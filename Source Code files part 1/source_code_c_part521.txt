          pAuthInfo->pAuthIdentityData = pAuthIdentityData;
            pcsiName->pAuthInfo = pAuthInfo;
        }
    }
    while(FALSE);

    return pcsiName;
}



void
CComAuthInfo::FreeServerInfoStruct(
    IN COSERVERINFO * pServerInfo
    ) const
/*++

Routine Description:

    As mentioned above -- free the server info structure

Arguments:

    COSERVERINFO * pServerInfo  : Server info structure

Return Value:

    None

--*/
{
    if (pServerInfo)
    {
        if (pServerInfo->pAuthInfo)
        {
            if (pServerInfo->pAuthInfo->pAuthIdentityData)
            {
                if (pServerInfo->pAuthInfo->pAuthIdentityData)
                {
                    SAFE_FREEMEM(pServerInfo->pAuthInfo->pAuthIdentityData->User);
                    SAFE_FREEMEM(pServerInfo->pAuthInfo->pAuthIdentityData->Domain);
                    SAFE_FREEMEM(pServerInfo->pAuthInfo->pAuthIdentityData->Password);
                    FreeMem(pServerInfo->pAuthInfo->pAuthIdentityData);
                }
            }

            FreeMem(pServerInfo->pAuthInfo);
        }

        FreeMem(pServerInfo);
    }
}



HRESULT
CComAuthInfo::ApplyProxyBlanket(
    IN OUT IUnknown * pInterface
    )
/*++

Routine Description:

    Set security information on the interface.  The user name is of the form
    domain\username.

Arguments:

    IUnknown * pInterface       : Interface

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    COSERVERINFO * pcsiName = CreateServerInfoStruct();

    //
    // This method should only be called if we're using impersonation.
    // so the pcsiName returned should never be NULL.
    //
//    ASSERT(pcsiName && pcsiName->pAuthInfo);

    if (pcsiName && pcsiName->pAuthInfo)
    {
        hr =  ::CoSetProxyBlanket(
            pInterface,
            pcsiName->pAuthInfo->dwAuthnSvc,
            pcsiName->pAuthInfo->dwAuthzSvc,
            pcsiName->pAuthInfo->pwszServerPrincName,
            pcsiName->pAuthInfo->dwAuthnLevel,
            pcsiName->pAuthInfo->dwImpersonationLevel,
            pcsiName->pAuthInfo->pAuthIdentityData,
            pcsiName->pAuthInfo->dwCapabilities
            );

        FreeServerInfoStruct(pcsiName);
    }

    return hr;
}


HRESULT
CComAuthInfo::ApplyProxyBlanket(
    IN OUT IUnknown * pInterface,
	IN DWORD dwAuthnLevel
    )
/*++

Routine Description:

    Set security information on the interface.  The user name is of the form
    domain\username.

Arguments:

    IUnknown * pInterface       : Interface

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    COSERVERINFO * pcsiName = CreateServerInfoStruct(dwAuthnLevel);

    //
    // This method should only be called if we're using impersonation.
    // so the pcsiName returned should never be NULL.
    //
//    ASSERT(pcsiName && pcsiName->pAuthInfo);

    if (pcsiName && pcsiName->pAuthInfo)
    {
        hr =  ::CoSetProxyBlanket(
            pInterface,
            pcsiName->pAuthInfo->dwAuthnSvc,
            pcsiName->pAuthInfo->dwAuthzSvc,
            pcsiName->pAuthInfo->pwszServerPrincName,
            pcsiName->pAuthInfo->dwAuthnLevel,
            pcsiName->pAuthInfo->dwImpersonationLevel,
            pcsiName->pAuthInfo->pAuthIdentityData,
            pcsiName->pAuthInfo->dwCapabilities
            );

        FreeServerInfoStruct(pcsiName);
    }

    return hr;
}


//
// CMetabasePath implemention
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



const LPCTSTR CMetabasePath::_cszMachine = SZ_MBN_MACHINE;
const LPCTSTR CMetabasePath::_cszRoot    = SZ_MBN_ROOT;
const LPCTSTR CMetabasePath::_cszSep     = SZ_MBN_SEP_STR;
const TCHAR   CMetabasePath::_chSep      = SZ_MBN_SEP_CHAR;



/* static */
LPCTSTR
CMetabasePath::ConvertToParentPath(
    OUT IN CString & strMetaPath
    )
/*++

Routine Description:

    Given the path, convert it to the parent path
    e.g. "foo/bar/etc" returns "foo/bar"

Arguments:

    CString & strMetaPath    : Path to be converted

Return value:

    Pointer to the converted path, or NULL in case of error

--*/
{
    LPTSTR lpszPath = strMetaPath.GetBuffer(1);
    LPTSTR lpszTail = lpszPath + lstrlen(lpszPath) - 1;
    LPTSTR lpszReturn = NULL;

    do
    {
        if (lpszTail <= lpszPath)
        {
            break;
        }

        //
        // Strip trailing backslash
        //
        if (*lpszTail == _chSep)
        {
            *lpszTail-- = _T('\0');
        }

        //
        // Search for parent
        //
        while (lpszTail > lpszPath && *lpszTail != _chSep)
        {
            --lpszTail;
        }

        if (lpszTail <= lpszPath)
        {
            break;
        }

        *lpszTail = _T('\0');

        lpszReturn = lpszPath;
    }
    while(FALSE);

    strMetaPath.ReleaseBuffer();

    return lpszReturn;
}



/* static */
LPCTSTR
CMetabasePath::TruncatePath(
    IN  int     nLevel,
    IN  LPCTSTR lpszMDPath,
    OUT CString & strNewPath,
    OUT CString * pstrRemainder     OPTIONAL
    )
/*++

Routine Description:

    Truncate the given metabase path at the given level, that is,
    the nLevel'th separator in the path, starting at 0, where 0 will
    always give lpszPath back whether it started with a separator or not.

    Examples:

        "/lm/w3svc/1/foo" at level 2 returns "/lm/w3svc" as does
        "lm/w3svc/1/foo".

Arguments:

    int     nLevel             0-based separator count to truncate at.
    LPTSTR lpszMDPath          Fully-qualified metabase path
    CString & strNewPath       Returns truncated path
    CString * pstrRemainder    Optionally returns the remainder past
                               the nLevel'th separator.

Return Value:

    The truncated path at the level requested.  See examples above. *pstrRemainder
    returns the remainder of the path.  If the path does not contain nLevel
    worth of separators, the entire path is returned, and the remainder will be
    blank.

--*/
{
    ASSERT_PTR(lpszMDPath);
    ASSERT(nLevel >= 0);

    if (!lpszMDPath || nLevel < 0)
    {
        return NULL;
    }

    //
    // Skip the first sep whether it exists or not
    //
    LPCTSTR lp = *lpszMDPath == _chSep ? lpszMDPath + 1 : lpszMDPath;
    LPCTSTR lpRem = NULL;
    int cSeparators = 0;

    if (nLevel)
    {
        //
        // Advance to the requested separator level
        //
        while (*lp)
        {
            if (*lp == _chSep)
            {
                if (++cSeparators == nLevel)
                {
                    break;
                }
            }

            ++lp;
        }

        if (!*lp)
        {
            //
            // End of path is considered a separator
            //
            ++cSeparators;
        }

        ASSERT(cSeparators <= nLevel);

        if (cSeparators == nLevel)
        {
            //
            // Break up the strings
            //
            strNewPath = lpszMDPath;
            strNewPath.ReleaseBuffer((int)(lp - lpszMDPath));
            if (*lp)
            {
                lpRem = ++lp;
            }
        }
    }

    //
    // Return remainder
    //
    if (pstrRemainder && lpRem)
    {
        ASSERT_WRITE_PTR(pstrRemainder);
        *pstrRemainder = lpRem;
    }

    return strNewPath;
}



/* static */
DWORD
CMetabasePath::GetInstanceNumber(
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Get the number of the instance referred to in the given metabase
    path.

    Examples:  "lm/w3svc/1/foo/bar" will return 1
               "lm/w3svc/"          will return 0 (master instance)
               "lm/bogus/path/"     will return 0xffffffff (error)

Arguments:

    LPCTSTR lpszMDPath      : A metabase path.

Return Value:

    Instance number (0 indicates master instance)
    or 0xffffffff if the path is in error.

--*/
{
    DWORD dwInstance = 0xffffffff;

    CString strService, strInst;

    if (GetServicePath(lpszMDPath, strService, &strInst))
    {
        if (strInst.IsEmpty())
        {
            dwInstance = MASTER_INSTANCE;
        }
        else
        {
            if (_istdigit(strInst.GetAt(0)))
            {
                dwInstance = _ttol(strInst);
            }
        }
    }

    return dwInstance;
}



/* static */
LPCTSTR
CMetabasePath::GetLastNodeName(
    IN  LPCTSTR lpszMDPath,
    OUT CString & strNodeName
    )
/*++

Routine Description:

    Get the last nodename off the metabase path

    Example:

        "/lm/foo/bar/"      returns "bar"

Arguments:

    LPCTSTR lpszMDPath      : Metabase path

Return Value:

    Pointer to the node name or NULL in case of a malformed path.

--*/
{
    ASSERT_PTR(lpszMDPath);

    if (!lpszMDPath || !*lpszMDPath)
    {
        return NULL;
    }

    LPCTSTR lp;
    LPCTSTR lpTail;
    lp = lpTail = lpszMDPath + lstrlen(lpszMDPath) - 1;

    //
    // Skip trailing separator
    //
    if (*lp == _chSep)
    {
        --lpTail;
        --lp;
    }

    strNodeName.Empty();

    while (*lp && *lp != _chSep)
    {
        strNodeName += *(lp--);
    }

    strNodeName.MakeReverse();

    return strNodeName;
}



/* static */
void
CMetabasePath::SplitMetaPathAtInstance(
    IN  LPCTSTR lpszMDPath,
    OUT CString & strParent,
    OUT CString & strAlias
    )
/*++

Routine Description:

    Split the given path into parent metabase root and alias, with the root
    being the instance path, and the alias everything following the
    instance.

Arguments:

    LPCTSTR lpszMDPath  : Input path
    CString & strParent : Outputs the parent path
    CString & strAlias  : Outputs the alias name

Return Value:

    None.

--*/
{
    ASSERT_PTR(lpszMDPath);

    strParent = lpszMDPath;
    strAlias.Empty();

    LPTSTR lp = strParent.GetBuffer(0);
    ASSERT_PTR(lp);

    if (!lp)
    {
        //
        // This is just about impossible
        //
        return;
    }

    int cSeparators = 0;
    int iChar = 0;

    //
    // Looking for "LM/sss/ddd/" <-- 3d slash:
    //
    while (*lp && cSeparators < 2)
    {
        if (*lp++ == _chSep)
        {
            ++cSeparators;
        }

        ++iChar;
    }

    if (!*lp)
    {
        //
        // Bogus format
        //
        ASSERT_MSG("Bogus Format");
        return;
    }

    if (_istdigit(*lp))
    {
        //
        // Not at the master instance, skip one more.
        //
        while (*lp)
        {
            ++iChar;

            if (*lp++ == _chSep)
            {
                break;
            }
        }

        if (!*lp)
        {
            //
            // Bogus format
            //
            ASSERT_MSG("Bogus Format");
            return;
        }
    }

    strAlias = strParent.Mid(iChar);
    strParent.ReleaseBuffer(--iChar);
}



/* static */
BOOL
CMetabasePath::IsHomeDirectoryPath(
    IN LPCTSTR lpszMetaPath
    )
/*++

Routine Description:

    Determine if the path given describes a root directory

Arguments:

    LPCTSTR lpszMetaPath        : Metabase path

Return Value:

    TRUE if the path describes a root directory,
    FALSE if it does not

--*/
{
    ASSERT_READ_PTR(lpszMetaPath);

    LPTSTR lpNode = lpszMetaPath ? _tcsrchr(lpszMetaPath, _chSep) : NULL;

    if (lpNode)
    {
        return _tcsicmp(++lpNode, _cszRoot) == 0;
    }

    return FALSE;
}



/* static */
BOOL
CMetabasePath::IsMasterInstance(
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Determine if the given metabase path points to the master instance
    (site).  This is essentially the service path.

Arguments:

    LPCTSTR lpszMDPath  : Metabase path.

Return Value:

    TRUE if the path is the master instance,
    FALSE otherwise.

--*/
{
    ASSERT_READ_PTR(lpszMDPath);

    if (!lpszMDPath || !*lpszMDPath)
    {
        return FALSE;
    }

    CString strService;
    CString strRemainder;

    LPCTSTR lpPath = TruncatePath(2, lpszMDPath, strService, &strRemainder);

    return lpPath && !strService.IsEmpty() && strRemainder.IsEmpty();
}



/* static */
LPCTSTR
CMetabasePath::GetServiceInfoPath(
    IN  LPCTSTR lpszMDPath,
    OUT CString & strInfoPath,
    IN  LPCTSTR lpszDefService      OPTIONAL
    )
/*++

Routine Description:

    Generate the appropriate metabase service info path for the given
    metabase path.

    For example:

        "lm/w3svc/1/foo/bar"    Generates "lm/w3svc/info"

Arguments:

    LPCTSTR lpszMDPath      : Input metabase path
    CString & strInfoPath   : Returns the info path
    LPCTSTR lpszDefService  : Optionally specifies the default service to
                              use (e.g "w3svc") if no service could be found
                              in the path.

Return Value:

    The info metabase path or NULL if one could not be generated.

--*/
{
    //
    // Capability info stored off the service path ("lm/w3svc").
    //
    CString strService;
    CString strRem;

    //
    // Strip off everything past the service
    //
    if (!TruncatePath(2, lpszMDPath, strService, &strRem)
      || strService.IsEmpty())
    {
        if (!lpszDefService)
        {
            TRACEEOLID("Unable to generate info path");
            return NULL;
        }

        //
        // Machine path (no service).  Use web as default service to
        // look for capability and version info.
        //
        strService = CMetabasePath(TRUE, lpszDefService);
    }

    strInfoPath = CMetabasePath(FALSE, strService, SZ_MBN_INFO);

    return strInfoPath;
}



/* static */
LPCTSTR
CMetabasePath::CleanMetaPath(
    IN OUT CString & strMetaRoot
    )
/*++

Routine Description:

    Clean up the metabase path to one valid for internal consumption.
    This removes the beginning and trailing slashes off the path.

Arguments:

    CString & strMetaRoot       : Metabase path to be cleaned up.

Return Value:

    Pointer to the metabase path

--*/
{
    if (!strMetaRoot.IsEmpty())
    {
        if (strMetaRoot[strMetaRoot.GetLength() - 1] == _chSep)
        {
            strMetaRoot.ReleaseBuffer(strMetaRoot.GetLength() - 1);
        }

        if (!strMetaRoot.IsEmpty() && strMetaRoot[0] == _chSep)
        {
            strMetaRoot = strMetaRoot.Right(strMetaRoot.GetLength() - 1);
        }
    }

    return strMetaRoot;
}



CMetabasePath::CMetabasePath(
    IN BOOL    fAddBasePath,
    IN LPCTSTR lpszMDPath,
    IN LPCTSTR lpszMDPath2  OPTIONAL,
    IN LPCTSTR lpszMDPath3  OPTIONAL,
    IN LPCTSTR lpszMDPath4  OPTIONAL
    )
/*++

Routine Description:

    Constructor.

Arguments:

    BOOL    fAddBasePath    : TRUE to prepend base path ("LM")
                              FALSE if the path is complete
    LPCTSTR lpszMDPath      : Metabase path
    LPCTSTR lpszMDPath2     : Optional child path
    LPCTSTR lpszMDPath3     : Optional child path
    LPCTSTR lpszMDPath4     : Optional child path

Return Value:

    N/A

--*/
    : m_strMetaPath()
{
    ASSERT_READ_PTR(lpszMDPath);

    if (fAddBasePath)
    {
        m_strMetaPath = _cszMachine;
        AppendPath(lpszMDPath);
    }
    else
    {
        m_strMetaPath = lpszMDPath;
    }

    //
    // Add optional path components
    //
    AppendPath(lpszMDPath2);
    AppendPath(lpszMDPath3);
    AppendPath(lpszMDPath4);
}



CMetabasePath::CMetabasePath(
    IN  LPCTSTR lpszSvc,        OPTIONAL
    IN  DWORD   dwInstance,     OPTIONAL
    IN  LPCTSTR lpszParentPath, OPTIONAL
    IN  LPCTSTR lpszAlias       OPTIONAL
    )
/*++

Routine Description:

    Constructor.  Construct with path components.

Arguments:

    LPCTSTR lpszSvc         : Service (may be NULL or "")
    DWORD   dwInstance      : Instance number (may be 0 for master)
    LPCTSTR lpszParentPath  : Parent path (may be NULL or "")
    LPCTSTR lpszAlias       : Alias (may be NULL or "")

Return Value:

    N/A

--*/
    : m_strMetaPath()
{
    BuildMetaPath(lpszSvc, dwInstance, lpszParentPath, lpszAlias);
}



void
CMetabasePath::AppendPath(
    IN LPCTSTR lpszPath
    )
/*++

Routine Description:

    Append path to current metabase path

Arguments:

    LPCTSTR lpszPath        : Metabase path

Return Value:

    None

--*/
{
    if (lpszPath && *lpszPath)
    {
        m_strMetaPath += _cszSep;
        m_strMetaPath += lpszPath;
    }
}



void
CMetabasePath::AppendPath(
    IN DWORD dwInstance
    )
/*++

Routine Description:

    Append path to current metabase path

Arguments:

    DWORD dwInstance        : Instance path

Return Value:

    None

--*/
{
    if (!IS_MASTER_INSTANCE(dwInstance))
    {
        TCHAR szInstance[] = _T("4000000000");
        _ltot(dwInstance, szInstance, 10);

        m_strMetaPath += _cszSep;
        m_strMetaPath += szInstance;
    }
}



void
CMetabasePath::BuildMetaPath(
    IN  LPCTSTR lpszSvc            OPTIONAL,
    IN  LPCTSTR lpszInstance       OPTIONAL,
    IN  LPCTSTR lpszParentPath     OPTIONAL,
    IN  LPCTSTR lpszAlias          OPTIONAL
    )
/*++

Routine Description:

    Build a complete metapath with the given service name, instance
    number and optional path components.

Arguments:

    LPCTSTR lpszSvc         : Service (may be NULL or "")
    LPCTSTR lpszInstance    : Instance (may be NULL or "")
    LPCTSTR lpszParentPath  : Parent path (may be NULL or "")
    LPCTSTR lpszAlias       : Alias (may be NULL or "")

Return Value:

    Pointer to internal buffer containing the path.

--*/
{
    m_strMetaPath = _cszMachine;

    AppendPath(lpszSvc);
    AppendPath(lpszInstance);
    AppendPath(lpszParentPath);

    if (lpszAlias && *lpszAlias)
    {
        //
        // Special case: If the alias is root, but we're
        // at the master instance, ignore this.
        //
        if (lpszInstance || ::lstrcmpi(_cszRoot, lpszAlias))
        {
            m_strMetaPath += _cszSep;
            m_strMetaPath += lpszAlias;
        }
    }
}




void
CMetabasePath::BuildMetaPath(
    IN  LPCTSTR lpszSvc            OPTIONAL,
    IN  DWORD   dwInstance         OPTIONAL,
    IN  LPCTSTR lpszParentPath     OPTIONAL,
    IN  LPCTSTR lpszAlias          OPTIONAL
    )
/*++

Routine Description:

    Build a complete metapath with the given service name, instance
    number and optional path components.

Arguments:

    LPCTSTR lpszSvc         : Service (may be NULL or "")
    DWORD   dwInstance      : Instance number (may be 0 for master)
    LPCTSTR lpszParentPath  : Parent path (may be NULL or "")
    LPCTSTR lpszAlias       : Alias (may be NULL or "")

Return Value:

    Pointer to internal buffer containing the path.

--*/
{
    m_strMetaPath = _cszMachine;

    AppendPath(lpszSvc);
    AppendPath(dwInstance);
    AppendPath(lpszParentPath);

    if (lpszAlias && *lpszAlias)
    {
        //
        // Special case: If the alias is root, but we're
        // at the master instance, ignore this.
        //
        if (!IS_MASTER_INSTANCE(dwInstance) || ::lstrcmpi(_cszRoot, lpszAlias))
        {
            m_strMetaPath += _cszSep;
            m_strMetaPath += lpszAlias;
        }
    }
}




//
// CIISInterface class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CIISInterface::CIISInterface(
    IN CComAuthInfo * pAuthInfo,    OPTIONAL
    IN HRESULT hrInterface          OPTIONAL
    )
/*++

Routine Description:

    Base class constructor.

Arguments:

    CComAuthInfo * pAuthInfo : Auth info or NULL for local computer
    HRESULT hrInterface      : Initial error code. S_OK by default.

Return Value:

    N/A

--*/
    : m_auth(pAuthInfo),
      m_hrInterface(hrInterface)
{
}



HRESULT
CIISInterface::Create(
    IN  int   cInterfaces,
    IN  const IID rgIID[],
    IN  const GUID rgCLSID[],
    OUT int * pnInterface,          OPTIONAL
    OUT IUnknown ** ppInterface
    )
/*++

Routine Description:

    Create interface.  This will try a range of interfaces in order of priority.

Arguments:

    int   cInterfaces       : Number of interfaces in array.
    const IID * rgIID       : Array if IIDs
    const GUID * rgCLSID    : Array of CLSIDs
    int * pnInterface       : Returns the interface index that was successful.
                              or NULL if not interested.
    IUnknown ** ppInterface : Returns pointer to the interface.

Return Value:

    HRESULT

Notes:

    This will attempt to create an interface, in order of declaration in
    the IID and CLSIS arrays.  The first successful interface to be created
    will have its index returned in *pnInterfaces.

--*/
{
    ASSERT(cInterfaces > 0);
    ASSERT(rgIID && rgCLSID && ppInterface);

    COSERVERINFO * pcsiName = m_auth.CreateServerInfoStruct();

    MULTI_QI rgmqResults;
    CError err;
    int nInterface;

    ZeroMemory(&rgmqResults, sizeof(rgmqResults));
    //
    // Try to create the interface in order
    //
    for (nInterface = 0; nInterface < cInterfaces; ++nInterface)
    {
        rgmqResults.pIID = &rgIID[nInterface];
        err = ::CoCreateInstanceEx(
            rgCLSID[nInterface],
            NULL,
            CLSCTX_SERVER,
            pcsiName,
            1,
            &rgmqResults
            );

        if (err.Succeeded() || err.Win32Error() == ERROR_ACCESS_DENIED)
        {
            break;
        }
        ZeroMemory(&rgmqResults, sizeof(rgmqResults));
    }

    if(err.Succeeded())
    {
        //
        // Save the interface pointer
        //
        ASSERT_PTR(rgmqResults.pItf);
        *ppInterface = rgmqResults.pItf;

        if (pnInterface)
        {
            //
            // Store successful interface index
            //
            *pnInterface = nInterface;
        }

        //
        // Strangely enough, I now have still have to apply
        // the proxy blanket.  Apparently this is by design.
        //
        if (m_auth.UsesImpersonation())
        {
            ApplyProxyBlanket();
        }
    }

    //
    // Clean up
    //
    m_auth.FreeServerInfoStruct(pcsiName);

    return err;
}



//
// CMetaInterface class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CMetaInterface::CMetaInterface(
    IN CComAuthInfo * pAuthInfo        OPTIONAL
    )
/*++

Routine Description:

    Construct and initialize the interface

Arguments:

    CComAuthInfo * pAuthInfo    : Authentication info.  NULL indicates
                                  the local computer.

Return Value:

    N/A

--*/
    : CIISInterface(pAuthInfo),
      m_pInterface(NULL),
      m_iTimeOutValue(MB_TIMEOUT)
{
    //
    // Initialize the interface
    //
    m_hrInterface = Create();
}



CMetaInterface::CMetaInterface(
    IN CMetaInterface * pInterface
    )
/*++

Routine Description:

    Construct from existing interface (Copy Constructor)

Arguments:

    CMetaInterface * pInterface : Existing interface

Return Value:

    N/A

Notes:

    Object will not take ownership of the interface,
    it will merely add to the reference count, and
    release it upon destruction

BUGBUG:

    if pInterface is NULL, this will AV.

--*/
    : CIISInterface(&pInterface->m_auth, pInterface->m_hrInterface),
      m_pInterface(pInterface->m_pInterface),
      m_iTimeOutValue(pInterface->m_iTimeOutValue)
{
    ASSERT_READ_PTR(m_pInterface);
    m_pInterface->AddRef();
}



CMetaInterface::~CMetaInterface()
/*++

Routine Description:
    Destructor -- releases the interface

--*/
{
    SAFE_RELEASE(m_pInterface);
}


HRESULT
CMetaInterface::CreateSite(
	LPCTSTR service,
	LPCTSTR comment,
	LPCTSTR binding,
	LPCTSTR home_path,
	DWORD * pinst,
    DWORD * pRequestedSiteInst
    )
{
    CError err;
    BOOL bHonorRequestedSiteId = FALSE;
    CSiteCreator sc(m_pInterface);
    if (pRequestedSiteInst)
    {
        if (*pRequestedSiteInst != 0)
        {
            bHonorRequestedSiteId = TRUE;
        }
    }
    if (bHonorRequestedSiteId)
    {
        err = sc.CreateNewSite2(
            _tcsicmp(service, SZ_MBN_WEB) == 0 ? SC_W3SVC : SC_MSFTPSVC,
            comment, binding, home_path, NULL, pinst, pRequestedSiteInst);
    }
    else
    {
        err = sc.CreateNewSite2(
            _tcsicmp(service, SZ_MBN_WEB) == 0 ? SC_W3SVC : SC_MSFTPSVC,
            comment, binding, home_path, NULL, pinst);
    }
	return err;
}

//
// CMetaKey class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//
// Helper macros
//
#define ASSURE_OPEN_KEY()\
    if (!m_hKey && !m_fAllowRootOperations) { ASSERT_MSG("No open key"); return HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE); }

#define FETCH_PROPERTY_DATA_OR_FAIL(dwID, md)\
    ZeroMemory(&md, sizeof(md)); \
    if (!GetMDFieldDef(dwID, md.dwMDIdentifier, md.dwMDAttributes, md.dwMDUserType, md.dwMDDataType))\
    { ASSERT_MSG("Bad property ID"); return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER); }

//
// Static Initialization
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



#define MD_SERVER_PLATFORM              (IIS_MD_SERVER_BASE+100 )
#define MD_SERVER_VERSION_MAJOR         (IIS_MD_SERVER_BASE+101 )
#define MD_SERVER_VERSION_MINOR         (IIS_MD_SERVER_BASE+102 )
#define MD_SERVER_CAPABILITIES          (IIS_MD_SERVER_BASE+103 )

#if 0
//
// Metabase table
//
const CMetaKey::MDFIELDDEF CMetaKey::s_rgMetaTable[] =
{
    ///////////////////////////////////////////////////////////////////////////
    //
    // !!!IMPORTANT!!! This table must be sorted on dwMDIdentifier.  (Will
    // ASSERT if not not sorted)
    //
    { MD_MAX_BANDWIDTH,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_KEY_TYPE,                        METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_SERVER_COMMAND,                  METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_CONNECTION_TIMEOUT,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CONNECTION_TIMEOUT          },
    { MD_MAX_CONNECTIONS,                 METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_MAX_CONNECTIONS             },
    { MD_SERVER_COMMENT,                  METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  IDS_MD_SERVER_COMMENT              },
    { MD_SERVER_STATE,                    METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_SERVER_AUTOSTART,                METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_SERVER_SIZE,                     METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_SERVER_SIZE                 },
    { MD_SERVER_LISTEN_BACKLOG,           METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_SERVER_LISTEN_BACKLOG       },
    { MD_SERVER_LISTEN_TIMEOUT,           METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_SERVER_LISTEN_TIMEOUT       },
    { MD_DOWNLEVEL_ADMIN_INSTANCE,        METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_DOWNLEVEL_ADMIN_INSTANCE    },
    { MD_SERVER_BINDINGS,                 METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, MULTISZ_METADATA, 0                                  },
    { MD_WIN32_ERROR,                     METADATA_VOLATILE,                         IIS_MD_UT_FILE,   DWORD_METADATA,   0                                  },
    { MD_SERVER_PLATFORM,                 METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_SERVER_VERSION_MAJOR,            METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_SERVER_VERSION_MINOR,            METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_SERVER_CAPABILITIES,             METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_SECURE_BINDINGS,                 METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, MULTISZ_METADATA, 0                                  },
    { MD_FILTER_LOAD_ORDER,               METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_FILTER_IMAGE_PATH,               METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_FILTER_STATE,                    METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_FILTER_ENABLED,                  METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_FILTER_FLAGS,                    METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_AUTH_CHANGE_URL,                 METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_AUTH_EXPIRED_URL,                METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_AUTH_NOTIFY_PWD_EXP_URL,         METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_ADV_NOTIFY_PWD_EXP_IN_DAYS,      METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_ADV_CACHE_TTL,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_AUTH_EXPIRED_UNSECUREURL,        METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_AUTH_CHANGE_FLAGS,               METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_AUTH_NOTIFY_PWD_EXP_UNSECUREURL, METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_FRONTPAGE_WEB,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_IN_PROCESS_ISAPI_APPS,           METADATA_INHERIT,                          IIS_MD_UT_FILE,   MULTISZ_METADATA, IDS_MD_IN_PROCESS_ISAPI_APPS       },
    { MD_MAPCERT,                         METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_MAPNTACCT,                       METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_MAPNAME,                         METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_MAPENABLED,                      METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_MAPREALM,                        METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_MAPPWD,                          METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_ITACCT,                          METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_CPP_CERT11,                      METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SERIAL_CERT11,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_CPP_CERTW,                       METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SERIAL_CERTW,                    METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_CPP_DIGEST,                      METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SERIAL_DIGEST,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_CPP_ITA,                         METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SERIAL_ITA,                      METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_FRONTPAGE_WEB,                   METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_APP_FRIENDLY_NAME,               METADATA_INHERIT,                          IIS_MD_UT_WAM,    STRING_METADATA,  IDS_MD_APP_FRIENDLY_NAME           },
    { MD_APP_ROOT,                        METADATA_INHERIT,                          IIS_MD_UT_WAM,    STRING_METADATA,  IDS_MD_APP_ROOT                    },
    { MD_APP_ISOLATED,                    METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   IDS_MD_APP_ISOLATED                },
    { MD_CPU_RESET_INTERVAL,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CPU_RESET_INTERVAL          },
    { MD_HC_COMPRESSION_DIRECTORY,        METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_HC_DO_DYNAMIC_COMPRESSION,       METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_HC_DO_STATIC_COMPRESSION,        METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_HC_DO_DISK_SPACE_LIMITING,       METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_HC_MAX_DISK_SPACE_USAGE,         METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_VR_PATH,                         METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_VR_PATH                     },
    { MD_VR_USERNAME,                     METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_VR_USERNAME                 },
    { MD_VR_PASSWORD,                     METADATA_INHERIT | METADATA_SECURE,        IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_VR_PASSWORD                 },
    { MD_VR_ACL,                          METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_FILE,   BINARY_METADATA,  0                                  },
    { MD_VR_UPDATE,                       METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_FILE,   DWORD_METADATA,   0                                  },
    { MD_LOG_TYPE,                        METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_LOG_TYPE                    },
    { MD_LOGFILE_DIRECTORY,               METADATA_INHERIT,                          IIS_MD_UT_FILE,   EXPANDSZ_METADATA,IDS_MD_LOGFILE_DIRECTORY           },
    { MD_LOGFILE_PERIOD,                  METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_LOGFILE_PERIOD              },
    { MD_LOGFILE_TRUNCATE_SIZE,           METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_LOGFILE_TRUNCATE_SIZE       },
    { MD_LOG_PLUGIN_MOD_ID,               METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  IDS_MD_LOG_PLUGIN_MOD_ID           },
    { MD_LOG_PLUGIN_UI_ID,                METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  IDS_MD_LOG_PLUGIN_UI_ID            },
    { MD_LOGSQL_DATA_SOURCES,             METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_LOGSQL_DATA_SOURCES         },
    { MD_LOGSQL_TABLE_NAME,               METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_LOGSQL_TABLE_NAME           },
    { MD_LOGSQL_USER_NAME,                METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_LOGSQL_USER_NAME            },
    { MD_LOGSQL_PASSWORD,                 METADATA_INHERIT | METADATA_SECURE,        IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_LOGSQL_PASSWORD             },
    { MD_LOG_PLUGIN_ORDER,                METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  IDS_MD_LOG_PLUGIN_ORDER            },
    { MD_LOG_PLUGINS_AVAILABLE,           METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  IDS_MD_LOG_PLUGINS_AVAILABLE       },
    { MD_LOGEXT_FIELD_MASK,               METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_LOGEXT_FIELD_MASK           },
    { MD_LOGFILE_LOCALTIME_ROLLOVER,      METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_LOGFILE_LOCALTIME_ROLLOVER  },
    { MD_LOGCUSTOM_PROPERTY_ID,       	  METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA, 	 IDS_MD_LOGCUSTOM_PROPERTY_ID       },
    { MD_LOGCUSTOM_PROPERTY_MASK,         METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_LOGCUSTOM_PROPERTY_MASK     },
    { MD_LOGCUSTOM_SERVICES_STRING,       METADATA_INHERIT,                          IIS_MD_UT_SERVER, MULTISZ_METADATA, IDS_MD_LOGCUSTOM_SERVICES_STRING   },
    { MD_LOGCUSTOM_PROPERTY_NODE_ID,      METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA, 	 IDS_MD_LOGCUSTOM_PROPERTY_NODE_ID  },
    { MD_EXIT_MESSAGE,                    METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  IDS_MD_EXIT_MESSAGE                },
    { MD_GREETING_MESSAGE,                METADATA_INHERIT,                          IIS_MD_UT_SERVER, MULTISZ_METADATA, IDS_MD_GREETING_MESSAGE            },
    { MD_MAX_CLIENTS_MESSAGE,             METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  IDS_MD_MAX_CLIENTS_MESSAGE         },
    { MD_MSDOS_DIR_OUTPUT,                METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_MSDOS_DIR_OUTPUT            },
    { MD_ALLOW_ANONYMOUS,                 METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_ALLOW_ANONYMOUS             },
    { MD_ANONYMOUS_ONLY,                  METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_ANONYMOUS_ONLY              },
    { MD_LOG_ANONYMOUS,                   METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_LOG_ANONYMOUS               },
    { MD_LOG_NONANONYMOUS,                METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_LOG_NONANONYMOUS            },
    { MD_BANNER_MESSAGE,				  METADATA_INHERIT,                          IIS_MD_UT_SERVER, MULTISZ_METADATA, IDS_MD_BANNER_MESSAGE              },
    { MD_SSL_PUBLIC_KEY,                  METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SSL_PRIVATE_KEY,                 METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SSL_KEY_PASSWORD,                METADATA_SECURE,                           IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SSL_CERT_HASH,                   METADATA_INHERIT,                          IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SSL_CERT_STORE_NAME,             METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_SSL_CTL_IDENTIFIER,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_SSL_CTL_STORE_NAME,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_SSL_USE_DS_MAPPER,               METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_AUTHORIZATION,                   METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_AUTHORIZATION               },
    { MD_REALM,                           METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_REALM                       },
    { MD_HTTP_EXPIRES,                    METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_HTTP_EXPIRES                },
    { MD_HTTP_PICS,                       METADATA_INHERIT,                          IIS_MD_UT_FILE,   MULTISZ_METADATA, IDS_MD_HTTP_PICS                   },
    { MD_HTTP_CUSTOM,                     METADATA_INHERIT,                          IIS_MD_UT_FILE,   MULTISZ_METADATA, IDS_MD_HTTP_CUSTOM                 },
    { MD_DIRECTORY_BROWSING,              METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_DIRECTORY_BROWSING          },
    { MD_DEFAULT_LOAD_FILE,               METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_DEFAULT_LOAD_FILE           },
    { MD_CONTENT_NEGOTIATION,             METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_CONTENT_NEGOTIATION         },
    { MD_CUSTOM_ERROR,                    METADATA_INHERIT,                          IIS_MD_UT_FILE,   MULTISZ_METADATA, IDS_MD_CUSTOM_ERROR                },
    { MD_FOOTER_DOCUMENT,                 METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_FOOTER_DOCUMENT             },
    { MD_FOOTER_ENABLED,                  METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_FOOTER_ENABLED              },
    { MD_HTTP_REDIRECT,                   METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_HTTP_REDIRECT               },
    { MD_DEFAULT_LOGON_DOMAIN,            METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_DEFAULT_LOGON_DOMAIN        },
    { MD_LOGON_METHOD,                    METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_LOGON_METHOD                },
    { MD_SCRIPT_MAPS,                     METADATA_INHERIT,                          IIS_MD_UT_FILE,   MULTISZ_METADATA, IDS_MD_SCRIPT_MAPS                 },
    { MD_MIME_MAP,                        METADATA_INHERIT,                          IIS_MD_UT_FILE,   MULTISZ_METADATA, IDS_MD_MIME_MAP                    },
    { MD_ACCESS_PERM,                     METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_ACCESS_PERM                 },
    { MD_IP_SEC,                          METADATA_INHERIT | METADATA_REFERENCE,     IIS_MD_UT_FILE,   BINARY_METADATA,  IDS_MD_IP_SEC                      },
    { MD_ANONYMOUS_USER_NAME,             METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_ANONYMOUS_USER_NAME         },
    { MD_ANONYMOUS_PWD,                   METADATA_INHERIT | METADATA_SECURE,        IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_ANONYMOUS_PWD               },
    { MD_ANONYMOUS_USE_SUBAUTH,           METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_ANONYMOUS_USE_SUBAUTH       },
    { MD_DONT_LOG,                        METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_DONT_LOG                    },
    { MD_ADMIN_ACL,                       METADATA_INHERIT | METADATA_SECURE | METADATA_REFERENCE,IIS_MD_UT_SERVER, BINARY_METADATA,  IDS_MD_ADMIN_ACL      },
    { MD_SSI_EXEC_DISABLED,               METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_SSI_EXEC_DISABLED           },
    { MD_SSL_ACCESS_PERM,                 METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_SSL_ACCESS_PERM             },
    { MD_NTAUTHENTICATION_PROVIDERS,      METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_NTAUTHENTICATION_PROVIDERS  },
    { MD_SCRIPT_TIMEOUT,                  METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_SCRIPT_TIMEOUT              },
    { MD_CACHE_EXTENSIONS,                METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_CACHE_EXTENSIONS            },
    { MD_CREATE_PROCESS_AS_USER,          METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CREATE_PROCESS_AS_USER      },
    { MD_CREATE_PROC_NEW_CONSOLE,         METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CREATE_PROC_NEW_CONSOLE     },
    { MD_POOL_IDC_TIMEOUT,                METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_POOL_IDC_TIMEOUT            },
    { MD_ALLOW_KEEPALIVES,                METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_ALLOW_KEEPALIVES            },
    { MD_IS_CONTENT_INDEXED,              METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_IS_CONTENT_INDEXED          },
    { MD_ISM_ACCESS_CHECK,                METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_FILE,   DWORD_METADATA,   0                                  },
    { MD_ASP_BUFFERINGON,                 METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_BUFFERINGON                },
    { MD_ASP_LOGERRORREQUESTS,            METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   IDS_ASP_LOGERRORREQUESTS           },
    { MD_ASP_SCRIPTERRORSSENTTOBROWSER,   METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_SCRIPTERRORSSENTTOBROWSER  },
    { MD_ASP_SCRIPTERRORMESSAGE,          METADATA_INHERIT,                          ASP_MD_UT_APP,    STRING_METADATA,  IDS_ASP_SCRIPTERRORMESSAGE         },
    { MD_ASP_SCRIPTFILECACHESIZE,         METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   IDS_ASP_SCRIPTFILECACHESIZE        },
    { MD_ASP_SCRIPTENGINECACHEMAX,        METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   IDS_ASP_SCRIPTENGINECACHEMAX       },
    { MD_ASP_SCRIPTTIMEOUT,               METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_SCRIPTTIMEOUT              },
    { MD_ASP_SESSIONTIMEOUT,              METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_SESSIONTIMEOUT             },
    { MD_ASP_ENABLEPARENTPATHS,           METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_ENABLEPARENTPATHS          },
    { MD_ASP_ALLOWSESSIONSTATE,           METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_ALLOWSESSIONSTATE          },
    { MD_ASP_SCRIPTLANGUAGE,              METADATA_INHERIT,                          ASP_MD_UT_APP,    STRING_METADATA,  IDS_ASP_SCRIPTLANGUAGE             },
    { MD_ASP_EXCEPTIONCATCHENABLE,        METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   IDS_ASP_EXCEPTIONCATCHENABLE       },
    { MD_ASP_ENABLESERVERDEBUG,           METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_ENABLESERVERDEBUG          },
    { MD_ASP_ENABLECLIENTDEBUG,           METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_ENABLECLIENTDEBUG          },

    { MD_WAM_USER_NAME,                   METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  IDS_MD_WAM_USER_NAME               },
    { MD_WAM_PWD,                         METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  IDS_MD_WAM_PWD                     },
    //
    // IIS6 Application Pools
    //
    { MD_APPPOOL_PERIODIC_RESTART_TIME,   METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_APPPOOL_PERIODIC_RESTART_TIME },
    { MD_APPPOOL_PERIODIC_RESTART_REQUEST_COUNT,
                                          METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_APPPOOL_PERIODIC_RESTART_REQUEST_COUNT },
    { MD_APPPOOL_MAX_PROCESS_COUNT,       METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_APPPOOL_MAX_PROCESS_COUNT   },
    { MD_APPPOOL_PINGING_ENABLED,         METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_APPPOOL_PINGING_ENABLED     },
    { MD_APPPOOL_IDLE_TIMEOUT,            METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_APPPOOL_IDLE_TIMEOUT        },
    { MD_APPPOOL_RAPID_FAIL_PROTECTION_ENABLED,
                                          METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_APPPOOL_RAPID_FAIL_PROTECTION_ENABLED  },
    { MD_APPPOOL_ORPHAN_PROCESSES_FOR_DEBUGGING,
                                          METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_APPPOOL_ORPHAN_PROCESSES_FOR_DEBUGGING },
    { MD_APPPOOL_STARTUP_TIMELIMIT,       METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_APPPOOL_STARTUP_TIMELIMIT   },
    { MD_APPPOOL_SHUTDOWN_TIMELIMIT,      METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_APPPOOL_SHUTDOWN_TIMELIMIT  },
    { MD_APPPOOL_PING_INTERVAL,           METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_APPPOOL_PING_INTERVAL       },
    { MD_APPPOOL_UL_APPPOOL_QUEUE_LENGTH,
                                          METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_APPPOOL_UL_APPPOOL_QUEUE_LENGTH },
    { MD_APPPOOL_PERIODIC_RESTART_SCHEDULE,
                                          METADATA_INHERIT,                          IIS_MD_UT_SERVER, MULTISZ_METADATA, IDS_MD_APPPOOL_PERIODIC_RESTART_SCHEDULE },
    { MD_APPPOOL_IDENTITY_TYPE,           METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_APPPOOL_IDENTITY_TYPE       },
    { MD_CPU_ACTION,                      METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CPU_ACTION                  },
    { MD_CPU_LIMIT,                       METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CPU_LIMIT                   },
    { MD_APPPOOL_PERIODIC_RESTART_MEMORY, METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_APPPOOL_PERIODIC_RESTART_MEMORY },
    { MD_APPPOOL_COMMAND,				  METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_APPPOOL_COMMAND },
    { MD_APPPOOL_STATE,					  METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_APPPOOL_STATE },
    { MD_RAPID_FAIL_PROTECTION_INTERVAL,  METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_RAPID_FAIL_PROTECTION_INTERVAL},
    { MD_RAPID_FAIL_PROTECTION_MAX_CRASHES,
										  METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_RAPID_FAIL_PROTECTION_MAX_CRASHES},
    { MD_APPPOOL_ORPHAN_ACTION_EXE,       METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  IDS_MD_APPPOOL_ORPHAN_ACTION_EXE   },
    { MD_APPPOOL_ORPHAN_ACTION_PARAMS,    METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  IDS_MD_APPPOOL_ORPHAN_ACTION_PARAMS},
    { MD_APP_APPPOOL_ID,                  METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  IDS_MD_APP_APPPOOL_ID              },
    // Global parameters
    { MD_MAX_GLOBAL_BANDWIDTH,			  METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_MAX_GLOBAL_BANDWIDTH        },
    { MD_GLOBAL_STANDARD_APP_MODE_ENABLED,METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_GLOBAL_STANDARD_APP_MODE_ENABLED },
    { MD_GLOBAL_LOG_IN_UTF_8,             METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_GLOBAL_LOG_IN_UTF_8         },
    { MD_ROOT_ENABLE_EDIT_WHILE_RUNNING,  METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
};
#endif

/* static */
int
CMetaKey::MapMDIDToTableIndex(
    IN DWORD dwID
    )
/*++

Routine Description:
    Map MD id value to table index.  Return -1 if not found

Arguments:
    DWORD dwID : MD id value

Return Value:
    Index into the table that coresponds to the MD id value

--*/
{
#if defined(_DEBUG) //|| DBG
    {
        //
        // Do a quick verification that our metadata
        // table is sorted correctly.
        //
        static BOOL fTableChecked = FALSE;

        if (!fTableChecked)
        {
            for (int n = 1; n < s_MetaTableSize; ++n)
            {
                if (s_rgMetaTable[n].dwMDIdentifier
                    <= s_rgMetaTable[n - 1].dwMDIdentifier)
                {
                    TRACEEOLID("MD ID Table is out of order: Item is "
                        << n
                        << " "
                        << s_rgMetaTable[n].dwMDIdentifier
                        );
                    ASSERT_MSG("MD ID Table out of order");
                }
            }

            //
            // But only once.
            //
            ++fTableChecked;
        }
    }

#endif // _DEBUG

    //
    // Look up the ID in the table using a binary search
    //
    int nRange = s_MetaTableSize;
    int nLow = 0;
    int nHigh = nRange - 1;
    int nMid;
    int nHalf;

    while (nLow <= nHigh)
    {
        if (0 != (nHalf = nRange / 2))
        {
            nMid  = nLow + (nRange & 1 ? nHalf : (nHalf - 1));

            if (s_rgMetaTable[nMid].dwMDIdentifier == dwID)
            {
                return nMid;
            }
            else if (s_rgMetaTable[nMid].dwMDIdentifier > dwID)
            {
                nHigh  = --nMid;
                nRange = nRange & 1 ? nHalf : nHalf - 1;
            }
            else
            {
                nLow   = ++nMid;
                nRange = nHalf;
            }
        }
        else if (nRange)
        {
            return s_rgMetaTable[nLow].dwMDIdentifier == dwID ? nLow : -1;
        }
        else
        {
            break;
        }
    }

    return -1;
}


static CMap<DWORD, DWORD, CMetaKey::MDFIELDDEF *, CMetaKey::MDFIELDDEF *&> g_metaid_map;

const CMetaKey::MDFIELDDEF *
CMetaKey::GetMetaProp(DWORD id)
{
    MDFIELDDEF * p = NULL;
    if (g_metaid_map.GetCount() == 0)
    {
        for (int i = 0; i < s_MetaTableSize; i++)
        {
            DWORD id2 = CMetaKey::s_rgMetaTable[i].dwMDIdentifier;
            MDFIELDDEF * pt = (MDFIELDDEF *)&CMetaKey::s_rgMetaTable[i];
            g_metaid_map.SetAt(id2, pt);
        }
        ASSERT(g_metaid_map.GetCount() > 0);
    }
    VERIFY(g_metaid_map.Lookup(id, p));
    return (const CMetaKey::MDFIELDDEF *)p;
}

/* static */
BOOL
CMetaKey::GetMDFieldDef(
    IN  DWORD dwID,
    OUT DWORD & dwMDIdentifier,
    OUT DWORD & dwMDAttributes,
    OUT DWORD & dwMDUserType,
    OUT DWORD & dwMDDataType
    )
/*++

Routine Description:
    Get information about metabase property

Arguments:
    DWORD dwID                  : Meta ID
    DWORD & dwMDIdentifier      : Meta parms
    DWORD & dwMDAttributes      : Meta parms
    DWORD & dwMDUserType        : Meta parms
    DWORD & dwMDDataType        : Meta parms

Return Value:
    TRUE for success, FALSE for failure.

--*/
{
#if 0
    int nID = MapMDIDToTableIndex(dwID);

    if (nID == -1)
    {
        //
        // Unrecognized meta data ID
        //
        ASSERT_MSG("Unrecognized meta data id");
        return FALSE;
    }

    dwMDIdentifier = s_rgMetaTable[nID].dwMDIdentifier;
    dwMDAttributes = s_rgMetaTable[nID].dwMDAttributes;
    dwMDUserType   = s_rgMetaTable[nID].dwMDUserType;
    dwMDDataType   = s_rgMetaTable[nID].dwMDDataType;
    return TRUE;
#endif
    const MDFIELDDEF * p = GetMetaProp(dwID);
    if (p != NULL)
    {
        dwMDIdentifier = p->dwMDIdentifier;
        dwMDAttributes = p->dwMDAttributes;
        dwMDUserType   = p->dwMDUserType;
        dwMDDataType   = p->dwMDDataType;
        return TRUE;
    }
    return FALSE;
}



/* static */
BOOL
CMetaKey::IsPropertyInheritable(
    IN DWORD dwID
    )
/*++

Routine Description:

    Check to see if the given property is inheritable

Arguments:

    DWORD dwID      : Metabase ID

Return Value:

    TRUE if the metabase ID is inheritable, FALSE otherwise.

--*/
{
    const MDFIELDDEF * p = GetMetaProp(dwID);
    if (p == NULL)
    {
        ASSERT_MSG("Unrecognized meta data ID");
        return FALSE;
    }
    return (p->dwMDAttributes & METADATA_INHERIT) != 0;
#if 0
    int nID = MapMDIDToTableIndex(dwID);

    if (nID == -1)
    {
        //
        // Unrecognized meta data ID
        //
        ASSERT_MSG("Unrecognized meta data ID");
        return FALSE;
    }

    return (s_rgMetaTable[nID].dwMDAttributes & METADATA_INHERIT) != 0;
#endif
}



/* static */
BOOL
CMetaKey::GetPropertyDescription(
    IN  DWORD dwID,
    OUT CString & strName
    )
/*++

Routine Description:

    Get a description for the given property

Arguments:

    DWORD dwID            : Property ID
    CString & strName     : Returns friendly property name

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    const MDFIELDDEF * p = GetMetaProp(dwID);
    if (p == NULL)
    {
        ASSERT_MSG("Unrecognized meta data ID");
        return FALSE;
    }
    UINT uID = p->uStringID;
#if 0
    int nID = MapMDIDToTableIndex(dwID);

    if (nID == -1)
    {
        //
        // Unrecognized meta data ID
        //
        ASSERT_MSG("Unrecognized meta data ID");
        return FALSE;
    }

    UINT uID = s_rgMetaTable[nID].uStringID;
#endif
    BOOL fResult = TRUE;

    if (uID > 0)
    {
        fResult = (strName.LoadString(uID) != 0);
        ASSERT(fResult);
    }
    else
    {
        //
        // Don't have a friendly name -- fake it
        //
        CComBSTR bstrFmt;
        VERIFY(bstrFmt.LoadString(hDLLInstance, IDS_INHERITANCE_NO_NAME));

        strName.Format(bstrFmt, dwID);
    }

    return fResult;
}



CMetaKey::CMetaKey(
    IN CComAuthInfo * pAuthInfo     OPTIONAL
    )
/*++

Routine Description:

    Constructor that creates the interface, but does not open the key.
    This is the ONLY constructor that allows operations from
    METDATA_MASTER_ROOT_HANDLE (read operations obviously)

Arguments:

    CComAuthInfo * pAuthInfo  : If NULL, opens interface on local machine

Return Value:

    N/A

--*/
    : CMetaInterface(pAuthInfo),
      m_hKey(METADATA_MASTER_ROOT_HANDLE),
      m_hBase(NULL),
      m_hrKey(S_OK),
      m_dwFlags(0L),
      m_cbInitialBufferSize(MB_INIT_BUFF_SIZE),
      m_strMetaPath(),
      m_fAllowRootOperations(TRUE),
      m_fOwnKey(TRUE)
{
    m_hrKey = CMetaInterface::QueryResult();

    //
    // Do not open key
    //
}



CMetaKey::CMetaKey(
    IN CMetaInterface * pInterface
    )
/*++

Routine Description:

    Construct with pre-existing interface.  Does not
    open any keys

Arguments:

    CMetaInterface * pInterface       : Preexisting interface

Return Value:

    N/A

--*/
    : CMetaInterface(pInterface),
      m_hKey(NULL),
      m_hBase(NULL),
      m_strMetaPath(),
      m_dwFlags(0L),
      m_cbInitialBufferSize(MB_INIT_BUFF_SIZE),
      m_fAllowRootOperations(TRUE),
      m_fOwnKey(TRUE)
{
    m_hrKey = CMetaInterface::QueryResult();
}



CMetaKey::CMetaKey(
    IN CComAuthInfo * pAuthInfo,    OPTIONAL
    IN LPCTSTR lpszMDPath,          OPTIONAL
    IN DWORD   dwFlags,
    IN METADATA_HANDLE hkBase
    )
/*++

Routine Description:

    Fully defined constructor that opens a key

Arguments:

    CComAuthInfo * pAuthInfo : Auth info or NULL
    LPCTSTR lpszMDPath       : Path or NULL
    DWORD   dwFlags          : Open permissions
    METADATA_HANDLE hkBase   : Base key

Return Value:

    N/A

--*/
    : CMetaInterface(pAuthInfo),
      m_hKey(NULL),
      m_hBase(NULL),
      m_dwFlags(0L),
      m_cbInitialBufferSize(MB_INIT_BUFF_SIZE),
      m_fAllowRootOperations(FALSE),
      m_strMetaPath(),
      m_fOwnKey(TRUE)
{
    m_hrKey = CMetaInterface::QueryResult();

    if (SUCCEEDED(m_hrKey))
    {
        m_hrKey = Open(dwFlags, lpszMDPath, hkBase);
    }
}



CMetaKey::CMetaKey(
    IN CMetaInterface * pInterface,
    IN LPCTSTR lpszMDPath,              OPTIONAL
    IN DWORD   dwFlags,
    IN METADATA_HANDLE hkBase
    )
/*++

Routine Description:

    Fully defined constructor that opens a key

Arguments:

    CMetaInterface * pInterface : Existing interface
    DWORD   dwFlags             : Open permissions
    METADATA_HANDLE hkBase      : Base key
    LPCTSTR lpszMDPath          : Path or NULL

Return Value:

    N/A

--*/
    : CMetaInterface(pInterface),
      m_hKey(NULL),
      m_hBase(NULL),
      m_strMetaPath(),
      m_dwFlags(0L),
      m_cbInitialBufferSize(MB_INIT_BUFF_SIZE),
      m_fAllowRootOperations(FALSE),
      m_fOwnKey(TRUE)
{
    m_hrKey = CMetaInterface::QueryResult();

    if (SUCCEEDED(m_hrKey))
    {
        m_hrKey = Open(dwFlags, lpszMDPath, hkBase);
    }
}



CMetaKey::CMetaKey(
    IN BOOL  fOwnKey,
    IN CMetaKey * pKey
    )
/*++

Routine Description:

    Copy constructor.

Arguments:

    BOOL  fOwnKey               : TRUE to take ownership of the key
    const CMetaKey * pKey       : Existing key

Return Value:

    N/A

--*/
    : CMetaInterface(pKey),
      m_hKey(pKey->m_hKey),
      m_hBase(pKey->m_hBase),
      m_dwFlags(pKey->m_dwFlags),
      m_cbInitialBufferSize(pKey->m_cbInitialBufferSize),
      m_fAllowRootOperations(pKey->m_fAllowRootOperations),
      m_hrKey(pKey->m_hrKey),
      m_strMetaPath(pKey->m_strMetaPath),
      m_fOwnKey(fOwnKey)
{
    //
    // No provisions for anything else at the moment
    //
    ASSERT(!m_fOwnKey);
}



CMetaKey::~CMetaKey()
/*++

Routine Description:

    Destructor -- Close the key.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    if (IsOpen() && m_fOwnKey)
    {
        Close();
    }
}



/* virtual */
BOOL
CMetaKey::Succeeded() const
/*++

Routine Description:

    Determine if object was constructed successfully

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    return SUCCEEDED(m_hrKey);
}



/* virtual */
HRESULT
CMetaKey::QueryResult() const
/*++

Routine Description:

    Return the construction error for this object

Arguments:

    None

Return Value:

    HRESULT from construction errors

--*/
{
    return m_hrKey;
}



HRESULT
CMetaKey::Open(
    IN DWORD dwFlags,
    IN LPCTSTR lpszMDPath,          OPTIONAL
    IN METADATA_HANDLE hkBase
    )
/*++

Routine Description:

    Attempt to open a metabase key

Arguments:

    DWORD dwFlags           : Permission flags
    LPCTSTR lpszMDPath      : Optional path
    METADATA_HANDLE hkBase  : Base metabase key

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();

    if (m_hKey != NULL)
    {
//        ASSERT_MSG("Attempting to open key that already has an open handle");
        Close();
    }

    //
    // Base key is stored for reopen purposes only
    //
    m_hBase = hkBase;
    m_strMetaPath = lpszMDPath;
    m_dwFlags = dwFlags;

    return OpenKey(m_hBase, m_strMetaPath, m_dwFlags, &m_hKey);
}



HRESULT
CMetaKey::CreatePathFromFailedOpen()
/*++

Routine Description:

    If the path doesn't exist, create it.  This method should be
    called after an Open call failed (because it will have initialized
    m_strMetaPath.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CString strParentPath;
    CString strObjectName;
    CString strSavePath(m_strMetaPath);

    CMetabasePath::SplitMetaPathAtInstance(
        m_strMetaPath,
        strParentPath,
        strObjectName
        );

    CError err(Open(
        METADATA_PERMISSION_WRITE,
        strParentPath
        ));

    if (err.Succeeded())
    {
        //
        // This really should never fail, because we're opening
        // the path at the instance.
        //
        err = AddKey(strObjectName);
    }

    if (IsOpen())
    {
        Close();
    }

    //
    // The previous open wiped out the path...
    //
    m_strMetaPath = strSavePath;

    return err;
}



HRESULT
CMetaKey::Close()
/*++

Routine Description:

    Close the currently open key.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    ASSURE_PROPER_INTERFACE();

    HRESULT hr = S_OK;

    ASSERT(m_hKey != NULL);
    ASSERT(m_fOwnKey);

    if (m_hKey)
    {
        hr = CloseKey(m_hKey);

        if (SUCCEEDED(hr))
        {
            m_hKey = NULL;
        }
    }

    return hr;
}



HRESULT
CMetaKey::ConvertToParentPath(
    IN  BOOL fImmediate
    )
/*++

Routine Description:

    Change the path to the parent path.

Arguments:

    BOOL fImmediate     : If TRUE, the immediate parent's path will be used
                          if FALSE, the first parent that really exists

Return Value:

    HRESULT

        ERROR_INVALID_PARAMETER if there is no valid path

--*/
{
    BOOL fIsOpen = IsOpen();

    if (fIsOpen)
    {
        Close();
    }

    CError err;

    FOREVER
    {
        if (!CMetabasePath::ConvertToParentPath(m_strMetaPath))
        {
            //
            // There is no parent path
            //
            err = ERROR_INVALID_PARAMETER;
            break;
        }

        err = ReOpen();

        //
        // Path not found is the only valid error
        // other than success.
        //
        if (fImmediate
            || err.Succeeded()
            || err.Win32Error() != ERROR_PATH_NOT_FOUND)
        {
            break;
        }
    }

    //
    // Remember to reset the construction error
    // which referred to the parent path.
    //
    m_hrKey = err;

    return err;
}




/* protected */
HRESULT
CMetaKey::GetPropertyValue(
    IN  DWORD dwID,
    OUT IN DWORD & dwSize,               OPTIONAL
    OUT IN void *& pvData,               OPTIONAL
    OUT IN DWORD * pdwDataType,          OPTIONAL
    IN  BOOL * pfInheritanceOverride,    OPTIONAL
    IN  LPCTSTR lpszMDPath,              OPTIONAL
    OUT DWORD * pdwAttributes            OPTIONAL
    )
/*++

Routine Description:

    Get metadata on the currently open key.

Arguments:

    DWORD dwID                      : Property ID number
    DWORD & dwSize                  : Buffer size (could be 0)
    void *& pvData                  : Buffer -- will allocate if NULL
    DWORD * pdwDataType             : NULL or on in  contains valid data types,
                                    :         on out contains actual data type
    BOOL * pfInheritanceOverride    : NULL or on forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes

Return Value:

    HRESULT

    ERROR_INVALID_HANDLE        : If the handle is not open
    ERROR_INVALID_PARAMETER     : If the property id is not found,
                                  or the data type doesn't match requested type
    ERROR_OUTOFMEMORY           : Out of memory

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    METADATA_RECORD mdRecord;
    FETCH_PROPERTY_DATA_OR_FAIL(dwID, mdRecord);

    //
    // If unable to find this property ID in our table, or
    // if we specified a desired type, and this type doesn't
    // match it, give up.
    //
    if (pdwDataType && *pdwDataType != ALL_METADATA
        && *pdwDataType != mdRecord.dwMDDataType)
    {
        ASSERT_MSG("Invalid parameter");
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    //
    // Check to see if inheritance behaviour is overridden
    //
    if (pfInheritanceOverride)
    {
        if (*pfInheritanceOverride)
        {
            mdRecord.dwMDAttributes |= METADATA_INHERIT;
        }
        else
        {
            mdRecord.dwMDAttributes &= ~METADATA_INHERIT;
        }
    }

    //
    // This causes a bad parameter error on input otherwise
    //
    mdRecord.dwMDAttributes &= ~METADATA_REFERENCE;

    //
    // If we're looking for inheritable properties, the path
    // doesn't have to be completely specified.
    //
    if (mdRecord.dwMDAttributes & METADATA_INHERIT)
    {
        mdRecord.dwMDAttributes |= (METADATA_PARTIAL_PATH | METADATA_ISINHERITED);
    }

    ASSERT(dwSize > 0 || pvData == NULL);

    mdRecord.dwMDDataLen = dwSize;
    mdRecord.pbMDData = (LPBYTE)pvData;

    //
    // If no buffer provided, allocate one.
    //
    HRESULT hr = S_OK;
    BOOL fBufferTooSmall = FALSE;
    BOOL fAllocatedMemory = FALSE;
    DWORD dwInitSize = m_cbInitialBufferSize;

    do
    {
        if(mdRecord.pbMDData == NULL)
        {
            mdRecord.dwMDDataLen = dwInitSize;
            mdRecord.pbMDData = (LPBYTE)AllocMem(dwInitSize);

            if(mdRecord.pbMDData == NULL && dwInitSize > 0)
            {
                hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
                break;
            }

            ++fAllocatedMemory;
        }

        //
        // Get the data
        //
        DWORD dwRequiredDataLen = 0;
        hr = GetData(m_hKey, lpszMDPath, &mdRecord, &dwRequiredDataLen);

        //
        // Re-fetch the buffer if it's too small.
        //
        fBufferTooSmall =
            (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER) && fAllocatedMemory;

        if(fBufferTooSmall)
        {
            //
            // Delete the old buffer, and set up for a re-fetch.
            //
            FreeMem(mdRecord.pbMDData);
            mdRecord.pbMDData = NULL;
            dwInitSize = dwRequiredDataLen;
        }
    }
    while(fBufferTooSmall);

    //
    // Failed
    //
    if(FAILED(hr) && fAllocatedMemory)
    {
        FreeMem(mdRecord.pbMDData);
        mdRecord.pbMDData = NULL;
    }

    dwSize = mdRecord.dwMDDataLen;
    pvData = mdRecord.pbMDData;

    if (pdwDataType != NULL)
    {
        //
        // Return actual data type
        //
        *pdwDataType = mdRecord.dwMDDataType;
    }

    if (pdwAttributes != NULL)
    {
        //
        // Return data attributes
        //
        *pdwAttributes =  mdRecord.dwMDAttributes;
    }

    return hr;
}



/* protected */
HRESULT
CMetaKey::GetDataPaths(
    OUT CStringListEx & strlDataPaths,
    IN  DWORD   dwMDIdentifier,
    IN  DWORD   dwMDDataType,
    IN  LPCTSTR lpszMDPath              OPTIONAL
    )
/*++

Routine Description:

    Get data paths

Arguments:


Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    //
    // Start with a small buffer
    //
    DWORD  dwMDBufferSize = 1024;
    LPTSTR lpszBuffer = NULL;
    CError err;

    do
    {
        if (lpszBuffer != NULL)
        {
            FreeMem(lpszBuffer);
        }

        lpszBuffer = AllocTString(dwMDBufferSize);

        if (lpszBuffer == NULL)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        err = CMetaInterface::GetDataPaths(
            m_hKey,
            lpszMDPath,
            dwMDIdentifier,
            dwMDDataType,
            dwMDBufferSize,
            lpszBuffer,
            &dwMDBufferSize
            );
    }
    while(err.Win32Error() == ERROR_INSUFFICIENT_BUFFER);

    if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
    {
        //
        // That's ok... this is some sort of physical directory
        // that doesn't currently exist in the metabase, and
        // which therefore doesn't have any descendants anyway.
        //
        ZeroMemory(lpszBuffer, dwMDBufferSize);
        err.Reset();
    }

    if (err.Succeeded())
    {
        ConvertDoubleNullListToStringList(lpszBuffer, strlDataPaths);
        FreeMem(lpszBuffer);
    }

    return err;
}



HRESULT
CMetaKey::CheckDescendants(
    IN DWORD   dwID,
    IN CComAuthInfo * pAuthInfo, OPTIONAL
    IN LPCTSTR lpszMDPath         OPTIONAL
    )
/*++

Routine Description:

    Check for descendant overrides;  If there are any, bring up a dialog
    that displays them, and give the user the opportunity the remove
    the overrides.

Arguments:

    DWORD dwID               : Property ID
    CComAuthInfo * pAuthInfo : Server or NULL
    LPCTSTR lpszMDPath       : Metabase path or NULL

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();

    HRESULT hr = S_OK;

    METADATA_RECORD mdRecord;
    FETCH_PROPERTY_DATA_OR_FAIL(dwID, mdRecord);

    if (mdRecord.dwMDAttributes & METADATA_INHERIT)
    {
        CStringListEx strlDataPaths;

        hr = GetDataPaths(
            strlDataPaths,
            mdRecord.dwMDIdentifier,
            mdRecord.dwMDDataType,
            lpszMDPath
            );

        if (SUCCEEDED(hr) && !strlDataPaths.IsEmpty())
        {
            //
            // Bring up the inheritance override dialog
            //
            CInheritanceDlg dlg(
                dwID,
                FROM_WRITE_PROPERTY,
                pAuthInfo,
                lpszMDPath,
                strlDataPaths
                );

            if (!dlg.IsEmpty())
            {
                dlg.DoModal();
            }
        }
    }

    return hr;
}



/* protected */
HRESULT
CMetaKey::SetPropertyValue(
    IN DWORD dwID,
    IN DWORD dwSize,
    IN void * pvData,
    IN BOOL * pfInheritanceOverride,    OPTIONAL
    IN LPCTSTR lpszMDPath               OPTIONAL
    )
/*++

Routine Description:

    Set metadata on the open key.  The key must have been opened with
    write permission.

Arguments:

    DWORD dwID                      : Property ID
    DWORD dwSize                    : Size of data
    void * pvData                   : Data buffer
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key

Return Value:

    HRESULT

    ERROR_INVALID_HANDLE            : If the handle is not open
    ERROR_INVALID_PARAMETER         : If the property id is not found,
                                      or the buffer is NULL or of size 0

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    if (pvData == NULL && dwSize != 0)
    {
        ASSERT_MSG("No Data");
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    METADATA_RECORD mdRecord;
    FETCH_PROPERTY_DATA_OR_FAIL(dwID, mdRecord);

    if (pfInheritanceOverride)
    {
        if (*pfInheritanceOverride)
        {
            mdRecord.dwMDAttributes |= METADATA_INHERIT;
        }
        else
        {
            mdRecord.dwMDAttributes &= ~METADATA_INHERIT;
        }
    }

    mdRecord.dwMDDataLen = dwSize;
    mdRecord.pbMDData = (LPBYTE)pvData;

    return SetData(m_hKey, lpszMDPath, &mdRecord);
}



/* protected */
HRESULT
CMetaKey::GetAllData(
    IN  DWORD dwMDAttributes,
    IN  DWORD dwMDUserType,
    IN  DWORD dwMDDataType,
    OUT DWORD * pdwMDNumEntries,
    OUT DWORD * pdwMDDataLen,
    OUT PBYTE * ppbMDData,
    IN  LPCTSTR lpszMDPath              OPTIONAL
    )
/*++

Routine Description:

    Get all data off the open key.  Buffer is created automatically.

Arguments:

    DWORD dwMDAttributes            : Attributes
    DWORD dwMDUserType              : User type to fetch
    DWORD dwMDDataType              : Data type to fetch
    DWORD * pdwMDNumEntries         : Returns number of entries read
    DWORD * pdwMDDataLen            : Returns size of data buffer
    PBYTE * ppbMDData               : Returns data buffer
    LPCTSTR lpszMDPath              : Optional data path

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    //
    // Check for valid parameters
    //
    if(!pdwMDDataLen || !ppbMDData || !pdwMDNumEntries)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    HRESULT hr = S_OK;
    BOOL fBufferTooSmall = FALSE;
    DWORD dwMDDataSetNumber;
    DWORD dwRequiredBufferSize;
    DWORD dwInitSize = m_cbInitialBufferSize;
    *ppbMDData = NULL;

    do
    {
        *pdwMDDataLen = dwInitSize;
        *ppbMDData = (LPBYTE)AllocMem(dwInitSize);

        if (ppbMDData == NULL && dwInitSize > 0)
        {
            hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
            break;
        }

        hr = CMetaInterface::GetAllData(
            m_hKey,
            lpszMDPath,
            dwMDAttributes,
            dwMDUserType,
            dwMDDataType,
            pdwMDNumEntries,
            &dwMDDataSetNumber,
            *pdwMDDataLen,
            *ppbMDData,
            &dwRequiredBufferSize
            );

        //
        // Re-fetch the buffer if it's too small.
        //
        fBufferTooSmall = (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER);

        if(fBufferTooSmall)
        {
            //
            // Delete the old buffer, and set up for a re-fetch.
            //
            SAFE_FREEMEM(*ppbMDData);
            dwInitSize = dwRequiredBufferSize;
        }
    }
    while (fBufferTooSmall);

    if (FAILED(hr))
    {
        //
        // No good, be sure we don't leak anything
        //
        SAFE_FREEMEM(*ppbMDData);
        dwInitSize = 0L;
    }

    return hr;
}



HRESULT
CMetaKey::QueryValue(
    IN  DWORD dwID,
    IN  OUT DWORD & dwValue,
    IN  BOOL * pfInheritanceOverride, OPTIONAL
    IN  LPCTSTR lpszMDPath,           OPTIONAL
    OUT DWORD * pdwAttributes         OPTIONAL
    )
/*++

Routine Description:

    Fetch data as a DWORD

Arguments:

    DWORD dwID                      : Property ID
    DWORD & dwValue                 : Returns the value read in
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes

Return Value:

    HRESULT

--*/
{
    DWORD dwSize = sizeof(dwValue);
    DWORD dwDataType = DWORD_METADATA;
    void * pvData = &dwValue;

    return GetPropertyValue(
        dwID,
        dwSize,
        pvData,
        &dwDataType,
        pfInheritanceOverride,
        lpszMDPath,
        pdwAttributes
        );
}



HRESULT
CMetaKey::QueryValue(
    IN  DWORD dwID,
    IN  OUT CString & strValue,
    IN  BOOL * pfInheritanceOverride, OPTIONAL
    IN  LPCTSTR lpszMDPath,           OPTIONAL
    OUT DWORD * pdwAttributes         OPTIONAL
    )
/*++

Routine Description:

    Fetch data as a string

Arguments:

    DWORD dwID                      : Property ID
    DWORD & strValue                : Returns the value read in
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes

Return Value:

    HRESULT

--*/
{
    //
    // Get GetData allocate the buffer for us
    //
    DWORD dwSize = 0;
    DWORD dwDataType = ALL_METADATA;
    LPTSTR lpData = NULL;

    HRESULT hr = GetPropertyValue(
        dwID,
        dwSize,
        (void *&)lpData,
        &dwDataType,
        pfInheritanceOverride,
        lpszMDPath,
        pdwAttributes
        );

    if (SUCCEEDED(hr))
    {
        //
        // Notes: consider optional auto-expansion on EXPANDSZ_METADATA
        // (see registry functions), and data type conversions for DWORD
        // or MULTISZ_METADATA or BINARY_METADATA
        //
        if (dwDataType == EXPANDSZ_METADATA || dwDataType == STRING_METADATA)
        {
            try
            {
                strValue = lpData;
            }
            catch(CMemoryException * e)
            {
                hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                strValue.Empty();
                e->Delete();
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        }
    }

    if (lpData)
    {
        FreeMem(lpData);
    }

    return hr;
}



HRESULT
CMetaKey::QueryValue(
    IN  DWORD dwID,
    IN  OUT CStrPassword & strValue,
    IN  BOOL * pfInheritanceOverride, OPTIONAL
    IN  LPCTSTR lpszMDPath,           OPTIONAL
    OUT DWORD * pdwAttributes         OPTIONAL
    )
/*++

Routine Description:

    Fetch data as a string

Arguments:

    DWORD dwID                      : Property ID
    CStrPassword & strValue                : Returns the value read in
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes

Return Value:

    HRESULT

--*/
{
    //
    // Get GetData allocate the buffer for us
    //
    DWORD dwSize = 0;
    DWORD dwDataType = ALL_METADATA;
    LPTSTR lpData = NULL;

    HRESULT hr = GetPropertyValue(
        dwID,
        dwSize,
        (void *&)lpData,
        &dwDataType,
        pfInheritanceOverride,
        lpszMDPath,
        pdwAttributes
        );

    if (SUCCEEDED(hr))
    {
        //
        // Notes: consider optional auto-expansion on EXPANDSZ_METADATA
        // (see registry functions), and data type conversions for DWORD
        // or MULTISZ_METADATA or BINARY_METADATA
        //
        if (dwDataType == EXPANDSZ_METADATA || dwDataType == STRING_METADATA)
        {
            try
            {
                strValue = (LPCTSTR) lpData;
            }
            catch(CMemoryException * e)
            {
                hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                strValue.Empty();
                e->Delete();
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        }
    }

    if (lpData)
    {
        FreeMem(lpData);
    }

    return hr;
}



HRESULT
CMetaKey::QueryValue(
    IN  DWORD dwID,
    IN  OUT CComBSTR & strValue,
    IN  BOOL * pfInheritanceOverride, OPTIONAL
    IN  LPCTSTR lpszMDPath,           OPTIONAL
    OUT DWORD * pdwAttributes         OPTIONAL
    )
/*++

Routine Description:

    Fetch data as a string

Arguments:

    DWORD dwID                      : Property ID
    DWORD & CComBSTR                : Returns the value read in
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes

Return Value:

    HRESULT

--*/
{
    //
    // Get GetData allocate the buffer for us
    //
    DWORD dwSize = 0;
    DWORD dwDataType = ALL_METADATA;
    LPTSTR lpData = NULL;

    HRESULT hr = GetPropertyValue(
        dwID,
        dwSize,
        (void *&)lpData,
        &dwDataType,
        pfInheritanceOverride,
        lpszMDPath,
        pdwAttributes
        );

    if (SUCCEEDED(hr))
    {
        //
        // Notes: consider optional auto-expansion on EXPANDSZ_METADATA
        // (see registry functions), and data type conversions for DWORD
        // or MULTISZ_METADATA or BINARY_METADATA
        //
        if (dwDataType == EXPANDSZ_METADATA || dwDataType == STRING_METADATA)
        {
            strValue = lpData;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        }
    }

    if (lpData)
    {
        FreeMem(lpData);
    }

    return hr;
}




HRESULT
CMetaKey::QueryValue(
    IN  DWORD dwID,
    IN  OUT CStringListEx & strlValue,
    IN  BOOL * pfInheritanceOverride, OPTIONAL
    IN  LPCTSTR lpszMDPath,           OPTIONAL
    OUT DWORD * pdwAttributes         OPTIONAL
    )
/*++

Routine Description:

    Fetch data as a stringlist

Arguments:

    DWORD dwID                      : Property ID
    DWORD & strlValue               : Returns the value read in
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes

Return Value:

    HRESULT

--*/
{
    //
    // Get GetData allocate the buffer for us
    //
    DWORD dwSize = 0;
    DWORD dwDataType = MULTISZ_METADATA;
    LPTSTR lpData = NULL;

    HRESULT hr = GetPropertyValue(
        dwID,
        dwSize,
        (void *&)lpData,
        &dwDataType,
        pfInheritanceOverride,
        lpszMDPath,
        pdwAttributes
        );

    if (SUCCEEDED(hr))
    {
        //
        // Notes: Consider accepting a single STRING
        //
        ASSERT(dwDataType == MULTISZ_METADATA);

        DWORD err = ConvertDoubleNullListToStringList(
            lpData,
            strlValue,
            dwSize / sizeof(TCHAR)
            );
        hr = HRESULT_FROM_WIN32(err);
    }

    if (lpData)
    {
        FreeMem(lpData);
    }

    return hr;
}


HRESULT
CMetaKey::GetChildPaths(CStringListEx& child_paths, LPCTSTR path)
{
    DWORD bsize = 0;
    CError err;
    LPTSTR pData = _T("");
    do
    {
        err = CMetaInterface::GetChildPaths(
            m_hKey, path, 0, pData, &bsize);
        if (err.Failed() && err.Win32Error() != ERROR_INSUFFICIENT_BUFFER)
            break;
        pData = (LPTSTR)::LocalAlloc(LPTR, bsize * sizeof(WCHAR));
        if (pData == NULL)
        {
            err = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
            break;
        }
        err = CMetaInterface::GetChildPaths(
            m_hKey, path, bsize, pData, &bsize);
        if (err.Failed()) break;
        ConvertDoubleNullListToStringList(pData, child_paths);
    } while (FALSE);
    if (pData != NULL)
    {
        ::LocalFree(pData);
    }
    return err;
}


HRESULT
CMetaKey::QueryValue(
    IN  DWORD dwID,
    IN  OUT CBlob & blValue,
    IN  BOOL * pfInheritanceOverride, OPTIONAL
    IN  LPCTSTR lpszMDPath,           OPTIONAL
    OUT DWORD * pdwAttributes         OPTIONAL
    )
/*++

Routine Description:

    Fetch data as a binary blob

Arguments:

    DWORD dwID                      : Property ID
    DWORD CBlob & blValue           : Returns the binary blob
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes

Return Value:

    HRESULT

--*/
{
    //
    // Get GetData allocate the buffer for us
    //
    DWORD dwSize = 0;
    DWORD dwDataType = BINARY_METADATA;
    LPBYTE pbData = NULL;

    HRESULT hr = GetPropertyValue(
        dwID,
        dwSize,
        (void *&)pbData,
        &dwDataType,
        pfInheritanceOverride,
        lpszMDPath,
        pdwAttributes
        );

    if (SUCCEEDED(hr))
    {
        //
        // Blob takes ownership of the data, so don't free it...
        //
        ASSERT_READ_PTR2(pbData, dwSize);
        blValue.SetValue(dwSize, pbData, FALSE);
    }

    return hr;
}


HRESULT
CMetaKey::SetValue(
    IN DWORD dwID,
    IN CStrPassword & strlValue,
    IN BOOL * pfInheritanceOverride,        OPTIONAL
    IN LPCTSTR lpszMDPath                   OPTIONAL
    )
{
    LPTSTR lpstr = NULL;
    HRESULT hr = S_OK;

    lpstr = strlValue.GetClearTextPassword();
    if (lpstr)
    {
        hr = SetPropertyValue(
            dwID,
            strlValue.GetByteLength(),
            (void *)lpstr,
            pfInheritanceOverride,
            lpszMDPath
            );

        strlValue.DestroyClearTextPassword(lpstr);
    }
    return hr;
}

HRESULT
CMetaKey::SetValue(
    IN DWORD dwID,
    IN CStringListEx & strlValue,
    IN BOOL * pfInheritanceOverride,        OPTIONAL
    IN LPCTSTR lpszMDPath                   OPTIONAL
    )
/*++

Routine Description:

    Store data as string

Arguments:

    DWORD dwID                   : Property ID
    CStringListEx & strlValue    : Value to be written
    BOOL * pfInheritanceOverride : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath           : Optional path (or NULL or "")

Return Value:

    HRESULT

--*/
{
    DWORD cCharacters;
    LPTSTR lpstr = NULL;

    //
    // Flatten value
    //
    ConvertStringListToDoubleNullList(
       strlValue,
       cCharacters,
       lpstr
       );

    HRESULT hr = SetPropertyValue(
        dwID,
        cCharacters * sizeof(TCHAR),
        (void *)lpstr,
        pfInheritanceOverride,
        lpszMDPath
        );

    SAFE_FREEMEM(lpstr);

    return hr;
}


HRESULT
CMetaKey::SetValue(
    IN DWORD dwID,
    IN CBlob & blValue,
    IN BOOL * pfInheritanceOverride,    OPTIONAL
    IN LPCTSTR lpszMDPath               OPTIONAL
    )
/*++

Routine Description:

    Store data as binary

Arguments:

    DWORD dwID                   : Property ID
    CBlob & blValue              : Value to be written
    BOOL * pfInheritanceOverride : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath           : Optional path (or NULL or "")

Return Value:

    HRESULT

--*/
{
    return SetPropertyValue(
        dwID,
        blValue.GetSize(),
        (void *)blValue.GetData(),
        pfInheritanceOverride,
        lpszMDPath
        );
}



HRESULT
CMetaKey::DeleteValue(
    DWORD   dwID,
    LPCTSTR lpszMDPath      OPTIONAL
    )
/*++

Routine Description:

    Delete data

Arguments:

    DWORD   dwID            : Property ID of property to be deleted
    LPCTSTR lpszMDPath      : Optional path (or NULL or "")

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    METADATA_RECORD mdRecord;
    FETCH_PROPERTY_DATA_OR_FAIL(dwID, mdRecord);

    return DeleteData(
        m_hKey,
        lpszMDPath,
        mdRecord.dwMDIdentifier,
        mdRecord.dwMDDataType
        );
}



HRESULT
CMetaKey::DoesPathExist(
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Determine if the path exists

Arguments:

    LPCTSTR lpszMDPath      : Relative path off the open key

Return Value:

    HRESULT, or S_OK if the path exists.

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    FILETIME ft;

    return GetLastChangeTime(m_hKey, lpszMDPath, &ft, FALSE);
}



HRESULT
CMetaInterface::Regenerate()
/*++

Routine Description:

    Attempt to recreate the interface pointer.  This assumes that the interface
    had been successfully created before, but has become invalid at some
    point afterwards.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ASSERT_PTR(m_pInterface);           // Must have been initialised

    SAFE_RELEASE(m_pInterface);

    m_hrInterface = Create();

    return m_hrInterface;
}


#define GET_TO_INTERFACE2()\
    IMSAdminBase2 * pInterface2 = NULL;\
	HRESULT hr = GetAdminInterface2(&pInterface2);\
	if (SUCCEEDED(hr)) {

#define GET_TO_INTERFACE3()\
    IMSAdminBase3 * pInterface3 = NULL;\
	HRESULT hr = GetAdminInterface3(&pInterface3);\
	if (SUCCEEDED(hr)) {

#define RELEASE_AND_RETURN2()\
        if (pInterface2 != NULL)\
			pInterface2->Release();\
    }\
	return hr

#define RELEASE_AND_RETURN3()\
        if (pInterface3 != NULL)\
			pInterface3->Release();\
    }\
	return hr

HRESULT
CMetaInterface::GetAdminInterface2(IMSAdminBase2 ** pp)
{
	HRESULT hr = S_OK;
	IMSAdminBase2 * p = NULL;
	if (pp == NULL)
		return E_POINTER;
    if (m_auth.UsesImpersonation())
	{
		IUnknown * punk = NULL;
		hr = m_pInterface->QueryInterface(__uuidof(IUnknown), (void **)&punk);
		if (SUCCEEDED(hr))
		{
			if (SUCCEEDED(hr = m_auth.ApplyProxyBlanket(punk)))
			{
				if (SUCCEEDED(hr = punk->QueryInterface(IID_IMSAdminBase2, (void **)&p)))
				{
					if (p != NULL)
					{
						hr = m_auth.ApplyProxyBlanket(p);
						if (SUCCEEDED(hr))
						{
							*pp = p;
						}
					}
				}
			}
		}
		if (punk != NULL)
			punk->Release();
    }
	else
	{
        if (m_pInterface)
        {
		    hr = m_pInterface->QueryInterface(IID_IMSAdminBase2, (void **)pp);
        }
        else
        {
            hr = E_NOINTERFACE;
        }
	}
	return hr;
}

HRESULT
CMetaInterface::GetAdminInterface3(IMSAdminBase3 ** pp)
{
	HRESULT hr = S_OK;
	IMSAdminBase3 * p = NULL;
	if (pp == NULL)
		return E_POINTER;
    if (m_auth.UsesImpersonation())
	{
		IUnknown * punk = NULL;
		hr = m_pInterface->QueryInterface(__uuidof(IUnknown), (void **)&punk);
		if (SUCCEEDED(hr))
		{
			if (SUCCEEDED(hr = m_auth.ApplyProxyBlanket(punk)))
			{
				if (SUCCEEDED(hr = punk->QueryInterface(IID_IMSAdminBase3, (void **)&p)))
				{
					if (p != NULL)
					{
						hr = m_auth.ApplyProxyBlanket(p);
						if (SUCCEEDED(hr))
						{
							*pp = p;
						}
					}
				}
			}
		}
		if (punk != NULL)
			punk->Release();
    }
	else
	{
        if (m_pInterface)
        {
		    hr = m_pInterface->QueryInterface(IID_IMSAdminBase3, (void **)pp);
        }
        else
        {
            hr = E_NOINTERFACE;
        }
	}
	return hr;
}

HRESULT CMetaInterface::BackupWithPassword(
    IN LPCTSTR lpszBackupLocation,
    IN DWORD dwMDVersion,
    IN DWORD dwMDFlags,
	IN LPCTSTR lpszPassword
    )
{
    GET_TO_INTERFACE2();
    hr = pInterface2->BackupWithPasswd(lpszBackupLocation, dwMDVersion, dwMDFlags, lpszPassword);
    RELEASE_AND_RETURN2();
}


HRESULT CMetaInterface::RestoreWithPassword(
    IN LPCTSTR lpszBackupLocation,
    IN DWORD dwMDVersion,
    IN DWORD dwMDFlags,
	IN LPCTSTR lpszPassword
    )
{
    GET_TO_INTERFACE2();
    hr = pInterface2->RestoreWithPasswd(lpszBackupLocation, dwMDVersion, dwMDFlags, lpszPassword);
    RELEASE_AND_RETURN2();
}


HRESULT CMetaInterface::EnumHistory(
    OUT LPTSTR pszMDHistoryLocation,
    OUT DWORD * pdwMDMajorVersion,
    OUT DWORD * pdwMDMinorVersion,
    OUT FILETIME * pftMDHistoryTime,
    IN  DWORD dwIndex
    )
{
    GET_TO_INTERFACE2();
    hr = pInterface2->EnumHistory(pszMDHistoryLocation, pdwMDMajorVersion, pdwMDMinorVersion, pftMDHistoryTime, dwIndex);
	RELEASE_AND_RETURN2();
}

HRESULT CMetaInterface::RestoreHistory(
    IN LPCTSTR pszMDHistoryLocation,
    IN DWORD dwMDMajorVersion,
    IN DWORD dwMDMinorVersion,
    IN DWORD dwMDFlags
    )
{
    // dwMDFlags.  The flag is set to RESTORE_LATEST would signal the API that the Major and Minor version parameters
    // are to be ignored and the history file at the HistoryLocation with the largest Major (and corresponding
    // largest Minor version) should be restored.  If this flag is specified, the dwMDMajorVersion, dwMDMinorVersion
    // parameters must be set to 0 (zero).
    GET_TO_INTERFACE2();
    hr = pInterface2->RestoreHistory(pszMDHistoryLocation, dwMDMajorVersion, dwMDMinorVersion, dwMDFlags);
    RELEASE_AND_RETURN2();
}


HRESULT
CMetaInterface::GetChildPaths(
    METADATA_HANDLE hKey,
    LPCTSTR path,
    DWORD buf_size,
    WCHAR * pbuf,
    DWORD * preq_size
    )
{
    GET_TO_INTERFACE3();
	hr = pInterface3->GetChildPaths(hKey, path, buf_size, pbuf, preq_size);
    RELEASE_AND_RETURN3();
}


//
// CWamInterface class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CWamInterface::CWamInterface(
    IN CComAuthInfo * pAuthInfo         OPTIONAL
    )
/*++

Routine Description:

    Construct and initialize the interface.

Arguments:

    CComAuthInfo * pAuthInfo   : Auth info.  NULL indicates the local computer.

Return Value:

    N/A

--*/
    : CIISInterface(pAuthInfo),
      m_pInterface(NULL),
      m_fSupportsPooledProc(FALSE)
{
    //
    // Initialize the interface
    //
    m_hrInterface = Create();
}



CWamInterface::CWamInterface(
    IN CWamInterface * pInterface
    )
/*++

Routine Description:

    Construct from existing interface (copy constructor)

Arguments:

    CWamInterface * pInterface  : Existing interface

Return Value:

    N/A

--*/
    : CIISInterface(&pInterface->m_auth, pInterface->m_hrInterface),
      m_pInterface(pInterface->m_pInterface),
      m_fSupportsPooledProc(FALSE)
{
    ASSERT_PTR(m_pInterface);
    m_pInterface->AddRef();
}



CWamInterface::~CWamInterface()
/*++

Routine Description:

    Destructor -- releases the interface.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    SAFE_RELEASE(m_pInterface);
}



/* protected */
HRESULT
CWamInterface::Create()
/*++

Routine Description:
    Create the interface with DCOM

Arguments:
    None

Return Value:
    HRESULT

Notes:
    First, it will attempt to create the new interface, if it
    fails, it will attempt to create the downlevel interface

--*/
{
    CLSID rgCLSID[2];
    IID   rgIID[2];

    rgCLSID[1] = rgCLSID[0] = CLSID_WamAdmin;
    rgIID[0] = IID_IWamAdmin2;
    rgIID[1] = IID_IWamAdmin;

    ASSERT(ARRAY_SIZE(rgCLSID) == ARRAY_SIZE(rgIID));
    int cInterfaces = ARRAY_SIZE(rgCLSID);
    int iInterface;

    HRESULT hr = CIISInterface::Create(
        cInterfaces,
        rgIID,
        rgCLSID,
        &iInterface,
        (IUnknown **)&m_pInterface
        );

    if (SUCCEEDED(hr))
    {
        //
        // Only supported on IWamAdmin2
        //
        m_fSupportsPooledProc = (rgIID[iInterface] == IID_IWamAdmin2);
    }

    return hr;
}



HRESULT
CWamInterface::AppCreate(
    IN LPCTSTR szMDPath,
    IN DWORD   dwAppProtection
    )
/*++

Routine Description:

    Create  application

Arguments:

    LPCTSTR szMDPath      : Metabase path
    DWORD dwAppProtection : APP_INPROC     to create in-proc app
                            APP_OUTOFPROC  to create out-of-proc app
                            APP_POOLEDPROC to create a pooled-proc app

Return Value:

    HRESULT (ERROR_INVALID_PARAMETER if unsupported protection state is requested)

--*/
{
    if (m_fSupportsPooledProc)
    {
        //
        // Interface pointer is really IWamAdmin2, so call the new method
        //
        return ((IWamAdmin2 *)m_pInterface)->AppCreate2(szMDPath, dwAppProtection);
    }

    //
    // Call the downlevel API
    //
    if (dwAppProtection == APP_INPROC || dwAppProtection == APP_OUTOFPROC)
    {
        BOOL fInProc = (dwAppProtection == APP_INPROC);

        ASSERT_PTR(m_pInterface);
		ASSURE_PROPER_INTERFACE();
		return m_pInterface->AppCreate(szMDPath, fInProc);
    }

    return CError(ERROR_INVALID_PARAMETER);
}

#define GET_TO_INTERFACE()\
    IIISApplicationAdmin * pAppAdmin = NULL;\
	HRESULT hr = GetAppAdminInterface(&pAppAdmin);\
	if (SUCCEEDED(hr)) {

#define RELEASE_AND_RETURN()\
        if (pAppAdmin != NULL)\
			pAppAdmin->Release();\
    }\
	return hr\

HRESULT
CWamInterface::GetAppAdminInterface(IIISApplicationAdmin ** pp)
{
	HRESULT hr = S_OK;
	IIISApplicationAdmin * p = NULL;
	if (pp == NULL)
    {
		return E_POINTER;
    }
	if (m_auth.UsesImpersonation())
	{
		IUnknown * punk = NULL;
		hr = m_pInterface->QueryInterface(__uuidof(IUnknown), (void **)&punk);
		if (SUCCEEDED(hr))
		{
			if (SUCCEEDED(hr = m_auth.ApplyProxyBlanket(punk)))
			{
				if (SUCCEEDED(hr = punk->QueryInterface(IID_IIISApplicationAdmin, (void **)&p)))
				{
					if (p != NULL)
					{
						hr = m_auth.ApplyProxyBlanket(p);
						if (SUCCEEDED(hr))
						{
							*pp = p;
						}
					}
				}
			}
		}
		if (punk != NULL)
        {
			punk->Release();
        }
    }
	else
	{
        if (m_pInterface)
        {
		    hr = m_pInterface->QueryInterface(IID_IIISApplicationAdmin, (void **)pp);
        }
        else
        {
            hr = E_NOINTERFACE;
        }
	}
	return hr;
}

HRESULT
CWamInterface::CreateApplication(
    LPCWSTR szMDPath,
    DWORD dwAppMode,
    LPCWSTR szAppPoolId,
    BOOL fCreatePool
    )
{
	GET_TO_INTERFACE();
    hr = pAppAdmin->CreateApplication(
            szMDPath, dwAppMode, szAppPoolId, fCreatePool);
	RELEASE_AND_RETURN();
}

HRESULT
CWamInterface::DeleteApplication(LPCWSTR szMDPath, BOOL fRecursive)
{
	GET_TO_INTERFACE();
    hr = pAppAdmin->DeleteApplication(szMDPath, fRecursive);
	RELEASE_AND_RETURN();
}

HRESULT
CWamInterface::CreateApplicationPool(LPCWSTR szMDPath)
{
	GET_TO_INTERFACE();
    hr = pAppAdmin->CreateApplicationPool(szMDPath);
	RELEASE_AND_RETURN();
}

HRESULT
CWamInterface::DeleteApplicationPool(LPCWSTR szMDPath)
{
	GET_TO_INTERFACE();
    hr = pAppAdmin->DeleteApplicationPool(szMDPath);
	RELEASE_AND_RETURN();
}

HRESULT
CWamInterface::RecycleApplicationPool(LPCWSTR szMDPath)
{
	GET_TO_INTERFACE();
	hr = pAppAdmin->RecycleApplicationPool(szMDPath);
	RELEASE_AND_RETURN();
}

HRESULT
CWamInterface::EnumerateApplicationsInPool(LPCTSTR szMDPath, BSTR * pbstr)
{
	GET_TO_INTERFACE();
	hr = pAppAdmin->EnumerateApplicationsInPool(szMDPath, pbstr);
	RELEASE_AND_RETURN();
}

HRESULT CWamInterface::GetProcessMode(DWORD * pdwMode)
{
	GET_TO_INTERFACE();
    if (pAppAdmin)
    {
        hr = pAppAdmin->GetProcessMode(pdwMode);
    }
	RELEASE_AND_RETURN();
}



//
// CMetaback Class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


const LPCTSTR CMetaBack::s_szMasterAppRoot =\
    SZ_MBN_SEP_STR SZ_MBN_MACHINE SZ_MBN_SEP_STR SZ_MBN_WEB;


CMetaBack::CMetaBack(
    IN CComAuthInfo * pAuthInfo        OPTIONAL
    )
/*++

Routine Description:

    Constructor for metabase backup/restore operations class.  This object
    is both a WAM interface and a METABASE interface.

Arguments:

    CComAuthInfo * pAuthInfo    : Auth info.  NULL indicates the local computer.

Return Value:

    N/A

--*/
    : m_dwIndex(0),
      CMetaInterface(pAuthInfo),
      CWamInterface(pAuthInfo)
{
}

/* virtual */
BOOL
CMetaBack::Succeeded() const
/*++

Routine Description:

    Determine if object was constructed successfully.

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
	BOOL bRet = FALSE;

	bRet = CMetaInterface::Succeeded();
	if (TRUE == bRet)
	{
		bRet = CWamInterface::Succeeded();
		if (FALSE == bRet)
		{
			HRESULT hr = CWamInterface::QueryResult();
			if (REGDB_E_CLASSNOTREG == hr)
			{
				// could mean that only FTP is installed and WAM is not available.
				// just return success...
				bRet = TRUE;
			}
		}
	}
    return bRet;
}


/* virtual */
HRESULT
CMetaBack::QueryResult() const
/*++

Routine Description:

    Return the construction error for this object

Arguments:

    None

Return Value:

    HRESULT from construction errors

--*/
{
    //
    // Both interfaces must have constructed successfully
    //
    HRESULT hr = CMetaInterface::QueryResult();

    if (SUCCEEDED(hr))
    {
        hr = CWamInterface::QueryResult();
		if (REGDB_E_CLASSNOTREG == hr)
		{
			// could mean that only FTP is installed and WAM is not available.
			// just return success...
			hr = S_OK;
		}
    }

    return hr;
}

HRESULT
CMetaBack::Restore(
    IN LPCTSTR lpszLocation,
    IN DWORD dwVersion
    )
/*++

Routine Description:

    Restore metabase

Arguments:

    DWORD dwVersion         : Backup version
    LPCTSTR lpszLocation    : Backup location

Return Value:

    HRESULT

--*/
{
	HRESULT hr = S_OK;
    //
    // Backup and restore the application information from a restore
    //
    CString strPath(s_szMasterAppRoot);
	BOOL bDoesWamInterfaceExist = (REGDB_E_CLASSNOTREG != CWamInterface::QueryResult());

	// Check if there is a WAM interface 1st...
	// could mean that only FTP is installed and WAM is not available.
	if (bDoesWamInterfaceExist)
	{
		// could mean that only FTP is installed and WAM is not available.
		// just return success...
		hr = AppDeleteRecoverable(strPath, TRUE);
	}
    if (SUCCEEDED(hr))
    {
        hr = CMetaInterface::Restore(lpszLocation, dwVersion, 0);

        if (SUCCEEDED(hr))
        {
			if (bDoesWamInterfaceExist)
			{
				hr = AppRecover(strPath, TRUE);
			}
        }
    }

    return hr;
}


HRESULT
CMetaBack::BackupWithPassword(
    IN LPCTSTR lpszLocation,
	IN LPCTSTR lpszPassword
    )
{
    return CMetaInterface::BackupWithPassword(
        lpszLocation,
        MD_BACKUP_NEXT_VERSION,
        MD_BACKUP_SAVE_FIRST,
		lpszPassword
        );
}

HRESULT
CMetaBack::RestoreWithPassword(
    IN LPCTSTR lpszLocation,
    IN DWORD dwVersion,
    IN LPCTSTR lpszPassword
    )
/*++

Routine Description:

    Restore metabase

Arguments:

    DWORD dwVersion         : Backup version
    LPCTSTR lpszLocation    : Backup location
    LPCTSTR lpszPassword    : Backup password

Return Value:

    HRESULT

--*/
{
    //
    // Backup and restore the application information from a restore
    //
   // BUGBUG: clear it out, why we had an error "parameter is incorrect" from AppDeleteRecoverable
    CString strPath(s_szMasterAppRoot);
    HRESULT hr;// = AppDeleteRecoverable(strPath, TRUE);

//    if (SUCCEEDED(hr))
//    {
        hr = CMetaInterface::RestoreWithPassword(lpszLocation, dwVersion, 0, lpszPassword);

//        if (SUCCEEDED(hr))
//        {
//            hr = AppRecover(strPath, TRUE);
//        }
//    }

    return hr;
}


//
// CIISSvcControl class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CIISSvcControl::CIISSvcControl(
    IN CComAuthInfo * pAuthInfo        OPTIONAL
    )
/*++

Routine Description:

    Construct and initialize the interface.

Arguments:

    CComAuthInfo * pAuthInfo    : Auth info.  NULL indicates the local computer.

Return Value:

    N/A

--*/
    : CIISInterface(pAuthInfo),
      m_pInterface(NULL)
{
    //
    // Initialize the interface
    //
    m_hrInterface = Create();
}



CIISSvcControl::CIISSvcControl(
    IN CIISSvcControl * pInterface
    )
/*++

Routine Description:

    Construct from existing interface (copy constructor)

Arguments:

    CIISSvcControl * pInterface  : Existing interface

Return Value:

    N/A

--*/
    : CIISInterface(&pInterface->m_auth, pInterface->m_hrInterface),
      m_pInterface(pInterface->m_pInterface)
{
    ASSERT_PTR(m_pInterface);
    m_pInterface->AddRef();
}



CIISSvcControl::~CIISSvcControl()
/*++

Routine Description:

    Destructor -- releases the interface.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    SAFE_RELEASE(m_pInterface);
}



//
// CMetaEnumerator Clas
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CMetaEnumerator::CMetaEnumerator(
    IN CComAuthInfo * pAuthInfo     OPTIONAL,
    IN LPCTSTR lpszMDPath           OPTIONAL,
    IN METADATA_HANDLE hkBase       OPTIONAL
    )
/*++

Routine Description:

    Metabase enumerator constructor.  This constructor creates a new interface
    and opens a key.

Arguments:

    CComAuthInfo * pAuthInfo : Auth info.  NULL indicates the local computer.
    LPCTSTR lpszMDPath       : Metabase path
    METADATA_HANDLE hkBase   : Metabase handle

Return Value:

    N/A

--*/
    : CMetaKey(pAuthInfo, lpszMDPath, METADATA_PERMISSION_READ, hkBase),
      m_dwIndex(0L)
{
}



CMetaEnumerator::CMetaEnumerator(
    IN CMetaInterface * pInterface,
    IN LPCTSTR lpszMDPath,                  OPTIONAL
    IN METADATA_HANDLE hkBase               OPTIONAL
    )
/*++

Routine Description:

    Metabase enumerator constructor.  This constructor uses an existing
    interface and opens a key.

Arguments:

    CMetaInterface * pInterface : Existing interface
    LPCTSTR lpszMDPath          : Metabase path
    METADATA_HANDLE hkBase      : Metabase handle

Return Value:

    N/A

--*/
    : CMetaKey(pInterface, lpszMDPath, METADATA_PERMISSION_READ, hkBase),
      m_dwIndex(0L)
{
}



CMetaEnumerator::CMetaEnumerator(
    IN BOOL fOwnKey,
    IN CMetaKey * pKey
    )
/*++

Routine Description:

    Metabase enumerator constructor.  This constructor uses an existing
    interface and open key.

Arguments:

    BOOL fOwnKey            : TRUE if we own the key (destructor will close)
    CMetaKey * pKey         : Open key

Return Value:

    N/A

--*/
    : CMetaKey(fOwnKey, pKey),
      m_dwIndex(0L)
{
}



HRESULT
CMetaEnumerator::Next(
    OUT CString & strKey,
    IN  LPCTSTR lpszMDPath      OPTIONAL
    )
/*++

Routine Description:

    Get the next subkey

Arguments:

    CString & str           Returns keyname
    LPCTSTR lpszMDPath      Optional subpath

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    LPTSTR lpKey = strKey.GetBuffer(MAX_PATH);
    HRESULT hr = EnumKeys(m_hKey, lpszMDPath, lpKey, m_dwIndex++);
    strKey.ReleaseBuffer();

    return hr;
}



HRESULT
CMetaEnumerator::Next(
    OUT DWORD & dwKey,
    OUT CString & strKey,
    IN  LPCTSTR lpszMDPath      OPTIONAL
    )
/*++

Routine Description:

    Get the next subkey as a DWORD.  This skips non-numeric
    keynames (including 0) until the first numeric key name

Arguments:

    DWORD & dwKey           Numeric key
    CString & strKey        Same key in string format
    LPCTSTR lpszMDPath      Optional subpath

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    HRESULT hr = S_OK;
    BOOL fContinue = TRUE;

    while (fContinue)
    {
        fContinue = FALSE;

        LPTSTR lpKey = strKey.GetBuffer(MAX_PATH);
        hr = EnumKeys(m_hKey, lpszMDPath, lpKey, m_dwIndex++);
        strKey.ReleaseBuffer();

        if (SUCCEEDED(hr))
        {
            if (FALSE == (dwKey = _ttoi((LPCTSTR)strKey)))
            {
                //
                // Ignore this one
                //
                fContinue = TRUE;
            }
        }
    }

    return hr;
}



//
// CIISApplication class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<</



CIISApplication::CIISApplication(
    IN CComAuthInfo * pAuthInfo   OPTIONAL,
    IN LPCTSTR lpszMetapath
    )
/*++

Routine Description:

    Construct IIS application.

Arguments:

    CComAuthInfo * pAuthInfo : Authentication info.  NULL indicates the
                               local computer.
    LPCTSTR lpszMetapath     : Metabase path

Return Value:

    N/A

--*/
    : CWamInterface(pAuthInfo),
      CMetaKey(pAuthInfo),
      m_dwProcessProtection(APP_INPROC),
      m_dwAppState(APPSTATUS_NOTDEFINED),
      m_strFriendlyName(),
      m_strAppRoot(),
      m_strWamPath(lpszMetapath)
{
    CommonConstruct();
}



void
CIISApplication::CommonConstruct()
/*++

Routine Description:

    Perform common construction

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Munge the metapath so that WAM doesn't cough up a hairball.
    //


    //
    // BUGBUG: CleanMetaPath() disabled currently
    //

    if (m_strWamPath[0] != SZ_MBN_SEP_CHAR)
    {
        m_strWamPath = SZ_MBN_SEP_CHAR + m_strWamPath;
    }

    do
    {
        m_hrApp = CWamInterface::QueryResult();

        if (FAILED(m_hrApp))
        {
            break;
        }

        m_hrApp = RefreshAppState();

        if (HRESULT_CODE(m_hrApp) == ERROR_PATH_NOT_FOUND)
        {
            //
            // "Path Not Found" errors are acceptable, since
            // the application may not yet exist.
            //
            m_hrApp = S_OK;
        }
    }
    while(FALSE);
}



/* virtual */
BOOL
CIISApplication::Succeeded() const
/*++

Routine Description:

    Determine if object was constructed successfully

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    return CMetaInterface::Succeeded()
        && CWamInterface::Succeeded()
        && SUCCEEDED(m_hrApp);
}



/* virtual */
HRESULT
CIISApplication::QueryResult() const
/*++

Routine Description:

    Return the construction error for this object

Arguments:

    None

Return Value:

    HRESULT from construction errors

--*/
{
    //
    // Both interfaces must have constructed successfully
    //
    HRESULT hr = CMetaInterface::QueryResult();

    if (SUCCEEDED(hr))
    {
        hr = CWamInterface::QueryResult();

        if (SUCCEEDED(hr))
        {
            hr = m_hrApp;
        }
    }

    return hr;
}



HRESULT
CIISApplication::RefreshAppState()
/*++

Routine Description:

    Refresh the application state

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ASSERT(!m_strWamPath.IsEmpty());

    HRESULT hr, hrKeys;

    hr = AppGetStatus(m_strWamPath, &m_dwAppState);

    if (FAILED(hr))
    {
        m_dwAppState = APPSTATUS_NOTDEFINED;
    }

    m_strAppRoot.Empty();
    hrKeys = QueryValue(MD_APP_ROOT, m_strAppRoot, NULL, m_strWamPath);

    m_dwProcessProtection = APP_INPROC;
    hrKeys = QueryValue(
        MD_APP_ISOLATED,
        m_dwProcessProtection,
        NULL,
        m_strWamPath
        );

    hrKeys = QueryValue(
        MD_APP_APPPOOL_ID,
        m_strAppPoolId,
        NULL,
        m_strWamPath
        );

    m_strFriendlyName.Empty();
    hrKeys = QueryValue(
        MD_APP_FRIENDLY_NAME,
        m_strFriendlyName,
        NULL,
        m_strWamPath
        );

    return hr;
}



HRESULT
CIISApplication::Create(
    IN LPCTSTR lpszName,        OPTIONAL
    IN DWORD dwAppProtection
    )
/*++

Routine Description:

    Create the application

Arguments:

    LPCTSTR lpszName      : Application name
    DWORD dwAppProtection : APP_INPROC     to create in-proc app
                            APP_OUTOFPROC  to create out-of-proc app
                            APP_POOLEDPROC to create a pooled-proc app

Return Value:

    HRESULT

--*/
{
    ASSERT(!m_strWamPath.IsEmpty());
    HRESULT hr = AppCreate(m_strWamPath, dwAppProtection);

    if (SUCCEEDED(hr))
    {
        //
        // Write the friendly app name, which we maintain
        // ourselves.  Empty it first, because we might
        // have picked up a name from inheritance.
        //
        m_strFriendlyName.Empty();
        hr = WriteFriendlyName(lpszName);

        RefreshAppState();
    }

    return hr;
}

HRESULT
CIISApplication::CreatePooled(
	LPCTSTR name,
	DWORD mode,
	LPCTSTR pool_id,
	BOOL fCreatePool)
{
    ASSERT(!m_strWamPath.IsEmpty());
	ASSERT(NULL != pool_id);
	HRESULT hr = CreateApplication(m_strWamPath, mode, pool_id, fCreatePool);
	if (SUCCEEDED(hr))
	{
        m_strFriendlyName.Empty();
        hr = WriteFriendlyName(name);
        RefreshAppState();
	}
	return hr;
}

HRESULT
CIISApplication::WriteFriendlyName(
    IN LPCTSTR lpszName
    )
/*++

Routine Description:

    Write the friendly name.  This will not write anything
    if the name is the same as it was

Arguments:

    LPCTSTR lpszName        : New friendly name

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    if (m_strFriendlyName.CompareNoCase(lpszName) != 0)
    {
        hr = Open(METADATA_PERMISSION_WRITE, m_strWamPath);

        if (SUCCEEDED(hr))
        {
            ASSERT_PTR(lpszName);

            CString str(lpszName);
            hr = SetValue(MD_APP_FRIENDLY_NAME, str);
            Close();

            if (SUCCEEDED(hr))
            {
                m_strFriendlyName = lpszName;
            }
        }
    }

    return hr;
}

HRESULT
CIISApplication::WritePoolId(LPCTSTR id)
{
    HRESULT hr = S_OK;

    if (m_strAppPoolId.CompareNoCase(id) != 0)
    {
        hr = Open(METADATA_PERMISSION_WRITE, m_strWamPath);

        if (SUCCEEDED(hr))
        {
            ASSERT_PTR(id);

            CString str(id);
            hr = SetValue(MD_APP_APPPOOL_ID, str);
            Close();

            if (SUCCEEDED(hr))
            {
                m_strAppPoolId = id;
            }
        }
    }
    return hr;
}

/////////////////////////////////////////////////////////
// CIISAppPool class

CIISAppPool::CIISAppPool(
    IN CComAuthInfo * pAuthInfo   OPTIONAL,
    IN LPCTSTR lpszMetapath
    )
/*++

Routine Description:

    Construct IIS application pool.

Arguments:

    CComAuthInfo * pAuthInfo : Authentication info.  NULL indicates the
                               local computer.
    LPCTSTR lpszMetapath     : Metabase path

Return Value:

    N/A

--*/
    : CWamInterface(pAuthInfo),
      CMetaKey(pAuthInfo),
      m_dwPoolState(0),
      m_strWamPath(lpszMetapath)
{
    if (m_strWamPath[0] != SZ_MBN_SEP_CHAR)
    {
        m_strWamPath = SZ_MBN_SEP_CHAR + m_strWamPath;
    }

    do
    {
        if (FAILED(m_hrPool = CWamInterface::QueryResult()))
        {
            break;
        }
        if (MD_ERROR_DATA_NOT_FOUND == (m_hrPool = RefreshState())
            || HRESULT_CODE(m_hrPool) == ERROR_PATH_NOT_FOUND)
        {
            //
            // "Path Not Found" errors are acceptable, since
            // the pool may not yet exist.
            //
            m_hrPool = S_OK;
        }
    }
    while(FALSE);
}

HRESULT
CIISAppPool::RefreshState()
{
    ASSERT(!m_strWamPath.IsEmpty());

    HRESULT hr;

    hr = QueryValue(
        MD_APP_APPPOOL_ID,
        m_strAppPoolId,
        NULL,
        m_strWamPath
        );

    return hr;
}

/* virtual */
HRESULT
CIISAppPool::QueryResult() const
/*++

Routine Description:

    Return the construction error for this object

Arguments:

    None

Return Value:

    HRESULT from construction errors

--*/
{
    //
    // Both interfaces must have constructed successfully
    //
    HRESULT hr = CMetaInterface::QueryResult();

    if (SUCCEEDED(hr))
    {
        hr = CWamInterface::QueryResult();

        if (SUCCEEDED(hr))
        {
            hr = m_hrPool;
        }
    }

    return hr;
}

/* virtual */
BOOL
CIISAppPool::Succeeded() const
/*++

Routine Description:

    Determine if object was constructed successfully

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    return CMetaInterface::Succeeded()
        && CWamInterface::Succeeded()
        && SUCCEEDED(m_hrPool);
}

HRESULT
CIISAppPool::EnumerateApplications(CStringListEx& apps)
{
    CString pool;
    BSTR bstr = NULL;

    CMetabasePath::GetLastNodeName(m_strWamPath, pool);
    CError err = CWamInterface::EnumerateApplicationsInPool(
        pool, &bstr);
    if (err.Succeeded())
    {
        ConvertDoubleNullListToStringList(bstr, apps);
    }
#ifdef _DEBUG
    err.MessageBoxOnFailure();
#endif
    SysFreeString(bstr);
    return err;
}

HRESULT
CIISAppPool::Create(LPCTSTR name)
{
    CString id;
    if (name != NULL)
    {
        id = name;
    }
    else
    {
        CMetabasePath::GetLastNodeName(m_strWamPath, id);
    }
    CError err = CWamInterface::CreateApplicationPool(id);

    return err;
}

HRESULT
CIISAppPool::Delete(LPCTSTR id)
{
    CError err = CWamInterface::DeleteApplicationPool(id);

    return err;
}

HRESULT
CIISAppPool::Recycle(LPCTSTR id)
{
    CError err = CWamInterface::RecycleApplicationPool(id);

    return err;
}

HRESULT
CIISAppPool::GetProcessMode(DWORD * pdwMode)
{
    CError err = CWamInterface::GetProcessMode(pdwMode);
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\msg.cpp ===
/*++

   Copyright    (c)    1994-2002    Microsoft Corporation

   Module  Name :
        msg.cpp

   Abstract:
        Message Functions

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/

#include "stdafx.h"
#include <lmerr.h>
#include <lmcons.h>
#include <winsock2.h>
#include "common.h"
#include <pudebug.h>

//
// Needed for appsrv facility code.
//
//#include "webcluserr.h"


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


#define new DEBUG_NEW


extern HINSTANCE hDLLInstance;



#ifdef _MT

    //
    // Thread protected stuff
    //
    #define RaiseThreadProtection() \
        do {\
            EnterCriticalSection(&_csSect);\
        } while(0)
    #define LowerThreadProtection() \
        do {\
            LeaveCriticalSection(&_csSect);\
        } while (0)

    static CRITICAL_SECTION _csSect;

#else

    #pragma message("Module is not thread-safe.")

    #define RaiseThreadProtection()
    #define LowerThreadProtection()

#endif // _MT




BOOL
InitErrorFunctionality()
/*++

Routine Description:

    Initialize CError class, and allocate static objects

Arguments:

    None:

Return Value:

    TRUE for success, FALSE for failure

--*/
{
#ifdef _MT
    INITIALIZE_CRITICAL_SECTION(&_csSect);
#endif // _MT

    BOOL fOK = CError::AllocateStatics();

    return fOK;
}



void
TerminateErrorFunctionality()
/*++

Routine Description:

    De-initialize CError class, freeing up static objects

Arguments:

    None

Return Value:

    None

--*/
{
    CError::DeAllocateStatics();

#ifdef _MT
    DeleteCriticalSection(&_csSect);
#endif // _MT

}

//
// Static Initialization:
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

const TCHAR g_cszNull[] = _T("(Null)");
const TCHAR CError::s_chEscape = _T('%');        // Error text escape
const TCHAR CError::s_chEscText = _T('h');       // Escape code for text
const TCHAR CError::s_chEscNumber = _T('H');     // Escape code for error code
LPCTSTR CError::s_cszLMDLL = _T("netmsg.dll");   // LM Error File
LPCTSTR CError::s_cszWSDLL = _T("iisui.dll");   // Winsock error file
LPCTSTR CError::s_cszFacility[] = 
{
    /* FACILITY_NULL        */ NULL,
    /* FACILITY_RPC         */ NULL,
    /* FACILITY_DISPATCH    */ NULL,            
    /* FACILITY_STORAGE     */ NULL,
    /* FACILITY_ITF         */ NULL,
    /* FACILITY_DS          */ NULL,
    /* 6                    */ NULL,
    /* FACILITY_WIN32       */ NULL,
    /* FACILITY_WINDOWS     */ NULL,
    /* FACILITY_SSPI        */ NULL,
    /* FACILITY_CONTROL     */ NULL,
    /* FACILITY_CERT        */ NULL,
    /* FACILITY_INTERNET    */ _T("metadata.dll"),
    /* FACILITY_MEDIASERVER */ NULL,
    /* FACILITY_MSMQ        */ NULL,
    /* FACILITY_SETUPAPI    */ NULL,
    /* FACILITY_SCARD       */ NULL,
    /* 17 (MTX)             */ _T("iisui.dll"),
};

HRESULT CError::s_cdwMinLMErr = NERR_BASE; 
HRESULT CError::s_cdwMaxLMErr = MAX_NERR;
HRESULT CError::s_cdwMinWSErr = WSABASEERR;    
HRESULT CError::s_cdwMaxWSErr = WSABASEERR + 2000;    
DWORD   CError::s_cdwFacilities = (sizeof(CError::s_cszFacility)\
    / sizeof(CError::s_cszFacility[0]));

//
// Allocated objects (static MFC objects in a DLL are a no-no)
//
CString * CError::s_pstrDefError;
CString * CError::s_pstrDefSuccs;
CMapDWORDtoCString * CError::s_pmapFacilities;
BOOL CError::s_fAllocated = FALSE;



/* protected */
/* static */
BOOL
CError::AllocateStatics()
/*++

Routine Description:

    Allocate static objects

Arguments:

    None

Return Value:

    TRUE for successfull allocation, FALSE otherwise

--*/
{
    RaiseThreadProtection();

    if (!AreStaticsAllocated())
    {
        try
        {
            CError::s_pstrDefError   = new CString;
            CError::s_pstrDefSuccs   = new CString(_T("0x%08lx"));
            CError::s_pmapFacilities = new CMapDWORDtoCString;
            s_fAllocated = TRUE;

            LPTSTR lp = CError::s_pstrDefError->GetBuffer(255);
            
            if (!::LoadString(
                hDLLInstance,
                IDS_NO_MESSAGE,
                lp,
                255
                ))
            {
                //
                // Just in case we didn't load this message from the resources
                //
                ASSERT_MSG("Unable to load resource message");
                lstrcpy(lp, _T("Error Code: 0x%08lx"));
            }

            CError::s_pstrDefError->ReleaseBuffer();
        }
        catch(CMemoryException * e)
        {
            TRACEEOLID("Initialization Failed");
            e->ReportError();
            e->Delete();
        }
    }

    LowerThreadProtection();

    return AreStaticsAllocated();
}



/* protected */
/* static */
void
CError::DeAllocateStatics()
/*++

Routine Description:

    Clean up allocations

Arguments:

    N/A

Return Value:

    N/A

--*/
{

    RaiseThreadProtection();

    if (AreStaticsAllocated())
    {
        SAFE_DELETE(CError::s_pstrDefError);
        SAFE_DELETE(CError::s_pstrDefSuccs);
        SAFE_DELETE(CError::s_pmapFacilities);

        s_fAllocated = FALSE;
    }

    LowerThreadProtection();
}



/* static */
HRESULT 
CError::CvtToInternalFormat(
    IN HRESULT hrCode
    )
/*++

Routine Description:

    Convert WIN32 or HRESULT code to internal (HRESULT) format.

Arguments:

    DWORD dwCode        Error code

Return Value:

    HRESULT

Notes:

    HRESULTS are left as is.  Lanman and Winsock errors are converted
    to HRESULTS using private facility codes.

--*/
{
    if (IS_HRESULT(hrCode))
    {
        return hrCode;
    }

    if(hrCode >= s_cdwMinLMErr && hrCode <= s_cdwMaxLMErr)
    {
        return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_LANMAN, (DWORD)hrCode);
    }

    if (hrCode >= s_cdwMinWSErr && hrCode <= s_cdwMaxWSErr)
    {
        return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WINSOCK, (DWORD)hrCode);
    }

    return HResult(hrCode);    
}



/* static */ 
void 
CError::RegisterFacility(
    IN DWORD dwFacility,
    IN LPCSTR lpDLL         OPTIONAL
    )
/*++

Routine Description:

    Register a DLL for a given facility code.  Use NULL to unregister
    the DLL name.

Arguments:

    DWORD dwFacility : Facility code
    LPCSTR lpDLL     : DLL Name.

Return Value:

    None

--*/
{
    RaiseThreadProtection();

    ASSERT(AreStaticsAllocated());

    if (lpDLL == NULL)
    {
        //
        // Remove the facility
        //
        s_pmapFacilities->RemoveKey(dwFacility);
    }
    else
    {
        CString str(lpDLL);

        //
        // Register facility
        //
        s_pmapFacilities->SetAt(dwFacility, str);
    }

    LowerThreadProtection();
}


        
/* static */
LPCTSTR 
CError::FindFacility(
    IN DWORD dwFacility
    )
/*++

Routine Description:

    Determine if a DLL name has been registered for the given facility
    code.

Arguments:

    DWORD dwFacility        : Facility code

Return Value:

    Returns the DLL name, or NULL.

--*/
{
    RaiseThreadProtection();

    ASSERT(AreStaticsAllocated());

    LPCTSTR pRes = NULL;
    CString strDLL;

    if (s_pmapFacilities->Lookup(dwFacility, strDLL))
    {
        pRes = strDLL;
    }

    LowerThreadProtection();

    return pRes;
}



CError::~CError()
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    N/A

--*/
{
}



const CError & 
CError::Construct(
    IN HRESULT hr
    )
/*++

Routine Description:

    construct with new value.

Arguments:
    
    HRESULT hr : New value, either an HRESULT or a WIN32
                 error code.

Return Value:

    Reference to current object

--*/
{
    ASSERT(AreStaticsAllocated());

    m_hrCode = CvtToInternalFormat(hr);

    return *this;
}



const CError & 
CError::Construct(
    IN const CError & err
    )
/*++

Routine Description:

    Assign new value.

Arguments:
    
    CError & err    : Error code

Return Value:

    Reference to current object

--*/
{
    ASSERT(AreStaticsAllocated());

    m_hrCode = err.m_hrCode;

    return *this;
}



int
CError::MessageBox(
    HWND    hWnd,
    UINT    nType,
    UINT    nHelpContext
    ) const
/*++

Routine Description:

    Display error message in a message box

Arguments:

    HRESULT hrCode       : HRESULT error code
    UINT    nType        : See AfxMessageBox for documentation
    UINT    nHelpContext : See AfxMessageBox for documentation

Return Value:

    AfxMessageBox return code

--*/
{
    CString strMsg;

    nHelpContext;
    TextFromHRESULT(strMsg);

    //
    // Try to find the main window (hopefully an MFC app)
    //
    if (hWnd == NULL)
    {
        CWnd * pWnd = ::AfxGetMainWnd();
        if (pWnd)
        {
            hWnd = pWnd->m_hWnd;
        }
        nType |= MB_APPLMODAL;
    }
    return ::MessageBox(hWnd, strMsg, NULL, nType);
}




//
// Extend CString just to get at FormatV publically
//
class CStringEx : public CString
{
public:
    void FormatV(LPCTSTR lpszFormat, va_list argList)
    {
       LPTSTR p = GetBuffer(1024);
       VERIFY(-1 != _vsntprintf(p, 1024, lpszFormat, argList));
       ReleaseBuffer(-1);
    }
};



int 
CError::MessageBoxFormat(
    HWND hWnd,
    UINT nFmt,
    UINT nType,
    UINT nHelpContext,
    ...
    ) const
/*++

Routine Description:

    Display formatted error message in messagebox.  The format
    string (given as a resource ID) is a normal printf-style
    string, with the additional parameter of %h, which takes
    the text equivalent of the error message, or %H, which takes
    the error return code itself.

Arguments:

    UINT    nFmt         : Resource format
    UINT    nType        : See AfxMessageBox for documentation
    UINT    nHelpContext : See AfxMessageBox for documentation
    ...                    More as needed for sprintf

Return Value:

    AfxMessageBox return code
    
--*/
{
    CString strFmt;
    CStringEx strMsg;

    strFmt.LoadString(nFmt);

    //
    // First expand the error
    //
    TextFromHRESULTExpand(strFmt);

    va_list marker;
    va_start(marker, nHelpContext);
    strMsg.FormatV(strFmt, marker);
    va_end(marker);

    if (hWnd == NULL)
    {
        CWnd * pWnd = ::AfxGetMainWnd();
        if (pWnd)
        {
            hWnd = pWnd->m_hWnd;
        }
        nType |= MB_APPLMODAL;
    }
    return ::MessageBox(hWnd, strMsg, NULL, nType);
}


BOOL 
CError::MessageBoxOnFailure(
    HWND hWnd,
    UINT nType,
    UINT nHelpContext
    ) const
/*++

Routine Description:

    Display message box if the current error is a failure
    condition, else do nothing

Arguments:

    UINT    nType        : See AfxMessageBox for documentation
    UINT    nHelpContext : See AfxMessageBox for documentation

Return Value:

    TRUE if a messagebox was shown, FALSE otherwise

--*/
{
    if (Failed())
    {
        MessageBox(hWnd, nType, nHelpContext);
        return TRUE;
    }
    return FALSE;
}



BOOL 
CError::HasOverride(
    UINT * pnMessage        OPTIONAL
    ) const
/*++

Routine Description:

    Check to see if a given HRESULT has an override

Arguments:

    HRESULT hrCode              : HRESULT to check for
    UINT * pnMessage            : Optionally returns the override

Return Value:

    TRUE if there is an override, FALSE if there is not.

--*/
{
    ASSERT(AreStaticsAllocated());

    UINT nID;
    HRESULT hrCode = CvtToInternalFormat(m_hrCode);
    BOOL fResult = mapOverrides.Lookup(hrCode, nID);

    if (fResult && pnMessage != NULL)
    {
        *pnMessage = nID;
    }

    return fResult;
}



UINT
CError::AddOverride(
    HRESULT    hrCode,
    UINT       nMessage
    )
/*++

Routine Description:

    Add an override for a specific HRESULT.

Arguments:

    HRESULT    hrCode       : HRESULT to override
    UINT       nMessage     : New message, or -1 to remove override

Return Value:

    The previous override, or -1

--*/
{
    ASSERT(AreStaticsAllocated());

    UINT nPrev;
    hrCode = CvtToInternalFormat(hrCode);

    //
    // Fetch the current override
    //
    if (!mapOverrides.Lookup(hrCode, nPrev))
    {
        //
        // Didn't exist
        //
        nPrev = REMOVE_OVERRIDE;
    }

    if (nMessage == REMOVE_OVERRIDE)
    {
        //
        // Remove the override
        //
        mapOverrides.RemoveKey(hrCode);
    }
    else
    {
        //
        // Set new override
        //
        mapOverrides.SetAt(hrCode, nMessage);
    }

    return nPrev;
}



void
CError::RemoveAllOverrides()
/*++

Routine Description:

    Remove all overrides

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT(AreStaticsAllocated());
    mapOverrides.RemoveAll();
}



HRESULT
CError::TextFromHRESULT(
    LPTSTR  szBuffer,
    DWORD   cchBuffer
    ) const
/*++

Routine Description:

    Get text from the given HRESULT.  Based on the range that the HRESULT
    falls in and the facility code, find the location of the message,
    and fetch it.

Arguments:

    HRESULT hrCode      HRESULT or (DWORD WIN32 error) whose message to get
    LPTSTR  szBuffer    Buffer to load message text into
    DWORD   cchBuffer   Size of buffer in characters.

Return Value:

    HRESULT error code depending on whether the message was
    found.  If the message was not found, some generic message
    is synthesized in the buffer if a buffer is provided.

    ERROR_FILE_NOT_FOUND        No message found
    ERROR_INSUFFICIENT_BUFFER   Buffer is a NULL pointer or too small

--*/
{
    HRESULT hrReturn = ERROR_SUCCESS;

    //
    // First check to see if this message is overridden
    //
    UINT nID;
    HRESULT hrCode = m_hrCode;

    if (HasOverride(&nID))
    {
        //
        // Message overridden.  Load replacement message
        // instead.
        //
        BOOL fSuccess;

        //
        // Attempt to load from calling process first
        //
//        if (FALSE == (fSuccess = ::LoadString(
//                           ::GetModuleHandle(NULL), nID, szBuffer, cchBuffer)))
		CString str;
        if (FALSE == (fSuccess = str.LoadString(nID)))
        {
            //
            // Try this dll
            //
//            fSuccess = ::LoadString(hDLLInstance, nID, szBuffer, cchBuffer);
        }

        if (fSuccess)
        {
			lstrcpyn(szBuffer, str, cchBuffer);
            return hrReturn;
        }

        //
        // Message didn't exist, skip the override, and 
        // load as normal.
        //
        TRACEEOLID("Couldn't load " << nID);
        ASSERT_MSG("Attempted override failed");
    }

    LPCTSTR lpDll    = NULL;
    HINSTANCE hDll   = NULL;
    DWORD dwFacility = HRESULT_FACILITY(hrCode);
//    DWORD dwSeverity = HRESULT_SEVERITY(hrCode);
    DWORD dwCode     = HRESULT_CODE(hrCode);
    BOOL  fSuccess   = Succeeded(hrCode);

    //
    // Strip off meaningless internal facility codes
    //
    if (dwFacility == FACILITY_LANMAN || dwFacility == FACILITY_WINSOCK)
    {
        dwFacility = FACILITY_NULL;
        hrCode   = (HRESULT)dwCode;
    }

    DWORD dwFlags = FORMAT_MESSAGE_IGNORE_INSERTS | 
                    FORMAT_MESSAGE_MAX_WIDTH_MASK;

    //
    // Since we allow both HRESULTS and WIN32 codes to be
    // used here, we can't rely on the private FACILITY code 
    // for lanman and winsock.
    //
    if(hrCode >= s_cdwMinLMErr && hrCode <= s_cdwMaxLMErr)
    {
        //
        // Lanman error
        //
        lpDll = s_cszLMDLL;
    }
    else if (hrCode >= s_cdwMinWSErr && hrCode <= s_cdwMaxWSErr)
    {
        //
        // Winsock error
        //
        lpDll = s_cszWSDLL;
    }
    else
    {
        //
        // Attempt to determine message location from facility code.
        // Check for registered facility first.
        //
        lpDll = FindFacility(dwFacility);

        if (lpDll == NULL)
        {
            if (dwFacility < s_cdwFacilities)
            {
                lpDll = s_cszFacility[dwFacility];
            }
            else
            {
                ASSERT_MSG("Bogus FACILITY code encountered.");
                lpDll = NULL;
            }
        }
    }

    do
    {
        if (szBuffer == NULL || cchBuffer <= 0)
        {
            hrReturn = HResult(ERROR_INSUFFICIENT_BUFFER);
            break;
        }

        if (lpDll)
        {
            //
            // Load message file
            //
            hDll = ::LoadLibraryEx(
                lpDll,
                NULL,
                LOAD_LIBRARY_AS_DATAFILE
                );

            if (hDll == NULL)
            {
                hrReturn = ::GetLastHRESULT();
                break;
            }

            dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
        }
        else
        {
            dwFlags |= FORMAT_MESSAGE_FROM_SYSTEM;
        }

        DWORD dwResult = 0L;
        DWORD dwID = hrCode;
        HINSTANCE hSource = hDll;

        while(!dwResult)
        {
            dwResult = ::FormatMessage(
                dwFlags,
                (LPVOID)hSource,
                dwID,
                0,
                szBuffer,
                cchBuffer,
                NULL
                );

            if (dwResult > 0)
            {
                //
                // Successfully got a message
                //
                hrReturn = ERROR_SUCCESS;
                break;
            } 

            hrReturn = ::GetLastHRESULT();
    
            if (dwID != dwCode && !fSuccess)
            {
                //
                // Try the SCODE portion of the error from win32
                // if this is an error message
                //
                dwID = dwCode;
                hSource = NULL;
                continue;
            }

            //
            // Failed to obtain a message
            //
            hrReturn = HResult(ERROR_FILE_NOT_FOUND);
            break;
        }
    }
    while(FALSE);

    if(hDll != NULL)
    {
        ::FreeLibrary(hDll);
    }

    if (Failed(hrReturn))
    {
        //
        // Unable to find the message, synthesize something with
        // the code in it if there's room (+8 for the number)
        //
        CString & strMsg = (fSuccess ? *s_pstrDefSuccs : *s_pstrDefError);

        if (cchBuffer > (DWORD)strMsg.GetLength() + 8)
        {
            TRACEEOLID("Substituting default message for " << (DWORD)m_hrCode);
            wsprintf(szBuffer, (LPCTSTR)strMsg, m_hrCode);
        }
        else
        {
            //
            // Not enough room for message code
            //
            ASSERT_MSG("Buffer too small for default message -- left blank");
            *szBuffer = _T('\0');
        }
    }

    return hrReturn;
}



HRESULT 
CError::TextFromHRESULT(
    CString & strBuffer
    ) const
/*++

Routine Description:

    Similar to the function above, but use a CString

Arguments:

    HRESULT hrCode         HRESULT or (DWORD WIN32 error) whose message to get
    CString & strBuffer    Buffer to load message text into

Return Value:

    HRESULT error code depending on whether the message was
    found.  If the message was not found, some generic message
    is synthesized in the buffer if a buffer is provided.

    ERROR_FILE_NOT_FOUND   No message found

--*/
{
    DWORD cchBuffer = 512;
    HRESULT hr = S_OK;

    for (;;)
    {
        LPTSTR szBuffer = strBuffer.GetBuffer(cchBuffer + 1);

        if (szBuffer == NULL)
        {
            return HResult(ERROR_NOT_ENOUGH_MEMORY);
        }

        hr = TextFromHRESULT(szBuffer, cchBuffer);

        if (Win32Error(hr) != ERROR_INSUFFICIENT_BUFFER)
        {
            //
            // Done!
            //
            break;
        }

        //
        // Insufficient buffer, enlarge and try again
        //
        cchBuffer *= 2;
    }

    strBuffer.ReleaseBuffer();

    return hr;
}



BOOL
CError::ExpandEscapeCode(
    LPTSTR szBuffer,
    DWORD cchBuffer,
    LPTSTR & lp,
    CString & strReplacement,
    HRESULT & hr
    ) const
/*++

Routine Description:

    Expand escape code

Arguments:

    LPTSTR szBuffer             Buffer
    DWORD cchBuffer             Size of buffer
    LPTSTR & lp                 Pointer to escape code
    CString & strReplacement    Message to replace the escape code
    HRESULT & hr                Returns HRESULT in case of failure

Return Value:

    TRUE if the replacement was successful, FALSE otherwise.
    In the case of failure, hr will return an HRESULT.
    In the case of success, lp will be advanced past the
    replacement string.

--*/
{
    //
    // Make sure there's room (account for terminating NULL)
    // Free up 2 spaces for the escape code.
    //
    int cchFmt = lstrlen(szBuffer) - 2;
    int cchReplacement = strReplacement.GetLength();
    int cchRemainder = lstrlen(lp + 2);

    if (    lp != NULL && (lp + 2) != NULL 
       &&   (DWORD)(cchReplacement + cchFmt) < cchBuffer
       )
    {
        //
        // Put it in
        //
        MoveMemory(
            lp + cchReplacement,
            lp + 2,
            (cchRemainder + 1) * sizeof(TCHAR)
            );
        CopyMemory(lp, strReplacement, cchReplacement * sizeof(TCHAR));
        lp += cchReplacement;
        
        return TRUE;
    }

    hr = HResult(ERROR_INSUFFICIENT_BUFFER);

    return FALSE;
}



LPCTSTR 
CError::TextFromHRESULTExpand(
    LPTSTR  szBuffer,
    DWORD   cchBuffer,
    HRESULT * phResult  OPTIONAL
    ) const
/*++

Routine Description:

    Expand %h/%H strings in szBuffer to text from HRESULT,
    or error code respectively within the limits of szBuffer.

Arguments:

    LPTSTR  szBuffer    Buffer to load message text into
    DWORD   cchBuffer   Buffer size in characters
    HRESULT * phResult  Optional return code

Return Value:

    Pointer to string.

--*/
{
    HRESULT hr = S_OK;

    if (szBuffer == NULL || cchBuffer <= 0)
    {
        hr = HResult(ERROR_INSUFFICIENT_BUFFER);
    }
    else
    {
        //
        // Look for the escape sequence
        //
        int cReplacements = 0;
        CString strMessage;
        LPTSTR lp = szBuffer;

        while (*lp)
        {
            if (*lp == s_chEscape)
            {
                switch(*(lp + 1))
                {
                case s_chEscText:
                    //
                    // Replace escape code with text message
                    //
                    hr = TextFromHRESULT(strMessage);

                    if (ExpandEscapeCode(
                        szBuffer,
                        cchBuffer,
                        lp,
                        strMessage,
                        hr
                        ))
                    {
                        ++cReplacements;
                    }
                    break;

                case s_chEscNumber:
                    //
                    // Replace escape code with numeric error code
                    //
                    strMessage.Format(_T("0x%08x"), m_hrCode);

                    if (ExpandEscapeCode(
                        szBuffer,
                        cchBuffer,
                        lp,
                        strMessage,
                        hr
                        ))
                    {
                        ++cReplacements;
                    }
                    break;

                default:
                    //
                    // Regular printf-style escape sequence.
                    //
                    break;
                }
            }

            ++lp;
        }

        if (!cReplacements)
        {
            //
            // Got to the end without finding any escape codes.
            //
            hr = HResult(ERROR_INVALID_PARAMETER);
        }
    }

    if (phResult)
    {
        *phResult = hr;
    }

    return szBuffer;
}



LPCTSTR 
CError::TextFromHRESULTExpand(
    CString & strBuffer
    ) const
/*++

Routine Description:

    Expand %h string in strBuffer to text from HRESULT

Arguments:

    CString & strBuffer Buffer to load message text into

Return Value:

    Pointer to string.

--*/
{
    DWORD cchBuffer = strBuffer.GetLength() + 1024;

    for (;;)
    {
        LPTSTR szBuffer = strBuffer.GetBuffer(cchBuffer + 1);

        if (szBuffer != NULL)
        {
            HRESULT hr;

            TextFromHRESULTExpand(szBuffer, cchBuffer, &hr);

            if (Win32Error(hr) != ERROR_INSUFFICIENT_BUFFER)
            {
                //
                // Done!
                //
                break;
            }

            //
            // Insufficient buffer, enlarge and try again
            //
            cchBuffer *= 2;
        }
    }

    strBuffer.ReleaseBuffer();

    return strBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\mbschema.cpp ===
//
// This is computer generated code
// please don't edit it manually.
//
#include "stdafx.h"
#include "common.h"
#include <iiscnfg.h>
#include "mdkeys.h"
#include "mbschema.h"

const CMetaKey::MDFIELDDEF CMetaKey::s_rgMetaTable[] =
{
	{ 1000, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_MaxBandwidth },
	{ 1001, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, 0 /* MD_1001 */ },
	{ 1002, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, STRING_METADATA, IDS_KeyType },
	{ 1003, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_MaxBandwidthBlocked },
	{ 1012, METADATA_VOLATILE, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_ServerCommand },
	{ 1013, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_ConnectionTimeout },
	{ 1014, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_MaxConnections },
	{ 1015, METADATA_INHERIT, IIS_MD_UT_SERVER, STRING_METADATA, IDS_ServerComment },
	{ 1016, METADATA_VOLATILE, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_ServerState },
	{ 1017, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_ServerAutoStart },
	{ 1018, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_ServerSize },
	{ 1019, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_ServerListenBacklog },
	{ 1020, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_ServerListenTimeout },
	{ 1021, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_DownlevelAdminInstance },
	{ 1022, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_DirectoryLevelsToScan },
	{ 1023, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, MULTISZ_METADATA, IDS_ServerBindings },
	{ 1024, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_MaxEndpointConnections },
	{ 1025, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_ClusterEnabled },
	{ 1027, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_ServerConfigFlags },
	{ 1028, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, MULTISZ_METADATA, 0 /* MD_IISADMIN_EXTENSIONS */ },
	{ 1029, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_DisableSocketPooling },
	{ 1030, METADATA_INHERIT, IIS_MD_UT_SERVER, MULTISZ_METADATA, 0 /* MD_METADATA_ID_REGISTRATION */ },
	{ 1099, METADATA_VOLATILE, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_Win32Error },
	{ 1100, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, 0 /* MD_SERVER_PLATFORM */ },
	{ 1101, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_MajorIIsVersionNumber },
	{ 1102, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_MinorIIsVersionNumber },
	{ 1103, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, 0 /* MD_SERVER_CAPABILITIES */ },
	{ 2021, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, MULTISZ_METADATA, IDS_SecureBindings },
	{ 2039, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, 0 /* MD_ETAG_CHANGENUMBER */ },
	{ 2040, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, STRING_METADATA, IDS_FilterLoadOrder },
	{ 2041, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, STRING_METADATA, IDS_FilterPath },
	{ 2042, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_FilterState },
	{ 2043, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_FilterEnabled },
	{ 2044, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_FilterFlags },
	{ 2045, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, STRING_METADATA, IDS_FilterDescription },
	{ 2046, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_FilterEnableCache },
	{ 2060, METADATA_INHERIT, IIS_MD_UT_SERVER, STRING_METADATA, IDS_AuthChangeURL },
	{ 2061, METADATA_INHERIT, IIS_MD_UT_SERVER, STRING_METADATA, IDS_AuthExpiredURL },
	{ 2062, METADATA_INHERIT, IIS_MD_UT_SERVER, STRING_METADATA, IDS_AuthNotifyPwdExpURL },
	{ 2063, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_PasswordExpirePrenotifyDays },
	{ 2064, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_PasswordCacheTTL },
	{ 2067, METADATA_INHERIT, IIS_MD_UT_SERVER, STRING_METADATA, IDS_AuthExpiredUnsecureURL },
	{ 2068, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_PasswordChangeFlags },
	{ 2069, METADATA_INHERIT, IIS_MD_UT_SERVER, STRING_METADATA, IDS_AuthNotifyPwdExpUnsecureURL },
	{ 2070, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_ProcessNTCRIfLoggedOn },
	{ 2072, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_FrontPageWeb },
	{ 2073, METADATA_INHERIT, IIS_MD_UT_SERVER, MULTISZ_METADATA, IDS_InProcessIsapiApps },
	{ 2095, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_AllowPathInfoForScriptMappings },
	{ 2102, METADATA_INHERIT, IIS_MD_UT_WAM, STRING_METADATA, IDS_AppFriendlyName },
	{ 2103, METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA, IDS_AppRoot },
	{ 2104, METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA, IDS_AppIsolated },
	{ 2105, METADATA_INHERIT, IIS_MD_UT_WAM, STRING_METADATA, IDS_AppWamClsid },
	{ 2106, METADATA_INHERIT, IIS_MD_UT_WAM, STRING_METADATA, IDS_AppPackageID },
	{ 2107, METADATA_INHERIT, IIS_MD_UT_WAM, STRING_METADATA, IDS_AppPackageName },
	{ 2108, METADATA_NO_ATTRIBUTES, IIS_MD_UT_WAM, STRING_METADATA, 0 /* MD_APP_LAST_OUTPROC_PID */ },
	{ 2110, METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA, IDS_AppOopRecoverLimit },
	{ 2115, METADATA_INHERIT, IIS_MD_UT_SERVER, STRING_METADATA, IDS_AdminServer },
	{ 2120, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, MULTISZ_METADATA, IDS_CustomErrorDescriptions },
	{ 2144, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_CPUResetInterval },
	{ 2160, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_CertCheckMode },
	{ 2161, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_RevocationFreshnessTime },
	{ 2162, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_RevocationURLRetrievalTimeout },
	{ 2167, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, MULTISZ_METADATA, IDS_ApplicationDependencies },
	{ 2168, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, MULTISZ_METADATA, IDS_WebSvcExtRestrictionList },
	{ 2210, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, EXPANDSZ_METADATA, IDS_HcCompressionDirectory },
	{ 2211, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, STRING_METADATA, IDS_HcCacheControlHeader },
	{ 2212, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, STRING_METADATA, IDS_HcExpiresHeader },
	{ 2213, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_HcDoDynamicCompression },
	{ 2214, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_HcDoStaticCompression },
	{ 2215, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_HcDoOnDemandCompression },
	{ 2216, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_HcDoDiskSpaceLimiting },
	{ 2217, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_HcNoCompressionForHttp10 },
	{ 2218, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_HcNoCompressionForProxies },
	{ 2219, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_HcNoCompressionForRange },
	{ 2220, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_HcSendCacheHeaders },
	{ 2221, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_HcMaxDiskSpaceUsage },
	{ 2222, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_HcIoBufferSize },
	{ 2223, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_HcCompressionBufferSize },
	{ 2224, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_HcMaxQueueLength },
	{ 2225, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_HcFilesDeletedPerDiskFree },
	{ 2226, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_HcMinFileSizeForComp },
	{ 2237, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, EXPANDSZ_METADATA, IDS_HcCompressionDll },
	{ 2238, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, MULTISZ_METADATA, IDS_HcFileExtensions },
	{ 2240, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_HcPriority },
	{ 2241, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_HcDynamicCompressionLevel },
	{ 2242, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_HcOnDemandCompLevel },
	{ 2243, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_HcCreateFlags },
	{ 2244, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, MULTISZ_METADATA, IDS_HcScriptFileExtensions },
	{ 2255, METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA, IDS_DoDynamicCompression },
	{ 2256, METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA, IDS_DoStaticCompression },
	{ 3001, METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA, IDS_Path },
	{ 3002, METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA, IDS_UNCUserName },
	{ 3003, METADATA_INHERIT | METADATA_SECURE, IIS_MD_UT_FILE, STRING_METADATA, IDS_UNCPassword },
	{ 4000, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_LogType },
	{ 4001, METADATA_INHERIT, IIS_MD_UT_SERVER, EXPANDSZ_METADATA, IDS_LogFileDirectory },
	{ 4003, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_LogFilePeriod },
	{ 4004, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_LogFileTruncateSize },
	{ 4005, METADATA_INHERIT, IIS_MD_UT_SERVER, STRING_METADATA, IDS_LogModuleId },
	{ 4006, METADATA_INHERIT, IIS_MD_UT_SERVER, STRING_METADATA, IDS_LogModuleUiId },
	{ 4007, METADATA_INHERIT, IIS_MD_UT_SERVER, STRING_METADATA, IDS_LogOdbcDataSource },
	{ 4008, METADATA_INHERIT, IIS_MD_UT_SERVER, STRING_METADATA, IDS_LogOdbcTableName },
	{ 4009, METADATA_INHERIT, IIS_MD_UT_SERVER, STRING_METADATA, IDS_LogOdbcUserName },
	{ 4010, METADATA_INHERIT | METADATA_SECURE, IIS_MD_UT_SERVER, STRING_METADATA, IDS_LogOdbcPassword },
	{ 4011, METADATA_INHERIT, IIS_MD_UT_SERVER, STRING_METADATA, IDS_LogPluginClsid },
	{ 4012, METADATA_INHERIT, IIS_MD_UT_SERVER, STRING_METADATA, IDS_LogModuleList },
	{ 4013, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_LogExtFileFlags },
	{ 4015, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_LogFileLocaltimeRollover },
	{ 4016, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_CentralBinaryLoggingEnabled },
	{ 4501, METADATA_INHERIT, IIS_MD_UT_SERVER, STRING_METADATA, IDS_LogCustomPropertyName },
	{ 4502, METADATA_INHERIT, IIS_MD_UT_SERVER, STRING_METADATA, IDS_LogCustomPropertyHeader },
	{ 4503, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_LogCustomPropertyID },
	{ 4504, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_LogCustomPropertyMask },
	{ 4505, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_LogCustomPropertyDataType },
	{ 4506, METADATA_INHERIT, IIS_MD_UT_SERVER, MULTISZ_METADATA, IDS_LogCustomPropertyServicesString },
	{ 4508, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_LogCustomPropertyNodeID },
	{ 5001, METADATA_INHERIT, IIS_MD_UT_SERVER, STRING_METADATA, IDS_ExitMessage },
	{ 5002, METADATA_INHERIT, IIS_MD_UT_SERVER, MULTISZ_METADATA, IDS_GreetingMessage },
	{ 5003, METADATA_INHERIT, IIS_MD_UT_SERVER, STRING_METADATA, IDS_MaxClientsMessage },
	{ 5004, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_MSDOSDirOutput },
	{ 5005, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_AllowAnonymous },
	{ 5006, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_AnonymousOnly },
	{ 5007, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_LogAnonymous },
	{ 5008, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_LogNonAnonymous },
	{ 5010, METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA, IDS_FtpDirBrowseShowLongDate },
	{ 5011, METADATA_INHERIT, IIS_MD_UT_SERVER, MULTISZ_METADATA, IDS_BannerMessage },
	{ 5012, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_UserIsolationMode },
	{ 5013, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_FtpLogInUtf8 },
	{ 5014, METADATA_INHERIT, IIS_MD_UT_SERVER, STRING_METADATA, IDS_ADConnectionsUserName },
	{ 5015, METADATA_INHERIT | METADATA_SECURE, IIS_MD_UT_SERVER, STRING_METADATA, IDS_ADConnectionsPassword },
	{ 5016, METADATA_INHERIT, IIS_MD_UT_SERVER, STRING_METADATA, IDS_PassivePortRange },
	{ 5506, METADATA_INHERIT, IIS_MD_UT_SERVER, BINARY_METADATA, IDS_SSLCertHash },
	{ 5511, METADATA_INHERIT, IIS_MD_UT_SERVER, STRING_METADATA, IDS_SSLStoreName },
	{ 5512, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, STRING_METADATA, IDS_SslCtlIdentifier },
	{ 5517, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, STRING_METADATA, IDS_SslCtlStoreName },
	{ 5519, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_SslUseDsMapper },
	{ 6000, METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA, IDS_AuthFlags },
	{ 6001, METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA, IDS_Realm },
	{ 6002, METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA, IDS_HttpExpires },
	{ 6003, METADATA_INHERIT, IIS_MD_UT_FILE, MULTISZ_METADATA, IDS_HttpPics },
	{ 6004, METADATA_INHERIT, IIS_MD_UT_FILE, MULTISZ_METADATA, IDS_HttpCustomHeaders },
	{ 6005, METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA, IDS_DirBrowseFlags },
	{ 6006, METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA, IDS_DefaultDoc },
	{ 6008, METADATA_INHERIT, IIS_MD_UT_FILE, MULTISZ_METADATA, IDS_HttpErrors },
	{ 6009, METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA, IDS_DefaultDocFooter },
	{ 6010, METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA, IDS_EnableDocFooter },
	{ 6011, METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA, IDS_HttpRedirect },
	{ 6012, METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA, IDS_DefaultLogonDomain },
	{ 6013, METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA, IDS_LogonMethod },
	{ 6014, METADATA_INHERIT, IIS_MD_UT_FILE, MULTISZ_METADATA, IDS_ScriptMaps },
	{ 6015, METADATA_INHERIT, IIS_MD_UT_FILE, MULTISZ_METADATA, IDS_MimeMap },
	{ 6016, METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA, IDS_AccessFlags },
	{ 6019, METADATA_INHERIT | METADATA_REFERENCE, IIS_MD_UT_FILE, BINARY_METADATA, IDS_IPSecurity },
	{ 6020, METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA, IDS_AnonymousUserName },
	{ 6021, METADATA_INHERIT | METADATA_SECURE, IIS_MD_UT_FILE, STRING_METADATA, IDS_AnonymousUserPass },
	{ 6022, METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA, IDS_AnonymousPasswordSync },
	{ 6023, METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA, IDS_DontLog },
	{ 6027, METADATA_INHERIT | METADATA_SECURE | METADATA_REFERENCE, IIS_MD_UT_SERVER, BINARY_METADATA, IDS_AdminACL },
	{ 6028, METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA, IDS_SSIExecDisable },
	{ 6029, METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA, IDS_EnableReverseDns },
	{ 6030, METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA, IDS_AccessSSLFlags },
	{ 6031, METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA, IDS_AuthPersistence },
	{ 6032, METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA, IDS_NTAuthenticationProviders },
	{ 6033, METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA, IDS_CGITimeout },
	{ 6034, METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA, IDS_CacheISAPI },
	{ 6035, METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA, IDS_CreateProcessAsUser },
	{ 6036, METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA, IDS_CreateCGIWithNewConsole },
	{ 6037, METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA, IDS_PoolIdcTimeout },
	{ 6038, METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA, IDS_AllowKeepAlive },
	{ 6039, METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA, IDS_ContentIndexed },
	{ 6041, METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA, IDS_CacheControlNoCache },
	{ 6042, METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA, IDS_CacheControlMaxAge },
	{ 6043, METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA, IDS_CacheControlCustom },
	{ 6044, METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA, IDS_RedirectHeaders },
	{ 6045, METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA, IDS_UploadReadAheadSize },
	{ 6047, METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA, IDS_UseDigestSSP },
	{ 6048, METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA, IDS_AzEnable },
	{ 6049, METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA, IDS_AzStoreName },
	{ 6050, METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA, IDS_AzScopeName },
	{ 6051, METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA, IDS_MaxRequestEntityAllowed },
	{ 6269, METADATA_NO_ATTRIBUTES, IIS_MD_UT_FILE, DWORD_METADATA, 0 /* MD_ISM_ACCESS_CHECK */ },
	{ 6286, METADATA_INHERIT | METADATA_SECURE | METADATA_REFERENCE, IIS_MD_UT_SERVER, BINARY_METADATA, IDS_AdminACLBin },
	{ 7000, METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA, IDS_AspBufferingOn },
	{ 7001, METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA, IDS_AspLogErrorRequests },
	{ 7002, METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA, IDS_AspScriptErrorSentToBrowser },
	{ 7003, METADATA_INHERIT, ASP_MD_UT_APP, STRING_METADATA, IDS_AspScriptErrorMessage },
	{ 7004, METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA, IDS_AspScriptFileCacheSize },
	{ 7005, METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA, IDS_AspScriptEngineCacheMax },
	{ 7006, METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA, IDS_AspScriptTimeout },
	{ 7007, METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA, IDS_AspSessionTimeout },
	{ 7008, METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA, IDS_AspEnableParentPaths },
	{ 7011, METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA, IDS_AspAllowSessionState },
	{ 7012, METADATA_INHERIT, ASP_MD_UT_APP, STRING_METADATA, IDS_AspScriptLanguage },
	{ 7013, METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA, IDS_AspQueueTimeout },
	{ 7014, METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA, IDS_AspAllowOutOfProcComponents },
	{ 7015, METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA, IDS_AspExceptionCatchEnable },
	{ 7016, METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA, IDS_AspCodepage },
	{ 7018, METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA, IDS_AppAllowDebugging },
	{ 7019, METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA, IDS_AppAllowClientDebug },
	{ 7020, METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA, IDS_AspTrackThreadingModel },
	{ 7021, METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA, IDS_AspEnableAspHtmlFallback },
	{ 7022, METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA, IDS_AspEnableChunkedEncoding },
	{ 7023, METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA, IDS_AspEnableTypelibCache },
	{ 7024, METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA, IDS_AspErrorsToNTLog },
	{ 7025, METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA, IDS_AspProcessorThreadMax },
	{ 7026, METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA, IDS_AspRequestQueueMax },
	{ 7027, METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA, IDS_AspEnableApplicationRestart },
	{ 7028, METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA, IDS_AspQueueConnectionTestTime },
	{ 7029, METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA, IDS_AspSessionMax },
	{ 7036, METADATA_INHERIT, IIS_MD_UT_WAM, EXPANDSZ_METADATA, IDS_AspDiskTemplateCacheDirectory },
	{ 7040, METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA, IDS_AspMaxDiskTemplateCacheFiles },
	{ 7041, METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA, IDS_AspExecuteInMTA },
	{ 7042, METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA, IDS_AspLCID },
	{ 7043, METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA, IDS_AspKeepSessionIDSecure },
	{ 7044, METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA, IDS_AspAppServiceFlags },
	{ 7048, METADATA_INHERIT, ASP_MD_UT_APP, STRING_METADATA, IDS_AspPartitionID },
	{ 7049, METADATA_INHERIT, ASP_MD_UT_APP, STRING_METADATA, IDS_AspSxsName },
	{ 7050, METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA, IDS_AspCalcLineNumber },
	{ 7051, METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA, IDS_AspRunOnEndAnonymously },
	{ 7052, METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA, IDS_AspBufferingLimit },
	{ 7053, METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA, IDS_AspMaxRequestEntityAllowed },
	{ 7501, METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA, IDS_WAMUserName },
	{ 7502, METADATA_INHERIT | METADATA_SECURE, IIS_MD_UT_FILE, STRING_METADATA, IDS_WAMUserPass },
	{ 9001, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_PeriodicRestartTime },
	{ 9002, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_PeriodicRestartRequests },
	{ 9003, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_MaxProcesses },
	{ 9004, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_PingingEnabled },
	{ 9005, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_IdleTimeout },
	{ 9006, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_RapidFailProtection },
	{ 9007, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_SMPAffinitized },
	{ 9008, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_SMPProcessorAffinityMask },
	{ 9009, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_OrphanWorkerProcess },
	{ 9011, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_StartupTimeLimit },
	{ 9012, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_ShutdownTimeLimit },
	{ 9013, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_PingInterval },
	{ 9014, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_PingResponseTime },
	{ 9015, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_DisallowOverlappingRotation },
	{ 9017, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_AppPoolQueueLength },
	{ 9018, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_DisallowRotationOnConfigChange },
	{ 9020, METADATA_INHERIT, IIS_MD_UT_SERVER, MULTISZ_METADATA, IDS_PeriodicRestartSchedule },
	{ 9021, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_AppPoolIdentityType },
	{ 9022, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_CPUAction },
	{ 9023, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_CPULimit },
	{ 9024, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_PeriodicRestartMemory },
	{ 9026, METADATA_VOLATILE, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_AppPoolCommand },
	{ 9027, METADATA_VOLATILE, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_AppPoolState },
	{ 9028, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_AppPoolAutoStart },
	{ 9029, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_RapidFailProtectionInterval },
	{ 9030, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_RapidFailProtectionMaxCrashes },
	{ 9031, METADATA_INHERIT, IIS_MD_UT_SERVER, STRING_METADATA, IDS_OrphanActionExe },
	{ 9032, METADATA_INHERIT, IIS_MD_UT_SERVER, STRING_METADATA, IDS_OrphanActionParams },
	{ 9034, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_LoadBalancerCapabilities },
	{ 9035, METADATA_INHERIT, IIS_MD_UT_SERVER, STRING_METADATA, IDS_AutoShutdownAppPoolExe },
	{ 9036, METADATA_INHERIT, IIS_MD_UT_SERVER, STRING_METADATA, IDS_AutoShutdownAppPoolParams },
	{ 9037, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_LogEventOnRecycle },
	{ 9038, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_PeriodicRestartPrivateMemory },
	{ 9101, METADATA_INHERIT, IIS_MD_UT_SERVER, STRING_METADATA, IDS_AppPoolId },
	{ 9201, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_MaxGlobalBandwidth },
	{ 9203, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_IIs5IsolationModeEnabled },
	{ 9204, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_HeaderWaitTimeout },
	{ 9205, METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_MinFileBytesPerSec },
	{ 9206, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_LogInUTF8 },
	{ 9207, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_DemandStartThreshold },
	{ 9988, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_MaxErrorFiles },
	{ 9990, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, STRING_METADATA, IDS_CollectionComment },
	{ 9991, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, BINARY_METADATA, IDS_BINSchemaTimeStamp },
	{ 9992, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, BINARY_METADATA, IDS_XMLSchemaTimeStamp },
	{ 9994, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_HistoryMajorVersionNumber },
	{ 9995, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_MaxHistoryFiles },
	{ 9996, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_EnableHistory },
	{ 9997, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_ChangeNumber },
	{ 9998, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA, IDS_EnableEditWhileRunning },
	{ 9999, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, BINARY_METADATA, IDS_SessionKey },
};

const int CMetaKey::s_MetaTableSize = sizeof(CMetaKey::s_rgMetaTable) / sizeof(CMetaKey::s_rgMetaTable[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\msg.h ===
/*++

   Copyright    (c)    1994-2002    Microsoft Corporation

   Module  Name :
        msg.h

   Abstract:
        Message Functions Definitions

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/

#ifndef _MSG_H
#define _MSG_H


//
// Slightly easier syntax to register a facility
//
#define REGISTER_FACILITY(dwCode, lpSource)\
    CError::RegisterFacility(dwCode, lpSource)


//
// Helper Function
//
HRESULT GetLastHRESULT();



BOOL InitErrorFunctionality();
void TerminateErrorFunctionality();



typedef struct tagFACILITY
{
    LPCTSTR lpszDll;
    UINT    nTextID;
} FACILITY;



typedef CMap<DWORD, DWORD &, CString, CString &> CMapDWORDtoCString;
typedef CMap<HRESULT, HRESULT &, UINT, UINT &>   CMapHRESULTtoUINT;



class COMDLL CError
/*++

Class Description:

    Error handling class, works for both HRESULT and old-style DWORD
    error codes.  Construct with or assign a DWORD or HRESULT error
    return code, and the object can then be used to determine success
    or failure, and the object provides text for the error code either
    directly, in a message, or formatted with additional text.  Also,
    the CError object understands the range of winsock errors and
    lanman errors, and looks for them in the appropriate places.
    The object can be referenced as a BOOL, a DWORD, an HRESULT, or
    a LPCTSTR as a success/failure, a WIN32 error, and HRESULT or
    the text equivalent respectively.

    Example of typical programme flow:

    CError err(FunctionWhichReturnsHresult());

    //
    // Use IDS_MY_ERROR for access denied errors for the
    // duration of this scope.
    //
    err.AddOverride(ERROR_ACCESS_DENIED, IDS_MY_ERROR);

    if (!err.MessageBoxOnFailure())
    {
        //
        // If we failed, this already displayed the error
        // message in a messagebox.  Only when we succeed
        // we get here.
        //
        ... stuff ...
    }

    SomeWinApiWhichSetsLastError();
    err.GetLastWinError();
    if (err.Failed())
    {
        printf("WIN32 Error code %ld\nHRESULT %ld\nText: %s\n",
            (DWORD)err,
            (HRESULT)err,
            (LPCTSTR)err
            );
    }

Public Interface:

    TextFromHRESULT         : Convert HRESULT to text
    TextFromHRESULTExpand   : Expand %h string to error text, %H to error code
    MessageBox              : Display error in a messagebox
    MessageBoxFormat        : Use %h string as format in messagebox
    MessageBoxOnFailure     : Display message if error is a failure
    AddOverride             : Add message override with string ID
    RemoveOverride          : Remove message override
    RegisterFacility        : Register facility
    UnregisterFacility      : Unregister facility
    Succeeded               : Determine if the error code indicates a success
    Failed                  : Determine if the error code indicates a failure

    CError                  : Constructors
    Reset                   : Reset error code
    GetLastWinError         : Assign internal code to GetLastError
    SetLastWinError         : Set last error from internal code

    operator =              : Assignment operators
    operator ==             : Comparison operators
    operator !=             : Comparison operators
    operator LPOLESTR       : Conversion operator
    operator LPCTSTR        : Conversion operator
    operator HRESULT        : Conversion operator
    operator DWORD          : Conversion operator
    operator BOOL           : Conversion operator

--*/
{
#define IS_HRESULT(hr)  (hr & 0xffff0000)
#define REMOVE_OVERRIDE ((UINT)-1)
#define NO_HELP_CONTEXT ((UINT)-1)
#define USE_LAST_ERROR  (TRUE)

//
// Private Internal FACILITY codes
//
#define FACILITY_WINSOCK    (0xffe)
#define FACILITY_LANMAN     (0xfff)

//
// Static Helpers
//
public:
    //
    // Success/Failure determinants, works regardless
    // of whether hrCode is a DWORD or HRESULT
    //
    static BOOL Succeeded(HRESULT hrCode);
    static BOOL Failed(HRESULT hrCode);

    //
    // Guarantee return is WIN32 error code
    //
    static DWORD Win32Error(HRESULT hrCode) { return HRESULT_CODE(hrCode); }

    //
    // Guarantee return is a true HRESULT
    //
    static HRESULT HResult(HRESULT hrCode) { return HRESULT_FROM_WIN32(hrCode); }

    //
    // Register a DLL for a given facility code.
    // Use NULL to unregister the facility
    //
    static void RegisterFacility(
        DWORD dwFacility,
        LPCSTR lpDLL = NULL
        );

    static void UnregisterFacility(
        DWORD dwFacility
        );

//
// Constructor/Destructor
//
public:
    //
    // If constructed with TRUE, the object is initialized to
    // last error.  It's set to ERROR_SUCCESS otherwise (default case)
    //
    CError();
    CError(HRESULT hrCode);
    CError(DWORD   dwCode);
    ~CError();

//
// Helpers
//
public:
    BOOL Succeeded() const { return SUCCEEDED(m_hrCode); }
    BOOL Failed() const { return FAILED(m_hrCode); }

    HRESULT TextFromHRESULT(
        LPTSTR szBuffer,
        DWORD  cchBuffer
        ) const;

    HRESULT TextFromHRESULT(
        CString & strMsg
        ) const;

    LPCTSTR TextFromHRESULTExpand(
        LPTSTR  szBuffer,
        DWORD   cchBuffer,
        HRESULT * phResult = NULL
        ) const;

    LPCTSTR TextFromHRESULTExpand(
        CString & strBuffer
        ) const;

    int MessageBox(
        HWND hWnd = NULL,
        UINT nType = MB_OK | MB_ICONWARNING,
        UINT nHelpContext = NO_HELP_CONTEXT
        ) const;

    BOOL MessageBoxOnFailure(
        HWND hWnd = NULL,
        UINT nType = MB_OK | MB_ICONWARNING,
        UINT nHelpContext = NO_HELP_CONTEXT
        ) const;

    int MessageBoxFormat(
        HWND hWnd,
        UINT nFmt,
        UINT nType,
        UINT nHelpContext,
        ...
        ) const;

    void Reset();
    void GetLastWinError();
    void SetLastWinError() const;
    DWORD Win32Error() const;
    HRESULT HResult() const { return m_hrCode; }

    //
    // Add override for specific error code.
    // Use -1 to remove the override.  This function
    // will return the previous override (or -1)
    //
    UINT AddOverride(
        HRESULT hrCode,
        UINT    nMessage = REMOVE_OVERRIDE
        );         

    void RemoveOverride(
        HRESULT hrCode
        );
        
    void RemoveAllOverrides();   

protected:
    //
    // Expand escape code
    //
    BOOL ExpandEscapeCode(
        LPTSTR szBuffer,
        DWORD cchBuffer,
        LPTSTR & lp,
        CString & strReplacement,
        HRESULT & hr
        ) const;

    //
    // Check for override message
    //
    BOOL HasOverride(
        UINT * pnMessage = NULL
        ) const;

//
// Assignment Operators
//
public:
    const CError & operator =(HRESULT hr);
    const CError & operator =(const CError & err);

// 
// Comparison Operators
//
public:
    const BOOL operator ==(HRESULT hr);
    const BOOL operator ==(CError & err);
    const BOOL operator !=(HRESULT hr);
    const BOOL operator !=(CError & err);

//
// Conversion Operators
//
public:
    operator const HRESULT() const { return m_hrCode; }
    operator const DWORD() const;
    operator const BOOL() const;
    operator LPOLESTR();
    operator LPCTSTR();

#if defined(_DEBUG) || DBG

public:
    //
    // CDumpContext stream operator
    //
    inline friend CDumpContext & AFXAPI operator <<(
        CDumpContext & dc,
        const CError & value
        )
    {
        return dc << (DWORD)value.m_hrCode;
    }

#endif // _DEBUG

protected:
    static HRESULT CvtToInternalFormat(HRESULT hrCode);

    //
    // Check for FACILITY dll
    //
    static LPCTSTR FindFacility(
        DWORD dwFacility
        );

protected:
    friend BOOL InitErrorFunctionality();
    friend void TerminateErrorFunctionality();
    static BOOL AllocateStatics();
    static void DeAllocateStatics();
    static BOOL AreStaticsAllocated() { return s_fAllocated; }

protected:
    static const TCHAR s_chEscape;    // Escape character
    static const TCHAR s_chEscText;   // Escape code for text
    static const TCHAR s_chEscNumber; // Escape code for error code
    static LPCTSTR s_cszLMDLL;        // Lanman Message DLL
    static LPCTSTR s_cszWSDLL;        // Winsock Message DLL
    static LPCTSTR s_cszFacility[];   // Facility Table
    static HRESULT s_cdwMinLMErr;     // Lanman Error Range
    static HRESULT s_cdwMaxLMErr;     // Lanman Error Range
    static HRESULT s_cdwMinWSErr;     // Winsock Error Range
    static HRESULT s_cdwMaxWSErr;     // Winsock Error Range
    static DWORD   s_cdwFacilities;   // Number of facility items

    //
    // Allocated objects 
    //
    static CString * s_pstrDefError;  // Default Error String
    static CString * s_pstrDefSuccs;  // Default Success String
    static CMapDWORDtoCString * s_pmapFacilities;
    static BOOL s_fAllocated;

protected:
    const CError & Construct(HRESULT hr);
    const CError & Construct(const CError & err);
    CMapHRESULTtoUINT  mapOverrides;

private:
    HRESULT m_hrCode;
    CString m_str;
};



//
// Inline Expansions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline HRESULT GetLastHRESULT()
{
    return CError::HResult(::GetLastError());
}

inline /* static */ BOOL CError::Succeeded(HRESULT hrCode)
{
    //
    // Works with either HRESULT or WIN32 error code
    //
    return IS_HRESULT(hrCode)
        ? SUCCEEDED(hrCode)
        : hrCode == ERROR_SUCCESS;
}

inline /* static */ BOOL CError::Failed(HRESULT hrCode)
{
    //
    // Works with either HRESULT or WIN32 error code
    //
    return IS_HRESULT(hrCode)
        ? FAILED(hrCode)
        : hrCode != ERROR_SUCCESS;
}

inline /* static */ void CError::UnregisterFacility(
    DWORD dwFacility
    )
{
    RegisterFacility(dwFacility, NULL);
}

inline CError::CError()
{
    Construct(S_OK);
}

inline CError::CError(HRESULT hrCode)
{
    Construct(hrCode);
}

inline CError::CError(DWORD dwCode)
{
    Construct((HRESULT)dwCode);
}

inline DWORD CError::Win32Error() const
{
    return CError::Win32Error(m_hrCode);
}

inline void CError::Reset()
{
    m_hrCode = S_OK;
}

inline void CError::GetLastWinError()
{
    Construct(::GetLastError());
}

inline void CError::SetLastWinError() const
{
    ::SetLastError(Win32Error(m_hrCode));
}

inline void CError::RemoveOverride(
    HRESULT hrCode
    )
{
    (void)CError::AddOverride(hrCode, REMOVE_OVERRIDE);
}

inline const CError & CError::operator =(HRESULT hr)
{
    return Construct(hr);
}

inline const CError & CError::operator =(const CError & err)
{
    return Construct(err);
}

inline const BOOL CError::operator ==(HRESULT hr)
{
    return m_hrCode == hr;
}

inline const BOOL CError::operator ==(CError & err)
{
    return m_hrCode == err.m_hrCode;
}

inline const BOOL CError::operator !=(HRESULT hr)
{
    return m_hrCode != hr;
}

inline const BOOL CError::operator !=(CError & err)
{
    return m_hrCode != err.m_hrCode;
}

inline CError::operator const DWORD() const
{
    return Win32Error();
}

inline CError::operator const BOOL() const
{
    return Succeeded();
}

inline CError::operator LPOLESTR()
{
    TextFromHRESULT(m_str);
    return m_str.GetBuffer(0);
}
    
inline CError::operator LPCTSTR()
{
    TextFromHRESULT(m_str);
    return m_str;
}

//
// AfxMessageBox helpers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline BOOL NoYesMessageBox(UINT nID)
{
    return AfxMessageBox(nID, MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON2) == IDYES;
}

inline BOOL NoYesMessageBox(CString & str)
{
    return AfxMessageBox(str, MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON2) == IDYES;
}

inline BOOL YesNoMessageBox(UINT nID)
{
    return AfxMessageBox(nID, MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON1) == IDYES;
}

inline BOOL YesNoMessageBox(CString & str)
{
    return AfxMessageBox(str, MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON1) == IDYES;
}

#endif // _MSG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\objpick.h ===
// objpick.cpp: implementation of the CGetUser class and the 
//              CGetComputer class using the object picker
//
//////////////////////////////////////////////////////////////////////
#ifndef OBJPICK_H
#define OBJPICK_H

DWORD ObjPickNameOrIpToHostname(CString & strNameOrIp, CString & strHostName);


//
// A list of names (e.g., users, groups, machines, and etc)
//

BOOL COMDLL GetIUsrAccount(
    IN  LPCTSTR lpstrServer,
    IN  CWnd * pParent,
    OUT CString & str
    );

BOOL COMDLL GetIUsrAccount(
    LPCTSTR lpstrServer,
    CWnd * pParent,
    LPTSTR pBuffer,
    int size
    );

void    FormatName(LPCTSTR pszFullName, LPCTSTR pszDomainName, CString & strDisplay);

class CAccessEntry;

class CAccessEntryArray : public CArray<CAccessEntry *, CAccessEntry *&>
{
public:
    CAccessEntryArray() {}
    ~CAccessEntryArray();
};

class COMDLL CGetUsers : public CAccessEntryArray
{
public:
    CGetUsers(LPCTSTR pszMachineName, BOOL fMultiselect = FALSE);
    ~CGetUsers();

    BOOL    GetUsers(HWND hwndOwner, BOOL bUsersOnly = FALSE);

protected:
    void    ProcessSelectedObjects(IDataObject *pdo);

protected:
    BOOL    m_fMultiselect;
    CString m_MachineName;
};

class COMDLL CGetComputer 
{
public:
    CGetComputer();
    ~CGetComputer();

    BOOL    GetComputer(HWND hwndOwner);

protected:
    void    ProcessSelectedObjects(IDataObject *pdo);

public:
    CString     m_strComputerName;
};

#endif // OBJPICK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\objpick.cpp ===
// objpick.cpp: implementation of the CGetUser class and the 
//              CGetComputer class using the object picker
//
//////////////////////////////////////////////////////////////////////
#include "stdafx.h"

#include <iads.h>           

#include <objsel.h>
#include <adshlp.h>
#include <winsock2.h>
#include <comdef.h>
#include "common.h"

#include "objpick.h"
#include "accentry.h"
#include "util.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


#define BREAK_ON_FAIL_HRESULT(hr)       \
    if (FAILED(hr)) { TRACE(_T("line %u err 0x%x\n"), __LINE__, hr); break; }

UINT g_cfDsObjectPicker; // = ::RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

HRESULT InitObjectPickerForGroups(IDsObjectPicker *pDsObjectPicker, 
                                  BOOL fMultiselect,
                                  LPCTSTR pszMachineName,
                                  BOOL bUsersOnly);
HRESULT InitObjectPickerForComputers(IDsObjectPicker *pDsObjectPicker);

CAccessEntryArray::~CAccessEntryArray()
{
    for (int i = 0; i < GetSize(); i++)
        delete GetAt(i);
}

//////////////////////////////////////////////////////////////////////
// CGetUsers Class
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


void    
FormatName(LPCTSTR pszFullName, LPCTSTR pszDomainName, CString & strDisplay)
{
    strDisplay.Format(_T("%s\\%s"), pszDomainName, pszFullName);
}

CGetUsers::CGetUsers(LPCTSTR pszMachineName, BOOL fMultiselect)
    : m_MachineName(pszMachineName),
      m_fMultiselect(fMultiselect)
{
}

CGetUsers::~CGetUsers()
{

}

BOOL
CGetUsers::GetUsers(HWND hwndParent, BOOL bUsersOnly)
{
    HRESULT             hr = S_OK;
    IDsObjectPicker *   pDsObjectPicker = NULL;
    IDataObject *       pdo = NULL;
    BOOL                fSuccess = TRUE;

    hr = CoInitialize(NULL);
    if (FAILED(hr)) 
        return FALSE;

    do
    {
        //
        // Create an instance of the object picker.  The implementation in
        // objsel.dll is apartment model.
        //
        hr = CoCreateInstance(CLSID_DsObjectPicker,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDsObjectPicker,
                              (void **) &pDsObjectPicker);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = InitObjectPickerForGroups(pDsObjectPicker, m_fMultiselect, m_MachineName, bUsersOnly);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Invoke the modal dialog.
        //
        hr = pDsObjectPicker->InvokeDialog(hwndParent, &pdo);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // If the user hit Cancel, hr == S_FALSE
        //
        if (hr == S_FALSE)
        {
            TRACE(_T("User canceled object picker dialog\n"));
            fSuccess = FALSE;
            break;
        }

        //
        // Process the user's selections
        //
        ASSERT(pdo);
        ProcessSelectedObjects(pdo);

        pdo->Release();
        pdo = NULL;

    } while (0);

    if (pDsObjectPicker)
    {
        pDsObjectPicker->Release();
    }
    
    CoUninitialize();

    if (FAILED(hr) || S_FALSE == hr)
        fSuccess = FALSE;

    return fSuccess;
}

void
CGetUsers::ProcessSelectedObjects(IDataObject *pdo)
{
    HRESULT hr = S_OK;

    STGMEDIUM stgmedium =
    {
        TYMED_HGLOBAL,
        NULL,
        NULL
    };

    if (g_cfDsObjectPicker == 0)
       g_cfDsObjectPicker = ::RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);
    ASSERT(g_cfDsObjectPicker != 0);

    FORMATETC formatetc =
    {
        (CLIPFORMAT)g_cfDsObjectPicker,
        NULL,
        DVASPECT_CONTENT,
        -1,
        TYMED_HGLOBAL
    };

    BOOL fGotStgMedium = FALSE;

    do
    {
        hr = pdo->GetData(&formatetc, &stgmedium);
        BREAK_ON_FAIL_HRESULT(hr);

        fGotStgMedium = TRUE;

        PDS_SELECTION_LIST pDsSelList =
            (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);

        if (!pDsSelList)
        {
            TRACE(_T("GlobalLock error %u\n"), GetLastError());
            break;
        }

        // create the path name thing
        IADsPathname * pIADsPathname;
        hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                             IID_IADsPathname, (PVOID *)&pIADsPathname);
        BREAK_ON_FAIL_HRESULT(hr);
        if (FAILED(hr = pIADsPathname->SetDisplayType(ADS_DISPLAY_VALUE_ONLY)))
        {
            pIADsPathname->Release();
            break;
        }
        for (UINT i = 0; i < pDsSelList->cItems; i++)
        {
            PSID psid = NULL;
            DS_SELECTION * pDsSel = &(pDsSelList->aDsSelection[i]);
            if (pDsSel->pvarFetchedAttributes != NULL)
            {
               hr = SafeArrayAccessData(V_ARRAY(pDsSel->pvarFetchedAttributes), &psid);
            }
            if (psid != NULL)
            {
                LPWSTR pwzADsPath = pDsSel->pwzADsPath;
                if (FAILED(hr = pIADsPathname->Set(pwzADsPath, ADS_SETTYPE_FULL)))
                    continue;
                long lnNumPathElements = 0;
                if (FAILED(hr = pIADsPathname->GetNumElements(&lnNumPathElements)))
                    continue;
                BSTR bstrUser = NULL, bstrDomain = NULL;
                if (FAILED(hr = pIADsPathname->GetElement(0, &bstrUser)))
                    continue;
                switch (lnNumPathElements)
                {
                    case 1:
                        hr = pIADsPathname->Retrieve(ADS_FORMAT_SERVER, &bstrDomain);
                        break;

                    case 2:  // nt4, nt5 domain
                    case 3:  // local domain
                        hr = pIADsPathname->GetElement(1, &bstrDomain);
                        break;

                    default:
                        ASSERT(FALSE);
                        hr = E_FAIL;
                }
                if (FAILED(hr))
                    continue;
                CString name;
                FormatName(bstrUser, bstrDomain, name);
                if (bstrDomain != NULL)
                    SysFreeString(bstrDomain);
                if (bstrUser != NULL)
                    SysFreeString(bstrUser);
                CAccessEntry * entry = 
                    new CAccessEntry(psid, name, pDsSel->pwzClass);
                Add(entry);
            }
        }
        pIADsPathname->Release();
        GlobalUnlock(stgmedium.hGlobal);

    } while (0);

    if (fGotStgMedium)
    {
        ReleaseStgMedium(&stgmedium);
    }
}


//////////////////////////////////////////////////////////////////////
// CGetComputer Class
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CGetComputer::CGetComputer()
{
}

CGetComputer::~CGetComputer()
{
}

BOOL
CGetComputer::GetComputer(HWND hwndParent)
{
    HRESULT             hr = S_OK;
    IDsObjectPicker *   pDsObjectPicker = NULL;
    IDataObject *       pdo = NULL;
    BOOL                fSuccess = TRUE;

    hr = CoInitialize(NULL);
    if (FAILED(hr)) 
        return FALSE;

    do
    {
        //
        // Create an instance of the object picker.  The implementation in
        // objsel.dll is apartment model.
        //
        hr = CoCreateInstance(CLSID_DsObjectPicker,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDsObjectPicker,
                              (void **) &pDsObjectPicker);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Reinitialize the object picker to choose computers
        //

        hr = InitObjectPickerForComputers(pDsObjectPicker);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Now pick a computer
        //

        hr = pDsObjectPicker->InvokeDialog(hwndParent, &pdo);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // If the user hit Cancel, hr == S_FALSE
        //
        if (hr == S_FALSE)
        {
            TRACE(_T("User canceled object picker dialog\n"));
            fSuccess = FALSE;
            break;
        }

        ASSERT(pdo);
        ProcessSelectedObjects(pdo);

        pdo->Release();
        pdo = NULL;
    
    } while (0);

    if (pDsObjectPicker)
    {
        pDsObjectPicker->Release();
    }
    
    CoUninitialize();

    if (FAILED(hr))
        fSuccess = FALSE;

    return fSuccess;
}


void
CGetComputer::ProcessSelectedObjects(IDataObject *pdo)
{
    HRESULT hr = S_OK;

    STGMEDIUM stgmedium =
    {
        TYMED_HGLOBAL,
        NULL,
        NULL
    };

    if (g_cfDsObjectPicker == 0)
       g_cfDsObjectPicker = ::RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);
    ASSERT(g_cfDsObjectPicker != 0);

    FORMATETC formatetc =
    {
        (CLIPFORMAT)g_cfDsObjectPicker,
        NULL,
        DVASPECT_CONTENT,
        -1,
        TYMED_HGLOBAL
    };

    BOOL fGotStgMedium = FALSE;

    do
    {
        hr = pdo->GetData(&formatetc, &stgmedium);
        BREAK_ON_FAIL_HRESULT(hr);

        fGotStgMedium = TRUE;

        PDS_SELECTION_LIST pDsSelList =
            (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);

        if (!pDsSelList)
        {
            TRACE(_T("GlobalLock error %u\n"), GetLastError());
            break;
        }

        CString strTemp = pDsSelList->aDsSelection[0].pwzName;
        if (strTemp.Left(2) == _T("\\\\"))
            strTemp = pDsSelList->aDsSelection[0].pwzName[2];

        if (ERROR_SUCCESS != ObjPickNameOrIpToHostname(strTemp, m_strComputerName))
        {
            //we use the name from the object picker if we failed to convert it into hostname
            m_strComputerName = strTemp;
        }

        GlobalUnlock(stgmedium.hGlobal);

    } while (0);

    if (fGotStgMedium)
    {
        ReleaseStgMedium(&stgmedium);
    }
}

//+--------------------------------------------------------------------------
//
//  Function:   InitObjectPickerForGroups
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick one or more groups.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//  History:    10-14-1998   DavidMun   Created
//              1-8-2000     SergeiA    Adapted for IIS
//
//---------------------------------------------------------------------------
HRESULT
InitObjectPickerForGroups(IDsObjectPicker *pDsObjectPicker, 
                          BOOL fMultiselect,
                          LPCTSTR pszMachineName,
                          BOOL bUsersOnly)
{
    //
    // Prepare to initialize the object picker.
    // Set up the array of scope initializer structures.
    //

    static const int     SCOPE_INIT_COUNT = 5;
    DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];

    ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);

    //
    // Target computer scope.  This adds a "Look In" entry for the
    // target computer.  Computer scopes are always treated as
    // downlevel (i.e., they use the WinNT provider).
    //

    aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[0].flType = DSOP_SCOPE_TYPE_TARGET_COMPUTER;
    aScopeInit[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;
    aScopeInit[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS;
    aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;
    if (!bUsersOnly)
    {
       aScopeInit[0].FilterFlags.flDownlevel |= 
//            DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS;
            DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS;
    }

    //
    // The domain to which the target computer is joined.  Note we're
    // combining two scope types into flType here for convenience.
    //

    aScopeInit[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[1].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
    aScopeInit[1].flType = 
          DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
      |   DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
    aScopeInit[1].FilterFlags.Uplevel.flNativeModeOnly = DSOP_FILTER_USERS;
    if (!bUsersOnly)
    {
      aScopeInit[1].FilterFlags.Uplevel.flNativeModeOnly |= 
            DSOP_FILTER_GLOBAL_GROUPS_SE
         |  DSOP_FILTER_UNIVERSAL_GROUPS_SE
         |  DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE;
    }
    aScopeInit[1].FilterFlags.Uplevel.flMixedModeOnly = DSOP_FILTER_USERS;
    if (!bUsersOnly)
    {
       aScopeInit[1].FilterFlags.Uplevel.flMixedModeOnly |= DSOP_FILTER_GLOBAL_GROUPS_SE;
    }
    aScopeInit[1].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;
    if (!bUsersOnly)
    {
       aScopeInit[1].FilterFlags.flDownlevel |= DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS;
    }

    //
    // The domains in the same forest (enterprise) as the domain to which
    // the target machine is joined.  Note these can only be DS-aware
    //

    aScopeInit[2].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[2].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
    aScopeInit[2].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
    
    aScopeInit[2].FilterFlags.Uplevel.flNativeModeOnly = DSOP_FILTER_USERS;
    if (!bUsersOnly)
    {
       aScopeInit[2].FilterFlags.Uplevel.flNativeModeOnly |=
            DSOP_FILTER_GLOBAL_GROUPS_SE
         |  DSOP_FILTER_UNIVERSAL_GROUPS_SE;
    }
    aScopeInit[2].FilterFlags.Uplevel.flMixedModeOnly = DSOP_FILTER_USERS;
    if (!bUsersOnly)
    {
       aScopeInit[2].FilterFlags.Uplevel.flMixedModeOnly |= 
            DSOP_FILTER_GLOBAL_GROUPS_SE;
    }
    //
    // Domains external to the enterprise but trusted directly by the
    // domain to which the target machine is joined.
    //
    // If the target machine is joined to an NT4 domain, only the
    // external downlevel domain scope applies, and it will cause
    // all domains trusted by the joined domain to appear.
    //

    aScopeInit[3].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[3].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
    aScopeInit[3].flType =
         DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
      |  DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;

    aScopeInit[3].FilterFlags.Uplevel.flNativeModeOnly = DSOP_FILTER_USERS;
    if (!bUsersOnly)
    {
       aScopeInit[3].FilterFlags.Uplevel.flNativeModeOnly |= 
            DSOP_FILTER_GLOBAL_GROUPS_SE
         |  DSOP_FILTER_UNIVERSAL_GROUPS_SE;
    }

    aScopeInit[3].FilterFlags.Uplevel.flMixedModeOnly = DSOP_FILTER_USERS;
    if (!bUsersOnly)
    {
       aScopeInit[3].FilterFlags.Uplevel.flMixedModeOnly |= 
            DSOP_FILTER_GLOBAL_GROUPS_SE;
    }

    aScopeInit[3].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;
    if (!bUsersOnly)
    {
       aScopeInit[3].FilterFlags.flDownlevel |= 
            DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS;
    }

    //
    // The Global Catalog
    //

    aScopeInit[4].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[4].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
    aScopeInit[4].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;

    // Only native mode applies to gc scope.

    aScopeInit[4].FilterFlags.Uplevel.flNativeModeOnly = DSOP_FILTER_USERS;
    if (!bUsersOnly)
    {
       aScopeInit[4].FilterFlags.Uplevel.flNativeModeOnly |= 
            DSOP_FILTER_GLOBAL_GROUPS_SE
         |  DSOP_FILTER_UNIVERSAL_GROUPS_SE;
    }

    //
    // Put the scope init array into the object picker init array
    //

    DSOP_INIT_INFO  InitInfo;
    ZeroMemory(&InitInfo, sizeof(InitInfo));

    InitInfo.cbSize = sizeof(InitInfo);

    //
    // The pwzTargetComputer member allows the object picker to be
    // retargetted to a different computer.  It will behave as if it
    // were being run ON THAT COMPUTER.
    //

    InitInfo.pwzTargetComputer = pszMachineName;
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;
    InitInfo.flOptions = (fMultiselect) ? DSOP_FLAG_MULTISELECT : 0;

    LPCTSTR attrs[] = {_T("ObjectSid")};
    InitInfo.cAttributesToFetch = sizeof(attrs) / sizeof(attrs[0]);
    InitInfo.apwzAttributeNames = attrs;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

    HRESULT hr = pDsObjectPicker->Initialize(&InitInfo);
#ifdef _DEBUG
    if (FAILED(hr))
    {
        ULONG i;

        for (i = 0; i < SCOPE_INIT_COUNT; i++)
        {
            if (FAILED(InitInfo.aDsScopeInfos[i].hr))
            {
                TRACE(_T("Initialization failed because of scope %u\n"), i);
            }
        }
    }
#endif
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   InitObjectPickerForComputers
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick a single computer object.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//  History:    10-14-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
InitObjectPickerForComputers(IDsObjectPicker *pDsObjectPicker)
{
    //
    // Prepare to initialize the object picker.
    // Set up the array of scope initializer structures.
    //

    static const int     SCOPE_INIT_COUNT = 2;
    DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];

    ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);

    //
    // Build a scope init struct for everything except the joined domain.
    //

    aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[0].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
                           | DSOP_SCOPE_TYPE_GLOBAL_CATALOG
                           | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
                           | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
                           | DSOP_SCOPE_TYPE_WORKGROUP
                           | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
                           | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
    aScopeInit[0].FilterFlags.Uplevel.flBothModes =
        DSOP_FILTER_COMPUTERS;
    aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;


    //
    // scope for the joined domain, make it the default
    //
    aScopeInit[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[1].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
                           | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
    aScopeInit[1].FilterFlags.Uplevel.flBothModes =
        DSOP_FILTER_COMPUTERS;
    aScopeInit[1].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

    aScopeInit[1].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;

    //
    // Put the scope init array into the object picker init array
    //

    DSOP_INIT_INFO  InitInfo;
    ZeroMemory(&InitInfo, sizeof(InitInfo));

    InitInfo.cbSize = sizeof(InitInfo);
    InitInfo.pwzTargetComputer = NULL;  // NULL == local machine
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

    return pDsObjectPicker->Initialize(&InitInfo);
}

//Convert any valid name of a machine (IP address, NetBios name or fully qualified DNS name)
//to the host name
DWORD ObjPickNameOrIpToHostname(CString & strNameOrIp, CString & strHostName)
{
    DWORD dwErr = ERROR_SUCCESS;
    CString strTemp;

    CIPAddress ia(strNameOrIp);
    if (!ia.IsValid())
    {
        dwErr = MyGetHostName((DWORD)ia, strTemp);
    }
    else
    {
         // just want the host name
         int nDot = strNameOrIp.Find('.');
         if (nDot != -1)
         {
             strTemp = strNameOrIp.Left(nDot);
         }
         else
         {
             strTemp = strNameOrIp;
         }
    }

    if (ERROR_SUCCESS == dwErr)
    {
        strHostName = strTemp;
    }

    return dwErr;
}

BOOL
GetIUsrAccount(
    IN  LPCTSTR lpstrServer,
    IN  CWnd * pParent,      OPTIONAL
    OUT CString & str
    )
/*++

Routine Description:

    Helper function to browse for IUSR Account

Arguments:

    LPCTSTR lpstrServer : Server
    CWnd * pParent      : Parent window
    CString & str       : Will contain the selected account

Return Value:

    TRUE if an account was selected FALSE if not

--*/
{
    CGetUsers usrBrowser(lpstrServer);
    BOOL bRes = usrBrowser.GetUsers(pParent->GetSafeHwnd(), TRUE);
    if (bRes)
    {
       if (usrBrowser.GetSize() != 0)
       {
         str = usrBrowser.GetAt(0)->QueryUserName();
       }
       else
          bRes = FALSE;
    }
    return bRes;
}

BOOL
GetIUsrAccount(
    LPCTSTR lpstrServer,
    CWnd * pParent,
    TCHAR * pBuffer,
    int size
    )
/*++

Routine Description:

    Helper function to browse for IUSR Account

Arguments:

    LPCTSTR lpstrServer : Server
    CWnd * pParent      : Parent window
    CString & str       : Will contain the selected account

Return Value:

    TRUE if an account was selected FALSE if not

--*/
{
    CGetUsers usrBrowser(lpstrServer);
    BOOL bRes = usrBrowser.GetUsers(pParent->GetSafeHwnd(), TRUE);
    if (bRes)
    {
       if (usrBrowser.GetSize() != 0)
       {
          lstrcpyn(pBuffer, usrBrowser.GetAt(0)->QueryUserName(), size - 1);
       }
       else
          bRes = FALSE;
    }
    return bRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\objplus.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        objplus.cpp

   Abstract:

        Base object classes

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager (cluster edition)

   Revision History:

--*/



//
// Include Files
//
#include "stdafx.h"
#include "common.h"

#include <stdlib.h>
#include <memory.h>
#include <ctype.h>



#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



#define new DEBUG_NEW



CObjHelper::CObjHelper()
/*++

Routine Description:

    Constructor for super object help class

Arguments:

    None

Return Value:

    N/A

--*/
    : m_ctor_err(ERROR_SUCCESS),
      m_api_err(ERROR_SUCCESS),
      m_fDirty(FALSE),
      m_time_created(::GetCurrentTime())
{
}



void
CObjHelper::ReportError(
    IN LONG errInConstruction
    )
/*++

Routine Description:

    Set the constructor error code, and dump the error message to
    the debugging context.

Arguments:

    LONG errInConstruction : Error code

Return Value:

    None

--*/
{
    TRACEEOLID("CObjectPlus construction failure, error = "
        << errInConstruction);

    m_ctor_err = errInConstruction;
}



LONG
CObjHelper::SetApiErr(
    IN LONG errApi
    )
/*++

Routine Description:

    Set the API error code.

Arguments:

    LONG errApi  : API error code

Return Value:

    The API error code

--*/
{
    return m_api_err = errApi;
}



BOOL
CObjHelper::IsValid() const
/*++

Routine Description:

    Determine if the object is in a valid state

Arguments:

    LONG errApi  : API error code

Return Value:

    TRUE if the the object is in a valid state, FALSE otherwise

--*/
{
    return QueryError() == 0;
}



DWORD
CObjHelper::QueryAge() const
/*++

Routine Description:

    Determine the age of the object.

Arguments:

    None

Return Value:

    time_t value indicating the age of the object.

--*/
{
    DWORD dwTime = ::GetCurrentTime(),
          dwDiff;

    if (dwTime < m_time_created)
    {
        dwDiff = dwTime + (((DWORD)-1) - (m_time_created - 1));
    }
    else
    {
        dwDiff = dwTime - m_time_created;
    }

    return dwDiff;
}



#ifdef _DEBUG



void
CObjHelper::AssertValid() const
/*++

Routine Description:

    Assert the object if the object is in a valid state

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT(IsValid());
}



#endif // _DEBUG



CObjectPlus::CObjectPlus()
/*++

Routine Description:

    Constructor of extended object

Arguments:

    None

Return Value:

    N/A

--*/
{
}



int
CObjectPlus::Compare(
    IN const CObjectPlus * pob
    ) const
/*++

Routine Description:

    Compare one object with another:  default implementation orders objects
    by creation time.  Return -1, 0 or 1.

Arguments:

    const CObjectPlus * pob : Object to be compared against

Return Value:

    -1 if this object is < than the compared object
     0 if this object is == to the compared object
    +1 if this object is > than the compared object

--*/
{
    return QueryCreationTime() < pob->QueryCreationTime()
        ? -1
        : QueryCreationTime() != pob->QueryCreationTime();
}



CObListPlus::CObListPlus(
    IN int nBlockSize
    )
/*++

Routine Description:

    Subclass of CObList whose default behavior is to destroy its
    contents during its own destruction

Arguments:

    int nBlockSize : Initial block size

Return Value:

    None

--*/
    : CObList(nBlockSize),
      m_fOwned(TRUE)
{
}



CObListPlus::~CObListPlus()
/*++

Routine Description:

    Destructor.  If the objects are owned, clean them up.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    RemoveAll();
}



void
CObListPlus::RemoveAll()
/*++

Routine Description:

    Remove all the objects in the list if the list owns its objects

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_fOwned)
    {
        //
        // Remove and discard all the objects
        //
        while (!IsEmpty())
        {
            CObject * pob = RemoveHead();
            delete pob ;
        }
    }
    else
    {
        //
        // Just remove the object pointers
        //
        CObList::RemoveAll();
    }
}



CObject *
CObListPlus::Index(
    IN int index
    )
/*++

Routine Description:

    Get object by index

Arguments:

    int index  : The index of the object to be returned

Return Value:

    The object, or NULL if the index is invalid

--*/
{
   CObListIter obli(*this);

   CObject * pob = NULL;

   for (int i = 0; (NULL != (pob = obli.Next())) && i++ < index; /**/ );

   return pob;
}



BOOL
CObListPlus::RemoveIndex(
    IN int index
    )
/*++

Routine Description:

    Remove object by index

Arguments:

    int index  : The index of the object to be removed

Return Value:

    The object, or NULL if the index is invalid

--*/
{
    int i;
    POSITION pos;
    CObListIter obli(*this);
    CObject * pob;

    for (i = 0, pos = obli.QueryPosition();
        (NULL != (pob = obli.Next())) && i < index;
        i++, pos = obli.QueryPosition());

    if (pob && i == index)
    {
        RemoveAt(pos);

        return TRUE;
    }

    return FALSE;
}



BOOL
CObListPlus::Remove(
    IN CObject * pob
    )
/*++

Routine Description:

    Remove the first (and hopefully only) occurrence of an object
    pointer from this list.

Arguments:

    CObject * pob : The object to be removed

Return Value:

    TRUE if the object was found and succesfully removed, FALSE otherwise

--*/
{
    POSITION pos = Find(pob);

    if (pos == NULL)
    {
        return FALSE;
    }

    RemoveAt(pos);

    return TRUE;
}



void
CObListPlus::RemoveAt(
    IN POSITION & pos
    )
/*++

Routine Description:

    Override of RemoveAt to delete the pointer at the position
    given

Arguments:

    POSITION pos        : Position of item to delete

Return Value:

    None.

Notes:

    The item will only be deleted if this is an "owned" list.

--*/
{
    CObject * pItem = GetAt(pos);

    CObList::RemoveAt(pos);

    if (m_fOwned)
    {
        delete pItem;
    }
}



BOOL
CObListPlus::SetAll(
    IN BOOL fDirty
    )
/*++

Routine Description:

    Set all elements to dirty or clean.  Return TRUE if any element was dirty.

Arguments:

    BOOL fDirty : Dirty flag to set the objects with

Return Value:

    TRUE if any element was dirty.

--*/
{
    int cDirtyItems = 0;
    CObjectPlus * pob;
    CObListIter obli(*this);

    while (NULL != (pob = (CObjectPlus *)obli.Next()))
    {
        cDirtyItems += pob->IsDirty();
        pob->SetDirty(fDirty);
    }

    SetDirty(fDirty);

    return cDirtyItems > 0;
}



int
CObListPlus::FindElement(
    IN CObject * pobSought
    ) const
/*++

Routine Description:

    Find the object in the list.

Arguments:

    CObject * pobSought : Object to be looked for

Return Value:

    The index of the object, or -1 if it wasn't found.

--*/
{
    CObject * pob;
    CObListIter obli(*this);

    for (int i = 0;
        (NULL != (pob = obli.Next())) && pob != pobSought;
        i++);

    return pob
        ? i
        : -1;
}


//
// Sorting structure
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

typedef struct
{
    CObjectPlus * pObj;                        // Pointer to object to be sorted
    CObjectPlus::PCOBJPLUS_ORDER_FUNC  pFunc;  // Pointer to ordering function
} CBOWNEDLIST_SORT_HELPER;



int _cdecl
CObListPlus::SortHelper(
    IN const void * pa,
    IN const void * pb
    )
/*++

Routine Description:

    This static member function is used to quick sort an array of structures
    as declared above.  Each element contains the object pointer and a
    pointer to the object's member function to be invoked for comparison.

Arguments:

    const void * pa      : Sorting help struct 1
    const void * pb      : Sorting help struct 2

Return Value:

    Sort return code

--*/
{
    CBOWNEDLIST_SORT_HELPER *pHelp1 = (CBOWNEDLIST_SORT_HELPER *)pa,
                            *pHelp2 = (CBOWNEDLIST_SORT_HELPER *)pb;

    return (pHelp1->pObj->*pHelp1->pFunc)(pHelp2->pObj);
}



DWORD
CObListPlus::Sort(
    IN CObjectPlus::PCOBJPLUS_ORDER_FUNC pOrderFunc
    )
/*++

Routine Description:

    Sort the list by recreating it entirely.

Arguments:

    CObjectPlus::PCOBJPLUS_ORDER_FUNC pOrderFunc : Ordering function

Return Value:

    Error code

--*/
{
    DWORD err = ERROR_SUCCESS;
    int cItems = (int)GetCount();

    if (cItems < 2)
    {
        return err;
    }

    CObjectPlus * pObNext;
    CObListIter obli(*this);
    BOOL fOwned = SetOwnership(FALSE);
    int i;

    CBOWNEDLIST_SORT_HELPER * paSortHelpers = NULL;

    //
    // Allocate the helper array
    //
    paSortHelpers = AllocMemByType(cItems, CBOWNEDLIST_SORT_HELPER);
    if (paSortHelpers == NULL)
    {
       return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Fill the helper array.
    //
    for (i = 0; NULL != (pObNext = (CObjectPlus *)obli.Next()); i++)
    {
        paSortHelpers[i].pFunc = pOrderFunc;
        paSortHelpers[i].pObj = pObNext;
    }

    //
    // Release all object pointer references.  Note that we
    // forced "owned" to FALSE above.
    //
    RemoveAll();
    ASSERT(GetCount() == 0);

    //
    // Sort the helper array
    //
    ::qsort( (void *) paSortHelpers,
         cItems,
         sizeof(paSortHelpers[0]),
         SortHelper
         );

    //
    // Refill the list from the helper array.
    //
    for (i = 0; i < cItems; i++ )
    {
        AddTail(paSortHelpers[i].pObj);
    }

    ASSERT(GetCount() == cItems);

    //
    // Delete the working array
    //
    FreeMem(paSortHelpers);

    //
    // Restore the object ownership state
    //
    SetOwnership(fOwned);

    return err;
}



CObListIter::CObListIter(
    IN const CObListPlus & obList
    )
/*++

Routine Description:

    Constructor of ObOwnedList iterator

Arguments:

    const CObListPlus & obList : List to be iterated

Return Value:

    N/A

--*/
    : m_obList(obList)
{
    Reset();
}



void
CObListIter::Reset()
/*++

Routine Description:

    Reset the iterator

Arguments:

    None

Return Value:

    None

--*/
{
    m_pos = m_obList.GetCount()
        ? m_obList.GetHeadPosition()
        : NULL;
}



CObject * CObListIter::Next()
/*++

Routine Description:

    Get the next object in the list, or NULL

Arguments:

    None

Return Value:

    The next object in the list, or NULL

--*/
{
    return m_pos == NULL
        ? NULL
        : m_obList.GetNext(m_pos);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by iisui.rc
//
#define chx1                            0x0410
#define stc1                            0x0440
#define stc2                            0x0441
#define stc3                            0x0442
#define stc4                            0x0443
#define lst1                            0x0460
#define lst2                            0x0461
#define cmb1                            0x0470
#define cmb2                            0x0471
#define edt1                            0x0480
#define IDC_STATIC_WZ_WELCOME           4000
#define IDC_STATIC_WZ_TITLE             4001
#define IDC_STATIC_WZ_SUBTITLE          4002
#define IDC_STATIC_WZ_BODY              4003
#define IDC_STATIC_WZ_CLICK             4004
#define IDC_STATIC_WZ_HEADER_DIVIDER    4005
#define IDC_ED_BOLD1                    4011
#define IDC_ED_BOLD2                    4012
#define IDC_ED_BOLD3                    4013
#define IDC_ED_BOLD4                    4014
#define IDC_ED_BOLD5                    4015
#define IDB_UP                          10013
#define IDB_UPFOC                       10014
#define IDB_UPDIS                       10015
#define IDB_UPINV                       10016
#define IDB_DOWN                        10017
#define IDB_DOWNFOC                     10018
#define IDB_DOWNDIS                     10019
#define IDB_DOWNINV                     10020
#define IDB_ACLUSERS                    10021
#define IDI_AUTHENTICATION              10050
#define IDI_GRANTED                     10051
#define IDI_DENIED                      10052
#define IDC_EDIT_CONFIRM_PASSWORD       11007
#define IDC_BUTTON_ADD                  11008
#define IDC_IPA_SUBNET_MASK             11010
#define IDC_STATIC_PASSWORD             11011
#define IDC_BUTTON_EDIT                 11012
#define IDC_BUTTON_REMOVE               11013
#define IDC_LIST_IP_ADDRESSES           11014
#define IDC_RADIO_GRANTED               11018
#define IDC_RADIO_DENIED                11019
#define IDC_RADIO_SINGLE                11020
#define IDC_RADIO_MULTIPLE              11021
#define IDC_STATIC_SUBNET_MASK          11022
#define IDC_STATIC_IP_ADDRESS           11023
#define IDC_IPA_IPADDRESS               11024
#define IDC_BUTTON_DNS                  11025
#define IDC_EDIT_DNS_NAME               11026
#define IDC_STATIC_BY_DEFAULT           11027
#define IDC_STATIC_EXCEPT               11028
#define IDC_ICON_GRANTED                11029
#define IDC_ICON_DENIED                 11030
#define IDC_RADIO_DOMAIN                11033
#define IDC_EDIT_DOMAIN                 11034
#define IDC_LIST_CHILD_NODES            11042
#define IDC_BUTTON_SELECT_ALL           11043
#define IDC_STATIC_PROMPT               11044
#define IDC_STATIC_GROUP_DETAILS        11045
#define IDC_BUTTON_E3                   11048
#define IDC_STATIC_ERROR_ICON           11049
#define IDC_STATIC_DIR_NAME             11050
#define IDC_EDIT_NEW_DIRECTORY_NAME     11051
#define IDC_EDIT_USERNAME               11052
#define IDC_STATIC_USERNAME             11054
#define IDC_BUTTON_CHECK_PASSWORD       11055
#define IDC_BUTTON_BROWSE_USERS         11056
#define IDD_CONFIRM_PASSWORD            15000
#define IDD_DIRBROWSE                   15006
#define IDD_INHERITANCE                 15012
#define IDD_ERROR                       15013
#define IDD_WIZARD_BOOKEND              15020
#define IDS_DDX_MINIMUM                 20110
#define IDS_PASSWORD_NO_MATCH           20111
#define IDS_INHERITANCE_NO_NAME         20112
#define IDS_INHERITANCE_PROMPT          20113
#define IDS_FMT_SECURITY                20127
#define IDS_NO_MESSAGE                  20132
#define IDS_DEFAULT_IP                  20133
#define IDS_INVALID_NUMBER              20134
#define IDS_SELECT_ADMIN                20135
#define IDS_BROWSE_DOMAIN               20136
#define IDS_SELECT_IUSR_ACCOUNT         20137
#define IDS_PASSWORD_OK                 20138
#define IDS_BROWSE_DIRECTORY            20287
#define IDS_BAD_BROWSE                  20288
#define IDS_ALL_UNASSIGNED              20289
#define IDS_INVALID_IP_ADDRESS          20290
#define IDS_UNKNOWN_USER                20291
#define IDS_WIZ_NEXT                    20355
#define IDS_WIZ_FINISH                  20356
#define IDS_PATH_INPUT_INVALID_ALLOW_DEVICE_PATH 20357
#define IDS_ADDRESS_IP                  21015
#define IDS_ERR_INVALID_PATH            21100
#define IDS_ERR_PATH_NOT_FOUND          21101
#define IDS_ERR_BAD_PATH                21102
#define IDS_BAD_UNC_PATH                21103
#define IDS_BAD_URL_PATH                21104
#define IDS_ERR_FILE_NOT_FOUND          21105
#define IDS_ERR_RPC_NA                  50000
#define IDS_ERR_INTERFACE               50001
#define IDS_ERR_ODBC                    50002
#define IDS_ERR_NO_MESSAGE              50003
#define IDS_ERR_CANT_START_SERVICE      50004
#define IDS_ERR_METABASE_ERROR          50005
#define IDS_ERR_DUP_VROOT               50006
#define IDS_ERR_NO_INTERFACE            50007
#define IDS_ERR_NO_SHUTDOWN             50008
#define IDS_ERR_NO_BACKUP_RESTORE       50009
#define IDS_ERR_CANNOT_RESTORE          50010
#define IDS_ERR_RPC_NA_SHORT            50011
#define IDS_ERR_ACCESS_DENIED           50012
#define IDS_ERR_BINDING_SHORT           50013
#define IDS_ERR_BINDING_LONG            50014
#define IDS_ERROR                       50015
#define IDS_ERR_BAD_BACKUP_NAME         50016
#define IDS_PATH_INPUT_INVALID          50017
#define IDS_ERR_INVALID_HOSTHEADER_CHARS 50018
#define IDS_ERR_NUM_TOO_LARGE           50019

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\odlbox.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        odlbox.cpp

   Abstract:

        Owner draw listbox/combobox base classes

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager (cluster edition)

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "common.h"



#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



#define new DEBUG_NEW

#define BMP_LEFT_OFFSET  (1)          // Space allotted to the left of bitmap
#define BMP_RIGHT_OFFSET (3)          // Space allotted to the right of bitmap

//
// Ellipses are shown when column text doesn't fit in the display
//
const TCHAR g_szEllipses[] = _T("...");
int g_nLenEllipses = (sizeof(g_szEllipses) / sizeof(g_szEllipses[0])) - 1;

//
// Registry value for columns
//
const TCHAR g_szRegColumns[] = _T("Columns");

//
// Column Value Separator
//
const TCHAR g_szColValueSep[] = _T(" ");



void
GetDlgCtlRect(
    IN  HWND hWndParent,
    IN  HWND hWndControl,
    OUT LPRECT lprcControl
    )
/*++

Routine Description:

    Get the control rectangle coordinates relative to its parent.  This can
    then be used in e.g. SetWindowPos()

Arguments:

    HWND hWndParent    : Parent window handle
    HWND hWndControl   : Control window handle
    LPRECT lprcControl : Control rectangle to be filled in

Return Value:

    None

--*/
{
#define MapWindowRect(hwndFrom, hwndTo, lprc)\
     MapWindowPoints((hwndFrom), (hwndTo), (POINT *)(lprc), 2)

    ::GetWindowRect(hWndControl, lprcControl);
    ::MapWindowRect(NULL, hWndParent, lprcControl);
}



void
FitPathToControl(
    IN CWnd & wndControl,
    IN LPCTSTR lpstrString,
	IN BOOL bIsFilePath
    )
/*++

Routine Description:

    Display the given path in the given control, using ellipses
    to ensure that the path fits within the control.

Arguments:

    CWnd & wndControl       : Control to display on
    LPCTSTR lpstrString       : Path

Return Value:

    None

--*/
{
    CString strDisplay(lpstrString);
    UINT uLength = strDisplay.GetLength() + 4;  // Account for ell.
    LPTSTR lp = strDisplay.GetBuffer(uLength);

    if (lp)
    {
        CDC * pDC = wndControl.GetDC();
        ASSERT_PTR(pDC);

        if (pDC != NULL)
        {
            CRect rc;
            wndControl.GetClientRect(&rc);
			if (bIsFilePath)
			{
				pDC->DrawText(lp, uLength, &rc, DT_PATH_ELLIPSIS | DT_MODIFYSTRING);
			}
			else
			{
				pDC->DrawText(lp, uLength, &rc, DT_END_ELLIPSIS | DT_MODIFYSTRING);
			}
            wndControl.ReleaseDC(pDC);
        }

        strDisplay.ReleaseBuffer();
        wndControl.SetWindowText(strDisplay);
    }
}



void
ActivateControl(
    IN CWnd & wndControl,
    IN BOOL fShow
    )
/*++

Routine Description:

    Show/hide _AND_ enable/disable control window

Arguments:

    CWnd & wndControl           : Window in question
    BOOL fShow                  : TRUE to show/enable,
                                  FALSE to hide/disable

Return Value:

    None

Notes:

    Merely hiding a window does not disable it.  Use this function
    instead of ShowWindow() to do that.

--*/
{
    wndControl.ShowWindow(fShow ? SW_SHOW : SW_HIDE);
    wndControl.EnableWindow(fShow);
}



BOOL
VerifyState()
/*++

Routine Description:

    Verify keyboard state

Arguments:

    None

Return Value:

    TRUE if keyboard is in specified state
    FALSE otherwise.

--*/
{
    SHORT s1, s2;
    s1 = GetKeyState(VK_SHIFT);
    s2 = GetKeyState(VK_CONTROL);

    return (s1 & 0x8000) && (s2 & 0x8000);
}



BOOL
CMappedBitmapButton::LoadMappedBitmaps(
    IN UINT nIDBitmapResource,
    IN UINT nIDBitmapResourceSel,
    IN UINT nIDBitmapResourceFocus,
    IN UINT nIDBitmapResourceDisabled
    )
/*++

Routine Description:

    LoadBitmaps will load one, two, three or all four bitmaps
    returns TRUE if all specified images are loaded.  This
    will map the buttons to the default colours

Arguments:

    UINT nIDBitmapResource           : Standard button
    UINT nIDBitmapResourceSel        : Selected button
    UINT nIDBitmapResourceFocus      : Button with focus
    UINT nIDBitmapResourceDisabled   : Disabled button

--*/
{
    //
    // delete old bitmaps (if present)
    //
    m_bitmap.DeleteObject();
    m_bitmapSel.DeleteObject();
    m_bitmapFocus.DeleteObject();
    m_bitmapDisabled.DeleteObject();

    if (!m_bitmap.LoadMappedBitmap(nIDBitmapResource))
    {
        TRACEEOLID("Failed to load bitmap for normal image.");

        return FALSE;   // need this one image
    }

    BOOL bAllLoaded = TRUE;
    if (nIDBitmapResourceSel != 0)
    {
        if (!m_bitmapSel.LoadMappedBitmap(nIDBitmapResourceSel))
        {
            TRACEEOLID("Failed to load bitmap for selected image.");
            bAllLoaded = FALSE;
        }
    }
    if (nIDBitmapResourceFocus != 0)
    {
        if (!m_bitmapFocus.LoadMappedBitmap(nIDBitmapResourceFocus))
        {
            bAllLoaded = FALSE;
        }
    }

    if (nIDBitmapResourceDisabled != 0)
    {
        if (!m_bitmapDisabled.LoadMappedBitmap(nIDBitmapResourceDisabled))
        {
            bAllLoaded = FALSE;
        }
    }

    return bAllLoaded;
}



CRMCListBoxResources::CRMCListBoxResources(
    IN int bmId,
    IN int nBitmaps,
    IN COLORREF rgbBackground
    )
/*++

Routine Description:

    Constructor

Arguments:

    int bmId               : Bitmap resource ID
    int nBitmaps           : Number of bitmaps
    COLORREF rgbBackground : Background colour to mask out

Return Value:

    N/A

--*/
    : m_idBitmap(bmId),
      m_rgbColorTransparent(rgbBackground),
      m_nBitmaps(nBitmaps),
      m_nBitmapHeight(0),
      m_nBitmapWidth(-1),    // Set Later
      m_fInitialized(FALSE)
{
    ASSERT(m_nBitmaps > 0);
    GetSysColors();
    PrepareBitmaps();
}



CRMCListBoxResources::~CRMCListBoxResources()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    UnprepareBitmaps();
}



void
CRMCListBoxResources::UnprepareBitmaps()
/*++

Routine Description:

    Free up bitmap resources

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    ASSERT(m_fInitialized);

    if (m_fInitialized)
    {
        CBitmap * pBmp = (CBitmap *)CGdiObject::FromHandle(m_hOldBitmap);
        ASSERT_READ_PTR(pBmp);

        VERIFY(m_dcFinal.SelectObject(pBmp));
        VERIFY(m_dcFinal.DeleteDC());
        VERIFY(m_bmpScreen.DeleteObject());

        m_fInitialized = FALSE;
    }
}



void
CRMCListBoxResources::PrepareBitmaps()
/*++

Routine Description:

    Prepare 2 rows of bitmaps.  One with the selection colour background,
    and one with the ordinary listbox background.

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT(m_idBitmap);

    //
    // Clean up if we were already initialised
    //
    if (m_fInitialized)
    {
        UnprepareBitmaps();
    }

    //
    // create device contexts compatible with screen
    //
    CDC dcImage;
    CDC dcMasks;

    VERIFY(dcImage.CreateCompatibleDC(0));
    VERIFY(dcMasks.CreateCompatibleDC(0));

    VERIFY(m_dcFinal.CreateCompatibleDC(0));

    CBitmap bitmap;
    VERIFY(bitmap.LoadBitmap(m_idBitmap));

    BITMAP bm;
    VERIFY(bitmap.GetObject(sizeof(BITMAP), &bm));

    //
    // Each bitmap is assumed to be the same size.
    //
    m_nBitmapWidth = bm.bmWidth / m_nBitmaps;
    ASSERT(m_nBitmapWidth > 0);

    const int bmWidth = bm.bmWidth;
    const int bmHeight = bm.bmHeight;
    m_nBitmapHeight = bmHeight;

    CBitmap * pOldImageBmp = dcImage.SelectObject(&bitmap);
    ASSERT_PTR(pOldImageBmp);

    CBitmap bmpMasks;
    VERIFY(bmpMasks.CreateBitmap(bmWidth, bmHeight * 2, 1, 1, NULL));

    CBitmap * pOldMaskBmp = (CBitmap *)dcMasks.SelectObject(&bmpMasks);
    ASSERT_PTR(pOldMaskBmp);

    //
    // create the foreground and object masks
    //
    COLORREF crOldBk = dcImage.SetBkColor(m_rgbColorTransparent);
    dcMasks.BitBlt(0, 0, bmWidth, bmHeight, &dcImage, 0, 0, SRCCOPY);
    dcMasks.BitBlt(0, 0, bmWidth, bmHeight, &dcImage, 0, bmHeight, SRCAND);
    dcImage.SetBkColor(crOldBk);
    dcMasks.BitBlt(0, bmHeight, bmWidth, bmHeight, &dcMasks, 0, 0, NOTSRCCOPY);

    //
    // create DC to hold final image
    //
    VERIFY(m_bmpScreen.CreateCompatibleBitmap(&dcImage, bmWidth, bmHeight * 2));
    CBitmap * pOldBmp = (CBitmap*)m_dcFinal.SelectObject(&m_bmpScreen);
    ASSERT_PTR(pOldBmp);
    m_hOldBitmap = pOldBmp->m_hObject;

    CBrush b1, b2;
    VERIFY(b1.CreateSolidBrush(m_rgbColorHighlight));
    VERIFY(b2.CreateSolidBrush(m_rgbColorWindow));

    m_dcFinal.FillRect(CRect(0, 0, bmWidth, bmHeight), &b1);
    m_dcFinal.FillRect(CRect(0, bmHeight, bmWidth, bmHeight * 2), &b2);

    //
    // mask out the object pixels in the destination
    //
    m_dcFinal.BitBlt(0, 0, bmWidth, bmHeight, &dcMasks, 0, 0, SRCAND);

    //
    // mask out the background pixels in the image
    //
    dcImage.BitBlt(0, 0, bmWidth, bmHeight, &dcMasks, 0, bmHeight, SRCAND);

    //
    // XOR the revised image into the destination
    //
    m_dcFinal.BitBlt(0, 0, bmWidth, bmHeight, &dcImage, 0, 0, SRCPAINT);

    //
    // mask out the object pixels in the destination
    //
    m_dcFinal.BitBlt(0, bmHeight, bmWidth, bmHeight, &dcMasks, 0, 0, SRCAND);

    //
    // XOR the revised image into the destination
    //
    m_dcFinal.BitBlt(0, bmHeight, bmWidth, bmHeight, &dcImage, 0, 0, SRCPAINT);

    VERIFY(dcMasks.SelectObject(pOldMaskBmp));
    VERIFY(dcImage.SelectObject(pOldImageBmp));

    //
    // The result of all of this mucking about is a bitmap identical with the
    // one loaded from the resources but with the lower row of bitmaps having
    // their background changed from transparent1 to the window background
    // and the upper row having their background changed from transparent2 to
    // the highlight colour.  A derived CRMCListBox can BitBlt the relevant part
    // of the image into an item's device context for a transparent bitmap
    // effect which does not take any extra time over a normal BitBlt.
    //
    m_fInitialized = TRUE;
}



void
CRMCListBoxResources::SysColorChanged()
/*++

Routine Description:

    Respond to change in system colours by rebuilding the resources

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Reinitialise bitmaps and syscolors. This should be called from
    // the parent of the CRMCListBoxResources object from
    // the OnSysColorChange() function.
    //
    GetSysColors();
    PrepareBitmaps();
}



void
CRMCListBoxResources::GetSysColors()
/*++

Routine Description:

    Get sytem colours

Arguments:

    None

Return Value:

    None

--*/
{
    m_rgbColorWindow = ::GetSysColor(COLOR_WINDOW);
    m_rgbColorHighlight = ::GetSysColor(COLOR_HIGHLIGHT);
    m_rgbColorWindowText = ::GetSysColor(COLOR_WINDOWTEXT);
    m_rgbColorHighlightText = ::GetSysColor(COLOR_HIGHLIGHTTEXT);
}


CRMCListBoxDrawStruct::CRMCListBoxDrawStruct(
    IN CDC * pDC,
    IN RECT * pRect,
    IN BOOL sel,
    IN DWORD_PTR item,
    IN int itemIndex,
    IN const CRMCListBoxResources * pres
    )
/*++

Routine Description:

    Constructor

Arguments:

    CDC * pdc                           : Device context
    RECT * pRect                        : Rectange to paint into
    BOOL sel                            : TRUE if selected
    DWORD item                          : item
    int itemIndex                       : item index
    const CRMCListBoxResources * pres    : Pointer to resources

Return Value:

    N/A

--*/
    : m_pDC(pDC),
      m_Sel(sel),
      m_ItemData(item),
      m_ItemIndex(itemIndex),
      m_pResources(pres)
{
    m_Rect.CopyRect(pRect);
}



CODLBox::CODLBox()
/*++

Routine Description:

    Constructor for CODLBox -- abstract base class for both CRMCComboBox,
    and CRMCListBox

Arguments:

    None

Return Value:

    N/A

--*/
    : m_lfHeight(0),
      m_pResources(NULL),
      m_auTabs(),
      m_pWnd(NULL)
{
}



CODLBox::~CODLBox()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



/* virtual */
BOOL
CODLBox::Initialize()
/*++

Routine Description:

    Listbox/combobox is being created

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    //
    // Derived control must be attached at this point
    //
    ASSERT_PTR(m_pWnd);

    //
    // GetFont returns non NULL when the control is in a dialog box
    //
    CFont * pFont = m_pWnd->GetFont();

    if(pFont == NULL)
    {
        LOGFONT lf;
        CFont fontTmp;

        ::GetObject(::GetStockObject(SYSTEM_FONT), sizeof(LOGFONT), &lf);
        fontTmp.CreateFontIndirect(&lf);

        CalculateTextHeight(&fontTmp);
    }
    else
    {
        CalculateTextHeight(pFont);
    }

    return TRUE;
}



BOOL
CODLBox::ChangeFont(
    IN CFont * pFont
    )
/*++

Routine Description:

    Change the control font the specified font

Arguments:

    CFont * pFont : Pointer to the new font to be used

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    ASSERT_PTR(m_pResources);
    ASSERT_PTR(m_pWnd);

    if( pFont == NULL || m_pResources == NULL
     || m_pWnd == NULL || m_pWnd->m_hWnd == NULL
      )
    {
        TRACEEOLID("Invalid state of the control.  Can't change font");
        return FALSE;
    }

    //
    // Don't reflect changes immediately
    //
    m_pWnd->SetRedraw(FALSE);

    m_pWnd->SetFont(pFont, TRUE);
    CalculateTextHeight(pFont);

    int nItems = __GetCount();
    int bmHeight = m_pResources->BitmapHeight();
    int nHeight = bmHeight > m_lfHeight ? bmHeight : m_lfHeight;

    for(int i = 0; i < nItems; ++i)
    {
        __SetItemHeight(i, nHeight);
    }

    //
    // Now reflect the change visually
    //
    m_pWnd->SetRedraw(TRUE);
    m_pWnd->Invalidate();

    return TRUE;
}



void
CODLBox::AttachResources(
    IN const CRMCListBoxResources * pRes
    )
/*++

Routine Description:

    Attach the bitmaps

Arguments:

    const CRMCListBoxResources * pRes : pointer to resources to be attached

Return Value:

    None

--*/
{
    if(pRes != m_pResources)
    {
        ASSERT_READ_PTR(pRes);
        m_pResources = pRes;

        if(m_pWnd != NULL && m_pWnd->m_hWnd != NULL)
        {
            //
            // if window was created already, redraw everything.
            //
            m_pWnd->Invalidate();
        }
    }
}



/* static */
int
CODLBox::GetRequiredWidth(
    IN CDC * pDC,
    IN const CRect & rc,
    IN LPCTSTR lpstr,
    IN int nLength
    )
/*++

Routine Description:

    Determine required display width of the string

Arguments:

    CDC * pDC         : Pointer to device context to use
    const CRect & rc  : Starting rectangle
    LPCTSTR lpstr     : String whose width is to be displayed
    int nLength       : Length (in characters of the string

Return Value:

    The display width that the string would need to be displayed on the
    given device context

--*/
{
#ifdef _DEBUG

    pDC->AssertValid();

#endif // _DEBUG

    CRect rcTmp(rc);

    pDC->DrawText(
        lpstr,
        nLength,
        &rcTmp,
        DT_CALCRECT | DT_LEFT | DT_SINGLELINE | DT_NOPREFIX | DT_VCENTER
        );

    return rcTmp.Width();
}



/* static */
BOOL
CODLBox::ColumnText(
    IN CDC * pDC,
    IN int nLeft,
    IN int nTop,
    IN int nRight,
    IN int nBottom,
    IN LPCTSTR lpstr
    )
/*++

Routine Description:

    Display text limited by a rectangle.  Use ellipses if the text is too wide
    to fit inside the given dimensions.

Arguments:

    CDC * pDC     : Pointer to display context to use
    int nLeft     : Left coordinate
    int nTop      : Top coordinate
    int nRight    : Right coordinate
    int nBottom   : Bottom coordinate
    LPCTSTR lpstr : String to be displayed

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    BOOL fSuccess = TRUE;

#ifdef _DEBUG

    pDC->AssertValid();

#endif // _DEBUG

    CString str;
    CRect rc(nLeft, nTop, nRight, nBottom);

    int nAvailWidth = rc.Width();
    int nLength = ::lstrlen(lpstr);

    try
    {
        if (GetRequiredWidth(pDC, rc, lpstr, nLength) <= nAvailWidth)
        {
            //
            // Sufficient space, display as is.
            //
            str = lpstr;
        }
        else
        {
            //
            // Build a string with ellipses until it
            // fits
            //
            LPTSTR lpTmp = str.GetBuffer(nLength + g_nLenEllipses);
            while (nLength)
            {
                ::lstrcpyn(lpTmp, lpstr, nLength);
                ::lstrcpy(lpTmp + nLength - 1, g_szEllipses);

                if (GetRequiredWidth(pDC, rc, lpTmp,
                    nLength + g_nLenEllipses) <= nAvailWidth)
                {
                    break;
                }

                --nLength;
            }

            str = lpTmp;
        }

        pDC->DrawText(
           str,
           &rc,
           DT_LEFT | DT_SINGLELINE | DT_NOPREFIX | DT_VCENTER
           );

    }
    catch(CMemoryException * e)
    {
        //
        // Mem failure
        //
        fSuccess = FALSE;
        e->ReportError();
        e->Delete();
    }

    return fSuccess;
}



void
CODLBox::ComputeMargins(
    IN  CRMCListBoxDrawStruct & ds,
    IN  int nCol,
    OUT int & nLeft,
    OUT int & nRight
    )
/*++

Routine Description:

    Compute the left and right margins of the given column.

Arguments:

    CRMCListBoxDrawStruct & ds : Drawing structure
    int nCol                  : Column whose margins we're interested in
    int & nLeft               : Left column
    int & nRight              : Right column

Return Value:

    None

--*/
{
    nLeft = ds.m_Rect.left;
    nRight = ds.m_Rect.right;

    //
    // Find tab value associated with column index (0-based),
    // and adjust left and right
    //
    ASSERT(nCol <= NumTabs());

    if (nCol > 0)
    {
        if (nCol <= NumTabs())
        {
            nLeft += m_auTabs[nCol-1];
        }
    }
    if (nCol < NumTabs())
    {
        nRight = m_auTabs[nCol];
    }
}



BOOL
CODLBox::DrawBitmap(
    IN CRMCListBoxDrawStruct & ds,
    IN int nCol,
    IN int nID
    )
/*++

Routine Description:

    Draw a bitmap in the given column.  Bitmap are always placed on the
    leftmost side of the column if there is sufficient space.

Arguments:

    CRMCListBoxDrawStruct & ds : Drawing structure
    int nCol                  : Column to place bitmap in
    int nID                   : Bitmap ID (offset within the bitmap resources)

Return Value:

    None

--*/
{
    CDC * pBmpDC = (CDC *)&ds.m_pResources->dcBitMap();

#ifdef _DEBUG

    pBmpDC->AssertValid();

#endif // _DEBUG

    //
    // Select the bitmap with either a selection or
    // a regular background
    //
    int bm_h = ds.m_Sel ? 0 : ds.m_pResources->BitmapHeight();
    int bm_w = ds.m_pResources->BitmapWidth() * nID;

    int nLeft, nRight;
    ComputeMargins(ds, nCol, nLeft, nRight);
    nLeft += BMP_LEFT_OFFSET;

    //
    // Check to make sure there's enough room before
    // drawing the bitmap.
    //
    if (nRight - nLeft >= ds.m_pResources->BitmapWidth())
    {
        ds.m_pDC->BitBlt(
            nLeft,
            ds.m_Rect.top,
            ds.m_pResources->BitmapWidth(),
            ds.m_pResources->BitmapHeight(),
            pBmpDC,
            bm_w,
            bm_h,
            SRCCOPY
            );
    }

    return TRUE;
}



BOOL
CODLBox::ColumnText(
    IN CRMCListBoxDrawStruct & ds,
    IN int nCol,
    IN BOOL fSkipBitmap,
    IN LPCTSTR lpstr
    )
/*++

Routine Description:

    Draw column text.

Arguments:

    CRMCListBoxDrawStruct & ds : Drawing structure
    int nCol                  : Column to place bitmap in
    BOOL fSkipBitmap          : If TRUE, increment lefthand column by the width
                                of a bitmap
    LPCTSTR lpstr             : String to be displayed.  May be truncated as
                                necessary

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    int nLeft, nRight;

    ComputeMargins(ds, nCol, nLeft, nRight);

    //
    // Optionally adjust for bitmap
    //
    if (fSkipBitmap)
    {
        nLeft += (ds.m_pResources->BitmapWidth() + BMP_RIGHT_OFFSET);
    }

    return CODLBox::ColumnText(
        ds.m_pDC,
        nLeft,
        ds.m_Rect.top,
        nRight,
        ds.m_Rect.bottom,
        lpstr
        );
}



void
CODLBox::CalculateTextHeight(
    IN CFont * pFont
    )
/*++

Routine Description:

    Calculate and set the text height of font

Arguments:

    CFont * pFont : Pointer to the font to be used.

Return Value:

    None

--*/
{
    ASSERT_PTR(m_pWnd);

    CClientDC dc(m_pWnd);
    CFont * pOldFont = dc.SelectObject(pFont);

    TEXTMETRIC tm;
    dc.GetTextMetrics(&tm);
    m_lfHeight = tm.tmHeight;

    dc.SelectObject(pOldFont);
}



int
CODLBox::AddTab(
    IN UINT uTab
    )
/*++

Routine Description:

    Add a tab to the end of the list (e.g the right side of the header)

Arguments:

    UINT uTab : Tab value to set

Return Value:

    The index of the new tab

--*/
{
    return (int)m_auTabs.Add(uTab);
}



int
CODLBox::AddTabFromHeaders(
    IN CWnd & wndLeft,
    IN CWnd & wndRight
    )
/*++

Routine Description:

    Add a tab to the end of the list (e.g the right side of the header),
    but compute the tab by taking the difference in left-hand coordinat of two
    window controls (usually static header text)

Arguments:

    CWnd & wndLeft   : Left window
    CWnd & wndRight  : Right window

Return Value:

    The index of the new tab

--*/
{
    CRect rcLeft, rcRight;

    wndLeft.GetWindowRect(&rcLeft);
    wndRight.GetWindowRect(&rcRight);

    ASSERT(rcRight.left > rcLeft.left);

    return AddTab(rcRight.left - rcLeft.left - 1);
}



int
CODLBox::AddTabFromHeaders(
    IN UINT idLeft,
    IN UINT idRight
    )
/*++

Routine Description:

    Similar to the function above, but use the control IDs.  The parent
    window is assumed to be the same as the parent window of the listbox

Arguments:

    UINT idLeft  : ID of the left control
    UINT idRight : ID of the right control

Return Value:

    The index of the new tab or -1 in case of failure

--*/
{
    ASSERT_PTR(m_pWnd);

    if (m_pWnd == NULL)
    {
        //
        // Should have associated window handle by now
        //
        return -1;
    }

    CWnd * pLeft = m_pWnd->GetParent()->GetDlgItem(idLeft);
    CWnd * pRight = m_pWnd->GetParent()->GetDlgItem(idRight);

    ASSERT_READ_PTR(pLeft);
    ASSERT_READ_PTR(pRight);

    if (!pLeft || !pRight)
    {
        //
        // One or both control IDs were not valid
        //
        return -1;
    }

    return AddTabFromHeaders(*pLeft, *pRight);
}



void
CODLBox::InsertTab(
    IN int nIndex,
    IN UINT uTab
    )
/*++

Routine Description:

    Insert a tab at the given index

Arguments:

    int nIndex : Column index at which the tab is to be inserted
    UINT uTab  : Tab value to set

Return Value:

    None

--*/
{
    m_auTabs.InsertAt(nIndex, uTab);
}



void
CODLBox::RemoveTab(
    IN int nIndex,
    IN int nCount
    )
/*++

Routine Description:

    Remove one or more tabs

Arguments:

    int nIndex : Column index at which to start removing tabs
    int nCount : Number of tabs to be removed

Return Value:

    None

--*/
{
    m_auTabs.RemoveAt(nIndex, nCount);
}



void
CODLBox::RemoveAllTabs()
/*++

Routine Description:

    Remove all tabs

Arguments:

    None

Return Value:

    None

--*/
{
    m_auTabs.RemoveAll();
}



void
CODLBox::__DrawItem(
    IN LPDRAWITEMSTRUCT lpDIS
    )
/*++

Routine Description:

    Draw an item.  This will draw the focus and selection state, and then
    call out to the derived class to draw the item.

Arguments:

    LPDRAWITEMSTRUCT lpDIS : The drawitem structure

Return Value:

    None

--*/
{
    //
    // Need to attach resources before creation/adding items
    //
    ASSERT_PTR(m_pResources);

    CDC * pDC = CDC::FromHandle(lpDIS->hDC);

#ifdef _DEBUG

    pDC->AssertValid();

#endif // _DEBUG

    //
    // Draw focus rectangle when no items in listbox
    //
    if(lpDIS->itemID == (UINT)-1)
    {
        if(lpDIS->itemAction & ODA_FOCUS)
        {
            //
            // rcItem.bottom seems to be 0 for variable height list boxes
            //
            lpDIS->rcItem.bottom = m_lfHeight;
            pDC->DrawFocusRect(&lpDIS->rcItem);
        }

        return;
    }
    else
    {
        BOOL fSelChange   = (lpDIS->itemAction & ODA_SELECT) != 0;
        BOOL fFocusChange = (lpDIS->itemAction & ODA_FOCUS) != 0;
        BOOL fDrawEntire  = (lpDIS->itemAction & ODA_DRAWENTIRE) != 0;

        if(fSelChange || fDrawEntire)
        {
            BOOL fSel = (lpDIS->itemState & ODS_SELECTED) != 0;

            COLORREF hlite   = (fSel ? (m_pResources->ColorHighlight())
                                     : (m_pResources->ColorWindow()));
            COLORREF textcol = (fSel ? (m_pResources->ColorHighlightText())
                                     : (m_pResources->ColorWindowText()));
            pDC->SetBkColor(hlite);
            pDC->SetTextColor(textcol);

            //
            // fill the rectangle with the background colour.
            //
            pDC->ExtTextOut(0, 0, ETO_OPAQUE, &lpDIS->rcItem, NULL, 0, NULL);

            CRMCListBoxDrawStruct ds(pDC,
                (RECT *)&lpDIS->rcItem,
                fSel,
                (DWORD_PTR)lpDIS->itemData,
                lpDIS->itemID,
                m_pResources
                );

            //
            // Now call the draw function of the derived class
            //
            DrawItemEx(ds);
        }

        if (fFocusChange || (fDrawEntire && (lpDIS->itemState & ODS_FOCUS)))
        {
            pDC->DrawFocusRect(&lpDIS->rcItem);
        }
    }
}



void
CODLBox::__MeasureItem(
    IN OUT LPMEASUREITEMSTRUCT lpMIS
    )
/*++

Routine Description:

    Provide dimensions of given item

Arguments:

    LPMEASUREITEMSTRUCT lpMIS : Measure item structure

Return Value:

    None

--*/
{
    ASSERT_PTR(m_pResources);

//    int h = lpMIS->itemHeight;
    int ch = TextHeight();
    int bmHeight = m_pResources->BitmapHeight();

    lpMIS->itemHeight = ch < bmHeight ? bmHeight : ch;
}



CRMCListBoxHeader::CRMCListBoxHeader(
    IN DWORD dwStyle
    )
/*++

Routine Description:

    Constructor.

Arguments:

    DWORD dwStyle : Style bits

Return Value:

    N/A

--*/
    : m_pHCtrl(NULL),
      m_pListBox(NULL),
      m_dwStyle(dwStyle),
      m_fRespondToColumnWidthChanges(TRUE)
{
    m_pHCtrl = new CHeaderCtrl;
}



CRMCListBoxHeader::~CRMCListBoxHeader()
/*++

Routine Description:

    Destructor.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    //
    // Kill the header control and the
    // font
    //
    if (m_pHCtrl)
    {
        delete m_pHCtrl;
    }

    //
    // Leave the listbox pointer alone, as we don't
    // own it, but are merely associated with it.
    //
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CRMCListBoxHeader, CStatic)
    //{{AFX_MSG_MAP(CRMCListBoxHeader)
    ON_WM_DESTROY()
    ON_WM_SETFOCUS()
    //}}AFX_MSG_MAP

    ON_NOTIFY_RANGE(HDN_ENDTRACK,    0, 0xFFFF, OnHeaderEndTrack)
    ON_NOTIFY_RANGE(HDN_ITEMCHANGED, 0, 0xFFFF, OnHeaderItemChanged)
    ON_NOTIFY_RANGE(HDN_ITEMCLICK,   0, 0xFFFF, OnHeaderItemClick)

END_MESSAGE_MAP()

void
CRMCListBoxHeader::OnSetFocus(CWnd * pWnd)
{
    m_pListBox->SetFocus();
}

void
CRMCListBoxHeader::OnDestroy()
/*++

Routine Description:

    WM_DESTROY message handler.  When the control is being destroyed,
    also destroy the invisible static control.

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Destroy optional header control
    //
    if (m_pHCtrl)
    {
        m_pHCtrl->DestroyWindow();
    }

    CStatic::OnDestroy();
}



BOOL
CRMCListBoxHeader::Create(
    IN DWORD dwStyle,
    IN const RECT & rect,
    IN CWnd * pParentWnd,
    IN CHeaderListBox * pListBox,
    IN UINT nID
    )
/*++

Routine Description:

    Create the control.  This will first create an invisible static window,
    which is to take up the entire area of the listbox.  This static window
    then will be the parent to the listbox as well as this header control.

Arguments:

    DWORD dwStyle              : Creation style bits
    const RECT & rect          : Rectangle in which the header is to be created
    CWnd * pParentWnd          : Parent window
    CHeaderListBox * pListBox  : Associated listbox
    UINT nID                   : Control ID of the header

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    //
    // Make sure the real header control exists by now
    //
    if (m_pHCtrl == NULL)
    {
        return FALSE;
    }

    //
    // Make sure there's an associated listbox
    //
    m_pListBox = pListBox;
    if (m_pListBox == NULL)
    {
        return FALSE;
    }

    //
    // Create the controlling static window as do-nothing window
    //
    if (!CStatic::Create(NULL, WS_VISIBLE | WS_TABSTOP | SS_BITMAP | WS_CHILD,
        rect, pParentWnd, 0xFFFF))
    {
        return FALSE;
    }

    //
    // Now create the header control. Its parent
    // window is this static control we just created
    //
    CRect rc(0, 0, 0 ,0);
    dwStyle |= (UseButtons() ? HDS_BUTTONS : 0L);
    VERIFY(m_pHCtrl->Create(dwStyle, rc, this, nID));
	m_pHCtrl->ModifyStyle(HDS_DRAGDROP, 0);

    //
    // Place header control as per style bits,
    // compute the desired layout, and move it
    //
    HD_LAYOUT hdl;
    WINDOWPOS wp;

    GetClientRect(&rc);
    hdl.prc = &rc;
    hdl.pwpos = &wp;

    m_pHCtrl->Layout(&hdl);
    m_pHCtrl->SetWindowPos(m_pListBox, wp.x, wp.y,
        wp.cx, wp.cy, wp.flags | SWP_SHOWWINDOW);

    //
    // And move our associated listbox just below it
    //
    ::GetDlgCtlRect(GetParent()->m_hWnd, m_pListBox->m_hWnd, &rc);
    rc.top += wp.cy - 1;

    //
    // Adjust if header is bigger than the entire listbox
    //
    if (rc.top > rc.bottom)
    {
        rc.top = rc.bottom;
    }
    // Fix for theme support. Make listbox and header children of the same static control
    m_pListBox->SetParent(this);
    GetParent()->ClientToScreen(&rc);
    ScreenToClient(&rc);
    m_pListBox->MoveWindow(rc.left, rc.top, rc.Width(), rc.Height());

    //
    // Make sure the header uses the right font
    //
    m_pHCtrl->SetFont(
        CFont::FromHandle((HFONT)::GetStockObject(DEFAULT_GUI_FONT)),
        FALSE
        );

    return TRUE;
}



void
CRMCListBoxHeader::OnHeaderEndTrack(
    IN  UINT nId,
    IN  NMHDR * pnmh,
    OUT LRESULT * pResult
    )
/*++

Routine Description:

    User has finished dragging the column divider.  If we're supposed to ensure
    that the last column is a stretch column, turn off the redraw now -- it
    will get turned back on after the column width changes have all been
    completed.  This will reduce the flash effect.

Arguments:

    UINT nId          : Control ID
    NMHDR * pnmh      : Notification header structure
    LRESULT * pResult : Result.  Will be set to 0 if the message was handled

Return Value:

    None (handled in pResult)

--*/
{
   pnmh;
   nId;

    if (DoesRespondToColumnWidthChanges() && UseStretch())
    {
        //
        // This will get turned back on in OnHeaderItemChanged
        //
        SetRedraw(FALSE);
    }

    *pResult = 0;
}



void
CRMCListBoxHeader::SetColumnWidth(
    IN int nCol,
    IN int nWidth
    )
/*++

Routine Description:

    Set the given column to the given width

Arguments:

    int nCol        : Column number
    int nWidth      : New width

Return Value:

    None

--*/
{
    ASSERT(nCol < QueryNumColumns());

    if (nCol >= QueryNumColumns())
    {
        return;
    }

    TRACEEOLID("Setting width of column  " << nCol << " to " << nWidth);

    HD_ITEM hdItem;

    hdItem.mask = HDI_WIDTH;
    hdItem.cxy = nWidth;
    VERIFY(SetItem(nCol, &hdItem));
}



void
CRMCListBoxHeader::OnHeaderItemChanged(
    IN  UINT nId,
    IN  NMHDR *pnmh,
    OUT LRESULT *pResult
    )
/*++

Routine Description:

    Handle change in header column width.  Note: we're actually tracking
    the HDN_ITEMCHANGED notification, not the HDN_ENDDRAG one, because
    the latter is sent out before the column widths in the structure have
    changed.

Arguments:

    UINT nId          : Control ID
    NMHDR * pnmh      : Notification header structure
    LRESULT * pResult : Result.  Will be set to 0 if the message was handled

Return Value:

    None (handled in pResult)

--*/
{
   nId;
    //
    // Adjust tabs in associate listbox if
    // column widths have changed
    //
    HD_NOTIFY * pNotify = (HD_NOTIFY *)pnmh;
    if (DoesRespondToColumnWidthChanges() && pNotify->pitem->mask & HDI_WIDTH)
    {
        ASSERT_PTR(m_pListBox);

        //
        // Stretch the last column
        //
        if (UseStretch())
        {
            //
            // Turn this off, as we don't want
            // to get in an infinite loop
            //
            RespondToColumnWidthChanges(FALSE);

            //
            // Compute available space
            //
            CRect rc;
            GetClientRect(&rc);

            //
            // See how much is taken up by preceding
            // columns
            //
            int nTotalWidth = 0;
            int cColumns = QueryNumColumns();
            int nLastCol = cColumns - 1;
            ASSERT(nLastCol >= 0);

            for (int nCol = 0; nCol < nLastCol; ++nCol)
            {
                int nWidth = GetColumnWidth(nCol);

                //
                // Each column must be at least one pixel wide
                //
                int nMaxWidth = rc.Width() - nTotalWidth - (nLastCol - nCol);
                if (nWidth > nMaxWidth)
                {
                    nWidth = nMaxWidth;
                    SetColumnWidth(nCol, nWidth);
                }

                nTotalWidth += nWidth;
            }

            //
            // Make sure the last column takes up the rest
            //
            if (rc.Width() > nTotalWidth)
            {
                SetColumnWidth(nLastCol, rc.Width() - nTotalWidth);
            }

            //
            // Turn this back on again
            //
            RespondToColumnWidthChanges(TRUE);

            //
            // Redraw will have been turned off in
            // OnHeaderEndTrack, now that all column
            // movement has completed, turn it back
            // on to draw the control in its current
            // state.
            //
            SetRedraw(TRUE);
            Invalidate();
        }

        //
        // Recompute tabs on associate listbox,
        // and force redraw on it.
        //
        m_pListBox->SetRedraw(FALSE);
        SetTabsFromHeader();
        m_pListBox->SetRedraw(TRUE);
        m_pListBox->Invalidate();
    }

    *pResult = 0;
}



void
CRMCListBoxHeader::OnHeaderItemClick(
    IN  UINT nId,
    IN  NMHDR *pnmh,
    OUT LRESULT *pResult
    )
/*++

Routine Description:

    A button has been clicked in the header control.  Pass it on
    to the real parent window.

Arguments:

    UINT nId          : Control ID
    NMHDR * pnmh      : Notification header structure
    LRESULT * pResult : Result.  Will be set to 0 if the message was handled

Return Value:

    None (handled in pResult)

--*/
{
    //
    // Pass notification on to parent
    //
    ASSERT(GetParent());
    GetParent()->SendMessage(WM_NOTIFY, (WPARAM)nId, (LPARAM)pnmh);
    *pResult = 0;
}



void
CRMCListBoxHeader::SetTabsFromHeader()
/*++

Routine Description:

    Set the tabs (which are cumulative) from the header control
    columns (which are not)

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Must have the same number of tabs
    // as header columns
    //
    ASSERT_PTR(m_pListBox);
    ASSERT(GetItemCount() == m_pListBox->NumTabs());

    int nTab = 0;
    for (int n = 0; n < m_pListBox->NumTabs(); ++n)
    {
        m_pListBox->SetTab(n, nTab += GetColumnWidth(n));
    }
}



int
CRMCListBoxHeader::GetItemCount() const
/*++

Routine Description:

    Get the number of items in the header

Arguments:

    None

Return Value:

    The number of items in the header (e.g. the number of columns)

--*/
{
    ASSERT_PTR(m_pHCtrl);
    return m_pHCtrl->GetItemCount();
}



BOOL
CRMCListBoxHeader::GetItem(
    IN  int nPos,
    OUT HD_ITEM * pHeaderItem
    ) const
/*++

Routine Description:

    Get information on specific position (column index)

Arguments:

    int nPos              : Column index
    HD_ITEM * pHeaderItem : Header item information

Return Value:

    TRUE for success, FALSE for failure (bad column index)

--*/
{
    ASSERT_PTR(m_pHCtrl);
    return m_pHCtrl->GetItem(nPos, pHeaderItem);
}



int
CRMCListBoxHeader::GetColumnWidth(
    IN int nPos
    ) const
/*++

Routine Description:

    Get column width of a specific column

Arguments:

    int nPos : Column index

Return Value:

    The column width of the given colum, or -1 in case of failure (bad
    column index)

--*/
{
    HD_ITEM hi;

    hi.mask = HDI_WIDTH;
    if (GetItem(nPos, &hi))
    {
        return hi.cxy;
    }

    return -1;
}



BOOL
CRMCListBoxHeader::SetItem(
    IN int nPos,
    IN HD_ITEM * pHeaderItem
    )
/*++***

Routine Description:

    Set information on specific position (column index)

Arguments:

    int nPos              : Column index
    HD_ITEM * pHeaderItem : Header item information

Return Value:

    TRUE for success, FALSE for failure (bad column index)

--*/
{
    ASSERT_PTR(m_pHCtrl);
    ASSERT_PTR(m_pListBox);

    if (!m_pHCtrl->SetItem(nPos, pHeaderItem))
    {
        return FALSE;
    }

    if (pHeaderItem->mask & HDI_WIDTH)
    {
        SetTabsFromHeader();
    }

    return TRUE;
}



int
CRMCListBoxHeader::InsertItem(
    IN int nPos,
    IN HD_ITEM * pHeaderItem
    )
/*++

Routine Description:

    insert information in specific position (column index)

Arguments:

    int nPos              : Column index
    HD_ITEM * pHeaderItem : Header item information

Return Value:

    The new index, or -1 in case of failure.

--*/
{
    ASSERT_PTR(m_pHCtrl);
    ASSERT_PTR(m_pListBox);

    int nCol = m_pHCtrl->InsertItem(nPos, pHeaderItem);
    if (nCol != -1)
    {
        //
        // Set 0-width tab, as tabs get recomputed anyway
        //
        m_pListBox->InsertTab(nPos, 0);
        SetTabsFromHeader();
    }

    return nCol;
}



BOOL
CRMCListBoxHeader::DeleteItem(
    IN int nPos
    )
/*++

Routine Description:

    Delete the given item (i.e. column)

Arguments:

    int nPos              : Column index

Return Value:

    TRUE for success, FALSE for failure (bad column index)

--*/
{
    ASSERT_PTR(m_pHCtrl);
    ASSERT_PTR(m_pListBox);

    if (!m_pHCtrl->DeleteItem(nPos))
    {
        return FALSE;
    }

    m_pListBox->RemoveTab(nPos, 1);

    return TRUE;
}



IMPLEMENT_DYNAMIC(CRMCListBoxHeader, CStatic);



CRMCListBox::CRMCListBox()
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    N/A

--*/
    : m_fInitialized(FALSE),
      m_fMultiSelect(FALSE)
{
}



CRMCListBox::~CRMCListBox()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CRMCListBox, CListBox)
    //{{AFX_MSG_MAP(CRMCListBox)
    ON_WM_CREATE()
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



/* virtual */
BOOL
CRMCListBox::Initialize()
/*++

Routine Description:

    This function should be called directly when subclassing an existing
    listbox, otherwise OnCreate will take care of it.

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    //
    // Make sure we're only initialized once
    //
    if (m_fInitialized)
    {
        return TRUE;
    }

    //
    // Ensure the base class knows our window
    // handle
    //
    AttachWindow(this);

    if (!CODLBox::Initialize())
    {
        return FALSE;
    }

    m_fInitialized = TRUE;

    DWORD dwStyle = GetStyle();
    m_fMultiSelect = (dwStyle & (LBS_EXTENDEDSEL | LBS_MULTIPLESEL)) != 0;

    return m_fInitialized;
}



void
CRMCListBox::MeasureItem(
    IN LPMEASUREITEMSTRUCT lpMIS
    )
/*++

Routine Description:

    CListBox override to ODL base class

Arguments:

    LPMEASUREITEMSTRUCT lpMIS : Measure item structure

Return Value:

    None

--*/
{
    CODLBox::__MeasureItem(lpMIS);
}



void
CRMCListBox::DrawItem(
    IN LPDRAWITEMSTRUCT lpDIS
    )
/*++

Routine Description:

    CListBox override to ODL base class

Arguments:

    LPDRAWITEMSTRUCT lpDIS : Drawing item structure

Return Value:

    None

--*/
{
    CODLBox::__DrawItem(lpDIS);
}



/* virtual */
void
CRMCListBox::DrawItemEx(
    IN CRMCListBoxDrawStruct & dw
    )
/*++

Routine Description:

    Do-nothing extended draw function, which should
    be provided by the derived class.  This one will
    ASSERT, and should never be called.

Arguments:

    CRMCListBoxDrawStruct & dw   : Draw Structure

Return Value:

    None

--*/
{
   dw;
    ASSERT_MSG("Derived class did not provide DrawItemEx");
}



/* virtual */
int
CRMCListBox::__GetCount() const
/*++

Routine Description:

    Provide GetCount() to ODL base class

Arguments:

    None

Return Value:

    Count of items in the listbox

--*/
{
    return GetCount();
}



/* virtual */
int
CRMCListBox::__SetItemHeight(
    IN int nIndex,
    IN UINT cyItemHeight
    )
/*++

Routine Description:

    Provide SetItemHeight() to ODL base class

Arguments:

    None

Return Value:

    LB_ERR if the index or height is invalid.

--*/
{
    return SetItemHeight(nIndex, cyItemHeight);
}



int
CRMCListBox::OnCreate(
    IN LPCREATESTRUCT lpCreateStruct
    )
/*++

Routine Description:

    Listbox is being created

Arguments:

    LPCREATESTRUCT lpCreateStruct : Creation structure

Return Value:

    -1 for failure, 0 for success

--*/
{
    if (CListBox::OnCreate(lpCreateStruct) == -1)
    {
        return -1;
    }

    Initialize();

    return 0;
}



int
CRMCListBox::GetCurSel() const
/*++

Routine Description:

    Get the index of the current selected item

Arguments:

    None

Return Value:

    On multi-selection listbox, it will return
    the index of an item, iff that is the only
    item selected.

    On single-selection listbox, it behaves as
    normal.

--*/
{
    if (IsMultiSelect())
    {
        //
        // We only like it if one item is selected
        //
        int nCurSel = LB_ERR;

        if (CListBox::GetSelCount() == 1)
        {
            if (CListBox::GetSelItems(1, &nCurSel) != 1)
            {
                nCurSel = LB_ERR;
            }
        }

        return nCurSel;
    }

    //
    // Single select listbox
    //
    return CListBox::GetCurSel();
}



int
CRMCListBox::SetCurSel(
    IN int nSelect
    )
/*++

Routine Description:

    Select an item.  On a multi-select listbox,
    this will deselect everything except the given
    item.

Arguments:

    int nSelect     : Index of the item to be selected, or
                      -1 to reset all selections.

Return Value:

    LB_ERR in case of error.

--*/
{
    if (IsMultiSelect())
    {
        //
        // Reset all selections
        //
        int nReturn = SelItemRange(FALSE, 0, GetCount() - 1);

        if (nSelect >= 0)
        {
            //
            // Ensure item is visible
            //
            nReturn = CListBox::SetSel(nSelect, TRUE);
            CListBox::SetCaretIndex(nSelect, 0);
        }

        return nReturn;
    }

    return CListBox::SetCurSel(nSelect);
}



int
CRMCListBox::GetSel(
    IN int nSel
    ) const
/*++

Routine Description:

    Determine if the given item is selected or not
    Works for both single and multi-select listboxes

Arguments:

    int nSel        : Item whose state to check

Return Value:

    LB_ERR in case of error, 0 if the item in question
    is not selected, a positive number if it is.

--*/
{
    if (IsMultiSelect())
    {
        return CListBox::GetSel(nSel);
    }

    //
    // Some magic for single select
    //
    if (nSel < 0 || nSel >= CListBox::GetCount())
    {
        return LB_ERR;
    }

    return nSel == CListBox::GetCurSel()
        ? TRUE
        : FALSE;
}



int
CRMCListBox::GetSelCount() const
/*++

Routine Description:

    Return count of selected items.  Works for both
    single and multi select (in the former case,
    it will return zero or one only)

Arguments:

    None

Return Value:

    Count of selected items

--*/
{
    if (IsMultiSelect())
    {
        return CListBox::GetSelCount();
    }

    return GetCurSel() != LB_ERR ? 1 : 0;
}



void *
CRMCListBox::GetSelectedListItem(
    OUT int * pnSel     OPTIONAL
    )
/*++

Routine Description:

    Return the single selected item in the list or NULL

Arguments:

    int * pnSel     : Optionally returns the selected index

Returns:

    The currently selected (single) item, or NULL
    if 0 or more than one items is selected.  Works for
    both multi-select and single select.

--*/
{
    void * pItem = NULL;

    int nCurSel = GetCurSel();
    if (nCurSel >= 0)
    {
        //
        // Get item properties
        //
        pItem = GetItemDataPtr(nCurSel);
        if (pnSel)
        {
            *pnSel = nCurSel;
        }
    }

    return pItem;
}



void *
CRMCListBox::GetNextSelectedItem(
    IN OUT int * pnStartingIndex
    )
/*++

Routine Description:

    Return the next selected item starting at a specific
    index.

Arguments:

    int *pnStartingIndex          : Starting index (>= 0)

Return Value:

    Pointer to next selected item, or NULL if there are
    none left.

    The starting index will be updated to reflect the current
    index, LB_ERR if no more selected items remain.

--*/
{
    ASSERT_READ_WRITE_PTR(pnStartingIndex);

    if (!pnStartingIndex)
    {
        return NULL;
    }

    ASSERT(*pnStartingIndex >= 0);

    if (*pnStartingIndex < 0)
    {
        *pnStartingIndex = 0;
    }

    if (IsMultiSelect())
    {
        //
        // Multi-select -- loop through
        // until found
        //
        BOOL fFoundItem = FALSE;

        while (*pnStartingIndex < GetCount())
        {
            if (CListBox::GetSel(*pnStartingIndex) > 0)
            {
                ++fFoundItem;
                break;
            }

            ++(*pnStartingIndex);
        }

        if (!fFoundItem)
        {
            *pnStartingIndex = LB_ERR;
        }
    }
    else
    {
        //
        // Single select listbox, so there's no
        // looping through -- either the selected item
        // (if any) is in range or it isn't.
        //
        int nCurSel = CListBox::GetCurSel();
        *pnStartingIndex = (nCurSel >= *pnStartingIndex) ? nCurSel : LB_ERR;
    }

    return (*pnStartingIndex != LB_ERR)
        ? GetItemDataPtr(*pnStartingIndex)
        : NULL;
}



BOOL
CRMCListBox::SelectItem(
    IN void * pItemData
    )
/*++

Routine Description:

    Select the listbox item with the given data pointer

Arguments:

    void * pItemData : Item to search for

Return Value:

    TRUE if the item was found and selected, FALSE otherwise

Notes:

    On a multi-select listbox, this will unselect
    all other items in the listbox.

--*/
{
    if (pItemData != NULL)
    {
        for (int n = 0; n < GetCount(); ++n)
        {
            if (pItemData == GetItemDataPtr(n))
            {
                SetCurSel(n);

                return TRUE;
            }
        }
    }

    if (!IsMultiSelect())
    {
        //
        // Set no selection
        //
        SetCurSel(-1);
    }

    return FALSE;
}



void
CRMCListBox::InvalidateSelection(
    IN int nSel
    )
/*++

Routine Description:

    Force a repaint of the given selection

Arguments:

    int nSel : Index of the item to be repainted

Return Value:

    None

--*/
{
    CRect rc;

    if (GetItemRect(nSel, &rc) != LB_ERR)
    {
        InvalidateRect(&rc, TRUE);
    }
}



IMPLEMENT_DYNAMIC(CRMCListBox,CListBox);



CHeaderListBox::CHeaderListBox(
    IN DWORD dwStyle,
    IN LPCTSTR lpRegKey OPTIONAL
    )
/*++

Routine Description:

    Constructor

Arguments:

    DWORD   dwStyle  : Style bits (see HLS_*)
    LPCTSTR lpRegKey : If specified, the registry key where the column
                       sizes will be stored.

Return Value:

    None

--*/
    : m_strRegKey(),
      m_fInitialized(FALSE)
{
    m_pHeader = new CRMCListBoxHeader(dwStyle);
    if (lpRegKey)
    {
        GenerateRegistryKey(m_strRegKey, lpRegKey);
    }
}



CHeaderListBox::~CHeaderListBox()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    //
    // Clean up header control
    //
    ASSERT_PTR(m_pHeader);

    if (m_pHeader != NULL)
    {
        delete m_pHeader;
    }
}



//
// Message map
//
BEGIN_MESSAGE_MAP(CHeaderListBox, CRMCListBox)
    //{{AFX_MSG_MAP(CHeaderListBox)
    ON_WM_CREATE()
    ON_WM_DESTROY()
	ON_WM_SETFOCUS()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



/* virtual */
BOOL
CHeaderListBox::Initialize()
/*++

Routine Description:

    This function should be called directly when subclassing an existing
    listbox, otherwise OnCreate will take care of it, and this function
    should not be called

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    //
    // Make sure we're only initialized once
    //
    if (m_fInitialized)
    {
        return TRUE;
    }

    if (!CRMCListBox::Initialize())
    {
        return FALSE;
    }

    //
    // Create header control
    //
    ASSERT_PTR(m_pHeader);

    if (m_pHeader)
    {
        TRACEEOLID("Creating Header");

        //
        // Create it in our location exactly
        //
        CRect rc;
        ::GetDlgCtlRect(GetParent()->m_hWnd, m_hWnd, &rc);

        //
        // Make sure the header control shares the same parent
        // as we do,
        //
        ASSERT(GetParent());

        #ifndef CCS_NOHILITE
        #define CCS_NOHILITE 0x00000010L
        #endif

        DWORD dwStyle = WS_VISIBLE | WS_TABSTOP | CCS_TOP | CCS_NODIVIDER | WS_BORDER
            | HDS_HORZ;

        if (!m_pHeader->Create(dwStyle, rc, GetParent(), this, 0xFFFF))
        {
            return FALSE;
        }
    }

    m_fInitialized = TRUE;

    return TRUE;
}



int
CHeaderListBox::QueryColumnWidth(
    IN int nCol
    ) const
/*++

Routine Description:

    Get the width of the specified column

Arguments:

    int nCol : The column

Return Value:

    The width of the column, or -1 if the column index was out of range

--*/
{
    ASSERT(nCol < QueryNumColumns());

    if (nCol >= QueryNumColumns())
    {
        return -1;
    }

    HD_ITEM hdItem;

    hdItem.mask = HDI_WIDTH;
    VERIFY(GetHeaderItem(nCol, &hdItem));

    return hdItem.cxy;
}



BOOL
CHeaderListBox::SetColumnWidth(
    IN int nCol,
    IN int nWidth
    )
/*++

Routine Description:

    Set the width of the specified column

Arguments:

    int nCol   : The column
    int nWidth : New width

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    ASSERT(nCol < QueryNumColumns());

    if (nCol >= QueryNumColumns())
    {
        return FALSE;
    }

    TRACEEOLID("Setting width of column  " << nCol << " to " << nWidth);

    HD_ITEM hdItem;
    hdItem.mask = HDI_WIDTH;
    hdItem.cxy = nWidth;
    VERIFY(SetHeaderItem(nCol, &hdItem));

    return TRUE;
}



BOOL
CHeaderListBox::SetWidthsFromReg()
/*++

Routine Description:

    Attempt to set the column widths from the registry
    value we were initialized with.

Arguments:

    None

Return Value:

    TRUE if the column widths were succesfully set from the registry,
    FALSE otherwise

--*/
{
    if (m_strRegKey.IsEmpty())
    {
        //
        // No reg key specified
        //
        return FALSE;
    }

    //
    // Try to read the current column sizes from the registry
    //
    CRegKey rkUser;
    if (ERROR_SUCCESS != rkUser.Create(HKEY_CURRENT_USER, m_strRegKey))
    {
        //
        // Path doesn't exist -- no problem.
        //
        return FALSE;
    }

    //
    // Don't auto adjust
    //
    m_pHeader->RespondToColumnWidthChanges(FALSE);

    CRect rc;
    m_pHeader->GetClientRect(&rc);

    CError err;

    try
    {
        TCHAR buf[MAX_PATH];
        DWORD count = MAX_PATH;
        int nTotalWidth = 0;

        err = rkUser.QueryValue(buf, g_szRegColumns, &count);

        if (err.Succeeded() && lstrlen(buf) > 0)
        {
            LPTSTR lpstrValue = buf;
            LPTSTR lpWidth = _tcstok(lpstrValue, g_szColValueSep);

            for (int n = 0; n < QueryNumColumns(); ++n)
            {
                ASSERT_PTR(lpWidth);

                if (lpWidth == NULL)
                {
                    err = ERROR_INVALID_PARAMETER;
                    break;
                }

                //
                // Sanity check
                //
                int nWidth = _ttoi(lpWidth);
                if (nWidth <= 0 || (nTotalWidth + nWidth > rc.Width()))
                {
                    ASSERT_MSG("column width invalid");

                    return FALSE;
                }

                nTotalWidth += nWidth;

                VERIFY(SetColumnWidth(n, nWidth));

                lpWidth = _tcstok(NULL, g_szColValueSep);
            }
        }
    }
    catch(CMemoryException * e)
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        e->Delete();
    }
    //
    // Turn auto-adjust back on
    //
    m_pHeader->RespondToColumnWidthChanges(TRUE);

//    if (err.Win32Error() == ERROR_FILE_NOT_FOUND)
//    {
//       // No problem, it is first run. We will set defaults.
//       return err;
//    }
    return err;
}



void
CHeaderListBox::DistributeColumns()
/*++

Routine Description:

    Proportion the column widths of over the entire width of the
    header control while maintaining relative proportions.

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Obtain available width
    //
    ASSERT_PTR(m_pHeader);

    CRect rc;
    m_pHeader->GetClientRect(&rc);

    //
    // Get current total width
    //
    int nTotalWeight = 0;
    int nCol;
    for (nCol = 0; nCol < QueryNumColumns(); ++nCol)
    {
        nTotalWeight += QueryColumnWidth(nCol);
    }

    //
    // And spread out the width, maintaining the same
    // proportions
    //

    //
    // Temporarily ignore changes
    //
    m_pHeader->RespondToColumnWidthChanges(FALSE);
    int cColumns = QueryNumColumns();

    for (nCol = 0; nCol < cColumns; ++nCol)
    {
        int nWidth = QueryColumnWidth(nCol);
        nWidth = rc.Width() * nWidth / nTotalWeight;
        VERIFY(SetColumnWidth(nCol, nWidth));
    }

    //
    // Turn changes back on
    //
    m_pHeader->RespondToColumnWidthChanges(TRUE);
}



int
CHeaderListBox::InsertColumn(
    IN int nCol,
    IN int nWeight,
    IN UINT nStringID,
    IN HINSTANCE hResInst
    )
/*++

Routine Description:

    Insert column.  The width of the column is actually a relative
    "weight" of the column which needs to be adjusted later.  The
    return value is the column number or -1 if the column is not inserted.

Arguments:

    int nCol        : Column number
    int nWeight     : Relative weight of column
    UINT nStringID  : Resource string ID

Return Value:

    Index of the column, or -1 in case of failure

--*/
{
    CString strColName;
    HD_ITEM hdItem;

    HINSTANCE hInst = AfxGetResourceHandle();
    AfxSetResourceHandle(hResInst);
    VERIFY(strColName.LoadString(nStringID));
    AfxSetResourceHandle(hInst);

    hdItem.mask = HDI_FORMAT | HDI_WIDTH | HDI_TEXT;
    hdItem.fmt = HDF_STRING | HDF_LEFT;
    hdItem.pszText = (LPTSTR)(LPCTSTR)strColName;
    hdItem.cchTextMax = strColName.GetLength();
    hdItem.cxy = nWeight;

    return InsertHeaderItem(nCol, &hdItem);
}



int
CHeaderListBox::OnCreate(
    IN LPCREATESTRUCT lpCreateStruct
    )
/*++

Routine Description:

    Listbox is being created

Arguments:

    LPCREATESTRUCT lpCreateStruct : Creation structure

Return Value:

    0 for success, -1 for failure

--*/
{
    if (CRMCListBox::OnCreate(lpCreateStruct) == -1)
    {
        return -1;
    }

    Initialize();

    return 0;
}



BOOL
CHeaderListBox::EnableWindow(
    IN BOOL bEnable
    )
/*++

Routine Description:

    Enable/disable the control.

Arguments:

    BOOL bEnable : TRUE to enable the control, FALSE to disable

Return Value:

    Indicates the state before the EnableWindow member function was called.
    The return value is nonzero if the window was previously disabled. The
    return value is 0 if the window was previously enabled or an error
    occurred.

--*/
{
    if (m_pHeader)
    {
        m_pHeader->EnableWindow(bEnable);
    }

    return CRMCListBox::EnableWindow(bEnable);
}



BOOL
CHeaderListBox::ShowWindow(
    IN int nCmdShow
    )
/*++

Routine Description:

    Show/hide the window

Arguments:

    int nCmdShow : SW_ flag such as SW_SHOW or SW_HIDE

Return Value:

    If the window was previously visible, the return value is TRUE. If the
    window was previously hidden, the return value is FALSE.

--*/
{
    if (m_pHeader)
    {
        m_pHeader->ShowWindow(nCmdShow);
    }

    return CRMCListBox::ShowWindow(nCmdShow);
}



void
CHeaderListBox::OnDestroy()
/*++

Routine Description:

    Handle destruction of the control

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Destroy optional header control
    //
    ASSERT_PTR(m_pHeader);

    if (m_pHeader)
    {
        if (!m_strRegKey.IsEmpty())
        {
            //
            // Try to write the current column sizes to the registry
            //
            CError err;

            CRegKey rkUser;
            
            rkUser.Create(HKEY_CURRENT_USER, m_strRegKey);

            int nWidth;
            TCHAR szValue[32];
            CString strValue;

            try
            {
                for (int n = 0; n < GetHeaderItemCount(); ++n)
                {
                    if (n > 0)
                    {
                        //
                        // Put in field separator
                        //
                        strValue += g_szColValueSep;
                    }

                    nWidth = m_pHeader->GetColumnWidth(n);
                    strValue += ::_itot(nWidth, szValue, 10);
                }

                err = rkUser.SetValue(strValue, g_szRegColumns);
            }
            catch(CMemoryException * e)
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
                e->Delete();
            }

            err.MessageBoxOnFailure(m_hWnd);
        }

        m_pHeader->DestroyWindow();
    }

    CRMCListBox::OnDestroy();
}


IMPLEMENT_DYNAMIC(CHeaderListBox, CRMCListBox);



CRMCComboBox::CRMCComboBox()
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    N/A

--*/
    : m_fInitialized(FALSE)
{
}



CRMCComboBox::~CRMCComboBox()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CRMCComboBox, CComboBox)
    //{{AFX_MSG_MAP(CRMCComboBox)
    ON_WM_CREATE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()




/* virtual */
BOOL
CRMCComboBox::Initialize()
/*++

Routine Description:

    This function should be called directly when subclassing an existing
    combobox, otherwise OnCreate will take care of it.

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    //
    // Make sure we're only initialized once
    //
    if (m_fInitialized)
    {
        return TRUE;
    }

    //
    // Ensure the base class knows our window
    // handle
    //
    AttachWindow(this);

    if (!CODLBox::Initialize())
    {
        return FALSE;
    }

    m_fInitialized = TRUE;

    return TRUE;
}



void
CRMCComboBox::MeasureItem(
    IN LPMEASUREITEMSTRUCT lpMIS
    )
/*++

Routine Description:

    CComboBox override to ODL base class

Arguments:

    LPMEASUREITEMSTRUCT lpMIS : Measure item structure

Return Value:

    None

--*/
{
    CODLBox::__MeasureItem(lpMIS);
}



void
CRMCComboBox::DrawItem(
    IN LPDRAWITEMSTRUCT lpDIS
    )
/*++

Routine Description:

    CListBox override to ODL base class

Arguments:

    LPDRAWITEMSTRUCT lpDIS : Drawing item structure

Return Value:

    None

--*/
{
    CODLBox::__DrawItem(lpDIS);
}



/* virtual */
void
CRMCComboBox::DrawItemEx(
    IN CRMCListBoxDrawStruct & dw
    )
/*++

Routine Description:

    Do-nothing extended draw function, which should
    be provided by the derived class.  This one will
    ASSERT, and should never be called.

Arguments:

    CRMCListBoxDrawStruct & dw   : Draw Structure

Return Value:

    None

--*/
{
   dw;
    ASSERT_MSG("Derived class did not provide DrawItemEx");
}



int
CRMCComboBox::OnCreate(
    IN LPCREATESTRUCT lpCreateStruct
    )
/*++

Routine Description:

    Combo box is being created

Arguments:

    LPCREATESTRUCT lpCreateStruct : Creation structure

Return Value:

    -1 for failure, 0 for success

--*/
{
    if (CComboBox::OnCreate(lpCreateStruct) == -1)
    {
        return -1;
    }

    Initialize();

    return 0;
}



/* virtual */
int
CRMCComboBox::__GetCount() const
/*++

Routine Description:

    Provide CComboBox::GetCount() functionality to base class

Arguments:

    None

Return Value:

    Get the count of items in the combo box

--*/
{
    return GetCount();
}



/* virtual */
int
CRMCComboBox::__SetItemHeight(
    IN int nIndex,
    IN UINT cyItemHeight
    )
/*++

Routine Description:

    Provide CListBox::SetItemHeight() functionality to base class.

Arguments:

    int nIndex        : Index of the item
    UINT cyItemHeight : Height of the item

Return Value:

    SetItemHeight return value.

--*/
{
    return SetItemHeight(nIndex, cyItemHeight);
}



IMPLEMENT_DYNAMIC(CRMCComboBox,CComboBox);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\odlbox.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        odlbox.h

   Abstract:

        Owner draw listbox/combobox base class

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _ODLBOX_H
#define _ODLBOX_H



//
// Get control rect in terms of
// parent coordinates
//
void COMDLL GetDlgCtlRect(
    IN  HWND hWndParent,
    IN  HWND hWndControl,
    OUT LPRECT lprcControl
    );


//
// Fit path to the given control
//
void COMDLL FitPathToControl(
    IN CWnd & wndControl,
    IN LPCTSTR lpstrString,
	IN BOOL bIsFilePath
    );

//
// Show/hide _AND_ enable/disable control
//
void COMDLL ActivateControl(
    IN CWnd & wndControl,
    IN BOOL fShow          = TRUE
    );

//
// Helper
//
inline void DeActivateControl(CWnd & wndControl)
{
    ActivateControl(wndControl, FALSE);
}

BOOL COMDLL VerifyState();


class COMDLL CMappedBitmapButton : public CBitmapButton
/*++

Class Description:

    Similar to CBitmapbutton, but use ::LoadMappedBitmap to reflect
    propert colour mapping.

Public Interface:

    CMappedBitmapButton     : Constructor

--*/
{
//
// Constructor
//
public:
    CMappedBitmapButton();

protected:
    BOOL LoadMappedBitmaps(
        UINT nIDBitmapResource,
        UINT nIDBitmapResourceSel = 0,
        UINT nIDBitmapResourceFocus = 0,
        UINT nIDBitmapResourceDisabled = 0
        );
};



class COMDLL CUpButton : public CMappedBitmapButton
/*++

Class Description:

    Up button.

Public Interface:

    CUpButton       : Constructor; does everything

--*/
{
public:
    CUpButton();
};



class COMDLL CDownButton : public CMappedBitmapButton
/*++

Class Description:

    Down button

Public Interface:

    CDownButton     : Constructor; does everything

--*/
{
public:
    CDownButton();
};



class COMDLL CRMCListBoxResources
{
/*++

Class Description:

    Listbox resources, a series of bitmaps for use by the listbox.  Will
    generate bitmaps against the proper background colours for both
    selected and non-selected states.

Public Interface:

    CRMCListBoxResources  : Constructor
    ~CRMCListBoxResources : Destructor

    SysColorChanged       : Regenerate bitmaps in response to change in colours
    DcBitMap              : Get final DC
    BitmapHeight          : Get bitmap height
    BitmapWidth           : Get bitmap width
    ColorWindow           : Get currently set window colour
    ColorHighlight        : Get currently set highlight colour
    ColorWindowText       : Get currently set window text colour
    ColorHighlightText    : Get currently set text highlight colour

--*/
//
// Constructor
//
public:
    CRMCListBoxResources(
        IN int bmId,
        IN int nBitmapWidth,
        IN COLORREF crBackground = RGB(0,255,0) /* Green */
        );

    ~CRMCListBoxResources();

//
// Interface
//
public:
    void SysColorChanged();
    const CDC & dcBitMap() const;
    int BitmapHeight() const;
    int BitmapWidth() const;
    COLORREF ColorWindow() const;
    COLORREF ColorHighlight() const;
    COLORREF ColorWindowText() const;
    COLORREF ColorHighlightText() const;

//
// Internal Helpers
//
protected:
    void GetSysColors();
    void PrepareBitmaps();
    void UnprepareBitmaps();
    void UnloadResources();
    void LoadResources();

private:
    COLORREF m_rgbColorWindow;
    COLORREF m_rgbColorHighlight;
    COLORREF m_rgbColorWindowText;
    COLORREF m_rgbColorHighlightText;
    COLORREF m_rgbColorTransparent;
    HGDIOBJ  m_hOldBitmap;
    CBitmap  m_bmpScreen;
    CDC      m_dcFinal;
    BOOL     m_fInitialized;
    int      m_idBitmap;
    int      m_nBitmapHeight;
    int      m_nBitmapWidth;
    int      m_nBitmaps;
};



class COMDLL CRMCListBoxDrawStruct
{
/*++

Class Description:

    Drawing information passed on to ODLBox

Public Interface:

    CRMCListBoxDrawStruct  : Constructor

--*/
public:
    CRMCListBoxDrawStruct(
        IN CDC * pDC,
        IN RECT * pRect,
        IN BOOL sel,
        IN DWORD_PTR item,
        IN int itemIndex,
        IN const CRMCListBoxResources * pres
        );

public:
    const CRMCListBoxResources * m_pResources;
    int   m_ItemIndex;
    CDC * m_pDC;
    CRect m_Rect;
    BOOL  m_Sel;
    DWORD_PTR m_ItemData;
};



/* abstract */ class COMDLL CODLBox
/*++

Class Description:

    abstract base class for owner-draw listbox and combobox

Public Interface:

    AttachResources   : Attach the resource structure to the list/combo box
    ChangeFont        : Change the font
    NumTabs           : Get the number of tabs currently set
    AddTab            : Add tab
    AddTabFromHeaders : Add tab computed from the difference in left coordinate
                        of two controls.
    InsertTab         : Insert a tab
    RemoveTab         : Remove a tab
    RemoveAllTabs     : Remove all tabs
    SetTab            : Set tab value
    GetTab            : Get tab value
    TextHeight        : Get the text height of the current font
    __GetCount        : Pure virtual function to get the number of items in the
                        list/combo box
    __SetItemHeight   : Pure virtual function to set the text height of the font

--*/
{
//
// Operations
//
public:
    void AttachResources(
        IN const CRMCListBoxResources * pResources
        );

    BOOL ChangeFont(
        CFont * pNewFont
        );

    int NumTabs() const;

    int AddTab(
        IN UINT uTab
        );

    int AddTabFromHeaders(
        IN CWnd & wndLeft,
        IN CWnd & wndRight
        );

    int AddTabFromHeaders(
        IN UINT idLeft,
        IN UINT idRight
        );

    void InsertTab(
        IN int nIndex,
        IN UINT uTab
        );

    void RemoveTab(
        IN int nIndex,
        IN int nCount = 1
        );

    void RemoveAllTabs();

    void SetTab(
        IN int nIndex,
        IN UINT uTab
        );

    UINT GetTab(
        IN int nIndex
        ) const;

    int TextHeight() const;

    /* pure */ virtual int __GetCount() const = 0;

    /* pure */ virtual int __SetItemHeight(
        IN int nIndex,
        IN UINT cyItemHeight
        ) = 0;

protected:
    CODLBox();
    ~CODLBox();

protected:
    //
    // Determine required display width of the string
    //
    static int GetRequiredWidth(
        IN CDC * pDC,
        IN const CRect & rc,
        IN LPCTSTR lpstr,
        IN int nLength
        );

    //
    // Helper function to display text in a limited rectangle
    //
    static BOOL ColumnText(
        IN CDC * pDC,
        IN int left,
        IN int top,
        IN int right,
        IN int bottom,
        IN LPCTSTR str
        );

protected:
    //
    // Helper functions for displaying bitmaps and text
    //
    BOOL DrawBitmap(
        IN CRMCListBoxDrawStruct & ds,
        IN int nCol,
        IN int nID
        );

    BOOL ColumnText(
        IN CRMCListBoxDrawStruct & ds,
        IN int nCol,
        IN BOOL fSkipBitmap,
        IN LPCTSTR lpstr
        );

    void ComputeMargins(
        IN  CRMCListBoxDrawStruct & ds,
        IN  int nCol,
        OUT int & nLeft,
        OUT int & nRight
        );

protected:
    void CalculateTextHeight(
        IN CFont * pFont
        );

    void AttachWindow(
        IN CWnd * pWnd
        );

protected:
    //
    // must override this to provide drawing of item
    //
    /* pure */ virtual void DrawItemEx(
        IN CRMCListBoxDrawStruct & dw
        ) = 0;

    void __MeasureItem(
        IN OUT LPMEASUREITEMSTRUCT lpMIS
        );

    void __DrawItem(
        IN LPDRAWITEMSTRUCT lpDIS
        );

    virtual BOOL Initialize();

protected:
    int m_lfHeight;
    const CRMCListBoxResources* m_pResources;

private:
    //
    // Window handle -- to be attached by derived class
    //
    CWnd * m_pWnd;
    CUIntArray m_auTabs;
};


//
// Forward decleration
//
class CHeaderListBox;



//
// Styles for listbox headers
//
#define HLS_STRETCH         (0x00000001)
#define HLS_BUTTONS         (0x00000002)

#define HLS_DEFAULT         (HLS_STRETCH | HLS_BUTTONS)



class COMDLL CRMCListBoxHeader : public CStatic
/*++

Class Description:

    Header object to be used in conjunction with listbox

Public Interface:

    CRMCListBoxHeader            : Constructor
    ~CRMCListBoxHeader           : Destructor

    Create                      : Create control

    GetItemCount                : Get the number of items in the header control
    GetColumnWidth              : Get column width of a specific column
    QueryNumColumns             : Get the number of columns in the listbox
    SetColumnWidth              : Set the width of specified column
    GetItem                     : Get header item information about specific
                                  column
    SetItem                     : Set header item information about specific
                                  column
    InsertItem                  : Insert header item
    DeleteItem                  : Delete header item
    RespondToColumnWidthChanges : Set response flagg

--*/
{
    DECLARE_DYNAMIC(CRMCListBoxHeader)

public:
    //
    // Constructor
    //
    CRMCListBoxHeader(
        IN DWORD dwStyle = HLS_DEFAULT
        );

    ~CRMCListBoxHeader();

    //
    // Create control
    //
    BOOL Create(
        IN DWORD dwStyle,
        IN const RECT & rect,
        IN CWnd * pParentWnd,
        IN CHeaderListBox * pListBox,
        IN UINT nID
        );

//
// Header control stuff
//
public:
    int GetItemCount() const;

    int GetColumnWidth(
        IN int nPos
        ) const;

    BOOL GetItem(
        IN int nPos,
        IN HD_ITEM * pHeaderItem
        ) const;

    BOOL SetItem(
        IN int nPos,
        IN HD_ITEM * pHeaderItem
        );

    int InsertItem(
        IN int nPos,
        IN HD_ITEM * phdi
        );

    BOOL DeleteItem(
        IN int nPos
        );

    void SetColumnWidth(
        IN int nCol,
        IN int nWidth
        );

    BOOL DoesRespondToColumnWidthChanges() const;

    void RespondToColumnWidthChanges(
        IN BOOL fRespond = TRUE
        );

    int QueryNumColumns() const;

protected:
    //{{AFX_MSG(CRMCListBoxHeader)
    afx_msg void OnDestroy();
    //}}AFX_MSG

    afx_msg void OnHeaderItemChanged(UINT nId, NMHDR * n, LRESULT * l);
    afx_msg void OnHeaderEndTrack(UINT nId, NMHDR * n, LRESULT * l);
    afx_msg void OnHeaderItemClick(UINT nId, NMHDR * n, LRESULT * l);
    afx_msg void OnSetFocus(CWnd * pWnd);

    DECLARE_MESSAGE_MAP()

    void CRMCListBoxHeader::SetTabsFromHeader();

    BOOL UseStretch() const;
    BOOL UseButtons() const;

private:
    CHeaderCtrl * m_pHCtrl;
    CHeaderListBox * m_pListBox;
    DWORD m_dwStyle;
    BOOL m_fRespondToColumnWidthChanges;

};



class COMDLL CRMCListBox : public CListBox, public CODLBox
/*++

Class Description:

    Super listbox class.  Its methods work for both
    single selection, and multi selection listboxes.

Public Interface:

    CRMCListBox          : Constructor
    ~CRMCListBox         : Destructor

    Initialize          : Initialize the control

    __GetCount          : Get the count of items in the listbox
    __SetItemHeight     : Set the item height in the listbox
    InvalidateSelection : Invalidate selection

--*/
{
    DECLARE_DYNAMIC(CRMCListBox)

public:
    //
    // Plain Construction
    //
    CRMCListBox();
    virtual ~CRMCListBox();
    virtual BOOL Initialize();

//
// Implementation
//
public:
    virtual int __GetCount() const;

    virtual int __SetItemHeight(
        IN int nIndex,
        IN UINT cyItemHeight
        );

    //
    // Invalidate item
    //
    void InvalidateSelection(
        IN int nSel
        );

    //
    // Select single item
    //
    int SetCurSel(int nSelect);

    //
    // Get index of selected item.  For multi-selects
    // with more than 1 selected, it will return LB_ERR
    //
    int GetCurSel() const;

    //
    // Check to see if item is selected
    //
    int GetSel(int nSel) const;

    //
    // Get count of selected items
    //
    int GetSelCount() const;

    //
    // Get next select item (single or multi-select).
    // Returns NULL if no further selected items available
    //
    void * GetNextSelectedItem(
        IN OUT int * pnStartingIndex
        );

    //
    // Select a single item (works for multi and single
    // select listboxes)
    //
    BOOL SelectItem(
        IN void * pItemData = NULL
        );

    //
    // Get the item at the single selection (works for both
    // multi and single selection listboxes).  Return NULL
    // if fewer than or more than one is selected.
    //
    void * GetSelectedListItem(
        OUT int * pnSel = NULL
        );

protected:
    //
    // Do-nothing drawitemex for non-owner draw listboxes.
    //
    virtual void DrawItemEx(
        IN CRMCListBoxDrawStruct & dw
        );

    virtual void MeasureItem(
        IN OUT LPMEASUREITEMSTRUCT lpMIS
        );

    virtual void DrawItem(
        IN LPDRAWITEMSTRUCT lpDIS
        );

protected:
    //{{AFX_MSG(CRMCListBox)
    afx_msg int  OnCreate(LPCREATESTRUCT lpCreateStruct);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

//
// Helpers
//
protected:
    BOOL IsMultiSelect() const;

private:
    BOOL m_fInitialized;
    BOOL m_fMultiSelect;
};


//
// Column Definition Structure
//
typedef struct tagODL_COLUMN_DEF
{
    int nWeight;
    UINT nLabelID;
} ODL_COLUMN_DEF;



//
// Enhanced Column Definition Structure (Can't
// be used in global structures in an AFXEXT dll
// because of the CObjectPlus reference)
//
typedef struct tagODL_COLUMN_DEF_EX
{
    ODL_COLUMN_DEF cd;
    CObjectPlus::PCOBJPLUS_ORDER_FUNC pSortFn;
} ODL_COLUMN_DEF_EX;



class COMDLL CHeaderListBox : public CRMCListBox
/*++

Class Description:

    Header listbox class. When using this class, do not use the tabbing
    functions of the base class.  These will be set by the header control.

Public Interface:

    CHeaderListBox      : Constructor
    ~CHeaderListBox     : Destructor

    Initialize          : Initialize the control
    QueryNumColumns     : Get the number of columns in the listbox
    QueryColumnWidth    : Get the width of specified column
    SetColumnWidth      : Set the width of specified column

--*/
{
    DECLARE_DYNAMIC(CHeaderListBox)

public:
    //
    // Plain Construction
    //
    CHeaderListBox(
        IN DWORD dwStyle = HLS_DEFAULT,
        LPCTSTR lpRegKey = NULL
        );

    virtual ~CHeaderListBox();

    virtual BOOL Initialize();

public:
    BOOL EnableWindow(
        IN BOOL bEnable = TRUE
        );

    BOOL ShowWindow(
        IN int nCmdShow
        );

    int QueryNumColumns() const;

    int QueryColumnWidth(
        IN int nCol
        ) const;

    BOOL SetColumnWidth(
        IN int nCol,
        IN int nWidth
        );

//
// Header Control Attachment Access
//
protected:
    int GetHeaderItemCount() const;

    BOOL GetHeaderItem(
        IN int nPos,
        IN HD_ITEM * pHeaderItem
        ) const;

    BOOL SetHeaderItem(
        IN int nPos,
        IN HD_ITEM * pHeaderItem
        );

    int InsertHeaderItem(
        IN int nPos,
        IN HD_ITEM * phdi
        );

    BOOL DeleteHeaderItem(
        IN int nPos
        );

    CRMCListBoxHeader * GetHeader();

    int InsertColumn(
        IN int nCol,
        IN int nWeight,
        IN UINT nStringID,
        IN HINSTANCE hResInst
        );

    void ConvertColumnWidth(
        IN int nCol,
        IN int nTotalWeight,
        IN int nTotalWidth
        );

    BOOL SetWidthsFromReg();

    void DistributeColumns();

protected:
    //{{AFX_MSG(CHeaderListBox)
    afx_msg int  OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnDestroy();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    BOOL m_fInitialized;
    CString m_strRegKey;
    CRMCListBoxHeader * m_pHeader;
};



class COMDLL CRMCComboBox : public CComboBox, public CODLBox
/*++

Class Description:

    Super combo box class

Public Interface:

    CRMCComboBox        : Constructor
    ~CRMCComboBox       : Destructor

    Initialize          : Initialize the control

    __GetCount          : Get the count of items in the combobox
    __SetItemHeight     : Set the item height in the combobox
    InvalidateSelection : Invalidate selection

--*/
{
    DECLARE_DYNAMIC(CRMCComboBox)

//
// Construction
//
public:
    CRMCComboBox();
    virtual BOOL Initialize();

//
// Implementation
//
public:
    virtual ~CRMCComboBox();

    virtual int __GetCount() const;

    virtual int __SetItemHeight(
        IN int nIndex,
        IN UINT cyItemHeight
        );

    void InvalidateSelection(
        IN int nSel
        );

protected:
    //
    // Do-nothing drawitemex for non-owner draw comboboxes.
    //
    virtual void DrawItemEx(
        IN CRMCListBoxDrawStruct & dw
        );

    virtual void MeasureItem(
        IN OUT LPMEASUREITEMSTRUCT lpMIS
        );

    virtual void DrawItem(
        IN LPDRAWITEMSTRUCT lpDIS
        );

protected:
    //{{AFX_MSG(CRMCComboBox)
    afx_msg int  OnCreate(LPCREATESTRUCT lpCreateStruct);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    BOOL m_fInitialized;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CMappedBitmapButton::CMappedBitmapButton()
{
};

inline CUpButton::CUpButton()
{
   LoadMappedBitmaps(IDB_UP, IDB_UPINV, IDB_UPFOC, IDB_UPDIS);
}

inline CDownButton::CDownButton()
{
   LoadMappedBitmaps(IDB_DOWN, IDB_DOWNINV, IDB_DOWNFOC, IDB_DOWNDIS);
}

inline const CDC & CRMCListBoxResources::dcBitMap() const
{
    return m_dcFinal;
}

inline int CRMCListBoxResources::BitmapHeight() const
{
    return m_nBitmapHeight;
}

inline int CRMCListBoxResources::BitmapWidth() const
{
    return m_nBitmapWidth;
}

inline COLORREF CRMCListBoxResources::ColorWindow() const
{
    return m_rgbColorWindow;
}

inline COLORREF CRMCListBoxResources::ColorHighlight() const
{
    return m_rgbColorHighlight;
}

inline COLORREF CRMCListBoxResources::ColorWindowText() const
{
    return m_rgbColorWindowText;
}

inline COLORREF CRMCListBoxResources::ColorHighlightText() const
{
    return m_rgbColorHighlightText;
}

inline int CODLBox::NumTabs() const
{
    return (int)m_auTabs.GetSize();
}

inline void CODLBox::SetTab(
    IN int nIndex,
    IN UINT uTab
    )
{
    ASSERT(nIndex >= 0 && nIndex < NumTabs());
    m_auTabs[nIndex] = uTab;
}

inline UINT CODLBox::GetTab(
    IN int nIndex
    ) const
{
    ASSERT(nIndex >= 0 && nIndex < NumTabs());
    return m_auTabs[nIndex];
}

inline int CODLBox::TextHeight() const
{
    return m_lfHeight;
}

inline void CODLBox::AttachWindow(
    IN CWnd * pWnd
    )
{
    m_pWnd = pWnd;
}

inline BOOL CRMCListBoxHeader::DoesRespondToColumnWidthChanges() const
{
    return m_fRespondToColumnWidthChanges;
}

inline void CRMCListBoxHeader::RespondToColumnWidthChanges(
    IN BOOL fRespond
    )
{
    m_fRespondToColumnWidthChanges = fRespond;
}

inline int CRMCListBoxHeader::QueryNumColumns() const
{
    return GetItemCount();
}

inline BOOL CRMCListBoxHeader::UseStretch() const
{
    return (m_dwStyle & HLS_STRETCH) != 0L;
}

inline BOOL CRMCListBoxHeader::UseButtons() const
{
    return (m_dwStyle & HLS_BUTTONS) != 0L;
}

inline int CHeaderListBox::QueryNumColumns() const
{
    return GetHeaderItemCount();
}

inline int CHeaderListBox::GetHeaderItemCount() const
{
    ASSERT_PTR(m_pHeader);
    return m_pHeader->GetItemCount();
}

inline BOOL CHeaderListBox::GetHeaderItem(
    IN int nPos,
    IN HD_ITEM * pHeaderItem
    ) const
{
    ASSERT_PTR(m_pHeader);
    return m_pHeader->GetItem(nPos, pHeaderItem);
}

inline BOOL CHeaderListBox::SetHeaderItem(
    IN int nPos,
    IN HD_ITEM * pHeaderItem
    )
{
    ASSERT_PTR(m_pHeader);
    return m_pHeader->SetItem(nPos, pHeaderItem);
}

inline int CHeaderListBox::InsertHeaderItem(
    IN int nPos,
    IN HD_ITEM * phdi
    )
{
    ASSERT_PTR(m_pHeader);
    return m_pHeader->InsertItem(nPos, phdi);
}

inline BOOL CHeaderListBox::DeleteHeaderItem(
    IN int nPos
    )
{
    ASSERT_PTR(m_pHeader);
    return m_pHeader->DeleteItem(nPos);
}

inline CRMCListBoxHeader * CHeaderListBox::GetHeader()
{
    return m_pHeader;
}

inline BOOL CRMCListBox::IsMultiSelect() const
{
    ASSERT(m_fInitialized);
    return m_fMultiSelect;
}


#endif  // _ODLBOX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\sitesecu.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        sitesecu.cpp

   Abstract:

        Site Security property page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager (cluster edition)

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "common.h"


#undef dllexp
#include <tcpdllp.hxx>
#define  _RDNS_STANDALONE
#include <rdns.hxx>


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif // _DEBUG



//#ifdef _DEBUG
//
// Careful here... This may cause build failure
//
extern "C" DEBUG_PRINTS * g_pDebug = NULL;
//#endif // _DEBUG


#define new DEBUG_NEW




CIPAccessDescriptor::CIPAccessDescriptor(
    IN BOOL fGranted 
    )
/*++

Routine Description:

    Dummy Constructor for access description object.  Assumes a single IP
    address of 0.0.0.0

Arguments:
    
    BOOL fGranted : TRUE for 'grant' access, FALSE for 'deny' access      

Return Value:

    N/A

--*/
    : m_fGranted(fGranted),
      m_adtType(CIPAccessDescriptor::ADT_SINGLE),
      m_iaIPAddress(NULL_IP_ADDRESS),
      m_iaSubnetMask(NULL_IP_MASK),
      m_strDomain()
{
}




CIPAccessDescriptor::CIPAccessDescriptor(
    IN const CIPAccessDescriptor & ac
    )
/*++

Routine Description:

    Copy constructor for access description object

Arguments:

    const CIPAccessDescriptor & ac : Source access description object    

Return Value:

    N/A

--*/
    : m_fGranted(ac.m_fGranted),
      m_adtType(ac.m_adtType),
      m_iaIPAddress(ac.m_iaIPAddress),
      m_iaSubnetMask(ac.m_iaSubnetMask),
      m_strDomain(ac.m_strDomain)
{
}



CIPAccessDescriptor::CIPAccessDescriptor(
    IN BOOL fGranted,
    IN DWORD dwIPAddress,
    IN DWORD dwSubnetMask,    OPTIONAL
    IN BOOL fNetworkByteOrder OPTIONAL
    )
/*++

Routine Description:

    Constructor for ip range (ip address/subnet mask pair) 
    access description object.

Arguments:

    BOOL fGranted          : TRUE for 'grant' access, FALSE for 'deny' access      
    DWORD dwIPAddress      : IP Address
    DWORD dwSubnetMask     : The subnet mask or 0xffffffff
    BOOL fNetworkByteOrder : If TRUE, the ip address and subnet mask are in 
                             network byte order

Return Value:

    N/A

--*/
{
    SetValues(fGranted, dwIPAddress, dwSubnetMask, fNetworkByteOrder);
}



CIPAccessDescriptor::CIPAccessDescriptor(
    IN BOOL fGranted,
    IN LPCTSTR lpstrDomain
    )
/*++

Routine Description:

    Constructor for domain name access description object.

Arguments:

    BOOL fGranted       : TRUE for 'grant' access, FALSE for 'deny' access      
    LPCTSTR lpstrDomain : The domain name

Return Value:

    N/A

--*/
{
    SetValues(fGranted, lpstrDomain);
}


void
CIPAccessDescriptor::SetValues(
    IN BOOL fGranted,
    IN DWORD dwIPAddress,
    IN DWORD dwSubnetMask,
    IN BOOL fNetworkByteOrder OPTIONAL
    )
/*++

Routine Description:

    Set values for 'ip range (ip address and subnet mask)' access descriptor,
    or a single ip address if  the mask is 0xffffffff

Arguments:

    BOOL fGranted          : TRUE for 'grant' access, FALSE for 'deny' access
    DWORD dwIPAddress      : IP Address
    DWORD dwSubnetMask     : The subnet mask or ffffffff
    BOOL fNetworkByteOrder : If TRUE, the ip address and subnet mask are in 
                             network byte order

Return Value:

    None

Notes:

    If the subnetmask is 0xffffffff this describes a single ip address.

--*/
{
    m_fGranted = fGranted;
    m_adtType = (dwSubnetMask == NULL_IP_MASK) ? ADT_SINGLE : ADT_MULTIPLE;
    m_iaIPAddress = CIPAddress(dwIPAddress, fNetworkByteOrder);
    m_iaSubnetMask = CIPAddress(dwSubnetMask, fNetworkByteOrder);

    //
    // Not used:
    //
    m_strDomain.Empty();
}



void
CIPAccessDescriptor::SetValues(
    IN BOOL fGranted,
    IN LPCTSTR lpstrDomain
    )
/*++

Routine Description:

    Set values for 'domain name' access descriptor

Arguments:

    BOOL fGranted       : TRUE for 'grant' access, FALSE for 'deny' access
    LPCTSTR lpstrDomain : The domain name

Return Value:

    None

--*/
{
    m_fGranted = fGranted;
    m_adtType = ADT_DOMAIN;

    try
    {
        m_strDomain = lpstrDomain;
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("!!!exception assigning domain name");
        e->ReportError();
        e->Delete();
    }

    //
    // Not used:
    //
    m_iaIPAddress.SetZeroValue();
    m_iaSubnetMask.SetZeroValue();
}



BOOL 
CIPAccessDescriptor::DuplicateInList(
    IN CObListPlus & oblList
    )
/*++

Routine Description:

    Check to see if a duplicate exists in the provided oblist

Arguments:

    CObListPlus & oblList

Return Value:

    TRUE if a duplicate exists, FALSE otherwise.

Notes:

    As there's no information how this list might be sorted at this point,
    and the list is likely to be small, the search is sequential.

--*/
{
    CObListIter obli(oblList);
    CIPAccessDescriptor * pAccess;

    TRACEEOLID("Looking for duplicate access descriptors");
    while (pAccess = (CIPAccessDescriptor *)obli.Next())
    {
        ASSERT_READ_PTR(pAccess);

        //
        // Eliminate the item itself from the list, and look
        // only for duplicates.
        //
        if (pAccess != this && *this == *pAccess)
        {
            TRACEEOLID("Duplicate access descriptor found");
            return TRUE;
        }
    }

    TRACEEOLID("No duplicate access descriptor found");

    return FALSE;
}



BOOL
CIPAccessDescriptor::operator ==(
    IN const CIPAccessDescriptor & ac
    ) const
/*++

Routine Description:

    Compare against another access descriptor.

Arguments:

    const CIPAccessDescriptor & ac : Object to be compared against

Return Value:

    TRUE if the two are identical

--*/
{
    if ( m_fGranted != ac.m_fGranted
      || m_adtType != ac.m_adtType)
    {
        return FALSE;
    }

    if (IsDomainName())
    {
        return m_strDomain.CompareNoCase(ac.m_strDomain) == 0;
    }

    return m_iaIPAddress == ac.m_iaIPAddress
        && m_iaSubnetMask == ac.m_iaSubnetMask;
}



int
CIPAccessDescriptor::OrderByAddress(
    IN const CObjectPlus * pobAccess
    ) const
/*++

Routine Description:

    Compare two access descriptors against each other. 
    Sorting criteria are in the following order:

    1) 'Granted' sorts before 'Denied'
    2) Domain names are sorted before ip addresses, and are
       sorted alphabetically.
    3) IP Address and IP Address/subnet mask pairs are sorted
       by ip address.

Arguments:

    const CObjectPlus * pobAccess : This really refers to another 
                                    CIPAccessDescriptor to be compared to.

Return Value:

    Sort (+1, 0, -1) return value

--*/
{
    const CIPAccessDescriptor * pob = (CIPAccessDescriptor *)pobAccess;

    //
    // First sort by access/denied
    //
    int n1 = HasAccess() ? 1 : 0;
    int n2 = pob->HasAccess() ? 1 : 0;

    if (n2 != n1)
    {
        //
        // Grant sorts before denied
        //
        return n2 - n1;
    }

    //
    // Secondly, try to sort by domain name (domain name sorts before
    // ip address and ip address/subnet mask objects)
    //
    n1 = IsDomainName() ? 1 : 0;
    n2 = pob->IsDomainName() ? 1 : 0;

    if (n1 != n2)
    {
        //
        // Domain names sort before ip addresses
        //
        return n2 - n1;
    }

    if (n1 && n2)
    {
        //
        // Both are domain names.  Sort alphabetically
        //
        return ::lstrcmpi(QueryDomainName(), pob->QueryDomainName());
    }

    //
    // IP address is the third key.
    //
    return QueryIPAddress().CompareItem(pob->QueryIPAddress());
}



DWORD
AddAccessEntries(
    IN  ADDRESS_CHECK & ac,
    IN  BOOL fName,
    IN  BOOL fGrant,
    OUT CObListPlus & oblAccessList,
    OUT DWORD & cEntries
    )
/*++

Routine Description:

    Add specific kind of addresses from the list to the oblist of
    access entries

Arguments:

    ADDRESS_CHECK & ac              : Address list input object
    BOOL fName                      : TRUE for names, FALSE for ip
    BOOL fGrant                     : TRUE for granted, FALSE for denied        
    CObListPlus & oblAccessList     : ObList to add access entries to
    int & cEntries                  : Returns the number of entries
    
Return Value:

    Error code

Notes:

    Sentinel entries (ip 0.0.0.0) are not added to the oblist, but
    are reflected in the cEntries return value

--*/
{
    DWORD i;
    DWORD dwFlags;

    if (fName)
    {
        //
        // Domain names
        //
        LPSTR lpName;

        cEntries = ac.GetNbName(fGrant);

        for (i = 0L; i < cEntries; ++i)
        {
            if (ac.GetName(fGrant, i,  &lpName, &dwFlags))
            {
                CString strDomain(lpName);

                if (!(dwFlags & DNSLIST_FLAG_NOSUBDOMAIN))
                {
                    strDomain = _T("*.") + strDomain;
                }

                oblAccessList.AddTail(new CIPAccessDescriptor(fGrant, strDomain));
            }
        }
    }
    else
    {
        //
        // IP Addresses
        //
        LPBYTE lpMask;
        LPBYTE lpAddr;
        cEntries = ac.GetNbAddr(fGrant);

        for (i = 0L; i < cEntries; ++i)
        {
            if (ac.GetAddr(fGrant, i,  &dwFlags, &lpMask, &lpAddr))
            {
                DWORD dwIP = MAKEIPADDRESS(lpAddr[0], lpAddr[1], lpAddr[2], lpAddr[3]);
                DWORD dwMask = MAKEIPADDRESS(lpMask[0], lpMask[1], lpMask[2], lpMask[3]);

                if (dwIP == NULL_IP_ADDRESS && dwMask == NULL_IP_MASK)
                {
                    //
                    // Sentinel in the grant list is not added, but
                    // also not subtracted from the count of entries,
                    // which is correct behaviour, since this is
                    // how default grant/deny by default is determined.
                    //
                    TRACEEOLID("Ignoring sentinel");
                }
                else
                {
                    oblAccessList.AddTail(
                        new CIPAccessDescriptor(
                           fGrant,
                           dwIP,
                           dwMask,
                           FALSE
                           )
                        );
                }
            }
        }
    }

    return ERROR_SUCCESS;
}



DWORD
BuildIplOblistFromBlob(
    IN  CBlob & blob,
    OUT CObListPlus & oblAccessList,
    OUT BOOL & fGrantByDefault
    )
/*++

Routine Description:

    Convert a blob to an oblist of access descriptors.

Arguments:

    CBlob & blob                : Input binary large object(blob)
    CObListPlus & oblAccessList : Output oblist of access descriptors
    BOOL & fGrantByDefault      : Returns TRUE if access is granted
                                  by default, FALSE otherwise

Return Value:

    Error Return Code

--*/
{
    oblAccessList.RemoveAll();

    if (blob.IsEmpty())
    {
        return ERROR_SUCCESS;
    }

    ADDRESS_CHECK ac;
    ac.BindCheckList(blob.GetData(), blob.GetSize());

    DWORD cGrantAddr, cGrantName, cDenyAddr, cDenyName;

    //                   Name/IP Granted/Deny
    // ============================================================
    AddAccessEntries(ac, TRUE,   TRUE,  oblAccessList, cGrantName);
    AddAccessEntries(ac, FALSE,  TRUE,  oblAccessList, cGrantAddr);
    AddAccessEntries(ac, TRUE,   FALSE, oblAccessList, cDenyName);
    AddAccessEntries(ac, FALSE,  FALSE, oblAccessList, cDenyAddr);

    ac.UnbindCheckList();

    fGrantByDefault = (cDenyAddr + cDenyName != 0L)
        || (cGrantAddr + cGrantName == 0L);

    return ERROR_SUCCESS;
}  



LPSTR 
PrepareDomainName(
    IN  LPSTR lpName,
    OUT DWORD * pdwFlags
    )
/*++

Routine Description:

    Check to see if the domain name contains a wild card,
    if so remove it.  Set the flags based on the domain name

Arguments:

    LPSTR  lpName       : Input domain name
    DWORD * pdwFlags    : Return the flags for AddName

Return:

    Pointer to the cleaned up domain name

--*/
{
    *pdwFlags = 0L;

    if (!strncmp(lpName, "*.", 2))
    {
        return lpName + 2;
    }

    *pdwFlags |= DNSLIST_FLAG_NOSUBDOMAIN;

    return lpName;
}



void
BuildIplBlob(
    IN  CObListPlus & oblAccessList,
    IN  BOOL fGrantByDefault,
    OUT CBlob & blob
    )
/*++

Routine Description:

    Build a blob from an oblist of access descriptors

Arguments:

    CObListPlus & oblAccessList  : Input oblist of access descriptors
    BOOL fGrantByDefault         : TRUE if access is granted by default
    CBlob & blob                 : Output blob

Return Value:

    None

Notes:

    If fGrantByDefault is FALSE, e.g. access is to be denied by
    default, but nobody is specifically granted access, then add
    a dummy entry 0.0.0.0 to the grant list.

    If grant by default is on, then granted entries will not be
    added to the blob.  Similart for denied entries if deny by
    default is on.

--*/
{
    ADDRESS_CHECK ac;

    ac.BindCheckList();

    int cItems = 0;

    CObListIter obli(oblAccessList);
    const CIPAccessDescriptor * pAccess;

    //
    // Should be empty to start with.
    //
    ASSERT(blob.IsEmpty());
    blob.CleanUp();

    BYTE bMask[4];
    BYTE bIp[4];

    while (pAccess = (CIPAccessDescriptor *)obli.Next())
    {
        ASSERT_READ_PTR(pAccess);

        if (pAccess->HasAccess() == fGrantByDefault)
        {
            //
            // Skip this entry -- it's irrelevant
            //
            continue;
        }

        if (pAccess->IsDomainName())
        {
            LPSTR lpName = AllocAnsiString(pAccess->QueryDomainName());
            if (lpName)
            {
                DWORD dwFlags;
                LPSTR lpDomain = PrepareDomainName(lpName, &dwFlags);
                ac.AddName(
                    pAccess->HasAccess(),
                    lpDomain,
                    dwFlags
                    );
                FreeMem(lpName);
            }
        }
        else
        {
            //
            // Build with network byte order
            //
            ac.AddAddr(
                pAccess->HasAccess(),
                AF_INET, 
                CIPAddress::DWORDtoLPBYTE(pAccess->QuerySubnetMask(FALSE), bMask),
                CIPAddress::DWORDtoLPBYTE(pAccess->QueryIPAddress(FALSE), bIp)  
                );
        }

        ++cItems;
    }

    if (cItems == 0 && !fGrantByDefault)
    {
        //
        // List is empty.  If deny by default is on, create
        // a dummy sentinel entry to grant access to single
        // address 0.0.0.0, otherwise we're ok.
        //
        ac.AddAddr(
            TRUE,
            AF_INET, 
            CIPAddress::DWORDtoLPBYTE(NULL_IP_MASK, bMask),
            CIPAddress::DWORDtoLPBYTE(NULL_IP_ADDRESS, bIp)  
            );
        ++cItems;
    }

    if (cItems > 0)
    {
        blob.SetValue(ac.QueryCheckListSize(), ac.QueryCheckListPtr(), TRUE);
    }

    ac.UnbindCheckList();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\objplus.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        objplus.h

   Abstract:

        Base object class definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _COMMON_H_
#define _COMMON_H_



//
// Forward declarations
//
class CObjHelper;
class CObjectPlus;
class CObListPlus;
class CObListIter;



class COMDLL CObjHelper
/*++

Class Description:

    Helper class for control of construction and API errors

Public Interface:

    IsValid           : Determine if the object is in a valid state.
    operator BOOL     : Boolean cast to IsValid()
    SetDirty          : Set or reset the dirty flag
    IsDirty           : Query the dirty state of the object
    QueryCreationTime : Query the creation time of the object
    QueryAge          : Query the age of the object
    ReportError       : Query/set construction failure
    QueryError        : Query the error code of the object
    QueryApiErr       : Query/set API error code
    ResetErrors       : Reset all error codes
    SetApiErr         : Echoes the error to the caller
    AssertValid       : Assert the object is in a valid state (debug only)

--*/
{
protected:
    //
    // Protected constructor: Not to be declared independently.
    //
    CObjHelper();

public:
    virtual BOOL IsValid() const;
    operator BOOL();

    //
    // Update the Dirty flag
    //
    void SetDirty(
        IN BOOL fDirty = TRUE
        );

    //
    // Query the Dirty flag
    //
    BOOL IsDirty() const { return m_fDirty; }

    //
    // Return the creation time of this object
    //
    DWORD QueryCreationTime() const { return m_time_created; }

    //
    // Return the elapsed time this object has been alive.
    //
    DWORD QueryAge() const;

    //
    // Query/set construction failure
    //
    void ReportError(
        IN LONG errInConstruction
        );

    //
    // Fetch construction error
    //
    LONG QueryError() const { return m_ctor_err; }

    //
    // Query/set API errors.
    //
    LONG QueryApiErr() const { return m_api_err; }

    //
    // Reset all error conditions.
    //
    void ResetErrors();

    //
    // SetApiErr() echoes the error to the caller.
    // for use in expressions.
    //
    LONG SetApiErr(
        IN LONG errApi = ERROR_SUCCESS
        );

#ifdef _DEBUG

    void AssertValid() const;

#endif // _DEBUG

protected:
    LONG  m_ctor_err;
    LONG  m_api_err;
    DWORD m_time_created;
    BOOL  m_fDirty;
};



class COMDLL CObjectPlus : public CObject, public CObjHelper
/*++

Class Description:

    Super CObject class.

Public Interface:

    CObjectPlus       : Constructor
    Compare           : Compare one object with another

--*/
{
public:
    CObjectPlus();

    //
    // Compare one object with another
    //
    virtual int Compare(
        IN const CObjectPlus * pob
        ) const;

    //
    // Define a typedef for an ordering function.
    //
    typedef int (CObjectPlus::*PCOBJPLUS_ORDER_FUNC)(
        IN const CObjectPlus * pobOther
        ) const;
};



class COMDLL CObListPlus : public CObList, public CObjHelper
/*++

Class Description:

    Object pointer list which optionally "owns" the objects pointed to, and
    with facility to sort.  If the list "owns" its objects, the destructor
    will clean up its member objects.

Public Interface:

    CObListPlus      : Constructor
    ~CObListPlus     : Destructor

    SetOwnership     : Set/reset ownership bit
    Index            : Get object by index
    RemoveIndex      : Remove object by index
    Remove           : Remove object
    RemoveAt         : Remove object at position
    RemoveAll        : Remove all objects
    FindElement      : Find object
    SetAll           : Set/Reset the dirty flag of all objects
    AddTail          : Add new object to the tail of the list
    Sort             : Sort the list elements with sorting function provided

--*/
{
//
// Constructor/Destructor
//
public:
    CObListPlus(
        IN int nBlockSize = 10
        );

    virtual ~CObListPlus();

//
// Access
//
public:
    BOOL SetOwnership(
        IN BOOL fOwned = TRUE
        );

    //
    // Return object at the given index
    //
    CObject * Index(
        IN int index
        );

    //
    // Remove item the given index
    //
    BOOL RemoveIndex(
        IN int index
        );

    //
    // Remove the given object from the list
    //
    BOOL Remove(
        IN CObject * pob
        );

    //
    // Remove the item at the given position
    //
    void RemoveAt(
        IN POSITION & pos
        );

    //
    // Remove all items from the list
    //
    void RemoveAll();

    int FindElement(
        IN CObject * pobSought
        ) const;

    //
    // Set all elements to dirty or clean.  Return TRUE if
    // any element was dirty.
    //
    BOOL SetAll(
        IN BOOL fDirty = FALSE
        );

    //
    // Sort the list elements according to the
    // given ordering function.  Return error code
    //
    DWORD Sort(
        IN CObjectPlus::PCOBJPLUS_ORDER_FUNC pOrderFunc
        );

protected:
    static int _cdecl SortHelper(
        IN const void * pa,
        IN const void * pb
        );

protected:
    BOOL m_fOwned;
};



class COMDLL CObListIter : public CObjectPlus
/*++

Class Description:

    Object iteration class

Public Interface:

    CObListIter       : Constructor
    Next              : Get next object
    Reset             : Reset the iteration index
    QueryPosition     : Query the current iteration index
    SetPosition       : Set the current position in the list by POSITION

--*/
{
public:
    CObListIter(
        IN const CObListPlus & obList
        );

    CObject * Next();
    void Reset();
    POSITION QueryPosition() const { return m_pos; }

    void SetPosition(
        IN POSITION pos
        );

protected:
    POSITION m_pos;
    const CObListPlus & m_obList;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CObjHelper::operator BOOL()
{
    return IsValid();
}

inline void CObjHelper::SetDirty(
    IN BOOL fDirty 
    )
{
    m_fDirty = fDirty;
}

inline void CObjHelper::ResetErrors()
{
    m_ctor_err = m_api_err = ERROR_SUCCESS;
}

inline BOOL CObListPlus::SetOwnership(
    IN BOOL fOwned
    )
{
    BOOL fOld = m_fOwned;
    m_fOwned = fOwned;

    return fOld;
}

inline void CObListIter::SetPosition(
    IN POSITION pos
    )
{
    m_pos = pos;
}

#endif // _COMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\sitesecu.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        sitesecu.h

   Abstract:

        Site Security property page definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _SITESECU_H_
#define _SITESECU_H_



#define DEFAULT_GRANTED     0
#define DEFAULT_DENIED      1



class COMDLL CIPAccessDescriptor : public CObjectPlus
/*++

Class Description:

    Access description object

Public Interface:

    CIPAccessDescriptor : Various overload constructors for the different types

    SetValues         : Set values, overloaded on a per type basis
    DuplicateInList   : Check to see if a duplicate entry exists in the list
    GrantAccess       : Grant or deny access
    HasAccess         : Query whether the object describes a 'grant' or 'deny'
                        item
    IsSingle          : Query whether the object describes a single IP address
    IsMultiple        : Query whether the object describes a range of ip 
                        addresses
    IsDomainName      : Query whether the object describes a domain name
    QueryIPAddress    : Get the object's IP address
    QuerySubnetMask   : Get the object's subnet mask value
    QueryDomainName   : Get the object's domain name
    operator ==       : Comparison operator
    OrderByAddress    : Sorting helper

--*/
{
protected:
    //
    // Access descriptor types
    //
    enum AD_TYPE
    {
        ADT_SINGLE,
        ADT_MULTIPLE,
        ADT_DOMAIN,
    };

//
// Constructors
//
public:
    //
    // Construct NULL descriptor
    //
    CIPAccessDescriptor(
        IN BOOL fGranted = TRUE
        );

    //
    // Copy Constructor
    //
    CIPAccessDescriptor(
        IN const CIPAccessDescriptor & ac
        );

    //
    // Construct with ip address(ip address/subnet mask) descriptor
    // if subnet massk is ffffffff this describes a single ip address
    //
    CIPAccessDescriptor(
        IN BOOL fGranted,
        IN DWORD dwIpAddress,
        IN DWORD dwSubnetMask = NULL_IP_MASK,
        IN BOOL fNetworkByteOrder = FALSE
        );

    //
    // Construct domain name descriptor
    //
    CIPAccessDescriptor(
        IN BOOL fGranted,
        IN LPCTSTR lpstrDomain
        );

//
// Interface
//
public:
    //
    // Set ip address/ip range value
    //
    void SetValues(
        IN BOOL fGranted,
        IN DWORD dwIpAddress,
        IN DWORD dwSubnetMask = NULL_IP_MASK,
        BOOL fNetworkByteOrder = FALSE
        );

    //
    // Set domain name
    //
    void SetValues(
        IN BOOL fGranted,
        IN LPCTSTR lpstrDomain
        );

    //
    // Check to see if a duplicate exists in the 
    // list.  
    //
    BOOL DuplicateInList(
        IN CObListPlus & oblList
        );
        
//
// Access
//
public:
    //
    // Access Functions
    //
    BOOL HasAccess() const;

    //
    // Grant/deny access
    //
    void GrantAccess(
        IN BOOL fGranted = TRUE
        );

    //
    // TRUE if this item is single ip address
    //
    BOOL IsSingle() const;

    //
    // True if this item describes an ip range
    //
    BOOL IsMultiple() const;

    //
    // True if this item describes a domain name
    //
    BOOL IsDomainName() const;

    //
    // Get the ip address as a DWORD
    //
    DWORD QueryIPAddress(
        IN BOOL fNetworkByteOrder
        ) const;

    //
    // Get the ip address as ip address object
    //
    CIPAddress QueryIPAddress() const;

    //
    // Get the subnet mask as a DWORD
    //
    DWORD QuerySubnetMask(
        IN BOOL fNetworkByteOrder
        ) const;

    //
    // Get the subnet mask as an ip address object
    //
    CIPAddress QuerySubnetMask() const;

    //
    // Get the domain name
    //
    LPCTSTR QueryDomainName() const;

public:
    //
    // Comparison Operator
    //
    BOOL operator ==(
        IN const CIPAccessDescriptor & ac
        ) const;

    //
    // Sorting Helper
    //
    int OrderByAddress(
        IN const CObjectPlus * pobAccess
        ) const;

private:
    BOOL m_fGranted;
    AD_TYPE m_adtType;
    CString m_strDomain;
    CIPAddress m_iaIPAddress;
    CIPAddress m_iaSubnetMask;
};



//
// Helper Functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


//
// Convert an oblist of access descriptors to a blob
//
void 
COMDLL 
BuildIplBlob(
    IN  CObListPlus & oblAccessList,
    IN  BOOL fGrantByDefault,
    OUT CBlob & blob
    );


//
// Reverse the above, build an oblist of access descriptors
// from a blob
//
DWORD 
COMDLL 
BuildIplOblistFromBlob(
    IN  CBlob & blob,
    OUT CObListPlus & oblAccessList,
    OUT BOOL & fGrantByDefault
    );



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline BOOL CIPAccessDescriptor::HasAccess() const
{
    return m_fGranted;
}

inline void CIPAccessDescriptor::GrantAccess(
    IN BOOL fGranted
    )
{
    m_fGranted = fGranted;
}

inline BOOL CIPAccessDescriptor::IsSingle() const
{
    return m_adtType == ADT_SINGLE;
}

inline BOOL CIPAccessDescriptor::IsMultiple() const
{
    return m_adtType == ADT_MULTIPLE;
}

inline BOOL CIPAccessDescriptor::IsDomainName() const
{
    return m_adtType == ADT_DOMAIN;
}

inline DWORD CIPAccessDescriptor::QueryIPAddress(
    IN BOOL fNetworkByteOrder
    ) const
{
    ASSERT(!IsDomainName());
    return m_iaIPAddress.QueryIPAddress(fNetworkByteOrder);
}

inline CIPAddress CIPAccessDescriptor::QueryIPAddress() const
{
    ASSERT(!IsDomainName());
    return m_iaIPAddress;
}

inline DWORD CIPAccessDescriptor::QuerySubnetMask(
    IN BOOL fNetworkByteOrder
    ) const
{
    ASSERT(!IsDomainName());
    return m_iaSubnetMask.QueryIPAddress(fNetworkByteOrder);
}

inline CIPAddress CIPAccessDescriptor::QuerySubnetMask() const
{
    ASSERT(!IsDomainName());
    return m_iaSubnetMask;
}

inline LPCTSTR CIPAccessDescriptor::QueryDomainName() const
{
    ASSERT(IsDomainName());
    return (LPCTSTR)m_strDomain;
}



#endif  // _SITESECU_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\stdafx.h ===
#ifndef __STDAFX_H__
#define __STDAFX_H__

#define VC_EXTRALEAN

#include <ctype.h>

extern "C"
{
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
}

#undef STRICT
#undef VERIFY
#undef ASSERT



#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED



#include <afxwin.h>
#include <afxdisp.h>
#include <afxext.h>         // MFC extensions
#include <afxcoll.h>        // collection class
#include <afxtempl.h>
#include <afxcmn.h>

#include <atlbase.h>

#include <iiscnfg.h>
#include <inetreg.h>
#include <lmcons.h>
#include <tchar.h>

#include <aclapi.h>

//{{AFX_INSERT_LOCATION}}


#endif // __STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\strfn.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        strfrn.h

   Abstract:

        String Functions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager (Cluster Edition)

   Revision History:

--*/

#ifndef _STRFN_H
#define _STRFN_H

//
// Helper Macros
//

//
// Get number of array elements
//
#define ARRAY_SIZE(a)    (sizeof(a)/sizeof(a[0]))

//
// Compute size of string array in characters.  That is, don't count
// the terminal null.
//
#define STRSIZE(str)     (ARRAY_SIZE(str)-1)

//
// Get byte count of array
//
#define ARRAY_BYTES(a)   (sizeof(a) * sizeof(a[0]))

//
// Get byte count of character elements of a string -- again
// by not including the terminating NULL.
//
#define STRBYTES(str)    (ARRAY_BYTES(str) - sizeof(str[0]))

//
// Size in bits
//
#define SIZE_IN_BITS(u)  (sizeof(u) * 8)

#define AllocTString(cch)\
    (LPTSTR)AllocMem((cch) * sizeof(TCHAR))

#define IS_NETBIOS_NAME(lpstr) (*lpstr == _T('\\'))

//
// Return the portion of a computer name without the backslashes
//
#define PURE_COMPUTER_NAME(lpstr) (IS_NETBIOS_NAME(lpstr) ? lpstr + 2 : lpstr)

CString COMDLL AppendToDevicePath(CString szPath, LPCTSTR szName );

//
// Convert CR/LF to LF
//
BOOL 
COMDLL 
PCToUnixText(
    OUT LPWSTR & lpstrDestination,
    IN  const CString strSource
    );

//
// Expand LF to CR/LF (no allocation necessary)
//
BOOL 
COMDLL 
UnixToPCText(
    OUT CString & strDestination,
    IN  LPCWSTR lpstrSource
    );

/*
//
// Straight copy
//
BOOL
COMDLL 
TextToText(
    OUT LPWSTR & lpstrDestination,
    IN  const CString & strSource
    );
*/

LPSTR 
COMDLL 
AllocAnsiString(
    IN LPCTSTR lpString
    );

LPTSTR 
COMDLL 
AllocString(
    IN LPCTSTR lpString,
    IN int nLen = -1        // -1 to autodetermine
    );

/*
#ifdef UNICODE

    //
    // Copy W string to T string
    // 
    #define WTSTRCPY(dst, src, cch) \
        lstrcpy(dst, src)

    //
    // Copy T string to W string
    //
    #define TWSTRCPY(dst, src, cch) \
        lstrcpy(dst, src)

    //
    // Reference a T String as a W String (a nop in Unicode)
    //
    #define TWSTRREF(str)   ((LPWSTR)str)

#else

    //
    // Convert a T String to a temporary W Buffer, and
    // return a pointer to this internal buffer
    //
    LPWSTR ReferenceAsWideString(LPCTSTR str);

    //
    // Copy W string to T string
    // 
    #define WTSTRCPY(dst, src, cch) \
        WideCharToMultiByte(CP_ACP, 0, src, -1, dst, cch, NULL, NULL)

    //
    // Copy T string to W string
    //
    #define TWSTRCPY(dst, src, cch) \
        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, src, -1, dst, cch)

    //
    // Reference a T String as a W String 
    //
    #define TWSTRREF(str)   ReferenceAsWideString(str)

#endif // UNICODE

*/

//
// Determine if the given string is a UNC name
//
BOOL 
COMDLL 
IsUNCName(
    IN const CString & strDirPath
    );

//
// Determine if the path is e.g. an IFS path
//
BOOL 
COMDLL 
IsDevicePath(
    IN const CString & strDirPath
    );

//
// Determine if the path is a "special" path
//
BOOL 
COMDLL 
IsSpecialPath(
    IN const CString & strDirPath,
	IN BOOL bCheckIfValid,
    IN BOOL bDevicePath
    );

BOOL 
COMDLL
GetSpecialPathRealPath(
    IN INT iUsageFlag,
    IN const CString & strDirPath,
    OUT CString & strDestination
    );

BOOL 
COMDLL 
IsRestrictedFilename(
    IN const CString & strDirPath
    );

//
// Determine if the path is a fully qualified path in the context
// of the local machine
//
BOOL 
COMDLL 
IsFullyQualifiedPath(
    IN const CString & strDirPath
    );

//
// Determine if the path exists on a network directory in the context
// of the local machine
//
BOOL 
COMDLL 
IsNetworkPath(
    IN  const CString & strDirPath,
    OUT CString * pstrDrive = NULL,
    OUT CString * pstrUNC = NULL
    );

//
// Determine if the given string is an URL path
//
BOOL 
COMDLL 
IsURLName(
    IN const CString & strDirPath
    );

//
// Determine if the given string describes a relative URL path
//
inline BOOL IsRelURLPath(
    IN LPCTSTR lpPath
    )
{
    ASSERT_READ_PTR(lpPath);
    return *lpPath == _T('/');
}

//
// Determine if the given path describes a wild-carded redirection
// path (starts with *;)
//
inline BOOL IsWildcardedRedirectPath(
    IN LPCTSTR lpPath
    )
{
    ASSERT_READ_PTR(lpPath);
    return lpPath[0] == '*' && lpPath[1] == ';';
}

//
// Determine if the account is local (doesn't have a computer name)
//
inline BOOL IsLocalAccount(
    IN CString & strAccount
    )
{
    return strAccount.Find(_T('\\')) == -1;
}

//
// Convert local path to UNC path
//
LPCTSTR COMDLL MakeUNCPath(
    IN OUT CString & strDir,
    IN LPCTSTR lpszOwner,
    IN LPCTSTR lpszDirectory
    );

//
// Convert GUID to a CString
//
LPCTSTR COMDLL GUIDToCString(
    IN  REFGUID guid,
    OUT CString & str
    );

//
// Convert double-null terminated string to a CStringList
//
DWORD COMDLL ConvertDoubleNullListToStringList(
    IN  LPCTSTR lpstrSrc,
    OUT CStringList & strlDest,
    IN  int cChars = -1
    );

//
// Go from a CStringList to a double null terminated list
//
DWORD COMDLL ConvertStringListToDoubleNullList(
    IN  CStringList & strlSrc,
    OUT DWORD & cchDest,
    OUT LPTSTR & lpstrDest
    );

//
// Convert separated list of strings to CStringList
//
int COMDLL ConvertSepLineToStringList(
    IN  LPCTSTR lpstrIn,
    OUT CStringList & strlOut,
    IN  LPCTSTR lpstrSep
    );

//
// Reverse function of the above
//
LPCTSTR COMDLL ConvertStringListToSepLine(
    IN  CStringList & strlIn,
    OUT CString & strOut,
    IN  LPCTSTR lpstrSep
    );

//
// Advanced atol which recognises hex strings
//
BOOL COMDLL CvtStringToLong(
    IN  LPCTSTR lpNumber,
    OUT DWORD * pdwValue
    );

//
// GMT string to time_t
//
BOOL COMDLL CvtGMTStringToInternal(
    IN  LPCTSTR lpTime,
    OUT time_t * ptValue
    );

//
// time_t to GMT string
//
void COMDLL CvtInternalToGMTString(
    IN  time_t tm,
    OUT CString & str
    );

//
// CString.Find() that's not case-sensitive
//
int COMDLL CStringFindNoCase(
    IN const CString & strSrc,
    IN LPCTSTR lpszSub
    );

//
// Replace the first occurrance of one string
// inside another one.  Return error code
//
DWORD COMDLL ReplaceStringInString(
    OUT IN CString & strBuffer,
    IN  CString & strTarget,
    IN  CString & strReplacement,
    IN  BOOL fCaseSensitive
    );

//
// Replace a path in strTarget with the 
// environment variable lpszEnvVar if that
// strTarget path is a superset of the path
// pointed to by lpszEnvVar
//
DWORD COMDLL DeflateEnvironmentVariablePath(
    IN LPCTSTR lpszEnvVar,
    IN OUT CString & strTarget
    );



class COMDLL CStringListEx : public CStringList
/*++

Class Description:

    Superclass of CStringList with comparison and assignment
    operators.

Public Interface:

    operator ==       Comparison operator
    operator !=       Comparison operator
    operator =        Assignment operator  

--*/
{
//
// ctor
//
public:
    CStringListEx(int nBlockSize = 10) : CStringList(nBlockSize) {};

//
// Operators
//
public:
    BOOL operator == (const CStringList & strl);           
    BOOL operator != (const CStringList & strl) { return !operator ==(strl); }
    CStringListEx & operator =(const CStringList & strl);
};



class COMDLL CINumber
/*++

Class Description:

    Base class for international-friendly number formatting

Public Interface:

NOTES: Consider making this class a template

--*/
{
public:
    static BOOL Initialize(BOOL fUserSetting = TRUE);
    static CString * _pstrBadNumber;
    static BOOL UseSystemDefault();
    static BOOL UseUserDefault();
    static BOOL IsInitialized();
    static LPCTSTR QueryThousandSeparator();
    static LPCTSTR QueryDecimalPoint();
    static LPCTSTR QueryCurrency();
    static double BuildFloat(const LONG lInteger, const LONG lFraction);
    static LPCTSTR ConvertLongToString(const LONG lSrc, CString & str);
    static LPCTSTR ConvertFloatToString(
        IN const double flSrc, 
        IN int nPrecision, 
        OUT CString & str
        );

    static BOOL ConvertStringToLong(LPCTSTR lpsrc, LONG & lValue);
    static BOOL ConvertStringToFloat(LPCTSTR lpsrc, double & flValue);

protected:
    CINumber();
    ~CINumber();

protected:
    friend BOOL InitIntlSettings();
    friend void TerminateIntlSettings();
    static BOOL Allocate();
    static void DeAllocate();
    static BOOL IsAllocated();

protected:
    static CString * _pstr;

private:
    static CString * _pstrThousandSeparator;
    static CString * _pstrDecimalPoint;
    static CString * _pstrCurrency;
    static BOOL _fCurrencyPrefix;
    static BOOL _fInitialized;
    static BOOL _fAllocated;
};



class COMDLL CILong : public CINumber
/*++

Class Description:

    International-friendly LONG number

Public Interface:


--*/
{
public:
    //
    // Constructors
    //
    CILong();
    CILong(LONG lValue);
    CILong(LPCTSTR lpszValue);

public:
    //
    // Assignment Operators
    //
    CILong & operator =(LONG lValue);
    CILong & operator =(LPCTSTR lpszValue);

    //
    // Shorthand Operators
    //
    CILong & operator +=(const LONG lValue);
    CILong & operator +=(const LPCTSTR lpszValue);
    CILong & operator +=(const CILong & value);
    CILong & operator -=(const LONG lValue);
    CILong & operator -=(const LPCTSTR lpszValue);
    CILong & operator -=(const CILong & value);
    CILong & operator *=(const LONG lValue);
    CILong & operator *=(const LPCTSTR lpszValue);
    CILong & operator *=(const CILong & value);
    CILong & operator /=(const LONG lValue);
    CILong & operator /=(const LPCTSTR lpszValue);
    CILong & operator /=(const CILong & value);

    //
    // Comparison operators
    //
    BOOL operator ==(LONG value);
    BOOL operator !=(CILong& value);

    //
    // Conversion operators
    //
    operator const LONG() const;
    operator LPCTSTR() const;

    inline friend CArchive & AFXAPI operator <<(CArchive & ar, CILong & value)
    {
        return (ar << value.m_lValue);
    }

    inline friend CArchive & AFXAPI operator >>(CArchive & ar, CILong & value)
    {
        return (ar >> value.m_lValue);
    }

#if defined(_DEBUG) || DBG

    //
    // CDumpContext stream operator
    //
    inline friend CDumpContext & AFXAPI operator<<(
        CDumpContext & dc, 
        const CILong & value
        )
    {
        return (dc << value.m_lValue);
    }

#endif // _DEBUG

protected:
    LONG m_lValue;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline /* static */ BOOL CINumber::UseSystemDefault()
{
    return Initialize(FALSE);
}

inline /* static */ BOOL CINumber::UseUserDefault()
{
    return Initialize(TRUE);
}

inline /* static */ BOOL CINumber::IsInitialized()
{
    return _fInitialized;
}

inline /* static */ LPCTSTR CINumber::QueryThousandSeparator()
{
    return (LPCTSTR)*_pstrThousandSeparator;
}

inline /* static */ LPCTSTR CINumber::QueryDecimalPoint()
{
    return (LPCTSTR)*_pstrDecimalPoint;
}

inline /* static */ LPCTSTR CINumber::QueryCurrency()
{
    return (LPCTSTR)*_pstrCurrency;
}

inline /* static */ BOOL CINumber::IsAllocated()
{
    return _fAllocated;
}

inline BOOL CILong::operator ==(LONG value)
{
    return m_lValue == value;
}

inline BOOL CILong::operator !=(CILong& value)
{
    return m_lValue != value.m_lValue;
}

inline CILong::operator const LONG() const
{
    return m_lValue;
}

inline CILong::operator LPCTSTR() const
{
    return CINumber::ConvertLongToString(m_lValue, *CINumber::_pstr);
}

#endif // _STRFN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\strfn.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        strfrn.cpp

   Abstract:

        String Functions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager (cluster edition)

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "ipa.h"
#include "iisdebug.h"
#include "util.h"
#include <pudebug.h>


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


#define new DEBUG_NEW


#ifdef _MT

    //
    // Thread protected stuff
    //
    #define RaiseThreadProtection() EnterCriticalSection(&_csSect)
    #define LowerThreadProtection() LeaveCriticalSection(&_csSect)

    static CRITICAL_SECTION _csSect;

#else

    #pragma message("Module is not thread-safe")

    #define RaiseThreadProtection()
    #define LowerThreadProtection()

#endif // _MT

#define MAKE_NULL(obj) { if (obj) delete obj, obj = NULL; }

CString AppendToDevicePath(CString szPath, LPCTSTR szName )
{
    TCHAR szPathCopy[_MAX_PATH] = _T("");
    StrCpyN(szPathCopy, szPath, _MAX_PATH);
	LPTSTR p = szPathCopy;
    ASSERT(szPathCopy);
    ASSERT(szName); 

    // Find end of the string
    while (*p){p = _tcsinc(p);}
	
	// If no trailing backslash then add one
    if (*(_tcsdec(szPathCopy, p)) != _T('\\'))
		{_tcscat(szPathCopy, _T("\\"));}
	
	// if there are spaces precluding szName, then skip
    while ( *szName == _T(' ') ) szName = _tcsinc(szName);;

    // make sure that the szName
    // does not look like this "\filename"
    CString csTempString = szName;
    if (_tcsicmp(csTempString.Left(1), _T("\\")) == 0)
    {
        csTempString = csTempString.Right( csTempString.GetLength() - 1);
    }
    
	// Add new name to existing path string
	StrCatN(szPathCopy, csTempString,_MAX_PATH);

    return szPathCopy;
}

//
// Text copy functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
BOOL
PCToUnixText(
    OUT LPWSTR & lpstrDestination,
    IN  const CString strSource
    )
/*++

Routine Description:

    Convert CR/LF string to LF string (T String to W String).  Destination
    string will be allocated.

Arguments:

    LPWSTR & lpstrDestination : Destination string
    const CString & strSource : Source string

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    int cch = strSource.GetLength() + 1;
    lpstrDestination = (LPWSTR)AllocMem(cch * sizeof(WCHAR));

    if (lpstrDestination != NULL)
    {
        LPCTSTR lpS = strSource;
        LPWSTR lpD = lpstrDestination;

        do
        {
            if (*lpS != _T('\r'))
            {

#ifdef UNICODE
                *lpD++ = *lpS;
#else
                ::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, lpS, 1, lpD++, 1);
#endif // UNICODE

            }
        }
        while (*lpS++);

        return TRUE;
    }

    return FALSE;
}



BOOL
UnixToPCText(
    OUT CString & strDestination,
    IN  LPCWSTR lpstrSource
    )
/*++

Routine Description:

    Expand LF to CR/LF (no allocation necessary) W String to T String.

Arguments:

    CString & strDestination : Destination string
    LPCWSTR lpstrSource      : Source string

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    BOOL fSuccess = FALSE;

    try
    {
        LPCWSTR lpS = lpstrSource;

        //
        // Since we're doubling every linefeed length, assume
        // the worst possible expansion to start with.
        //
        int cch = (::lstrlenW(lpstrSource) + 1) * 2;
        LPTSTR lpD = strDestination.GetBuffer(cch);

        do
        {
            if (*lpS == L'\n')
            {
                *lpD++ = _T('\r');
            }

#ifdef UNICODE
            *lpD++ = *lpS;
#else
            ::WideCharToMultiByte(CP_ACP, 0, lpS, 1, lpD++, 1, NULL, NULL);
#endif // UNICODE

        }
        while (*lpS++);

        strDestination.ReleaseBuffer();

        ++fSuccess;
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("Exception in UnixToPCText");
        e->ReportError();
        e->Delete();
    }

    return fSuccess;
}

/*

BOOL
TextToText(
    OUT LPWSTR & lpstrDestination,
    IN  const CString & strSource
    )
/*++

Routine Description:

    Straight copy with allocation. T String to W String.

Arguments:

    LPWSTR & lpstrDestination : Destination string
    const CString & strSource : Source string

Return Value:

    TRUE for success, FALSE for failure.

--/
{
    int cch = strSource.GetLength() + 1;
    lpstrDestination = (LPWSTR)AllocMem(cch * sizeof(WCHAR));

    if (lpstrDestination != NULL)
    {
        TWSTRCPY(lpstrDestination, strSource, cch);
        return TRUE;
    }

    return FALSE;
}



#ifndef UNICODE



#define WBUFF_SIZE  255



LPWSTR
ReferenceAsWideString(
    IN LPCTSTR str
    )
/*++

Routine Description:

    Reference a T string as a W string (non-unicode only).

Arguments:

    LPCTSTR str : Source string

Return Value:

    Wide char pointer to wide string.

Notes:

    This uses an internal wide char buffer, which will be overwritten
    by subsequent calls to this function.

--/
{
    static WCHAR wchBuff[WBUFF_SIZE + 1];

    ::MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        str,
        -1,
        wchBuff,
        WBUFF_SIZE + 1
        );

    return wchBuff;
}



#endif !UNICODE


*/


LPSTR
AllocAnsiString(
    IN LPCTSTR lpString
    )
/*++

Routine Description:

    Convert the wide string to an ansi (multi-byte) string, which is allocated
    by this function

Arguments:

    LPCTSTR lpString        : Input wide string

Return Value:

    Pointer to the allocated string

--*/
{
    //
    // Character counts are DBCS friendly
    //
    int cChars = lstrlen(lpString);
    int nLength = (cChars * 2) + 1;
    LPSTR lp = (LPSTR)AllocMem(nLength);

    if (lp)
    {
        ::WideCharToMultiByte(
            CP_ACP,
            0,
            lpString,
            cChars + 1,
            lp,
            nLength,
            NULL,
            NULL
            );
    }

    return lp;
}




LPTSTR
AllocString(
    IN LPCTSTR lpString,
    IN int nLen 
    )
/*++

Routine Description:

    Allocate and copy string

Arguments:

    LPCTSTR lpString        : Input string
    int nLen                : Length or -1 to autodetermine

Return Value:

    Pointer to the allocated string

--*/
{
    if (nLen < 0)
    {
        nLen = lstrlen(lpString);
    }
    
    LPTSTR lp = (LPTSTR)AllocMem((nLen + 1) * sizeof(TCHAR));

    if (lp)
    {
        lstrcpy(lp, lpString);
    }

    return lp;
}



BOOL
IsUNCName(
    IN const CString & strDirPath
    )
/*++

Routine Description:

    Determine if the given string path is a UNC path.

Arguments:

    const CString & strDirPath : Directory path string

Return Value:

    TRUE if the path is a UNC path, FALSE otherwise.

Notes:

    Any string of the form \\foo\bar\whatever is considered a UNC path,
    with the exception of \\.\device paths.  No validation for the 
    existance occurs, only for the correct format.

	also with the exeption of \\?\

--*/
{
    if (strDirPath.GetLength() >= 5)  // It must be at least as long as \\x\y,
    {                                 //
        LPCTSTR lp = strDirPath;      //
        if (*lp == _T('\\')           // It must begin with \\,
         && *(lp + 1) == _T('\\')     //
         && *(lp + 2) != _T('.')      // This is a device.
		 && *(lp + 2) != _T('?')      // This is a "?" device.
         && _tcschr(lp + 3, _T('\\')) // And have at least one more \ after that
           )
        {
            //
            // Yes, it's a UNC path
            //
            return TRUE;
        }
    }

    //
    // No, it's not
    //
    return FALSE;
}

BOOL 
GetSpecialPathRealPath(
    IN INT iUsageFlag,
    IN const CString & strDirPath,
    OUT CString & strDestination
    )
{
    BOOL bReturn = FALSE;
    LPCTSTR lpszDeviceStuff = _T("\\\\.\\");
	LPCTSTR lpszSpecialStuff = _T("\\\\?\\");
	LPCTSTR lpszUNCDevice = _T("UNC\\");
    LPCTSTR lpszUseStuff = NULL;

    // Default it with something
    strDestination = strDirPath;

    if (1 == iUsageFlag)
    {
        lpszUseStuff = lpszDeviceStuff;
    }
    else
    {
        lpszUseStuff = lpszSpecialStuff;
    }

	// Check for the "special stuff"
	BOOL bIsValidPath = (0 == _tcsnccmp(strDirPath, lpszUseStuff, lstrlen(lpszUseStuff)));
	// check if we need to verifiy that it is indeeded a valid devicepath
	if (bIsValidPath)
	{
		CString strTempPath;

		// verify that this is indeed a valid special path
		// grab everyting after the part we're interested in...
		//
		// and check if that is a fully qualified path
		// or a fully qualified UNC path.
		//
		// 1) \\?\c:\temp\testind.dll
		// 2) \\?\UNC\MyUnc\testing.dll
		//
		// check for #1
		strTempPath = strDirPath.Right(strDirPath.GetLength() - lstrlen(lpszUseStuff));

		// check if it starts with UNC
		if (0 == _tcsnccmp(strTempPath, lpszUNCDevice, lstrlen(lpszUNCDevice)))
		{
            CString strTempPath2;
            strTempPath2 = strTempPath.Right(strTempPath.GetLength() - lstrlen(lpszUNCDevice));

			DebugTrace(_T("SpecialPath:%s,it's a UNC path!\r\n"),strTempPath2);

            // Append on the extra ("\\\\") when returning the munged path
            strDestination = _T("\\\\") +  strTempPath2;

            bReturn = TRUE;
		}
		else
		{
			// check if the path if fully qualified and
			// if it's valid
            strDestination = strTempPath;
			if (PathIsRelative(strTempPath))
			{
                // don't accept relative paths as valid type paths..
                bReturn = FALSE;
                DebugTrace(_T("SpecialPath:%s,is relative.\r\n"),strTempPath);
            }
            else
            {
                // check if it has these 3 parts "c:\"
                if (IsFullyQualifiedPath(strTempPath))
                {
                    bReturn = TRUE;
                    DebugTrace(_T("SpecialPath:%s a valid path\r\n"),strTempPath);
                }
                else
                {
                    bReturn = FALSE;
                    DebugTrace(_T("SpecialPath:%s,is missing drive part\r\n"),strTempPath);
                }
			}
		}
	}
    return bReturn;
}


BOOL 
IsSpecialPath(
    IN const CString & strDirPath,
	IN BOOL bCheckIfValid,
    IN BOOL bDevicePath
    )
/*++

Routine Description:
    Determine if the given path is of the form:
        1) \\?\c:\temp\testind.dll
        2) \\?\UNC\MyUnc\testing.dll
    
Arguments:
    const CString & strDirPath : Directory path string
	BOOL bCheckIfValid : to say "return true only if it's a "special path" and if it's valid"
    BOOL bDevicePath : check on device path, not special path

Return Value:
    TRUE if the path given is a special path, 
    FALSE if it is not.

	if bCheckIfValid = TRUE then:
    TRUE if the path given is a special path and it's valid
    FALSE if it is not.

--*/
{
	BOOL bIsSpecialPath = FALSE;
    LPCTSTR lpszDeviceStuff = _T("\\\\.\\");
	LPCTSTR lpszSpecialStuff = _T("\\\\?\\");
	LPCTSTR lpszUNCDevice = _T("UNC\\");
    LPCTSTR lpszUseStuff = NULL;

	// Check for the "special stuff"
    if (bDevicePath)
    {
        lpszUseStuff = lpszDeviceStuff;
    }
    else
    {
        lpszUseStuff = lpszSpecialStuff;
    }

    bIsSpecialPath = (0 == _tcsnccmp(strDirPath, lpszUseStuff, lstrlen(lpszUseStuff)));

	// check if we need to verifiy that it is indeeded a valid devicepath
	if (bIsSpecialPath && bCheckIfValid)
	{
		bIsSpecialPath = FALSE;
		CString strTempPath;

		// verify that this is indeed a valid special path
		// grab everyting after the part we're interested in...
		//
		// and check if that is a fully qualified path
		// or a fully qualified UNC path.
		//
		// 1) \\?\c:\temp\testind.dll
		// 2) \\?\UNC\MyUnc\testing.dll
		//
		// check for #1
		strTempPath = strDirPath.Right(strDirPath.GetLength() - lstrlen(lpszUseStuff));
		// check if it starts with UNC
		if (0 == _tcsnccmp(strTempPath, lpszUNCDevice, lstrlen(lpszUNCDevice)))
		{
			bIsSpecialPath = TRUE;
			DebugTrace(_T("SpecialPath:%s,it's a UNC path!\r\n"),strTempPath);
		}
		else
		{
			
			// check if the path if fully qualified and
			// if it's valid
			if (!PathIsRelative(strTempPath))
			{
				bIsSpecialPath = TRUE;
				DebugTrace(_T("SpecialPath:%s,it's NOT a UNC path!\r\n"),strTempPath);
			}
		}
	}
    return bIsSpecialPath;
}


BOOL 
IsDevicePath(
    IN const CString & strDirPath
    )
/*++

Routine Description:

    Determine if the given path is of the form "\\.\foobar"

Arguments:

    const CString & strDirPath : Directory path string

Return Value:

    TRUE if the path given is a device path, 
    FALSE if it is not.

--*/
{
    LPCTSTR lpszDevice = _T("\\\\.\\");
	return (0 == _tcsnccmp(strDirPath, lpszDevice, lstrlen(lpszDevice)));
}

BOOL 
IsRestrictedFilename(
    IN const CString & strDirPath
    )
{
	// The following are the possible file names that can cause problems
	// Restricted Filenames:
	// CON
	// PRN
	// AUX
	// CLOCK$
	// NUL
	// COM1-COM9
	// LPT1-LPT9

    return FALSE;
}

BOOL
IsFullyQualifiedPath(
    IN const CString & strDirPath
    )
/*++

Routine Description:

    Determine if the given string is a fully qualified path name

Arguments:

    const CString & strDirPath : Directory path string

Return Value:

    TRUE if the path is a fully qualified path name


--*/
{
    return strDirPath.GetLength() >= 3
        && strDirPath[1] == _T(':')
        && strDirPath[2] == _T('\\');
}



BOOL
IsNetworkPath(
    IN  const CString & strDirPath,
    OUT CString * pstrDrive,        OPTIONAL
    OUT CString * pstrUNC           OPTIONAL
    )
/*++

Routine Description:

    Determine if the path exists on a network directory
    in the context of the local machine.

Arguments:

    const CString & strDirPath : Directory path string
    CString * pstrDrive        : Returns drive
    CString * pstrUNC          : Returns UNC path

Return Value:

    TRUE if the path is a network path, FALSE if it is local.

Notes:

    Only fully qualified paths with drive letters are checked.

--*/
{
    BOOL fUNC = FALSE;
    CString strDrive;

    try
    {
        if (pstrDrive == NULL)
        {
            pstrDrive = &strDrive;
        }

        ASSERT(strDirPath[1] == _T(':'));

        if (strDirPath[1] == _T(':'))
        {
            *pstrDrive = _T("?:");

            //
            // Fill in actual drive letter
            //
            pstrDrive->SetAt(0, strDirPath[0]);
            UINT nType = GetDriveType(*pstrDrive);

            //
            // DRIVE_NO_ROOT_DIR? this is a little dodgy, but
            // this is the result I get back after browsing
            // using a file open dialog.  Weird.
            //
            fUNC = (nType == DRIVE_NO_ROOT_DIR || nType == DRIVE_REMOTE);
        }

        //
        // Return UNC path if requested
        //
        if (fUNC && pstrUNC != NULL)
        {
            DWORD dwSize = _MAX_PATH;
            LPTSTR lp = pstrUNC->GetBuffer(dwSize);
            ::WNetGetConnection(*pstrDrive, lp, &dwSize);
            pstrUNC->ReleaseBuffer();
        }
    }
    catch(CException * e)
    {
        e->ReportError();
        e->Delete();
    }

    return fUNC;
}



LPCTSTR
MakeUNCPath(
    IN OUT CString & strDir,
    IN LPCTSTR lpszOwner,
    IN LPCTSTR lpszDirectory
    )
/*++

Routine Description:

    Convert the given directory to a UNC path.

Arguments:

    CString & strDir      : UNC String.
    LPCTSTR lpszOwner     : Computer name
    LPCTSTR lpszDirectory : Source string

Return Value:

    Pointer to strDir

Notes:

    The owner may or may not start with "\\".  If it doesn't, the
    backslashes are provided.

--*/
{
    //
    // Try to make make a unc path out of the directory
    //
    ASSERT(lpszDirectory[1] == _T(':'));
    if (lpszDirectory[1] != _T(':'))
    {
        strDir = _T("");
        return (LPCTSTR)strDir;
    }

    // Problem here could be that lpszOwner is not a computername but rather
    // an IP Address!!!!
    LPCTSTR lpszServer = PURE_COMPUTER_NAME(lpszOwner);
    if (LooksLikeIPAddress(lpszServer))
    {
        //
        // Get by ip address
        //
        CString strTemp;
        CIPAddress ia(lpszServer);
        if (NOERROR != MyGetHostName((DWORD)ia, strTemp))
        {
            strTemp = lpszServer;
        }

        strDir.Format(
            _T("\\\\%s\\%c$\\%s"),
            PURE_COMPUTER_NAME((LPCTSTR) strTemp),
            lpszDirectory[0],
            lpszDirectory + 3
            );
    }
    else
    {
        strDir.Format(
            _T("\\\\%s\\%c$\\%s"),
            PURE_COMPUTER_NAME(lpszOwner),
            lpszDirectory[0],
            lpszDirectory + 3
            );
    }

    return (LPCTSTR)strDir;
}



BOOL
IsURLName(
    IN const CString & strDirPath
    )
/*++

Routine Description:

    Determine if the given string path is an URL path.

Arguments:

    const CString & strDirPath : Directory path string

Return Value:

    TRUE if the path is an URL path, FALSE otherwise.

Notes:

    Any string of the form protocol://whatever is considered an URL path

--*/
{
    if (strDirPath.GetLength() >= 4)  // It must be at least as long as x://
    {                                 //
        if (strDirPath.Find(_T("://")) > 0) // Must contain ://
        {
            //
            // Yes, it's an URL path
            //
            return TRUE;
        }
    }

    //
    // No, it's not
    //
    return FALSE;
}



int
CStringFindNoCase(
    IN const CString & strSrc,
    IN LPCTSTR lpszSub
    )
/*++

Routine Description:

    This should be CString::FindNoCase().  Same as CString::Find(),
    but case-insensitive.

Arguments:

    const CString & strSrc  : Source string
    LPCTSTR lpszSub         : String to look for.

Return Value:

    The position of the substring, or -1 if not found.

--*/
{
    LPCTSTR lp1 = strSrc;
    LPCTSTR lp2, lp3;
    int nPos = -1;

    while (*lp1)
    {
        lp2 = lp1;
        lp3 = lpszSub;

        while(*lp2 && *lp3 && _totupper(*lp2) == _totupper(*lp3))
        {
            ++lp2;
            ++lp3;
        }

        if (!*lp3)
        {
            //
            // Found the substring
            //
            nPos = (int)(lp1 - (LPCTSTR)strSrc);
            break;
        }
    
        ++lp1;                    
    }

    return nPos;
}



DWORD
ReplaceStringInString(
    OUT IN CString & strBuffer,
    IN  CString & strTarget,
    IN  CString & strReplacement,
    IN  BOOL fCaseSensitive
    )
/*++

Routine Description:

    Replace the first occurrence of a string with a second string
    inside a third string.

Arguments:

    CString & strBuffer         : Buffer in which to replace
    CString & strTarget         : String to look for
    CString & strReplacement    : String to replace it with
    BOOL fCaseSensitive         : TRUE for case sensitive replacement.
    
Return Value:

    ERROR_SUCCESS for successful replacement.
    ERROR_INVALID_PARAMETER if any string is empty,
    ERROR_FILE_NOT_FOUND if the target string doesn't exist, or
    another win32 error code indicating failure.

--*/
{
    if (strBuffer.IsEmpty() || strTarget.IsEmpty() || strReplacement.IsEmpty())
    {
        return ERROR_INVALID_PARAMETER;
    }

    DWORD err = ERROR_FILE_NOT_FOUND;
    int nPos = fCaseSensitive 
        ? strBuffer.Find(strTarget)
        : CStringFindNoCase(strBuffer, strTarget);

    if (nPos >= 0)
    {
        try
        {
            CString str(strBuffer.Left(nPos));

            str += strReplacement;
            str += strBuffer.Mid(nPos + strTarget.GetLength());
            strBuffer = str;

            err = ERROR_SUCCESS;
        }
        catch(CMemoryException * e)
        {
            e->Delete();
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }    

    return err;
}




DWORD
DeflateEnvironmentVariablePath(
    IN LPCTSTR lpszEnvVar,
    IN OUT CString & strTarget
    )
/*++

Routine Description:

    Take a path, and if the path represents a superset of the
    path in the environment variable given, replace the relevant
    portion of the path with the environment variable.

Arguments:

    LPCTSTR lpszEnvVar      : Environment variable
    CString & strTarget     : Path

Return Value:

    ERROR_SUCCESS if the replacement was done succesfully,
    ERROR_FILE_NOT_FOUND if the path represented by the environment
    variable is not contained within the string, or an other win32
    error for error conditions

--*/
{
    CError err;
    CString strEnv;

    if (!::GetEnvironmentVariable(
        lpszEnvVar,
        strEnv.GetBuffer(_MAX_PATH),
        _MAX_PATH
        ))
    {
        err.SetLastWinError();
    }

    strEnv.ReleaseBuffer();

    if (err.Succeeded())
    {
        try
        {
            CString strReplacement(_T("%"));
            strReplacement += lpszEnvVar;
            strReplacement += _T("%");

            err = ReplaceStringInString(
                strTarget,
                strEnv,
                strReplacement,
                FALSE 
                );
        }
        catch(CMemoryException * e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            e->Delete();
        }
    }

    return err;
}



LPCTSTR
GUIDToCString(
    IN  REFGUID guid,
    OUT CString & str
    )
/*++

Routine Description:

    Convert a GUID to a CString, returning pointer to the string

Arguments:

    REFGUID       : GUID to be converted
    CString & str : Output string buffer

Return Value:

    Pointer to the string

--*/
{
    LPTSTR lpGUID = str.GetBuffer(MAX_PATH);

    if (lpGUID)
    {
        ::StringFromGUID2(guid, lpGUID, MAX_PATH);
        str.ReleaseBuffer();
    }

    return str;
}



int
CountCharsToDoubleNull(
    IN LPCTSTR lp
    )
/*++

Routine Description:

    Count TCHARS up to and including the double NULL.

Arguments:

    LPCTSTR lp       : TCHAR Stream

Return Value:

    Number of chars up to and including the double NULL

--*/
{
    int cChars = 0;

    for(;;)
    {
        ++cChars;

        if (lp[0] == _T('\0') && lp[1] == _T('\0'))
        {
            return ++cChars;
        }

        ++lp;
    }
}



DWORD
ConvertDoubleNullListToStringList(
    IN  LPCTSTR lpstrSrc,
    OUT CStringList & strlDest,
    IN  int cChars                  OPTIONAL
    )
/*++

Routine Description:

    Convert a double null terminate list of null terminated strings to a more
    manageable CStringListEx

Arguments:

    LPCTSTR lpstrSrc       : Source list of strings
    CStringList & strlDest : Destination string list.
    int cChars             : Number of characters in double NULL list. if
                             -1, autodetermine length

Return Value:

    ERROR_SUCCESS           if the list was converted properly
    ERROR_INVALID_PARAMETER if the list was empty
    ERROR_NOT_ENOUGH_MEMORY if there was a mem exception

--*/
{
    DWORD err = ERROR_SUCCESS;

    if (lpstrSrc == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (cChars < 0)
    {
        //
        // Calculate our own size.  This might be off if multiple
        // blank linkes (0) appear in the multi_sz, so the character
        // size is definitely preferable
        //
        cChars = CountCharsToDoubleNull(lpstrSrc);
    }

    try
    {
        strlDest.RemoveAll();

        if (cChars == 2 && *lpstrSrc == _T('\0'))
        {
            //
            // Special case: MULTI_SZ containing only
            // a double NULL are in fact blank entirely.
            //
            // N.B. IMHO this is a metabase bug -- RonaldM
            //
            --cChars;
        }

        //
        // Grab strings until only the final NULL remains
        //
        while (cChars > 1)
        {
            CString strTmp = lpstrSrc;
            strlDest.AddTail(strTmp);
            lpstrSrc += (strTmp.GetLength() + 1);
            cChars -= (strTmp.GetLength() + 1);
        }
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("!!! exception building stringlist");
        err = ERROR_NOT_ENOUGH_MEMORY;
        e->Delete();
    }

    return err;
}



DWORD
ConvertStringListToDoubleNullList(
    IN  CStringList & strlSrc,
    OUT DWORD & cchDest,
    OUT LPTSTR & lpstrDest
    )
/*++

Routine Description:

    Flatten the string list into a double null terminated list
    of null terminated strings.

Arguments:

    CStringList & strlSrc : Source string list
    DWORD & cchDest       : Size in characters of the resultant array
                            (including terminating NULLs)
    LPTSTR & lpstrDest    : Allocated flat array.

Return Value:

    ERROR_SUCCESS           if the list was converted properly
    ERROR_INVALID_PARAMETER if the list was empty
    ERROR_NOT_ENOUGH_MEMORY if there was a mem exception

--*/
{
    cchDest = 0;
    lpstrDest = NULL;
    BOOL fNullPad = FALSE;

    //
    // Compute total size in characters
    //
    POSITION pos;

    for(pos = strlSrc.GetHeadPosition(); pos != NULL; /**/ )
    {
        CString & str = strlSrc.GetNext(pos);

        TRACEEOLID(str);

        cchDest += str.GetLength() + 1;
    }

    if (!cchDest)
    {
        //
        // Special case: A totally empty MULTI_SZ
        // in fact consists of 2 (final) NULLS, instead
        // of 1 (final) NULL.  This is required by the
        // metabase, but should be a bug.  See note
        // at reversal function above.
        //
        ++cchDest;
        fNullPad = TRUE;
    }

    //
    // Remember final NULL
    //
    cchDest += 1;

    lpstrDest = AllocTString(cchDest);

    if (lpstrDest == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LPTSTR pch = lpstrDest;

    for(pos = strlSrc.GetHeadPosition(); pos != NULL; /**/ )
    {
        CString & str = strlSrc.GetNext(pos);

        lstrcpy(pch, (LPCTSTR)str);
        pch += str.GetLength();
        *pch++ = _T('\0');
    }

    *pch++ = _T('\0');

    if (fNullPad)
    {
        *pch++ = _T('\0');
    }

    return ERROR_SUCCESS;
}



int
ConvertSepLineToStringList(
    IN  LPCTSTR lpstrIn,
    OUT CStringList & strlOut,
    IN  LPCTSTR lpstrSep
    )
/*++

Routine Description:

    Convert a line containing multiple strings separated by
    a given character to a CStringListEx

Arguments:

    LPCTSTR lpstrIn         : Input line
    CStringListEx & strlOut : Output stringlist
    LPCTSTR lpstrSep        : List of separators

Return Value:

    The number of items added

--*/
{
    int cItems = 0;
    strlOut.RemoveAll();

    try
    {
        CString strSrc(lpstrIn);
        LPTSTR lp = strSrc.GetBuffer(0);
        lp = _tcstok(lp, lpstrSep);

        while (lp)
        {
            CString str(lp);

            strlOut.AddTail(str);
            lp = _tcstok(NULL, lpstrSep);
            ++cItems;
        }
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("Exception converting CSV list to stringlist");
        e->ReportError();
        e->Delete();
    }

    return cItems;
}




LPCTSTR
ConvertStringListToSepLine(
    IN  CStringList & strlIn,
    OUT CString & strOut,
    IN  LPCTSTR lpstrSep
    )
/*++

Routine Description:

    Convert stringlist into a single CString, each entry separated by the given
    separator string.

Arguments:

    CStringListEx & strlIn  : Input stringlist
    CString & strOut        : Output string
    LPCTSTR lpstrSep        : Separator string

Return Value:

    Pointer to the output string.

--*/
{
    strOut.Empty();
    POSITION pos = strlIn.GetHeadPosition();

    while(pos)
    {
        CString & str = strlIn.GetNext(pos);

        strOut += str;
        strOut += lpstrSep;
    }

    //
    // Fix for bug #286824
    // Remove separator from the last line: it looks ugly in edit control
    //
    if (!strOut.IsEmpty())
    {
        strOut.GetBufferSetLength(strOut.GetLength() - 1);
        strOut.ReleaseBuffer();
    }

    return strOut;
}



BOOL
CStringListEx::operator ==(
    IN const CStringList & strl
    )
/*++

Routine Description:

    Compare against CStringList.  In order for two CStringLists to match,
    they must match in every element, which must be in the same order.

Arguments:

    CStringList strl       : String list to compare against.

Return Value:

    TRUE if the two string lists are identical

--*/
{
    if (strl.GetCount() != GetCount())
    {
        return FALSE;
    }

    POSITION posa = strl.GetHeadPosition();
    POSITION posb = GetHeadPosition();

    while (posa)
    {
        ASSERT(posa);
        ASSERT(posb);

        CString & strA = strl.GetNext(posa);
        CString & strB = GetNext(posb);

        if (strA != strB)
        {
            return FALSE;
        }
    }

    return TRUE;
}



CStringListEx & 
CStringListEx::operator =(
    IN const CStringList & strl
    )
/*++

Routine Description:

    Assignment operator

Arguments:

    const CStringList & strl        : Source stringlist

Return Value:

    Reference to this

--*/
{
    RemoveAll();
    POSITION pos = strl.GetHeadPosition();

    while(pos)
    {
        CString & str = strl.GetNext(pos);
        AddTail(str);
    }

    return *this;
}



BOOL
CvtStringToLong(
    IN  LPCTSTR lpNumber,
    OUT DWORD * pdwValue
    )
/*++

Routine Description:

    Helper function to convert string (hex or decimal) to a dword.

Arguments:

    LPCTSTR lpNumber        : Input number
    DWORD * pdwValue        : Returns the value

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    const TCHAR rgchHex[] = _T("00112233445566778899aAbBcCdDeEfF");

    DWORD dwResult = 0L;
    DWORD dwResultPrev = 0L;

    //
    // Assume a decimal base
    //
    DWORD dwBase = 10L;

    ASSERT_READ_PTR(lpNumber);
    ASSERT_WRITE_PTR(pdwValue);

    while (*lpNumber == _T(' ') || *lpNumber == _T('0'))
    {
        ++lpNumber;
    }

    if (*lpNumber == _T('x') || *lpNumber == _T('X'))
    {
        dwBase = 16L;
        ++lpNumber;
    }

    while (*lpNumber)
    {
        DWORD dwDigit;

        //
        // Search the character in the hexadecimal string
        //
        LPCTSTR pchDigit =  _tcschr(rgchHex, *lpNumber);

        if (!pchDigit)
        {
            //
            // Character is not found
            //
            return FALSE;
        }

        dwDigit = DIFF(pchDigit - rgchHex) >> 1;

        if (dwDigit >= dwBase)
        {
            //
            // Hexadecimal character in a decimal integer
            //
            return FALSE;
        }

        dwResultPrev = dwResult;
        dwResult *= dwBase;
        dwResult += dwDigit;

        if (dwResult < dwResultPrev)
        {
            //
            // Overflow
            //
            return FALSE;
        }

        //
        // Parse the next character
        //
        ++lpNumber;
    }

    *pdwValue = dwResult;

    return TRUE;
}



const LPCTSTR g_cszMonths[] =
{
    _T("Jan"),
    _T("Feb"),
    _T("Mar"),
    _T("Apr"),
    _T("May"),
    _T("Jun"),
    _T("Jul"),
    _T("Aug"),
    _T("Sep"),
    _T("Oct"),
    _T("Nov"),
    _T("Dec"),
};



const LPCTSTR g_cszWeekDays[] =
{
    _T("Sun"),
    _T("Mon"),
    _T("Tue"),
    _T("Wed"),
    _T("Thu"),
    _T("Fri"),
    _T("Sat"),
};



inline BOOL SkipTillDigit(LPCTSTR & lp)
{
    while (lp && *lp && !_istdigit(*lp)) ++lp;

    return lp != NULL;
}



inline BOOL SkipPastDigits(LPCTSTR & lp)
{
    while (lp && *lp && _istdigit(*lp)) ++lp;

    return lp != NULL;
}



BOOL
FetchIntField(
    LPCTSTR & lp,
    int & n
    )
{
    if (SkipTillDigit(lp))
    {
        n = _ttoi(lp);
        if (n < 0)
        {
            ASSERT_MSG("Bogus string->int");
            return FALSE;
        }

        return SkipPastDigits(lp);
    }

    return FALSE;
}



BOOL
MatchString(
    LPCTSTR lpTarget,
    const LPCTSTR * rglp,
    int cElements,
    int & idx
    )
{
    for (idx = 0; idx < cElements; ++idx)
    {
        if (!_tcsnicmp(lpTarget, rglp[idx], _tcslen(rglp[idx])))
        {
            return TRUE;
        }
    }

    return FALSE;
}



static g_dwCurrentTimeZone = TIME_ZONE_ID_INVALID;
static TIME_ZONE_INFORMATION g_tzInfo;




BOOL
CvtGMTStringToInternal(
    IN  LPCTSTR lpTime,
    OUT time_t * ptValue
    )
/*++

Routine Description:

    Convert GMT string to time in the local timezone format

Arguments:

    IN  LPCSTSTR lpTime             : Input time string
    OUT time_t * ptValue            : Output time_t

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    ASSERT_READ_PTR(lpTime);
    ASSERT_WRITE_PTR(ptValue);

    int year, month, day, hour, minutes, seconds;

    do
    {
        if (!lpTime || !ptValue)
        {
            break;
        }

        if (!FetchIntField(lpTime, day))
        {
            break;
        }

        ++lpTime;   // Skip separator

        if (!MatchString(lpTime, g_cszMonths, 12, month))
        {
            break;
        }

        ++month; // 0-based.

        if (!FetchIntField(lpTime, year)    ||
            !FetchIntField(lpTime, hour)    ||
            !FetchIntField(lpTime, minutes) ||
            !FetchIntField(lpTime, seconds))
        {
            break;
        }

        if (year < 100)
        {
            year += ((year < 50) ? 2000 : 1900);
        }

        CTime time(year, month, day, hour, minutes, seconds);
        if (time.GetTime() == (time_t)-1L)
        {
            break;
        }

        *ptValue = time.GetTime();

        TRACEEOLID("GMT Time is " << ctime(ptValue));

        //
        // Adjust for local time zone
        //
        RaiseThreadProtection();

        if (g_dwCurrentTimeZone == TIME_ZONE_ID_INVALID) 
        {
            //
            // GetTimeZoneInfo() is expensive, so cache its output
            //
            g_dwCurrentTimeZone = GetTimeZoneInformation(&g_tzInfo);
        }

        LowerThreadProtection();

        if (g_dwCurrentTimeZone != TIME_ZONE_ID_INVALID)
        {
            _tzset();

            struct tm * tb = localtime(ptValue);

            BOOL fDST = tb->tm_isdst;

            RaiseThreadProtection();
            *ptValue -= (g_tzInfo.Bias * 60L);

            TRACEEOLID("local time (w/o dst adjustment) is " << ctime(ptValue));

            if (fDST)
            {
                *ptValue -= (g_tzInfo.DaylightBias * 60L);
            }
            else
            {
                //
                // Almost always this is zero
                //
                *ptValue -= (g_tzInfo.StandardBias * 60L);
            }
            LowerThreadProtection();

            TRACEEOLID("Local time adjusted for dst is " << ctime(ptValue));
        }

        //
        // Time OK
        //
        return TRUE;
    }
    while(FALSE);

    //
    // Set max abs timeout value.
    //
    CTime time(2037, 12, 31, 0, 0, 0);
    *ptValue = (time_t)time.GetTime();

    return FALSE;
}



void
CvtInternalToGMTString(
    IN  time_t tm,
    OUT CString & str
    )
/*++

Routine Description:

    Reverse of the above function.  Convert internal time_t to a GMT
    time string (converting to GM time in the process)

Arguments:

    time_t tm       : Input time_t
    CString & str   : Out CString

Return Value:

    None

--*/
{
    try
    {
        _tzset();

        struct tm * tb = gmtime(&tm);

        str.Format(
            _T("%-3.3s, %02d %-3.3s %4d %02d:%02d:%02d GMT"),
            g_cszWeekDays[tb->tm_wday],
            tb->tm_mday,
            g_cszMonths[tb->tm_mon],
            tb->tm_year + 1900,
            tb->tm_hour,
            tb->tm_min,
            tb->tm_sec
            );

        TRACEEOLID("Time string is " << str);
    }
    catch(CMemoryException * e)
    {
        e->ReportError();
        e->Delete();
    }
}



//
// International numeric strings
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



//
// Initialize library
//
BOOL
InitIntlSettings()
{
#ifdef _MT
    INITIALIZE_CRITICAL_SECTION(&_csSect);
#endif // _MT

    return CINumber::Allocate();
}



//
// De-initialize library
//
void
TerminateIntlSettings()
{
    CINumber::DeAllocate();

#ifdef _MT
    DeleteCriticalSection(&_csSect);
#endif // _MT
}



//
// Static Member Initialization
//
// NOTE: MFC classes CANNOT be global in an AFX extension, as they
//       will not be initialized properly.  Solution is to allocate them.
//
CString * CINumber::_pstrThousandSeparator = NULL;
CString * CINumber::_pstrDecimalPoint = NULL;
CString * CINumber::_pstrBadNumber = NULL;
CString * CINumber::_pstrCurrency = NULL;
CString * CINumber::_pstr = NULL;
BOOL CINumber::_fAllocated = FALSE;
BOOL CINumber::_fCurrencyPrefix = TRUE;
BOOL CINumber::_fInitialized = FALSE;



CINumber::CINumber()
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    None

--*/
{
    if (!CINumber::_fInitialized)
    {
        CINumber::Initialize();
    }
}



CINumber::~CINumber()
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    None

--*/
{
}



/* static */
BOOL
CINumber::Allocate()
/*++

Routine Description:

    Allocate with US settings

Arguments:

    None

Return Value:

    TRUE if allocation was successfull, FALSE otherwise

--*/
{
    RaiseThreadProtection();

    ASSERT(!IsAllocated());

    if (!IsAllocated())
    {
        try
        {
            //
            // NOTE: Cannot use globals for these, because
            //       they will not be initialized properly
            //       when used in an extension dll.
            //
            CINumber::_pstrThousandSeparator = new CString(_T(","));
            CINumber::_pstrDecimalPoint = new CString(_T("."));
            CINumber::_pstrBadNumber = new CString(_T("--"));
            CINumber::_pstrCurrency = new CString(_T("$ "));
            CINumber::_pstr = new CString;
            _fAllocated = TRUE;
        }
        catch(CMemoryException * e)
        {
            TRACEEOLID("Initialization Failed");
            e->ReportError();
            e->Delete();
        }
    }

    LowerThreadProtection();

    return IsAllocated();
}



/* static */
void
CINumber::DeAllocate()
/*++

Routine Description:

    Clean up allocations

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    RaiseThreadProtection();
    
    ASSERT(IsAllocated());

    if (IsAllocated())
    {
        MAKE_NULL(CINumber::_pstrThousandSeparator);
        MAKE_NULL(CINumber::_pstrDecimalPoint);
        MAKE_NULL(CINumber::_pstrBadNumber);
        MAKE_NULL(CINumber::_pstrCurrency);
        MAKE_NULL(CINumber::_pstr);
    }

    LowerThreadProtection();

    _fAllocated = FALSE;
}



/* static */
BOOL
CINumber::Initialize(
    IN BOOL fUserSetting /* TRUE */
    )
/*++

Routine Description:

    Initialize all the international settings, such as thousand
    separators and decimal points

Parameters:

    BOOL    fUserSetting        If TRUE, use current user settings,
                                if FALSE use system settings.
Return Value:

    TRUE for success, FALSE for failure

Notes:

    Note that this function only needs to be explicitly called
    when the country settings have changed, or when system
    settings are desired (user is default)

--*/
{
#define MAXLEN  6

    int cErrors = 0;

    TRACEEOLID("Getting locale-dependend information");

    ASSERT(IsAllocated());
    if (!IsAllocated())
    {
        Allocate();
    }

    RaiseThreadProtection();

    try
    {
        LCID lcid = fUserSetting
            ? ::GetUserDefaultLCID()
            : GetSystemDefaultLCID();

        LCTYPE lctype = fUserSetting ? 0 : LOCALE_NOUSEROVERRIDE;

        //
        // Get Decimal Point
        //
        if (!::GetLocaleInfo(
            lcid,
            LOCALE_SDECIMAL | lctype,
            CINumber::_pstrDecimalPoint->GetBuffer(MAXLEN),
            MAXLEN
            ))
        {
            TRACEEOLID("Unable to get intl decimal point");
            ++cErrors;
        }

        CINumber::_pstrDecimalPoint->ReleaseBuffer();

        //
        // Get Thousand Separator
        //
        if (!::GetLocaleInfo(
            lcid, LOCALE_STHOUSAND | lctype,
            CINumber::_pstrThousandSeparator->GetBuffer(MAXLEN),
            MAXLEN
            ))
        {
            TRACEEOLID("Unable to get 1000 separator");
            ++cErrors;
        }

        CINumber::_pstrThousandSeparator->ReleaseBuffer();

#ifndef _UNICODE
        //
        // Some countries have a space as a 1000 separator,
        // but for some reason, this is ansi 160, which
        // shows up as a space fine on windows apps,
        // looks like garbage on console apps.
        //
        if ((*CINumber::_pstrThousandSeparator)[0] == CHAR(160))
        {
            CINumber::_pstrThousandSeparator->SetAt(0, ' ');
            TRACEEOLID("Space 1000 separator substituted");
        }
#endif // _UNICODE

        //
        // Get currency symbol
        //
        if (!::GetLocaleInfo(
            lcid,
            LOCALE_SCURRENCY | lctype,
            CINumber::_pstrCurrency->GetBuffer(MAXLEN),
            MAXLEN
            ))
        {
            TRACEEOLID("Unable to get currency symbol");
            ++cErrors;
        }

        CINumber::_pstrCurrency->ReleaseBuffer();
    }

    catch(CMemoryException * e)
    {
        TRACEEOLID("!!!exception in getting intl settings:");
        e->ReportError();
        e->Delete();
        ++cErrors;
    }

    TRACEEOLID("Thousand Separator . . . . . : " << *CINumber::_pstrThousandSeparator);
    TRACEEOLID("Decimal Point  . . . . . . . : " << *CINumber::_pstrDecimalPoint);
    TRACEEOLID("Currency Symbol. . . . . . . : " << *CINumber::_pstrCurrency);
    TRACEEOLID("Bad number . . . . . . . . . : " << *CINumber::_pstrBadNumber);
    TRACEEOLID("Currency Prefix. . . . . . . : " << CINumber::_fCurrencyPrefix);

    CINumber::_fInitialized = TRUE;

    LowerThreadProtection();

    return cErrors == 0;
}



/* static */
double
CINumber::BuildFloat(
    IN const LONG lInteger,
    IN const LONG lFraction
    )
/*++

Return Value:

    Combine integer and fraction to form float

Parameters:

    const LONG lInteger       Integer portion
    const LONG lFraction      Fractional portion

Return Value:

    float value

--*/
{
    double flValue = 0.0;

    //
    // Negative fractions?
    //
    ASSERT(lFraction >= 0);

    if (lFraction >= 0)
    {
        flValue = (double)lFraction;

        while (flValue >= 1.0)
        {
            flValue /= 10.0;
        }

        //
        // Re-add (or subtract if the original number
        // was negative) the fractional part
        //
        if (lInteger > 0L)
        {
            flValue += (double)lInteger;
        }
        else
        {
            flValue -= (double)lInteger;
            flValue = -flValue;
        }
    }

    return flValue;
}



/* static */
LPCTSTR
CINumber::ConvertLongToString(
    IN  const LONG lSrc,
    OUT CString & str
    )
/*++

CINumber::ConvertLongToString

Purpose:

    Convert long number to string with 1000 separators

Parameters:

    const LONG lSrc         Source number
    CString & str           String to write to

Return Value:

    Pointer to converted string

--*/
{
    LPTSTR lpOutString = str.GetBuffer(16);

    //
    // Forget about the negative sign for now.
    //
    LONG lNum = (lSrc >= 0L) ? lSrc : -lSrc;
    int outstrlen = 0;

    do
    {
        lpOutString[outstrlen++] = _T('0') + (TCHAR)(lNum % 10L);
        lNum /= 10L;

        //
        // if more digits left and we're on a 1000 boundary (printed 3 digits,
        // or 3 digits + n*(3 digits + 1 comma), then print a 1000 separator.
        // Note: will only work if the 1000 separator is 1 character.
        //
        ASSERT(CINumber::_pstrThousandSeparator->GetLength() == 1);

        if (lNum != 0L && (outstrlen == 3 || outstrlen == 7 || outstrlen == 11))
        {
            lstrcpy(lpOutString + outstrlen, *CINumber::_pstrThousandSeparator);
            outstrlen += CINumber::_pstrThousandSeparator->GetLength();
        }

    }
    while (lNum > 0L);

    //
    // Add a negative sign if necessary.
    //
    if (lSrc < 0L)
    {
        lpOutString[outstrlen++] = _T('-');
    }

    str.ReleaseBuffer(outstrlen);
    str.MakeReverse();

    return (LPCTSTR)str;
}



/* static */
LPCTSTR
CINumber::ConvertFloatToString(
    IN const double flSrc,
    IN int nPrecision,
    OUT CString & str
    )
/*++

Routine Description:

    Convert floating point number to string represenation

Parameters:

    const double flSrc          Source floating point number
    int nPrecision              Number of decimal points
    CString & str               String to convert to

Return Value:

    Pointer to converted string.

--*/
{
    //
    // Forget about the negative sign for now,
    // and the fractional portion.
    //
    TCHAR szFraction[256];
    LPCTSTR lpFraction = NULL;

    ::_stprintf(szFraction, _T("%.*f"), nPrecision, flSrc);
    lpFraction = ::_tcschr(szFraction, _T('.') );
    ASSERT(lpFraction != NULL);
    ++lpFraction;

    CINumber::ConvertLongToString((LONG)flSrc, str);

    str += *CINumber::_pstrDecimalPoint + lpFraction;

    return (LPCTSTR)str;
}



/* static */
BOOL
CINumber::ConvertStringToLong(
    IN  LPCTSTR lpsrc,
    OUT LONG & lValue
    )
/*++

Routine Description:

    Convert string to long integer.  1000 Separators will be treated
    correctly.

Parameters:

    LPCTSTR lpsrc       Source string
    LONG & lValue       Value to convert to.  Will be 0 in case of error

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    CString strNumber(lpsrc);
    LONG lBase = 1L;
    BOOL fNegative = FALSE;

    lValue = 0L;

    //
    // Empty strings are invalid
    //
    if (strNumber.IsEmpty())
    {
        return FALSE;
    }

    //
    // Check for negative sign (at the end only)
    //
    if (strNumber[0] == _T('-'))
    {
        fNegative = TRUE;
    }

    strNumber.MakeReverse();

    //
    // Strip negative sign
    //
    if (fNegative)
    {
        strNumber.ReleaseBuffer(strNumber.GetLength()-1);
    }

    //
    // Make sure the 1000 separator is only 1 char.  See note below
    //
    ASSERT(CINumber::_pstrThousandSeparator->GetLength() == 1);

    for (int i = 0; i < strNumber.GetLength(); ++i)
    {
        if ((strNumber[i] >= _T('0')) && (strNumber[i] <= _T('9')))
        {
            LONG lDigit = (LONG)(strNumber[i] - _T('0'));
            if (lDigit != 0L)
            {
                LONG lOldValue = lValue;
                LONG lDelta = (lDigit * lBase);
                if (lDelta / lDigit != lBase)
                {
                    TRACEEOLID("Overflow!");
                    lValue = 0x7fffffff;

                    return FALSE;
                }

                lValue += lDelta;

                if (lValue - lDelta != lOldValue)
                {
                    TRACEEOLID("Overflow!");
                    lValue = 0x7fffffff;

                    return FALSE;
                }
            }

            lBase *= 10L;
        }
        //
        // It's not a digit, maybe a thousand separator?
        // CAVEAT: If a thousand separator of more than
        //         one character is used, this won't work.
        //
        else if ((strNumber[i] != (*CINumber::_pstrThousandSeparator)[0])
             || (i != 3) && (i != 7) && (i != 11))
        {
            //
            // This is just invalid, since it is not a thousand
            // separator in the proper location, nor a negative
            // sign.
            //
            TRACEEOLID("Invalid character " << (BYTE)strNumber[i] << " encountered");
            return FALSE;
        }
    }

    if (fNegative)
    {
        lValue = -lValue;
    }

    return TRUE;
}



/* static */
BOOL
CINumber::ConvertStringToFloat(
    IN  LPCTSTR lpsrc,
    OUT double & flValue
    )
/*++

Routine Description:

    Convert fully decorated floating point string to double

Parameters:

    LPCTSTR lpsrc       Source string
    double & flValue    float value generated from string

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    CString strNumber(lpsrc);

    //
    // This only works if the decimal point is a
    // single character
    //
    ASSERT(CINumber::_pstrDecimalPoint->GetLength() == 1);

    //
    // Strip off the > 0 part
    //
    LONG lFraction = 0;

    int nPoint = strNumber.ReverseFind((*CINumber::_pstrDecimalPoint)[0]);

    if (nPoint >= 0)
    {
        //
        // Convert fractional part
        //
        LPCTSTR lpszFraction = (LPCTSTR)strNumber + ++nPoint;
        lFraction = ::_ttol(lpszFraction);
        strNumber.ReleaseBuffer(--nPoint);
    }

    //
    // Convert integer part
    //
    LONG lInteger;

    if (ConvertStringToLong(strNumber, lInteger))
    {
        flValue = CINumber::BuildFloat(lInteger, lFraction);
        return TRUE;
    }

    return FALSE;
}



CILong::CILong()
/*++

Routine Description:

    Constructor without arguments

Parameters:

    None.

Return Value:

    N/A

--*/
    : m_lValue(0L)
{
}



CILong::CILong(
    IN LONG lValue
    )
/*++

Routine Description:

    Constructor taking LONG argument

Parameters:

    LONG lValue     Value to be set

Return Value:

    N/A

--*/
    : m_lValue(lValue)
{
}



CILong::CILong(
    IN LPCTSTR lpszValue
    )
/*++

Routine Description:

    Constructor taking string argument

Parameters:

    LPCTSTR lpszValue       String number

Return Value:

    N/A

--*/
{
    ConvertStringToLong(lpszValue, m_lValue);
}



CILong &
CILong::operator =(
    IN LONG lValue
    )
/*++

Routine Description:

    Assignment operator taking long value

Parameters:

    LONG lValue     Value to be set

Return Value:

    this object

--*/
{
    m_lValue = lValue;

    return *this;
}



CILong &
CILong::operator =(
    IN LPCTSTR lpszValue
    )
/*++

Routine Description:

    Assignment operator taking string value

Parameters:

    LPCTSTR lpszValue       String number

Return Value:

    this object

--*/
{
    ConvertStringToLong(lpszValue, m_lValue);

    return *this;
}



//
// Arithmetic Shorthand operators
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CILong &
CILong::operator +=(
    IN const LONG lValue
    )
{
    m_lValue += lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator +=(
    IN const LPCTSTR lpszValue
    )
{
    LONG lValue;

    ConvertStringToLong(lpszValue, lValue);

    m_lValue += lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator +=(
    IN const CILong& value
    )
{
    m_lValue += value.m_lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator -=(
    IN const LONG lValue
    )
{
    m_lValue -= lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator -=(
    IN const LPCTSTR lpszValue
    )
{
    LONG lValue;

    ConvertStringToLong(lpszValue, lValue);

    m_lValue -= lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator -=(
    IN const CILong & value
    )
{
    m_lValue -= value.m_lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator *=(
    IN const LONG lValue
    )
{
    m_lValue *= lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator *=(
    IN const LPCTSTR lpszValue
    )
{
    LONG lValue;

    ConvertStringToLong(lpszValue, lValue);

    m_lValue *= lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator *=(
    IN const CILong & value
    )               
{
    m_lValue *= value.m_lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator /=(
    IN const LONG lValue
    )
{
    m_lValue /= lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator /=(
    IN const LPCTSTR lpszValue
    )
{
    LONG lValue;

    ConvertStringToLong(lpszValue, lValue);
    if (lValue != 0)
    {
      m_lValue /= lValue;
    }

    return *this;
}



//
// As above
//
CILong &
CILong::operator /=(
    IN const CILong& value
    )
{
    m_lValue /= value.m_lValue;

    return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\strpass.cpp ===
/*++

   Copyright    (c)    1994-2002    Microsoft Corporation

   Module  Name :
        strpass.cpp

   Abstract:
        Message Functions

   Author:
        Aaron Lee (aaronl)

   Project:
        Internet Services Manager

   Revision History:

--*/

#include "stdafx.h"
#include "common.h"
#include "strpass.h"
#include "cryptpass.h"
#include <strsafe.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


#define new DEBUG_NEW

void CStrPassword::ClearPasswordBuffers(void)
{
    if (NULL != m_pszDataEncrypted)
    {
        if (m_cbDataEncrypted > 0)
        {
            SecureZeroMemory(m_pszDataEncrypted,m_cbDataEncrypted);
        }
        LocalFree(m_pszDataEncrypted);m_pszDataEncrypted=NULL;
		m_pszDataEncrypted = NULL;
    }
    m_cbDataEncrypted = 0;
}

// constructor
CStrPassword::CStrPassword()
{
    m_pszDataEncrypted = NULL;
    m_cbDataEncrypted = 0;
}

CStrPassword::~CStrPassword()
{
    ClearPasswordBuffers();
}

// constructor
CStrPassword::CStrPassword(LPTSTR lpch)
{
    m_pszDataEncrypted = NULL;
    m_cbDataEncrypted = 0;

    // Copy the string
    if (NULL != lpch)
    {
        if (FAILED(EncryptMemoryPassword(lpch,&m_pszDataEncrypted,&m_cbDataEncrypted)))
        {
            ASSERT(FALSE);
        }
    }
}

// constructor
CStrPassword::CStrPassword(LPCTSTR lpch)
{
    CStrPassword((LPTSTR) lpch);
}

// constructor
CStrPassword::CStrPassword(CStrPassword& csPassword)
{
    m_pszDataEncrypted = NULL;
    m_cbDataEncrypted = 0;
    LPTSTR lpTempPassword = csPassword.GetClearTextPassword();
    if (FAILED(EncryptMemoryPassword((LPTSTR) lpTempPassword,&m_pszDataEncrypted,&m_cbDataEncrypted)))
    {
        ASSERT(FALSE);
    }
    csPassword.DestroyClearTextPassword(lpTempPassword);
}

BOOL CStrPassword::IsEmpty() const
{
    if (m_pszDataEncrypted && (m_cbDataEncrypted > 0))
    {
        return FALSE;
    }
    return TRUE;
}

void CStrPassword::Empty()
{
    ClearPasswordBuffers();
}

int CStrPassword::GetLength() const
{
    int iRet = 0;
    LPTSTR lpszTempPassword = NULL;

    if (m_pszDataEncrypted && (m_cbDataEncrypted > 0))
    {
	    if (SUCCEEDED(DecryptMemoryPassword((LPTSTR) m_pszDataEncrypted,&lpszTempPassword,m_cbDataEncrypted)))
        {
            iRet = _tcslen(lpszTempPassword);
        }
    }

    if (lpszTempPassword)
    {
        SecureZeroMemory(lpszTempPassword,(_tcslen(lpszTempPassword)+1) * sizeof(TCHAR));
        LocalFree(lpszTempPassword);lpszTempPassword=NULL;
    }
    return iRet;
};

int CStrPassword::GetByteLength() const
{
    int iRet = 0;
    LPTSTR lpszTempPassword = NULL;

    if (m_pszDataEncrypted && (m_cbDataEncrypted > 0))
    {
	    if (SUCCEEDED(DecryptMemoryPassword((LPTSTR) m_pszDataEncrypted,&lpszTempPassword,m_cbDataEncrypted)))
        {
            iRet = (_tcslen(lpszTempPassword) + 1) * sizeof(TCHAR);
        }
    }

    if (lpszTempPassword)
    {
        SecureZeroMemory(lpszTempPassword,(_tcslen(lpszTempPassword)+1) * sizeof(TCHAR));
        LocalFree(lpszTempPassword);lpszTempPassword=NULL;
    }
    return iRet;
};

int CStrPassword::Compare(LPCTSTR lpsz) const
{
    // identical = 0
    // not equal = 1
    int iRet = 1;
    LPTSTR lpszTempPassword = NULL;

    if (lpsz == NULL)
    {
        return this->IsEmpty() ? 0 : 1;
    }
    if (lpsz[0] == NULL)
    {
        return this->IsEmpty() ? 0 : 1;
    }

    // Decrypt what we have
	if (!m_pszDataEncrypted || (m_cbDataEncrypted < 1))
	{
        // means we have nothing in here
        // but they want to compare it to something
        return iRet;
	}

	if (FAILED(DecryptMemoryPassword((LPTSTR) m_pszDataEncrypted,&lpszTempPassword,m_cbDataEncrypted)))
	{
        goto CStrPassword_Compare_Exit;
	}
    else
    {
        iRet = _tcscmp(lpszTempPassword,lpsz);
    }

CStrPassword_Compare_Exit:
    if (lpszTempPassword)
    {
        LocalFree(lpszTempPassword);lpszTempPassword=NULL;
    }
    return iRet;
}

const CStrPassword& CStrPassword::operator=(LPCTSTR lpsz)
{
    ClearPasswordBuffers();
    if (lpsz != NULL)
    {
		// make sure it's pointing to some value
		if (*lpsz != NULL)
		{
			// Copy the string
			if (FAILED(EncryptMemoryPassword((LPTSTR) lpsz,&m_pszDataEncrypted,&m_cbDataEncrypted)))
			{
				ASSERT(FALSE);
			}
		}
    }
    return *this;
}

const CStrPassword& CStrPassword::operator= (CStrPassword& StrPass)
{
   // handle the a = a case.
   if (this == &StrPass)
   {
      return *this;
   }
   ClearPasswordBuffers();
   if (!StrPass.IsEmpty())
   {
	  LPTSTR p = StrPass.GetClearTextPassword();
	  ASSERT(NULL != p);
	  if (FAILED(EncryptMemoryPassword((LPTSTR) p,&m_pszDataEncrypted,&m_cbDataEncrypted)))
	  {
	     ASSERT(FALSE);
	  }
	  StrPass.DestroyClearTextPassword(p);
   }
   return *this;
}

void CStrPassword::CopyTo(CString& stringSrc)
{
    LPTSTR lpTempPassword = GetClearTextPassword();
    stringSrc = lpTempPassword;
    DestroyClearTextPassword(lpTempPassword);
    return;
}

void CStrPassword::CopyTo(CStrPassword& stringSrc)
{
    LPTSTR lpTempPassword = GetClearTextPassword();
    stringSrc = (LPCTSTR) lpTempPassword;
    DestroyClearTextPassword(lpTempPassword);
    return;
}

int CStrPassword::Compare(CString& csString) const
{
    int iRet = 1;
    if (!csString.IsEmpty())
    {
        return Compare((LPCTSTR) csString);
    }
    return iRet;
}

int CStrPassword::Compare(CStrPassword& cstrPassword) const
{
    int iRet = 1;
    if (!cstrPassword.IsEmpty())
    {
        LPTSTR lpTempPassword = cstrPassword.GetClearTextPassword();
        iRet = Compare((LPCTSTR) lpTempPassword);
        cstrPassword.DestroyClearTextPassword(lpTempPassword);
        return iRet;
    }
    return iRet;
}

// user needs to LocalFree return.
// or call DestroyClearTextPassword.
LPTSTR CStrPassword::GetClearTextPassword()
{
    LPTSTR lpszTempPassword = NULL;

    if (m_pszDataEncrypted && (m_cbDataEncrypted > 0))
    {
	    if (FAILED(DecryptMemoryPassword((LPTSTR) m_pszDataEncrypted,&lpszTempPassword,m_cbDataEncrypted)))
	    {
            if (lpszTempPassword)
            {
                LocalFree(lpszTempPassword);lpszTempPassword=NULL;
            }
	    }
        else
        {
            return lpszTempPassword;
        }
    }
    return NULL;
}

void CStrPassword::DestroyClearTextPassword(LPTSTR lpClearTextPassword) const
{
    if (lpClearTextPassword)
    {
        SecureZeroMemory(lpClearTextPassword,(_tcslen(lpClearTextPassword)+1) * sizeof(TCHAR));
        LocalFree(lpClearTextPassword);lpClearTextPassword=NULL;
    }
    return;
}

// assign to a CString
CStrPassword::operator CString()
{
    LPTSTR lpTempPassword = GetClearTextPassword();
    CString csTempCString(lpTempPassword);
    DestroyClearTextPassword(lpTempPassword);
    return csTempCString;
}

bool CStrPassword::operator==(CStrPassword& csCompareToMe)
{
    LPTSTR lpTempPassword1 = NULL;
    LPTSTR lpTempPassword2 = NULL;
    bool result = FALSE;

    // handle the a == a case
    if (this == &csCompareToMe)
    {
        return TRUE;
    }

    if (GetLength() != csCompareToMe.GetLength())
    {
        // can't be the same if lengths differ...
        return FALSE;
    }

    // check the case when both are empty (fix for 593488)
    if (GetLength() == 0 && csCompareToMe.GetLength() == 0)
    {
        return TRUE;
    }
   
    // Two strings are the same if their decoded contents are the same.
    lpTempPassword1 = GetClearTextPassword();
    lpTempPassword2 = csCompareToMe.GetClearTextPassword();

    result = (_tcscmp(lpTempPassword1, lpTempPassword2) == 0);

    if (lpTempPassword1)
        {DestroyClearTextPassword(lpTempPassword1);}
    if (lpTempPassword2)
        {csCompareToMe.DestroyClearTextPassword(lpTempPassword2);}
   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\strpass.h ===
/*++

   Copyright    (c)    1994-2002    Microsoft Corporation

   Module  Name :
        strpass.h

   Abstract:
        Message Functions Definitions

   Author:
        Aaron Lee (aaronl)

   Project:
        Internet Services Manager

   Revision History:

--*/

#ifndef _STRPASS_H_
#define _STRPASS_H_


// ----------------------------------------
// This class was created to allow a class to
// keep passwords in it's member variables.
//
// In the event that the process get's paged out to
// the swapfile, any user will be able to read the 
// swapfile.  if the member variables contained 
// passwords, they wil be there in clear text.
//
// Usage1 -- with LPTSTR:
//   CStrPassword m_strPassword;
//   // assign a password into member variable
//   m_strPassword = _T("MyPassword");
//   // get a password out
//   LPTSTR lpPassword = m_strPassword.GetClearTextPassword();
//   // use it...
//   FunctionToUsePassword(lpPassword);
//   // erase it -- this will erase memory where cleartext password was stored
//   m_strPassword.DestroyClearTextPassword();
//
// Usage2 -- with CString:
//   CStrPassword m_strPassword(_T("MyPassword"));
//   // get a password out into CString
//   CString csPassword;
//   m_strPassword.CopyTo(csPassword);
//   // use it...
//   FunctionToUsePassword(csPassword);
//   // erase it by overwritting
//   csPassword = _T("        ");
//   csPassword.Empty();
//
// DO NOT DO THIS -- this will allocate a cleartext password and it will never be Freed!
//   FunctionToUsePassword( (LPTSTR) m_strPassword.GetClearTextPassword());
// 
// ----------------------------------------
#ifdef _COMEXPORT
    class COMDLL CStrPassword
#elif defined(_DLLEXP)
    class _EXPORT CStrPassword
#else
    class CStrPassword
#endif
{
public:

    // constructor/destructor
	CStrPassword();
	~CStrPassword();

    // copy constructors
    CStrPassword(LPTSTR lpsz);
    CStrPassword(LPCTSTR lpsz);
    CStrPassword(CStrPassword& csPassword);

	// get character count
	int GetLength() const;
    // get byte count
    int GetByteLength() const;
	// TRUE if zero length
	BOOL IsEmpty() const;
	// clear contents to empty
	void Empty();

	// straight character comparison
	int Compare(LPCTSTR lpsz) const;
    int Compare(CString& lpsz) const;
    int Compare(CStrPassword& lpsz) const;

	// copy string content from UNICODE string (converts to TCHAR)
	const CStrPassword& operator=(LPCTSTR lpsz);
    const CStrPassword& operator=(CStrPassword& lpStrPass);

    // copy to...
    void CopyTo(CString& stringSrc);
    void CopyTo(CStrPassword& stringSrc);

    // Get Data out from it (unencrypted)
    // Each call to GetClearTextPassword() should have an equal
    // DestroyClearTextPassword() call to it.
    LPTSTR GetClearTextPassword();
    void DestroyClearTextPassword(LPTSTR lpClearTextPassword) const;

    // not implemented
    operator TCHAR*();

    // returns CString
    operator CString();

    bool operator== (CStrPassword& csCompareToMe);

    bool operator!= (CStrPassword& csCompareToMe)
    {
        return !(operator==(csCompareToMe));
    }
   
private:
    void ClearPasswordBuffers(void);

protected:
    LPTSTR m_pszDataEncrypted;
    DWORD  m_cbDataEncrypted;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\strvalid.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        strfrn.h

   Abstract:

        String Functions

   Author:

        Aaron Lee (aaronl)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _STRVALID_H
#define _STRVALID_H

#define IS_FLAG_SET(dw, flag) ((((dw) & (flag)) != 0) ? TRUE : FALSE)
#define FLAG_IS_NOT_SET(dw, flag) ((((dw) & (flag)) == 0) ? TRUE : FALSE)
#define SET_FLAG(dw, flag)    dw |= (flag)

//  FAILURE values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+-------+---------------------+-------------------------------+
//  |S|0000000|General              |               Code            |
//  +-+-------+---------------------+-------------------------------+
//
//  where
//      S - Severity - indicates success/fail
//          0 - Success, 1 - Fail (COERROR)
//      0 - NOT USED AT ALL
//      General - is the General error code area
//      Code - is the error code
typedef long FILERESULT;
// success or error
#define SEVERITY_SUCCESS    0
#define SEVERITY_ERROR      1
// Construct a code
#define MAKE_FILERESULT(sev,fac,code) \
    ((HRESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )

// Allowed:
// These need to be allow rather than "not allow" flags,
// the reason is that the caller must specifically specify
// what they expect.  Whereas if we changed the function
// to check for more stuff, we won't break code which specially
// says what they want....
#define CHKPATH_ALLOW_RELATIVE_PATH              0x00000001
#define CHKPATH_ALLOW_DEVICE_PATH                0x00000002
#define CHKPATH_ALLOW_UNC_PATH                   0x00000004
#define CHKPATH_ALLOW_UNC_SERVERNAME_ONLY        0x00000008
#define CHKPATH_ALLOW_UNC_SERVERSHARE_ONLY       0x00000010
#define CHKPATH_ALLOW_MAX                        0x0000001F
// Charset:
#define CHKPATH_CHARSET_GENERAL                  0x00000001
#define CHKPATH_CHARSET_GENERAL_NO_COMMA         0x00000002
#define CHKPATH_CHARSET_GENERAL_ALLOW_QUESTION   0x00000004
#define CHKPATH_CHARSET_MAX                      0x00000007

// Returned failures:
// E_INVALIDARG if a bad parameter was sent
#define CHKPATH_FAIL_INVALID_LENGTH              0x00100000
#define CHKPATH_FAIL_INVALID_EMPTY               0x80100101
#define CHKPATH_FAIL_INVALID_TOO_LONG            0x80100102
//
#define CHKPATH_FAIL_INVALID_CHARSET             0x00200000
#define CHKPATH_FAIL_INVALID_CHARSET_GENERAL     0x80200201
#define CHKPATH_FAIL_INVALID_CHARSET_FOR_DIR     0x80200202
#define CHKPATH_FAIL_INVALID_CHARSET_FOR_FILE    0x80200203
#define CHKPATH_FAIL_INVALID_CHARSET_FOR_UNC     0x80200204
//
#define CHKPATH_FAIL_INVALID_PARTS               0x00400000
#define CHKPATH_FAIL_INVALID_BAD_DRIVE_PART      0x80400301
#define CHKPATH_FAIL_INVALID_BAD_DIR_PART        0x80400302
#define CHKPATH_FAIL_INVALID_BAD_FILE_PART       0x80400303
#define CHKPATH_FAIL_INVALID_BAD_UNC_PART        0x80400304
#define CHKPATH_FAIL_INVALID_BAD_PATH            0x80400305
//
#define CHKPATH_FAIL_NOT_ALLOWED                 0x00800000
#define CHKPATH_FAIL_NOT_ALLOWED_FILE_PATH       0x80800401
#define CHKPATH_FAIL_NOT_ALLOWED_DIR_PATH        0x80800402
#define CHKPATH_FAIL_NOT_ALLOWED_RELATIVE_PATH   0x80800403
#define CHKPATH_FAIL_NOT_ALLOWED_DEVICE_PATH     0x80800404
#define CHKPATH_FAIL_NOT_ALLOWED_UNC_PATH        0x80800405
#define CHKPATH_FAIL_NOT_ALLOWED_UNC_SERVERNAME  0x80800406
#define CHKPATH_FAIL_NOT_ALLOWED_UNC_SERVERSHARE 0x80800407
#define CHKPATH_FAIL_NOT_ALLOWED_DIR_NOT_EXIST   0x80800408

// commas are valid dir/filenames
//
#define CHKPATH_INVALID_CHARSET_GENERAL  _T("|<>/*?\t\r\n")
#define CHKPATH_INVALID_CHARSET_COMMA    _T(",")
#define CHKPATH_INVALID_CHARSET_QUESTION _T("?")

#define CHKPATH_WANT_FILE 1
#define CHKPATH_WANT_DIR  2
FILERESULT COMDLL MyValidatePath(LPCTSTR path,BOOL bLocal,INT iPathTypeWanted,DWORD dwAllowedFlags,DWORD dwCharSetFlags);

#endif // _STRVALID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\strvalid.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        strvalid.cpp

   Abstract:

        String Functions

   Author:

        Aaron Lee (aaronl)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "iisdebug.h"
#include <pudebug.h>


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


#define new DEBUG_NEW

//
//  Procedure removes all characters in the second string from the first one.
//
INT RemoveChars(LPTSTR pszStr,LPTSTR pszRemoved)
{
    INT iCharsRemovedCount = 0;
    INT iOrgStringLength = _tcslen(pszStr);
    INT cbRemoved = _tcslen(pszRemoved);
    INT iSrc, iDest;
    
    for (iSrc = iDest = 0; pszStr[iSrc]; iSrc++, iDest++)
    {
        // Check if this char is the in the list of stuf
        // we are supposed to remove.
        // if it is then just set iSrc to iSrc +1
#ifdef UNICODE
        while (wmemchr(pszRemoved, pszStr[iSrc], cbRemoved))
#else
        while (memchr(pszRemoved, pszStr[iSrc], cbRemoved))
#endif
        {
            iCharsRemovedCount++;
            iSrc++;
        }

        // copy the character to itself
        pszStr[iDest] = pszStr[iSrc];
    }

    // Cut off the left over strings
    // which we didn't erase.  but need to.
    if (iCharsRemovedCount >= 0){pszStr[iOrgStringLength - iCharsRemovedCount]= '\0';}

    return iDest - 1;
}

BOOL IsContainInvalidChars(LPCTSTR szUncOrDirOrFilePart,LPCTSTR szListOfInvalidChars)
{
    LPTSTR psz = (LPTSTR) szUncOrDirOrFilePart;

	if (NULL == psz)
		return FALSE;

	if (NULL == szListOfInvalidChars)
		return FALSE;
    
	while (*psz)
	{
        // Check if this characters is in the "bad" set.
        if (_tcschr(szListOfInvalidChars,*psz))
        {
            DebugTrace(_T("Path:Contains bad character '%c'"),*psz);
            return TRUE;
        }
		psz = ::CharNext(psz);
	}

	return FALSE;
}
// This character set is invalid for:
// 1. Anything in a UNC path (includes servername,servershare,path,dir)
// 2. Anything in the dir part of the path (doesn't include drive part -- obviously c: -- includes a colon)
// 3. Anything in the filepart of the path 
BOOL IsContainInvalidChars(LPCTSTR szUncOrDirOrFilePart)
{
    return IsContainInvalidChars(szUncOrDirOrFilePart,_T(":|<>/*?\t\r\n"));
  
}

BOOL IsContainInvalidCharsUNC(LPCTSTR lpFullFileNamePath)
{
    return IsContainInvalidChars(lpFullFileNamePath);
}

BOOL IsContainInvalidCharsAfterDrivePart(LPCTSTR lpFullFileNamePath)
{
    TCHAR szPath_only[_MAX_PATH];
    _tsplitpath(lpFullFileNamePath, NULL, szPath_only, NULL, NULL);
    if (szPath_only)
    {
        return IsContainInvalidChars(szPath_only);
    }
    return FALSE;
}

BOOL IsContainInvalidCharsFilePart(LPCTSTR szFilenameOnly)
{
    return IsContainInvalidChars(szFilenameOnly);
}

BOOL IsDirPartExist(LPCTSTR lpFullFileNamePath)
{
    TCHAR szDrive_only[_MAX_DRIVE];
    TCHAR szPath_only[_MAX_PATH];
	TCHAR szTemp[_MAX_PATH];
    _tsplitpath(lpFullFileNamePath, szDrive_only, szPath_only, NULL, NULL);

	// Get the Dirpart and see if it exists
	_tcscpy(szTemp,szDrive_only);
	_tcscat(szTemp,szPath_only);

	// Check if it's a directory
    if (PathIsDirectory(szTemp))
    {
	    // it's an existing valid directory.
        return TRUE;
    }

    return FALSE;
}

// bForFullFilePath = TRUE, if for something like \\servername\servershare\mydir\myfile.txt
// bForFullFilePath = FALSE, if for something like \\servername\servershare\mydir
BOOL IsValidUNCSpecialCases(LPCTSTR path,BOOL bLocal,BOOL bForFullFilePath)
{
    BOOL bReturn = TRUE;
    CString csPathMunged = path;
    TCHAR * pszRoot = NULL;

    if (!PathIsUNC(csPathMunged))
    {
        bReturn = FALSE;
        goto IsValidUNCSpecialCases_Exit;
    }

    if (PathIsUNCServer(csPathMunged))
    {
        bReturn = TRUE;
        goto IsValidUNCSpecialCases_Exit;
	}

    if (PathIsUNCServerShare(csPathMunged))
    {
        bReturn = TRUE;
        goto IsValidUNCSpecialCases_Exit;
    }
    
    // From this point on.
    // it is likely
    // \\servername\servershare\somepath
    // \\servername\servershare\somepath\somefilename.txt
    
    // looking for an invalid UNC...
	// Test for something lame like \\servername\\dir
	// add enough space for an extra "\" at the beginning.
	pszRoot = (TCHAR *) LocalAlloc(LPTR, ((_tcslen(csPathMunged)+2) * sizeof(TCHAR)));
	if (pszRoot)
	{
		// Add an extra "\" at the beginning.
		_tcscpy(pszRoot,_T("\\"));
		_tcscat(pszRoot,csPathMunged);

		// for some reason a UNC like this: \\\servername\dir
		// will be valid for PathIsUNCServer.
		// but a UNC like this: \\\\servername\dir will be invalid
		// we want to ensure that \\\servername\dir is invalid
		// that's why we added an extra "\"
		if (PathStripToRoot(pszRoot))
		{
			// if we get back just the \\server name
			// then we have an invalid path.
			// we're supposed to get back \\servername\servershare
			if (PathIsUNCServer(pszRoot))
			{
                bReturn = FALSE;
                DebugTrace(_T("Path:Bad UNC path"));
                goto IsValidUNCSpecialCases_Exit;
    		}
		}

        // We have \\servername\Servershare now...
        if (bForFullFilePath)
        {
		    // set it back to the real path without the extra "\"
		    _tcscpy(pszRoot,csPathMunged);

		    if (PathStripToRoot(pszRoot))
		    {
			    // if we get back just the \\server name
			    // then we have an invalid path.
			    // we're supposed to get back \\servername\servershare
			    if (PathIsUNCServer(pszRoot))
			    {
                    bReturn = FALSE;
                    DebugTrace(_T("Path:Bad UNC path"));
                    goto IsValidUNCSpecialCases_Exit;
			    }
			    else
			    {
				    _tcscpy(pszRoot,csPathMunged);

				    // it's a sharename.
				    // let's check if that is valid even...
				    TCHAR * pszAfterRoot = NULL;
				    pszAfterRoot = PathSkipRoot(pszRoot);

				    if (pszAfterRoot)
				    {
					    if (0 == _tcslen(pszAfterRoot))
					    {
                            if (bForFullFilePath)
                            {
                                // don't accept something like "\\servername\fileshare\"
                                bReturn = FALSE;
                                DebugTrace(_T("Path:Bad UNC path:no accept \\\\s\\f\\ (ending slash)"));
                                goto IsValidUNCSpecialCases_Exit;
                            }
					    }
					    else if (0 == _tcsicmp(pszAfterRoot,_T(".")))
					    {
                            // don't accept something like "\\servername\fileshare\."
                            bReturn = FALSE;
                            DebugTrace(_T("Path:Bad UNC path:no accept \\\\s\\f\\."));
                            goto IsValidUNCSpecialCases_Exit;
					    }
                        else
                        {
                            // otherwise it's probably
                            // \\servername\servershare\somedir
                            // \\servername\servershare\somedir\somefilename.txt
                        }
				    }
			    }
		    }
        }
	}

IsValidUNCSpecialCases_Exit:
    if (pszRoot){LocalFree(pszRoot);}
    return bReturn;
}

// return 0 on success
// error code on failure
FILERESULT MyValidatePath(LPCTSTR path,BOOL bLocal,INT iPathTypeWanted,DWORD dwAllowedFlags,DWORD dwCharSetFlags)
{
    FILERESULT dwReturn = SEVERITY_SUCCESS;
    CString csPathMunged = path;
    CComBSTR bstrTempString;

    // verify all parameters are filled in...
    if (iPathTypeWanted != CHKPATH_WANT_FILE && iPathTypeWanted != CHKPATH_WANT_DIR)
    {
        return E_INVALIDARG;
    }
    if (dwAllowedFlags > CHKPATH_ALLOW_MAX)
    {
        return E_INVALIDARG;
    }
    if (dwCharSetFlags < CHKPATH_CHARSET_GENERAL || dwCharSetFlags > CHKPATH_CHARSET_MAX)
    {
        return E_INVALIDARG;
    }

    // ------------
    // length check
    // ------------
    {
        dwReturn = MAKE_FILERESULT(SEVERITY_ERROR,CHKPATH_FAIL_INVALID_LENGTH,CHKPATH_FAIL_INVALID_EMPTY);

        // check if it's empty
        if (path == NULL || *path == 0)
        {
            dwReturn |= CHKPATH_FAIL_INVALID_EMPTY;
            DebugTrace(_T("Path:Empty"));
            goto MyValidatePath_Exit;
        }

        // check if it's empty
	    if (0 == _tcslen(path))
	    {
            dwReturn |= CHKPATH_FAIL_INVALID_EMPTY;
            DebugTrace(_T("Path:Empty"));
            goto MyValidatePath_Exit;
	    }

        // check length
	    if (_tcslen(path) >= 256)
	    {
            dwReturn |= CHKPATH_FAIL_INVALID_TOO_LONG;
            // it's empty, please specify something!
            DebugTrace(_T("Path:too long"));
            goto MyValidatePath_Exit;
	    }

        // length check passes
        dwReturn = SEVERITY_SUCCESS;
    }

    // ------------------------
    // Invalid characters check
    // ------------------------
    {
        dwReturn = MAKE_FILERESULT(SEVERITY_ERROR,CHKPATH_FAIL_INVALID_CHARSET,CHKPATH_FAIL_INVALID_CHARSET_GENERAL);

        // check for invalid characters...
        bstrTempString = _T("\t\r\n");
        if (IS_FLAG_SET(dwCharSetFlags,CHKPATH_CHARSET_GENERAL))
        {
            bstrTempString = CHKPATH_INVALID_CHARSET_GENERAL;
        }
        if (IS_FLAG_SET(dwCharSetFlags,CHKPATH_CHARSET_GENERAL_NO_COMMA))
        {
            // user wants to make sure that comma is an invalid entry
            bstrTempString = bstrTempString + CHKPATH_INVALID_CHARSET_COMMA;
        }
        if (IS_FLAG_SET(dwCharSetFlags,CHKPATH_CHARSET_GENERAL_ALLOW_QUESTION))
        {
            // user wants to allow Question marks...
            RemoveChars((LPTSTR) bstrTempString,CHKPATH_INVALID_CHARSET_QUESTION);
        }
        if (IsContainInvalidChars(path,bstrTempString))
        {
            dwReturn |= CHKPATH_FAIL_INVALID_CHARSET_GENERAL;
            DebugTrace(_T("Path:invalid chars"));
            goto MyValidatePath_Exit;
        }

        // invalid chars check passes
        dwReturn = SEVERITY_SUCCESS;
    }

    // -------------------------------------------------------------
    // Before we do anything we need to see if it's a "special" path
    //
    // Everything after this function must validate against csPathMunged...
    // this is because GetSpecialPathRealPath could have munged it...
    // -------------------------------------------------------------
    csPathMunged = path;
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
    GetSpecialPathRealPath(0,path,csPathMunged);
#endif

    // ------------------------
    // Do we allow device type paths
    // \\.\myfile.txt
    // ------------------------
    if (IsDevicePath(csPathMunged))
	{
        if (IS_FLAG_SET(dwAllowedFlags,CHKPATH_ALLOW_DEVICE_PATH))
        {
            // user allows device path
            // Do we want to verify it further??
            dwReturn = SEVERITY_SUCCESS;
            DebugTrace(_T("Path:accept device path"));
        }
        else
        {
            // user won't allow device path
            // so return failure
            dwReturn = MAKE_FILERESULT(SEVERITY_ERROR,CHKPATH_FAIL_NOT_ALLOWED,CHKPATH_FAIL_NOT_ALLOWED_DEVICE_PATH);
            DebugTrace(_T("Path:no accept device path"));
        }
        goto MyValidatePath_Exit;
    }

    // ------------------------
    // Do we allow device relative paths
    // ..\testing\test.txt
    // ------------------------
	if (PathIsRelative(csPathMunged))
	{
        if (IS_FLAG_SET(dwAllowedFlags,CHKPATH_ALLOW_RELATIVE_PATH))
        {
            // we have a relative path...
            // Check to see if it is valid...
            // BUGBUG:aaronl: do more work here...
            dwReturn = SEVERITY_SUCCESS;
            DebugTrace(_T("Path:accept relative path"));
        }
        else
        {
            dwReturn = MAKE_FILERESULT(SEVERITY_ERROR,CHKPATH_FAIL_NOT_ALLOWED,CHKPATH_FAIL_NOT_ALLOWED_RELATIVE_PATH);
            DebugTrace(_T("Path:no accept relative path"));
        }
        goto MyValidatePath_Exit;
	}

    // -------------------------------------------------------------
    // UNC Validation
    // -------------------------------------------------------------
    if (PathIsUNC(csPathMunged))
    {
        // ------------------------
        // Do we allow UNC type paths at all?
        // \\servername
        // \\servername\servershare
        // \\servername\servershare\dir
        // \\servername\servershare\dir\filename.txt
        // ------------------------
        if (!IS_FLAG_SET(dwAllowedFlags,CHKPATH_ALLOW_UNC_PATH))
        {
            // We are not allowing UNC paths...
            dwReturn = MAKE_FILERESULT(SEVERITY_ERROR,CHKPATH_FAIL_NOT_ALLOWED,CHKPATH_FAIL_NOT_ALLOWED_UNC_PATH);
            DebugTrace(_T("Path:no accept UNC path"));
            goto MyValidatePath_Exit;
        }

        // ------------------------
        // Do we allow servername only?
        // \\servername
        // ------------------------
        if (PathIsUNCServer(csPathMunged))
        {
            if (IS_FLAG_SET(dwAllowedFlags,CHKPATH_ALLOW_UNC_SERVERNAME_ONLY))
            {
                dwReturn = SEVERITY_SUCCESS;
                DebugTrace(_T("Path:accept only servername"));
            }
            else
            {
                dwReturn = MAKE_FILERESULT(SEVERITY_ERROR,CHKPATH_FAIL_NOT_ALLOWED,CHKPATH_FAIL_NOT_ALLOWED_UNC_SERVERNAME);
                DebugTrace(_T("Path:no accept only servername"));
            }
            goto MyValidatePath_Exit;
		}

        // ------------------------
        // Do we allow servershare only?
        // \\servername\servershare
        // ------------------------
	    if (PathIsUNCServerShare(csPathMunged))
	    {
            if (IS_FLAG_SET(dwAllowedFlags,CHKPATH_ALLOW_UNC_SERVERSHARE_ONLY))
            {
                dwReturn = SEVERITY_SUCCESS;
                DebugTrace(_T("Path:accept only servershare"));
            }
            else
            {
                dwReturn = MAKE_FILERESULT(SEVERITY_ERROR,CHKPATH_FAIL_NOT_ALLOWED,CHKPATH_FAIL_NOT_ALLOWED_UNC_SERVERSHARE);
                DebugTrace(_T("Path:no accept only servershare"));
            }
            goto MyValidatePath_Exit;
	    }

        // Check for invalid chars in UNC path
        if (IsContainInvalidCharsUNC(csPathMunged))
        {
            dwReturn = MAKE_FILERESULT(SEVERITY_ERROR,CHKPATH_FAIL_INVALID_CHARSET,CHKPATH_FAIL_INVALID_CHARSET_FOR_UNC);
            DebugTrace(_T("Path:Bad UNC share contains ':'"));
            goto MyValidatePath_Exit;
        }

        // ------------------------
        // Check for special case invalid UNC paths...
        // \\servername\servershare\
        // \\servername\servershare\.
        // ------------------------
        BOOL bWantFilePart = FALSE;
        if (iPathTypeWanted == CHKPATH_WANT_FILE)
        {
            bWantFilePart = TRUE;
        }
        if (!IsValidUNCSpecialCases(csPathMunged,bLocal,bWantFilePart))
        {
            dwReturn = MAKE_FILERESULT(SEVERITY_ERROR,CHKPATH_FAIL_INVALID_PARTS,CHKPATH_FAIL_INVALID_BAD_UNC_PART);
            DebugTrace(_T("Path:Bad UNC share"));
            goto MyValidatePath_Exit;
        }

        // this function is UNC friendly
        if (bLocal)
        {
            if (PathIsDirectory(csPathMunged))
            {
                if (iPathTypeWanted == CHKPATH_WANT_FILE)
                {
                    // it is a valid directory...but we don't want that
                    dwReturn = MAKE_FILERESULT(SEVERITY_ERROR,CHKPATH_FAIL_NOT_ALLOWED,CHKPATH_FAIL_NOT_ALLOWED_DIR_PATH);
                    DebugTrace(_T("Path:PathIsDirectory:DIR specified, should be filename"));
                    goto MyValidatePath_Exit;
                }
            }
            else
            {
                // path is not directory
                // check if that is what they wanted.
                if (iPathTypeWanted == CHKPATH_WANT_DIR)
                {
                    dwReturn = MAKE_FILERESULT(SEVERITY_ERROR,CHKPATH_FAIL_NOT_ALLOWED,CHKPATH_FAIL_NOT_ALLOWED_DIR_NOT_EXIST);
                    DebugTrace(_T("Path:PathIsDirectory:DIR not exist"));
                    // the directory doesn't exist...
                    goto MyValidatePath_Exit;
                }
            }
        }

        // if we are here, then we passed all the above ways that we could figure
        // out if this is an invalid UNC.

        // now we just need to determine if it's what the user wants!
        // is there anyway we can verify that is is a filename
        // and not a dir???
        goto MyValidatePath_Exit;
    }

    // -------------------------------------------------------------
    // Regular filepath Validation
    // -------------------------------------------------------------

    // ensure that we have a valid drive path...
    // "c:myfile.txt" is not valid!

    // we have to have all parts
    // Not -- just directory paths, we need filename part

    // check if it has these 3 parts "c:\"
    if (!IsFullyQualifiedPath(csPathMunged))
    {
        // Missing drive part
        dwReturn = MAKE_FILERESULT(SEVERITY_ERROR,CHKPATH_FAIL_INVALID_PARTS,CHKPATH_FAIL_INVALID_BAD_DRIVE_PART);
        DebugTrace(_T("Path:IsFullyQualifiedPath:Bad Drive path"));
        goto MyValidatePath_Exit;
    }

    // check if dir part contains invalid chars
    if (IsContainInvalidCharsAfterDrivePart(csPathMunged))
    {
        // Bad path portion
        dwReturn = MAKE_FILERESULT(SEVERITY_ERROR,CHKPATH_FAIL_INVALID_CHARSET,CHKPATH_FAIL_INVALID_CHARSET_FOR_DIR);
        DebugTrace(_T("Path:IsContainInvalidCharsAfterDrivePart:Bad Dir path"));
        goto MyValidatePath_Exit;
    }

    // check if specified path, has a filename part
    if (iPathTypeWanted == CHKPATH_WANT_FILE)
    {
        TCHAR szFullPath[_MAX_PATH];
        LPTSTR pFilePart = NULL;
        if (0 == GetFullPathName(csPathMunged, _MAX_PATH, szFullPath, &pFilePart))
        {
            dwReturn = MAKE_FILERESULT(SEVERITY_ERROR,CHKPATH_FAIL_INVALID_PARTS,CHKPATH_FAIL_INVALID_BAD_PATH);
            DebugTrace(_T("Path:GetFullPathName FAILED"));
            goto MyValidatePath_Exit;
        }
        if (NULL == pFilePart)
        {
            // Missing filename
            dwReturn = MAKE_FILERESULT(SEVERITY_ERROR,CHKPATH_FAIL_INVALID_PARTS,CHKPATH_FAIL_INVALID_BAD_FILE_PART);
            DebugTrace(_T("Path:GetFullPathName missing filename"));
            goto MyValidatePath_Exit;
        }
        else
        {
            // Check if the file part contains a ":"
            // since this is invalid for a filename...

            // Check if it contains an invalid character like ':'
            if (IsContainInvalidCharsFilePart(pFilePart))
            {
                // contains a bad character
                dwReturn = MAKE_FILERESULT(SEVERITY_ERROR,CHKPATH_FAIL_INVALID_CHARSET,CHKPATH_FAIL_INVALID_CHARSET_FOR_FILE);
                DebugTrace(_T("Path:filename contains bad char ':'"));
                goto MyValidatePath_Exit;
            }
        }
    }

    // check if it's a directory
    if (bLocal)
    {
        // ------------------------------------------------
        // check for a filename at the end
        // the user wants a path with a filename at the end
        // ------------------------------------------------
        if (iPathTypeWanted == CHKPATH_WANT_FILE)
        {
            // Check if it's a directory
            if (PathIsDirectory(csPathMunged))
            {
                // it is a valid directory...but we don't want that
                dwReturn = MAKE_FILERESULT(SEVERITY_ERROR,CHKPATH_FAIL_NOT_ALLOWED,CHKPATH_FAIL_NOT_ALLOWED_DIR_PATH);
                DebugTrace(_T("Path:PathIsDirectory:DIR specified, should be filename!"));
                goto MyValidatePath_Exit;
            }

            // strip off the filename part and
		    // check if the user specified a valid directory in the dir portion
		    if (IsContainInvalidCharsAfterDrivePart(csPathMunged))
		    {
                dwReturn = MAKE_FILERESULT(SEVERITY_ERROR,CHKPATH_FAIL_INVALID_PARTS,CHKPATH_FAIL_INVALID_BAD_DIR_PART);
                DebugTrace(_T("Path:DirectoryIsInvalid:Bad Dir Part"));
			    goto MyValidatePath_Exit;
		    }

		    if (FALSE == IsDirPartExist(csPathMunged))
		    {
                // it's not a directory that exists...
                dwReturn = MAKE_FILERESULT(SEVERITY_ERROR,CHKPATH_FAIL_NOT_ALLOWED,CHKPATH_FAIL_NOT_ALLOWED_DIR_NOT_EXIST);
                DebugTrace(_T("Path:Dir Part doesnt exist"));
			    goto MyValidatePath_Exit;
		    }

            {
			    // check if the filename part is valid
			    // dont' accept c:\\\a.dll, or c:\\a.dll
			    TCHAR * pszAfterRoot = NULL;
			    pszAfterRoot = PathSkipRoot(csPathMunged);
			    if (pszAfterRoot)
			    {
				    // check if there are any \ in the beginning.
				    if ( pszAfterRoot[0] == '\\' )
				    {
                        dwReturn = MAKE_FILERESULT(SEVERITY_ERROR,CHKPATH_FAIL_INVALID_PARTS,CHKPATH_FAIL_INVALID_BAD_FILE_PART);
					    DebugTrace(_T("Path:bad filename:%s"),pszAfterRoot);
					    goto MyValidatePath_Exit;
				    }
			    }
            }

            /*
		    if (!PathFileExists(csPathMunged))
		    {
                // err, file does not exists
		    }
		    */
        }
        else
        {
            // ------------------------------------------------
            // check for dir
            // the user wants a dir with no filename
            // ------------------------------------------------
            // Check if it's a directory
            if (!PathIsDirectory(csPathMunged))
            {
                // it's not a directory that exists...
                dwReturn = MAKE_FILERESULT(SEVERITY_ERROR,CHKPATH_FAIL_NOT_ALLOWED,CHKPATH_FAIL_NOT_ALLOWED_DIR_NOT_EXIST);
                DebugTrace(_T("Path:DirectoryIsInvalid:Bad Dir Part"));
			    goto MyValidatePath_Exit;
            }
        }
    }

MyValidatePath_Exit:
    DebugTrace(_T("MyValidatePath(%s)=0x%x:"),path,dwReturn);
    if (IS_FLAG_SET(dwReturn,CHKPATH_FAIL_INVALID_LENGTH))
    {
        DebugTrace(_T("CHKPATH_FAIL_INVALID_LENGTH\r\n"));
    }
    if (IS_FLAG_SET(dwReturn,CHKPATH_FAIL_INVALID_CHARSET))
    {
        DebugTrace(_T("CHKPATH_FAIL_INVALID_CHARSET\r\n"));
    }
    if (IS_FLAG_SET(dwReturn,CHKPATH_FAIL_INVALID_PARTS))
    {
        DebugTrace(_T("CHKPATH_FAIL_INVALID_PARTS\r\n"));
    }
    if (IS_FLAG_SET(dwReturn,CHKPATH_FAIL_NOT_ALLOWED))
    {
        DebugTrace(_T("CHKPATH_FAIL_NOT_ALLOWED\r\n"));
    }
    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\util.h ===
BOOL COMDLL DoesUNCShareExist(CString& strServerShare);
BOOL COMDLL LooksLikeIPAddress(IN LPCTSTR lpszServer);
DWORD COMDLL MyGetHostName(DWORD dwIpAddr, CString & strHostName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\util.cpp ===
#include "stdafx.h"
#include "common.h"
#include "util.h"
#include "iisdebug.h"
#include <winsock.h>
#include <lm.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
#define new DEBUG_NEW

BOOL DoesUNCShareExist(CString& strServerShare)
{
    // try to connect to the unc path.
    CString server, share;
    int idx = strServerShare.ReverseFind(_T('\\'));
    server = strServerShare.Left(idx);
    share = strServerShare.Mid(++idx);
    LPBYTE pbuf = NULL;

    NET_API_STATUS rc = NetShareGetInfo((LPTSTR)(LPCTSTR)server, (LPTSTR)(LPCTSTR)share, 0, &pbuf);
    if (NERR_Success == rc)
    {
        NetApiBufferFree(pbuf);
		return TRUE;
    }

    return FALSE;
}

BOOL  // WinSE 25807
LooksLikeIPAddress(
    IN LPCTSTR lpszServer)
{
    BOOL bSomeDigits = FALSE;

    // Skip leading blanks
    while(*lpszServer == ' ')
    {
        lpszServer ++;
    }

    // Check all characters until first blank
    while(*lpszServer && *lpszServer != ' ')
    {
        if(*lpszServer != '.')
        {
            // If it's non-digit and not a dot, it's not IP address
            if (!_istdigit(*lpszServer))
            {
                return FALSE;  // not digit, not dot --> not IP addr
            }
            bSomeDigits = TRUE;
        }
        lpszServer ++;
    }

    // Skip remaining blanks
    while(*lpszServer == ' ')
    {
        lpszServer ++;
    }

    // Looks like IP if we're at NULL & saw some digits
    return (*lpszServer == 0) && bSomeDigits;
}

//Use WinSock to the host name based on the ip address
DWORD
MyGetHostName
(
    DWORD       dwIpAddr,
    CString &   strHostName
)
{
    CString strName;

    //
    //  Call the Winsock API to get host name information.
    //
    strHostName.Empty();

    ULONG ulAddrInNetOrder = ::htonl( (ULONG) dwIpAddr ) ;

    HOSTENT * pHostInfo = ::gethostbyaddr( (CHAR *) & ulAddrInNetOrder,
                                           sizeof ulAddrInNetOrder,
                                           PF_INET ) ;
    if ( pHostInfo == NULL )
    {
        return ::WSAGetLastError();
    }

    // copy the name
    LPTSTR pBuf = strName.GetBuffer(256);
    ZeroMemory(pBuf, 256);

    ::MultiByteToWideChar(CP_ACP, 
                          MB_PRECOMPOSED, 
                          pHostInfo->h_name, 
                          -1, 
                          pBuf, 
                          256);

    strName.ReleaseBuffer();
    strName.MakeUpper();

    int nDot = strName.Find(_T("."));

    if (nDot != -1)
        strHostName = strName.Left(nDot);
    else
        strHostName = strName;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\utcls.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        utcls.h

   Abstract:

        Some utility functions and classes.

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _UTCLS_H_
#define _UTCLS_H_

//
// CDialog parameters
//
#define USE_DEFAULT_CAPTION (0)

//
// Determine if the given server name refers to the local machine
//
BOOL 
COMDLL
IsServerLocal(
    IN LPCTSTR lpszServer       
    );

//
// Get volume information system flags for the given path
//
BOOL 
COMDLL
GetVolumeInformationSystemFlags(
    IN  LPCTSTR lpszPath,
    OUT DWORD * pdwSystemFlags
    );

//
// Build registry key name
//
LPCTSTR COMDLL GenerateRegistryKey(
    OUT CString & strBuffer,    
    IN  LPCTSTR lpszSubKey = NULL
    );



class COMDLL CBlob
/*++

Class Description:

    Binary large object class, which owns its pointer

Public Interface:

    CBlob           : Constructors
    ~CBlob          : Destructor

    SetValue        : Assign the value
    GetSize         : Get the byte size
    GetData         : Get pointer to the byte stream

--*/
{
//
// Constructors/Destructor
//
public:
    //
    // Initialize empty blob
    //
    CBlob();

    //
    // Initialize with binary data
    //
    CBlob(
        IN DWORD dwSize,
        IN PBYTE pbItem,
        IN BOOL fMakeCopy = TRUE
        );

    //
    // Copy constructor
    //
    CBlob(IN const CBlob & blob);

    //
    // Destructor destroys the pointer
    //    
    ~CBlob();

//
// Operators
//
public:
    CBlob & operator =(const CBlob & blob);
    BOOL operator ==(const CBlob & blob) const;
    BOOL operator !=(const CBlob & blob) const { return !operator ==(blob); }

//
// Access
//
public: 
    //
    // Clean up internal data
    //
    void CleanUp();

    //
    // Set the current value of the blob
    //
    void SetValue(
        IN DWORD dwSize,
        IN PBYTE pbItem,
        IN BOOL fMakeCopy = TRUE
        );

    //
    // TRUE if the blob is currently empty
    //
    BOOL IsEmpty() const { return m_dwSize == 0L; }

    //
    // Return the size of the blob in bytes
    //
    DWORD GetSize() const { return m_dwSize; }

    //
    // Get a pointer to the byte stream
    //
    PBYTE GetData();

private:
    DWORD m_dwSize;
    PBYTE m_pbItem;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CBlob::~CBlob()
{
    CleanUp();
}

inline PBYTE CBlob::GetData()
{
    return m_pbItem;
}





#endif // _UTCLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\utcls.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        utcls.cpp

   Abstract:

        Internet Properties base classes

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "idlg.h"

#include "mmc.h"

extern "C"
{
    #include <lm.h>
}

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


#define new DEBUG_NEW


#define SZ_REG_KEY_BASE  _T("Software\\Microsoft\\%s")


BOOL
IsServerLocal(
    IN LPCTSTR lpszServer
    )
/*++

Routine Description:

    Check to see if the given name refers to the local machine

Arguments:

    LPCTSTR lpszServer   : Server name

Return Value:

    TRUE if the given name refers to the local computer, FALSE otherwise

Note:

    Doesn't work if the server is an ip address

--*/
{
    TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwSize = sizeof(szComputerName) / sizeof(TCHAR);

    //
    // CODEWORK(?): we're not checking for all the ip addresses
    //              on the local box or full dns names.
    //
    //              Try GetComputerNameEx when we're building with NT5 
    //              settings.
    //
    return (!_tcsicmp(_T("localhost"), PURE_COMPUTER_NAME(lpszServer))
         || !_tcscmp( _T("127.0.0.1"), PURE_COMPUTER_NAME(lpszServer)))
         || (GetComputerName(szComputerName, &dwSize) 
             && !_tcsicmp(szComputerName, PURE_COMPUTER_NAME(lpszServer)));
}



BOOL
GetVolumeInformationSystemFlags(
    IN  LPCTSTR lpszPath,
    OUT DWORD * pdwSystemFlags
    )
/*++

Routine Description:

    Get the system flags for the path in question

Arguments:

    LPCTSTR lpszPath            : Path
    DWORD * pdwSystemFlags      : Returns system flags

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    ASSERT_WRITE_PTR(pdwSystemFlags);

    TRACEEOLID("Getting system flags for " << lpszPath);

    DWORD dwMaxComponentLength;
    TCHAR szRoot[MAX_PATH + 1];
    TCHAR szFileSystem[MAX_PATH + 1];

    //
    // Generating root path
    //
    if (IsUNCName(lpszPath))
    {
        //
        // Root path of a UNC path is \\foo\bar\
        //
        ASSERT(lstrlen(lpszPath) < MAX_PATH);

        int cSlashes = 0;
        LPCTSTR lpszSrc = lpszPath;
        LPTSTR lpszDst = szRoot;

        while (cSlashes < 4 && *lpszSrc)
        {
            if ((*lpszDst++ = *lpszSrc++) == '\\')
            {
                ++cSlashes;
            }
        }    

        if (!*lpszSrc)
        {
            *lpszDst++ = '\\';
        }

        *lpszDst = '\0';
    }
    else
    {
        ::wsprintf(szRoot, _T("%c:\\"), *lpszPath);
    }

    TRACEEOLID("Root path is " << szRoot);
    
    return ::GetVolumeInformation(
        szRoot,
        NULL,
        0,
        NULL,
        &dwMaxComponentLength,
        pdwSystemFlags,
        szFileSystem,
        STRSIZE(szFileSystem)
        );
}



LPCTSTR
GenerateRegistryKey(
    OUT CString & strBuffer,
    IN  LPCTSTR lpszSubKey OPTIONAL
    )
/*++

Routine Description:

    Generate a registry key name based on the current app, and a
    provided subkey (optional)

Arguments:

    CString & strBuffer : Buffer to create registry key name into.
    LPCTSTR lpszSubKey  : Subkey name or NULL

Return Value:

    Pointer to the registry key value 

--*/
{
    try
    {
        //
        // Use the app name as the primary registry name
        //
        CWinApp * pApp = ::AfxGetApp();

        if (!pApp)
        {
            ASSERT_MSG("No app object -- can't generate registry key name");

            return NULL;
        }

        strBuffer.Format(SZ_REG_KEY_BASE, pApp->m_pszAppName);

        if (lpszSubKey)
        {
            strBuffer += _T("\\");
            strBuffer += lpszSubKey;
        }

        TRACEEOLID("Registry key is " << strBuffer);
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("!!!exception building regkey");
        e->ReportError();
        e->Delete();
        return NULL;
    }

    return strBuffer;
}







//
// CBlob Implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


CBlob::CBlob() 
/*++

Routine Description:

    NULL constructor

Arguments:

    None

Return Value:

    N/A

--*/
    : m_pbItem(NULL), 
      m_dwSize(0L)
{
}



CBlob::CBlob(
    IN DWORD dwSize,
    IN PBYTE pbItem,
    IN BOOL fMakeCopy
    )
/*++

Routine Description:

    Constructor

Arguments:

    DWORD dwSize        : Size of memory block
    PBYTE pbItem        : Pointer to memory block
    BOOL fMakeCopy      : If TRUE, makes a copy of the memory block.
                          If FALSE, takes ownership of the pointer.

Return Value:

    N/A

--*/
    : m_pbItem(NULL),
      m_dwSize(0L)
{
    SetValue(dwSize, pbItem, fMakeCopy);
}



CBlob::CBlob(
    IN const CBlob & blob
    )
/*++

Routine Description:

    Copy constructor

Arguments:

    const CBlob & blob      : Source blob

Return Value:

    N/A

Notes:

    This contructor makes a copy of the memory block in question.

--*/
    : m_pbItem(NULL),
      m_dwSize(0L)
{
    SetValue(blob.GetSize(), blob.m_pbItem, TRUE);
}



void
CBlob::SetValue(
    IN DWORD dwSize,
    IN PBYTE pbItem,
    IN BOOL fMakeCopy OPTIONAL
    )
/*++

Routine Description:

    Assign the value to this binary object.  If fMakeCopy is FALSE,
    the blob will take ownership of the pointer, otherwise a copy
    will be made.

Arguments:

    DWORD dwSize        : Size in bytes
    PBYTE pbItem        : Byte streadm
    BOOL fMakeCopy      : If true, make a copy, else assign pointer

Return Value:

    None

--*/
{
    //ASSERT_READ_PTR2(pbItem, dwSize);

    if (!IsEmpty())
    {
        TRACEEOLID("Assigning value to non-empty blob.  Cleaning up");
        CleanUp();
    }

    if (dwSize > 0L)
    {
        //
        // Make private copy
        //
        m_dwSize = dwSize;

        if (fMakeCopy)
        {
            m_pbItem = (PBYTE)AllocMem(m_dwSize);
            if (NULL != m_pbItem)
            {
               CopyMemory(m_pbItem, pbItem, dwSize);
            }
        }
        else
        {
            m_pbItem = pbItem;
        }
    }
}



void 
CBlob::CleanUp()
/*++

Routine Description:

    Delete data pointer, and reset pointer and size.

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_pbItem)
    {
        FreeMem(m_pbItem);
    }

    m_pbItem = NULL;
    m_dwSize = 0L;
}



CBlob & 
CBlob::operator =(
    IN const CBlob & blob
    )
/*++

Routine Description:

    Assign values from another CBlob. 

Arguments:

    const CBlob & blob      : Source blob

Return Value:

    Reference to this object

--*/
{
    //
    // Make copy of data
    //
    SetValue(blob.GetSize(), blob.m_pbItem, TRUE);

    return *this;
}



BOOL 
CBlob::operator ==(
    IN const CBlob & blob
    ) const
/*++

Routine Description:
    
    Compare two binary large objects.  In order to match, the objects
    must be the same size, and byte identical.

Arguments:

    const CBlob & blob      : Blob to compare against.

Return Value:

    TRUE if the objects match, FALSE otherwise.

--*/
{
    if (GetSize() != blob.GetSize())
    {
        return FALSE;
    }

    return memcmp(m_pbItem, blob.m_pbItem, GetSize()) == 0;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\wizard.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        wizard.cpp

   Abstract:

        Enhanced dialog and IIS Wizard pages, including
        support for Wizard '97

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



//
// Include Files
//
#include "stdafx.h"
#include "common.h"

extern HINSTANCE hDLLInstance;

BOOL
CreateSpecialDialogFont(
    IN CWnd * pDlg,
    IN OUT CFont * pfontSpecial,
    IN LONG lfOffsetWeight,     OPTIONAL
    IN LONG lfOffsetHeight,     OPTIONAL
    IN LONG lfOffsetWidth,      OPTIONAL
    IN BOOL fItalic,            OPTIONAL
    IN BOOL fUnderline          OPTIONAL
    )
/*++

Routine Description:

    From the dialog font, create special effects font.

Arguments:

    CWnd * pDlg         : Pointer to dialog
    CFont * pfontSpecial: Font object to be created.
    LONG lfOffsetWeight : Change in font weight
    LONG lfOffsetHeight : Value to add to height (will autonegate for truetype)
    LONG lfOffsetWidth  : Value to add to width (ignored for truetype)
    BOOL fItalic        : If true, reverses italic
    BOOL fUnderline     : If true, reverses underline

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    ASSERT_READ_PTR(pDlg);
    ASSERT_READ_WRITE_PTR(pfontSpecial);        // Font must be allocated
    ASSERT((HFONT)(*pfontSpecial) == NULL);     // But not yet created

    if (pDlg && pfontSpecial)
    {
        //
        // Use dialog font as basis.
        //
        CFont * pfontDlg = pDlg->GetFont();
        ASSERT_PTR(pfontDlg);

        if (pfontDlg)
        {
            LOGFONT lf;

            if (pfontDlg->GetLogFont(&lf))
            {
                lf.lfWeight += lfOffsetWeight;

                if (lf.lfHeight < 0)
                {
                    //
                    // truetype font, ignore widths
                    //
                    lf.lfHeight -= lfOffsetHeight;
                    ASSERT(lf.lfWidth == 0);
                }
                else
                {
                    //
                    // Non-true type font
                    //
                    lf.lfHeight += lfOffsetHeight;
                    lf.lfWidth += lfOffsetWidth;
                }

                if (fItalic)
                {
                    lf.lfItalic = !lf.lfItalic;
                }

                if (fUnderline)
                {
                    lf.lfUnderline = !lf.lfUnderline;
                }

                return pfontSpecial->CreateFontIndirect(&lf);
            }
        }
    }

    return FALSE;
}



void
ApplyFontToControls(
    IN CWnd * pdlg,
    IN CFont * pfont,
    IN UINT nFirst,
    IN UINT nLast
    )
/*++

Routine Description:

    Helper function to apply a font to a range of controls in a dialog.

Arguments:

    CWnd * pdlg      : Pointer to dialog
    CFont * pfont    : Font to apply
    UINT nFirst      : First control ID
    UINT nLast       : Last control ID (Not all need exist)

Return Value:

    None

Notes:

    The control IDs are expected to exist sequentially.  That is,
    the first id in the range nFirst to nLast that doesn't exist
    will break the loop.

---*/
{
    ASSERT((HFONT)(*pfont) != NULL);
    ASSERT(nFirst <= nLast);

    CWnd * pCtl;
    for (UINT n = nFirst; n <= nLast; ++n)
    {
        pCtl = pdlg->GetDlgItem(n);

        if (!pCtl)
        {
            break;
        }

        pCtl->SetFont(pfont);
    }
}



IMPLEMENT_DYNCREATE(CEmphasizedDialog, CDialog)



//
// Message Map
//
BEGIN_MESSAGE_MAP(CEmphasizedDialog, CDialog)
    ON_WM_DESTROY()
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CEmphasizedDialog::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.

Arguments:

    None

Return:

    TRUE unless a control has received focus.

--*/
{
    BOOL bReturn = CDialog::OnInitDialog();

    if (CreateSpecialDialogFont(this, &m_fontBold))
    {
        //
        // Apply bold font
        //
        ApplyFontToControls(this, &m_fontBold, IDC_ED_BOLD1, IDC_ED_BOLD5);
    }

    return bReturn;
}



void 
CEmphasizedDialog::OnDestroy()
/*++

Routine Description:

    Cleanup internal structures
    
Arguments:

    None

Return Value:

    None

--*/
{
    m_fontBold.DeleteObject();

    CDialog::OnDestroy();
}



IMPLEMENT_DYNCREATE(CIISWizardSheet, CPropertySheet)



//
// Static Initialization
//
const int CIISWizardSheet::s_cnBoldDeltaFont   = +500;
const int CIISWizardSheet::s_cnBoldDeltaHeight = +8;
const int CIISWizardSheet::s_cnBoldDeltaWidth  = +3;



CIISWizardSheet::CIISWizardSheet(
    IN UINT nWelcomeBitmap,
    IN UINT nHeaderBitmap,
    IN COLORREF rgbForeColor,
    IN COLORREF rgbBkColor
    )
/*++

Routine Description:

    Wizard sheet constructor.  Specifying a welcome bitmap
    make the sheet wizard '97 compliant.

Arguments:

    UINT nWelcomeBitmap     : Resource ID of welcome bitmap
    UINT nHeaderBitmap      : Resource ID of header bitmap

Return Value:

    N/A

--*/
    : CPropertySheet()
{
    m_psh.dwFlags &= ~(PSH_HASHELP);
    SetWizardMode();

    m_rgbWindow     = GetSysColor(COLOR_WINDOW);
    m_rgbWindowText = GetSysColor(COLOR_WINDOWTEXT);

    if (nWelcomeBitmap)
    {
        //
        // Load bitmaps, replacing colours.
        //
        COLORMAP crMap[2];
        
        crMap[0].from = rgbBkColor;
        crMap[0].to = m_rgbWindow;
        crMap[1].from = rgbForeColor;
        crMap[1].to = m_rgbWindowText;

        //
        // Half tone the foreground colour
        //
        if (m_rgbWindowText == RGB(0,0,0))
        {
            BYTE bRed, bGreen, bBlue;
            bRed   = GetRValue(m_rgbWindowText);
            bGreen = GetGValue(m_rgbWindowText);
            bBlue  = GetBValue(m_rgbWindowText);
        
            crMap[1].to = RGB( ((255 - bRed) * 2 / 3), ((255 - bGreen) * 2 / 3), ((255 - bBlue) * 2 / 3) );
        }
        else
        {
            crMap[1].to = m_rgbWindowText;
        }

        VERIFY(m_bmpWelcome.LoadBitmap(nWelcomeBitmap));
        m_bmpWelcome.GetBitmap(&m_bmWelcomeInfo);

        VERIFY(m_bmpHeader.LoadMappedBitmap(nHeaderBitmap));
        m_bmpHeader.GetBitmap(&m_bmHeaderInfo);

        m_psh.dwFlags |= PSH_WIZARD_LITE;
    }
}



void 
CIISWizardSheet::EnableButton(
    IN int nID, 
    IN BOOL fEnable         OPTIONAL
    )
/*++

Routine Description:

    Enable/disable sheet button

Arguments:

    int nID         : Button ID (IDCANCEL, etc)
    BOOL fEnable    : TRUE to enable, FALSE to disable

Return Value:

    None

--*/
{
    CWnd * pButton = GetDlgItem(nID);

    if (pButton)
    {
        pButton->EnableWindow(fEnable);
    }
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CIISWizardSheet, CPropertySheet)
    ON_WM_DESTROY()
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CIISWizardSheet::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Resize the sheet to the proper
    size, and set up some basic information

Arguments:

    None

Return:

    TRUE unless a control has received focus.

--*/
{
    if (IsWizard97())
    {
        //
        // Create special fonts.
        //
        // Title font is same size as dialog, but bold
        // Welcome font is much bolder (+500), and 3 sizes larger.
        // Specifying a +1 in width increase is on the unlikely chance
        // that the dialog font is not true-type.
        //                                                            
        VERIFY(CreateSpecialDialogFont(this, &m_fontTitle));
        VERIFY(CreateSpecialDialogFont(
            this, 
            &m_fontWelcome, 
            s_cnBoldDeltaFont, 
            s_cnBoldDeltaHeight, 
            s_cnBoldDeltaWidth
            ));
    }

    //
    // Load default brush (transparent brush);
    //
    VERIFY(m_brBkgnd = (HBRUSH)GetStockObject(HOLLOW_BRUSH));

    //
    // Create the window brush
    //
    VERIFY(m_brWindow.CreateSolidBrush(m_rgbWindow));

    BOOL bResult = CPropertySheet::OnInitDialog();

    if (IsWizard97())
    {
        // 
        // Get temporary DC for dialog - Will be released in dc destructor
        //
        CClientDC dc(this);

        //
        // Create compatible memory DCs using the dialogs DC
        //
        VERIFY(m_dcMemWelcome.CreateCompatibleDC(&dc));
        VERIFY(m_dcMemHeader.CreateCompatibleDC(&dc));

        //
        // Save state to be restored later.
        //
        CBitmap * pbmpOldWelcome, 
                * pbmpOldHeader;

        VERIFY(pbmpOldWelcome   = m_dcMemWelcome.SelectObject(&m_bmpWelcome));
        VERIFY(m_hbmpOldWelcome = (HBITMAP)pbmpOldWelcome->GetSafeHandle());
        VERIFY(pbmpOldHeader    = m_dcMemHeader.SelectObject(&m_bmpHeader));
        VERIFY(m_hbmpOldHeader  = (HBITMAP)pbmpOldHeader->GetSafeHandle());
    }

    return bResult;
}



void 
CIISWizardSheet::OnDestroy()
/*++

Routine Description:

    Cleanup internal structures

Arguments:

    None

Return Value:

    None

--*/
{
    CPropertySheet::OnDestroy();

    if (IsWizard97())
    {
        //
        // Restore memory DCs
        //
        ASSERT(m_hbmpOldWelcome != NULL);
        ASSERT(m_hbmpOldHeader != NULL);
        VERIFY(m_dcMemWelcome.SelectObject(
            CBitmap::FromHandle(m_hbmpOldWelcome)
            ));
        VERIFY(m_dcMemHeader.SelectObject(
            CBitmap::FromHandle(m_hbmpOldHeader)
            ));

        //
        // Clean up the bitmaps
        //
        m_bmpWelcome.DeleteObject();
        m_bmpHeader.DeleteObject();
        m_brWindow.DeleteObject();
       
        //
        // Destructors will take care of the rest.
        //
    }
}




void
CIISWizardSheet::WinHelp(
    IN DWORD dwData,
    IN UINT nCmd
    )
/*++

Routine Description:

    'Help' handler.  Implemented to ensure no response for F1,
    instead of the bogus "Topic not found" error.

Arguments:

    DWORD dwData        : Help data
    UINT nCmd           : Help command

Return Value:

    None

--*/
{
    //
    // Eat the help command
    //
}



IMPLEMENT_DYNCREATE(CIISWizardPage, CPropertyPage)



//
// Margin for header bitmap
//
const int CIISWizardPage::s_cnHeaderOffset = 2;



CIISWizardPage::CIISWizardPage(
    IN UINT nIDTemplate,            OPTIONAL
    IN UINT nIDCaption,             OPTIONAL
    IN BOOL fHeaderPage,            OPTIONAL
    IN UINT nIDHeaderTitle,         OPTIONAL
    IN UINT nIDSubHeaderTitle       OPTIONAL
    )
/*++

Routine Description:

    Header wizard page 

Arguments:

    UINT nIDTemplate        : Resource template
    UINT nIDCaption         : caption ID
    BOOL fHeaderPage        : TRUE for header page, FALSE for welcome page
    UINT nIDHeaderTitle     : Header title
    UINT nIDSubHeaderTitle  : Subheader title.

Return Value:

    N/A

--*/
    : CPropertyPage(nIDTemplate, nIDCaption),
      m_strTitle(),
      m_strSubTitle(),
      m_rcFillArea(0, 0, 0, 0),
      m_ptOrigin(0, 0),
      m_fUseHeader(fHeaderPage)
{
    m_psp.dwFlags &= ~(PSP_HASHELP); // No Help

    if (nIDHeaderTitle)
    {
        ASSERT(IsHeaderPage());
        VERIFY(m_strTitle.LoadString(nIDHeaderTitle));
    }

    if (nIDSubHeaderTitle)
    {
        ASSERT(IsHeaderPage());
        VERIFY(m_strSubTitle.LoadString(nIDSubHeaderTitle));
    }

    m_psp.dwFlags |= PSP_HIDEHEADER; // Wizard97
}



BOOL
CIISWizardPage::ValidateString(
    IN  CEdit & edit,
    OUT CString & str,
    IN  int nMin,
    IN  int nMax
    )
/*++

Routine Description:

    Since normal 'DoDataExchange' validation happens on every entrance
    and exit of a property page, it's not well suited to wizards.  This
    function is to be called on 'next' only to do validation.

Arguments:

    CEdit & edit        : Edit box where the string is to be gotten from
    CString & str       : String to be validated
    int nMin            : Minimum length
    int nMax            : Maximum length

Return Value:

    TRUE if the string is within the limits, FALSE otherwise.

--*/
{
    ASSERT(nMin <= nMax);

    UINT nID;
    TCHAR szT[33];

    edit.GetWindowText(str);

    if (str.GetLength() < nMin)
    {
        nID = IDS_DDX_MINIMUM;
        ::wsprintf(szT, _T("%d"), nMin);
    }
    else if (str.GetLength() > nMax)
    {
        nID = AFX_IDP_PARSE_STRING_SIZE;
        ::wsprintf(szT, _T("%d"), nMax);
    }
    else
    {
        //
        // Passes both our tests, it's ok.
        //
        return TRUE;
    }

    //
    // Highlight and puke
    //
    edit.SetSel(0,-1);
    edit.SetFocus();

    CString prompt;
    ::AfxFormatString1(prompt, nID, szT);
    ::AfxMessageBox(prompt, MB_ICONEXCLAMATION, nID);

    return FALSE;
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CIISWizardPage, CPropertyPage)
    ON_WM_CTLCOLOR()
    ON_WM_ERASEBKGND()
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
BOOL IsControlAboveDivider(HWND TheWholeTing,CWnd * pWnd,CWnd * pDiv)
{
    CRect rcClient;
    CRect rcClientDiv;
    if (pDiv != NULL && pWnd != NULL)
    {
        pWnd->GetClientRect(&rcClient);
        pDiv->GetClientRect(&rcClientDiv);

        GetDlgCtlRect(TheWholeTing, pWnd->m_hWnd, &rcClient);
        GetDlgCtlRect(TheWholeTing, pDiv->m_hWnd, &rcClientDiv);

        if (rcClientDiv.top > rcClient.top)
        {
            return TRUE;
        }
    }
    return FALSE;
}


HBRUSH 
CIISWizardPage::OnCtlColor(
    IN CDC * pDC, 
    IN CWnd * pWnd, 
    IN UINT nCtlColor
    )
/*++

Routine Description:

    Handle control colour.  Ensure a true transparent
    background colouring.

Arguments:

    CDC * pDC       : Device context
    CWnd * pWnd     : Pointer to window
    UINT nCtlColor  : Ctrl type ID

Return Value:

    Handle to brush to be used for background painting

--*/
{
    BOOL bSetBackGroundColor = FALSE;

    if (IsWizard97())
    {
        {
            switch (nCtlColor)    
            {        
                case CTLCOLOR_STATIC:
                    // option/check boxes are CTLCOLOR_STATIC's as well as simple static texts...
                    // problem is that option/check boxes look ugly (can't even see them)
                    // if we set the background color, so make sure that
                    // we don't do this on the option/check boxes...
                    if (IsHeaderPage())
                    {
                        if (TRUE == IsControlAboveDivider(m_hWnd,pWnd,GetDlgItem(IDC_STATIC_WZ_HEADER_DIVIDER)))
                        {
                            bSetBackGroundColor = TRUE;
                        }
                    }
                    else
                    {
                        bSetBackGroundColor = TRUE;
                    }
                    break;
                case CTLCOLOR_BTN:
                //case CTLCOLOR_EDIT:
                //case CTLCOLOR_LISTBOX:
                //case CTLCOLOR_SCROLLBAR:
                case CTLCOLOR_DLG:
                    bSetBackGroundColor = TRUE;
                    break;
            }
        }
    }

    if (bSetBackGroundColor)
    {
        //
        // Have text and controls be painted smoothly over bitmap
        // without using default background colour
        //
        pDC->SetBkMode(TRANSPARENT);
        pDC->SetTextColor(QueryWindowTextColor());

        return GetBackgroundBrush();
    }
    //
    // Default processing...
    //
    return CPropertyPage::OnCtlColor(pDC, pWnd, nCtlColor);
}



BOOL 
CIISWizardPage::OnEraseBkgnd(
    IN CDC * pDC
    )
/*++

Routine Description:

    Handle erasing the background colour of the dialog

Arguments:

    CDC * pDC       : Device context

Return Value:

    TRUE if no further works needs to be done.
    FALSE otherwise.

--*/
{
    if (IsWizard97())
    {
        //
        // Cache height/width of the fill area, and compute
        // the origin of the destination bitmap.
        //
        if (m_rcFillArea.Width() == 0)
        {
            //
            // Not yet cached, compute values
            //
            CRect rcClient;

            GetClientRect(&rcClient);

            if (IsHeaderPage())
            {
                //
                // Fill the upper rectangle above
                // the divider
                //
                CWnd * pDiv = GetDlgItem(IDC_STATIC_WZ_HEADER_DIVIDER);
                ASSERT_PTR(pDiv);

                if (pDiv != NULL)
                {
                    m_rcFillArea = rcClient;                    
                    GetDlgCtlRect(m_hWnd, pDiv->m_hWnd, &rcClient);
                    m_rcFillArea.bottom = rcClient.top;
        
                    //
                    // Figure out a place for the bitmap
                    // to go.  If any coordinate is negative,
                    // the bitmap will not be displayed
                    //                    
                    TRACEEOLID(
                        "Fill area  : " << m_rcFillArea.Height() 
                        << "x"          << m_rcFillArea.Width()
                        );
                    TRACEEOLID(
                        "Bitmap size: " << QueryBitmapHeight()
                        << "x"          << QueryBitmapWidth()
                        );

                    ASSERT(m_rcFillArea.Width()  >= QueryBitmapWidth());
                    ASSERT(m_rcFillArea.Height() >= QueryBitmapHeight()); 

                    //
                    // Find a place for the header box properly offset from the
                    // margins
                    //
                    m_ptOrigin.y = 
                        (m_rcFillArea.Height() - QueryBitmapHeight() + 1) / 2;
                    m_ptOrigin.x = m_rcFillArea.Width() 
                        - QueryBitmapWidth() 
                        + 1
                        - (__max(s_cnHeaderOffset, m_ptOrigin.y));
                }   
            }      
            else
            {
                //
                // Fill the entire client are
                //
                m_rcFillArea = rcClient;
            }
        }
        
        //
        // Fill background colour with window colour
        //
        pDC->FillRect(&m_rcFillArea, GetWindowBrush());

        //
        // Draw the background picture if there's room.
        //
        if (m_ptOrigin.x >= 0 && m_ptOrigin.y >= 0)
        {
            pDC->BitBlt( 
                m_ptOrigin.x,
                m_ptOrigin.y,
                QueryBitmapWidth() - 1, 
                QueryBitmapHeight() - 1,
                GetBitmapMemDC(), 
                0, 
                0, 
                SRCCOPY 
                );
        }

        /*

        //
        // Scale bitmap appropriately -- looks grainy
        //
        int nHeight = rc.Height();

        double dDelta = (double)nHeight / (double)(QueryBitmapHeight() - 1);

        int nWidth = (int)((double)(QueryBitmapWidth() - 1) * dDelta);

        pDC->StretchBlt( 
            0,
            0,
            nWidth,
            nHeight,    
            GetBitmapMemDC(), 
            0, 
            0, 
            QueryBitmapWidth() - 1, 
            QueryBitmapHeight() - 1,
            SRCCOPY 
            );

         */

        //
        // No more background painting needed
        //
        return TRUE;    
    }

    //
    // No background images of any kind
    //
    return CPropertyPage::OnEraseBkgnd(pDC);
}



BOOL
CIISWizardPage::OnInitDialog()
/*++

Routine Description:

    Handle WM_INITIDIALOG.  Load the appropriate 
    bitmaps, and create the brushes and fonts as needed.

Arguments:

    None

Return Value:

    TRUE unless a control has received initial focus

--*/
{
    CPropertyPage::OnInitDialog();

    //
    // Fake the WIZARD97 look
    //
    if (IsWizard97())
    {
        if (IsHeaderPage())
        {
            CWnd * pCtlTitle = GetDlgItem(IDC_STATIC_WZ_TITLE);
            CWnd * pCtlSubTitle = GetDlgItem(IDC_STATIC_WZ_SUBTITLE);
            ASSERT_PTR(pCtlTitle);
            ASSERT_PTR(pCtlSubTitle);

            if (pCtlTitle)
            {
                pCtlTitle->SetFont(GetSpecialFont());

                if (!m_strTitle.IsEmpty())
                {
                    pCtlTitle->SetWindowText(m_strTitle);
                }
            }

            if (pCtlSubTitle && !m_strSubTitle.IsEmpty())
            {
                pCtlSubTitle->SetWindowText(m_strSubTitle);
            }
        }
        else
        {
            CWnd * pCtl = GetDlgItem(IDC_STATIC_WZ_WELCOME);
            ASSERT_PTR(pCtl);

            if (pCtl)
            {
                pCtl->SetFont(GetSpecialFont());
            }
        }

        //
        // Apply fonts
        //
        ApplyFontToControls(this, GetBoldFont(), IDC_ED_BOLD1, IDC_ED_BOLD5);
    }

    return TRUE;  
}


                            
//
// CIISWizardBookEnd page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CIISWizardBookEnd, CIISWizardPage)



CIISWizardBookEnd::CIISWizardBookEnd(
    IN HRESULT * phResult,
    IN UINT nIDWelcomeTxtSuccess,
    IN UINT nIDWelcomeTxtFailure,
    IN UINT nIDCaption,             OPTIONAL
    IN UINT nIDBodyTxtSuccess,      OPTIONAL
    IN UINT nIDBodyTxtFailure,      OPTIONAL
    IN UINT nIDClickTxt,            OPTIONAL
    IN UINT nIDTemplate             OPTIONAL
    )
/*++

Routine Description:

    Constructor for success/failure page

Arguments:

    HRESULT * phResult          : Address of result code
    UINT nIDWelcomeTxtSuccess   : Success message
    UINT nIDWelcomeTxtFailure   : Failure message
    UINT nIDCaption             : Template caption
    UINT nIDBodyTxtSuccess      : Body text for success
    UINT nIDBodyTxtFailure      : Body text for success
    UINT nIDClickTxt            : Click message
    UINT nIDTemplate            : Dialog template
    

Return Value:

    N/A

--*/
    : CIISWizardPage(
        nIDTemplate ? nIDTemplate : CIISWizardBookEnd::IDD,
        nIDCaption
        ),
      m_phResult(phResult),
      m_strWelcomeSuccess(),
      m_strWelcomeFailure(),
      m_strBodySuccess(),
      m_strBodyFailure(),
      m_strClick()
{
    ASSERT_PTR(m_phResult); // Must know success/failure

    VERIFY(m_strWelcomeSuccess.LoadString(nIDWelcomeTxtSuccess));
    VERIFY(m_strWelcomeFailure.LoadString(nIDWelcomeTxtFailure));
    VERIFY(m_strClick.LoadString(nIDClickTxt ? nIDClickTxt : IDS_WIZ_FINISH));

    if (nIDBodyTxtSuccess)
    {
        VERIFY(m_strBodySuccess.LoadString(nIDBodyTxtSuccess));
    }

    if (nIDBodyTxtFailure)
    {
        VERIFY(m_strBodyFailure.LoadString(nIDBodyTxtFailure));
    }
    else
    {
        //
        // Error text only by default
        //
        m_strBodyFailure = _T("%h");
    }
}



CIISWizardBookEnd::CIISWizardBookEnd(
    IN UINT nIDWelcomeTxt,        
    IN UINT nIDCaption,         OPTIONAL
    IN UINT nIDBodyTxt,
    IN UINT nIDClickTxt,        OPTIONAL
    IN UINT nIDTemplate
    )
/*++

Routine Description:

    Constructor for welcome page

Arguments:

    UINT nIDWelcomeTxt          : Welcome message
    UINT nIDCaption             : Template
    UINT nIDBodyTxt             : Body text
    UINT nIDClickTxt            : Click message
    UINT nIDTemplate            : Dialog template

Return Value:

    N/A

--*/
    : CIISWizardPage(
        nIDTemplate ? nIDTemplate : CIISWizardBookEnd::IDD,
        nIDCaption
        ),
      m_phResult(NULL),
      m_strWelcomeSuccess(),
      m_strWelcomeFailure(),
      m_strBodySuccess(),
      m_strBodyFailure(),
      m_strClick()
{
    VERIFY(m_strWelcomeSuccess.LoadString(nIDWelcomeTxt));

    if (nIDBodyTxt)
    {
        VERIFY(m_strBodySuccess.LoadString(nIDBodyTxt));
    }

    VERIFY(m_strClick.LoadString(nIDClickTxt ? nIDClickTxt : IDS_WIZ_NEXT));
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CIISWizardBookEnd, CIISWizardPage)
    //{{AFX_MSG_MAP(CIISWizardBookEnd)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



BOOL 
CIISWizardBookEnd::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE to display the page, FALSE otherwise.

--*/
{
    if (IsWelcomePage())
    {
        GetDlgItem(IDC_STATIC_WZ_WELCOME)->SetWindowText(m_strWelcomeSuccess);
        GetDlgItem(IDC_STATIC_WZ_BODY)->SetWindowText(m_strBodySuccess);
    }
    else
    {
        CError err(*m_phResult);

        GetDlgItem(IDC_STATIC_WZ_WELCOME)->SetWindowText(
            err.Succeeded() ? m_strWelcomeSuccess : m_strWelcomeFailure
            );

        //
        // Build body text string and expand error messages
        //
        CString strBody = err.Succeeded() ? m_strBodySuccess : m_strBodyFailure;
        err.TextFromHRESULTExpand(strBody);

        GetDlgItem(IDC_STATIC_WZ_BODY)->SetWindowText(strBody);
    }

    DWORD dwFlags = IsWelcomePage() ? PSWIZB_NEXT : PSWIZB_FINISH;

    SetWizardButtons(dwFlags);

    return CIISWizardPage::OnSetActive();
}



BOOL 
CIISWizardBookEnd::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CIISWizardPage::OnInitDialog();

    //
    // Make the "Click 'foo' to continue" message bold as well.
    //
    if (m_hWnd != NULL)
    // This paranoia check to shut down PREFIX
    {
       ApplyFontToControls(this, GetBoldFont(), IDC_STATIC_WZ_CLICK, IDC_STATIC_WZ_CLICK);

       GetDlgItem(IDC_STATIC_WZ_CLICK)->SetWindowText(m_strClick);

       //
       // Remove Cancel Button on the completion page only.
       //
       EnableSheetButton(IDCANCEL, IsWelcomePage());
    }
    return TRUE;  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\wizard.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        wizard.h

   Abstract:

        Enhanced dialog and IIS MMC Wizards definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef __IISUI_WIZARD_H__
#define __IISUI_WIZARD_H__



//
// CIISWizardPage parameters
//
#define HEADER_PAGE         (TRUE)
#define WELCOME_PAGE        (FALSE)
#define USE_DEFAULT_CAPTION (0)



#if (_WIN32_IE < 0x0400)
//
// Defined in comctrl.h.  Defined here because NT 5 MFC42.dll are
// defined with _WIN32_IE 0x300
//
#pragma message("Warning: privately defining _WIN32_IE definitions")
#define PSH_WIZARD97               0x00002000
#define ICC_INTERNET_CLASSES       0x00000800
#define PSP_HIDEHEADER             0x00000800
#define PSP_USEHEADERTITLE         0x00001000
#define PSP_USEHEADERSUBTITLE      0x00002000
#define PSH_WIZARD_LITE            0x00400000
#endif // _WIN32_IE



//
// Using dialog font as a basis, create a new special effects font
//
BOOL COMDLL CreateSpecialDialogFont(
    IN CWnd * pdlg,                 // Source dialog
    IN OUT CFont * pfontSpecial,    // Font to be used must be allocated already
    IN LONG lfOffsetWeight = +300,  // Assuming boldification
    IN LONG lfOffsetHeight = +0,    // Assuming no change in height
    IN LONG lfOffsetWidth  = +0,    // Assuming no change in width (or true type)
    IN BOOL fItalic        = FALSE, // Do not invert italic state
    IN BOOL fUnderline     = FALSE  // Do not invert underline state
    );



//
// Apply fonts to child controls of a dialog
//
void COMDLL ApplyFontToControls(
    IN CWnd * pdlg,                 // Parent dialog
    IN CFont * pfont,               // Font to be applied
    IN UINT nFirst,                 // First control ID in the series
    IN UINT nLast                   // Last control ID in the series
    );



class COMDLL CEmphasizedDialog : public CDialog
/*++

Class Description:

    A standard CDialog that allows use of emphasized fonts as follows:

    control ID      Meaning
    --------------------------------------------------------------------------
    IDC_ED_BOLD1    Dialog font, bold-faced.
    IDC_ED_BOLD2    Dialog font, bold-faced.
    IDC_ED_BOLD3    Dialog font, bold-faced.
    IDC_ED_BOLD4    Dialog font, bold-faced.
    IDC_ED_BOLD5    Dialog font, bold-faced.

    Note: others might be added as needed.

Public Interface:

    CEmphasizedDialog   : Constructor

--*/
{
    DECLARE_DYNCREATE(CEmphasizedDialog)

//
// Constructors
//
public:
    CEmphasizedDialog(LPCTSTR lpszTemplateName, CWnd * pParentWnd = NULL);
    CEmphasizedDialog(UINT nIDTemplate, CWnd * pParentWnd = NULL);
    CEmphasizedDialog();

protected:
    virtual BOOL OnInitDialog();
    afx_msg void OnDestroy();

    DECLARE_MESSAGE_MAP()

private:
    CFont   m_fontBold;
};



class COMDLL CIISWizardSheet : public CPropertySheet
/*++

Class Description:

    IIS Wizard sheet base class
    
Public Interface:    

    CIISWizardSheet     : Constructor

    IsWizard97          : TRUE if the wizard is in '97 mode
    GetSpecialFont      : Get pointer to special font
    GetBitmapMemDC      : Get memory DC where bitmap resides.
    GetBackgroundBrush  : Get background brush
    QueryBitmapWidth    : Get bitmap width
    QueryBitmapHeight   : Get bitmap height

Notes:

    The sheets will be shown in wizard '97 format
    if a welcome bitmap ID is specified.  In that
    case, a header bitmap ID must also be specified.

    Additionally, the same control IDs as used in CEmphasizedDialog
    above have special meaning.

--*/
{
    DECLARE_DYNCREATE(CIISWizardSheet)

//
// Construction
//
public:
    //
    // Specifying a welcome bitmap make the wizard
    // wizard '97, otherwise it's a plain-old wizard
    // page.
    //
    CIISWizardSheet(
        IN UINT nWelcomeBitmap     = 0,
        IN UINT nHeaderBitmap      = 0,
        IN COLORREF rgbForeColor   = RGB(0,0,0),      // Black
        IN COLORREF rgbBkColor     = RGB(255,255,255) // White
        );

//
// Access
//
public:
    BOOL IsWizard97() const;
    CFont * GetSpecialFont(BOOL fHeader);
    CFont * GetBoldFont() { return &m_fontTitle; }
    CFont * GetBigFont() { return &m_fontWelcome; }
    CDC * GetBitmapMemDC(BOOL fHeader);
    HBRUSH GetBackgroundBrush() const { return m_brBkgnd; }
    CBrush * GetWindowBrush() { return &m_brWindow; }
    LONG QueryBitmapWidth(BOOL fHeader) const;
    LONG QueryBitmapHeight(BOOL fHeader) const;
    COLORREF QueryWindowColor() const { return m_rgbWindow; }
    COLORREF QueryWindowTextColor() const { return m_rgbWindowText; }
    void EnableButton(int nID, BOOL fEnable = TRUE);

protected:
    virtual BOOL OnInitDialog();
    virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);
    afx_msg void OnDestroy();

    DECLARE_MESSAGE_MAP()

protected:
    static const int s_cnBoldDeltaFont;
    static const int s_cnBoldDeltaHeight;
    static const int s_cnBoldDeltaWidth;

protected:
    COLORREF m_rgbWindow;
    COLORREF m_rgbWindowText;

private:
    CFont   m_fontWelcome;
    CFont   m_fontTitle;
    HBRUSH  m_brBkgnd;       
    CBrush  m_brWindow;
    CBitmap m_bmpWelcome;
    CBitmap m_bmpHeader;
    BITMAP  m_bmWelcomeInfo;        
    BITMAP  m_bmHeaderInfo;
    CDC     m_dcMemWelcome;     
    CDC     m_dcMemHeader;     
    HBITMAP m_hbmpOldWelcome;   
    HBITMAP m_hbmpOldHeader;   
};



class COMDLL CIISWizardPage : public CPropertyPage
/*++

Class Description:

    IIS Wizard page base class

Public Interface:

    CIISWizardPage      : Constructor

    ValidateString      : DDX/DDV Helper

Notes:

    If the sheet is constructed with bitmap IDs, the
    pages will be displayed in wizard '97 format.  
    Wizard '97 pages will be displayed in either welcome
    page or header page format.  The welcome page will
    be displayed on a welcome bitmap background, with
    the welcome text (IDC_STATIC_WZ_WELCOME) displayed
    in large bold.  Header pages (ordinary pages), display
    IDC_STATIC_WZ_TITLE in bold, and use the header bitmap
    at the top of the page.

    Special control IDs:
    --------------------

        IDC_STATIC_WZ_WELCOME    - Welcome text displayed in bold
        IDC_STATIC_WZ_TITLE      - Title text displayed in bold
        IDC_STATIC_WZ_SUBTITLE   - Subtitle text

--*/
{
    DECLARE_DYNCREATE(CIISWizardPage)

//
// Construction
//
public:
    CIISWizardPage(
        IN UINT nIDTemplate        = 0,
        IN UINT nIDCaption         = USE_DEFAULT_CAPTION,
        IN BOOL fHeaderPage        = FALSE,
        IN UINT nIDHeaderTitle     = USE_DEFAULT_CAPTION,
        IN UINT nIDSubHeaderTitle  = USE_DEFAULT_CAPTION
        );

public:
    //
    // DDX/DDV Helper
    //
    BOOL ValidateString(
        IN  CEdit & edit,
        OUT CString & str,
        IN  int nMin,
        IN  int nMax
        );

//
// Interface
//
protected:
    virtual BOOL OnInitDialog();
    afx_msg HBRUSH OnCtlColor(CDC * pDC, CWnd * pWnd, UINT nCtlColor);
    afx_msg BOOL OnEraseBkgnd(CDC * pDC);
    DECLARE_MESSAGE_MAP()

//
// Sheet Access
//
protected:
    CIISWizardSheet * GetSheet() const;
    void SetWizardButtons(DWORD dwFlags);
    void EnableSheetButton(int nID, BOOL fEnable = TRUE);
    BOOL IsWizard97() const;
    BOOL IsHeaderPage() const { return m_fUseHeader; }
    CFont * GetSpecialFont();
    CFont * GetBoldFont();
    CFont * GetBigFont();
    CDC   * GetBitmapMemDC();
    HBRUSH GetBackgroundBrush() const;
    CBrush * GetWindowBrush();
    LONG QueryBitmapWidth() const;
    LONG QueryBitmapHeight() const;
    COLORREF QueryWindowColor() const;
    COLORREF QueryWindowTextColor() const;

protected:
    static const int s_cnHeaderOffset;

private:
    BOOL    m_fUseHeader;    // TRUE to use header
    CRect   m_rcFillArea;    // Fill area
    CPoint  m_ptOrigin;      // Bitmap origin
    CString m_strTitle;      // Title text
    CString m_strSubTitle;   // Subtitle text
};



class COMDLL CIISWizardBookEnd : public CIISWizardPage
/*++

Class Description:

    Welcome / Completion Page

Public Interface:

    CIISWizardBookEnd    : Constructor

Notes:

    The resource template is not required.  If not provided,
    a default template will be used.

    Special control IDs (on the dialog template):
    ---------------------------------------------

        IDC_STATIC_WZ_WELCOME    - Welcome text displayed in bold
        IDC_STATIC_WZ_BODY       - Body text will be placed here
        IDC_STATIC_WZ_CLICK      - Click instructions.

    The click instructions default to something sensible, and body text
    will default to the error text on a failure page and to nothing on 
    success and welcome page.  The body text may include the %h/%H 
    escape sequences for CError on a success/failure page.

--*/
{
    DECLARE_DYNCREATE(CIISWizardBookEnd)

public:
    //
    // Constructor for success/failure completion page
    //
    CIISWizardBookEnd(
        IN HRESULT * phResult,
        IN UINT nIDWelcomeTxtSuccess ,
        IN UINT nIDWelcomeTxtFailure,
        IN UINT nIDCaption           = USE_DEFAULT_CAPTION,
        IN UINT nIDBodyTxtSuccess    = USE_DEFAULT_CAPTION,
        IN UINT nIDBodyTxtFailure    = USE_DEFAULT_CAPTION,
        IN UINT nIDClickTxt          = USE_DEFAULT_CAPTION,
        IN UINT nIDTemplate          = 0
        );

    //
    // Constructor for a welcome page
    //
    CIISWizardBookEnd(
        IN UINT nIDWelcomeTxt        = 0,
        IN UINT nIDCaption           = USE_DEFAULT_CAPTION,
        IN UINT nIDBodyTxt           = USE_DEFAULT_CAPTION,
        IN UINT nIDClickTxt          = USE_DEFAULT_CAPTION,
        IN UINT nIDTemplate          = 0
        );

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CPWWelcome)
    enum { IDD = IDD_WIZARD_BOOKEND };
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CIISWizardBookEnd)
    public:
    virtual BOOL OnSetActive();
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CPWTemplate)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    BOOL IsWelcomePage() const { return m_phResult == NULL; }

private:
    HRESULT * m_phResult;
    CString m_strWelcomeSuccess;
    CString m_strWelcomeFailure;
    CString m_strBodySuccess;
    CString m_strBodyFailure;
    CString m_strClick;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CEmphasizedDialog::CEmphasizedDialog(
    IN LPCTSTR lpszTemplateName,
    IN CWnd * pParentWnd
    )
    : CDialog(lpszTemplateName, pParentWnd)
{
}

inline CEmphasizedDialog::CEmphasizedDialog(
    IN UINT nIDTemplate,
    IN CWnd * pParentWnd
    )
    : CDialog(nIDTemplate, pParentWnd)
{
}

inline CEmphasizedDialog::CEmphasizedDialog()
    : CDialog()
{
}

inline BOOL CIISWizardSheet::IsWizard97() const
{
    return ((HBITMAP)m_bmpWelcome != NULL);
}

inline CFont * CIISWizardSheet::GetSpecialFont(BOOL fHeader)
{
    return fHeader ? &m_fontTitle : &m_fontWelcome;
}

inline CDC * CIISWizardSheet::GetBitmapMemDC(BOOL fHeader)
{
    return fHeader ? &m_dcMemHeader : &m_dcMemWelcome;
}

inline LONG CIISWizardSheet::QueryBitmapWidth(BOOL fHeader) const
{
    return fHeader ? m_bmHeaderInfo.bmWidth : m_bmWelcomeInfo.bmWidth;
}

inline LONG CIISWizardSheet::QueryBitmapHeight(BOOL fHeader) const
{
    return fHeader ? m_bmHeaderInfo.bmHeight : m_bmWelcomeInfo.bmHeight;
}

inline CIISWizardSheet * CIISWizardPage::GetSheet() const
{
    return (CIISWizardSheet *)GetParent();
}

inline void CIISWizardPage::SetWizardButtons(DWORD dwFlags)
{
    GetSheet()->SetWizardButtons(dwFlags);
}

inline void CIISWizardPage::EnableSheetButton(int nID, BOOL fEnable)
{
    GetSheet()->EnableButton(nID, fEnable);
}

inline BOOL CIISWizardPage::IsWizard97() const
{
    return GetSheet()->IsWizard97();
}

inline CFont * CIISWizardPage::GetSpecialFont()
{
    ASSERT(IsWizard97());
    return GetSheet()->GetSpecialFont(m_fUseHeader);
}

inline CFont * CIISWizardPage::GetBoldFont()
{
    ASSERT(IsWizard97());
    return GetSheet()->GetBoldFont();
}

inline CFont * CIISWizardPage::GetBigFont()
{
    ASSERT(IsWizard97());
    return GetSheet()->GetBigFont();
}

inline CDC * CIISWizardPage::GetBitmapMemDC()
{
    ASSERT(IsWizard97());
    return GetSheet()->GetBitmapMemDC(m_fUseHeader);
}

inline LONG CIISWizardPage::QueryBitmapWidth() const
{
    ASSERT(IsWizard97());
    return GetSheet()->QueryBitmapWidth(m_fUseHeader);
}

inline LONG CIISWizardPage::QueryBitmapHeight() const
{
    ASSERT(IsWizard97());
    return GetSheet()->QueryBitmapHeight(m_fUseHeader);
}

inline HBRUSH CIISWizardPage::GetBackgroundBrush() const
{
    ASSERT(IsWizard97());
    return GetSheet()->GetBackgroundBrush();
}

inline CBrush * CIISWizardPage::GetWindowBrush()
{
    ASSERT(IsWizard97());
    return GetSheet()->GetWindowBrush();
}

inline COLORREF CIISWizardPage::QueryWindowColor() const 
{ 
    ASSERT(IsWizard97());
    return GetSheet()->QueryWindowColor();
}

inline COLORREF CIISWizardPage::QueryWindowTextColor() const
{ 
    ASSERT(IsWizard97());
    return GetSheet()->QueryWindowTextColor();
}


#endif // __IISUI_WIZARD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\coauth.h ===
BOOL EqualAuthInfo(COAUTHINFO* pAuthInfo,COAUTHINFO* pAuthInfoOther);

/*
HRESULT CopyAuthIdentity(COAUTHIDENTITY * pAuthIdentSrc,COAUTHIDENTITY ** ppAuthIdentDest);
HRESULT CopyAuthInfo(COAUTHINFO * pAuthInfoSrc,COAUTHINFO ** ppAuthInfoDest);
HRESULT CopyServerInfo(COSERVERINFO * pServerInfoSrc,COSERVERINFO ** ppServerInfoDest);
*/

HRESULT CopyAuthIdentityStruct(COAUTHIDENTITY * pAuthIdentSrc,COAUTHIDENTITY * pAuthIdentDest);
HRESULT CopyAuthInfoStruct(COAUTHINFO * pAuthInfoSrc,COAUTHINFO * pAuthInfoDest);
HRESULT CopyServerInfoStruct(COSERVERINFO * pServerInfoSrc,COSERVERINFO * pServerInfoDest);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\cryptpass.cpp ===
#include "stdafx.h"
#include "common.h"
#include <wincrypt.h>
#include <strsafe.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
#define new DEBUG_NEW

//  Given a clear text password.  this function will encrypt the password in memory
//  then allocate memory and passback the encrypted password into the memory
//
//  The class can then store the ppszEncryptedPassword in it's member variables safely
//  and when the class is destructed, should SecureZeroMemory() out the password and LocalFree() up the the memory.
HRESULT EncryptMemoryPassword(LPWSTR pszClearTextPassword,LPWSTR *ppszEncryptedPassword,DWORD *ppdwBufferBytes)
{
	HRESULT hRes = E_FAIL;

	LPWSTR pszTempStr = NULL;
	DWORD dwTempStrSizeOf = 0;

    *ppszEncryptedPassword = NULL;
    *ppdwBufferBytes = 0;

	if (pszClearTextPassword)
	{
        // We should check if the pszClearTextPassword is null terminated before doing wcslen

		DWORD dwBufferByteLen = (wcslen(pszClearTextPassword) + 1) * sizeof(WCHAR);
		if (CRYPTPROTECTMEMORY_BLOCK_SIZE > 0 && dwBufferByteLen > 0)
		{
			int iBlocks = dwBufferByteLen / CRYPTPROTECTMEMORY_BLOCK_SIZE;
			iBlocks++;

			dwTempStrSizeOf = iBlocks * CRYPTPROTECTMEMORY_BLOCK_SIZE;
			pszTempStr = (LPWSTR) LocalAlloc(LPTR,dwTempStrSizeOf);
			if (!pszTempStr)
			{
				hRes = E_OUTOFMEMORY;
				goto EncryptMemoryPassword_Exit;
			}

			ZeroMemory(pszTempStr,dwTempStrSizeOf);
            StringCbCopy(pszTempStr,dwTempStrSizeOf,pszClearTextPassword);

			if (FALSE != CryptProtectMemory(pszTempStr,dwTempStrSizeOf,CRYPTPROTECTMEMORY_SAME_PROCESS))
			{
				// We're all set...
				*ppszEncryptedPassword = pszTempStr;
				*ppdwBufferBytes = dwTempStrSizeOf;

				hRes = S_OK;
				goto EncryptMemoryPassword_Exit;
			}
		}
	}

EncryptMemoryPassword_Exit:
    if (FAILED(hRes)) 
	{
		if (pszTempStr)
		{
			if (dwTempStrSizeOf > 0)
			{
				SecureZeroMemory(pszTempStr,dwTempStrSizeOf);
			}
			LocalFree(pszTempStr);
			pszTempStr = NULL;
			dwTempStrSizeOf = 0;
		}
	}
	return hRes;
}

// Given a encrypted password (encrypted in the same process with EncryptMemoryPassword -- which uses CryptProtectMemory)
// this function will allocate some new memory, decrypt the password and put it in the new memory
// and return it back to the caller in ppszReturnedPassword.
//
// The caller must ensure to erase and free the memory after it is finished using the decrypted password.
//
//     LPWSTR lpwstrTempPassword = NULL;
//
//     if (FAILED(DecryptMemoryPassword((LPWSTR) pszUserPasswordEncrypted,&lpwstrTempPassword,cbUserPasswordEncrypted)))
//     {
//			// do some failure processing...
//     }
//
//     // use password for whatever you needed to use it for...
//
//     if (lpwstrTempPassword)
//     {
//         if (cbTempPassword > 0)
//         (
//             SecureZeroMemory(lpwstrTempPassword,cbTempPassword);
//         )
//         LocalFree(lpwstrTempPassword);lpwstrTempPassword = NULL;
//      }
HRESULT DecryptMemoryPassword(LPWSTR pszEncodedPassword,LPWSTR *ppszReturnedPassword,DWORD dwBufferBytes)
{
    HRESULT hRes = E_FAIL;
    LPWSTR pszTempStr = NULL;
    
    if (!dwBufferBytes || !ppszReturnedPassword) 
	{
		return E_FAIL;
    }

    *ppszReturnedPassword = NULL;
    if (dwBufferBytes) 
	{
        pszTempStr = (LPWSTR) LocalAlloc(LPTR,dwBufferBytes);
        if (!pszTempStr) 
		{
			hRes = E_OUTOFMEMORY;
			goto DecryptMemoryPassword_Exit;
        }

		ZeroMemory(pszTempStr,dwBufferBytes);
        memcpy(pszTempStr,pszEncodedPassword,dwBufferBytes);
		if (FALSE != CryptUnprotectMemory(pszTempStr,dwBufferBytes,CRYPTPROTECTMEMORY_SAME_PROCESS))
		{
			// We're all set...
			*ppszReturnedPassword = pszTempStr;
			hRes = S_OK;
		}
    }

DecryptMemoryPassword_Exit:
    if (FAILED(hRes)) 
	{
		if (pszTempStr)
		{
			if (dwBufferBytes > 0)
			{
				SecureZeroMemory(pszTempStr,dwBufferBytes);
			}
			LocalFree(pszTempStr);
			pszTempStr =  NULL;
		}
    }

	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\balloon.cpp ===
#include "stdafx.h"
#include "common.h"
#include "bidi.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
#define new DEBUG_NEW

#define ID_MY_EDITTIMER           10007
#define EDIT_TIPTIMEOUT           10000
// 2.0 seconds
#define EDIT_TIPTIMEOUT_LOSTFOCUS  20000000

inline UINT64 FILETIMEToUINT64( const FILETIME & FileTime )
{
    ULARGE_INTEGER LargeInteger;
    LargeInteger.HighPart = FileTime.dwHighDateTime;
    LargeInteger.LowPart = FileTime.dwLowDateTime;
    return LargeInteger.QuadPart;
}

inline FILETIME UINT64ToFILETIME( UINT64 Int64Value )
{
    ULARGE_INTEGER LargeInteger;
    LargeInteger.QuadPart = Int64Value;

    FILETIME FileTime;
    FileTime.dwHighDateTime = LargeInteger.HighPart;
    FileTime.dwLowDateTime = LargeInteger.LowPart;

    return FileTime;
}

typedef struct tagBALLOONCONTROLINFO
{
    HWND hwndControl;
    HWND hwndBalloon;
	FILETIME ftStart;
} BALLOONCONTROLINFO, *PBALLOONCONTROLINFO;

// global
BALLOONCONTROLINFO g_MyBalloonInfo;

// forwards
LRESULT CALLBACK Edit_BalloonTipParentSubclassProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam, UINT_PTR uID, ULONG_PTR dwRefData);
VOID CALLBACK MyBalloonTimerProc(HWND hwnd,UINT uMsg,UINT idEvent,DWORD dwTime);


BOOL IsSupportTooltips(void)
{
    BOOL bReturn = FALSE;
    HINSTANCE hComCtl = NULL;
    //
    //  Comctl32.dll must be 5.80 or greater to use balloon tips.  We check the dll version 
    //  by calling DllGetVersion in comctl32.dll.
    //
    hComCtl = LoadLibraryExA("comctl32.dll", NULL, 0);
    if (hComCtl != NULL)
    {
        typedef HRESULT (*DLLGETVERSIONPROC)(DLLVERSIONINFO* lpdvi);
        DLLGETVERSIONPROC fnDllGetVersion = (DLLGETVERSIONPROC) GetProcAddress(hComCtl,"DllGetVersion");
        if (NULL == fnDllGetVersion)
        {
            //
            //  DllGetVersion does not exist in Comctl32.dll.  This mean the version is too old so we need to fail.
            //
            goto IsSupportTooltips_Exit;
        }
        else
        {
            DLLVERSIONINFO dvi;

            ZeroMemory(&dvi, sizeof(dvi));
            dvi.cbSize = sizeof(dvi);

            HRESULT hResult = (*fnDllGetVersion)(&dvi);

            if (SUCCEEDED(hResult))
            {
                //
                //  Take the version returned and compare it to 5.80.
                //
                if (MAKELONG(dvi.dwMinorVersion,dvi.dwMajorVersion) < MAKELONG(80,5))
                {
                    //CMTRACE2(TEXT("COMCTL32.DLL version - %d.%d"),dvi.dwMajorVersion,dvi.dwMinorVersion);
                    //CMTRACE1(TEXT("COMCTL32.DLL MAKELONG - %li"),MAKELONG(dvi.dwMinorVersion,dvi.dwMajorVersion));
                    //CMTRACE1(TEXT("Required minimum MAKELONG - %li"),MAKELONG(80,5));
					
                    // Wrong DLL version
                    bReturn = FALSE;
                    goto IsSupportTooltips_Exit;
                }
                
                // version is larger than 5.80
                bReturn = TRUE;
            }
        }
    }

IsSupportTooltips_Exit:
    if (hComCtl)
    {
        FreeLibrary(hComCtl);hComCtl=NULL;
    }
    return bReturn;
}

LRESULT Edit_BalloonTipSubclassParents(PBALLOONCONTROLINFO pMyBalloonInfo)
{
    if (pMyBalloonInfo)
    {
        // Subclass all windows along the parent chain from the edit control
        // and in the same thread (can only subclass windows with same thread affinity)
        HWND  hwndParent = GetAncestor(pMyBalloonInfo->hwndControl, GA_PARENT);
        DWORD dwTid      = GetWindowThreadProcessId(pMyBalloonInfo->hwndControl, NULL);

        while (hwndParent && (dwTid == GetWindowThreadProcessId(hwndParent, NULL)))
        {
            SetWindowSubclass(hwndParent, Edit_BalloonTipParentSubclassProc, (UINT_PTR)pMyBalloonInfo->hwndControl, (DWORD_PTR) pMyBalloonInfo);
            hwndParent = GetAncestor(hwndParent, GA_PARENT);
        }
    }

    return TRUE;
}

HWND Edit_BalloonTipRemoveSubclasses(HWND hwndControl)
{
    HWND  hwndParent  = GetAncestor(hwndControl, GA_PARENT);
    HWND  hwndTopMost = NULL;
    DWORD dwTid       = GetWindowThreadProcessId(hwndControl, NULL);

    while (hwndParent && (dwTid == GetWindowThreadProcessId(hwndParent, NULL)))
    {
        RemoveWindowSubclass(hwndParent, Edit_BalloonTipParentSubclassProc, (UINT_PTR) NULL);
        hwndTopMost = hwndParent;
        hwndParent = GetAncestor(hwndParent, GA_PARENT);
    }

    return hwndTopMost;
}

LRESULT Edit_HideBalloonTipHandler(PBALLOONCONTROLINFO pMyBalloonControl)
{
    HWND hwndParent = 0;

    if (pMyBalloonControl)
    {
        KillTimer(pMyBalloonControl->hwndControl, ID_MY_EDITTIMER);

        if (SendMessage(pMyBalloonControl->hwndBalloon, TTM_ENUMTOOLS, 0, (LPARAM)0))
        {
            SendMessage(pMyBalloonControl->hwndBalloon, TTM_DELTOOL, 0, (LPARAM)0);
        }

        SendMessage(pMyBalloonControl->hwndBalloon, TTM_TRACKACTIVATE, FALSE, 0);
        DestroyWindow(pMyBalloonControl->hwndBalloon);
        pMyBalloonControl->hwndBalloon = NULL;

        hwndParent = Edit_BalloonTipRemoveSubclasses(pMyBalloonControl->hwndControl);
        if (hwndParent && IsWindow(hwndParent))
        {
            InvalidateRect(hwndParent, NULL, TRUE);
            UpdateWindow(hwndParent);
        }

        if (hwndParent != pMyBalloonControl->hwndControl)
        {
            RedrawWindow(pMyBalloonControl->hwndControl, NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW);
        }
    }

    return TRUE;
}

void Edit_HideBalloonTipHandler(void)
{
    if (g_MyBalloonInfo.hwndBalloon)
    {
        Edit_HideBalloonTipHandler(&g_MyBalloonInfo);
    }
}

VOID CALLBACK MyBalloonTimerProc(HWND hwnd,UINT uMsg,UINT idEvent,DWORD dwTime)
{
    Edit_HideBalloonTipHandler(&g_MyBalloonInfo);
}

LRESULT CALLBACK Edit_BalloonTipParentSubclassProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam, UINT_PTR uID, ULONG_PTR dwRefData)
{
    
    PBALLOONCONTROLINFO pMyBalloonControl = (PBALLOONCONTROLINFO) dwRefData;
    if (pMyBalloonControl)
    {
        switch (uMessage)
        {
        case WM_MOVE:
        case WM_SIZING:
		case WM_TIMER:
            //
            // dismiss any showing tips
            //
            if (pMyBalloonControl->hwndBalloon)
            {
                Edit_HideBalloonTipHandler(pMyBalloonControl);
            }
            break;

        case WM_KILLFOCUS: //for some reason we never get this notification that's why we need to use mousemove
        case WM_MOUSEMOVE:
			if (pMyBalloonControl->hwndBalloon)
			{
				FILETIME ftNow;
				::GetSystemTimeAsFileTime(&ftNow);

				// Check if at least 2 seconds have gone by
				// if they have not then show for at least that long
				if ((FILETIMEToUINT64(ftNow) - FILETIMEToUINT64(g_MyBalloonInfo.ftStart)) > EDIT_TIPTIMEOUT_LOSTFOCUS)
				{
					// Displayed for longer than 2 seconds
					// that's long enough
					Edit_HideBalloonTipHandler(pMyBalloonControl);
				}
				else
				{
					// special case here
					// set timeout to kill the tip in 2 seconds
					KillTimer(g_MyBalloonInfo.hwndControl, ID_MY_EDITTIMER);
					SetTimer(g_MyBalloonInfo.hwndControl, ID_MY_EDITTIMER, EDIT_TIPTIMEOUT_LOSTFOCUS / 10000, (TIMERPROC) MyBalloonTimerProc);
					//Edit_HideBalloonTipHandler(pMyBalloonControl);
				}
			}
			break;

        case WM_DESTROY:
            // Clean up subclass
            RemoveWindowSubclass(hDlg, Edit_BalloonTipParentSubclassProc, (UINT_PTR) pMyBalloonControl->hwndControl);
            break;

        default:
            break;
        }
    }

    return DefSubclassProc(hDlg, uMessage, wParam, lParam);
}

LRESULT Edit_TrackBalloonTip(PBALLOONCONTROLINFO pMyBalloonControl)
{
    if (pMyBalloonControl)
    {
        DWORD dwPackedCoords;
        HDC   hdc = GetDC(pMyBalloonControl->hwndControl);
        RECT  rcWindowCaret;
        RECT  rcWindowControl;
        POINT ptBalloonSpear;
        ptBalloonSpear.x = 0;
        ptBalloonSpear.y = 0;
        POINT ptCaret;
        ptCaret.x = 0;
        ptCaret.y = 0;
    
        //
        // get the average size of one character
        //
        int cxCharOffset = 0;
        //cxCharOffset = TESTFLAG(GET_EXSTYLE(ped), WS_EX_RTLREADING) ? -ped->aveCharWidth : ped->aveCharWidth;
        TEXTMETRIC tm;
        GetTextMetrics(hdc, &tm);
        cxCharOffset = tm.tmAveCharWidth / 2;

        //
        // Get current caret position.
        //
        GetCaretPos( (POINT FAR*)& ptCaret);
        GetClientRect(pMyBalloonControl->hwndControl,&rcWindowCaret);
        ptBalloonSpear.x = ptCaret.x + cxCharOffset;
        ptBalloonSpear.y = rcWindowCaret.top + (rcWindowCaret.bottom - rcWindowCaret.top) / 2 ;

        //
        // Translate to window coords
        //
        GetWindowRect(pMyBalloonControl->hwndControl, &rcWindowControl);
        ptBalloonSpear.x += rcWindowControl.left;
        ptBalloonSpear.y += rcWindowControl.top;

        //
        // Position the tip stem at the caret position
        //
        dwPackedCoords = (DWORD) MAKELONG(ptBalloonSpear.x, ptBalloonSpear.y);
        SendMessage(pMyBalloonControl->hwndBalloon, TTM_TRACKPOSITION, 0, (LPARAM) dwPackedCoords);

        ReleaseDC(pMyBalloonControl->hwndBalloon,hdc);
    }
    return 1;
}

LRESULT Edit_ShowBalloonTipHandler(HWND hwndControl,LPCTSTR szText)
{
    LRESULT lResult = FALSE;

    if (g_MyBalloonInfo.hwndBalloon)
    {
        Edit_HideBalloonTipHandler(&g_MyBalloonInfo);
    }

    g_MyBalloonInfo.hwndControl = hwndControl;
    KillTimer(g_MyBalloonInfo.hwndControl , ID_MY_EDITTIMER);

    g_MyBalloonInfo.hwndBalloon = CreateWindowEx(
                            (IsBiDiLocalizedSystem() ? WS_EX_LAYOUTRTL : 0), 
                            TOOLTIPS_CLASS, NULL,
                            WS_POPUP | TTS_NOPREFIX | TTS_BALLOON,
                            CW_USEDEFAULT, CW_USEDEFAULT,
                            CW_USEDEFAULT, CW_USEDEFAULT,
                            hwndControl, NULL, _Module.GetResourceInstance(),
                            NULL);
    if (NULL != g_MyBalloonInfo.hwndBalloon)
    {
        TOOLINFO ti = {0};

        ti.cbSize = TTTOOLINFOW_V2_SIZE;
        ti.uFlags = TTF_IDISHWND | TTF_TRACK | TTF_SUBCLASS; // not sure if we need TTF_SUBCLASS
        ti.hwnd   = hwndControl;
        ti.uId    = (WPARAM) g_MyBalloonInfo.hwndBalloon;
        ti.lpszText = (LPTSTR) szText;

        // set the version so we can have non buggy mouse event forwarding
        SendMessage(g_MyBalloonInfo.hwndBalloon, CCM_SETVERSION, COMCTL32_VERSION, 0);
        SendMessage(g_MyBalloonInfo.hwndBalloon, TTM_ADDTOOL, 0, (LPARAM)&ti);
        SendMessage(g_MyBalloonInfo.hwndBalloon, TTM_SETMAXTIPWIDTH, 0, 300);
        //SendMessage(g_MyBalloonInfo.hwndBalloon, TTM_SETTITLE, (WPARAM) 0, (LPARAM) "");

        Edit_TrackBalloonTip(&g_MyBalloonInfo);
        SendMessage(g_MyBalloonInfo.hwndBalloon, TTM_TRACKACTIVATE, (WPARAM) TRUE, (LPARAM)&ti);
        SetFocus(g_MyBalloonInfo.hwndControl);

        Edit_BalloonTipSubclassParents(&g_MyBalloonInfo);

        //
        // set timeout to kill the tip
        //
        KillTimer(g_MyBalloonInfo.hwndControl, ID_MY_EDITTIMER);
		::GetSystemTimeAsFileTime(&g_MyBalloonInfo.ftStart);
        SetTimer(g_MyBalloonInfo.hwndControl, ID_MY_EDITTIMER, EDIT_TIPTIMEOUT, (TIMERPROC) MyBalloonTimerProc);

        lResult = TRUE;
    }

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\balloon.h ===
#ifndef _BALLOON_H_
#define _BALLOON_H_


LRESULT _EXPORT Edit_ShowBalloonTipHandler(HWND hwndControl,LPCTSTR szText);
void Edit_HideBalloonTipHandler(void);

#endif // _BALLOON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\bidi.h ===
#ifndef _BIDI_H_
#define _BIDI_H_


BOOL _EXPORT IsBiDiLocalizedSystem(void);

#endif // _BIDI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\coauth.cpp ===
#include "stdafx.h"
#include "common.h"
#include "coauth.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
#define new DEBUG_NEW

BOOL
EqualAuthInfo(
             COAUTHINFO*         pAuthInfo,
             COAUTHINFO*         pAuthInfoOther)
{
    if ( pAuthInfo && pAuthInfoOther )
    {
        if ( (pAuthInfo->dwAuthnSvc != pAuthInfoOther->dwAuthnSvc) ||
             (pAuthInfo->dwAuthzSvc != pAuthInfoOther->dwAuthzSvc) ||
             (pAuthInfo->dwAuthnLevel != pAuthInfoOther->dwAuthnLevel) ||
             (pAuthInfo->dwImpersonationLevel != pAuthInfoOther->dwImpersonationLevel) ||
             (pAuthInfo->dwCapabilities != pAuthInfoOther->dwCapabilities) )
        {
            return FALSE;
        }

        // only compare pwszServerPrincName's if they're both specified
        if (pAuthInfo->pwszServerPrincName && pAuthInfoOther->pwszServerPrincName)
        {
            if ( lstrcmpW(pAuthInfo->pwszServerPrincName,
                          pAuthInfoOther->pwszServerPrincName) != 0 )
            {
                return FALSE;
            }
        }
        else
        {
            // if one was NULL, both should be NULL for equality
            if (pAuthInfo->pwszServerPrincName != pAuthInfoOther->pwszServerPrincName)
            {
                return FALSE;
            }
        }
        // we never cache authid, so one of them must be NULL
        ASSERT(!(pAuthInfo->pAuthIdentityData && pAuthInfoOther->pAuthIdentityData));
        if (pAuthInfo->pAuthIdentityData || pAuthInfoOther->pAuthIdentityData) 
        {
           return FALSE;
        }
    }
    else
    {
        if ( pAuthInfo != pAuthInfoOther )
        {
            return FALSE;
        }
    }

    return TRUE;
}

HRESULT
CopyServerInfoStruct(
            IN  COSERVERINFO *    pServerInfoSrc,
            IN  COSERVERINFO *    pServerInfoDest
            )
{
    HRESULT hr = E_OUTOFMEMORY;
   
    if (pServerInfoSrc == NULL)
    {
       return S_OK;
    }

    if (pServerInfoDest == NULL)
    {
       return E_POINTER;
    }

    CopyMemory(pServerInfoDest, pServerInfoSrc, sizeof(COSERVERINFO));

    // We need to allocate these fields and make a copy
    pServerInfoDest->pwszName = NULL;

    // only alloc space for pwszServerPrincName if its non-null
    if (pServerInfoSrc->pwszName)
    {
        pServerInfoDest->pwszName = 
            (LPWSTR) LocalAlloc(LPTR,(lstrlenW(pServerInfoSrc->pwszName) + 1) * sizeof(WCHAR));

        if (!pServerInfoDest->pwszName)
            goto Cleanup;
        
        lstrcpyW(pServerInfoDest->pwszName, pServerInfoSrc->pwszName);
    }

    pServerInfoDest->pAuthInfo = NULL;
    hr = S_OK;
    
Cleanup:
    return hr;
}

HRESULT
CopyAuthInfoStruct(
            IN  COAUTHINFO *    pAuthInfoSrc,
            IN  COAUTHINFO *    pAuthInfoDest
            )
{
    HRESULT hr = E_OUTOFMEMORY;

    if (pAuthInfoSrc == NULL)
    {
       return S_OK;
    }

    if (pAuthInfoDest == NULL)
    {
        return E_POINTER;
    }

    CopyMemory(pAuthInfoDest, pAuthInfoSrc, sizeof(COAUTHINFO));

    // We need to allocate these fields and make a copy
    pAuthInfoDest->pwszServerPrincName = NULL;
    pAuthInfoDest->pAuthIdentityData = NULL;

    // only alloc space for  pwszServerPrincName if its non-null
    if (pAuthInfoSrc->pwszServerPrincName)
    {
        pAuthInfoDest->pwszServerPrincName = 
            (LPWSTR) LocalAlloc(LPTR,(lstrlenW(pAuthInfoSrc->pwszServerPrincName) + 1) * sizeof(WCHAR));

        if (!pAuthInfoDest->pwszServerPrincName)
            goto Cleanup;
        
        lstrcpyW(pAuthInfoDest->pwszServerPrincName, pAuthInfoSrc->pwszServerPrincName);
    }
    
    pAuthInfoDest->pAuthIdentityData = NULL;
    hr = S_OK;
    
Cleanup:
    return hr;
}

HRESULT
CopyAuthIdentityStruct(
                IN  COAUTHIDENTITY *    pAuthIdentSrc,
                IN  COAUTHIDENTITY *    pAuthIdentDest
                )
{
    HRESULT hr = E_OUTOFMEMORY;
    ULONG ulCharLen = 1;

    if (pAuthIdentSrc == NULL)
    {
        hr =  E_POINTER;
        goto Cleanup;
    }
    if (pAuthIdentDest == NULL)
    {
        hr =  E_POINTER;
        goto Cleanup;
    }
    
    // Guard against both being set, although presumably this would have
    // caused grief before we got to this point.
    if ((pAuthIdentSrc->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE) &&
        (pAuthIdentSrc->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI))
    {
        ASSERT(0 && "Both string type flags were set!");
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    if (pAuthIdentSrc->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE)
    {
        ulCharLen = sizeof(WCHAR);
    }
    else if (pAuthIdentSrc->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI)
    {
        ulCharLen = sizeof(CHAR);
    }
    else
    {
       // The user didn't specify either string bit? How did we get here?
        ASSERT(0 && "String type flag was not set!");
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    CopyMemory(pAuthIdentDest, pAuthIdentSrc, sizeof(COAUTHIDENTITY));

    // Strings need to be allocated individually and copied
    pAuthIdentDest->User = pAuthIdentDest->Domain = pAuthIdentDest->Password = NULL;

    if (pAuthIdentSrc->User)
    {
        pAuthIdentDest->User = (USHORT *)LocalAlloc(LPTR,(pAuthIdentDest->UserLength+1) * ulCharLen);

        if (!pAuthIdentDest->User)
            goto Cleanup;

        CopyMemory(pAuthIdentDest->User, pAuthIdentSrc->User, (pAuthIdentDest->UserLength+1) * ulCharLen);
    }

    if (pAuthIdentSrc->Domain)
    {
        pAuthIdentDest->Domain = (USHORT *)LocalAlloc(LPTR,(pAuthIdentDest->DomainLength+1) * ulCharLen);

        if (!pAuthIdentDest->Domain)
            goto Cleanup;

        CopyMemory(pAuthIdentDest->Domain, pAuthIdentSrc->Domain, (pAuthIdentDest->DomainLength+1) * ulCharLen);
    }
            
    if (pAuthIdentSrc->Password)
    {
        pAuthIdentDest->Password = (USHORT *)LocalAlloc(LPTR,(pAuthIdentDest->PasswordLength+1) * ulCharLen);

        if (!pAuthIdentDest->Password)
            goto Cleanup;

        CopyMemory(pAuthIdentDest->Password, pAuthIdentSrc->Password, (pAuthIdentDest->PasswordLength+1) * ulCharLen);
    }
    
    hr = S_OK;

Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\cryptpass.h ===
#ifndef _PASSWORD_H_
#define _PASSWORD_H_


HRESULT _EXPORT EncryptMemoryPassword(LPWSTR pszClearTextPassword,LPWSTR *ppszEncryptedPassword,DWORD *ppdwBufferBytes);
HRESULT _EXPORT DecryptMemoryPassword(LPWSTR pszEncodedPassword,LPWSTR *ppszReturnedPassword,DWORD dwBufferBytes);

#endif // _PASSWORD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\bidi.cpp ===
#include "stdafx.h"
#include "common.h"
#include "bidi.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
#define new DEBUG_NEW

/***************************************************************************\
* ConvertHexStringToIntW
*
* Converts a hex numeric string into an integer.
*
* History:
* 14-June-1998 msadek    Created
\***************************************************************************/
BOOL ConvertHexStringToIntW( WCHAR *pszHexNum , int *piNum )
{
    int   n=0L;
    WCHAR  *psz=pszHexNum;

  
    for(n=0 ; ; psz=CharNextW(psz))
    {
        if( (*psz>='0') && (*psz<='9') )
            n = 0x10 * n + *psz - '0';
        else
        {
            WCHAR ch = *psz;
            int n2;

            if(ch >= 'a')
                ch -= 'a' - 'A';

            n2 = ch - 'A' + 0xA;
            if (n2 >= 0xA && n2 <= 0xF)
                n = 0x10 * n + n2;
            else
                break;
        }
    }

    /*
     * Update results
     */
    *piNum = n;

    return (psz != pszHexNum);
}

typedef struct tagMUIINSTALLLANG {
    LANGID LangID;
    BOOL   bInstalled;
} MUIINSTALLLANG, *LPMUIINSTALLLANG;

typedef BOOL (WINAPI *PFNENUMUILANGUAGES)(UILANGUAGE_ENUMPROC, DWORD, LONG_PTR);

BOOL CALLBACK Mirror_EnumUILanguagesProc(LPTSTR lpUILanguageString, LONG_PTR lParam)
{
    int langID = 0;

    ConvertHexStringToIntW(lpUILanguageString, &langID);

    if((LANGID)langID == ((LPMUIINSTALLLANG)lParam)->LangID)
    {
        ((LPMUIINSTALLLANG)lParam)->bInstalled = TRUE;
        return FALSE;
    }
    return TRUE;
}

/***************************************************************************\
* Mirror_IsUILanguageInstalled
*
* Verifies that the User UI language is installed on W2k
*
* History:
* 14-June-1999 msadek    Created
\***************************************************************************/
BOOL Mirror_IsUILanguageInstalled( LANGID langId )
{

    MUIINSTALLLANG MUILangInstalled = {0};
    MUILangInstalled.LangID = langId;
    
    static PFNENUMUILANGUAGES pfnEnumUILanguages=NULL;

    if( NULL == pfnEnumUILanguages )
    {
        HMODULE hmod = GetModuleHandleA("KERNEL32");

        if( hmod )
            pfnEnumUILanguages = (PFNENUMUILANGUAGES)
                                          GetProcAddress(hmod, "EnumUILanguagesW");
    }

    if( pfnEnumUILanguages )
        pfnEnumUILanguages(Mirror_EnumUILanguagesProc, 0, (LONG_PTR)&MUILangInstalled);

    return MUILangInstalled.bInstalled;
}

/***************************************************************************\
* IsBiDiLocalizedSystemEx
*
* returns TRUE if running on a lozalized BiDi (Arabic/Hebrew) NT5 or Memphis.
* Should be called whenever SetProcessDefaultLayout is to be called.
*
* History:
* 02-Feb-1998 samera    Created
\***************************************************************************/
BOOL IsBiDiLocalizedSystemEx( LANGID *pLangID )
{
    int           iLCID=0L;
    static BOOL   bRet = (BOOL)(DWORD)-1;
    static LANGID langID = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);

    if (bRet != (BOOL)(DWORD)-1)
    {
        if (bRet && pLangID)
        {
            *pLangID = langID;
        }
        return bRet;
    }

    bRet = FALSE;
    /*
     * Need to use NT5 detection method (Multiligual UI ID)
     */
    langID = GetUserDefaultUILanguage();

    if( langID )
    {
        WCHAR wchLCIDFontSignature[16];
        iLCID = MAKELCID( langID , SORT_DEFAULT );

        /*
         * Let's verify this is a RTL (BiDi) locale. Since reg value is a hex string, let's
         * convert to decimal value and call GetLocaleInfo afterwards.
         * LOCALE_FONTSIGNATURE always gives back 16 WCHARs.
         */

        if( GetLocaleInfoW( iLCID , 
                            LOCALE_FONTSIGNATURE , 
                            (WCHAR *) &wchLCIDFontSignature[0] ,
                            (sizeof(wchLCIDFontSignature)/sizeof(WCHAR))) )
        {
  
            /* Let's verify the bits we have a BiDi UI locale */
            if(( wchLCIDFontSignature[7] & (WCHAR)0x0800) && Mirror_IsUILanguageInstalled(langID) )
            {
                bRet = TRUE;
            }
        }
    }

    if (bRet && pLangID)
    {
        *pLangID = langID;
    }
    return bRet;
}

BOOL
IsBiDiLocalizedSystem( void )
{
    return IsBiDiLocalizedSystemEx(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\common.h ===
/*++

   Copyright    (c)    1994-2000   Microsoft Corporation

   Module  Name :

        common.h

   Abstract:

        Common properties header file

   Author:

        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:
        2/17/2000    sergeia     removed dependency on MFC

--*/



#ifndef __COMPROP_H__
#define __COMPROP_H__


#include <lmcons.h>
#include <wincrypt.h>
#include <iis64.h>
#include "inetcom.h"
#include "iisinfo.h"
#include "svcloc.h"

#include "resource.h"

#ifndef _DLLEXP
    #define _EXPORT              __declspec(dllimport)
#else
    #define _EXPORT              __declspec(dllexport)
#endif


//
// Memory Allocation Macros
//
//#define AllocMem(cbSize)\
//    ::LocalAlloc(LPTR, cbSize)

//#define FreeMem(lp)\
//    ::LocalFree(lp)

//#define AllocMemByType(citems, type)\
//    (type *)AllocMem(citems * sizeof(type))



//
// Program flow macros
//
#define FOREVER for(;;)

#define BREAK_ON_ERR_FAILURE(err)\
    if (err.Failed()) break;

#define BREAK_ON_NULL_PTR(lp)\
    if (lp == NULL) break;

#define BREAK_ON_FAILURE(hr)\
    if (FAILED(hr)) break

//
// Safe allocators
//
#define SAFE_DELETE(obj)\
    if (obj != NULL) do { delete obj; obj = NULL; } while(0)

#define SAFE_DELETE_OBJECT(obj)\
    if (obj != NULL) do { DeleteObject(obj); obj = NULL; } while(0)

#define SAFE_FREEMEM(lp)\
    if (lp != NULL) do { FreeMem(lp); lp = NULL; } while(0)

#define SAFE_SYSFREESTRING(lp)\
    if (lp != NULL) do { ::SysFreeString(lp); lp = NULL; } while(0)

#define SAFE_RELEASE(lpInterface)\
    if (lpInterface != NULL) do { lpInterface->Release(); lpInterface = NULL; } while(0)


#define IS_NETBIOS_NAME(lpstr) (*lpstr == _T('\\'))
//
// Return the portion of a computer name without the backslashes
//
#define PURE_COMPUTER_NAME(lpstr) (IS_NETBIOS_NAME(lpstr) ? lpstr + 2 : lpstr)

#define ARRAY_SIZE(a)    (sizeof(a)/sizeof(a[0]))
#define STRSIZE(str)     (ARRAY_SIZE(str)-1)
#define ARRAY_BYTES(a)   (sizeof(a) * sizeof(a[0]))
#define STRBYTES(str)    (ARRAY_BYTES(str) - sizeof(str[0]))

//
// General purpose files
//
#include "iiscstring.h"
typedef IIS::CString CString;

#include "debugatl.h"
#include "utcls.h"
//#include "objplus.h"
//#include "strfn.h"
//#include "odlbox.h"
#include "error.h"
#include "mdkeys.h"
//#include "ipa.h"
//#include "wizard.h"
//#include "registry.h"
//#include "ddxv.h"
//#include "objpick.h"
//#include "accentry.h"
//#include "sitesecu.h"
//#include "ipctl.h"
//#include "dtp.h"
//#include "dirbrows.h"
#include "FileChooser.h"

#include "bidi.h"
#include "balloon.h"
#include "cryptpass.h"



#endif // __COMPROP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\ddxv.h ===
#ifndef _DDXV_H_
#define _DDXV_H_

void EditShowBalloon(HWND hwnd, LPCTSTR txt);
void EditShowBalloon(HWND hwnd, HINSTANCE hInst, UINT ids);
void EditHideBalloon(void);
BOOL IsValidFolderPath(HWND hwnd,LPCTSTR value,BOOL local);
BOOL IsValidFilePath(HWND hwnd,LPCTSTR value,BOOL local);
BOOL IsValidUNCFolderPath(HWND hwnd,LPCTSTR value);
BOOL IsValidPath(LPCTSTR lpFileName);
BOOL IsValidName(LPCTSTR lpFileName);

#endif // _DDXV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\ddxv.cpp ===
#include "stdafx.h"
#include "common.h"
#include "balloon.h"
#include "strfn.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
#define new DEBUG_NEW

void _EXPORT 
EditShowBalloon(HWND hwnd, LPCTSTR txt)
{
    Edit_ShowBalloonTipHandler(hwnd, (LPCTSTR) txt);
}

void _EXPORT
EditShowBalloon(HWND hwnd, HINSTANCE hInst, UINT ids)
{
	if (ids != 0)
	{
		CString txt;
		if (txt.LoadString(hInst,ids))
		{
			EditShowBalloon(hwnd, (LPCTSTR) txt);
		}
	}
}

void _EXPORT EditHideBalloon(void)
{
	Edit_HideBalloonTipHandler();
}

BOOL _EXPORT IsValidFolderPath(
    HWND hwnd,
    LPCTSTR value,
    BOOL local
    )
{
    BOOL bReturn = TRUE;
    TCHAR expanded[_MAX_PATH];
    ExpandEnvironmentStrings(value, expanded, _MAX_PATH);
	int ids = 0;
	do
	{
		if (!PathIsValid(expanded))
		{
			ids = IDS_ERR_INVALID_PATH;
			break;
		}
		if (!IsDevicePath(expanded))
		{
			if (PathIsUNCServerShare(expanded) || PathIsUNCServer(expanded))
			{
				ids = IDS_ERR_BAD_PATH;
				break;
			}
			if (PathIsRelative(expanded))
			{
				ids = IDS_ERR_BAD_PATH;
				break;
			}
			if (local)
			{
				if (!PathIsDirectory(expanded))
				{
					ids = IDS_ERR_PATH_NOT_FOUND;
					break;
				}
			}
		}
	}
	while (FALSE);

    if (ids != 0)
    {
        bReturn = FALSE;
	    EditShowBalloon(hwnd,_Module.GetResourceInstance(),ids);
    }

    return bReturn;
}


BOOL _EXPORT IsValidFilePath(
    HWND hwnd,
    LPCTSTR value,
    BOOL local
    )
{
    BOOL bReturn = TRUE;
    TCHAR expanded[_MAX_PATH];
    ExpandEnvironmentStrings(value, expanded, _MAX_PATH);
	int ids = 0;
    do
    {
        if (!PathIsValid(expanded))
        {
		    ids = IDS_ERR_INVALID_PATH;
            break;
        }
		if (!IsDevicePath(expanded))
		{
			if (PathIsUNCServerShare(expanded) || PathIsUNCServer(expanded))
			{
				ids = IDS_ERR_BAD_PATH;
				break;
			}
			if (PathIsRelative(expanded))
			{
				ids = IDS_ERR_BAD_PATH;
				break;
			}
			if (local)
			{
				if (PathIsDirectory(expanded))
				{
					ids = IDS_ERR_FILE_NOT_FOUND;
					break;
				}
				if (!PathFileExists(expanded))
				{
					ids = IDS_ERR_FILE_NOT_FOUND;
					break;
				}
			}
		}
    }
    while (FALSE);

    if (ids != 0)
    {
        bReturn = FALSE;
	    EditShowBalloon(hwnd,_Module.GetResourceInstance(),ids);
    }

    return bReturn;
}


BOOL _EXPORT IsValidUNCFolderPath(
    HWND hwnd,
    LPCTSTR value
    )
{
    BOOL bReturn = TRUE;
	int ids = 0;
    do
    {
        if (!PathIsValid(value))
        {
            ids = IDS_ERR_INVALID_PATH;
            break;
        }
        // PathIsUNCServer doesn't catch "\\". We are expecting share here.
        if (!PathIsUNC(value) || PathIsUNCServer(value) || lstrlen(value) == 2)
        {
		    ids = IDS_BAD_UNC_PATH;
            break;
        }
    }
    while (FALSE);
    if (ids != 0)
    {
        bReturn = FALSE;
	    EditShowBalloon(hwnd,_Module.GetResourceInstance(),ids);
    }

    return bReturn;
}

BOOL _EXPORT IsValidPath(LPCTSTR lpFileName)
{
	while ((*lpFileName != _T('?'))
			&& (*lpFileName != _T('*'))
			&& (*lpFileName != _T('"'))
			&& (*lpFileName != _T('<'))
			&& (*lpFileName != _T('>'))
			&& (*lpFileName != _T('|'))
			&& (*lpFileName != _T('/'))
            && (*lpFileName != _T(','))
			&& (*lpFileName != _T('\0')))
    {
		lpFileName++;
    }
	
	if (*lpFileName != '\0')
		return FALSE;

  return TRUE;
}

BOOL _EXPORT IsValidName(LPCTSTR lpFileName)
{
	while ((*lpFileName != _T('?'))
			&& (*lpFileName != _T('\\'))
			&& (*lpFileName != _T('*'))
			&& (*lpFileName != _T('"'))
			&& (*lpFileName != _T('<'))
			&& (*lpFileName != _T('>'))
			&& (*lpFileName != _T('|'))
			&& (*lpFileName != _T('/'))
			&& (*lpFileName != _T(':'))
			&& (*lpFileName != _T('\0')))
    {
		lpFileName++;
    }
	
	if (*lpFileName != '\0')
		return FALSE;

  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\debugatl.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :
        debugafx.cpp

   Abstract:
        Debugging routines using AFX/MFC extensions

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
        3/20/2000    sergeia        Made this compatible to ATL, not MFC
--*/



//
// Include Files
//
#include "stdafx.h"
#include "common.h"

#if defined(_DEBUG) || DBG

int 
IISUIFireAssert(
    const char * filename,
    const char * timestamp,
    int linenum,
    const char * expr
    )
{
    char sz[4096];
    char * pch = sz;

    pch += wsprintfA(pch, 
        "-------------------------------------------------------------------------------\n"
        "ASSERT FAILURE!\n"
        "-------------------------------------------------------------------------------\n"
        "File:\t\t%s\n"
        "Line:\t\t%u\n"
        "Time Stamp:\t%s\n"
        "-------------------------------------------------------------------------------\n",
        filename, linenum, timestamp
        );
        
    if (expr)
    {
        wsprintfA(pch, "Expression:\t%s\n"
        "-------------------------------------------------------------------------------\n",
        expr
        );
    } 

    TRACEEOL(sz);

    int nReturn = MessageBoxA(
        NULL, 
        sz, 
        "ASSERT FAILURE!", 
        MB_ABORTRETRYIGNORE | MB_DEFBUTTON1 | MB_ICONHAND
        );
    
    if (nReturn == IDABORT)
    {
        exit(-1);
    }
    
    //
    // Return 1 to break, 0 to ignore
    //
    return (nReturn == IDRETRY);
}


#endif // _DEBUG || DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\guid.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        guid.cpp

   Abstract:

        Initialization as required by initguid

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager (cluster edition)

   Revision History:

--*/

//
// Include Files
//
#include <stdafx.h>
#include <winsvc.h>

#include <objbase.h>
#include <initguid.h>

#include <iwamreg.h>
#include <iadmw.h>
#include <iisrsta.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\iisdebug.cpp ===
#include "stdafx.h"
#include "common.h"
#include "iisdebug.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
#define new DEBUG_NEW

INT g_iDebugOutputLevel = 0;

void GetOutputDebugFlag(void)
{
    DWORD rc, err, size, type;
    HKEY  hkey;
    err = RegOpenKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\InetMgr"), &hkey);
    if (err != ERROR_SUCCESS) {return;}
    size = sizeof(DWORD);
    err = RegQueryValueEx(hkey,_T("OutputDebugFlag"),0,&type,(LPBYTE)&rc,&size);
    if (err != ERROR_SUCCESS || type != REG_DWORD) {rc = 0;}
    RegCloseKey(hkey);

	if (rc < 0xffffffff)
	{
		g_iDebugOutputLevel = rc;
	}
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\debugatl.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        debugafx.h

   Abstract:

        Debugging routines using ATL extensions

   Author:

        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:
        3/20/2000    sergeia        Made this compatible to ATL, not MFC

--*/
#ifndef _DEBUGATL_H
#define _DEBUGATL_H

#if defined(_DEBUG) || DBG

    #undef ATLASSERT
    #undef ASSERT
    #undef _ASSERTE
    #undef VERIFY

    #define _ASSERTE(expr)\
            do { if (!(expr) &&\
                    (IISUIFireAssert(__FILE__, __TIMESTAMP__, __LINE__, #expr)==1))\
                 DebugBreak(); } while (0)

    #define ASSERT(expr)    _ASSERTE(expr)

    #define VERIFY(expr)    _ASSERTE(expr)
    #define ATLASSERT(expr) _ASSERTE(expr)

    #define ASSERT_PTR(ptr)                 _ASSERTE(ptr != NULL);
    #define ASSERT_READ_PTR(ptr)            _ASSERTE(ptr != NULL && !IsBadReadPtr(ptr, sizeof(*ptr)));
    #define ASSERT_READ_PTR2(ptr, cb)       _ASSERTE(ptr != NULL && !IsBadReadPtr(ptr, cb));
    #define ASSERT_WRITE_PTR(ptr)           _ASSERTE(ptr != NULL && !IsBadWritePtr(ptr, sizeof(*ptr)));
    #define ASSERT_WRITE_PTR2(ptr, cb)      _ASSERTE(ptr != NULL && !IsBadWritePtr(ptr, cb));
    #define ASSERT_READ_WRITE_PTR(ptr)      ASSERT_READ_PTR(ptr); ASSERT_WRITE_PTR(ptr);
    #define ASSERT_READ_WRITE_PTR2(ptr, cb) ASSERT_READ_PTR2(ptr, cb); && ASSERT_WRITE_PTR2(ptr, cb);
    #define ASSERT_MSG(msg)\
            do { if (IISUIFireAssert(__FILE__, __TIMESTAMP__, __LINE__, msg)==1)\
                 DebugBreak(); } while (0)

    int _EXPORT
    IISUIFireAssert(
        const char * filename,
        const char * timestamp,
        int linenum,
        const char * expr
        );

#else
    //
    // Retail
    //
    #undef ATLASSERT
    #undef ASSERT
    #undef VERIFY

    #define ATLASSERT
    #define ASSERT
    #define VERIFY(exp)    (exp)
    #define ASSERT_PTR(ptr)           
    #define ASSERT_READ_PTR(ptr)
    #define ASSERT_READ_PTR2(ptr, cb)
    #define ASSERT_WRITE_PTR(ptr)
    #define ASSERT_WRITE_PTR2(ptr, cb)
    #define ASSERT_READ_WRITE_PTR(ptr)
    #define ASSERT_READ_WRITE_PTR2(ptr, cb)
    #define ASSERT_MSG(msg)                 

#endif // _DEBUG || DBG


#ifndef TRACE
   #define TRACE                   ATLTRACE
#endif

#ifndef TRACE0
  #ifdef _DEBUG
    #define TRACE0(fmt) TRACE(fmt)
    #define TRACE1(fmt, a1) TRACE(fmt, a1)
    #define TRACE2(fmt, a1, a2) TRACE(fmt, a1, a2)
    #define TRACE3(fmt, a1, a2, a3) TRACE(fmt, a1, a2, a3)
    #define TRACE4(fmt, a1, a2, a3, a4) TRACE(fmt, a1, a2, a3, a4)
  #else // _DEBUG
    #define TRACE0(fmt)
    #define TRACE1(fmt, a1)
    #define TRACE2(fmt, a1, a2)
    #define TRACE3(fmt, a1, a2, a3)
    #define TRACE4(fmt, a1, a2, a3, a4)
  #endif // _DEBUG
#endif // TRACE0

#if defined(_DEBUG) || DBG
   #define TRACEEOLID(msg)\
      do {TRACE("%s %d %s\n", __FILE__, __LINE__, msg); } while (FALSE)
   #define TRACEEOLERR(err,x) { if (err) TRACEEOLID(x) }
   #define TRACEEOL(msg)\
       do {TRACE("%s\n", msg);} while (FALSE)
#else
   #define TRACEEOLID(msg)
   #define TRACEEOLERR(err,x)
   #define TRACEEOL(msg)
#endif

#define TRACE_RETURN(msg, err) TRACEEOLID(msg); return err;
#define TRACE_NOTIMPL(msg)     TRACE_RETURN(msg, E_NOTIMPL);
#define TRACE_NOINTERFACE(msg) TRACE_RETURN(msg, E_NOINTERFACE);
#define TRACE_UNEXPECTED(msg)  TRACE_RETURN(msg, E_UNEXPECTED);
#define TRACE_POINTER(msg)     TRACE_RETURN(msg, E_POINTER);

#endif // _DEBUGATL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\error.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        msg.cpp

   Abstract:

        Message Functions

   Author:

        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager (cluster edition)

   Revision History:
        2/18/2000    sergeia     removed dependency on MFC

--*/

#include "stdafx.h"
#include <lmerr.h>
#include <lmcons.h>
#include "common.h"

extern CComModule _Module;

#ifdef _MT

    //
    // Thread protected stuff
    //
    #define RaiseThreadProtection() \
        do {\
            EnterCriticalSection(&_csSect);\
        } while(0)
    #define LowerThreadProtection() \
        do {\
            LeaveCriticalSection(&_csSect);\
        } while (0)

    static CRITICAL_SECTION _csSect;

#else

    #pragma message("Module is not thread-safe.")

    #define RaiseThreadProtection()
    #define LowerThreadProtection()

#endif // _MT

BOOL
InitErrorFunctionality()
/*++

Routine Description:

    Initialize CError class, and allocate static objects

Arguments:

    None:

Return Value:

    TRUE for success, FALSE for failure

--*/
{
#ifdef _MT
   InitializeCriticalSection(&_csSect);
#endif // _MT

    BOOL fOK = CError::AllocateStatics();

    if (fOK)
    {
//        REGISTER_FACILITY(FACILITY_APPSERVER, "iisui2.dll");
    }

    return fOK;
}



void
TerminateErrorFunctionality()
/*++

Routine Description:

    De-initialize CError class, freeing up static objects

Arguments:

    None

Return Value:

    None

--*/
{
    CError::DeAllocateStatics();

#ifdef _MT
    DeleteCriticalSection(&_csSect);
#endif // _MT
}

//
// Static Initialization:
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

const TCHAR g_cszNull[] = _T("(Null)");
const TCHAR CError::s_chEscape = _T('%');        // Error text escape
const TCHAR CError::s_chEscText = _T('h');       // Escape code for text
const TCHAR CError::s_chEscNumber = _T('H');     // Escape code for error code
LPCTSTR CError::s_cszLMDLL = _T("netmsg.dll");   // LM Error File
LPCTSTR CError::s_cszWSDLL = _T("iisui2.dll");   // Winsock error file
LPCTSTR CError::s_cszFacility[] = 
{
    /* FACILITY_NULL        */ NULL,
    /* FACILITY_RPC         */ NULL,
    /* FACILITY_DISPATCH    */ NULL,            
    /* FACILITY_STORAGE     */ NULL,
    /* FACILITY_ITF         */ NULL,
    /* FACILITY_DS          */ NULL,
    /* 6                    */ NULL,
    /* FACILITY_WIN32       */ NULL,
    /* FACILITY_WINDOWS     */ NULL,
    /* FACILITY_SSPI        */ NULL,
    /* FACILITY_CONTROL     */ NULL,
    /* FACILITY_CERT        */ NULL,
    /* FACILITY_INTERNET    */ _T("metadata.dll"),
    /* FACILITY_MEDIASERVER */ NULL,
    /* FACILITY_MSMQ        */ NULL,
    /* FACILITY_SETUPAPI    */ NULL,
    /* FACILITY_SCARD       */ NULL,
    /* 17 (MTX)             */ _T("iisui2.dll"),
};

HRESULT CError::s_cdwMinLMErr = NERR_BASE; 
HRESULT CError::s_cdwMaxLMErr = MAX_NERR;
HRESULT CError::s_cdwMinWSErr = WSABASEERR;    
HRESULT CError::s_cdwMaxWSErr = WSABASEERR + 2000;    
DWORD   CError::s_cdwFacilities = (sizeof(CError::s_cszFacility)\
    / sizeof(CError::s_cszFacility[0]));

//
// Allocated objects
//
CString * CError::s_pstrDefError;
CString * CError::s_pstrDefSuccs;
CFacilityMap * CError::s_pmapFacilities;
BOOL CError::s_fAllocated = FALSE;



/* protected */
/* static */
BOOL
CError::AllocateStatics()
/*++

Routine Description:

    Allocate static objects

Arguments:

    None

Return Value:

    TRUE for successfull allocation, FALSE otherwise

--*/
{
    RaiseThreadProtection();

    if (!AreStaticsAllocated())
    {
        try
        {
            CError::s_pstrDefError   = new CString;
            CError::s_pstrDefSuccs   = new CString(_T("0x%08lx"));
            CError::s_pmapFacilities = new CFacilityMap;
            s_fAllocated = TRUE;

            if (!CError::s_pstrDefError->LoadString(_Module.GetResourceInstance(), IDS_NO_MESSAGE))
            {
                //
                // Just in case we didn't load this message from the resources
                //
                ASSERT_MSG("Unable to load resource message");
                *s_pstrDefError = _T("Error Code: 0x%08lx");
            }
        }
        catch(std::bad_alloc)
        {
            ASSERT_MSG("Initialization Failed");
        }
    }

    LowerThreadProtection();

    return AreStaticsAllocated();
}



/* protected */
/* static */
void
CError::DeAllocateStatics()
/*++

Routine Description:

    Clean up allocations

Arguments:

    N/A

Return Value:

    N/A

--*/
{

    RaiseThreadProtection();

    if (AreStaticsAllocated())
    {
        SAFE_DELETE(CError::s_pstrDefError);
        SAFE_DELETE(CError::s_pstrDefSuccs);
        SAFE_DELETE(CError::s_pmapFacilities);

        s_fAllocated = FALSE;
    }

    LowerThreadProtection();
}


/*static*/ BOOL 
CError::AreStaticsAllocated() 
{ 
   return s_fAllocated; 
}

/* static */
HRESULT 
CError::CvtToInternalFormat(
    IN HRESULT hrCode
    )
/*++

Routine Description:

    Convert WIN32 or HRESULT code to internal (HRESULT) format.

Arguments:

    DWORD dwCode        Error code

Return Value:

    HRESULT

Notes:

    HRESULTS are left as is.  Lanman and Winsock errors are converted
    to HRESULTS using private facility codes.

--*/
{
    if (IS_HRESULT(hrCode))
    {
        return hrCode;
    }

    if(hrCode >= s_cdwMinLMErr && hrCode <= s_cdwMaxLMErr)
    {
        return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_LANMAN, (DWORD)hrCode);
    }

    if (hrCode >= s_cdwMinWSErr && hrCode <= s_cdwMaxWSErr)
    {
        return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WINSOCK, (DWORD)hrCode);
    }

    return HResult(hrCode);    
}



/* static */ 
void 
CError::RegisterFacility(
    IN DWORD dwFacility,
    IN LPCSTR lpDLL         OPTIONAL
    )
/*++

Routine Description:

    Register a DLL for a given facility code.  Use NULL to unregister
    the DLL name.

Arguments:

    DWORD dwFacility : Facility code
    LPCSTR lpDLL     : DLL Name.

Return Value:

    None

--*/
{
    RaiseThreadProtection();

    ASSERT(AreStaticsAllocated());

    if (lpDLL == NULL)
    {
        //
        // Remove the facility
        //
        s_pmapFacilities->erase(dwFacility);
    }
    else
    {
        CString str(lpDLL);

        //
        // Register facility
        //
        s_pmapFacilities->insert(s_pmapFacilities->begin(), 
           CFacilityMap::value_type(dwFacility, str));
    }

    LowerThreadProtection();
}


        
/* static */
LPCTSTR 
CError::FindFacility(
    IN DWORD dwFacility
    )
/*++

Routine Description:

    Determine if a DLL name has been registered for the given facility
    code.

Arguments:

    DWORD dwFacility        : Facility code

Return Value:

    Returns the DLL name, or NULL.

--*/
{
    RaiseThreadProtection();

    ASSERT(AreStaticsAllocated());

    LPCTSTR pRes = NULL;
    CFacilityMap::iterator it = s_pmapFacilities->find(dwFacility);
    if (it != s_pmapFacilities->end())
    {
        pRes = (*it).second;
    }

    LowerThreadProtection();

    return pRes;
}



CError::~CError()
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    N/A

--*/
{
}



const CError & 
CError::Construct(
    IN HRESULT hr
    )
/*++

Routine Description:

    construct with new value.

Arguments:
    
    HRESULT hr : New value, either an HRESULT or a WIN32
                 error code.

Return Value:

    Reference to current object

--*/
{
    ASSERT(AreStaticsAllocated());

    m_hrCode = CvtToInternalFormat(hr);

    return *this;
}



const CError & 
CError::Construct(
    IN const CError & err
    )
/*++

Routine Description:

    Assign new value.

Arguments:
    
    CError & err    : Error code

Return Value:

    Reference to current object

--*/
{
    ASSERT(AreStaticsAllocated());

    m_hrCode = err.m_hrCode;

    return *this;
}



int
CError::MessageBox(
    IN UINT    nType,
    IN UINT    nHelpContext OPTIONAL
    ) const
/*++

Routine Description:

    Display error message in a message box

Arguments:

    HRESULT hrCode       : HRESULT error code
    UINT    nType        : See AfxMessageBox for documentation
    UINT    nHelpContext : See AfxMessageBox for documentation

Return Value:

    AfxMessageBox return code

--*/
{
    CString strMsg;
    TextFromHRESULT(strMsg);
    return ::MessageBox(::GetAncestor(::GetFocus(), GA_ROOT), strMsg, NULL, nType);
}




//
// Extend CString just to get at FormatV publically
//
class CStringEx : public CString
{
public:
    void FormatV(LPCTSTR lpszFormat, va_list argList)
    {
        CString::FormatV(lpszFormat, argList);
    }
};



int 
CError::MessageBoxFormat(
    IN HINSTANCE hInst,
    IN UINT nFmt,
    IN UINT nType,
    IN UINT nHelpContext,
    ...
    ) const
/*++

Routine Description:

    Display formatted error message in messagebox.  The format
    string (given as a resource ID) is a normal printf-style
    string, with the additional parameter of %h, which takes
    the text equivalent of the error message, or %H, which takes
    the error return code itself.

Arguments:

    UINT    nFmt         : Resource format
    UINT    nType        : See AfxMessageBox for documentation
    UINT    nHelpContext : See AfxMessageBox for documentation
    ...                    More as needed for sprintf

Return Value:

    AfxMessageBox return code
    
--*/
{
    CString strFmt;
    CStringEx strMsg;

    strFmt.LoadString(hInst, nFmt);

    //
    // First expand the error
    //
    TextFromHRESULTExpand(strFmt);

    va_list marker;
    va_start(marker, nHelpContext);
    strMsg.FormatV(strFmt, marker);
    va_end(marker);

    return ::MessageBox(::GetFocus(), strMsg, NULL, nType);
}


BOOL 
CError::MessageBoxOnFailure(
    IN UINT nType,
    IN UINT nHelpContext    OPTIONAL
    ) const
/*++

Routine Description:

    Display message box if the current error is a failure
    condition, else do nothing

Arguments:

    UINT    nType        : See AfxMessageBox for documentation
    UINT    nHelpContext : See AfxMessageBox for documentation

Return Value:

    TRUE if a messagebox was shown, FALSE otherwise

--*/
{
    if (Failed())
    {
        MessageBox(nType, nHelpContext);
        return TRUE;
    }

    return FALSE;
}



BOOL 
CError::HasOverride(
    OUT UINT * pnMessage        OPTIONAL
    ) const
/*++

Routine Description:

    Check to see if a given HRESULT has an override

Arguments:

    HRESULT hrCode              : HRESULT to check for
    UINT * pnMessage            : Optionally returns the override

Return Value:

    TRUE if there is an override, FALSE if there is not.

--*/
{
   ASSERT(AreStaticsAllocated());

   HRESULT hrCode = CvtToInternalFormat(m_hrCode);
   if (!mapOverrides.empty())
   {
       COverridesMap::const_iterator it = mapOverrides.find(hrCode);
       if (it != mapOverrides.end())
       {
           if (pnMessage != NULL)
              *pnMessage = (*it).second;
           return TRUE;
       }
   }
   return FALSE;
}



UINT
CError::AddOverride(
    IN HRESULT    hrCode,
    IN UINT       nMessage
    )
/*++

Routine Description:

    Add an override for a specific HRESULT.

Arguments:

    HRESULT    hrCode       : HRESULT to override
    UINT       nMessage     : New message, or -1 to remove override

Return Value:

    The previous override, or -1

--*/
{
    ASSERT(AreStaticsAllocated());

    UINT nPrev;
    hrCode = CvtToInternalFormat(hrCode);

    //
    // Fetch the current override
    //
    COverridesMap::iterator it = mapOverrides.find(hrCode);
    nPrev = (it == mapOverrides.end()) ? REMOVE_OVERRIDE : (*it).second;

    if (nMessage == REMOVE_OVERRIDE)
    {
        //
        // Remove the override
        //
        mapOverrides.erase(hrCode);
    }
    else
    {
        //
        // Set new override
        //
        mapOverrides[hrCode] = nMessage;
    }

    return nPrev;
}



void
CError::RemoveAllOverrides()
/*++

Routine Description:

    Remove all overrides

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT(AreStaticsAllocated());
    mapOverrides.clear();
}



HRESULT
CError::TextFromHRESULT(
    OUT LPTSTR  szBuffer,
    OUT DWORD   cchBuffer
    ) const
/*++

Routine Description:

    Get text from the given HRESULT.  Based on the range that the HRESULT
    falls in and the facility code, find the location of the message,
    and fetch it.

Arguments:

    HRESULT hrCode      HRESULT or (DWORD WIN32 error) whose message to get
    LPTSTR  szBuffer    Buffer to load message text into
    DWORD   cchBuffer   Size of buffer in characters.

Return Value:

    HRESULT error code depending on whether the message was
    found.  If the message was not found, some generic message
    is synthesized in the buffer if a buffer is provided.

    ERROR_FILE_NOT_FOUND        No message found
    ERROR_INSUFFICIENT_BUFFER   Buffer is a NULL pointer or too small

--*/
{
    HRESULT hrReturn = ERROR_SUCCESS;

    //
    // First check to see if this message is overridden
    //
    UINT nID;
    HRESULT hrCode = m_hrCode;

    if (HasOverride(&nID))
    {
        //
        // Message overridden.  Load replacement message
        // instead.
        //
        BOOL fSuccess;

        //
        // Attempt to load from calling process first
        //
        if (!(fSuccess = ::LoadString(
            ::GetModuleHandle(NULL), 
            nID, 
            szBuffer, 
            cchBuffer
            )))
        {
            //
            // Try this dll
            //
            fSuccess = ::LoadString(
                _Module.GetResourceInstance(), 
                nID, 
                szBuffer, 
                cchBuffer
                );
        }

        if (fSuccess)
        {
            //
            // Everything ok
            //
            return hrReturn;
        }

        //
        // Message didn't exist, skip the override, and 
        // load as normal.
        //
        TRACE("Couldn't load %d\n", nID);
        ASSERT_MSG("Attempted override failed");
    }

    LPCTSTR lpDll    = NULL;
    HINSTANCE hDll   = NULL;
    DWORD dwFacility = HRESULT_FACILITY(hrCode);
    DWORD dwSeverity = HRESULT_SEVERITY(hrCode);
    DWORD dwCode     = HRESULT_CODE(hrCode);
    BOOL  fSuccess   = Succeeded(hrCode);

    //
    // Strip off meaningless internal facility codes
    //
    if (dwFacility == FACILITY_LANMAN || dwFacility == FACILITY_WINSOCK)
    {
        dwFacility = FACILITY_NULL;
        hrCode   = (HRESULT)dwCode;
    }

    DWORD dwFlags = FORMAT_MESSAGE_IGNORE_INSERTS | 
                    FORMAT_MESSAGE_MAX_WIDTH_MASK;

    //
    // Since we allow both HRESULTS and WIN32 codes to be
    // used here, we can't rely on the private FACILITY code 
    // for lanman and winsock.
    //
    if(hrCode >= s_cdwMinLMErr && hrCode <= s_cdwMaxLMErr)
    {
        //
        // Lanman error
        //
        lpDll = s_cszLMDLL;
    }
    else if (hrCode >= s_cdwMinWSErr && hrCode <= s_cdwMaxWSErr)
    {
        //
        // Winsock error
        //
        lpDll = s_cszWSDLL;
    }
    else
    {
        //
        // Attempt to determine message location from facility code.
        // Check for registered facility first.
        //
        lpDll = FindFacility(dwFacility);

        if (lpDll == NULL)
        {
            if (dwFacility < s_cdwFacilities)
            {
                lpDll = s_cszFacility[dwFacility];
            }
            else
            {
                ASSERT_MSG("Bogus FACILITY code encountered.");
                lpDll = NULL;
            }
        }
    }

    do
    {
        if (szBuffer == NULL || cchBuffer <= 0)
        {
            hrReturn = HResult(ERROR_INSUFFICIENT_BUFFER);
            break;
        }

        if (lpDll)
        {
            //
            // Load message file
            //
            hDll = ::LoadLibraryEx(
                lpDll,
                NULL,
                LOAD_LIBRARY_AS_DATAFILE
                );

            if (hDll == NULL)
            {
                hrReturn = ::GetLastHRESULT();
                break;
            }

            dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
        }
        else
        {
            dwFlags |= FORMAT_MESSAGE_FROM_SYSTEM;
        }

        DWORD dwResult = 0L;
        DWORD dwID = hrCode;
        HINSTANCE hSource = hDll;

        while(!dwResult)
        {
            dwResult = ::FormatMessage(
                dwFlags,
                (LPVOID)hSource,
                dwID,
                0,
                szBuffer,
                cchBuffer,
                NULL
                );

            if (dwResult > 0)
            {
                //
                // Successfully got a message
                //
                hrReturn = ERROR_SUCCESS;
                break;
            } 

            hrReturn = ::GetLastHRESULT();
    
            if (dwID != dwCode && !fSuccess)
            {
                //
                // Try the SCODE portion of the error from win32
                // if this is an error message
                //
                dwID = dwCode;
                hSource = NULL;
                continue;
            }

            //
            // Failed to obtain a message
            //
            hrReturn = HResult(ERROR_FILE_NOT_FOUND);
            break;
        }
    }
    while(FALSE);

    if(hDll != NULL)
    {
        ::FreeLibrary(hDll);
    }

    if (Failed(hrReturn))
    {
        //
        // Unable to find the message, synthesize something with
        // the code in it if there's room (+8 for the number)
        //
        CString & strMsg = (fSuccess ? *s_pstrDefSuccs : *s_pstrDefError);

        if (cchBuffer > (DWORD)strMsg.GetLength() + 8)
        {
            TRACE("Substituting default message for %d\n", (DWORD)m_hrCode);
            wsprintf(szBuffer, (LPCTSTR)strMsg, m_hrCode);
        }
        else
        {
            //
            // Not enough room for message code
            //
            ASSERT_MSG("Buffer too small for default message -- left blank");
            *szBuffer = _T('\0');
        }
    }

    return hrReturn;
}



HRESULT 
CError::TextFromHRESULT(
    OUT CString & strBuffer
    ) const
/*++

Routine Description:

    Similar to the function above, but use a CString

Arguments:

    HRESULT hrCode         HRESULT or (DWORD WIN32 error) whose message to get
    CString & strBuffer    Buffer to load message text into

Return Value:

    HRESULT error code depending on whether the message was
    found.  If the message was not found, some generic message
    is synthesized in the buffer if a buffer is provided.

    ERROR_FILE_NOT_FOUND   No message found

--*/
{
   DWORD cchBuffer = 255;
   HRESULT hr = S_OK;
   LPTSTR p = NULL;

   for (;;)
   {
      p = strBuffer.get_allocator().allocate(cchBuffer, p);
      if (p == NULL)
      {
         return HResult(ERROR_NOT_ENOUGH_MEMORY);
      }

      hr = TextFromHRESULT(p, cchBuffer - 1);
      if (Win32Error(hr) != ERROR_INSUFFICIENT_BUFFER)
      {
         //
         // Done!
         //
         strBuffer.assign(p);
         break;
      }

      //
      // Insufficient buffer, enlarge and try again
      //
      cchBuffer *= 2;
   }
   if (p != NULL)
   {
      strBuffer.get_allocator().deallocate(p, cchBuffer);
   }
   return hr;
}



BOOL
CError::ExpandEscapeCode(
    IN  LPTSTR szBuffer,
    IN  DWORD cchBuffer,
    OUT IN LPTSTR & lp,
    IN  CString & strReplacement,
    OUT HRESULT & hr
    ) const
/*++

Routine Description:

    Expand escape code

Arguments:

    LPTSTR szBuffer             Buffer
    DWORD cchBuffer             Size of buffer
    LPTSTR & lp                 Pointer to escape code
    CString & strReplacement    Message to replace the escape code
    HRESULT & hr                Returns HRESULT in case of failure

Return Value:

    TRUE if the replacement was successful, FALSE otherwise.
    In the case of failure, hr will return an HRESULT.
    In the case of success, lp will be advanced past the
    replacement string.

--*/
{
    //
    // Make sure there's room (account for terminating NULL)
    // Free up 2 spaces for the escape code.
    //
    int cchFmt = lstrlen(szBuffer) - 2;
    int cchReplacement = strReplacement.GetLength();
    int cchRemainder = lstrlen(lp + 2);

    if ((DWORD)(cchReplacement + cchFmt) < cchBuffer)
    {
        //
        // Put it in
        //
        MoveMemory(
            lp + cchReplacement,
            lp + 2,
            (cchRemainder + 1) * sizeof(TCHAR)
            );
        CopyMemory(lp, strReplacement, cchReplacement * sizeof(TCHAR));
        lp += cchReplacement;
        
        return TRUE;
    }

    hr = HResult(ERROR_INSUFFICIENT_BUFFER);

    return FALSE;
}



LPCTSTR 
CError::TextFromHRESULTExpand(
    OUT LPTSTR  szBuffer,
    OUT DWORD   cchBuffer,
    OUT HRESULT * phResult  OPTIONAL
    ) const
/*++

Routine Description:

    Expand %h/%H strings in szBuffer to text from HRESULT,
    or error code respectively within the limits of szBuffer.

Arguments:

    LPTSTR  szBuffer    Buffer to load message text into
    DWORD   cchBuffer   Buffer size in characters
    HRESULT * phResult  Optional return code

Return Value:

    Pointer to string.

--*/
{
    HRESULT hr = S_OK;

    if (szBuffer == NULL || cchBuffer <= 0)
    {
        hr = HResult(ERROR_INSUFFICIENT_BUFFER);
    }
    else
    {
        //
        // Look for the escape sequence
        //
        int cReplacements = 0;
        CString strMessage;
        LPTSTR lp = szBuffer;

        while (*lp)
        {
            if (*lp == s_chEscape)
            {
                switch(*(lp + 1))
                {
                case s_chEscText:
                    //
                    // Replace escape code with text message
                    //
                    hr = TextFromHRESULT(strMessage);

                    if (ExpandEscapeCode(
                        szBuffer,
                        cchBuffer,
                        lp,
                        strMessage,
                        hr
                        ))
                    {
                        ++cReplacements;
                    }
                    break;

                case s_chEscNumber:
                    //
                    // Replace escape code with numeric error code
                    //
                    strMessage.Format(_T("0x%08x"), m_hrCode);

                    if (ExpandEscapeCode(
                        szBuffer,
                        cchBuffer,
                        lp,
                        strMessage,
                        hr
                        ))
                    {
                        ++cReplacements;
                    }
                    break;

                default:
                    //
                    // Regular printf-style escape sequence.
                    //
                    break;
                }
            }

            ++lp;
        }

        if (!cReplacements)
        {
            //
            // Got to the end without finding any escape codes.
            //
            hr = HResult(ERROR_INVALID_PARAMETER);
        }
    }

    if (phResult)
    {
        *phResult = hr;
    }

    return szBuffer;
}



LPCTSTR 
CError::TextFromHRESULTExpand(
    OUT CString & strBuffer
    ) const
/*++

Routine Description:

    Expand %h string in strBuffer to text from HRESULT

Arguments:

    CString & strBuffer Buffer to load message text into

Return Value:

    Pointer to string.

--*/
{
   DWORD cchBuffer = strBuffer.GetLength() + 1024;
   LPTSTR p = NULL;
   for (;;)
   {
      p = strBuffer.get_allocator().allocate(cchBuffer, p);

      if (p != NULL)
      {
         HRESULT hr;

         TextFromHRESULTExpand(p, cchBuffer - 1, &hr);

         if (Win32Error(hr) != ERROR_INSUFFICIENT_BUFFER)
         {
            //
            // Done!
            //
            strBuffer.assign(p);
            break;
         }

         //
         // Insufficient buffer, enlarge and try again
         //
         cchBuffer *= 2;
      }
   }
   if (p != NULL)
   {
      strBuffer.get_allocator().deallocate(p, cchBuffer);
   }

   return strBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\filechooser.h ===
//
// FileChooser.h
//
#ifndef _FILE_CHOOSER_H
#define _FILE_CHOOSER_H

#pragma warning(disable : 4275)

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CFileChooser;
class CFileChooserEdit;

class CFilterEntry
{
public:
   CFilterEntry() 
   {
   }
   CFilterEntry(LPCTSTR text, LPCTSTR ext)
      : m_text(text), m_ext(ext)
   {
   }
   CString m_text;
   CString m_ext;
};

#define FC_UNDEFINED             0x00000000
#define FC_FORWRITE              0x00000001
#define FC_AUTOCOMPLETION        0x00000002
// Put "*.ext" to edit initially if no file with default
// extensions was found in the initial directory
#define FC_WILDCARD_DEFAULT      0x00000004
// Set "description (*.ext)" to FileDialog filter
#define FC_WILDCARD_DESC         0x00000008
// prefill the path edit with default file name
#define FC_PREPARE_DEFAULT       0x00000010
// supress file existance check
#define FC_PATH_CHECK            0x00000020
// Check if entered filename with any of default extensions
// are available in the current directory. If yes, choose it
#define FC_CHECK_FILENAME_ONLY   0x00000040
#define FC_DIRECTORY_ONLY        0x00000080
#define FC_HIDEREADONLY          0x00000100
#define FC_COMMANDLINE           0x00000200

#define FC_DEFAULT\
   FC_AUTOCOMPLETION | FC_WILDCARD_DESC | FC_WILDCARD_DEFAULT | FC_PATH_CHECK
#define FC_DEFAULT_READ\
   FC_DEFAULT | FC_HIDEREADONLY
#define FC_DEFAULT_WRITE\
   FC_DEFAULT | FC_FORWRITE

#define FC_SUCCESS               0x00000000
#define FC_FILE_DOES_NOT_EXIST   0x00000001
#define FC_FILENAME_IS_DIRECTORY 0x00000002
#define FC_FILENAME_IS_FILE      0x00000003
#define FC_TEXT_IS_INVALID       0x00000004
#define FC_WRONG_FORMAT          0x00000005
#define FC_NO_CLOSING_QUOTE      0x00000006

class _EXPORT CFileChooser : 
   public CWindowImpl<CFileChooser>
{
   friend class CFileChooserButton;
public:
   CFileChooser()
      :  m_pParent(NULL),
         m_bDoReplaceFile(FALSE),
         m_bEditDirty(FALSE),
         m_bTextValid(TRUE),
         m_bDialogActive(FALSE),
         m_bInternalChange(FALSE),
         m_dwStyle(FC_UNDEFINED),
         m_ofn_Flags(0),
         m_edit(this, 1),
         m_button(this, 2)
   {
   }
   ~CFileChooser()
   {
   }

BEGIN_MSG_MAP(CFileChooser)
ALT_MSG_MAP(1)
    MESSAGE_HANDLER(WM_CHAR, OnEditChar)
	MESSAGE_HANDLER(WM_SETFOCUS, OnEditSetFocus)
	MESSAGE_HANDLER(WM_KILLFOCUS, OnEditKillFocus)
    REFLECT_NOTIFICATIONS()
ALT_MSG_MAP(2)
    MESSAGE_HANDLER(BM_SETSTATE, OnSetBrowseState)
END_MSG_MAP()

   BOOL Init(CWindow * pParent, DWORD dwStyle, UINT idEdit, UINT idButton);
   DWORD GetStyle() const
   {
      return m_dwStyle;
   }
   DWORD SetStyle(DWORD dwStyle)
   {
      DWORD dw = m_dwStyle;
      m_dwStyle = dwStyle;
      return dw;
   }
   BOOL StyleBitSet(DWORD bit)
   {
      return 0 != (m_dwStyle & bit);
   }
   BOOL OpenForRead()
   {
      return !StyleBitSet(FC_FORWRITE);
   }
   void AddStyle(DWORD dwStyle)
   {
      m_dwStyle |= dwStyle;
   }
   void RemoveStyle(DWORD dwStyle)
   {
      m_dwStyle &= ~dwStyle;
   }
   void SetOfnFlags(DWORD flags)
   {
      m_ofn_Flags = flags;
   }
   DWORD GetOfnFlags()
   {
      return m_ofn_Flags;
   }
   void SetDialogTitle(LPCTSTR strTitle)
   {
      m_strTitle = strTitle;
   }
   DWORD GetFileName(CString& str);
   void SetPath(const CString& str);
   void AddExtension(LPCTSTR text, LPCTSTR ext);
   void AddExtension(HINSTANCE hInst, UINT idText, UINT idExt);
   int BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam);
   void OnEditChange();
   void OnPaste();

protected:
   void OnBrowseBtn();
   void CreateFilter(CString& strFilter, CString& strDefExt);
   void CreateDefaultPathForRead();
   BOOL BrowseForFile(CString& strPath, CString& strFile);
   BOOL BrowseForFolder(CString& strPath);
   LRESULT OnEditChar(UINT nMsg, WPARAM, LPARAM, BOOL&);
   LRESULT OnEditSetFocus(UINT nMsg, WPARAM, LPARAM, BOOL&);
   LRESULT OnEditKillFocus(UINT nMsg, WPARAM, LPARAM, BOOL&);
   LRESULT OnSetBrowseState(UINT nMsg, WPARAM, LPARAM, BOOL&);
//   LRESULT OnEditPaste(UINT nMsg, WPARAM, LPARAM, BOOL&);
   LRESULT OnEditCommand(UINT nMsg, WPARAM, LPARAM, BOOL&);
   BOOL HasEditFocus();
   BOOL IsValidChar(UINT nChar, BOOL bExcludeWildcards = TRUE);
   BOOL IsValidPath(LPCTSTR);
   void SetCompactedPath(LPCTSTR path);
   void SetPathToEdit(LPCTSTR path);
   int ExtractPath(LPTSTR path);
   int ExtractArgs(LPTSTR buf);
   void GetText(LPTSTR buf);
   int GetFilterIndex(const CString& fileName);

protected:
   DWORD m_ofn_Flags;
   CWindow * m_pParent;
   CContainedWindow m_edit;
   CContainedWindow m_button;
   DWORD m_dwStyle;
   CString m_strPath;
   LPTSTR m_pPathTemp;
   CString m_strTitle;
   std::list<CFilterEntry> m_ext;
   BOOL m_bDoReplaceFile;
   BOOL m_bEditDirty;
   BOOL m_bTextValid;
   BOOL m_bDialogActive;
   BOOL m_bInternalChange;
};

#endif   //_FILE_CHOOSER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\filechooser.cpp ===
//
// FileChooser.cpp
//
#include "stdafx.h"
#include "common.h"
#include "FileChooser.h"
#include <Shlwapi.h>
#include <shellapi.h>
#include <ShlObj.h>
#include <CommDlg.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

const TCHAR QuotMark = _T('\"');
const TCHAR AllExt[] = _T(".*");

//---------------------

BOOL 
CFileChooser::Init(CWindow * pParent, DWORD dwStyle, UINT idEdit, UINT idButton)
{
   ASSERT(NULL != pParent);
   ASSERT(NULL != pParent->GetDlgItem(idEdit));
   ASSERT(NULL != pParent->GetDlgItem(idButton));
   
   m_pParent = pParent;
   SetStyle(dwStyle);

   VERIFY(m_edit.SubclassWindow(pParent->GetDlgItem(idEdit)));
   if (StyleBitSet(FC_AUTOCOMPLETION))
   {
      SHAutoComplete(pParent->GetDlgItem(idEdit), SHACF_FILESYSTEM);
   }

   VERIFY(m_button.SubclassWindow(pParent->GetDlgItem(idButton)));

   return FALSE;
}

// External SetPath
void 
CFileChooser::SetPath(const CString& path)
{
   m_strPath = path;
   if (OpenForRead() && StyleBitSet(FC_PREPARE_DEFAULT))
      CreateDefaultPathForRead();
   SetPathToEdit(m_strPath);
   m_bEditDirty = FALSE;
}

BOOL 
CFileChooser::HasEditFocus()
{
   return GetFocus() == m_edit.m_hWnd;
}

void 
CFileChooser::SetPathToEdit(LPCTSTR path)
{
   if (HasEditFocus())
   {
      m_edit.SetWindowText(path);
   }
   else
   {
      SetCompactedPath(path);
   }
}

void 
CFileChooser::CreateDefaultPathForRead()
{
	if (!PathFileExists(m_strPath))
	{
		// try to find first file with the first extension
      // from the extensions list
      BOOL bDefaultSet = FALSE;
      BOOL bPathEmpty = m_strPath.IsEmpty();
      TCHAR find_str[MAX_PATH];
		WIN32_FIND_DATA find_data;
      if (bPathEmpty)
      {
         GetCurrentDirectory(MAX_PATH, find_str);
         m_strPath = find_str;
      }
      else
      {
         StrCpy(find_str, m_strPath);
         if (!PathIsDirectory(find_str))
         {
		      PathRemoveFileSpec(find_str);
         }
      }
	  PathAppend(find_str, _T("*"));
      std::list<CFilterEntry>::iterator it;
      for (it = m_ext.begin(); it != m_ext.end(); it++)
      {
         CString ext = (*it).m_ext;
		   PathAddExtension(find_str, ext);
		   HANDLE hFind = FindFirstFile(find_str, &find_data);
		   if (	hFind != INVALID_HANDLE_VALUE 
			   && (find_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0
			   )
		   {
            if (!bPathEmpty)
            {
               TCHAR buf[MAX_PATH];
               StrCpy(buf, m_strPath);
			      PathRemoveFileSpec(buf);
               m_strPath = buf;
            }
			   m_strPath += find_data.cFileName;
			   FindClose(hFind);
            bDefaultSet = TRUE;
            break;
		   }
      }
      if (!bDefaultSet && StyleBitSet(FC_WILDCARD_DEFAULT))
      {
	     // if nothing found, just attach *.ext to the path
         // find_str was prepared before as xxx\*.
		 m_strPath = find_str;
         if (!m_ext.empty())
         {
            m_strPath += m_ext.front().m_ext;
         }
         else
         {
            m_strPath += _T("*");
         }
      }
    }
}

BOOL 
CFileChooser::IsValidChar(UINT nChar, BOOL bExcludeWildcards)
{
   switch (PathGetCharType((TCHAR)nChar))
   {
   case GCT_INVALID:
      return FALSE;
   case GCT_WILD:
      return !bExcludeWildcards;
   case GCT_LFNCHAR:
   case GCT_SEPARATOR:
   case GCT_SHORTCHAR:
      break;
   }
   return TRUE;
}

BOOL 
CFileChooser::IsValidPath(LPCTSTR path)
{
   UINT len = lstrlen(path);
   BOOL bRes = TRUE;
   for (UINT i = 0; i < len; i++)
   {
      TCHAR c = path[i];
      if (!IsValidChar(c))
      {
         bRes = FALSE;
         break;
      }
   }
   return bRes;
}

// Character filtering routine for the edit control.
// Returns TRUE if character should be passed to the CEdit
//
LRESULT 
CFileChooser::OnEditChar(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
   UINT nChar = wParam;
   UINT nRepCount = (UINT)lParam & 0xFFFF;
   UINT nFlags = (UINT)((lParam & 0xFFFF0000) >> 16);
   bHandled = TRUE;
   if (IsValidChar(nChar))
   {
       bHandled = FALSE;
   }
   else
   {
      switch (nChar)
      {
      case VK_DELETE:
      case VK_BACK:
      case _T('/'):
         bHandled = FALSE;
         break;
      case _T('"'):
         bHandled = !StyleBitSet(FC_COMMANDLINE);
         break;
      }
   }
   m_bEditDirty = !bHandled;
   return 0;
}

// Text was pasted to edit control
void 
CFileChooser::OnPaste()
{
   TCHAR buf[MAX_PATH];
   int len = m_edit.GetWindowText(buf, MAX_PATH);
   for (int i = 0; i < len || IsValidChar(buf[i]); i++)
      ;
   if (i < len)
   {
      m_edit.SendMessage(EM_SETSEL, i, len - 1);
      m_bTextValid = FALSE;
      m_bEditDirty = FALSE;
   }
   else
   {
      m_strPath = buf;
      SetPathToEdit(buf);
      m_bEditDirty = TRUE;
   }
}

void 
CFileChooser::OnEditChange()
{
	if (!m_bInternalChange)
    {
		m_bEditDirty = TRUE;
    }
}

LRESULT 
CFileChooser::OnEditSetFocus(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    m_bInternalChange = TRUE;
    m_edit.SetWindowText(m_strPath);
    m_bInternalChange = FALSE;
    bHandled = FALSE;
    return 0;
}

LRESULT 
CFileChooser::OnEditKillFocus(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
   // update internal string buffer with path
   TCHAR buf[MAX_PATH];
   ZeroMemory(buf, MAX_PATH);
   if (m_bEditDirty)
   {
      m_edit.GetWindowText(buf, MAX_PATH);
      m_strPath = buf;
   }
   m_bInternalChange = TRUE;
   SetCompactedPath(m_strPath);
   m_bInternalChange = FALSE;
   m_bEditDirty = FALSE;
   bHandled = FALSE;
   return 0;
}

LRESULT 
CFileChooser::OnSetBrowseState(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
   // We are producing dialog on the way back
   if (!wParam)
   {
      OnBrowseBtn();
   }
   bHandled = FALSE;
   return 0;
}

void 
CFileChooser::SetCompactedPath(LPCTSTR path)
{
   // compact path before writing to edit
   CRect rc;
   m_edit.GetClientRect(&rc);
   HDC dc = m_edit.GetDC();
   TCHAR buf[MAX_PATH] = {0};
   StrCpy(buf, path);
   PathMakePretty(buf);
   PathCompactPath(dc, buf, rc.Width());
   m_edit.ReleaseDC(dc);
   m_edit.SetWindowText(buf);
}

DWORD 
CFileChooser::GetFileName(CString& strFile)
{
   DWORD dwRes = FC_SUCCESS;
   TCHAR str[MAX_PATH];
   BOOL expanded = FALSE;

   if (  !m_bTextValid
      || FC_SUCCESS != ExtractPath(str)
      || !IsValidPath(str)
      )
      return FC_TEXT_IS_INVALID;
   if (StyleBitSet(FC_PATH_CHECK))
   {
      if (OpenForRead())
      {
          TCHAR str_exp[MAX_PATH];
          lstrcpy(str_exp, str);
          DoEnvironmentSubst(str_exp, MAX_PATH);
          expanded = lstrcmpi(str, str_exp) != 0;

          if (!PathFileExists(str_exp) && !PathIsDirectory(str_exp))
	      {
            BOOL bFound = FALSE;
            if (StyleBitSet(FC_CHECK_FILENAME_ONLY))
            {
		         // try with default extension(s) if it is just filename
               // without any extensions
               LPTSTR p = PathFindExtension(str_exp);
               if (p != NULL && *p == 0)
               {
                  CString strExt, strTest = str_exp;
                  std::list<CFilterEntry>::iterator it;
                  for (it = m_ext.begin(); it != m_ext.end(); it++)
                  {
                     strExt = (*it).m_ext;
		               if (PathFileExists(strTest + strExt))
                     {
                        StrCat(str, strExt);
                        bFound = TRUE;
                        break;
                     }
                  }
               }
            }
            if (!bFound)
               dwRes = FC_FILE_DOES_NOT_EXIST;
	      }
	      else if (PathIsDirectory(str_exp))
	      {
            if (!StyleBitSet(FC_DIRECTORY_ONLY))
            {
               PathAddBackslash(str);
               dwRes = FC_FILENAME_IS_DIRECTORY;
            }
	      }
         else if (StyleBitSet(FC_DIRECTORY_ONLY))
         {
            if (PathFileExists(str_exp))
               dwRes = FC_FILENAME_IS_FILE;
         }
      }
      else if (StyleBitSet(FC_FORWRITE))
      {
         // TODO: make sure we have write access to this path
      }
   }
   if (dwRes == FC_SUCCESS)
   {
      if (StyleBitSet(FC_COMMANDLINE) || expanded)
      {
         // We are returning whole command line, get it again
         GetText(str);
      }
      strFile = str;
   }
   return dwRes;
}

BOOL 
CFileChooser::BrowseForFile(CString& strPath, CString& strFile)
{
   BOOL bRes = FALSE;
   OPENFILENAME ofn;
   TCHAR buf[MAX_PATH];

   ZeroMemory(&ofn, sizeof(OPENFILENAME));
   StrCpy(buf, strFile);
   ofn.lStructSize = sizeof(OPENFILENAME);
   // We are not using template
   ofn.hInstance = NULL;
   ofn.Flags |= m_ofn_Flags;
   ofn.Flags |= OFN_NOCHANGEDIR | OFN_OVERWRITEPROMPT;
   if (OpenForRead())
      ofn.Flags |= OFN_FILEMUSTEXIST;
    else
		ofn.Flags |= (OFN_NOREADONLYRETURN | OFN_NOTESTFILECREATE | OFN_HIDEREADONLY);
#if (_WIN32_WINNT >= 0x0500)
   ofn.FlagsEx &= ~(OFN_EX_NOPLACESBAR);
#endif
   // Create filter using our extensions list
   CString strFilter, strDefExt;
   CreateFilter(strFilter, strDefExt);
	ofn.lpstrDefExt = strDefExt;
	ofn.lpstrFile = buf;
	ofn.nMaxFile = MAX_PATH;
	ofn.lpstrInitialDir = strPath.IsEmpty() ? NULL : (LPCTSTR)strPath;
	ofn.lpstrFilter = strFilter;
	ofn.nFilterIndex = GetFilterIndex(strFile);
   // We better set the owner, or this dialog will be visible on task bar
   ofn.hwndOwner = m_pParent->m_hWnd;
   ofn.lpstrTitle = m_strTitle; 

   if (StyleBitSet(FC_HIDEREADONLY))
      ofn.Flags |= OFN_HIDEREADONLY;
   if (!StyleBitSet(FC_FORWRITE))
      bRes = GetOpenFileName(&ofn);
   else
      bRes = GetSaveFileName(&ofn);
	if (bRes)
	{
		m_bDoReplaceFile = TRUE;
	}
   else
   {
#ifdef _DEBUG
      DWORD dwError;
      ASSERT(0 == (dwError = CommDlgExtendedError()));
#endif
   }

	strFile = buf;

   return bRes;
}


static int CALLBACK 
FileChooserCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
   CFileChooser * pThis = (CFileChooser *)lpData;
   ASSERT(pThis != NULL);
   return pThis->BrowseForFolderCallback(hwnd, uMsg, lParam);
}

int CFileChooser::BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam)
{
   switch (uMsg)
   {
   case BFFM_INITIALIZED:
      ASSERT(m_pPathTemp != NULL);
      if (::PathIsNetworkPath(m_pPathTemp))
         return 0;
      while (!::PathIsDirectory(m_pPathTemp))
      {
         if (0 == ::PathRemoveFileSpec(m_pPathTemp) && !::PathIsRoot(m_pPathTemp))
         {
            return 0;
         }
         DWORD attr = GetFileAttributes(m_pPathTemp);
         if (StyleBitSet(FC_FORWRITE) && (attr & FILE_ATTRIBUTE_READONLY) == 0)
            break;
      }
      ::SendMessage(hwnd, BFFM_SETSELECTION, TRUE, (LPARAM)m_pPathTemp);
      break;
   case BFFM_SELCHANGED:
      {
         LPITEMIDLIST pidl = (LPITEMIDLIST)lParam;
         TCHAR path[MAX_PATH];
         if (SHGetPathFromIDList(pidl, path))
         {
            ::SendMessage(hwnd, BFFM_ENABLEOK, 0, !PathIsNetworkPath(path));
         }
      }
      break;
   case BFFM_VALIDATEFAILED:
      break;
   }
   return 0;
}

BOOL 
CFileChooser::BrowseForFolder(CString& strPath)
{
   LPITEMIDLIST  pidl = NULL;
   HRESULT hr;
   BOOL bRes = FALSE;

   if (SUCCEEDED(hr = CoInitialize(NULL)))
   {
      if (SUCCEEDED(SHGetFolderLocation(NULL, CSIDL_DRIVES, NULL, 0, &pidl)))
      {
         LPITEMIDLIST pidList = NULL;
         BROWSEINFO bi;
         TCHAR buf[MAX_PATH];
         ZeroMemory(&bi, sizeof(bi));
         int drive = PathGetDriveNumber(strPath);
         if (GetDriveType(PathBuildRoot(buf, drive)) == DRIVE_FIXED)
         {
            StrCpy(buf, strPath);
         }
         else
         {
             buf[0] = 0;
         }
         
         bi.hwndOwner = m_pParent->m_hWnd;
         bi.pidlRoot = pidl;
         bi.pszDisplayName = m_pPathTemp = buf;
         bi.lpszTitle = m_strTitle;
         bi.ulFlags |= BIF_NEWDIALOGSTYLE | BIF_RETURNONLYFSDIRS/* | BIF_EDITBOX*/;
         bi.lpfn = FileChooserCallback;
         bi.lParam = (LPARAM)this;

         pidList = SHBrowseForFolder(&bi);
         if (  pidList != NULL
            && SHGetPathFromIDList(pidList, buf)
            )
         {
            strPath = buf;
            bRes = TRUE;
         }
         IMalloc * pMalloc;
         VERIFY(SUCCEEDED(SHGetMalloc(&pMalloc)));
         if (pidl != NULL)
            pMalloc->Free(pidl);
         pMalloc->Release();
      }
      CoUninitialize();
   }
   return bRes;
}

void
CFileChooser::AddExtension(HINSTANCE hInst, UINT idText, UINT idExt)
{
   CString text, ext;
   if (text.LoadString(hInst, idText) && ext.LoadString(hInst, idExt))
   {
      AddExtension(text, ext);
   }
}

void 
CFileChooser::AddExtension(LPCTSTR text, LPCTSTR ext)
{
   ASSERT(ext != NULL && *ext == _T('.'));
   CFilterEntry entry(text, ext);
   m_ext.push_back(entry);
}

const TCHAR cDelimiter = _T('\n');

void 
CFileChooser::CreateFilter(CString& strFilter, CString& strDefExt)
{
   strFilter.Empty();
   strDefExt.Empty();
   BOOL bExtDone = FALSE;
   std::list<CFilterEntry>::iterator it;
   for (it = m_ext.begin(); it != m_ext.end(); it++)
   {
      CFilterEntry entry = (*it);
      strFilter += entry.m_text;
      if (m_dwStyle & FC_WILDCARD_DESC)
      {
         strFilter += _T(" (*");
         strFilter += entry.m_ext;
         strFilter += _T(")");
      }
      strFilter += cDelimiter;
      strFilter += _T('*');
      strFilter += entry.m_ext;
      strFilter += cDelimiter;
      if (!bExtDone)
      {
         LPCTSTR pExt = entry.m_ext;
         strDefExt = 
            *pExt == _T('.') ? pExt + 1 : pExt;
         bExtDone = TRUE;
      }
   }
   if (!strFilter.IsEmpty())
   {
      strFilter += cDelimiter;
      for (int i = 0; i < strFilter.GetLength(); i++)
      {
         if (strFilter[i] == cDelimiter)
            strFilter.SetAt(i, 0);
      }
   }
}

int
CFileChooser::GetFilterIndex(const CString& fileName)
{
   LPTSTR p = PathFindExtension(fileName);
   if (p == NULL)
      p = (LPTSTR)AllExt;
   std::list<CFilterEntry>::iterator it;
   int idx = 1;
   for (it = m_ext.begin(); it != m_ext.end(); it++, idx++)
   {
      if (StrCmpI((*it).m_ext, p) == 0)
         return idx;
   }
   return 0;
}

void
CFileChooser::GetText(LPTSTR buf)
{
   ASSERT(buf != NULL);

   if (m_bEditDirty)
   {
      m_edit.GetWindowText(buf, MAX_PATH);
   }
   else
   {
      StrCpy(buf, m_strPath);
   }
}

int
CFileChooser::ExtractPath(LPTSTR path)
{
   ASSERT(path != NULL);
   int rc = FC_SUCCESS;
   TCHAR buf[MAX_PATH] = {0};
   LPTSTR start = buf;

   GetText(buf);

   if (StyleBitSet(FC_COMMANDLINE))
   {
      if (*buf == QuotMark)
      {
         LPTSTR end = StrChr(++start, QuotMark);
         if (end == NULL)
         {
            // Wrong format, closing quotation mark is not set
            rc = FC_NO_CLOSING_QUOTE;
            // Return part of the path up to first space
            PathRemoveArgs(buf);
         }
         else
         {
            ++end;
            *end = 0;
            PathUnquoteSpaces(buf);
            start = buf;
         }
      }
      else
      {
         PathRemoveArgs(buf);
      }
   }

   StrCpy(path, start);

   return rc;
}

int
CFileChooser::ExtractArgs(LPTSTR buf)
{
   ASSERT(buf != NULL);

   int rc = FC_SUCCESS;

   GetText(buf);
   LPTSTR p = PathGetArgs(buf);
   if (p != NULL)
   {
      StrCpy(buf, p);
   }
   else
   {
      *buf = 0;
   }
   return rc;
}

void 
CFileChooser::OnBrowseBtn()
{
   BOOL bRes = FALSE;
   if (m_bDialogActive)
      return;
   m_bDialogActive = TRUE;
   TCHAR path[MAX_PATH] = {0};
   TCHAR args[MAX_PATH] = {0};

   int rc = ExtractPath(path);
   if (StyleBitSet(FC_COMMANDLINE))
   {
      ExtractArgs(args);
   }
	CString strFile, strBuffer;
//	m_strPath = path;
   strBuffer = path;

   if (StyleBitSet(FC_FORWRITE))
   {
	   if (!PathIsDirectory(path))
	   {
		   if (PathRemoveFileSpec(path))
		   {
			   // check if path part of filename exists
			   if (PathIsDirectory(path))
			   {
				   // we will use non-path part of spec as a filename
				   strFile = PathFindFileName(strBuffer);
			   }
			   else
			   {
				   // it is wrong path, use default one
				   // TODO: actually I need to take from filespec all existent
				   // chunks of path and filename, for example c:\aa\bb\cc\dd.txt,
				   // if c:\aa\bb exists, then strPath should be set to c:\aa\bb,
				   // and strFile to dd.txt
				   path[0] = 0;
			   }
		   }
		   else
		   {
			   // it is filename only
			   strFile = strBuffer;
			   path[0] = 0;
		   }
	   }
   }
   else
   {
      if (!PathIsDirectory(path))
      {
	      strFile = PathFindFileName(path);
	      PathRemoveFileSpec(path);
      }
   }
   CString strPath(path);
   if (StyleBitSet(FC_DIRECTORY_ONLY))
   {
      bRes = BrowseForFolder(strPath);
      if (bRes)
      {
         StrCpy(path, strPath);
      }
   }
   else
   {
      bRes = BrowseForFile(strPath, strFile);
      if (bRes)
      {
         StrCpy(path, strFile);
      }
   }
   if (bRes)
   {
      if (StyleBitSet(FC_COMMANDLINE))
      {
         PathQuoteSpaces(path);
         m_strPath = path;
         if (*args != 0)
         {
            m_strPath += _T(' ');
            m_strPath += args;
         }
      }
      else
         m_strPath = path;
      SetPathToEdit(m_strPath);
      m_bEditDirty = FALSE;
      ::SendMessage(GetParent(), WM_COMMAND, (WPARAM)EN_CHANGE, (LPARAM)m_edit.m_hWnd);
   }
   m_bDialogActive = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\iisdebug.h ===
#include "debugdefs.h"

void GetOutputDebugFlag(void);

extern g_iDebugOutputLevel;

#if defined(_DEBUG) || DBG
	#define DEBUG_FLAG
#endif

#ifdef DEBUG_FLAG
    inline void _cdecl DebugTrace(LPTSTR lpszFormat, ...)
    {
        // Only do this if the flag is set.
        if (0 != g_iDebugOutputLevel)
        {
			if (DEBUG_FLAG_MODULE_IISUI & g_iDebugOutputLevel)
			{
				int nBuf;
				TCHAR szBuffer[_MAX_PATH];
				va_list args;
				va_start(args, lpszFormat);

				nBuf = _vsntprintf(szBuffer, sizeof(szBuffer)/sizeof(szBuffer[0]), lpszFormat, args);

				OutputDebugString(szBuffer);
				va_end(args);

				// if it does not end if '\r\n' then make one.
				int nLen = _tcslen(szBuffer);
				if (szBuffer[nLen-1] != _T('\n')){OutputDebugString(_T("\r\n"));}
			}
        }
    }
#else
    inline void _cdecl DebugTrace(LPTSTR , ...){}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\iiscstring.cpp ===
//
//    IISCStringImpl.cpp
//
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#pragma warning(disable:4786) // Disable warning for names > 256

#include "common.h"
#include <algorithm>
#include <deque>
#include <TCHAR.h>
#include "IISCString.h"

//////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////
// Constructors
///////////////////////////////////////////////////////////////////////////
CString::CString()
      :  std::basic_string<TCHAR>() 
{
}

CString::CString(const CString& strInput)
      :  std::basic_string<TCHAR>(strInput) 
{
}

CString::CString(const std::basic_string<TCHAR>& strInput)
      :  std::basic_string<TCHAR>(strInput) 
{
}

CString::CString(TCHAR ch, int nRepeat /* = 1*/)
      :  std::basic_string<TCHAR>(nRepeat, ch) 
{
}

CString::CString(LPCTSTR p)
      :  std::basic_string<TCHAR>(p) 
{
}

#ifdef _UNICODE
CString::CString(LPCSTR strInput)
{
   int len = strlen(strInput);
   TCHAR * buf = (TCHAR *)_alloca(len * (sizeof(TCHAR) + 1));
   if (0 != MultiByteToWideChar(CP_THREAD_ACP, MB_PRECOMPOSED,
      strInput, len, buf, len))
   {
      assign(buf);
   }
   else
   {
      ATLASSERT(FALSE);
   }
}
#endif

#ifndef _UNICODE
CString::CString(LPCWSTR strInput)
{
   int len = wstrlen(strInput);
   int buflen = len * (sizeof(TCHAR) + 1);
   TCHAR * buf = (TCHAR *)_alloca(buflen);
   if (0 != WideCharToMultiByte(CP_THREAD_ACP, 0,
      strInput, len, buf, buflen))
   {
      assign(buf);
   }
   else
   {
      ATLASSERT(FALSE);
   }
}
#endif

CString::CString(const CComBSTR& bstr)
{
   assign((LPCTSTR)bstr.m_str);
}

CString::~CString()
{
}

///////////////////////////////////////////////////////////////////////////
// The string as an array
///////////////////////////////////////////////////////////////////////////

int CString::GetLength() const
{
   return length();
};

bool CString::IsEmpty() const
{
   return empty();
};

void CString::Empty()
{
   erase();
};

TCHAR CString::GetAt(int nIndex) const
{
	ATLASSERT(nIndex >= 0);
   return at(nIndex);
};

TCHAR CString::operator[](int nIndex) const
{
	// same as GetAt
	ATLASSERT(nIndex >= 0);
	return at(nIndex);
}

void CString::SetAt(int nIndex, TCHAR ch)
{
   at(nIndex) = ch;
};

const CString& CString::operator=(const CString& stringSrc)
{
   assign(stringSrc);
	return *this;
}

const CString& CString::operator=(LPCTSTR p)
{
   // Here we will have a problem if NULL pointer is passed because
   // later STL will call wcslen(NULL) which uses *p without test.
   // We will emulate the result by erasing current string
   if (p == NULL)
      erase();
   // another problem is when we assign string to self, like str = str.c_str()
   // STL deletes data and then assign it resulting in garbage
   else if (p != this->data())
      assign(p);
   return *this;
}

#ifdef _UNICODE
const CString& CString::operator=(const unsigned char * lpsz)
{ 
   int len = strlen((const char *)lpsz);
   TCHAR * buf = (TCHAR *)_alloca(len * (sizeof(TCHAR) + 1));
   if (0 != MultiByteToWideChar(CP_THREAD_ACP, MB_PRECOMPOSED, (const char *)lpsz, -1, buf, len))
   {
      assign(buf);
   }
   else
   {
      ATLASSERT(FALSE);
   }
   return *this; 
}
#endif

const CString& CString::operator=(TCHAR c)
{
   assign(1, c);
   return *this;
}

#ifdef _UNICODE
const CString& CString::operator+=(char ch)
{ 
   *this += (TCHAR)ch; 
   return *this; 
}

const CString& CString::operator=(char ch)
{ 
   *this = (TCHAR)ch; 
   return *this; 
}

CString __stdcall operator+(const CString& string, char ch)
{ 
   return string + (TCHAR)ch; 
}

CString __stdcall operator+(char ch, const CString& string)
{ 
   return (TCHAR)ch + string; 
}
#endif

const CString& CString::operator+=(TCHAR ch)
{ 
   append(1, ch);
   return *this;
}

const CString& CString::operator+=(const CString& s)
{ 
   append(s); 
   return *this; 
}

const CString& CString::operator+=(LPCTSTR p)
{ 
   append(p); 
   return *this; 
}

static int __stdcall _LoadString(HINSTANCE hInstance, UINT nID, LPTSTR lpszBuf, UINT nMaxBuf)
{
#ifdef _DEBUG
	// LoadString without annoying warning from the Debug kernel if the
	//  segment containing the string is not present
	if (::FindResource(hInstance, MAKEINTRESOURCE((nID>>4)+1), RT_STRING) == NULL)
	{
		lpszBuf[0] = '\0';
		return 0; // not found
	}
#endif //_DEBUG
	int nLen = ::LoadString(hInstance, nID, lpszBuf, nMaxBuf);
	if (nLen == 0)
		lpszBuf[0] = '\0';
	return nLen;
}

#ifdef _UNICODE
#define CHAR_FUDGE 1    // one TCHAR unused is good enough
#else
#define CHAR_FUDGE 2    // two BYTES unused for case of DBC last char
#endif

#define INITIAL_SIZE    256

BOOL CString::LoadString(HINSTANCE hInstance, UINT id)
{
	// try fixed buffer first (to avoid wasting space in the heap)
	TCHAR szTemp[INITIAL_SIZE];
	int nCount =  sizeof(szTemp) / sizeof(szTemp[0]);
	int nLen = _LoadString(hInstance, id, szTemp, nCount);
	if (nCount - nLen > CHAR_FUDGE)
	{
		*this = szTemp;
		return nLen > 0;
	}

	// try buffer size of 512, then larger size until entire string is retrieved
	int nSize = INITIAL_SIZE;
   LPTSTR p = NULL;
	do
	{
		nSize += INITIAL_SIZE;
      p = get_allocator().allocate(nSize, p);
		nLen = _LoadString(hInstance, id, p, nSize - 1);
	} while (nSize - nLen <= CHAR_FUDGE);
   if (nLen > 0)
      assign(p, nLen);

	return nLen > 0;
}

///////////////////////////////////////////////////////////////////////////
// Comparison
///////////////////////////////////////////////////////////////////////////

int CString::Compare(const TCHAR * psz) const
{
   if (psz == NULL)
      return this->empty() ? 0 : 1;
   return compare(psz);
};

int CString::CompareNoCase(const TCHAR * psz) const
{
   if (psz == NULL)
      return this->empty() ? 0 : 1;
   return _tcsicmp(c_str(), psz);
};

int CString::Collate(const TCHAR * psz) const
{
   if (psz == NULL)
      return this->empty() ? 0 : 1;
   return _tcscoll(c_str(), psz);
};

///////////////////////////////////////////////////////////////////////////
// Extraction
///////////////////////////////////////////////////////////////////////////

CString CString::Mid(int nFirst) const
{
   return substr(nFirst);
};

CString CString::Mid(int nFirst, int nCount) const
{
   return substr(nFirst, nCount);
};

CString CString::Left(int nCount) const
{
   return substr(0, nCount);
};

CString CString::Right(int nCount) const
{
   return substr(length() - nCount, nCount);
};

CString CString::SpanIncluding(const TCHAR * pszCharSet) const
{
   return substr(0, find_first_not_of(pszCharSet));
};

CString CString::SpanExcluding(const TCHAR * pszCharSet) const
{
   return substr(0, find_first_of(pszCharSet));
};

///////////////////////////////////////////////////////////////////////////
// Other Conversions
///////////////////////////////////////////////////////////////////////////

void CString::MakeUpper()
{
   std::for_each(begin(), end(), _totupper);
};

void CString::MakeLower()
{
   std::for_each(begin(), end(), _totlower);
};

void CString::MakeReverse()
{
   std::reverse(begin(), end());
};

void CString::TrimLeft()
{
   while (_istspace(at(0)))
	   erase(0, 1);
};

void CString::TrimRight()
{
   while (_istspace(at(length() - 1)))
	   erase(length() - 1, 1);
};

#define BUFFER_SIZE     1024

void __cdecl CString::FormatV(LPCTSTR lpszFormat, va_list argList)
{
   TCHAR buf[BUFFER_SIZE];
   if (-1 != _vsntprintf(buf, BUFFER_SIZE, lpszFormat, argList))
   {
	  buf[BUFFER_SIZE - 1] = L'\0'; // null terminate the string 
      assign(buf);
   }
}

// formatting (using wsprintf style formatting)
void __cdecl CString::Format(LPCTSTR lpszFormat, ...)
{
	va_list argList;
	va_start(argList, lpszFormat);
	FormatV(lpszFormat, argList);
	va_end(argList);
}

void __cdecl CString::Format(HINSTANCE hInst, UINT nFormatID, ...)
{
	CString strFormat;
	BOOL bRet = strFormat.LoadString(hInst, nFormatID);
	bRet;	// ref
	ATLASSERT(bRet != 0);

	va_list argList;
	va_start(argList, nFormatID);
	FormatV(strFormat, argList);
	va_end(argList);
}

// formatting (using FormatMessage style formatting)
BOOL CString::FormatMessage(LPCTSTR lpszFormat, ...)
{
	// format message into temporary buffer lpszTemp
	va_list argList;
	va_start(argList, lpszFormat);
	LPTSTR lpszTemp;
	BOOL bRet = TRUE;

	if (::FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
		lpszFormat, 0, 0, (LPTSTR)&lpszTemp, 0, &argList) == 0 ||
		lpszTemp == NULL)
		bRet = FALSE;

	// assign lpszTemp into the resulting string and free the temporary
	*this = lpszTemp;
	LocalFree(lpszTemp);
	va_end(argList);
	return bRet;
}

BOOL CString::FormatMessage(HINSTANCE hInst, UINT nFormatID, ...)
{
	// get format string from string table
	CString strFormat;
	BOOL bRetTmp = strFormat.LoadString(hInst, nFormatID);
	bRetTmp;	// ref
	ATLASSERT(bRetTmp != 0);

	// format message into temporary buffer lpszTemp
	va_list argList;
	va_start(argList, nFormatID);
	LPTSTR lpszTemp;
	BOOL bRet = TRUE;

	if (::FormatMessage(
            FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
		      strFormat, 0, 0, (LPTSTR)&lpszTemp, 0, &argList) == 0 || lpszTemp == NULL
      )
		bRet = FALSE;

	// assign lpszTemp into the resulting string and free lpszTemp
	*this = lpszTemp;
	LocalFree(lpszTemp);
	va_end(argList);
	return bRet;
}

///////////////////////////////////////////////////////////////////////////
// Searching
///////////////////////////////////////////////////////////////////////////
int CString::Find(TCHAR ch) const
{
   return find(ch);
};

int CString::Find(const TCHAR * psz) const
{
   if (psz == NULL)
      return -1;
   return find(psz);
};

int CString::ReverseFind(TCHAR ch) const
{
   return rfind(ch);
};

int CString::FindOneOf(const TCHAR * psz) const
{
   if (psz == NULL)
      return -1;
   return find_first_of(psz);
};

///////////////////////////////////////////////////////////////////////////
// Operators
///////////////////////////////////////////////////////////////////////////

CString::operator const TCHAR *() const
{ 
   return c_str(); 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\iisuihelper.cpp ===
#include "stdafx.h"
#include "resource.h"
#include <initguid.h>

#include "common.h"
#include "iisdebug.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
        InitErrorFunctionality();
		GetOutputDebugFlag();
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        TerminateErrorFunctionality();
        _Module.Term();
    }
    return TRUE;    // ok
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\error.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :

        error.h

   Abstract:

        Message Functions Definitions

   Author:

        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:
        2/17/2000    sergeia     removed dependency on MFC

--*/

#ifndef _ERROR_H
#define _ERROR_H

#pragma warning(disable:4786) // Disable warning for names > 256

//
// Slightly easier syntax to register a facility
//
#define REGISTER_FACILITY(dwCode, lpSource)\
    CError::RegisterFacility(dwCode, lpSource)

//
// Helper Function
//
HRESULT GetLastHRESULT();
BOOL InitErrorFunctionality();
void TerminateErrorFunctionality();


typedef struct tagFACILITY
{
    LPCTSTR lpszDll;
    UINT    nTextID;
} FACILITY;

#pragma warning(disable : 4231)
#pragma warning(disable : 4251)

//typedef std::map<DWORD, CString> CMapDWORDtoCString;
//typedef std::map<HRESULT, UINT> CMapHRESULTtoUINT;

class CFacilityMap : public std::map<DWORD, CString>
{
};

class COverridesMap : public std::map<HRESULT, UINT>
{
public:
   COverridesMap()
   {
   }
   ~COverridesMap()
   {
   }
};

class _EXPORT CError
/*++

Class Description:

    Error handling class, works for both HRESULT and old-style DWORD
    error codes.  Construct with or assign a DWORD or HRESULT error
    return code, and the object can then be used to determine success
    or failure, and the object provides text for the error code either
    directly, in a message, or formatted with additional text.  Also,
    the CError object understands the range of winsock errors and
    lanman errors, and looks for them in the appropriate places.
    The object can be referenced as a BOOL, a DWORD, an HRESULT, or
    a LPCTSTR as a success/failure, a WIN32 error, and HRESULT or
    the text equivalent respectively.

    Example of typical programme flow:

    CError err(FunctionWhichReturnsHresult());

    //
    // Use IDS_MY_ERROR for access denied errors for the
    // duration of this scope.
    //
    err.AddOverride(ERROR_ACCESS_DENIED, IDS_MY_ERROR);

    if (!err.MessageBoxOnFailure())
    {
        //
        // If we failed, this already displayed the error
        // message in a messagebox.  Only when we succeed
        // we get here.
        //
        ... stuff ...
    }

    SomeWinApiWhichSetsLastError();
    err.GetLastWinError();
    if (err.Failed())
    {
        printf("WIN32 Error code %ld\nHRESULT %ld\nText: %s\n",
            (DWORD)err,
            (HRESULT)err,
            (LPCTSTR)err
            );
    }

Public Interface:

    TextFromHRESULT         : Convert HRESULT to text
    TextFromHRESULTExpand   : Expand %h string to error text, %H to error code
    MessageBox              : Display error in a messagebox
    MessageBoxFormat        : Use %h string as format in messagebox
    MessageBoxOnFailure     : Display message if error is a failure
    AddOverride             : Add message override with string ID
    RemoveOverride          : Remove message override
    RegisterFacility        : Register facility
    UnregisterFacility      : Unregister facility
    Succeeded               : Determine if the error code indicates a success
    Failed                  : Determine if the error code indicates a failure

    CError                  : Constructors
    Reset                   : Reset error code
    GetLastWinError         : Assign internal code to GetLastError
    SetLastWinError         : Set last error from internal code

    operator =              : Assignment operators
    operator ==             : Comparison operators
    operator !=             : Comparison operators
    operator LPOLESTR       : Conversion operator
    operator LPCTSTR        : Conversion operator
    operator HRESULT        : Conversion operator
    operator DWORD          : Conversion operator
    operator BOOL           : Conversion operator

--*/
{
#define IS_HRESULT(hr)  (hr & 0xffff0000)
#define REMOVE_OVERRIDE ((UINT)-1)
#define NO_HELP_CONTEXT ((UINT)-1)
#define USE_LAST_ERROR  (TRUE)

//
// Private Internal FACILITY codes
//
#define FACILITY_WINSOCK    (0xffe)
#define FACILITY_LANMAN     (0xfff)

//
// Static Helpers
//
public:
    //
    // Success/Failure determinants, works regardless
    // of whether hrCode is a DWORD or HRESULT
    //
    static BOOL Succeeded(HRESULT hrCode);
    static BOOL Failed(HRESULT hrCode);

    //
    // Guarantee return is WIN32 error code
    //
    static DWORD Win32Error(HRESULT hrCode) { return HRESULT_CODE(hrCode); }

    //
    // Guarantee return is a true HRESULT
    //
    static HRESULT HResult(HRESULT hrCode) { return HRESULT_FROM_WIN32(hrCode); }

    //
    // Register a DLL for a given facility code.
    // Use NULL to unregister the facility
    //
    static void RegisterFacility(
        IN DWORD dwFacility,
        IN LPCSTR lpDLL = NULL
        );

    static void UnregisterFacility(
        IN DWORD dwFacility
        );

//
// Constructor/Destructor
//
public:
    //
    // If constructed with TRUE, the object is initialized to
    // last error.  It's set to ERROR_SUCCESS otherwise (default case)
    //
    CError();
    CError(HRESULT hrCode);
    CError(DWORD   dwCode);
    ~CError();

//
// Helpers
//
public:
    BOOL Succeeded() const { return SUCCEEDED(m_hrCode); }
    BOOL Failed() const { return FAILED(m_hrCode); }

    HRESULT TextFromHRESULT(
        OUT LPTSTR szBuffer,
        OUT DWORD  cchBuffer
        ) const;

    HRESULT TextFromHRESULT(
        OUT CString & strMsg
        ) const;

    LPCTSTR TextFromHRESULTExpand(
        OUT LPTSTR  szBuffer,
        OUT DWORD   cchBuffer,
        OUT HRESULT * phResult = NULL
        ) const;

    LPCTSTR TextFromHRESULTExpand(
        OUT CString & strBuffer
        ) const;

    int MessageBox(
        IN UINT nType = MB_OK | MB_ICONWARNING,
        IN UINT nHelpContext = NO_HELP_CONTEXT
        ) const;

    BOOL MessageBoxOnFailure(
        IN UINT nType = MB_OK | MB_ICONWARNING,
        IN UINT nHelpContext = NO_HELP_CONTEXT
        ) const;

    int MessageBoxFormat(
        IN HINSTANCE hInst,
        IN UINT nFmt,
        IN UINT nType,
        IN UINT nHelpContext,
        ...
        ) const;

    void Reset();
    void GetLastWinError();
    void SetLastWinError() const;
    DWORD Win32Error() const;
    HRESULT HResult() const { return m_hrCode; }

    //
    // Add override for specific error code.
    // Use -1 to remove the override.  This function
    // will return the previous override (or -1)
    //
    UINT AddOverride(
        IN HRESULT hrCode,
        IN UINT    nMessage = REMOVE_OVERRIDE
        );         

    void RemoveOverride(
        IN HRESULT hrCode
        );
        
    void RemoveAllOverrides();   

protected:
    //
    // Expand escape code
    //
    BOOL ExpandEscapeCode(
        IN  LPTSTR szBuffer,
        IN  DWORD cchBuffer,
        OUT IN LPTSTR & lp,
        IN  CString & strReplacement,
        OUT HRESULT & hr
        ) const;

    //
    // Check for override message
    //
    BOOL HasOverride(
        OUT UINT * pnMessage = NULL
        ) const;

//
// Assignment Operators
//
public:
    const CError & operator =(HRESULT hr);
    const CError & operator =(const CError & err);

// 
// Comparison Operators
//
public:
    const BOOL operator ==(HRESULT hr);
    const BOOL operator ==(CError & err);
    const BOOL operator !=(HRESULT hr);
    const BOOL operator !=(CError & err);

//
// Conversion Operators
//
public:
    operator const HRESULT() const { return m_hrCode; }
    operator const DWORD() const;
    operator const BOOL() const;
    operator LPOLESTR();
    operator LPCTSTR();

protected:
    static HRESULT CvtToInternalFormat(HRESULT hrCode);

    //
    // Check for FACILITY dll
    //
    static LPCTSTR FindFacility(
        IN DWORD dwFacility
        );

protected:
    friend BOOL InitErrorFunctionality();
    friend void TerminateErrorFunctionality();
    static BOOL AllocateStatics();
    static void DeAllocateStatics();
    static BOOL AreStaticsAllocated();

protected:
    static const TCHAR s_chEscape;    // Escape character
    static const TCHAR s_chEscText;   // Escape code for text
    static const TCHAR s_chEscNumber; // Escape code for error code
    static LPCTSTR s_cszLMDLL;        // Lanman Message DLL
    static LPCTSTR s_cszWSDLL;        // Winsock Message DLL
    static LPCTSTR s_cszFacility[];   // Facility Table
    static HRESULT s_cdwMinLMErr;     // Lanman Error Range
    static HRESULT s_cdwMaxLMErr;     // Lanman Error Range
    static HRESULT s_cdwMinWSErr;     // Winsock Error Range
    static HRESULT s_cdwMaxWSErr;     // Winsock Error Range
    static DWORD   s_cdwFacilities;   // Number of facility items

    //
    // Allocated objects 
    //
    static CString * s_pstrDefError;  // Default Error String
    static CString * s_pstrDefSuccs;  // Default Success String
    static CFacilityMap * s_pmapFacilities;
    static BOOL s_fAllocated;

protected:
    const CError & Construct(HRESULT hr);
    const CError & Construct(const CError & err);
    COverridesMap mapOverrides;

private:
    HRESULT m_hrCode;
    CString m_str;
};



//
// Inline Expansions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline HRESULT GetLastHRESULT()
{
    return CError::HResult(::GetLastError());
}

inline /* static */ BOOL CError::Succeeded(HRESULT hrCode)
{
    //
    // Works with either HRESULT or WIN32 error code
    //
    return IS_HRESULT(hrCode)
        ? SUCCEEDED(hrCode)
        : hrCode == ERROR_SUCCESS;
}

inline /* static */ BOOL CError::Failed(HRESULT hrCode)
{
    //
    // Works with either HRESULT or WIN32 error code
    //
    return IS_HRESULT(hrCode)
        ? FAILED(hrCode)
        : hrCode != ERROR_SUCCESS;
}

inline /* static */ void CError::UnregisterFacility(
    IN DWORD dwFacility
    )
{
    RegisterFacility(dwFacility, NULL);
}

inline CError::CError()
{
    Construct(S_OK);
}

inline CError::CError(HRESULT hrCode)
{
    Construct(hrCode);
}

inline CError::CError(DWORD dwCode)
{
    Construct((HRESULT)dwCode);
}

inline DWORD CError::Win32Error() const
{
    return CError::Win32Error(m_hrCode);
}

inline void CError::Reset()
{
    m_hrCode = S_OK;
}

inline void CError::GetLastWinError()
{
    Construct(::GetLastError());
}

inline void CError::SetLastWinError() const
{
    ::SetLastError(Win32Error(m_hrCode));
}

inline void CError::RemoveOverride(
    IN HRESULT hrCode
    )
{
    (void)CError::AddOverride(hrCode, REMOVE_OVERRIDE);
}

inline const CError & CError::operator =(HRESULT hr)
{
    return Construct(hr);
}

inline const CError & CError::operator =(const CError & err)
{
    return Construct(err);
}

inline const BOOL CError::operator ==(HRESULT hr)
{
    return m_hrCode == hr;
}

inline const BOOL CError::operator ==(CError & err)
{
    return m_hrCode == err.m_hrCode;
}

inline const BOOL CError::operator !=(HRESULT hr)
{
    return m_hrCode != hr;
}

inline const BOOL CError::operator !=(CError & err)
{
    return m_hrCode != err.m_hrCode;
}

inline CError::operator const DWORD() const
{
    return Win32Error();
}

inline CError::operator const BOOL() const
{
    return Succeeded();
}

//inline CError::operator LPOLESTR()
//{
//    TextFromHRESULT(m_str);
//    return m_str.c_str();
//}
    
inline CError::operator LPCTSTR()
{
    TextFromHRESULT(m_str);
    return m_str;
}

//
// AfxMessageBox helpers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline BOOL NoYesMessageBox(CString& str)
{
   CString strCaption;
   strCaption.LoadString(_Module.GetResourceInstance(), IDS_APP_TITLE);
   return ::MessageBox(::GetFocus(), str, strCaption, MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON2) == IDYES;
}

inline BOOL NoYesMessageBox(UINT nID)
{
   CString strText;
   strText.LoadString(_Module.GetResourceInstance(), nID);
   return NoYesMessageBox(strText);
}

inline BOOL YesNoMessageBox(CString& str)
{
   CString strCaption;
   strCaption.LoadString(_Module.GetResourceInstance(), IDS_APP_TITLE);
   return ::MessageBox(::GetFocus(), str, strCaption, MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON1) == IDYES;
}

inline BOOL YesNoMessageBox(UINT nID)
{
   CString strText;
   strText.LoadString(_Module.GetResourceInstance(), nID);
   return YesNoMessageBox(strText);
}

#endif // _ERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\iiscstring.h ===
//
//    IISCString.h
//
//////////////////////////////////////////////////////////////////////////////

#if !defined(IISCSTRING_H)
#define IISCSTRING_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

//////////////////////////////////////////////////////////////////////////////
#pragma warning(disable:4786) // Disable warning for names > 256
#pragma warning(disable:4275) // Disable warning for non dll-interface class used as a base class

#include <string>
#include <cstring>
#include "common.h"

//////////////////////////////////////////////////////////////////////////////

namespace IIS
{
   class _EXPORT CString : public std::basic_string<TCHAR>
   {
   public:
      // Constructors
      CString();
      CString(const CString& strInput);
      CString(const std::basic_string<TCHAR>& strInput);
      CString(TCHAR ch, int nRepeat = 1);
#ifdef _UNICODE
	   CString(LPCSTR lpsz);
#endif
#ifndef _UNICODE
	   CString(LPCWSTR lpsz);
#endif
      CString(LPCTSTR p);
	   CString(LPCTSTR lpch, int nLength);
	   CString(const unsigned char * psz);
      CString(const CComBSTR& bstr);

      ~CString();

      int GetLength() const;
      bool IsEmpty() const;
      void Empty();
      TCHAR GetAt(int nIndex) const;
	   TCHAR operator[](int nIndex) const;
      void SetAt(int nIndex, TCHAR ch);
	   operator LPCTSTR() const;           // as a C string

	   const CString& operator=(const CString& stringSrc);
	   const CString& operator=(TCHAR ch);
      const CString& operator=(LPCTSTR p);
#ifdef _UNICODE
	   const CString& operator=(char ch);
	   const CString& operator=(LPCSTR lpsz);
	   const CString& operator=(const unsigned char* psz);
#endif
#ifndef _UNICODE
	   const CString& operator=(WCHAR ch);
	   const CString& operator=(LPCWSTR lpsz);
#endif

	   // string concatenation
	   const CString& operator+=(const CString& string);
	   const CString& operator+=(TCHAR ch);
#ifdef _UNICODE
   	const CString& operator+=(char ch);
#endif
	   const CString& operator+=(LPCTSTR lpsz);

	   friend CString __stdcall operator+(const CString& string1, const CString& string2);
	   friend CString __stdcall operator+(const CString& string, TCHAR ch);
	   friend CString __stdcall operator+(TCHAR ch, const CString& string);
#ifdef _UNICODE
   	friend CString __stdcall operator+(const CString& string, char ch);
	   friend CString __stdcall operator+(char ch, const CString& string);
#endif
	   friend CString __stdcall operator+(const CString& string, LPCTSTR lpsz);
	   friend CString __stdcall operator+(LPCTSTR lpsz, const CString& string);

	   int Compare(LPCTSTR lpsz) const;         // straight character
	   int CompareNoCase(LPCTSTR lpsz) const;   // ignore case
	   int Collate(LPCTSTR lpsz) const;         // NLS aware

	   // simple sub-string extraction
	   CString Mid(int nFirst, int nCount) const;
	   CString Mid(int nFirst) const;
	   CString Left(int nCount) const;
	   CString Right(int nCount) const;

	   CString SpanIncluding(LPCTSTR lpszCharSet) const;
	   CString SpanExcluding(LPCTSTR lpszCharSet) const;

	   // upper/lower/reverse conversion
	   void MakeUpper();
	   void MakeLower();
	   void MakeReverse();

	   // trimming whitespace (either side)
	   void TrimRight();
	   void TrimLeft();

	   // advanced manipulation
	   // replace occurrences of chOld with chNew
	   int Replace(TCHAR chOld, TCHAR chNew);
	   // replace occurrences of substring lpszOld with lpszNew;
	   // empty lpszNew removes instances of lpszOld
	   int Replace(LPCTSTR lpszOld, LPCTSTR lpszNew);
	   // remove occurrences of chRemove
	   int Remove(TCHAR chRemove);
	   // insert character at zero-based index; concatenates
	   // if index is past end of string
	   int Insert(int nIndex, TCHAR ch);
	   // insert substring at zero-based index; concatenates
	   // if index is past end of string
	   int Insert(int nIndex, LPCTSTR pstr);
	   // delete nCount characters starting at zero-based index
	   int Delete(int nIndex, int nCount = 1);

	   // searching (return starting index, or -1 if not found)
	   // look for a single character match
	   int Find(TCHAR ch) const;               // like "C" strchr
	   int ReverseFind(TCHAR ch) const;
	   int FindOneOf(LPCTSTR lpszCharSet) const;

	   // look for a specific sub-string
	   int Find(LPCTSTR lpszSub) const;        // like "C" strstr

	   // Concatentation for non strings
//	   const CString& Append(int n)
//	   {
//		   TCHAR szBuffer[10];
//		   wsprintf(szBuffer,_T("%d"),n);
//		   ConcatInPlace(SafeStrlen(szBuffer), szBuffer);
//		   return *this;
//	   }

   	// simple formatting
      void __cdecl FormatV(LPCTSTR lpszFormat, va_list argList);
	   void __cdecl Format(LPCTSTR lpszFormat, ...);
	   void __cdecl Format(HINSTANCE hInst, UINT nFormatID, ...);

	   // formatting for localization (uses FormatMessage API)
	   BOOL __cdecl FormatMessage(LPCTSTR lpszFormat, ...);
	   BOOL __cdecl FormatMessage(HINSTANCE hInst, UINT nFormatID, ...);

	   // Windows support
	   BOOL LoadString(HINSTANCE hInstance, UINT nID);
#ifndef _UNICODE
   	// ANSI <-> OEM support (convert string in place)
	   void AnsiToOem();
	   void OemToAnsi();
#endif

#ifndef _ATL_NO_COM
	   // OLE BSTR support (use for OLE automation)
	   BSTR AllocSysString() const;
	   BSTR SetSysString(BSTR* pbstr) const;
#endif //!_ATL_NO_COM

   };

   //////////////////////////////////////////////////////////////////////////////
inline bool operator==(const CString& s1, const CString& s2)
	{ return s1.compare(s2) == 0; }
inline bool operator==(const CString& s1, const TCHAR * s2)
	{ return s1.compare(s2) == 0; }
inline bool operator==(const TCHAR * s1, const CString& s2)
	{ return s2.compare(s1) == 0; }

inline bool operator!=(const CString& s1, const CString& s2)
	{ return s1.compare(s2) != 0; }
inline bool operator!=(const CString& s1, const TCHAR * s2)
	{ return s1.compare(s2) != 0; }
inline bool operator!=(const TCHAR * s1, const CString& s2)
	{ return s2.compare(s1) != 0; }

inline bool operator<(const CString& s1, const CString& s2)
	{ return s1.compare(s2) < 0; }
inline bool operator<(const CString& s1, const TCHAR * s2)
	{ return s1.compare(s2) < 0; }
inline bool operator<(const TCHAR * s1, const CString& s2)
	{ return s2.compare(s1) > 0; }

inline bool operator>(const CString& s1, const CString& s2)
	{ return s1.compare(s2) > 0; }
inline bool operator>(const CString& s1, const TCHAR * s2)
	{ return s1.compare(s2) > 0; }
inline bool operator>(const TCHAR * s1, const CString& s2)
	{ return s2.compare(s1) < 0; }

inline bool operator<=(const CString& s1, const CString& s2)
	{ return s1.compare(s2) <= 0; }
inline bool operator<=(const CString& s1, const TCHAR * s2)
	{ return s1.compare(s2) <= 0; }
inline bool operator<=(const TCHAR * s1, const CString& s2)
	{ return s2.compare(s1) >= 0; }

inline bool operator>=(const CString& s1, const CString& s2)
	{ return s1.compare(s2) >= 0; }
inline bool operator>=(const CString& s1, const TCHAR * s2)
	{ return s1.compare(s2) >= 0; }
inline bool operator>=(const TCHAR * s1, const CString& s2)
	{ return s2.compare(s1) <= 0; }

inline CString __stdcall operator+(const CString& string1, const CString& string2)
{
   CString s = string1;
   s += string2;
   return s;
}

inline CString __stdcall operator+(const CString& string, LPCTSTR lpsz)
{
	ATLASSERT(lpsz == NULL);
	CString s = string;
	s += lpsz;
	return s;
}

inline CString __stdcall operator+(LPCTSTR lpsz, const CString& string)
{
	ATLASSERT(lpsz == NULL);
	CString s = lpsz;;
	s += string;
	return s;
}

inline CString __stdcall operator+(const CString& string, TCHAR c)
{
	CString s = string;
	s += c;
	return s;
}

inline CString __stdcall operator+(TCHAR c, const CString& string)
{
	CString s;
	s += c;
   s += string;
	return s;
}

}; // namespace IIS

#pragma warning(default:4786) // Enable warning for names > 256
#pragma warning(default:4275) 

#endif // !defined(IISCSTRING_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\inheritancedlg.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :

        inheritancedlg.h

   Abstract:

        Inheritance Dialog Definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef __INHERITANCEDLG__H__
#define __INHERITANCEDLG__H__


class CListBoxNodes : public CWindowImpl<CListBoxNodes, CListBox>
{
public:
   BEGIN_MSG_MAP(CListBoxNodes)
   END_MSG_MAP()
};

/*++

Class Description:

    Inheritance override checker dialog.

Public Interface:

    CInheritanceDlg         : Constructor
    IsEmpty                 : Check to see if there are overrides.

Notes:

    There are two constructors.  One which assumes GetDataPaths() has
    already been called, and which takes the results from GetDataPaths()
    as a CStringList, and a second constructor which will make the GetDataPaths
    automatically.

    In either case, the calling process should check IsEmpty() right after
    constructing the dialog to see if DoModal() needs to be called.  If
    IsEmpty() returns TRUE, there's no reason to call DoModal().

--*/
class CInheritanceDlg : 
   public CDialogImpl<CInheritanceDlg>,
   public CWinDataExchange<CInheritanceDlg>
{
//
// fWrite parameter helper definitions
//
#define FROM_WRITE_PROPERTY     (TRUE)
#define FROM_DELETE_PROPERTY    (FALSE)

//
// Construction
//
public:
   CInheritanceDlg() :
      m_fWrite(FALSE), m_fEmpty(FALSE), m_fHasInstanceInMaster(FALSE), m_fUseTable(FALSE),
      m_dwMDIdentifier(0), m_dwMDAttributes(0), m_dwMDUserType(0), m_dwMDDataType(0),
      m_mk((CComAuthInfo *)NULL)
   {
   }
   //
   // Standard constructor (GetDataPaths() already called)
   //
   CInheritanceDlg(
         DWORD dwMetaID,
         BOOL fWrite,
         CComAuthInfo * pAuthInfo,
         LPCTSTR lpstrMetaRoot,
         CStringListEx & strlMetaChildNodes,
         LPCTSTR lpstrPropertyName = NULL,
         HWND hwndParent = NULL
         );

    //
    // Constructor which will call GetDataPaths()
    //
    CInheritanceDlg(
         DWORD dwMetaID,
         BOOL fWrite,
         CComAuthInfo * pAuthInfo,
         LPCTSTR lpstrMetaRoot,
         LPCTSTR lpstrPropertyName            = NULL,
         HWND hwndParent                      = NULL
         );

    //
    // Constructor which will call GetDataPaths(), and which
    // does not use the predefined property table unless
    // fTryToFindInTable is TRUE, in which case it will attempt
    // to use the table first, and use the specified parameters
    // only if the property ID is not found in the table.
    //
    CInheritanceDlg(
         BOOL    fTryToFindInTable,
         DWORD   dwMDIdentifier,
         DWORD   dwMDAttributes,
         DWORD   dwMDUserType,
         DWORD   dwMDDataType,
         LPCTSTR lpstrPropertyName,
         BOOL    fWrite,
         CComAuthInfo * pAuthInfo,
         LPCTSTR lpstrMetaRoot,
         HWND    hwndParent = NULL                     
         );
public:
    enum { IDD = IDD_INHERITANCE };
    //
    // Check to see if there's a reason to continue displaying
    // the dialog.
    //
    BOOL IsEmpty() const { return m_fEmpty; }

//
// Dialog Data
//
protected:
    CListBoxNodes m_list_ChildNodes;

//
// Implementation
//
protected:
   BEGIN_MSG_MAP_EX(CInheritanceDlg)
      MSG_WM_INITDIALOG(OnInitDialog)
      COMMAND_HANDLER_EX(IDOK, BN_CLICKED, OnOK)
      COMMAND_HANDLER_EX(IDC_BUTTON_SELECT_ALL, BN_CLICKED, OnButtonSelectAll)
   END_MSG_MAP()

   LRESULT OnInitDialog(HWND hwnd, LPARAM lParam);
   void OnOK(WORD wNotifyCode, WORD wID, HWND hwndCtrl);
   void OnButtonSelectAll(WORD wNotifyCode, WORD wID, HWND hwndCtrl);

   BEGIN_DDX_MAP(CInheritanceDlg)
      DDX_CONTROL(IDC_LIST_CHILD_NODES, m_list_ChildNodes)
   END_DDX_MAP()

   void Initialize();
   HRESULT GetDataPaths();

   BOOL FriendlyInstance(
        IN  CString & strMetaRoot,
        OUT CString & strFriendly
        );

   CString & CleanDescendantPath(
        IN OUT CString & strMetaPath
        );

private:
   BOOL    m_fWrite;
   BOOL    m_fEmpty;
   BOOL    m_fHasInstanceInMaster;
   BOOL    m_fUseTable;
   DWORD   m_dwMDIdentifier;
   DWORD   m_dwMDAttributes;
   DWORD   m_dwMDUserType;
   DWORD   m_dwMDDataType;
   CString m_strMetaRoot;
   //CString m_strServer;
   CString m_strPropertyName;
   CStringListEx m_strlMetaChildNodes;
   CMetaKey m_mk;
};


#endif // __INHERITANCEDLG__H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\mdkeys.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :

        mdkeys.cpp

   Abstract:

        Metabase key wrapper class

   Author:

        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:
        2/17/2000    sergeia     removed dependency on MFC

--*/

//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "inheritancedlg.h"
#include "mdkeys.h"


//
// Constants
//
#define MB_TIMEOUT          (15000)     // Timeout in milliseconds 
#define MB_INIT_BUFF_SIZE   (  256)     // Initial buffer size


//
// CComAuthInfo implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

/* static */
BOOL
CComAuthInfo::SplitUserNameAndDomain(
    IN OUT CString & strUserName,
    IN CString & strDomainName
    )
/*++

Routine Description:

    Split the user name and domain from the given
    username, which is in the format "domain\user".

    Return TRUE if the user name contained a domain
    FALSE if it did not

Arguments:

    CString & strUserName   : User name which may contain a domain name
    CString & strDomainName : Output domain name ("." if local)

Return Value:

    TRUE if a domain is split off

--*/
{
    //
    // Assume local
    //
    strDomainName = _T(".");
    int nSlash = strUserName.Find(_T("\\"));

    if (nSlash >= 0)
    {
        strDomainName = strUserName.Left(nSlash);
        strUserName = strUserName.Mid(nSlash + 1);

        return TRUE;
    }

    return FALSE;
}


/* static */
DWORD
CComAuthInfo::VerifyUserPassword(
    IN LPCTSTR lpstrUserName,
    IN LPCTSTR lpstrPassword
    )
/*++

Routine Description:

    Verify the usernamer password combo checks out

Arguments:

    LPCTSTR lpstrUserName   : Domain/username combo
    LPCTSTR lpstrPassword   : Password

Return Value:

    ERROR_SUCCESS if the password checks out, an error code
    otherwise.

--*/
{
    CString strDomain;
    CString strUser(lpstrUserName);
    CString strPassword(lpstrPassword);

    SplitUserNameAndDomain(strUser, strDomain);

    //
    // In order to look up an account name, this process
    // must first be granted the privilege of doing so.
    //
    CError err;
    {
        HANDLE hToken;
        LUID AccountLookupValue;
        TOKEN_PRIVILEGES tkp;

        do
        {
            if (!::OpenProcessToken(GetCurrentProcess(),
                  TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                  &hToken)
               )
            {
                err.GetLastWinError();
                break;
            }

            if (!::LookupPrivilegeValue(NULL, SE_TCB_NAME, &AccountLookupValue))
            {
                err.GetLastWinError();
                break;
            }

            tkp.PrivilegeCount = 1;
            tkp.Privileges[0].Luid = AccountLookupValue;
            tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            ::AdjustTokenPrivileges(
                hToken,
                FALSE,
                &tkp,
                sizeof(TOKEN_PRIVILEGES),
                (PTOKEN_PRIVILEGES)NULL,
                (PDWORD)NULL
                );

            err.GetLastWinError();

            if (err.Failed())
            {
                break;
            }

            HANDLE hUser = NULL;

            if (::LogonUser(
                (LPTSTR)(LPCTSTR)strUser,
                (LPTSTR)(LPCTSTR)strDomain,
                (LPTSTR)(LPCTSTR)strPassword,
                LOGON32_LOGON_NETWORK,
                LOGON32_PROVIDER_DEFAULT,
                &hUser
                ))
            {
                //
                // Success!
                //
                CloseHandle(hUser);
            }
            else
            {
                err.GetLastWinError();
            }

            //
            // Remove the privilege
            //
        }
        while(FALSE);
    }

    HANDLE hUser = NULL;

    if (::LogonUser(
        (LPTSTR)(LPCTSTR)strUser,
        (LPTSTR)(LPCTSTR)strDomain,
        (LPTSTR)(LPCTSTR)strPassword,
        LOGON32_LOGON_NETWORK,
        LOGON32_PROVIDER_DEFAULT,
        &hUser))
    {
        //
        // Success!
        //
        CloseHandle(hUser);
    }
    else
    {
        err.GetLastWinError();
    }

    return err;
}



CComAuthInfo::CComAuthInfo(
    IN LPCOLESTR lpszServerName     OPTIONAL,
    IN LPCOLESTR lpszUserName       OPTIONAL,
    IN LPCOLESTR lpszPassword       OPTIONAL
    )
/*++

Routine Description:

    Construct CIIServer object

Argument:

    LPCOLESTR lpszServerName     : Server name or NULL for local computer
    LPCOLESTR lpszUserName       : User name of blank for no impersonation
    LPCOLESTR lpszPassword       : Password (might be blank or NULL)

Return Value:

    N/A

--*/
    : m_bstrServerName(),
      m_bstrUserName(lpszUserName),
      m_bstrPassword(lpszPassword),
      m_fLocal(FALSE)
{
    SetComputerName(lpszServerName);
}



CComAuthInfo::CComAuthInfo(
    IN CComAuthInfo & auth
    )
/*++

Routine Description:

    Copy constructor

Arguments:

    CComAuthInfo & auth    : Source object to copy from

Return Value:

    N/A

--*/
    : m_bstrServerName(auth.m_bstrServerName),
      m_bstrUserName(auth.m_bstrUserName),
      m_bstrPassword(auth.m_bstrPassword),
      m_fLocal(auth.m_fLocal)
{
}



CComAuthInfo::CComAuthInfo(
    IN CComAuthInfo * pAuthInfo        OPTIONAL
    )
/*++

Routine Description:

    Copy constructor

Arguments:

    CComAuthInfo * pAuthInfo    : Source object to copy from (or NULL)

Return Value:

    N/A

--*/
    : m_bstrServerName(),
      m_bstrUserName(),
      m_bstrPassword(),
      m_fLocal(FALSE)
{
    if (pAuthInfo)
    {
        //
        // Full authentication information available
        //
        m_bstrUserName = pAuthInfo->m_bstrUserName;
        m_bstrPassword = pAuthInfo->m_bstrPassword;
        m_bstrServerName = pAuthInfo->m_bstrServerName;
        m_fLocal = pAuthInfo->m_fLocal;
    }
    else
    {
        //
        // Local computer w/o impersonation
        //
        SetComputerName(NULL);
    }
}



CComAuthInfo & 
CComAuthInfo::operator =(
    IN CComAuthInfo & auth
    )
/*++

Routine Description:

    Assignment operator

Arguments:

    CComAuthInfo & auth     : Source object to copy from

Return Value:

    Reference to current object

--*/
{
    m_bstrServerName = auth.m_bstrServerName;
    m_bstrUserName   = auth.m_bstrUserName;
    m_bstrPassword   = auth.m_bstrPassword;
    m_fLocal         = auth.m_fLocal;

    return *this;
}



CComAuthInfo & 
CComAuthInfo::operator =(
    IN CComAuthInfo * pAuthInfo       OPTIONAL
    )
/*++

Routine Description:

    Assignment operator

Arguments:

    CComAuthInfo * pAuthInfo : Source object to copy from (or NULL)

Return Value:

    Reference to current object

--*/
{
    if (pAuthInfo)
    {
        m_bstrUserName = pAuthInfo->m_bstrUserName;
        m_bstrPassword = pAuthInfo->m_bstrPassword;
        SetComputerName(pAuthInfo->m_bstrServerName);
    }
    else
    {
        //
        // Local computer w/o impersonation
        //
        m_bstrUserName.Empty();
        m_bstrPassword.Empty();
        SetComputerName(NULL);
    }

    return *this;
}


CComAuthInfo & 
CComAuthInfo::operator =(
    IN LPCTSTR lpszServerName
    )
/*++

Routine Description:

    Assignment operator.  Assign computer name w/o impersonation

Arguments:

    LPCTSTR lpszServerName      : Source server name

Return Value:

    Reference to current object

--*/
{
    RemoveImpersonation();
    SetComputerName(lpszServerName);

    return *this;
}



void
CComAuthInfo::SetComputerName(
    IN LPCOLESTR lpszServerName   OPTIONAL
    )
/*++

Routine Description:

    Store the computer name.  Determine if its local.

Arguments:

    LPCOLESTR lpszServername  : Server name.  NULL indicates the local computer

Return Value:

    None

--*/
{
    if (lpszServerName && *lpszServerName)
    {
        //
        // Specific computer name specified
        //
        m_bstrServerName = lpszServerName;
        m_fLocal = ::IsServerLocal(lpszServerName);
    }
    else
    {
        //
        // Use local computer name
        //
        // CODEWORK: Cache static version of computername maybe?
        // 
        TCHAR szLocalServer[MAX_PATH + 1];
        DWORD dwSize = MAX_PATH;

        VERIFY(::GetComputerName(szLocalServer, &dwSize));
        m_bstrServerName = szLocalServer;
        m_fLocal = TRUE;
    }
}



void     
CComAuthInfo::SetImpersonation(
    IN LPCOLESTR lpszUser, 
    IN LPCOLESTR lpszPassword
    )
/*++

Routine Description:

    Set impersonation parameters

Arguments:

    LPCOLESTR lpszUser          : User name
    LPCOLESTR lpszPassword      : Password

Return Value:

    None

--*/
{
    m_bstrUserName = lpszUser;
    StorePassword(lpszPassword);
}



void     
CComAuthInfo::RemoveImpersonation()
/*++

Routine Description:

    Remove impersonation parameters

Arguments:

    None

Return Value:

    None

--*/
{
    m_bstrUserName.Empty();
    m_bstrPassword.Empty();
}

COSERVERINFO * 
CComAuthInfo::CreateServerInfoStruct() const
{
    return (CComAuthInfo::CreateServerInfoStruct(RPC_C_AUTHN_LEVEL_DEFAULT));
}

COSERVERINFO * 
CComAuthInfo::CreateServerInfoStruct(DWORD dwAuthnLevel) const
/*++

Routine Description:

    Create the server info structure.  Might return NULL for the no frills case.

Arguments:

    NULL

Return Value:

    A COSERVERINFO structure, or NULL if the computer is local, and no
    impersonation is required.

Notes:

    Caller must call FreeServerInfoStruct() to prevent memory leaks

--*/
{
    //
    // Be smart about the server name; optimize for local
    // computer name.
    //
    if (m_fLocal && !UsesImpersonation())
    {
        //
        // Special, no-frills case. 
        //
        return NULL;
    }

    //
    // Create the COM server info for CoCreateInstanceEx
    //
    COSERVERINFO * pcsiName = NULL;

    do
    {
        pcsiName = new COSERVERINFO;

        if (!pcsiName)
        {
            break;
        }
        ZeroMemory(pcsiName, sizeof(COSERVERINFO));
        pcsiName->pwszName = m_bstrServerName;

        //
        // Set impersonation 
        //
        if (UsesImpersonation())
        {
            COAUTHINFO * pAuthInfo = new COAUTHINFO;

            if (!pAuthInfo)
            {
                break;
            }
            ZeroMemory(pAuthInfo, sizeof(COAUTHINFO));

            COAUTHIDENTITY * pAuthIdentityData = new COAUTHIDENTITY;

            if (!pAuthIdentityData)
            {
                break;
            }
            ZeroMemory(pAuthIdentityData, sizeof(COAUTHIDENTITY));

            CString strUserName(m_bstrUserName);
            CString strPassword(m_bstrPassword);
            CString strDomain;

            //
            // Break up domain\username combo
            //
            SplitUserNameAndDomain(strUserName, strDomain);

            pAuthIdentityData->UserLength = strUserName.GetLength();

            if (pAuthIdentityData->UserLength != 0)
            {
                pAuthIdentityData->User = StrDup(strUserName);
            }

            pAuthIdentityData->DomainLength = strDomain.GetLength();

            if (pAuthIdentityData->DomainLength != 0)
            {
                pAuthIdentityData->Domain = StrDup(strDomain);
            }

            pAuthIdentityData->PasswordLength = strPassword.GetLength();

            if (pAuthIdentityData->PasswordLength)
            {
                pAuthIdentityData->Password = StrDup(strPassword);
            }

            // RPC_C_AUTHN_LEVEL_DEFAULT       0 
            // RPC_C_AUTHN_LEVEL_NONE          1 
            // RPC_C_AUTHN_LEVEL_CONNECT       2 
            // RPC_C_AUTHN_LEVEL_CALL          3 
            // RPC_C_AUTHN_LEVEL_PKT           4 
            // RPC_C_AUTHN_LEVEL_PKT_INTEGRITY 5 
            // RPC_C_AUTHN_LEVEL_PKT_PRIVACY   6 
            // you can only specify stuff stronger than RPC_C_AUTHN_LEVEL_CONNECT
            if (RPC_C_AUTHN_LEVEL_DEFAULT != dwAuthnLevel)
            {
                if (dwAuthnLevel >= RPC_C_AUTHN_LEVEL_CONNECT && dwAuthnLevel <= RPC_C_AUTHN_LEVEL_PKT_PRIVACY)
                {
                    pAuthInfo->dwAuthnLevel = dwAuthnLevel;
                }
                else
                {
                    pAuthInfo->dwAuthnLevel = RPC_C_AUTHN_LEVEL_CONNECT;
                }
            }
            else
            {
                pAuthInfo->dwAuthnLevel = RPC_C_AUTHN_LEVEL_DEFAULT;
            }
            pAuthIdentityData->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
            pAuthInfo->dwImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
            pAuthInfo->dwAuthnSvc = RPC_C_AUTHN_WINNT;
            pAuthInfo->dwAuthzSvc = RPC_C_AUTHZ_NONE;
            pAuthInfo->pwszServerPrincName = NULL;
            pAuthInfo->dwCapabilities = EOAC_NONE;
            pAuthInfo->pAuthIdentityData = pAuthIdentityData;
            pcsiName->pAuthInfo = pAuthInfo;
        }
    }
    while(FALSE);

    return pcsiName;
}



void 
CComAuthInfo::FreeServerInfoStruct(
    IN COSERVERINFO * pServerInfo
    ) const
/*++

Routine Description:

    As mentioned above -- free the server info structure

Arguments:

    COSERVERINFO * pServerInfo  : Server info structure

Return Value:

    None

--*/
{
    if (pServerInfo)
    {
        if (pServerInfo->pAuthInfo)
        {
            if (pServerInfo->pAuthInfo->pAuthIdentityData)
            {
                if (pServerInfo->pAuthInfo->pAuthIdentityData)
                {
                    LocalFree(pServerInfo->pAuthInfo->pAuthIdentityData->User);
                    LocalFree(pServerInfo->pAuthInfo->pAuthIdentityData->Domain);
                    LocalFree(pServerInfo->pAuthInfo->pAuthIdentityData->Password);
                    delete pServerInfo->pAuthInfo->pAuthIdentityData;
                }
            }

            delete pServerInfo->pAuthInfo;
        }

        delete pServerInfo;
    }
}



HRESULT
CComAuthInfo::ApplyProxyBlanket(
    IN OUT IUnknown * pInterface
    )
/*++

Routine Description:

    Set security information on the interface.  The user name is of the form
    domain\username.

Arguments:

    IUnknown * pInterface       : Interface

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    COSERVERINFO * pcsiName = CreateServerInfoStruct();

    //
    // This method should only be called if we're using impersonation.
    // so the pcsiName returned should never be NULL.
    //
    ATLASSERT(pcsiName && pcsiName->pAuthInfo);

    DWORD dwAuthSvc, dwAuthzSvc, dwAuthnLevel, dwImplLevel, dwCaps;
    OLECHAR * pServerPrincName;
    RPC_AUTH_IDENTITY_HANDLE pAuthInfo;

    hr = ::CoQueryProxyBlanket(
       pInterface,
       &dwAuthSvc,
       &dwAuthzSvc,
       &pServerPrincName,
       &dwAuthnLevel,
       &dwImplLevel,
       &pAuthInfo,
       &dwCaps);

    if (pcsiName && pcsiName->pAuthInfo)
    {
        hr =  ::CoSetProxyBlanket(
            pInterface,
            pcsiName->pAuthInfo->dwAuthnSvc,
            pcsiName->pAuthInfo->dwAuthzSvc,
            pcsiName->pAuthInfo->pwszServerPrincName,
            pcsiName->pAuthInfo->dwAuthnLevel,
            pcsiName->pAuthInfo->dwImpersonationLevel,
            pcsiName->pAuthInfo->pAuthIdentityData,
            pcsiName->pAuthInfo->dwCapabilities    
            );

        FreeServerInfoStruct(pcsiName);
    }

    return hr;
}

HRESULT
CComAuthInfo::ApplyProxyBlanket(
    IN OUT IUnknown * pInterface,
	IN DWORD dwAuthnLevelInput
    )
/*++

Routine Description:

    Set security information on the interface.  The user name is of the form
    domain\username.

Arguments:

    IUnknown * pInterface       : Interface

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    COSERVERINFO * pcsiName = CreateServerInfoStruct(dwAuthnLevelInput);

    //
    // This method should only be called if we're using impersonation.
    // so the pcsiName returned should never be NULL.
    //
    ATLASSERT(pcsiName && pcsiName->pAuthInfo);

    DWORD dwAuthSvc, dwAuthzSvc, dwAuthnLevel, dwImplLevel, dwCaps;
    OLECHAR * pServerPrincName;
    RPC_AUTH_IDENTITY_HANDLE pAuthInfo;

    hr = ::CoQueryProxyBlanket(
       pInterface,
       &dwAuthSvc,
       &dwAuthzSvc,
       &pServerPrincName,
       &dwAuthnLevel,
       &dwImplLevel,
       &pAuthInfo,
       &dwCaps);

    if (pcsiName && pcsiName->pAuthInfo)
    {
        hr =  ::CoSetProxyBlanket(
            pInterface,
            pcsiName->pAuthInfo->dwAuthnSvc,
            pcsiName->pAuthInfo->dwAuthzSvc,
            pcsiName->pAuthInfo->pwszServerPrincName,
            pcsiName->pAuthInfo->dwAuthnLevel,
            pcsiName->pAuthInfo->dwImpersonationLevel,
            pcsiName->pAuthInfo->pAuthIdentityData,
            pcsiName->pAuthInfo->dwCapabilities    
            );

        FreeServerInfoStruct(pcsiName);
    }

    return hr;
}

//
// CMetabasePath implemention
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



const LPCTSTR CMetabasePath::_cszMachine = SZ_MBN_MACHINE;
const LPCTSTR CMetabasePath::_cszRoot    = SZ_MBN_ROOT;
const LPCTSTR CMetabasePath::_cszSep     = SZ_MBN_SEP_STR;
const TCHAR   CMetabasePath::_chSep      = SZ_MBN_SEP_CHAR;
const CString CMetabasePath::_anySep     = SZ_MBN_ANYSEP_STR;

/*static*/
BOOL
CMetabasePath::IsSeparator(TCHAR c)
{
   return _anySep.find(c) != CString::npos;
}

/* static */
LPCTSTR
CMetabasePath::ConvertToParentPath(
    OUT IN CString & strMetaPath
    )
/*++

Routine Description:

    Given the path, convert it to the parent path
    e.g. "foo/bar/etc" returns "foo/bar"

Arguments:

    CString & strMetaPath    : Path to be converted

Return value:

    Pointer to the converted path, or NULL in case of error

--*/
{
//   TRACE(_T("Getting parent path of %s\n"), strMetaPath);

   CString::size_type pos, pos_head;
   if ((pos = strMetaPath.find_last_of(SZ_MBN_ANYSEP_STR)) == strMetaPath.length() - 1)
   {
      strMetaPath.erase(pos);
   }
   pos = strMetaPath.find_last_of(SZ_MBN_ANYSEP_STR);
   if (pos == CString::npos)
      return strMetaPath;
   pos_head = strMetaPath.find_first_of(SZ_MBN_ANYSEP_STR);
   if (pos_head != pos)
   {
      strMetaPath.erase(pos);
   }

//   TRACE(_T("Parent path should be %s\n"), strMetaPath);

   return strMetaPath;
}

LPCTSTR
CMetabasePath::ConvertToParentPath(
    CMetabasePath& path
    )
{
   return CMetabasePath::ConvertToParentPath(path.m_strMetaPath);
}

/* static */
LPCTSTR
CMetabasePath::TruncatePath(
    IN  int nLevel,          
    IN  LPCTSTR lpszMDPath,
    OUT CString & strNewPath,
    OUT CString * pstrRemainder     OPTIONAL
    )
/*++

Routine Description:

    Truncate the given metabase path at the given level, that is, 
    the nLevel'th separator in the path, starting at 0, where 0 will
    always give lpszPath back whether it started with a separator or not.

    Examples: 

        "/lm/w3svc/1/foo" at level 2 returns "/lm/w3svc" as does
        "lm/w3svc/1/foo".
    
Arguments:

    int     nLevel             0-based separator count to truncate at.
    LPTSTR lpszMDPath          Fully-qualified metabase path
    CString & strNewPath       Returns truncated path
    CString * pstrRemainder    Optionally returns the remainder past
                               the nLevel'th separator.

Return Value:

    The truncated path at the level requested.  See examples above. *pstrRemainder
    returns the remainder of the path.  If the path does not contain nLevel
    worth of separators, the entire path is returned, and the remainder will be
    blank. 

--*/
{
//    ASSERT_PTR(lpszMDPath);
    ATLASSERT(nLevel >= 0);

    if (!lpszMDPath || nLevel < 0)
    {
//        TRACE(_T("TruncatePath: Invalid parameter\n"));
        return NULL;
    }

//    TRACE(_T("Source Path: %s\n"), lpszMDPath);

    //
    // Skip the first sep whether it exists or not
    //
    LPCTSTR lp = IsSeparator(*lpszMDPath) ? lpszMDPath + 1 : lpszMDPath;
    LPCTSTR lpRem = NULL;
    int cSeparators = 0;

    if (nLevel)
    {
        //
        // Advance to the requested separator level
        //
        while (*lp)
        {
            if (IsSeparator(*lp))
            {
                if (++cSeparators == nLevel)
                {
                    break;
                }
            }

            ++lp;
        }

        if (!*lp)
        {
            //
            // End of path is considered a separator
            //
            ++cSeparators;
        }

        ATLASSERT(cSeparators <= nLevel);

        if (cSeparators == nLevel)
        {
            //
            // Break up the strings
            //
            strNewPath = lpszMDPath;
            strNewPath.erase(lp - lpszMDPath);

//            TRACE(_T("Path truncated at level %d : %s\n"), nLevel, strNewPath);

            if (*lp)
            {
                lpRem = ++lp;
//                TRACE(_T("Remainder: %s\n"), lpRem);
            }
        }
    }

    //
    // Return remainder
    //
    if (pstrRemainder && lpRem)
    {
//        ASSERT_WRITE_PTR(pstrRemainder);
        *pstrRemainder = lpRem;
    }

    return strNewPath;
}



/* static */
DWORD 
CMetabasePath::GetInstanceNumber(
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Get the number of the instance referred to in the given metabase
    path.  
    
    Examples:  "lm/w3svc/1/foo/bar" will return 1
               "lm/w3svc/"          will return 0 (master instance)
               "lm/bogus/path/"     will return 0xffffffff (error)

Arguments:

    LPCTSTR lpszMDPath      : A metabase path.

Return Value:

    Instance number (0 indicates master instance)
    or 0xffffffff if the path is in error.

--*/
{
//    TRACE(_T("Determining instance number of %s\n"), lpszMDPath);
    DWORD dwInstance = 0xffffffff;

    CString strService, strInst;

    if (GetServicePath(lpszMDPath, strService, &strInst))
    {
        if (strInst.IsEmpty())
        {
            dwInstance = MASTER_INSTANCE;
        }
        else
        {
            if (_istdigit(strInst.GetAt(0)))  
            {
                dwInstance = _ttol(strInst);
            }
        }
    }

    return dwInstance;
}



/* static */
LPCTSTR
CMetabasePath::GetLastNodeName(
    IN  LPCTSTR lpszMDPath,
    OUT CString & strNodeName
    )
/*++

Routine Description:

    Get the last nodename off the metabase path

    Example:

        "/lm/foo/bar/"      returns "bar"

Arguments:

    LPCTSTR lpszMDPath      : Metabase path

Return Value:

    Pointer to the node name or NULL in case of a malformed path.

--*/
{
//    ASSERT_PTR(lpszMDPath);

    if (!lpszMDPath || !*lpszMDPath)
    {
        return NULL;
    }

//    TRACE(_T("Getting last node name from %s\n"), lpszMDPath);

    LPCTSTR lp;
    LPCTSTR lpTail;
    lp = lpTail = lpszMDPath + lstrlen(lpszMDPath) - 1;

    //
    // Skip trailing separator
    //
    if (IsSeparator(*lp))
    {
        --lpTail;
        --lp;
    }

    strNodeName.Empty();

    while (*lp && !IsSeparator(*lp))
    {
        strNodeName += *(lp--);
    }

    strNodeName.MakeReverse();

//    TRACE(_T("Node is %s\n"), strNodeName);
    
    return strNodeName;    
}



/* static */
void
CMetabasePath::SplitMetaPathAtInstance(
    IN  LPCTSTR lpszMDPath,
    OUT CString & strParent,
    OUT CString & strAlias
    )
/*++

Routine Description:

    Split the given path into parent metabase root and alias, with the root
    being the instance path, and the alias everything following the
    instance.

Arguments:

    LPCTSTR lpszMDPath  : Input path
    CString & strParent : Outputs the parent path
    CString & strAlias  : Outputs the alias name

Return Value:

    None.

--*/
{
//    ASSERT_PTR(lpszMDPath);

//    TRACE(_T("Source Path %s\n"), lpszMDPath);

    strParent = lpszMDPath;
    strAlias.Empty();

    LPTSTR lp = (LPTSTR)lpszMDPath;

    if (lp == NULL)
    {
       return;
    }

    int cSeparators = 0;
    int iChar = 0;

    //
    // Looking for "LM/sss/ddd/" <-- 3d slash:
    //
    while (*lp && cSeparators < 2)
    {
        if (IsSeparator(*lp))
        {
            ++cSeparators;
        }

        ++iChar;
    }

    if (!*lp)
    {
        //
        // Bogus format
        //
        ASSERT_MSG("Bogus Format");
        return;
    }

    if (_istdigit(*lp))
    {
        //
        // Not at the master instance, skip one more.
        //
        while (*lp)
        {
            ++iChar;

            if (IsSeparator(*lp++))
            {
                break;
            }
        }

        if (!*lp)
        {
            //
            // Bogus format
            //
            ASSERT_MSG("Bogus Format");
            return;
        }
    }

    strAlias = strParent.Mid(iChar);
    strParent.erase(iChar);

//    TRACE(_T("Broken up into %s\n"), strParent);
//    TRACE(_T("           and %s\n"), strAlias);
}



/* static */
BOOL 
CMetabasePath::IsHomeDirectoryPath(
    IN LPCTSTR lpszMetaPath
    )
/*++

Routine Description:

    Determine if the path given describes a root directory

Arguments:

    LPCTSTR lpszMetaPath        : Metabase path

Return Value:

    TRUE if the path describes a root directory, 
    FALSE if it does not

--*/
{
//    ASSERT_READ_PTR(lpszMetaPath);

    LPTSTR lpNode = lpszMetaPath ? StrPBrk(lpszMetaPath, _anySep) : NULL;

    if (lpNode)
    {
        return _tcsicmp(++lpNode, _cszRoot) == 0;
    }

    return FALSE;
}



/* static */
BOOL 
CMetabasePath::IsMasterInstance(
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Determine if the given metabase path points to the master instance
    (site).  This is essentially the service path.

Arguments:

    LPCTSTR lpszMDPath  : Metabase path.

Return Value:

    TRUE if the path is the master instance,
    FALSE otherwise.

--*/
{
//    ASSERT_READ_PTR(lpszMDPath);

    if (!lpszMDPath || !*lpszMDPath)
    {
        return FALSE;
    }

//    TRACE(_T("Checking path %s\n"), lpszMDPath);

    CString strService;
    CString strRemainder;

    LPCTSTR lpPath = TruncatePath(2, lpszMDPath, strService, &strRemainder);

    return lpPath && !strService.IsEmpty() && strRemainder.IsEmpty();
}



/* static */
LPCTSTR
CMetabasePath::GetServiceInfoPath(
    IN  LPCTSTR lpszMDPath,
    OUT CString & strInfoPath,   
    IN  LPCTSTR lpszDefService      OPTIONAL
    )
/*++

Routine Description:

    Generate the appropriate metabase service info path for the given
    metabase path.  

    For example:

        "lm/w3svc/1/foo/bar"    Generates "lm/w3svc/info"

Arguments:

    LPCTSTR lpszMDPath      : Input metabase path
    CString & strInfoPath   : Returns the info path
    LPCTSTR lpszDefService  : Optionally specifies the default service to
                              use (e.g "w3svc") if no service could be found
                              in the path.
    
Return Value:

    The info metabase path or NULL if one could not be generated.

--*/
{
    //
    // Capability info stored off the service path ("lm/w3svc").
    //
    CString strService;
    CString strRem;
   
    //
    // Strip off everything past the service
    //
    if (!TruncatePath(2, lpszMDPath, strService, &strRem)
      || strService.IsEmpty())
    {
        if (!lpszDefService)
        {
//            TRACEEOLID("Unable to generate info path");
            return NULL;
        }

        TRACEEOLID("Using default service for info path");

        //
        // Machine path (no service).  Use web as default service to
        // look for capability and version info.
        //
        strService = CMetabasePath(TRUE, lpszDefService);
    }

    strInfoPath = CMetabasePath(FALSE, strService, SZ_MBN_INFO);
//    TRACE("Using %s to look for capability info\n", strInfoPath);

    return strInfoPath;
}
 


/* static */
LPCTSTR
CMetabasePath::CleanMetaPath(
    IN OUT CString & strMetaRoot
    )
/*++

Routine Description:

    Clean up the metabase path to one valid for internal consumption.
    This removes the beginning and trailing slashes off the path.

Arguments:

    CString & strMetaRoot       : Metabase path to be cleaned up.

Return Value:

    Pointer to the metabase path

--*/
{
   if (!strMetaRoot.IsEmpty())
   {
      int hd = strMetaRoot.find_first_not_of(SZ_MBN_ANYSEP_STR);
      int tl = strMetaRoot.find_last_not_of(SZ_MBN_ANYSEP_STR);
      if (hd == CString::npos && tl == CString::npos)
      {
         // path contains only separators
         strMetaRoot.erase();
         return strMetaRoot;
      }
      else if (hd != CString::npos)
      {
         if (tl != CString::npos)
            tl++;
         strMetaRoot = strMetaRoot.substr(hd, tl - hd);
      }
#if 0
        while (strMetaRoot.GetLength() > 0 
            && IsSeparator(strMetaRoot[strMetaRoot.GetLength() - 1]))
        {
            strMetaRoot.erase(strMetaRoot.GetLength() - 1);
        }

        while (strMetaRoot.GetLength() > 0 
           && IsSeparator(strMetaRoot[0]))
        {
            strMetaRoot = strMetaRoot.Right(strMetaRoot.GetLength() - 1);
        }
#endif
        // looks like IISAdmin works only with separators "/"
       for (int i = 0; i < strMetaRoot.GetLength(); i++)
       {
          if (IsSeparator(strMetaRoot[i]))
             strMetaRoot.SetAt(i, _chSep);
       }
   }
   return strMetaRoot;
}


/* static */
LPCTSTR
CMetabasePath::CleanMetaPath(
    IN OUT CMetabasePath & path
    )
{
   return CleanMetaPath(path.m_strMetaPath);
}

CMetabasePath::CMetabasePath(
    IN BOOL    fAddBasePath,
    IN LPCTSTR lpszMDPath,
    IN LPCTSTR lpszMDPath2  OPTIONAL,
    IN LPCTSTR lpszMDPath3  OPTIONAL,
    IN LPCTSTR lpszMDPath4  OPTIONAL
    )
/*++

Routine Description:

    Constructor.

Arguments:

    BOOL    fAddBasePath    : TRUE to prepend base path ("LM")
                              FALSE if the path is complete
    LPCTSTR lpszMDPath      : Metabase path
    LPCTSTR lpszMDPath2     : Optional child path
    LPCTSTR lpszMDPath3     : Optional child path
    LPCTSTR lpszMDPath4     : Optional child path

Return Value:

    N/A

--*/
    : m_strMetaPath()
{
//    This will fail for NULL pointer
//    ASSERT_READ_PTR(lpszMDPath);

    if (fAddBasePath)
    {
        m_strMetaPath = _cszMachine;
        AppendPath(lpszMDPath);
    }
    else
    {
        m_strMetaPath = lpszMDPath;
    }

    //
    // Add optional path components
    //    
    AppendPath(lpszMDPath2);
    AppendPath(lpszMDPath3);
    AppendPath(lpszMDPath4);
}



CMetabasePath::CMetabasePath(
    IN  LPCTSTR lpszSvc,        OPTIONAL
    IN  DWORD   dwInstance,     OPTIONAL
    IN  LPCTSTR lpszParentPath, OPTIONAL
    IN  LPCTSTR lpszAlias       OPTIONAL
    )
/*++

Routine Description:

    Constructor.  Construct with path components.

Arguments:

    LPCTSTR lpszSvc         : Service (may be NULL or "")
    DWORD   dwInstance      : Instance number (may be 0 for master)
    LPCTSTR lpszParentPath  : Parent path (may be NULL or "")
    LPCTSTR lpszAlias       : Alias (may be NULL or "")

Return Value:

    N/A

--*/
    : m_strMetaPath()
{
    BuildMetaPath(lpszSvc, dwInstance, lpszParentPath, lpszAlias);
}



void 
CMetabasePath::AppendPath(
    IN LPCTSTR lpszPath
    )
/*++

Routine Description:

    Append path to current metabase path

Arguments:

    LPCTSTR lpszPath        : Metabase path

Return Value:

    None

--*/
{
    if (lpszPath && *lpszPath)
    {
        m_strMetaPath += _cszSep;
        m_strMetaPath += lpszPath;
    }
}



void 
CMetabasePath::AppendPath(
    IN DWORD dwInstance
    )
/*++

Routine Description:

    Append path to current metabase path

Arguments:

    DWORD dwInstance        : Instance path

Return Value:

    None

--*/
{
//    ASSERT(dwInstance >= 0);

    if (!IS_MASTER_INSTANCE(dwInstance))
    {
        TCHAR szInstance[] = _T("4000000000");
        _ltot(dwInstance, szInstance, 10);

        m_strMetaPath += _cszSep;
        m_strMetaPath += szInstance;
    }
}



void
CMetabasePath::BuildMetaPath(
    IN  LPCTSTR lpszSvc            OPTIONAL,
    IN  LPCTSTR lpszInstance       OPTIONAL,
    IN  LPCTSTR lpszParentPath     OPTIONAL,
    IN  LPCTSTR lpszAlias          OPTIONAL
    )
/*++

Routine Description:

    Build a complete metapath with the given service name, instance
    number and optional path components.

Arguments:

    LPCTSTR lpszSvc         : Service (may be NULL or "")
    LPCTSTR lpszInstance    : Instance (may be NULL or "")
    LPCTSTR lpszParentPath  : Parent path (may be NULL or "")
    LPCTSTR lpszAlias       : Alias (may be NULL or "")

Return Value:

    Pointer to internal buffer containing the path.

--*/
{
    m_strMetaPath = _cszMachine;

    AppendPath(lpszSvc);
    AppendPath(lpszInstance);
    AppendPath(lpszParentPath);

    if (lpszAlias && *lpszAlias)
    {
        //
        // Special case: If the alias is root, but we're
        // at the master instance, ignore this.
        //
        if (lpszInstance || ::lstrcmpi(_cszRoot, lpszAlias))
        {
            m_strMetaPath += _cszSep;
            m_strMetaPath += lpszAlias;
        }
    }

//    TRACE(_T("Generated metapath: %s\n"), m_strMetaPath );
}




void
CMetabasePath::BuildMetaPath(
    IN  LPCTSTR lpszSvc            OPTIONAL,
    IN  DWORD   dwInstance         OPTIONAL,
    IN  LPCTSTR lpszParentPath     OPTIONAL,
    IN  LPCTSTR lpszAlias          OPTIONAL
    )
/*++

Routine Description:

    Build a complete metapath with the given service name, instance
    number and optional path components.

Arguments:

    LPCTSTR lpszSvc         : Service (may be NULL or "")
    DWORD   dwInstance      : Instance number (may be 0 for master)
    LPCTSTR lpszParentPath  : Parent path (may be NULL or "")
    LPCTSTR lpszAlias       : Alias (may be NULL or "")

Return Value:

    Pointer to internal buffer containing the path.

--*/
{
    m_strMetaPath = _cszMachine;

    AppendPath(lpszSvc);
    AppendPath(dwInstance);
    AppendPath(lpszParentPath);

    if (lpszAlias && *lpszAlias)
    {
        //
        // Special case: If the alias is root, but we're
        // at the master instance, ignore this.
        //
        if (!IS_MASTER_INSTANCE(dwInstance) || ::lstrcmpi(_cszRoot, lpszAlias))
        {
            m_strMetaPath += _cszSep;
            m_strMetaPath += lpszAlias;
        }
    }

//    TRACE(_T("Generated metapath: %s\n"), m_strMetaPath);
}


//
// CIISInterface class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CIISInterface::CIISInterface(
    IN CComAuthInfo * pAuthInfo,    OPTIONAL
    IN HRESULT hrInterface          OPTIONAL
    )
/*++

Routine Description:

    Base class constructor.  

Arguments:

    CComAuthInfo * pAuthInfo : Auth info or NULL for local computer
    HRESULT hrInterface      : Initial error code. S_OK by default.

Return Value:

    N/A

--*/
    : m_auth(pAuthInfo),
      m_hrInterface(hrInterface)
{
}



HRESULT 
CIISInterface::Create(
    IN  int   cInterfaces,       
    IN  const IID rgIID[],      
    IN  const GUID rgCLSID[],    
    OUT int * pnInterface,          OPTIONAL
    OUT IUnknown ** ppInterface 
    )
/*++

Routine Description:

    Create interface.  This will try a range of interfaces in order of priority.

Arguments:

    int   cInterfaces       : Number of interfaces in array.
    const IID * rgIID       : Array if IIDs
    const GUID * rgCLSID    : Array of CLSIDs
    int * pnInterface       : Returns the interface index that was successful.
                              or NULL if not interested.
    IUnknown ** ppInterface : Returns pointer to the interface.

Return Value:

    HRESULT

Notes:

    This will attempt to create an interface, in order of declaration in 
    the IID and CLSIS arrays.  The first successful interface to be created
    will have its index returned in *pnInterfaces.

--*/
{
    ASSERT(cInterfaces > 0);
    ASSERT(rgIID && rgCLSID && ppInterface);
    
    COSERVERINFO * pcsiName = m_auth.CreateServerInfoStruct();

    MULTI_QI rgmqResults;
    
    CError err;
    int    nInterface;

    //
    // Try to create the interface in order
    //
    for (nInterface = 0; nInterface < cInterfaces; ++nInterface)
    {
        ZeroMemory(&rgmqResults, sizeof(rgmqResults));
        rgmqResults.pIID = &rgIID[nInterface];

//        TRACE("Attempting to create interface #%d\n", nInterface);
        err = ::CoCreateInstanceEx(
            rgCLSID[nInterface],
            NULL,
            CLSCTX_SERVER,
            pcsiName,
            1,
            &rgmqResults
            );

        if (err.Succeeded() || err.Win32Error() == ERROR_ACCESS_DENIED)
        {
            break;
        }
    }

    if(err.Succeeded())
    {
        //
        // Save the interface pointer
        //
        ASSERT_PTR(rgmqResults.pItf);
        *ppInterface = rgmqResults.pItf;

        if (pnInterface)
        {
            //
            // Store successful interface index
            //
            *pnInterface = nInterface;
        }

        //
        // Strangely enough, I now have still have to apply
        // the proxy blanket.  Apparently this is by design.
        //
        if (m_auth.UsesImpersonation())
        {
            ApplyProxyBlanket();
        }
    }

    //
    // Clean up
    //
    m_auth.FreeServerInfoStruct(pcsiName);

    return err;
}


//
// CMetaInterface class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

CMetaInterface::CMetaInterface(
    IN CComAuthInfo * pAuthInfo        OPTIONAL
    )
/*++

Routine Description:

    Construct and initialize the interface

Arguments:

    CComAuthInfo * pAuthInfo    : Authentication info.  NULL indicates 
                                  the local computer.

Return Value:

    N/A

--*/
    : CIISInterface(pAuthInfo),
      m_pInterface(NULL),
      m_iTimeOutValue(MB_TIMEOUT)
{
    //
    // Initialize the interface
    //
    m_hrInterface = Create();
}



CMetaInterface::CMetaInterface(
    IN CMetaInterface * pInterface
    )
/*++

Routine Description:

    Construct from existing interface (Copy Constructor)

Arguments:

    CMetaInterface * pInterface : Existing interface

Return Value:

    N/A

Notes:
        
    Object will not take ownership of the interface,
    it will merely add to the reference count, and 
    release it upon destruction

BUGBUG:

    if pInterface is NULL, this will AV.

--*/
    : CIISInterface(&pInterface->m_auth, pInterface->m_hrInterface),
      m_pInterface(pInterface->m_pInterface),
      m_iTimeOutValue(pInterface->m_iTimeOutValue)
{
    ASSERT_READ_PTR(m_pInterface);
    m_pInterface->AddRef();
}



CMetaInterface::~CMetaInterface()
/*++

Routine Description:

    Destructor -- releases the interface

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    SAFE_RELEASE(m_pInterface);
}


HRESULT 
CMetaInterface::Create()
{
    return CIISInterface::Create(
        1,
        &IID_IMSAdminBase, 
        &CLSID_MSAdminBase, 
        NULL,
        (IUnknown **)&m_pInterface
        );
}

//
// CMetaKey class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//
// Helper macros
//
#define ASSURE_PROPER_INTERFACE()\
    if (!HasInterface()) { ASSERT_MSG("No interface"); return MD_ERROR_NOT_INITIALIZED; }

#define ASSURE_OPEN_KEY()\
    if (!m_hKey && !m_fAllowRootOperations) { ASSERT_MSG("No open key"); return HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE); }

#define FETCH_PROPERTY_DATA_OR_FAIL(dwID, md)\
    ZeroMemory(&md, sizeof(md)); \
    if (!GetMDFieldDef(dwID, md.dwMDIdentifier, md.dwMDAttributes, md.dwMDUserType, md.dwMDDataType))\
    { ASSERT_MSG("Bad property ID"); return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER); }

//
// Static Initialization
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



#define MD_SERVER_PLATFORM              (IIS_MD_SERVER_BASE+100 )
#define MD_SERVER_VERSION_MAJOR         (IIS_MD_SERVER_BASE+101 )
#define MD_SERVER_VERSION_MINOR         (IIS_MD_SERVER_BASE+102 )
#define MD_SERVER_CAPABILITIES          (IIS_MD_SERVER_BASE+103 )

#ifndef MD_APP_PERIODIC_RESTART_TIME
#define MD_APP_PERIODIC_RESTART_TIME         2111
#endif
#ifndef MD_APP_PERIODIC_RESTART_REQUESTS
#define MD_APP_PERIODIC_RESTART_REQUESTS     2112
#endif
#ifndef MD_APP_PERIODIC_RESTART_SCHEDULE
#define MD_APP_PERIODIC_RESTART_SCHEDULE     2113
#endif
#ifndef MD_ASP_DISKTEMPLATECACHEDIRECTORY
#define MD_ASP_DISKTEMPLATECACHEDIRECTORY    7036
#endif
#ifndef MD_ASP_MAXDISKTEMPLATECACHEFILES
#define MD_ASP_MAXDISKTEMPLATECACHEFILES     7040
#endif
//
// Metabase table
//
const CMetaKey::MDFIELDDEF CMetaKey::s_rgMetaTable[] =
{
    ///////////////////////////////////////////////////////////////////////////
    //
    // !!!IMPORTANT!!! This table must be sorted on dwMDIdentifier.  (Will
    // ASSERT if not not sorted)
    //
    { MD_MAX_BANDWIDTH,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_KEY_TYPE,                        METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_SERVER_COMMAND,                  METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_CONNECTION_TIMEOUT,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CONNECTION_TIMEOUT          },
    { MD_MAX_CONNECTIONS,                 METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_MAX_CONNECTIONS             },
    { MD_SERVER_COMMENT,                  METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  IDS_MD_SERVER_COMMENT              },
    { MD_SERVER_STATE,                    METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_SERVER_AUTOSTART,                METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_SERVER_SIZE,                     METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_SERVER_SIZE                 },
    { MD_SERVER_LISTEN_BACKLOG,           METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_SERVER_LISTEN_BACKLOG       },
    { MD_SERVER_LISTEN_TIMEOUT,           METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_SERVER_LISTEN_TIMEOUT       },
    { MD_SERVER_BINDINGS,                 METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, MULTISZ_METADATA, 0                                  },
    { MD_WIN32_ERROR,                     METADATA_VOLATILE,                         IIS_MD_UT_FILE,   DWORD_METADATA,   0                                  },
    { MD_SERVER_PLATFORM,                 METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_SERVER_VERSION_MAJOR,            METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_SERVER_VERSION_MINOR,            METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_SERVER_CAPABILITIES,             METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_SECURE_BINDINGS,                 METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, MULTISZ_METADATA, 0                                  },
    { MD_FILTER_LOAD_ORDER,               METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_FILTER_IMAGE_PATH,               METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_FILTER_STATE,                    METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_FILTER_ENABLED,                  METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_FILTER_FLAGS,                    METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_AUTH_CHANGE_URL,                 METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_AUTH_EXPIRED_URL,                METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_AUTH_NOTIFY_PWD_EXP_URL,         METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_ADV_NOTIFY_PWD_EXP_IN_DAYS,      METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_ADV_CACHE_TTL,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_AUTH_EXPIRED_UNSECUREURL,        METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_AUTH_CHANGE_FLAGS,               METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_AUTH_NOTIFY_PWD_EXP_UNSECUREURL, METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_FRONTPAGE_WEB,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_MAPCERT,                         METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_MAPNTACCT,                       METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_MAPNAME,                         METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_MAPENABLED,                      METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_MAPREALM,                        METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_MAPPWD,                          METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_ITACCT,                          METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_CPP_CERT11,                      METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SERIAL_CERT11,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_CPP_CERTW,                       METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SERIAL_CERTW,                    METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_CPP_DIGEST,                      METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SERIAL_DIGEST,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_CPP_ITA,                         METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SERIAL_ITA,                      METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_APP_FRIENDLY_NAME,               METADATA_INHERIT,                          IIS_MD_UT_WAM,    STRING_METADATA,  IDS_MD_APP_FRIENDLY_NAME           },
    { MD_APP_ROOT,                        METADATA_INHERIT,                          IIS_MD_UT_WAM,    STRING_METADATA,  IDS_MD_APP_ROOT                    },
    { MD_APP_ISOLATED,                    METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   IDS_MD_APP_ISOLATED                },
// new stuff
    { MD_APP_PERIODIC_RESTART_TIME,       METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   0                                  },
    { MD_APP_PERIODIC_RESTART_REQUESTS,   METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   0                                  },
    { MD_APP_PERIODIC_RESTART_SCHEDULE,   METADATA_INHERIT,                          IIS_MD_UT_WAM,    MULTISZ_METADATA, 0                                  },
// end new stuff
    { MD_HC_COMPRESSION_DIRECTORY,        METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_HC_DO_DYNAMIC_COMPRESSION,       METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_HC_DO_STATIC_COMPRESSION,        METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_HC_DO_DISK_SPACE_LIMITING,       METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_HC_MAX_DISK_SPACE_USAGE,         METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_VR_PATH,                         METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_VR_PATH                     },
    { MD_VR_USERNAME,                     METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_VR_USERNAME                 },
    { MD_VR_PASSWORD,                     METADATA_INHERIT | METADATA_SECURE,        IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_VR_PASSWORD                 },
    { MD_VR_ACL,                          METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_FILE,   BINARY_METADATA,  0                                  },
    { MD_VR_UPDATE,                       METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_FILE,   DWORD_METADATA,   0                                  },
    { MD_LOG_TYPE,                        METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_LOG_TYPE                    },
    { MD_LOGFILE_DIRECTORY,               METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_LOGFILE_DIRECTORY           },
    { MD_LOGFILE_PERIOD,                  METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_LOGFILE_PERIOD              },
    { MD_LOGFILE_TRUNCATE_SIZE,           METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_LOGFILE_TRUNCATE_SIZE       },
    { MD_LOGSQL_DATA_SOURCES,             METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_LOGSQL_DATA_SOURCES         },
    { MD_LOGSQL_TABLE_NAME,               METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_LOGSQL_TABLE_NAME           },
    { MD_LOGSQL_USER_NAME,                METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_LOGSQL_USER_NAME            },
    { MD_LOGSQL_PASSWORD,                 METADATA_INHERIT | METADATA_SECURE,        IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_LOGSQL_PASSWORD             },
    { MD_LOG_PLUGIN_ORDER,                METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  IDS_MD_LOG_PLUGIN_ORDER            },
    { MD_LOGEXT_FIELD_MASK,               METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_LOGEXT_FIELD_MASK           },
    { MD_LOGFILE_LOCALTIME_ROLLOVER,      METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_LOGFILE_LOCALTIME_ROLLOVER  },
    { MD_EXIT_MESSAGE,                    METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  IDS_MD_EXIT_MESSAGE                },
    { MD_GREETING_MESSAGE,                METADATA_INHERIT,                          IIS_MD_UT_SERVER, MULTISZ_METADATA, IDS_MD_GREETING_MESSAGE            },
    { MD_MAX_CLIENTS_MESSAGE,             METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  IDS_MD_MAX_CLIENTS_MESSAGE         },
    { MD_MSDOS_DIR_OUTPUT,                METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_MSDOS_DIR_OUTPUT            },
    { MD_ALLOW_ANONYMOUS,                 METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_ALLOW_ANONYMOUS             },
    { MD_ANONYMOUS_ONLY,                  METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_ANONYMOUS_ONLY              },
    { MD_LOG_ANONYMOUS,                   METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_LOG_ANONYMOUS               },
    { MD_LOG_NONANONYMOUS,                METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_LOG_NONANONYMOUS            },
    { MD_SSL_PUBLIC_KEY,                  METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SSL_PRIVATE_KEY,                 METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SSL_KEY_PASSWORD,                METADATA_SECURE,                           IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SSL_CERT_HASH,                   METADATA_INHERIT,                          IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SSL_CERT_STORE_NAME,             METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_SSL_CTL_IDENTIFIER,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_SSL_CTL_STORE_NAME,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_SSL_USE_DS_MAPPER,               METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_AUTHORIZATION,                   METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_AUTHORIZATION               },
    { MD_REALM,                           METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_REALM                       },
    { MD_HTTP_EXPIRES,                    METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_HTTP_EXPIRES                },
    { MD_HTTP_PICS,                       METADATA_INHERIT,                          IIS_MD_UT_FILE,   MULTISZ_METADATA, IDS_MD_HTTP_PICS                   },
    { MD_HTTP_CUSTOM,                     METADATA_INHERIT,                          IIS_MD_UT_FILE,   MULTISZ_METADATA, IDS_MD_HTTP_CUSTOM                 },
    { MD_DIRECTORY_BROWSING,              METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_DIRECTORY_BROWSING          },
    { MD_DEFAULT_LOAD_FILE,               METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_DEFAULT_LOAD_FILE           },
    { MD_CONTENT_NEGOTIATION,             METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_CONTENT_NEGOTIATION         },
    { MD_CUSTOM_ERROR,                    METADATA_INHERIT,                          IIS_MD_UT_FILE,   MULTISZ_METADATA, IDS_MD_CUSTOM_ERROR                },
    { MD_FOOTER_DOCUMENT,                 METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_FOOTER_DOCUMENT             },
    { MD_FOOTER_ENABLED,                  METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_FOOTER_ENABLED              },
    { MD_HTTP_REDIRECT,                   METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_HTTP_REDIRECT               },
    { MD_DEFAULT_LOGON_DOMAIN,            METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_DEFAULT_LOGON_DOMAIN        },
    { MD_LOGON_METHOD,                    METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_LOGON_METHOD                },
    { MD_SCRIPT_MAPS,                     METADATA_INHERIT,                          IIS_MD_UT_FILE,   MULTISZ_METADATA, IDS_MD_SCRIPT_MAPS                 },
    { MD_MIME_MAP,                        METADATA_INHERIT,                          IIS_MD_UT_FILE,   MULTISZ_METADATA, IDS_MD_MIME_MAP                    },
    { MD_ACCESS_PERM,                     METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_ACCESS_PERM                 },
    { MD_IP_SEC,                          METADATA_INHERIT | METADATA_REFERENCE,     IIS_MD_UT_FILE,   BINARY_METADATA,  IDS_MD_IP_SEC                      },
    { MD_ANONYMOUS_USER_NAME,             METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_ANONYMOUS_USER_NAME         },
    { MD_ANONYMOUS_PWD,                   METADATA_INHERIT | METADATA_SECURE,        IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_ANONYMOUS_PWD               },
    { MD_ANONYMOUS_USE_SUBAUTH,           METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_ANONYMOUS_USE_SUBAUTH       },
    { MD_DONT_LOG,                        METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_DONT_LOG                    },
    { MD_ADMIN_ACL,                       METADATA_INHERIT | METADATA_SECURE | METADATA_REFERENCE,IIS_MD_UT_SERVER, BINARY_METADATA,  IDS_MD_ADMIN_ACL      },
    { MD_SSI_EXEC_DISABLED,               METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_SSI_EXEC_DISABLED           },
    { MD_SSL_ACCESS_PERM,                 METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_SSL_ACCESS_PERM             },
    { MD_NTAUTHENTICATION_PROVIDERS,      METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_NTAUTHENTICATION_PROVIDERS  },
    { MD_SCRIPT_TIMEOUT,                  METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_SCRIPT_TIMEOUT              },
    { MD_CACHE_EXTENSIONS,                METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_CACHE_EXTENSIONS            },
    { MD_CREATE_PROCESS_AS_USER,          METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CREATE_PROCESS_AS_USER      },
    { MD_CREATE_PROC_NEW_CONSOLE,         METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CREATE_PROC_NEW_CONSOLE     },
    { MD_POOL_IDC_TIMEOUT,                METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_POOL_IDC_TIMEOUT            },
    { MD_ALLOW_KEEPALIVES,                METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_ALLOW_KEEPALIVES            },
    { MD_IS_CONTENT_INDEXED,              METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_IS_CONTENT_INDEXED          },
    { MD_ISM_ACCESS_CHECK,                METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_FILE,   DWORD_METADATA,   0                                  },
    { MD_ASP_BUFFERINGON,                 METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_BUFFERINGON                },
    { MD_ASP_LOGERRORREQUESTS,            METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   IDS_ASP_LOGERRORREQUESTS           },
    { MD_ASP_SCRIPTERRORSSENTTOBROWSER,   METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_SCRIPTERRORSSENTTOBROWSER  },
    { MD_ASP_SCRIPTERRORMESSAGE,          METADATA_INHERIT,                          ASP_MD_UT_APP,    STRING_METADATA,  IDS_ASP_SCRIPTERRORMESSAGE         },
    { MD_ASP_SCRIPTFILECACHESIZE,         METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   IDS_ASP_SCRIPTFILECACHESIZE        },
    { MD_ASP_SCRIPTENGINECACHEMAX,        METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   IDS_ASP_SCRIPTENGINECACHEMAX       },
    { MD_ASP_SCRIPTTIMEOUT,               METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_SCRIPTTIMEOUT              },
    { MD_ASP_SESSIONTIMEOUT,              METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_SESSIONTIMEOUT             },
    { MD_ASP_ENABLEPARENTPATHS,           METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_ENABLEPARENTPATHS          },
    { MD_ASP_ALLOWSESSIONSTATE,           METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_ALLOWSESSIONSTATE          },
    { MD_ASP_SCRIPTLANGUAGE,              METADATA_INHERIT,                          ASP_MD_UT_APP,    STRING_METADATA,  IDS_ASP_SCRIPTLANGUAGE             },
    { MD_ASP_EXCEPTIONCATCHENABLE,        METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   IDS_ASP_EXCEPTIONCATCHENABLE       },
    { MD_ASP_ENABLESERVERDEBUG,           METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_ENABLESERVERDEBUG          },
    { MD_ASP_ENABLECLIENTDEBUG,           METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_ENABLECLIENTDEBUG          },
    { MD_ASP_DISKTEMPLATECACHEDIRECTORY,  METADATA_INHERIT,                          IIS_MD_UT_WAM,    STRING_METADATA,  0                                  },
    { MD_ASP_MAXDISKTEMPLATECACHEFILES,   METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   0                                  },
    { MD_WAM_USER_NAME,                   METADATA_INHERIT,                          IIS_MD_UT_WAM,    STRING_METADATA,  0                                  },
    { MD_WAM_PWD,                         METADATA_INHERIT,                          IIS_MD_UT_WAM,    STRING_METADATA,  0                                  }
};



#define NUM_ENTRIES (sizeof(CMetaKey::s_rgMetaTable) / sizeof(CMetaKey::s_rgMetaTable[0]))



/* static */
int
CMetaKey::MapMDIDToTableIndex(
    IN DWORD dwID
    )
/*++

Routine Description:

    Map MD id value to table index.  Return -1 if not found

Arguments:

    DWORD dwID : MD id value

Return Value:

    Index into the table that coresponds to the MD id value

--*/
{
#ifdef _DEBUG

    {
        //
        // Do a quick verification that our metadata
        // table is sorted correctly.
        //
        static BOOL fTableChecked = FALSE;

        if (!fTableChecked)
        {
            for (int n = 1; n < NUM_ENTRIES; ++n)
            {
                if (s_rgMetaTable[n].dwMDIdentifier
                    <= s_rgMetaTable[n - 1].dwMDIdentifier)
                {
//                    TRACE("MD ID Table is out of order: Item is %d %s\n", n, s_rgMetaTable[n].dwMDIdentifier);
                    ASSERT_MSG("MD ID Table out of order");
                }
            }

            //
            // But only once.
            //
            ++fTableChecked;
        }
    }

#endif // _DEBUG

    //
    // Look up the ID in the table using a binary search
    //
    int nRange = NUM_ENTRIES;
    int nLow = 0;
    int nHigh = nRange - 1;
    int nMid;
    int nHalf;

    while (nLow <= nHigh)
    {
        if (nHalf = nRange / 2)
        {
            nMid  = nLow + (nRange & 1 ? nHalf : (nHalf - 1));

            if (s_rgMetaTable[nMid].dwMDIdentifier == dwID)
            {
                return nMid;
            }
            else if (s_rgMetaTable[nMid].dwMDIdentifier > dwID)
            {
                nHigh  = --nMid;
                nRange = nRange & 1 ? nHalf : nHalf - 1;
            }
            else
            {
                nLow   = ++nMid;
                nRange = nHalf;
            }
        }
        else if (nRange)
        {
            return s_rgMetaTable[nLow].dwMDIdentifier == dwID ? nLow : -1;
        }
        else
        {
            break;
        }
    }

    return -1;
}



/* static */
BOOL
CMetaKey::GetMDFieldDef(
    IN  DWORD dwID,
    OUT DWORD & dwMDIdentifier,
    OUT DWORD & dwMDAttributes,
    OUT DWORD & dwMDUserType,
    OUT DWORD & dwMDDataType
    )
/*++

Routine Description:

    Get information about metabase property

Arguments:

    DWORD dwID                  : Meta ID
    DWORD & dwMDIdentifier      : Meta parms
    DWORD & dwMDAttributes      : Meta parms
    DWORD & dwMDUserType        : Meta parms
    DWORD & dwMDDataType        : Meta parms

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    int nID = MapMDIDToTableIndex(dwID);

    if (nID == -1)
    {
        //
        // Unrecognized meta data ID
        //
        ASSERT_MSG("Unrecognized meta data id");
        return FALSE;
    }

    dwMDIdentifier = s_rgMetaTable[nID].dwMDIdentifier;
    dwMDAttributes = s_rgMetaTable[nID].dwMDAttributes;
    dwMDUserType   = s_rgMetaTable[nID].dwMDUserType;
    dwMDDataType   = s_rgMetaTable[nID].dwMDDataType;

    return TRUE;
}



/* static */
BOOL
CMetaKey::IsPropertyInheritable(
    IN DWORD dwID
    )
/*++

Routine Description:

    Check to see if the given property is inheritable

Arguments:

    DWORD dwID      : Metabase ID

Return Value:

    TRUE if the metabase ID is inheritable, FALSE otherwise.

--*/
{
    int nID = MapMDIDToTableIndex(dwID);

    if (nID == -1)
    {
        //
        // Unrecognized meta data ID
        //
        ASSERT_MSG("Unrecognized meta data ID");
        return FALSE;
    }

    return (s_rgMetaTable[nID].dwMDAttributes & METADATA_INHERIT) != 0;
}



/* static */
BOOL
CMetaKey::GetPropertyDescription(
    IN  DWORD dwID,
    OUT CString & strName
    )
/*++

Routine Description:

    Get a description for the given property

Arguments:

    DWORD dwID            : Property ID
    CString & strName     : Returns friendly property name

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    int nID = MapMDIDToTableIndex(dwID);

    if (nID == -1)
    {
        //
        // Unrecognized meta data ID
        //
        ASSERT_MSG("Unrecognized meta data ID");
        return FALSE;
    }

    UINT uID = s_rgMetaTable[nID].uStringID;

    BOOL fResult = TRUE;

    if (uID > 0)
    {
        fResult = (strName.LoadString(_Module.GetResourceInstance(), uID) != 0);
    }
    else
    {
        //
        // Don't have a friendly name -- fake it
        //
        CComBSTR bstrFmt;
        VERIFY(bstrFmt.LoadString(_Module.GetResourceInstance(), IDS_INHERITANCE_NO_NAME));

        strName.Format(bstrFmt, dwID);
    }

    return fResult;
}



CMetaKey::CMetaKey(
    IN CComAuthInfo * pAuthInfo     OPTIONAL
    )
/*++

Routine Description:

    Constructor that creates the interface, but does not open the key.
    This is the ONLY constructor that allows operations from
    METDATA_MASTER_ROOT_HANDLE (read operations obviously)

Arguments:

    CComAuthInfo * pAuthInfo  : If NULL, opens interface on local machine

Return Value:

    N/A

--*/
    : CMetaInterface(pAuthInfo),
      m_hKey(METADATA_MASTER_ROOT_HANDLE),
      m_hBase(NULL),
      m_hrKey(S_OK),
      m_dwFlags(0L),
      m_cbInitialBufferSize(MB_INIT_BUFF_SIZE),
      m_strMetaPath(),
      m_fAllowRootOperations(TRUE),
      m_fOwnKey(TRUE)
{
    m_hrKey = CMetaInterface::QueryResult(); 

    //
    // Do not open key
    //
}



CMetaKey::CMetaKey(
    IN CMetaInterface * pInterface
    )
/*++

Routine Description:

    Construct with pre-existing interface.  Does not
    open any keys

Arguments:

    CMetaInterface * pInterface       : Preexisting interface

Return Value:

    N/A

--*/
    : CMetaInterface(pInterface),
      m_hKey(NULL),
      m_hBase(NULL),
      m_strMetaPath(),
      m_dwFlags(0L),
      m_cbInitialBufferSize(MB_INIT_BUFF_SIZE),
      m_fAllowRootOperations(TRUE),
      m_fOwnKey(TRUE)
{
    m_hrKey = CMetaInterface::QueryResult(); 
}        



CMetaKey::CMetaKey(
    IN CComAuthInfo * pAuthInfo,    OPTIONAL
    IN LPCTSTR lpszMDPath,          OPTIONAL
    IN DWORD   dwFlags,               
    IN METADATA_HANDLE hkBase
    )
/*++

Routine Description:

    Fully defined constructor that opens a key

Arguments:

    CComAuthInfo * pAuthInfo : Auth info or NULL
    LPCTSTR lpszMDPath       : Path or NULL
    DWORD   dwFlags          : Open permissions
    METADATA_HANDLE hkBase   : Base key

Return Value:

    N/A

--*/
    : CMetaInterface(pAuthInfo),
//    : CMetaInterface((CComAuthInfo *)NULL),
      m_hKey(NULL),
      m_hBase(NULL),
      m_dwFlags(0L),
      m_cbInitialBufferSize(MB_INIT_BUFF_SIZE),
      m_fAllowRootOperations(FALSE),
      m_strMetaPath(),
      m_fOwnKey(TRUE)
{
    m_hrKey = CMetaInterface::QueryResult(); 

    if (SUCCEEDED(m_hrKey))
    {
        m_hrKey = Open(dwFlags, lpszMDPath, hkBase);
    }
}



CMetaKey::CMetaKey(
    IN CMetaInterface * pInterface,
    IN LPCTSTR lpszMDPath,              OPTIONAL
    IN DWORD   dwFlags,               
    IN METADATA_HANDLE hkBase
    )
/*++

Routine Description:

    Fully defined constructor that opens a key

Arguments:

    CMetaInterface * pInterface : Existing interface
    DWORD   dwFlags             : Open permissions
    METADATA_HANDLE hkBase      : Base key
    LPCTSTR lpszMDPath          : Path or NULL

Return Value:

    N/A

--*/
    : CMetaInterface(pInterface),
      m_hKey(NULL),
      m_hBase(NULL),
      m_strMetaPath(),
      m_dwFlags(0L),
      m_cbInitialBufferSize(MB_INIT_BUFF_SIZE),
      m_fAllowRootOperations(FALSE),
      m_fOwnKey(TRUE)
{
    m_hrKey = CMetaInterface::QueryResult(); 

    if (SUCCEEDED(m_hrKey))
    {
        m_hrKey = Open(dwFlags, lpszMDPath, hkBase);
    }
}



CMetaKey::CMetaKey(
    IN BOOL  fOwnKey,
    IN CMetaKey * pKey
    )
/*++

Routine Description:

    Copy constructor. 

Arguments:

    BOOL  fOwnKey               : TRUE to take ownership of the key
    const CMetaKey * pKey       : Existing key

Return Value:

    N/A

--*/
    : CMetaInterface(pKey),
      m_hKey(pKey->m_hKey),
      m_hBase(pKey->m_hBase),
      m_dwFlags(pKey->m_dwFlags),
      m_cbInitialBufferSize(pKey->m_cbInitialBufferSize),
      m_fAllowRootOperations(pKey->m_fAllowRootOperations),
      m_hrKey(pKey->m_hrKey),
      m_strMetaPath(pKey->m_strMetaPath),
      m_fOwnKey(fOwnKey)
{
    //
    // No provisions for anything else at the moment
    //
    ASSERT(!m_fOwnKey);
}



CMetaKey::~CMetaKey()
/*++

Routine Description:

    Destructor -- Close the key.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    if (IsOpen() && m_fOwnKey)
    {
        Close();
    }
}



/* virtual */
BOOL 
CMetaKey::Succeeded() const
/*++

Routine Description:

    Determine if object was constructed successfully

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    return SUCCEEDED(m_hrKey);
}



/* virtual */
HRESULT 
CMetaKey::QueryResult() const
/*++

Routine Description:

    Return the construction error for this object

Arguments:

    None

Return Value:

    HRESULT from construction errors

--*/
{
    return m_hrKey;
}



HRESULT 
CMetaKey::Open(
    IN DWORD dwFlags,                
    IN LPCTSTR lpszMDPath,          OPTIONAL
    IN METADATA_HANDLE hkBase
    )
/*++

Routine Description:

    Attempt to open a metabase key

Arguments:

    DWORD dwFlags           : Permission flags
    LPCTSTR lpszMDPath      : Optional path
    METADATA_HANDLE hkBase  : Base metabase key

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();

    if (m_hKey != NULL)
    {
        ASSERT_MSG("Attempting to open key that already has an open handle");

//        TRACEEOLID("Closing that key");
        Close();
    }

    //
    // Base key is stored for reopen purposes only
    //
    m_hBase = hkBase;
    m_strMetaPath = lpszMDPath;
    m_dwFlags = dwFlags;

    return OpenKey(m_hBase, m_strMetaPath, m_dwFlags, &m_hKey);
}



HRESULT 
CMetaKey::CreatePathFromFailedOpen()
/*++

Routine Description:

    If the path doesn't exist, create it.  This method should be
    called after an Open call failed (because it will have initialized
    m_strMetaPath.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CString strParentPath;
    CString strObjectName;
    CString strSavePath(m_strMetaPath);

    CMetabasePath::SplitMetaPathAtInstance(
        m_strMetaPath, 
        strParentPath, 
        strObjectName
        );

    CError err(Open(
        METADATA_PERMISSION_WRITE,
        strParentPath
        ));

    if (err.Succeeded())
    {
        //
        // This really should never fail, because we're opening
        // the path at the instance.
        //
        err = AddKey(strObjectName);
    }

    if (IsOpen())
    {
        Close();
    }

    //
    // The previous open wiped out the path...
    //
    m_strMetaPath = strSavePath;

    return err;
}



HRESULT
CMetaKey::Close()
/*++

Routine Description:

    Close the currently open key.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    ASSURE_PROPER_INTERFACE();

    HRESULT hr = S_OK;

    ASSERT(m_hKey != NULL);
    ASSERT(m_fOwnKey);

    if (m_hKey)
    {
        hr = CloseKey(m_hKey);

        if (SUCCEEDED(hr))
        {
            m_hKey = NULL;
        }
    }

    return hr;
}



HRESULT
CMetaKey::ConvertToParentPath(
    IN  BOOL fImmediate
    )
/*++

Routine Description:

    Change the path to the parent path.

Arguments:

    BOOL fImmediate     : If TRUE, the immediate parent's path will be used
                          if FALSE, the first parent that really exists

Return Value:

    HRESULT

        ERROR_INVALID_PARAMETER if there is no valid path

--*/
{
    BOOL fIsOpen = IsOpen();

    if (fIsOpen)
    {
        Close();
    }

    CError err;

    FOREVER
    {
        if (!CMetabasePath::ConvertToParentPath(m_strMetaPath))
        {
            //
            // There is no parent path
            //
            err = ERROR_INVALID_PARAMETER;
            break;
        }

        err = ReOpen();

        //
        // Path not found is the only valid error
        // other than success.
        //
        if (fImmediate 
            || err.Succeeded() 
            || err.Win32Error() != ERROR_PATH_NOT_FOUND)
        {
            break;
        }
    }

    //
    // Remember to reset the construction error
    // which referred to the parent path.
    //
    m_hrKey = err;

    return err;
}




/* protected */
HRESULT
CMetaKey::GetPropertyValue(
    IN  DWORD dwID,
    OUT IN DWORD & dwSize,               OPTIONAL
    OUT IN void *& pvData,               OPTIONAL
    OUT IN DWORD * pdwDataType,          OPTIONAL
    IN  BOOL * pfInheritanceOverride,    OPTIONAL
    IN  LPCTSTR lpszMDPath,              OPTIONAL
    OUT DWORD * pdwAttributes            OPTIONAL
    )
/*++

Routine Description:

    Get metadata on the currently open key.

Arguments:

    DWORD dwID                      : Property ID number
    DWORD & dwSize                  : Buffer size (could be 0)
    void *& pvData                  : Buffer -- will allocate if NULL
    DWORD * pdwDataType             : NULL or on in  contains valid data types,
                                    :         on out contains actual data type
    BOOL * pfInheritanceOverride    : NULL or on forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes    

Return Value:

    HRESULT 

    ERROR_INVALID_HANDLE        : If the handle is not open
    ERROR_INVALID_PARAMETER     : If the property id is not found,
                                  or the data type doesn't match requested type
    ERROR_OUTOFMEMORY           : Out of memory

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    METADATA_RECORD mdRecord;
    FETCH_PROPERTY_DATA_OR_FAIL(dwID, mdRecord);

    //
    // If unable to find this property ID in our table, or
    // if we specified a desired type, and this type doesn't 
    // match it, give up.
    //
    if (pdwDataType && *pdwDataType != ALL_METADATA 
        && *pdwDataType != mdRecord.dwMDDataType)
    {
        ASSERT_MSG("Invalid parameter");
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    //
    // Check to see if inheritance behaviour is overridden
    //
    if (pfInheritanceOverride)
    {
        if (*pfInheritanceOverride)
        {
            mdRecord.dwMDAttributes |= METADATA_INHERIT;
        }
        else
        {
            mdRecord.dwMDAttributes &= ~METADATA_INHERIT;
        }
    }

    //
    // This causes a bad parameter error on input otherwise
    //
    mdRecord.dwMDAttributes &= ~METADATA_REFERENCE;

    //
    // If we're looking for inheritable properties, the path
    // doesn't have to be completely specified.
    //
    if (mdRecord.dwMDAttributes & METADATA_INHERIT)
    {
        mdRecord.dwMDAttributes |= (METADATA_PARTIAL_PATH | METADATA_ISINHERITED);
    }

    ASSERT(dwSize > 0 || pvData == NULL);
    
    mdRecord.dwMDDataLen = dwSize;
    mdRecord.pbMDData = (LPBYTE)pvData;

    //
    // If no buffer provided, allocate one.
    //
    HRESULT hr = S_OK;
    BOOL fBufferTooSmall = FALSE;
    BOOL fAllocatedMemory = FALSE;
    DWORD dwInitSize = m_cbInitialBufferSize;

    do
    {
        if(mdRecord.pbMDData == NULL)
        {
            mdRecord.dwMDDataLen = dwInitSize;
            mdRecord.pbMDData = new BYTE[dwInitSize];

            if(mdRecord.pbMDData == NULL && dwInitSize > 0)
            {
                hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
                break;
            }

            ++fAllocatedMemory;
        }

        //
        // Get the data
        //
        DWORD dwRequiredDataLen = 0;
        hr = GetData(m_hKey, lpszMDPath, &mdRecord, &dwRequiredDataLen);

        //
        // Re-fetch the buffer if it's too small.
        //
        fBufferTooSmall = 
            (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER) && fAllocatedMemory;

        if(fBufferTooSmall)
        {
            //
            // Delete the old buffer, and set up for a re-fetch.
            //
            delete [] mdRecord.pbMDData;
            mdRecord.pbMDData = NULL;
            dwInitSize = dwRequiredDataLen;
        }
    }
    while(fBufferTooSmall);

    //
    // Failed
    //
   if (FAILED(hr) && fAllocatedMemory)
   {
       delete [] mdRecord.pbMDData;
       mdRecord.pbMDData = NULL;
   }

   dwSize = mdRecord.dwMDDataLen;
   pvData = mdRecord.pbMDData;

   if (pdwDataType != NULL)
   {
      //
      // Return actual data type
      //
      *pdwDataType = mdRecord.dwMDDataType;
   }

   if (pdwAttributes != NULL)
   {
      //
      // Return data attributes
      //
      *pdwAttributes =  mdRecord.dwMDAttributes;
   }

   return hr;
}



/* protected */
HRESULT 
CMetaKey::GetDataPaths( 
    OUT CStringListEx & strlDataPaths,
    IN  DWORD   dwMDIdentifier,
    IN  DWORD   dwMDDataType,
    IN  LPCTSTR lpszMDPath              OPTIONAL
    )
/*++

Routine Description:

    Get data paths

Arguments:


Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    //
    // Start with a small buffer
    //
    DWORD  dwMDBufferSize = 1024;
    LPTSTR lpszBuffer = NULL;
    CError err;

    do
    {
        delete [] lpszBuffer;
        lpszBuffer = new TCHAR[dwMDBufferSize];

        if (lpszBuffer == NULL)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        err = CMetaInterface::GetDataPaths(
            m_hKey,
            lpszMDPath,
            dwMDIdentifier,
            dwMDDataType,
            dwMDBufferSize,
            lpszBuffer,
            &dwMDBufferSize
            );
    }
    while(err.Win32Error() == ERROR_INSUFFICIENT_BUFFER);

    if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
    {
        //
        // That's ok... this is some sort of physical directory
        // that doesn't currently exist in the metabase, and
        // which therefore doesn't have any descendants anyway.
        //
        ZeroMemory(lpszBuffer, dwMDBufferSize);
        err.Reset();
    }

    if (err.Succeeded())
    {
        strlDataPaths.ConvertFromDoubleNullList(lpszBuffer);
        delete [] lpszBuffer;
    }

    return err;
}



HRESULT
CMetaKey::CheckDescendants(
    IN DWORD   dwID,
    IN CComAuthInfo * pAuthInfo, OPTIONAL
    IN LPCTSTR lpszMDPath         OPTIONAL
    )
/*++

Routine Description:

    Check for descendant overrides;  If there are any, bring up a dialog
    that displays them, and give the user the opportunity the remove
    the overrides.

Arguments:

    DWORD dwID               : Property ID
    CComAuthInfo * pAuthInfo : Server or NULL
    LPCTSTR lpszMDPath       : Metabase path or NULL

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();

    HRESULT hr = S_OK;

    METADATA_RECORD mdRecord;
    FETCH_PROPERTY_DATA_OR_FAIL(dwID, mdRecord);

    if (mdRecord.dwMDAttributes & METADATA_INHERIT)
    {
        CStringListEx strlDataPaths;

        hr = GetDataPaths( 
            strlDataPaths,
            mdRecord.dwMDIdentifier,
            mdRecord.dwMDDataType,
            lpszMDPath
            );

        if (SUCCEEDED(hr) && !strlDataPaths.empty())
        {
            //
            // Bring up the inheritance override dialog
            //
            CInheritanceDlg dlg(
                dwID,
                FROM_WRITE_PROPERTY,
                pAuthInfo,
                lpszMDPath,
                strlDataPaths
                );

            if (!dlg.IsEmpty())
            {
                dlg.DoModal();
            }
        }
    }

    return hr;
}



/* protected */
HRESULT
CMetaKey::SetPropertyValue(
    IN DWORD dwID,
    IN DWORD dwSize,
    IN void * pvData,
    IN BOOL * pfInheritanceOverride,    OPTIONAL
    IN LPCTSTR lpszMDPath               OPTIONAL
    )
/*++

Routine Description:

    Set metadata on the open key.  The key must have been opened with
    write permission.

Arguments:

    DWORD dwID                      : Property ID
    DWORD dwSize                    : Size of data
    void * pvData                   : Data buffer
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key

Return Value:

    HRESULT 

    ERROR_INVALID_HANDLE            : If the handle is not open
    ERROR_INVALID_PARAMETER         : If the property id is not found,
                                      or the buffer is NULL or of size 0

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    if (pvData == NULL && dwSize != 0)
    {
        ASSERT_MSG("No Data");
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    METADATA_RECORD mdRecord;
    FETCH_PROPERTY_DATA_OR_FAIL(dwID, mdRecord);

    if (pfInheritanceOverride)
    {
        if (*pfInheritanceOverride)
        {
            mdRecord.dwMDAttributes |= METADATA_INHERIT;
        }
        else
        {
            mdRecord.dwMDAttributes &= ~METADATA_INHERIT;
        }
    }

    mdRecord.dwMDDataLen = dwSize;
    mdRecord.pbMDData = (LPBYTE)pvData;

    return SetData(m_hKey, lpszMDPath, &mdRecord);
}



/* protected */
HRESULT 
CMetaKey::GetAllData(
    IN  DWORD dwMDAttributes,
    IN  DWORD dwMDUserType,
    IN  DWORD dwMDDataType,
    OUT DWORD * pdwMDNumEntries,
    OUT DWORD * pdwMDDataLen,
    OUT PBYTE * ppbMDData,
    IN  LPCTSTR lpszMDPath              OPTIONAL
    )
/*++

Routine Description:

    Get all data off the open key.  Buffer is created automatically.

Arguments:

    DWORD dwMDAttributes            : Attributes
    DWORD dwMDUserType              : User type to fetch
    DWORD dwMDDataType              : Data type to fetch
    DWORD * pdwMDNumEntries         : Returns number of entries read
    DWORD * pdwMDDataLen            : Returns size of data buffer
    PBYTE * ppbMDData               : Returns data buffer
    LPCTSTR lpszMDPath              : Optional data path        

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    //
    // Check for valid parameters
    //
    if(!pdwMDDataLen || !ppbMDData || !pdwMDNumEntries)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    HRESULT hr = S_OK;
    BOOL fBufferTooSmall = FALSE;
    DWORD dwMDDataSetNumber;
    DWORD dwRequiredBufferSize;
    DWORD dwInitSize = m_cbInitialBufferSize;
    *ppbMDData = NULL;

    do
    {
        *pdwMDDataLen = dwInitSize;
        *ppbMDData = new BYTE[dwInitSize];

        if (ppbMDData == NULL && dwInitSize > 0)
        {
            hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
            break;
        }

        hr = CMetaInterface::GetAllData(
            m_hKey,
            lpszMDPath,
            dwMDAttributes,
            dwMDUserType,
            dwMDDataType,
            pdwMDNumEntries,
            &dwMDDataSetNumber,
            *pdwMDDataLen,
            *ppbMDData,
            &dwRequiredBufferSize
            );

        //
        // Re-fetch the buffer if it's too small.
        //
        fBufferTooSmall = (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER);

        if(fBufferTooSmall)
        {
            //
            // Delete the old buffer, and set up for a re-fetch.
            //
            delete [] *ppbMDData;
            dwInitSize = dwRequiredBufferSize;
        }
    }
    while (fBufferTooSmall);

    if (FAILED(hr))
    {
        //
        // No good, be sure we don't leak anything
        //
        delete [] *ppbMDData;
        dwInitSize = 0L;
    }

    return hr;
}



HRESULT
CMetaKey::QueryValue(
    IN  DWORD dwID,
    IN  OUT DWORD & dwValue,
    IN  BOOL * pfInheritanceOverride, OPTIONAL
    IN  LPCTSTR lpszMDPath,           OPTIONAL
    OUT DWORD * pdwAttributes         OPTIONAL
    )
/*++

Routine Description:

    Fetch data as a DWORD

Arguments:

    DWORD dwID                      : Property ID
    DWORD & dwValue                 : Returns the value read in
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes    

Return Value:

    HRESULT

--*/
{
    DWORD dwSize = sizeof(dwValue);
    DWORD dwDataType = DWORD_METADATA;
    void * pvData = &dwValue;

    return GetPropertyValue(
        dwID, 
        dwSize, 
        pvData, 
        &dwDataType, 
        pfInheritanceOverride,
        lpszMDPath,
        pdwAttributes
        );
}



HRESULT
CMetaKey::QueryValue(
    IN  DWORD dwID,
    IN  OUT CString & strValue,
    IN  BOOL * pfInheritanceOverride, OPTIONAL
    IN  LPCTSTR lpszMDPath,           OPTIONAL
    OUT DWORD * pdwAttributes         OPTIONAL
    )
/*++

Routine Description:

    Fetch data as a string

Arguments:

    DWORD dwID                      : Property ID
    DWORD & strValue                : Returns the value read in
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes    

Return Value:

    HRESULT

--*/
{
   //
   // Get GetData allocate the buffer for us
   //
   DWORD dwSize = 0;
   DWORD dwDataType = ALL_METADATA;
   LPTSTR lpData = NULL;

   HRESULT hr = GetPropertyValue(
        dwID, 
        dwSize, 
        (void *&)lpData, 
        &dwDataType,
        pfInheritanceOverride,
        lpszMDPath,
        pdwAttributes
        );

   if (SUCCEEDED(hr))
   {
      //
      // Notes: consider optional auto-expansion on EXPANDSZ_METADATA
      // (see registry functions), and data type conversions for DWORD
      // or MULTISZ_METADATA or BINARY_METADATA
      //
      if (dwDataType == EXPANDSZ_METADATA || dwDataType == STRING_METADATA)
      {
         try
         {
            strValue = lpData;
         }
         catch(std::bad_alloc)
         {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
         }
      }
      else
      {
         hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
      }
   }

   if (lpData)
   {
      delete [] lpData;
   }
   return hr;
}



HRESULT
CMetaKey::QueryValue(
    IN  DWORD dwID,
    IN  OUT CStrPassword & strValue,
    IN  BOOL * pfInheritanceOverride, OPTIONAL
    IN  LPCTSTR lpszMDPath,           OPTIONAL
    OUT DWORD * pdwAttributes         OPTIONAL
    )
/*++

Routine Description:

    Fetch data as a string

Arguments:

    DWORD dwID                      : Property ID
    CStrPassword & strValue                : Returns the value read in
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes    

Return Value:

    HRESULT

--*/
{
   //
   // Get GetData allocate the buffer for us
   //
   DWORD dwSize = 0;
   DWORD dwDataType = ALL_METADATA;
   LPTSTR lpData = NULL;

   HRESULT hr = GetPropertyValue(
        dwID, 
        dwSize, 
        (void *&)lpData, 
        &dwDataType,
        pfInheritanceOverride,
        lpszMDPath,
        pdwAttributes
        );

   if (SUCCEEDED(hr))
   {
      //
      // Notes: consider optional auto-expansion on EXPANDSZ_METADATA
      // (see registry functions), and data type conversions for DWORD
      // or MULTISZ_METADATA or BINARY_METADATA
      //
      if (dwDataType == EXPANDSZ_METADATA || dwDataType == STRING_METADATA)
      {
         try
         {
            strValue = lpData;
         }
         catch(std::bad_alloc)
         {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
         }
      }
      else
      {
         hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
      }
   }

   if (lpData)
   {
      delete [] lpData;
   }
   return hr;
}




HRESULT
CMetaKey::QueryValue(
    IN  DWORD dwID,
    IN  OUT CComBSTR & strValue,
    IN  BOOL * pfInheritanceOverride, OPTIONAL
    IN  LPCTSTR lpszMDPath,           OPTIONAL
    OUT DWORD * pdwAttributes         OPTIONAL
    )
/*++

Routine Description:

    Fetch data as a string

Arguments:

    DWORD dwID                      : Property ID
    DWORD & CComBSTR                : Returns the value read in
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes    

Return Value:

    HRESULT

--*/
{
    //
    // Get GetData allocate the buffer for us
    //
    DWORD dwSize = 0;
    DWORD dwDataType = ALL_METADATA;
    LPTSTR lpData = NULL;

    HRESULT hr = GetPropertyValue(
        dwID, 
        dwSize, 
        (void *&)lpData, 
        &dwDataType,
        pfInheritanceOverride,
        lpszMDPath,
        pdwAttributes
        );

    if (SUCCEEDED(hr))
    {
        //
        // Notes: consider optional auto-expansion on EXPANDSZ_METADATA
        // (see registry functions), and data type conversions for DWORD
        // or MULTISZ_METADATA or BINARY_METADATA
        //
        if (dwDataType == EXPANDSZ_METADATA || dwDataType == STRING_METADATA)
        {
            strValue = lpData;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        }
    }

    if (lpData)
    {
        delete [] lpData;
    }

    return hr;
}




HRESULT
CMetaKey::QueryValue(
    IN  DWORD dwID,
    IN  OUT CStringListEx & strlValue,
    IN  BOOL * pfInheritanceOverride, OPTIONAL
    IN  LPCTSTR lpszMDPath,           OPTIONAL
    OUT DWORD * pdwAttributes         OPTIONAL
    )
/*++

Routine Description:

    Fetch data as a stringlist

Arguments:

    DWORD dwID                      : Property ID
    DWORD & strlValue               : Returns the value read in
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes    

Return Value:

    HRESULT

--*/
{
    //
    // Get GetData allocate the buffer for us
    //
    DWORD dwSize = 0;
    DWORD dwDataType = MULTISZ_METADATA;
    LPTSTR lpData = NULL;

    HRESULT hr = GetPropertyValue(
        dwID, 
        dwSize, 
        (void *&)lpData, 
        &dwDataType,
        pfInheritanceOverride,
        lpszMDPath,
        pdwAttributes
        );

    if (SUCCEEDED(hr))
    {
        //
        // Notes: Consider accepting a single STRING
        //
        ASSERT(dwDataType == MULTISZ_METADATA);

        DWORD err = strlValue.ConvertFromDoubleNullList(lpData, dwSize / sizeof(TCHAR));
        hr = HRESULT_FROM_WIN32(err);
    }

    if (lpData)
    {
        delete [] lpData;
    }

    return hr;
}



HRESULT
CMetaKey::QueryValue(
    IN  DWORD dwID,
    IN  OUT CBlob & blValue,
    IN  BOOL * pfInheritanceOverride, OPTIONAL
    IN  LPCTSTR lpszMDPath,           OPTIONAL
    OUT DWORD * pdwAttributes         OPTIONAL
    )
/*++

Routine Description:

    Fetch data as a binary blob

Arguments:

    DWORD dwID                      : Property ID
    DWORD CBlob & blValue           : Returns the binary blob
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes    

Return Value:

    HRESULT

--*/
{
    //
    // Get GetData allocate the buffer for us
    //
    DWORD dwSize = 0;
    DWORD dwDataType = BINARY_METADATA;
    LPBYTE pbData = NULL;

    HRESULT hr = GetPropertyValue(
        dwID, 
        dwSize, 
        (void *&)pbData, 
        &dwDataType,
        pfInheritanceOverride,
        lpszMDPath,
        pdwAttributes
        );

    if (SUCCEEDED(hr))
    {
        //
        // Blob takes ownership of the data, so don't free it...
        //
        ASSERT_READ_PTR2(pbData, dwSize);
        blValue.SetValue(dwSize, pbData, FALSE);
    }

    return hr;
}



HRESULT 
CMetaKey::SetValue(
    IN DWORD dwID,
    IN CStrPassword & strlValue,
    IN BOOL * pfInheritanceOverride,        OPTIONAL
    IN LPCTSTR lpszMDPath                   OPTIONAL
    )
{
    LPTSTR lpstr = NULL;
    HRESULT hr = E_FAIL;

    lpstr = strlValue.GetClearTextPassword();
    if (lpstr)
    {
        hr = SetPropertyValue(
            dwID,
            strlValue.GetByteLength(),
            (void *)lpstr,
            pfInheritanceOverride,
            lpszMDPath
            );

        strlValue.DestroyClearTextPassword(lpstr);
    }
    return hr;
}



HRESULT 
CMetaKey::SetValue(
    IN DWORD dwID,
    IN CStringListEx & strlValue,
    IN BOOL * pfInheritanceOverride,        OPTIONAL
    IN LPCTSTR lpszMDPath                   OPTIONAL
    )
/*++

Routine Description:

    Store data as string

Arguments:

    DWORD dwID                   : Property ID
    CStringListEx & strlValue    : Value to be written
    BOOL * pfInheritanceOverride : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath           : Optional path (or NULL or "")

Return Value:

    HRESULT

--*/
{
    DWORD cCharacters;
    LPTSTR lpstr = NULL;

    //
    // Flatten value
    //
    strlValue.ConvertToDoubleNullList(cCharacters, lpstr);

    HRESULT hr = SetPropertyValue(
        dwID,
        cCharacters * sizeof(TCHAR),
        (void *)lpstr,
        pfInheritanceOverride,
        lpszMDPath
        );

    delete [] lpstr;

    return hr;
}


HRESULT 
CMetaKey::SetValue(
    IN DWORD dwID,
    IN CBlob & blValue,
    IN BOOL * pfInheritanceOverride,    OPTIONAL     
    IN LPCTSTR lpszMDPath               OPTIONAL        
    )
/*++

Routine Description:

    Store data as binary

Arguments:

    DWORD dwID                   : Property ID
    CBlob & blValue              : Value to be written
    BOOL * pfInheritanceOverride : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath           : Optional path (or NULL or "")

Return Value:

    HRESULT

--*/
{
    return SetPropertyValue(
        dwID,
        blValue.GetSize(),
        (void *)blValue.GetData(),
        pfInheritanceOverride,
        lpszMDPath
        );
}



HRESULT
CMetaKey::DeleteValue(
    DWORD   dwID,
    LPCTSTR lpszMDPath      OPTIONAL
    )
/*++

Routine Description:

    Delete data

Arguments:

    DWORD   dwID            : Property ID of property to be deleted
    LPCTSTR lpszMDPath      : Optional path (or NULL or "")

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    METADATA_RECORD mdRecord;
    FETCH_PROPERTY_DATA_OR_FAIL(dwID, mdRecord);

    return DeleteData(
        m_hKey,
        lpszMDPath,
        mdRecord.dwMDIdentifier,
        mdRecord.dwMDDataType
        );
}



HRESULT 
CMetaKey::DoesPathExist(
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Determine if the path exists

Arguments:

    LPCTSTR lpszMDPath      : Relative path off the open key

Return Value:

    HRESULT, or S_OK if the path exists.

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    FILETIME ft;

    return GetLastChangeTime(m_hKey, lpszMDPath, &ft, FALSE);
}



HRESULT
CMetaInterface::Regenerate()
/*++

Routine Description:

    Attempt to recreate the interface pointer.  This assumes that the interface
    had been successfully created before, but has become invalid at some
    point afterwards.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ASSERT_PTR(m_pInterface);           // Must have been initialised

    SAFE_RELEASE(m_pInterface);

    m_hrInterface = Create();

    return m_hrInterface;
}


#define GET_TO_INTERFACE2()\
    IMSAdminBase2 * pInterface2 = NULL;\
	HRESULT hr = GetAdminInterface2(&pInterface2);\
	if (SUCCEEDED(hr)) {

#define RELEASE_AND_RETURN2()\
        if (pInterface2 != NULL)\
			pInterface2->Release();\
    }\
	return hr\

HRESULT
CMetaInterface::GetAdminInterface2(IMSAdminBase2 ** pp)
{
	HRESULT hr = S_OK;
	IMSAdminBase2 * p = NULL;
	if (pp == NULL)
		return E_POINTER;
    if (m_auth.UsesImpersonation())
	{
		IUnknown * punk = NULL;
		hr = m_pInterface->QueryInterface(__uuidof(IUnknown), (void **)&punk);
		if (SUCCEEDED(hr)) 
		{
			if (SUCCEEDED(hr = m_auth.ApplyProxyBlanket(punk))) 
			{
				if (SUCCEEDED(hr = punk->QueryInterface(IID_IMSAdminBase2, (void **)&p))) 
				{
					if (p != NULL) 
					{
						hr = m_auth.ApplyProxyBlanket(p);
						if (SUCCEEDED(hr))
						{
							*pp = p;
						}
					}
				}
			}
		}
		if (punk != NULL)
			punk->Release();
    }
	else
	{
		hr = m_pInterface->QueryInterface(IID_IMSAdminBase2, (void **)pp);
	}
	return hr;
}

//
// CWamInterface class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CWamInterface::CWamInterface(
    IN CComAuthInfo * pAuthInfo         OPTIONAL
    )
/*++

Routine Description:

    Construct and initialize the interface.

Arguments:

    CComAuthInfo * pAuthInfo   : Auth info.  NULL indicates the local computer.

Return Value:

    N/A

--*/
    : CIISInterface(pAuthInfo),
      m_pInterface(NULL),
      m_fSupportsPooledProc(FALSE)
{
    //
    // Initialize the interface
    //
    m_hrInterface = Create();
}



CWamInterface::CWamInterface(
    IN CWamInterface * pInterface
    )
/*++

Routine Description:

    Construct from existing interface (copy constructor)

Arguments:

    CWamInterface * pInterface  : Existing interface

Return Value:

    N/A

--*/
    : CIISInterface(&pInterface->m_auth, pInterface->m_hrInterface),
      m_pInterface(pInterface->m_pInterface),
      m_fSupportsPooledProc(FALSE)
{
    ASSERT_PTR(m_pInterface);
    m_pInterface->AddRef();
}



CWamInterface::~CWamInterface()
/*++

Routine Description:

    Destructor -- releases the interface.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    SAFE_RELEASE(m_pInterface);
}



/* protected */
HRESULT
CWamInterface::Create()
/*++

Routine Description:

    Create the interface with DCOM

Arguments:

    None

Return Value:

    HRESULT 

Notes:

    First, it will attempt to create the new interface, if it
    fails, it will attempt to create the downlevel interface

--*/
{
    CLSID rgCLSID[2];
    IID   rgIID[2];

    rgCLSID[1] = rgCLSID[0] = CLSID_WamAdmin;
    rgIID[0] = IID_IWamAdmin2;
    rgIID[1] = IID_IWamAdmin;
    
    ASSERT(ARRAY_SIZE(rgCLSID) == ARRAY_SIZE(rgIID));
    int cInterfaces = ARRAY_SIZE(rgCLSID);
    int iInterface;
    
    HRESULT hr = CIISInterface::Create(
        cInterfaces,
        rgIID, 
        rgCLSID, 
        &iInterface, 
        (IUnknown **)&m_pInterface
        );

    if (SUCCEEDED(hr))
    {
        //
        // Only supported on IWamAdmin2
        //
        m_fSupportsPooledProc = (rgIID[iInterface] == IID_IWamAdmin2);
    }

    return hr;
}



HRESULT 
CWamInterface::AppCreate( 
    IN LPCTSTR szMDPath,
    IN DWORD   dwAppProtection
    )
/*++

Routine Description:

    Create  application

Arguments:

    LPCTSTR szMDPath      : Metabase path
    DWORD dwAppProtection : APP_INPROC     to create in-proc app
                            APP_OUTOFPROC  to create out-of-proc app
                            APP_POOLEDPROC to create a pooled-proc app

Return Value:

    HRESULT (ERROR_INVALID_PARAMETER if unsupported protection state is requested)

--*/
{
    if (m_fSupportsPooledProc)
    {
        //
        // Interface pointer is really IWamAdmin2, so call the new method
        //
        return ((IWamAdmin2 *)m_pInterface)->AppCreate2(szMDPath, dwAppProtection);
    }

    //
    // Call the downlevel API
    //
    if (dwAppProtection == APP_INPROC || dwAppProtection == APP_OUTOFPROC)
    {
        BOOL fInProc = (dwAppProtection == APP_INPROC);
    
        ASSERT_PTR(m_pInterface);
        return m_pInterface->AppCreate(szMDPath, fInProc);
    }

    return CError(ERROR_INVALID_PARAMETER);
}



//
// CMetaback Class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


const LPCTSTR CMetaBack::s_szMasterAppRoot =\
    SZ_MBN_SEP_STR SZ_MBN_MACHINE SZ_MBN_SEP_STR SZ_MBN_WEB;


CMetaBack::CMetaBack(
    IN CComAuthInfo * pAuthInfo        OPTIONAL
    )
/*++

Routine Description:

    Constructor for metabase backup/restore operations class.  This object
    is both a WAM interface and a METABASE interface.

Arguments:

    CComAuthInfo * pAuthInfo    : Auth info.  NULL indicates the local computer.

Return Value:

    N/A

--*/
    : m_dwIndex(0),
      CMetaInterface(pAuthInfo),
      CWamInterface(pAuthInfo)
{
}



/* virtual */
BOOL 
CMetaBack::Succeeded() const
/*++

Routine Description:

    Determine if object was constructed successfully.

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    return CMetaInterface::Succeeded() && CWamInterface::Succeeded();
}



/* virtual */
HRESULT 
CMetaBack::QueryResult() const
/*++

Routine Description:

    Return the construction error for this object

Arguments:

    None

Return Value:

    HRESULT from construction errors

--*/
{
    //
    // Both interfaces must have constructed successfully
    //
    HRESULT hr = CMetaInterface::QueryResult();

    if (SUCCEEDED(hr))
    {
        hr = CWamInterface::QueryResult();
    }    

    return hr;
}



HRESULT 
CMetaBack::Restore(
    IN LPCTSTR lpszLocation,
    IN DWORD dwVersion
    )
/*++

Routine Description:

    Restore metabase

Arguments:

    DWORD dwVersion         : Backup version
    LPCTSTR lpszLocation    : Backup location

Return Value:

    HRESULT

--*/
{
    //
    // Backup and restore the application information from a restore
    //
    CString strPath(s_szMasterAppRoot);
    HRESULT hr = AppDeleteRecoverable(strPath, TRUE);

    if (SUCCEEDED(hr))
    {
        hr = CMetaInterface::Restore(lpszLocation, dwVersion, 0);

        if (SUCCEEDED(hr))
        {
            hr = AppRecover(strPath, TRUE);
        }
    }

    return hr;
}



//
// CIISSvcControl class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CIISSvcControl::CIISSvcControl(
    IN CComAuthInfo * pAuthInfo        OPTIONAL
    )
/*++

Routine Description:

    Construct and initialize the interface.

Arguments:

    CComAuthInfo * pAuthInfo    : Auth info.  NULL indicates the local computer.

Return Value:

    N/A

--*/
    : CIISInterface(pAuthInfo),
      m_pInterface(NULL)
{
    //
    // Initialize the interface
    //
    m_hrInterface = Create();
}



CIISSvcControl::CIISSvcControl(
    IN CIISSvcControl * pInterface
    )
/*++

Routine Description:

    Construct from existing interface (copy constructor)

Arguments:

    CIISSvcControl * pInterface  : Existing interface

Return Value:

    N/A

--*/
    : CIISInterface(&pInterface->m_auth, pInterface->m_hrInterface),
      m_pInterface(pInterface->m_pInterface)
{
    ASSERT_PTR(m_pInterface);
    m_pInterface->AddRef();
}



CIISSvcControl::~CIISSvcControl()
/*++

Routine Description:

    Destructor -- releases the interface.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    SAFE_RELEASE(m_pInterface);
}


#ifdef KEVLAR
//
// CWebCluster class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CWebCluster::CWebCluster(
    IN CComAuthInfo * pAuthInfo        OPTIONAL
    )
/*++

Routine Description:

    Construct and initialize the interface.

Arguments:

    CComAuthInfo * pAuthInfo : Authentication information.  
                               NULL indicates the local computer
    
Return Value:

    N/A

--*/
    : CIISInterface(pAuthInfo),
      m_pInterface(NULL)
{
    //
    // Initialize the interface
    //
    m_hrInterface = Create();
}



/* virtual */
CWebCluster::~CWebCluster()
/*++

Routine Description:

    Destructor -- releases the interface.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    SAFE_RELEASE(m_pInterface);
}

#endif // KEVLAR

//
// CMetaEnumerator Clas
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CMetaEnumerator::CMetaEnumerator(
    IN CComAuthInfo * pAuthInfo     OPTIONAL,
    IN LPCTSTR lpszMDPath           OPTIONAL,
    IN METADATA_HANDLE hkBase       OPTIONAL
    )
/*++

Routine Description:

    Metabase enumerator constructor.  This constructor creates a new interface
    and opens a key.

Arguments:

    CComAuthInfo * pAuthInfo : Auth info.  NULL indicates the local computer.
    LPCTSTR lpszMDPath       : Metabase path
    METADATA_HANDLE hkBase   : Metabase handle

Return Value:

    N/A

--*/
    : CMetaKey(pAuthInfo, lpszMDPath, METADATA_PERMISSION_READ, hkBase),
      m_dwIndex(0L)
{
}



CMetaEnumerator::CMetaEnumerator(
    IN CMetaInterface * pInterface,
    IN LPCTSTR lpszMDPath,                  OPTIONAL
    IN METADATA_HANDLE hkBase               OPTIONAL
    )
/*++

Routine Description:

    Metabase enumerator constructor.  This constructor uses an existing
    interface and opens a key.

Arguments:

    CMetaInterface * pInterface : Existing interface
    LPCTSTR lpszMDPath          : Metabase path
    METADATA_HANDLE hkBase      : Metabase handle

Return Value:

    N/A

--*/
    : CMetaKey(pInterface, lpszMDPath, METADATA_PERMISSION_READ, hkBase),
      m_dwIndex(0L)
{
}



CMetaEnumerator::CMetaEnumerator(
    IN BOOL fOwnKey,
    IN CMetaKey * pKey
    )
/*++

Routine Description:

    Metabase enumerator constructor.  This constructor uses an existing
    interface and open key.

Arguments:

    BOOL fOwnKey            : TRUE if we own the key (destructor will close)
    CMetaKey * pKey         : Open key

Return Value:

    N/A

--*/
    : CMetaKey(fOwnKey, pKey),
      m_dwIndex(0L)
{
}



HRESULT
CMetaEnumerator::Next(
    OUT CString & strKey,
    IN  LPCTSTR lpszMDPath      OPTIONAL
    )
/*++

Routine Description:

    Get the next subkey

Arguments:

    CString & str           Returns keyname
    LPCTSTR lpszMDPath      Optional subpath

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    TCHAR buf[MAX_PATH];
    HRESULT hr = EnumKeys(m_hKey, lpszMDPath, buf, m_dwIndex++);
    if (SUCCEEDED(hr))
       strKey = buf;

    return hr;        
}



HRESULT
CMetaEnumerator::Next(
    OUT DWORD & dwKey,
    OUT CString & strKey,
    IN  LPCTSTR lpszMDPath      OPTIONAL
    )
/*++

Routine Description:

    Get the next subkey as a DWORD.  This skips non-numeric
    keynames (including 0) until the first numeric key name 

Arguments:

    DWORD & dwKey           Numeric key
    CString & strKey        Same key in string format
    LPCTSTR lpszMDPath      Optional subpath

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    HRESULT hr;
    TCHAR buf[MAX_PATH];

    while (TRUE)
    {
        if (SUCCEEDED(hr = EnumKeys(m_hKey, lpszMDPath, buf, m_dwIndex++)))
        {
            if (0 != (dwKey = _ttoi(buf)))
            {
               strKey = buf;
               break;
            }
        }
        else
           break;
    }
    
    return hr;        
}


// This method moved from inline to remove dependency on IIDs and CLSIDs
HRESULT 
CIISSvcControl::Create()
{
    return CIISInterface::Create(
        1,
        &IID_IIisServiceControl, 
        &CLSID_IisServiceControl, 
        NULL, 
        (IUnknown **)&m_pInterface
        );
}


//
// CIISApplication class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<</



CIISApplication::CIISApplication(
    IN CComAuthInfo * pAuthInfo   OPTIONAL,
    IN LPCTSTR lpszMetapath
    )
/*++

Routine Description:

    Construct IIS application.        

Arguments:

    CComAuthInfo * pAuthInfo : Authentication info.  NULL indicates the
                               local computer.
    LPCTSTR lpszMetapath     : Metabase path

Return Value:

    N/A

--*/
    : CWamInterface(pAuthInfo),
      CMetaKey(pAuthInfo),
      m_dwProcessProtection(APP_INPROC),
      m_dwAppState(APPSTATUS_NOTDEFINED),
      m_strFriendlyName(),
      m_strAppRoot(),
      m_strWamPath(lpszMetapath)
{
    CommonConstruct();
}



void
CIISApplication::CommonConstruct()
/*++

Routine Description:

    Perform common construction

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Munge the metapath so that WAM doesn't cough up a hairball.
    //


    //
    // BUGBUG: CleanMetaPath() disabled currently
    //

    if (m_strWamPath[0] != SZ_MBN_SEP_CHAR)
    {
        m_strWamPath = SZ_MBN_SEP_CHAR + m_strWamPath;
    }

    do
    {
        m_hrApp = CWamInterface::QueryResult();

        if (FAILED(m_hrApp))
        {
            break;
        }

        m_hrApp = RefreshAppState();

        if (HRESULT_CODE(m_hrApp) == ERROR_PATH_NOT_FOUND)
        {
            //
            // "Path Not Found" errors are acceptable, since
            // the application may not yet exist.
            //
            m_hrApp = S_OK;
        }
    }
    while(FALSE);
}



/* virtual */
BOOL 
CIISApplication::Succeeded() const
/*++

Routine Description:

    Determine if object was constructed successfully

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    return CMetaInterface::Succeeded() 
        && CWamInterface::Succeeded()
        && SUCCEEDED(m_hrApp);
}



/* virtual */
HRESULT 
CIISApplication::QueryResult() const
/*++

Routine Description:

    Return the construction error for this object

Arguments:

    None

Return Value:

    HRESULT from construction errors

--*/
{
    //
    // Both interfaces must have constructed successfully
    //
    HRESULT hr = CMetaInterface::QueryResult();

    if (SUCCEEDED(hr))
    {
        hr = CWamInterface::QueryResult();

        if (SUCCEEDED(hr))
        {
            hr = m_hrApp;
        }
    }    

    return hr;
}



HRESULT 
CIISApplication::RefreshAppState()
/*++

Routine Description:

    Refresh the application state

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ASSERT(!m_strWamPath.IsEmpty());

    HRESULT hr, hrKeys;

    hr = AppGetStatus(m_strWamPath, &m_dwAppState);

    if (FAILED(hr))
    {
        m_dwAppState = APPSTATUS_NOTDEFINED;
    }

    m_strAppRoot.Empty();
    hrKeys = QueryValue(MD_APP_ROOT, m_strAppRoot, NULL, m_strWamPath);

    m_dwProcessProtection = APP_INPROC;
    hrKeys = QueryValue(
        MD_APP_ISOLATED, 
        m_dwProcessProtection, 
        NULL, 
        m_strWamPath
        );

    m_strFriendlyName.Empty();
    hrKeys = QueryValue(
        MD_APP_FRIENDLY_NAME, 
        m_strFriendlyName, 
        NULL, 
        m_strWamPath
        );

    return hr;
}



HRESULT 
CIISApplication::Create(
    IN LPCTSTR lpszName,        OPTIONAL
    IN DWORD dwAppProtection
    )
/*++

Routine Description:

    Create the application

Arguments:

    LPCTSTR lpszName      : Application name
    DWORD dwAppProtection : APP_INPROC     to create in-proc app
                            APP_OUTOFPROC  to create out-of-proc app
                            APP_POOLEDPROC to create a pooled-proc app

Return Value:

    HRESULT

--*/
{
    ASSERT(!m_strWamPath.IsEmpty());
    HRESULT hr = AppCreate(m_strWamPath, dwAppProtection);

    if (SUCCEEDED(hr))
    {
        //
        // Write the friendly app name, which we maintain
        // ourselves.  Empty it first, because we might
        // have picked up a name from inheritance.
        //
        m_strFriendlyName.Empty(); 
        hr = WriteFriendlyName(lpszName);

        RefreshAppState();
    }

    return hr;
}



HRESULT 
CIISApplication::WriteFriendlyName(
    IN LPCTSTR lpszName
    )
/*++

Routine Description:

    Write the friendly name.  This will not write anything
    if the name is the same as it was

Arguments:

    LPCTSTR lpszName        : New friendly name

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;    

    if (m_strFriendlyName.CompareNoCase(lpszName) != 0)
    {
        hr = Open(METADATA_PERMISSION_WRITE, m_strWamPath);

        if (SUCCEEDED(hr))
        {
            ASSERT_PTR(lpszName);

            CString str(lpszName);    
            hr = SetValue(MD_APP_FRIENDLY_NAME, str);
            Close();

            if (SUCCEEDED(hr))
            {
                m_strFriendlyName = lpszName;
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\mdkeys.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module Name :

        mdkeys.h

   Abstract:

        Metabase key wrapper classes

   Author:

        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:
        2/17/2000    sergeia     removed dependency on MFC

--*/

#ifndef _MDKEYS_H_
#define _MDKEYS_H_

//
// Include Files
//
#include <iadmw.h>
#include <iwamreg.h>
#include <iiscnfgp.h>
#include <winsvc.h>
#include <iisrsta.h>
#include "strpass.h"

//
// Forward definitions
//
class CBlob;

//
// Use this instance number to denote the master
//
#define MASTER_INSTANCE       (0)
#define IS_MASTER_INSTANCE(i) (i == MASTER_INSTANCE)

//
// Metabase node constants, used for static initialization of const
// strings further down.  Defined here with #defines for easier 
// concatenation later.
//
#define SZ_MBN_MACHINE      _T("LM")
#define SZ_MBN_FILTERS      _T("Filters")
#define SZ_MBN_MIMEMAP      _T("MimeMap")
#define SZ_MBN_TEMPLATES    _T("Templates")
#define SZ_MBN_INFO         _T("Info")
#define SZ_MBN_ROOT         _T("Root")
#define SZ_MBN_COMPRESSION  _T("Compression")
#define SZ_MBN_PARAMETERS   _T("Parameters")
#define SZ_MBN_SEP_CHAR     _T('/')
#define SZ_MBN_SEP_STR      _T("/")
#define SZ_MBN_ANYSEP_STR   _T("/\\")
#define SZ_MBN_WEB          _T("W3SVC")
#define SZ_MBN_FTP          _T("MSFTPSVC")
#define SZ_MBN_APP_POOLS    _T("AppPools")


class CIISInterface;

class _EXPORT CComAuthInfo
/*++

Class Description:

    Server/authentication information.  Contains optional 
    impersonation parameters. Typically used in the construction in 
    CIISInterface.

Public Interface:

    CComAuthInfo            : Constructor.  Impersonation optional
    operator=               : Assignment operators
    CreateServerInfoStruct  : Helper function for use in COM
    FreeServerInfoStruct    : As above.

Notes:

    Because there's an operator for a pointer to itself and because
    CIISInterface copies the information at construction time, a 
    CComAuthInfo can safely be constructed on the stack as a parameter
    to CIISInterface derived classes.

--*/
{
//
// Constructor/Destructor
//
public:
    //
    // Standard Constructor.  NULL for servername indicates
    // local computer.
    //
    CComAuthInfo(
        IN LPCOLESTR lpszServerName  = NULL,    
        IN LPCOLESTR lpszUserName    = NULL,
        IN LPCOLESTR lpszPassword    = NULL
        );

    //
    // Copy Constructors
    //
    CComAuthInfo(
        IN CComAuthInfo & auth
        );

    CComAuthInfo(
        IN CComAuthInfo * pAuthInfo OPTIONAL
        );

//
// Assignment operators
//
public:
    CComAuthInfo & operator =(CComAuthInfo & auth);
    CComAuthInfo & operator =(CComAuthInfo * pAuthInfo);
    CComAuthInfo & operator =(LPCTSTR lpszServerName);

//
// Access
//
public:
    COSERVERINFO * CreateServerInfoStruct() const;
    COSERVERINFO * CreateServerInfoStruct(DWORD dwAuthnLevel) const;
    void FreeServerInfoStruct(COSERVERINFO * pServerInfo) const;

    LPOLESTR QueryServerName() const { return m_bstrServerName; }
    LPOLESTR QueryUserName() const { return m_bstrUserName; }
    LPOLESTR QueryPassword() const { return m_bstrPassword; }
    BOOL     IsLocal() const { return m_fLocal; }
    BOOL     UsesImpersonation() const { return m_bstrUserName.Length() > 0; }
    void     SetImpersonation(LPCOLESTR lpszUser, LPCOLESTR lpszPassword);
    void     RemoveImpersonation();
    void     StorePassword(LPCOLESTR lpszPassword);

public:
    HRESULT  ApplyProxyBlanket(IUnknown * pInterface);
	HRESULT  ApplyProxyBlanket(IUnknown * pInterface,DWORD dwAuthnLevel);

    
//
// Conversion Operators
//
public:
    operator LPOLESTR() { return QueryServerName(); }
    operator CComAuthInfo *() { return this; }

//
// Static Helpers
//
public:
    //
    // Given domain\username, split into user name and domain
    //
    static BOOL SplitUserNameAndDomain(
        IN OUT CString & strUserName,
        IN CString & strDomainName
        );

    //
    // Verify username and password are correct
    //
    static DWORD VerifyUserPassword(
        IN LPCTSTR lpstrUserName,
        IN LPCTSTR lpstrPassword
        );

protected:
    //
    // Store the computer name (NULL for local computer)
    //
    void SetComputerName(
        IN LPCOLESTR lpszServerName   OPTIONAL
        );

private:
    CComBSTR    m_bstrServerName;
    CComBSTR    m_bstrUserName;
    CComBSTR    m_bstrPassword;
    BOOL        m_fLocal;
};

class _EXPORT CMetabasePath
/*++

Class Description:

    Metabase path class.  This is a helper class to build complete
    metabase paths out of various components.

    Example: CMetaKey(CComAuthInfo("ronaldm3"), CMetabasePath(SZ_WEBSVC, dwInstance, _T("root")));

--*/
{
    //
    // Metabase components in order
    //
    enum
    {
        iBlank,                    // Sep 0
        iMachine,                  // LM
        iService,                  // e.g. lm/w3svc
        iInstance,                 // e.g. lm/w3svc/1
        iRootDirectory,            // e.g. lm/w3svc/1/root
        iSubDirectory,             // e.g. lm/w3vsc/1/root/foobar
    };

//
// Metabase helper functions.
//
public:
    //
    // Clean metabase path
    //
    static LPCTSTR CleanMetaPath(
        IN OUT CString & strMetaRoot
        );

    static LPCTSTR CleanMetaPath(
        CMetabasePath & path
        );

    //
    // Find the instance number from the given metabase path
    //
    static DWORD GetInstanceNumber(LPCTSTR lpszMDPath);

    //
    // Get the last nodename in the given metabase path
    //
    static LPCTSTR GetLastNodeName(
        IN  LPCTSTR lpszMDPath,
        OUT CString & strNodeName
        );

    //
    // Truncate the path at a given sub path
    //
    static LPCTSTR TruncatePath(
        IN int     nLevel,          
        IN LPCTSTR lpszMDPath,
        OUT CString & strNewPath,
        OUT CString * pstrRemainder = NULL
        );

    static LPCTSTR GetMachinePath(
        IN  LPCTSTR lpszMDPath,
        OUT CString & strNewPath,
        OUT CString * pstrRemainder = NULL
        );

    static LPCTSTR GetServicePath(
        IN  LPCTSTR lpszMDPath,
        OUT CString & strNewPath,
        OUT CString * pstrRemainder = NULL
        );

    static LPCTSTR GetInstancePath(
        IN  LPCTSTR lpszMDPath,
        OUT CString & strNewPath,
        OUT CString * pstrRemainder = NULL
        );

    static LPCTSTR GetRootPath(
        IN  LPCTSTR lpszMDPath,
        OUT CString & strNewPath,
        OUT CString * pstrRemainder = NULL
        );

    //
    // Determine the path to the info node that's relevant
    // to this metabase path.
    //
    static LPCTSTR GetServiceInfoPath(
        IN  LPCTSTR lpszMDPath,
        OUT CString & strInfoPath,   
        IN  LPCTSTR lpszDefService  = SZ_MBN_WEB
        );

    //
    // Change path to parent node
    //
    static LPCTSTR ConvertToParentPath(
        OUT IN CString & strMetaPath
        );

    static LPCTSTR ConvertToParentPath(
        CMetabasePath& path
        );

    //
    // Determine if the path describes a home directory path
    //
    static BOOL IsHomeDirectoryPath(
        IN LPCTSTR lpszMDPath
        );

    //
    // Determine if the path describes the 'master' instance (site)
    //
    static BOOL IsMasterInstance(
        IN LPCTSTR lpszMDPath
        );

    //
    // Split the metapath at the instance border
    //
    static void SplitMetaPathAtInstance(
        IN  LPCTSTR lpszMDPath,
        OUT CString & strParent,
        OUT CString & strAlias
        );

    static BOOL IsSeparator(TCHAR c);
 

//
// Constructor/Destructor
//
public:
    CMetabasePath(
        IN BOOL    fAddBasePath,
        IN LPCTSTR lpszMDPath,
        IN LPCTSTR lpszMDPath2 = NULL,
        IN LPCTSTR lpszMDPath3 = NULL,
        IN LPCTSTR lpszMDPath4 = NULL
        );

    //
    // Construct with path components
    //
    CMetabasePath(
        IN  LPCTSTR lpszSvc        = NULL,    
        IN  DWORD   dwInstance     = MASTER_INSTANCE,
        IN  LPCTSTR lpszParentPath = NULL,        
        IN  LPCTSTR lpszAlias      = NULL    
        );

//
// Access
//
public:
    BOOL    IsHomeDirectoryPath() const { return IsHomeDirectoryPath(m_strMetaPath); }
    LPCTSTR QueryMetaPath() const { return m_strMetaPath; }

//
// Conversion Operators
//
public:
    operator LPCTSTR() const { return QueryMetaPath(); }

//
// Helpers
//
protected:
    void BuildMetaPath(  
        IN  LPCTSTR lpszSvc,
        IN  LPCTSTR szInstance,
        IN  LPCTSTR lpszParentPath,
        IN  LPCTSTR lpszAlias           
        );

    void BuildMetaPath(  
        IN  LPCTSTR lpszSvc,
        IN  DWORD   dwInstance,
        IN  LPCTSTR lpszParentPath,
        IN  LPCTSTR lpszAlias           
        );

    void AppendPath(LPCTSTR lpszPath);
    void AppendPath(DWORD dwInstance);

protected:
    //
    // Metabase path components
    //
    static const LPCTSTR _cszMachine;     
    static const LPCTSTR _cszRoot;        
    static const LPCTSTR _cszSep;         
    static const TCHAR   _chSep;          
    static const CString _anySep;

private:
    CString m_strMetaPath;
};

class _EXPORT CIISInterface
/*++

Class Description:

    Base interface class for IIS interfaces.  Most client COM-wrappers
    should derive from this class so that they can easily pick up
    share authentication and proxy blanket information methods.

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

Public Interface:

    operator BOOL       : Cast to TRUE/FALSE depending on success
    operator HRESULT    : Cast to the HRESULT status

    QueryServerName     : Get the server name
    IsLocal             : Determine if the interface is on the local machine

--*/
{
//
// Constructor/Destructor
//
public:
    CIISInterface(
        IN CComAuthInfo * pAuthInfo,
        IN HRESULT hrInterface    = S_OK
        );

//
// Interface:
//
public:
    CComAuthInfo * QueryAuthInfo() { return &m_auth; }
    LPCOLESTR QueryServerName() const { return m_auth.QueryServerName(); }
    BOOL IsLocal() const { return m_auth.IsLocal(); }

//
// Virtual Interface:
//
public:
    virtual BOOL Succeeded() const { return SUCCEEDED(m_hrInterface); }
    virtual HRESULT QueryResult() const { return m_hrInterface; }
    virtual HRESULT ChangeProxyBlanket(
        IN LPCOLESTR lpszUserName, 
        IN LPCOLESTR lpszPassword
        );

//
// Conversion Operators
//
public:
    operator BOOL() const { return Succeeded(); }
    operator HRESULT() const { return m_hrInterface; }

protected:
    virtual HRESULT ApplyProxyBlanket() = 0;
    HRESULT Create(
        IN  int   cInterfaces,       
        IN  const IID rgIID[],      
        IN  const GUID rgCLSID[],    
        OUT int * pnInterface,          OPTIONAL
        OUT IUnknown ** ppInterface 
        );

protected:
    CComAuthInfo m_auth;
    HRESULT    m_hrInterface;
};


class _EXPORT CMetaInterface : public CIISInterface
/*++

Class description:

    Metabase interface class.

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

Public Interface:

    Regenerate          : Recreate the interface

--*/
{
public:
    //
    // Destructor destroys the interface
    //
    virtual ~CMetaInterface();

//
// Constructor/Destructor
//
protected:
    //
    // Fully defined constructor that creates the interface.
    // Use NULL to indicate the local computer name
    //
    CMetaInterface(
        IN CComAuthInfo * pServer
        );

    //
    // Construct from existing interface
    //
    CMetaInterface(
        IN CMetaInterface * pInterface
        );

public:
    //
    // Rebuild the interface
    //
    HRESULT Regenerate();
    // 
    // Flush matabase to disk
    //
    HRESULT SaveData();
    //
    IMSAdminBase * GetInterface() { return m_pInterface; }

    HRESULT GetAdminInterface2(IMSAdminBase2 ** pp);

protected:
    virtual HRESULT ApplyProxyBlanket();

    //
    // Create a metadata object in this server. This function initializes the
    // metadata object with DCOM.
    //
    HRESULT Create();

    //
    // Make sure the interface has been created
    //
    BOOL HasInterface() const { return m_pInterface != NULL; }

//
// IADMW Interface -- all methods defines as inline at the end of this file.
//
protected:
    HRESULT OpenKey(
        IN  METADATA_HANDLE hkBase,
        IN  LPCTSTR lpszMDPath,
        IN  DWORD dwFlags,
        OUT METADATA_HANDLE * phMDNewHandle
        );

    HRESULT CloseKey(
        IN METADATA_HANDLE hKey
        );

    HRESULT SetLastChangeTime( 
        IN METADATA_HANDLE hMDHandle,
        IN LPCTSTR pszMDPath,
        IN FILETIME * pftMDLastChangeTime,
        IN BOOL bLocalTime
        );
        
    HRESULT GetLastChangeTime( 
        IN  METADATA_HANDLE hMDHandle,
        IN  LPCTSTR lpszMDPath,
        OUT FILETIME * pftMDLastChangeTime,
        IN  BOOL bLocalTime
        );

    HRESULT AddKey( 
        IN METADATA_HANDLE hKey,
        IN LPCTSTR lpszMDPath
        );

    HRESULT DeleteKey(
        IN METADATA_HANDLE hKey,
        IN LPCTSTR lpszMDPath
        );

    HRESULT DeleteChildKeys(
        IN METADATA_HANDLE hKey,
        IN LPCTSTR lpszMDPath
        );

    HRESULT EnumKeys(
        IN  METADATA_HANDLE hKey,
        IN  LPCTSTR lpszMDPath,
        OUT LPTSTR lpszMDName,
        IN  DWORD dwIndex
        );

    HRESULT CopyKey(
        IN METADATA_HANDLE hSourceKey,
        IN LPCTSTR lpszMDSourcePath,
        IN METADATA_HANDLE hDestKey,
        IN LPCTSTR lpszMDDestPath,
        IN BOOL fOverwrite,
        IN BOOL fCopy
        );

    HRESULT RenameKey(
        IN METADATA_HANDLE hKey,
        IN LPCTSTR lpszMDPath,
        IN LPCTSTR lpszNewName
        );

    HRESULT GetData(
        IN  METADATA_HANDLE hKey,
        IN  LPCTSTR lpszMDPath,
        OUT METADATA_RECORD * pmdRecord,
        OUT DWORD * pdwRequiredDataLen
        );

    HRESULT SetData(
        IN METADATA_HANDLE hKey,
        IN LPCTSTR lpszMDPath,
        IN METADATA_RECORD * pmdRecord
        );

    HRESULT DeleteData(
        IN METADATA_HANDLE hKey,
        IN LPCTSTR lpszMDPath,
        IN DWORD dwMDIdentifier,
        IN DWORD dwMDDataType
        );

    HRESULT EnumData(
        IN METADATA_HANDLE hKey,
        IN LPCTSTR lpszMDPath,
        OUT METADATA_RECORD * pmdRecord,
        IN DWORD dwIndex,
        OUT DWORD * pdwRequiredDataLen
        );

    HRESULT GetAllData(
        IN  METADATA_HANDLE hKey,
        IN  LPCTSTR lpszMDPath,
        IN  DWORD dwMDAttributes,
        IN  DWORD dwMDUserType,
        IN  DWORD dwMDDataType,
        OUT DWORD * pdwMDNumDataEntries,
        OUT DWORD * pdwMDDataSetNumber,
        IN  DWORD dwMDBufferSize,
        OUT LPBYTE pbMDBuffer,
        OUT DWORD * pdwRequiredBufferSize
        );

    HRESULT DeleteAllData( 
        IN METADATA_HANDLE hKey,
        IN LPCTSTR lpszMDPath,
        IN DWORD dwMDUserType,
        IN DWORD dwMDDataType
        );

    HRESULT CopyData( 
        IN METADATA_HANDLE hMDSourceKey,
        IN LPCTSTR lpszMDSourcePath,
        IN METADATA_HANDLE hMDDestKey,
        IN LPCTSTR lpszMDDestPath,
        IN DWORD dwMDAttributes,
        IN DWORD dwMDUserType,
        IN DWORD dwMDDataType,
        IN BOOL fCopy
        );

    HRESULT GetDataPaths( 
        IN  METADATA_HANDLE hKey,
        IN  LPCTSTR lpszMDPath,
        IN  DWORD dwMDIdentifier,
        IN  DWORD dwMDDataType,
        IN  DWORD dwMDBufferSize,
        OUT LPTSTR lpszBuffer,
        OUT DWORD * pdwMDRequiredBufferSize
        );

    HRESULT Backup( 
        IN LPCTSTR lpszBackupLocation,
        IN DWORD dwMDVersion,
        IN DWORD dwMDFlags
        );

    HRESULT Restore(    
        IN LPCTSTR lpszBackupLocation,
        IN DWORD dwMDVersion,
        IN DWORD dwMDFlags
        );

    HRESULT EnumBackups(
        OUT LPTSTR lpszBackupLocation,
        OUT DWORD * pdwMDVersion,
        OUT FILETIME * pftMDBackupTime,
        IN  DWORD dwIndex
        );

    HRESULT DeleteBackup(
        IN LPCTSTR lpszBackupLocation,
        IN DWORD dwMDVersion
        );

protected:
    IMSAdminBase * m_pInterface; 

private:
    int  m_iTimeOutValue;         
};



class _EXPORT CMetaKey : public CMetaInterface
/*++

Class Description:

    Metabase key wrapper class

Public Interface:

    CMetaKey                    : Constructor
    ~CMetaKey                   : Destructor

    Succeeded                   : TRUE if key opened successfully.
    QueryResult                 : Get the HRESULT status

    QueryValue                  : Various overloaded methods to get values
    SetValue                    : Various overloaded methods to set values
    DeleteValue                 : Delete a value
    Open                        : Open key
    ReOpen                      : Re key that was opened before
    Close                       : Close key
    ConvertToParentPath         : Change path to parent path

    operator METADATA_HANDLE    : Cast to a metadata handle
    operator LPCTSTR            : Cast to the metabase path
    operator BOOL               : Cast to TRUE if the key is open, FALSE if not

    GetHandle                   : Obtain metadata handle
    IsOpen                      : TRUE if a key is open
    QueryMetaPath               : Get the relative metabase path
    QueryFlags                  : Get the open permissions

--*/
{
//
// Constructor/Destructor
//
public:
    //
    // Null constructor that only creates the interface.
    // A key constructed this way may read from META_ROOT_HANDLE.
    // This is not true of other constructors.
    //
    CMetaKey(
        IN CComAuthInfo * pServer
        );

    //
    // As above, using an existing interface
    //
    CMetaKey(
        IN CMetaInterface * pInterface
        );

    //
    // Fully defined constructor that opens a key
    //
    CMetaKey(
        IN CComAuthInfo * pServer,
        IN LPCTSTR lpszMDPath,
        IN DWORD   dwFlags        = METADATA_PERMISSION_READ,
        IN METADATA_HANDLE hkBase = METADATA_MASTER_ROOT_HANDLE
        );

    //
    // As above, using an existing interface
    //
    CMetaKey(
        IN CMetaInterface * pInterface,
        IN LPCTSTR lpszMDPath,
        IN DWORD   dwFlags        = METADATA_PERMISSION_READ,
        IN METADATA_HANDLE hkBase = METADATA_MASTER_ROOT_HANDLE
        );

    //
    // Copy constructor, might or might not own the key
    //
    CMetaKey(
        IN BOOL fOwnKey,
        IN CMetaKey * pKey
        );

    //
    // Destructor -- closes key.
    //
    virtual ~CMetaKey();

//
// Interface
//
public:
    //
    // Fetch a DWORD
    //
    HRESULT QueryValue(
        IN  DWORD dwID, 
        OUT DWORD & dwValue,
        IN  BOOL * pfInheritanceOverride = NULL,
        IN  LPCTSTR lpszMDPath           = NULL,
        OUT DWORD * pdwAttributes        = NULL
        );

    //
    // Fetch a boolean
    //
    HRESULT QueryValue(
        IN  DWORD dwID, 
        OUT BOOL & fValue,
        IN  BOOL * pfInheritanceOverride = NULL,
        IN  LPCTSTR lpszMDPath           = NULL,
        OUT DWORD * pdwAttributes        = NULL
        );

    //
    // Fetch a string
    //
    HRESULT QueryValue(
        IN  DWORD dwID, 
        OUT CString & strValue, 
        IN  BOOL * pfInheritanceOverride = NULL,
        IN  LPCTSTR lpszMDPath           = NULL,
        OUT DWORD * pdwAttributes        = NULL
        );

    //
    // Fetch a CStrPassword
    //
    HRESULT QueryValue(
        IN  DWORD dwID, 
        OUT CStrPassword & strValue, 
        IN  BOOL * pfInheritanceOverride = NULL,
        IN  LPCTSTR lpszMDPath           = NULL,
        OUT DWORD * pdwAttributes        = NULL
        );

    //
    // Fetch a BSTR
    //
    HRESULT QueryValue(
        IN  DWORD dwID, 
        OUT CComBSTR & strValue, 
        IN  BOOL * pfInheritanceOverride = NULL,
        IN  LPCTSTR lpszMDPath           = NULL,
        OUT DWORD * pdwAttributes        = NULL
        );

    //
    // Fetch a string list
    //
    HRESULT QueryValue(
        IN  DWORD dwID, 
        OUT CStringListEx & strlValue, 
        IN  BOOL * pfInheritanceOverride = NULL,
        IN  LPCTSTR lpszMDPath           = NULL,
        OUT DWORD * pdwAttributes        = NULL
        );

    //
    // Fetch binary blob
    //
    HRESULT QueryValue(
        IN  DWORD dwID, 
        OUT CBlob & blValue, 
        IN  BOOL * pfInheritanceOverride = NULL,
        IN  LPCTSTR lpszMDPath           = NULL,
        OUT DWORD * pdwAttributes        = NULL
        );

    //
    // Store a DWORD
    //
    HRESULT SetValue(
        IN DWORD dwID,
        IN DWORD dwValue,
        IN BOOL * pfInheritanceOverride = NULL,
        IN LPCTSTR lpszMDPath           = NULL
        );

    //
    // Store a BOOL
    //
    HRESULT SetValue(
        IN DWORD dwID,
        IN BOOL fValue,
        IN BOOL * pfInheritanceOverride = NULL,
        IN LPCTSTR lpszMDPath           = NULL
        );

    //
    // Store a string
    //
    HRESULT SetValue(
        IN DWORD dwID,
        IN CString & strValue,
        IN BOOL * pfInheritanceOverride = NULL,
        IN LPCTSTR lpszMDPath           = NULL
        );

    //
    // Store a CStrPassword
    //
    HRESULT SetValue(
        IN DWORD dwID,
        IN CStrPassword & strValue,
        IN BOOL * pfInheritanceOverride = NULL,
        IN LPCTSTR lpszMDPath           = NULL
        );

    //
    // Store a BSTR
    //
    HRESULT SetValue(
        IN DWORD dwID,
        IN CComBSTR & strValue,
        IN BOOL * pfInheritanceOverride = NULL,
        IN LPCTSTR lpszMDPath           = NULL
        );


    //
    // Store a stringlist
    //
    HRESULT SetValue(
        IN DWORD dwID,
        IN CStringListEx & strlValue,
        IN BOOL * pfInheritanceOverride  = NULL,
        IN LPCTSTR lpszMDPath            = NULL
        );

    //
    // Store a binary blob
    //
    HRESULT SetValue(
        IN DWORD dwID,
        IN CBlob & blValue,
        IN BOOL * pfInheritanceOverride  = NULL,
        IN LPCTSTR lpszMDPath            = NULL
        );

    //
    // Delete Value:
    //
    HRESULT DeleteValue(
        IN DWORD   dwID,
        IN LPCTSTR lpszMDPath = NULL
        );

    //
    // Check for path existance
    //
    HRESULT DoesPathExist(
        IN LPCTSTR lpszMDPath
        );

    //
    // Create current path (which we attempted to open, and got
    // a path not found error on).
    //
    HRESULT CreatePathFromFailedOpen();

    //
    // Check for descendant overrides
    //
    HRESULT CheckDescendants(
        IN DWORD   dwID,
        IN CComAuthInfo * pServer,
        IN LPCTSTR lpszMDPath       = NULL
        );

    //
    // Open key
    //
    HRESULT Open(
        IN DWORD   dwFlags,
        IN LPCTSTR lpszMDPath       = NULL,
        IN METADATA_HANDLE hkBase   = METADATA_MASTER_ROOT_HANDLE 
        );

    //
    // Re-open previously opened key
    //
    HRESULT ReOpen(
        IN DWORD   dwFlags
        );

    //
    // As above using the same permissions as before
    //
    HRESULT ReOpen();

    //
    // Open the parent object
    // 
    HRESULT ConvertToParentPath(
        IN  BOOL fImmediate
        );

    //
    // Close key, set it to NULL, but doesn't destroy the interface
    //
    HRESULT Close();

    //
    // Add key
    //
    HRESULT AddKey(
        IN LPCTSTR lpszMDPath
        );

    //
    // Delete key off currently open key
    //
    HRESULT DeleteKey(
        IN LPCTSTR lpszMDPath
        );

    //
    // Rename key off currently open key
    //
    HRESULT RenameKey(
        IN LPCTSTR lpszMDPath,
        IN LPCTSTR lpszNewName
        );

    //
    // Get list of descendant nodes that override
    // a specific value
    //
    HRESULT GetDataPaths( 
        OUT CStringListEx & strlNodes,
        IN  DWORD dwMDIdentifier,
        IN  DWORD dwMDDataType,
        IN  LPCTSTR lpszMDPath = NULL
        );


//
// Access
//
public:
    METADATA_HANDLE GetHandle() const { return m_hKey; }
    METADATA_HANDLE GetBase() const   { return m_hBase; }
    LPCTSTR QueryMetaPath() const     { return m_strMetaPath; }
    DWORD QueryFlags() const          { return m_dwFlags; }
    BOOL IsOpen() const               { return m_hKey != NULL; }
    BOOL IsHomeDirectoryPath() const ;

//
// Conversion operators
//
public:
    operator METADATA_HANDLE() const  { return GetHandle(); }
    operator LPCTSTR() const          { return QueryMetaPath(); }
    operator BOOL() const             { return IsOpen(); }

//
// Virtual Interface:
//
public:
    virtual BOOL Succeeded() const;
    virtual HRESULT QueryResult() const;

//
// Protected members
//
protected:
    //
    // Get data
    //
    HRESULT GetPropertyValue(
        IN  DWORD dwID,
        OUT IN DWORD & dwSize,
        OUT IN void *& pvData,
        OUT IN DWORD * pdwDataType           = NULL,
        IN  BOOL * pfInheritanceOverride     = NULL,
        IN  LPCTSTR lpszMDPath               = NULL,
        OUT DWORD * pdwAttributes            = NULL
        );

    //
    // Store data
    //
    HRESULT SetPropertyValue(
        IN DWORD dwID,
        IN DWORD dwSize,
        IN void * pvData,
        IN BOOL * pfInheritanceOverride = NULL,
        IN LPCTSTR lpszMDPath           = NULL
        );

    //
    // Get All Data off the open key
    //
    HRESULT GetAllData(
        IN  DWORD dwMDAttributes,
        IN  DWORD dwMDUserType,
        IN  DWORD dwMDDataType,
        OUT DWORD * pdwMDNumEntries,
        OUT DWORD * pdwMDDataLen,
        OUT PBYTE * ppbMDData,
        IN  LPCTSTR lpszMDPath  = NULL
        );

//
// Property Table Methods
//
protected:
    //
    // Metabase table entry definition
    //
    typedef struct tagMDFIELDDEF
    {
        DWORD dwMDIdentifier;
        DWORD dwMDAttributes;
        DWORD dwMDUserType;
        DWORD dwMDDataType;
        UINT  uStringID;
    } MDFIELDDEF;

    static const MDFIELDDEF s_rgMetaTable[];

//
// CODEWORK: Ideally, these should be protected, but are used
//           by idlg.
//
public:
    static BOOL GetMDFieldDef(
        DWORD dwID,
        DWORD & dwMDIdentifier,
        DWORD & dwMDAttributes,
        DWORD & dwMDUserType,
        DWORD & dwMDDataType
        );

    //
    // Map metabase ID value to table index
    //
    static int MapMDIDToTableIndex(DWORD dwID);

//
// Allow limited access to the table
//
public:
    static BOOL IsPropertyInheritable(DWORD dwID);
    static BOOL GetPropertyDescription(DWORD dwID, CString & strName);

protected:
    BOOL    m_fAllowRootOperations;
    BOOL    m_fOwnKey;
    DWORD   m_cbInitialBufferSize;    
    DWORD   m_dwFlags;
    HRESULT m_hrKey;
    CString m_strMetaPath;
    METADATA_HANDLE m_hKey;
    METADATA_HANDLE m_hBase;
};



class _EXPORT CWamInterface : public CIISInterface
/*++

Class description:

    WAM interface class

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

Public Interface:

    SupportsPooledProc  : Check to see if pooled out of proc is supported.

--*/
{
//
// App Protection States:
//
public:
    enum
    {
        //
        // Note: order must match MD_APP_ISOLATED values
        //
        APP_INPROC,
        APP_OUTOFPROC,
        APP_POOLEDPROC,
    };

//
// Constructor/Destructor
//
public:
    //
    // Destructor destroys the interface
    //
    virtual ~CWamInterface();

protected:
    //
    // Fully defined constructor that creates the interface.
    // Use NULL to create the interface on the local computer
    //
    CWamInterface(
        IN CComAuthInfo * pServer
        );

    //
    // Construct from existing interface.  
    //
    CWamInterface(
        IN CWamInterface * pInterface
        );

//
// Access
//
public:
    BOOL SupportsPooledProc() const { return m_fSupportsPooledProc; }

protected:
    virtual HRESULT ApplyProxyBlanket();

    //
    // Create a wam object in this server. This function initializes the
    // object with DCOM.
    //
    HRESULT Create();

    //
    // Make sure the interface has been created
    //
    BOOL HasInterface() const { return m_pInterface != NULL; }

//
// IWAM Interface
//
protected:
    HRESULT AppCreate( 
        IN LPCTSTR szMDPath,
        IN DWORD dwAppProtection
        );
    
    HRESULT AppDelete( 
        IN LPCTSTR szMDPath,
        IN BOOL fRecursive
        );
    
    HRESULT AppUnLoad( 
        IN LPCTSTR szMDPath,
        IN BOOL fRecursive
        );
    
    HRESULT AppGetStatus( 
        IN LPCTSTR szMDPath,
        OUT DWORD * pdwAppStatus
        );
    
    HRESULT AppDeleteRecoverable( 
        IN LPCTSTR szMDPath,
        IN BOOL fRecursive
        );
    
    HRESULT AppRecover( 
        IN LPCTSTR szMDPath,
        IN BOOL fRecursive
        );

protected:
    IWamAdmin * m_pInterface; 

private:
    BOOL m_fSupportsPooledProc;
};



class _EXPORT CMetaBack : public CMetaInterface, public CWamInterface
/*++

Class Description:

    Metabase backup/restore class

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

Public Interface:

    Reset               : Enum first existing backup
    Next                : Enum next existing backup
    Backup              : Create new backup
    Delete              : Delete existing backup
    Restore             : Restore from existing backup

--*/
{
public:
    //
    // Construct and create the interfaces.  Use NULL to create
    // on the local computer.
    //
    CMetaBack(
        IN CComAuthInfo * pServer
        );

//
// Virtual Interface
//
public:
    virtual BOOL Succeeded() const;
    virtual HRESULT QueryResult() const;

//
// Interface
//
public:
    //
    // Reset counter
    //
    void Reset() { m_dwIndex = 0L; }

    HRESULT Next(
        OUT DWORD * pdwVersion,
        OUT LPTSTR lpszLocation,
        OUT FILETIME * pftBackupTime
        );

    HRESULT Backup(
        IN LPCTSTR lpszLocation
        );

    HRESULT Delete(
        IN LPCTSTR lpszLocation,
        IN DWORD dwVersion
        );

    HRESULT Restore(
        IN LPCTSTR lpszLocation,
        IN DWORD dwVersion
        );

protected:
    virtual HRESULT ApplyProxyBlanket();

protected:
    static const LPCTSTR s_szMasterAppRoot;

private:
    DWORD m_dwIndex;
};



class _EXPORT CMetaEnumerator : public CMetaKey
/*++

Class Description:

    Metabase key enumerator

Public Interface:

    CMetaEnumerator     : Constructor
    
    Reset               : Reset the enumerator
    Next                : Get next key

--*/
{
public:
    //
    // Constructor creates a new interface and opens a key
    //
    CMetaEnumerator(
        IN CComAuthInfo * pServer,
        IN LPCTSTR lpszMDPath     = NULL,
        IN METADATA_HANDLE hkBase = METADATA_MASTER_ROOT_HANDLE
        );

    //
    // Constructor which uses an existing interface and opens
    // a new key
    //
    CMetaEnumerator(
        IN CMetaInterface * pInterface,
        IN LPCTSTR lpszMDPath     = NULL,
        IN METADATA_HANDLE hkBase = METADATA_MASTER_ROOT_HANDLE
        );

    //
    // Constructor which uses an open key
    //
    CMetaEnumerator(
        IN BOOL fOwnKey,
        IN CMetaKey * pKey
        );

//
// Interface:
//
public:
    //
    // Reset counter
    //
    void Reset(DWORD counter = 0L) { m_dwIndex = counter; }
    DWORD GetIndex() { return m_dwIndex; }
    // Index stack operators, used for recursive enums
    void Push()
    {
       m_stack.push(m_dwIndex);
    }
    void Pop()
    {
       ASSERT(!m_stack.empty());
       m_dwIndex = m_stack.top();
       m_stack.pop();
    }

    //
    // Get next key as string.
    //
    HRESULT Next(
        OUT CString & strKey,
        IN  LPCTSTR lpszMDPath = NULL
        );

    //
    // Get next key as a DWORD (numeric keys only)
    //
    HRESULT Next(
        OUT DWORD & dwKey,
        OUT CString & strKey,
        IN  LPCTSTR lpszMDPath = NULL
        );

private:
    DWORD m_dwIndex;
    std::stack<DWORD> m_stack;
};



class _EXPORT CIISApplication : public CWamInterface, public CMetaKey
/*++

Class Description:

    IIS Application class

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

Public Interface:

    RefreshState        : Refresh application state
    QueryAppState       : Return current application state
    IsEnabledApplication: Return TRUE if appplication is enabled. 
    Create              : Create app
    Delete              : Delete app
    Unload              : Unload app
    DeleteRecoverable   : Delete w. recovery allowed
    Recover             : Recover
    WriteFriendlyName   : Write friendly name to metabase

--*/
{
//
// Constructor/Destructor
//
public:
    CIISApplication(
        IN CComAuthInfo * pServer,
        IN LPCTSTR lpszMetapath
        );

//
// Virtual Interface:
//
public:
    virtual BOOL Succeeded() const;
    virtual HRESULT QueryResult() const;

//
// Interface
//
public:
    DWORD   QueryAppState() const { return m_dwAppState; }
    LPCTSTR QueryWamPath() const { return m_strWamPath; }
    BOOL    IsEnabledApplication() const;
    HRESULT RefreshAppState();
    HRESULT Create(LPCTSTR lpszName, DWORD dwAppProtection);
    HRESULT Delete(BOOL fRecursive = FALSE);
    HRESULT Unload(BOOL fRecursive = FALSE);
    HRESULT DeleteRecoverable(BOOL fRecursive = FALSE);
    HRESULT Recover(BOOL fRecursive = FALSE);
    HRESULT WriteFriendlyName(LPCTSTR lpszName);

public:
    BOOL IsInproc() const { return m_dwProcessProtection == APP_INPROC; }
    BOOL IsOutOfProc() const { return m_dwProcessProtection == APP_OUTOFPROC; }
    BOOL IsPooledProc() const { return m_dwProcessProtection == APP_POOLEDPROC; }

public:
    DWORD   m_dwProcessProtection;
    CString m_strFriendlyName;
    CString m_strAppRoot;

protected:
    void CommonConstruct();

private:
    DWORD   m_dwAppState;
    CString m_strWamPath;
    HRESULT m_hrApp;
};



class _EXPORT CIISSvcControl : public CIISInterface
/*++

Class description:

    IIS Service control

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

--*/
{
//
// Constructor/Destructor
//
public:
    //
    // Fully defined constructor that creates the interface.
    // Use NULL to create the interface on the local computer
    //
    CIISSvcControl(
        IN CComAuthInfo * pServer
        );

    //
    // Construct from existing interface.  
    //
    CIISSvcControl(
        IN CIISSvcControl * pInterface
        );

    //
    // Destructor destroys the interface
    //
    virtual ~CIISSvcControl();

protected:
    //
    // Create an object in this server. This function initializes the
    // object with DCOM.
    //
    HRESULT Create();

    //
    // Make sure the interface has been created
    //
    BOOL HasInterface() const { return m_pInterface != NULL; }

//
// Interface
//
public:
    //
    // Stop services
    //
    HRESULT Stop(
        IN DWORD dwTimeoutMsecs,
        IN BOOL fForce
        );

    //
    // Start services
    //
    HRESULT Start(
        IN DWORD dwTimeoutMsecs
        );

    //
    // Reboot
    //
    HRESULT Reboot(
        IN DWORD dwTimeouMsecs,
        IN BOOL fForceAppsClosed
        );

    //
    // Status
    //
    HRESULT Status(
        IN  DWORD dwBufferSize,
        OUT LPBYTE pbBuffer,
        OUT DWORD * MDRequiredBufferSize,
        OUT DWORD * pdwNumServices
        );

    //
    // Kill
    //
    HRESULT Kill();

protected:
    virtual HRESULT ApplyProxyBlanket();

protected:
    IIisServiceControl * m_pInterface; 
};


#ifdef KEVLAR
class _EXPORT CWebCluster : public CIISInterface
/*++

Class description:

    IWebCluster warpper

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

--*/
{
//
// Constructor/Destructor
//
public:
    //
    // Fully defined constructor that creates the interface.
    // Use NULL to create the interface on the local computer
    //
    CWebCluster(
        CComAuthInfo * pServer
        );

    //
    // Destructor destroys the interface
    //
    virtual ~CWebCluster();

protected:
    //
    // Create an object in this server. This function initializes the
    // object with DCOM.
    //
    HRESULT Create();

    //
    // Make sure the interface has been created
    //
    BOOL HasInterface() const { return m_pInterface != NULL; }

//
// Interface
//
public:
#if (0) // dantra: 8/17/99 legacy code, not supported by new IWebCluster interfaces
    HRESULT GetParameter( 
        LONG lParamId,
        BSTR bstrParamInfo,
        VARIANT * lpvarParam
        );
    
    HRESULT SetParameter( 
        LONG lParam,
        BSTR bstrParamInfo,
        VARIANT * lpvarResults
        );
#endif
protected:
    virtual HRESULT ApplyProxyBlanket();

protected:
    IWebCluster * m_pInterface; 
};
#endif


//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline void CComAuthInfo::StorePassword(LPCOLESTR lpszPassword)
{
    m_bstrPassword = lpszPassword;
}

inline /* virtual */ HRESULT CIISInterface::ChangeProxyBlanket(
    IN LPCOLESTR lpszUserName, 
    IN LPCOLESTR lpszPassword
    )
{
    m_auth.SetImpersonation(lpszUserName, lpszPassword);
    return ApplyProxyBlanket();
}

inline /*static */ LPCTSTR CMetabasePath::GetMachinePath(
    IN  LPCTSTR lpszMDPath,
    OUT CString & strNewPath,
    OUT CString * pstrRemainder
    )
{
    return TruncatePath(iMachine, lpszMDPath, strNewPath, pstrRemainder);
}

inline /* static */ LPCTSTR CMetabasePath::GetServicePath(
    IN  LPCTSTR lpszMDPath,
    OUT CString & strNewPath,
    OUT CString * pstrRemainder
    )
{
    return TruncatePath(iService, lpszMDPath, strNewPath, pstrRemainder);
}

inline /* static */ LPCTSTR CMetabasePath::GetInstancePath(
    IN  LPCTSTR lpszMDPath,
    OUT CString & strNewPath,
    OUT CString * pstrRemainder
    )
{
    return TruncatePath(iInstance, lpszMDPath, strNewPath, pstrRemainder);
}

inline /* static */ LPCTSTR CMetabasePath::GetRootPath(
    IN  LPCTSTR lpszMDPath,
    OUT CString & strNewPath,
    OUT CString * pstrRemainder
    )
{
    return TruncatePath(iRootDirectory, lpszMDPath, strNewPath, pstrRemainder);
}

inline /* virtual */ HRESULT CMetaInterface::ApplyProxyBlanket()
{
    return m_auth.ApplyProxyBlanket(m_pInterface);
}

inline HRESULT CMetaInterface::OpenKey(
    IN  METADATA_HANDLE hkBase,
    IN  LPCTSTR lpszMDPath,
    IN  DWORD dwFlags,
    OUT METADATA_HANDLE * phMDNewHandle
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->OpenKey(
        hkBase,
        lpszMDPath,
        dwFlags,
        m_iTimeOutValue,
        phMDNewHandle
        );
}

inline HRESULT CMetaInterface::CloseKey(
    IN METADATA_HANDLE hKey
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->CloseKey(hKey);
}

inline HRESULT CMetaInterface::SetLastChangeTime( 
    IN METADATA_HANDLE hMDHandle,
    IN LPCTSTR pszMDPath,
    IN FILETIME * pftMDLastChangeTime,
    IN BOOL bLocalTime
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->SetLastChangeTime(
        hMDHandle,
        pszMDPath,
        pftMDLastChangeTime,
        bLocalTime
        );
}
        
inline HRESULT CMetaInterface::GetLastChangeTime( 
    IN  METADATA_HANDLE hMDHandle,
    IN  LPCTSTR lpszMDPath,
    OUT FILETIME * pftMDLastChangeTime,
    IN  BOOL bLocalTime
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->GetLastChangeTime(
        hMDHandle,
        lpszMDPath,
        pftMDLastChangeTime,
        bLocalTime
        );
}

inline HRESULT CMetaInterface::AddKey( 
    IN METADATA_HANDLE hKey,
    IN LPCTSTR lpszMDPath
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->AddKey(hKey, lpszMDPath);
}

inline HRESULT CMetaInterface::DeleteKey(
    IN METADATA_HANDLE hKey,
    IN LPCTSTR lpszMDPath
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->DeleteKey(hKey, lpszMDPath);
}

inline HRESULT CMetaInterface::DeleteChildKeys(
    IN METADATA_HANDLE hKey,
    IN LPCTSTR lpszMDPath
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->DeleteChildKeys(hKey, lpszMDPath);
}

inline HRESULT CMetaInterface::EnumKeys(
    IN  METADATA_HANDLE hKey,
    IN  LPCTSTR lpszMDPath,
    OUT LPTSTR lpszMDName,
    IN  DWORD dwIndex
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->EnumKeys(hKey, lpszMDPath, lpszMDName, dwIndex);
}        

inline HRESULT CMetaInterface::CopyKey(
    IN METADATA_HANDLE hSourceKey,
    IN LPCTSTR lpszMDSourcePath,
    IN METADATA_HANDLE hDestKey,
    IN LPCTSTR lpszMDDestPath,
    IN BOOL fOverwrite,
    IN BOOL fCopy
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->CopyKey(
        hSourceKey,
        lpszMDSourcePath,
        hDestKey,
        lpszMDDestPath,
        fOverwrite,
        fCopy
        );        
}

inline HRESULT CMetaInterface::RenameKey(
    IN METADATA_HANDLE hKey,
    IN LPCTSTR lpszMDPath,
    IN LPCTSTR lpszNewName
    )
{   
    ASSERT_PTR(m_pInterface);     
    return m_pInterface->RenameKey(hKey, lpszMDPath, lpszNewName);
}

inline HRESULT CMetaInterface::GetData(
    IN  METADATA_HANDLE hKey,
    IN  LPCTSTR lpszMDPath,
    OUT METADATA_RECORD * pmdRecord,
    OUT DWORD * pdwRequiredDataLen
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->GetData(
        hKey,
        lpszMDPath,
        pmdRecord,
        pdwRequiredDataLen
        );
}

inline HRESULT CMetaInterface::SetData(
    IN METADATA_HANDLE hKey,
    IN LPCTSTR lpszMDPath,
    IN METADATA_RECORD * pmdRecord
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->SetData(
        hKey,
        lpszMDPath,
        pmdRecord
        );
}

inline HRESULT CMetaInterface::DeleteData(
    IN METADATA_HANDLE hKey,
    IN LPCTSTR lpszMDPath,
    IN DWORD dwMDIdentifier,
    IN DWORD dwMDDataType
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->DeleteData(
        hKey,
        lpszMDPath,
        dwMDIdentifier,
        dwMDDataType
        );
}

inline HRESULT CMetaInterface::EnumData(
    IN  METADATA_HANDLE hKey,
    IN  LPCTSTR lpszMDPath,
    OUT METADATA_RECORD * pmdRecord,
    IN  DWORD dwIndex,
    OUT DWORD * pdwRequiredDataLen
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->EnumData(
        hKey,
        lpszMDPath,
        pmdRecord,
        dwIndex,
        pdwRequiredDataLen
        );
}

inline HRESULT CMetaInterface::GetAllData(
    IN  METADATA_HANDLE hKey,
    IN  LPCTSTR lpszMDPath,
    IN  DWORD dwMDAttributes,
    IN  DWORD dwMDUserType,
    IN  DWORD dwMDDataType,
    OUT DWORD * pdwMDNumDataEntries,
    OUT DWORD * pdwMDDataSetNumber,
    IN  DWORD dwMDBufferSize,
    OUT LPBYTE pbMDBuffer,
    OUT DWORD * pdwRequiredBufferSize
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->GetAllData(
        hKey,
        lpszMDPath,
        dwMDAttributes,
        dwMDUserType,
        dwMDDataType,
        pdwMDNumDataEntries,
        pdwMDDataSetNumber,
        dwMDBufferSize,
        pbMDBuffer,
        pdwRequiredBufferSize
        );
}    

inline HRESULT CMetaInterface::DeleteAllData( 
    IN METADATA_HANDLE hKey,
    IN LPCTSTR lpszMDPath,
    IN DWORD dwMDUserType,
    IN DWORD dwMDDataType
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->DeleteAllData(
        hKey, 
        lpszMDPath, 
        dwMDUserType, 
        dwMDDataType
        );
}

inline HRESULT CMetaInterface::CopyData( 
    IN METADATA_HANDLE hMDSourceKey,
    IN LPCTSTR lpszMDSourcePath,
    IN METADATA_HANDLE hMDDestKey,
    IN LPCTSTR lpszMDDestPath,
    IN DWORD dwMDAttributes,
    IN DWORD dwMDUserType,
    IN DWORD dwMDDataType,
    IN BOOL fCopy
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->CopyData(
        hMDSourceKey,
        lpszMDSourcePath,
        hMDDestKey,
        lpszMDDestPath,
        dwMDAttributes,
        dwMDUserType,
        dwMDDataType,
        fCopy
        );
}

inline HRESULT CMetaInterface::GetDataPaths( 
    IN  METADATA_HANDLE hKey,
    IN  LPCTSTR lpszMDPath,
    IN  DWORD dwMDIdentifier,
    IN  DWORD dwMDDataType,
    IN  DWORD dwMDBufferSize,
    OUT LPTSTR lpszBuffer,
    OUT DWORD * pdwMDRequiredBufferSize
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->GetDataPaths(
        hKey,
        lpszMDPath,
        dwMDIdentifier,
        dwMDDataType,
        dwMDBufferSize,
        lpszBuffer,
        pdwMDRequiredBufferSize
        );
}

inline HRESULT CMetaInterface::Backup( 
    IN LPCTSTR lpszBackupLocation,
    IN DWORD dwMDVersion,
    IN DWORD dwMDFlags
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->Backup(lpszBackupLocation, dwMDVersion, dwMDFlags);
}

inline HRESULT CMetaInterface::Restore(    
    IN LPCTSTR lpszBackupLocation,
    IN DWORD dwMDVersion,
    IN DWORD dwMDFlags
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->Restore(lpszBackupLocation, dwMDVersion, dwMDFlags);
}

inline HRESULT CMetaInterface::EnumBackups(
    OUT LPTSTR lpszBackupLocation,
    OUT DWORD * pdwMDVersion,
    OUT FILETIME * pftMDBackupTime,
    IN  DWORD dwIndex
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->EnumBackups(
        lpszBackupLocation,
        pdwMDVersion,
        pftMDBackupTime,
        dwIndex
        );    
}

inline HRESULT CMetaInterface::DeleteBackup(
    IN LPCTSTR lpszBackupLocation,
    IN DWORD dwMDVersion
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->DeleteBackup(lpszBackupLocation, dwMDVersion);
}        

inline HRESULT CMetaInterface::SaveData()
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->SaveData();
}

inline HRESULT CMetaKey::AddKey(
    IN LPCTSTR lpszMDPath
    )
{
    return CMetaInterface::AddKey(m_hKey, lpszMDPath);    
}

inline HRESULT CMetaKey::DeleteKey(
    IN LPCTSTR lpszMDPath
    )
{
    return CMetaInterface::DeleteKey(m_hKey, lpszMDPath);    
}

inline HRESULT CMetaKey::RenameKey(
    IN LPCTSTR lpszMDPath,
    IN LPCTSTR lpszNewName
    )
{
    return CMetaInterface::RenameKey(m_hKey, lpszMDPath, lpszNewName);    
}

inline HRESULT CMetaKey::ReOpen()
{
    return Open(m_dwFlags, m_strMetaPath, m_hBase);
}

inline HRESULT CMetaKey::ReOpen(DWORD dwFlags)
{
    return Open(dwFlags, m_strMetaPath, m_hBase);
}

inline BOOL CMetaKey::IsHomeDirectoryPath() const
{ 
    return CMetabasePath::IsHomeDirectoryPath(m_strMetaPath); 
}

inline HRESULT CMetaKey::QueryValue(
    IN  DWORD dwID, 
    OUT BOOL & fValue,
    IN  BOOL * pfInheritanceOverride,
    IN  LPCTSTR lpszMDPath,
    OUT DWORD * pdwAttributes        
    )
{
    ASSERT(sizeof(DWORD) == sizeof(BOOL));
    return CMetaKey::QueryValue(
        dwID, 
        (DWORD &)fValue, 
        pfInheritanceOverride, 
        lpszMDPath,
        pdwAttributes
        );
}

inline HRESULT CMetaKey::SetValue(
    IN DWORD dwID,
    IN DWORD dwValue,
    IN BOOL * pfInheritanceOverride,    OPTIONAL
    IN LPCTSTR lpszMDPath               OPTIONAL
    )
{
    return SetPropertyValue(
        dwID, 
        sizeof(dwValue), 
        &dwValue, 
        pfInheritanceOverride,
        lpszMDPath
        );
}

inline HRESULT CMetaKey::SetValue(
    IN DWORD dwID,
    IN BOOL fValue,
    IN BOOL * pfInheritanceOverride,
    IN LPCTSTR lpszMDPath
    )
{
    ASSERT(sizeof(DWORD) == sizeof(BOOL));
    return CMetaKey::SetValue(
        dwID,
        (DWORD)fValue,
        pfInheritanceOverride,
        lpszMDPath
        );
}

inline HRESULT CMetaKey::SetValue(
    IN DWORD dwID,
    IN CString & strValue,
    IN BOOL * pfInheritanceOverride,    OPTIONAL
    IN LPCTSTR lpszMDPath               OPTIONAL
    )
{
    return SetPropertyValue(
        dwID,
        (strValue.GetLength() + 1) * sizeof(TCHAR),
        (void *)(LPCTSTR)strValue,
        pfInheritanceOverride,
        lpszMDPath
        );
}

inline HRESULT CWamInterface::AppDelete( 
    IN LPCTSTR szMDPath,
    IN BOOL fRecursive
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->AppDelete(szMDPath, fRecursive);
}

inline HRESULT CWamInterface::AppUnLoad( 
    IN LPCTSTR szMDPath,
    IN BOOL fRecursive
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->AppUnLoad(szMDPath, fRecursive);
}

inline HRESULT CWamInterface::AppGetStatus( 
    IN  LPCTSTR szMDPath,
    OUT DWORD * pdwAppStatus
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->AppGetStatus(szMDPath, pdwAppStatus);
}

inline HRESULT CWamInterface::AppDeleteRecoverable( 
    IN LPCTSTR szMDPath,
    IN BOOL fRecursive
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->AppDeleteRecoverable(szMDPath, fRecursive);
}

inline HRESULT CWamInterface::AppRecover( 
    IN LPCTSTR szMDPath,
    IN BOOL fRecursive
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->AppRecover(szMDPath, fRecursive);
}

inline /* virtual */ HRESULT CWamInterface::ApplyProxyBlanket()
{
    return m_auth.ApplyProxyBlanket(m_pInterface);
}

inline /* virtual */ HRESULT CMetaBack::ApplyProxyBlanket()
{
    HRESULT hr = CMetaInterface::ApplyProxyBlanket();
    return SUCCEEDED(hr) ? CWamInterface::ApplyProxyBlanket() : hr;
}

inline HRESULT CMetaBack::Next(
    OUT DWORD * pdwVersion,
    OUT LPTSTR lpszLocation,
    OUT FILETIME * pftBackupTime
    )
{
    return EnumBackups(
        lpszLocation,
        pdwVersion,
        pftBackupTime,
        m_dwIndex++
        );
}

inline HRESULT CMetaBack::Backup(
    IN LPCTSTR lpszLocation
    )
{
    return CMetaInterface::Backup(
        lpszLocation, 
        MD_BACKUP_NEXT_VERSION, 
        MD_BACKUP_SAVE_FIRST
        );
}

inline HRESULT CMetaBack::Delete(
    IN LPCTSTR lpszLocation,
    IN DWORD dwVersion
    )
{
    return DeleteBackup(lpszLocation, dwVersion);
}

inline BOOL 
CIISApplication::IsEnabledApplication() const
{
    return m_dwAppState == APPSTATUS_STOPPED 
        || m_dwAppState == APPSTATUS_RUNNING;
}

inline HRESULT CIISApplication::Delete(
    IN BOOL fRecursive
    )
{
    ASSERT(!m_strWamPath.IsEmpty());
    return AppDelete(m_strWamPath, fRecursive);
}

inline HRESULT CIISApplication::Unload(
    IN BOOL fRecursive
    )
{
    ASSERT(!m_strWamPath.IsEmpty());
    return AppUnLoad(m_strWamPath, fRecursive);
}

inline HRESULT CIISApplication::DeleteRecoverable(
    IN BOOL fRecursive
    )
{
    ASSERT(!m_strWamPath.IsEmpty());
    return AppDeleteRecoverable(m_strWamPath, fRecursive);
}

inline HRESULT CIISApplication::Recover(
    IN BOOL fRecursive
    )
{
    ASSERT(!m_strWamPath.IsEmpty());
    return AppRecover(m_strWamPath, fRecursive);
}

inline HRESULT CIISSvcControl::Stop(
    IN DWORD dwTimeoutMsecs,
    IN BOOL fForce
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->Stop(dwTimeoutMsecs, (DWORD)fForce);
}

inline HRESULT CIISSvcControl::Start(
    IN DWORD dwTimeoutMsecs
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->Start(dwTimeoutMsecs);
}

inline HRESULT CIISSvcControl::Reboot(
    IN DWORD dwTimeouMsecs,
    IN BOOL fForceAppsClosed
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->Reboot(dwTimeouMsecs, (DWORD)fForceAppsClosed);
}

inline HRESULT CIISSvcControl::Status(
    IN  DWORD dwBufferSize,
    OUT LPBYTE pbBuffer,
    OUT DWORD * MDRequiredBufferSize,
    OUT DWORD * pdwNumServices
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->Status(
        dwBufferSize, 
        pbBuffer,
        MDRequiredBufferSize,
        pdwNumServices
        );
}

inline HRESULT CIISSvcControl::Kill()
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->Kill();
}

inline /* virtual */ HRESULT CIISSvcControl::ApplyProxyBlanket()
{
    return m_auth.ApplyProxyBlanket(m_pInterface);
}

#ifdef KEVLAR
inline HRESULT CWebCluster::Create()
{
    return CIISInterface::Create(
        1,
        &IID_IWebCluster, 
        &CLSID_WebCluster, 
        NULL, 
        (IUnknown **)&m_pInterface
        );
}

inline /* virtual */ HRESULT CWebCluster::ApplyProxyBlanket()
{
    return m_auth.ApplyProxyBlanket(m_pInterface);
}
#if (0)  // dantra: 8/17/99 - legacy
inline HRESULT CWebCluster::GetParameter( 
    LONG lParamId,
    BSTR bstrParamInfo,
    VARIANT * lpvarParam
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->GetParameter(lParamId, bstrParamInfo, lpvarParam);
}
    
inline HRESULT CWebCluster::SetParameter( 
    LONG lParam,
    BSTR bstrParamInfo,
    VARIANT * lpvarResults
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->SetParameter(lParam, bstrParamInfo, lpvarResults);
}

#endif // 0
#endif // KEVLAR

#endif // _MDKEYS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(_STDAFX_H)
#define _STDAFX_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#define _WTL_NO_CSTRING

#include <atlcom.h>
#include <atlwin.h>
#include <atlapp.h>
#include <atlmisc.h>
#include <atlctrls.h>
#include <atlddx.h>
#include <atlcrack.h>

#include <map>
#include <list>
#include <stack>
#include <memory>
#include <shlwapi.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(_STDAFX_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\inheritancedlg.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        idlg.cpp

   Abstract:

        Inheritance Dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager (cluster edition)

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "inheritancedlg.h"



//
// Inheritance dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

CInheritanceDlg::CInheritanceDlg(
    DWORD dwMetaID,
    BOOL fWrite,
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpstrMetaRoot,
    CStringListEx& strlMetaChildNodes,
    LPCTSTR lpstrPropertyName,
    HWND hwndParent
    )
/*++

Routine Description:

    Inheritance dialog constructor.  This constructor assumes GetDataPaths()
    has already been called.

Arguments:

    DWORD dwMetaID                      : Meta ID
    BOOL fWrite                         : TRUE from write, FALSE from delete
    CIISServer * pAuthInfo              : Auth info object or NULL
    LPCTSTR lpstrMetaRoot               : Meta root
    CStringList & strlMetaChildNodes    : List of child nodes from GetDataPaths
    LPCTSTR lpstrPropertyName           : Optional text string for the property
    CWnd * pParent                      : Optional parent window

Return Value:

    None

--*/
    : m_fWrite(fWrite),
      m_fEmpty(TRUE),
      m_fUseTable(TRUE),
      m_strMetaRoot(lpstrMetaRoot),
      m_strPropertyName(lpstrPropertyName ? lpstrPropertyName : _T("")),
      m_mk(pAuthInfo)
//      CDialog(CInheritanceDlg::IDD, hwndParent)
{
    m_strlMetaChildNodes = strlMetaChildNodes;

    VERIFY(CMetaKey::GetMDFieldDef(
        dwMetaID, 
        m_dwMDIdentifier, 
        m_dwMDAttributes, 
        m_dwMDUserType,
        m_dwMDDataType
        ));

    Initialize();
}



CInheritanceDlg::CInheritanceDlg(
    DWORD dwMetaID,
    BOOL fWrite,
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpstrMetaRoot,
    LPCTSTR lpstrPropertyName,
    HWND hwndParent
    )
/*++

Routine Description:

    Inheritance dialog constructor.  This constructor will call GetDataPaths().

Arguments:

    DWORD dwMetaID                      : Meta ID
    BOOL fWrite                         : TRUE from write, FALSE from delete
    CComAuthInfo * pAuthInfo            : Auth info or NULL
    LPCTSTR lpstrMetaRoot               : Meta root
    LPCTSTR lpstrPropertyName           : Optional text string for the property
    CWnd * pParent                      : Optional parent window

Return Value:

    None

--*/
    : m_fWrite(fWrite),
      m_fEmpty(TRUE),
      m_fUseTable(TRUE),
      m_strMetaRoot(lpstrMetaRoot),
      m_strlMetaChildNodes(),
      m_strPropertyName(lpstrPropertyName ? lpstrPropertyName : _T("")),
      m_mk(pAuthInfo)
//      CDialog(CInheritanceDlg::IDD, pParent)
{
    //
    // Specify the resources to use
    //
//    HINSTANCE hOldRes = AfxGetResourceHandle();
//    AfxSetResourceHandle(hDLLInstance);

    VERIFY(CMetaKey::GetMDFieldDef(
        dwMetaID, 
        m_dwMDIdentifier, 
        m_dwMDAttributes, 
        m_dwMDUserType,
        m_dwMDDataType
        ));

    //
    // Need to do our own GetDataPaths()
    //
    CError err(GetDataPaths());

    if (!err.MessageBoxOnFailure())
    {
        Initialize();
    }

    //
    // Restore the resources
    //
//    AfxSetResourceHandle(hOldRes);
}



CInheritanceDlg::CInheritanceDlg(
    BOOL    fTryToFindInTable,
    DWORD   dwMDIdentifier,
    DWORD   dwMDAttributes,
    DWORD   dwMDUserType,
    DWORD   dwMDDataType,
    LPCTSTR lpstrPropertyName,
    BOOL    fWrite,
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpstrMetaRoot,
    HWND hwndParent
    )
/*++

Routine Description:

    Inheritance dialog constructor.  This constructor will call GetDataPaths(),
    and will use the specified parameters if the property ID does not exist
    in the property table

Arguments:

    BOOL    fTryToFindInTable           : If TRUE, first look in table
    DWORD   dwMDIdentifier              : Metadata identifier
    DWORD   dwMDAttributes              : Metadata attributes
    DWORD   dwMDUserType                : Metadata user type
    DWORD   dwMDDataType                : Metadata data type
    LPCTSTR lpstrPropertyName           : Text string for the property
    BOOL    fWrite                      : TRUE from write, FALSE from delete
    CComAuthInfo * pAuthInfo            : Authentication info or NULL.
    LPCTSTR lpstrMetaRoot               : Meta root
    CWnd *  pParent                     : Optional parent window

Return Value:

    None

--*/
    : m_fWrite(fWrite),
      m_fEmpty(TRUE),
      m_fUseTable(FALSE),
      m_strMetaRoot(lpstrMetaRoot),
      m_strlMetaChildNodes(),
      m_mk(pAuthInfo)
//      CDialog(CInheritanceDlg::IDD, pParent)
{
    //
    // Specify the resources to use
    //
//    HINSTANCE hOldRes = AfxGetResourceHandle();
//    AfxSetResourceHandle(hDLLInstance);

    if (fTryToFindInTable && !CMetaKey::GetMDFieldDef(
        dwMDIdentifier, 
        m_dwMDIdentifier, 
        m_dwMDAttributes, 
        m_dwMDUserType,
        m_dwMDDataType
        ))
    {
        //
        // Did not exist in the table, use specified parameters
        //
        m_dwMDIdentifier  = dwMDIdentifier;
        m_dwMDAttributes  = dwMDAttributes;
        m_dwMDUserType    = dwMDUserType;
        m_dwMDDataType    = dwMDDataType;
        m_strPropertyName = lpstrPropertyName;
    }


    //
    // Need to do our own GetDataPaths()
    //
    CError err(GetDataPaths());

    if (!err.MessageBoxOnFailure())
    {
        Initialize();
    }

    //
    // Restore the resources
    //
//    AfxSetResourceHandle(hOldRes);
}



HRESULT
CInheritanceDlg::GetDataPaths()
/*++

Routine Description:

    GetDataPaths()

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    //ASSERT(!m_strServer.IsEmpty());

    CError err(m_mk.QueryResult());

    if (err.Succeeded())
    {
        err = m_mk.GetDataPaths( 
            m_strlMetaChildNodes,
            m_dwMDIdentifier,
            m_dwMDDataType,
            m_strMetaRoot
            );
    }

    return err;
}



void
CInheritanceDlg::Initialize()
/*++

Routine Description:

    Initialize data members.  Set the m_fEmpty flag to determine if
    it is necessary to proceed.

Arguments:

    None

Return Value:

    None

--*/
{
    CMetabasePath::CleanMetaPath(m_strMetaRoot);

    if (m_fUseTable && !CMetaKey::IsPropertyInheritable(m_dwMDIdentifier))
    {
        //
        // No point in displaying non-inheritable properties
        //
        return;
    }

    switch(m_dwMDIdentifier)
    {
    //
    // Ignore these properties, even though they are inheritable
    //
    case MD_VR_PATH:
    case MD_APP_ISOLATED:
    case MD_APP_FRIENDLY_NAME:
        return;
    }

    //
    // Check to see if the current metabase path contains an instance
    //
    CString strTmp;
    m_fHasInstanceInMaster = FriendlyInstance(m_strMetaRoot, strTmp);

    //
    // If property name was not specified in the constructor, load default
    // one from table.
    //
    if (m_strPropertyName.IsEmpty())
    {
        ASSERT(m_fUseTable);

        //
        // Specify the resources to use
        //
//        HINSTANCE hOldRes = AfxGetResourceHandle();
//        AfxSetResourceHandle(hDLLInstance);

        VERIFY(CMetaKey::GetPropertyDescription(
            m_dwMDIdentifier, 
            m_strPropertyName
            ));

//        AfxSetResourceHandle(hOldRes);
    }

    //
    // Go through the list of metapaths, and clean them
    // up.
    //
    CStringListEx::iterator it = m_strlMetaChildNodes.begin();
    while (it != m_strlMetaChildNodes.end())
    {
        CString& strMetaPath = (*it++);
        CMetabasePath::CleanMetaPath(strMetaPath);
    }

    //
    // If the special info key (lm/service/info) is in the list, remove it.
    // We only need to this if the key that is getting the
    // change (m_strMetaRoot) is the service master property (lm/service).
    // If it is anything else, then the special "info" key cannot be below
    // it so we don't need to check. Thus the first test is to see if there
    // is only one "/" character. If there is only one, then we know it is
    // the service and we can go ahead and do the test.  In some ways,
    // mfc is a pain, so we limited to the CString methods to do this
    // copy the root into the temp string.
    //
    int iSlash = m_strMetaRoot.ReverseFind(SZ_MBN_SEP_CHAR);

    if (iSlash >= 0)
    {
        strTmp = m_strMetaRoot.Left(iSlash);

        //
        // Now make sure that there aren't any more slashes
        //
        if (strTmp.Find(SZ_MBN_SEP_CHAR) == -1)
        {
            //
            // Now build the path to the special info key by adding it
            // to the meta root
            //
            strTmp = m_strMetaRoot + SZ_MBN_SEP_CHAR + IIS_MD_SVC_INFO_PATH;

            TRACE("Removing any descendants of %s\n", strTmp);

            //
            // Search the list for the info key and remove it if we find it
            //
            it = m_strlMetaChildNodes.begin();
            while (it != m_strlMetaChildNodes.end())
            {
                CString & strMetaPath = (*it);
                if (strTmp.CompareNoCase(strMetaPath.Left(strTmp.GetLength())) == 0)
                {
                    TRACEEOLID("Removing service/info metapath from list");
                    m_strlMetaChildNodes.erase(it);
                }
                it++;
            }
        }
    }

    //
    // Remove the first item if it's the current metapath
    //
    it = m_strlMetaChildNodes.begin();
    if (it != m_strlMetaChildNodes.end())
    {
        TRACE("Stripping %s\n", m_strMetaRoot);

        CString & strMetaPath = (*it);
        if (strMetaPath.CompareNoCase(m_strMetaRoot) == 0)
        {
            TRACEEOLID("Removing current metapath from list");
            m_strlMetaChildNodes.pop_front();
        }
    }

    m_fEmpty = m_strlMetaChildNodes.size() == 0;
}

#if 0
int
CInheritanceDlg::DoModal()
/*++

Routine Description:

    Display the dialog.

Arguments:

    None

Return Value:

    IDOK if the OK button was pressed, IDCANCEL otherwise.

--*/
{
    //
    // Specify the resources to use
    //
//    HINSTANCE hOldRes = AfxGetResourceHandle();
//    AfxSetResourceHandle(hDLLInstance);

    int answer = CDialog::DoModal();

    //
    // restore the resources
    //
//    AfxSetResourceHandle(hOldRes);

    return answer;
}
#endif


#if 0

void
CInheritanceDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CInheritanceDlg)
    DDX_Control(pDX, IDC_LIST_CHILD_NODES, m_list_ChildNodes);
    //}}AFX_DATA_MAP
}


//
// Message Map
//
BEGIN_MESSAGE_MAP(CInheritanceDlg, CDialog)
    //{{AFX_MSG_MAP(CInheritanceDlg)
    ON_BN_CLICKED(IDC_BUTTON_SELECT_ALL, OnButtonSelectAll)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()
#endif


BOOL
CInheritanceDlg::FriendlyInstance(CString& strMetaRoot, CString& strFriendly)
/*++

Routine Description:

    Replace the instance number with its descriptive name.

Arguments:

    CString & strMetaRoot       : Metabase path
    CString & strFriendly       : Converted output friendly path.

Return Value:

    TRUE if the path contained an instance number.

--*/
{
    //
    // Break into fields
    //
    // CODEWORK: make static like BuildMetaPath
    //
   int n = CMetabasePath::GetInstanceNumber(strMetaRoot);
   if (n == 0)
   {
      // Master instance
      return FALSE;
   }
   CString service, instance;
   if (CMetabasePath::GetServicePath(strMetaRoot, service, NULL))
   {
      int len = strMetaRoot.GetLength();
      int pos = strMetaRoot.Find(SZ_MBN_SEP_CHAR);
      if (pos != -1)
      {
         HRESULT hr = m_mk.Open(METADATA_PERMISSION_READ, CMetabasePath(service, n));
         if (SUCCEEDED(hr))
         {
            CString comment;
            hr = m_mk.QueryValue(MD_SERVER_COMMENT, comment);
            m_mk.Close();

            if (FAILED(hr) || comment.IsEmpty())
            {
               strFriendly.Format(
                    SZ_MBN_MACHINE SZ_MBN_SEP_STR _T("%s") SZ_MBN_SEP_STR _T("%d"),
                    service,
                    n
                    );
            }
            else
            {
               strFriendly.Format(
                    SZ_MBN_MACHINE SZ_MBN_SEP_STR _T("%s") SZ_MBN_SEP_STR _T("%s"),
                    service,
                    comment
                    );
            }

            TRACEEOLID(strFriendly);

            //
            // Append the rest of the path
            //
            CString tail;
            CMetabasePath::SplitMetaPathAtInstance(strMetaRoot, instance, tail);
            strFriendly += tail;
   
            return TRUE;
         }
      }
   }
   return FALSE;
}



CString&
CInheritanceDlg::CleanDescendantPath(CString& strMetaPath)
/*++

Routine Description:

    Clean the descendant metabase path.  The path is shown
    as a descendant of the current metabase root, and instance
    numbers are replaced with their description names.

Arguments:

    CString & strMetaPath   : Metabase path to be treated

Return Value:

    Reference to the cleaned-up path.

--*/
{
    //
    // This better be a descendant!
    //
    ASSERT(strMetaPath.GetLength() >= m_strMetaRoot.GetLength());
    ASSERT(!::_tcsnicmp(strMetaPath, m_strMetaRoot, m_strMetaRoot.GetLength()));

    if (!m_fHasInstanceInMaster)
    {
        //
        // Need to replace the instance number with the friendly
        // name.
        //
        CString strTmp;
        VERIFY(FriendlyInstance(strMetaPath, strTmp));
        strMetaPath = strTmp;
    }

    strMetaPath = strMetaPath.Mid(m_strMetaRoot.GetLength() + 1);

    return strMetaPath;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



LRESULT
CInheritanceDlg::OnInitDialog(HWND hwnd, LPARAM lParam)
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    //
    // Get friendly name for the property, and set the text.
    //
    CString strPrompt; 
    strPrompt.Format(_Module.GetResourceInstance(), 
       IDS_INHERITANCE_PROMPT, (LPCTSTR)m_strPropertyName);
    ::SetWindowText(GetDlgItem(IDC_STATIC_PROMPT), strPrompt);

    //
    // Turn inherited nodes into friendly paths, and add them
    // to the listbox.  Note the "current" node should have been
    // deleted at this stage.
    //
    CStringListEx::iterator pos = m_strlMetaChildNodes.begin();

    while (pos != m_strlMetaChildNodes.end())
    {
        CString strNode = (*pos++);
        m_list_ChildNodes.AddString(CleanDescendantPath(strNode));
    }
    return TRUE;
}



void
CInheritanceDlg::OnButtonSelectAll(WORD wNotifyCode, WORD wID, HWND hwndCtrl)
/*++

Routine Description:

    'Select All' button handler

Arguments:

    None

Return Value:

    None

--*/
{
   ASSERT(wNotifyCode == BN_CLICKED);
   ASSERT(wID == IDC_BUTTON_SELECT_ALL);
    //
    // Select all entries
    //
    if (m_list_ChildNodes.GetCount() == 1)
    {
        //
        // SelItemRange refuses to do a single member
        //
        m_list_ChildNodes.SetSel(0, TRUE);
    }
    else
    {
        m_list_ChildNodes.SelItemRange(TRUE, 0, m_list_ChildNodes.GetCount() - 1);
    }
}



void
CInheritanceDlg::OnOK(WORD wNotifyCode, WORD wID, HWND hwndCtrl)
/*++

Routine Description:

    'OK' button handler

Arguments:

    None

Return Value:

    None

--*/
{
   ASSERT(wNotifyCode == BN_CLICKED);
   ASSERT(wID == IDOK);
    //
    // Now delete the property for all selected child nodes.
    // Grab from the orginal list, and not the listbox
    // as the latter have been frienly-fied, and is no longer
    // usable.
    //
    int cItems = m_list_ChildNodes.GetCount();
    ASSERT(cItems > 0);

    CString strMetaPath;
    CError err(m_mk.QueryResult());

    if (err.Succeeded())
    {
        int i = 0;
        CStringListEx::iterator pos = m_strlMetaChildNodes.begin();
        while (pos != m_strlMetaChildNodes.end())
        {
            strMetaPath = (*pos++);

            if (m_list_ChildNodes.GetSel(i++) > 0)
            {
                TRACE("Deleting property on %s\n", strMetaPath);

                err = m_mk.Open(METADATA_PERMISSION_WRITE, strMetaPath);

                if (err.Failed())
                {
                    break;
                }

                err = m_mk.DeleteValue(m_dwMDIdentifier);

                m_mk.Close();

                if (err.Failed())
                {
                    break;
                }
            }
        }
    }

    if (!err.MessageBoxOnFailure())
    {
        //
        // Dialog can be dismissed
        //
        EndDialog(IDOK);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\strfn.h ===
#ifndef _STRFN_H
#define _STRFN_H

BOOL PathIsValid(LPCTSTR path);
BOOL _EXPORT IsDevicePath(IN const CString & strDirPath);
BOOL _EXPORT IsSpecialPath(IN const CString & strDirPath,IN BOOL bCheckIfValid);
BOOL _EXPORT GetSpecialPathRealPath(IN const CString & strDirPath,OUT CString & strDestination);


#endif // _STRFN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by iisuihelper.rc
//
#define IDS_PROJNAME                    100
#define IDS_APP_TITLE                   101
#define IDS_NO_MESSAGE                  102
#define IDR_AUTHINFO                    103
#define IDC_LIST_CHILD_NODES            11042
#define IDC_BUTTON_SELECT_ALL           11043
#define IDC_STATIC_PROMPT               11044
#define IDD_INHERITANCE                 15012
#define IDS_INHERITANCE_NO_NAME         20112
#define IDS_INHERITANCE_PROMPT          20113
#define IDS_FMT_SECURITY                20127
#define IDS_MD_CONNECTION_TIMEOUT       20200
#define IDS_MD_MAX_CONNECTIONS          20201
#define IDS_MD_SERVER_COMMENT           20202
#define IDS_MD_SERVER_SIZE              20203
#define IDS_MD_SERVER_LISTEN_BACKLOG    20204
#define IDS_MD_SERVER_LISTEN_TIMEOUT    20205
#define IDS_MD_APP_FRIENDLY_NAME        20207
#define IDS_MD_APP_ROOT                 20208
#define IDS_MD_APP_ISOLATED             20209
#define IDS_MD_VR_PATH                  20210
#define IDS_MD_VR_USERNAME              20211
#define IDS_MD_VR_PASSWORD              20212
#define IDS_MD_EXIT_MESSAGE             20213
#define IDS_MD_GREETING_MESSAGE         20214
#define IDS_MD_MAX_CLIENTS_MESSAGE      20215
#define IDS_MD_MSDOS_DIR_OUTPUT         20216
#define IDS_MD_ALLOW_ANONYMOUS          20217
#define IDS_MD_ANONYMOUS_ONLY           20218
#define IDS_MD_LOG_ANONYMOUS            20219
#define IDS_MD_LOG_NONANONYMOUS         20220
#define IDS_MD_AUTHORIZATION            20221
#define IDS_MD_REALM                    20222
#define IDS_MD_HTTP_EXPIRES             20223
#define IDS_MD_HTTP_PICS                20224
#define IDS_ERR_INVALID_PATH            20224
#define IDS_MD_HTTP_CUSTOM              20225
#define IDS_ERR_BAD_PATH                20225
#define IDS_MD_DIRECTORY_BROWSING       20226
#define IDS_ERR_PATH_NOT_FOUND          20226
#define IDS_MD_DEFAULT_LOAD_FILE        20227
#define IDS_ERR_FILE_NOT_FOUND          20227
#define IDS_MD_CONTENT_NEGOTIATION      20228
#define IDS_BAD_UNC_PATH                20228
#define IDS_MD_CUSTOM_ERROR             20229
#define IDS_MD_FOOTER_DOCUMENT          20230
#define IDS_MD_FOOTER_ENABLED           20231
#define IDS_MD_HTTP_REDIRECT            20232
#define IDS_MD_DEFAULT_LOGON_DOMAIN     20233
#define IDS_MD_LOGON_METHOD             20234
#define IDS_MD_SCRIPT_MAPS              20235
#define IDS_MD_MIME_MAP                 20236
#define IDS_MD_ACCESS_PERM              20237
#define IDS_MD_HEADER_DOCUMENT          20238
#define IDS_MD_HEADER_ENABLED           20239
#define IDS_MD_IP_SEC                   20240
#define IDS_MD_ANONYMOUS_USER_NAME      20241
#define IDS_MD_ANONYMOUS_PWD            20242
#define IDS_MD_ANONYMOUS_USE_SUBAUTH    20243
#define IDS_MD_DONT_LOG                 20244
#define IDS_MD_ADMIN_ACL                20245
#define IDS_MD_SSI_EXEC_DISABLED        20246
#define IDS_MD_SSL_ACCESS_PERM          20247
#define IDS_MD_NTAUTHENTICATION_PROVIDERS 20248
#define IDS_MD_SCRIPT_TIMEOUT           20249
#define IDS_MD_CACHE_EXTENSIONS         20250
#define IDS_MD_CREATE_PROCESS_AS_USER   20251
#define IDS_MD_CREATE_PROC_NEW_CONSOLE  20252
#define IDS_MD_POOL_IDC_TIMEOUT         20253
#define IDS_MD_ALLOW_KEEPALIVES         20254
#define IDS_MD_IS_CONTENT_INDEXED       20255
#define IDS_ASP_BUFFERINGON             20256
#define IDS_ASP_LOGERRORREQUESTS        20257
#define IDS_ASP_SCRIPTERRORSSENTTOBROWSER 20258
#define IDS_ASP_SCRIPTERRORMESSAGE      20259
#define IDS_ASP_SCRIPTFILECACHESIZE     20260
#define IDS_ASP_SCRIPTENGINECACHEMAX    20261
#define IDS_ASP_SCRIPTTIMEOUT           20262
#define IDS_ASP_SESSIONTIMEOUT          20263
#define IDS_ASP_ENABLEPARENTPATHS       20264
#define IDS_ASP_ALLOWSESSIONSTATE       20265
#define IDS_ASP_SCRIPTLANGUAGE          20266
#define IDS_ASP_EXCEPTIONCATCHENABLE    20267
#define IDS_ASP_ENABLESERVERDEBUG       20268
#define IDS_ASP_ENABLECLIENTDEBUG       20269
#define IDS_MD_LOG_PLUGIN_ORDER         20270
#define IDS_MD_LOGEXT_FIELD_MASK        20271
#define IDS_MD_LOG_TYPE                 20272
#define IDS_MD_LOGFILE_DIRECTORY        20273
#define IDS_MD_LOGFILE_PERIOD           20274
#define IDS_MD_LOGFILE_TRUNCATE_SIZE    20275
#define IDS_MD_LOGSQL_DATA_SOURCES      20276
#define IDS_MD_LOGSQL_TABLE_NAME        20277
#define IDS_MD_LOGSQL_USER_NAME         20278
#define IDS_MD_LOGSQL_PASSWORD          20279
#define IDS_MD_LOGFILE_LOCALTIME_ROLLOVER 20285
#define ID_HELP                         0xE146

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\strfn.cpp ===
//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "iisdebug.h"
#include "strfn.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


BOOL
IsUNCName(
    IN const CString & strDirPath
    )
/*++

Routine Description:

    Determine if the given string path is a UNC path.

Arguments:

    const CString & strDirPath : Directory path string

Return Value:

    TRUE if the path is a UNC path, FALSE otherwise.

Notes:

    Any string of the form \\foo\bar\whatever is considered a UNC path,
    with the exception of \\.\device paths.  No validation for the 
    existance occurs, only for the correct format.

--*/
{
    if (strDirPath.GetLength() >= 5)  // It must be at least as long as \\x\y,
    {                                 //
        LPCTSTR lp = strDirPath;      //
        if (*lp == _T('\\')           // It must begin with \\,
         && *(lp + 1) == _T('\\')     //
         && *(lp + 2) != _T('.')      // This is a device.
         && _tcschr(lp + 3, _T('\\')) // And have at least one more \ after that
           )
        {
            //
            // Yes, it's a UNC path
            //
            return TRUE;
        }
    }

    //
    // No, it's not
    //
    return FALSE;
}

BOOL 
_EXPORT
GetSpecialPathRealPath(
    IN const CString & strDirPath,
    OUT CString & strDestination
    )
{
    BOOL bReturn = FALSE;
	LPCTSTR lpszSpecialStuff = _T("\\\\?\\");
	LPCTSTR lpszUNCDevice = _T("UNC\\");

    // Default it with something
    strDestination = strDirPath;

	// Check for the "special stuff"
	BOOL bIsSpecialPath = (0 == _tcsnccmp(strDirPath, lpszSpecialStuff, lstrlen(lpszSpecialStuff)));
	// check if we need to verifiy that it is indeeded a valid devicepath
	if (bIsSpecialPath)
	{
		CString strTempPath;

		// verify that this is indeed a valid special path
		// grab everyting after the part we're interested in...
		//
		// and check if that is a fully qualified path
		// or a fully qualified UNC path.
		//
		// 1) \\?\c:\temp\testind.dll
		// 2) \\?\UNC\MyUnc\testing.dll
		//
		// check for #1
		strTempPath = strDirPath.Right(strDirPath.GetLength() - lstrlen(lpszSpecialStuff));

		// check if it starts with UNC
		if (0 == _tcsnccmp(strTempPath, lpszUNCDevice, lstrlen(lpszUNCDevice)))
		{
            CString strTempPath2;
            strTempPath2 = strTempPath.Right(strTempPath.GetLength() - lstrlen(lpszUNCDevice));

			DebugTrace(_T("SpecialPath:%s,it's a UNC path!\r\n"),strTempPath2);

            // Append on the extra ("\\\\") when returning the munged path
            strDestination = _T("\\\\") +  strTempPath2;

            bReturn = TRUE;
		}
		else
		{
			// check if the path if fully qualified and
			// if it's valid
			if (!PathIsRelative(strTempPath))
			{
				DebugTrace(_T("SpecialPath:%s,it's NOT a UNC path!\r\n"),strTempPath);
                strDestination = strTempPath;
                bReturn = TRUE;
			}
		}
	}
    return bReturn;
}


BOOL
_EXPORT
IsSpecialPath(
    IN const CString & strDirPath,
	IN BOOL bCheckIfValid
    )
/*++

Routine Description:
    Determine if the given path is of the form:
        1) \\?\c:\temp\testind.dll
        2) \\?\UNC\MyUnc\testing.dll
    
Arguments:
    const CString & strDirPath : Directory path string
	BOOL bCheckIfValid : to say "return true only if it's a "special path" and if it's valid"

Return Value:
    TRUE if the path given is a special path, 
    FALSE if it is not.

	if bCheckIfValid = TRUE then:
    TRUE if the path given is a special path and it's valid
    FALSE if it is not.

--*/
{
	BOOL bIsSpecialPath = FALSE;
	LPCTSTR lpszSpecialStuff = _T("\\\\?\\");
	LPCTSTR lpszUNCDevice = _T("UNC\\");

	// Check for the "special stuff"
	bIsSpecialPath = (0 == _tcsnccmp(strDirPath, lpszSpecialStuff, lstrlen(lpszSpecialStuff)));

	// check if we need to verifiy that it is indeeded a valid devicepath
	if (bIsSpecialPath && bCheckIfValid)
	{
		bIsSpecialPath = FALSE;
		CString strTempPath;

		// verify that this is indeed a valid special path
		// grab everyting after the part we're interested in...
		//
		// and check if that is a fully qualified path
		// or a fully qualified UNC path.
		//
		// 1) \\?\c:\temp\testind.dll
		// 2) \\?\UNC\MyUnc\testing.dll
		//
		// check for #1
		strTempPath = strDirPath.Right(strDirPath.GetLength() - lstrlen(lpszSpecialStuff));
		// check if it starts with UNC
		if (0 == _tcsnccmp(strTempPath, lpszUNCDevice, lstrlen(lpszUNCDevice)))
		{
			bIsSpecialPath = TRUE;
			DebugTrace(_T("SpecialPath:%s,it's a UNC path!\r\n"),strTempPath);
		}
		else
		{
			
			// check if the path if fully qualified and
			// if it's valid
			if (!PathIsRelative(strTempPath))
			{
				bIsSpecialPath = TRUE;
				DebugTrace(_T("SpecialPath:%s,it's NOT a UNC path!\r\n"),strTempPath);
			}
		}
	}
    return bIsSpecialPath;
}

BOOL
_EXPORT
IsDevicePath(
    IN const CString & strDirPath
    )
/*++

Routine Description:

    Determine if the given path is of the form "\\.\foobar"

Arguments:

    const CString & strDirPath : Directory path string

Return Value:

    TRUE if the path given is a device path, 
    FALSE if it is not.

--*/
{
    LPCTSTR lpszDevice = _T("\\\\.\\");
    return (0 == _tcsnccmp(strDirPath, lpszDevice, lstrlen(lpszDevice)));
}

BOOL PathIsValid(LPCTSTR path)
{
    LPCTSTR p = path;
    BOOL rc = TRUE;
    if (p == NULL || *p == 0)
        return FALSE;
    while (*p != 0)
    {
        switch (*p)
        {
        case TEXT('|'):
        case TEXT('>'):
        case TEXT('<'):
        case TEXT('/'):
        case TEXT('?'):
        case TEXT('*'):
//        case TEXT(';'):
//        case TEXT(','):
        case TEXT('"'):
            rc = FALSE;
            break;
        default:
            if (*p < TEXT(' '))
            {
                rc = FALSE;
            }
            break;
        }
        if (!rc)
        {
            break;
        }
        p++;
    }
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\strpass.h ===
/*++

   Copyright    (c)    1994-2002    Microsoft Corporation

   Module  Name :
        strpass.h

   Abstract:
        Message Functions Definitions

   Author:
        Aaron Lee (aaronl)

   Project:
        Internet Services Manager

   Revision History:

--*/

#ifndef _STRPASS_H_
#define _STRPASS_H_

#ifdef _COMEXPORT
    class COMDLL CStrPassword
#elif defined(_DLLEXP)
    class _EXPORT CStrPassword
#else
    class CStrPassword
#endif

{
public:

    // constructor/destructor
	CStrPassword();
	~CStrPassword();

    // copy constructors
    CStrPassword(LPTSTR lpsz);
    CStrPassword(LPCTSTR lpsz);
    CStrPassword(CStrPassword& csPassword);

	// get character count
	int GetLength() const;
    // get byte count
    int GetByteLength() const;
	// TRUE if zero length
	BOOL IsEmpty() const;
	// clear contents to empty
	void Empty();

	// straight character comparison
	int Compare(LPCTSTR lpsz) const;
    int Compare(CString& lpsz) const;
    int Compare(CStrPassword& lpsz) const;

	// copy string content from UNICODE string (converts to TCHAR)
	const CStrPassword& operator=(LPCTSTR lpsz);
    const CStrPassword& operator=(CStrPassword& lpStrPass);

    // copy to...
    void CopyTo(CString& stringSrc);
    void CopyTo(CStrPassword& stringSrc);

    // Get Data out from it (unencrypted)
    // Each call to GetClearTextPassword() should have an equal
    // DestroyClearTextPassword() call to it.
    LPTSTR GetClearTextPassword();
    void DestroyClearTextPassword(LPTSTR lpClearTextPassword) const;

    // not implemented
    operator TCHAR*();

    // returns CString
    operator CString();

    bool operator== (CStrPassword& csCompareToMe);

    bool operator!= (CStrPassword& csCompareToMe)
    {
        return !(operator==(csCompareToMe));
    }
   
private:
    void ClearPasswordBuffers(void);

protected:
    LPTSTR m_pszDataEncrypted;
    DWORD  m_cbDataEncrypted;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\strpass.cpp ===
/*++

   Copyright    (c)    1994-2002    Microsoft Corporation

   Module  Name :
        strpass.cpp

   Abstract:
        Message Functions

   Author:
        Aaron Lee (aaronl)

   Project:
        Internet Services Manager

   Revision History:

--*/

#include "stdafx.h"
#include "common.h"
#include "strpass.h"
#include "cryptpass.h"
#include <strsafe.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


#define new DEBUG_NEW

void CStrPassword::ClearPasswordBuffers(void)
{
    if (NULL != m_pszDataEncrypted)
    {
        if (m_cbDataEncrypted > 0)
        {
            SecureZeroMemory(m_pszDataEncrypted,m_cbDataEncrypted);
        }
        LocalFree(m_pszDataEncrypted);m_pszDataEncrypted=NULL;
    }
    m_pszDataEncrypted = NULL;
    m_cbDataEncrypted = 0;
}

// constructor
CStrPassword::CStrPassword()
{
    m_pszDataEncrypted = NULL;
    m_cbDataEncrypted = 0;
}

CStrPassword::~CStrPassword()
{
    ClearPasswordBuffers();
}

// constructor
CStrPassword::CStrPassword(LPTSTR lpch)
{
    m_pszDataEncrypted = NULL;
    m_cbDataEncrypted = 0;

    // Copy the string
    if (NULL != lpch)
    {
        if (FAILED(EncryptMemoryPassword(lpch,&m_pszDataEncrypted,&m_cbDataEncrypted)))
        {
            ASSERT(FALSE);
        }
    }
}

// constructor
CStrPassword::CStrPassword(LPCTSTR lpch)
{
    CStrPassword((LPTSTR) lpch);
}

// constructor
CStrPassword::CStrPassword(CStrPassword& csPassword)
{
    m_pszDataEncrypted = NULL;
    m_cbDataEncrypted = 0;
    LPTSTR lpTempPassword = csPassword.GetClearTextPassword();
    if (FAILED(EncryptMemoryPassword((LPTSTR) lpTempPassword,&m_pszDataEncrypted,&m_cbDataEncrypted)))
    {
        ASSERT(FALSE);
    }
    csPassword.DestroyClearTextPassword(lpTempPassword);
}

BOOL CStrPassword::IsEmpty() const
{
    if (m_pszDataEncrypted && (m_cbDataEncrypted > 0))
    {
        return FALSE;
    }
    return TRUE;
}

void CStrPassword::Empty()
{
    ClearPasswordBuffers();
}

int CStrPassword::GetLength() const
{
    int iRet = 0;
    LPTSTR lpszTempPassword = NULL;

    if (m_pszDataEncrypted && (m_cbDataEncrypted > 0))
    {
	    if (SUCCEEDED(DecryptMemoryPassword((LPTSTR) m_pszDataEncrypted,&lpszTempPassword,m_cbDataEncrypted)))
        {
            iRet = _tcslen(lpszTempPassword);
        }
    }

    if (lpszTempPassword)
    {
        SecureZeroMemory(lpszTempPassword,(_tcslen(lpszTempPassword)+1) * sizeof(TCHAR));
        LocalFree(lpszTempPassword);lpszTempPassword=NULL;
    }
    return iRet;
};

int CStrPassword::GetByteLength() const
{
    int iRet = 0;
    LPTSTR lpszTempPassword = NULL;

    if (m_pszDataEncrypted && (m_cbDataEncrypted > 0))
    {
	    if (SUCCEEDED(DecryptMemoryPassword((LPTSTR) m_pszDataEncrypted,&lpszTempPassword,m_cbDataEncrypted)))
        {
            iRet = (_tcslen(lpszTempPassword) + 1) * sizeof(TCHAR);
        }
    }

    if (lpszTempPassword)
    {
        SecureZeroMemory(lpszTempPassword,(_tcslen(lpszTempPassword)+1) * sizeof(TCHAR));
        LocalFree(lpszTempPassword);lpszTempPassword=NULL;
    }
    return iRet;
};

int CStrPassword::Compare(LPCTSTR lpsz) const
{
    // identical = 0
    // not equal = 1
    int iRet = 1;
    LPTSTR lpszTempPassword = NULL;

    if (lpsz == NULL)
    {
        return this->IsEmpty() ? 0 : 1;
    }
    if (lpsz[0] == NULL)
    {
        return this->IsEmpty() ? 0 : 1;
    }

    // Decrypt what we have
	if (!m_pszDataEncrypted || (m_cbDataEncrypted < 1))
	{
        // means we have nothing in here
        // but they want to compare it to something
        return iRet;
	}

	if (FAILED(DecryptMemoryPassword((LPTSTR) m_pszDataEncrypted,&lpszTempPassword,m_cbDataEncrypted)))
	{
        goto CStrPassword_Compare_Exit;
	}
    else
    {
        iRet = _tcscmp(lpszTempPassword,lpsz);
    }

CStrPassword_Compare_Exit:
    if (lpszTempPassword)
    {
        LocalFree(lpszTempPassword);lpszTempPassword=NULL;
    }
    return iRet;
}

const CStrPassword& CStrPassword::operator=(LPCTSTR lpsz)
{
    ClearPasswordBuffers();
    if (lpsz != NULL)
    {
        // Copy the string
        if (FAILED(EncryptMemoryPassword((LPTSTR) lpsz,&m_pszDataEncrypted,&m_cbDataEncrypted)))
        {
            ASSERT(FALSE);
        }
    }
    return *this;
}

const CStrPassword& CStrPassword::operator= (CStrPassword& lpStrPass)
{
   // handle the a = a case.
   if (this == &lpStrPass)
   {
      return *this;
   }
   ClearPasswordBuffers();
   LPTSTR lpTempPassword = lpStrPass.GetClearTextPassword();
   if (FAILED(EncryptMemoryPassword((LPTSTR) lpTempPassword,&m_pszDataEncrypted,&m_cbDataEncrypted)))
   {
       ASSERT(FALSE);
   }
   lpStrPass.DestroyClearTextPassword(lpTempPassword);

   return *this;
}

void CStrPassword::CopyTo(CString& stringSrc)
{
    LPTSTR lpTempPassword = GetClearTextPassword();
    stringSrc = lpTempPassword;
    DestroyClearTextPassword(lpTempPassword);
    return;
}

void CStrPassword::CopyTo(CStrPassword& stringSrc)
{
    LPTSTR lpTempPassword = GetClearTextPassword();
    stringSrc = (LPCTSTR) lpTempPassword;
    DestroyClearTextPassword(lpTempPassword);
    return;
}

int CStrPassword::Compare(CString& csString) const
{
    int iRet = 1;
    if (!csString.IsEmpty())
    {
        return Compare((LPCTSTR) csString);
    }
    return iRet;
}

int CStrPassword::Compare(CStrPassword& cstrPassword) const
{
    int iRet = 1;
    if (!cstrPassword.IsEmpty())
    {
        LPTSTR lpTempPassword = cstrPassword.GetClearTextPassword();
        iRet = Compare((LPCTSTR) lpTempPassword);
        cstrPassword.DestroyClearTextPassword(lpTempPassword);
        return iRet;
    }
    return iRet;
}

// user needs to LocalFree return.
// or call DestroyClearTextPassword.
LPTSTR CStrPassword::GetClearTextPassword()
{
    LPTSTR lpszTempPassword = NULL;

    if (m_pszDataEncrypted && (m_cbDataEncrypted > 0))
    {
	    if (FAILED(DecryptMemoryPassword((LPTSTR) m_pszDataEncrypted,&lpszTempPassword,m_cbDataEncrypted)))
	    {
            if (lpszTempPassword)
            {
                LocalFree(lpszTempPassword);lpszTempPassword=NULL;
            }
	    }
        else
        {
            return lpszTempPassword;
        }
    }
    return NULL;
}

void CStrPassword::DestroyClearTextPassword(LPTSTR lpClearTextPassword) const
{
    if (lpClearTextPassword)
    {
        SecureZeroMemory(lpClearTextPassword,(_tcslen(lpClearTextPassword)+1) * sizeof(TCHAR));
        LocalFree(lpClearTextPassword);lpClearTextPassword=NULL;
    }
    return;
}

// assign to a CString
CStrPassword::operator CString()
{
	CString csTempCString;
    LPTSTR lpTempPassword = GetClearTextPassword();
	if (lpTempPassword)
	{
		csTempCString = lpTempPassword;
		DestroyClearTextPassword(lpTempPassword);
	}
	return csTempCString;
}

bool CStrPassword::operator==(CStrPassword& csCompareToMe)
{
    LPTSTR lpTempPassword1 = NULL;
    LPTSTR lpTempPassword2 = NULL;
    bool result = FALSE;

    // handle the a == a case
    if (this == &csCompareToMe)
    {
        return TRUE;
    }

    if (GetLength() != csCompareToMe.GetLength())
    {
        // can't be the same if lengths differ...
        return FALSE;
    }
   
    // Two strings are the same if their decoded contents are the same.
    lpTempPassword1 = GetClearTextPassword();
    lpTempPassword2 = csCompareToMe.GetClearTextPassword();

    result = (_tcscmp(lpTempPassword1, lpTempPassword2) == 0);

    if (lpTempPassword1)
        {DestroyClearTextPassword(lpTempPassword1);}
    if (lpTempPassword2)
        {csCompareToMe.DestroyClearTextPassword(lpTempPassword2);}
   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\iisuiobj\defaults.h ===
#include "stdafx.h"



BOOL DefaultValueSettingsLoad(LPCTSTR lpszUncMachineName, LPCTSTR szRegItem, TCHAR * szReturnValue);
BOOL DefaultValueSettingsSave(LPCTSTR lpszUncMachineName, LPCTSTR szRegItem, LPCTSTR szInputValue);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\iisuiobj\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( IISUIObj )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( IISUIObj ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\utcls.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        utcls.h

   Abstract:

        Some utility functions and classes.

   Author:

        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _UTCLS_H_
#define _UTCLS_H_

#pragma warning(disable : 4275)

//
// CDialog parameters
//
#define USE_DEFAULT_CAPTION (0)

//
// Determine if the given server name refers to the local machine
//
BOOL _EXPORT
IsServerLocal(
    IN LPCTSTR lpszServer       
    );

//
// Get volume information system flags for the given path
//
BOOL _EXPORT
GetVolumeInformationSystemFlags(
    IN  LPCTSTR lpszPath,
    OUT DWORD * pdwSystemFlags
    );

//
// Build registry key name
//
LPCTSTR _EXPORT GenerateRegistryKey(
    OUT CString & strBuffer,    
    IN  LPCTSTR lpszSubKey = NULL
    );


class _EXPORT CStringListEx : public std::list<CString>
{
public:
   CStringListEx();
   ~CStringListEx();

   void PushBack(LPCTSTR str);
   void Clear();

   DWORD ConvertFromDoubleNullList(LPCTSTR lpstrSrc, int cChars = -1);
   DWORD ConvertToDoubleNullList(DWORD & cchDest, LPTSTR & lpstrDest);
};


class _EXPORT CBlob
/*++

Class Description:

    Binary large object class, which owns its pointer

Public Interface:

    CBlob           : Constructors
    ~CBlob          : Destructor

    SetValue        : Assign the value
    GetSize         : Get the byte size
    GetData         : Get pointer to the byte stream

--*/
{
//
// Constructors/Destructor
//
public:
    //
    // Initialize empty blob
    //
    CBlob();

    //
    // Initialize with binary data
    //
    CBlob(
        IN DWORD dwSize,
        IN PBYTE pbItem,
        IN BOOL fMakeCopy = TRUE
        );

    //
    // Copy constructor
    //
    CBlob(IN const CBlob & blob);

    //
    // Destructor destroys the pointer
    //    
    ~CBlob();

//
// Operators
//
public:
    CBlob & operator =(const CBlob & blob);
    BOOL operator ==(const CBlob & blob) const;
    BOOL operator !=(const CBlob & blob) const { return !operator ==(blob); }

//
// Access
//
public: 
    //
    // Clean up internal data
    //
    void CleanUp();

    //
    // Set the current value of the blob
    //
    void SetValue(
        IN DWORD dwSize,
        IN PBYTE pbItem,
        IN BOOL fMakeCopy = TRUE
        );

    //
    // TRUE if the blob is currently empty
    //
    BOOL IsEmpty() const { return m_dwSize == 0L; }

    //
    // Return the size of the blob in bytes
    //
    DWORD GetSize() const { return m_dwSize; }

    //
    // Get a pointer to the byte stream
    //
    PBYTE GetData();

private:
    DWORD m_dwSize;
    PBYTE m_pbItem;
};

// Blob for use in CryptoAPI functions
//
class CCryptBlob
{
public:
	CCryptBlob()
	{
		m_blob.cbData = 0;
		m_blob.pbData = NULL;
	}
	virtual ~CCryptBlob()
	{
	}
	DWORD GetSize() {return m_blob.cbData;}
	BYTE * GetData() {return m_blob.pbData;}
	void Set(DWORD cb, BYTE * pb)
	{
		Destroy();
		m_blob.cbData = cb;
		m_blob.pbData = pb;
	}
	BOOL Resize(DWORD cb)
   {
      BOOL res = TRUE;
      BYTE * p = m_blob.pbData;
      if (NULL != (m_blob.pbData = Realloc(m_blob.pbData, cb)))
      {
         m_blob.cbData = cb;
      }
      else
      {
         m_blob.pbData = p;
         res = FALSE;
      }
      return res;
   }
	operator CRYPT_DATA_BLOB *()
	{
		return &m_blob;
	}

protected:
	void Destroy()
	{
		if (m_blob.pbData != NULL)
			Free(m_blob.pbData);
	}
	virtual BYTE * Realloc(BYTE * pb, DWORD cb) = 0;
	virtual void Free(BYTE * pb) = 0;
	CRYPT_DATA_BLOB m_blob;
};

class CCryptBlobIMalloc : public CCryptBlob
{
public:
	virtual ~CCryptBlobIMalloc()
	{
		CCryptBlob::Destroy();
	}

protected:
	virtual BYTE * Realloc(BYTE * pb, DWORD cb)
	{
		return (BYTE *)CoTaskMemRealloc(pb, cb);
	}
	virtual void Free(BYTE * pb)
	{
		CoTaskMemFree(pb);
	}
};

class CCryptBlobLocal : public CCryptBlob
{
public:
	virtual ~CCryptBlobLocal()
	{
		CCryptBlob::Destroy();
	}

protected:
	virtual BYTE * Realloc(BYTE * pb, DWORD cb)
	{
		return (BYTE *)realloc(pb, cb);
	}
	virtual void Free(BYTE * pb)
	{
		free(pb);
	}
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CBlob::~CBlob()
{
    CleanUp();
}

inline PBYTE CBlob::GetData()
{
    return m_pbItem;
}





#endif // _UTCLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\iisuiobj\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "IISUIObj_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\iisuiobj\iisdebug.cpp ===
#include "stdafx.h"

INT g_iDebugOutputLevel = 0;

void GetOutputDebugFlag(void)
{
    DWORD rc, err, size, type;
    HKEY  hkey;
    err = RegOpenKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\InetMgr"), &hkey);
    if (err != ERROR_SUCCESS) {return;}
    size = sizeof(DWORD);
    err = RegQueryValueEx(hkey,_T("OutputDebugFlag"),0,&type,(LPBYTE)&rc,&size);
    if (err != ERROR_SUCCESS || type != REG_DWORD) {rc = 0;}
    RegCloseKey(hkey);

	if (rc < 0xffffffff)
	{
		g_iDebugOutputLevel = rc;
	}
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common2\utcls.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        utcls.cpp

   Abstract:

        Internet Properties base classes

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager (cluster edition)

   Revision History:

--*/


//
// Include Files
//
#include "stdafx.h"
#include "common.h"
//#include "idlg.h"

#include "mmc.h"

extern "C"
{
    #include <lm.h>
}

#define SZ_REG_KEY_BASE  _T("Software\\Microsoft\\%s")


BOOL
IsServerLocal(
    IN LPCTSTR lpszServer
    )
/*++

Routine Description:

    Check to see if the given name refers to the local machine

Arguments:

    LPCTSTR lpszServer   : Server name

Return Value:

    TRUE if the given name refers to the local computer, FALSE otherwise

Note:

    Doesn't work if the server is an ip address

--*/
{
    TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwSize = sizeof(szComputerName)/sizeof(szComputerName[0]);

    //
    // CODEWORK(?): we're not checking for all the ip addresses
    //              on the local box or full dns names.
    //
    //              Try GetComputerNameEx when we're building with NT5 
    //              settings.
    //
    return (!_tcsicmp(_T("localhost"), PURE_COMPUTER_NAME(lpszServer))
         || !_tcscmp( _T("127.0.0.1"), PURE_COMPUTER_NAME(lpszServer)))
         || (GetComputerName(szComputerName, &dwSize) 
             && !_tcsicmp(szComputerName, PURE_COMPUTER_NAME(lpszServer)));
}



BOOL
GetVolumeInformationSystemFlags(
    IN  LPCTSTR lpszPath,
    OUT DWORD * pdwSystemFlags
    )
/*++

Routine Description:

    Get the system flags for the path in question

Arguments:

    LPCTSTR lpszPath            : Path
    DWORD * pdwSystemFlags      : Returns system flags

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    ASSERT_WRITE_PTR(pdwSystemFlags);

    TRACE("Getting system flags for %s\n", lpszPath);

    DWORD dwMaxComponentLength;
    TCHAR szRoot[MAX_PATH + 1];
    TCHAR szFileSystem[MAX_PATH + 1];

    //
    // Generating root path
    //
    if (PathIsUNC(lpszPath))
    {
        //
        // Root path of a UNC path is \\foo\bar\
        //
        ASSERT(lstrlen(lpszPath) < MAX_PATH);

        int cSlashes = 0;
        LPCTSTR lpszSrc = lpszPath;
        LPTSTR lpszDst = szRoot;

        while (cSlashes < 4 && *lpszSrc)
        {
            if ((*lpszDst++ = *lpszSrc++) == '\\')
            {
                ++cSlashes;
            }
        }    

        if (!*lpszSrc)
        {
            *lpszDst++ = '\\';
        }

        *lpszDst = '\0';
    }
    else
    {
        ::wsprintf(szRoot, _T("%c:\\"), *lpszPath);
    }

    TRACE("Root path is %s\n", szRoot);
    
    return ::GetVolumeInformation(
        szRoot,
        NULL,
        0,
        NULL,
        &dwMaxComponentLength,
        pdwSystemFlags,
        szFileSystem,
        sizeof(szFileSystem) / sizeof(TCHAR)
        );
}



LPCTSTR
GenerateRegistryKey(
    OUT CString & strBuffer,
    IN  LPCTSTR lpszSubKey OPTIONAL
    )
/*++

Routine Description:

    Generate a registry key name based on the current app, and a
    provided subkey (optional)

Arguments:

    CString & strBuffer : Buffer to create registry key name into.
    LPCTSTR lpszSubKey  : Subkey name or NULL

Return Value:

    Pointer to the registry key value 

--*/
{
    try
    {
        //
        // Use the app name as the primary registry name
        //
       CString app_name;
       app_name.LoadString(_Module.GetResourceInstance(), IDS_APP_TITLE);
       strBuffer.Format(SZ_REG_KEY_BASE, app_name);

        if (lpszSubKey)
        {
            strBuffer += _T("\\");
            strBuffer += lpszSubKey;
        }

        TRACE("Registry key is %s\n", strBuffer);
    }
    catch(std::bad_alloc)
    {
        TRACEEOLID("!!!exception building regkey");
        return NULL;
    }

    return strBuffer;
}


static int
CountCharsToDoubleNull(
    IN LPCTSTR lp
    )
/*++

Routine Description:

    Count TCHARS up to and including the double NULL.

Arguments:

    LPCTSTR lp       : TCHAR Stream

Return Value:

    Number of chars up to and including the double NULL

--*/
{
    int cChars = 0;

    for(;;)
    {
        ++cChars;

        if (lp[0] == _T('\0') && lp[1] == _T('\0'))
        {
            return ++cChars;
        }

        ++lp;
    }
}

CStringListEx::CStringListEx() : std::list<CString> ()
{
}

CStringListEx::~CStringListEx()
{
}

void
CStringListEx::PushBack(LPCTSTR str)
{
   push_back(str);
}

void
CStringListEx::Clear()
{
   clear();
}

DWORD
CStringListEx::ConvertFromDoubleNullList(LPCTSTR lpstrSrc, int cChars)
/*++

Routine Description:

    Convert a double null terminate list of null terminated strings to a more
    manageable CStringList

Arguments:

    LPCTSTR lpstrSrc       : Source list of strings
    int cChars             : Number of characters in double NULL list. if
                             -1, autodetermine length

Return Value:

    ERROR_SUCCESS           if the list was converted properly
    ERROR_INVALID_PARAMETER if the list was empty
    ERROR_NOT_ENOUGH_MEMORY if there was a mem exception

--*/
{
    DWORD err = ERROR_SUCCESS;

    if (lpstrSrc == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (cChars < 0)
    {
        //
        // Calculate our own size.  This might be off if multiple
        // blank linkes (0) appear in the multi_sz, so the character
        // size is definitely preferable
        //
        cChars = CountCharsToDoubleNull(lpstrSrc);
    }

    try
    {
        clear();

        if (cChars == 2 && *lpstrSrc == _T('\0'))
        {
            //
            // Special case: MULTI_SZ containing only
            // a double NULL are in fact blank entirely.
            //
            // N.B. IMHO this is a metabase bug -- RonaldM
            //
            --cChars;
        }

        //
        // Grab strings until only the final NULL remains
        //
        while (cChars > 1)
        {
            CString strTmp = lpstrSrc;
            push_back(strTmp);
            lpstrSrc += (strTmp.GetLength() + 1);
            cChars -= (strTmp.GetLength() + 1);
        }
    }
    catch(std::bad_alloc)
    {
        TRACEEOLID("!!! exception building stringlist");
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

    return err;
}



DWORD
CStringListEx::ConvertToDoubleNullList(
    OUT DWORD & cchDest,
    OUT LPTSTR & lpstrDest
    )
/*++

Routine Description:

    Flatten the string list into a double null terminated list
    of null terminated strings.

Arguments:

    CStringList & strlSrc : Source string list
    DWORD & cchDest       : Size in characters of the resultant array
                            (including terminating NULLs)
    LPTSTR & lpstrDest    : Allocated flat array.

Return Value:

    ERROR_SUCCESS           if the list was converted properly
    ERROR_INVALID_PARAMETER if the list was empty
    ERROR_NOT_ENOUGH_MEMORY if there was a mem exception

--*/
{
    cchDest = 0;
    lpstrDest = NULL;
    BOOL fNullPad = FALSE;

    //
    // Compute total size in characters
    //
    CStringListEx::iterator it = begin();

    while (it != end())
    {
        CString & str = (*it++);

//        TRACEEOLID(str);

        cchDest += str.GetLength() + 1;
    }

    if (!cchDest)
    {
        //
        // Special case: A totally empty MULTI_SZ
        // in fact consists of 2 (final) NULLS, instead
        // of 1 (final) NULL.  This is required by the
        // metabase, but should be a bug.  See note
        // at reversal function above.
        //
        ++cchDest;
        fNullPad = TRUE;
    }

    //
    // Remember final NULL
    //
    cchDest += 1;

    lpstrDest = new TCHAR[cchDest];
    if (lpstrDest == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LPTSTR pch = lpstrDest;
    it = begin();
    while (it != end())
    {
        CString & str = (*it++);

        lstrcpy(pch, (LPCTSTR)str);
        pch += str.GetLength();
        *pch++ = _T('\0');
    }

    *pch++ = _T('\0');

    if (fNullPad)
    {
        *pch++ = _T('\0');
    }

    return ERROR_SUCCESS;
}






//
// CBlob Implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


CBlob::CBlob() 
/*++

Routine Description:

    NULL constructor

Arguments:

    None

Return Value:

    N/A

--*/
    : m_pbItem(NULL), 
      m_dwSize(0L)
{
}



CBlob::CBlob(
    IN DWORD dwSize,
    IN PBYTE pbItem,
    IN BOOL fMakeCopy
    )
/*++

Routine Description:

    Constructor

Arguments:

    DWORD dwSize        : Size of memory block
    PBYTE pbItem        : Pointer to memory block
    BOOL fMakeCopy      : If TRUE, makes a copy of the memory block.
                          If FALSE, takes ownership of the pointer.

Return Value:

    N/A

--*/
    : m_pbItem(NULL),
      m_dwSize(0L)
{
    SetValue(dwSize, pbItem, fMakeCopy);
}



CBlob::CBlob(
    IN const CBlob & blob
    )
/*++

Routine Description:

    Copy constructor

Arguments:

    const CBlob & blob      : Source blob

Return Value:

    N/A

Notes:

    This contructor makes a copy of the memory block in question.

--*/
    : m_pbItem(NULL),
      m_dwSize(0L)
{
    SetValue(blob.GetSize(), blob.m_pbItem, TRUE);
}



void
CBlob::SetValue(
    IN DWORD dwSize,
    IN PBYTE pbItem,
    IN BOOL fMakeCopy OPTIONAL
    )
/*++

Routine Description:

    Assign the value to this binary object.  If fMakeCopy is FALSE,
    the blob will take ownership of the pointer, otherwise a copy
    will be made.

Arguments:

    DWORD dwSize        : Size in bytes
    PBYTE pbItem        : Byte streadm
    BOOL fMakeCopy      : If true, make a copy, else assign pointer

Return Value:

    None

--*/
{
    ASSERT_READ_PTR2(pbItem, dwSize);

    if (!IsEmpty())
    {
        TRACEEOLID("Assigning value to non-empty blob.  Cleaning up");
        CleanUp();
    }

    if (dwSize > 0L)
    {
        //
        // Make private copy
        //
        m_dwSize = dwSize;

        if (fMakeCopy)
        {
            m_pbItem = new BYTE[m_dwSize];
            if (NULL != m_pbItem)
               CopyMemory(m_pbItem, pbItem, dwSize);
        }
        else
        {
            m_pbItem = pbItem;
        }
    }
}



void 
CBlob::CleanUp()
/*++

Routine Description:

    Delete data pointer, and reset pointer and size.

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_pbItem)
    {
        delete [] m_pbItem;
    }

    m_pbItem = NULL;
    m_dwSize = 0L;
}



CBlob & 
CBlob::operator =(
    IN const CBlob & blob
    )
/*++

Routine Description:

    Assign values from another CBlob. 

Arguments:

    const CBlob & blob      : Source blob

Return Value:

    Reference to this object

--*/
{
    //
    // Make copy of data
    //
    SetValue(blob.GetSize(), blob.m_pbItem, TRUE);

    return *this;
}



BOOL 
CBlob::operator ==(
    IN const CBlob & blob
    ) const
/*++

Routine Description:
    
    Compare two binary large objects.  In order to match, the objects
    must be the same size, and byte identical.

Arguments:

    const CBlob & blob      : Blob to compare against.

Return Value:

    TRUE if the objects match, FALSE otherwise.

--*/
{
    if (GetSize() != blob.GetSize())
    {
        return FALSE;
    }

    return memcmp(m_pbItem, blob.m_pbItem, GetSize()) == 0;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\iisuiobj\defaults.cpp ===
#include "stdafx.h"
#include "resource.h"
#include "common.h"
#include "remoteenv.h"
#include "util.h"
#include "defaults.h"
#include <strsafe.h>

#define DEFAULT_ROOT_KEY                HKEY_LOCAL_MACHINE

const TCHAR g_szRegistryKey[] = _T("SOFTWARE\\Microsoft\\InetMgr");
const TCHAR g_szRegistryKeyOurs[] = _T("IISUIObj\\ImportExport");

void GetRegistryPath(CString &str)
{
	str = g_szRegistryKey;
	str += _T("\\");
	str += g_szRegistryKeyOurs;
}

BOOL CreateInitialRegPath(LPCTSTR lpszMachineName)
{
    BOOL bRet = FALSE;
	HKEY hKey = NULL;
    HKEY RootKey = DEFAULT_ROOT_KEY;
    TCHAR szMachineName[MAX_COMPUTERNAME_LENGTH + 3];

    CString strRegKey;
    GetRegistryPath(strRegKey);

    if (lpszMachineName && 0 != _tcscmp(lpszMachineName,_T("")))
    {
        // check if lpszMachineName already starts with "\\"
        if (lpszMachineName[0] == _T('\\') && lpszMachineName[1] == _T('\\'))
        {
			StringCbCopy(szMachineName, sizeof(szMachineName), lpszMachineName);
        }
        else
        {
			StringCbCopy(szMachineName, sizeof(szMachineName), _T("\\\\"));
			StringCbCat(szMachineName, sizeof(szMachineName), lpszMachineName);
        }

        if (ERROR_SUCCESS != RegConnectRegistry((LPTSTR) szMachineName,DEFAULT_ROOT_KEY,&RootKey))
        {
            return(FALSE);
        }
    }

    if (ERROR_SUCCESS != RegOpenKeyEx(RootKey, strRegKey, 0, KEY_ALL_ACCESS, &hKey))
    {
	    if (ERROR_SUCCESS == RegOpenKeyEx(RootKey,g_szRegistryKey, 0, KEY_CREATE_SUB_KEY, &hKey))
	    {
		    HKEY hWizardKey;
		    if (ERROR_SUCCESS == RegCreateKey(hKey, g_szRegistryKeyOurs, &hWizardKey))
		    {
                bRet = TRUE;
			    RegCloseKey(hWizardKey);
		    }
		    RegCloseKey(hKey);
	    }
    }
    else
    {
        RegCloseKey(hKey);
    }
    return bRet;
}

BOOL DefaultValueSettingsLoad(LPCTSTR lpszMachineName, LPCTSTR szRegItem, TCHAR * szReturnValue)
{
    BOOL bRet = FALSE;
	HKEY hKey = NULL;
    HKEY RootKey = DEFAULT_ROOT_KEY;
    TCHAR szMachineName[MAX_COMPUTERNAME_LENGTH + 3];

    CString strRegKey;
    GetRegistryPath(strRegKey);

    if (lpszMachineName && 0 != _tcscmp(lpszMachineName,_T("")))
    {
        // check if lpszMachineName already starts with "\\"
        if (lpszMachineName[0] == _T('\\') && lpszMachineName[1] == _T('\\'))
        {
			StringCbCopy(szMachineName, sizeof(szMachineName), lpszMachineName);
        }
        else
        {
			StringCbCopy(szMachineName, sizeof(szMachineName), _T("\\\\"));
			StringCbCat(szMachineName, sizeof(szMachineName), lpszMachineName);
        }

        if (ERROR_SUCCESS != RegConnectRegistry((LPTSTR) szMachineName,DEFAULT_ROOT_KEY,&RootKey))
        {
            return(FALSE);
        }
    }

    if (ERROR_SUCCESS == RegOpenKeyEx(RootKey, strRegKey, 0, KEY_READ, &hKey))
    {
	    DWORD dwType;
	    DWORD cbData;
	    if (hKey != NULL)
	    {
		    BYTE * pName = NULL;
		    if (ERROR_SUCCESS == RegQueryValueEx(hKey, szRegItem, NULL, &dwType, NULL, &cbData))
		    {
			    pName = (BYTE *) szReturnValue;
			    RegQueryValueEx(hKey, szRegItem, NULL, &dwType, pName, &cbData);
			    if (pName != NULL)
			    {
				    pName = NULL;
                    bRet = TRUE;
			    }
		    }
		    RegCloseKey(hKey);
	    }
    }
    return bRet;
}

BOOL DefaultValueSettingsSave(LPCTSTR lpszMachineName, LPCTSTR szRegItem, LPCTSTR szInputValue)
{
    BOOL bRet = FALSE;
	HKEY hKey = NULL;
    HKEY RootKey = DEFAULT_ROOT_KEY;
    TCHAR szMachineName[MAX_COMPUTERNAME_LENGTH + 3];

    CString strRegKey;
    GetRegistryPath(strRegKey);
    CreateInitialRegPath(lpszMachineName);

    if (lpszMachineName && 0 != _tcscmp(lpszMachineName,_T("")))
    {
        // check if lpszMachineName already starts with "\\"
        if (lpszMachineName[0] == _T('\\') && lpszMachineName[1] == _T('\\'))
        {
			StringCbCopy(szMachineName, sizeof(szMachineName), lpszMachineName);
        }
        else
        {
			StringCbCopy(szMachineName, sizeof(szMachineName), _T("\\\\"));
			StringCbCat(szMachineName, sizeof(szMachineName), lpszMachineName);
        }

        if (ERROR_SUCCESS != RegConnectRegistry((LPTSTR) szMachineName,DEFAULT_ROOT_KEY,&RootKey))
        {
            return(FALSE);
        }
    }

    if (ERROR_SUCCESS == RegOpenKeyEx(RootKey, strRegKey, 0, KEY_ALL_ACCESS, &hKey))
    {
        if (hKey != NULL)
	    {
            RegSetValueEx(hKey,szRegItem,0,REG_SZ,(const BYTE *)(LPCTSTR)(szInputValue),sizeof(TCHAR) * (_tcslen(szInputValue) + 1));
		    RegCloseKey(hKey);
            bRet = TRUE;
        }
    }
	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\iisuiobj\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__3C4C690D_DBEB_4CA9_8578_03E740F33ED9__INCLUDED_)
#define AFX_DLLDATAX_H__3C4C690D_DBEB_4CA9_8578_03E740F33ED9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__3C4C690D_DBEB_4CA9_8578_03E740F33ED9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\iisuiobj\exportui.h ===
// ExportUI.h : Declaration of the CExportUI

#ifndef __EXPORTUI_H_
#define __EXPORTUI_H_

#include "resource.h"       // main symbols
#include <atlhost.h>

HRESULT DoExportConfigToFile(PCONNECTION_INFO pConnectionInfo,BSTR bstrFileNameAndPath,BSTR bstrMetabasePath,BSTR bstrPassword,DWORD dwExportFlags);
INT_PTR CALLBACK ShowExportDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

#endif //__EXPORTUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\iisuiobj\global.h ===
#include "stdafx.h"

#ifndef _ALL_GLOBAL_H
#define _ALL_GLOBAL_H

// Connection info
typedef struct tagCONNECTION_INFO
{
    BOOL     IsLocal;
	LPCTSTR	 pszMachineName;
    LPCTSTR	 pszUserName;
    LPCTSTR	 pszUserPasswordEncrypted;
	DWORD    cbUserPasswordEncrypted;
} CONNECTION_INFO, *PCONNECTION_INFO;


// used to pass info to a common dlgproc
typedef struct tagCOMMONDLGPARAM
{
    CONNECTION_INFO ConnectionInfo;
    LPCTSTR	 pszMetabasePath;
    LPCTSTR	 pszKeyType;
    DWORD    dwImportFlags;
    DWORD    dwExportFlags;
} COMMONDLGPARAM, *PCOMMONDLGPARAM;


#endif	// _ALL_GLOBAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\iisuiobj\exportui.cpp ===
// ExportUI.cpp : Implementation of CExportUI
//#include "stdafx.h"
//#include "ExportUI.h"

#include "stdafx.h"
#include "IISUIObj.h"
#include "ImportExportConfig.h"
#include "ExportUI.h"
#include "ImportUI.h"
#include "defaults.h"
#include "util.h"
#include "ddxv.h"
#include <strsafe.h>

#define HIDD_IISUIOBJ_EXPORT 0x50402
#define LAST_USED_EXPORT_PATH _T("LastExportPath")

void SetControlStates(HWND hDlg, UINT msg, WPARAM wParam, PCOMMONDLGPARAM pcdParams)
{
    BOOL bEnAbleOk = FALSE;
    BOOL bEnAbleBrowse = FALSE;
    BOOL bAllPasswordsFilled = TRUE;
    BOOL bFileNameFilled = FALSE;
    BOOL bFilePathFilled = FALSE;

    BOOL bUsingPassword = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_CHECK_ENCRYPT));
    if (bUsingPassword)
    {
        bAllPasswordsFilled = FALSE;
        // check to see if we want to enable okay button
        if (SendMessage(GetDlgItem(hDlg,IDC_EDIT_PASSWORD1),EM_LINELENGTH,(WPARAM) -1, 0))
        {
            if (SendMessage(GetDlgItem(hDlg,IDC_EDIT_PASSWORD2),EM_LINELENGTH,(WPARAM) -1, 0))
            {
                bAllPasswordsFilled = TRUE;
            }
        }
    }

    if (SendMessage(GetDlgItem(hDlg,IDC_EDIT_FILENAME),EM_LINELENGTH,(WPARAM) -1, 0))
    {
        bFileNameFilled = TRUE;
    }

    if (SendMessage(GetDlgItem(hDlg,IDC_EDIT_PATH),EM_LINELENGTH,(WPARAM) -1, 0))
    {
        bFilePathFilled = TRUE;
    }

    if (bFileNameFilled && bFilePathFilled && bAllPasswordsFilled)
    {
        bEnAbleOk = TRUE;
    }

    // no browse button for remote case
    if (pcdParams)
    {
        if (pcdParams->ConnectionInfo.IsLocal)
        {
            bEnAbleBrowse = TRUE;
        }
    }

    EnableWindow(GetDlgItem(hDlg,IDOK), bEnAbleOk);
    EnableWindow(GetDlgItem(hDlg,IDC_BUTTON_BROWSE), bEnAbleBrowse);
    UpdateWindow(hDlg);
    return;
}

INT_PTR CALLBACK ShowExportDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    static PCOMMONDLGPARAM pcdParams;

    switch (msg)
    {
        case WM_INITDIALOG:
            {
                TCHAR szPathToInetsrv[_MAX_PATH];
                pcdParams = (PCOMMONDLGPARAM)lParam;

                if (!pcdParams->pszMetabasePath)
                {
                    EnableWindow(GetDlgItem(hDlg,IDOK), FALSE);
                    SetLastError(ERROR_INVALID_PARAMETER);
                    return FALSE;
                }

                SendDlgItemMessage(hDlg, IDC_EDIT_FILENAME, EM_LIMITTEXT, _MAX_PATH, 0);
                SendDlgItemMessage(hDlg, IDC_EDIT_PATH, EM_LIMITTEXT, _MAX_PATH, 0);
                SendDlgItemMessage(hDlg, IDC_EDIT_PASSWORD1, EM_LIMITTEXT, PWLEN, 0);
                SendDlgItemMessage(hDlg, IDC_EDIT_PASSWORD2, EM_LIMITTEXT, PWLEN, 0);

                // Default it with some default values...
                // Fill a Default filename...
                SetDlgItemText(hDlg, IDC_EDIT_FILENAME, _T(""));
                // Fill a default filepath...
                SetDlgItemText(hDlg, IDC_EDIT_PATH, _T(""));
                if (DefaultValueSettingsLoad((LPCTSTR) pcdParams->ConnectionInfo.pszMachineName,LAST_USED_EXPORT_PATH,szPathToInetsrv))
                {
                    if (0 != _tcscmp(szPathToInetsrv, _T("")))
                    {
                        SetDlgItemText(hDlg, IDC_EDIT_PATH, szPathToInetsrv);
                    }
                    else
                    {
                        if (GetInetsrvPath(pcdParams->ConnectionInfo.pszMachineName,szPathToInetsrv,sizeof(szPathToInetsrv)))
                        {
                            SetDlgItemText(hDlg, IDC_EDIT_PATH, szPathToInetsrv);
                        }
                    }
                }
                else
                {
                    if (pcdParams->ConnectionInfo.IsLocal)
                    {
                        if (GetInetsrvPath(pcdParams->ConnectionInfo.pszMachineName,szPathToInetsrv,sizeof(szPathToInetsrv)))
                        {
                            SetDlgItemText(hDlg, IDC_EDIT_PATH, szPathToInetsrv);
                        }
                    }
                    else
                    {
                        // forget remote case, since GetInetsrvPath may hang for this reason...
                    }
                }
           
                // Set encryption using password to unchecked.
                SendDlgItemMessage(hDlg, IDC_CHECK_ENCRYPT, BM_SETCHECK, BST_UNCHECKED, 0L);

                // Set encryption password1 to blank
                // make sure it's disabled...
                SendDlgItemMessage(hDlg, IDC_EDIT_PASSWORD1, EM_SETPASSWORDCHAR, WPARAM('*'), 0);
	            EnableWindow(GetDlgItem(hDlg,IDC_EDIT_PASSWORD1), FALSE);
                SetDlgItemText(hDlg, IDC_EDIT_PASSWORD1, _T(""));

                // Set encryption password2 to blank
                // make sure it's disabled...
                SendDlgItemMessage(hDlg, IDC_EDIT_PASSWORD2, EM_SETPASSWORDCHAR, WPARAM('*'), 0);
                EnableWindow(GetDlgItem(hDlg,IDC_EDIT_PASSWORD2), FALSE);
                SetDlgItemText(hDlg, IDC_EDIT_PASSWORD2, _T(""));

                EnableWindow(GetDlgItem(hDlg,IDC_STATIC_PASSWORD1), FALSE);
                EnableWindow(GetDlgItem(hDlg,IDC_STATIC_PASSWORD2), FALSE);

                CenterWindow(GetForegroundWindow(), hDlg);
                SetFocus(GetDlgItem(hDlg, IDC_EDIT_FILENAME));

                SetControlStates(hDlg,msg,wParam,pcdParams);
                break;
            }

	    case WM_NOTIFY:
		    break;

        case WM_CLOSE:
            EndDialog(hDlg, IDCANCEL);
            return FALSE;
            break;

		case WM_HELP:
			LaunchHelp(hDlg,HIDD_IISUIOBJ_EXPORT);
			return TRUE;
			break;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDC_BUTTON_BROWSE:
                    {
                        CString strTitle;
                        strTitle.LoadString(_Module.GetResourceInstance(), IDS_BROWSE_SELECT_FOLDER);
                        UINT ulFlags=BIF_NEWDIALOGSTYLE | 
                                     BIF_RETURNONLYFSDIRS | 
                                     BIF_RETURNFSANCESTORS | 
                                     //BIF_STATUSTEXT |
                                     //BIF_DONTGOBELOWDOMAIN |
                                     BIF_BROWSEFORCOMPUTER |
                                     BIF_SHAREABLE |
                                     //BIF_BROWSEINCLUDEFILES |
                                     //BIF_USENEWUI |
                                     BIF_UAHINT |
                                     BIF_VALIDATE;
                        CFolderDialog dlg(hDlg,strTitle,ulFlags);
                       
	                    if (IDOK == dlg.DoModal())
	                    {
		                    // update the dialog box
                            if (0 != _tcsicmp(dlg.GetFolderPath(), _T("")))
                            {
                                SetDlgItemText(hDlg, IDC_EDIT_PATH, dlg.GetFolderPath());
                                UpdateWindow(hDlg);
                            }
	                    }

                        return FALSE;
                    }

                case IDC_EDIT_FILENAME:
                    {
	                    switch (HIWORD(wParam))
                        {
	                        case EN_CHANGE:
								EditHideBalloon();
		                        // If the contents of the edit control have changed,
                                SetControlStates(hDlg,msg,wParam,pcdParams);
		                        break;
                            case EN_MAXTEXT:
	                        case EN_ERRSPACE:
		                        // If the control is out of space, honk
		                        MessageBeep (0);
		                        break;
	                        default:
                                break;
	                    }
	                    return FALSE;
                    }

                case IDC_EDIT_PASSWORD1:
                    {
	                    switch (HIWORD(wParam))
                        {
	                        case EN_CHANGE:
								EditHideBalloon();
                                SetControlStates(hDlg,msg,wParam,pcdParams);
		                        break;
                            case EN_MAXTEXT:
	                        case EN_ERRSPACE:
		                        // If the control is out of space, honk
		                        MessageBeep (0);
		                        break;
	                        default:
                                break;
	                    }
	                    return FALSE;
                    }
                case IDC_EDIT_PASSWORD2:
                    {
	                    switch (HIWORD(wParam))
                        {
	                        case EN_CHANGE:
								EditHideBalloon();
                                SetControlStates(hDlg,msg,wParam,pcdParams);
                                break;
                            case EN_MAXTEXT:
	                        case EN_ERRSPACE:
		                        // If the control is out of space, honk
		                        MessageBeep (0);
		                        break;
	                        default:
                                break;
	                    }
	                    return FALSE;
                    }

                case IDC_EDIT_PATH:
                    {
	                    switch (HIWORD(wParam))
                        {
	                        case EN_CHANGE:
								EditHideBalloon();
		                        // If the contents of the edit control have changed,
                                SetControlStates(hDlg,msg,wParam,pcdParams);
		                        break;
                            case EN_MAXTEXT:
	                        case EN_ERRSPACE:
		                        // If the control is out of space, honk
		                        MessageBeep (0);
		                        break;
	                        default:
                                break;
	                    }
	                    return FALSE;
                    }

                case IDHELP:
					LaunchHelp(hDlg,HIDD_IISUIOBJ_EXPORT);
                    return TRUE;

                case IDCANCEL:
                    {
                        EndDialog(hDlg, (int)wParam);
                        return FALSE;
                    }

                case IDOK:
                    {
                        HRESULT hr = ERROR_SUCCESS;
                        TCHAR szFullFileName[_MAX_PATH + 1];
                        TCHAR szFileName[_MAX_PATH + 1];
                        TCHAR szNoSpaces[_MAX_PATH + 1];
                        ZeroMemory(szFullFileName, sizeof(szFullFileName));
                        ZeroMemory(szFileName, sizeof(szFileName));
                        GetDlgItemText(hDlg, IDC_EDIT_FILENAME, szFileName, _MAX_PATH);
                        GetDlgItemText(hDlg, IDC_EDIT_PATH, szFullFileName, _MAX_PATH);
                        CString strDefaultExt;
                        strDefaultExt.LoadString(_Module.GetResourceInstance(), IDS_DEFAULT_SAVED_EXT);

                        RemoveSpaces(szNoSpaces, sizeof(szNoSpaces), szFileName);
						StringCbCopy(szNoSpaces, sizeof(szNoSpaces), szFileName);
                        RemoveSpaces(szNoSpaces, sizeof(szNoSpaces), szFullFileName);
						StringCbCopy(szFullFileName, sizeof(szFullFileName), szNoSpaces);
                        if (IsSpaces(szFileName))
                        {
                            // There was no filename specified.
                            EditShowBalloon(GetDlgItem(hDlg, IDC_EDIT_FILENAME),_Module.GetResourceInstance(),IDS_FILENAME_MISSING);
                        }
                        else if (0 == _tcsicmp(szFullFileName,_T("")))
                        {
                            // There was no filename specified.
                            EditShowBalloon(GetDlgItem(hDlg, IDC_EDIT_FILENAME),_Module.GetResourceInstance(),IDS_FILENAME_MISSING);
                        }
                        else
                        {
                            // check for % characters
                            // if there are any, expand them.
                            LPTSTR pch = _tcschr( (LPTSTR) szFullFileName, _T('%'));
                            if (pch)
                            {
                                if (pcdParams->ConnectionInfo.IsLocal)
                                {
                                    if (pch)
                                    {
                                        TCHAR szValue[_MAX_PATH + 1];
		                                StringCbCopy(szValue, sizeof(szValue), szFullFileName);
                                        if (!ExpandEnvironmentStrings( (LPCTSTR)szFullFileName, szValue, sizeof(szValue)/sizeof(TCHAR)))
                                            {
				                                StringCbCopy(szValue, sizeof(szValue), szFullFileName);
			                                }
                                            StringCbCopy(szFullFileName, sizeof(szFullFileName), szValue);
                                    }
                                }
                                else
                                {
                                    // we don't support % characters on remote systems.
                                    EditShowBalloon(GetDlgItem(hDlg, IDC_EDIT_PATH),_Module.GetResourceInstance(),IDS_FILENAME_NOREMOTE_EXPAND);
                                    return FALSE;
                                }
                            }

                            // Check if valid folderpath
                            if (!IsValidFolderPath(GetDlgItem(hDlg, IDC_EDIT_PATH),szFullFileName,TRUE))
                            {
                                return FALSE;
                            }

                            AddPath(szFullFileName,sizeof(szFullFileName),szFileName);

                            // Check if file has an extension.
                            // if there is none, then add the .xml extention.
                            AddFileExtIfNotExist(szFullFileName,sizeof(szFullFileName),strDefaultExt);

                            if (!IsValidName(szFileName))
                            {
                                EditShowBalloon(GetDlgItem(hDlg, IDC_EDIT_FILENAME),_Module.GetResourceInstance(),IDS_FILENAME_INVALID);
                                return FALSE;
                            }

                            if (pcdParams->ConnectionInfo.IsLocal)
                            {
                                // Check if the file already exists...
                                if (IsFileExist(szFullFileName))
                                {
                                    // check if the filename is a directory!
                                    if (IsFileADirectory(szFullFileName))
                                    {
                                        EditShowBalloon(GetDlgItem(hDlg, IDC_EDIT_FILENAME),_Module.GetResourceInstance(),IDS_FILE_IS_A_DIR);
                                        return FALSE;
                                    }
                                    else
                                    {
                                        if (FALSE == AnswerIsYes(hDlg,IDS_REPLACE_FILE,szFullFileName))
                                        {
                                            return FALSE;
                                        }
                                    }
                                }
                            }
                            else
                            {
                                // Check if the file already exists...
								// security percaution:decypt password before using it...then zero out memory that used it
								if (pcdParams->ConnectionInfo.pszUserPasswordEncrypted)
								{
									LPWSTR lpwstrTemp = NULL;

									if (FAILED(DecryptMemoryPassword((LPWSTR) pcdParams->ConnectionInfo.pszUserPasswordEncrypted,&lpwstrTemp,pcdParams->ConnectionInfo.cbUserPasswordEncrypted)))
									{
										return FALSE;
									}

									if (IsFileExistRemote(pcdParams->ConnectionInfo.pszMachineName,szFullFileName,pcdParams->ConnectionInfo.pszUserName,lpwstrTemp))
									{
										if (FALSE == AnswerIsYes(hDlg,IDS_REPLACE_FILE,szFullFileName))
										{
											return FALSE;
										}
									}

									if (lpwstrTemp)
									{
										// security percaution:Make sure to zero out memory that temporary password was used for.
										SecureZeroMemory(lpwstrTemp,pcdParams->ConnectionInfo.cbUserPasswordEncrypted);
										LocalFree(lpwstrTemp);
										lpwstrTemp = NULL;
									}
								}
                            }

                            // Perform the action...
                            // and then if successfull proceed to close the dialog...

                            // check if everything is filled in.
                            // if not then warn user and do nothing.
                            BOOL bUsingPassword = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_CHECK_ENCRYPT));
                            if (bUsingPassword)
                            {
                                TCHAR szPW1[PWLEN + 1];
                                TCHAR szPW2[PWLEN + 1];
                                SecureZeroMemory(szPW1, sizeof(szPW1));
                                SecureZeroMemory(szPW2, sizeof(szPW2));

                                GetDlgItemText(hDlg, IDC_EDIT_PASSWORD1, szPW1, PWLEN);
                                GetDlgItemText(hDlg, IDC_EDIT_PASSWORD2, szPW2, PWLEN);
                                if ( _tcscmp(szPW1, szPW2) ) 
                                {
                                    // passwords do not match
                                    EditShowBalloon(GetDlgItem(hDlg, IDC_EDIT_PASSWORD1),_Module.GetResourceInstance(),IDS_PASSWORDS_NO_MATCH);
                                    return FALSE;
                                }
                                else 
                                {
                                    hr = DoExportConfigToFile(&pcdParams->ConnectionInfo,(BSTR) szFullFileName,(BSTR) pcdParams->pszMetabasePath,szPW1,pcdParams->dwExportFlags);
                                }
                            }
                            else
                            {
                                hr = DoExportConfigToFile(&pcdParams->ConnectionInfo,(BSTR) szFullFileName,(BSTR) pcdParams->pszMetabasePath,NULL,pcdParams->dwExportFlags);
                            }

                            if (FAILED(hr))
                            {
                                if (hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND))
                                {
                                    //0x80070003
                                    EditShowBalloon(GetDlgItem(hDlg, IDC_EDIT_PATH),_Module.GetResourceInstance(),IDS_FILE_NOT_FOUND);
                                }
                                else
                                {
                                    
                                    // we failed.
                                    // so keep the dialog open and do nothing
                                    CError err(hr);
                                    err.MessageBox();
                                }
                                return FALSE;
                            }
                            else
                            {
                                TCHAR szNoSpaces2[_MAX_PATH + 1];
                                ZeroMemory(szFullFileName, sizeof(szFullFileName));
                                GetDlgItemText(hDlg, IDC_EDIT_PATH, szFullFileName, _MAX_PATH);
                                RemoveSpaces(szNoSpaces2, sizeof(szNoSpaces2), szFullFileName);
								StringCbCopy(szFullFileName, sizeof(szFullFileName), szNoSpaces2);
                                if (0 != _tcscmp(szFullFileName, _T("")))
                                {
                                    DefaultValueSettingsSave((LPCTSTR) pcdParams->ConnectionInfo.pszMachineName,LAST_USED_EXPORT_PATH,szFullFileName);
                                }
                                EndDialog(hDlg, (int)wParam);
                                return TRUE;
                            }
                        }
                        return FALSE;
                    }

                case IDC_CHECK_ENCRYPT:
                    {
                    // user is toggling the checkbox.
                    BOOL bUsingPassword = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_CHECK_ENCRYPT));
                    // enable/disable edit label
                    EnableWindow(GetDlgItem(hDlg,IDC_STATIC_PASSWORD1), bUsingPassword);
                    EnableWindow(GetDlgItem(hDlg,IDC_STATIC_PASSWORD2), bUsingPassword);
                    // enable/disable edit boxes
                    EnableWindow(GetDlgItem(hDlg,IDC_EDIT_PASSWORD1), bUsingPassword);
                    EnableWindow(GetDlgItem(hDlg,IDC_EDIT_PASSWORD2), bUsingPassword);

                    SetControlStates(hDlg,msg,wParam,pcdParams);
                    return TRUE;
                    }
            }
            break;
    }
    return FALSE;
}

HRESULT DoExportConfigToFile(PCONNECTION_INFO pConnectionInfo,BSTR bstrFileNameAndPath,BSTR bstrMetabasePath,BSTR bstrPassword,DWORD dwExportFlags)
{
    HRESULT hr = E_FAIL;
    IMSAdminBase *pIMSAdminBase = NULL;
    IMSAdminBase2 *pIMSAdminBase2 = NULL;
	LPWSTR lpwstrTempPassword = NULL;

    if (!pConnectionInfo)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

	if (pConnectionInfo->pszUserPasswordEncrypted)
	{
		if (FAILED(DecryptMemoryPassword((LPWSTR) pConnectionInfo->pszUserPasswordEncrypted,&lpwstrTempPassword,pConnectionInfo->cbUserPasswordEncrypted)))
		{
			return HRESULT_FROM_WIN32(ERROR_DECRYPTION_FAILED);
		}
	}

    CComAuthInfo auth(pConnectionInfo->pszMachineName,pConnectionInfo->pszUserName,lpwstrTempPassword);

    if (!bstrFileNameAndPath)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    // buffer overflow paranoia, make sure it's less than 255 characters long
    if (wcslen(bstrFileNameAndPath) > (_MAX_PATH)){return RPC_S_STRING_TOO_LONG;}
    if (wcslen(bstrMetabasePath) > (_MAX_PATH)){return RPC_S_STRING_TOO_LONG;}

    if (bstrPassword)
    {
        if (wcslen(bstrPassword) > (_MAX_PATH)){return RPC_S_STRING_TOO_LONG;}
    }

    if(FAILED(hr = CoInitializeEx(NULL, COINIT_MULTITHREADED)))
    {
        if(FAILED(hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED)))
        {
            return hr;
        }
    }

    // RPC_C_AUTHN_LEVEL_DEFAULT       0 
    // RPC_C_AUTHN_LEVEL_NONE          1 
    // RPC_C_AUTHN_LEVEL_CONNECT       2 
    // RPC_C_AUTHN_LEVEL_CALL          3 
    // RPC_C_AUTHN_LEVEL_PKT           4 
    // RPC_C_AUTHN_LEVEL_PKT_INTEGRITY 5 
    // RPC_C_AUTHN_LEVEL_PKT_PRIVACY   6 
    //COSERVERINFO * pcsiName = auth.CreateServerInfoStruct(RPC_C_AUTHN_LEVEL_PKT_PRIVACY);
    COSERVERINFO * pcsiName = auth.CreateServerInfoStruct(RPC_C_AUTHN_LEVEL_DEFAULT);
    MULTI_QI res[1] = 
    {
        {&IID_IMSAdminBase, NULL, 0}
    };

    if (FAILED(hr = CoCreateInstanceEx(CLSID_MSAdminBase,NULL,CLSCTX_ALL,pcsiName,1,res)))
    {
        goto DoExportConfigToFile_Exit;
    }

    pIMSAdminBase = (IMSAdminBase *)res[0].pItf;
    if (auth.UsesImpersonation())
    {
        if (FAILED(hr = auth.ApplyProxyBlanket(pIMSAdminBase)))
        {
            goto DoExportConfigToFile_Exit;
        }

        // There is a remote IUnknown interface that lurks behind IUnknown.
        // If that is not set, then the Release call can return access denied.
        IUnknown * pUnk = NULL;
        hr = pIMSAdminBase->QueryInterface(IID_IUnknown, (void **)&pUnk);
        if(FAILED(hr))
        {
            return hr;
        }
        if (FAILED(hr = auth.ApplyProxyBlanket(pUnk)))
        {
            goto DoExportConfigToFile_Exit;
        }
        pUnk->Release();pUnk = NULL;
    }

     if (FAILED(hr = pIMSAdminBase->QueryInterface(IID_IMSAdminBase2, (void **)&pIMSAdminBase2)))
    {
        goto DoExportConfigToFile_Exit;
    }

    if (auth.UsesImpersonation())
    {
        if (FAILED(hr = auth.ApplyProxyBlanket(pIMSAdminBase2)))
        {
            goto DoExportConfigToFile_Exit;
        }
    }
    else
    {
        // the local call needs min RPC_C_IMP_LEVEL_IMPERSONATE
        // for the pIMSAdminBase2 objects Import/Export functions!
        if (FAILED(hr = SetBlanket(pIMSAdminBase2)))
        {
            //goto DoExportConfigToFile_Exit;
        }
    }

    //IISDebugOutput(_T("Export:bstrPassword=%s,bstrFileNameAndPath=%s,bstrMetabasePath=%s,dwExportFlags=%d\r\n"),bstrPassword,bstrFileNameAndPath,bstrMetabasePath,dwExportFlags);
    IISDebugOutput(_T("Export:FileName=%s,MetabasePath=%s,ExportFlags=%d\r\n"),bstrFileNameAndPath,bstrMetabasePath,dwExportFlags);
    hr = pIMSAdminBase2->Export(bstrPassword,bstrFileNameAndPath,bstrMetabasePath,dwExportFlags);

DoExportConfigToFile_Exit:
    IISDebugOutput(_T("Export:ret=0x%x\r\n"),hr);
    auth.FreeServerInfoStruct(pcsiName);
	if (lpwstrTempPassword)
	{
		// security percaution:Make sure to zero out memory that temporary password was used for.
		SecureZeroMemory(lpwstrTempPassword,pConnectionInfo->cbUserPasswordEncrypted);
		LocalFree(lpwstrTempPassword);
		lpwstrTempPassword = NULL;
	}
    if (pIMSAdminBase2) 
    {
        pIMSAdminBase2->Release();
        pIMSAdminBase2 = NULL;
    }
    if (pIMSAdminBase) 
    {
        pIMSAdminBase->Release();
        pIMSAdminBase = NULL;
    }
    CoUninitialize();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\iisuiobj\iisdebug.h ===
#include "stdafx.h"
#include "debugdefs.h"

extern g_iDebugOutputLevel;

#if defined(_DEBUG) || DBG
	#define DEBUG_FLAG
#endif

#ifdef DEBUG_FLAG
    inline void _cdecl DebugTraceHelp(DWORD_PTR dwWinHelpID)
    {
        // Only do this if the flag is set.
        if (0 != g_iDebugOutputLevel)
        {
			if (DEBUG_FLAG_HELP & g_iDebugOutputLevel)
			{
				TCHAR szBuffer[30];
				_stprintf(szBuffer,_T("WinHelp:0x%x,%d\r\n"),dwWinHelpID,dwWinHelpID);
				OutputDebugString(szBuffer);
			}
		}
        return;
    }

    inline void _cdecl DebugTrace(LPTSTR lpszFormat, ...)
    {
        // Only do this if the flag is set.
        if (0 != g_iDebugOutputLevel)
        {
			if (DEBUG_FLAG_MODULE_IISUIOBJ & g_iDebugOutputLevel)
			{
				int nBuf;
				TCHAR szBuffer[_MAX_PATH];
				va_list args;
				va_start(args, lpszFormat);

				nBuf = _vsntprintf(szBuffer, sizeof(szBuffer)/sizeof(szBuffer[0]), lpszFormat, args);

				OutputDebugString(szBuffer);
				va_end(args);

				// if it does not end if '\r\n' then make one.
				int nLen = _tcslen(szBuffer);
				if (szBuffer[nLen-1] != _T('\n')){OutputDebugString(_T("\r\n"));}
			}
        }
    }
#else
    inline void _cdecl DebugTraceHelp(DWORD_PTR dwWinHelpID){}
    inline void _cdecl DebugTrace(LPTSTR , ...){}
#endif

void GetOutputDebugFlag(void);

#define IISDebugOutput DebugTrace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\iisuiobj\importexportconfig.h ===
// ImportExportConfig.h : Declaration of the CImportExportConfig

#ifndef __IMPORTEXPORTCONFIG_H_
#define __IMPORTEXPORTCONFIG_H_

#include "resource.h"       // main symbols
#include "common.h"

/////////////////////////////////////////////////////////////////////////////
// CImportExportConfig
class ATL_NO_VTABLE CImportExportConfig : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CImportExportConfig, &CLSID_ImportExportConfig>,
	public IDispatchImpl<IImportExportConfig, &IID_IImportExportConfig, &LIBID_IISUIOBJLib>
{
public:
	CImportExportConfig()
	{
        m_dwImportFlags = 0;
        m_dwExportFlags = MD_EXPORT_INHERITED;
		m_strUserPasswordEncrypted = NULL;
		m_cbUserPasswordEncrypted = 0;
	}

	~CImportExportConfig()
	{
		if (m_strUserPasswordEncrypted)
		{
			if (m_cbUserPasswordEncrypted > 0)
			{
				SecureZeroMemory(m_strUserPasswordEncrypted,m_cbUserPasswordEncrypted);
			}
			LocalFree(m_strUserPasswordEncrypted);
			m_strUserPasswordEncrypted = NULL;
			m_cbUserPasswordEncrypted = 0;
		}
	}

DECLARE_REGISTRY_RESOURCEID(IDR_IMPORTEXPORTCONFIG)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CImportExportConfig)
	COM_INTERFACE_ENTRY(IImportExportConfig)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IImportExportConfig
public:
	STDMETHOD(get_ExportFlags)(/*[out, retval]*/ DWORD *pVal);
	STDMETHOD(put_ExportFlags)(/*[in]*/ DWORD newVal);
	STDMETHOD(get_ImportFlags)(/*[out, retval]*/ DWORD *pVal);
	STDMETHOD(put_ImportFlags)(/*[in]*/ DWORD newVal);
	STDMETHOD(ImportConfigFromFileUI)(/*[in]*/ BSTR bstrMetabasePath,/*[in]*/ BSTR bstrKeyType);
	STDMETHOD(ImportConfigFromFile)(/*[in]*/ BSTR bstrFileNameAndPath,/*[in]*/ BSTR SourcePath, /*[in]*/ BSTR bstrDestinationPath, /*[in]*/ BSTR bstrPassword);
	STDMETHOD(ExportConfigToFileUI)(/*[in]*/ BSTR bstrMetabasePath);
	STDMETHOD(ExportConfigToFile)(/*[in]*/ BSTR bstrFileNameAndPath, /*[in]*/ BSTR bstrMetabasePath, /*[in]*/ BSTR bstrPassword);
	STDMETHOD(put_UserPassword)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_UserName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_UserName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_MachineName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_MachineName)(/*[in]*/ BSTR newVal);

private:
    CComPtr<IImportExportConfig> m_pObj;
    CString m_strMachineName;
    CString m_strUserName;

	LPWSTR  m_strUserPasswordEncrypted;
	DWORD   m_cbUserPasswordEncrypted;

    CString m_strMetabasePath;
    CString m_strKeyType;
    DWORD   m_dwImportFlags;
    DWORD   m_dwExportFlags;
};

#endif //__IMPORTEXPORTCONFIG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\iisuiobj\iisuiobj.cpp ===
// IISUIObj.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for IISUIObj.idl by adding the following 
//      files to the Outputs.
//          IISUIObj_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f IISUIObjps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "IISUIObj.h"
#include "dlldatax.h"

#include "IISUIObj_i.c"
#include "ImportExportConfig.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_ImportExportConfig, CImportExportConfig)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_IISUIOBJLib);
        DisableThreadLibraryCalls(hInstance);
        GetOutputDebugFlag();
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\iisuiobj\importexportconfig.cpp ===
// ImportExportConfig.cpp : Implementation of CImportExportConfig
#include "stdafx.h"
#include "IISUIObj.h"
#include "ImportExportConfig.h"
#include "ExportUI.h"
#include "ImportUI.h"
#include "util.h"
#include <strsafe.h>
#include "cryptpass.h"

/////////////////////////////////////////////////////////////////////////////
// CImportExportConfig

// Checks a pointer which should be non NULL - can be used as follows.
#define CheckPointer(p,ret) {if((p)==NULL) return (ret);}
//   HRESULT Foo(VOID *pBar)
//   {
//       CheckPointer(pBar,E_INVALIDARG)
//   }
//
//   Or if the function returns a boolean
//
//   BOOL Foo(VOID *pBar)
//   {
//       CheckPointer(pBar,FALSE)
//   }

HRESULT ValidateBSTRIsntNULL(BSTR pbstrString)
{
    if( !pbstrString ) return E_INVALIDARG;
    if( pbstrString[0] == 0 ) return E_INVALIDARG;
    return NOERROR;
}


STDMETHODIMP CImportExportConfig::get_MachineName(BSTR *pVal)
{
	CheckPointer(pVal, E_POINTER);
	_bstr_t bstrTempName = (LPCTSTR) m_strMachineName;
	*pVal = bstrTempName.copy();
	return S_OK;
}

STDMETHODIMP CImportExportConfig::put_MachineName(BSTR newVal)
{
	HRESULT hr = S_OK;
    if(FAILED(hr = ValidateBSTRIsntNULL(newVal))){return hr;}

    // buffer overflow paranoia, make sure it's less than 255 characters long
    if (wcslen(newVal) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    m_strMachineName = newVal;
	return S_OK;
}

STDMETHODIMP CImportExportConfig::get_UserName(BSTR *pVal)
{
	CheckPointer(pVal, E_POINTER);
	_bstr_t bstrTempName = (LPCTSTR) m_strUserName;
	*pVal = bstrTempName.copy();
	return S_OK;
}

STDMETHODIMP CImportExportConfig::put_UserName(BSTR newVal)
{
	HRESULT hr = S_OK;
    if(FAILED(hr = ValidateBSTRIsntNULL(newVal))){return hr;}

    // buffer overflow paranoia, make sure it's less than 255 characters long
    if (wcslen(newVal) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    m_strUserName = newVal;
	return S_OK;
}

STDMETHODIMP CImportExportConfig::put_UserPassword(BSTR newVal)
{
	HRESULT hr = S_OK;
    if(FAILED(hr = ValidateBSTRIsntNULL(newVal))){return hr;}

    // buffer overflow paranoia, make sure it's less than 255 characters long
    if (wcslen(newVal) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

	m_strUserPasswordEncrypted = NULL;
	m_cbUserPasswordEncrypted = 0;

	// encrypt the password in memory (CryptProtectMemory)
	// this way if the process get's paged out to the swapfile,
	// the password won't be in clear text.
	if (FAILED(EncryptMemoryPassword(newVal,&m_strUserPasswordEncrypted,&m_cbUserPasswordEncrypted)))
	{
		return E_FAIL;
	}
    return S_OK;
}

STDMETHODIMP CImportExportConfig::ExportConfigToFile(BSTR bstrFileNameAndPath,BSTR bstrMetabasePath,BSTR bstrPassword)
{
	HRESULT hr = S_OK;
    if(FAILED(hr = ValidateBSTRIsntNULL(bstrFileNameAndPath))){return hr;}
	if(FAILED(hr = ValidateBSTRIsntNULL(bstrMetabasePath))){return hr;}
	if(FAILED(hr = ValidateBSTRIsntNULL(bstrPassword))){return hr;}

    CONNECTION_INFO ConnectionInfo;
    memset((void *)&ConnectionInfo,0,sizeof(CONNECTION_INFO));
    ConnectionInfo.IsLocal         = IsLocalComputer(m_strMachineName);
    ConnectionInfo.pszMachineName   = m_strMachineName;
    ConnectionInfo.pszUserName     = m_strUserName;
    ConnectionInfo.pszUserPasswordEncrypted = m_strUserPasswordEncrypted;
	ConnectionInfo.cbUserPasswordEncrypted = m_cbUserPasswordEncrypted;

    return DoExportConfigToFile(&ConnectionInfo,bstrFileNameAndPath,bstrMetabasePath,bstrPassword,m_dwExportFlags);;
}

STDMETHODIMP CImportExportConfig::ExportConfigToFileUI(BSTR bstrMetabasePath)
{
	HRESULT hr = S_OK;
    if(FAILED(hr = ValidateBSTRIsntNULL(bstrMetabasePath))){return hr;}

    m_strMetabasePath = bstrMetabasePath;

    // verify Parameters
    if (_tcslen(m_strMachineName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    if (_tcslen(m_strMetabasePath) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

	COMMONDLGPARAM dlgParam;
    memset((void *)&dlgParam,0,sizeof(COMMONDLGPARAM));

    // Copy into a structure so that we can pass it to the dialog function.
    dlgParam.ConnectionInfo.IsLocal      = IsLocalComputer(m_strMachineName);
	dlgParam.ConnectionInfo.pszMachineName = (LPCTSTR) m_strMachineName;
    dlgParam.ConnectionInfo.pszUserName = (LPCTSTR) m_strUserName;
    dlgParam.ConnectionInfo.pszUserPasswordEncrypted = (LPCTSTR) m_strUserPasswordEncrypted;
	dlgParam.ConnectionInfo.cbUserPasswordEncrypted = m_cbUserPasswordEncrypted;
    dlgParam.pszMetabasePath = (LPCTSTR) m_strMetabasePath;
    dlgParam.pszKeyType = NULL;
    dlgParam.dwImportFlags = m_dwImportFlags;
    dlgParam.dwExportFlags = m_dwExportFlags;

    if (FALSE == DialogBoxParam((HINSTANCE) _Module.m_hInst, MAKEINTRESOURCE(IDD_DIALOG_EXPORT), GetActiveWindow(), ShowExportDlgProc, (LPARAM) &dlgParam))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        return S_OK;
    }
}

STDMETHODIMP CImportExportConfig::ImportConfigFromFile(BSTR bstrFileNameAndPath, BSTR bstrSourcePath, BSTR bstrDestinationPath, BSTR bstrPassword)
{
	HRESULT hr = S_OK;
    if(FAILED(hr = ValidateBSTRIsntNULL(bstrFileNameAndPath))){return hr;}
	if(FAILED(hr = ValidateBSTRIsntNULL(bstrSourcePath))){return hr;}
	if(FAILED(hr = ValidateBSTRIsntNULL(bstrDestinationPath))){return hr;}
	if(FAILED(hr = ValidateBSTRIsntNULL(bstrPassword))){return hr;}

    CONNECTION_INFO ConnectionInfo;
    memset((void *)&ConnectionInfo,0,sizeof(CONNECTION_INFO));
    ConnectionInfo.IsLocal         = IsLocalComputer(m_strMachineName);
    ConnectionInfo.pszMachineName   = m_strMachineName;
    ConnectionInfo.pszUserName     = m_strUserName;
    ConnectionInfo.pszUserPasswordEncrypted = m_strUserPasswordEncrypted;
	ConnectionInfo.cbUserPasswordEncrypted = m_cbUserPasswordEncrypted;

    return DoImportConfigFromFile(&ConnectionInfo,bstrFileNameAndPath,bstrSourcePath,bstrDestinationPath,bstrPassword,m_dwImportFlags);
}
STDMETHODIMP CImportExportConfig::ImportConfigFromFileUI(BSTR bstrMetabasePath,BSTR bstrKeyType)
{
	HRESULT hr = S_OK;
    if(FAILED(hr = ValidateBSTRIsntNULL(bstrMetabasePath))){return hr;}
	if(FAILED(hr = ValidateBSTRIsntNULL(bstrKeyType))){return hr;}

    m_strMetabasePath = bstrMetabasePath;
    m_strKeyType = bstrKeyType;

    if (_tcslen(m_strMachineName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    if (_tcslen(m_strMetabasePath) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    if (_tcslen(m_strKeyType) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

	COMMONDLGPARAM dlgParam;
    memset((void *)&dlgParam,0,sizeof(COMMONDLGPARAM));

    // Copy into a structure so that we can pass it to the dialog function.
    dlgParam.ConnectionInfo.IsLocal      = IsLocalComputer(m_strMachineName);
	dlgParam.ConnectionInfo.pszMachineName = (LPCTSTR) m_strMachineName;
    dlgParam.ConnectionInfo.pszUserName = (LPCTSTR) m_strUserName;
    dlgParam.ConnectionInfo.pszUserPasswordEncrypted = (LPCTSTR) m_strUserPasswordEncrypted;
	dlgParam.ConnectionInfo.cbUserPasswordEncrypted = m_cbUserPasswordEncrypted;
    dlgParam.pszMetabasePath = (LPCTSTR) m_strMetabasePath;
    dlgParam.pszKeyType = (LPCTSTR) m_strKeyType;
    dlgParam.dwImportFlags = m_dwImportFlags;
    dlgParam.dwExportFlags = m_dwExportFlags;
   
    if (FALSE == DialogBoxParam((HINSTANCE) _Module.m_hInst, MAKEINTRESOURCE(IDD_DIALOG_IMPORT), GetActiveWindow(), ShowImportDlgProc, (LPARAM) &dlgParam))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        return S_OK;
    }
}

STDMETHODIMP CImportExportConfig::get_ImportFlags(DWORD *pVal)
{
	CheckPointer(pVal, E_POINTER);
    *pVal = m_dwImportFlags;
	return S_OK;
}

STDMETHODIMP CImportExportConfig::put_ImportFlags(DWORD newVal)
{
    // 0 = default
    //#define MD_IMPORT_INHERITED             0x00000001
    //#define MD_IMPORT_NODE_ONLY             0x00000002
    //#define MD_IMPORT_MERGE                 0x00000004
    m_dwImportFlags = newVal;
	return S_OK;
}

STDMETHODIMP CImportExportConfig::get_ExportFlags(DWORD *pVal)
{
	CheckPointer(pVal, E_POINTER);
    *pVal = m_dwExportFlags;
	return S_OK;
}

STDMETHODIMP CImportExportConfig::put_ExportFlags(DWORD newVal)
{
    //#define MD_EXPORT_INHERITED             0x00000001 (default)
    //#define MD_EXPORT_NODE_ONLY             0x00000002
    m_dwExportFlags = newVal;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\iisuiobj\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\iisuiobj\importui.h ===
// ImportUI.h : Declaration of the CImportUI

#ifndef __IMPORTUI_H_
#define __IMPORTUI_H_

#include "resource.h"       // main symbols
#include <atlhost.h>

INT_PTR CALLBACK ShowImportDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ShowPasswordDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ShowSiteExistsDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ShowVDirExistsDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ShowAppPoolExistsDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

HRESULT DoImportConfigFromFile(PCONNECTION_INFO pConnectionInfo,BSTR bstrFileNameAndPath,BSTR bstrMetabaseSourcePath,BSTR bstrMetabaseDestinationPath,BSTR bstrPassword,DWORD dwImportFlags);
HRESULT DoEnumDataFromFile(PCONNECTION_INFO pConnectionInfo,BSTR bstrFileNameAndPath,BSTR bstrPathType,WCHAR ** pszMetabaseMultiszList);
void    ImportDlgEnableButtons(HWND hDlg);
BOOL    OnImportOK(HWND hDlg,PCONNECTION_INFO pConnectionInfo,LPCTSTR szKeyType,LPCTSTR szCurrentMetabasePath,DWORD dwImportFlags);
BOOL GetNewDestinationPathIfEntryExists(HWND hDlg,PCONNECTION_INFO pConnectionInfo,LPCTSTR szKeyType,LPTSTR * pszDestinationPathMungeAble,DWORD * pcbDestinationPathMungeAble,BOOL * bOverWriteSettings);
HRESULT CleanDestinationPathForVdirs(LPCTSTR szKeyType,LPCTSTR szCurrentMetabasePath,LPTSTR * pszDestinationPathMungeMe,DWORD * pcbDestinationPathMungeMe);
HRESULT FillListBoxWithMultiSzData(HWND hList,LPCTSTR szKeyType,WCHAR * pszBuffer);
HRESULT FixupImportAppRoot(PCONNECTION_INFO pConnectionInfo,LPCWSTR pszSourcePath,LPCWSTR pszDestPath);

#endif //__IMPORTUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\iisuiobj\remoteenv.h ===
#if !defined(AFX_REMOTEENV_H__1B164072_460A_432a_99C0_26941B44FC53__INCLUDED_)
#define AFX_REMOTEENV_H__1B164072_460A_432a_99C0_26941B44FC53__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////

class CRemoteExpandEnvironmentStrings
{
public:
    CRemoteExpandEnvironmentStrings();
    ~CRemoteExpandEnvironmentStrings();
    BOOL SetMachineName(IN LPCTSTR szMachineName);
    BOOL SetUserName(IN LPCTSTR szUserName);
    BOOL SetUserPassword(IN LPCTSTR szUserPassword);
    BOOL NewRemoteEnvironment();
    void DeleteRemoteEnvironment();
    NET_API_STATUS RemoteExpandEnvironmentStrings(IN LPCTSTR UnexpandedString,OUT LPTSTR * ExpandedString);

protected:
    PVOID m_pEnvironment;
    LPTSTR m_lpszUncServerName;
    LPTSTR m_lpszUserName;
    LPTSTR m_lpszUserPasswordEncrypted;
	DWORD  m_cbUserPasswordEncrypted;

private:
    DWORD SetOtherEnvironmentValues(void **pEnv);
    BOOL  SetEnvironmentVariables(void **pEnv);
    BOOL  IsLocalMachine(LPCTSTR psz);

    BOOL  SetEnvironmentVariableInBlock(void **pEnv, LPTSTR lpVariable,LPTSTR lpValue, BOOL bOverwrite);
    BOOL  SetUserEnvironmentVariable(void **pEnv, LPTSTR lpVariable, LPTSTR lpValue, BOOL bOverwrite);
    BOOL  BuildEnvironmentPath(void **pEnv, LPTSTR lpPathVariable, LPTSTR lpPathValue);
    DWORD ExpandUserEnvironmentStrings(void *pEnv, LPTSTR lpSrc, LPTSTR lpDst, DWORD nSize);
    DWORD GetRegKeyMaxSizes(IN HKEY WinRegHandle,OUT LPDWORD MaxKeywordSize OPTIONAL,OUT LPDWORD MaxValueSize OPTIONAL);
};

/////////////////////////////////////////////////////////////////////////////

#endif // !defined(AFX_REMOTEENV_H__1B164072_460A_432a_99C0_26941B44FC53__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\iisuiobj\remoteenv.cpp ===
#include "stdafx.h"
#include "RemoteEnv.h"
#include "common.h"
#include <strsafe.h>
#include "cryptpass.h"

typedef LONG NTSTATUS;

#define MAX_ENV_VALUE_LEN               1024

#define DEFAULT_ROOT_KEY                HKEY_LOCAL_MACHINE
#define REG_PATH_TO_SYSROOT             TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion")
#define REG_PATH_TO_COMMON_FOLDERS      TEXT("Software\\Microsoft\\Windows\\CurrentVersion")
#define REG_PATH_TO_ENV                 TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Environment")

#define PATH_VARIABLE                   TEXT("Path")
#define LIBPATH_VARIABLE                TEXT("LibPath")
#define OS2LIBPATH_VARIABLE             TEXT("Os2LibPath")
#define AUTOEXECPATH_VARIABLE           TEXT("AutoexecPath")

#define ENV_KEYWORD_SYSTEMROOT          TEXT("SystemRoot")
#define ENV_KEYWORD_PROGRAMFILESDIR     TEXT("ProgramFilesDir")
#define ENV_KEYWORD_COMMONFILESDIR      TEXT("CommonFilesDir")
#define ENV_KEYWORD_PROGRAMFILESDIR_X86 TEXT("ProgramFilesDir (x86)")
#define ENV_KEYWORD_COMMONFILESDIR_X86  TEXT("CommonFilesDir (x86)")

#define PROGRAMFILES_VARIABLE           TEXT("ProgramFiles")
#define COMMONPROGRAMFILES_VARIABLE     TEXT("CommonProgramFiles")
#define PROGRAMFILESX86_VARIABLE        TEXT("ProgramFiles(x86)")
#define COMMONPROGRAMFILESX86_VARIABLE  TEXT("CommonProgramFiles(x86)")

CRemoteExpandEnvironmentStrings::CRemoteExpandEnvironmentStrings()
{
    m_pEnvironment = NULL;
    m_lpszUncServerName = NULL;
    m_lpszUserName = NULL;
    m_lpszUserPasswordEncrypted = NULL;
	m_cbUserPasswordEncrypted = 0;
    return;
}

CRemoteExpandEnvironmentStrings::~CRemoteExpandEnvironmentStrings()
{
    DeleteRemoteEnvironment();
    
    if (m_lpszUncServerName)
    {
        LocalFree(m_lpszUncServerName);
        m_lpszUncServerName = NULL;
    }
    if (m_lpszUserName)
    {
        LocalFree(m_lpszUserName);
        m_lpszUserName = NULL;
    }
    if (m_lpszUserPasswordEncrypted)
    {
		if (m_cbUserPasswordEncrypted > 0)
		{
			// erase any password we may have in memory -- even though it's encrypted in memory
			SecureZeroMemory(m_lpszUserPasswordEncrypted,m_cbUserPasswordEncrypted);
		}
        LocalFree(m_lpszUserPasswordEncrypted);
    }
	m_lpszUserPasswordEncrypted = NULL;
	m_cbUserPasswordEncrypted = 0;

    return;
}

BOOL
CRemoteExpandEnvironmentStrings::NewRemoteEnvironment()
{
    BOOL bReturn = FALSE;

    // already have a cached one, use that...
    if (m_pEnvironment)
    {
        bReturn = TRUE;
    }
    else
    {
        //
        // Create a temporary environment, which we'll fill in and let RTL
        // routines do the expansion for us.
        //
        if ( !NT_SUCCESS(RtlCreateEnvironment((BOOLEAN) FALSE,&m_pEnvironment)) ) 
        {
            bReturn = FALSE;
            goto NewRemoteEnvironment_Exit;
        }
    
        SetOtherEnvironmentValues(&m_pEnvironment);
        SetEnvironmentVariables(&m_pEnvironment);
        bReturn = TRUE;
    }

NewRemoteEnvironment_Exit:
    return bReturn;
}

void
CRemoteExpandEnvironmentStrings::DeleteRemoteEnvironment()
{
    if (m_pEnvironment != NULL)
    {
        RtlDestroyEnvironment(m_pEnvironment);
        m_pEnvironment = NULL;
    }
    return;
}


BOOL CRemoteExpandEnvironmentStrings::IsLocalMachine(LPCTSTR psz)
{
    TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD cbComputerName = MAX_COMPUTERNAME_LENGTH + 1;

    if (_tcsicmp(psz,_T("")) == 0)
    {
        // it's empty,
        // yeah it's local machine
        return TRUE;
    }

    // get the actual name of the local machine
    if (!GetComputerName(szComputerName, &cbComputerName))
    {
        return FALSE;
    }

    // compare and return
    if (0 == _tcsicmp(szComputerName, psz))
    {
        return TRUE;
    }

    return FALSE;
}

BOOL
CRemoteExpandEnvironmentStrings::SetUserName(IN LPCTSTR szUserName)
{
    BOOL bReturn = FALSE;
    DWORD dwSize = 0;
    LPTSTR lpszUserNameOriginal =  NULL;

    // free any previous thing we had...
    if (m_lpszUserName)
    {
        // Make a copy of it before we delete it
        dwSize = (_tcslen(m_lpszUserName) + 1) * sizeof(TCHAR);
        lpszUserNameOriginal = (LPTSTR) LocalAlloc(LMEM_ZEROINIT,dwSize);
        if (lpszUserNameOriginal)
        {
			StringCbCopy(lpszUserNameOriginal,dwSize,m_lpszUserName);
        }

        // free up anything we had before
        LocalFree(m_lpszUserName);
        m_lpszUserName = NULL;
    }

    if (_tcsicmp(szUserName,_T("")) == 0)
    {
        bReturn = TRUE;
        goto SetUserName_Exit;
    }

    dwSize = (_tcslen(szUserName) + 1 + 2) * sizeof(TCHAR);
    m_lpszUserName = (LPTSTR) LocalAlloc(LMEM_ZEROINIT,dwSize);
    if (m_lpszUserName)
    {
		StringCbCopy(m_lpszUserName,dwSize,szUserName);
        bReturn = TRUE;
    }

SetUserName_Exit:
    if (lpszUserNameOriginal)
        {LocalFree(lpszUserNameOriginal);lpszUserNameOriginal=NULL;}
    return TRUE;
}

BOOL
CRemoteExpandEnvironmentStrings::SetUserPassword(IN LPCTSTR szUserPassword)
{
    BOOL bReturn = FALSE;

    // free any previous thing we had...
    if (m_lpszUserPasswordEncrypted)
    {
        // free up anything we had before
		if (m_cbUserPasswordEncrypted > 0)
		{
			SecureZeroMemory(m_lpszUserPasswordEncrypted,m_cbUserPasswordEncrypted);
		}
        LocalFree(m_lpszUserPasswordEncrypted);
        m_lpszUserPasswordEncrypted = NULL;
		m_cbUserPasswordEncrypted = 0;
    }

    if (_tcsicmp(szUserPassword,_T("")) == 0)
    {
        bReturn = TRUE;
        goto SetUserPassword_Exit;
    }

	// encrypt the password in memory (CryptProtectMemory)
	// this way if the process get's paged out to the swapfile,
	// the password won't be in clear text.
	if (SUCCEEDED(EncryptMemoryPassword((LPWSTR) szUserPassword,&m_lpszUserPasswordEncrypted,&m_cbUserPasswordEncrypted)))
	{
		bReturn = TRUE;
		goto SetUserPassword_Exit;
	}

SetUserPassword_Exit:
    return bReturn;
}

BOOL
CRemoteExpandEnvironmentStrings::SetMachineName(IN LPCTSTR szMachineName)
{
    BOOL bReturn = FALSE;
    DWORD dwSize = 0;
    LPTSTR lpszUncServerNameOriginal =  NULL;

    // free any previous thing we had...
    if (m_lpszUncServerName)
    {
        // Make a copy of it before we delete it
        dwSize = (_tcslen(m_lpszUncServerName) + 1) * sizeof(TCHAR);
        lpszUncServerNameOriginal = (LPTSTR) LocalAlloc(LMEM_ZEROINIT,dwSize);
        if (lpszUncServerNameOriginal)
        {
			StringCbCopy(lpszUncServerNameOriginal,dwSize,m_lpszUncServerName);
        }

        // free up anything we had before
        LocalFree(m_lpszUncServerName);
        m_lpszUncServerName = NULL;
    }

    if (_tcsicmp(szMachineName,_T("")) == 0)
    {
        bReturn = TRUE;
        goto SetMachineName_Exit;
    }

    // if it's the localmachine name
    // then set it to NULL
    // so that it will be treated as localmachine.
    if (IsLocalMachine(szMachineName))
    {
        m_lpszUncServerName = NULL;
        bReturn = TRUE;
        goto SetMachineName_Exit;
    }

    dwSize = (_tcslen(szMachineName) + 1 + 2) * sizeof(TCHAR);
    m_lpszUncServerName = (LPTSTR) LocalAlloc(LMEM_ZEROINIT,dwSize);
    if (m_lpszUncServerName)
    {
        // check if szMachineName already starts with "\\"
        if (szMachineName[0] == _T('\\') && szMachineName[1] == _T('\\'))
        {
			StringCbCopy(m_lpszUncServerName,dwSize,szMachineName);
        }
        else
        {
			StringCbCopy(m_lpszUncServerName,dwSize,_T("\\\\"));
			StringCbCat(m_lpszUncServerName,dwSize,szMachineName);
        }
        bReturn = TRUE;
    }

    // if the machine name is different from what it was before
    // then delete the current environment if any...
    if (m_lpszUncServerName && lpszUncServerNameOriginal)
    {
        if (0 != _tcsicmp(lpszUncServerNameOriginal,m_lpszUncServerName))
        {
            DeleteRemoteEnvironment();
        }
    }
    else
    {
        DeleteRemoteEnvironment();
    }

SetMachineName_Exit:
    if (lpszUncServerNameOriginal)
        {LocalFree(lpszUncServerNameOriginal);lpszUncServerNameOriginal=NULL;}
    return bReturn;
}

DWORD
CRemoteExpandEnvironmentStrings::GetRegKeyMaxSizes(
    IN  HKEY    WinRegHandle,
    OUT LPDWORD MaxKeywordSize OPTIONAL,
    OUT LPDWORD MaxValueSize OPTIONAL
    )
{
    LONG Error;
    DWORD MaxValueNameLength;
    DWORD MaxValueDataLength;

    Error = RegQueryInfoKey(
            WinRegHandle,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            &MaxValueNameLength,
            &MaxValueDataLength,
            NULL,
            NULL
            );
    if (ERROR_SUCCESS == Error) 
    {
        //
        // MaxValueNameLength is a count of TCHARs.
        // MaxValueDataLength is a count of bytes already.
        //
        MaxValueNameLength = (MaxValueNameLength + 1) * sizeof(TCHAR);

        if (MaxKeywordSize)
        {
            *MaxKeywordSize = MaxValueNameLength;
        }
        if (MaxValueSize)
        {
            *MaxValueSize = MaxValueDataLength;
        }
    }

    return (Error);
}

NET_API_STATUS
CRemoteExpandEnvironmentStrings::RemoteExpandEnvironmentStrings(
    IN  LPCTSTR  UnexpandedString,
    OUT LPTSTR * ValueBufferPtr         // Must be freed by LocalFree().
    )
/*++

Routine Description:

    This function expands a value string (which may include references to
    environment variables).  For instance, an unexpanded string might be:

        %SystemRoot%\System32\Repl\Export

    This could be expanded to:

        c:\nt\System32\Repl\Export

    The expansion makes use of environment variables on m_lpszUncServerName,
    if given.  This allows remote administration of the directory
    replicator.

Arguments:

    m_lpszUncServerName - assumed to NOT BE EXPLICIT LOCAL SERVER NAME.

    UnexpandedString - points to source string to be expanded.

    ValueBufferPtr - indicates a pointer which will be set by this routine.
        This routine will allocate memory for a null-terminated string.
        The caller must free this with LocalFree() or equivalent.


Return Value:

    NET_API_STATUS

--*/
{
    NET_API_STATUS ApiStatus = NO_ERROR;
    LPTSTR         ExpandedString = NULL;
    DWORD          LastAllocationSize = 0;
    NTSTATUS       NtStatus;

    //
    // Check for caller errors.
    //
    if (ValueBufferPtr == NULL) {
        // Can't goto Cleanup here, as it assumes this pointer is valid
        return (ERROR_INVALID_PARAMETER);
    }
    *ValueBufferPtr = NULL;     // assume error until proven otherwise.
    if (UnexpandedString == NULL)
    {
        ApiStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // This is probably just a constant string.
    //
    if (wcschr( UnexpandedString, _T('%') ) == NULL) 
    {
        // Just need to allocate a copy of the input string.
        DWORD dwSize = (_tcslen(UnexpandedString) + 1) * sizeof(TCHAR);
        ExpandedString = (LPTSTR) LocalAlloc(LMEM_ZEROINIT,dwSize);
        if (ExpandedString == NULL)
        {
            ApiStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
        else
        {
            RtlCopyMemory(ExpandedString, UnexpandedString, dwSize);
        }

        // That's all, folks!
        ApiStatus = NO_ERROR;
    //
    // Otherwise, is this local?  Maybe we can
    // handle local expansion the easy (fast) way: using win32 API.
    //
    }
    else if (m_lpszUncServerName == NULL) 
    {

        DWORD CharsRequired = wcslen(UnexpandedString)+1;
        do {

            // Clean up from previous pass.
            if (ExpandedString){LocalFree(ExpandedString);ExpandedString = NULL;}

            // Allocate the memory.
            ExpandedString = (LPTSTR) LocalAlloc(LMEM_FIXED, CharsRequired * sizeof(TCHAR));
            if (ExpandedString == NULL) 
            {
                ApiStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
            LastAllocationSize = CharsRequired * sizeof(TCHAR);

            // Expand string using local env vars.
            CharsRequired = ExpandEnvironmentStrings(UnexpandedString,ExpandedString,LastAllocationSize / sizeof(TCHAR));
            if (CharsRequired == 0) 
            {
                ApiStatus = (NET_API_STATUS) GetLastError();
                goto Cleanup;
            }

        } while ((CharsRequired*sizeof(TCHAR)) > LastAllocationSize);

        ApiStatus = NO_ERROR;

    //
    // Oh well, remote expansion required.
    //
    }
    else 
    {
        UNICODE_STRING ExpandedUnicode;
        DWORD          SizeRequired;
        UNICODE_STRING UnexpandedUnicode;

        //
        // Create a temporary environment, which we'll fill in and let RTL
        // routines do the expansion for us.
        //
        if (FALSE == NewRemoteEnvironment())
        {
			ApiStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
        
        //
        // Loop until we have enough storage.
        // Expand the string.
        //
        SizeRequired = (_tcslen(UnexpandedString) + 1) * sizeof(TCHAR); // First pass, try same size
        RtlInitUnicodeString(&UnexpandedUnicode,(PCWSTR) UnexpandedString);
        do {

            // Clean up from previous pass.
            if (ExpandedString){LocalFree(ExpandedString);ExpandedString = NULL;}

            // Allocate the memory.
            ExpandedString = (LPTSTR) LocalAlloc(LMEM_FIXED, SizeRequired);
            if (ExpandedString == NULL) 
            {
                ApiStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
            LastAllocationSize = SizeRequired;

            ExpandedUnicode.MaximumLength = (USHORT)SizeRequired;
            ExpandedUnicode.Buffer = ExpandedString;

            NtStatus = RtlExpandEnvironmentStrings_U(
                    m_pEnvironment,             // env to use
                    &UnexpandedUnicode,         // source
                    &ExpandedUnicode,           // dest
                    (PULONG) &SizeRequired );   // dest size needed next time.

            if ( NtStatus == STATUS_BUFFER_TOO_SMALL ) 
            {
                continue;  // try again with larger buffer.
            }
            else if ( !NT_SUCCESS( NtStatus ) ) 
            {
				ApiStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
            else 
            {
                break;  // All done.
            }

        } while (SizeRequired > LastAllocationSize);

        ApiStatus = NO_ERROR;
    }


Cleanup:
    if (ApiStatus == NO_ERROR) 
    {
        *ValueBufferPtr = ExpandedString;
    }
    else 
    {
        *ValueBufferPtr = NULL;
        if (ExpandedString){LocalFree(ExpandedString);ExpandedString = NULL;}
    }

    return (ApiStatus);
}

BOOL CRemoteExpandEnvironmentStrings::BuildEnvironmentPath(void **pEnv, LPTSTR lpPathVariable, LPTSTR lpPathValue)
{
    NTSTATUS Status;
    UNICODE_STRING Name;
    UNICODE_STRING Value;
    WCHAR lpTemp[1025];
    DWORD cb;

    if (!*pEnv) {
        return(FALSE);
    }
    RtlInitUnicodeString(&Name, lpPathVariable);
    cb = 1024;
    Value.Buffer = (PWCHAR)LocalAlloc(LPTR, cb*sizeof(WCHAR));
    if (!Value.Buffer) {
        return(FALSE);
    }
    Value.Length = (USHORT)(sizeof(WCHAR) * cb);
    Value.MaximumLength = (USHORT)(sizeof(WCHAR) * cb);
    Status = RtlQueryEnvironmentVariable_U(*pEnv, &Name, &Value);
    if (!NT_SUCCESS(Status)) {
        LocalFree(Value.Buffer);
        Value.Length = 0;
        *lpTemp = 0;
    }
    if (Value.Length) 
	{
		StringCbCopy(lpTemp,sizeof(lpTemp),Value.Buffer);
        if ( *( lpTemp + lstrlen(lpTemp) - 1) != TEXT(';') ) 
		{
			StringCbCat(lpTemp,sizeof(lpTemp),TEXT(";"));
        }
        LocalFree(Value.Buffer);
    }
    if (lpPathValue && ((lstrlen(lpTemp) + lstrlen(lpPathValue) + 1) < (INT)cb)) 
	{
		StringCbCat(lpTemp,sizeof(lpTemp),lpPathValue);
        RtlInitUnicodeString(&Value, lpTemp);
        Status = RtlSetEnvironmentVariable(pEnv, &Name, &Value);
    }
    if (NT_SUCCESS(Status)) {
        return(TRUE);
    }
    return(FALSE);
}

DWORD CRemoteExpandEnvironmentStrings::ExpandUserEnvironmentStrings(void *pEnv, LPTSTR lpSrc, LPTSTR lpDst, DWORD nSize)
{
    NTSTATUS Status;
    UNICODE_STRING Source, Destination;
    ULONG Length;
    
    RtlInitUnicodeString( &Source, lpSrc );
    Destination.Buffer = lpDst;
    Destination.Length = 0;
    Destination.MaximumLength = (USHORT)(nSize* sizeof(WCHAR));
    Length = 0;
    Status = RtlExpandEnvironmentStrings_U(pEnv,
        (PUNICODE_STRING)&Source,
        (PUNICODE_STRING)&Destination,
        &Length
        );
    if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_TOO_SMALL) {
        return( Length );
    }
    else {
        return( 0 );
    }
}

BOOL CRemoteExpandEnvironmentStrings::SetUserEnvironmentVariable(void **pEnv, LPTSTR lpVariable, LPTSTR lpValue, BOOL bOverwrite)
{
    NTSTATUS Status;
    UNICODE_STRING Name;
    UNICODE_STRING Value;
    DWORD cb;
    TCHAR szValue[1024];

    if (!*pEnv || !lpVariable || !*lpVariable) {
        return(FALSE);
    }
    RtlInitUnicodeString(&Name, lpVariable);
    cb = 1024;
    Value.Buffer = (PTCHAR)LocalAlloc(LPTR, cb*sizeof(WCHAR));
    if (Value.Buffer) {
        Value.Length = (USHORT)cb;
        Value.MaximumLength = (USHORT)cb;
        Status = RtlQueryEnvironmentVariable_U(*pEnv, &Name, &Value);
        LocalFree(Value.Buffer);
        if (NT_SUCCESS(Status) && !bOverwrite) {
            return(TRUE);
        }
    }
    if (lpValue && *lpValue) {

        //
        // Special case TEMP and TMP and shorten the path names
        //

        if ((!lstrcmpi(lpVariable, TEXT("TEMP"))) ||
            (!lstrcmpi(lpVariable, TEXT("TMP")))) {

             if (!GetShortPathName (lpValue, szValue, 1024)) {
                 lstrcpyn (szValue, lpValue, 1024);
             }
        } else {
            lstrcpyn (szValue, lpValue, 1024);
        }

        RtlInitUnicodeString(&Value, szValue);
        Status = RtlSetEnvironmentVariable(pEnv, &Name, &Value);
    }
    else {
        Status = RtlSetEnvironmentVariable( pEnv, &Name, NULL);
    }
    return NT_SUCCESS(Status);
}

// Reads the system environment variables from the registry
// and adds them to the environment block at pEnv.
BOOL CRemoteExpandEnvironmentStrings::SetEnvironmentVariables(void **pEnv)
{
    WCHAR lpValueName[MAX_PATH];
    LPBYTE  lpDataBuffer;
    DWORD cbDataBuffer;
    LPBYTE  lpData;
    LPTSTR lpExpandedValue = NULL;
    DWORD cbValueName = MAX_PATH;
    DWORD cbData;
    DWORD dwType;
    DWORD dwIndex = 0;
    HKEY hkey;
    BOOL bResult;
    HKEY RootKey = DEFAULT_ROOT_KEY;

    // If any of this fails...
    // we should try to use the username/userpassword to connect to the server
    // and try it again...
    if (ERROR_SUCCESS != RegConnectRegistry((LPTSTR) m_lpszUncServerName,DEFAULT_ROOT_KEY,& RootKey ))
    {
        return(FALSE);
    }

    if (RegOpenKeyExW(RootKey,REG_PATH_TO_ENV,REG_OPTION_NON_VOLATILE,KEY_READ,& hkey))
    {
        return(FALSE);
    }

    cbDataBuffer = 4096;
    lpDataBuffer = (LPBYTE)LocalAlloc(LPTR, cbDataBuffer*sizeof(WCHAR));
    if (lpDataBuffer == NULL) {
        RegCloseKey(hkey);
        return(FALSE);
    }
    lpData = lpDataBuffer;
    cbData = cbDataBuffer;
    bResult = TRUE;
    while (!RegEnumValue(hkey, dwIndex, lpValueName, &cbValueName, 0, &dwType,
                         lpData, &cbData)) {
        if (cbValueName) {

            //
            // Limit environment variable length
            //

            lpData[MAX_ENV_VALUE_LEN-1] = TEXT('\0');


            if (dwType == REG_SZ) {
                //
                // The path variables PATH, LIBPATH and OS2LIBPATH must have
                // their values apppended to the system path.
                //

                if ( !lstrcmpi(lpValueName, PATH_VARIABLE) ||
                     !lstrcmpi(lpValueName, LIBPATH_VARIABLE) ||
                     !lstrcmpi(lpValueName, OS2LIBPATH_VARIABLE) ) {

                    BuildEnvironmentPath(pEnv, lpValueName, (LPTSTR)lpData);
                }
                else {

                    //
                    // the other environment variables are just set.
                    //
                    SetUserEnvironmentVariable(pEnv, lpValueName, (LPTSTR)lpData, TRUE);
                }
            }
        }
        dwIndex++;
        cbData = cbDataBuffer;
        cbValueName = MAX_PATH;
    }

    dwIndex = 0;
    cbData = cbDataBuffer;
    cbValueName = MAX_PATH;


    while (!RegEnumValue(hkey, dwIndex, lpValueName, &cbValueName, 0, &dwType,
                         lpData, &cbData)) {
        if (cbValueName) {

            //
            // Limit environment variable length
            //

            lpData[MAX_ENV_VALUE_LEN-1] = TEXT('\0');


            if (dwType == REG_EXPAND_SZ) {
                DWORD cb, cbNeeded;

                cb = 1024;
                lpExpandedValue = (LPTSTR)LocalAlloc(LPTR, cb*sizeof(WCHAR));
                if (lpExpandedValue) {
                    cbNeeded = ExpandUserEnvironmentStrings(*pEnv, (LPTSTR)lpData, lpExpandedValue, cb);
                    if (cbNeeded > cb) {
                        LocalFree(lpExpandedValue);
                        cb = cbNeeded;
                        lpExpandedValue = (LPTSTR)LocalAlloc(LPTR, cb*sizeof(WCHAR));
                        if (lpExpandedValue) {
                            ExpandUserEnvironmentStrings(*pEnv, (LPTSTR)lpData, lpExpandedValue, cb);
                        }
                    }
                }

                if (lpExpandedValue == NULL) {
                    bResult = FALSE;
                    break;
                }


                //
                // The path variables PATH, LIBPATH and OS2LIBPATH must have
                // their values apppended to the system path.
                //

                if ( !lstrcmpi(lpValueName, PATH_VARIABLE) ||
                     !lstrcmpi(lpValueName, LIBPATH_VARIABLE) ||
                     !lstrcmpi(lpValueName, OS2LIBPATH_VARIABLE) ) {

                    BuildEnvironmentPath(pEnv, lpValueName, (LPTSTR)lpExpandedValue);
                }
                else {

                    //
                    // the other environment variables are just set.
                    //

                    SetUserEnvironmentVariable(pEnv, lpValueName, (LPTSTR)lpExpandedValue, TRUE);
                }

                LocalFree(lpExpandedValue);

            }

        }
        dwIndex++;
        cbData = cbDataBuffer;
        cbValueName = MAX_PATH;
    }



    LocalFree(lpDataBuffer);
    RegCloseKey(hkey);

    return(bResult);
}

//*************************************************************
//
//  SetEnvironmentVariableInBlock()
//
//  Purpose:    Sets the environment variable in the given block
//
//  Parameters: pEnv        -   Environment block
//              lpVariable  -   Variables
//              lpValue     -   Value
//              bOverwrite  -   Overwrite
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/21/96     ericflo    Ported
//
//*************************************************************
BOOL CRemoteExpandEnvironmentStrings::SetEnvironmentVariableInBlock(PVOID *pEnv, LPTSTR lpVariable,LPTSTR lpValue, BOOL bOverwrite)
{
    NTSTATUS Status;
    UNICODE_STRING Name, Value;
    DWORD cb;
    LPTSTR szValue = NULL;

    if (!*pEnv || !lpVariable || !*lpVariable) {
        return(FALSE);
    }

    RtlInitUnicodeString(&Name, lpVariable);

    cb = 1025 * sizeof(WCHAR);
    Value.Buffer = (PWSTR) LocalAlloc(LPTR, cb);
    if (Value.Buffer) {
        Value.Length = 0;
        Value.MaximumLength = (USHORT)cb;
        Status = RtlQueryEnvironmentVariable_U(*pEnv, &Name, &Value);

        LocalFree(Value.Buffer);

        if ( NT_SUCCESS(Status) && !bOverwrite) {
            return(TRUE);
        }
    }

    szValue = (LPTSTR)LocalAlloc(LPTR, 1024*sizeof(TCHAR));
    if (!szValue) 
    {
        return FALSE;
    }

    if (lpValue && *lpValue) {

        //
        // Special case TEMP and TMP and shorten the path names
        //

        if ((!lstrcmpi(lpVariable, TEXT("TEMP"))) ||
            (!lstrcmpi(lpVariable, TEXT("TMP")))) {

             if (!GetShortPathName (lpValue, szValue, 1024)) {
                 lstrcpyn (szValue, lpValue, 1024);
             }
        } else {
            lstrcpyn (szValue, lpValue, 1024);
        }

        RtlInitUnicodeString(&Value, szValue);
        Status = RtlSetEnvironmentVariable(pEnv, &Name, &Value);
    }
    else {
        Status = RtlSetEnvironmentVariable(pEnv, &Name, NULL);
    }

    LocalFree(szValue);
    if (NT_SUCCESS(Status)) {
        return(TRUE);
    }
    return(FALSE);
}

// Just set the environmental variables that we can
// if we can't set them because of no access, no biggie
DWORD CRemoteExpandEnvironmentStrings::SetOtherEnvironmentValues(void **pEnv)
{
    DWORD dwResult = ERROR_SUCCESS;
    HKEY  hKey = NULL;
    HKEY  RootKey = DEFAULT_ROOT_KEY;
    DWORD dwType, dwSize;
    TCHAR szValue[MAX_ENV_VALUE_LEN + 1];
    TCHAR szExpValue[MAX_ENV_VALUE_LEN + 1];
    DWORD RandomValueSize = 0;
    LPTSTR RandomValueW = NULL;

    // If any of this fails...
    // we should try to use the username/userpassword to connect to the server
    // and try it again...

    // try to connect to remote registry (or local registry if Null)
    dwResult = RegConnectRegistry((LPTSTR) m_lpszUncServerName,DEFAULT_ROOT_KEY,& RootKey);
    if (ERROR_SUCCESS != dwResult)
    {
        goto SetOtherEnvironmentValues_Exit;
    }

    dwResult = RegOpenKeyEx(RootKey,REG_PATH_TO_SYSROOT,REG_OPTION_NON_VOLATILE,KEY_READ,&hKey);
    if (ERROR_SUCCESS == dwResult)
    {
        dwResult = GetRegKeyMaxSizes(
               hKey,
               NULL,                    // don't need keyword size
               &RandomValueSize );      // set max value size.
        if (ERROR_SUCCESS != dwResult)
        {
            goto SetOtherEnvironmentValues_Exit;
        }

        RandomValueW = (LPTSTR) LocalAlloc(LMEM_FIXED, RandomValueSize);
        if (RandomValueW == NULL)
        {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            if (RegQueryValueEx(hKey,(LPTSTR)ENV_KEYWORD_SYSTEMROOT,REG_OPTION_NON_VOLATILE,&dwType,(LPBYTE) RandomValueW,&RandomValueSize) == ERROR_SUCCESS)
            {
                SetEnvironmentVariableInBlock(pEnv, ENV_KEYWORD_SYSTEMROOT, RandomValueW, TRUE);
            }
        }

        if (hKey) {RegCloseKey(hKey);}
    }

    dwResult = RegOpenKeyEx (RootKey, REG_PATH_TO_COMMON_FOLDERS, REG_OPTION_NON_VOLATILE, KEY_READ, &hKey);
    if (ERROR_SUCCESS == dwResult)
    {
        dwSize = (MAX_ENV_VALUE_LEN+1) * sizeof(TCHAR);

        if (RegQueryValueEx (hKey, ENV_KEYWORD_PROGRAMFILESDIR, NULL, &dwType,(LPBYTE) szValue, &dwSize) == ERROR_SUCCESS) 
        {
            ExpandEnvironmentStrings (szValue, szExpValue, (MAX_ENV_VALUE_LEN+1));
            SetEnvironmentVariableInBlock(pEnv, PROGRAMFILES_VARIABLE, szExpValue, TRUE);
        }

        dwSize = (MAX_ENV_VALUE_LEN+1) * sizeof(TCHAR);
        if (RegQueryValueEx (hKey, ENV_KEYWORD_COMMONFILESDIR, NULL, &dwType,(LPBYTE) szValue, &dwSize) == ERROR_SUCCESS) 
        {
            ExpandEnvironmentStrings (szValue, szExpValue, (MAX_ENV_VALUE_LEN+1));
            SetEnvironmentVariableInBlock(pEnv, COMMONPROGRAMFILES_VARIABLE, szExpValue, TRUE);
        }

        dwSize = (MAX_ENV_VALUE_LEN+1)*sizeof(TCHAR);
        if (RegQueryValueEx (hKey, ENV_KEYWORD_PROGRAMFILESDIR_X86, NULL, &dwType,(LPBYTE) szValue, &dwSize) == ERROR_SUCCESS) 
        {
            ExpandEnvironmentStrings (szValue, szExpValue, (MAX_ENV_VALUE_LEN+1));
            SetEnvironmentVariableInBlock(pEnv, PROGRAMFILESX86_VARIABLE, szExpValue, TRUE);
        }

        dwSize = (MAX_ENV_VALUE_LEN+1)*sizeof(TCHAR);
        if (RegQueryValueEx (hKey, ENV_KEYWORD_COMMONFILESDIR_X86, NULL, &dwType,(LPBYTE) szValue, &dwSize) == ERROR_SUCCESS) 
        {
            ExpandEnvironmentStrings (szValue, szExpValue, (MAX_ENV_VALUE_LEN+1));
            SetEnvironmentVariableInBlock(pEnv, COMMONPROGRAMFILESX86_VARIABLE, szExpValue, TRUE);
        }
    }

SetOtherEnvironmentValues_Exit:
    if (RootKey != DEFAULT_ROOT_KEY) 
        {RegCloseKey(RootKey);}
    if (hKey) {RegCloseKey(hKey);}
    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\iisuiobj\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by iisuiobj.rc
//
#define IDS_PROJNAME                    100
#define IDR_IMPORTEXPORTCONFIG          101
#define IDS_EXPORT_FILTER               101
#define IDS_XML_FILES                   102
#define IDS_XML_EXT                     103
#define IDS_ALL_FILES                   104
#define IDS_ALL_EXT                     105
#define IDS_PASSWORDS_NO_MATCH          106
#define IDS_COL_LOCATION                107
#define IDS_DEFAULT_SAVED_EXT           108
#define IDS_FILENAME_MISSING            109
#define IDS_REPLACE_FILE                110
#define IDS_MSGBOX_CAPTION              111
#define IDS_FILEPATH_MISSING            112
#define IDS_BROWSE_SELECT_FOLDER        113
#define IDS_FILE_NOT_FOUND              114
#define IDS_FILE_IS_A_DIR               115
#define IDS_FILENAME_INVALID            116
#define IDS_INVALID_ENTRY               117
#define IDS_FILENAME_NOREMOTE_EXPAND    118
#define IDS_HELPLOC                     119
#define IDS_HELPLOC_HELP                119
#define IDS_IMPORT_MISMATCH             120
#define IDS_STRING_WEB_SERVER           121
#define IDS_STRING_FTP_SERVER           122
#define IDS_STRING_WEB_VDIR             123
#define IDS_STRING_FTP_VDIR             124
#define IDS_STRING_APP_POOL             125
#define IDD_DIALOG_EXPORT               201
#define IDC_STATIC_FILENAME             201
#define IDC_EDIT_FILENAME               202
#define IDD_DIALOG_IMPORT               202
#define IDC_STATIC_PATH                 203
#define IDD_DIALOG_PASSWORD             203
#define IDC_EDIT_PATH                   204
#define IDD_DIALOG_EXISTS_VDIR          204
#define IDC_BUTTON_BROWSE               205
#define IDD_DIALOG_EXISTS_APP_POOL      205
#define IDC_CHECK_ENCRYPT               206
#define IDD_DIALOG_EXISTS_SITE          206
#define IDC_STATIC_PASSWORD1            207
#define IDD_DIALOG_GET_PASSWORD         207
#define IDC_STATIC_PASSWORD2            208
#define IDC_EDIT3                       209
#define IDC_EDIT_PASSWORD1              209
#define IDC_EDIT_PASSWORD2              210
#define IDC_STATIC_FILE                 211
#define IDC_EDIT_FILE                   212
#define IDC_STATIC_SELECT               214
#define IDC_LIST_OBJECT                 215
#define IDC_EDIT1                       216
#define IDC_STATIC_CAPTION              217
#define IDC_RADIO1                      218
#define IDC_RADIO2                      219
#define IDC_STATIC_NEW_NAME             220
#define IDC_EDIT_NEW_NAME               221
#define IDC_STATIC_GET_PASSWORD         222
#define IDC_EDIT_GET_PASSWORD           223
#define IDC_BUTTON_ENUM_FILE            224

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        208
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         225
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\iisuiobj\importui.cpp ===
// ImportUI.cpp : Implementation of CImportUI
#include "stdafx.h"
#include "IISUIObj.h"
#include "ImportExportConfig.h"
#include "ExportUI.h"
#include "ImportUI.h"
#include "Defaults.h"
#include "util.h"
#include "ddxv.h"
#include <strsafe.h>

#define HIDD_IISUIOBJ_IMPORT 0x50401

#define LAST_USED_IMPORT_FILE _T("LastImportFile")

LPTSTR GimmiePointerToLastPart(LPCTSTR lpszMDPath)
{
    LPTSTR lpszReturn = NULL;
    ASSERT_PTR(lpszMDPath);

    if (!lpszMDPath || !*lpszMDPath)
    {
        return NULL;
    }

    LPCTSTR lp = lpszMDPath + _tcslen(lpszMDPath) - 1;

    //
    // Skip trailing separator
    //
    if (*lp == SZ_MBN_SEP_CHAR)
    {
        --lp;
    }

    while (*lp && *lp != SZ_MBN_SEP_CHAR)
    {
        lpszReturn = (LPTSTR) (lp--);
    }

    return lpszReturn;
}

void InitListView(HWND hList)
{
    LV_COLUMN lvCol;
    RECT      rect;
    LONG      width;

    ZeroMemory(&rect, sizeof(rect));
    GetWindowRect(hList, &rect);
    width = rect.right - rect.left - 4; // -4 to prevent the horizontal scrollbar from appearing

    ZeroMemory(&lvCol, sizeof(lvCol));
    lvCol.mask = LVCF_TEXT | LVCF_WIDTH;
    lvCol.fmt = LVCFMT_LEFT;
    lvCol.cx = width;
    ListView_InsertColumn(hList, 0, &lvCol);
    return;
}

HRESULT DoImportConfigFromFile(PCONNECTION_INFO pConnectionInfo,BSTR bstrFileNameAndPath,BSTR bstrMetabaseSourcePath,BSTR bstrMetabaseDestinationPath,BSTR bstrPassword,DWORD dwImportFlags)
{
    HRESULT hr = E_FAIL;
    IMSAdminBase *pIMSAdminBase = NULL;
    IMSAdminBase2 *pIMSAdminBase2 = NULL;
	LPWSTR lpwstrTempPassword = NULL;

    if (!pConnectionInfo)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

	if (pConnectionInfo->pszUserPasswordEncrypted)
	{
		if (FAILED(DecryptMemoryPassword((LPWSTR) pConnectionInfo->pszUserPasswordEncrypted,&lpwstrTempPassword,pConnectionInfo->cbUserPasswordEncrypted)))
		{
			return HRESULT_FROM_WIN32(ERROR_DECRYPTION_FAILED);
		}
	}

	CComAuthInfo auth(pConnectionInfo->pszMachineName,pConnectionInfo->pszUserName,lpwstrTempPassword);

    if (!bstrFileNameAndPath)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    // Bufferfer overflow paranoia, make sure it's less than 255 characters long
    if (wcslen(bstrFileNameAndPath) > (_MAX_PATH)){return RPC_S_STRING_TOO_LONG;}
    if (wcslen(bstrMetabaseSourcePath) > (_MAX_PATH * 3)){return RPC_S_STRING_TOO_LONG;}
    if (wcslen(bstrMetabaseDestinationPath) > (_MAX_PATH * 3)){return RPC_S_STRING_TOO_LONG;}

    if (bstrPassword)
    {
        if (wcslen(bstrPassword) > (_MAX_PATH)){return RPC_S_STRING_TOO_LONG;}
    }

    if(FAILED(hr = CoInitializeEx(NULL, COINIT_MULTITHREADED)))
    {
        if(FAILED(hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED)))
        {
            return hr;
        }
    }

    // RPC_C_AUTHN_LEVEL_DEFAULT       0 
    // RPC_C_AUTHN_LEVEL_NONE          1 
    // RPC_C_AUTHN_LEVEL_CONNECT       2 
    // RPC_C_AUTHN_LEVEL_CALL          3 
    // RPC_C_AUTHN_LEVEL_PKT           4 
    // RPC_C_AUTHN_LEVEL_PKT_INTEGRITY 5 
    // RPC_C_AUTHN_LEVEL_PKT_PRIVACY   6 
    COSERVERINFO * pcsiName = auth.CreateServerInfoStruct(RPC_C_AUTHN_LEVEL_DEFAULT);
    MULTI_QI res[1] = 
    {
        {&IID_IMSAdminBase, NULL, 0}
    };

    if (FAILED(hr = CoCreateInstanceEx(CLSID_MSAdminBase,NULL,CLSCTX_ALL,pcsiName,1,res)))
    {
        goto DoImportConfigFromFile_Exit;
    }

    pIMSAdminBase = (IMSAdminBase *)res[0].pItf;
    if (auth.UsesImpersonation())
    {
        if (FAILED(hr = auth.ApplyProxyBlanket(pIMSAdminBase)))
        {
            goto DoImportConfigFromFile_Exit;
        }

        // There is a remote IUnknown interface that lurks behind IUnknown.
        // If that is not set, then the Release call can return access denied.
        IUnknown * pUnk = NULL;
        hr = pIMSAdminBase->QueryInterface(IID_IUnknown, (void **)&pUnk);
        if(FAILED(hr))
        {
            return hr;
        }
        if (FAILED(hr = auth.ApplyProxyBlanket(pUnk)))
        {
            goto DoImportConfigFromFile_Exit;
        }
        pUnk->Release();pUnk = NULL;
    }

    if (FAILED(hr = pIMSAdminBase->QueryInterface(IID_IMSAdminBase2, (void **)&pIMSAdminBase2)))
    {
        goto DoImportConfigFromFile_Exit;
    }

    if (auth.UsesImpersonation())
    {
        if (FAILED(hr = auth.ApplyProxyBlanket(pIMSAdminBase2)))
        {
            goto DoImportConfigFromFile_Exit;
        }
    }
    else
    {
        // the local call needs min RPC_C_IMP_LEVEL_IMPERSONATE
        // for the pIMSAdminBase2 objects Import/Export functions!
        if (FAILED(hr = SetBlanket(pIMSAdminBase2)))
        {
            //goto DoImportConfigFromFile_Exit;
        }
    }

    //#define MD_IMPORT_INHERITED             0x00000001
    //#define MD_IMPORT_NODE_ONLY             0x00000002
    //#define MD_IMPORT_MERGE                 0x00000004
    IISDebugOutput(_T("Import:MetabasePathSource=%s,MetabasePathDestination=%s\r\n"),bstrMetabaseSourcePath,bstrMetabaseDestinationPath);
    hr = pIMSAdminBase2->Import(bstrPassword,bstrFileNameAndPath,bstrMetabaseSourcePath,bstrMetabaseDestinationPath,dwImportFlags);

DoImportConfigFromFile_Exit:
    IISDebugOutput(_T("Import:ret=0x%x\r\n"),hr);
	if (lpwstrTempPassword)
	{
		// security percaution:Make sure to zero out memory that temporary password was used for.
		SecureZeroMemory(lpwstrTempPassword,pConnectionInfo->cbUserPasswordEncrypted);
		LocalFree(lpwstrTempPassword);
		lpwstrTempPassword = NULL;
	}
    if (pIMSAdminBase2) 
    {
        pIMSAdminBase2->Release();
        pIMSAdminBase2 = NULL;
    }
    if (pIMSAdminBase) 
    {
        pIMSAdminBase->Release();
        pIMSAdminBase = NULL;
    }
    CoUninitialize();
    return hr;
}

INT_PTR CALLBACK ShowSiteExistsDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
        case WM_INITDIALOG:
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO1), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO2), TRUE);
            CheckDlgButton(hDlg,IDC_RADIO1,BST_CHECKED);
            CheckDlgButton(hDlg,IDC_RADIO2,BST_UNCHECKED);
            CenterWindow(GetParent(hDlg), hDlg);
            UpdateWindow(hDlg);
            break;

        case WM_CLOSE:
            EndDialog(hDlg, IDCANCEL);
            return FALSE;
            break;

        case WM_COMMAND:
            switch (wParam)
            {
                case IDCANCEL:
                    EndDialog(hDlg, (int) wParam);
                    return FALSE;

                case IDOK:
                    if (BST_CHECKED == IsDlgButtonChecked(hDlg,IDC_RADIO1))
                    {
                        EndDialog(hDlg, (int) IDC_RADIO1);
                    }
                    else if (BST_CHECKED == IsDlgButtonChecked(hDlg,IDC_RADIO2))
                    {
                        EndDialog(hDlg, (int) IDC_RADIO2);
                    }
                    return TRUE;
            }
            break;
    }
    return FALSE;
}

INT_PTR CALLBACK ShowVDirExistsDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    static LPTSTR szReturnString = NULL;

    switch (msg)
    {
        case WM_INITDIALOG:
            szReturnString = (LPTSTR) lParam;
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO1), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO2), TRUE);
            CheckDlgButton(hDlg,IDC_RADIO1,BST_CHECKED);
            CheckDlgButton(hDlg,IDC_RADIO2,BST_UNCHECKED);
            SendDlgItemMessage(hDlg, IDC_EDIT_NEW_NAME, EM_LIMITTEXT, _MAX_PATH, 0);
            EnableWindow(GetDlgItem(hDlg,IDC_EDIT_NEW_NAME), TRUE);
            SetDlgItemText(hDlg, IDC_EDIT_NEW_NAME, _T(""));
            CenterWindow(GetParent(hDlg), hDlg);
            UpdateWindow(hDlg);
            break;

        case WM_CLOSE:
            EndDialog(hDlg, IDCANCEL);
            return FALSE;
            break;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDC_EDIT_NEW_NAME:
                    {
	                    switch (HIWORD(wParam))
                        {
	                        case EN_CHANGE:
								EditHideBalloon();
		                        // If the contents of the edit control have changed,
                                if (BST_CHECKED == IsDlgButtonChecked(hDlg,IDC_RADIO1))
                                {
                                    EnableWindow(GetDlgItem(hDlg, IDOK),(SendMessage(GetDlgItem(hDlg,LOWORD(wParam)),EM_LINELENGTH,(WPARAM) -1, 0) != 0));
                                }
		                        break;
                            case EN_MAXTEXT:
	                        case EN_ERRSPACE:
		                        // If the control is out of space, honk
		                        MessageBeep (0);
		                        break;
	                        default:
                                break;
	                    }
	                    return TRUE;
                    }

                case IDC_RADIO1:
                    EnableWindow(GetDlgItem(hDlg, IDC_EDIT_NEW_NAME), TRUE);
                    EnableWindow(GetDlgItem(hDlg, IDOK),(SendMessage(GetDlgItem(hDlg,IDC_EDIT_NEW_NAME),EM_LINELENGTH,(WPARAM) -1, 0) != 0));
                    SetFocus(GetDlgItem(hDlg, IDC_EDIT_NEW_NAME));
                    return TRUE;

                case IDC_RADIO2:
                    EnableWindow(GetDlgItem(hDlg, IDC_EDIT_NEW_NAME), FALSE);
                    EnableWindow(GetDlgItem(hDlg, IDOK),TRUE);
                    return TRUE;

                case IDCANCEL:
                    EndDialog(hDlg, (int) wParam);
                    return FALSE;

                case IDOK:
                    TCHAR szEditString[_MAX_PATH + 1];
                    ZeroMemory(szEditString, sizeof(szEditString));
                    GetDlgItemText(hDlg, IDC_EDIT_NEW_NAME, szEditString, _MAX_PATH);
					// sizeof szReturnString = _MAX_PATH + 1
					StringCbCopy(szReturnString,_MAX_PATH + 1, szEditString);
                    if (BST_CHECKED == IsDlgButtonChecked(hDlg,IDC_RADIO1))
                    {
                        EndDialog(hDlg, (int) IDC_RADIO1);
                    }
                    else if (BST_CHECKED == IsDlgButtonChecked(hDlg,IDC_RADIO2))
                    {
                        EndDialog(hDlg, (int) IDC_RADIO2);
                    }
                    return TRUE;
            }
            break;
    }
    return FALSE;
}

INT_PTR CALLBACK 
ShowAppPoolExistsDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    static LPTSTR szReturnString = NULL;

    switch (msg)
    {
        case WM_INITDIALOG:
            szReturnString = (LPTSTR) lParam;
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO1), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO2), TRUE);
            CheckDlgButton(hDlg,IDC_RADIO1,BST_CHECKED);
            CheckDlgButton(hDlg,IDC_RADIO2,BST_UNCHECKED);
            SendDlgItemMessage(hDlg, IDC_EDIT_NEW_NAME, EM_LIMITTEXT, _MAX_PATH, 0);
            EnableWindow(GetDlgItem(hDlg,IDC_EDIT_NEW_NAME), TRUE);
            SetDlgItemText(hDlg, IDC_EDIT_NEW_NAME, _T(""));
            CenterWindow(GetParent(hDlg), hDlg);
            UpdateWindow(hDlg);
            break;

        case WM_CLOSE:
            EndDialog(hDlg, IDCANCEL);
            return FALSE;
            break;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDC_EDIT_NEW_NAME:
                    {
	                    switch (HIWORD(wParam))
                        {
	                        case EN_CHANGE:
								EditHideBalloon();
		                        // If the contents of the edit control have changed,
                                if (BST_CHECKED == IsDlgButtonChecked(hDlg,IDC_RADIO1))
                                {
                                    EnableWindow(GetDlgItem(hDlg, IDOK),(SendMessage(GetDlgItem(hDlg,LOWORD(wParam)),EM_LINELENGTH,(WPARAM) -1, 0) != 0));
                                }
		                        break;
                            case EN_MAXTEXT:
	                        case EN_ERRSPACE:
		                        // If the control is out of space, honk
		                        MessageBeep (0);
		                        break;
	                        default:
                                break;
	                    }
	                    return TRUE;
                    }

                case IDC_RADIO1:
                    EnableWindow(GetDlgItem(hDlg, IDC_EDIT_NEW_NAME), TRUE);
                    EnableWindow(GetDlgItem(hDlg, IDOK),(SendMessage(GetDlgItem(hDlg,IDC_EDIT_NEW_NAME),EM_LINELENGTH,(WPARAM) -1, 0) != 0));
                    SetFocus(GetDlgItem(hDlg, IDC_EDIT_NEW_NAME));
                    return TRUE;

                case IDC_RADIO2:
                    EnableWindow(GetDlgItem(hDlg, IDC_EDIT_NEW_NAME), FALSE);
                    EnableWindow(GetDlgItem(hDlg, IDOK),TRUE);
                    return TRUE;

                case IDCANCEL:
                    EndDialog(hDlg, (int) wParam);
                    return FALSE;

                case IDOK:
                    TCHAR szEditString[_MAX_PATH + 1];
                    ZeroMemory(szEditString, sizeof(szEditString));

                    if (BST_CHECKED == IsDlgButtonChecked(hDlg,IDC_RADIO1))
                    {
                        GetDlgItemText(hDlg, IDC_EDIT_NEW_NAME, szEditString, _MAX_PATH);

                        // check for invalid entry
                        TCHAR bad_chars[] = _T("\\/");
                        if (_tcslen(szEditString) != _tcscspn(szEditString, bad_chars))
                        {
                            CString strCaption;
                            CString strMsg;
                            strCaption.LoadString(_Module.GetResourceInstance(), IDS_MSGBOX_CAPTION);
                            strMsg.LoadString(_Module.GetResourceInstance(), IDS_INVALID_ENTRY);
                            MessageBox(hDlg,strMsg,strCaption,MB_ICONEXCLAMATION | MB_OK);
                            *szReturnString = 0;
                        }
                        else
                        {
						    // sizeof szReturnString = _MAX_PATH + 1
						    StringCbCopy(szReturnString,_MAX_PATH + 1, szEditString);
                            EndDialog(hDlg, (int) IDC_RADIO1);
                        }
                    }
                    else if (BST_CHECKED == IsDlgButtonChecked(hDlg,IDC_RADIO2))
                    {
                        *szReturnString = 0;
                        EndDialog(hDlg, (int) IDC_RADIO2);
                    }
            }
            break;
    }
    return FALSE;
}

INT_PTR CALLBACK ShowPasswordDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    static LPTSTR szReturnString = NULL;

    switch (msg)
    {
        case WM_INITDIALOG:
            szReturnString = (LPTSTR) lParam;
            SendDlgItemMessage(hDlg, IDC_EDIT_GET_PASSWORD, EM_LIMITTEXT, PWLEN, 0);
            SendDlgItemMessage(hDlg, IDC_EDIT_GET_PASSWORD, EM_SETPASSWORDCHAR, WPARAM('*'), 0);
            EnableWindow(GetDlgItem(hDlg,IDC_EDIT_GET_PASSWORD), TRUE);
            SetDlgItemText(hDlg, IDC_EDIT_GET_PASSWORD, _T(""));
            UpdateWindow(hDlg);
            break;

        case WM_CLOSE:
            EndDialog(hDlg, IDCANCEL);
            return FALSE;
            break;

        case WM_COMMAND:
            switch (wParam)
            {
                case IDCANCEL:
                    EndDialog(hDlg,(int)wParam);
                    return FALSE;

                case IDOK:
                    {
                        TCHAR szPassword[PWLEN + 1];
                        SecureZeroMemory(szPassword, sizeof(szPassword));
                        GetDlgItemText(hDlg, IDC_EDIT_GET_PASSWORD, szPassword, PWLEN);
						// sizeof szReturnString = _MAX_PATH + 1
						StringCbCopy(szReturnString,_MAX_PATH + 1, szPassword);
                        // security percaution:Make sure to zero out memory that temporary password was used for.
                        SecureZeroMemory(szPassword, sizeof(szPassword));
                        EndDialog(hDlg,(int)wParam);
                        return TRUE;
                    }
            }
            break;
    }
    return FALSE;
}

HRESULT FillListBoxWithMultiSzData(HWND hList,LPCTSTR szKeyType,WCHAR * pszBuffer)
{
    HRESULT hr = E_FAIL;
    WCHAR szBuffer[_MAX_PATH + 1];
    WCHAR * pszBufferTemp1 = NULL;
    WCHAR * pszBufferTemp2 = NULL;
    LVITEM ItemIndex;
    LV_COLUMN lvcol;
    INT iIndex = 0;
    DWORD dwCount = 0;
    BOOL bMultiSzIsPaired = FALSE;
    BOOL bPleaseAddItem = TRUE;
    BOOL bPleaseFilterThisSitesList = FALSE;

    if (0 == _tcscmp(szKeyType,IIS_CLASS_WEB_SERVER_W) || 0 == _tcscmp(szKeyType,IIS_CLASS_FTP_SERVER_W) )
    {
        bPleaseFilterThisSitesList = TRUE;
    }
    
    pszBufferTemp1 = pszBuffer;

    // forget this, it's always paired.
    //bMultiSzIsPaired = IsMultiSzPaired(pszBufferTemp1);
    bMultiSzIsPaired = TRUE;

    // Erase existing data in list box...
    ListView_DeleteAllItems(hList);
    // Delete all of the columns.
    for (int i=0;i <= ListView_GetItemCount(hList);i++)
        {ListView_DeleteColumn(hList,i);}

    //
    // Decide on the column widths
    //
    RECT rect;
    GetClientRect(hList, &rect);

    LONG lWidth;
    if (dwCount > (DWORD)ListView_GetCountPerPage(hList))
    {
        lWidth = (rect.right - rect.left) - GetSystemMetrics(SM_CYHSCROLL);
    }
    else
    {
        lWidth = rect.right - rect.left;
    }

    //
    // Insert the component name column
    //
    memset(&lvcol, 0, sizeof(lvcol));
	// zero memory
	ZeroMemory(szBuffer, sizeof(szBuffer));

    lvcol.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
    lvcol.fmt = LVCFMT_LEFT;
    lvcol.pszText = szBuffer;
    lvcol.cx = lWidth;
    LoadString(_Module.m_hInst, IDS_COL_LOCATION, szBuffer, ARRAYSIZE(szBuffer));
    ListView_InsertColumn(hList, 0, &lvcol);

    SendMessage(hList, LVM_SETEXTENDEDLISTVIEWSTYLE,(WPARAM) 0, LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP);

    if (!pszBufferTemp1)
    {
        return ERROR_SUCCESS;
    }

    while (1)
    {
        if (pszBufferTemp1)
        {
            hr = ERROR_SUCCESS;
            ZeroMemory (&ItemIndex, sizeof(ItemIndex));

            if (bMultiSzIsPaired)
            {
                bPleaseAddItem = TRUE;
                // -----------
                // paired list
                //  value1a value1b
                //  value2a value2b
                //  ...
                // -----------

                // make a copy of this baby
                pszBufferTemp2 = pszBufferTemp1; 

                // then increment until we hit another null.
                // to get value #2 -- which is the description
                while (*pszBufferTemp1)
                {
                    pszBufferTemp1++;
                }
                // check for the ending \0\0
                if ( *(pszBufferTemp1+1) == NULL)
                {
                    break;
                }
                else
                {
                    pszBufferTemp1++;
                }

                // Check if pszBufferTemp1 is an empty string
                // if it is then display something else.
                //IISDebugOutput(_T("key=%s,friendly=%s\r\n"),pszBufferTemp2,pszBufferTemp1);
                if (IsSpaces(pszBufferTemp1))
                {
                    ItemIndex.pszText = pszBufferTemp2;
                    ItemIndex.pszText = GimmiePointerToLastPart(pszBufferTemp2);
                }
                else
                {
                    ItemIndex.pszText = pszBufferTemp1;
                }
                if (bPleaseFilterThisSitesList)
                {
                    // Check if it is a true site node -- like
                    // /LM/W3SVC/1
                    // /LM/MSFTPSVC/1
                    // and not /LM/W3SVC/SOMETHINGELSE
                    //
                    DWORD dwInstanceNum = CMetabasePath::GetInstanceNumber(pszBufferTemp2);
                    if (dwInstanceNum == 0 || dwInstanceNum == 0xffffffff)
                    {
                        // this is not a valid site path
                        bPleaseAddItem = FALSE;
                    }
                }

                if (bPleaseAddItem)
                {
                    ItemIndex.mask = LVIF_TEXT | LVIF_PARAM;
                    ItemIndex.iItem = iIndex;
                    ItemIndex.lParam = (LPARAM) pszBufferTemp2;
                    iIndex = ListView_InsertItem (hList, &ItemIndex);
                }

                // then increment until we hit another null.
                // to get value #2
                while (*pszBufferTemp1)
                {
                    pszBufferTemp1++;
                }
                // check for the ending \0\0
                if ( *(pszBufferTemp1+1) == NULL)
                {
                    break;
                }
                else
                {
                    pszBufferTemp1++;
                }
            }
            else
            {
                // -----------
                // single list
                //  value1a
                //  value2a
                //  ...
                // -----------
                ItemIndex.mask = LVIF_TEXT | LVIF_PARAM;
                ItemIndex.iItem = iIndex;
                ItemIndex.pszText = pszBufferTemp1;
                ItemIndex.lParam = (LPARAM) pszBufferTemp1;
                iIndex = ListView_InsertItem (hList, &ItemIndex);

                // then increment until we hit another null.
                // to get value #2
                while (*pszBufferTemp1)
                {
                    pszBufferTemp1++;
                }
            }

            // check for the ending \0\0
            if ( *(pszBufferTemp1+1) == NULL)
            {
                break;
            }
            else
            {
                pszBufferTemp1++;
            }

            
            iIndex++;
        }
    }

    return hr;
}

HRESULT DoEnumDataFromFile(PCONNECTION_INFO pConnectionInfo,BSTR bstrFileNameAndPath,BSTR bstrPathType,WCHAR ** pszMetabaseMultiszList)
{
    HRESULT hr = E_FAIL;
    IMSAdminBase *pIMSAdminBase = NULL;
    IMSImpExpHelp * pIMSImpExpHelp = NULL;
    WCHAR * pszBuffer = NULL;
    DWORD dwBufferSize = 1;
	LPWSTR lpwstrTempPassword = NULL;
    
    if (!pConnectionInfo)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

	if (pConnectionInfo->pszUserPasswordEncrypted)
	{
		if (FAILED(DecryptMemoryPassword((LPWSTR) pConnectionInfo->pszUserPasswordEncrypted,&lpwstrTempPassword,pConnectionInfo->cbUserPasswordEncrypted)))
		{
			return HRESULT_FROM_WIN32(ERROR_DECRYPTION_FAILED);
		}
	}
	
    CComAuthInfo auth(pConnectionInfo->pszMachineName,pConnectionInfo->pszUserName,lpwstrTempPassword);

    if (!bstrFileNameAndPath)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    if (!bstrPathType)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    // Buffer overflow paranoia, make sure it's less than 255 characters long
    if (wcslen(bstrFileNameAndPath) > (_MAX_PATH)){return RPC_S_STRING_TOO_LONG;}
    if (wcslen(bstrPathType) > (_MAX_PATH)){return RPC_S_STRING_TOO_LONG;}

    if(FAILED(hr = CoInitializeEx(NULL, COINIT_MULTITHREADED)))
    {
        if(FAILED(hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED)))
        {
            return hr;
        }
    }

    // RPC_C_AUTHN_LEVEL_DEFAULT       0 
    // RPC_C_AUTHN_LEVEL_NONE          1 
    // RPC_C_AUTHN_LEVEL_CONNECT       2 
    // RPC_C_AUTHN_LEVEL_CALL          3 
    // RPC_C_AUTHN_LEVEL_PKT           4 
    // RPC_C_AUTHN_LEVEL_PKT_INTEGRITY 5 
    // RPC_C_AUTHN_LEVEL_PKT_PRIVACY   6 
    COSERVERINFO * pcsiName = auth.CreateServerInfoStruct(RPC_C_AUTHN_LEVEL_DEFAULT);
    MULTI_QI res[1] = 
    {
        {&IID_IMSAdminBase, NULL, 0}
    };

    if (FAILED(hr = CoCreateInstanceEx(CLSID_MSAdminBase,NULL,CLSCTX_ALL,pcsiName,1,res)))
    {
        goto DoEnumDataFromFile_Exit;
    }

    pIMSAdminBase = (IMSAdminBase *)res[0].pItf;
    if (auth.UsesImpersonation())
    {
        if (FAILED(hr = auth.ApplyProxyBlanket(pIMSAdminBase)))
        {
            goto DoEnumDataFromFile_Exit;
        }

        // There is a remote IUnknown interface that lurks behind IUnknown.
        // If that is not set, then the Release call can return access denied.
        IUnknown * pUnk = NULL;
        hr = pIMSAdminBase->QueryInterface(IID_IUnknown, (void **)&pUnk);
        if(FAILED(hr))
        {
            return hr;
        }
        if (FAILED(hr = auth.ApplyProxyBlanket(pUnk)))
        {
            goto DoEnumDataFromFile_Exit;
        }
        pUnk->Release();pUnk = NULL;
    }

    if (FAILED(hr = pIMSAdminBase->QueryInterface(IID_IMSImpExpHelp, (void **)&pIMSImpExpHelp)))
    {
        goto DoEnumDataFromFile_Exit;
    }

    if (auth.UsesImpersonation())
    {
        if (FAILED(hr = auth.ApplyProxyBlanket(pIMSImpExpHelp)))
        {
            goto DoEnumDataFromFile_Exit;
        }
    }
    else
    {
        // the local call needs min RPC_C_IMP_LEVEL_IMPERSONATE
        // for the pIMSAdminBase2 objects Import/Export functions!
        if (FAILED(hr = SetBlanket(pIMSImpExpHelp)))
        {
            //goto DoEnumDataFromFile_Exit;
        }
    }

    IISDebugOutput(_T("EnumeratePathsInFile:FileName=%s,PathType=%s\r\n"),bstrFileNameAndPath,bstrPathType);
    if (FAILED(hr = pIMSImpExpHelp->EnumeratePathsInFile(bstrFileNameAndPath, bstrPathType, dwBufferSize, pszBuffer, &dwBufferSize))) 
    {
        goto DoEnumDataFromFile_Exit;
    }

    pszBuffer = (WCHAR *) ::CoTaskMemAlloc(dwBufferSize * sizeof(WCHAR));
    if (NULL == pszBuffer)
    {
        hr = E_OUTOFMEMORY;
        goto DoEnumDataFromFile_Exit;
    }

    if (FAILED(hr = pIMSImpExpHelp->EnumeratePathsInFile(bstrFileNameAndPath, bstrPathType, dwBufferSize, pszBuffer, &dwBufferSize))) 
    {
        // free existing amount of space we asked for
        if (pszBuffer)
        {
            ::CoTaskMemFree(pszBuffer);
            pszBuffer = NULL;
        }

        goto DoEnumDataFromFile_Exit;
    }

    if (!pszBuffer || dwBufferSize <= 0)
    {
        goto DoEnumDataFromFile_Exit;
    }

    // see if returned an empty list...
    if (0 == _tcscmp(pszBuffer,_T("")))
    {
        goto DoEnumDataFromFile_Exit;
    }

    *pszMetabaseMultiszList = pszBuffer;

DoEnumDataFromFile_Exit:
    IISDebugOutput(_T("EnumeratePathsInFile:ret=0x%x\r\n"),hr);
	if (lpwstrTempPassword)
	{
		// security percaution:Make sure to zero out memory that temporary password was used for.
		SecureZeroMemory(lpwstrTempPassword,pConnectionInfo->cbUserPasswordEncrypted);
		LocalFree(lpwstrTempPassword);
		lpwstrTempPassword = NULL;
	}
    if (pIMSImpExpHelp) 
    {
        pIMSImpExpHelp->Release();
        pIMSImpExpHelp = NULL;
    }
    if (pIMSAdminBase) 
    {
        pIMSAdminBase->Release();
        pIMSAdminBase = NULL;
    }
    CoUninitialize();
    return hr;
}

void ImportDlgEnableButtons(HWND hDlg,PCOMMONDLGPARAM pcdParams,LPCTSTR lpszCurrentEnumedFileName)
{
    BOOL fEnableListControl = FALSE;
    BOOL fEnableOK = FALSE;
    BOOL fEnableBrowse = FALSE;
    BOOL fEnableEnum = FALSE;

    TCHAR szFullFileName[_MAX_PATH + 1];
    ZeroMemory(szFullFileName, sizeof(szFullFileName));
    GetDlgItemText(hDlg, IDC_EDIT_FILE, szFullFileName, _MAX_PATH);

    HWND hList = GetDlgItem(hDlg, IDC_LIST_OBJECT);
    int ItemIndex = ListView_GetNextItem(hList, -1, LVNI_ALL);
    if (ItemIndex < 0)
    {
        // no items in listview,disable what we need to
        fEnableListControl = FALSE;
        fEnableOK = FALSE;
    }
    else
    {
        fEnableListControl = TRUE;

        // Check if something is selected
        ItemIndex = ListView_GetNextItem(hList, -1, LVNI_SELECTED);
        if (ItemIndex < 0)
        {
            fEnableOK = FALSE;
        }
        else
        {
            fEnableOK = TRUE;
        }
    }

    // Check if we should enable the listcontrol at all...
    // see if the filename is the same
    if (0 != _tcsicmp(_T(""),lpszCurrentEnumedFileName))
    {
        // check for % characters
        // if there are any, expand them.
        LPTSTR pch = _tcschr( (LPTSTR) szFullFileName, _T('%'));
        if (pch && pcdParams->ConnectionInfo.IsLocal)
        {
            TCHAR szValue[_MAX_PATH + 1];
            TCHAR szValue2[_MAX_PATH + 1];
		    StringCbCopy(szValue, sizeof(szValue), szFullFileName);
            StringCbCopy(szValue2, sizeof(szValue2), lpszCurrentEnumedFileName);
            if (!ExpandEnvironmentStrings( (LPCTSTR)szFullFileName, szValue, sizeof(szValue)/sizeof(TCHAR)))
                {StringCbCopy(szValue, sizeof(szValue), szFullFileName);}
            if (!ExpandEnvironmentStrings( (LPCTSTR)lpszCurrentEnumedFileName, szValue2, sizeof(szValue2)/sizeof(TCHAR)))
                {StringCbCopy(szValue2, sizeof(szValue2), lpszCurrentEnumedFileName);}

            if (0 != _tcsicmp(szValue,szValue2))
            {
                // it's not the same file
                // so let's erase and disable the info in the list box.
                fEnableListControl = FALSE;
            }
        }
        else
        {
            if (0 != _tcsicmp(szFullFileName,lpszCurrentEnumedFileName))
            {
                // it's not the same file
                // so let's erase and disable the info in the list box.
                fEnableListControl = FALSE;
            }
        }
    }
    EnableWindow(hList, fEnableListControl);

    if (FALSE == IsWindowEnabled(hList))
    {
        fEnableOK = FALSE;
    }

    // Set focus on listbox
    //if (fEnableListControl){SetFocus(GetDlgItem(hDlg, IDC_LIST_OBJECT));}

    fEnableEnum = (SendMessage(GetDlgItem(hDlg,IDC_EDIT_FILE),EM_LINELENGTH,(WPARAM) -1, 0) != 0);

    // no browse button for remote case
    if (pcdParams)
    {
        if (pcdParams->ConnectionInfo.IsLocal)
            {fEnableBrowse = TRUE;}
    }

    // enable enum button
    EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_ENUM_FILE),fEnableEnum);

    // enable browse button
    EnableWindow(GetDlgItem(hDlg,IDC_BUTTON_BROWSE), fEnableBrowse);
    
    // enable OK button
    EnableWindow(GetDlgItem(hDlg, IDOK), fEnableOK);

    UpdateWindow(hDlg);
}

INT_PTR CALLBACK ShowImportDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    static PCOMMONDLGPARAM pcdParams;
    static TCHAR * pszMetabaseMultiszList = NULL;
    static CString strCurrentFileNameEnum;

    switch (msg)
    {
        case WM_INITDIALOG:
            pcdParams = (PCOMMONDLGPARAM)lParam;
            pszMetabaseMultiszList = NULL;
            TCHAR szFullFileName1[_MAX_PATH + 1];
            ZeroMemory(szFullFileName1, sizeof(szFullFileName1));
            if (DefaultValueSettingsLoad(pcdParams->ConnectionInfo.pszMachineName,LAST_USED_IMPORT_FILE,szFullFileName1))
            {
                if (0 != _tcscmp(szFullFileName1, _T("")))
                {
                    SetDlgItemText(hDlg, IDC_EDIT_FILE, szFullFileName1);
                }
            }
            strCurrentFileNameEnum = _T("");
            InitListView(GetDlgItem(hDlg, IDC_LIST_OBJECT));
            CenterWindow(GetParent(hDlg), hDlg);
            SetFocus(GetDlgItem(hDlg, IDC_EDIT_FILE));
            ImportDlgEnableButtons(hDlg,pcdParams,strCurrentFileNameEnum);
            EnableWindow(GetDlgItem(hDlg, IDC_LIST_OBJECT), FALSE);
            break;

    /*
      case WM_ACTIVATE:
            if (wParam == 0) 
            {
            }
            break;
    */

	    case WM_NOTIFY:
            {
                if((int)((LPNMHDR)lParam)->idFrom == IDC_LIST_OBJECT)
                {
                    switch (((LPNMHDR)lParam)->code)
                    {
                        case LVN_ITEMCHANGED:
                            ImportDlgEnableButtons(hDlg,pcdParams,strCurrentFileNameEnum);
                            break;

                        case NM_CLICK:
                            ImportDlgEnableButtons(hDlg,pcdParams,strCurrentFileNameEnum);
                            break;

                        case NM_DBLCLK:
                            if((int)((LPNMHDR)lParam)->idFrom == IDC_LIST_OBJECT)
                            {
                                PostMessage(hDlg,WM_COMMAND,IDOK,NULL);
                            }
                            break;
                        default:
                            break;
                    }
                }
                return FALSE;
		        break;
            }

        case WM_CLOSE:
            ListView_DeleteAllItems(GetDlgItem(hDlg, IDC_LIST_OBJECT));
            EndDialog(hDlg, IDCANCEL);
            return FALSE;
            break;

		case WM_HELP:
			LaunchHelp(hDlg,HIDD_IISUIOBJ_IMPORT);
			return TRUE;
			break;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDC_EDIT_FILE:
                    {
	                    switch (HIWORD(wParam))
                        {
	                        case EN_CHANGE:
								EditHideBalloon();
                                {
		                            // If the contents of the edit control have changed,
                                    // check if it's the same as the file that is currently enumed...
                                    HWND hList = GetDlgItem(hDlg, IDC_LIST_OBJECT);
                                    if (ListView_GetItemCount(hList) > 0)
                                    {
                                        TCHAR szFullFileName3[_MAX_PATH + 1];
                                        ZeroMemory(szFullFileName3, sizeof(szFullFileName3));
                                        GetDlgItemText(hDlg, IDC_EDIT_FILE, szFullFileName3, _MAX_PATH);

                                        // see if the filename is the same as this one!
                                        if (!strCurrentFileNameEnum.IsEmpty())
                                        {
                                            if (0 != _tcsicmp(szFullFileName3,strCurrentFileNameEnum))
                                            {
                                                // it's not the same file
                                                // so let's erase and disable the info in the list box.
                                                EnableWindow(hList, FALSE);
                                            }
                                        }
                                    }
                                    ImportDlgEnableButtons(hDlg,pcdParams,strCurrentFileNameEnum);
		                            break;
                                }
                            case EN_MAXTEXT:
	                        case EN_ERRSPACE:
		                        // If the control is out of space, honk
		                        MessageBeep (0);
		                        break;
	                        default:
                                break;
	                    }
	                    return TRUE;
                        break;
                    }

                case IDC_BUTTON_BROWSE:
                    {
                        TCHAR szOldFilePath[_MAX_PATH + 1];
                        GetDlgItemText(hDlg, IDC_EDIT_FILE, szOldFilePath, _MAX_PATH);

                        TCHAR szNewFilePath[_MAX_PATH + 1];
						ZeroMemory(szNewFilePath, sizeof(szNewFilePath));

                        if (BrowseForFile(szOldFilePath,szNewFilePath,sizeof(szNewFilePath)))
                        {
                            if (0 != _tcsicmp(szNewFilePath, _T("")))
                            {
                                SetDlgItemText(hDlg, IDC_EDIT_FILE, szNewFilePath);
                                UpdateWindow(hDlg);
                            }
                        }
                        ImportDlgEnableButtons(hDlg,pcdParams,strCurrentFileNameEnum);
                        return FALSE;
                        break;
                    }

                case IDC_BUTTON_ENUM_FILE:
                    {
                        BOOL bThingsAreKool = TRUE;
                        TCHAR szFullFileName2[_MAX_PATH + 1];
                        ZeroMemory(szFullFileName2, sizeof(szFullFileName2));
                        GetDlgItemText(hDlg, IDC_EDIT_FILE, szFullFileName2, _MAX_PATH);

                        // check for % characters
                        // if there are any, expand them.
                        LPTSTR pch = _tcschr( (LPTSTR) szFullFileName2, _T('%'));
                        if (pch)
                        {
                            if (pcdParams->ConnectionInfo.IsLocal)
                            {
                                TCHAR szValue[_MAX_PATH + 1];
		                        StringCbCopy(szValue, sizeof(szValue), szFullFileName2);
                                if (!ExpandEnvironmentStrings( (LPCTSTR)szFullFileName2, szValue, sizeof(szValue)/sizeof(TCHAR)))
                                    {
				                        StringCbCopy(szValue, sizeof(szValue), szFullFileName2);
			                        }
                                    StringCbCopy(szFullFileName2, sizeof(szFullFileName2), szValue);
                                    bThingsAreKool = TRUE;
                            }
                            else
                            {
                                // we don't support % characters on remote systems.
                                EditShowBalloon(GetDlgItem(hDlg, IDC_EDIT_FILE),_Module.GetResourceInstance(),IDS_FILENAME_NOREMOTE_EXPAND);
                                bThingsAreKool = FALSE;
                            }
                        }

                        if (bThingsAreKool)
                        {
                            if (pcdParams->ConnectionInfo.IsLocal)
                            {
                                if (!IsFileExist(szFullFileName2))
                                {
                                    bThingsAreKool = FALSE;

                                    EditShowBalloon(GetDlgItem(hDlg, IDC_EDIT_FILE),_Module.GetResourceInstance(),IDS_FILE_NOT_FOUND);
                                }
                            }
                        }

                        if (bThingsAreKool)
                        {
                            TCHAR szNodeType[50];
							ZeroMemory(szNodeType, sizeof(szNodeType));

                            if (pcdParams->pszKeyType)
                            {
                                HRESULT hr = ERROR_SUCCESS;
								StringCbCopy(szNodeType, sizeof(szNodeType), pcdParams->pszKeyType);
                                if (0 != _tcsicmp(szNodeType,_T("")))
                                {
                                    HWND hList = GetDlgItem(hDlg, IDC_LIST_OBJECT);

                                    // Erase existing data in list box...
                                    ListView_DeleteAllItems(hList);
                                    // free up the preiously used pointer if we already have memory freed
                                    if (pszMetabaseMultiszList)
                                    {
                                        ::CoTaskMemFree(pszMetabaseMultiszList);
                                        pszMetabaseMultiszList = NULL;
                                    }

                                    if (SUCCEEDED(hr = DoEnumDataFromFile(&pcdParams->ConnectionInfo,szFullFileName2,szNodeType,&pszMetabaseMultiszList)))
                                    {
                                        strCurrentFileNameEnum = szFullFileName2;

                                        if (pszMetabaseMultiszList)
                                        {
                                            // filter out stuff we don't want the user to see...
                                            hr = FillListBoxWithMultiSzData(hList,szNodeType,pszMetabaseMultiszList);
                                            //DumpStrInMultiStr(pszMetabaseMultiszList);
                                            if (SUCCEEDED(hr))
                                            {
										        if (0 != _tcscmp(szFullFileName2, _T("")))
                                                {
                                                    DefaultValueSettingsSave(pcdParams->ConnectionInfo.pszMachineName,LAST_USED_IMPORT_FILE,szFullFileName2);
                                                }
                                            }
                                        }
										else
										{
											// check if there was anything returned...
											// if there was then we got something back
											// which doesn't have the objects we asked for
											CString strMsg;
											CString strFormat;
											CString strObjectType;
											BOOL bFound = FALSE;
											//IIS_CLASS_WEB_SERVER_W
											//IIS_CLASS_FTP_SERVER_W
											//IIS_CLASS_WEB_VDIR_W
											//IIS_CLASS_FTP_VDIR_W
											//IIsApplicationPool
											if (0 == _tcscmp(szNodeType,IIS_CLASS_WEB_SERVER_W))
											{
												strObjectType = IIS_CLASS_WEB_SERVER_W;
												strObjectType.LoadString(_Module.GetResourceInstance(), IDS_STRING_WEB_SERVER);
												bFound = TRUE;
											}
											else if (0 == _tcscmp(szNodeType,IIS_CLASS_FTP_SERVER_W))
											{
												strObjectType = IIS_CLASS_FTP_SERVER_W;
												strObjectType.LoadString(_Module.GetResourceInstance(), IDS_STRING_FTP_SERVER);
												bFound = TRUE;
											}
											else if (0 == _tcscmp(szNodeType,IIS_CLASS_WEB_VDIR_W))
											{
												strObjectType = IIS_CLASS_WEB_VDIR_W;
												strObjectType.LoadString(_Module.GetResourceInstance(), IDS_STRING_WEB_VDIR);
												bFound = TRUE;
											}
											else if (0 == _tcscmp(szNodeType,IIS_CLASS_FTP_VDIR_W))
											{
												strObjectType = IIS_CLASS_FTP_VDIR_W;
												strObjectType.LoadString(_Module.GetResourceInstance(), IDS_STRING_FTP_VDIR);
												bFound = TRUE;
											}
											else if (0 == _tcscmp(szNodeType,_T("IIsApplicationPool")))
											{
												strObjectType = _T("IIsApplicationPool");
												strObjectType.LoadString(_Module.GetResourceInstance(), IDS_STRING_APP_POOL);
												bFound = TRUE;
											}
											if (bFound)
											{
												strFormat.LoadString(_Module.GetResourceInstance(), IDS_IMPORT_MISMATCH);
												strMsg.FormatMessage((LPCTSTR) strFormat,(LPCTSTR) strObjectType,(LPCTSTR) strObjectType,(LPCTSTR) strObjectType);
												EditShowBalloon(GetDlgItem(hDlg, IDC_EDIT_FILE),(LPCTSTR) strMsg);
											}
										}
                                    }
									else
									{
										if (HRESULTTOWIN32(hr) == ERROR_FILE_NOT_FOUND)
										{
											EditShowBalloon(
												GetDlgItem(hDlg, IDC_EDIT_FILE),
												_Module.GetResourceInstance(),IDS_FILE_NOT_FOUND);
										}
									}
                                }
                            }
                        }
                        ImportDlgEnableButtons(hDlg,pcdParams,strCurrentFileNameEnum);
                        return FALSE;
                        break;
                    }

                case IDC_LIST_OBJECT:
                    {
                        ImportDlgEnableButtons(hDlg,pcdParams,strCurrentFileNameEnum);
                        return FALSE;
                        break;
                    }

                case IDHELP:
					LaunchHelp(hDlg,HIDD_IISUIOBJ_IMPORT);
                    return TRUE;

                case IDCANCEL:
                    {
                        ListView_DeleteAllItems(GetDlgItem(hDlg, IDC_LIST_OBJECT));

                        // free up memory we may have allocated...
                        if (pszMetabaseMultiszList)
                        {
                            ::CoTaskMemFree(pszMetabaseMultiszList);
                            pszMetabaseMultiszList = NULL;
                        }

                        EndDialog(hDlg,(int)wParam);
                        return FALSE;
                        break;
                    }

                case IDOK:
                    if (TRUE == OnImportOK(hDlg,&pcdParams->ConnectionInfo,pcdParams->pszKeyType,pcdParams->pszMetabasePath,pcdParams->dwImportFlags))
                    {
                        TCHAR szFullFileName3[_MAX_PATH + 1];
                        ZeroMemory(szFullFileName3, sizeof(szFullFileName3));
                        GetDlgItemText(hDlg, IDC_EDIT_FILE, szFullFileName3, _MAX_PATH);

                        ListView_DeleteAllItems(GetDlgItem(hDlg, IDC_LIST_OBJECT));
                        // free up memory we may have allocated...
                        if (pszMetabaseMultiszList)
                        {
                            ::CoTaskMemFree(pszMetabaseMultiszList);
                            pszMetabaseMultiszList = NULL;
                        }
                        return TRUE;
                    }
                    else
                    {
                        return FALSE;
                    }
                    break;
            }
            break;
    }
    return FALSE;
}

BOOL OnImportOK(HWND hDlg,PCONNECTION_INFO pConnectionInfo,LPCTSTR szKeyType,LPCTSTR szCurrentMetabasePath,DWORD dwImportFlags)
{
    BOOL bPleaseProceed = FALSE;
    HRESULT hr = ERROR_SUCCESS;
    INT  iReturnedFlag = 0;

    TCHAR szFullFileName[_MAX_PATH + 1];
    TCHAR szNewPassword[PWLEN + 1];

    LPTSTR pszSourcePath = NULL;
    LPTSTR pszDestinationPathMungeAble = NULL;
    DWORD dwDestinationPathMungeAble = 0;
    LPTSTR pszSaveSafeCopy = NULL;

    int ItemIndex = 0;
    LVITEM lviGet;
    memset(&lviGet, 0, sizeof(lviGet));

    // Get the filepath which this tree was created from.
    // could have changed since user edited edit box...
    // so get the one that the tree was created from...
    GetDlgItemText(hDlg, IDC_EDIT_FILE, szFullFileName, _MAX_PATH);

	SecureZeroMemory(szNewPassword, sizeof(szNewPassword));
	
    if (ListView_GetSelectedCount(GetDlgItem(hDlg, IDC_LIST_OBJECT)) <= 0)
    {
        goto OnImportOK_Exit;
    }

    // Get the metabase path the user selected..
    ItemIndex = ListView_GetNextItem(GetDlgItem(hDlg, IDC_LIST_OBJECT), -1, LVNI_SELECTED);
    if (-1 == ItemIndex)
    {
        goto OnImportOK_Exit;
    }

    ZeroMemory(&lviGet, sizeof(LVITEM));

    lviGet.iItem	= ItemIndex;
    lviGet.iSubItem = 0;
    lviGet.mask = LVIF_PARAM;
    lviGet.lParam = NULL;
	if (FALSE == ListView_GetItem(GetDlgItem(hDlg, IDC_LIST_OBJECT), &lviGet))
    {
        goto OnImportOK_Exit;
    }

    if (lviGet.lParam)
    {
        // figure out how big of a buffer do we need...
        int iLen = _tcslen((LPTSTR) lviGet.lParam) + 1;

        pszSourcePath = (LPTSTR) LocalAlloc(LPTR, iLen * sizeof(TCHAR));
        if (!pszSourcePath)
        {
            goto OnImportOK_Exit;
        }
        StringCbCopy(pszSourcePath,(iLen * sizeof(TCHAR)), (WCHAR *) lviGet.lParam);

        dwDestinationPathMungeAble = iLen * sizeof(TCHAR);
        pszDestinationPathMungeAble = (LPTSTR) LocalAlloc(LPTR, dwDestinationPathMungeAble);
        if (!pszDestinationPathMungeAble)
        {
            goto OnImportOK_Exit;
        }
        // make the destination path the same as what we got from the file!
        StringCbCopy(pszDestinationPathMungeAble,dwDestinationPathMungeAble,pszSourcePath);
    }

    // Clean the metabase to work with Import...
    // we have something like this in the list
    // LM/W3SVC/1/ROOT/MyDir

    // -----------------------------------
    // Check to see if the destination path already exists!!!!
    // if it already does, then popup a msg box to get another from the user!
    // -----------------------------------
    do
    {
        iReturnedFlag = 0;

        IISDebugOutput(_T("CleanDestinationPathForVdirs:before:KeyType=%s,CurPath=%s,MetabasePathDestination=%s\r\n"),szKeyType,szCurrentMetabasePath,pszDestinationPathMungeAble);
        if (FAILED(hr = CleanDestinationPathForVdirs(szKeyType,szCurrentMetabasePath,&pszDestinationPathMungeAble,&dwDestinationPathMungeAble)))
        {
            // something failed, let's just stay on this dialog
            bPleaseProceed = FALSE;
            goto OnImportOK_Exit;
        }
        IISDebugOutput(_T("CleanDestinationPathForVdirs:after :KeyType=%s,CurPath=%s,MetabasePathDestination=%s\r\n"),szKeyType,szCurrentMetabasePath,pszDestinationPathMungeAble);

        // allocate the new space
        int cbSafeCopy = (_tcslen(pszDestinationPathMungeAble)+ 1) * sizeof(TCHAR);
        if (pszSaveSafeCopy)
            {LocalFree(pszSaveSafeCopy);pszSaveSafeCopy=NULL;}

        pszSaveSafeCopy = (LPTSTR) LocalAlloc(LPTR, cbSafeCopy);
        if (!pszSaveSafeCopy)
        {
            bPleaseProceed = FALSE;
            goto OnImportOK_Exit;
        }
        // copy the data to the new buffer
        StringCbCopy(pszSaveSafeCopy,cbSafeCopy,pszDestinationPathMungeAble);

        if (FALSE == GetNewDestinationPathIfEntryExists(hDlg,pConnectionInfo,szKeyType,&pszDestinationPathMungeAble,&dwDestinationPathMungeAble,&iReturnedFlag))
        {
            // cancelled, so let's just stay on this dialog
            bPleaseProceed = FALSE;
            goto OnImportOK_Exit;
        }
        else
        {
            if (1 == iReturnedFlag)
            {
                // The destination path already exists and we should overwrite
                // we should overwrite

                // Get the original destination path
                // since it could already have been munged...
                StringCbCopy(pszDestinationPathMungeAble,dwDestinationPathMungeAble,pszSaveSafeCopy);
                break;
            }
            else if (2 == iReturnedFlag)
            {
                // the path didn't already exists so we can write it out now...
                break;
            }
            else
            {
                // we got a new pszDestinationPathMungeAble
                // go thru the loop again.
            }
        }
    } while (TRUE);

    // if we get down here
    // it's because we have a pszDestinationPathMungeAble that we
    // can write to or overwrite...
    // we will never get here is the user cancelled...
    do
    {
        // Perform the action...
        // if it fails then ask for a password...
        if (FAILED(hr = DoImportConfigFromFile(pConnectionInfo,szFullFileName,pszSourcePath,pszDestinationPathMungeAble,szNewPassword,dwImportFlags)))
        {
            // Check if it failed because the site/vdir/app pool already exists...
            // if that's the error, then ask the user for a new path...

            // If it failed because of bad password, then say so
            if (0x8007052B == hr)
            {
                // See if the user wants to try again.
                // if they do, then try it with the new password...
                if (IDCANCEL == DialogBoxParam((HINSTANCE) _Module.m_hInst, MAKEINTRESOURCE(IDD_DIALOG_GET_PASSWORD), hDlg, ShowPasswordDlgProc, (LPARAM) szNewPassword))
                {
                    // the user cancelled...
                    // so we should just stay on this page...
                    // cancelled, so let's just stay on this dialog
                    bPleaseProceed = FALSE;
                    break;
                }
                else
                {
                    // try it again with the new password...
                }
            }
            else if (HRESULTTOWIN32(hr) == ERROR_NO_MATCH)
            {
                bPleaseProceed = FALSE;
                break;
            }
            else
            {
                // if it failed or some reason
                // then get out of loop
                // hr holds the error
                CError err(hr);
                err.MessageBox();
                bPleaseProceed = FALSE;
                break;
            }
        }
        else
        {
            // Succeeded to import the config from the file
            // let's get out
            bPleaseProceed = TRUE;
            ListView_DeleteAllItems(GetDlgItem(hDlg, IDC_LIST_OBJECT));

            //
            // If we imported then, we need to do some fixup....
            //
            // make sure to append on the "root" stuff...
            if (0 == _tcscmp(szKeyType,IIS_CLASS_WEB_SERVER_W))
            {
                // figure out how big of a buffer do we need...
                int iLen = _tcslen((LPTSTR) pszSourcePath) + _tcslen(_T("/ROOT")) + 1;
                LPTSTR pszNewPath = (LPTSTR) LocalAlloc(LPTR, iLen * sizeof(TCHAR));
                if (pszNewPath)
                {
                    StringCbCopy(pszNewPath,(iLen * sizeof(TCHAR)), (TCHAR *) pszSourcePath);
                    StringCbCat(pszNewPath,(iLen * sizeof(TCHAR)), (TCHAR *) _T("/ROOT"));

                    // figure out how big of a buffer do we need...
                    iLen = _tcslen((LPTSTR) pszDestinationPathMungeAble) + _tcslen(_T("/ROOT")) + 1;
                    LPTSTR pszNewPath2 = (LPTSTR) LocalAlloc(LPTR, iLen * sizeof(TCHAR));
                    if (pszNewPath2)
                    {
                        StringCbCopy(pszNewPath2,(iLen * sizeof(TCHAR)), (TCHAR *) pszDestinationPathMungeAble);
                        StringCbCat(pszNewPath2,(iLen * sizeof(TCHAR)), (TCHAR *) _T("/ROOT"));

                        hr = FixupImportAppRoot(pConnectionInfo,pszNewPath,pszNewPath2);
                    }
                }
            }
            else if (0 == _tcscmp(szKeyType,IIS_CLASS_WEB_VDIR_W))
            {
                hr = FixupImportAppRoot(pConnectionInfo,pszSourcePath,pszDestinationPathMungeAble);
            }

            EndDialog(hDlg, IDOK);
            break;
        }
    } while (FAILED(hr));

OnImportOK_Exit:
    if (pszSourcePath)
    {
        LocalFree(pszSourcePath);pszSourcePath=NULL;
    }
    if (pszDestinationPathMungeAble)
    {
        LocalFree(pszDestinationPathMungeAble);pszDestinationPathMungeAble=NULL;
    }
    if (pszSaveSafeCopy)
    {
        LocalFree(pszSaveSafeCopy);pszSaveSafeCopy=NULL;
    }
	// make sure this doesn't hang around in memory
	SecureZeroMemory(szNewPassword, sizeof(szNewPassword));
    return bPleaseProceed;
}

// IIsWebServer
// IIsWebVirtualDir
// IIsFtpServer
// IIsFtpVirtualDir
// IIsApplicationPool
BOOL GetNewDestinationPathIfEntryExists(HWND hDlg,PCONNECTION_INFO pConnectionInfo,LPCTSTR szKeyType,LPTSTR * pszDestinationPathMungeAble,DWORD * pcbDestinationPathMungeAble,INT * iReturnedFlag)
{
    BOOL bPleaseProceed = FALSE;

    // IF iReturnedFlag = 0 then don't overwrite and don't use the new path
    // IF iReturnedFlag = 1 then overwrite the existing entry
    // IF iReturnedFlag = 2 then use the newly created path
    *iReturnedFlag = 0;

    if (!pConnectionInfo)
    {
        goto GetNewDestinationPathIfEntryExists_Exit;
    }

    BOOL bEntryAlreadyThere = IsMetabaseWebSiteKeyExistAuth(pConnectionInfo,*pszDestinationPathMungeAble);
    if (FALSE == bEntryAlreadyThere)
    {
        bPleaseProceed = TRUE;
        *iReturnedFlag = 2;
        goto GetNewDestinationPathIfEntryExists_Exit;
    }

    // at this point
    // the destination path already exists in the metabase
    // Popup a dialog to get the user to pick a different DestinationPath

    // figure out which one of the dialogs we need to display and get another path from the user...
    if (0 == _tcscmp(szKeyType,IIS_CLASS_WEB_SERVER_W) || 0 == _tcscmp(szKeyType,IIS_CLASS_FTP_SERVER_W) )
    {
        INT_PTR iRet = DialogBox((HINSTANCE) _Module.m_hInst, MAKEINTRESOURCE(IDD_DIALOG_EXISTS_SITE), hDlg, ShowSiteExistsDlgProc);
        switch(iRet)
        {
            case IDCANCEL:
                bPleaseProceed = FALSE;
                *iReturnedFlag = 0;
                break;
            case IDC_RADIO1: // create new site...
                {
                    bPleaseProceed = TRUE;
                    *iReturnedFlag = 0;

                    // Get the new size that we're going to need...
                    LPTSTR pNewPointer = NULL;
                    INT iNewSize = 0;
                    if (0 == _tcscmp(szKeyType,IIS_CLASS_WEB_SERVER_W))
                    {
                        iNewSize = _tcslen(SZ_MBN_MACHINE SZ_MBN_SEP_STR SZ_MBN_WEB SZ_MBN_SEP_STR) + 10 + 1;
                    }
                    else
                    {
                        iNewSize = _tcslen(SZ_MBN_MACHINE SZ_MBN_SEP_STR SZ_MBN_FTP SZ_MBN_SEP_STR) + 10 + 1;
                    }

                    pNewPointer = (LPTSTR) LocalAlloc(LPTR, iNewSize * sizeof(TCHAR));
                    if (!pNewPointer)
                    {
                        bPleaseProceed = FALSE;
                        *iReturnedFlag = 0;
                        goto GetNewDestinationPathIfEntryExists_Exit;
                    }

                    // Generate a new site ID
                    if (0 == _tcscmp(szKeyType,IIS_CLASS_WEB_SERVER_W))
                    {
					    StringCbPrintf(pNewPointer,(iNewSize * sizeof(TCHAR)),SZ_MBN_MACHINE SZ_MBN_SEP_STR SZ_MBN_WEB SZ_MBN_SEP_STR _T("%d"), GetUniqueSite(SZ_MBN_MACHINE SZ_MBN_SEP_STR SZ_MBN_WEB));
                    }
                    else
                    {
					    StringCbPrintf(pNewPointer,(iNewSize * sizeof(TCHAR)),SZ_MBN_MACHINE SZ_MBN_SEP_STR SZ_MBN_FTP SZ_MBN_SEP_STR _T("%d"), GetUniqueSite(SZ_MBN_MACHINE SZ_MBN_SEP_STR SZ_MBN_FTP));
                    }

                    LocalFree((LPTSTR) *pszDestinationPathMungeAble);*pszDestinationPathMungeAble=NULL;
                    *pszDestinationPathMungeAble = pNewPointer;
                    *pcbDestinationPathMungeAble = (iNewSize * sizeof(TCHAR));

                    //IISDebugOutput(_T("Create new site:[%s]\r\n"),*pszDestinationPathMungeAble);
                    break;
                }
            case IDC_RADIO2: // replace existing..
                bPleaseProceed = TRUE;
                *iReturnedFlag = 1;
                break;
            default:
                bPleaseProceed = FALSE;
                *iReturnedFlag = 0;
                break;
        }
    }
    else if (0 == _tcscmp(szKeyType,IIS_CLASS_WEB_VDIR_W) || 0 == _tcscmp(szKeyType,IIS_CLASS_FTP_VDIR_W))
    {
        TCHAR szMetabaseVDir[_MAX_PATH + 1];
		ZeroMemory(szMetabaseVDir, sizeof(szMetabaseVDir));
        
        INT_PTR iRet = DialogBoxParam((HINSTANCE) _Module.m_hInst, MAKEINTRESOURCE(IDD_DIALOG_EXISTS_VDIR), hDlg, ShowVDirExistsDlgProc, (LPARAM) szMetabaseVDir);
        switch(iRet)
        {
            case IDCANCEL:
                bPleaseProceed = FALSE;
                *iReturnedFlag = 0;
                break;
            case IDC_RADIO1: // create new site...
                {
                    bPleaseProceed = TRUE;
                    *iReturnedFlag = 0;

                    // Get VDir Name that the user input on that screeen...
                    // Generate a VDir Name
                    CString strOriginalDestPath = *pszDestinationPathMungeAble;
                    CString strNewPath, strRemainder;
                    // Is this the root??
                    LPCTSTR lpPath1 = CMetabasePath::GetRootPath(strOriginalDestPath, strNewPath, &strRemainder);
                    if (lpPath1)
                    {
                        // Allocate enough space for the new path...
                        LPTSTR pNewPointer = NULL;
                        DWORD iNewSize = 0;
                        iNewSize = _tcslen(lpPath1) + _tcslen(szMetabaseVDir) + 2;

                        pNewPointer = (LPTSTR) LocalAlloc(LPTR, iNewSize * sizeof(TCHAR));
                        if (!pNewPointer)
                        {
                            bPleaseProceed = FALSE;
                            *iReturnedFlag = 0;
                            goto GetNewDestinationPathIfEntryExists_Exit;
                        }

                        // if this is the root dir...
					    StringCbCopy(pNewPointer,iNewSize * sizeof(TCHAR),lpPath1);
                        AddEndingMetabaseSlashIfNeedTo(pNewPointer,iNewSize * sizeof(TCHAR));
					    StringCbCat(pNewPointer,iNewSize * sizeof(TCHAR),szMetabaseVDir);

                        LocalFree((LPTSTR) *pszDestinationPathMungeAble);*pszDestinationPathMungeAble=NULL;
                        *pszDestinationPathMungeAble = pNewPointer;
                        *pcbDestinationPathMungeAble = (iNewSize * sizeof(TCHAR));

                        //IISDebugOutput(_T("Create new vdir:[%s]\r\n"),*pszDestinationPathMungeAble);
                    }   
                    break;
                }
            case IDC_RADIO2: // replace existing...
                bPleaseProceed = TRUE;
                *iReturnedFlag = 1;
                break;
            default:
                bPleaseProceed = FALSE;
                *iReturnedFlag = 0;
                break;
        }
    }
    else if (0 == _tcscmp(szKeyType,L"IIsApplicationPool"))
    {
        TCHAR szMetabaseAppPool[_MAX_PATH + 1];
		ZeroMemory(szMetabaseAppPool,sizeof(szMetabaseAppPool));

        INT_PTR iRet = DialogBoxParam((HINSTANCE) _Module.m_hInst, MAKEINTRESOURCE(IDD_DIALOG_EXISTS_APP_POOL), hDlg, ShowAppPoolExistsDlgProc, (LPARAM) szMetabaseAppPool);
        switch(iRet)
        {
            case IDCANCEL:
                bPleaseProceed = FALSE;
                *iReturnedFlag = 0;
                break;
            case IDC_RADIO1: // create new site...
                {
                    bPleaseProceed = TRUE;
                    *iReturnedFlag = 0;

                    // Allocate enough space for the new path...
                    LPTSTR pNewPointer = NULL;
                    INT iNewSize = 0;
                    iNewSize = _tcslen(SZ_MBN_MACHINE SZ_MBN_SEP_STR SZ_MBN_WEB SZ_MBN_SEP_STR SZ_MBN_APP_POOLS SZ_MBN_SEP_STR) +
                                _tcslen(szMetabaseAppPool) + 1;

                    pNewPointer = (LPTSTR) LocalAlloc(LPTR, iNewSize * sizeof(TCHAR));
                    if (!pNewPointer)
                    {
                        bPleaseProceed = FALSE;
                        *iReturnedFlag = 0;
                        goto GetNewDestinationPathIfEntryExists_Exit;
                    }

                    // Get The New AppPool Name that the user input on that screeen...
                    StringCbPrintf(pNewPointer,(iNewSize * sizeof(TCHAR)),SZ_MBN_MACHINE SZ_MBN_SEP_STR SZ_MBN_WEB SZ_MBN_SEP_STR SZ_MBN_APP_POOLS SZ_MBN_SEP_STR _T("%s"),szMetabaseAppPool);

                    LocalFree((LPTSTR) *pszDestinationPathMungeAble);*pszDestinationPathMungeAble=NULL;
                    *pszDestinationPathMungeAble = pNewPointer;
                    *pcbDestinationPathMungeAble = (iNewSize * sizeof(TCHAR));

                    //IISDebugOutput(_T("Create new AppPool:[%s]\r\n"),*pszDestinationPathMungeAble);
                    break;
                }
            case IDC_RADIO2: // replace existing...
                bPleaseProceed = TRUE;
                *iReturnedFlag = 1;
                break;
            default:
                bPleaseProceed = FALSE;
                *iReturnedFlag = 0;
                break;
        }
    }
    else
    {
        // nothing matches, get out
        bPleaseProceed = FALSE;
    }

GetNewDestinationPathIfEntryExists_Exit:
    return bPleaseProceed;
}


HRESULT CleanDestinationPathForVdirs(LPCTSTR szKeyType,LPCTSTR szCurrentMetabasePath,LPTSTR * pszDestinationPathMungeMe,DWORD * pcbDestinationPathMungeMe)
{
    HRESULT hReturn = E_FAIL;
    BOOL bCreateAFirstLevelVdir = FALSE;

    LPTSTR pszLastPart = NULL;
    LPTSTR pszLastPartNew = NULL;
    int    iLastPartNewSize = 0;
    INT iChars = 0;
    DWORD cbNewPointer = 0;
    LPTSTR pNewPointer = NULL;

    if (!CleanMetaPath(pszDestinationPathMungeMe,pcbDestinationPathMungeMe))
    {
        hReturn = E_POINTER;
    }

    if (0 == _tcscmp(szKeyType,IIS_CLASS_WEB_SERVER_W) || 0 == _tcscmp(szKeyType,IIS_CLASS_FTP_SERVER_W) )
    {
        hReturn = S_OK;
    }
    else if (0 == _tcscmp(szKeyType,IIS_CLASS_WEB_VDIR_W) || 0 == _tcscmp(szKeyType,IIS_CLASS_FTP_VDIR_W))
    {
        hReturn = E_FAIL;

        // szCurrentMetabasePath probably looks like:
        //         lm/w3svc/500/ROOT/CurrentSite
        //         lm/w3svc/500/ROOT
        //         lm/w3svc/500
        // *pszDestinationPathMungeMe probably looks like:
        //         lm/w3svc/23/ROOT/MyOldSite
        //         lm/w3svc/23/ROOT
        //
        // make *pszDestinationPathMungeMe look like lm/w3svc/500/ROOT/MyOldSite
        // 
        // Get the lm/w3svc/sitenum part of szCurrentMetabasePath
        //
        if (0 == _tcscmp(szKeyType,IIS_CLASS_WEB_VDIR_W))
        {
            //IISDebugOutput(_T("CleanDestinationPathForVdirs:KeyType=%s,CurPath=%s,MetabasePathDestination=%s\r\n"),szKeyType,szCurrentMetabasePath,*pszDestinationPathMungeMe);

            // Get Vdir we want to append...
            // should look like "ROOT/MyVdir"
            CString strSiteNode, strRemainder_WithRoot;
            LPCTSTR lpPath1 = CMetabasePath::TruncatePath(3, *pszDestinationPathMungeMe, strSiteNode, &strRemainder_WithRoot);
			if (lpPath1){}

            if (strRemainder_WithRoot.IsEmpty())
            {
                hReturn = E_INVALIDARG;
                goto CleanDestinationPathForVdirs_Exit;
            }

            if (IsWebSitePath(szCurrentMetabasePath))
            {
                // if our current metabase path is already a site node, then add them together
                // /LM/W3SVC/1 + / + ROOT/MyVdir

                // figure out how much space we need.
                iChars = _tcslen(szCurrentMetabasePath) + _tcslen(strRemainder_WithRoot) + 2; // includes extra slash
                cbNewPointer = iChars * sizeof(TCHAR);

                // allocate the new space
                pNewPointer = NULL;
                pNewPointer = (LPTSTR) LocalAlloc(LPTR, cbNewPointer);
                if (!pNewPointer)
                {
                    hReturn = E_OUTOFMEMORY;
                    goto CleanDestinationPathForVdirs_Exit;
                }

                // copy the data to the new buffer
                StringCbCopy(pNewPointer,cbNewPointer,szCurrentMetabasePath);
                AddEndingMetabaseSlashIfNeedTo(pNewPointer,cbNewPointer);
                StringCbCat(pNewPointer,cbNewPointer,(LPCTSTR) strRemainder_WithRoot);

                // Free the old one.
                LocalFree(*pszDestinationPathMungeMe);*pszDestinationPathMungeMe=NULL;

                // point to the new buffer
                *pszDestinationPathMungeMe = pNewPointer;
                *pcbDestinationPathMungeMe = cbNewPointer;

                hReturn = S_OK;
            }
            else if (IsWebSiteVDirPath(szCurrentMetabasePath,FALSE))
            {
                // we failed to get farther, just treat it as a new vdir
                bCreateAFirstLevelVdir = TRUE;

                // if our current metabase path is already a vdir/physical path dir...then do some funky magic
                pszLastPart = NULL;
                pszLastPartNew = NULL;
                iLastPartNewSize = 0;

                BOOL bIsRootVdir = IsRootVDir(*pszDestinationPathMungeMe);

                pszLastPart = GimmiePointerToLastPart(*pszDestinationPathMungeMe);
                if (pszLastPart)
                {
                    bCreateAFirstLevelVdir = FALSE;
                    iLastPartNewSize = _tcslen(pszLastPart) + 1;

                    pszLastPartNew = (LPTSTR) LocalAlloc(LPTR, iLastPartNewSize * sizeof(TCHAR));
                    if (!pszLastPartNew)
                    {
                        hReturn = E_OUTOFMEMORY;
                        goto CleanDestinationPathForVdirs_Exit;
                    }
					StringCbCopy(pszLastPartNew, iLastPartNewSize * sizeof(TCHAR),pszLastPart);
                }

                // check if the site that the user is currently on, is a vdir or physical dir...
                if (bCreateAFirstLevelVdir)
                {
                    // /LM/W3SVC/1 + / + ROOT/MyNewVdir
                    CString strRemainder_Temp;
                    LPCTSTR lpPath2 = CMetabasePath::TruncatePath(3, szCurrentMetabasePath, strSiteNode, &strRemainder_Temp);
					if (lpPath2){}
                    if (strSiteNode.IsEmpty())
                    {
                        hReturn = E_INVALIDARG;
                        goto CleanDestinationPathForVdirs_Exit;
                    }

                    // figure out how much space we need.
                    iChars = _tcslen(strSiteNode) + _tcslen(strRemainder_WithRoot) + 2; // includes extra slash
                    cbNewPointer = iChars * sizeof(TCHAR);

                    // allocate it
                    pNewPointer = NULL;
                    pNewPointer = (LPTSTR) LocalAlloc(LPTR, cbNewPointer);
                    if (!pNewPointer)
                    {
                        hReturn = E_OUTOFMEMORY;
                        goto CleanDestinationPathForVdirs_Exit;
                    }

                    // Copy to new buffer
				    StringCbCopy(pNewPointer,cbNewPointer,strSiteNode);
                    AddEndingMetabaseSlashIfNeedTo(pNewPointer,cbNewPointer);
				    StringCbCat(pNewPointer,cbNewPointer,(LPCTSTR) strRemainder_WithRoot);

                    // Free the old one.
                    LocalFree(*pszDestinationPathMungeMe);*pszDestinationPathMungeMe=NULL;

                    // point to the new buffer
                    *pszDestinationPathMungeMe = pNewPointer;
                    *pcbDestinationPathMungeMe = cbNewPointer;
                }
                else
                {
                    // /LM/W3SVC/1/ROOT/MyOldVdirThatIwantToKeep + / + MyNewVdir

                    // figure out how much space we need.
                    iChars = _tcslen(szCurrentMetabasePath) + 2; // includes extra slash
                    if (pszLastPartNew)
                    {
                        iChars = iChars + _tcslen(pszLastPartNew);
                    }
                    cbNewPointer = iChars * sizeof(TCHAR);

                    // allocate the new amt of space
                    pNewPointer = NULL;
                    pNewPointer = (LPTSTR) LocalAlloc(LPTR, cbNewPointer);
                    if (!pNewPointer)
                    {
                        hReturn = E_OUTOFMEMORY;
                        goto CleanDestinationPathForVdirs_Exit;
                    }

                    // Copy to new buffer
                    StringCbCopy(pNewPointer,cbNewPointer,szCurrentMetabasePath);
                    if (pszLastPartNew)
                    {
                        // Don't copy over if the end of this part is root
                        // and the part we want to copy over is "root"
                        if (!bIsRootVdir)
                        {
                            AddEndingMetabaseSlashIfNeedTo(pNewPointer,cbNewPointer);
					        StringCbCat(pNewPointer,cbNewPointer,pszLastPartNew);
                        }
                    }

                    // Free the old one.
                    LocalFree(*pszDestinationPathMungeMe);*pszDestinationPathMungeMe=NULL;

                    // point to the new buffer
                    *pszDestinationPathMungeMe = pNewPointer;
                    *pcbDestinationPathMungeMe = cbNewPointer;
                }
                hReturn = S_OK;
            }
            else
            {
                hReturn = E_INVALIDARG;
                goto CleanDestinationPathForVdirs_Exit;
            }
        }
        else
        {
            // Get Vdir we want to append...
            CString strSiteNode, strRemainder_WithRoot;
            LPCTSTR lpPath3 = CMetabasePath::TruncatePath(3, *pszDestinationPathMungeMe, strSiteNode, &strRemainder_WithRoot);
			if (lpPath3){}
            if (strRemainder_WithRoot.IsEmpty())
            {
                hReturn = E_INVALIDARG;
                goto CleanDestinationPathForVdirs_Exit;
            }

            if (IsFTPSitePath(szCurrentMetabasePath))
            {
                // if our current metabase path is already a site node, then add them together
                // /LM/MSFTPSVC/1 + / + ROOT/MyVdir

                // figure out how much space we need.
                iChars = _tcslen(szCurrentMetabasePath) + _tcslen(strRemainder_WithRoot) + 2;
                cbNewPointer = iChars * sizeof(TCHAR);

                // allocate the new amt of space
                pNewPointer = NULL;
                pNewPointer = (LPTSTR) LocalAlloc(LPTR, cbNewPointer);
                if (!pNewPointer)
                {
                    hReturn = E_OUTOFMEMORY;
                    goto CleanDestinationPathForVdirs_Exit;
                }

                // Copy to new buffer
				StringCbCopy(pNewPointer,cbNewPointer,szCurrentMetabasePath);
				AddEndingMetabaseSlashIfNeedTo(pNewPointer,cbNewPointer);
				StringCbCat(pNewPointer,cbNewPointer,(LPCTSTR) strRemainder_WithRoot);

                // Free the old one.
                LocalFree(*pszDestinationPathMungeMe);*pszDestinationPathMungeMe=NULL;

                // point to the new buffer
                *pszDestinationPathMungeMe = pNewPointer;
                *pcbDestinationPathMungeMe = cbNewPointer;

                hReturn = S_OK;
            }
            else if (IsFTPSiteVDirPath(szCurrentMetabasePath,FALSE))
            {
                // we failed to get farther, just treat it as a new vdir
                bCreateAFirstLevelVdir = TRUE;

                // if our current metabase path is already a vdir/physical path dir...then do some funky magic
                pszLastPart = NULL;
                pszLastPartNew = NULL;
                iLastPartNewSize = 0;

                BOOL bIsRootVdir = IsRootVDir(*pszDestinationPathMungeMe);

                pszLastPart = GimmiePointerToLastPart(*pszDestinationPathMungeMe);
                if (pszLastPart)
                {
                    bCreateAFirstLevelVdir = FALSE;

                    iLastPartNewSize = _tcslen(pszLastPart) + 1;

                    pszLastPartNew = (LPTSTR) LocalAlloc(LPTR, iLastPartNewSize * sizeof(TCHAR));
                    if (!pszLastPartNew)
                    {
                        hReturn = E_OUTOFMEMORY;
                        goto CleanDestinationPathForVdirs_Exit;
                    }
					StringCbCopy(pszLastPartNew, iLastPartNewSize * sizeof(TCHAR),pszLastPart);
                }

                // check if the site that the user is currently on, is a vdir or physical dir...
                if (bCreateAFirstLevelVdir)
                {
                    CString strRemainder_Temp;
                    LPCTSTR lpPath4 = CMetabasePath::TruncatePath(3, szCurrentMetabasePath, strSiteNode, &strRemainder_Temp);
					if (lpPath4){}
                    if (strSiteNode.IsEmpty())
                    {
                        hReturn = E_INVALIDARG;
                        goto CleanDestinationPathForVdirs_Exit;
                    }

                    // figure out how much space we need.
                    iChars = _tcslen(szCurrentMetabasePath) + _tcslen(strRemainder_WithRoot) + 2;
                    cbNewPointer = iChars * sizeof(TCHAR);

                    // allocate the new amt of space
                    pNewPointer = NULL;
                    pNewPointer = (LPTSTR) LocalAlloc(LPTR, cbNewPointer);
                    if (!pNewPointer)
                    {
                        hReturn = E_OUTOFMEMORY;
                        goto CleanDestinationPathForVdirs_Exit;
                    }

                    // Copy to new buffer
				    StringCbCopy(pNewPointer,cbNewPointer,strSiteNode);
                    AddEndingMetabaseSlashIfNeedTo(pNewPointer,cbNewPointer);
				    StringCbCat(pNewPointer,cbNewPointer,(LPCTSTR) strRemainder_WithRoot);

                    // Free the old one.
                    LocalFree(*pszDestinationPathMungeMe);*pszDestinationPathMungeMe=NULL;

                    // point to the new buffer
                    *pszDestinationPathMungeMe = pNewPointer;
                    *pcbDestinationPathMungeMe = cbNewPointer;

                }
                else
                {
                    // /LM/MSFTPSVC/1/ROOT/MyOldVdirThatIwantToKeep + / + MyNewVdir

                    // figure out how much space we need.
                    iChars = _tcslen(szCurrentMetabasePath) + 2;
                    if (pszLastPartNew)
                    {
                        iChars = iChars + _tcslen(pszLastPartNew);
                    }
                    cbNewPointer = iChars * sizeof(TCHAR);

                    // allocate the new amt of space
                    pNewPointer = NULL;
                    pNewPointer = (LPTSTR) LocalAlloc(LPTR, cbNewPointer);
                    if (!pNewPointer)
                    {
                        hReturn = E_OUTOFMEMORY;
                        goto CleanDestinationPathForVdirs_Exit;
                    }

                    // Copy to new buffer
					StringCbCopy(pNewPointer,cbNewPointer,szCurrentMetabasePath);
                    if (pszLastPartNew)
                    {
                        // Don't copy over if the end of this part is root
                        // and the part we want to copy over is "root"
                        if (!bIsRootVdir)
                        {
                            AddEndingMetabaseSlashIfNeedTo(pNewPointer,cbNewPointer);
					        StringCbCat(pNewPointer,cbNewPointer,pszLastPartNew);
                        }
                    }

                    // Free the old one.
                    LocalFree(*pszDestinationPathMungeMe);*pszDestinationPathMungeMe=NULL;

                    // point to the new buffer
                    *pszDestinationPathMungeMe = pNewPointer;
                    *pcbDestinationPathMungeMe = cbNewPointer;
                }

                hReturn = S_OK;
            }
            else
            {
                hReturn = E_INVALIDARG;
                goto CleanDestinationPathForVdirs_Exit;
            }
        }
    }
    else if (0 == _tcscmp(szKeyType,L"IIsApplicationPool"))
    {
        hReturn = S_OK;
    }
    else
    {
        // nothing matches, get out
        hReturn = E_INVALIDARG;
    }

CleanDestinationPathForVdirs_Exit:
    if (pszLastPartNew)
    {
        LocalFree(pszLastPartNew);pszLastPartNew=NULL;
    }
    return hReturn;
}


#define DEFAULT_TIMEOUT_VALUE 30000

HRESULT FixupImportAppRoot(PCONNECTION_INFO pConnectionInfo,LPCWSTR pszSourcePath,LPCWSTR pszDestPath)
{
    HRESULT hr = S_OK;
    IMSAdminBase *pIMSAdminBase = NULL;
    IMSAdminBase2 *pIMSAdminBase2 = NULL;
    METADATA_HANDLE hObjHandle = NULL;
    DWORD dwMDMetaID = MD_APP_ROOT;
    DWORD dwBufferSize = 0;
    DWORD dwReqdBufferSize = 0;
    WCHAR *pBuffer = NULL;
    DWORD dwRecBufSize = 0;
    WCHAR *pRecBuf = NULL;
    METADATA_RECORD mdrMDData;
    const WCHAR c_slash = L'/';
    WCHAR *pSourcePath = NULL;
    DWORD dwSLen = 0;
    WCHAR *pFoundStr = NULL;
    WCHAR *pOrigBuffer = NULL;
    WCHAR *pNewAppRoot = NULL;
    BOOL bCoInitCalled = FALSE;
	LPWSTR lpwstrTempPassword = NULL;

    if ((!pszSourcePath)||(!pszDestPath))
    {
        return RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }
    if (!pConnectionInfo)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }
	if (pConnectionInfo->pszUserPasswordEncrypted)
	{
		if (FAILED(DecryptMemoryPassword((LPWSTR) pConnectionInfo->pszUserPasswordEncrypted,&lpwstrTempPassword,pConnectionInfo->cbUserPasswordEncrypted)))
		{
            return HRESULT_FROM_WIN32(ERROR_DECRYPTION_FAILED);
		}
	}

	CComAuthInfo auth(pConnectionInfo->pszMachineName,pConnectionInfo->pszUserName,lpwstrTempPassword);

    _wcsupr((WCHAR*)pszSourcePath);
    _wcsupr((WCHAR*)pszDestPath);

    // Make sure that pSourcePath has a trailing slash.
    dwSLen = (DWORD)wcslen(pszSourcePath);

    if (c_slash == pszSourcePath[dwSLen - 1])
    {
        pSourcePath = new WCHAR[dwSLen+ 1];

        if (!pSourcePath)
        {
            hr = E_OUTOFMEMORY;
            goto done;    
        }

        StringCbCopyW(pSourcePath,((dwSLen+1) * sizeof(WCHAR)), pszSourcePath);
    }
    else
    {
        pSourcePath = new WCHAR[dwSLen + 2];

        if (!pSourcePath)
        {
            hr = E_OUTOFMEMORY;
            goto done;    
        }

        StringCbCopyW(pSourcePath,((dwSLen+2) * sizeof(WCHAR)), pszSourcePath);
        pSourcePath[dwSLen] = c_slash;
        pSourcePath[dwSLen+1] = 0;
    }

    if(FAILED(hr = CoInitializeEx(NULL, COINIT_MULTITHREADED)))
    {
        if(FAILED(hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED)))
        {
            goto done;
        }
    }
    bCoInitCalled = TRUE;

    // RPC_C_AUTHN_LEVEL_DEFAULT       0 
    // RPC_C_AUTHN_LEVEL_NONE          1 
    // RPC_C_AUTHN_LEVEL_CONNECT       2 
    // RPC_C_AUTHN_LEVEL_CALL          3 
    // RPC_C_AUTHN_LEVEL_PKT           4 
    // RPC_C_AUTHN_LEVEL_PKT_INTEGRITY 5 
    // RPC_C_AUTHN_LEVEL_PKT_PRIVACY   6 
    COSERVERINFO * pcsiName = auth.CreateServerInfoStruct(RPC_C_AUTHN_LEVEL_DEFAULT);
    MULTI_QI res[1] = 
    {
        {&IID_IMSAdminBase, NULL, 0}
    };

    if (FAILED(hr = CoCreateInstanceEx(CLSID_MSAdminBase,NULL,CLSCTX_ALL,pcsiName,1,res)))
    {
        goto done;
    }

    pIMSAdminBase = (IMSAdminBase *)res[0].pItf;
    if (auth.UsesImpersonation())
    {
        if (FAILED(hr = auth.ApplyProxyBlanket(pIMSAdminBase)))
        {
            goto done;
        }

        // There is a remote IUnknown interface that lurks behind IUnknown.
        // If that is not set, then the Release call can return access denied.
        IUnknown * pUnk = NULL;
        hr = pIMSAdminBase->QueryInterface(IID_IUnknown, (void **)&pUnk);
        if(FAILED(hr))
        {
            goto done;
        }
        if (FAILED(hr = auth.ApplyProxyBlanket(pUnk)))
        {
            goto done;
        }
        pUnk->Release();pUnk = NULL;
    }

    if (FAILED(hr = pIMSAdminBase->QueryInterface(IID_IMSAdminBase2, (void **)&pIMSAdminBase2)))
    {
        goto done;
    }

    if (auth.UsesImpersonation())
    {
        if (FAILED(hr = auth.ApplyProxyBlanket(pIMSAdminBase2)))
        {
            goto done;
        }
    }
    else
    {
        // the local call needs min RPC_C_IMP_LEVEL_IMPERSONATE
        // for the pIMSAdminBase2 objects Import/Export functions!
        if (FAILED(hr = SetBlanket(pIMSAdminBase2)))
        {
            //goto done;
        }
    }




    hr = pIMSAdminBase2->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                (LPWSTR)L"",
                METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                DEFAULT_TIMEOUT_VALUE,
                &hObjHandle
                );

    if (FAILED(hr))
    {
        goto done;
    }

    hr = pIMSAdminBase2->GetDataPaths(
                hObjHandle,
                pszDestPath,
                dwMDMetaID,
                ALL_METADATA,
                dwBufferSize,
                (LPWSTR)L"",
                &dwReqdBufferSize
                );
    if (FAILED(hr))
    {
        if (hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
        {
            goto done;
        }
    }

    pBuffer = new WCHAR[dwReqdBufferSize];
    if (!pBuffer)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    dwBufferSize = dwReqdBufferSize;

    hr = pIMSAdminBase2->GetDataPaths(
                hObjHandle,
                pszDestPath,
                dwMDMetaID,
                ALL_METADATA,
                dwBufferSize,
                (LPWSTR)pBuffer,
                &dwReqdBufferSize
                );

    pOrigBuffer = pBuffer;
    if (FAILED(hr))
    {
        goto done;
    }

    // look at AppRoot at each path
    while (*pBuffer)
    {
        // Create the new AppRoot for this record...
        int iNewAppRootLen = wcslen(pBuffer) + 1;
        pNewAppRoot = new WCHAR[iNewAppRootLen];
        if (!pNewAppRoot)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        StringCbCopy(pNewAppRoot,iNewAppRootLen * sizeof(WCHAR),pBuffer);
        _wcsupr((WCHAR*)pNewAppRoot);

        // make sure it doesn't end with a slash...
        if (_T('/') == pNewAppRoot[iNewAppRootLen - 2])
        {
            // cut if off if it's there
            pNewAppRoot[iNewAppRootLen - 2] = '\0';
        }
                
        MD_SET_DATA_RECORD(&mdrMDData,
                           dwMDMetaID,
                           METADATA_INHERIT,
                           IIS_MD_UT_FILE,
                           STRING_METADATA,
                           dwRecBufSize,
                           pRecBuf);

        hr = pIMSAdminBase2->GetData(
                    hObjHandle,
                    pBuffer,
                    &mdrMDData,
                    &dwRecBufSize
                    );

        if (FAILED(hr))
        {
            if (hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
            {
                goto done;
            }
        }

        pRecBuf = new WCHAR[dwRecBufSize + 1];  // for extra slash if we need it

        if (!pRecBuf)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        MD_SET_DATA_RECORD(&mdrMDData,
                           dwMDMetaID,
                           METADATA_INHERIT,
                           IIS_MD_UT_FILE,
                           STRING_METADATA,
                           dwRecBufSize,
                           pRecBuf);

        hr = pIMSAdminBase2->GetData(
                    hObjHandle,
                    pBuffer,
                    &mdrMDData,
                    &dwRecBufSize
                    );

        if (FAILED(hr))
        {
            goto done;
        }

        _wcsupr(pRecBuf);

        // Make sure that pRecBuf has a trailing slash.
        dwSLen = (DWORD)wcslen(pRecBuf);

        if (c_slash != pRecBuf[dwSLen - 1])
        {
            pRecBuf[dwSLen] = c_slash;
            pRecBuf[dwSLen+1] = 0;
        }


        pFoundStr = wcsstr(pRecBuf,pSourcePath);
        if (pFoundStr)
        {
            if (pNewAppRoot)
            {
                // now set the new AppRoot
                MD_SET_DATA_RECORD(&mdrMDData,
                                dwMDMetaID,
                                METADATA_INHERIT,
                                IIS_MD_UT_FILE,
                                STRING_METADATA,
                                (DWORD)((wcslen(pNewAppRoot)+1)*sizeof(WCHAR)),
                                (PBYTE)pNewAppRoot);

                hr = pIMSAdminBase2->SetData(
                    hObjHandle,
                    pBuffer,
                    &mdrMDData
                    );

                IISDebugOutput(_T("FixupImportAppRoot:NewAppRoot=%s\r\n"),(LPCTSTR) pNewAppRoot);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            if (FAILED(hr))
            {
                goto done;
            }

            if (pNewAppRoot)
            {
                delete[] pNewAppRoot;
                pNewAppRoot = NULL;
            }
        }

        if (pRecBuf)
        {
            delete [] pRecBuf;
            pRecBuf = NULL;
        }

        pBuffer += wcslen(pBuffer) + 1;
    }

done:
	if (lpwstrTempPassword)
	{
		// security percaution:Make sure to zero out memory that temporary password was used for.
		SecureZeroMemory(lpwstrTempPassword,pConnectionInfo->cbUserPasswordEncrypted);
		LocalFree(lpwstrTempPassword);
		lpwstrTempPassword = NULL;
	}

    if (hObjHandle)
    {
        pIMSAdminBase2->CloseKey(hObjHandle);
    }

    if (pIMSAdminBase2)
    {
        pIMSAdminBase2->Release();
        pIMSAdminBase2 = NULL;
    }

    if (pIMSAdminBase) 
    {
        pIMSAdminBase->Release();
        pIMSAdminBase = NULL;
    }

    if (pRecBuf)
    {
        delete[] pRecBuf;
        pRecBuf = NULL;
    }

    if (pNewAppRoot)
    {
        delete[] pNewAppRoot;
        pNewAppRoot = NULL;
    }

    if (pOrigBuffer)
    {
        // pOrigBuffer is pBuffer before we moved through it.
        delete pOrigBuffer;
        pOrigBuffer = NULL;
        pBuffer = NULL;
    }

    if (pSourcePath)
    {
        delete[] pSourcePath;
        pSourcePath = NULL;
    }

    if (bCoInitCalled)
    {
        CoUninitialize();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\iisuiobj\util.h ===
#include "stdafx.h"

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

BOOL AnswerIsYes(HWND hDlg,UINT id,LPCTSTR file);
void CenterWindow(HWND hwndParent, HWND hwnd);

VOID RemoveSpaces(LPTSTR szPath, DWORD dwPathSizeOf, LPTSTR szEdit);
BOOL IsSpaces(LPCTSTR szPath);

BOOL IsLocalComputer(IN LPCTSTR lpszComputer);
BOOL GetInetsrvPath(LPCTSTR szMachineName,LPTSTR szReturnedPath,DWORD dwReturnedPathSizeOf);
void AddPath(LPTSTR szPath,DWORD dwPathSizeOf, LPCTSTR szName );
void AddFileExtIfNotExist(LPTSTR szPath, DWORD dwPathSizeOf, LPCTSTR szExt);
BOOL BrowseForFile(LPTSTR strPathIn,LPTSTR strPathOut,DWORD dwPathOutSizeOf);
BOOL BrowseForDir(LPTSTR strPath,LPTSTR strFile);

int GetMultiStrSize(LPTSTR p);
LPCTSTR GetEndOfMultiSz(LPCTSTR szMultiSz);
void DumpStrInMultiStr(LPTSTR pMultiStr);
BOOL FindStrInMultiStr(LPTSTR pMultiStr, LPTSTR StrToFind);
BOOL RemoveStrInMultiStr(LPTSTR pMultiStr, LPTSTR StrToFind);
BOOL IsMultiSzPaired(LPCTSTR pszBufferTemp1);

BOOL IsFileExist(LPCTSTR szFile);
BOOL IsFileExistRemote(LPCTSTR szMachineName,LPTSTR szFilePathToCheck,LPCTSTR szUserName,LPCTSTR szUserPassword);
BOOL IsFileADirectory(LPCTSTR szFile);

BOOL IsWebSitePath(IN LPCTSTR lpszMDPath);
BOOL IsWebSiteVDirPath(IN LPCTSTR lpszMDPath,IN BOOL bOkayToQueryMetabase);
BOOL IsFTPSitePath(IN LPCTSTR lpszMDPath);
BOOL IsFTPSiteVDirPath(IN LPCTSTR lpszMDPath,IN BOOL bOkayToQueryMetabase);
BOOL IsAppPoolPath(IN LPCTSTR lpszMDPath);

BOOL IsMetabaseWebSiteKeyExistAuth(PCONNECTION_INFO pConnectionInfo,CString strMetabaseWebSite);
BOOL IsMetabaseWebSiteKeyExist(CString strMetabaseWebSite);
DWORD GetUniqueSite(CString strMetabaseServerNode);

BOOL CleanMetaPath(LPTSTR *szPathToClean,DWORD *cbPathToCleanSize);
void AddEndingMetabaseSlashIfNeedTo(LPTSTR szDestinationString,DWORD dwDestinationStringSizeOf);

inline HRESULT SetBlanket(LPUNKNOWN pIUnk)
{
  return CoSetProxyBlanket( pIUnk,
                            RPC_C_AUTHN_WINNT,    // NTLM authentication service
                            RPC_C_AUTHZ_NONE,     // default authorization service...
                            NULL,                 // no mutual authentication
                            RPC_C_AUTHN_LEVEL_DEFAULT,      // authentication level
                            RPC_C_IMP_LEVEL_IMPERSONATE,    // impersonation level
                            NULL,                 // use current token
                            EOAC_NONE );          // no special capabilities    
}

HRESULT DumpProxyInfo(IUnknown * punk);
BOOL EstablishSession(LPCTSTR Server,LPTSTR Domain,LPTSTR UserName,LPTSTR Password,BOOL bEstablish);
BOOL IsRootVDir(IN LPCTSTR lpszMDPath);
void LaunchHelp(HWND hWndMain, DWORD_PTR dwWinHelpID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\guid.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

        guid.cpp

   Abstract:

        Initialization as required by initguid

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include <stdafx.h>

#include <objbase.h>
#include <initguid.h>
#include <iadmw.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\inc\debugdefs.h ===
//
// used for the OutputDebugFlag regkey
//
#define DEBUG_FLAG_HELP            0x00000001
#define DEBUG_FLAG_MMC_NOTIFY      0x00000002
#define DEBUG_FLAG_CIISOBJECT      0x00000004
#define DEBUG_FLAG_CRESTRICTLIST   0x00000008
#define DEBUG_FLAG_CIISMBNODE      0x00001000
#define DEBUG_FLAG_MODULE_W3EXT    0x00002000
#define DEBUG_FLAG_MODULE_IISUIOBJ 0x00004000
#define DEBUG_FLAG_MODULE_CERTOBJ  0x00008000
#define DEBUG_FLAG_MODULE_CERTMAP  0x00010000
#define DEBUG_FLAG_MODULE_IISUI    0x00020000
#define DEBUG_FLAG_MODULE_CNFGPRTS 0x00040000
#define DEBUG_FLAG_MODULE_CERTWIZ  0x00080000
#define DEBUG_FLAG_MODULE_LOGUI    0x00100000
//#define DEBUG_FLAG_OTHER         0x00200000,0x00400000,0x00800000,etc...

//
// used for the inetmgr/parameters/InetmgrFlags Regkey
//
#define INETMGR_PARAM_RUNONCE_HAPPENED 0x1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\iisuiobj\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__1CAEC061_45C2_4EA3_BCA0_B9EB25932A8B__INCLUDED_)
#define AFX_STDAFX_H__1CAEC061_45C2_4EA3_BCA0_B9EB25932A8B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef ASSERT

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <windows.h> // added after atl wizard
// added after atl wizard
#include <comdef.h>
#define _WTL_NO_CSTRING
#include <atlwin.h>
#include <atlapp.h>
#include <atldlgs.h>
#include <atlmisc.h>
#include <atlctrls.h>
#include <atlddx.h>
#include <atlcrack.h>
#include <list>
#include <map>
#include <stack>
#include <set>
#include <memory>
#include <shlwapi.h>
#include "iisdebug.h"
#include "global.h"

#include <lmcons.h>

#ifdef ISOLATION_AWARE_ENABLED
#include <shfusion.h>

class CThemeContextActivator
{
public:
    CThemeContextActivator() : m_ulActivationCookie(0)
        { SHActivateContext (&m_ulActivationCookie); }

    ~CThemeContextActivator()
        { SHDeactivateContext (m_ulActivationCookie); }

private:
    ULONG_PTR m_ulActivationCookie;
};

#else
class CThemeContextActivator
{
public:
    CThemeContextActivator() : m_ulActivationCookie(0)
        { }

    ~CThemeContextActivator()
        { }

private:
    ULONG_PTR m_ulActivationCookie;
};


#endif


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1CAEC061_45C2_4EA3_BCA0_B9EB25932A8B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\iisuiobj\util.cpp ===
#include "stdafx.h"
#include <windns.h>
#include "resource.h"
#include "common.h"
#include "remoteenv.h"
#include "util.h"
#include "balloon.h"
#include <commctrl.h>
#include <lm.h>         // for NetXxx API
#include <strsafe.h>


BOOL EstablishNullSession(
      LPCTSTR                Server,       // in - server name
      BOOL                   bEstablish    // in - TRUE=establish, FALSE=disconnect
    )
{
   return EstablishSession(Server,_T(""),_T(""),_T(""),bEstablish);
}

BOOL EstablishSession(
      LPCTSTR                Server,       // in - server name
      LPTSTR                 Domain,       // in - domain name for user credentials
      LPTSTR                 UserName,     // in - username for credentials to use
      LPTSTR                 Password,     // in - password for credentials 
      BOOL                   bEstablish    // in - TRUE=establish, FALSE=disconnect
    )
{
   LPCTSTR                   szIpc = _T("\\IPC$");
   TCHAR                     RemoteResource[UNCLEN + 5 + 1]; // UNC len + \IPC$ + NULL
   DWORD                     cchServer;
   NET_API_STATUS            nas;

   //
   // do not allow NULL or empty server name
   //
   if(Server == NULL || *Server == _T('\0')) 
   {
       SetLastError(ERROR_INVALID_COMPUTERNAME);
       return FALSE;
   }

   cchServer = _tcslen( Server );

   if( Server[0] != _T('\\') && Server[1] != _T('\\')) 
   {

      //
      // prepend slashes and NULL terminate
      //
      RemoteResource[0] = _T('\\');
      RemoteResource[1] = _T('\\');
      RemoteResource[2] = _T('\0');
   }
   else 
   {
      cchServer -= 2; // drop slashes from count
      
      RemoteResource[0] = _T('\0');
   }

   if(cchServer > CNLEN) 
   {
      SetLastError(ERROR_INVALID_COMPUTERNAME);
      return FALSE;
   }

   if (FAILED(StringCbCat(RemoteResource,sizeof(RemoteResource),Server)))
   {
	   return FALSE;
   }

   if (FAILED(StringCbCat(RemoteResource,sizeof(RemoteResource),szIpc)))
   {
	   return FALSE;
   }

   //
   // disconnect or connect to the resource, based on bEstablish
   //
   if(bEstablish) 
   {
      USE_INFO_2 ui2;
      DWORD      errParm;

      ZeroMemory(&ui2, sizeof(ui2));

      ui2.ui2_local = NULL;
      ui2.ui2_remote = RemoteResource;
      ui2.ui2_asg_type = USE_IPC;
      ui2.ui2_domainname = Domain;
      ui2.ui2_username = UserName;
      ui2.ui2_password = Password;

      // try establishing session for one minute
      // if computer is not accepting any more connections

      for (int i = 0; i < (60000 / 5000); i++)
      {
         nas = NetUseAdd(NULL, 2, (LPBYTE)&ui2, &errParm);

         if (nas != ERROR_REQ_NOT_ACCEP)
         {
            break;
         }

         Sleep(5000);
      }
   }
   else 
   {
      nas = NetUseDel(NULL, RemoteResource, 0);
   }

   if( nas == NERR_Success ) 
   {
      return TRUE; // indicate success
   }
   SetLastError(nas);
   return FALSE;
}

BOOL IsValidMetabasePath(LPCTSTR lpszMDPath)
{
    BOOL bReturn = FALSE;
    CString strNewPath;
    CString strRemainder;

    LPCTSTR lpPath = CMetabasePath::GetMachinePath(lpszMDPath, strNewPath, &strRemainder);
    if (lpPath && !strNewPath.IsEmpty())
    {
        if (0 == _tcscmp(strNewPath,_T("/LM")))
        {
            bReturn = TRUE;
        }
    }   
    return bReturn;
}

BOOL IsRootVDir(IN LPCTSTR lpszMDPath)
/*++

Routine Description:

Arguments:

    LPCTSTR lpszMDPath  : Metabase path.

Return Value:

    TRUE if the path is 
        LM/W3SVC/1/ROOT
    
    FALSE otherwise.
--*/
{
    BOOL bReturn = FALSE;

    if (!lpszMDPath || !*lpszMDPath)
    {
        return bReturn;
    }

    CString strSiteNode;
    CString strRemainder;

    LPCTSTR lpPath = CMetabasePath::TruncatePath(3, lpszMDPath, strSiteNode, &strRemainder);
    if (lpPath && !strSiteNode.IsEmpty())
    {
        if (0 == strRemainder.CompareNoCase(_T("ROOT")))
        {
            return TRUE;
        }
    }   

    return bReturn;
}

// Clean the metabase path
// make sure it has no beginning / and no ending /
BOOL CleanMetaPath(LPTSTR *pszPathToClean,DWORD *pcbPathToCleanSize)
{
    BOOL bRet = FALSE;
    if (!pszPathToClean || !*pszPathToClean)
    {
        return FALSE;
    }

    __try
    {
        // loop thru the string and change all '\\' to '/'
        for (int i = 0; i < (int) _tcslen(*pszPathToClean); i++)
        {
            if ('\\' == (*pszPathToClean)[i])
            {
                (*pszPathToClean)[i] = '/';
            }
        }

        if (0 == _tcscmp(*pszPathToClean,_T("/")))
        {
            // if it's one single slash
            // then just return the slash.
        }
        else
        {
            // Check if the string ends with a '/'
            if ('/' == (*pszPathToClean)[_tcslen(*pszPathToClean) - 1])
            {
                // cut it off
                (*pszPathToClean)[_tcslen(*pszPathToClean) - 1] = '\0';
            }

            // Check if the starts with a '/'
            if ('/' == (*pszPathToClean)[0])
            {
                if ((*pszPathToClean)[1])
                {
                    // Get rid of it
					StringCbCopy(*pszPathToClean, *pcbPathToCleanSize, &(*pszPathToClean)[1]);
                }
            }
        }
        bRet = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        // lame
    }

    return bRet;
}

__inline int RECT_WIDTH(RECT rc) { return rc.right - rc.left; };
__inline int RECT_HEIGHT(RECT rc) { return rc.bottom - rc.top; };
__inline int RECT_WIDTH(const RECT* prc) { return prc->right - prc->left; };
__inline int RECT_HEIGHT(const RECT* prc) { return prc->bottom - prc->top; };
void CenterWindow(HWND hwndParent, HWND hwnd)
{
	RECT rcParent, rc;

	if (!hwndParent)
		hwndParent = GetDesktopWindow();

	GetWindowRect(hwndParent, &rcParent);
	GetWindowRect(hwnd, &rc);

	int cx = RECT_WIDTH(rc);
	int cy = RECT_HEIGHT(rc);
	int left = rcParent.left + (RECT_WIDTH(rcParent) - cx) / 2;
	int top  = rcParent.top + (RECT_HEIGHT(rcParent) - cy) / 2;

	// Make certain we don't cover the tray

	SystemParametersInfo(SPI_GETWORKAREA, 0, &rc, 0);
	if (left < rc.left)
		left = rc.left;
	if (top < rc.top)
		top = rc.top;

	MoveWindow(hwnd, left, top, cx, cy, TRUE);
}

// NOTE: this function only handles limited cases, e.g., no ip address
BOOL IsLocalComputer(IN LPCTSTR lpszComputer)
{
    if (!lpszComputer || !*lpszComputer)
    {
        return TRUE;
    }

    if ( _tcslen(lpszComputer) > 2 && *lpszComputer == _T('\\') && *(lpszComputer + 1) == _T('\\') )
    {
        lpszComputer += 2;
    }

    BOOL    bReturn = FALSE;
    DWORD   dwErr = 0;
    TCHAR   szBuffer[DNS_MAX_NAME_BUFFER_LENGTH];
    DWORD   dwSize = DNS_MAX_NAME_BUFFER_LENGTH;

    // 1st: compare against local Netbios computer name
    if ( !GetComputerNameEx(ComputerNameNetBIOS, szBuffer, &dwSize) )
    {
        dwErr = GetLastError();
    }
    else
    {
        bReturn = (0 == lstrcmpi(szBuffer, lpszComputer));
        if (!bReturn)
        {
            // 2nd: compare against local Dns computer name 
            dwSize = DNS_MAX_NAME_BUFFER_LENGTH;
            if (GetComputerNameEx(ComputerNameDnsFullyQualified, szBuffer, &dwSize))
            {
                bReturn = (0 == lstrcmpi(szBuffer, lpszComputer));
            }
            else
            {
                dwErr = GetLastError();
            }
        }
    }

    if (dwErr)
    {
        //TRACE(_T("IsLocalComputer dwErr = %x\n"), dwErr);
    }

    return bReturn;
}

void GetFullPathLocalOrRemote(
    IN  LPCTSTR   lpszMachineName,
    IN  LPCTSTR   lpszDir,
    OUT CString&  cstrPath
)
{
    ASSERT(lpszDir && *lpszDir);

    if (IsLocalComputer(lpszMachineName))
    {
        cstrPath = lpszDir;
    }
    else
    {
        // Check if it's already pointing to a share...
        if (*lpszDir == _T('\\') || *(lpszDir + 1) == _T('\\'))
        {
            cstrPath = lpszDir;
        }
        else
        {
            if (*lpszMachineName != _T('\\') || *(lpszMachineName + 1) != _T('\\'))
            {
                cstrPath = _T("\\\\");
                cstrPath += lpszMachineName;
            }
            else
            {
                cstrPath = lpszMachineName;
            }

            cstrPath += _T("\\");
            cstrPath += lpszDir;
            int i = cstrPath.Find(_T(':'));
            ASSERT(-1 != i);
            if (i != -1)
            {
                cstrPath.SetAt(i, _T('$'));
            }
        }
    }
}

BOOL GetInetsrvPath(LPCTSTR szMachineName,LPTSTR szReturnedPath,DWORD cbReturnedPathSize)
{
	BOOL bReturn = FALSE;
	TCHAR szTempPath[_MAX_PATH];
	ZeroMemory(szTempPath,sizeof(szTempPath));

	// Determine if we are doing this on the local machine
	// or to a remote machine.
	if (IsLocalComputer(szMachineName))
	{
		// Get the local system32 directory.
		if (_MAX_PATH >= GetSystemDirectory(szTempPath, _MAX_PATH))
		{
            StringCbCat(szTempPath,sizeof(szTempPath),_T("\\inetsrv"));
		}
		else
		{
			ZeroMemory(szTempPath,sizeof(szTempPath));
		}
	}
	else
	{
		// Do a ton of work just to do this environment variable for %windir% on
		// the remote machine.
		CString csNewFileSharePath = _T("");
		TCHAR szWindowsSystem32InetsrvDir[] = _T("%windir%\\system32\\inetsrv");

		CRemoteExpandEnvironmentStrings MyRemoteEnv;
		MyRemoteEnv.SetMachineName(szMachineName);
        //MyRemoteEnv.SetUserName(_T(""));
        //MyRemoteEnv.SetUserPassword(_T(""));
			
        LPTSTR UnexpandedString = NULL;
        LPTSTR ExpandedString = NULL;
        NET_API_STATUS ApiStatus = NO_ERROR;

        // Expand string, using remote environment if necessary.
        UnexpandedString = szWindowsSystem32InetsrvDir;
        ApiStatus = MyRemoteEnv.RemoteExpandEnvironmentStrings(UnexpandedString,&ExpandedString);
        if (NO_ERROR == ApiStatus)
        {
			GetFullPathLocalOrRemote(szMachineName,ExpandedString,csNewFileSharePath);
			StringCbCopy(szTempPath, sizeof(szTempPath), csNewFileSharePath);
			if (ExpandedString){LocalFree(ExpandedString);ExpandedString=NULL;}
        }
		else
		{
			ZeroMemory(szTempPath,sizeof(szTempPath));
		}
	}

	if (0 == _tcsicmp(szTempPath,_T("")))
	{
		ZeroMemory(szReturnedPath,sizeof(szReturnedPath));
	}
	else
	{
		StringCbCopy(szReturnedPath, cbReturnedPathSize, szTempPath);
		bReturn = TRUE;
	}

	return bReturn;
}

void AddFileExtIfNotExist(LPTSTR szPath, DWORD cbPathSize, LPCTSTR szExt)
{
    TCHAR szFilename_ext_only[_MAX_EXT];

    _tsplitpath(szPath, NULL, NULL, NULL, szFilename_ext_only);
    if (0 == _tcscmp(szFilename_ext_only,_T("")))
    {
        if (szExt && 0 != _tcscmp(szExt,_T("")))
        {
			StringCbCat(szPath,cbPathSize,szExt);
        }
    }
}

void AddPath(LPTSTR szPath,DWORD cbPathSize, LPCTSTR szName )
{
	LPTSTR p = szPath;

    // Find end of the string
    while (*p){p = _tcsinc(p);}
	
	// If no trailing backslash then add one
    if (*(_tcsdec(szPath, p)) != _T('\\'))
		{
			StringCbCat(szPath,cbPathSize,_T("\\"));
		}
	
	// if there are spaces precluding szName, then skip
    while ( *szName == ' ' ) szName = _tcsinc(szName);;

	// Add new name to existing path string
	StringCbCat(szPath,cbPathSize,szName);
}

BOOL BrowseForDir(LPTSTR strPath,LPTSTR strFile)
{
    BOOL bReturn = FALSE;

	if (0 == _tcsicmp(strPath,_T("")))
	{
		::GetCurrentDirectory(_MAX_PATH, strPath);
	}

	CFileDialog fileName(FALSE);
	fileName.m_ofn.Flags |= OFN_NOCHANGEDIR | OFN_OVERWRITEPROMPT;
    fileName.m_ofn.Flags |= OFN_NOREADONLYRETURN;

	// We need to disable hook to show new style of File Dialog
	fileName.m_ofn.Flags &= ~(OFN_ENABLEHOOK);
	LPTSTR strExt = _T("*.*");
	fileName.m_ofn.lpstrDefExt = strExt;
	fileName.m_ofn.lpstrFile = strFile;
	fileName.m_ofn.nMaxFile = _MAX_PATH;

    if (0 == _tcsicmp(strPath,_T("")))
    {
        fileName.m_ofn.lpstrInitialDir = NULL;
    }
    else
    {
        fileName.m_ofn.lpstrInitialDir = (LPCTSTR) strPath;
    }
	
	fileName.m_ofn.lpstrFilter = _T("");
	fileName.m_ofn.nFilterIndex = 0;
    //CThemeContextActivator activator;
	if (IDOK == fileName.DoModal())
	{
        bReturn = TRUE;
		CString strPrev;
		//GetDlgItemText(IDC_FILE_NAME, strPrev);
        /*
		if (strPrev.CompareNoCase(strFile) != 0)
		{
			SetDlgItemText(IDC_FILE_NAME, strFile);
			m_DoReplaceFile = TRUE;
			FileNameChanged();
		}
        */
	}
    return bReturn;
}

BOOL BrowseForFile(LPTSTR strPathIn,LPTSTR strPathOut,DWORD cbPathOut)
{
    CString szFileExt;
    szFileExt.LoadString(_Module.GetResourceInstance(), IDS_XML_EXT);

    CString szFileView(_T("*.xml"));
       
    CString szFilter;
    szFilter.LoadString(_Module.GetResourceInstance(), IDS_EXPORT_FILTER);

	// replace '|'s in this string to null chars
	for (int i = 0; i < szFilter.GetLength(); i++)
	{
		if (szFilter[i] == L'|')
			szFilter.SetAt(i, L'\0');
	}

    CFileDialog* pFileDlg = new CFileDialog (
        TRUE,	    // use as open File
        szFileExt,	// default extension
        szFileView,	// preferred file name
        OFN_PATHMUSTEXIST,
        szFilter,   // filter
        NULL);

    if (pFileDlg)
    {
        TCHAR szTempFileName[_MAX_PATH];
        //TCHAR szFileName_drive[_MAX_DRIVE];
        //TCHAR szFileName_dir[_MAX_DIR];
        TCHAR szFileName_fname[_MAX_FNAME];
        TCHAR szFileName_ext[_MAX_EXT];
        _tsplitpath(strPathIn, NULL, NULL, szFileName_fname, szFileName_ext);
		StringCbCopy(szTempFileName, sizeof(szTempFileName), szFileName_fname);
		StringCbCat(szTempFileName,sizeof(szTempFileName),szFileName_ext);

	    pFileDlg->m_ofn.Flags |= OFN_FILEMUSTEXIST;
	    // We need to disable hook to show new style of File Dialog
	    //pFileDlg->m_ofn.Flags &= ~(OFN_ENABLEHOOK);

        if (0 == _tcsicmp(strPathIn,_T("")))
        {
            pFileDlg->m_ofn.lpstrInitialDir = NULL;
        }
        else
        {
            pFileDlg->m_ofn.lpstrInitialDir = (LPCTSTR) strPathIn;
        }

        pFileDlg->m_ofn.lpstrFile = szTempFileName;
        pFileDlg->m_ofn.nMaxFile = _MAX_PATH;

        //CThemeContextActivator activator;
        if ( IDOK == pFileDlg->DoModal () )
        {
            //
            // Retrieve the file and path
            //
			StringCbCopy(strPathOut,cbPathOut,szTempFileName);
            return TRUE;
        }
    }
    return FALSE;
}

// Calculate the size of a Multi-String in TCHAR, including the ending 2 '\0's.
int GetMultiStrSize(LPTSTR p)
{
    int c = 0;

    while (1) 
    {
        if (*p) 
        {
            p++;
            c++;
        }
        else 
        {
            c++;
            if (*(p+1)) 
            {
                p++;
            }
            else 
            {
                c++;
                break;
            }
        }
    }
    return c;
}

BOOL IsMultiSzPaired(LPCTSTR pMultiStr)
{
    BOOL bPaired = FALSE;
    LPCTSTR pTempMultiStr = pMultiStr;
    BOOL bLeadEntry = TRUE;;
    while (1) 
    {
        if (pTempMultiStr) 
        {
            // This first value should be a metabase path.
            // let's not check it.
            //IISDebugOutput(_T("[%d] %s\r\n"),bLeadEntry,pTempMultiStr);

            // then increment until we hit another null.
            while (*pTempMultiStr)
            {
                pTempMultiStr++;
            }

            // check for the ending \0\0
            if ( *(pTempMultiStr+1) == NULL)
            {
                break;
            }
            else
            {
                if (bLeadEntry)
                {
                    bLeadEntry = FALSE;
                }
                else
                {
                    bLeadEntry = TRUE;
                }
                pTempMultiStr++;
            }

            if (FALSE == bLeadEntry)
            {
                // We hit the 2nd value.
                // this value should not be a metabase path
                // let's check if it is a metabase path.
                // if it's a metabase path then it's definetly not "paired"
                // (or it's a description with slashes in it...)
                if (!IsValidMetabasePath(pTempMultiStr))
                {
                    bPaired = TRUE;
                    break;
                }
                /*
                if (!_tcschr(pTempMultiStr, '/'))
                {
                    bPaired = TRUE;
                    break;
                }
                */
            }
        }
    }

    return bPaired;
}

// This walks the multi-sz and returns a pointer between
// the last string of a multi-sz and the second terminating NULL
LPCTSTR GetEndOfMultiSz(LPCTSTR szMultiSz)
{
	LPCTSTR lpTemp = szMultiSz;

	do
	{
		lpTemp += wcslen(lpTemp);
		lpTemp++;

	} while (*lpTemp != L'\0');

	return(lpTemp);
}

void DumpStrInMultiStr(LPTSTR pMultiStr)
{
    LPTSTR pTempMultiStr = pMultiStr;

    //IISDebugOutput(_T("DumpStrInMultiStr:start\r\n"));

    while (1) 
    {
        if (pTempMultiStr) 
        {
            // display value
            IISDebugOutput(_T("  %s\r\n"),pTempMultiStr);
            //wprintf(L"    %s\r\n",pTempMultiStr);

            // then increment until we hit another null.
            while (*pTempMultiStr)
            {
                pTempMultiStr++;
            }

            // check for the ending \0\0
            if ( *(pTempMultiStr+1) == NULL)
            {
                break;
            }
            else
            {
                pTempMultiStr++;
            }
        }
    }
    //IISDebugOutput(_T("DumpStrInMultiStr:  end\r\n"));
    return;
}

BOOL FindStrInMultiStr(LPTSTR pMultiStr, LPTSTR StrToFind)
{
    BOOL bFound = FALSE;
    LPTSTR pTempMultiStr = pMultiStr;
    DWORD dwCharCount = 0;

    while (1) 
    {
        if (pTempMultiStr) 
        {
            // compare this value to the imput value
            if (0 == _tcsicmp((const TCHAR *) pTempMultiStr,StrToFind))
            {
                bFound = TRUE;
                break;
            }

            // then increment until we hit another null.
            while (*pTempMultiStr)
            {
                pTempMultiStr++;
                dwCharCount++;
            }

            // check for the ending \0\0
            if ( *(pTempMultiStr+1) == NULL)
            {
                break;
            }
            else
            {
                pTempMultiStr++;
                dwCharCount++;
            }

            // Check if we screwed up somehow and are in an infinite loop.
            // could happen if we don't find an ending \0\0
            if (dwCharCount > 32000)
            {
                break;
            }
        }
    }
    return bFound;
}

BOOL RemoveStrInMultiStr(LPTSTR pMultiStr, LPTSTR StrToFind)
{
    BOOL bFound = FALSE;
    LPTSTR pTempMultiStr = pMultiStr;
    DWORD dwCharCount = 0;

    while (1) 
    {
        if (pTempMultiStr) 
        {
            // compare this value to the imput value
            if (0 == _tcsicmp((const TCHAR *) pTempMultiStr,StrToFind))
            {
                LPTSTR pLastDoubleNull = NULL;
                LPTSTR pBeginPath = pTempMultiStr;
                bFound = TRUE;

                // then increment until we hit another null.
                while (*pTempMultiStr)
                {
                    pTempMultiStr++;
                }
                pTempMultiStr++;

                // Find the last double null.
                pLastDoubleNull = pTempMultiStr;
                if (*pLastDoubleNull)
                {
                    while (1)
                    {
                        if (NULL == *pLastDoubleNull && NULL == *(pLastDoubleNull+1))
                        {
                            break;
                        }
                        pLastDoubleNull++;
                    }
                    pLastDoubleNull++;
                }

                // check if we are the last entry.
                if (pLastDoubleNull == pTempMultiStr)
                {
                    // set everything to nulls
                    memset(pBeginPath,0,(pLastDoubleNull-pBeginPath) * sizeof(TCHAR));
                }
                else
                {
                    // move everything behind it to where we are.
                    memmove(pBeginPath,pTempMultiStr, (pLastDoubleNull - pTempMultiStr) * sizeof(TCHAR));
                    // and set everything behind that to nulls
                    memset(pBeginPath + (pLastDoubleNull - pTempMultiStr),0,(pTempMultiStr-pBeginPath) * sizeof(TCHAR));
                }
                break;
            }

            // then increment until we hit another null.
            while (*pTempMultiStr)
            {
                pTempMultiStr++;
                dwCharCount++;
            }

            // check for the ending \0\0
            if ( *(pTempMultiStr+1) == NULL)
            {
                break;
            }
            else
            {
                pTempMultiStr++;
                dwCharCount++;
            }

            // Check if we screwed up somehow and are in an infinite loop.
            // could happen if we don't find an ending \0\0
            if (dwCharCount > 32000)
            {
                break;
            }
        }
    }
    return bFound;
}

BOOL IsFileExist(LPCTSTR szFile)
{
    // Check if the file has expandable Environment strings
    LPTSTR pch = NULL;
    DWORD dwReturn = 0;
    pch = _tcschr( (LPTSTR) szFile, _T('%'));
    if (pch) 
    {
        TCHAR szValue[_MAX_PATH];
		StringCbCopy(szValue, sizeof(szValue), szFile);
        if (!ExpandEnvironmentStrings( (LPCTSTR)szFile, szValue, sizeof(szValue)/sizeof(TCHAR)))
            {
				StringCbCopy(szValue, sizeof(szValue), szFile);
			}

        dwReturn = GetFileAttributes(szValue);
        if (INVALID_FILE_ATTRIBUTES == dwReturn)
        {
            return FALSE;
        }
        else
        {
            return TRUE;
        }
    }
    else
    {
        dwReturn = GetFileAttributes(szFile);
        if (INVALID_FILE_ATTRIBUTES == dwReturn)
        {
            // Check if it was because we don't have access...
            if (ERROR_LOGON_FAILURE == GetLastError())
            {
                IISDebugOutput(_T("IsFileExist failed,err=%d (logon failed)\r\n"),GetLastError());
            }
            return FALSE;
        }
        else
        {
            return TRUE;
        }
    }
}

BOOL IsFileExistRemote(LPCTSTR szMachineName,LPTSTR szFilePathToCheck,LPCTSTR szUserName,LPCTSTR szUserPassword)
{
    BOOL bReturn = FALSE;
	TCHAR szTempPath[_MAX_PATH];
	ZeroMemory(szTempPath,sizeof(szTempPath));

	// Determine if we are doing this on the local machine
	// or to a remote machine.
	if (IsLocalComputer(szMachineName))
	{
        return IsFileExist(szFilePathToCheck);
	}
	else
	{
		// Do a ton of work just to do this environment variable for %windir% on
		// the remote machine.
		CString csNewFileSharePath = _T("");
		CRemoteExpandEnvironmentStrings MyRemoteEnv;
		MyRemoteEnv.SetMachineName(szMachineName);
        //MyRemoteEnv.SetUserName(szUserName);
        //MyRemoteEnv.SetUserPassword(szUserPassword);

        LPTSTR UnexpandedString = NULL;
        LPTSTR ExpandedString = NULL;
        NET_API_STATUS ApiStatus = NO_ERROR;

        // Expand string, using remote environment if necessary.
        UnexpandedString = szFilePathToCheck;
        ApiStatus = MyRemoteEnv.RemoteExpandEnvironmentStrings(UnexpandedString,&ExpandedString);
        if (NO_ERROR == ApiStatus)
        {
			GetFullPathLocalOrRemote(szMachineName,ExpandedString,csNewFileSharePath);
            if (!csNewFileSharePath.IsEmpty())
            {
			    StringCbCopy(szTempPath, sizeof(szTempPath), csNewFileSharePath);
            }
			if (ExpandedString){LocalFree(ExpandedString);ExpandedString=NULL;}
        }
	}

	if (0 != _tcsicmp(szTempPath,_T("")))
	{
        // Check if the file exists...
        bReturn = IsFileExist(szTempPath);
        if (!bReturn)
        {
            if (ERROR_LOGON_FAILURE == GetLastError())
            {
                // try to net use to the share if the file doesn't exist...
                EstablishSession(szMachineName,_T(""),(LPTSTR) szUserName,(LPTSTR) szUserPassword,TRUE);
                bReturn = IsFileExist(szTempPath);
                EstablishSession(szMachineName,_T(""),_T(""),_T(""),FALSE);
            }
        }
        //IISDebugOutput(_T("IsFileExistRemote:%s,ret=%d\r\n"),szTempPath,bReturn);
	}

	return bReturn;
}

BOOL IsFileADirectory(LPCTSTR szFile)
{
    // Check if the file has expandable Environment strings
    DWORD retCode = 0xFFFFFFFF;
    LPTSTR pch = NULL;
    pch = _tcschr( (LPTSTR) szFile, _T('%'));
    if (pch) 
    {
        TCHAR szValue[_MAX_PATH];
		StringCbCopy(szValue, sizeof(szValue), szFile);
        if (!ExpandEnvironmentStrings( (LPCTSTR)szFile, szValue, sizeof(szValue)/sizeof(TCHAR)))
            {
				StringCbCopy(szValue, sizeof(szValue), szFile);
			}

        retCode = GetFileAttributes(szValue);
    }
    else
    {
        retCode = GetFileAttributes(szFile);
    }

    if (retCode & FILE_ATTRIBUTE_DIRECTORY)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


BOOL IsWebSitePath(IN LPCTSTR lpszMDPath)
/*++

Routine Description:


Arguments:

    LPCTSTR lpszMDPath  : Metabase path.

Return Value:

    TRUE if the path is a w3svc/1 web site,
    FALSE otherwise.

--*/
{
    BOOL bReturn = FALSE;

    if (!lpszMDPath || !*lpszMDPath)
    {
        return bReturn;
    }

    CString strSiteNode;
    CString strRemainder;

    LPCTSTR lpPath = CMetabasePath::TruncatePath(3, lpszMDPath, strSiteNode, &strRemainder);

    if (lpPath && !strSiteNode.IsEmpty() && strRemainder.IsEmpty())
    {
        LPCTSTR lpPath2 = CMetabasePath::TruncatePath(2, lpPath, strSiteNode, &strRemainder);
		if (lpPath2){} // to get rid of warning level 4 compile

        if (_tcsicmp(strSiteNode,SZ_MBN_SEP_STR SZ_MBN_MACHINE SZ_MBN_SEP_STR SZ_MBN_WEB) == 0 
            || _tcsicmp(strSiteNode,SZ_MBN_MACHINE SZ_MBN_SEP_STR SZ_MBN_WEB) == 0)
        {
            bReturn = TRUE;
        }
    }   


    return bReturn;
}

BOOL IsFTPSitePath(IN LPCTSTR lpszMDPath)
/*++

Routine Description:


Arguments:

    LPCTSTR lpszMDPath  : Metabase path.

Return Value:

    TRUE if the path is a msftpsvc/1 web site,
    FALSE otherwise.

--*/
{
    BOOL bReturn = FALSE;

    if (!lpszMDPath || !*lpszMDPath)
    {
        return bReturn;
    }

    CString strSiteNode;
    CString strRemainder;

    LPCTSTR lpPath = CMetabasePath::TruncatePath(3, lpszMDPath, strSiteNode, &strRemainder);

    if (lpPath && !strSiteNode.IsEmpty() && strRemainder.IsEmpty())
    {
        LPCTSTR lpPath2 = CMetabasePath::TruncatePath(2, lpPath, strSiteNode, &strRemainder);
		if (lpPath2){} // to get rid of warning level 4 compile

        if (_tcsicmp(strSiteNode,SZ_MBN_SEP_STR SZ_MBN_MACHINE SZ_MBN_SEP_STR SZ_MBN_FTP) == 0 
            || _tcsicmp(strSiteNode,SZ_MBN_MACHINE SZ_MBN_SEP_STR SZ_MBN_FTP) == 0)
        {
            bReturn = TRUE;
        }
    }   


    return bReturn;
}

BOOL IsAppPoolPath(IN LPCTSTR lpszMDPath)
/*++

Routine Description:


Arguments:

    LPCTSTR lpszMDPath  : Metabase path.

Return Value:

    TRUE if the path is a app pool,
    FALSE otherwise.

--*/
{
    BOOL bReturn = FALSE;

    if (!lpszMDPath || !*lpszMDPath)
    {
        return bReturn;
    }

    CString strSiteNode;
    CString strRemainder;

    LPCTSTR lpPath = CMetabasePath::TruncatePath(3, lpszMDPath, strSiteNode, &strRemainder);
    if (lpPath && !strSiteNode.IsEmpty() && strRemainder.IsEmpty())
    {
        LPCTSTR lpPath2 = CMetabasePath::TruncatePath(2, lpPath, strSiteNode, &strRemainder);
		if (lpPath2){} // to get rid of warning level 4 compile

        if (_tcsicmp(strSiteNode,SZ_MBN_SEP_STR SZ_MBN_MACHINE SZ_MBN_SEP_STR SZ_MBN_APP_POOLS) == 0 
            || _tcsicmp(strSiteNode,SZ_MBN_MACHINE SZ_MBN_SEP_STR SZ_MBN_APP_POOLS) == 0)
        {
            bReturn = TRUE;
        }
    }   

    return bReturn;
}

BOOL IsWebSiteVDirPath(IN LPCTSTR lpszMDPath,IN BOOL bOkayToQueryMetabase)
/*++

Routine Description:


Arguments:

    LPCTSTR lpszMDPath  : Metabase path.

Return Value:

    TRUE if the path is a w3svc/1/root/whatevers vdir,
    FALSE otherwise.

--*/
{
    BOOL bReturn = FALSE;

    if (!lpszMDPath || !*lpszMDPath)
    {
        return bReturn;
    }

    CString strSiteNode;
    CString strRemainder;

    LPCTSTR lpPath = CMetabasePath::TruncatePath(3, lpszMDPath, strSiteNode, &strRemainder);
    if (lpPath && !strSiteNode.IsEmpty())
    {
        LPCTSTR lpPath2 = CMetabasePath::TruncatePath(2, lpPath, strSiteNode, &strRemainder);
		if (lpPath2){} // to get rid of warning level 4 compile

        if (_tcsicmp(strSiteNode,SZ_MBN_SEP_STR SZ_MBN_MACHINE SZ_MBN_SEP_STR SZ_MBN_WEB) == 0 
            || _tcsicmp(strSiteNode,SZ_MBN_MACHINE SZ_MBN_SEP_STR SZ_MBN_WEB) == 0)
        {
            // This is at least a lm/w3svc site
            // "lets now ask the metabase, if this is a VDir
            if (bOkayToQueryMetabase)
            {
                // query the metabase to see for sure...
            }
            bReturn = TRUE;
        }
    }   

    return bReturn;
}

BOOL IsFTPSiteVDirPath(IN LPCTSTR lpszMDPath,IN BOOL bOkayToQueryMetabase)
/*++

Routine Description:


Arguments:

    LPCTSTR lpszMDPath  : Metabase path.

Return Value:

    TRUE if the path is a msftpsvc/1/root/whatevers vdir,
    FALSE otherwise.

--*/
{
    BOOL bReturn = FALSE;

    if (!lpszMDPath || !*lpszMDPath)
    {
        return bReturn;
    }

    CString strSiteNode;
    CString strRemainder;

    LPCTSTR lpPath = CMetabasePath::TruncatePath(3, lpszMDPath, strSiteNode, &strRemainder);
    if (lpPath && !strSiteNode.IsEmpty())
    {
        LPCTSTR lpPath2 = CMetabasePath::TruncatePath(2, lpPath, strSiteNode, &strRemainder);
		if (lpPath2){} // to get rid of warning level 4 compile

        if (_tcsicmp(strSiteNode,SZ_MBN_SEP_STR SZ_MBN_MACHINE SZ_MBN_SEP_STR SZ_MBN_FTP) == 0 
            || _tcsicmp(strSiteNode,SZ_MBN_MACHINE SZ_MBN_SEP_STR SZ_MBN_FTP) == 0)
        {
            // This is at least a lm/msftpsvc site
            // "lets now ask the metabase, if this is a VDir
            if (bOkayToQueryMetabase)
            {
                // query the metabase to see for sure...
            }
            bReturn = TRUE;
        }
    }   

    return bReturn;
}

// Quick-'n'-dirty case-insensitive string hash function.
// Make sure that you follow up with _stricmp or _mbsicmp.  You should
// also cache the length of strings and check those first.  Caching
// an uppercase version of a string can help too.
// Again, apply HashScramble to the result if using with something other
// than LKRhash.
// Note: this is not really adequate for MBCS strings.
// Small prime number used as a multiplier in the supplied hash functions
const DWORD HASH_MULTIPLIER = 101;
# define HASH_MULTIPLY(dw) ((dw) * HASH_MULTIPLIER)
inline DWORD
HashStringNoCase(
    TCHAR * psz,
    DWORD       dwHash = 0)
{
    TCHAR * upsz = psz;
    for (  ;  *upsz;  ++upsz)
        dwHash = HASH_MULTIPLY(dwHash)
                     +  (*upsz & 0xDF);  // strip off lowercase bit
    return dwHash;
}

static const DWORD  DW_MAX_SITEID        = INT_MAX;
DWORD GetUniqueSite(CString strMetabaseServerNode)
{
    DWORD   dwReturn = 0;
    GUID    guid;
    TCHAR   wszSiteId[20] = {0};
    TCHAR   wszBuffer[64];
    CString strNewSitePath;

	StringCbCopy(wszBuffer, sizeof(wszBuffer), _T("abcdefghijklmnopqrstuvwxyz1234567890"));

    if (SUCCEEDED(::CoCreateGuid(&guid)))
    {
        VERIFY( StringFromGUID2( guid, wszBuffer, 64 ) != 0 );
    }

    // Create random string.
    DWORD dwStart = ( HashStringNoCase(wszBuffer) % DW_MAX_SITEID ) + 1;
    DWORD dwNrSitesTried = 0;
    for(DWORD idx = dwStart; 
        dwNrSitesTried < DW_MAX_SITEID; 
        dwNrSitesTried++, idx = (idx % DW_MAX_SITEID) + 1)
    {
        dwReturn = idx;
        _ultow(idx, wszSiteId, 10);
        strNewSitePath = strMetabaseServerNode + _T("/") + wszSiteId;

        if (!IsMetabaseWebSiteKeyExist(strNewSitePath))
        {
            break;
        }
        
        if (dwNrSitesTried > 100)
        {
            // if we can't find one in 100 tries
            // there is something seriously wrong...
            break;
        }
    }
    return dwReturn;
}

BOOL IsMetabaseWebSiteKeyExistAuth(PCONNECTION_INFO pConnectionInfo,CString strMetabaseWebSite)
{
	BOOL bRet = FALSE;
    HRESULT hr = E_FAIL;
    CString str = strMetabaseWebSite;
	LPWSTR lpwstrTempPassword = NULL;

    if (!pConnectionInfo)
    {
        return FALSE;
    }

	if (pConnectionInfo->pszUserPasswordEncrypted)
	{
		if (FAILED(DecryptMemoryPassword((LPWSTR) pConnectionInfo->pszUserPasswordEncrypted,&lpwstrTempPassword,pConnectionInfo->cbUserPasswordEncrypted)))
		{
			return FALSE;
		}
	}

    CComAuthInfo auth(pConnectionInfo->pszMachineName,pConnectionInfo->pszUserName,lpwstrTempPassword);
    CMetaKey key(&auth,str,METADATA_PERMISSION_READ);

    hr = key.QueryResult();
    if (key.Succeeded())
    {
        // i guess so.
		bRet = TRUE;
		goto IsMetabaseWebSiteKeyExistAuth_Exit;
    }

IsMetabaseWebSiteKeyExistAuth_Exit:
	if (lpwstrTempPassword)
	{
		// security percaution:Make sure to zero out memory that temporary password was used for.
		SecureZeroMemory(lpwstrTempPassword,pConnectionInfo->cbUserPasswordEncrypted);
		LocalFree(lpwstrTempPassword);
		lpwstrTempPassword = NULL;
	}
    return bRet;
}


BOOL IsMetabaseWebSiteKeyExist(CString strMetabaseWebSite)
{
    HRESULT hr = E_FAIL;
    CString str = strMetabaseWebSite;
    CComAuthInfo auth;
    CMetaKey key(&auth,str,METADATA_PERMISSION_READ);

    hr = key.QueryResult();
    if (key.Succeeded())
    {
        // i guess so.
        return TRUE;
    }
    return FALSE;
}

void AddEndingMetabaseSlashIfNeedTo(LPTSTR szDestinationString,DWORD cbDestinationString)
{
    if (szDestinationString)
    {
        if ('/' != szDestinationString[_tcslen(szDestinationString) - 1])
        {
            __try
            {
				StringCbCat(szDestinationString,cbDestinationString,_T("/"));
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                // lame
            }
        }
    }
}

BOOL AnswerIsYes(HWND hDlg,UINT id,LPCTSTR file)
{
	CString strFormat;
    CString strMsg;
    CString strCaption;
    strCaption.LoadString(_Module.GetResourceInstance(), IDS_MSGBOX_CAPTION);
    strFormat.LoadString(_Module.GetResourceInstance(), id);
	strMsg.Format(strFormat, file);
    return (IDYES == MessageBox(hDlg,strMsg,strCaption,MB_ICONEXCLAMATION | MB_YESNO));
}


/*
 *  Function : RemoveSpaces
 *     Copies a string removing leading and trailing spaces but allowing
 *     for long file names with internal spaces.
 *
 *  Parameters :
 *     szPath - The output result
 *     szEdit - The input path
 */
 VOID RemoveSpaces(LPTSTR szPath, DWORD cbPathSize, LPTSTR szEdit)
 {
     LPTSTR szLastSpaceList;

     while (*szEdit == TEXT(' ')) {
         szEdit = CharNext(szEdit);
     }
     StringCbCopy(szPath, cbPathSize, szEdit);
     for (szLastSpaceList = NULL;
          *szPath != TEXT('\0');
          szPath = CharNext(szPath)) {

        if (*szPath == TEXT(' ')) {
            if (szLastSpaceList == NULL) {
                szLastSpaceList = szPath;
            }
        } else {
            szLastSpaceList = NULL;
        }

     }

     if (szLastSpaceList != NULL) {
         *szLastSpaceList = TEXT('\0');
     }
}


BOOL IsSpaces(LPCTSTR szPath)
{
    BOOL bAllSpaces = TRUE;

    // skip over leading spaces..
    while (*szPath == TEXT(' ')) 
    {
        szPath = CharNext(szPath);
    }

    while (*szPath && *szPath != TEXT(' ')) 
    {
        bAllSpaces = FALSE;
        szPath = CharNext(szPath);
    }
    return bAllSpaces;
}

HRESULT DumpProxyInfo(IUnknown * punk)
{
	COAUTHINFO	authinfo;
	COAUTHINFO*	pCoAuthInfo = &authinfo;

    HRESULT hr = E_FAIL;

    // in all cases, update the fields to reflect the actual state of
    // security on the proxy

	if (SUCCEEDED(hr = CoQueryProxyBlanket(punk, 
        &pCoAuthInfo->dwAuthnSvc, 
        &pCoAuthInfo->dwAuthzSvc,
		&pCoAuthInfo->pwszServerPrincName, 
        &pCoAuthInfo->dwAuthnLevel,
		&pCoAuthInfo->dwImpersonationLevel, 
        (RPC_AUTH_IDENTITY_HANDLE*) &pCoAuthInfo->pAuthIdentityData,
        &pCoAuthInfo->dwCapabilities 
        )))
    {
        IISDebugOutput(_T("CoQueryProxyBlanket:dwAuthnSvc=%d,dwAuthzSvc=%d,pwszServerPrincName=%s,dwAuthnLevel=%d,dwImpersonationLevel=%d,pAuthIdentityData=%p,dwCapabilities=%d\r\n"),
            pCoAuthInfo->dwAuthnSvc,
            pCoAuthInfo->dwAuthzSvc,
		    pCoAuthInfo->pwszServerPrincName, 
            pCoAuthInfo->dwAuthnLevel,
		    pCoAuthInfo->dwImpersonationLevel, 
            pCoAuthInfo->pAuthIdentityData,
            pCoAuthInfo->dwCapabilities 
            );
    }
    return hr;
}

void LaunchHelp(HWND hWndMain, DWORD_PTR dwWinHelpID)
{
	DebugTraceHelp(dwWinHelpID);

    CString sz;
    TCHAR szHelpLocation[MAX_PATH+1];
	sz.LoadString(_Module.GetResourceInstance(), IDS_HELPLOC_HELP);
    if (ExpandEnvironmentStrings(sz, szHelpLocation, MAX_PATH))
	{
		WinHelp(hWndMain,szHelpLocation,HELP_CONTEXT,dwWinHelpID);
	}

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\iishelp.cpp ===
#include "stdafx.h"

INT g_iDebugOutputLevel = 0;

void GetOutputDebugFlag(void)
{
    DWORD rc, err, size, type;
    HKEY  hkey;
    err = RegOpenKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\InetMgr"), &hkey);
    if (err != ERROR_SUCCESS) {return;}
    size = sizeof(DWORD);
    err = RegQueryValueEx(hkey,_T("OutputDebugFlag"),0,&type,(LPBYTE)&rc,&size);
    if (err != ERROR_SUCCESS || type != REG_DWORD) {rc = 0;}
    RegCloseKey(hkey);

	if (rc < 0xffffffff)
	{
		g_iDebugOutputLevel = rc;
	}
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\extndppg.cpp ===
// ExtndPpg.cpp : Implementation of the CExtndPropPage property page class.

#include "stdafx.h"
#include "logui.h"
#include "ExtndPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CExtndPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CExtndPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CExtndPropPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CExtndPropPage, "LOGUI.ExtndPropPage.1",
	0x68871e4a, 0xba87, 0x11d0, 0x92, 0x99, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b)


/////////////////////////////////////////////////////////////////////////////
// CExtndPropPage::CExtndPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CExtndPropPage

BOOL CExtndPropPage::CExtndPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_EXTND_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CExtndPropPage::CExtndPropPage - Constructor

CExtndPropPage::CExtndPropPage() :
	COlePropertyPage(IDD, IDS_EXTND_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CExtndPropPage)
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CExtndPropPage::DoDataExchange - Moves data between page and properties

void CExtndPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CExtndPropPage)
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CExtndPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\cnfrmpsd.cpp ===
// CnfrmPsD.cpp : implementation file
//

#include "stdafx.h"
#include "logui.h"
#include "CnfrmPsD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConfirmPassDlg dialog

CConfirmPassDlg::CConfirmPassDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CConfirmPassDlg::IDD, pParent)
    {
    //{{AFX_DATA_INIT(CConfirmPassDlg)
	m_sz_password_new = _T("");
	//}}AFX_DATA_INIT
    }

void CConfirmPassDlg::DoDataExchange(CDataExchange* pDX)
    {
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CConfirmPassDlg)
	DDX_Text_SecuredString(pDX, IDC_ODBC_CONFIRM_PASSWORD, m_sz_password_new);
	//}}AFX_DATA_MAP
    }

BEGIN_MESSAGE_MAP(CConfirmPassDlg, CDialog)
    //{{AFX_MSG_MAP(CConfirmPassDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfirmPassDlg message handlers

void CConfirmPassDlg::OnOK() 
    {
    UpdateData( TRUE );

    // confirm it
    if (0 != m_sz_password_new.Compare(m_szOrigPass))
        {
        AfxMessageBox( IDS_PASS_CONFIRM_FAIL );
        return;
        }

    CDialog::OnOK();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\cnfrmpsd.h ===
// CnfrmPsD.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CConfirmPassDlg dialog

class CConfirmPassDlg : public CDialog
{
// Construction
public:
	CConfirmPassDlg(CWnd* pParent = NULL);   // standard constructor

    // the original password that we are confirming
    CStrPassword m_szOrigPass;

// Dialog Data
	//{{AFX_DATA(CConfirmPassDlg)
	enum { IDD = IDD_CONFIRM_ODBC_PASSWORD };
	CStrPassword m_sz_password_new;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConfirmPassDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CConfirmPassDlg)
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\helpmap.h ===
// helpmaps for the logui project - handmade

#define HIDD_LOGUI_GENERIC                      0x50200
#define HIDD_LOGUI_EXTENDED						0x50201
#define HIDD_LOGUI_ODBC							0x50202
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\extndppg.h ===
// ExtndPpg.h : Declaration of the CExtndPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CExtndPropPage : See ExtndPpg.cpp.cpp for implementation.

class CExtndPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CExtndPropPage)
	DECLARE_OLECREATE_EX(CExtndPropPage)

// Constructor
public:
	CExtndPropPage();

// Dialog Data
	//{{AFX_DATA(CExtndPropPage)
	enum { IDD = IDD_PROPPAGE_EXTND };
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CExtndPropPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\iishelp.h ===
#ifndef  _IISHELP_H_
#define  _IISHELP_H_

#include "debugdefs.h"

#if defined(_DEBUG) || DBG
    #define DEBUG_WINHELP_FLAG
#else
    // set this to debug on fre build
    //#define DEBUG_WINHELP_FLAG
#endif

extern INT g_iDebugOutputLevel;

#ifdef DEBUG_WINHELP_FLAG
    inline void _cdecl DebugTraceHelp(DWORD_PTR dwWinHelpID)
    {
        // Only do this if the flag is set.
        if (0 != g_iDebugOutputLevel)
        {
			if (DEBUG_FLAG_HELP & g_iDebugOutputLevel)
			{
				TCHAR szBuffer[30];
				_stprintf(szBuffer,_T("WinHelp:0x%x,%d\r\n"),dwWinHelpID,dwWinHelpID);
				OutputDebugString(szBuffer);
			}
		}
        return;
    }

    inline void _cdecl DebugTrace(LPTSTR lpszFormat, ...)
    {
        // Only do this if the flag is set.
        if (0 != g_iDebugOutputLevel)
        {
			if (DEBUG_FLAG_MODULE_LOGUI & g_iDebugOutputLevel)
			{
				int nBuf;
				TCHAR szBuffer[_MAX_PATH];
				va_list args;
				va_start(args, lpszFormat);

				nBuf = _vsntprintf(szBuffer, sizeof(szBuffer)/sizeof(szBuffer[0]), lpszFormat, args);

				OutputDebugString(szBuffer);
				va_end(args);

				// if it does not end if '\r\n' then make one.
				int nLen = _tcslen(szBuffer);
				if (szBuffer[nLen-1] != _T('\n')){OutputDebugString(_T("\r\n"));}
			}
        }
    }

#else
    inline void _cdecl DebugTraceHelp(DWORD_PTR dwWinHelpID){}
	inline void _cdecl DebugTrace(LPTSTR , ...){}
#endif

void GetOutputDebugFlag(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\logadvpg.cpp ===
// LogAdvPg.cpp : implementation file
//

#include "stdafx.h"
#include "logui.h"
//#include "wrapmb.h"
#include <iiscnfg.h>
//#include <metatool.h>

//#include <shlwapi.h>
#include "shlwapip.h"

#include "tmschema.h"
//#include "uxtheme.h"
#include "uxthemep.h"

#include "LogAdvPg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern HINSTANCE g_hInstance;
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

//
// Possible Item States
//
#define TVIS_GCEMPTY        0 
#define TVIS_GCNOCHECK      1 
#define TVIS_GCCHECK        2
#define TVIS_GCTRINOCHECK   3
#define TVIS_GCTRICHECK     4

#define STATEIMAGEMASKTOINDEX(i) ((i) >> 12)

#define USE_NEW_CHECKBOXES_IN_WINXP



static int CALLBACK LogUICompareProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
	// lParamSort contains a pointer to the tree control

	CLogAdvanced::PCONFIG_INFORMATION pCnfgInfo1 = (CLogAdvanced::PCONFIG_INFORMATION) lParam1;
	CLogAdvanced::PCONFIG_INFORMATION pCnfgInfo2 = (CLogAdvanced::PCONFIG_INFORMATION) lParam2;

	CTreeCtrl* pTreeCtrl = (CTreeCtrl*) lParamSort;

	if (pCnfgInfo1->iOrder < pCnfgInfo2->iOrder)
		return(-1);
	else if (pCnfgInfo1->iOrder > pCnfgInfo2->iOrder)
		return(1);
	else	
		return(0);
}

/////////////////////////////////////////////////////////////////////////////
// CLogAdvanced property page

IMPLEMENT_DYNCREATE(CLogAdvanced, CPropertyPage)

CLogAdvanced::CLogAdvanced() : CPropertyPage(CLogAdvanced::IDD)
{
	//{{AFX_DATA_INIT(CLogAdvanced)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_mapLogUIOrder[1] = 1;   // IDS_DATE
    m_mapLogUIOrder[2] = 2;   // IDS_TIME
    m_mapLogUIOrder[3] = 3;   // IDS_EXTENDED
    m_mapLogUIOrder[4] = 4;   // IDS_PROCESS_ACCT
                    
    m_mapLogUIOrder[5] = 1;   // IDS_CLIENT
    m_mapLogUIOrder[6] = 2;   // IDS_USER
    m_mapLogUIOrder[7] = 3;   // IDS_SERVICE_NAME_T
    m_mapLogUIOrder[8] = 4;   // IDS_SERVER_NAME_T
    m_mapLogUIOrder[9] = 5;   // IDS_SERVER_IP
    m_mapLogUIOrder[10] = 6;   // IDS_SERVER_PORT
    m_mapLogUIOrder[11] = 7;   // IDS_METHOD
    m_mapLogUIOrder[12] = 8;   // IDS_URI_STEM
    m_mapLogUIOrder[13] = 9;   // IDS_URI_QUERY
    m_mapLogUIOrder[14] = 10;   // IDS_PROTOCOL
    m_mapLogUIOrder[15] = 12;   // IDS_WIN32
    m_mapLogUIOrder[16] = 13;   // IDS_BYTES_SENT_T
    m_mapLogUIOrder[17] = 14;   // IDS_BYTES_RECEIVED
    m_mapLogUIOrder[18] = 15;   // IDS_TIME_TAKEN
    m_mapLogUIOrder[19] = 16;   // IDS_PROTOCOL_VER
    m_mapLogUIOrder[20] = 17;   // IDS_HOST
    m_mapLogUIOrder[21] = 18;   // IDS_USER_AGENT
    m_mapLogUIOrder[22] = 19;   // IDS_COOKIE_T
    m_mapLogUIOrder[23] = 20;   // IDS_REFERER

    m_mapLogUIOrder[24] = 1;   // IDS_PROCESS_EVENT
    m_mapLogUIOrder[25] = 2;   // IDS_PROCESS_TYPE
    m_mapLogUIOrder[26] = 3;   // IDS_TOTAL_USER_TIME
    m_mapLogUIOrder[27] = 4;   // IDS_TOTAL_KERNEL_TIME
    m_mapLogUIOrder[28] = 5;   // IDS_TOTAL_PAGE_FAULTS
    m_mapLogUIOrder[29] = 6;   // IDS_TOTAL_PROCESSES
    m_mapLogUIOrder[30] = 7;   // IDS_ACTIVE_PROCESSES
    m_mapLogUIOrder[31] = 8;   // IDS_TOTAL_TERM_PROCS

    m_mapLogUIOrder[32] = 11;   // IDS_PROTOCOL_SUB

    m_mapLogUIString[1] = IDS_DATE;
    m_mapLogUIString[2] = IDS_TIME;
    m_mapLogUIString[3] = IDS_EXTENDED;
    m_mapLogUIString[4] = IDS_PROCESS_ACCT;
                    
    m_mapLogUIString[5] = IDS_CLIENT;
    m_mapLogUIString[6] = IDS_USER;
    m_mapLogUIString[7] = IDS_SERVICE_NAME_T;
    m_mapLogUIString[8] = IDS_SERVER_NAME_T;
    m_mapLogUIString[9] = IDS_SERVER_IP;
    m_mapLogUIString[10] = IDS_SERVER_PORT;
    m_mapLogUIString[11] = IDS_METHOD;
    m_mapLogUIString[12] = IDS_URI_STEM;
    m_mapLogUIString[13] = IDS_URI_QUERY;
    m_mapLogUIString[14] = IDS_PROTOCOL;
    m_mapLogUIString[15] = IDS_WIN32;
    m_mapLogUIString[16] = IDS_BYTES_SENT_T;
    m_mapLogUIString[17] = IDS_BYTES_RECEIVED;
    m_mapLogUIString[18] = IDS_TIME_TAKEN;
    m_mapLogUIString[19] = IDS_PROTOCOL_VER;
    m_mapLogUIString[20] = IDS_HOST;
    m_mapLogUIString[21] = IDS_USER_AGENT;
    m_mapLogUIString[22] = IDS_COOKIE_T;
    m_mapLogUIString[23] = IDS_REFERER;

    m_mapLogUIString[24] = IDS_PROCESS_EVENT;
    m_mapLogUIString[25] = IDS_PROCESS_TYPE;
    m_mapLogUIString[26] = IDS_TOTAL_USER_TIME;
    m_mapLogUIString[27] = IDS_TOTAL_KERNEL_TIME;
    m_mapLogUIString[28] = IDS_TOTAL_PAGE_FAULTS;
    m_mapLogUIString[29] = IDS_TOTAL_PROCESSES;
    m_mapLogUIString[30] = IDS_ACTIVE_PROCESSES;
    m_mapLogUIString[31] = IDS_TOTAL_TERM_PROCS;

    m_mapLogUIString[32] = IDS_PROTOCOL_SUB;

}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CLogAdvanced)
	DDX_Control(pDX, IDC_PROP_TREE, m_wndTreeCtrl);
	//}}AFX_DATA_MAP
}

/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CLogAdvanced, CPropertyPage)
	//{{AFX_MSG_MAP(CLogAdvanced)
	ON_NOTIFY(NM_CLICK, IDC_PROP_TREE, OnClickTree)
	ON_NOTIFY(TVN_KEYDOWN, IDC_PROP_TREE, OnKeydownTree)
	ON_WM_DESTROY()
    ON_MESSAGE(WM_THEMECHANGED, OnThemeChanged)
    ON_MESSAGE(WM_DISPLAYCHANGE, OnThemeChanged)
    ON_MESSAGE(WM_PALETTECHANGED, OnThemeChanged)
    ON_MESSAGE(WM_SYSCOLORCHANGE, OnThemeChanged)
	//}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLogAdvanced message handlers

LRESULT CLogAdvanced::OnThemeChanged(WPARAM wParam, LPARAM lParam)
{
    HandleThemes();
    InvalidateRect(0, TRUE);
    return TRUE;
}

HBITMAP CreateDIB(HDC h, int cx, int cy, RGBQUAD** pprgb)
{
    BITMAPINFO bi = {0};
    bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
    bi.bmiHeader.biWidth = cx;
    bi.bmiHeader.biHeight = cy;
    bi.bmiHeader.biPlanes = 1;
    bi.bmiHeader.biBitCount = 32;
    bi.bmiHeader.biCompression = BI_RGB;

    return CreateDIBSection(h, &bi, DIB_RGB_COLORS, (void**)pprgb, NULL, 0);
}


#define BITMAP_WIDTH    16
#define BITMAP_HEIGHT   16
#define NUM_BITMAPS     5

void CLogAdvanced::HandleThemes(void)
{
	UINT flags = ILC_MASK | (IsOS(OS_WHISTLERORGREATER)?ILC_COLOR32:ILC_COLOR);
    HBITMAP hBitmap = 0;

#ifndef USE_NEW_CHECKBOXES_IN_WINXP
    // Old code before WinXP themes...
    HIMAGELIST hImage = ImageList_LoadImage(AfxGetResourceHandle(), MAKEINTRESOURCE(IDB_CHECKBOX), 16, 5, RGB(255,0,0), IMAGE_BITMAP, LR_DEFAULTCOLOR);
#else
    // WinXP themes
    /*
    if(IS_WINDOW_RTL_MIRRORED(m_wndTreeCtrl.m_hWnd))
    {
        flags |= ILC_MIRROR;
    }
    */
    SHSetWindowBits(m_wndTreeCtrl.m_hWnd, GWL_STYLE, TVS_CHECKBOXES, 0);
    HIMAGELIST hImage = ImageList_Create(BITMAP_WIDTH, BITMAP_HEIGHT, flags, NUM_BITMAPS, 5);
    if (hImage)
    {
        HTHEME hTheme = OpenThemeData(NULL, L"Button");
        if (hTheme)
        {
            HDC hdc = CreateCompatibleDC(NULL);
            if (hdc)
            {
                HBITMAP hbmp = CreateDIB(hdc, BITMAP_WIDTH, BITMAP_HEIGHT, NULL);
                if (hbmp)
                {
                    RECT rc = {0, 0, BITMAP_WIDTH, BITMAP_HEIGHT};
                    static const s_rgParts[] = {BP_CHECKBOX,BP_CHECKBOX,BP_CHECKBOX,BP_CHECKBOX,BP_CHECKBOX};
                    static const s_rgStates[] = {CBS_CHECKEDNORMAL,CBS_UNCHECKEDNORMAL,CBS_CHECKEDNORMAL,CBS_UNCHECKEDDISABLED,CBS_CHECKEDDISABLED};
                    for (int i = 0; i < ARRAYSIZE(s_rgParts); i++)
                    {
                        HBITMAP hOld = (HBITMAP)SelectObject(hdc, hbmp);
                        SHFillRectClr(hdc, &rc, RGB(0,0,0));
                        DTBGOPTS dtbg = {sizeof(DTBGOPTS), DTBG_DRAWSOLID, 0,};   // tell drawthemebackground to preserve the alpha channel

                        DrawThemeBackgroundEx(hTheme, hdc, s_rgParts[i], s_rgStates[i], &rc, &dtbg);
                        SelectObject(hdc, hOld);

                        ImageList_Add(hImage, hbmp, NULL);
                    }

                    DeleteObject(hbmp);
                }
                DeleteDC(hdc);
            }
            CloseThemeData(hTheme);
        }
        else
        {
            if (hImage)
            {
                ImageList_Destroy(hImage);
                hImage = NULL;
            }
            hImage = ImageList_LoadImage(AfxGetResourceHandle(), MAKEINTRESOURCE(IDB_CHECKBOX), 16, 5, RGB(255,0,0), IMAGE_BITMAP, LR_DEFAULTCOLOR);
        }
    }
#endif

    if (hImage != NULL)
    {
        m_wndTreeCtrl.SetImageList(CImageList::FromHandle(hImage), TVSIL_STATE);
    }

    return;
}

BOOL CLogAdvanced::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();

    HandleThemes();
    CreateTreeFromMB();
    ProcessProperties(false);
	
    //
    // set up the modified property list array
    //
    
    m_fTreeModified = false;
    m_cModifiedProperties = 0;
    
    int cProperties = m_wndTreeCtrl.GetCount();

    m_pModifiedPropIDs[0] = new DWORD[cProperties];
    m_pModifiedPropIDs[1] = new DWORD[cProperties];

    SetModified(FALSE);

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::OnClickTree(NMHDR* pNMHDR, LRESULT* pResult) 
{
    DWORD dwpos;
    TV_HITTESTINFO tvhti;
    HTREEITEM  htiItemClicked;
    POINT point;

    //
    // Find out where the cursor was
    //

    dwpos = GetMessagePos();
    point.x = LOWORD(dwpos);
    point.y = HIWORD(dwpos);

    ::MapWindowPoints(HWND_DESKTOP, m_wndTreeCtrl.m_hWnd, &point, 1);

    tvhti.pt = point;
    htiItemClicked = m_wndTreeCtrl.HitTest(&tvhti);

    //
    // If the state image was clicked, lets get the state from the item and toggle it.
    //

    if (tvhti.flags & TVHT_ONITEMSTATEICON)
    {
        ProcessClick(htiItemClicked);
    }

    *pResult = 0;
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::OnKeydownTree(NMHDR* pNMHDR, LRESULT* pResult) 
{
    TV_KEYDOWN* pTVKeyDown = (TV_KEYDOWN*)pNMHDR;
    
    if (VK_SPACE != pTVKeyDown->wVKey)
    {
        // User didn't press the space key. Continue default action
        *pResult = 0;
        return;
    }
    
    ProcessClick(m_wndTreeCtrl.GetSelectedItem());

    //
    // Stop any more processing
    //
    
    *pResult = 1;
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::ProcessClick(HTREEITEM htiItemClicked)
{
    TV_ITEM                 tvi;
    UINT                    state;
    HTREEITEM               htiChild;
    PCONFIG_INFORMATION     pCnfg;
    
    if (htiItemClicked)
    {
        //
        // Flip the state of the clicked item if the item is enabled
        //
        tvi.hItem       = htiItemClicked;
        tvi.mask        = TVIF_STATE;
        tvi.stateMask   = TVIS_STATEIMAGEMASK;

        m_wndTreeCtrl.GetItem(&tvi); 

        state = STATEIMAGEMASKTOINDEX(tvi.state);
        pCnfg = (PCONFIG_INFORMATION)(tvi.lParam);
        htiChild = m_wndTreeCtrl.GetNextItem(htiItemClicked, TVGN_CHILD);

        if ( TVIS_GCNOCHECK == state )
        {
            tvi.state = INDEXTOSTATEIMAGEMASK (TVIS_GCCHECK) ;
            pCnfg->fItemModified = true;
            
            m_wndTreeCtrl.SetItem(&tvi);
    
            m_fTreeModified = true;
            SetModified();

            // Reset properties for child nodes
            if (htiChild)
            {
                SetSubTreeProperties(NULL, htiChild, TRUE, FALSE);
            }
        }
        else if ( TVIS_GCCHECK == state )
        {
            tvi.state = INDEXTOSTATEIMAGEMASK (TVIS_GCNOCHECK) ;
            pCnfg->fItemModified = true;
            
            m_wndTreeCtrl.SetItem(&tvi);

            m_fTreeModified = true;
            SetModified();

            // Reset properties for child nodes

            if (htiChild)
            {
                SetSubTreeProperties(NULL, htiChild, FALSE, FALSE);
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::ProcessProperties(bool fSave)
{
    HTREEITEM hRoot;
    if ( NULL != (hRoot = m_wndTreeCtrl.GetRootItem()))
    {
        CString csTempPassword;
        m_szPassword.CopyTo(csTempPassword);
        CComAuthInfo auth(m_szServer, m_szUserName, csTempPassword);
        CMetaKey mk(&auth, m_szMeta, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
        if (fSave && m_fTreeModified)
        {
            SaveSubTreeProperties(mk, hRoot);
            for (int i = 0; i < m_cModifiedProperties; i++)
            {
                mk.SetValue(m_pModifiedPropIDs[0][i], m_pModifiedPropIDs[1][i]);
            }
            m_fTreeModified = false;
        }
        else
        {
            SetSubTreeProperties(&mk, hRoot, TRUE, TRUE);
        }
    }
}

/////////////////////////////////////////////////////////////////////////////


void CLogAdvanced::SetSubTreeProperties(
    CMetaKey * mk,
    HTREEITEM hTreeRoot, 
    BOOL fParentState, 
    BOOL fInitialize
    )
{
    HTREEITEM hTreeChild, hTreeSibling;
    PCONFIG_INFORMATION pCnfg;
    UINT iState;
    DWORD dwProperty = 0;
    
    if (NULL == hTreeRoot)
    {
        return;
    }

    pCnfg = (PCONFIG_INFORMATION)(m_wndTreeCtrl.GetItemData(hTreeRoot));
    if (NULL != pCnfg)
    {
        if (fInitialize)
        {
            if (pCnfg->dwPropertyID != 0)
            {
                mk->QueryValue(pCnfg->dwPropertyID, dwProperty);
                dwProperty &= pCnfg->dwPropertyMask;
            }
        }
        else
        {
            //
            // we are not initializing, so use the value from the tree
            //
            iState = STATEIMAGEMASKTOINDEX(m_wndTreeCtrl.GetItemState(hTreeRoot, TVIS_STATEIMAGEMASK));
            dwProperty = (TVIS_GCCHECK == iState || TVIS_GCTRICHECK == iState);
        }
		if (pCnfg->dwPropertyID != 0)
		{
			//
			// Choose the new state depending on parent state
			//
			if (fParentState)
			{
				iState = ( 0 == dwProperty) ?   INDEXTOSTATEIMAGEMASK(TVIS_GCNOCHECK) :
												INDEXTOSTATEIMAGEMASK(TVIS_GCCHECK);
			}
			else
			{
				iState = ( 0 == dwProperty) ?   INDEXTOSTATEIMAGEMASK(TVIS_GCTRINOCHECK) :
												INDEXTOSTATEIMAGEMASK(TVIS_GCTRICHECK);
			}
		}
		else
		{
			dwProperty = TRUE;
			iState = TVIS_GCEMPTY;
		}
        m_wndTreeCtrl.SetItemState(hTreeRoot, iState, TVIS_STATEIMAGEMASK);
    }
    else
    {
        //
        // Tree node with no checkbox (hence no config info)
        //
        dwProperty = TRUE;
        m_wndTreeCtrl.SetItemState(hTreeRoot, INDEXTOSTATEIMAGEMASK(TVIS_GCEMPTY), TVIS_STATEIMAGEMASK);
    }
    
    //
    // Recurse through children and siblings
    //
    if ( NULL != (hTreeChild = m_wndTreeCtrl.GetNextItem(hTreeRoot, TVGN_CHILD)))
    {
        SetSubTreeProperties(mk, hTreeChild, dwProperty && fParentState, fInitialize);
    }
    if ( NULL != (hTreeSibling = m_wndTreeCtrl.GetNextItem(hTreeRoot, TVGN_NEXT)))
    {
        SetSubTreeProperties(mk, hTreeSibling, fParentState, fInitialize);
    }
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::SaveSubTreeProperties(CMetaKey& mk, HTREEITEM hTreeRoot)
{
    HTREEITEM hTreeChild, hTreeSibling;
    PCONFIG_INFORMATION pCnfg;
    
    if (NULL != hTreeRoot)
    {
        pCnfg = (PCONFIG_INFORMATION)(m_wndTreeCtrl.GetItemData(hTreeRoot));
        if (NULL != pCnfg && pCnfg->fItemModified)
        {
            UINT NewState 
                = STATEIMAGEMASKTOINDEX(m_wndTreeCtrl.GetItemState(hTreeRoot, TVIS_STATEIMAGEMASK));
            if (TVIS_GCNOCHECK <= NewState && TVIS_GCTRICHECK >= NewState)
            {
				if (pCnfg->dwPropertyID != 0)
				{
					//
					// Get the property, reset the bit mask & write it back
					//
					DWORD   dwProperty = 0;
					if (!GetModifiedFieldFromArray(pCnfg->dwPropertyID, &dwProperty))
					{
						mk.QueryValue(pCnfg->dwPropertyID, dwProperty);
					}
					dwProperty &= ~(pCnfg->dwPropertyMask);
					if ((TVIS_GCCHECK == NewState) || (TVIS_GCTRICHECK == NewState))
					{
						dwProperty |= pCnfg->dwPropertyMask;
					}
					//mk.SetValue(pCnfg->dwPropertyID, dwProperty);
					// mbWrap.SetDword(_T(""), pCnfg->dwPropertyID, IIS_MD_UT_SERVER, dwProperty);
					InsertModifiedFieldInArray(pCnfg->dwPropertyID, dwProperty);
				}
            }
        }
        //
        // Recurse through children and siblings
        //
        if ( NULL != (hTreeChild = m_wndTreeCtrl.GetNextItem(hTreeRoot, TVGN_CHILD)))
        {
            SaveSubTreeProperties(mk, hTreeChild);
        }
        if( NULL != (hTreeSibling = m_wndTreeCtrl.GetNextItem(hTreeRoot, TVGN_NEXT)))
        {
            SaveSubTreeProperties(mk, hTreeSibling);
        }
    }
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::DeleteSubTreeConfig(HTREEITEM hTreeRoot)
{
    HTREEITEM hTreeChild, hTreeSibling;
    PCONFIG_INFORMATION pCnfg;
    if (NULL == hTreeRoot)
    {
        return;
    }

    if ( NULL != (hTreeChild = m_wndTreeCtrl.GetNextItem(hTreeRoot, TVGN_CHILD)))
    {
        DeleteSubTreeConfig(hTreeChild);
    }
    if ( NULL != (hTreeSibling = m_wndTreeCtrl.GetNextItem(hTreeRoot, TVGN_NEXT)))
    {
        DeleteSubTreeConfig(hTreeSibling);
    }
    pCnfg = (PCONFIG_INFORMATION)(m_wndTreeCtrl.GetItemData(hTreeRoot));
    if (pCnfg)
    {
        delete pCnfg;
    }
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::CreateTreeFromMB()
{
    TCHAR szLoggingUIPath[] = _T("/LM/Logging/Custom Logging");
    CString csTempPassword;
    m_szPassword.CopyTo(csTempPassword);
    CComAuthInfo auth(m_szServer, m_szUserName, csTempPassword);
    CMetaKey mk(&auth, szLoggingUIPath, METADATA_PERMISSION_READ);
    if (mk.Succeeded())
    {
        CreateSubTree(mk, _T(""), NULL);
    }
    m_wndTreeCtrl.EnsureVisible(m_wndTreeCtrl.GetRootItem());
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::CreateSubTree(CMetaKey& mk, LPCTSTR szPath, HTREEITEM hTreeRoot)
{
    CString child;
	TCHAR szDisplayName[256];

    TV_ITEM tvi;
    TV_INSERTSTRUCT tvins;
    HTREEITEM hChild = NULL;
    PCONFIG_INFORMATION pCnfgInfo;

    // Prepare the item for insertion
    tvi.mask           = TVIF_TEXT | TVIF_PARAM | TVIF_STATE;
    tvi.state          = INDEXTOSTATEIMAGEMASK(TVIS_GCEMPTY) ;
    tvi.stateMask      = TVIS_STATEIMAGEMASK;
    tvins.hParent      = hTreeRoot;
    tvins.hInsertAfter = TVI_LAST;

    int count = 0;
    CMetaEnumerator en(FALSE, &mk);
    while (SUCCEEDED(en.Next(child, szPath)))
    {
        DWORD dwPropertyID, dwPropertyMask;
        DWORD dwNodeID = 0;
        CStringListEx list;
        CMetabasePath path(FALSE, szPath, child);
        if (SUCCEEDED(en.QueryValue(MD_LOGCUSTOM_SERVICES_STRING, list, NULL, path)))
        {
            BOOL bFound = FALSE;
            POSITION pos = list.GetHeadPosition();
            while (pos != NULL)
            {
                if (list.GetNext(pos).CompareNoCase(m_szServiceName) == 0)
                {
                    bFound = TRUE;
                    break;
                }
            }
            if (!bFound)
            {
                continue;
            }
        }
        pCnfgInfo = new CONFIG_INFORMATION;
        if (pCnfgInfo == NULL) 
        {
            break;
        }
        if (    SUCCEEDED(en.QueryValue(MD_LOGCUSTOM_PROPERTY_ID, dwPropertyID, NULL, path))
            &&  SUCCEEDED(en.QueryValue(MD_LOGCUSTOM_PROPERTY_MASK, dwPropertyMask, NULL, path))
            )
        {
            pCnfgInfo->dwPropertyID = dwPropertyID;
            pCnfgInfo->dwPropertyMask = dwPropertyMask;
        }
        else
        {
	        pCnfgInfo->dwPropertyID = 0;
	        pCnfgInfo->dwPropertyMask = 0;
        }
        if (FAILED(en.QueryValue(MD_LOGCUSTOM_PROPERTY_NODE_ID, dwNodeID, NULL, path)))
        {
            dwNodeID = 0;
        }
        pCnfgInfo->fItemModified = false;

        if (dwNodeID) 
        {
            ::LoadString(
                (HINSTANCE)GetWindowLongPtr(m_wndTreeCtrl, GWLP_HINSTANCE), m_mapLogUIString[dwNodeID], 
                szDisplayName, 256);
            tvi.pszText = szDisplayName;
            pCnfgInfo->iOrder	= m_mapLogUIOrder[dwNodeID];
        }
        else 
        {
            tvi.pszText = StrDup(child);
            pCnfgInfo->iOrder = 0;
        }
        tvi.lParam = (LPARAM)pCnfgInfo;
        tvins.item = tvi;
        hChild = m_wndTreeCtrl.InsertItem((LPTV_INSERTSTRUCT) &tvins);
        //
        // Enumerate children
        //
        CreateSubTree(mk, (LPCTSTR)path, hChild);
        count++;
    }

    if (0 != count) 
    {
        m_wndTreeCtrl.Expand(hTreeRoot, TVE_EXPAND);
    }

	// Now sort the tree from subtree root down
	TVSORTCB tvs;
	tvs.hParent = hTreeRoot;
	tvs.lpfnCompare = LogUICompareProc;
	tvs.lParam = (LPARAM) &m_wndTreeCtrl;
	m_wndTreeCtrl.SortChildrenCB(&tvs);
}

/////////////////////////////////////////////////////////////////////////////

bool CLogAdvanced::IsPresentServiceSupported(LPTSTR szSupportedServices)
{
    while ( szSupportedServices[0] != 0) 
    {
        if ( 0 == lstrcmpi(m_szServiceName, szSupportedServices) )
        {
            return true;
        }

        szSupportedServices += lstrlen(szSupportedServices)+1;
    }

    return false;
}

/////////////////////////////////////////////////////////////////////////////

BOOL CLogAdvanced::OnApply() 
{
    ProcessProperties(true);
    return CPropertyPage::OnApply();
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::DoHelp()
{
    DebugTraceHelp(HIDD_LOGUI_EXTENDED);
    WinHelp( HIDD_LOGUI_EXTENDED );
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::InsertModifiedFieldInArray(DWORD dwPropID, DWORD dwPropValue)
{
    int     index;
    bool    fFound = false;
    
    if (m_pModifiedPropIDs[0])
    {
        //
        // Search if this property ID pre-exists in the array
        //
        
        for(index = 0; index < m_cModifiedProperties; index++)
        {
            if (dwPropID == m_pModifiedPropIDs[0][index])
            {
                fFound = true;   
                break;
            }   
        }

        if (fFound)
        {
            m_pModifiedPropIDs[1][index] = dwPropValue;
        }
        else
        {
            m_pModifiedPropIDs[0][m_cModifiedProperties] = dwPropID;
            m_pModifiedPropIDs[1][m_cModifiedProperties]= dwPropValue;
            m_cModifiedProperties++;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////

bool CLogAdvanced::GetModifiedFieldFromArray(DWORD dwPropID, DWORD * pdwPropValue)
{
    int     index;
    bool    fFound = false;
    
    if (m_pModifiedPropIDs[0])
    {
        //
        // Search if this property ID pre-exists in the array
        //
        
        for(index = 0; index < m_cModifiedProperties; index++)
        {
            if (dwPropID == m_pModifiedPropIDs[0][index])
            {
                fFound = true;   
                break;
            }   
        }

        if (fFound)
        {
            *pdwPropValue = m_pModifiedPropIDs[1][index];
        }
    }

    return fFound;
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::OnDestroy() 
{
	CPropertyPage::OnDestroy();
    //
    // Delete all the CONFIG_INFORMATION structures
    //
    CImageList * pImage = m_wndTreeCtrl.SetImageList(CImageList::FromHandle(NULL), TVSIL_STATE);
    if (pImage != NULL && pImage->m_hImageList != NULL)
    {
        ImageList_Destroy(pImage->m_hImageList);
    }
    DeleteSubTreeConfig(m_wndTreeCtrl.GetRootItem());

    delete [] m_pModifiedPropIDs[0];
    delete [] m_pModifiedPropIDs[1];
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\logadvpg.h ===
#if !defined _LOGADVCPG_H
#define _LOGADVCPG_H

#if _MSC_VER >= 1000
#pragma once
#endif

/////////////////////////////////////////////////////////////////////////////
// CLogAdvanced dialog

class CLogAdvanced : public CPropertyPage
{
	DECLARE_DYNCREATE(CLogAdvanced)
public:
	CLogAdvanced();
	typedef struct _CONFIG_INFORMATION_
	{
	    DWORD   dwPropertyID;
	    DWORD   dwPropertyMask;
	    bool    fItemModified;
		int		iOrder;
	} CONFIG_INFORMATION, *PCONFIG_INFORMATION;

    CString m_szServer;
    CString m_szMeta;
    CString m_szUserName;
    CStrPassword m_szPassword;
    CString m_szServiceName;

// Dialog Data
	//{{AFX_DATA(CLogAdvanced)
	enum { IDD = IDD_LOG_ADVANCED };
	CTreeCtrl	m_wndTreeCtrl;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CLogAdvanced)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CLogAdvanced)
	virtual BOOL OnInitDialog();
	afx_msg void OnClickTree(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKeydownTree(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:

    CImageList m_cImageList;
    bool m_fTreeModified;
    int m_cModifiedProperties;
    DWORD * m_pModifiedPropIDs[2];

    LRESULT OnThemeChanged(WPARAM wParam, LPARAM lParam);
    void HandleThemes();
    void CreateTreeFromMB();
    void CreateSubTree(CMetaKey& mk, LPCTSTR szPath, HTREEITEM hTreeRoot);
    void ProcessClick(HTREEITEM htiItemClicked);
    void ProcessProperties(bool fSave);
    void SetSubTreeProperties(CMetaKey * pmk, HTREEITEM hTreeRoot, BOOL fParentState, BOOL fInitialize);
    void SaveSubTreeProperties(CMetaKey& mk, HTREEITEM hTreeRoot);
    void InsertModifiedFieldInArray(DWORD dwPropID, DWORD dwPropValue);
    bool GetModifiedFieldFromArray(DWORD dwPropID, DWORD * pdwPropValue);
    bool IsPresentServiceSupported(LPTSTR szSupportedServices);
    void DeleteSubTreeConfig(HTREEITEM hTreeRoot);
    void DoHelp();
	std::map<int, int> m_mapLogUIString;
	std::map<int, int> m_mapLogUIOrder;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\loggenpg.h ===
// LogGenPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CLogGeneral dialog

class CLogGeneral : public CPropertyPage
{
	DECLARE_DYNCREATE(CLogGeneral)

// Construction
public:
	CLogGeneral();
	~CLogGeneral();

   int BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam);

    CComboBox * m_pComboLog;
    CString m_szServer;
    CString m_szMeta;
    CString m_szUserName;
    CStrPassword m_szPassword;

    // editing local machine
    BOOL m_fLocalMachine;
    BOOL m_fShowLocalTimeCheckBox;

    // the two-letter file prefix
    CString szPrefix;
    // the longer file size prefix
    CString szSizePrefix;

// Dialog Data
	//{{AFX_DATA(CLogGeneral)
	enum { IDD = IDD_LOG_GENERAL };
	CButton	m_wndPeriod;
	CButton	m_wndUseLocalTime;
	CButton	m_cbttn_browse;
	CEdit	m_cedit_directory;
	CEdit	m_cedit_size;
	CSpinButtonCtrl	m_cspin_spin;
	CStatic	m_cstatic_units;
	CString	m_sz_directory;
	CString	m_sz_filesample;
	BOOL	m_fUseLocalTime;
	int		m_int_period;
	//}}AFX_DATA
//    CILong  m_dword_filesize;
	DWORD	m_dword_filesize;

    int     m_orig_MD_LOGFILE_PERIOD;
    DWORD   m_orig_MD_LOGFILE_TRUNCATE_SIZE;
    CString m_orig_MD_LOGFILE_DIRECTORY;
    BOOL    m_orig_MD_LOGFILE_LOCALTIME_ROLLOVER;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CLogGeneral)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CLogGeneral)
	virtual BOOL OnInitDialog();
	afx_msg void OnBrowse();
	afx_msg void OnLogDaily();
	afx_msg void OnLogMonthly();
	afx_msg void OnLogWhensize();
	afx_msg void OnLogWeekly();
	afx_msg void OnChangeLogDirectory();
	afx_msg void OnChangeLogSize();
	afx_msg void OnLogUnlimited();
	afx_msg void OnLogHourly();
	afx_msg void OnUseLocalTime();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void DoHelp();

    // update the sample file stirng
    virtual void UpdateSampleFileString();
    HRESULT GetServiceVersion();

//    void    Init();
    void    UpdateDependants();

private:
    // initialized flag
    BOOL    m_fInitialized;
    BOOL    m_fIsModified;
    LPTSTR  m_pPathTemp;
	CString m_NetHood;
    DWORD m_dwVersionMajor, m_dwVersionMinor;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\loggenpg.cpp ===
// LogGenPg.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "logui.h"
#include "LogGenPg.h"
#include <iiscnfg.h>
#include <idlg.h>

#include <shlobj.h>
#include <shlwapi.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define     SIZE_MBYTE          1048576
#define     MAX_LOGFILE_SIZE    4000

#define MD_LOGFILE_PERIOD_UNLIMITED  MD_LOGFILE_PERIOD_HOURLY + 1

//
// Support functions to map & unmap the weird logfile ordering to the UI ordering
//

/////////////////////////////////////////////////////////////////////////////

int MapLogFileTypeToUIIndex(int iLogFileType)
{
    int iUIIndex;

    switch (iLogFileType)
    {
    case MD_LOGFILE_PERIOD_HOURLY:      iUIIndex = 0; break;
    case MD_LOGFILE_PERIOD_DAILY:       iUIIndex = 1; break;
    case MD_LOGFILE_PERIOD_WEEKLY:      iUIIndex = 2; break;
    case MD_LOGFILE_PERIOD_MONTHLY:     iUIIndex = 3; break;
    case MD_LOGFILE_PERIOD_UNLIMITED:   iUIIndex = 4; break;
    case MD_LOGFILE_PERIOD_NONE:        iUIIndex = 5; break;
    }
    return iUIIndex;
}

/////////////////////////////////////////////////////////////////////////////

int MapUIIndexToLogFileType(int iUIIndex)
{
    int iLogFileType;

    switch (iUIIndex)
    {
    case 0: iLogFileType = MD_LOGFILE_PERIOD_HOURLY; break;
    case 1: iLogFileType = MD_LOGFILE_PERIOD_DAILY; break;
    case 2: iLogFileType = MD_LOGFILE_PERIOD_WEEKLY; break;
    case 3: iLogFileType = MD_LOGFILE_PERIOD_MONTHLY; break;
    case 4: iLogFileType = MD_LOGFILE_PERIOD_UNLIMITED; break;
    case 5: iLogFileType = MD_LOGFILE_PERIOD_NONE; break;
    }
    return iLogFileType;
}


/////////////////////////////////////////////////////////////////////////////
// CLogGeneral property page

IMPLEMENT_DYNCREATE(CLogGeneral, CPropertyPage)

//--------------------------------------------------------------------------
CLogGeneral::CLogGeneral() : CPropertyPage(CLogGeneral::IDD),
    m_fInitialized( FALSE ),
    m_pComboLog( NULL ),
    m_fLocalMachine( FALSE )
{
    //{{AFX_DATA_INIT(CLogGeneral)
    m_sz_directory = _T("");
    m_sz_filesample = _T("");
    m_fShowLocalTimeCheckBox = FALSE;
    m_int_period = -1;
    //}}AFX_DATA_INIT

    m_dwVersionMajor = 5;
    m_dwVersionMinor = 1;
    m_fIsModified = FALSE;
}

//--------------------------------------------------------------------------
CLogGeneral::~CLogGeneral()
{
}

//--------------------------------------------------------------------------
void CLogGeneral::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CLogGeneral)
    DDX_Control(pDX, IDC_LOG_HOURLY, m_wndPeriod);
    DDX_Control(pDX, IDC_USE_LOCAL_TIME, m_wndUseLocalTime);
    DDX_Control(pDX, IDC_LOG_BROWSE, m_cbttn_browse);
    DDX_Control(pDX, IDC_LOG_DIRECTORY, m_cedit_directory);
    DDX_Control(pDX, IDC_LOG_SIZE, m_cedit_size);
    DDX_Control(pDX, IDC_SPIN, m_cspin_spin);
    DDX_Control(pDX, IDC_LOG_SIZE_UNITS, m_cstatic_units);
    DDX_Text(pDX, IDC_LOG_FILE_SAMPLE, m_sz_filesample);
    DDX_Check(pDX, IDC_USE_LOCAL_TIME, m_fUseLocalTime);
    // DDX_Radio(pDX, IDC_LOG_HOURLY, m_int_period);
    //}}AFX_DATA_MAP

    DDX_Text(pDX, IDC_LOG_DIRECTORY, m_sz_directory);
    if (pDX->m_bSaveAndValidate)
    {
		if (PathIsUNCServerShare(m_sz_directory))
		{
			DDV_UNCFolderPath(pDX, m_sz_directory, m_fLocalMachine);
		}
		else
		{
			DDV_FolderPath(pDX, m_sz_directory, m_fLocalMachine);
		}
	}
    if (pDX->m_bSaveAndValidate)
    {
        DDX_Radio(pDX, IDC_LOG_HOURLY, m_int_period);
        m_int_period = MapUIIndexToLogFileType(m_int_period);
		if (m_int_period == MD_LOGFILE_PERIOD_NONE)
		{
            // this needs to come before DDX_TextBalloon
			DDV_MinMaxBalloon(pDX, IDC_LOG_SIZE, 0, MAX_LOGFILE_SIZE);
			DDX_Text(pDX, IDC_LOG_SIZE, m_dword_filesize);
		}
    }
    else
    {
        int iUIIndex = MapLogFileTypeToUIIndex(m_int_period);
        DDX_Radio(pDX, IDC_LOG_HOURLY, iUIIndex);
    }
}


BEGIN_MESSAGE_MAP(CLogGeneral, CPropertyPage)
    //{{AFX_MSG_MAP(CLogGeneral)
    ON_BN_CLICKED(IDC_LOG_BROWSE, OnBrowse)
    ON_BN_CLICKED(IDC_LOG_DAILY, OnLogDaily)
    ON_BN_CLICKED(IDC_LOG_MONTHLY, OnLogMonthly)
    ON_BN_CLICKED(IDC_LOG_WHENSIZE, OnLogWhensize)
    ON_BN_CLICKED(IDC_LOG_WEEKLY, OnLogWeekly)
    ON_EN_CHANGE(IDC_LOG_DIRECTORY, OnChangeLogDirectory)
    ON_EN_CHANGE(IDC_LOG_SIZE, OnChangeLogSize)
    ON_BN_CLICKED(IDC_LOG_UNLIMITED, OnLogUnlimited)
    ON_BN_CLICKED(IDC_LOG_HOURLY, OnLogHourly)
    ON_BN_CLICKED(IDC_USE_LOCAL_TIME, OnUseLocalTime)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CLogGeneral::DoHelp()
{
	DebugTraceHelp(HIDD_LOGUI_GENERIC);
    WinHelp( HIDD_LOGUI_GENERIC );
}

HRESULT
CLogGeneral::GetServiceVersion()
{
    CError err;
    CString info_path;
    if (NULL != CMetabasePath::GetServiceInfoPath(m_szMeta, info_path))
    {
        CString csTempPassword;
        m_szPassword.CopyTo(csTempPassword);
        CComAuthInfo auth(m_szServer, m_szUserName, csTempPassword);
        CMetaKey mk(&auth, info_path, METADATA_PERMISSION_READ);
        err = mk.QueryResult();
        if (err.Succeeded())
        {
            err = mk.QueryValue(MD_SERVER_VERSION_MAJOR, m_dwVersionMajor);
            if (err.Succeeded())
            {
                err = mk.QueryValue(MD_SERVER_VERSION_MINOR, m_dwVersionMinor);
            }
        }
    }
    else
    {
        err = E_FAIL;
    }
    return err;
}

//--------------------------------------------------------------------------
void CLogGeneral::UpdateDependants() 
{
    BOOL fEnable = (m_int_period == MD_LOGFILE_PERIOD_MAXSIZE);
    m_cspin_spin.EnableWindow(fEnable);
    m_cstatic_units.EnableWindow(fEnable);
    m_cedit_size.EnableWindow(fEnable);
}
    
//--------------------------------------------------------------------------
// update the sample file stirng
void CLogGeneral::UpdateSampleFileString()
    {
    CString szSample;

    // ok first we have to generate a string to show what sub-node the logging stuff
    // is going to go into. This would be of the general form of the name of the server
    // followed by the virtual node of the server. Example: LM/W3SVC/1 would
    // become "W3SVC1/example" Unfortunately, all we have to build this thing out of
    // is the target metabase path. So we strip off the preceding LM/. Then we find the
    // next / character and take the number that follows it. If we are editing the 
    // master root properties then there will be no slash/number at the end at which point
    // we can just append a capital X character to signifiy this. The MMC is currently set
    // up to only show the logging properties if we are editing the master props or a virtual
    // server, so we shouldn't have to worry about stuff after the virtual server number

    // get rid of the preceding LM/ (Always three characters)
    m_sz_filesample = m_szMeta.Right( m_szMeta.GetLength() - 3 );

    // Find the location of the '/' character
    INT     iSlash = m_sz_filesample.Find( _T('/') );

    // if there was no last slash, then append the X, otherwise append the number
    if ( iSlash < 0 )
        {
        m_sz_filesample += _T('X');
        }
    else
        {
        m_sz_filesample = m_sz_filesample.Left(iSlash) +
                    m_sz_filesample.Right( m_sz_filesample.GetLength() - (iSlash+1) );
        }

    // add a final path type slash to signify that it is a partial path
    m_sz_filesample += _T('\\');

    // build the sample string
    switch( m_int_period )
        {
        case MD_LOGFILE_PERIOD_MAXSIZE:
            m_sz_filesample += szSizePrefix;
            szSample.LoadString( IDS_LOG_SIZE_FILESAMPLE );
            break;
        case MD_LOGFILE_PERIOD_DAILY:
            m_sz_filesample += szPrefix;
            szSample.LoadString( IDS_LOG_DAILY_FILESAMPLE );
            break;
        case MD_LOGFILE_PERIOD_WEEKLY:
            m_sz_filesample += szPrefix;
            szSample.LoadString( IDS_LOG_WEEKLY_FILESAMPLE );
            break;
        case MD_LOGFILE_PERIOD_MONTHLY:
            m_sz_filesample += szPrefix;
            szSample.LoadString( IDS_LOG_MONTHLY_FILESAMPLE );
            break;
        case MD_LOGFILE_PERIOD_HOURLY:
            m_sz_filesample += szPrefix;
            szSample.LoadString( IDS_LOG_HOURLY_FILE_SAMPLE );
            break;
        case MD_LOGFILE_PERIOD_UNLIMITED:
            m_sz_filesample += szSizePrefix;
            szSample.LoadString( IDS_LOG_UNLIMITED_FILESAMPLE );
            break;
        };

    // add the two together
    m_sz_filesample += szSample;

    // update the display
    ::SetWindowText(CONTROL_HWND(IDC_LOG_FILE_SAMPLE), m_sz_filesample);
    // Don't do this it will reset the logfile directory 
    //UpdateData( FALSE );
    }

/////////////////////////////////////////////////////////////////////////////
// CLogGeneral message handlers

//--------------------------------------------------------------------------
BOOL CLogGeneral::OnInitDialog() 
{
    BOOL bRes = CPropertyPage::OnInitDialog();

    CError err = GetServiceVersion();
    if (err.Succeeded())
    {
        CString csTempPassword;
        m_szPassword.CopyTo(csTempPassword);
        CComAuthInfo auth(m_szServer, m_szUserName, csTempPassword);
        CMetaKey mk(&auth, m_szMeta, METADATA_PERMISSION_READ);
	    do
	    {
		    err = mk.QueryResult();
		    BREAK_ON_ERR_FAILURE(err);

		    err = mk.QueryValue(MD_LOGFILE_PERIOD, m_int_period);
		    BREAK_ON_ERR_FAILURE(err);

		    err = mk.QueryValue(MD_LOGFILE_TRUNCATE_SIZE, m_dword_filesize);
		    BREAK_ON_ERR_FAILURE(err);

		    m_dword_filesize /= SIZE_MBYTE;
		    if ( (m_dword_filesize > MAX_LOGFILE_SIZE) && (m_int_period == MD_LOGFILE_PERIOD_NONE) )
		    {
			    m_int_period = MD_LOGFILE_PERIOD_UNLIMITED;
			    m_dword_filesize = 512;
		    }
		    err = mk.QueryValue(MD_LOGFILE_DIRECTORY, m_sz_directory);
		    BREAK_ON_ERR_FAILURE(err);

		    if (m_fShowLocalTimeCheckBox)
		    {
			    m_wndUseLocalTime.ShowWindow(SW_SHOW);
			    if ((MD_LOGFILE_PERIOD_NONE == m_int_period) || (MD_LOGFILE_PERIOD_UNLIMITED == m_int_period))
			    {
				    m_wndUseLocalTime.EnableWindow(FALSE);
			    }
			    err = mk.QueryValue(MD_LOGFILE_LOCALTIME_ROLLOVER, m_fUseLocalTime);
			    if (err.Failed())
			    {
				    err.Reset();
			    }
		    }

            // Set original values...
            m_orig_MD_LOGFILE_PERIOD = m_int_period;
            m_orig_MD_LOGFILE_TRUNCATE_SIZE = m_dword_filesize;
            m_orig_MD_LOGFILE_DIRECTORY = m_sz_directory;
            m_orig_MD_LOGFILE_LOCALTIME_ROLLOVER = m_fUseLocalTime;

		    UpdateData( FALSE );
		    UpdateDependants();
		    UpdateSampleFileString();
		    m_cbttn_browse.EnableWindow(m_fLocalMachine);
			m_cspin_spin.SetRange32(0, MAX_LOGFILE_SIZE);
			m_cspin_spin.SetPos(m_dword_filesize);
	    } while (FALSE);
    }

#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
    LimitInputPath(CONTROL_HWND(IDC_LOG_DIRECTORY),TRUE);
#else
    LimitInputPath(CONTROL_HWND(IDC_LOG_DIRECTORY),FALSE);
#endif
    

#if defined(_DEBUG) || DBG
	err.MessageBoxOnFailure();
#endif
    SetModified(FALSE);

    return bRes;
}

//--------------------------------------------------------------------------
BOOL CLogGeneral::OnApply() 
{
    if (m_fIsModified)
    {
		UpdateData();
		if (!PathIsValid(m_sz_directory,FALSE))
		{
			AfxMessageBox(IDS_NEED_DIRECTORY);
			return FALSE;
		}
        if (m_fLocalMachine)
        {
		    CString expanded;
		    ExpandEnvironmentStrings(m_sz_directory, expanded.GetBuffer(MAX_PATH), MAX_PATH);
			expanded.ReleaseBuffer();
		    if (PathIsNetworkPath(expanded))
		    {
                if (m_dwVersionMajor < 6)
                {
			        AfxMessageBox(IDS_REMOTE_NOT_SUPPORTED);
			        return FALSE;
                }
                goto Verified;
		    }
		    if (PathIsRelative(expanded))
		    {
			    AfxMessageBox(IDS_NO_RELATIVE_PATH);
			    return FALSE;
		    }
		    if (!PathIsDirectory(expanded))
		    {
			    AfxMessageBox(IDS_NOT_DIR_EXIST);
			    return FALSE;
		    }
        }
Verified:
        CString csTempPassword;
        m_szPassword.CopyTo(csTempPassword);
		CComAuthInfo auth(m_szServer, m_szUserName, csTempPassword);
		CError err;
		CList<DWORD, DWORD> mdlist;
        int iNewValuePeriod = 0;
        DWORD dwNewValueTruncateSize = 0;
        BOOL fNewValueUseLocalTime = FALSE;
        BOOL fSomethingChanged = FALSE;
		do
		{
			CMetaKey mk(&auth, m_szMeta, METADATA_PERMISSION_WRITE);
			err = mk.QueryResult();
			BREAK_ON_ERR_FAILURE(err);

            // warning:
            // these values are all tied together:
            //   MD_LOGFILE_PERIOD
            //   MD_LOGFILE_TRUNCATE_SIZE
            //   MD_LOGFILE_LOCALTIME_ROLLOVER
            //
            // if anyone of these values change
            // then it affects the other one.
            // if you change anyone of of these,
            // then you must force the inheritance dlg
            // to prompt for all of them.
            // you can get into a funky state if not.
            iNewValuePeriod = (m_int_period == MD_LOGFILE_PERIOD_UNLIMITED ? MD_LOGFILE_PERIOD_NONE : m_int_period);
            dwNewValueTruncateSize = (m_int_period == MD_LOGFILE_PERIOD_UNLIMITED ? 0xFFFFFFFF : m_dword_filesize * SIZE_MBYTE);
            fNewValueUseLocalTime = m_fUseLocalTime;

            if (iNewValuePeriod != m_orig_MD_LOGFILE_PERIOD)
            {
                fSomethingChanged = TRUE;
            }
            if (dwNewValueTruncateSize != m_orig_MD_LOGFILE_TRUNCATE_SIZE)
            {
                fSomethingChanged = TRUE;
            }
            if (m_fShowLocalTimeCheckBox)
            {
                if (fNewValueUseLocalTime != m_orig_MD_LOGFILE_LOCALTIME_ROLLOVER)
                {
                    fSomethingChanged = TRUE;
                }
            }
            
            if (fSomethingChanged)
            {
			    err = mk.SetValue(MD_LOGFILE_PERIOD, iNewValuePeriod);
			    BREAK_ON_ERR_FAILURE(err);
			    mdlist.AddTail(MD_LOGFILE_PERIOD);
                m_orig_MD_LOGFILE_PERIOD = iNewValuePeriod; // Set original value...

			    err = mk.SetValue(MD_LOGFILE_TRUNCATE_SIZE, dwNewValueTruncateSize);
			    BREAK_ON_ERR_FAILURE(err);
			    mdlist.AddTail(MD_LOGFILE_TRUNCATE_SIZE);
                m_orig_MD_LOGFILE_TRUNCATE_SIZE = dwNewValueTruncateSize; // Set original value...

				err = mk.SetValue(MD_LOGFILE_LOCALTIME_ROLLOVER, fNewValueUseLocalTime);
				BREAK_ON_ERR_FAILURE(err);
				mdlist.AddTail(MD_LOGFILE_LOCALTIME_ROLLOVER);
                m_orig_MD_LOGFILE_LOCALTIME_ROLLOVER = fNewValueUseLocalTime; // Set original value...
			}

            if (0 != m_sz_directory.Compare(m_orig_MD_LOGFILE_DIRECTORY))
            {
			    err = mk.SetValue(MD_LOGFILE_DIRECTORY, m_sz_directory);
			    BREAK_ON_ERR_FAILURE(err);
			    mdlist.AddTail(MD_LOGFILE_DIRECTORY);
                m_orig_MD_LOGFILE_DIRECTORY = m_sz_directory; // Set original value...
            }

		} while(FALSE);


		// Check inheritance
		if (!mdlist.IsEmpty())
		{
			POSITION pos = mdlist.GetHeadPosition();
			while (pos)
			{
				DWORD id = mdlist.GetNext(pos);
				{
					CInheritanceDlg dlg(id, TRUE, &auth, m_szMeta);
					if (!dlg.IsEmpty())
					{
						dlg.DoModal();
					}
				}
			}
		}
	}
    return CPropertyPage::OnApply();
}

//--------------------------------------------------------------------------

static int CALLBACK 
FileChooserCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
   CLogGeneral * pThis = (CLogGeneral *)lpData;
   ASSERT(pThis != NULL);
   return pThis->BrowseForFolderCallback(hwnd, uMsg, lParam);
}

int 
CLogGeneral::BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam)
{
   BOOL bNetwork;
   switch (uMsg)
   {
   case BFFM_INITIALIZED:
      ASSERT(m_pPathTemp != NULL);
      bNetwork = ::PathIsNetworkPath(m_pPathTemp);
      if (m_dwVersionMajor >= 6 && bNetwork)
         return 0;
      if (m_fLocalMachine && !bNetwork)
      {
          while (!::PathIsDirectory(m_pPathTemp))
          {
             if (0 == ::PathRemoveFileSpec(m_pPathTemp) && !::PathIsRoot(m_pPathTemp))
             {
                return 0;
             }
             DWORD attr = GetFileAttributes(m_pPathTemp);
             if ((attr & FILE_ATTRIBUTE_READONLY) == 0)
                break;
          }
          ::SendMessage(hwnd, BFFM_SETSELECTION, TRUE, (LPARAM)m_pPathTemp);
      }
      break;
   case BFFM_SELCHANGED:
   {
      LPITEMIDLIST pidl = (LPITEMIDLIST)lParam;
      TCHAR path[MAX_PATH];
      if (SHGetPathFromIDList(pidl, path))
      {
         BOOL bEnable = TRUE;
	     if (m_dwVersionMajor >= 6)
		 {
		    TCHAR prefix[MAX_PATH];
            if (PathCommonPrefix(m_NetHood, path, prefix) > 0)
            {
                if (m_NetHood.CompareNoCase(prefix) == 0)
                {
                    bEnable = FALSE;
                }
            }
		 }
         else
         {
            bEnable =  !PathIsNetworkPath(path);
         }
	    ::SendMessage(hwnd, BFFM_ENABLEOK, 0, bEnable);
      }
	  else
	  {
         ::SendMessage(hwnd, BFFM_ENABLEOK, 0, FALSE);
	  }
   }
      break;
   case BFFM_VALIDATEFAILED:
      break;
   }
   return 0;
}


void CLogGeneral::OnBrowse()
{
   BOOL bRes = FALSE;
   HRESULT hr;
   CString str;
   m_cedit_directory.GetWindowText(str);

   if (SUCCEEDED(hr = CoInitialize(NULL)))
   {
      LPITEMIDLIST  pidl = NULL;
      int csidl = m_dwVersionMajor >= 6 ? CSIDL_DESKTOP : CSIDL_DRIVES;
      if (SUCCEEDED(SHGetFolderLocation(NULL, csidl, NULL, 0, &pidl)))
      {
         LPITEMIDLIST pidList = NULL;
         BROWSEINFO bi;
         TCHAR buf[MAX_PATH];
         ZeroMemory(&bi, sizeof(bi));
         int drive = PathGetDriveNumber(str);
         if (GetDriveType(PathBuildRoot(buf, drive)) == DRIVE_FIXED)
         {
            StrCpy(buf, str);
         }
         else
         {
             buf[0] = 0;
         }
         
         bi.hwndOwner = m_hWnd;
         bi.pidlRoot = pidl;
         bi.pszDisplayName = m_pPathTemp = buf;
         bi.lpszTitle = NULL;
         bi.ulFlags |= BIF_NEWDIALOGSTYLE;
         if (m_dwVersionMajor < 6)
         {
            bi.ulFlags |= BIF_RETURNONLYFSDIRS;
         }
         else
         {
             bi.ulFlags |= BIF_RETURNONLYFSDIRS;
             // this doesn't seem to work with BIF_RETURNONLYFSDIRS
             //bi.ulFlags |= BIF_SHAREABLE;
         }
         bi.lpfn = FileChooserCallback;
         bi.lParam = (LPARAM)this;

		 // Get NetHood folder location
		 SHGetFolderPath(NULL, CSIDL_NETHOOD, NULL, SHGFP_TYPE_CURRENT, m_NetHood.GetBuffer(MAX_PATH));
		 m_NetHood.ReleaseBuffer();

         pidList = SHBrowseForFolder(&bi);
         if (pidList != NULL && SHGetPathFromIDList(pidList, buf))
         {
            str = buf;
            bRes = TRUE;
         }
         IMalloc * pMalloc;
         VERIFY(SUCCEEDED(SHGetMalloc(&pMalloc)));
         if (pidl != NULL)
            pMalloc->Free(pidl);
         pMalloc->Release();
      }
      CoUninitialize();
   }

   if (bRes)
   {
       m_cedit_directory.SetWindowText(str);
   }
}

//--------------------------------------------------------------------------
void CLogGeneral::OnLogDaily() 
{
    m_wndUseLocalTime.EnableWindow(TRUE);
	m_int_period = MD_LOGFILE_PERIOD_DAILY;
    UpdateDependants();
    UpdateSampleFileString();
    SetModified();
    m_fIsModified = TRUE;
}

//--------------------------------------------------------------------------
void CLogGeneral::OnLogMonthly() 
{
    m_wndUseLocalTime.EnableWindow(TRUE);
	m_int_period = MD_LOGFILE_PERIOD_MONTHLY;
    UpdateDependants();
    UpdateSampleFileString();
    SetModified();
    m_fIsModified = TRUE;
}

//--------------------------------------------------------------------------
void CLogGeneral::OnLogWhensize() 
{
    m_wndUseLocalTime.EnableWindow(FALSE);
	m_int_period = MD_LOGFILE_PERIOD_MAXSIZE;
    UpdateDependants();
    UpdateSampleFileString();
    SetModified();
    m_fIsModified = TRUE;
}

//--------------------------------------------------------------------------
void CLogGeneral::OnLogUnlimited() 
{
    m_wndUseLocalTime.EnableWindow(FALSE);
	m_int_period = MD_LOGFILE_PERIOD_UNLIMITED;
    UpdateDependants();
    UpdateSampleFileString();
    SetModified();
    m_fIsModified = TRUE;
}

//--------------------------------------------------------------------------
void CLogGeneral::OnLogWeekly() 
{
    m_wndUseLocalTime.EnableWindow(TRUE);
	m_int_period = MD_LOGFILE_PERIOD_WEEKLY;
    UpdateDependants();
    UpdateSampleFileString();
    SetModified();
    m_fIsModified = TRUE;
}

//--------------------------------------------------------------------------
void CLogGeneral::OnLogHourly() 
{
    m_wndUseLocalTime.EnableWindow(TRUE);
	m_int_period = MD_LOGFILE_PERIOD_HOURLY;
    UpdateDependants();
    UpdateSampleFileString();
    SetModified();
    m_fIsModified = TRUE;
}

//--------------------------------------------------------------------------
void CLogGeneral::OnChangeLogDirectory() 
{
    SetModified();
    m_fIsModified = TRUE;
}

//--------------------------------------------------------------------------
void CLogGeneral::OnChangeLogSize() 
{
    SetModified();
    m_fIsModified = TRUE;
}

//--------------------------------------------------------------------------
void CLogGeneral::OnUseLocalTime() 
{
    SetModified();
    m_fIsModified = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\logtools.h ===
BOOL FSetObjectApartmentModel( REFCLSID clsid );
BOOL FIsLocalMachine( LPCTSTR psz );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\logtools.cpp ===
// common tools used by the various logging uis

#include "stdafx.h"
#include "logui.h"
#include "logtools.h"





//---------------------------------------------------------------
// Given the class ID of a server, it goes into the registry and
// sets the Apartment Model flag for that object.
// The strings used here are non-localized. They are also specific
// to this routine.
BOOL FSetObjectApartmentModel( REFCLSID clsid )
{
    LPOLESTR    pszwSid;
    LONG        err;
    HKEY        hKey;

    // transform the clsid into a string
    StringFromCLSID(
        clsid, //CLSID to be converted 
        &pszwSid //Address of output variable that receives a pointer to the resulting string 
        );

    // put it in a cstring
    CString szSid = pszwSid;

    // free the ole string
    CoTaskMemFree( pszwSid );

    // build the registry path
    CString szRegPath = _T("CLSID\\");
    szRegPath += szSid;
    szRegPath += _T("\\InProcServer32");

    // prep the apartment name
    CString szApartment = _T("Apartment");

    // open the registry key
    err = RegOpenKey(
            HKEY_CLASSES_ROOT,  // handle of open key  
            (LPCTSTR)szRegPath, // address of name of subkey to open  
            &hKey               // address of handle of open key  
            );
    if ( err != ERROR_SUCCESS )
        return FALSE;

    // set the apartment threading value
    err = RegSetValueEx(
            hKey, // handle of key to set value for  
            _T("ThreadingModel"), // address of value to set  
            0, // reserved  
            REG_SZ, // flag for value type  
            (PBYTE)(LPCTSTR)szApartment, // address of value data  
            (szApartment.GetLength() + 1) * sizeof(TCHAR)  // size of value data  
            ); 

    // close the registry key
	// in success or failure.
    RegCloseKey( hKey );

    if ( err != ERROR_SUCCESS )
	{
        return FALSE;
	}

    return TRUE;
}




//---------------------------------------------------------------
// tests a machine name to see if it is the local machine it is
// talking about
BOOL FIsLocalMachine( LPCTSTR psz )
	{
    CString szLocal;
    DWORD   cch = MAX_COMPUTERNAME_LENGTH + 1;
    BOOL    fAnswer;

    // get the actual name of the local machine
    fAnswer = GetComputerName(szLocal.GetBuffer(cch), &cch);
    szLocal.ReleaseBuffer();
    if ( !fAnswer )
        return FALSE;

    // compare and return
    fAnswer = (szLocal.CompareNoCase( psz ) == 0);
    return fAnswer;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\logodbc.h ===
// LogODBC.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CLogODBC dialog

class CLogODBC : public CPropertyPage
{
	DECLARE_DYNCREATE(CLogODBC)

// Construction
public:
	CLogODBC();
	~CLogODBC();

    // metabase target
    CString m_szServer;
    CString m_szMeta;
	CString m_szUserName;
	CStrPassword m_szPassword;

// Dialog Data
	//{{AFX_DATA(CLogODBC)
	enum { IDD = IDD_LOG_ODBC };
	CEdit	m_cedit_password;
	CString	m_sz_datasource;
	CStrPassword m_sz_password;
	CString	m_sz_table;
	CString	m_sz_username;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CLogODBC)
	public:
	virtual BOOL OnApply();
//	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CLogODBC)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeOdbcDatasource();
	afx_msg void OnChangeOdbcPassword();
	afx_msg void OnChangeOdbcTable();
	afx_msg void OnChangeOdbcUsername();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void DoHelp();

//    void Init();

    // initialized flag
    BOOL    m_fInitialized;

    CString m_szOrigPass;
    BOOL    m_bPassTyped;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\logodbc.cpp ===
// LogODBC.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "logui.h"
#include "LogODBC.h"
#include "CnfrmPsD.h"
#include <iiscnfg.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLogODBC property page

IMPLEMENT_DYNCREATE(CLogODBC, CPropertyPage)

//--------------------------------------------------------------------------
CLogODBC::CLogODBC() 
	: CPropertyPage(CLogODBC::IDD),
    m_fInitialized( FALSE )
{
    //{{AFX_DATA_INIT(CLogODBC)
    m_sz_datasource = _T("");
    m_sz_password = _T("");
    m_sz_table = _T("");
    m_sz_username = _T("");
    //}}AFX_DATA_INIT

    m_szOrigPass.Empty();
    m_bPassTyped = FALSE;
}

//--------------------------------------------------------------------------
CLogODBC::~CLogODBC()
{
}

//--------------------------------------------------------------------------
void CLogODBC::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CLogODBC)
	DDX_Control(pDX, IDC_ODBC_PASSWORD, m_cedit_password);
    DDX_Text(pDX, IDC_ODBC_DATASOURCE, m_sz_datasource);
    DDX_Text_SecuredString(pDX, IDC_ODBC_PASSWORD, m_sz_password);
    DDX_Text(pDX, IDC_ODBC_TABLE, m_sz_table);
    DDX_Text(pDX, IDC_ODBC_USERNAME, m_sz_username);
	//}}AFX_DATA_MAP
}

//--------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CLogODBC, CPropertyPage)
    //{{AFX_MSG_MAP(CLogODBC)
    ON_EN_CHANGE(IDC_ODBC_DATASOURCE, OnChangeOdbcDatasource)
    ON_EN_CHANGE(IDC_ODBC_PASSWORD, OnChangeOdbcPassword)
	ON_EN_CHANGE(IDC_ODBC_TABLE, OnChangeOdbcTable)
	ON_EN_CHANGE(IDC_ODBC_USERNAME, OnChangeOdbcUsername)
	//}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CLogODBC::DoHelp()
{
	DebugTraceHelp(HIDD_LOGUI_ODBC);
    WinHelp( HIDD_LOGUI_ODBC );
}

//--------------------------------------------------------------------------
BOOL 
CLogODBC::OnInitDialog()
{
	BOOL bRes = CPropertyPage::OnInitDialog();
	CError err;
    CString csTempPassword;
    m_szPassword.CopyTo(csTempPassword);
	CComAuthInfo auth(m_szServer, m_szUserName, csTempPassword);	
	CMetaKey mk(&auth, m_szMeta, METADATA_PERMISSION_READ);
	do
	{
		err = mk.QueryResult();
		BREAK_ON_ERR_FAILURE(err);
		err = mk.QueryValue(MD_LOGSQL_DATA_SOURCES, m_sz_datasource);
		BREAK_ON_ERR_FAILURE(err);
        CString csTempPassword;
        m_sz_password.CopyTo(csTempPassword);
		err = mk.QueryValue(MD_LOGSQL_PASSWORD, csTempPassword);
        m_sz_password = csTempPassword;
		BREAK_ON_ERR_FAILURE(err);
		err = mk.QueryValue(MD_LOGSQL_TABLE_NAME, m_sz_table);
		BREAK_ON_ERR_FAILURE(err);
		err = mk.QueryValue(MD_LOGSQL_USER_NAME, m_sz_username);
		BREAK_ON_ERR_FAILURE(err);
		UpdateData(FALSE);
	} while (FALSE);
	
	return bRes;
}

/////////////////////////////////////////////////////////////////////////////
// CLogODBC message handlers


//--------------------------------------------------------------------------
BOOL CLogODBC::OnApply() 
{
    BOOL    f;
    UpdateData( TRUE );

    // confirm the password
    if ( m_bPassTyped )
    {
        CConfirmPassDlg dlgPass;
        m_sz_password.CopyTo(dlgPass.m_szOrigPass);
        if ( dlgPass.DoModal() != IDOK )
        {
            m_cedit_password.SetFocus();
            m_cedit_password.SetSel(0, -1);
            return FALSE;
        }
    }

	CError err;
    CString csTempPassword;
    m_szPassword.CopyTo(csTempPassword);
	CComAuthInfo auth(m_szServer, m_szUserName, csTempPassword);	
	CMetaKey mk(&auth, m_szMeta, METADATA_PERMISSION_WRITE);
	// TODO add inheritace override dialog support
	do
	{
		err = mk.QueryResult();
		BREAK_ON_ERR_FAILURE(err);
		err = mk.SetValue(MD_LOGSQL_DATA_SOURCES, m_sz_datasource);
		BREAK_ON_ERR_FAILURE(err);
		if (m_bPassTyped)
		{
            CString csTempPassword;
            m_sz_password.CopyTo(csTempPassword);
			err = mk.SetValue(MD_LOGSQL_PASSWORD, csTempPassword);
			BREAK_ON_ERR_FAILURE(err);
		}
		err = mk.SetValue(MD_LOGSQL_TABLE_NAME, m_sz_table);
		BREAK_ON_ERR_FAILURE(err);
		err = mk.SetValue(MD_LOGSQL_USER_NAME, m_sz_username);
		BREAK_ON_ERR_FAILURE(err);
		SetModified(FALSE);
	} while (FALSE);

    m_sz_password.CopyTo(m_szOrigPass);
    m_bPassTyped = FALSE;
    
    return CPropertyPage::OnApply();
}

void CLogODBC::OnChangeOdbcDatasource() 
{
    SetModified();
}

void CLogODBC::OnChangeOdbcPassword() 
{
    m_bPassTyped = TRUE;
    SetModified();
}

void CLogODBC::OnChangeOdbcTable() 
{
    SetModified();
}

void CLogODBC::OnChangeOdbcUsername() 
{
    SetModified();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\msftppg.cpp ===
// MsftPpg.cpp : Implementation of the CMsftPropPage property page class.

#include "stdafx.h"
#include "logui.h"
#include "MsftPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CMsftPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CMsftPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CMsftPropPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CMsftPropPage, "LOGUI.MsftPropPage.1",
	0x68871e52, 0xba87, 0x11d0, 0x92, 0x99, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b)


/////////////////////////////////////////////////////////////////////////////
// CMsftPropPage::CMsftPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CMsftPropPage

BOOL CMsftPropPage::CMsftPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_MSFT_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CMsftPropPage::CMsftPropPage - Constructor

CMsftPropPage::CMsftPropPage() :
	COlePropertyPage(IDD, IDS_MSFT_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CMsftPropPage)
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CMsftPropPage::DoDataExchange - Moves data between page and properties

void CMsftPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CMsftPropPage)
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CMsftPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\logui.h ===
// logui.h : main header file for LOGUI.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#define _COMIMPORT

#include "resource.h"       // main symbols
#include <common.h>       // common properties symbols
#include "helpmap.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CLoguiApp : See logui.cpp for implementation.

class CLoguiApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
    void PrepHelp( OLECHAR* pocMetabasePath );
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;


//    ..\wrapmb\obj\*\wrapmb.lib \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\msftppg.h ===
// MsftPpg.h : Declaration of the CMsftPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CMsftPropPage : See MsftPpg.cpp.cpp for implementation.

class CMsftPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CMsftPropPage)
	DECLARE_OLECREATE_EX(CMsftPropPage)

// Constructor
public:
	CMsftPropPage();

// Dialog Data
	//{{AFX_DATA(CMsftPropPage)
	enum { IDD = IDD_PROPPAGE_MSFT };
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CMsftPropPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\logui.cpp ===
// logui.cpp : Implementation of CLoguiApp and DLL registration.

#include "stdafx.h"
#include "logui.h"
#include <iiscnfg.h>
#include <iiscnfgp.h>
#include <inetinfo.h>

#include "initguid.h"
#include <logtype.h>
#include <ilogobj.hxx>

#include "uincsa.h"
#include "uiextnd.h"
#include "uimsft.h"
#include "uiodbc.h"

// the global factory objects
CFacNcsaLogUI       facNcsa;
CFacMsftLogUI       facMsft;
CFacOdbcLogUI       facOdbc;
CFacExtndLogUI      facExtnd;

const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;

// the key type strings for the metabaes keys
#define SZ_LOGGING_MAIN_TYPE    _T("IIsLogModules")
#define SZ_LOGGING_TYPE         _T("IIsLogModule")

static HRESULT RegisterInMetabase();
//int SetInfoAdminACL(CMetaKey& mk, LPCTSTR szSubKeyPath);

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CLoguiApp NEAR theApp;

HINSTANCE	g_hInstance = NULL;

void CLoguiApp::PrepHelp( OLECHAR* pocMetabasePath )
{
    CString szMetaPath = pocMetabasePath;
    szMetaPath.MakeLower();
    UINT iHelp = IDS_HELPLOC_W3SVCHELP;
    if ( szMetaPath.Find(_T("msftpsvc")) >= 0 )
        iHelp = IDS_HELPLOC_FTPHELP;

    CString sz;
    CString szHelpLocation;
    sz.LoadString( iHelp );

    ExpandEnvironmentStrings(sz, szHelpLocation.GetBuffer(MAX_PATH + 1), MAX_PATH);
    szHelpLocation.ReleaseBuffer();

    if ( m_pszHelpFilePath )
        free((void*)m_pszHelpFilePath);
    m_pszHelpFilePath = _tcsdup(szHelpLocation);
}


////////////////////////////////////////////////////////////////////////////
// CLoguiApp::InitInstance - DLL initialization

BOOL CLoguiApp::InitInstance()
{
    g_hInstance = m_hInstance;
    BOOL bInit = COleControlModule::InitInstance();
    InitCommonDll();
    if (bInit)
    {
        CString sz;
        sz.LoadString( IDS_LOGUI_ERR_TITLE );
        // Never free this string because now MF...kingC
        // uses it internally BEFORE call to this function
        //free((void*)m_pszAppName);
        m_pszAppName = _tcsdup(sz);

		// Get debug flag
		GetOutputDebugFlag();
    }
    return bInit;
}

////////////////////////////////////////////////////////////////////////////
// CLoguiApp::ExitInstance - DLL termination

int CLoguiApp::ExitInstance()
{
    return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);
    return RegisterInMetabase();
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);

    if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
        return ResultFromScode(SELFREG_E_CLASS);

    return NOERROR;
}

// add all the base logging info to the /LM portion of the tree Also, add in
// the ftp and w3 service logging load strings
static HRESULT
RegisterInMetabase()
{
    CString sz;
    DWORD dw;
    BOOL fService_Exist_W3SVC = FALSE;
    BOOL fService_Exist_MSFTPSVC = FALSE;
    BOOL fODBCW3 = FALSE;
    BOOL fODBCFTP = FALSE;
    CString szAvail, path;
    CError err;

    do
    {
	    // This function is getting called only during registration -- locally. 
	    // Therefore we don't need any names, passwords, etc here
	    CComAuthInfo auth;
	    CMetaKey mk(&auth, SZ_MBN_MACHINE, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
        err = mk.QueryResult();
        BREAK_ON_ERR_FAILURE(err);

        // test to see if we can do odbc logging
        err = mk.QueryValue(MD_SERVER_CAPABILITIES, dw, NULL, _T("/W3SVC/Info"));
        // This key may not even exist (since this service might not even be installed)
        if (SUCCEEDED(err))
        {
            fService_Exist_W3SVC = TRUE;
            fODBCW3 = (dw & IIS_CAP1_ODBC_LOGGING) != 0;
        }

        err = mk.QueryValue(MD_SERVER_CAPABILITIES, dw, NULL, _T("/MSFTPSVC/Info"));
        // This key may not even exist (since this service might not even be installed)
        if (SUCCEEDED(err))
        {
            fService_Exist_MSFTPSVC = TRUE;
            fODBCFTP = (dw & IIS_CAP1_ODBC_LOGGING) != 0;
        }
        
        // open the logging object
	    path = _T("logging");
	    err = mk.AddKey(path);
		if (err.Win32Error() == ERROR_ALREADY_EXISTS)
		{
			err.Reset();
		}
        BREAK_ON_ERR_FAILURE(err);
        err = mk.SetValue(MD_KEY_TYPE, CString(SZ_LOGGING_MAIN_TYPE), NULL, path);
        BREAK_ON_ERR_FAILURE(err);

#define SETUP_LOG_KEY(id,x,y)\
    VERIFY(sz.LoadString((id)));\
    sz = CMetabasePath(FALSE, path, sz);\
    err = mk.AddKey(sz);\
	if (err.Win32Error() == ERROR_ALREADY_EXISTS)\
	{\
		err.Reset();\
	}\
    BREAK_ON_ERR_FAILURE(err);\
    err = mk.SetValue(MD_KEY_TYPE, CString(SZ_LOGGING_TYPE), NULL, sz);\
    BREAK_ON_ERR_FAILURE(err);\
    err = mk.SetValue(MD_LOG_PLUGIN_MOD_ID, CString((x)), NULL, sz);\
    BREAK_ON_ERR_FAILURE(err);\
    err = mk.SetValue(MD_LOG_PLUGIN_UI_ID, CString((y)), NULL, sz);\
    BREAK_ON_ERR_FAILURE(err)\

        SETUP_LOG_KEY(IDS_MTITLE_NCSA, NCSALOG_CLSID, NCSALOGUI_CLSID);
	    SETUP_LOG_KEY(IDS_MTITLE_ODBC, ODBCLOG_CLSID, ODBCLOGUI_CLSID);
	    SETUP_LOG_KEY(IDS_MTITLE_MSFT, ASCLOG_CLSID, ASCLOGUI_CLSID);
	    SETUP_LOG_KEY(IDS_MTITLE_XTND, EXTLOG_CLSID, EXTLOGUI_CLSID);

        // prepare the available logging extensions string
        // start with w3svc
        if (fService_Exist_W3SVC)
        {
            szAvail.LoadString(IDS_MTITLE_NCSA);
            sz.LoadString(IDS_MTITLE_MSFT);
            szAvail += _T(',') + sz;
            sz.LoadString(IDS_MTITLE_XTND);
            szAvail += _T(',') + sz;
            if (fODBCW3)
            {
                sz.LoadString(IDS_MTITLE_ODBC);
                szAvail += _T(',') + sz;
            }

            // This key may not even exist (since this service might not even be installed) so don't break on err
            err = mk.SetValue(MD_LOG_PLUGINS_AVAILABLE, szAvail, NULL, _T("W3SVC/info"));
        }

        if (fService_Exist_MSFTPSVC)
        {
            // now ftp - no ncsa
            szAvail.LoadString(IDS_MTITLE_MSFT);
            sz.LoadString(IDS_MTITLE_XTND);
            szAvail += _T(',') + sz;
            if (fODBCFTP)
            {
                sz.LoadString(IDS_MTITLE_ODBC);
                szAvail += _T(',') + sz;
            }
            // This key may not even exist (since this service might not even be installed) so don't break on err
	        err = mk.SetValue(MD_LOG_PLUGINS_AVAILABLE, szAvail, NULL, _T("MSFTPSVC/info"));
        }
       
    } while(FALSE);

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\odbcppg.cpp ===
// OdbcPpg.cpp : Implementation of the COdbcPropPage property page class.

#include "stdafx.h"
#include "logui.h"
#include "OdbcPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(COdbcPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(COdbcPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(COdbcPropPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(COdbcPropPage, "LOGUI.OdbcPropPage.1",
	0x68871e4e, 0xba87, 0x11d0, 0x92, 0x99, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b)


/////////////////////////////////////////////////////////////////////////////
// COdbcPropPage::COdbcPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for COdbcPropPage

BOOL COdbcPropPage::COdbcPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_ODBC_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// COdbcPropPage::COdbcPropPage - Constructor

COdbcPropPage::COdbcPropPage() :
	COlePropertyPage(IDD, IDS_ODBC_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(COdbcPropPage)
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// COdbcPropPage::DoDataExchange - Moves data between page and properties

void COdbcPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(COdbcPropPage)
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// COdbcPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\ncsappg.h ===
// NcsaPpg.h : Declaration of the CNcsaPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CNcsaPropPage : See NcsaPpg.cpp.cpp for implementation.

class CNcsaPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CNcsaPropPage)
	DECLARE_OLECREATE_EX(CNcsaPropPage)

// Constructor
public:
	CNcsaPropPage();

// Dialog Data
	//{{AFX_DATA(CNcsaPropPage)
	enum { IDD = IDD_PROPPAGE_NCSA };
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CNcsaPropPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\ncsappg.cpp ===
// NcsaPpg.cpp : Implementation of the CNcsaPropPage property page class.

#include "stdafx.h"
#include "logui.h"
#include "NcsaPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CNcsaPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CNcsaPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CNcsaPropPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CNcsaPropPage, "LOGUI.NcsaPropPage.1",
	0x68871e46, 0xba87, 0x11d0, 0x92, 0x99, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b)


/////////////////////////////////////////////////////////////////////////////
// CNcsaPropPage::CNcsaPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CNcsaPropPage

BOOL CNcsaPropPage::CNcsaPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_NCSA_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CNcsaPropPage::CNcsaPropPage - Constructor

CNcsaPropPage::CNcsaPropPage() :
	COlePropertyPage(IDD, IDS_NCSA_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CNcsaPropPage)
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CNcsaPropPage::DoDataExchange - Moves data between page and properties

void CNcsaPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CNcsaPropPage)
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CNcsaPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\odbcppg.h ===
// OdbcPpg.h : Declaration of the COdbcPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// COdbcPropPage : See OdbcPpg.cpp.cpp for implementation.

class COdbcPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(COdbcPropPage)
	DECLARE_OLECREATE_EX(COdbcPropPage)

// Constructor
public:
	COdbcPropPage();

// Dialog Data
	//{{AFX_DATA(COdbcPropPage)
	enum { IDD = IDD_PROPPAGE_ODBC };
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(COdbcPropPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by logui.rc
//
#define IDS_NCSA                        1
#define IDB_NCSA                        1
#define IDS_NCSA_PPG                    2
#define IDB_EXTND                       2
#define IDS_EXTND                       3
#define IDB_ODBC                        3
#define IDS_EXTND_PPG                   4
#define IDB_MSFT                        4
#define IDS_ODBC                        5
#define IDS_ODBC_PPG                    6
#define IDS_MSFT                        7
#define IDS_MSFT_PPG                    8
#define IDS_NCSA_PPG_CAPTION            100
#define IDD_PROPPAGE_NCSA               100
#define IDS_EXTND_PPG_CAPTION           101
#define IDD_PROPPAGE_EXTND              101
#define IDS_ODBC_PPG_CAPTION            102
#define IDD_PROPPAGE_ODBC               102
#define IDS_MSFT_PPG_CAPTION            103
#define IDD_PROPPAGE_MSFT               103
#define IDS_LOG_SHEETTITLE              104
#define IDS_LOG_INVALID_DIR             105
#define IDS_LOG_DAILY_FILESAMPLE        106
#define IDS_LOG_WEEKLY_FILESAMPLE       107
#define IDS_LOG_MONTHLY_FILESAMPLE      108
#define IDS_LOG_NCSA_PREFIX             109
#define IDS_GENERIC_INHERITANCE_TITLE   110
#define IDS_LOG_EXTND_PREFIX            111
#define IDS_LOG_MSFT_PREFIX             112
#define IDS_LOG_SIZE_FILESAMPLE         113
#define IDS_LOG_SIZE_NCSA_PREFIX        114
#define IDS_LOG_SIZE_EXTND_PREFIX       115
#define IDS_LOG_SIZE_MSFT_PREFIX        116
#define IDS_LOG_SIZE_NCSA_PREFIX4       117
#define IDS_MTITLE_NCSA                 118
#define IDS_MTITLE_ODBC                 119
#define IDS_MTITLE_MSFT                 120
#define IDS_MTITLE_XTND                 121
#define IDS_SHEET_NCSA_TITLE            122
#define IDS_SHEET_ODBC_TITLE            123
#define IDS_SHEET_MSFT_TITLE            124
#define IDS_SHEET_EXTND_TITLE           125
#define IDS_HELPLOC_W3SVCHELP           126
#define IDS_HELPLOC_FTPHELP             127
#define IDS_NEED_DIRECTORY              128
#define IDS_LOGUI_ERR_TITLE             129
#define IDS_SHOWN_PASSWORD              130
#define IDS_PASS_CONFIRM_FAIL           131
#define IDS_LOG_UNLIMITED_FILESAMPLE    132
#define IDS_LOG_HOURLY_FILE_SAMPLE      133
#define IDS_UNC_NOT_SUPPORTED           134
#define IDS_REMOTE_NOT_SUPPORTED        134
#define IDS_DATE		                135
#define IDS_TIME                        136
#define IDS_EXTENDED                    137
#define IDS_CLIENT                      138
#define IDS_USER                        139
#define IDS_SERVICE_NAME_T              140
#define IDS_SERVER_NAME_T               141
#define IDS_SERVER_IP                   142
#define IDS_SERVER_PORT                 143
#define IDS_METHOD                      144
#define IDS_URI_STEM                    145
#define IDS_URI_QUERY                   146
#define IDS_PROTOCOL                    147
#define IDS_WIN32                       148
#define IDS_BYTES_SENT_T                149
#define IDS_BYTES_RECEIVED              150
#define IDS_TIME_TAKEN                  151
#define IDS_PROTOCOL_VER                152
#define IDS_HOST                        153
#define IDS_USER_AGENT                  154
#define IDS_COOKIE_T                    155
#define IDS_REFERER                     156
#define IDS_PROCESS_ACCT                157
#define IDS_PROCESS_EVENT               158
#define IDS_PROCESS_TYPE                159
#define IDS_TOTAL_USER_TIME             160
#define IDS_TOTAL_KERNEL_TIME           161
#define IDS_TOTAL_PAGE_FAULTS           162
#define IDS_TOTAL_PROCESSES             163
#define IDS_ACTIVE_PROCESSES            164
#define IDS_TOTAL_TERM_PROCS            165
#define IDS_NO_RELATIVE_PATH			166
#define IDS_NOT_DIR_EXIST				167
#define IDS_PROTOCOL_SUB                168
#define IDD_GEN_LOG                     201
#define IDC_RADIO1                      201
#define IDD_LOG_GENERAL                 201
#define IDC_LOG_UNLIMITED               201
#define IDC_LOG_DAILY                   202
#define IDD_LOG_EXTENDED                203
#define IDC_LOG_WEEKLY                  204
#define IDD_LOG_ODBC                    205
#define IDC_LOG_MONTHLY                 206
#define IDD_ODBC_CONFIRM_PASSWORD       207
#define IDC_LOG_HOURLY                  208
#define IDD_CONFIRM_ODBC_PASSWORD       209
#define IDD_LOG_ADVANCED                210
#define IDB_CHECKBOX                    211
#define IDC_LOG_WHENSIZE                212
#define IDC_SPIN                        213
#define IDC_CHK_DATE                    214
#define IDC_LOG_SIZE                    215
#define IDC_CHK_TIME                    216
#define IDC_LOG_DIRECTORY               217
#define IDC_CHK_CLIENTIP                218
#define IDC_LOG_BROWSE                  219
#define IDC_CHK_USERNAME                220
#define IDC_LOG_SIZE_UNITS              221
#define IDC_CHK_SERVICENAME             222
#define IDC_LOG_FILE_SAMPLE             223
#define IDC_CHK_SERVERNAME              224
#define IDC_CHK_SERVERIP                225
#define IDC_METHOD                      226
#define IDC_CHK_URISTEM                 227
#define IDC_CHK_URI_QUERY               228
#define IDC_CHK_HTTPSTATUS              229
#define IDC_CHK_WIN32STATUS             230
#define IDC_CHK_BYTESSENT               231
#define IDC_CHK_BYTESRECEIVED           232
#define IDC_CHK_TIMETAKEN               233
#define IDC_CHK_USERAGENT               234
#define IDC_CHK_COOKIE                  235
#define IDC_CHK_REFERER                 236
#define IDC_ODBC_DATASOURCE             237
#define IDC_ODBC_TABLE                  238
#define IDC_ODBC_USERNAME               239
#define IDC_ODBC_PASSWORD               240
#define IDC_CHK_SERVERPORT              241
#define IDC_CHK_VERSION                 242
#define IDC_PROP_TREE                   243
#define IDC_USE_LOCAL_TIME              244
#define IDC_ODBC_CONFIRM_PASSWORD       1032

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        245
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         245
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

//#define INITGUID

#ifndef _UNICODE
#define _UNICODE
#endif

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for OLE Controls

// Delete the two includes below if you do not wish to use the MFC
//  database classes
#ifndef _UNICODE
#include <afxdb.h>			// MFC database classes
#include <afxdao.h>			// MFC DAO database classes
#endif //_UNICODE

#include <afxcmn.h>			// MFC support for Windows Common Controls
#include <afxtempl.h>
#include <atlbase.h>

#include <aclapi.h>
#include <map>
#include "iishelp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\uiextnd.cpp ===
#include "stdafx.h"
#include <iadmw.h>
#include <inetcom.h>
#include <logtype.h>
#include <ilogobj.hxx>
#include "logui.h"
#include "uiextnd.h"
#include "LogGenPg.h"
#include "LogAdvPg.h"
#include "logtools.h"

//#include <inetprop.h>

#define OLE_NAME    _T("Extended_Logging_UI")

static const DWORD BASED_CODE _dwOleMisc = OLEMISC_INSIDEOUT | OLEMISC_CANTLINKINSIDE;
extern HINSTANCE	g_hInstance;

//====================== the required methods
//---------------------------------------------------------------
CFacExtndLogUI::CFacExtndLogUI() :
        COleObjectFactory( CLSID_EXTLOGUI, RUNTIME_CLASS(CExtndCreator), TRUE, OLE_NAME )
{
}

//---------------------------------------------------------------
static const LPCTSTR rglpszServerRegister[] = 
{
	_T("%2\\CLSID\0") _T("%1"),
	_T("%2\\NotInsertable\0") _T(""),
	_T("CLSID\\%1\0") _T("%5"),
	_T("CLSID\\%1\\Verb\\0\0") _T("&Edit,0,2"),
	_T("CLSID\\%1\\NotInsertable\0") _T(""),
	_T("CLSID\\%1\\AuxUserType\\2\0") _T("%4"),
	_T("CLSID\\%1\\AuxUserType\\3\0") _T("%6"),
        _T("CLSID\\%1\\MiscStatus\0") _T("32"),
        NULL
};

static const LPCTSTR rglpszServerOverwriteDLL[] =
{
	_T("%2\\CLSID\0") _T("%1"),
	_T("CLSID\\%1\\ProgID\0") _T("%2"),
	_T("CLSID\\%1\\InProcServer32\0") _T("%3"),
        _T("CLSID\\%1\\DefaultIcon\0") _T("%3,%7"),
        NULL
};

BOOL CFacExtndLogUI::UpdateRegistry( BOOL bRegister )
{
	if (bRegister)
/*
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			CLSID_EXTLOGUI,
			OLE_NAME,
			0,
			0,
			afxRegApartmentThreading,
			_dwOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
*/
        if (AfxOleRegisterServerClass(
				CLSID_EXTLOGUI,
				OLE_NAME,
				_T("LogUI extnd"),
				_T("LogUI extnd"),
				OAT_SERVER,
				(LPCTSTR *)rglpszServerRegister,
				(LPCTSTR *)rglpszServerOverwriteDLL
				)
			)
        {
            return FSetObjectApartmentModel( CLSID_EXTLOGUI );
        }
	else
		return AfxOleUnregisterClass(m_clsid, OLE_NAME);

    return FALSE;
}


//---------------------------------------------------------------
IMPLEMENT_DYNCREATE(CExtndCreator, CCmdTarget)
LPUNKNOWN CExtndCreator::GetInterfaceHook(const void* piid)
{
    return new CImpExtndLogUI;
}

//====================== the action

//---------------------------------------------------------------
CImpExtndLogUI::CImpExtndLogUI():
        m_dwRefCount(0)
    {
//    guid = IID_LOGGINGUI;
    AfxOleLockApp();
    }

//---------------------------------------------------------------
CImpExtndLogUI::~CImpExtndLogUI()
    {
    AfxOleUnlockApp();
    }

HRESULT 
CImpExtndLogUI::OnProperties(
    OLECHAR * pocMachineName, 
    OLECHAR* pocMetabasePath
    )
{
    return OnPropertiesEx(pocMachineName, pocMetabasePath, NULL, NULL);
}

HRESULT 
CImpExtndLogUI::OnPropertiesEx(
    OLECHAR * pocMachineName, 
    OLECHAR* pocMetabasePath,
    OLECHAR* pocUser,
    OLECHAR* pocPassword
    )
{
//    AFX_MANAGE_STATE(_afxModuleAddrThis);
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

	// specify the resources to use
	HINSTANCE hOldRes = AfxGetResourceHandle();
	AfxSetResourceHandle( g_hInstance );

    // prepare the help
    ((CLoguiApp*)AfxGetApp())->PrepHelp(pocMetabasePath);

    // Things could (potentially maybe) throw here, so better protect it.
    try
    {
        // declare the property sheet
        CPropertySheet propsheet( IDS_SHEET_EXTND_TITLE );
        propsheet.m_psh.dwFlags  |= PSH_HASHELP;
        
        // declare the property pages
        CLogGeneral pageLogGeneral;
        CLogAdvanced pageLogAdvanced;

        // prepare the common pages
        pageLogGeneral.m_szMeta     = pocMetabasePath;
        pageLogGeneral.m_szServer   = pocMachineName;
        pageLogGeneral.m_szUserName    = pocUser;
        pageLogGeneral.m_szPassword    = pocPassword;
        pageLogGeneral.szPrefix.LoadString( IDS_LOG_EXTND_PREFIX );
        pageLogGeneral.szSizePrefix.LoadString( IDS_LOG_SIZE_EXTND_PREFIX );
        pageLogGeneral.m_fShowLocalTimeCheckBox = TRUE;
        pageLogGeneral.m_fLocalMachine = FIsLocalMachine( pocMachineName );
        pageLogGeneral.m_psp.dwFlags    |= PSP_HASHELP;

        propsheet.AddPage( &pageLogGeneral );

        // For /LM/W3SVC/1 scenario
        CString m_szServiceName(pocMetabasePath+3);
        m_szServiceName = m_szServiceName.Left( m_szServiceName.ReverseFind('/'));

        // For /LM/W3SVC scenario
        if (m_szServiceName.IsEmpty())
        {
            m_szServiceName = pocMetabasePath+3;
        }

        pageLogAdvanced.m_szMeta        = pocMetabasePath;
        pageLogAdvanced.m_szServer      = pocMachineName;
        pageLogAdvanced.m_szUserName    = pocUser;
        pageLogAdvanced.m_szPassword    = pocPassword;
        pageLogAdvanced.m_szServiceName = m_szServiceName;
        pageLogAdvanced.m_psp.dwFlags   |= PSP_HASHELP;

        propsheet.AddPage( &pageLogAdvanced );
        propsheet.DoModal();
    }
    catch ( CException* pException )
    {
        pException->Delete();
    }

    // restore the resources
	AfxSetResourceHandle( hOldRes );

    return NO_ERROR;
}

//====================== the required methods
//---------------------------------------------------------------
HRESULT CImpExtndLogUI::QueryInterface(REFIID riid, void **ppObject)
{
    if (    riid==IID_IUnknown 
        ||  riid==IID_LOGGINGUI 
        ||  riid==IID_LOGGINGUI2 
        ||  riid==CLSID_EXTLOGUI
        )
    {
        *ppObject = (ILogUIPlugin*) this;
    }
    else
    {
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}

//---------------------------------------------------------------
ULONG CImpExtndLogUI::AddRef()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

//---------------------------------------------------------------
ULONG CImpExtndLogUI::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0) 
    {
        delete this;
    }
    return dwRefCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\uiextnd.h ===
#ifndef _EXTNDLOGUI_H_
#define _EXTNDLOGUI_H_


class CFacExtndLogUI : COleObjectFactory
{
    public:
        CFacExtndLogUI();
        virtual BOOL UpdateRegistry( BOOL bRegister );
};

class CExtndCreator : public CCmdTarget
{
    DECLARE_DYNCREATE(CExtndCreator)
    virtual LPUNKNOWN GetInterfaceHook(const void* piid);
};

class CImpExtndLogUI : public ILogUIPlugin2
{

public:
    CImpExtndLogUI();
    ~CImpExtndLogUI();

    virtual HRESULT STDMETHODCALLTYPE 
        OnProperties(OLECHAR * pocMachineName, OLECHAR * pocMetabasePath);
    virtual HRESULT STDMETHODCALLTYPE 
        OnPropertiesEx(OLECHAR * pocMachineName, OLECHAR * pocMetabasePath,
            OLECHAR * pocUserName, OLECHAR * pocPassword);

    HRESULT _stdcall QueryInterface(REFIID riid, void **ppObject);
    ULONG _stdcall AddRef();
    ULONG _stdcall Release();

private:
    ULONG m_dwRefCount;
};  // CImpLogUI

#endif  // _EXTNDLOGUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\uincsa.h ===
#ifndef _NCSLOGUI_H_
#define _NCSLOGUI_H_


class CFacNcsaLogUI : COleObjectFactory
{
public:
	CFacNcsaLogUI();
	virtual BOOL UpdateRegistry( BOOL bRegister );
};



class CNcsaCreator : public CCmdTarget
{
    DECLARE_DYNCREATE(CNcsaCreator)
    virtual LPUNKNOWN GetInterfaceHook(const void* piid);
};


class CImpNcsaLogUI : public ILogUIPlugin
{

public:
	CImpNcsaLogUI();
    ~CImpNcsaLogUI();

    virtual HRESULT STDMETHODCALLTYPE OnProperties(
		OLECHAR* pocMachineName, 
		OLECHAR* pocMetabasePath
		);
    virtual HRESULT STDMETHODCALLTYPE OnPropertiesEx(
		OLECHAR* pocMachineName, 
		OLECHAR* pocMetabasePath,
		OLECHAR* pocUserName,
		OLECHAR* pocPassword
		);

    HRESULT _stdcall QueryInterface(REFIID riid, void **ppObject);
    ULONG _stdcall AddRef();
    ULONG _stdcall Release();

private:
    ULONG m_dwRefCount;
};  // CImpNcsaLogUI




#endif  // _NCSLOGUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\uimsft.h ===
#ifndef _MSFTLOGUI_H_
#define _MSFTLOGUI_H_


class CFacMsftLogUI : COleObjectFactory
{
public:
        CFacMsftLogUI();
        virtual BOOL UpdateRegistry( BOOL bRegister );
};

class CMsftCreator : public CCmdTarget
{
    DECLARE_DYNCREATE(CMsftCreator)
    virtual LPUNKNOWN GetInterfaceHook(const void* piid);
};


class CImpMsftLogUI : public ILogUIPlugin
{
public:
	CImpMsftLogUI();
    ~CImpMsftLogUI();

    virtual HRESULT STDMETHODCALLTYPE OnProperties(
		OLECHAR* pocMachineName, 
		OLECHAR* pocMetabasePath);
    virtual HRESULT STDMETHODCALLTYPE OnPropertiesEx(
		OLECHAR* pocMachineName, 
		OLECHAR* pocMetabasePath,
		OLECHAR* pocUserName,
		OLECHAR* pocPassword
		);

    HRESULT _stdcall QueryInterface(REFIID riid, void **ppObject);
    ULONG _stdcall AddRef();
    ULONG _stdcall Release();

private:
    ULONG m_dwRefCount;
};  // CImpMsftLogUI




#endif  // _MSFTLOGUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\uincsa.cpp ===
#include "stdafx.h"
#include <iadmw.h>
#include <inetcom.h>
#include <logtype.h>
#include <ilogobj.hxx>
#include "logui.h"
#include "uincsa.h"
#include "LogGenPg.h"
#include "logtools.h"

#define OLE_NAME _T("NCSA_Logging_UI")

static const DWORD BASED_CODE _dwOleMisc = OLEMISC_INSIDEOUT | OLEMISC_CANTLINKINSIDE;
extern HINSTANCE g_hInstance;

CFacNcsaLogUI::CFacNcsaLogUI() :
        COleObjectFactory(CLSID_NCSALOGUI, RUNTIME_CLASS(CNcsaCreator), TRUE, OLE_NAME)
{
}

//---------------------------------------------------------------
static const LPCTSTR rglpszServerRegister[] = 
{
	_T("%2\\CLSID\0") _T("%1"),
	_T("%2\\NotInsertable\0") _T(""),
	_T("CLSID\\%1\0") _T("%5"),
	_T("CLSID\\%1\\Verb\\0\0") _T("&Edit,0,2"),
	_T("CLSID\\%1\\NotInsertable\0") _T(""),
	_T("CLSID\\%1\\AuxUserType\\2\0") _T("%4"),
	_T("CLSID\\%1\\AuxUserType\\3\0") _T("%6"),
        _T("CLSID\\%1\\MiscStatus\0") _T("32"),
        NULL,
};

static const LPCTSTR rglpszServerOverwriteDLL[] =
{
	_T("%2\\CLSID\0") _T("%1"),
	_T("CLSID\\%1\\ProgID\0") _T("%2"),
	_T("CLSID\\%1\\InProcServer32\0") _T("%3"),
        _T("CLSID\\%1\\DefaultIcon\0") _T("%3,%7"),
        NULL
};

BOOL CFacNcsaLogUI::UpdateRegistry( BOOL bRegister )
{
	if (bRegister)
        if ( AfxOleRegisterServerClass(
            CLSID_NCSALOGUI,
            OLE_NAME,
            _T("LogUI ncsa"),
            _T("LogUI ncsa"),
			OAT_SERVER,
			(LPCTSTR *)rglpszServerRegister,
			(LPCTSTR *)rglpszServerOverwriteDLL
			) )
        {
            return FSetObjectApartmentModel( CLSID_NCSALOGUI );
        }
	else
		return AfxOleUnregisterClass(m_clsid, OLE_NAME);

    return FALSE;
}

IMPLEMENT_DYNCREATE(CNcsaCreator, CCmdTarget)
LPUNKNOWN CNcsaCreator::GetInterfaceHook(const void* piid)
{
    return new CImpNcsaLogUI;
}

CImpNcsaLogUI::CImpNcsaLogUI():
        m_dwRefCount(0)
{
    AfxOleLockApp();
}

CImpNcsaLogUI::~CImpNcsaLogUI()
{
    AfxOleUnlockApp();
}

HRESULT CImpNcsaLogUI::OnProperties(
	OLECHAR * pocMachineName, 
	OLECHAR * pocMetabasePath
	)
{
	return OnPropertiesEx(pocMachineName, pocMetabasePath, NULL, NULL);
}

HRESULT CImpNcsaLogUI::OnPropertiesEx(
	OLECHAR * pocMachineName, 
	OLECHAR * pocMetabasePath,
	OLECHAR * pocUserName,
	OLECHAR * pocPassword
	)
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);

	// specify the resources to use
	HINSTANCE hOldRes = AfxGetResourceHandle();
	AfxSetResourceHandle( g_hInstance );

    // prepare the help
    ((CLoguiApp*)AfxGetApp())->PrepHelp( pocMetabasePath );

    CLogGeneral pageLogGeneral;
    CPropertySheet propsheet(IDS_SHEET_NCSA_TITLE);

    try
    {
        pageLogGeneral.m_szMeta = pocMetabasePath;
        pageLogGeneral.m_szServer = pocMachineName;
		pageLogGeneral.m_szUserName = pocUserName;
		pageLogGeneral.m_szPassword = pocPassword;
        pageLogGeneral.szPrefix.LoadString(IDS_LOG_NCSA_PREFIX);
        pageLogGeneral.szSizePrefix.LoadString(IDS_LOG_SIZE_NCSA_PREFIX);
        pageLogGeneral.m_fLocalMachine = FIsLocalMachine( pocMachineName );

        propsheet.AddPage( &pageLogGeneral );
        propsheet.m_psh.dwFlags |= PSH_HASHELP;
	    pageLogGeneral.m_psp.dwFlags |= PSP_HASHELP;

        propsheet.DoModal();
	}
    catch ( CException * pException )
    {
        pException->Delete();
    }

	AfxSetResourceHandle( hOldRes );

    return NO_ERROR;
}

HRESULT CImpNcsaLogUI::QueryInterface(REFIID riid, void **ppObject)
{
	if (	riid==IID_IUnknown 
		||	riid==IID_LOGGINGUI 
		||	riid==IID_LOGGINGUI2 
		||	riid==CLSID_NCSALOGUI
		)
	{
		*ppObject = (ILogUIPlugin*) this;
	}
	else
	{
		return E_NOINTERFACE;
	}
	AddRef();
	return NO_ERROR;
}

ULONG CImpNcsaLogUI::AddRef()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG CImpNcsaLogUI::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0) {
        delete this;
    }
    return dwRefCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\uimsft.cpp ===
#include "stdafx.h"
#include <iadmw.h>
#include <inetcom.h>
#include <logtype.h>
#include <ilogobj.hxx>
#include "logui.h"
#include "uimsft.h"
#include "LogGenPg.h"
#include "logtools.h"

#define OLE_NAME _T("Msft_Logging_UI")

static const DWORD BASED_CODE _dwOleMisc = OLEMISC_INSIDEOUT | OLEMISC_CANTLINKINSIDE;
extern HINSTANCE	g_hInstance;

CFacMsftLogUI::CFacMsftLogUI() :
        COleObjectFactory( CLSID_ASCLOGUI, RUNTIME_CLASS(CMsftCreator), TRUE, OLE_NAME )
{
}

static const LPCTSTR rglpszServerRegister[] = 
{
	_T("%2\\CLSID\0") _T("%1"),
	_T("%2\\NotInsertable\0") _T(""),
	_T("CLSID\\%1\0") _T("%5"),
	_T("CLSID\\%1\\Verb\\0\0") _T("&Edit,0,2"),
	_T("CLSID\\%1\\NotInsertable\0") _T(""),
	_T("CLSID\\%1\\AuxUserType\\2\0") _T("%4"),
	_T("CLSID\\%1\\AuxUserType\\3\0") _T("%6"),
        _T("CLSID\\%1\\MiscStatus\0") _T("32"),
        NULL
};

static const LPCTSTR rglpszServerOverwriteDLL[] =
{
	_T("%2\\CLSID\0") _T("%1"),
	_T("CLSID\\%1\\ProgID\0") _T("%2"),
	_T("CLSID\\%1\\InProcServer32\0") _T("%3"),
        _T("CLSID\\%1\\DefaultIcon\0") _T("%3,%7"),
        NULL

};

BOOL CFacMsftLogUI::UpdateRegistry( BOOL bRegister )
{
	if (bRegister)
        if ( AfxOleRegisterServerClass(
            CLSID_ASCLOGUI,
            OLE_NAME,
            _T("LogUI msft"),
            _T("LogUI msft"),
			OAT_SERVER,
			(LPCTSTR *)rglpszServerRegister,
			(LPCTSTR *)rglpszServerOverwriteDLL
			) )
        {
            return FSetObjectApartmentModel( CLSID_ASCLOGUI );
        }
	else
		return AfxOleUnregisterClass(m_clsid, OLE_NAME);

    return FALSE;
}

IMPLEMENT_DYNCREATE(CMsftCreator, CCmdTarget)

LPUNKNOWN CMsftCreator::GetInterfaceHook(const void* piid)
{
    return new CImpMsftLogUI;
}

CImpMsftLogUI::CImpMsftLogUI():
        m_dwRefCount(0)
{
    AfxOleLockApp();
}

CImpMsftLogUI::~CImpMsftLogUI()
{
    AfxOleUnlockApp();
}

HRESULT 
CImpMsftLogUI::OnProperties(OLECHAR * pocMachineName, OLECHAR * pocMetabasePath)
{
	return OnPropertiesEx(pocMachineName, pocMetabasePath, NULL, NULL);
}

HRESULT 
CImpMsftLogUI::OnPropertiesEx(
	OLECHAR * pocMachineName,
	OLECHAR * pocMetabasePath,
	OLECHAR * pocUserName,
	OLECHAR * pocPassword
	)
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);

	// specify the resources to use
	HINSTANCE hOldRes = AfxGetResourceHandle();
	AfxSetResourceHandle( g_hInstance );

    // prepare the help
    ((CLoguiApp*)AfxGetApp())->PrepHelp( pocMetabasePath );

    CLogGeneral pageLogGeneral;
    CPropertySheet  propsheet( IDS_SHEET_MSFT_TITLE );

    try
    {
        // prepare the pages
        pageLogGeneral.m_szMeta = pocMetabasePath;
        pageLogGeneral.m_szServer = pocMachineName;
        pageLogGeneral.m_szUserName = pocUserName;
        pageLogGeneral.m_szPassword = pocPassword;
        pageLogGeneral.szPrefix.LoadString(IDS_LOG_MSFT_PREFIX);
        pageLogGeneral.szSizePrefix.LoadString(IDS_LOG_SIZE_MSFT_PREFIX);
        pageLogGeneral.m_fLocalMachine = FIsLocalMachine(pocMachineName);

        propsheet.AddPage(&pageLogGeneral);
        propsheet.m_psh.dwFlags |= PSH_HASHELP;
	    pageLogGeneral.m_psp.dwFlags |= PSP_HASHELP;

        propsheet.DoModal();
    }
    catch (CException * pException)
    {
        pException->Delete();
    }
	AfxSetResourceHandle(hOldRes);

    return NO_ERROR;
}

HRESULT CImpMsftLogUI::QueryInterface(REFIID riid, void **ppObject)
{
    if (	riid==IID_IUnknown 
		||	riid==IID_LOGGINGUI 
		||	riid==IID_LOGGINGUI2 
		||	riid==CLSID_ASCLOGUI
		)
    {
        *ppObject = (ILogUIPlugin*) this;
    }
    else
    {
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}

ULONG CImpMsftLogUI::AddRef()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG CImpMsftLogUI::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0) 
	{
        delete this;
    }
    return dwRefCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\uiodbc.h ===
#ifndef _ODBCLOGUI_H_
#define _ODBCLOGUI_H_


class CFacOdbcLogUI : COleObjectFactory
{
public:
    CFacOdbcLogUI();
    virtual BOOL UpdateRegistry( BOOL bRegister );
};

class COdbcCreator : public CCmdTarget
{
    DECLARE_DYNCREATE(COdbcCreator)
    virtual LPUNKNOWN GetInterfaceHook(const void* piid);
};

class CImpOdbcLogUI : public ILogUIPlugin
{
public:
	CImpOdbcLogUI();
    ~CImpOdbcLogUI();

    virtual HRESULT STDMETHODCALLTYPE OnProperties(
		OLECHAR* pocMachineName, 
		OLECHAR* pocMetabasePath);
    virtual HRESULT STDMETHODCALLTYPE OnPropertiesEx(
		OLECHAR* pocMachineName, 
		OLECHAR* pocMetabasePath,
		OLECHAR* pocUserName,
		OLECHAR* pocPassword
		);

    HRESULT _stdcall QueryInterface(REFIID riid, void **ppObject);
    ULONG _stdcall AddRef();
    ULONG _stdcall Release();

private:
    ULONG m_dwRefCount;
};  // CImpOdbcLogUI

#endif  // _ODBCLOGUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\logui\uiodbc.cpp ===
#include "stdafx.h"
#include <iadmw.h>
#include <inetcom.h>
#include <logtype.h>
#include <ilogobj.hxx>
#include "logui.h"
#include "uiOdbc.h"

//#include "LogGenPg.h"
#include "LogODBC.h"
#include "logtools.h"

#define OLE_NAME _T("Odbc_Logging_UI")

static const DWORD BASED_CODE _dwOleMisc = OLEMISC_INSIDEOUT | OLEMISC_CANTLINKINSIDE;
extern HINSTANCE	g_hInstance;

CFacOdbcLogUI::CFacOdbcLogUI() :
        COleObjectFactory( CLSID_ODBCLOGUI, RUNTIME_CLASS(COdbcCreator), TRUE, OLE_NAME )
{
}

static const LPCTSTR rglpszServerRegister[] = 
{
	_T("%2\\CLSID\0") _T("%1"),
	_T("%2\\NotInsertable\0") _T(""),
	_T("CLSID\\%1\0") _T("%5"),
	_T("CLSID\\%1\\Verb\\0\0") _T("&Edit,0,2"),
	_T("CLSID\\%1\\NotInsertable\0") _T(""),
	_T("CLSID\\%1\\AuxUserType\\2\0") _T("%4"),
	_T("CLSID\\%1\\AuxUserType\\3\0") _T("%6"),
        _T("CLSID\\%1\\MiscStatus\0") _T("32"),
        NULL
};

static const LPCTSTR rglpszServerOverwriteDLL[] =
{
	_T("%2\\CLSID\0") _T("%1"),
	_T("CLSID\\%1\\ProgID\0") _T("%2"),
	_T("CLSID\\%1\\InProcServer32\0") _T("%3"),
        _T("CLSID\\%1\\DefaultIcon\0") _T("%3,%7"),
        NULL
};

BOOL CFacOdbcLogUI::UpdateRegistry( BOOL bRegister )
{
	if (bRegister)
        if ( AfxOleRegisterServerClass(
            CLSID_ODBCLOGUI,
            OLE_NAME,
            _T("LogUI odbc"),
            _T("LogUI odbc"),
			OAT_SERVER,
			(LPCTSTR *)rglpszServerRegister,
			(LPCTSTR *)rglpszServerOverwriteDLL
			) )
        {
            return FSetObjectApartmentModel( CLSID_ODBCLOGUI );
        }
	else
		return AfxOleUnregisterClass(m_clsid, OLE_NAME);

    return FALSE;
}

IMPLEMENT_DYNCREATE(COdbcCreator, CCmdTarget)

LPUNKNOWN COdbcCreator::GetInterfaceHook(const void* piid)
{
        return new CImpOdbcLogUI;
}

CImpOdbcLogUI::CImpOdbcLogUI():
        m_dwRefCount(0)
{
    AfxOleLockApp();
}

CImpOdbcLogUI::~CImpOdbcLogUI()
{
    AfxOleUnlockApp();
}

HRESULT 
CImpOdbcLogUI::OnProperties(OLECHAR * pocMachineName, OLECHAR * pocMetabasePath)
{
	return OnPropertiesEx(pocMachineName, pocMetabasePath, NULL, NULL);
}

HRESULT 
CImpOdbcLogUI::OnPropertiesEx(
	OLECHAR * pocMachineName,
	OLECHAR * pocMetabasePath,
	OLECHAR * pocUserName,
	OLECHAR * pocPassword
	)
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);

	HINSTANCE hOldRes = AfxGetResourceHandle();
	AfxSetResourceHandle( g_hInstance );

    // prepare the help
    ((CLoguiApp*)AfxGetApp())->PrepHelp( pocMetabasePath );

//    CLogGeneral pageLogGeneral;
    CLogODBC pageLogODBC;
    CPropertySheet  propsheet( IDS_SHEET_ODBC_TITLE );

    try
    {
        // prepare the pages
        pageLogODBC.m_szMeta = pocMetabasePath;
        pageLogODBC.m_szServer = pocMachineName;
        pageLogODBC.m_szUserName = pocUserName;
        pageLogODBC.m_szPassword = pocPassword;

//        pageLogGeneral.m_szMeta = pocMetabasePath;
//        pageLogGeneral.m_szServer = pocMachineName;
//        pageLogGeneral.m_szUserName = pocUserName;
//        pageLogGeneral.m_szPassword = pocPassword;
//        pageLogGeneral.szPrefix.LoadString( IDS_LOG_EXTND_PREFIX );
//        pageLogGeneral.szSizePrefix.LoadString( IDS_LOG_SIZE_EXTND_PREFIX );
//        propsheet.AddPage( &pageLogGeneral );     // don't need general for ODBC
        propsheet.AddPage( &pageLogODBC );

        // turn on help
        propsheet.m_psh.dwFlags |= PSH_HASHELP;
//	    pageLogGeneral.m_psp.dwFlags |= PSP_HASHELP;
	    pageLogODBC.m_psp.dwFlags |= PSP_HASHELP;

        propsheet.DoModal();
    }
    catch ( CException * pException )
    {
        pException->Delete();
    }

	AfxSetResourceHandle( hOldRes );

    return NO_ERROR;
}

HRESULT CImpOdbcLogUI::QueryInterface(REFIID riid, void **ppObject)
{
    if (	riid==IID_IUnknown 
		||	riid==IID_LOGGINGUI 
		||	riid==IID_LOGGINGUI2 
		||	riid==CLSID_ASCLOGUI
		)
    {
        *ppObject = (ILogUIPlugin*) this;
    }
    else
    {
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}

ULONG CImpOdbcLogUI::AddRef()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG CImpOdbcLogUI::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0) {
        delete this;
    }
    return dwRefCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\mbsh\cmbshexception.cs ===
using System;

namespace mbsh
{
	/// <summary>
	/// 
	/// </summary>
	public class CMbshException : System.Exception
	{
		private string eMessage;

		public CMbshException()
		{
		}

		public CMbshException(string eMessage)
		{
			this.eMessage = eMessage;
		}

		public override string Message
		{
			get
			{
				string msg = base.Message;
				if (eMessage != null)
				{
					msg = eMessage;
				}

				return msg;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\mbsh\carghandler.cs ===
using System;
using System.Resources;

namespace mbsh
{
	/// <summary>
	/// Handles the command line arguments for the application.
	/// </summary>
	public class CArgHandler
	{
		enum HelpType {None, Usage}
		
		public CArgHandler(string[] args)
		{
			/// <summary>
			/// Constructor will take the command line arguments
			/// </summary>
			
			// First make sure we don't have too many arguments
			if (args.Length > CMbshApp.c_iMaxArgs)
			{
				m_helpType = HelpType.Usage;
				return;
			}
			
			for (int index = 0; index < args.Length; index++)
			{
				bool bArgHandled = false;

				// does the user need help?
				if (!NeedsHelp)
				{
					for (int numConst = 0; numConst < c_HelpArgs.Length; numConst++)
					{
						if (args[index].Equals(c_HelpArgs[numConst]))
						{
							m_helpType = HelpType.Usage;
						
							bArgHandled = true;
							break;
						}
					}
				}

				// did the user set the metabase path?
				if (!bArgHandled)
				{
					m_mbPath = args[index];
					bArgHandled = true;
				}
			}
   		}

		public string MBPath
		{
			get
			{
				return m_mbPath;
			}
		}

		public void GiveHelp()
		{
			// Get a resource manager
			ResourceManager resources = new ResourceManager("Mbsh.Mbsh", System.Reflection.Assembly.GetExecutingAssembly());

			switch (m_helpType)
			{
				default:
					Console.WriteLine(resources.GetString("mainHelp"));
					break;
			}
		}

		private HelpType m_helpType   = HelpType.None;
		private string[] c_HelpArgs   = {"-help", "/help", "-h", "/h", "-?", "/?"};
		private string   m_mbPath     = CMbshApp.c_DefaultMBPath;

		public bool NeedsHelp
		{
			get
			{
				if (m_helpType == HelpType.None)
				{
					return false;
				}
				else 
				{
					return true;
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\mbsh\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\mbsh\ctokenizer.cs ===
using System;

namespace mbsh
{
	/// <summary>
	/// Summary description for CTokenizer.
	/// </summary>
	public class CTokenizer
	{
		public CTokenizer(string inputLine, char[] delim)
		{
			int iNonEmpty = 0;
			int i = 0;
			int index = 0;
			string[] a_sAllTok = inputLine.Split(delim);
			
			// remove the empty tokens
			for (i = 0; i < a_sAllTok.Length; i++)
			{
				if (false == a_sAllTok[i].Equals(String.Empty))
				{
					iNonEmpty++;
				}
			}

			a_sCommands = (string[])Array.CreateInstance(typeof(string), iNonEmpty);

			index = 0;
			for (i = 0; i < a_sAllTok.Length; i++)
			{
				if (false == a_sAllTok[i].Equals(String.Empty))
				{
					a_sCommands[index] = String.Copy(a_sAllTok[i]);
					index++;
				}
			}
		}

		private string[] a_sCommands;

		public string this[int index]
		{
			get
			{
				if (index < a_sCommands.Length)
				{
					return a_sCommands[index];
				}
				else
				{
					return null;
				}
			}
		}
		/// <summary>
		/// Gets the next token in the tokenizer
		/// </summary>
		public string GetNextToken()
		{
			if (m_tokIndex < a_sCommands.Length)
			{
				m_tokIndex++;
				return a_sCommands[m_tokIndex-1];
			}
			else
			{
				return null;
			}
		}

		private int m_tokIndex = 0;

		/// <summary>
		/// Returns the number of tokens in the input line
		/// </summary>
		public int NumToks
		{
			get
			{
				return a_sCommands.Length;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\mbsh\cwscript.cs ===
using System;

namespace mbsh
{
	/// <summary>
	/// Implements an object that has the functionality of cscript's WScript root object
	/// </summary>
	public class CWScript
	{
		public CWScript()
		{
		}

		public void Echo(string outputLine)
		{
			Console.WriteLine(outputLine);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\mbsh\cmbshapp.cs ===
using System;
using System.Resources;

namespace mbsh
{
	/// <summary>
	/// Main class for mbsh application.
	/// </summary>
	class CMbshApp
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		public static int Main(string[] args)
		{
			// Get a resource manager
			ResourceManager resources = new ResourceManager("Mbsh.Mbsh", System.Reflection.Assembly.GetExecutingAssembly());

			Console.WriteLine(resources.GetString("mainGreeting"));

			try 
			{
				CArgHandler m_argHandler = new CArgHandler(args);
		
				CProcessor m_proc = new CProcessor(m_argHandler.MBPath);
				
				if (m_argHandler.NeedsHelp)
				{
					m_argHandler.GiveHelp();
				}
				else
				{
					m_proc.DoWork();
				}

				return(0);
			}

			catch(CMbshException e)
			{
				Console.WriteLine(e.Message);
				Console.WriteLine(resources.GetString("exiting"));
				return(-1);
			}

			catch(Exception e)
			{
				Console.WriteLine(e.Message);
				return(-1);
			}
		}
	
		public const int      c_iMaxArgs      = 1;
		public const string   c_DefaultMBPath = "/LOCALHOST";
		public const string   c_ConnectString = "IIS:/";
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\mbsh\cprocessor.cs ===
using System;
using System.DirectoryServices;
using System.Resources;
using MSScriptControl;
using System.Collections;

namespace mbsh
{
	/// <summary>
	/// The actual shell processor.
	/// </summary>
	public class CProcessor
	{
		public CProcessor(string mbPath)
		{
			// Set language
			m_sLanguage = c_defaultLanguage;

			// Get a resource manager
			m_resources = new ResourceManager("Mbsh.Mbsh", System.Reflection.Assembly.GetExecutingAssembly());

			// Init the WScript object
			m_WScript = new CWScript();

			// Init the script control
			InitEngine(c_defaultLanguage);

			// Set path
			MBPath = mbPath;
		}

		public void DoWork()
		{
			m_bWorkDone = false;

			while (!m_bWorkDone)
			{
				try
				{
					string s_inputLine;
					string token;

					CTokenizer localTok;

					s_inputLine = ShowPrompt();

					localTok = new CTokenizer(s_inputLine, null);

					token = localTok.GetNextToken();
					token = token.ToUpper();

					if (String.Equals(token, m_commandPrefix + m_resources.GetString("engCommand")))
					{
						// change the scripting engine

						if (localTok.NumToks < 2)
						{
							throw new CMbshException(m_resources.GetString("engError"));
						}

						string language = localTok.GetNextToken();

						InitEngine(language);
					}
				    
					else if (String.Equals(token, m_commandPrefix + m_resources.GetString("helpCommand")))
					{
						// help command
						
						if (localTok.NumToks < 2)
						{
							// general help

							Console.WriteLine(m_resources.GetString("generalHelp"));
						}

						else
						{
							// specific help

							Console.WriteLine(m_resources.GetString("specificHelp"));
						}
					}

					else if (String.Equals(token, m_commandPrefix + m_resources.GetString("dirCommand")))
					{
						EnumProps();
					}

					else if (String.Equals(token, m_commandPrefix + m_resources.GetString("setCommand")))
					{
						if (localTok.NumToks < 3)
						{
							throw new CMbshException(m_resources.GetString("setError"));
						}

						string propName = localTok.GetNextToken();
						string propVal = localTok.GetNextToken();

						SetProperty(propName, propVal);
					}

					else if (String.Equals(token, m_commandPrefix + m_resources.GetString("getCommand")))
					{
						if (localTok.NumToks < 2)
						{
							throw new CMbshException(m_resources.GetString("getError"));
						}

						GetProperty(localTok.GetNextToken());
					}

					else if (String.Equals(token, m_commandPrefix + m_resources.GetString("cdCommand")))
					{
						//change metabase node

						if (localTok.NumToks < 2)
						{
							throw new CMbshException(m_resources.GetString("cdError"));
						}

						ChangeDir(localTok);
					}

					else if ((String.Equals(token, m_commandPrefix + m_resources.GetString("exitCommand"))) ||
						(String.Equals(token, m_commandPrefix + m_resources.GetString("quitCommand"))))
					{
						// quitting
						m_bWorkDone = true;
					}

					else if (token.StartsWith(m_commandPrefix))
					{
						// unknown command
						throw new CMbshException(m_resources.GetString("unknownCommand") + token +
							"\n" + m_resources.GetString("useHelp") + m_commandPrefix +
							m_resources.GetString("helpCommand"));
					}

					else
					{
						m_scriptControl.ExecuteStatement(s_inputLine);
					}
				}

				catch(Exception e)
				{
					Console.WriteLine(e.Message);
				}
			}
		}

		private string ShowPrompt()
		{
			Console.Write(MBPath + c_promptSuffix);
			return Console.ReadLine();
		}

		private string          m_mbPath        = CMbshApp.c_DefaultMBPath;
		private const string    c_promptSuffix  = ">";
		private const string    c_pathDelim     = "/";
		private       char[]    c_cPathDelim    = {'/'};
		private string          m_commandPrefix = ".";
		private const string    c_upPath        = "..";
		private const string    c_altPathDelim  = "\\";
		private bool            m_bWorkDone     = false;
		private DirectoryEntry  m_dir           = null;
		private ResourceManager m_resources;

		/// <summary>
		/// Gets the ADSI object for the specified path
		/// </summary>
		private DirectoryEntry GetPathObject(string sPath)
		{
			string s_adsiPath;
			
			if (sPath.StartsWith(CMbshApp.c_ConnectString))
			{
				s_adsiPath = sPath;
			}
			else
			{
				s_adsiPath= CMbshApp.c_ConnectString + sPath;
			}

			try 
			{
				if (DirectoryEntry.Exists(s_adsiPath))
				{
					return new System.DirectoryServices.DirectoryEntry(s_adsiPath);
				}				
				else
				{
					return null;
				}
			}
			catch
			{
				return null;
			}
		}

		/// <summary>
		/// MSScriptControl.ScriptControl
		/// </summary>
		private ScriptControl m_scriptControl;
		/// <summary>
		/// Default script engine
		/// </summary>
		private const string c_defaultLanguage = "JScript";
		/// <summary>
		/// The active script engine
		/// </summary>
		private string m_sLanguage;

		/// <summary>
		/// Initializes m_scriptControl
		/// </summary>
		private void InitEngine(string language)
		{
			// Get the script control
			m_scriptControl = new MSScriptControl.ScriptControlClass();
			try
			{
				m_scriptControl.Language = language;
				m_sLanguage = language;
			}
			catch
			{
				Console.WriteLine(m_resources.GetString("noLang"));
				m_scriptControl.Language = m_sLanguage;
			}

			m_scriptControl.AllowUI = true;
		}

		/// <summary>
		/// Instantiation of WScript object
		/// </summary>
		private CWScript m_WScript;

		/// <summary>
		/// Sets a property in the metabase
		/// </summary>
		private void SetProperty(string propName, string propVal)
		{
			PropertyValueCollection propValColl;
			PropertyCollection collection = m_dir.Properties;
			try
			{
				propValColl = collection[propName];
			}
			catch
			{
				throw new CMbshException(m_resources.GetString("invalidProp"));
			}
			
			propValColl.Value = propVal;
			m_dir.CommitChanges();
		}

		private void ChangeDir(CTokenizer localTok)
		{
			string path = localTok.GetNextToken();
			path.Replace(c_altPathDelim, c_pathDelim);

			CTokenizer pathTokens = new CTokenizer(path, c_cPathDelim);
			string newPath;

			// absolute path
			if (path.StartsWith(c_pathDelim))
			{
				newPath = c_pathDelim;
			}
				// relative path
			else
			{
				newPath = MBPath;
			}

			for (int pathIndex = 0; pathIndex < pathTokens.NumToks; pathIndex++)
			{
				string pathToken = pathTokens.GetNextToken();

				// ".."
				if (String.Equals(pathToken, c_upPath))
				{
					int lastSlash = newPath.LastIndexOf(c_pathDelim);
					newPath = newPath.Remove(lastSlash, newPath.Length - lastSlash);

					if (0 == newPath.Length)
					{
						newPath = c_pathDelim;
					}
				}

				else
				{
					if (newPath.EndsWith(c_pathDelim))
					{
						newPath = newPath + pathToken;
					}
					else
					{
						newPath = newPath + c_pathDelim + pathToken;
					}
				}
			}

			MBPath = newPath;
		}

		/// <summary>
		/// Outputs the value of the selected property
		/// </summary>
		private void GetProperty(string propName)
		{
			PropertyValueCollection propValColl;
			PropertyCollection collection = m_dir.Properties;
			try
			{
				propValColl = collection[propName];
			}
			catch
			{
				throw new CMbshException(m_resources.GetString("invalidProp"));
			}

			Console.WriteLine(propValColl.Value.ToString());
		}

		/// <summary>
		/// Outputs all properties at the node
		/// </summary>
		private void EnumProps()
		{
			PropertyValueCollection propValColl;
			DirectoryEntry propEntry;
			PropertyCollection collection = m_dir.Properties;

			// Get the schema entry for the class of our object
			ActiveDs.IADsClass schemaEntry = (ActiveDs.IADsClass)m_dir.SchemaEntry.NativeObject;
			Array[] propLists = new Array[2];
			propLists[0] = (Array)schemaEntry.MandatoryProperties;
			propLists[1] = (Array)schemaEntry.OptionalProperties;

			foreach (Array propList in propLists)
			{
				foreach (string propName in propList)
				{
					if (!propName.Equals(string.Empty))
					{
						try
						{
							propValColl = collection[propName];

							// don't do anything if there's no value
							if (null != propValColl.Value)
							{
								string propVal = propValColl.Value.ToString();
								if (!propVal.Equals(string.Empty))
								{
									// check if isInherit
									IISOle.IISPropertyAttribute retVal = null;
									Object[] invokeArgs = {propName};
									try
									{
										retVal = (IISOle.IISPropertyAttribute) m_dir.Invoke("GetPropertyAttribObj", invokeArgs);
									}
									catch
									{
										// ignore the error - check for null below
									}

									if (null != retVal)
									{
										// check if IsInherit
										if (!retVal.Isinherit)
										{
											string propPath = m_dir.SchemaEntry.Parent.Path + "/" + propName;
											propEntry = GetPathObject(propPath);
											ActiveDs.IADsProperty iProp = (ActiveDs.IADsProperty)propEntry.NativeObject;
											string propSyntax = "(" + iProp.Syntax + ")";
											string vpropName = propName.PadRight(30, ' ');
											Console.Write(vpropName + " : ");
											string typename = propSyntax.ToUpper().PadRight(10, ' ');
											Console.Write(typename + " ");
											Console.WriteLine(propVal);
										}
									}
								}
							}
						}
						catch
						{
							Console.WriteLine(m_resources.GetString("noDisplay") + propName);
						}
					}
				}
			}
		}

		private string MBPath
		{
			get
			{
				return m_mbPath;
			}
			set
			{
				m_dir = GetPathObject(value);
				if (null != m_dir)
				{
					m_mbPath = String.Copy(value);

					// need the next line so that the control actually gets reset, even if we haven't used it
					m_scriptControl.State = MSScriptControl.ScriptControlStates.Connected;

					m_scriptControl.Reset();
					m_scriptControl.AddObject(m_resources.GetString("thisNodeName"), m_dir.NativeObject, true);
					m_scriptControl.AddObject(m_resources.GetString("WScriptName"), m_WScript, true);
					
					return;
				}

				m_dir = GetPathObject(m_mbPath);
				if (null != m_dir)
				{
					// throw "can't set path" exception
					throw new CMbshException(m_resources.GetString("failedADSI") + value +
						"\n" + m_resources.GetString("succeededADSI") + m_mbPath);
				}
			
				// throw "can't set any path" exception
				if (String.Equals(value, m_mbPath))
				{
					throw new CMbshException(m_resources.GetString("failedADSI") + value);
				}
				else
				{
					throw new CMbshException(m_resources.GetString("failedADSI") + value +
						"\n" + m_resources.GetString("failedADSI") + m_mbPath);
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\core\exceptions.h ===
#pragma once


// Exception to be thrown if the process is canceled by the user
class CCancelException
{
};



// Base exception class
/////////////////////////////////////////////////////////////////////////////
class CBaseException
{
protected:
	enum 
	{
		MaxErrorBuff	= 2 * 1024,	// Buffer for formating string messages
	};

protected:
	CBaseException(){}


public:
	CBaseException( UINT nResID, DWORD dwCode = ::GetLastError() )
	{
		FormatError( nResID, dwCode );
	}

	CBaseException( LPCWSTR wszError, DWORD dwCode = ::GetLastError() )
	{
		FormatError( wszError, dwCode );
	}

	LPCWSTR GetDescription()const{ return m_strError.c_str(); }


protected:
	void FormatError( UINT nResID, DWORD dwCode );
	void FormatError( LPCWSTR wszError, DWORD dwCode );


private:
	std::wstring	m_strError;
};



// CObjectException - exception on object access/acquire
class CObjectException : public CBaseException
{
public:
	CObjectException( UINT nResID, LPCWSTR wszObject, DWORD dwCode = ::GetLastError() );
	CObjectException(	UINT nResID, 
						LPCWSTR wszObject1,
						LPCWSTR wszObject2,
						DWORD dwCode = ::GetLastError() );
};



// CUnexpectedException - exception that is not expected to normally ocure
/*CUnexpectedException( char* file , UINT nLine, HRESULT hr = S_OK )
	{
		WCHAR wszBuffer[ CBaseException::MaxErrorBuff ];

		try
		{
			USES_CONVERSION;

			::swprintf( wszBuffer, 
						L"Unexpected exception occured.\nFile: '%s'.\nLine: %d\nCode: %x",
						A2W( file ),
						nLine,
						hr );

		}
		catch(...)
		{
			// A2W exceptions
		}

		CBaseException::FormatError( wszBuffer, hr );
	}
};*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\core\exceptions.cpp ===
#include "StdAfx.h"
#include "exceptions.h"

void CBaseException::FormatError( UINT nResID, DWORD dwCode )
{
	WCHAR		wszBuffer[ MaxErrorBuff ] = L"";
	
	VERIFY( ::LoadStringW( _Module.GetModuleInstance(), nResID, wszBuffer, MaxErrorBuff ) );

	FormatError( wszBuffer, dwCode );
}



void CBaseException::FormatError( LPCWSTR wszError, DWORD dwCode )
{
	_ASSERT( wszError != NULL );

	WCHAR	wszBuffer1[ MaxErrorBuff ] = L"";
	WCHAR	wszOSError[ MaxErrorBuff ] = L"";

	::wcsncpy( wszBuffer1, wszError, MaxErrorBuff );
	
	// Get the OS error info
	if ( dwCode != ERROR_SUCCESS )
	{
		WCHAR	wszFmt[ MaxErrorBuff ] = L"";

		// Load format string from resources
		VERIFY( ::LoadStringW( _Module.GetModuleInstance(), IDS_FMO_ERROR, wszFmt, MaxErrorBuff ) );

		// For E_FAIL use ErrorInfo 
		if ( dwCode != E_FAIL )
		{
            VERIFY( ::FormatMessageW(	FORMAT_MESSAGE_FROM_SYSTEM,
										NULL,
										dwCode,
										0,
										wszOSError,
										MaxErrorBuff,
										NULL ) != 0 );
		}
		else
		{
			IErrorInfoPtr	spErrorInfo;
			CComBSTR		bstrError;

			VERIFY( SUCCEEDED( ::GetErrorInfo( 0, &spErrorInfo ) ) );
			VERIFY( SUCCEEDED( spErrorInfo->GetDescription( &bstrError ) ) );

			::wcsncpy( wszOSError, bstrError, MaxErrorBuff - 1 );
            wszOSError[ MaxErrorBuff - 1 ] = L'\0';
		}

		_ASSERT( ( ::wcslen( wszError ) + ::wcslen( wszOSError ) + ::wcslen( wszFmt ) ) < MaxErrorBuff );

		// Build the final error msg
		::_snwprintf(	wszBuffer1, 
						MaxErrorBuff - ::wcslen( wszFmt ),
						wszFmt,
						wszError, 
						wszOSError );
	}

	try
	{
		m_strError = wszBuffer1;
	}
	catch(...)
	{
		// Out of memory - nothing to do
	}

	ATLTRACE( L"\nException occured: %s", wszBuffer1 );
}




// CObjectException implementation
CObjectException::CObjectException( UINT nResID, LPCWSTR wszObject, DWORD dwCode /*=GetLastError()*/ )
{
	WCHAR		wszFmt[ MaxErrorBuff ] = L"";
	WCHAR		wszError[ MaxErrorBuff ] = L"";
	
	VERIFY( ::LoadStringW( _Module.GetModuleInstance(), nResID, wszFmt, MaxErrorBuff ) );

	_ASSERT( ( ::wcslen( wszObject ) + ::wcslen( wszFmt ) ) < MaxErrorBuff );

	::swprintf( wszError, wszFmt, wszObject );

	CBaseException::FormatError( wszError, dwCode );
}



CObjectException::CObjectException(	UINT nResID, 
									LPCWSTR wszObject1,
									LPCWSTR wszObject2,
									DWORD dwCode /*= ::GetLastError()*/ )
{
	WCHAR		wszFmt[ CBaseException::MaxErrorBuff ] = L"";
	WCHAR		wszError[ CBaseException::MaxErrorBuff  ] = L"";
	
	VERIFY( ::LoadStringW( _Module.GetModuleInstance(), nResID, wszFmt, MaxErrorBuff ) );

	_ASSERT( ( ::wcslen( wszObject2 ) + ::wcslen( wszObject1 ) + ::wcslen( wszFmt ) ) < CBaseException::MaxErrorBuff );

	::swprintf( wszError, wszFmt, wszObject1, wszObject2 );

	CBaseException::FormatError( wszError, dwCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\core\exportpackage.cpp ===
/*
****************************************************************************
|    Copyright (C) 2002  Microsoft Corporation
|
|    Component / Subcomponent
|        IIS 6.0 / IIS Migration Wizard
|
|    Based on:
|        http://iis6/Specs/IIS%20Migration6.0_Final.doc
|
|   Abstract:
|        ExportPackage COM class implementation
|
|   Author:
|        ivelinj
|
|   Revision History:
|        V1.00    March 2002
|
****************************************************************************
*/
#include "StdAfx.h"
#include "exportpackage.h"
#include "IISHelpers.h"
#include "Wrappers.h"


const DWORD POS_XMLDATA_OFFSET = 80;    // See CExportPackage::CreateOutputFile(...)


// Event helper
void inline STATE_CHANGE(   CExportPackage* pThis ,
                            enExportState st, 
                            _variant_t arg1, 
                            _variant_t arg2, 
                            _variant_t arg3 )
{
    VARIANT_BOOL bContinue = VARIANT_TRUE; 
    VERIFY( SUCCEEDED( pThis->Fire_OnStateChange( st, arg1, arg2, arg3, &bContinue ) ) );

    if ( bContinue != VARIANT_TRUE )
    {
        throw CCancelException();
    }
}



CExportPackage::CExportPackage()
{
    m_dwContentFileCount = 0;
}



// IExportPackage implementation
STDMETHODIMP CExportPackage::get_SiteCount( SHORT* pVal )
{
    if ( pVal != NULL )
    {
        *pVal = static_cast<SHORT>( m_SitesToExport.size() );
        return S_OK;
    }
    
    return E_INVALIDARG;
}



STDMETHODIMP CExportPackage::AddSite( LONG nSiteID, LONG nOptions )
{
    if ( 0 == nSiteID ) return E_INVALIDARG;

    if ( !CTools::IsIISRunning() )
    {
        CTools::SetErrorInfoFromRes( IDS_E_NO_IIS );
        return E_FAIL;
    }
    
    // Check that the site is not already added
    for ( TSitesList::iterator it = m_SitesToExport.begin(); it != m_SitesToExport.end(); ++it )
    {
        if ( static_cast<LONG>( it->nSiteID ) == nSiteID )
        {
            return S_OK;
        }
    }

    try
    {
        // Check that this is a valid SiteID
        CIISSite Site( nSiteID );

        // Add the site to the list of sites to export
        _SiteInfo Info;
        Info.nSiteID    = static_cast<ULONG>( nSiteID );
        Info.nOptions   = nOptions;

        m_SitesToExport.push_back( Info );
    }
    catch( CBaseException& err )
    {
        CTools::SetErrorInfo( err.GetDescription() );
        return E_INVALIDARG;
    }
    catch( std::bad_alloc& )
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}



/*
    Adds a post-processing file to the package. This file can be used in post-processing commands
*/
STDMETHODIMP CExportPackage::PostProcessAddFile( LONG nSiteID, BSTR bstrFilePath )
{
    if ( ( 0 == nSiteID ) || ( NULL == bstrFilePath ) ) return E_INVALIDARG;

    HRESULT hr = S_OK;

    try
    {
        _SiteInfo& Info = GetSiteInfo( nSiteID );
        AddFileToSite( /*r*/Info, bstrFilePath );
    }
    catch( CBaseException& err )
    {
        CTools::SetErrorInfo( err.GetDescription() );
        hr = E_FAIL;
    }
    catch( std::bad_alloc& )
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}



/*
    Adds a post-processingcommand to the package. This command will be executed at import time
*/
STDMETHODIMP CExportPackage::PostProcessAddCommand( LONG nSiteID, 
                                                    BSTR bstrCommand,
                                                    LONG nTimeout,
                                                    VARIANT_BOOL bIgnoreErrors )
{
    if ( ( 0 == nSiteID ) || ( NULL == bstrCommand ) || ( nTimeout < 0 ) ) return E_INVALIDARG;

    HRESULT hr = S_OK;

    try
    {
        _SiteInfo&    SiteInfo = GetSiteInfo( nSiteID );
        _CmdInfo    CmdInfo;
        CmdInfo.strCommand      = bstrCommand;
        CmdInfo.bIgnoreErrors   = bIgnoreErrors != VARIANT_FALSE;
        CmdInfo.dwTimeout        = min( static_cast<DWORD>( nTimeout ), MAX_CMD_TIMEOUT );

        SiteInfo.listCommands.push_back( CmdInfo );
    }
    catch( CBaseException& err )
    {
        CTools::SetErrorInfo( err.GetDescription() );
        hr = E_FAIL;
    }
    catch( std::bad_alloc& )
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}



STDMETHODIMP CExportPackage::WritePackage(  BSTR bstrOutputFilename, 
                                            BSTR bstrPassword, 
                                            LONG nOptions,
                                            BSTR bstrComment )
{
    HRESULT hr = S_OK;

    try
    {
        WritePackageImpl( bstrOutputFilename, bstrPassword, bstrComment, nOptions );
    }
    catch( const CBaseException& err )
    {
        CTools::SetErrorInfo( err.GetDescription() );
        hr = E_FAIL;
    }
    catch ( CCancelException& )
    {
        hr = S_FALSE;
    }
    catch( const _com_error& err )
    {
        // Only out of mem is expected
        _ASSERT( err.Error() == E_OUTOFMEMORY );
        err;
        hr = E_OUTOFMEMORY;
    }
    catch( std::bad_alloc& )
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}



void CExportPackage::WritePackageImpl(  LPCWSTR wszOutputFile, 
                                        LPCWSTR wszPassword,
                                        BSTR bstrComment,
                                        LONG nOptions )
{
    // Validate imput parameters and export conditions
    ValidateExport( wszOutputFile, wszPassword, bstrComment, nOptions );    
    
    STATE_CHANGE( this, estInitializing, _variant_t( L"1" ), _variant_t( L"2" ), _variant_t( L"3 - Test" ) );    
    
    // Create the XMLDoc - this document contains all the configuration data for the exported package
    // Set any initial info in the doc
    IXMLDOMDocumentPtr  spXMLDoc;
    IXMLDOMElementPtr   spRoot;
    CreateXMLDoc( bstrComment, /*r*/spXMLDoc, /*r*/spRoot );

    // Create the output file
    TFileHandle shOutput( CreateOutputFile( wszOutputFile, static_cast<DWORD>( nOptions ) ) );

    // Create a CryptKey that will be used to secure the data
    // The key will be used to encrypt only secure MD data or to encrytpt everything in the package
    // depending on the supplied Options
    // We have two types of crypt key:
    // 1.    The package is not encrypted - in this case a random key is generated and it will be used
    //        to encrypt the secure metadata. At the end, this key is exported to the output file encrypted
    //        with the supplied password
    // 2.    The package is ecnrypted - a crypt key is created from the supplied password and this key is used
    //        to encrypt all package data
    TCryptProvHandle shCryptProv;
    TCryptKeyHandle  shCryptKey;
    
    // Get a crypt context. We will not use public/private keys - that's why Provider name is NULL
    // and CRYPT_VERIFYCONTEXT is used
    IF_FAILED_BOOL_THROW(    ::CryptAcquireContext( &shCryptProv,
                                                    NULL,
                                                    MS_ENHANCED_PROV,
                                                    PROV_RSA_FULL,
                                                    CRYPT_VERIFYCONTEXT | CRYPT_SILENT ),
                            CBaseException( IDS_E_CRYPT_CONTEXT ) );

    // Get a crypt key. If we will encryptthe package - use key derived from the password
    // Otherwise use a random ( session ) key and export it with the password
    if ( nOptions & wpkgEncrypt )
    {
        shCryptKey = CTools::GetCryptKeyFromPwd( shCryptProv.get(), wszPassword );
    }
    else
    {
        shCryptKey = GenCryptKeyData( shCryptProv.get(), wszPassword, spXMLDoc, spRoot );
    }
    
    // Create the class that will handle file output
    COutPackage OutPkg( shOutput.get(), 
                        ( nOptions & wpkgCompress ) != 0,
                        ( nOptions & wpkgEncrypt ) != 0 ? shCryptKey.get() : NULL );
    
    // Export each site
    // The ExportSiteMethod will modify the XML doc and will write some data to the output file
    for (   TSitesList::const_iterator it = m_SitesToExport.begin();
            it != m_SitesToExport.end();
            ++it )
    {
        // Crreate the XML node under which all the data will be stored
        IXMLDOMElementPtr spSiteRoot = CXMLTools::CreateSubNode( spXMLDoc, spRoot, L"WebSite" );
        CXMLTools::SetAttrib( spSiteRoot, L"SiteID", Convert::ToString( it->nSiteID ).c_str() );

        ExportSite( *it,
                    spXMLDoc,
                    spSiteRoot,
                    OutPkg,
                    shCryptKey.get(),
                    wszPassword );
    }

    STATE_CHANGE( this, estFinalizing, _variant_t(), _variant_t(), _variant_t() );

    WriteXmlToOutput(   spXMLDoc, 
                        shOutput.get(), 
                        ( nOptions & wpkgEncrypt ) ?  shCryptKey.get() : NULL );
    m_SitesToExport.clear();

// In DEBUG - write the XML file for testing purposes
#ifdef _DEBUG
    {
        spXMLDoc->save( _variant_t( L"c:\\Migr_export.xml" ) );
    }
#endif // _DEBUG
}


/* 
    Verifies ExportPackage input params
*/
void CExportPackage::ValidateExport(    LPCWSTR wszOutputFilename, 
                                        LPCWSTR wszPassword, 
                                        LPCWSTR wszComment,
                                        LONG /*nOptions*/ )
{
    // Check IIS Admin service state
    IF_FAILED_BOOL_THROW(   CTools::IsIISRunning(),
                            CBaseException( IDS_E_NO_IIS, ERROR_SUCCESS ) );

    IF_FAILED_BOOL_THROW(   ( wszOutputFilename != NULL ) && ( ::wcslen( wszOutputFilename ) < MAX_PATH ),
                            CBaseException( IDS_E_INVALIDARG, ERROR_SUCCESS ) );
    IF_FAILED_BOOL_THROW(   ( NULL == wszComment ) || ( ::wcslen( wszComment ) <= 1024 ),
                            CBaseException( IDS_E_INVALIDARG, ERROR_SUCCESS ) );
    
    // Empty passwords are not allowed
    IF_FAILED_BOOL_THROW(   ( wszPassword != NULL ) && ( ::wcslen( wszPassword ) > 0 ),
                            CBaseException( IDS_E_INVALIDARG, ERROR_SUCCESS) );
    if ( 0 == m_SitesToExport.size() )
    {
        throw CBaseException( IDS_E_NO_EXPORTSITES, ERROR_SUCCESS );
    }
}


/* 
    Writes all initial data to the XML file
*/
void CExportPackage::CreateXMLDoc(  BSTR bstrComment,
                                    IXMLDOMDocumentPtr& rspDoc,
                                    IXMLDOMElementPtr& rspRoot )
{
    IF_FAILED_HR_THROW( rspDoc.CreateInstance( CLSID_DOMDocument30 ),
                        CBaseException( IDS_E_NO_XML_PARSER ) );

    // Set the selection language to "XPath" or our selectNodes call will unexpectedly return no results
    IXMLDOMDocument2Ptr spI2 = rspDoc;
    IF_FAILED_HR_THROW( spI2->setProperty( _bstr_t( "SelectionLanguage" ), _variant_t( L"XPath" ) ),
                        CBaseException( IDS_E_XML_GENERATE ) );

    WCHAR       wszBuffer[ 64 ];        // Should be large enbough to hold two DWORD representations
    SYSTEMTIME  st    = { 0 };
    FILETIME    ft    = { 0 };
    
    // The time is stored as a file time.
    // At import time the filetime will be converted to DATE
    ::GetSystemTime( &st );
    VERIFY( ::SystemTimeToFileTime( &st,&ft ) );
    
    ::swprintf( wszBuffer, L"%u %u", ft.dwLowDateTime, ft.dwHighDateTime );

    // Create the root node
    IF_FAILED_HR_THROW( rspDoc->createElement( _bstr_t( L"IISMigrPkg" ), &rspRoot ),
                        CBaseException( IDS_E_XML_GENERATE ) );
    IF_FAILED_HR_THROW( rspDoc->appendChild( rspRoot, NULL ),
                        CBaseException( IDS_E_XML_GENERATE ) );
    // Set the attributes of the root node
    CXMLTools::SetAttrib( rspRoot, L"TimeCreated_UTC", wszBuffer );
    CXMLTools::SetAttrib( rspRoot, L"Comment", bstrComment );

    // Set local machine name
    CXMLTools::SetAttrib( rspRoot, L"Machine", CTools::GetMachineName().c_str() );

    // Local OS version
    CXMLTools::SetAttrib( rspRoot, L"OSVer", Convert::ToString( static_cast<DWORD>( CTools::GetOSVer() ) ).c_str() );
}


/*
    Creates and initializes the package output file.
    For more info about the file format used see the PkgFormat.txt ( part of this project )
*/
const TFileHandle CExportPackage::CreateOutputFile( LPCWSTR wszName, DWORD dwPkgOptions )
{
    TFileHandle shFile( ::CreateFile(    wszName,
                                        GENERIC_WRITE,
                                        0,
                                        NULL,
                                        CREATE_ALWAYS,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL ) );

    IF_FAILED_BOOL_THROW(   shFile.IsValid(),
                            CObjectException( IDS_E_OPENFILE, wszName ) );

    // Write a GUID at the begining of the file to mark it as a export package file
    CTools::WriteFile( shFile.get(), PKG_GUID, static_cast<DWORD>( ::wcslen( PKG_GUID ) * sizeof( WCHAR ) ) );

    // Write the package options
    CTools::WriteFile( shFile.get(), &dwPkgOptions, sizeof( DWORD ) );

    // The place where the XML data offset is written is hardcoded.
    // If you add variables before that offset, change the hardcoded value
    _ASSERT( POS_XMLDATA_OFFSET == CTools::GetFilePtrPos( shFile.get() ) );

    // Leave space for the offset in the file where the XML doc starts
    DWORDLONG nXMLOffset = 0;
    CTools::WriteFile( shFile.get(), &nXMLOffset, sizeof( __int64 ) );

    return shFile;
}



/*
    Generates random ( session ) key that will be used to encrypt the meta data
    Exports the key with the supplied password and stores it in the XML under spRoot
*/
const TCryptKeyHandle CExportPackage::GenCryptKeyData( HCRYPTPROV hCryptProv, 
                                                      LPCWSTR wszPassword,
                                                      const IXMLDOMDocumentPtr& spXMLDoc,
                                                      const IXMLDOMElementPtr& spRoot )
{
    _ASSERT( hCryptProv != NULL );
    _ASSERT( wszPassword != NULL );
    _ASSERT( spRoot != NULL );

    TCryptKeyHandle     shKey;
    TCryptKeyHandle     shKeyExch;
    TCryptHashHandle    shHash;
    
    DWORD                   dwSize        = 0;
    TByteAutoPtr            spKeyData;
    std::auto_ptr<WCHAR>    spString;

    // Geberate random key
    IF_FAILED_BOOL_THROW(   ::CryptGenKey(  hCryptProv,
                                            CALG_RC4,
                                            CRYPT_EXPORTABLE,
                                            &shKey ),
                            CBaseException( IDS_E_CRYPT_KEY_OR_HASH ) );

    // Create a hash to store the export pass
    IF_FAILED_BOOL_THROW(   ::CryptCreateHash(  hCryptProv,
                                                CALG_MD5,
                                                NULL,
                                                0,
                                                &shHash ),
                            CBaseException( IDS_E_CRYPT_KEY_OR_HASH ) );

    // Add the export passowrd to the hash
    IF_FAILED_BOOL_THROW(   ::CryptHashData(  shHash.get(),
                                              reinterpret_cast<const BYTE*>( wszPassword ),
                                              static_cast<DWORD>( ::wcslen( wszPassword ) * sizeof( WCHAR ) ),
                                              0 ),
                            CBaseException( IDS_E_CRYPT_KEY_OR_HASH ) );
        
    // Make a key from this hash ( this key will be used to export our encryption key )
    IF_FAILED_BOOL_THROW(   ::CryptDeriveKey(   hCryptProv,
                                                CALG_RC4,
                                                shHash.get(),
                                                0x00800000,    // 128bit RC4 key
                                                &shKeyExch ),
                            CBaseException( IDS_E_CRYPT_KEY_OR_HASH ) );
    
    // Get the key size
    ::CryptExportKey(   shKey.get(),
                        shKeyExch.get(),
                        SYMMETRICWRAPKEYBLOB,
                        0,
                        NULL,
                        &dwSize );
        
    _ASSERT( dwSize != 0 );

    // Alloc the mem
    spKeyData = TByteAutoPtr( new BYTE[ dwSize ] );

    // Get it
    IF_FAILED_BOOL_THROW(   ::CryptExportKey(   shKey.get(), 
                                                shKeyExch.get(),
                                                SYMMETRICWRAPKEYBLOB,
                                                0,
                                                spKeyData.get(),
                                                &dwSize ),
                            CBaseException( IDS_E_CRYPT_KEY_OR_HASH ) );

    CXMLTools::AddTextNode( spXMLDoc, 
                            spRoot, 
                            L"SessionKey", 
                            Convert::ToString( spKeyData.get(), dwSize ).c_str() );

    return shKey;
}


/* 
    Export and Web site to the package
*/
void CExportPackage::ExportSite(    const _SiteInfo& si, 
                                    const IXMLDOMDocumentPtr& spXMLDoc,
                                    const IXMLDOMElementPtr& spRoot,
                                    const COutPackage& OutPkg,
                                    HCRYPTKEY hCryptKey,
                                    LPCWSTR wszPassword )
{
    _ASSERT( wszPassword != NULL );
    _ASSERT( spRoot != NULL );
    
    // Open the site to be exported
    CIISSite Site( si.nSiteID );

    STATE_CHANGE( this, estSiteBegin, _variant_t( Site.GetDisplayName().c_str() ), _variant_t(), _variant_t() );
    
    // Export the config
    STATE_CHANGE( this, estExportingConfig, _variant_t(), _variant_t(), _variant_t() );

    // Export the config
    Site.ExportConfig( spXMLDoc, spRoot, hCryptKey );    

    // Export the certificate if we need to and if the site has one
    if ( !( si.nOptions & asNoCertificates ) && Site.HaveCertificate() )
    {    
        STATE_CHANGE( this, estExportingCertificate, _variant_t(), _variant_t(), _variant_t() );
        Site.ExportCert( spXMLDoc, spRoot, wszPassword );
    }

    // Export the content if we have to
    if ( !( si.nOptions & asNoContent ) )
    {
        ExportContent( si, spXMLDoc, spRoot, OutPkg );    
    }

    ExportPostProcess( si, spXMLDoc, spRoot, OutPkg );

    // Write the SID table to the XML.
    // This should be the last step in the export process as code may be added that exports security DACLs
    // Writing the SID table will reset it.This is done because SID table is Site related ( because each Web Site
    // can have different anonymous user )
    OutPkg.WriteSIDsToXML( si.nSiteID, spXMLDoc, spRoot );
    OutPkg.ResetSIDList();
}



void CExportPackage::ExportContent( const _SiteInfo& si,
                                    const IXMLDOMDocumentPtr& spXMLDoc,
                                    const IXMLDOMElementPtr& spRoot,
                                    const COutPackage& OutPkg )
{
    _ASSERT( spXMLDoc != NULL );
    _ASSERT( spRoot != NULL );

    // Create the node that will contain all content data
    IXMLDOMElementPtr spDataRoot = CXMLTools::CreateSubNode( spXMLDoc, spRoot, L"Content" );
    
    // Get all the root dirs that we will export.
    // The root dirs are all dirs that are assigned as virtual dirs in the metabase
    // spRoot is expected to be the site's root element in the XML
    // Here is the XPath to get the data from the XML
    // Metadata/IISConfigObject[ Custom[@ID=1002 ] and Custom = "IIsWebVirtualDir" ]/Custom[ @ID=3001 ]
    // How it works - the first part ( Metadata/IISConfigObject[ Custom[@ID=1002 ] and Custom = "IIsWebVirtualDir" ] )
    // selects all IISConfigObjects that are virtual dirs ( have Custom tag with ID=1002 ( NodeType ) )
    // and the value ( the NodeType ) is IIsWebVirtualDir
    // Then for these IISConfigObjects, it gets the CustomTags that contain the phisical path for the
    // VirtDir ( which is in the metadata with ID=3001 )
    // NOTE: IIsWebVirtualDir compraision in the XPath is CASE-SENSITIVE. I don't think the name will change
    // and it is the same for IIS4,5 and 6. However if the case varys, the XPath bellow may be used
    // Custom[translate(self::*, "iiswebvirtualdir", "IISWEBVIRTUALDIR") = "IISWEBVIRTUALDIR"
    IXMLDOMNodeListPtr    spVDirs;
    IXMLDOMNodePtr        spNode;

    STATE_CHANGE( this, estAnalyzingContent, _variant_t(), _variant_t(), _variant_t() );
    
    IF_FAILED_HR_THROW( spRoot->selectNodes( _bstr_t( L"Metadata/IISConfigObject[Custom[@ID=\"1002\"] and Custom=\"IIsWebVirtualDir\"]/Custom[@ID=\"3001\"]" ),
                                            &spVDirs ),
                        CBaseException( IDS_E_XML_PARSE ) );

    typedef std::list<std::pair<std::wstring,std::wstring> > TVDirsList;

    TVDirsList VDirs;    // Contains VDir names and paths to export content from

    // There should be at least one entry ( the site's root dir ) in the list
    // Put the paths in the string list
    while( S_OK == spVDirs->nextNode( &spNode ) )
    {
        CComBSTR bstrDir;
        IXMLDOMNodePtr spParent;

        IF_FAILED_HR_THROW( spNode->get_text( &bstrDir ),
                            CBaseException( IDS_E_XML_PARSE ) );

        // Get the parent ( IISConfigObject ) and get the VDir name
        IF_FAILED_HR_THROW( spNode->get_parentNode( &spParent ),
                            CBaseException( IDS_E_XML_PARSE ) );
        std::wstring strMBPath = CXMLTools::GetAttrib( spParent, L"Location" );
               
        VDirs.push_back( TVDirsList::value_type( strMBPath.c_str(), bstrDir.m_str ) );
    }

    // Now we have all folders that we need to extract.
    // However some of the virt dirs may point to a subdir of another VDir.
    // If we export them this way we will export part of the content twice
    // Analyze that and remove the redundant paths
    // ( the removed VDirs will be written to the XML but will not contain files/dirs
    RemoveRedundantPaths( /*r*/VDirs, spXMLDoc, spDataRoot );

    // Now in VDirs are only the paths that we need to extract

    // Collect statistics about the content, to be able to provide progress later
    DWORD dwSizeInKB    = 0;
    GetContentStat( VDirs, /*r*/m_dwContentFileCount, dwSizeInKB );

    for (   TVDirsList::const_iterator it = VDirs.begin();
            it != VDirs.end();
            ++it )
    {
        DWORDLONG nFilesSize = CDirTools::FilesSize( it->second.c_str(), CFindFile::ffGetFiles | CFindFile::ffRecursive );

        // Create the tag for this VDir
        IXMLDOMElementPtr spVDir = CXMLTools::CreateSubNode( spXMLDoc, spDataRoot, L"VirtDir" );
        CXMLTools::SetAttrib( spVDir, L"MBPath", it->first.c_str() );
        CXMLTools::SetAttrib( spVDir, L"Path", it->second.c_str() );
        CXMLTools::SetAttrib( spVDir, L"Size", Convert::ToString( nFilesSize ).c_str() );       

        // Extract the content
        DWORD dwOptions = COutPackage::afNone;

        if ( si.nOptions & asNoContentACLs )
        {
            dwOptions |= COutPackage::afNoDACL;
        }

        // Set the callback to receive notifications when files are added to the package
        OutPkg.SetCallback( _CallbackInfo( AddFileCallback, this ) );

        OutPkg.AddPath( it->second.c_str(), spXMLDoc, spVDir, dwOptions );

        // Remove the callback
        OutPkg.SetCallback( _CallbackInfo() );

    }
}



void CExportPackage::RemoveRedundantPaths(  std::list<std::pair<std::wstring,std::wstring> >& VDirs,
                                            const IXMLDOMDocumentPtr& spXMLDoc,
                                            const IXMLDOMElementPtr& spRoot )
{
    // Compare each with each path from the list
    // A path is considered redundant if it is a subdir of another dir in the list
    // I.e this is not a redundant dir:
    // Path1 = c:\Dirs\Something\whatever
    // Path2 = c:\Dirs\Something\anything
    // But this is:
    // Path1 = c:\Dirs\Something\anotherthing
    // Path2 = c:\Dirs\Something\anotherthing\whatever    - this is redundant

    typedef std::list<std::pair<std::wstring,std::wstring> > TVDirsList;
    IXMLDOMElementPtr spVDir;    

    for(    TVDirsList::iterator it1 = VDirs.begin();
            it1 != VDirs.end();
            ++it1 )
    {
        // Compare this path with all other paths
        // Start with the next path in the list
        TVDirsList::iterator it2 = it1;
        ++it2;
        
        while( it2 != VDirs.end() )
        {
            TVDirsList::iterator itToRemove = VDirs.end();

            // If they do not have anything in common - continue with the next
            switch( CDirTools::DoPathsNest( it1->second.c_str(), it2->second.c_str() ) )
            {
            case 1:    // it1 is subdir of it2
                itToRemove = it1;
                ++it1;
                // If we compare adjecent iterators, it1 will be it2 now. So move it
                if ( it1 == it2 ) ++it2;
                break;

            case 2: // it2 is subdir of it1
            case 3:    // it1 is the same as it2
                itToRemove = it2;
                ++it2;
                break;

            default:
                ++it2;
            }

            if ( itToRemove != VDirs.end() )
            {
                // Put itToRemove in the XML and remove it from the list
                spVDir = CXMLTools::CreateSubNode( spXMLDoc, spRoot, L"VirtDir" );
                CXMLTools::SetAttrib( spVDir, L"Name", itToRemove->first.c_str() );
                CXMLTools::SetAttrib( spVDir, L"Path", itToRemove->second.c_str() );

                VDirs.erase( itToRemove );
            }
        };
    }
}



void CExportPackage::ExportPostProcess( const _SiteInfo& si,
                                        const IXMLDOMDocumentPtr& spXMLDoc,
                                        const IXMLDOMElementPtr& spRoot,
                                        const COutPackage& OutPkg )
                                        
{
    // We must have at least one post-processing command to add
    // post-processing to this site
    // Note that it is normal to have commands, but to not have any files added to the site post-processing
    if ( si.listCommands.empty() ) return;

    // The number of progress steps - used for UI progress indicator
    long    nStepCount      = static_cast<long>( si.listCommands.size() + si.listFiles.size() );
    long    nCurrentStep    = 1;

    // Create the XML node under which all the post-process info will be stored
    IXMLDOMElementPtr spPP = CXMLTools::CreateSubNode( spXMLDoc, spRoot, L"PostProcess" );
                            
    // Write the post-process files to the output file
    for (   TStringList::const_iterator it = si.listFiles.begin();
            it != si.listFiles.end();
            ++it )
    {
        // Inform client for state change
        STATE_CHANGE(   this,
                        estExportingPostImport,
                        _variant_t( nCurrentStep++ ),
                        _variant_t( nStepCount ),
                        _variant_t( it->c_str() ) );

        // Write the file to the output
        OutPkg.AddFile( it->c_str(), spXMLDoc, spPP, COutPackage::afNoDACL );
    }
    
    // Add the commands to the XML
    for (   TCommands::const_iterator it = si.listCommands.begin();
            it != si.listCommands.end();
            ++it )
    {
        IXMLDOMElementPtr spEl = CXMLTools::CreateSubNode( spXMLDoc, spPP, L"Command" );
        
        // Inform client for state change
        STATE_CHANGE(   this,
                        estExportingPostImport,
                        _variant_t( nCurrentStep++ ),
                        _variant_t( nStepCount ),
                        _variant_t() );
        
        CXMLTools::SetAttrib( spEl, L"Text", it->strCommand.c_str() );
        CXMLTools::SetAttrib( spEl, L"Timeout" , Convert::ToString( it->dwTimeout ).c_str() );
        CXMLTools::SetAttrib( spEl, L"IgnoreErrors" , it->bIgnoreErrors ? L"True" : L"False" );
    }
}



CExportPackage::_SiteInfo& CExportPackage::GetSiteInfo( ULONG nSiteID )
{
    _ASSERT( nSiteID != 0 );

    // Get the SiteInfo for this site ID
    for (    TSitesList::iterator it = m_SitesToExport.begin();
            it != m_SitesToExport.end();
            ++it )
    {
        if ( it->nSiteID == nSiteID )
        {
            return *it;
        }
    }

    // If we are here - this SiteID is not included for export
    throw CBaseException( IDS_E_EXPORTSITE_NOTFOUND, ERROR_SUCCESS );
}



void CExportPackage::AddFileToSite( CExportPackage::_SiteInfo& rInfo, LPCWSTR wszFilePath )
{
    _ASSERT( wszFilePath != NULL );

    IF_FAILED_BOOL_THROW(   ::PathFileExistsW( wszFilePath ),
                            CObjectException( IDS_E_OPENFILE, wszFilePath ) );

    // Get only the filename and check if there is already a file with that name
    WCHAR wszFileName[ MAX_PATH + 1 ];
    ::wcsncpy( wszFileName, wszFilePath, MAX_PATH );
    ::PathStripPathW( wszFileName );

    TStringList& Files = rInfo.listFiles;

    // Check that there is no other file with the same filename
    for (   TStringList::iterator it = Files.begin();
            it != Files.end();
            ++it )
    {
        WCHAR wszCurrent[ MAX_PATH + 1 ];
        ::wcsncpy( wszCurrent, it->c_str(), MAX_PATH );
        ::PathStripPathW( wszCurrent );

        IF_FAILED_BOOL_THROW(    StrCmpIW( wszCurrent, wszFileName ) != 0,
                                CObjectException( IDS_E_PPFILE_EXISTS, wszFileName, wszFilePath ) );
    }

    // Add the file to the list
    Files.push_back( wszFilePath );
}



/*
    VDirs - list with VirtDirs to check for files
    rdwFileCount - total file count ( for all VDirs )
    rdwSizeInKB - total size of all files found in KB
*/
void CExportPackage::GetContentStat(    const std::list<std::pair<std::wstring,std::wstring> >& VDirs,
                                        DWORD& rdwFileCount,
                                        DWORD& rdwSizeInKB )
{
    rdwFileCount = rdwSizeInKB = 0;

    unsigned __int64    nSize       = 0;
    DWORD               dwFileCount = 0;

    typedef std::list<std::pair<std::wstring,std::wstring> > TVDirsList;

    for (   TVDirsList::const_iterator it = VDirs.begin();
            it != VDirs.end();
            ++it )
    {
        CFindFile           Search;
        WIN32_FIND_DATAW    fd              = { 0 };
        DWORDLONG           nCurrentSize    = 0;
        long                nCurrentCount   = 0;

        // Get the name of the current VDir and fire event for progrress
        LPCWSTR wszName = it->first.c_str();

        bool bFound = Search.FindFirst( it->second.c_str(),
                                        CFindFile::ffRecursive | CFindFile::ffGetFiles,
                                        NULL,
                                        &fd );
        while( bFound )
        {
            ++nCurrentCount;
            nCurrentSize += ( fd.nFileSizeHigh << 32 ) | fd.nFileSizeLow;

            STATE_CHANGE(   this, 
                            estAnalyzingContent, 
                            _variant_t( wszName ), 
                            _variant_t( nCurrentCount ),
                            _variant_t( nCurrentSize / 1024 ) );

            bFound = Search.Next( NULL, NULL, &fd );
        }

        nSize += nCurrentSize;
        dwFileCount += nCurrentCount;
    }

    rdwSizeInKB     = static_cast<DWORD>( nSize / 1024 );
    rdwFileCount    = dwFileCount;
}



void CExportPackage::WriteXmlToOutput(  const IXMLDOMDocumentPtr& spXmlDoc,
                                        HANDLE hOutputFile,
                                        HCRYPTKEY hCryptKey )
{
    _ASSERT( ( hOutputFile != NULL ) && ( hOutputFile != INVALID_HANDLE_VALUE ) );

    // Create IStream and use to store the content of the XML doc

    IStreamPtr    spIStream;
    IF_FAILED_HR_THROW( ::CreateStreamOnHGlobal( NULL, TRUE, &spIStream ),
                        CBaseException( IDS_E_OUTOFMEM, ERROR_SUCCESS ) );

    IF_FAILED_HR_THROW( spXmlDoc->save( _variant_t( spIStream.GetInterfacePtr() ) ),
                        CBaseException( IDS_E_OUTOFMEM, ERROR_SUCCESS ) );

    LARGE_INTEGER nOffset = { 0 };
    VERIFY( SUCCEEDED( spIStream->Seek( nOffset, STREAM_SEEK_SET, NULL ) ) );

    const DWORD BuffSize = 4 * 1024;
    BYTE btBuffer[ BuffSize ];

    ULONGLONG nCurrentPos = CTools::GetFilePtrPos( hOutputFile );
    ULONG nRead = 0;

    do
    {
        IF_FAILED_HR_THROW( spIStream->Read( btBuffer, BuffSize, &nRead ),
                            CObjectException( IDS_E_READFILE, L"<XML stream>" ) );

        if ( hCryptKey != NULL )
        {
            IF_FAILED_BOOL_THROW(	::CryptEncrypt(	hCryptKey, 
													NULL,
													nRead != BuffSize,
													0,
													btBuffer,
													&nRead,
													BuffSize ),
								    CObjectException( IDS_E_CRYPT_CRYPTO, L"<XML stream>" ) );
        }

        CTools::WriteFile( hOutputFile, btBuffer, nRead );
    }while( nRead == BuffSize );

    // Write the offset where the XML data starts
    // See CreateOutputFile for details about the hardcoded POS_XMLDATA_OFFSET
    IF_FAILED_BOOL_THROW(   ::SetFilePointer( hOutputFile, POS_XMLDATA_OFFSET, NULL, FILE_BEGIN ) != INVALID_SET_FILE_POINTER,
                            CBaseException( IDS_E_SEEK_PKG ) );

    CTools::WriteFile( hOutputFile, &nCurrentPos, sizeof( ULONGLONG ) );                                            
}


/* 
    This callback will be called by COutPkg before and after a file is added to the package
*/
void CExportPackage::AddFileCallback( void* pCtx, LPCWSTR wszFilename, bool bStart )
{
    static DWORD dwCurrentFile = 0;

    _ASSERT( pCtx != NULL );
    _ASSERT( wszFilename != NULL );

    // We handle only the start file event
    if ( bStart )
    {
        CExportPackage* pThis = reinterpret_cast<CExportPackage*>( pCtx );

        ++dwCurrentFile;

        STATE_CHANGE(   pThis, 
                        estExportingContent,
                        _variant_t( wszFilename ),
                        _variant_t( static_cast<LONG>( dwCurrentFile ) ),
                        _variant_t( static_cast<LONG>( pThis->m_dwContentFileCount ) ) );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\core\iishelpers.cpp ===
/*
****************************************************************************
|	Copyright (C) 2002  Microsoft Corporation
|
|	Component / Subcomponent
|		IIS 6.0 / IIS Migration Wizard
|
|	Based on:
|		http://iis6/Specs/IIS%20Migration6.0_Final.doc
|
|   Abstract:
|		IIS Metabase access classes implementation
|
|   Author:
|        ivelinj
|
|   Revision History:
|        V1.00	March 2002
|
****************************************************************************
*/
#include "StdAfx.h"
#include "IISHelpers.h"
#include "Utils.h"
#include "resource.h"


// CIISSite implementation
//////////////////////////////////////////////////////////////////////////////////
CIISSite::CIISSite( ULONG nSiteID, bool bReadOnly /*= true */ )
{
	IMSAdminBasePtr	spIABO;
	METADATA_HANDLE	hSite	= NULL;

	// Create the ABO
	IF_FAILED_HR_THROW(	spIABO.CreateInstance( CLSID_MSAdminBase ),
						CObjectException( IDS_E_CREATEINSTANCE, L"CLSID_MSAdminBase" ) );						

	// Open the site
	WCHAR wszSitePath[ MAX_PATH + 1 ];
	::swprintf( wszSitePath, L"LM/W3SVC/%u", nSiteID );

	HRESULT hr = spIABO->OpenKey(	METADATA_MASTER_ROOT_HANDLE,
									wszSitePath,
									bReadOnly ? METADATA_PERMISSION_READ : ( METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ ),
									KeyAccessTimeout,
									&hSite );

	if ( HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) == hr ) 
	{
		throw CBaseException( IDS_E_WEBNOTFOUND, ERROR_SUCCESS );
	}
	else if ( FAILED( hr ) )
	{
		throw CBaseException( IDS_E_SITEOPEN, hr );
	}

	m_spIABO.Attach( spIABO.Detach() );
	m_hSiteHandle = hSite;
}



CIISSite::~CIISSite()
{
	Close();
}



/*
	Creates a new empty web site entry in the metabase
    dwHint is the first ID to try.
	Returns the new SiteID
*/
DWORD CIISSite::CreateNew( DWORD dwHint /*=1*/ )
{
	// Creating new sites is available only on Server platforms
	_ASSERT( CTools::GetOSVer() & 1 );

	DWORD dwCurrentID = dwHint;
	WCHAR wszSitePath[ 64 ];	// Should be large enough for max DWORD value
	
	IMSAdminBasePtr	spIABO;
	METADATA_HANDLE	hData = NULL;

	// Create the ABO
	IF_FAILED_HR_THROW(	spIABO.CreateInstance( CLSID_MSAdminBase ),
						CObjectException( IDS_E_CREATEINSTANCE, L"CLSID_MSAdminBase" ) );

	// Open the W3SVC path
	IF_FAILED_HR_THROW(	spIABO->OpenKey(	METADATA_MASTER_ROOT_HANDLE,
											L"LM/W3SVC",
											METADATA_PERMISSION_WRITE,
											KeyAccessTimeout,
											&hData ),
						CObjectException( IDS_E_METABASE, L"LM/W3SVC" ) );

    HRESULT hr = E_FAIL;

	do
	{
		::swprintf( wszSitePath, L"%u", dwCurrentID++ );

		// Try to create this site id
		hr = spIABO->AddKey( hData, wszSitePath );
	}while( HRESULT_FROM_WIN32( ERROR_ALREADY_EXISTS ) == hr );

	VERIFY( SUCCEEDED( spIABO->CloseKey( hData ) ) );

	IF_FAILED_HR_THROW( hr, CObjectException( IDS_E_MD_ADDKEY, L"[NewSiteID]" ) );

    return dwCurrentID - 1;
}



void CIISSite::DeleteSite( DWORD dwSiteID )
{
	// Do not try to delete the default web
	_ASSERT( dwSiteID > 1 );

	WCHAR wszSitePath[ 64 ];
	
	IMSAdminBasePtr	spIABO;
	METADATA_HANDLE	hData = NULL;

	// Create the ABO
	IF_FAILED_HR_THROW(	spIABO.CreateInstance( CLSID_MSAdminBase ),
						CObjectException( IDS_E_CREATEINSTANCE, L"CLSID_MSAdminBase" ) );

	// Open the W3SVC path
	IF_FAILED_HR_THROW(	spIABO->OpenKey(	METADATA_MASTER_ROOT_HANDLE,
											L"LM/W3SVC",
											METADATA_PERMISSION_WRITE,
											KeyAccessTimeout,
											&hData ),
						CObjectException( IDS_E_METABASE, L"LM/W3SVC" ) );

	::swprintf( wszSitePath, L"%u", dwSiteID );

    HRESULT hr = spIABO->DeleteKey( hData, wszSitePath );

	VERIFY( SUCCEEDED( spIABO->CloseKey( hData ) ) );

	if ( FAILED( hr ) && ( hr != HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) ) )
	{
		throw CBaseException( IDS_E_METABASE_IO, hr );
	}
}



/*
	This methods writes the metabase data to the XML doc. spRoot is the XML element under which
	the data should be written. hEncryptKey is used to encrypt all secure properties.
	The crypt key may be null in which case the properties are exported in clear text ( that happens when
	the whole package will be encrypted )
*/
void CIISSite::ExportConfig(	const IXMLDOMDocumentPtr& spXMLDoc,
								const IXMLDOMElementPtr& spRoot,
								HCRYPTKEY hEncryptKey )const
{
	_ASSERT( spRoot != NULL );
	_ASSERT( m_hSiteHandle != NULL );	// Site must be opened first
	_ASSERT( m_spIABO != NULL );

	IXMLDOMElementPtr		spMDRoot;
	IXMLDOMElementPtr		spInheritRoot;

	// We will put the metadata under the XML tag <Metadata>
	// Under this node we will have <IISConfigObject> for each metakey under the site's root key
	// We will have one tag <MD_Inherit> bellow <Metadata>, where all the inheritable properties will be written
	// ( using the <Custom> tag )

	// Create our root node for metadata and the root node for inheritable data
	spMDRoot		= CXMLTools::CreateSubNode( spXMLDoc, spRoot, L"Metadata" );
	spInheritRoot	= CXMLTools::CreateSubNode( spXMLDoc, spMDRoot, L"MD_Inherit" );

	// We need a buffer for reading the metadata for each key
	// As there might be a lot of keys instead of allocating the buffer for each key
	// we will allocate it here and the ExportKey method will use it
	// ( ExportKey may modify the buffer. i.e. nake it bigger )
	DWORD dwDefaultBufferSize = 4 * 1024;
	TByteAutoPtr spBuffer( new BYTE[ dwDefaultBufferSize ] );

	// Export the current site config. This will export any subnodes as well
	// NOTE: this will not export inherited data
	ExportKey(	spXMLDoc, spMDRoot, hEncryptKey, L"", /*r*/spBuffer, /*r*/dwDefaultBufferSize );

	// Export ONLY the inheritable data
	// This will export all the data that the Site metadata key ( LM/W3SVC/### ) inherits from it's
	// parent ( LM/W3SVC )
	ExportInheritData( spXMLDoc, spInheritRoot, hEncryptKey, /*r*/spBuffer, /*r*/dwDefaultBufferSize );	

	// Remove any non-exportable data
	RemoveLocalMetadata( spRoot );
}


/*
	Exports the site's SSL certificate into the provided smart pointer
	Caller must check first if the site has SSL certificate with HaveCertificate method
*/
void CIISSite::ExportCert(	const IXMLDOMDocumentPtr& spDoc,
							const IXMLDOMElementPtr& spRoot,
							LPCWSTR wszPassword )const
{
	_ASSERT( m_spIABO != NULL );
	_ASSERT( m_hSiteHandle != NULL );
	_ASSERT( spRoot != NULL );
	_ASSERT( spDoc != NULL );
	_ASSERT( wszPassword != NULL );
	_ASSERT( HaveCertificate() );

	TCertContextHandle shCert( GetCert() );

    // Create a certificate store in memory. We will put the certificate in this mem store
    // and then export this mem store which will export the certificate as well
    TCertStoreHandle shMemStore( ::CertOpenStore(    CERT_STORE_PROV_MEMORY,
                                                    0,
                                                    0,
                                                    CERT_STORE_READONLY_FLAG,
                                                    NULL ) );
	IF_FAILED_BOOL_THROW(	shMemStore.IsValid(),
							CBaseException( IDS_E_OPEN_CERT_STORE ) );
	// Add our certificate to the mem store
	IF_FAILED_BOOL_THROW(	::CertAddCertificateContextToStore(	shMemStore.get(),
																shCert.get(),
																CERT_STORE_ADD_REPLACE_EXISTING,
																NULL ),
							CBaseException( IDS_E_ADD_CERT_STORE ) );

	// Add the certificate chain to the store
	// ( the certificate chain is all the certificates starting from this certificate up to a trusted,
	// self-signed certificate. We need to do this, as the root certificate may not be trusted on the target
	// machine and this will render the SSL certificate invalid (  not trusted )
	ChainCertificate( shCert.get(), shMemStore.get() );
    
	CRYPT_DATA_BLOB	Data = { 0 };

	// Get the size of the encrypted data
	::PFXExportCertStoreEx(	shMemStore.get(),
							&Data,
							wszPassword,
							NULL,
							EXPORT_PRIVATE_KEYS );
	_ASSERT( Data.cbData > 0 );

	// Alloc the space end get the data
    TByteAutoPtr spData = TByteAutoPtr( new BYTE[ Data.cbData ] );
    Data.pbData         = spData.get();

	IF_FAILED_BOOL_THROW(	::PFXExportCertStoreEx(	shMemStore.get(),
													&Data,
													wszPassword,
													NULL,
													EXPORT_PRIVATE_KEYS | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY ),
							CBaseException(	IDS_E_EXPORT_CERT ) );

	// Create the XML element to hold the certificate data 
    CXMLTools::AddTextNode( spDoc, 
                            spRoot, 
                            L"Certificate", 
                            Convert::ToString( spData.get(), Data.cbData ).c_str() );
}



void CIISSite::ImportConfig( const IXMLDOMNodePtr& spSite, HCRYPTKEY hDecryptKey, bool bImportInherited )const
{
    _ASSERT( spSite != NULL );

    IXMLDOMNodeListPtr  spPaths;
    IXMLDOMNodePtr      spConfig;
    IXMLDOMNodeListPtr  spValueList;
    IXMLDOMNodePtr      spValue;

    IF_FAILED_HR_THROW( spSite->selectNodes( _bstr_t( L"Metadata/IISConfigObject" ), &spPaths ),
                        CBaseException( IDS_E_XML_PARSE ) );

    while( S_OK == spPaths->nextNode( &spConfig ) )
    {
        std::wstring strLocation = CXMLTools::GetAttrib( spConfig, L"Location" );

        if ( !strLocation.empty() )
        {
            AddKey( strLocation.c_str() );
        }

        // Import every <Custom> tag in this Config object
        
        IF_FAILED_HR_THROW( spConfig->selectNodes( _bstr_t( L"Custom" ), &spValueList ),
                            CBaseException( IDS_E_XML_PARSE ) );
        while( S_OK == spValueList->nextNode( &spValue ) )
        {
            ImportMetaValue( spValue, strLocation.c_str(), hDecryptKey );
        }
    }

    // Import the inherited values
    if ( bImportInherited )
    {
        IF_FAILED_HR_THROW( spSite->selectNodes( _bstr_t( L"Metadata/MD_Inherit" ), &spValueList ),
                            CBaseException( IDS_E_XML_PARSE ) );

        while( S_OK == spValueList->nextNode( &spValue ) )
        {
            ImportMetaValue( spValue, NULL, hDecryptKey );
        };
    }
}



/*
	Copies currrent site name into wszName
	wszName must be at least METADATA_MAX_NAME_LEN + 1
*/
const std::wstring CIISSite::GetDisplayName()const
{
	_ASSERT( m_hSiteHandle != NULL );
	_ASSERT( m_spIABO != NULL );

	DWORD			dwUnsued	= 0;
	WCHAR			wszBuffer[ METADATA_MAX_NAME_LEN + 1 ];
	METADATA_RECORD	md			= { 0 };

	md.dwMDAttributes	= 0;
	md.dwMDIdentifier	= MD_SERVER_COMMENT;
	md.dwMDDataType		= ALL_METADATA;
	md.dwMDDataLen		= ( METADATA_MAX_NAME_LEN + 1 ) * sizeof( WCHAR );
	md.pbMDData			= reinterpret_cast<BYTE*>( wszBuffer );

	IF_FAILED_HR_THROW(	m_spIABO->GetData( m_hSiteHandle, NULL, &md, &dwUnsued ),
						CBaseException( IDS_E_METABASE_IO ) );

	return std::wstring( wszBuffer );
}



const std::wstring CIISSite::GetAnonUser()const
{
	_ASSERT( m_spIABO != NULL );
	_ASSERT( m_hSiteHandle != NULL );

	DWORD			dwSize	= 0;
	METADATA_RECORD	md		= { 0 };

	md.dwMDAttributes	= METADATA_INHERIT;
	md.dwMDIdentifier	= MD_ANONYMOUS_USER_NAME;
	md.dwMDDataType		= ALL_METADATA;
	md.dwMDDataLen		= 0;
	md.pbMDData			= NULL;

	VERIFY( FAILED( m_spIABO->GetData( m_hSiteHandle, NULL, &md, &dwSize ) ) );
	_ASSERT( dwSize > 0 );

	std::auto_ptr<WCHAR>	spBuffer( new WCHAR[ dwSize / sizeof( WCHAR ) ] );
	md.dwMDDataLen	= dwSize;
	md.pbMDData		= reinterpret_cast<BYTE*>( spBuffer.get() );

	IF_FAILED_HR_THROW(	m_spIABO->GetData( m_hSiteHandle, NULL, &md, &dwSize ),
						CBaseException( IDS_E_METABASE_IO ) );

    return std::wstring( spBuffer.get() );
}



/*
	Checks if the current IIS Site has a SSL certificate
*/
bool CIISSite::HaveCertificate()const
{
	_ASSERT( m_spIABO != NULL );
	_ASSERT( m_hSiteHandle != NULL );

	// Get the cert hash value from the metabase
	METADATA_RECORD	md			= { 0 };
	DWORD			dwHashSize	= 0;
	
	md.dwMDDataType		= ALL_METADATA;
	md.dwMDIdentifier	= MD_SSL_CERT_HASH;
		
	// Do not get the data - just check if it is there
	HRESULT hr = m_spIABO->GetData( m_hSiteHandle,
									NULL,
									&md,
									&dwHashSize );

	// If the data is not found - no SSL cert
	if ( FAILED( hr ) )
	{
		if ( MD_ERROR_DATA_NOT_FOUND == hr )
		{
			return false;
		}
		else if( hr != HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) )
		{
			// Unexpected error
			throw CBaseException( IDS_E_METABASE_IO, hr );
		}
		else
		{
			return true;
		}
	}

	// We can't get here - the above call should always fail
	_ASSERT( false );
	return false;
}



void CIISSite::BackupMetabase( LPCWSTR wszLocation /*=NULL */ )
{
    IMSAdminBasePtr	spIABO;	
	IF_FAILED_HR_THROW(	spIABO.CreateInstance( CLSID_MSAdminBase ),
						CObjectException( IDS_E_CREATEINSTANCE, L"CLSID_MSAdminBase" ) );	

	IF_FAILED_HR_THROW( spIABO->Backup(	wszLocation,
										MD_BACKUP_NEXT_VERSION,
										MD_BACKUP_SAVE_FIRST ),
						CBaseException( IDS_E_MDBACKUP ) );
}



void CIISSite::SetKeyData( LPCWSTR wszPath, DWORD dwID, DWORD dwUserType, LPCWSTR wszData )const
{
	_ASSERT( wszData != NULL );
	_ASSERT( m_hSiteHandle != NULL );
	_ASSERT( m_spIABO != NULL );

	METADATA_RECORD	md			= { 0 };	
	
	md.dwMDIdentifier	= dwID;
	md.dwMDDataType		= STRING_METADATA;
	md.dwMDUserType		= dwUserType;
	md.dwMDDataLen		= static_cast<DWORD>( ( ::wcslen( wszData ) + 1 ) * sizeof( WCHAR ) );
	md.pbMDData			= ( BYTE* )( wszData );

	IF_FAILED_HR_THROW(	m_spIABO->SetData( m_hSiteHandle, wszPath, &md ),
						CBaseException( IDS_E_METABASE_IO ) );
}



const std::wstring CIISSite::GetDefaultAnonUser()
{
	DWORD			dwSize	= 0;
	METADATA_RECORD	md		= { 0 };

	md.dwMDAttributes	= METADATA_INHERIT;
	md.dwMDIdentifier	= MD_ANONYMOUS_USER_NAME;
	md.dwMDDataType		= ALL_METADATA;
	md.dwMDDataLen		= 0;
	md.pbMDData			= NULL;

    IMSAdminBasePtr	spIABO;
	METADATA_HANDLE	hKey	= NULL;

	// Create the ABO
    IF_FAILED_HR_THROW( spIABO.CreateInstance( CLSID_MSAdminBase ),
                        CObjectException( IDS_E_CREATEINSTANCE, L"CLSID_MSAdminBase" ) );
    IF_FAILED_HR_THROW( spIABO->OpenKey(   METADATA_MASTER_ROOT_HANDLE,
                                            _bstr_t( L"LM/W3SVC" ),
                                            METADATA_PERMISSION_READ,
									        KeyAccessTimeout,
									        &hKey ),
                        CBaseException( IDS_E_METABASE_IO ) );
    
    VERIFY( FAILED( spIABO->GetData( hKey, NULL, &md, &dwSize ) ) );
    _ASSERT( dwSize > 0 );

    std::auto_ptr<WCHAR>    spBuffer( new WCHAR[ dwSize / sizeof( WCHAR ) ] );
    md.dwMDDataLen	= dwSize;
	md.pbMDData		= reinterpret_cast<BYTE*>( spBuffer.get() );

	HRESULT hr = spIABO->GetData( hKey, NULL, &md, &dwSize );

    VERIFY( SUCCEEDED( spIABO->CloseKey( hKey ) ) );

    IF_FAILED_HR_THROW( hr, CBaseException( IDS_E_METABASE_IO ) );

	return std::wstring( spBuffer.get() );
}



// Implementation
/////////////////////////////////////////////////////////////////////////////////////////
void CIISSite::ExportKey(	const IXMLDOMDocumentPtr& spDoc,
							const IXMLDOMElementPtr& spRoot,
							HCRYPTKEY hCryptKey,
							LPCWSTR wszNodePath,
							TByteAutoPtr& rspBuffer,
							DWORD& rdwBufferSize )const
{
	_ASSERT( m_hSiteHandle != NULL );
	_ASSERT( m_spIABO != NULL );
	_ASSERT( spDoc != NULL );
	_ASSERT( wszNodePath != NULL );
	_ASSERT( rdwBufferSize > 0 );
	_ASSERT( rspBuffer.get() != NULL );

	// Insert this key entry into the XML file
	IXMLDOMElementPtr spCurrentKey = CXMLTools::CreateSubNode( spDoc, spRoot, L"IISConfigObject" );
	CXMLTools::SetAttrib( spCurrentKey, L"Location", wszNodePath );

	WCHAR	wszSubKey[ METADATA_MAX_NAME_LEN + 1 ];
	
	// Write this node data to the XML
	ExportKeyData( spDoc, spCurrentKey, hCryptKey, wszNodePath, /*r*/rspBuffer, /*r*/rdwBufferSize );	
	
	// Enum any subkeys
	// They are not nested in the XML
	DWORD iKey = 0;
	while( true )
	{
		// Get the next keyname
		HRESULT hr = m_spIABO->EnumKeys( m_hSiteHandle, wszNodePath, wszSubKey, iKey++ );

		if ( FAILED( hr ) )
		{
            if ( HRESULT_FROM_WIN32( ERROR_NO_MORE_ITEMS ) == hr )	break;
			else throw CBaseException( IDS_E_METABASE_IO, hr );
		}

		WCHAR wszSubkeyPath[ METADATA_MAX_NAME_LEN + 1 ];
		::swprintf( wszSubkeyPath, L"%s/%s", wszNodePath, wszSubKey );
		
		// Export subkeys of the current subkey
		ExportKey( spDoc, spRoot, hCryptKey, wszSubkeyPath, /*r*/rspBuffer, /*r*/rdwBufferSize );
	}
}



void CIISSite::ExportInheritData(	const IXMLDOMDocumentPtr& spDoc,
									const IXMLDOMElementPtr& spInheritRoot, 
									HCRYPTKEY hEncryptKey,
									TByteAutoPtr& rspBuffer,
									DWORD& rdwBufferSize )const
{
	_ASSERT( spDoc != NULL );
	_ASSERT( spInheritRoot != NULL );
	_ASSERT( m_spIABO != NULL );
	_ASSERT( rspBuffer.get() != NULL );
	_ASSERT( rdwBufferSize > 0 );

	DWORD dwEntries	= 0;
	DWORD dwUnused	= 0; // DataSetNumber - we don't care
	
	while( true )
	{
		DWORD dwRequiredSize = rdwBufferSize;

        HRESULT hr = m_spIABO->GetAllData(	m_hSiteHandle,
											NULL,
											METADATA_SECURE | METADATA_INSERT_PATH | METADATA_INHERIT | METADATA_ISINHERITED,
											ALL_METADATA,
											ALL_METADATA,
											&dwEntries,
											&dwUnused,
											rdwBufferSize,
											rspBuffer.get(),
											&dwRequiredSize );
		// Increase the buffer if we need to
		if ( HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) == hr )
		{
			_ASSERT( dwRequiredSize > rdwBufferSize );
			rdwBufferSize = dwRequiredSize;
			rspBuffer = TByteAutoPtr( new BYTE[ rdwBufferSize ] );
			continue;
		}
		else if ( FAILED( hr ) )
		{
			throw CBaseException( IDS_E_METABASE_IO, hr );
		}
		else
		{
			// SUCCEEDED
			break;
		}
	};

	METADATA_GETALL_RECORD* aRecords = reinterpret_cast<METADATA_GETALL_RECORD*>( rspBuffer.get() );

	for ( DWORD i = 0; i < dwEntries; ++i )
	{
		// Store the record in the XML file only if this metadata is inherited from the parent
		if ( aRecords[ i ].dwMDAttributes & METADATA_ISINHERITED )
		{
			// Remove the inheritance attribs - we don't need them and ExportMetaRecord will
			// not recognize them
			aRecords[ i ].dwMDAttributes &= ~METADATA_ISINHERITED;

            // Set the inherit attrib as this is an inheritable data
            // ( event it is not now - it should be. At import time this data will be applied
            // to the WebSite root node as not-inherited but inheritable data
            aRecords[ i ].dwMDAttributes |= METADATA_INHERIT;

            ExportMetaRecord(	spDoc, 
								spInheritRoot, 
								hEncryptKey, 
								aRecords[ i ], 
								rspBuffer.get() + aRecords[ i ].dwMDDataOffset );	
		}
	}
}



void CIISSite::ExportKeyData(	const IXMLDOMDocumentPtr& spDoc,
								const IXMLDOMElementPtr& spKey,
								HCRYPTKEY hCryptKey,
								LPCWSTR wszNodePath,
								TByteAutoPtr& rspBuffer,
								DWORD& rdwBufferSize )const
{
	_ASSERT( wszNodePath != NULL );
	_ASSERT( spDoc != NULL );
	_ASSERT( spKey != NULL );
	_ASSERT( m_spIABO != NULL );
	_ASSERT( rspBuffer.get() != NULL );
	_ASSERT( rdwBufferSize > 0 );

	DWORD dwEntries	= 0;
	DWORD dwUnused	= 0; // DataSetNumber - we don't care
		
	do
	{
		DWORD dwRequiredSize = rdwBufferSize;

        HRESULT hr = m_spIABO->GetAllData(	m_hSiteHandle,
											wszNodePath,
											METADATA_SECURE | METADATA_INSERT_PATH,
											ALL_METADATA,
											ALL_METADATA,
											&dwEntries,
											&dwUnused,
											rdwBufferSize,
											rspBuffer.get(),
											&dwRequiredSize );
		// Increase the buffer if we need to
		if ( HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) == hr )
		{
			_ASSERT( dwRequiredSize > rdwBufferSize );
			rdwBufferSize = dwRequiredSize;
			rspBuffer = TByteAutoPtr( new BYTE[ rdwBufferSize ] );
			continue;
		}
		else if ( FAILED( hr ) )
		{
			throw CBaseException( IDS_E_METABASE_IO, hr );
		}
	}while( false );

	METADATA_GETALL_RECORD* aRecords = reinterpret_cast<METADATA_GETALL_RECORD*>( rspBuffer.get() );

	for ( DWORD i = 0; i < dwEntries; ++i )
	{
		// Store the record in the XML file
		ExportMetaRecord( spDoc, spKey, hCryptKey, aRecords[ i ], rspBuffer.get() + aRecords[ i ].dwMDDataOffset );	
	}
}



void CIISSite::DecryptData( HCRYPTKEY hDecryptKey, LPWSTR wszData )const
{
	_ASSERT( hDecryptKey != NULL );
	_ASSERT( wszData != NULL );

	TByteAutoPtr spData;
    DWORD dwSize = 0;

    Convert::ToBLOB( wszData, /*r*/spData, /*r*/dwSize );	

	// Decrypt data "in-place"
	// We are using stream cypher, so the length of the encrypted and decrypted string is the same
	IF_FAILED_BOOL_THROW(	::CryptDecrypt(	hDecryptKey,
											NULL,
											TRUE,
											0,
                                            spData.get(),
											&dwSize ),
							CBaseException( IDS_E_CRYPT_ENCRYPT ) );
	
	_ASSERT( ::wcslen( wszData ) * sizeof( WCHAR ) == dwSize );

	::CopyMemory( wszData, spData.get(), dwSize );
}



/*
	Returns the Site's SSL certificate context hanlde
*/
const TCertContextHandle CIISSite::GetCert()const
{
	_ASSERT( m_spIABO != NULL );
	_ASSERT( m_hSiteHandle != NULL );
	_ASSERT( HaveCertificate() );

	// Get the cert hash value from the metabase
	METADATA_RECORD	md			= { 0 };
	DWORD			dwHashSize	= 0;
	TByteAutoPtr	spHash;

	md.dwMDDataType		= ALL_METADATA;
	md.dwMDIdentifier	= MD_SSL_CERT_HASH;
		
	// Do not get the data - just check if it is there
	HRESULT hr = m_spIABO->GetData( m_hSiteHandle,
									NULL,
									&md,
									&dwHashSize );

	// We should find the cert - HaveCertificate() is expected to be called prior this method
	if ( FAILED( hr ) )
	{
		if( hr != HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) )
		{
			// Unexpected error
			throw CBaseException( IDS_E_METABASE_IO, hr );
		}
		else
		{
			// Alloc space for the hash
			_ASSERT( dwHashSize > 0 );
			spHash			= TByteAutoPtr( new BYTE[ dwHashSize ] );
			md.dwMDDataLen	= dwHashSize;
			md.pbMDData		= spHash.get();
		}
	}

	IF_FAILED_HR_THROW(	m_spIABO->GetData(	m_hSiteHandle,
											NULL,
											&md,
											&dwHashSize ),
						CBaseException( IDS_E_METABASE_IO ) );

	// Get the certificate from the store
	// The store that keeps the certificates that have assosiated private keys
	// is the system store named "MY"
	TCertStoreHandle shStore( ::CertOpenStore(	CERT_STORE_PROV_SYSTEM,
												0,		// Unused for the current store type
												NULL,	// Deafult crypt provider
												CERT_SYSTEM_STORE_LOCAL_MACHINE,
												L"MY" ) );

	IF_FAILED_BOOL_THROW(	shStore.IsValid(),
							CBaseException( IDS_E_OPEN_CERT_STORE ) );

	// Find the certificate in the store
	CRYPT_HASH_BLOB	Hash;
	Hash.cbData = md.dwMDDataLen;
	Hash.pbData	= spHash.get();
	TCertContextHandle shCert( ::CertFindCertificateInStore(	shStore.get(),
															    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
															    0,
															    CERT_FIND_HASH,
															    &Hash,
															    NULL ) );
	IF_FAILED_BOOL_THROW(	shCert.IsValid(),
							CBaseException( IDS_E_FIND_SSL_CERT ) );

	return shCert;
}


/*
	Adds hCert certificate chain to hStore
*/
void CIISSite::ChainCertificate( PCCERT_CONTEXT hCert, HCERTSTORE hStore )const
{
	_ASSERT( hCert != NULL );
	_ASSERT( hStore != NULL );

	TCertChainHandle    shCertChain;

	// Use default chain parameters
	CERT_CHAIN_PARA CertChainPara = { sizeof( CERT_CHAIN_PARA ) };

    IF_FAILED_BOOL_THROW(	::CertGetCertificateChain(	HCCE_LOCAL_MACHINE,
														hCert,
														NULL,
														NULL,
														&CertChainPara,
														0,
														NULL,
														&shCertChain ),
							CBaseException( IDS_E_CERT_CHAIN ) );

	// There must be at least on simple chain
	_ASSERT( shCertChain.get()->cChain != 0 );

	unsigned i = 0;
	while( i < shCertChain.get()->rgpChain[ 0 ]->cElement )
	{
		PCCERT_CONTEXT		hCurrentCert = shCertChain.get()->rgpChain[ 0 ]->rgpElement[ i ]->pCertContext;
		TCertContextHandle	shTempCert; 

		// Add it to the store
		IF_FAILED_BOOL_THROW(	::CertAddCertificateContextToStore(	hStore,
																	hCurrentCert,
																	CERT_STORE_ADD_REPLACE_EXISTING,
																	&shTempCert ),
								CBaseException( IDS_E_ADD_CERT_STORE ) );

		// As this code is used for the SSL certificate ( the hCert )
		// we don't need any root certificates' private keys
		VERIFY( ::CertSetCertificateContextProperty( shTempCert.get(), CERT_KEY_PROV_INFO_PROP_ID, 0, NULL ) );

		++i;
	};
}



void CIISSite::Close()
{
	if ( m_hSiteHandle != NULL )
	{
		_ASSERT( m_spIABO != NULL );

		VERIFY( SUCCEEDED( m_spIABO->CloseKey( m_hSiteHandle ) ) );
		m_spIABO		= NULL;
		m_hSiteHandle	= NULL;
	}
}



void CIISSite::AddKey( LPCWSTR wszKey )const
{
	_ASSERT( ( m_spIABO != NULL ) && ( m_hSiteHandle != NULL ) );
	_ASSERT( ( wszKey != NULL ) && ( ::wcslen( wszKey ) > 0 ) );

	HRESULT hr = m_spIABO->AddKey( m_hSiteHandle, wszKey );

	if ( FAILED( hr ) && ( hr != HRESULT_FROM_WIN32( ERROR_ALREADY_EXISTS ) ))
	{
		throw CObjectException( IDS_E_MD_ADDKEY, wszKey, hr );
	}
}



/* 
	Writes a MD record to the XML
*/
void CIISSite::ExportMetaRecord(	const IXMLDOMDocumentPtr& spDoc,
									const IXMLDOMElementPtr& spKey,
									HCRYPTKEY hCryptKey, 
									const METADATA_GETALL_RECORD& Data,
									void* pvData )const
{
	_ASSERT( spDoc != NULL );
	_ASSERT( spKey != NULL );
	
	// Skip this types of metadata:
	//	1. Volitile data
	if ( Data.dwMDAttributes & METADATA_VOLATILE ) return;
	
	// We handle only these types of attributes - METADATA_SECURE, METADATA_INHERIT
	// All other should not exist
	_ASSERT(	( Data.dwMDAttributes & METADATA_SECURE ) ||
				( Data.dwMDAttributes & METADATA_INHERIT ) ||
				( Data.dwMDAttributes == METADATA_NO_ATTRIBUTES ) );

	// Encrypt secure data if we need to
	if ( ( hCryptKey != NULL ) && ( Data.dwMDAttributes & METADATA_SECURE ) )
	{
		DWORD dwSize = Data.dwMDDataLen;

		IF_FAILED_BOOL_THROW(	::CryptEncrypt(	hCryptKey,
												NULL,
												TRUE,
												0,
												reinterpret_cast<BYTE*>( pvData ),
												&dwSize,
												Data.dwMDDataLen ),
								CBaseException( IDS_E_CRYPT_ENCRYPT ) );
		_ASSERT( dwSize == Data.dwMDDataLen );
	}

	IXMLDOMElementPtr spEl;

	// Create the node
	// 1. Empty data
    if ( ( NULL == pvData ) || ( 0 == Data.dwMDDataLen ) )
	{
		spEl = CXMLTools::AddTextNode( spDoc, spKey, L"Custom", L"" );
	}
	// 2. Secure and binary data ( secure data is written in binary format )
	else if ( ( BINARY_METADATA == Data.dwMDDataType ) || ( Data.dwMDAttributes & METADATA_SECURE ) )
	{
        spEl = CXMLTools::AddTextNode(	spDoc, 
										spKey, 
										L"Custom", 
                                        Convert::ToString( reinterpret_cast<BYTE*>( pvData ), Data.dwMDDataLen ).c_str() );
	}
	else if ( DWORD_METADATA == Data.dwMDDataType )
	{
		_ASSERT( sizeof( DWORD ) == Data.dwMDDataLen );
        spEl = CXMLTools::AddTextNode(  spDoc, 
                                        spKey, 
                                        L"Custom", 
                                        Convert::ToString( *( reinterpret_cast<DWORD*>( pvData ) ) ).c_str() );
	}
	else if ( STRING_METADATA == Data.dwMDDataType )
	{
		spEl = CXMLTools::AddTextNode( spDoc, spKey, L"Custom", reinterpret_cast<LPCWSTR>( pvData ) );
	}
	else if ( ( MULTISZ_METADATA == Data.dwMDDataType ) || ( EXPANDSZ_METADATA == Data.dwMDDataType ) )
	{
		// Convert to data to single string with spaces instead of string terminators
		LPWSTR wszData = reinterpret_cast<LPWSTR>( pvData );
		MultiStrToString( /*r*/wszData );
		
		spEl = CXMLTools::AddTextNode( spDoc, spKey, L"Custom", wszData );
	}
	else
	{
		// Unexpected MD type
		_ASSERT( false );
	}

	// Set the properties
    CXMLTools::SetAttrib( spEl, L"ID", Convert::ToString( Data.dwMDIdentifier ).c_str() );
	CXMLTools::SetAttrib( spEl, L"UserType", Convert::ToString( Data.dwMDUserType ).c_str() );
	CXMLTools::SetAttrib( spEl, L"Type", Convert::ToString( Data.dwMDDataType ).c_str() );
	CXMLTools::SetAttrib( spEl, L"Attributes", Convert::ToString( Data.dwMDAttributes ).c_str() );
}


/*
	Remove from the config XML all data that should not be imported
	spRoot is expected to be the <WebSite> node
*/
void CIISSite::RemoveLocalMetadata( const IXMLDOMElementPtr& spRoot )const
{
	struct _Helper
	{
		LPCWSTR wszPath;
		DWORD	dwID;
	};

	// First param is the Path ( the meta key, exactly as it will be written in the 'Location' attribute
	// of the IISConfigObject tag ).
	// Second param = the ID of the property to be removed ( ID attribute of the Custom tag )

	_Helper aData[] =	{	{ L"", MD_SSL_CERT_HASH },	// Cert hash
                            { L"", MD_SSL_CERT_STORE_NAME }	// Cert store name
						};

	for ( DWORD i = 0; i <  ARRAY_SIZE( aData ); ++i )
	{
		WCHAR wszXPath[ 1024 ];

		::swprintf( wszXPath, 
					L"Metadata/IISConfigObject[@Location=\"%s\"]/Custom[@ID=\"%u\"]",
					aData[ i ].wszPath,
					aData[ i ].dwID );

		CXMLTools::RemoveNodes( spRoot, wszXPath );
	}
}



void CIISSite::ImportMetaValue( const IXMLDOMNodePtr& spValue,
                                LPCWSTR wszLocation,
                                HCRYPTKEY hDecryptKey )const
{
    // Location and Decrypt key are valid to be NULL
    _ASSERT( spValue != NULL );

    METADATA_RECORD md = { 0 };

    md.dwMDIdentifier   = Convert::ToDWORD( CXMLTools::GetAttrib( spValue, L"ID" ).c_str() );
    md.dwMDAttributes   = Convert::ToDWORD( CXMLTools::GetAttrib( spValue, L"Attributes" ).c_str() );
    md.dwMDDataType     = Convert::ToDWORD( CXMLTools::GetAttrib( spValue, L"Type" ).c_str() );
    md.dwMDUserType     = Convert::ToDWORD( CXMLTools::GetAttrib( spValue, L"UserType" ).c_str() );

    CComBSTR    bstrData;
    IF_FAILED_HR_THROW( spValue->get_text( &bstrData ),
                        CBaseException( IDS_E_XML_PARSE ) );
    
    // If the data is secure and we have DecryptKey - then it was encrypted and we should decrypt it
    if ( ( md.dwMDAttributes & METADATA_SECURE ) && ( hDecryptKey != NULL ) )
    {
        // This will decrypt the data in-place
        DecryptData( hDecryptKey, /*r*/bstrData.m_str );
    }

    TByteAutoPtr    spBinData;
    DWORD			dwDWORDData	= 0;

    // There may not be any data. Just the key
	if ( bstrData.Length() > 0 )
	{
        DWORD	        dwMultiSzLen	= 0;
        
		switch( md.dwMDDataType )
		{
		case BINARY_METADATA:
            Convert::ToBLOB( bstrData.m_str, /*r*/spBinData, /*r*/md.dwMDDataLen  );
			md.pbMDData = spBinData.get();
			break;

		case DWORD_METADATA:
            dwDWORDData		= Convert::ToDWORD( bstrData.m_str );
			md.pbMDData		= reinterpret_cast<BYTE*>( &dwDWORDData );
			md.dwMDDataLen	= sizeof( DWORD );
			break;

		case STRING_METADATA:
			md.pbMDData		= reinterpret_cast<BYTE*>( bstrData.m_str );
			md.dwMDDataLen	= static_cast<DWORD>( ( ::wcslen( bstrData ) + 1 ) * sizeof( WCHAR ) );
			break;

		case MULTISZ_METADATA:
			// Multistrings are stored in the XML separated with space
			// Convert this to strings, separated with '\0' and the whole sequence must
			// be terminated with double '\0'

			XMLToMultiSz( /*r*/bstrData, dwMultiSzLen );
			md.pbMDData		= reinterpret_cast<BYTE*>( bstrData.m_str );
			md.dwMDDataLen	= dwMultiSzLen * sizeof( WCHAR );
			break;		

		default:
			_ASSERT( false );
		};
	}//if ( bstrData.Length() > 0 )
	else
	{
		// Empty data. However we need a valid pointer
		// Use the DWORD var
		md.pbMDData		= reinterpret_cast<BYTE*>( &dwDWORDData );
		md.dwMDDataLen	= 0;
	}

	// Set the data in the metabase
	IF_FAILED_HR_THROW(	m_spIABO->SetData(	m_hSiteHandle,
											wszLocation,
											&md ),
						CObjectException( IDS_E_METABASE, wszLocation ) );
}



void CIISSite::MultiStrToString( LPWSTR wszData )const
{
	_ASSERT( wszData != NULL );
	
	LPWSTR wszString = wszData;
		
	// Replace each '\0' with space. leave only the final one
	bool bExit = false;
	do
	{
		if ( L'\0' == *wszString )
		{
			*wszString = L' ';
			bExit = *( wszString + 1 ) == L'\0';
		}

		++wszString;
	}while( !bExit );
}









void CIISSite::XMLToMultiSz( CComBSTR& rbstrData, DWORD& rdwSize )const
{
	_ASSERT( rbstrData != NULL );

	// We need one more '\0' at the end of the string, 'cause the sequence must 
	// be double '\0' terminated

	// This will reallocate the buffer ( the buffer will be one more symbol wider )
	// and will add one more '\0' at the end
    DWORD   dwSize  = static_cast<DWORD>( ::wcslen( rbstrData ) + 2 );
	BSTR    bstrNew = ::SysAllocStringLen( rbstrData, dwSize - 1 ); // This fun adds one smore char. see docs for details

	if ( NULL == bstrNew ) throw CBaseException( IDS_E_OUTOFMEM, ERROR_SUCCESS );

	// Convert all spaces ( ' ' ) to '\0'
	DWORD	iChar	= 0;
	while( bstrNew[ iChar ] != L'\0' )
	{
        if ( L' ' == bstrNew[ iChar ] )
		{
			bstrNew[ iChar ] = L'\0';		
		}

		++iChar;
	};

    // Assign the new value to the result
	// Operator = cannot be used as it will do a SysAllocString and thus, the final '\0' will be lost
	rbstrData.Empty();
	rbstrData.Attach( bstrNew );
    rdwSize = dwSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\core\exportpackage.h ===
/*
****************************************************************************
|    Copyright (C) 2002  Microsoft Corporation
|
|    Component / Subcomponent
|        IIS 6.0 / IIS Migration Wizard
|
|    Based on:
|        http://iis6/Specs/IIS%20Migration6.0_Final.doc
|
|   Abstract:
|        ExportPackage COM class implementation
|
|   Author:
|        ivelinj
|
|   Revision History:
|        V1.00    March 2002
|
****************************************************************************
*/
#pragma once
#include "resource.h"
#include "IISMigrTool.h"
#include "Utils.h"
#include "PkgHandlers.h"
#include "_IExportEvents_CP.H"


// CExportPackage - COM class for IExportPackage interface
/////////////////////////////////////////////////////////////////////////////////////////
class CExportPackage : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CExportPackage, &CLSID_ExportPackage>,
    public IDispatchImpl<IExportPackage, &IID_IExportPackage, &LIBID_IISMigrToolLib, /*wMajor =*/ 1, /*wMinor =*/ 0>,
    public IConnectionPointContainerImpl<CExportPackage>,
    public CProxy_IExportEvents<CExportPackage>,
    public ISupportErrorInfoImpl<&IID_IExportPackage>
{
// COM Map
BEGIN_COM_MAP(CExportPackage)
    COM_INTERFACE_ENTRY(IExportPackage)
    COM_INTERFACE_ENTRY(IDispatch)    
    COM_INTERFACE_ENTRY(IConnectionPointContainer)
    COM_INTERFACE_ENTRY( ISupportErrorInfo )
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CExportPackage)
    CONNECTION_POINT_ENTRY(__uuidof(_IExportEvents))
END_CONNECTION_POINT_MAP()

DECLARE_REGISTRY_RESOURCEID( IDR_EXPORTPACKAGE )


// Data types
public:
    struct _CmdInfo
    {
        std::wstring    strCommand;
        DWORD           dwTimeout;    // In seconds            
        bool            bIgnoreErrors;
    };

    typedef std::list<_CmdInfo>    TCommands;

private:
    
    struct _SiteInfo
    {
        ULONG            nSiteID;       // SiteID
        ULONG            nOptions;      // Export options
        TStringList      listFiles;     // Post-process files
        TCommands        listCommands;  // Post process commands
    };


    typedef std::list<_SiteInfo>    TSitesList;


// Construction / Destruction
public:
    CExportPackage                  (    void );
    

// IExportPackage methods
public:
    STDMETHOD( get_SiteCount )      (   /*[out, retval]*/ SHORT* pVal);
    STDMETHOD( AddSite )            (   /*[in]*/ LONG SiteID, /*[in]*/ LONG nOptions );
    STDMETHOD( PostProcessAddFile ) (   /*[in]*/LONG nSiteID, /*[in]*/BSTR bstrFilePath );
    STDMETHOD( PostProcessAddCommand)(  /*[in]*/LONG nSiteID, 
                                        /*[in]*/BSTR bstrCommand,
                                        /*[in]*/LONG nTimeout,
                                        /*[in]*/VARIANT_BOOL bIgnoreErrors );
    STDMETHOD( WritePackage )       (   /*[in]*/ BSTR bstrOutputFilename, 
                                        /*[in]*/ BSTR bstrPassword, 
                                        /*[in]*/ LONG nOptions,
                                        /*[in]*/ BSTR bstrComment );


// Implementation
private:
    void        WritePackageImpl    (   LPCWSTR bstrOutputFile, 
                                        LPCWSTR wszPassword,
                                        BSTR bstrComment,
                                        LONG nOptions );
    void        ValidateExport      (   LPCWSTR wszOutputFilename, 
                                        LPCWSTR wszPassword, 
                                        LPCWSTR wszComment,
                                        LONG nOptions );
    void        CreateXMLDoc        (   BSTR bstrComment, 
                                        IXMLDOMDocumentPtr& rspDoc,
                                        IXMLDOMElementPtr& rspRoot );
    const TFileHandle CreateOutputFile   (  LPCWSTR wszName, DWORD dwPkgOptions );
    const TCryptKeyHandle GenCryptKeyPkg (  HCRYPTPROV hCryptProv, LPCWSTR wszPassword );
    const TCryptKeyHandle GenCryptKeyData(  HCRYPTPROV hCryptProv, 
                                        LPCWSTR wszPassword,
                                        const IXMLDOMDocumentPtr& spXMLDoc,
                                        const IXMLDOMElementPtr& spRoot );
    void        ExportSite          (   const _SiteInfo& si, 
                                        const IXMLDOMDocumentPtr& spXMLDoc,
                                        const IXMLDOMElementPtr& spRoot,
                                        const COutPackage& OutPkg,
                                        HCRYPTKEY hCryptKey,
                                        LPCWSTR wszPassword );
    void        ExportContent       (   const _SiteInfo& si,
                                        const IXMLDOMDocumentPtr& spXMLDoc,
                                        const IXMLDOMElementPtr& spRoot,
                                        const COutPackage& OutPkg );
    void        RemoveRedundantPaths(   std::list<std::pair<std::wstring,std::wstring> >& VDirs,
                                        const IXMLDOMDocumentPtr& spXMLDoc,
                                        const IXMLDOMElementPtr& spRoot );
    void        ExportPostProcess   (   const _SiteInfo& si,
                                        const IXMLDOMDocumentPtr& spXMLDoc,
                                        const IXMLDOMElementPtr& spRoot,
                                        const COutPackage& OutPkg );
    void        ExportPPFiles       (   const _SiteInfo& si,
                                        const IXMLDOMDocumentPtr& spXMLDoc,
                                        const IXMLDOMElementPtr& spRoot,
                                        HANDLE hOutputFile );
    _SiteInfo&    GetSiteInfo       (   ULONG nSiteID );
    void        AddFileToSite       (  _SiteInfo& rInfo, LPCWSTR wszFileName );
    void        GetContentStat      (   const std::list<std::pair<std::wstring,std::wstring> >& VDirs,
                                        DWORD& rdwFileCount,
                                        DWORD& rdwSizeInKB );
    void        WriteXmlToOutput    (   const IXMLDOMDocumentPtr& spXmlDoc,
                                        HANDLE hOutputFile,
                                        HCRYPTKEY hEncryptKey );

    static void AddFileCallback     (   void* pCtx, LPCWSTR wszFilename, bool bStartFile );
            
        

// Data members
private:
    TSitesList                      m_SitesToExport;
    DWORD                           m_dwContentFileCount;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\core\iishelpers.h ===
/*
****************************************************************************
|	Copyright (C) 2002  Microsoft Corporation
|
|	Component / Subcomponent
|		IIS 6.0 / IIS Migration Wizard
|
|	Based on:
|		http://iis6/Specs/IIS%20Migration6.0_Final.doc
|
|   Abstract:
|		IIS Metabase interface helper
|
|   Author:
|        ivelinj
|
|   Revision History:
|        V1.00	March 2002
|
****************************************************************************
*/
#pragma once

#include "Wrappers.h"


// Class for an IIS Web Site
class CIISSite
{
// Data types
private:
	enum
	{
		KeyAccessTimeout	= 2000		// 2sec
	};
	
public:
	CIISSite							(	ULONG nSiteID, bool bReadOnly = true );
	~CIISSite							(	void );

// Class Interface
public:
	void			Close				(	void );
	void			AddKey				(	LPCWSTR wszKey )const;
	void			ExportConfig		(	const IXMLDOMDocumentPtr& spDoc,
											const IXMLDOMElementPtr& spRoot,
											HCRYPTKEY hEncryptKey )const;
	void			ExportCert			(	const IXMLDOMDocumentPtr& spDoc,
											const IXMLDOMElementPtr& spRoot,
											LPCWSTR wszPassword )const;
    void			ImportConfig		(	const IXMLDOMNodePtr& spSite, 
                                            HCRYPTKEY hDecryptKey,
                                            bool bImportInherited )const;
	const std::wstring	GetDisplayName	(   void )const;
    const std::wstring  GetAnonUser     (   void )const;
	bool			HaveCertificate		(	void )const;
	static void	    BackupMetabase		(	LPCWSTR wszLocation = NULL );
	static DWORD	CreateNew			(	DWORD dwHint = 1 );
	static void		DeleteSite			(	DWORD dwSiteID );
    static const std::wstring GetDefaultAnonUser( void );
	

// Implementation
private:
	void			SetKeyData			(	LPCWSTR wszPath, 
											DWORD dwID, 
											DWORD dwUserType,
											LPCWSTR wszData )const;
	void			ExportKey			(	const IXMLDOMDocumentPtr& spDoc,
											const IXMLDOMElementPtr& spRoot,
											HCRYPTKEY hCryptKey,
											LPCWSTR wszNodePath,
											TByteAutoPtr& rspBuffer,
											DWORD& rdwBufferSize )const;
	void			ExportInheritData	(	const IXMLDOMDocumentPtr& spXMLDoc,
											const IXMLDOMElementPtr& spInheritRoot, 
											HCRYPTKEY hEncryptKey,
											TByteAutoPtr& rspBuffer,
											DWORD& rdwBufferSize )const;
	void			ExportKeyData		(	const IXMLDOMDocumentPtr& spDoc,
											const IXMLDOMElementPtr& spKey,
											HCRYPTKEY hCryptKey,
											LPCWSTR wszNodePath, 
											TByteAutoPtr& rspBuffer,
											DWORD& rdwBufferSize )const;
	void			ExportMetaRecord	(	const IXMLDOMDocumentPtr& spDoc,
											const IXMLDOMElementPtr& spKey,
											HCRYPTKEY hCryptKey, 
											const METADATA_GETALL_RECORD& Data,
											void* pvData )const;
	void			RemoveLocalMetadata	(	const IXMLDOMElementPtr& spRoot )const;
    void            ImportMetaValue     (   const IXMLDOMNodePtr& spValue,
                                            LPCWSTR wszLocation,
                                            HCRYPTKEY hDecryptKey )const;
	void			DecryptData			(	HCRYPTKEY hDecryptKey,
											LPWSTR wszData )const;
	const TCertContextHandle GetCert	(	void )const;
	void			ChainCertificate	(	PCCERT_CONTEXT hCert, HCERTSTORE hStore )const;

	// Conversion helpers
	void			MultiStrToString	(	LPWSTR wszData )const;
	void			XMLToMultiSz		(	CComBSTR& bstrData, DWORD& rdwSize )const;


// Data members
private:
	METADATA_HANDLE						m_hSiteHandle;
	IMSAdminBasePtr						m_spIABO;

// Restricted
private:
	CIISSite( const CIISSite& );
	void operator =( const CIISSite& );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\core\iismigrtool.cpp ===
/*
****************************************************************************
|	Copyright (C) 2002  Microsoft Corporation
|
|	Component / Subcomponent
|		IIS 6.0 / IIS Migration Wizard
|
|	Based on:
|		http://iis6/Specs/IIS%20Migration6.0_Final.doc
|
|   Abstract:
|		DLL support code
|
|   Author:
|        ivelinj
|
|   Revision History:
|        V1.00	March 2002
|
****************************************************************************
*/

#include "stdafx.h"
#include "resource.h"
#include "IISMigrTool.h"
#include "IISMigrTool_i.c"
#include "ExportPackage.h"
#include "ImportPackage.h"
#include <new.h>


CComModule _Module;


BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY( CLSID_ExportPackage, CExportPackage )
OBJECT_ENTRY( CLSID_ImportPackage, CImportPackage )
END_OBJECT_MAP()



// DLL Entry Point
extern "C" BOOL WINAPI DllMain( HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/ )
{
	if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init( ObjectMap, hInstance, &LIBID_IISMigrToolLib );
        DisableThreadLibraryCalls(hInstance);

		// Install operator new handler
		::_set_new_handler( CTools::BadAllocHandler );
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}



/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE
STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\core\macros.h ===
/*
****************************************************************************
|	Copyright (C) 2002  Microsoft Corporation
|
|	Component / Subcomponent
|		IIS 6.0 / IIS Migration Wizard
|
|	Based on:
|		http://iis6/Specs/IIS%20Migration6.0_Final.doc
|
|   Abstract:
|		Utility macros
|
|   Author:
|        ivelinj
|
|   Revision History:
|        V1.00	March 2002
|
****************************************************************************
*/
#pragma once


// DEBUG Macros
#ifndef VERIFY
	#ifdef _DEBUG
		#define VERIFY( t )		_ASSERT( (t) )
	#else
		#define VERIFY( t )		(t)
	#endif // _DEBUG
#endif // VERIFY


// General
#define ARRAY_SIZE( t )	( sizeof( t ) / sizeof( t[ 0 ] ) )


// Exception helpers
///////////////////////////////////////////////////////////////////////////////////////

// If the boolean expression 't' evaluates to FALSE/false - 'exc' is thrown
#define IF_FAILED_BOOL_THROW( t, exc )	if ( !(t) ){ throw (exc); }else{}

// If the expression evaluates to FAILED( hr ), then exc is thrown
#define IF_FAILED_HR_THROW( t, exc )	\
{\
	HRESULT _hr = (t);\
	if ( FAILED( _hr ) )\
	{\
		if ( ( _hr != E_FAIL ) || ( ::GetLastError() == ERROR_SUCCESS ) ) ::SetLastError( _hr );\
		throw (exc);\
	}\
}


// Used at the last point where excpetions should be catched and handled
// Requires hr variable to be already defined
#define BEGIN_EXCEP_TO_HR   try
#define END_EXCEP_TO_HR \
    catch( const CBaseException& err )\
    {\
        CTools::SetErrorInfo( err.GetDescription() );\
        hr = E_FAIL;\
    }\
    catch( CCancelException& )\
    {\
        hr = S_FALSE;\
    }\
    catch( const _com_error& err )\
    {\
        _ASSERT( err.Error() == E_OUTOFMEMORY );\
        err;\
        hr = E_OUTOFMEMORY;\
    }\
    catch( std::bad_alloc& )\
    {\
        hr = E_OUTOFMEMORY;\
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\core\importpackage.cpp ===
/*
****************************************************************************
|    Copyright (C) 2002  Microsoft Corporation
|
|    Component / Subcomponent
|        IIS 6.0 / IIS Migration Wizard
|
|    Based on:
|        http://iis6/Specs/IIS%20Migration6.0_Final.doc
|
|   Abstract:
|        ImportPackage COM class implementation
|
|   Author:
|        ivelinj
|
|   Revision History:
|        V1.00    March 2002
|
****************************************************************************
*/
#include "StdAfx.h"
#include "importpackage.h"


// Event helper
void inline STATE_CHANGE(   CImportPackage* pThis ,
                            enImportState st, 
                            _variant_t arg1 = _variant_t(), 
                            _variant_t arg2 = _variant_t(), 
                            _variant_t arg3 = _variant_t() )
{
    VARIANT_BOOL bContinue = VARIANT_TRUE; 
    VERIFY( SUCCEEDED( pThis->Fire_OnStateChange( st, arg1, arg2, arg3, &bContinue ) ) );

    if ( bContinue != VARIANT_TRUE )
    {
        throw CCancelException();
    }
}



// CSiteInfo implementation
/////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSiteInfo::get_SiteID( LONG* pVal )
{
    if ( NULL == pVal ) return E_INVALIDARG;

    HRESULT hr = S_OK;

    BEGIN_EXCEP_TO_HR
    {
        *pVal = static_cast<LONG>( Convert::ToDWORD( CXMLTools::GetDataValue(   m_spSiteNode, 
                                                                                L".", 
                                                                                L"SiteID", 
                                                                                NULL ).c_str() ) );
    }
    END_EXCEP_TO_HR

    return hr;
}


STDMETHODIMP CSiteInfo::get_DisplayName( BSTR* pVal )
{
    if ( NULL == pVal ) return E_INVALIDARG;

    HRESULT hr = S_OK;

    BEGIN_EXCEP_TO_HR
    {
        std::wstring str = CXMLTools::GetDataValue( m_spSiteNode, 
                                                    L"Metadata/IISConfigObject[@Location=\"\"]/Custom[@ID=\"1015\"]", 
                                                    NULL,
                                                    L"<no name>" );
        *pVal = ::SysAllocString( str.c_str() );
        if ( NULL == pVal ) hr = E_OUTOFMEMORY;
    }
    END_EXCEP_TO_HR    

    return hr;
}


STDMETHODIMP CSiteInfo::get_ContentIncluded( VARIANT_BOOL* pVal )
{
    if ( NULL == pVal ) return E_INVALIDARG;

    HRESULT hr = S_OK;

    BEGIN_EXCEP_TO_HR
    {
        IXMLDOMNodeListPtr  spList;
        IXMLDOMNodePtr      spNode;

        IF_FAILED_HR_THROW( m_spSiteNode->selectNodes( _bstr_t( L"Content" ), &spList ),
                            CBaseException( IDS_E_XML_PARSE ) );

        spList->nextNode( &spNode );    // Always succeedes

        *pVal = spNode != NULL ? VARIANT_TRUE : VARIANT_FALSE;
    }
    END_EXCEP_TO_HR

    return hr;
}


STDMETHODIMP CSiteInfo::get_IsFrontPageSite( VARIANT_BOOL* pVal )
{
    return E_NOTIMPL;
}


STDMETHODIMP CSiteInfo::get_HaveCertificates( VARIANT_BOOL* pVal )
{
    if ( NULL == pVal ) return E_INVALIDARG;

    HRESULT hr = S_OK;

    BEGIN_EXCEP_TO_HR
    {
        IXMLDOMNodeListPtr  spList;
        IXMLDOMNodePtr      spNode;

        IF_FAILED_HR_THROW( m_spSiteNode->selectNodes( _bstr_t( L"Certificate" ), &spList ),
                            CBaseException( IDS_E_XML_PARSE ) );

        spList->nextNode( &spNode );    // Always succeedes

        *pVal = spNode != NULL ? VARIANT_TRUE : VARIANT_FALSE;
    }
    END_EXCEP_TO_HR

    return hr;
}


STDMETHODIMP CSiteInfo::get_HaveCommands( VARIANT_BOOL* pVal )
{
    if ( NULL == pVal ) return E_INVALIDARG;

    HRESULT hr = S_OK;

    BEGIN_EXCEP_TO_HR
    {
        IXMLDOMNodeListPtr  spList;
        IXMLDOMNodePtr      spNode;

        IF_FAILED_HR_THROW( m_spSiteNode->selectNodes( _bstr_t( L"PostProcess" ), &spList ),
                            CBaseException( IDS_E_XML_PARSE ) );

        spList->nextNode( &spNode );    // Always succeedes

        *pVal = spNode != NULL ? VARIANT_TRUE : VARIANT_FALSE;
    }
    END_EXCEP_TO_HR

    return hr;
}


STDMETHODIMP CSiteInfo::get_ContentSize( LONG* pSize )
{
    if ( NULL == pSize ) return E_INVALIDARG;

    HRESULT hr = S_OK;

    BEGIN_EXCEP_TO_HR
    {
        // Get the size of all inlcuded virt dirs
        DWORDLONG nRes = 0;

        IXMLDOMNodeListPtr  spList;
        IXMLDOMNodePtr      spNode;

        IF_FAILED_HR_THROW( m_spSiteNode->selectNodes( _bstr_t( L"Content/VirtDir" ), &spList ),
                            CBaseException( IDS_E_XML_PARSE ) );

        while( S_OK == spList->nextNode( &spNode ) )
        {
            nRes += Convert::ToDWORDLONG( CXMLTools::GetAttrib( spNode, L"Size" ).c_str() );
        };

        *pSize = static_cast<LONG>( nRes / 1024 );  // Result is in KB
    }
    END_EXCEP_TO_HR

    return hr;
}


STDMETHODIMP CSiteInfo::get_SourceRootDir( BSTR* pVal )
{
    if ( NULL == pVal ) return E_INVALIDARG;

    HRESULT hr = S_OK;
    
    BEGIN_EXCEP_TO_HR
    {
        std::wstring strDir = CXMLTools::GetDataValue(  m_spSiteNode, 
                                                        L"Metadata/IISConfigObject[@Location=\"/ROOT\"]/Custom[@ID=\"3001\"]", 
                                                        NULL, L"" );
        *pVal = ::SysAllocString( strDir.c_str() );
        if ( NULL == pVal ) hr = E_OUTOFMEMORY;
    }
    END_EXCEP_TO_HR

    return hr;
}



STDMETHODIMP CSiteInfo::get_ACLsIncluded( VARIANT_BOOL* pVal )
{
    if ( NULL == pVal ) return E_INVALIDARG;

    HRESULT hr = S_OK;

    BEGIN_EXCEP_TO_HR
    {
        IXMLDOMNodeListPtr  spList;
        IXMLDOMNodePtr      spNode;

        IF_FAILED_HR_THROW( m_spSiteNode->selectNodes( _bstr_t( L"SIDList/SID" ), &spList ),
                            CBaseException( IDS_E_XML_PARSE ) );

        spList->nextNode( &spNode );    // Always succeedes

        *pVal = spNode != NULL ? VARIANT_TRUE : VARIANT_FALSE;
    }
    END_EXCEP_TO_HR

    return hr;
}




// CImportPackage implementation
/////////////////////////////////////////////////////////////////////////////////////////
CImportPackage::CImportPackage()
{
    m_dwPkgOptions  = 0;
}


CImportPackage::~CImportPackage()
{
    UnloadCurrentPkg();
}


// IImportPackage implementation
/////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImportPackage::get_SiteCount( SHORT* pVal )
{
    HRESULT hr = S_OK;

    if ( NULL == pVal ) return E_INVALIDARG;

    // Have a package been load
    if ( m_spXmlDoc == NULL ) 
    {
        CTools::SetErrorInfoFromRes( IDS_E_NOPACKAGE );
        return E_UNEXPECTED;
    }

    BEGIN_EXCEP_TO_HR
    {
        IXMLDOMNodeListPtr  spList;
        IF_FAILED_HR_THROW( m_spXmlDoc->selectNodes( L"/IISMigrPkg/WebSite", &spList ),
                            CBaseException( IDS_E_XML_PARSE ) );
        long nCount = 0;

        IF_FAILED_HR_THROW( spList->get_length( &nCount ),
                            CBaseException( IDS_E_XML_PARSE ) );

        *pVal = static_cast<SHORT>( nCount );
    }
    END_EXCEP_TO_HR

    return hr;
}



STDMETHODIMP CImportPackage::get_TimeCreated( DATE* pVal )
{
    if ( NULL == pVal ) return E_INVALIDARG;

    // Have a package been load
    if ( m_spXmlDoc == NULL ) 
    {
        CTools::SetErrorInfoFromRes( IDS_E_NOPACKAGE );
        return E_UNEXPECTED;
    }

    HRESULT hr = S_OK;

    BEGIN_EXCEP_TO_HR
    {
        std::wstring strTime = CXMLTools::GetDataValueAbs( m_spXmlDoc, L"/IISMigrPkg", L"TimeCreated_UTC", L"" );
        
        FILETIME		ft;
	    SYSTEMTIME		st;

	    if ( ::swscanf( strTime.c_str(), L"%u%u", &ft.dwLowDateTime, &ft.dwHighDateTime ) == EOF )
	    {
		    throw CBaseException( IDS_E_XML_PARSE, ERROR_INVALID_DATA );
	    }

	    // Time is in UTC - convert it to local machine's time
	    VERIFY( ::FileTimeToLocalFileTime( &ft, &ft ) );
	    VERIFY( ::FileTimeToSystemTime( &ft, &st ) );
	    VERIFY( SUCCEEDED( ::SystemTimeToVariantTime( &st, pVal ) ) );
    }
    END_EXCEP_TO_HR

    return hr;
}



STDMETHODIMP CImportPackage::get_Comment( BSTR* pVal )
{
    if ( NULL == pVal ) return E_INVALIDARG;

    HRESULT hr = S_OK;
    
    // Have a package been load
    if ( m_spXmlDoc == NULL ) 
    {
        CTools::SetErrorInfoFromRes( IDS_E_NOPACKAGE );
        return E_UNEXPECTED;
    }

    BEGIN_EXCEP_TO_HR
    {
        std::wstring strComment = CXMLTools::GetDataValueAbs( m_spXmlDoc, L"/IISMigrPkg", L"Comment", L"" );
        *pVal = ::SysAllocString( strComment.c_str() );
        if ( NULL == pVal ) hr = E_OUTOFMEMORY;
    }
    END_EXCEP_TO_HR

    return hr;
}


STDMETHODIMP CImportPackage::get_SourceMachine( BSTR* pVal )
{
    if ( NULL == pVal ) return E_INVALIDARG;

    HRESULT hr = S_OK;
    
    // Have a package been load
    if ( m_spXmlDoc == NULL ) 
    {
        CTools::SetErrorInfoFromRes( IDS_E_NOPACKAGE );
        return E_UNEXPECTED;
    }

    BEGIN_EXCEP_TO_HR
    {
        std::wstring strRes = CXMLTools::GetDataValueAbs( m_spXmlDoc, L"/IISMigrPkg", L"Machine", L"" );
        *pVal = ::SysAllocString( strRes.c_str() );
        if ( NULL == pVal ) hr = E_OUTOFMEMORY;
    }
    END_EXCEP_TO_HR

    return hr;
}



STDMETHODIMP CImportPackage::GetSourceOSVer( BYTE* pMajor, BYTE* pMinor, VARIANT_BOOL* pIsServer )
{
    if (    ( NULL == pMajor ) ||
            ( NULL == pMinor ) ||
            ( NULL == pIsServer ) ) return E_INVALIDARG;
    
    HRESULT hr = S_OK;
    
    // Have a package been load
    if ( m_spXmlDoc == NULL ) 
    {
        CTools::SetErrorInfoFromRes( IDS_E_NOPACKAGE );
        return E_UNEXPECTED;
    }

    BEGIN_EXCEP_TO_HR
    {
        std::wstring strVer = CXMLTools::GetDataValueAbs( m_spXmlDoc, L"/IISMigrPkg", L"OSVer", L"" );
        DWORD dwVer = Convert::ToDWORD( strVer.c_str() );

        _ASSERT( dwVer >= 400 ); // NT4.0 is the first OS supported

        *pMajor     = static_cast<BYTE>( dwVer / 100 );
        *pMinor     = static_cast<BYTE>( dwVer / 10 );
        *pMinor     -= ( *pMajor * 10 );
        *pIsServer  = dwVer & 1 ? VARIANT_TRUE : VARIANT_FALSE;
    }
    END_EXCEP_TO_HR

    return hr;
}



STDMETHODIMP CImportPackage::GetSiteInfo( SHORT nSiteIndex, ISiteInfo** ppISiteInfo )
{
    HRESULT hr = S_OK;

    if ( NULL == ppISiteInfo ) return E_INVALIDARG;

    // Have a package been load
    if ( m_spXmlDoc == NULL ) 
    {
        CTools::SetErrorInfoFromRes( IDS_E_NOPACKAGE );
        return E_UNEXPECTED;
    }

    BEGIN_EXCEP_TO_HR
    {
        CComObject<CSiteInfo>*  pInfo = NULL;
        
        // Create new SiteInfo. It starts with RefCount == 0
        IF_FAILED_HR_THROW( CComObject<CSiteInfo>::CreateInstance( &pInfo ),
                            CBaseException( IDS_E_OUTOFMEM, ERROR_SUCCESS ) );

        ISiteInfoPtr            spGuard( pInfo );

        pInfo->m_spSiteNode = GetSiteNode( nSiteIndex );

        pInfo->AddRef();
        *ppISiteInfo = pInfo;
    }
    END_EXCEP_TO_HR

    return hr;
}



STDMETHODIMP CImportPackage::ImportSite(    SHORT nSiteIndex,
                                            BSTR bstrSiteRootDir,    
                                            LONG nOptions )
{
    // Check IIS Admin service state
    IF_FAILED_BOOL_THROW(   CTools::IsIISRunning(),
                            CBaseException( IDS_E_NO_IIS, ERROR_SUCCESS ) );

    HRESULT hr = S_OK;

    BEGIN_EXCEP_TO_HR
    {
        STATE_CHANGE( this, istInitializing );

        // Find the <WebSite> XML node we are talking about
        IXMLDOMNodePtr spWebSite = GetSiteNode( nSiteIndex );

        // Calculate the number of progress steps needed for the import
        STATE_CHANGE(   this, 
                        istProgressInfo, 
                        _variant_t( CalcNumberOfSteps( spWebSite, nOptions ) ) );

        // This is the order in which we will import data
        // 1. Content
        // 2. Certificates
        // 3. Metadata
        // 4. PostProcess
        //
        // At every step, all metadata modifications are done in the XML doc. 
        // In the last step ( metadata import ) this data is imported in the metabase

        // Import content
        ImportContent( spWebSite, bstrSiteRootDir, nOptions );
        
        // Import certificates
        ImportCertificate( spWebSite, nOptions );

        // Import the metadata
        ImportConfig( spWebSite, nOptions );

        // Perform PostProcessOperations
        ExecPostProcess( spWebSite, nOptions );

        STATE_CHANGE( this, istFinalizing );
    }
    END_EXCEP_TO_HR

    return hr;
}



STDMETHODIMP CImportPackage::LoadPackage( BSTR bstrFilename, BSTR bstrPassword )
{
    if ( NULL == bstrFilename) return E_INVALIDARG;
    if ( !::PathFileExistsW( bstrFilename ) ) return E_INVALIDARG;
    if ( !CTools::IsAdmin() ) return E_ACCESSDENIED;
    if ( ::wcslen( bstrFilename ) > MAX_PATH ) return E_INVALIDARG;
    if ( 0 == CTools::GetOSVer() ) return HRESULT_FROM_WIN32( ERROR_OLD_WIN_VERSION );
    if ( NULL == bstrPassword ) return E_INVALIDARG;    // The password can be "" but not NULL

    HRESULT hr = S_OK;

    try
    {
        LoadPackageImpl( bstrFilename, bstrPassword );
    }
    catch( const CBaseException& err )
    {
        CTools::SetErrorInfo( err.GetDescription() );
        hr = E_FAIL;
    }
    catch( const _com_error& err )
    {
        // Only out of mem is expected
        _ASSERT( err.Error() == E_OUTOFMEMORY );
        err;
        hr = E_OUTOFMEMORY;
    }
    catch( std::bad_alloc& )
    {
        hr = E_OUTOFMEMORY;
    }

    if ( FAILED( hr ) )
    {
        UnloadCurrentPkg();
    }

    return hr;
}


/*
    This will verify that the file is a MigrTool pkg
    Load any package-wide data
    Create the key to decrypt any encrypted data in the package
    Create the handle to the package file
    Return all these to the caller
*/
void CImportPackage::LoadPackageImpl( LPCWSTR wszFileName, LPCWSTR wszPassword )
{
    // Check IIS Admin service state
    IF_FAILED_BOOL_THROW(    CTools::IsIISRunning(),
                            CBaseException( IDS_E_NO_IIS, ERROR_SUCCESS ) );

    // If there is currently loaded package - free it
    UnloadCurrentPkg();

    // Get a crypt context. We will not use public/private keys - that's why Provider name is NULL
    // and CRYPT_VERIFYCONTEXT is used
    IF_FAILED_BOOL_THROW(   ::CryptAcquireContext(  &m_shCryptProv,
                                                    NULL,
                                                    MS_ENHANCED_PROV,
                                                    PROV_RSA_FULL,
                                                    CRYPT_VERIFYCONTEXT | CRYPT_SILENT ),
                            CBaseException( IDS_E_CRYPT_CONTEXT ) );

    m_shPkgFile = ::CreateFile( wszFileName,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                NULL );
    IF_FAILED_BOOL_THROW(   m_shPkgFile.IsValid(),
                            CObjectException( IDS_E_OPENFILE, wszFileName ) );

    // Check if GUID at the beggining of the file
    WCHAR wszGUID[ 64 ];
    DWORD dwBytesRead   = 0;
    DWORD dwGuidSize    = static_cast<DWORD>( ::wcslen( PKG_GUID ) * sizeof( WCHAR ) );

    _ASSERT( ARRAY_SIZE( wszGUID ) > ::wcslen( PKG_GUID ) );

    if (    !::ReadFile( m_shPkgFile.get(), wszGUID, dwGuidSize, &dwBytesRead, NULL ) || 
            ( dwBytesRead != dwGuidSize ) )
    {
        throw CBaseException( IDS_E_PKG_CURRUPTED );
    }
    wszGUID[ dwGuidSize / sizeof( WCHAR ) ] = L'\0';
    // Compare the GUIDS

    if ( ::wcscmp( wszGUID, PKG_GUID ) != 0 )
    {
        throw CBaseException( IDS_E_PKG_NOTOURPKG );
    }

    // Read package options ( these are the same options as provided to CExportPackage::WritePackage )
    if (    !::ReadFile( m_shPkgFile.get(), &m_dwPkgOptions, sizeof( DWORD ), &dwBytesRead, NULL ) || 
            ( dwBytesRead != sizeof( DWORD ) ) )
    {
        throw CBaseException( IDS_E_PKG_CURRUPTED );
    }

    // Read the offset in file where the XML config data resides
    DWORDLONG nOffset = 0;

    if (    !::ReadFile( m_shPkgFile.get(), &nOffset, sizeof( DWORDLONG ), &dwBytesRead, NULL ) || 
            ( dwBytesRead != sizeof( DWORDLONG ) ) )
    {
        throw CBaseException( IDS_E_PKG_CURRUPTED );
    }

    // If the package data was encrypted - we need the crypt key to decrypt the XML file
    // Otherwise we will need the session key which is stored in the XML file
    if ( m_dwPkgOptions & wpkgEncrypt )
    {
        m_shDecryptKey = CTools::GetCryptKeyFromPwd( m_shCryptProv.get(), wszPassword );
    }

    // Load the XML file
    LoadXmlDoc( m_shPkgFile.get(), nOffset );

    // If the package was not encrypted - the crypt key used to decrypt secure data in the XML file
    // is in the XML file, so import it now
    if ( !( m_dwPkgOptions & wpkgEncrypt ) )
    {
        ImportSessionKey( wszPassword );
    }

    // Store the password - this password is used for exporting the site's ceritifcates
    // If we will import a site's certificate we will use this password
    m_strPassword = wszPassword;
}



// Implementation
/////////////////////////////////////////////////////////////////////////////////////////
void CImportPackage::UnloadCurrentPkg()
{
    m_strPassword.erase();
    m_shDecryptKey.Close();
    m_shCryptProv.Close();
    m_shPkgFile.Close();
    m_spXmlDoc      = NULL;
    m_dwPkgOptions  = 0;
}



void CImportPackage::LoadXmlDoc( HANDLE hFile, DWORDLONG nOffset )
{
    _ASSERT( hFile != INVALID_HANDLE_VALUE );
    _ASSERT( nOffset > 0 );

    // Position at the begining of the XML data
    CTools::SetFilePtrPos( hFile, nOffset );

    IStreamPtr          spIStream;
    
    IF_FAILED_HR_THROW( ::CreateStreamOnHGlobal( NULL, TRUE, &spIStream ),
                        CBaseException( IDS_E_OUTOFMEM, ERROR_SUCCESS ) );
    IF_FAILED_HR_THROW( m_spXmlDoc.CreateInstance( CLSID_DOMDocument30 ),
                        CBaseException( IDS_E_NO_XML_PARSER ) );

    const DWORD BuffSize = 4 * 1024;
    BYTE btBuffer[ BuffSize ];
    ULONG nRead = 0;
    
    do
    {
        IF_FAILED_BOOL_THROW(   ::ReadFile( hFile, btBuffer, BuffSize, &nRead, NULL ),
                                CBaseException( IDS_E_PKG_CURRUPTED ) );

        if ( m_shDecryptKey.IsValid() )
        {
            IF_FAILED_BOOL_THROW(	::CryptDecrypt(	m_shDecryptKey.get(),
													NULL,
                                                    nRead != BuffSize,
													0,
													btBuffer,
													&nRead ),
								    CObjectException( IDS_E_CRYPT_CRYPTO, L"<XML stream>" ) );
        }

        IF_FAILED_HR_THROW( spIStream->Write( btBuffer, nRead, NULL ),
                            CBaseException( IDS_E_OUTOFMEM, ERROR_SUCCESS ) );

    }while( nRead == BuffSize );

    {
        LARGE_INTEGER nTemp = { 0 };
        VERIFY( SUCCEEDED( spIStream->Seek( nTemp, STREAM_SEEK_SET, NULL ) ) );
    }

    VARIANT_BOOL bRes = VARIANT_FALSE;

    if (    FAILED( m_spXmlDoc->load( _variant_t( spIStream.GetInterfacePtr() ), &bRes ) ) || 
            ( bRes != VARIANT_TRUE ) )
    {
        // If we have an encrypted data and we fail to load the XML - most probably the password is incorrect.
        if ( m_shDecryptKey.IsValid() )
        {
            throw CBaseException( IDS_E_WRONGPASSWORD, ERROR_SUCCESS );
        }
        else
        {
            _ASSERT( false );   // Wrong XML format perhaps
            throw CBaseException( IDS_E_XML_PARSE, ERROR_SUCCESS );
        }
    }

    // Set the selection language to "XPath" or our selectNodes call will unexpectedly return no results
    IXMLDOMDocument2Ptr spI2 = m_spXmlDoc;
    IF_FAILED_HR_THROW( spI2->setProperty( _bstr_t( "SelectionLanguage" ), _variant_t( L"XPath" ) ),
                        CBaseException( IDS_E_XML_PARSE ) );
}



void CImportPackage::ImportSessionKey( LPCWSTR wszPassword )
{
    _ASSERT( wszPassword != NULL );
    _ASSERT( m_shCryptProv.IsValid() );
    _ASSERT( m_spXmlDoc != NULL );

    std::wstring        strData = CXMLTools::GetDataValueAbs( m_spXmlDoc, L"/IISMigrPkg/SessionKey", NULL, NULL );
	TCryptHashHandle    shHash;
	TCryptKeyHandle     shDecryptKey;
	TCryptKeyHandle     shSessionKey;

	// Create the key that will be used to decrypt the session key
		
	// Create a hash to store the export pass
    IF_FAILED_BOOL_THROW(	::CryptCreateHash(	m_shCryptProv.get(),
												CALG_MD5,
												NULL,
												0,
												&shHash ),
							CBaseException( IDS_E_CRYPT_KEY_OR_HASH ) );

	IF_FAILED_BOOL_THROW(	::CryptHashData(	shHash.get(),
												reinterpret_cast<const BYTE*>( wszPassword ),
												static_cast<DWORD>( ::wcslen( wszPassword ) * sizeof( WCHAR ) ),
												0 ),
							CBaseException( IDS_E_CRYPT_KEY_OR_HASH ) );
    
	// Make a key from this hash
	IF_FAILED_BOOL_THROW( ::CryptDeriveKey(	m_shCryptProv.get(),
											CALG_RC4,
											shHash.get(),
											0x00800000,	// 128bit RC4 key
											&shDecryptKey ),
							CBaseException( IDS_E_CRYPT_KEY_OR_HASH ) );

	// Convert the string key to bin data and import it into crypt key
	// ( make the string lower-case. HexToBin expects lower case symbols )
	::_wcslwr( const_cast<LPWSTR>( strData.data() ) );
	DWORD           dwSize = 0;
    TByteAutoPtr    spData;
    Convert::ToBLOB( strData.c_str(), /*r*/spData, /*r*/dwSize );

    // If this fails with bad data - the password is wrong
    if ( !::CryptImportKey(	m_shCryptProv.get(),
                                                spData.get(),
												dwSize,
												shDecryptKey.get(),
												0,
												&shSessionKey ) )
    {
        if ( ::GetLastError() == NTE_BAD_DATA ) throw CBaseException( IDS_E_WRONGPASSWORD, ERROR_SUCCESS );
        else throw CBaseException( IDS_E_CRYPT_KEY_OR_HASH );
    }

    m_shDecryptKey = shSessionKey;
}



void CImportPackage::ImportContent( const IXMLDOMNodePtr& spSite, LPCWSTR wszPath, DWORD dwOptions )
{
    _ASSERT( spSite != NULL );

    // If we have path specified - we have to create the VDir structure beneath it ( it may exist already though )
    if ( ( wszPath != NULL ) && ( wszPath[ 0 ] != L'\0' ) )
    {
        // Is it a valid path? ( it must be an existing dir )
        IF_FAILED_BOOL_THROW(   ::PathIsDirectoryW( wszPath ),
                                CObjectException( IDS_E_NOTDIR, wszPath ) );

        // Create the structure. Note that this will modify the XML data
        CreateContentDirs( spSite, wszPath, dwOptions );
    }

    // Extract the files
    if ( !(dwOptions & impSkipContent ) )
    {
        IXMLDOMNodeListPtr  spList;
        IXMLDOMNodePtr      spNode;
        DWORD               dwImpOpt = ( dwOptions & impSkipFileACLs ) ? CInPackage::edNoDACL : CInPackage::edNone;

        CInPackage Pkg( spSite, m_shPkgFile.get(), 
                        ( m_dwPkgOptions & wpkgCompress ) != 0, 
                        m_dwPkgOptions & wpkgEncrypt ? m_shDecryptKey.get() : NULL );

        Pkg.SetCallback( _CallbackInfo( CImportPackage::ExtractFileCallback, this ) );

        IF_FAILED_HR_THROW( spSite->selectNodes( _bstr_t( L"Content/VirtDir" ), &spList ),
                            CBaseException( IDS_E_XML_PARSE ) );

        while( S_OK == spList->nextNode( &spNode ) )
        {
            std::wstring    strVDir = CXMLTools::GetAttrib( spNode, L"MBPath" );
            std::wstring    strPath = CXMLTools::GetAttrib( spNode, L"Path" );
            double          dblSize = static_cast<double>( Convert::ToDWORDLONG( CXMLTools::GetAttrib( spNode, L"Size" ).c_str() ) );   
            dblSize /= 1024;
                        
            STATE_CHANGE(   this, 
                            istImportingVDir, 
                            _variant_t( ::wcsrchr( strVDir.c_str(), L'/' ) + 1 ),
                            _variant_t( strPath.c_str() ),
                            _variant_t( dblSize ) );

            Pkg.ExtractVDir( spNode, dwImpOpt );
        }                                
    }
}



void CImportPackage::ImportCertificate( const IXMLDOMNodePtr& spSite, DWORD dwOptions )
{
    _ASSERT( spSite != NULL );
    if ( dwOptions & impSkipCertificate ) return;

    std::wstring strData = CXMLTools::GetDataValue( spSite, L"Certificate", NULL, L"" );

    // If there is no Cert in the package - exit
    if ( strData.empty() ) return;

    STATE_CHANGE( this, istImportingCertificate );

    TByteAutoPtr    spBlob;
    DWORD           dwCertSize = 0;
    Convert::ToBLOB( strData.c_str(), /*r*/spBlob, /*r*/dwCertSize );

    CRYPT_DATA_BLOB CryptData = { 0 };
	CryptData.cbData	= dwCertSize;
	CryptData.pbData	= spBlob.get();

	// Verify the password. We should have verified the password already ( when importing the session key
    // or when decrypted the package )
	VERIFY( ::PFXVerifyPassword( &CryptData, m_strPassword.c_str(),0 ) );							

    // Import the cert(s) into a temp store
	// The cert private key will be stored on the local machine rather then in the current user
	// The cert(s) will be marked as exportable
	TCertStoreHandle shTempStore( ::PFXImportCertStore(	&CryptData, 
														m_strPassword.c_str(), 
														CRYPT_MACHINE_KEYSET | CRYPT_EXPORTABLE ) );

	IF_FAILED_BOOL_THROW(	shTempStore.IsValid(),
							CBaseException( IDS_E_IMPORT_CERT ) );

	// Now we have our SSL certificate as well as its cert chain in shTempStore
	// The SSL certificate will go to "MY" store ( MY store holds certs with Priv Keys )
	// All other certificates from the chain that are not self signed will go to
	// the "CA" store ( it holds Certification Authority certificates )
	// The self-signed certificate will go to the "ROOT" store where all trusted
	// certs live
	TCertContextHandle shSSLCert( PutCertsInStores( shTempStore.get(), ( dwOptions & impUseExistingCerts ) != 0 ) );
	
	// Now set the just-imported cert to be our site's SSL certificate
    // We will update the XML now. The data will be imported to the MB later
    DWORD dwHashSize = 0;

	// Get the certificate hash
	::CertGetCertificateContextProperty(	shSSLCert.get(),
											CERT_SHA1_HASH_PROP_ID,
											NULL,
											&dwHashSize );
	_ASSERT( dwHashSize > 0 );
	spBlob = TByteAutoPtr( new BYTE[ dwHashSize ] );

	IF_FAILED_BOOL_THROW(	::CertGetCertificateContextProperty(	shSSLCert.get(),
																	CERT_SHA1_HASH_PROP_ID,
																	spBlob.get(),
																	&dwHashSize ),
							CBaseException( IDS_E_CRYPT_KEY_OR_HASH ) );

    IXMLDOMNodeListPtr  spList;
    IXMLDOMNodePtr      spConfigObject;
    IF_FAILED_HR_THROW( spSite->selectNodes( _bstr_t( L"Metadata/IISConfigObject[@Location=\"\"]" ), &spList ),
                        CBaseException( IDS_E_XML_PARSE ) );
    IF_FAILED_BOOL_THROW(   S_OK == spList->nextNode( &spConfigObject ),
                            CBaseException( IDS_E_XML_PARSE, ERROR_NOT_FOUND ) );

    IXMLDOMElementPtr   spNew = CXMLTools::AddTextNode( m_spXmlDoc, 
                                                        spConfigObject, 
                                                        L"Custom", 
                                                        Convert::ToString( spBlob.get(), dwHashSize ).c_str() );
    CXMLTools::SetAttrib( spNew, L"ID", Convert::ToString( (DWORD)MD_SSL_CERT_HASH ).c_str() );
    CXMLTools::SetAttrib( spNew, L"UserType", Convert::ToString( (DWORD)IIS_MD_UT_SERVER ).c_str() );
    CXMLTools::SetAttrib( spNew, L"Type", Convert::ToString( (DWORD)BINARY_METADATA ).c_str() );
    CXMLTools::SetAttrib( spNew, L"Attributes", L"0" );
}


void CImportPackage::ImportConfig( const IXMLDOMNodePtr& spSite, DWORD dwOptions )
{
    STATE_CHANGE( this, istImportingConfig );

    // Perform any pre-import modifications to the metadata
    PreImportConfig( spSite, dwOptions );

// In DEBUG - write the XML file for testing purposes
#ifdef _DEBUG
    {
        m_spXmlDoc->save( _variant_t( L"c:\\Migr_import.xml" ) );
    }
#endif // _DEBUG

    DWORD dwSiteID = Convert::ToDWORD( CXMLTools::GetDataValue( spSite, L".", L"SiteID", NULL ).c_str() );

    CIISSite::BackupMetabase();

    // If we need to purge the old data - delete the old Site data and create new one with the same ID
    // Otherwise - create new site ID and import the data there
    if ( dwOptions & impPurgeOldData )
    {
        CIISSite::DeleteSite( dwSiteID );
    }

    // Create new SiteID
    // If dwSiteID was deleted - this will create the site with the same ID
    // Otherwise this ID will not be available and a new one will be generated and returned
    dwSiteID = CIISSite::CreateNew( dwSiteID );
    
    CIISSite    Site( dwSiteID, false );
    Site.ImportConfig(  spSite, 
                        ( m_dwPkgOptions & wpkgEncrypt ) != 0 ? NULL : m_shDecryptKey.get(),
                        ( dwOptions & impImortInherited ) != 0 );

}


void CImportPackage::ExecPostProcess( const IXMLDOMNodePtr& spSite, DWORD dwOptions )
{
    if ( impSkipPostProcess & dwOptions ) return;

    // Extract the post-process files to a temp dir
    CTempDir    TempDir;

    ExtractPPFiles( spSite, TempDir );
    ExecPPCommands( spSite, TempDir );    
}

/*
    Create a new dir under wszRoot for each VDir in the site's data. The name of the dir is the name
    of the VDir. Site's root VDir will be named "Root". This is not an error if a dir already exists.
    If the Purge options was specified - assure these dirs are empty ( delete everything in them )
    Modify the XML data for the VDir so that the VDirs paths match the local ones
*/
void CImportPackage::CreateContentDirs( const IXMLDOMNodePtr& spSite, LPCWSTR wszRoot, DWORD dwOptions )
{
    _ASSERT( spSite != NULL );
    _ASSERT( wszRoot != NULL );

    // Get all VDirs this site contains
    IXMLDOMNodeListPtr  spVDirList;
    IXMLDOMNodePtr      spVDir;

    IF_FAILED_HR_THROW( spSite->selectNodes( _bstr_t( L"Content/VirtDir" ), &spVDirList ),
                        CBaseException( IDS_E_XML_PARSE ) );

    // Perform the required actions for each VDir
    while( S_OK == spVDirList->nextNode( &spVDir ) )
    {
        // Get the name of the VDir
        std::wstring strMBPath = CXMLTools::GetAttrib( spVDir, L"MBPath" );

        // Create the subdir
        // We will use the MBPath to create the name. The path is in form "\ROOT\IISHelp"
        WCHAR wszFullPath[ MAX_PATH ];
        CDirTools::PathAppendLocal( wszFullPath, wszRoot, ::wcsrchr( strMBPath.c_str(), L'/' ) + 1 );

        // Create the dir. It's OK if it exists
        if ( !::CreateDirectoryW( wszFullPath, NULL ) )
        {
            IF_FAILED_BOOL_THROW(   ::GetLastError() == ERROR_ALREADY_EXISTS,
                                    CObjectException( IDS_E_CREATEDIR, wszFullPath ) );
        }

        // Modify the XML data to reflect the new VDir location
        
        // Change it in the VDirs list ( <Content>/<VirtDir> )
        CXMLTools::SetAttrib( spVDir, L"Path", wszFullPath );

        // Change it in the metadata
        // Locate the metadata path by the MB location of the VDir
        WCHAR wszQuery[ 512 ];
        ::swprintf( wszQuery, L"Metadata/IISConfigObject[@Location=\"%s\"]/Custom[@ID=\"3001\"]", strMBPath.c_str() );

        CXMLTools::SetDataValue( spSite, wszQuery, NULL, wszFullPath );
    };
}



void CImportPackage::ExtractPPFiles( const IXMLDOMNodePtr& spSite, LPCWSTR wszLocation )
{
    _ASSERT( ::PathIsDirectoryW( wszLocation ) );
    _ASSERT( spSite != NULL );

    IXMLDOMNodeListPtr  spFileList;
    IXMLDOMNodePtr      spFile;

    IF_FAILED_HR_THROW( spSite->selectNodes( _bstr_t( L"PostProcess/File" ), &spFileList ),
                        CBaseException( IDS_E_XML_PARSE ) );

    CInPackage Pkg( spSite, m_shPkgFile.get(), 
                ( m_dwPkgOptions & wpkgCompress ) != 0, 
                m_dwPkgOptions & wpkgEncrypt ? m_shDecryptKey.get() : NULL );

    while( S_OK == spFileList->nextNode( &spFile ) )
    {
        STATE_CHANGE(   this,
                        istPostProcess,
                        _variant_t( true ),
                        _variant_t( CXMLTools::GetAttrib( spFile, L"Name" ).c_str() ) );

        Pkg.ExtractFile( spFile, wszLocation, CInPackage::edNone );
    }
}



void CImportPackage::ExecPPCommands( const IXMLDOMNodePtr& spSite, LPCWSTR wszPPFilesLoc )
{
    _ASSERT( spSite != NULL );
    _ASSERT( ::PathIsDirectoryW( wszPPFilesLoc ) );

    // Get site's metabase ID ( the site metadata is already in the MB )
    std::wstring strSiteID = CXMLTools::GetDataValue( spSite, L".", L"SiteID", NULL );

    // Set our custom macros as environment variables for this process
    // This way they can be used by any post-process commands or executable
    IF_FAILED_BOOL_THROW(	::SetEnvironmentVariableW( IMPMACRO_TEMPDIR, wszPPFilesLoc ),
                            CObjectException( IDS_E_SET_ENV, IMPMACRO_TEMPDIR, wszPPFilesLoc ) );
    IF_FAILED_BOOL_THROW(	::SetEnvironmentVariableW( IMPMACRO_SITEIID, strSiteID.c_str() ),
                            CObjectException( IDS_E_SET_ENV, IMPMACRO_SITEIID, strSiteID.c_str() ) );

    // Get the commands and exec them
    IXMLDOMNodeListPtr  spCmdList;
    IXMLDOMNodePtr      spCmd;
    
    IF_FAILED_HR_THROW( spSite->selectNodes( _bstr_t( L"PostProcess/Command" ), &spCmdList ),
                        CBaseException( IDS_E_XML_PARSE ) );
    while( S_OK == spCmdList->nextNode( &spCmd ) )
    {
        std::wstring    strCmd      = CXMLTools::GetAttrib( spCmd, L"Text" );
        DWORD           dwTimeout   = Convert::ToDWORD( CXMLTools::GetAttrib( spCmd, L"Timeout" ).c_str() );
        bool            bIgnoreErr  = Convert::ToBool( CXMLTools::GetAttrib( spCmd, L"IgnoreErrors" ).c_str() );
    
        ExecPPCmd( strCmd.c_str(), dwTimeout, bIgnoreErr, wszPPFilesLoc );
    }
}



void CImportPackage::ExecPPCmd( LPCWSTR wszText, DWORD dwTimeout, bool bIgnoreErrors, LPCWSTR wszTempDir )
{
    _ASSERT( wszText != NULL );
    _ASSERT( dwTimeout <= MAX_CMD_TIMEOUT );

    const DWORD dwBuffSize = 4 * 1024;	// 4K buffer for the command
	WCHAR wszCmdBuffer[ dwBuffSize ];

	// Our command will look something like [cmd.exe /C "command goes here"]
	// But we need a buffer to expand the environment strings. So leave space for the first part
	WCHAR			wszLeft[]	= L"cmd.exe /C \"";
	const size_t	nLeftLen	= ARRAY_SIZE( wszLeft ) - 1;    // -1 for the '\0'

	// Expand the environment variables
	IF_FAILED_BOOL_THROW(	::ExpandEnvironmentStringsW(	wszText, 
															wszCmdBuffer + nLeftLen,
															dwBuffSize - nLeftLen - 1 ),
							CObjectException( IDS_E_CMD_TOOBIG, wszText ) );

	// Put the left part in the buffer
	::memcpy( wszCmdBuffer, wszLeft, ::wcslen( wszLeft ) * sizeof( WCHAR ) );
	// ...and add the enclosing quotaion mark
	::wcscat( wszCmdBuffer, L"\"" );	

    STATE_CHANGE(   this,
                    istPostProcess,
                    _variant_t( false ),
                    _variant_t( wszText ) );

	STARTUPINFOW		si	= { sizeof( STARTUPINFOW ) };
	PROCESS_INFORMATION	pi	= { 0 };

	::GetStartupInfoW( &si );

	IF_FAILED_BOOL_THROW(	::CreateProcessW(	NULL,
												wszCmdBuffer,
												NULL,
												NULL,
												FALSE,
												CREATE_NO_WINDOW,
												NULL,
												wszTempDir,
												&si,
												&pi ),
							CBaseException( IDS_E_CMD_SHELL ) );

	DWORD		dwExitCode	= 1;	// Initial value indicates error
	TStdHandle	shProcess( pi.hProcess );
	TStdHandle	shThread( pi.hThread );

	// Wait for command to complete
	// Terminate it if the timeout expires	
	if ( ::WaitForSingleObject( pi.hProcess, dwTimeout != 0 ? dwTimeout : INFINITE ) == WAIT_TIMEOUT )
	{
		VERIFY( ::TerminateProcess( pi.hProcess, 1 ) );
	}

	// Get the process exit code. Everything different then 0 is considered an error
	VERIFY( ::GetExitCodeProcess( pi.hProcess, &dwExitCode ) );

	IF_FAILED_BOOL_THROW(	bIgnoreErrors || ( 0 == dwExitCode ),
							CObjectException( IDS_E_CMD_FAILED, wszText, wszCmdBuffer, ERROR_SUCCESS ) );

}



/*
	Distributes all certificates from the temp ( memory ) store hSourceStore
	into their appropriate cert store ( "MY", "CA", "ROOT" )
	The function returns the SSL certificate's context handle
*/
const TCertContextHandle CImportPackage::PutCertsInStores( HCERTSTORE hSourceStore, bool bReuseCerts )
{
	_ASSERT( hSourceStore != NULL );

	TCertContextHandle	shSSLCert;
	TCertContextHandle	shImportedSSLCert;
	
	// In hSourceStore we have all the certificates that build the certificate chain for the SSL certificate
	// Usually there will be 2-3 certificates ( the SSL one and the self-signed trusted root cert )
	// In case of longer chains we need to import all certificates and sometimes - even the root certificate
	// However some root certificates cannot be replaced so we will fail to recreate the entire chain and
	// thus, the SSL cert will not be trusted.

	// So here is what we'll do:
	// 1) Find the SSL cert in the store ( it is the only one with a PK )
	// 2) Get the certificate chain from the mem store
	// 3) Import each certificate, starting with the last one ( last one means the cert with PK, which is the SSL one )
	// 4) After each imported cert - check that the SSL cert is valid and can be used. This is done by building
	// the cert chain for the SSL cert ( but this time using the local machine as a source, instead of our mem store )
	// and then verifying the chain with the SSL policy

	// Find the SSL cert
	/////////////////////////////////////////////////////////////////////////////////////////
	{
		TCertContextHandle	shCert( ::CertEnumCertificatesInStore( hSourceStore, NULL ) );
		_ASSERT( shCert.IsValid() );

		while( shCert.IsValid() )
		{
			if ( CertHasPrivateKey( shCert.get() ) )
			{
				shSSLCert = shCert;
				break;
			}

			shCert = ::CertEnumCertificatesInStore( hSourceStore, shCert.get() );
		};

		_ASSERT( shSSLCert.IsValid() );
	}
	
	// Add the SSL cert to the store
	shImportedSSLCert = CTools::AddCertToSysStore( shSSLCert.get(), L"MY", false );

	DWORD				dwError	= 0;
	TCertContextHandle	shCurrentCert = shSSLCert;

	while( !CTools::IsValidCert( shImportedSSLCert.get(), /*r*/dwError ) )
	{
		// Get the curent cert's issuer
		shCurrentCert = ::CertFindCertificateInStore(	hSourceStore,
														X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
														0,
														CERT_FIND_ISSUER_OF,
														shCurrentCert.get(),
														NULL );

		// The end of the chain is reached but the SSL cert is still not valid.
		// This may not be because if missing cert, but may be because of the cert policy
		IF_FAILED_BOOL_THROW(	shCurrentCert.IsValid(),
								CBaseException( IDS_E_CERT_CANNOT_VALIDATE, dwError ) );
			
		// Is this the self-signed cert?
		if ( CTools::IsSelfSignedCert( shCurrentCert.get() ) )
		{
			// It will be imported to the "ROOT" store
			CTools::AddCertToSysStore( shCurrentCert.get(), L"ROOT", bReuseCerts );
		}
		else
		{
			// Any other cert from the middle of the chain goes to the "CA" store
			CTools::AddCertToSysStore( shCurrentCert.get(), L"CA", bReuseCerts );
		}
	};

	_ASSERT( shImportedSSLCert.IsValid() );
	return shImportedSSLCert;
}



bool CImportPackage::CertHasPrivateKey( PCCERT_CONTEXT hCert )
{
	BOOL bRes = ::CryptFindCertificateKeyProvInfo( hCert, CRYPT_FIND_SILENT_KEYSET_FLAG, NULL );
	
	// The only accepted failure is NTE_NO_KEY. Everything else is really an error
	IF_FAILED_BOOL_THROW(	bRes || ( NTE_NO_KEY == ::GetLastError() ),
							CBaseException( IDS_E_CERT_PK_FIND ) );

	return bRes != FALSE;
}





/*
    Returns a node ptr for the specified site index ( zer-based )
*/
IXMLDOMNodePtr CImportPackage::GetSiteNode( DWORD iSite )
{
    _ASSERT( m_spXmlDoc != NULL );

    WCHAR wszBuff[ 256 ];
    ::swprintf( wszBuff, L"/IISMigrPkg/WebSite[%u]", iSite + 1 );

    IXMLDOMNodeListPtr  spList;
    IXMLDOMNodePtr      spSite;

    IF_FAILED_HR_THROW( m_spXmlDoc->selectNodes( wszBuff, &spList ),
                        CBaseException( IDS_E_XML_PARSE ) );

    IF_FAILED_BOOL_THROW(   spList->nextNode( &spSite ) == S_OK,
                            CBaseException( IDS_E_INVALIDARG, ERROR_NOT_FOUND ) );

    return spSite;
}



void CImportPackage::PreImportConfig( const IXMLDOMNodePtr& spSite, DWORD /*dwOptions*/ )
{
    LPCWSTR wszLocQry = L"Metadata/IISConfigObject[@Location=\"\"]/Custom[@ID=\"1015\"]";

    // Change the name of the site
    std::wstring strOrigName = CXMLTools::GetDataValue( spSite,
                                                        wszLocQry,
                                                        NULL,
                                                        L"" );

    // The site doesn't have name ( don't know if that can really happen, but...)
    if ( strOrigName.empty() ) return;

    // Get the name of the source machine
    CComBSTR bstrMachine;
    IF_FAILED_HR_THROW( get_SourceMachine( &bstrMachine ),
                        CBaseException( IDS_E_XML_PARSE ) );

    // Get Today
    WCHAR wszDate[ 64 ];
    SYSTEMTIME st = { 0 };
    ::GetLocalTime( &st );
    ::wsprintf( wszDate, L"%u/%u/%u", st.wMonth, st.wDay, st.wYear );


    WCHAR wszBuffer[ METADATA_MAX_NAME_LEN ];
    ::_snwprintf(   wszBuffer, 
                    METADATA_MAX_NAME_LEN, 
                    L"%s ( imported on %s from %s )",
                    strOrigName.c_str(),
                    wszDate,
                    bstrMachine.m_str );

    // Set it in the XML
    CXMLTools::SetDataValue( spSite, wszLocQry, NULL, wszBuffer );
}



long CImportPackage::CalcNumberOfSteps( const IXMLDOMNodePtr& spSite, DWORD dwOptions )
{
    long nSteps = 1;    // We always import the config/ That's one step

    IXMLDOMNodeListPtr  spList;

    // Get the total number of files included if we will import the content
    // Add the number of VDirs
    if ( !( dwOptions & impSkipContent ) )
    {               
        IF_FAILED_HR_THROW( spSite->selectNodes( _bstr_t( L"Content/VirtDir//File" ), &spList ),
                            CBaseException( IDS_E_XML_PARSE ) );

        long nCount = 0;

        if ( SUCCEEDED( spList->get_length( &nCount ) ) )
        {
            nSteps += nCount;
        }

        IF_FAILED_HR_THROW( spSite->selectNodes( _bstr_t( L"Content/VirtDir" ), &spList ),
                            CBaseException( IDS_E_XML_PARSE ) );

        if ( SUCCEEDED( spList->get_length( &nCount ) ) )
        {
            nSteps += nCount;
        }
    }

    if ( !( dwOptions & impSkipCertificate ) )
    {
        // 1 Step for the certificate
        ++nSteps;
    }

    // Get the number of post-process operations
    if ( !( dwOptions & impSkipPostProcess ) )
    {
        IF_FAILED_HR_THROW( spSite->selectNodes( _bstr_t( L"PostProcess/*" ), &spList ),
                            CBaseException( IDS_E_XML_PARSE ) );

        long nCount = 0;

        if ( SUCCEEDED( spList->get_length( &nCount ) ) )
        {
            nSteps += nCount;
        }
    }

    return nSteps;
}


/* 
    Called by CInPackage when a file is to be extracted
*/
void CImportPackage::ExtractFileCallback( void* pContext, LPCWSTR wszFilename, bool bStartFile )
{
    _ASSERT( pContext != NULL );
    _ASSERT( wszFilename != NULL );

    // We handle only StartFile = true
    if ( !bStartFile ) return;

    CImportPackage* pThis = reinterpret_cast<CImportPackage*>( pContext );

    STATE_CHANGE( pThis, istImportingFile, _variant_t( wszFilename ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\core\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by IISMigrTool.rc
//
#define IDR_IMPORTPACKAGE               4
#define IDS_PROJNAME                    100
#define IDS_E_WEBNOTFOUND               101
#define IDS_E_PATHNOTEXISTS             102
#define IDS_E_NOTDIR                    103
#define IDS_E_INVALID_PASSWORD          104
#define IDS_E_CERT_PK_FIND              104
#define IDS_E_NO_XML_PARSER             105
#define IDS_E_CANNOT_CREATE_TEMPDIR     106
#define IDS_E_WRITEFILE                 107
#define IDS_E_WRITE_OUTPUT              107
#define IDS_E_SETACESS                  108
#define IDS_E_CAB_ADDFILE               109
#define IDS_E_CAB_EXTRACT               110
#define IDS_E_CAB_INIT                  111
#define IDS_E_PKG_CURRUPTED             111
#define IDS_E_OPENFILE                  112
#define IDS_E_READFILE                  113
#define IDS_E_OUTOFMEM                  114
#define IDS_E_CAB_FINALIZE              115
#define IDS_E_PKG_NOTOURPKG             115
#define IDS_E_ENUM_FILES                116
#define IDS_E_CRYPT_CONTEXT             117
#define IDS_E_CRYPT_KEY_OR_HASH         118
#define IDS_E_SEEKFILE                  119
#define IDS_E_CRYPT_CRYPTO              120
#define IDS_E_NOPACKAGE                 121
#define IDS_E_NEWSITE_UNSUPPOERTED      122
#define IDS_E_WRONGPASSWORD             123
#define IDS_E_CREATEDIR                 124
#define IDS_E_BACKUPDIR_FULL            125
#define IDS_E_EXPORTSITE_NOTFOUND       126
#define IDS_E_MOVEFILE                  127
#define IDS_E_FAILED_IMPORT_CFG         128
#define IDS_E_SITEOPEN                  129
#define IDS_FMO_ERROR                   130
#define IDS_E_CAB_ITERATE               131
#define IDS_E_METABASE                  132
#define IDS_E_METABASE_IO               133
#define IDS_E_CRYPT_ENCRYPT             134
#define IDS_E_XML_GENERATE              135
#define IDS_E_XML_PARSE                 136
#define IDS_E_DELETEFILE                137
#define IDS_E_DELETEDIR                 138
#define IDS_E_INVALIDARG                139
#define IDS_E_NO_EXPORTSITES            140
#define IDS_E_CREATEINSTANCE            141
#define IDS_E_PPFILE_EXISTS             142
#define IDS_E_OPEN_CERT_STORE           143
#define IDS_E_FIND_SSL_CERT             144
#define IDS_E_EXPORT_CERT               145
#define IDS_E_TOOBIG_PPFILES            146
#define IDS_E_GETSET_CURRDIR            147
#define IDS_E_SET_ENV                   148
#define IDS_E_CMD_SHELL                 149
#define IDS_E_CMD_FAILED                150
#define IDS_E_ADD_CERT_STORE            151
#define IDS_E_NOPASSWORD_CERTEXPORT     152
#define IDS_E_NOPKG_PASSWORD            153
#define IDS_E_INVALIDPASSWORD_CERTIMPORT 154
#define IDS_E_IMPORT_CERT               155
#define IDS_E_MDRESTORE                 155
#define IDS_E_CERT_CHAIN                156
#define IDS_E_MDBACKUP                  157
#define IDS_E_NOIIS                     158
#define IDS_E_NO_IIS                    158
#define IDS_E_NO_DOWNGRADE              159
#define IDS_E_READ_FSECURITY            160
#define IDS_E_APPLY_DACL                161
#define IDS_E_MD_ADDKEY                 162
#define IDS_E_DIRNOTEMPTY               163
#define IDS_E_CERT_CANNOT_VALIDATE      164
#define IDS_E_SEEK_PKG                  165
#define IDR_EXPORTPACKAGE               201
#define IDS_E_CMD_TOOBIG                204

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        205
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\core\pkghandlers.cpp ===
#include "StdAfx.h"
#include "pkghandlers.h"
#include "Utils.h"
#include "IISHelpers.h"
#include "IISMigrTool.h"


// COutPackage implementation
/////////////////////////////////////////////////////////////////////////////////////////
COutPackage::COutPackage( HANDLE hFile, bool bCompress, HCRYPTKEY hCryptKey )
{
	_ASSERT( hFile != INVALID_HANDLE_VALUE );
	
	m_hFile		= hFile;
	m_hCryptKey	= hCryptKey;
    m_bCompress	= bCompress;
	m_spBuffer	= TByteAutoPtr( new BYTE[ COutPackage::DefaultBufferSize ] );
}



/*
	Adds file to the package. The file must exists.
	Optionally - the data is compressed or encrypted
	Optionally - the file DACL is exported
	Files data goes to the output file
	Everything else goes to the XML doc ( spXMLDoc ) under the node spRoot
*/
void COutPackage::AddFile(	LPCWSTR wszName,
							const IXMLDOMDocumentPtr& spXMLDoc,
							const IXMLDOMElementPtr& spRoot,
							DWORD dwOptions )const
{
	TFileHandle shInput( ::CreateFile(	wszName,
										GENERIC_READ,
										FILE_SHARE_READ,
										NULL,
										OPEN_EXISTING,
										FILE_ATTRIBUTE_NORMAL,
										NULL ) );

	IF_FAILED_BOOL_THROW(	shInput.IsValid(),
							CObjectException( IDS_E_OPENFILE, wszName ) );

	// Create the node for the file data
	IXMLDOMElementPtr spEl = CXMLTools::CreateSubNode( spXMLDoc, spRoot, L"File" );

	// Store the file atttributes
    CXMLTools::SetAttrib( spEl, L"Attributes", Convert::ToString( ::GetFileAttributes( wszName ) ).c_str() );
	// Set the current position in file. This is where trhe file data starts
    CXMLTools::SetAttrib( spEl, L"StartsAt", Convert::ToString( CTools::GetFilePtrPos( m_hFile ) ).c_str() );
	// Set the name ( remove the path. store only the name )
	{
		_ASSERT( DefaultBufferSize > MAX_PATH );
		LPWSTR wszPath = reinterpret_cast<LPWSTR>( m_spBuffer.get() );
		::wcscpy( wszPath, wszName );
		::PathStripPathW( wszPath );
		CXMLTools::SetAttrib( spEl, L"Name", wszPath );
	}		

	DWORDLONG	dwLength	= 0;	// How much the file occupies from the output file
	DWORD		dwBytesRead = 0;

	// Write "FD" as a mark for the begining of the file. This will serve for verification
	// when exctracting for corrupted or wrong package
	CTools::WriteFile( m_hFile, "FD", 2 * sizeof( char ) );

	// Read the file and process the data
	do
	{
		IF_FAILED_BOOL_THROW(	::ReadFile(	shInput.get(),
											m_spBuffer.get(),
											DefaultBufferSize,
											&dwBytesRead,
											NULL ),
								CObjectException( IDS_E_READFILE, wszName ) );

		// Compress it if we need to
		if ( m_bCompress )
		{
		}

		// Encrypt it if we need to
		if ( m_hCryptKey != NULL )
		{
			IF_FAILED_BOOL_THROW(	::CryptEncrypt(	m_hCryptKey, 
													NULL,
													dwBytesRead != DefaultBufferSize,
													0,
													m_spBuffer.get(),
													&dwBytesRead,
													DefaultBufferSize ),
								CObjectException( IDS_E_CRYPT_CRYPTO, wszName ) );
		}

		// Write the result
		CTools::WriteFile( m_hFile, m_spBuffer.get(), dwBytesRead );

		dwLength += dwBytesRead;
	}while( dwBytesRead == DefaultBufferSize );

	// Export the file security settings if we need to
	if ( !( dwOptions & afNoDACL ) )
	{
        ExportFileDACL( wszName, spXMLDoc, spEl, ( dwOptions & afAllowNoInhAce ) != 0 );
	}

	// Store the data length
    CXMLTools::SetAttrib( spEl, L"Length", Convert::ToString( dwLength ).c_str() );
}



void COutPackage::AddPath(	LPCWSTR wszPath,
							const IXMLDOMDocumentPtr& spXMLDoc,
							const IXMLDOMElementPtr& spRoot,
							DWORD dwOptions )const
{
	_ASSERT( ( wszPath != NULL ) && ::PathIsDirectoryW( wszPath ) );
    	
	WCHAR wszDir[ MAX_PATH ];

	CFindFile			Search;
	
	// Export the root ( wszPath ) with the name "\"
	AddPathOnly( wszPath, L"\\", spXMLDoc, spRoot, dwOptions );
	
	// Export each dir under wszPath
	bool bFound = Search.FindFirst(	wszPath,
									CFindFile::ffAbsolutePaths | 
										CFindFile::ffAddFilename |
										CFindFile::ffRecursive |
										CFindFile::ffGetDirs,
									wszDir,
									NULL );

	// This is the offset from the begining of wszPath, where the subdir ( relative to wszSiteRoot )
	// starts. I.e. wszSiteRoot + dwRootOffset points to the subdir only
	// ( wszSiteRoot="c:\InetPub", wszPath="c:\InetPub\Subdir",wszPath + dwRootOffset="\Subdir" )
	size_t nRootOffset = ::wcslen( wszPath );

	while( bFound )
	{
        // Allow inherited file ACES to be skipped
        // We will allow this even if it is not allowed for the dir itself, because
        // the subdirs are children of the dir ( wszPath ) and there is no need to explicitly export their ACEs
		AddPathOnly( wszDir, wszDir + nRootOffset, spXMLDoc, spRoot, dwOptions | afAllowNoInhAce );

		bFound = Search.Next( NULL, wszDir, NULL );
	};
}





void COutPackage::WriteSIDsToXML(	DWORD dwSiteID,
									const IXMLDOMDocumentPtr& spXMLDoc, 
									const IXMLDOMElementPtr& spRoot )const
{
	_ASSERT( spXMLDoc != NULL );
	_ASSERT( spRoot != NULL );

	IXMLDOMElementPtr spSIDList = CXMLTools::CreateSubNode( spXMLDoc, spRoot, L"SIDList" );

	// We will need the local machine name and the anonymous user account name
	std::wstring strMachine = CTools::GetMachineName();
	std::wstring strUser;
	{
		CIISSite Site( dwSiteID );
		strUser = Site.GetAnonUser();
	}

	DWORD nID = 0;
	for (	TSIDList::const_iterator it = m_SIDList.begin();
			it != m_SIDList.end();
			++it, ++nID )
	{
		std::wstring	strAccount;
		std::wstring	strDomain;
		SID_NAME_USE	SidUsage;
		_SidType		SidType;

		if ( !GetSIDDetails(	it->get(),
								strUser.c_str(),
								strMachine.c_str(),
								/*r*/strAccount,
								/*r*/strDomain,
								/*r*/SidUsage,
								/*r*/SidType ) )
		{
			// This SID is not exportable - remove all ACEs that reference it
			RemoveSidFromXML( spXMLDoc, nID );
		}
		else
		{
			WriteSIDToXML(	CXMLTools::CreateSubNode( spXMLDoc, spSIDList, L"SID" ),
							nID,
							strAccount.c_str(),
							strDomain.c_str(),
							SidUsage,
							SidType );
		}		
	}
}


/* 
	Gets the details fro a SID. Returns true if this SID should be exported and false otherwise
*/
bool COutPackage::GetSIDDetails(	PSID pSID,
									LPCWSTR wszIISUser, 
									LPCWSTR wszMachine,
									std::wstring& rstrAccount,
									std::wstring& rstrDomain,
									SID_NAME_USE& rSidUsage,
									_SidType& rSidType )const
{
	_ASSERT( ( pSID != NULL ) && ( wszIISUser != NULL ) && ( wszMachine != NULL ) );
	_ASSERT( ::IsValidSid( pSID ) );

	DWORD	dwNameLen	= 256;
	DWORD	dwDomainLen	= 256;
	BOOL	bResult		= FALSE;

	std::auto_ptr<WCHAR>	spName;
	std::auto_ptr<WCHAR>	spDomain;
	SID_NAME_USE			SidUse;

	do
	{
        spName		= std::auto_ptr<WCHAR>( new WCHAR[ dwNameLen ] );
		spDomain	= std::auto_ptr<WCHAR>( new WCHAR[ dwDomainLen ] );
		bResult		= ::LookupAccountSid(	NULL,
											pSID,
											spName.get(),
											&dwNameLen,
											spDomain.get(),
											&dwDomainLen,
											&SidUse );
	}while( !bResult && ( ERROR_INSUFFICIENT_BUFFER == ::GetLastError() ) );

	// If we cannot find the SID - skip it
	if ( !bResult ) return false;

	// We handle this type of SIDs. Everything else is skiped
	// 1. All domain/external accounts ( spDomain != wszLocalMachine )
	// 2. All well known SIDS ( like SYSTEM, Power Users, etc... )
	// 3. The anonymous web user ( spName == wszAnonymousUser )
	// 4. All built-in aliases ( like Administrators )

	_SidType sidType = sidInvalid;

	// NOTE: The check order is important
	// Is this the IIS anonymous user?
	if (	( ::StrCmpIW( spName.get(), wszIISUser ) == 0 ) && 
			( ::StrCmpIW( spDomain.get(), wszMachine ) == 0 ) )
	{
		sidType = sidIISUser;
	}
	// Is this a built-in SID
	else if ( ( SidTypeAlias == SidUse ) || ( SidTypeWellKnownGroup == SidUse ) )
	{
		sidType = sidWellKnown;
	}
    // Is a non-local account SID
	else if ( ( ::StrCmpIW( spDomain.get(), wszMachine ) != 0 ) )
	{
		sidType = sidExternal;
	}

	// Skip all other SIDs
	if ( sidInvalid == sidType ) return false;

	rstrAccount = spName.get();
	rstrDomain	= spDomain.get();
	rSidUsage	= SidUse;
	rSidType	= sidType;

	return true;
}



void COutPackage::WriteSIDToXML(	const IXMLDOMElementPtr& spSID,
									DWORD dwID,
									LPCWSTR wszAccount,
									LPCWSTR wszDomain,
									SID_NAME_USE SidUsage,
									_SidType SidType )const
{
	_ASSERT( spSID != NULL );
	_ASSERT( wszAccount != NULL );
	_ASSERT( wszDomain != NULL );
	_ASSERT( SidType != sidInvalid );

	LPCWSTR wszSidType = NULL;

	switch( SidType )
	{
	case sidIISUser:
		wszSidType = L"IISUser";
		break;

	case sidWellKnown:
		wszSidType = L"WellKnown";
		break;

	case sidExternal:
		wszSidType = L"External";
		break;

	default:
		_ASSERT( false );
	};

    CXMLTools::SetAttrib( spSID, L"ID", Convert::ToString( dwID ).c_str() );
	CXMLTools::SetAttrib( spSID, L"Type", wszSidType );
	CXMLTools::SetAttrib( spSID, L"Account", wszAccount );
	CXMLTools::SetAttrib( spSID, L"Domain", wszDomain );
    CXMLTools::SetAttrib( spSID, L"Usage", Convert::ToString( static_cast<DWORD>( SidUsage ) ).c_str() );
}



void COutPackage::RemoveSidFromXML( const IXMLDOMDocumentPtr& spDoc, DWORD nSidID )const
{
	_ASSERT( spDoc != NULL );

	WCHAR wszXPath[ 32 ];

	::swprintf( wszXPath, L"//ACE[@ID=%d]", nSidID );

	IXMLDOMElementPtr spRoot;

	IF_FAILED_HR_THROW( spDoc->get_documentElement( &spRoot ),
						CBaseException( IDS_E_XML_PARSE ) );

	CXMLTools::RemoveNodes( spRoot, wszXPath );
}



void COutPackage::ExportFileDACL(	LPCWSTR wszObject,
									const IXMLDOMDocumentPtr& spDoc,
									const IXMLDOMElementPtr& spRoot,
                                    bool bAllowSkipInherited )const
{
	_ASSERT( wszObject != NULL );
	_ASSERT( ( spDoc != NULL ) && ( spRoot != NULL ) );

	ACL* pACL = NULL;

	// Get the security info for this dir
	LPWSTR wszBuffer = reinterpret_cast<LPWSTR>( m_spBuffer.get() );
	::wcscpy( wszBuffer, wszObject );
	IF_FAILED_BOOL_THROW(   ::GetNamedSecurityInfo(	wszBuffer,
												    SE_FILE_OBJECT,
												    DACL_SECURITY_INFORMATION,
												    NULL,
												    NULL,
												    &pACL,
												    NULL,
												    NULL ) == ERROR_SUCCESS,
						CObjectException( IDS_E_READ_FSECURITY, wszObject ) );

    if ( NULL == pACL ) return;

	// Export each ACE in the ACL
	for ( int i = 0; i < pACL->AceCount; ++i )
	{
		LPVOID pAce = NULL;

		VERIFY( ::GetAce( pACL, i, &pAce ) );

		ExportAce(	pAce, spDoc, spRoot, bAllowSkipInherited );
	}
}



void COutPackage::ExportAce(	LPVOID pACE, 
								const IXMLDOMDocumentPtr& spDoc,
								const IXMLDOMElementPtr& spRoot,
                                bool bAllowSkipInherited )const
{
	_ASSERT( pACE != NULL );

    // Right now only ACCESS_ALLOWED_ACE_TYPE and ACCESS_DENIED_ACE_TYPE are exported
	BYTE	btType  = reinterpret_cast<ACE_HEADER*>( pACE )->AceType;
    BYTE    btFlags = reinterpret_cast<ACE_HEADER*>( pACE )->AceFlags;
	PSID	pSID    = NULL;

    // Do not export inherited ACES
    if ( bAllowSkipInherited && ( btFlags & INHERITED_ACE ) ) return;

    if ( ( ACCESS_ALLOWED_ACE_TYPE == btType ) || ( ACCESS_DENIED_ACE_TYPE == btType ) )
	{
		_ASSERT( sizeof( ACCESS_ALLOWED_ACE ) == sizeof( ACCESS_DENIED_ACE ) );

		// The type bellow doesn't matter. Both of the types have the same offset
		// of the SidStart member
		ACCESS_ALLOWED_ACE* pTypedAce = reinterpret_cast<ACCESS_ALLOWED_ACE*>( pACE );

		pSID = reinterpret_cast<PSID>( &( pTypedAce->SidStart ) );
	}
	else
	{
		// Unsupported type
		return;
	}

	// Here we will export all SIDs. Then, when exporting the SID list we will remove
	// the SIDs that are not exportable ( local user/groups are not exported ).
	// Also we will remove all ACE nodes from the XML that reference this SID
	// This way we save the time for each SID lookup here

	IXMLDOMElementPtr spACE = CXMLTools::CreateSubNode( spDoc, spRoot, L"ACE" );

	// Set the ACE attribs
    CXMLTools::SetAttrib( spACE, L"SID", Convert::ToString( IDFromSID( pSID ) ).c_str() );
	CXMLTools::SetAttrib( spACE, L"Type", Convert::ToString( btType ).c_str() );
	CXMLTools::SetAttrib( spACE, L"Flags", Convert::ToString( btFlags ).c_str() );
	CXMLTools::SetAttrib( spACE, L"Mask", Convert::ToString( reinterpret_cast<ACCESS_ALLOWED_ACE*>( pACE )->Mask ).c_str() );
}



DWORD COutPackage::IDFromSID( PSID pSID )const
{
	_ASSERT( ( pSID != NULL ) && ( ::IsValidSid( pSID ) ) );

	DWORD iPos = 0;

	for (	TSIDList::const_iterator it = m_SIDList.begin();
			it != m_SIDList.end();
			++it, ++iPos )
	{
		if ( ::EqualSid( it->get(), pSID ) )
		{
			return iPos;
		}
	}

	// If we are here - the SID is not in the list. So add it
	m_SIDList.push_back( _sid_ptr( pSID ) );

	return static_cast<DWORD>( m_SIDList.size() - 1 );
}


/*
	Add wszPath content to the output
	Only files in wszPath are added ( non recursive )
*/
void COutPackage::AddPathOnly(	LPCWSTR wszPath,
								LPCWSTR wszName,
								const IXMLDOMDocumentPtr& spXMLDoc,
								const IXMLDOMElementPtr& spRoot,
								DWORD dwOptions )const
{
	_ASSERT( wszPath != NULL );
	_ASSERT( wszName != NULL );

	// Create the node to hold this dir
	IXMLDOMElementPtr spDir = CXMLTools::CreateSubNode( spXMLDoc, spRoot, L"Dir" );
    CXMLTools::SetAttrib( spDir, L"Attributes", Convert::ToString( ::GetFileAttributes( wszPath ) ).c_str() );
	CXMLTools::SetAttrib( spDir, L"Name", wszName );

	if ( !( dwOptions & afNoDACL ) )
	{
        ExportFileDACL( wszPath, spXMLDoc, spDir, ( dwOptions & afAllowNoInhAce ) != 0 );
	}

	WCHAR wszFile[ MAX_PATH ];

	CFindFile	Search;
	bool bFound = Search.FindFirst( wszPath,
									CFindFile::ffGetFiles | 
										CFindFile::ffAbsolutePaths | 
										CFindFile::ffAddFilename,
									wszFile,
									NULL );

	while( bFound )
	{
        if ( m_CallbackInfo.pCallback != NULL )
        {
            m_CallbackInfo.pCallback(  m_CallbackInfo.pCtx, wszFile, true );
        }

        // Allow inherited file ACES to be skipped
        // We will allow this even if it is not allowed for the dir itself, because
        // the files are children of the dir and there is no need to explicitly export their ACEs
        AddFile( wszFile, spXMLDoc, spDir, dwOptions | afAllowNoInhAce );

        if ( m_CallbackInfo.pCallback != NULL )
        {
            m_CallbackInfo.pCallback(  m_CallbackInfo.pCtx, wszFile, false );
        }

		bFound = Search.Next( NULL, wszFile, NULL );
	}
}








// CInPackage implementation
/////////////////////////////////////////////////////////////////////////////////////////
CInPackage::CInPackage( const IXMLDOMNodePtr& spSite,
                        HANDLE hFile, 
                        bool bCompressed, 
                        HCRYPTKEY hDecryptKey )
{
    // Load the SIDs from the XML
    LoadSIDs( spSite );

    m_hDecryptKey   = hDecryptKey;
    m_hFile         = hFile;
    m_bCompressed   = bCompressed;

    m_spBuffer = TByteAutoPtr( new BYTE[ DefaultBufferSize ] );
}



void CInPackage::ExtractVDir( const IXMLDOMNodePtr& spVDir, DWORD dwOptions )
{
    _ASSERT( spVDir != NULL );

    // Get all contained dirs and export them
    IXMLDOMNodeListPtr  spDirList;
    IXMLDOMNodePtr      spDir;

    IF_FAILED_HR_THROW( spVDir->selectNodes( _bstr_t( L"Dir" ), &spDirList ),
                        CBaseException( IDS_E_XML_PARSE ) );

    while( S_OK == spDirList->nextNode( &spDir ) )
    {
        ExtractDir( spDir, CXMLTools::GetAttrib( spVDir, L"Path" ).c_str(), dwOptions );
    };
}



void CInPackage::LoadSIDs( const IXMLDOMNodePtr& spSite )
{
    _ASSERT( spSite != NULL );

    IXMLDOMDocumentPtr  spXmlDoc;
    IXMLDOMNodeListPtr  spList;
    IXMLDOMNodePtr      spSIDs;

    IF_FAILED_HR_THROW( spSite->selectNodes( _bstr_t( L"SIDList" ), &spList ),
                        CBaseException( IDS_E_XML_PARSE ) );
    IF_FAILED_BOOL_THROW(   S_OK == spList->nextNode( &spSIDs ),
                            CBaseException( IDS_E_XML_PARSE, ERROR_NOT_FOUND ) );

    IF_FAILED_HR_THROW( spSite->get_ownerDocument( &spXmlDoc ),
                        CBaseException( IDS_E_XML_PARSE ) );

    std::wstring    strLocalMachine     = CTools::GetMachineName();
    std::wstring    strSourceMachine    = CXMLTools::GetDataValueAbs(   spXmlDoc,
                                                                        L"/IISMigrPkg",
                                                                        L"Machine",
                                                                        NULL );
    // Get all SID entries from the XML
    IXMLDOMNodeListPtr	spSIDList;
	IXMLDOMNodePtr		spSID;

	IF_FAILED_HR_THROW( spSIDs->selectNodes( _bstr_t( L"SID" ), &spSIDList ),
						CBaseException( IDS_E_XML_PARSE ) );

	while( S_OK == spSIDList->nextNode( &spSID ) )
	{
        DWORD			dwID	= ULONG_MAX;
		TByteAutoPtr	spSIDData;

		// Check if this SID exists on the local machine
		if ( LookupSID( spSID, strLocalMachine.c_str(), strSourceMachine.c_str(), /*r*/dwID, /*r*/spSIDData ) )
		{
			m_SIDs.insert( TSIDMap::value_type( dwID, _sid_ptr( spSIDData.get() ) ) );
		}
	};
}


bool CInPackage::LookupSID( const IXMLDOMNodePtr& spSID,
						    LPCWSTR wszLocalMachine,
                            LPCWSTR wszSourceMachine,
							DWORD& rdwID,
							TByteAutoPtr& rspData )
{
    _ASSERT( spSID != NULL );
    _ASSERT( wszLocalMachine != NULL );

    rdwID = 0;
    rspData = TByteAutoPtr( NULL );
    
    // Get the SID data
    DWORD           dwID        = Convert::ToDWORD( CXMLTools::GetAttrib( spSID, L"ID" ).c_str() );
    std::wstring    strType     = CXMLTools::GetAttrib( spSID, L"Type" );
    std::wstring    strAccount  = CXMLTools::GetAttrib( spSID, L"Account" );
    std::wstring    strDomainXML= CXMLTools::GetAttrib( spSID, L"Domain" );
    SID_NAME_USE	SidUsageXML = static_cast<SID_NAME_USE>( 
                                    Convert::ToDWORD( CXMLTools::GetAttrib( spSID, L"Usage" ).c_str() ) );

	SID_NAME_USE    SidUsageLocal;
	
	// Check if this is the IIS anonymous user
	if ( ::StrCmpIW( strType.c_str(), L"IISUser" ) == 0 )
	{
		// Get the local anonymous user ( the one set at the WebSite level - it is the default )
        std::wstring strUser = CIISSite::GetDefaultAnonUser();

		// Get the local SID
		DWORD dwSize	= 0;
		DWORD dwDummie	= 0;
		::LookupAccountName(	NULL,
								strUser.c_str(),
								NULL,
								&dwSize,
								NULL,
								&dwDummie,
								&SidUsageLocal );
		_ASSERT( dwSize > 0 );
		rspData		= TByteAutoPtr( new BYTE[ dwSize ] );
		std::auto_ptr<WCHAR> spDummie( new WCHAR[ dwDummie ] );

		// We must found this SID. it was created by the IIS
		VERIFY ( ::LookupAccountName(	NULL,
										strUser.c_str(),
										rspData.get(),
										&dwSize,
										spDummie.get(),
										&dwDummie,
										&SidUsageLocal ) );
		return true;
	}

	TByteAutoPtr			spData;
	DWORD					dwSIDSize = 32;
	std::auto_ptr<WCHAR>	spDomain;
	DWORD					dwDomainSize = 64;
	BOOL					bResult = FALSE;

	do
	{
		spData		= TByteAutoPtr( new BYTE[ dwSIDSize ] );
		spDomain	= std::auto_ptr<WCHAR>( new WCHAR[ dwDomainSize ] );

		bResult = ::LookupAccountNameW(	NULL,
										strAccount.c_str(),
										spData.get(),
										&dwSIDSize,
										spDomain.get(),
										&dwDomainSize,
										&SidUsageLocal );
	}while( !bResult && ( ERROR_INSUFFICIENT_BUFFER == ::GetLastError() ) );

	// If we cannot find such account on this machine - skip this SID
	if ( !bResult ) return false;

	bool bValidSID = false;

	// For well-known sids - check that the domain name, if it is the name of the source machine
	// is the name of the local machine. 
	if ( ::StrCmpIW( strType.c_str(), L"WellKnown" ) == 0 )
	{
		// First check if the domain names match ( i.e. "NT AUTHORITY" )
		// in case they match - we have valid SID if the SID usage matches as well
		if (	( ::StrCmpIW( strDomainXML.c_str(), spDomain.get() ) == 0 ) &&
				( SidUsageXML == SidUsageLocal ) )
		{
			bValidSID = true;
		}
		// Else - the SID is also valid if the domain is the name of the machine
		else if (	( ::StrCmpIW( strDomainXML.c_str(), wszSourceMachine ) == 0 ) &&
					( ::StrCmpIW( spDomain.get(), wszLocalMachine ) == 0 ) &&
					( SidUsageXML == SidUsageLocal ) )
		{
			bValidSID = true;
		}
	}
	// Now check the external SIDs
	else if ( ::StrCmpIW( strType.c_str(), L"External" ) == 0 )
	{
		// External SIDs are valid if domain name match as well as the name usage
		if (	( ::StrCmpIW( strDomainXML.c_str(), spDomain.get() ) == 0 ) &&
				( SidUsageXML == SidUsageLocal ) )
		{
			bValidSID = true;
		}
	}

	if ( bValidSID )
	{
		rspData = spData;
		rdwID	= dwID;
	}

	return bValidSID;
}



void CInPackage::ExtractDir( const IXMLDOMNodePtr& spDir, LPCWSTR wszRoot, DWORD dwOptions )
{
    _ASSERT( spDir != NULL );
    _ASSERT( ::PathIsDirectoryW( wszRoot ) );

    WCHAR wszFullPath[ MAX_PATH ];
    CDirTools::PathAppendLocal( wszFullPath, wszRoot, CXMLTools::GetAttrib( spDir, L"Name" ).c_str() );

    if ( !::CreateDirectoryW( wszFullPath, NULL ) )
    {
        IF_FAILED_BOOL_THROW(   ::GetLastError() == ERROR_ALREADY_EXISTS,
                                CObjectException( IDS_E_CREATEDIR, wszFullPath ) );
    }

    // If we need to clean the dir - do it now
    if ( ( dwOptions & impPurgeOldData ) )
    {
        CDirTools::CleanupDir( wszFullPath, false, true );
    }

    DWORD dwAttribs = Convert::ToDWORD( CXMLTools::GetAttrib( spDir, L"Attributes" ).c_str() );
    IF_FAILED_BOOL_THROW(	::SetFileAttributes( wszFullPath, dwAttribs ),
							CObjectException( IDS_E_WRITEFILE, wszFullPath ) );

    if ( !( dwOptions & edNoDACL ) && !m_SIDs.empty() )
    {
        ApplyFileObjSecurity( spDir, wszFullPath );
    }

    // Extract the files
    IXMLDOMNodeListPtr  spFileList;
    IXMLDOMNodePtr      spFile;

    IF_FAILED_HR_THROW( spDir->selectNodes( _bstr_t( L"File" ), &spFileList ),
                        CBaseException( IDS_E_XML_PARSE ) );

    while( S_OK == spFileList->nextNode( &spFile ) )
    {
        std::wstring strName = CXMLTools::GetAttrib( spFile, L"Name" );

        if ( m_CallbackInfo.pCallback != NULL )
        {
            m_CallbackInfo.pCallback(  m_CallbackInfo.pCtx, strName.c_str(), true );
        }

        ExtractFile( spFile, wszFullPath, dwOptions );

        if ( m_CallbackInfo.pCallback != NULL )
        {
            m_CallbackInfo.pCallback(  m_CallbackInfo.pCtx, strName.c_str(), false );
        }
    };
}



void CInPackage::ExtractFile( const IXMLDOMNodePtr& spFile, LPCWSTR wszDir, DWORD dwOptions )
{
    _ASSERT( spFile != NULL );
    _ASSERT( ::PathIsDirectoryW( wszDir ) );

    DWORD       dwAttribs   = Convert::ToDWORD( CXMLTools::GetAttrib( spFile, L"Attributes" ).c_str() );
    DWORDLONG   dwStartsAt  = Convert::ToDWORDLONG( CXMLTools::GetAttrib( spFile, L"StartsAt" ).c_str() );
    DWORDLONG    dwLength    = Convert::ToDWORDLONG( CXMLTools::GetAttrib( spFile, L"Length" ).c_str() );
    std::wstring strName    = CXMLTools::GetAttrib( spFile, L"Name" );

    WCHAR wszFullPath[ MAX_PATH ];
    CDirTools::PathAppendLocal( wszFullPath, wszDir, strName.c_str() );

    // Change the file attribs to remove the "read-only" one
    IF_FAILED_BOOL_THROW(	::SetFileAttributes( wszFullPath, FILE_ATTRIBUTE_NORMAL ) || ( ::GetLastError() == ERROR_FILE_NOT_FOUND ),
							CObjectException( IDS_E_WRITEFILE, wszFullPath ) );

    TFileHandle shFile(  ::CreateFile(  wszFullPath,
                                        GENERIC_WRITE,
                                        0,
                                        NULL,
                                        CREATE_ALWAYS,
                                        dwAttribs,
                                        NULL ) );
    IF_FAILED_BOOL_THROW( shFile.IsValid(), CObjectException( IDS_E_OPENFILE, wszFullPath ) );

    DWORD dwRead = 0;

    // Write the file data
    CTools::SetFilePtrPos( m_hFile, dwStartsAt );

    // At the begining of every file, there is the "FD" chars. Check we have mark here
    char aszMark[ 2 ];
    IF_FAILED_BOOL_THROW(   ::ReadFile( m_hFile, aszMark, 2, &dwRead, NULL ) && ( 2 == dwRead ),
                            CBaseException( IDS_E_PKG_CURRUPTED ) );

    IF_FAILED_BOOL_THROW( ::strncmp( aszMark, "FD", 2 ) == 0, CBaseException( IDS_E_PKG_CURRUPTED ) );

    while( dwLength > 0 )
    {
        DWORD dwToRead = static_cast<DWORD>( min( dwLength, DefaultBufferSize ) );    // How much to read this pass

        // Read the data. we MUST read as much as we want
        IF_FAILED_BOOL_THROW(
            ::ReadFile( m_hFile, m_spBuffer.get(), dwToRead, &dwRead, NULL ) &&
                ( dwRead == dwToRead ),
            CBaseException( IDS_E_PKG_CURRUPTED ) );

        // If the package was encrypted - decrypt the data
        if ( m_hDecryptKey != NULL )
        {
            IF_FAILED_BOOL_THROW(   ::CryptDecrypt( m_hDecryptKey,
                                                    NULL,
                                                    dwLength == dwRead,
                                                    0,
                                                    m_spBuffer.get(),
                                                    &dwToRead ),
                                    CObjectException( IDS_E_CRYPT_CRYPTO, wszFullPath ) );
        }

        // Write the data in the new file
        CTools::WriteFile( shFile.get(), m_spBuffer.get(), dwRead );

        _ASSERT( dwRead <= dwLength ); 
        dwLength -= dwRead;
    };

    // Aply this file's security settings
    if ( !( dwOptions & edNoDACL ) && !m_SIDs.empty() )
    {
        ApplyFileObjSecurity( spFile, wszFullPath );
    }
}



void CInPackage::ApplyFileObjSecurity( const IXMLDOMNodePtr& spObj, LPCWSTR wszName )
{
    IXMLDOMNodeListPtr	spAceList;
	IXMLDOMNodePtr		spAce;
	
	IF_FAILED_HR_THROW(	spObj->selectNodes( _bstr_t( L"ACE" ), &spAceList ),
						CBaseException( IDS_E_XML_PARSE ) );

	DWORD	dwAclSize	= sizeof( ACL );	// This will be the ACL header + all ACEs size
	DWORD	dwAceCount	= 0;

	// Calc the ACL's size
	while( S_OK == spAceList->nextNode( &spAce ) )
	{
		// Get the ACE type ( allowed/denied ace )
        DWORD dwType		= Convert::ToDWORD( CXMLTools::GetAttrib( spAce, L"Type" ).c_str() );
        DWORD dwID			= Convert::ToDWORD( CXMLTools::GetAttrib( spAce, L"SID" ).c_str() );

		IF_FAILED_BOOL_THROW(	( ACCESS_ALLOWED_ACE_TYPE == dwType ) || ( ACCESS_DENIED_ACE_TYPE == dwType ),
								CBaseException( IDS_E_XML_PARSE, ERROR_INVALID_DATA ) );

		// Get the SID for this ACE. If the sid is not in the map - skip this ACE
		TSIDMap::const_iterator it = m_SIDs.find( dwID );
        if ( it == m_SIDs.end() ) continue;
        PSID pSID = it->second.get();

		// Add the size of the ACE itself
		dwAclSize += ( ACCESS_ALLOWED_ACE_TYPE == dwType ? sizeof( ACCESS_ALLOWED_ACE) : sizeof( ACCESS_DENIED_ACE ) );
		// Remove the size of the SidStart member ( it is part of both the ACE and the SID )
		dwAclSize -= sizeof( DWORD );
		// Add the SID length
		_ASSERT( ::IsValidSid( pSID ) );
		dwAclSize += ::GetLengthSid( pSID );

		++dwAceCount;
	};

	// If no ACEs were found - exit
	if ( 0 == dwAceCount ) return;

	VERIFY( SUCCEEDED( spAceList->reset() ) );

	// Allocate the buffer for the ACL
	TByteAutoPtr spACL( new BYTE[ dwAclSize ] );
	PACL pACL = reinterpret_cast<PACL>( spACL.get() );
	VERIFY( ::InitializeAcl( pACL, dwAclSize, ACL_REVISION ) );

	// Build the ACL
	DWORD dwCurrentAce = 0;
	while( S_OK == spAceList->nextNode( &spAce ) )
	{
        // Get the ACE type ( allowed/denied ace )
        DWORD dwType		= Convert::ToDWORD( CXMLTools::GetAttrib( spAce, L"Type" ).c_str() );
        DWORD dwID			= Convert::ToDWORD( CXMLTools::GetAttrib( spAce, L"SID" ).c_str() );
        DWORD dwAceFlags	= Convert::ToDWORD( CXMLTools::GetAttrib( spAce, L"Flags" ).c_str() );
        DWORD dwAceMask		= Convert::ToDWORD( CXMLTools::GetAttrib( spAce, L"Mask" ).c_str() );

        _ASSERT( ( ACCESS_ALLOWED_ACE_TYPE == dwType ) || ( ACCESS_DENIED_ACE_TYPE == dwType ) );

		// Get the SID for this ACE. If the sid is not in the map - skip this ACE
        TSIDMap::const_iterator it = m_SIDs.find( dwID );
        if ( it == m_SIDs.end() ) continue;
        PSID pSID = it->second.get();

        if ( ACCESS_ALLOWED_ACE_TYPE == dwType )
        {
            VERIFY( ::AddAccessAllowedAce(	pACL,
                                            ACL_REVISION,
                                            dwAceMask,
                                            pSID ) );
        }
        else
        {
			VERIFY( ::AddAccessDeniedAce(	pACL,
                                            ACL_REVISION,
                                            dwAceMask,
                                            pSID ) );
        }

		// Set the ACE's flags
		// We cannot use AddAccessDeniedAceEx on NT4 - so set the flags directly
		ACCESS_ALLOWED_ACE* pACE = NULL;
		VERIFY( ::GetAce( pACL, dwCurrentAce, reinterpret_cast<LPVOID*>( &pACE ) ) );
		pACE->Header.AceFlags = static_cast<BYTE>( dwAceFlags );
		++dwCurrentAce;
	};

	// Finally - apply the ACL to the object
	IF_FAILED_BOOL_THROW( ::SetNamedSecurityInfo(	const_cast<LPWSTR>( wszName ),
													SE_FILE_OBJECT,
													DACL_SECURITY_INFORMATION,
													NULL,
													NULL,
													pACL,
													NULL ) == ERROR_SUCCESS,
							CObjectException( IDS_E_APPLY_DACL, wszName ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\core\importpackage.h ===
/*
****************************************************************************
|    Copyright (C) 2002  Microsoft Corporation
|
|    Component / Subcomponent
|        IIS 6.0 / IIS Migration Wizard
|
|    Based on:
|        http://iis6/Specs/IIS%20Migration6.0_Final.doc
|
|   Abstract:
|        ImportPackage COM class implementation
|
|   Author:
|        ivelinj
|
|   Revision History:
|        V1.00    March 2002
|
****************************************************************************
*/

#pragma once
#include "resource.h"
#include "IISMigrTool.h"
#include "IISHelpers.h"
#include "_IImportEvents_CP.H"
#include "Utils.h"
#include "Wrappers.h"
#include "ExportPackage.h"


_COM_SMARTPTR_TYPEDEF( ISiteInfo, __uuidof( ISiteInfo ) );

class CImportPackage;


// CSiteInfo - class for ISiteInfo. Created and exposed through CImportPackage
/////////////////////////////////////////////////////////////////////////////////////////
class CSiteInfo :
    public CComObjectRoot,
    public IDispatchImpl<ISiteInfo, &IID_ISiteInfo, &LIBID_IISMigrToolLib, /*wMajor =*/ 1, /*wMinor =*/ 0>
{
// COM Map
BEGIN_COM_MAP( CSiteInfo )
    COM_INTERFACE_ENTRY( ISiteInfo )
    COM_INTERFACE_ENTRY( IDispatch )    
END_COM_MAP()


// Construction
public:
    CSiteInfo                           ( void ){}


// ISiteInfo interface
public:
    STDMETHOD( get_SiteID )             (   /*[out, retval]*/ LONG* pVal );
    STDMETHOD( get_DisplayName )        (   /*[out, retval]*/ BSTR* pVal );
    STDMETHOD( get_ContentIncluded )    (   /*[out, retval]*/ VARIANT_BOOL* pVal );
    STDMETHOD( get_IsFrontPageSite )    (   /*[out, retval]*/ VARIANT_BOOL* pVal );
    STDMETHOD( get_HaveCertificates )   (   /*[out, retval]*/ VARIANT_BOOL* pVal );
    STDMETHOD( get_HaveCommands )       (   /*[out, retval]*/ VARIANT_BOOL* pVal );
    STDMETHOD( get_ContentSize )        (   /*[out, retval]*/ LONG* pVal );
    STDMETHOD( get_SourceRootDir )      (   /*[out, retval]*/ BSTR* pVal );
    STDMETHOD( get_ACLsIncluded )       (   /*[out, retval]*/ VARIANT_BOOL* pVal );
    
// Implementation
private:


// Data Members
private:
    IXMLDOMNodePtr                m_spSiteNode;

    friend CImportPackage;
};




// CImportPackage - COM class for IImportPackage interface
/////////////////////////////////////////////////////////////////////////////////////////
class CImportPackage : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CImportPackage, &CLSID_ImportPackage>,
    public IDispatchImpl<IImportPackage, &IID_IImportPackage, &LIBID_IISMigrToolLib, /*wMajor =*/ 1, /*wMinor =*/ 0>,
    public IConnectionPointContainerImpl<CImportPackage>,
    public CProxy_IImportEvents<CImportPackage>,
    public ISupportErrorInfoImpl<&IID_IImportPackage>
{
// COM Map
BEGIN_COM_MAP(CImportPackage)
    COM_INTERFACE_ENTRY(IImportPackage)
    COM_INTERFACE_ENTRY(IDispatch)    
    COM_INTERFACE_ENTRY(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP( CImportPackage )
    CONNECTION_POINT_ENTRY(__uuidof(_IImportEvents))
    CONNECTION_POINT_ENTRY( __uuidof( _IImportEvents ) )
END_CONNECTION_POINT_MAP()

DECLARE_REGISTRY_RESOURCEID( IDR_IMPORTPACKAGE )


// Data types
private:
    
    
// Construction / Destruction
public:
    CImportPackage                  (   void );
    ~CImportPackage                 (   void );



// IImportPackage methods
public:
    STDMETHOD( get_SiteCount )      (   /*[out, retval]*/ SHORT* pVal );
    STDMETHOD( get_TimeCreated )    (   /*[out, retval]*/ DATE* pVal );
    STDMETHOD( get_Comment )        (   /*[out, retval]*/ BSTR* pVal );
    STDMETHOD( get_SourceMachine )  (   /*[out, retval]*/ BSTR* pVal );
    STDMETHOD( GetSourceOSVer )     (   /*[out]*/BYTE* pMajor, 
                                        /*[out]*/BYTE* pMinor,
                                        /*[out]*/VARIANT_BOOL* pIsServer );
    STDMETHOD( GetSiteInfo )        (   /*[in]*/ SHORT SiteIndex, /*[out,retval]*/ ISiteInfo** ppISiteInfo );
    STDMETHOD( ImportSite )         (   /*[in]*/ SHORT nSiteIndex,
                                        /*[in]*/ BSTR bstrSiteRootDir,    
                                        /*[in]*/ LONG nOptions );
    STDMETHOD( LoadPackage )        (   /*[in]*/ BSTR bstrFilename, 
                                        /*[in]*/ BSTR bstrPassword );    

// Implementation
private:
    void        LoadPackageImpl     (   LPCWSTR wszFileName, LPCWSTR wszPassword );
    void        UnloadCurrentPkg    (   void );
    void        LoadXmlDoc          (   HANDLE hFile, DWORDLONG nOffset ); 
    void        ImportSessionKey    (   LPCWSTR wszPassword );

    void        ImportContent       (   const IXMLDOMNodePtr& spSite, LPCWSTR wszPath, DWORD dwOptions );
    void        ImportCertificate   (   const IXMLDOMNodePtr& spSite, DWORD dwOptions );
    void        ImportConfig        (   const IXMLDOMNodePtr& spSite, DWORD dwOptions );
    void        ExecPostProcess     (   const IXMLDOMNodePtr& spSite, DWORD dwOptions );

    void        CreateContentDirs   (   const IXMLDOMNodePtr& spSite, LPCWSTR wszRoot, DWORD dwOptions );
    void        ExtractPPFiles      (   const IXMLDOMNodePtr& spSite, LPCWSTR wszLocation );
    void        ExecPPCommands      (   const IXMLDOMNodePtr& spSite, LPCWSTR wszPPFilesLoc );
    void        ExecPPCmd           (   LPCWSTR wszText, DWORD dwTimeout, bool bIgnoreErrors, LPCWSTR wszTempDir );
    bool        CertHasPrivateKey   (   PCCERT_CONTEXT hCert );
    void        PreImportConfig     (   const IXMLDOMNodePtr& spSite, DWORD dwOptions );
    long        CalcNumberOfSteps   (   const IXMLDOMNodePtr& spSite, DWORD dwOptions );

    const TCertContextHandle PutCertsInStores(   HCERTSTORE hStore, bool bReuseCerts );

    
    IXMLDOMNodePtr  GetSiteNode     (   DWORD iSite );
    
    static void ExtractFileCallback (   void* pCtx, LPCWSTR wszFilename, bool bStartFile );
    
    

// Data members
private:
    DWORD                           m_dwPkgOptions;         // Options the package were created with
    TCryptProvHandle                m_shCryptProv;          // Crypt provider used for the decrypt handles. We need it to have existing crypt key
    TCryptKeyHandle                 m_shDecryptKey;         // Key used to decrypt the package data or XML secure data
    TFileHandle                     m_shPkgFile;            // The data file itself
    IXMLDOMDocumentPtr              m_spXmlDoc;             // This is our XML doc where all the data lives
    std::wstring                    m_strPassword;          // Package password - used when importing certificate
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\core\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// IISMigrTool.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

LPCWSTR		PKG_GUID = L"{95D72F11-47FA-476d-88FF-CCF9EFEBDEFA}";	// Used as file type mark
const DWORD	MAX_CMD_TIMEOUT		= 24 * 60 * 60;	// 24h in seconds

LPCWSTR		IMPMACRO_TEMPDIR	= L"FILES_DIR";
LPCWSTR		IMPMACRO_SITEIID	= L"SITE_ID";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\core\stdafx.h ===
/*
****************************************************************************
|    Copyright (C) 2002  Microsoft Corporation
|
|	Component / Subcomponent
|		IIS 6.0 / IIS Migration Wizard
|
|	Based on:
|		http://iis6/Specs/IIS%20Migration6.0_Final.doc
|
|   Abstract:
|		Precompiled header file
|
|   Author:
|        ivelinj
|
|   Revision History:
|        V1.00	March 2002
|
****************************************************************************
*/

#pragma once

#ifndef STRICT
#define STRICT
#endif

// NT Build compatability
#ifndef _DEBUG
#if ( DBG != 0 )
#define _DEBUG
#endif // DBG
#endif // _DEBUG


// Modify the following defines if you have to target a platform prior to the ones specified below.
// Refer to MSDN for the latest info on corresponding values for different platforms.
#ifndef WINVER				// Allow use of features specific to Windows 95 and Windows NT 4 or later.
#define WINVER 0x0400		// Change this to the appropriate value to target Windows 98 and Windows 2000 or later.
#endif

#ifndef _WIN32_WINNT		// Allow use of features specific to Windows NT 4 or later.
#define _WIN32_WINNT 0x0400	// Change this to the appropriate value to target Windows 2000 or later.
#endif						

#ifndef _WIN32_WINDOWS		// Allow use of features specific to Windows 98 or later.
#define _WIN32_WINDOWS 0x0410 // Change this to the appropriate value to target Windows Me or later.
#endif

#ifndef _WIN32_IE			// Allow use of features specific to IE 4.0 or later.
#define _WIN32_IE 0x0400	// Change this to the appropriate value to target IE 5.0 or later.
#endif

#define _ATL_APARTMENT_THREADED
#define _ATL_NO_AUTOMATIC_NAMESPACE

#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS	// some CString constructors will be explicit

// turns off ATL's hiding of some common and often safely ignored warning messages
#define _ATL_ALL_WARNINGS


#include <comdef.h>
#include <initguid.h>

// ATL

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>
#include <atlcom.h>

// STL
#pragma warning( push, 3 )
#include <list>
#include <memory>
#include <string>
#include <map>
#include <queue>
#pragma warning( pop )

// Common string list
typedef std::list<std::wstring>	TStringList;
typedef std::auto_ptr<BYTE>		TByteAutoPtr;

// Shared
#include <limits.h>
#include <iadmw.h>      // ABO definition
#include <iiscnfg.h>    // MD_ & IIS_MD_ defines
#include <iiscnfgp.h>   // IIS private defs
#include <msxml2.h>		// MSXML parser
#include <WinCrypt.h>	// CryptAPI
#include <fci.h>		// CAB Compress API
#include <FCNTL.H>		// Setup Api structures
#include <shlwapi.h>
#include <shellapi.h>
#include <Aclapi.h>		// ACL

#pragma comment( lib, "msxml2.lib" )	// CLSIDs, IIDs
#pragma comment( lib, "Advapi32.lib" )	// CLSIDs, IIDs
#pragma comment( lib, "setupapi.lib" )	
#pragma comment( lib, "shlwapi.lib" )
#pragma comment( lib, "fci.lib" )		// File Compress interface ( CAB compression )
#pragma comment( lib, "crypt32.lib" )	// Certificates


// Local
#include "Macros.h"
#include "resource.h"
#include "Exceptions.h"


// Shared constants
extern const DWORD	MAX_CMD_TIMEOUT;
extern LPCWSTR		PKG_GUID;

// Post-import macro strings
extern LPCWSTR		IMPMACRO_TEMPDIR;
extern LPCWSTR		IMPMACRO_SITEIID;


// Smart pointer declarations
_COM_SMARTPTR_TYPEDEF( IMSAdminBase, __uuidof( IMSAdminBase ) );
_COM_SMARTPTR_TYPEDEF( IXMLDOMDocument, __uuidof( IXMLDOMDocument ) );
_COM_SMARTPTR_TYPEDEF( IXMLDOMDocument2, __uuidof( IXMLDOMDocument2 ) );
_COM_SMARTPTR_TYPEDEF( IXMLDOMElement, __uuidof( IXMLDOMElement ) );
_COM_SMARTPTR_TYPEDEF( IXMLDOMText, __uuidof( IXMLDOMText ) );
_COM_SMARTPTR_TYPEDEF( IXMLDOMCDATASection, __uuidof( IXMLDOMCDATASection ) );
_COM_SMARTPTR_TYPEDEF( IXMLDOMNamedNodeMap, __uuidof( IXMLDOMNamedNodeMap ) );
_COM_SMARTPTR_TYPEDEF( IXMLDOMNodeList, __uuidof( IXMLDOMNodeList ) );
_COM_SMARTPTR_TYPEDEF( IXMLDOMNode, __uuidof( IXMLDOMNode ) );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\core\pkghandlers.h ===
#pragma once

#include "wrappers.h"


struct _CallbackInfo
{
    typedef void (*PFN_CALLBACK)( void*, LPCWSTR, bool );

    _CallbackInfo( PFN_CALLBACK pCB = NULL, void* pContext = NULL )
    {
        pCallback   = pCB;
        pCtx        = pContext;
    }

    

    PFN_CALLBACK    pCallback;
    void*           pCtx;
};


// Class for writing files to the package
// Note that the class does not own any of the handles it contains. It just caches them
/////////////////////////////////////////////////////////////////////////////////////////
class COutPackage
{
// Data types
public:
	enum AddFileOptions
	{
		afNone		    = 0x0000,
		afNoDACL	    = 0x0001,
        afAllowNoInhAce = 0x0002,   // Allows for inherited ACEs to be not exported. 
	};


private:
	enum
	{
		DefaultBufferSize	= 4 * 1024,
	};

	enum _SidType
	{
		sidInvalid,
		sidIISUser,
		sidWellKnown,
		sidExternal
	};
	// Used for exporting file object's security settings
	typedef std::list<_sid_ptr>	TSIDList;


	
// Ctor / Dtor
public:
	COutPackage						(	HANDLE hFile, bool bCompress, HCRYPTKEY hCryptKey );


// Class interface
public:
	void			AddFile			(	LPCWSTR wszName, 
										const IXMLDOMDocumentPtr& spXMLDoc,
										const IXMLDOMElementPtr& spEl,
										DWORD dwOptions )const;
	void			AddPath			(	LPCWSTR wszPath,
										const IXMLDOMDocumentPtr& spXMLDoc,
										const IXMLDOMElementPtr& spEl,
										DWORD dwOptions )const;
	void			WriteSIDsToXML	(	DWORD dwSiteID,
										const IXMLDOMDocumentPtr& spXMLDoc, 
										const IXMLDOMElementPtr& spEl )const;
	void			ResetSIDList	(	void )const{ m_SIDList.clear();}

    void            SetCallback     (   const _CallbackInfo& Info )const
    { 
        m_CallbackInfo = Info;
    }


// Implementation
private:
	DWORDLONG		GetCurrentPos	(	void )const;
	void			ExportFileDACL	(	LPCWSTR wszObject,
										const IXMLDOMDocumentPtr& spDoc,
										const IXMLDOMElementPtr& spRoot,
                                        bool bAllowSkipInherited )const;
	void			ExportAce		(	LPVOID pACE, 
										const IXMLDOMDocumentPtr& spDoc,
										const IXMLDOMElementPtr& spRoot,
                                        bool bAllowSkipInherited )const;
	DWORD			IDFromSID		(	PSID pSID )const;
	bool			GetSIDDetails	(	PSID pSID, 
										LPCWSTR wszIISUser, 
										LPCWSTR wszMachine,
										std::wstring& rstrAccount,
										std::wstring& rstrDomain,
										SID_NAME_USE& rSidUsage,
										_SidType& rSidType )const;
	void			WriteSIDToXML	(	const IXMLDOMElementPtr& spSid,
										DWORD dwID,
										LPCWSTR wszAccount,
										LPCWSTR wszDomain,
										SID_NAME_USE SidUsage,
										_SidType SidType )const;
	void			RemoveSidFromXML(	const IXMLDOMDocumentPtr& spDoc, DWORD nSidID )const;
	void			AddPathOnly		(	LPCWSTR wszPath,
										LPCWSTR wszName,
										const IXMLDOMDocumentPtr& spXMLDoc,
										const IXMLDOMElementPtr& spEl,
										DWORD dwOptions )const;


// Data members
private:
	mutable TSIDList	m_SIDList;		// Contains all SIDs for files, added to the package
	HANDLE				m_hFile;		// The file handle
	bool				m_bCompress;	// If true - files are compressed
	HCRYPTKEY			m_hCryptKey;	// If not null - used to encrypt files
	TByteAutoPtr		m_spBuffer;		// Buffer used for the file operations

    mutable _CallbackInfo   m_CallbackInfo; // Calbback for add file
};





// Class for restoring files/dirs from the package
/////////////////////////////////////////////////////////////////////////////////////////
class CInPackage
{
// Data types
public:
   	enum ExtractDirOptions
	{
		edNone		= 0x0000,
		edNoDACL	= 0x0001        // Security settings will not be extracted
	};

private:
    typedef std::map<DWORD, _sid_ptr>	TSIDMap;    // These are the SIDs for file/dir permissions

    enum
	{
		DefaultBufferSize	= 4 * 1024,
	};


// Class interface
public:
    CInPackage                  (   const IXMLDOMNodePtr& spSite,
                                    HANDLE hFile, 
                                    bool bCompressed, 
                                    HCRYPTKEY hDecryptKey );


    void    ExtractVDir         (   const IXMLDOMNodePtr& spVDir, DWORD dwOptions );
    void    ExtractFile         (   const IXMLDOMNodePtr& spFile, LPCWSTR wszDir, DWORD dwOptions );

    void    SetCallback         (   const _CallbackInfo& Info )const
    { 
        m_CallbackInfo = Info;
    }

// Implementation
private:
    void    LoadSIDs            (   const IXMLDOMNodePtr& spSIDs );
    bool    LookupSID           (	const IXMLDOMNodePtr& spSID,
						            LPCWSTR wszLocalMachine,
                                    LPCWSTR wszSourceMachine,
							        DWORD& rdwID,
							        TByteAutoPtr& rspData );
    void    ExtractDir          (   const IXMLDOMNodePtr& spDir, LPCWSTR wszRoot, DWORD dwOptions );
    void    ApplyFileObjSecurity(   const IXMLDOMNodePtr& spObj, LPCWSTR wszName );
    



// Data
private:
    TSIDMap             m_SIDs;         // SID used for file.dir access permissions
    HANDLE              m_hFile;        // The input file ( the package )
    bool                m_bCompressed;  // Is the package data compressed
    HCRYPTKEY           m_hDecryptKey;  // Used to decrypt the data. If NULL - data is not encrypted
    TByteAutoPtr        m_spBuffer;     // General memory buffer

    mutable _CallbackInfo   m_CallbackInfo;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\core\_iexportevents_cp.h ===
// Wizard-generated connection point proxy class
// WARNING: This file may be regenerated by the wizard


#pragma once

template<class T>
class CProxy_IExportEvents :
	public IConnectionPointImpl<T, &__uuidof(_IExportEvents)>
{
public:
	HRESULT Fire_OnStateChange( enExportState  State,  VARIANT  vntArg1,  VARIANT  vntArg2,  VARIANT  vntArg3,  VARIANT_BOOL *  pbContinue)
	{
		HRESULT hr = S_OK;
		T * pThis = static_cast<T *>(this);
		int cConnections = m_vec.GetSize();

		for (int iConnection = 0; iConnection < cConnections; iConnection++)
		{
			pThis->Lock();
			CComPtr<IUnknown> punkConnection = m_vec.GetAt(iConnection);
			pThis->Unlock();

			IDispatch * pConnection = static_cast<IDispatch *>(punkConnection.p);

			if (pConnection)
			{
				CComVariant avarParams[4];
				avarParams[3] = State;
				avarParams[2] = vntArg1;
				avarParams[1] = vntArg2;
				avarParams[0] = vntArg3;
				CComVariant varResult;

				DISPPARAMS params = { avarParams, NULL, 4, 0 };
				hr = pConnection->Invoke(1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &params, &varResult, NULL, NULL);

				if ( SUCCEEDED( hr ) )
				{
					*pbContinue = V_BOOL( &varResult );
				}
			}
		}
		return hr;
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\core\_iimportevents_cp.h ===
// Wizard-generated connection point proxy class
// WARNING: This file may be regenerated by the wizard


#pragma once

template<class T>
class CProxy_IImportEvents :
	public IConnectionPointImpl<T, &__uuidof(_IImportEvents)>
{
public:
	HRESULT Fire_OnStateChange( enImportState  State,  VARIANT  vntArg1,  VARIANT  vntArg2,  VARIANT  vntArg3,  VARIANT_BOOL *  pbContinue)
	{
		HRESULT hr = S_OK;
		T * pThis = static_cast<T *>(this);
		int cConnections = m_vec.GetSize();

		for (int iConnection = 0; iConnection < cConnections; iConnection++)
		{
			pThis->Lock();
			CComPtr<IUnknown> punkConnection = m_vec.GetAt(iConnection);
			pThis->Unlock();

			IDispatch * pConnection = static_cast<IDispatch *>(punkConnection.p);

			if (pConnection)
			{
				CComVariant avarParams[4];
				avarParams[3] = State;
				avarParams[2] = vntArg1;
				avarParams[1] = vntArg2;
				avarParams[0] = vntArg3;
				CComVariant varResult;

				DISPPARAMS params = { avarParams, NULL, 4, 0 };
				hr = pConnection->Invoke(1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &params, &varResult, NULL, NULL);
			}
		}
		return hr;
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\core\utils.cpp ===
/*
****************************************************************************
|	Copyright (C) 2002  Microsoft Corporation
|
|	Component / Subcomponent
|		IIS 6.0 / IIS Migration Wizard
|
|	Based on:
|		http://iis6/Specs/IIS%20Migration6.0_Final.doc
|
|   Abstract:
|		Utility helpers for migration
|
|   Author:
|        ivelinj
|
|   Revision History:
|        V1.00	March 2002
|
****************************************************************************
*/
#include "StdAfx.h"
#include "utils.h"


/* 
	Concatenates wszPath and wszPathToAdd. Adds '\' between them if needed
	Result is stored into wszBuffer which is supposed to be large enough
*/
void CDirTools::PathAppendLocal( LPWSTR wszBuffer, LPCWSTR wszPath, LPCWSTR wszPathToAdd )
{
	// Buffer must be large enough!
	// Usually it's MAX_PATH + 1
	// Fail gracefully in release. However this is not expected to happen at all
	if ( ( ::wcslen( wszPath ) + ::wcslen( wszPathToAdd ) + 1 ) > MAX_PATH )
	{
        _ASSERT( false );		
		throw CBaseException( IDS_E_OUTOFMEM, ERROR_SUCCESS );
	}	
	
	if ( wszBuffer != wszPath )
	{
        ::wcscpy( wszBuffer, wszPath );
	}

	// If the second part starts with '\' - skip it
	LPCWSTR wszSecond = wszPathToAdd[ 0 ] == L'\\' ? ( wszPathToAdd + 1 ) : wszPathToAdd;

	size_t LastCh = ::wcslen( wszBuffer ) - 1;
	if ( wszBuffer[ LastCh ] != L'\\' )
	{
		wszBuffer[ LastCh + 1 ] = L'\\';
		wszBuffer[ LastCh + 2 ] = 0;
	}

	::wcscat( wszBuffer, wszSecond );
}




/* 
	Cleanup all files from a temp ( wszTempDir ) dir as well as any subdirs.
	If bRemoveRoot is true, wszTempDir is removed at the end
*/
void CDirTools::CleanupDir(	LPCWSTR wszTempDir, 
							bool bRemoveRoot /*=true*/,
							bool bReportErrors /*=false*/ )
{
	WCHAR		wszPath[ MAX_PATH + 1 ];
	CFindFile	Search;

	WIN32_FIND_DATAW fd = { 0 };

	bool bFound = Search.FindFirst(	wszTempDir,
									CFindFile::ffGetDirs |
										CFindFile::ffGetFiles |
										CFindFile::ffAbsolutePaths |
										CFindFile::ffAddFilename,
									wszPath,
									&fd );
	
	while( bFound )
	{
		// If it is a subdir - delete recursively
		if ( fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
		{
			CleanupDir( wszPath, true, bReportErrors );
		}
		else
		{
			// Clear any possible read-only flags
			::SetFileAttributes( wszPath, FILE_ATTRIBUTE_NORMAL );

			// Delete the file. 
			if ( !::DeleteFileW( wszPath ) && bReportErrors )
			{
                throw CObjectException( IDS_E_DELETEFILE, wszPath );
			}
		}

		bFound = Search.Next( NULL, wszPath, &fd );
	};
	
	// Remove the directory ( should be empty now )
	if ( bRemoveRoot )
	{
		if ( !::RemoveDirectoryW( wszTempDir ) && bReportErrors )
		{
			throw CObjectException( IDS_E_DELETEDIR, wszTempDir );
		}
	}
}


/* 
	COunt the number of files ( or dirs if bDirOnly = true ) in
	wszDir and all subdirs. Used for the export/import events to provide progress info
*/
DWORD CDirTools::FileCount( LPCWSTR wszDir, WORD wOptions )
{
	DWORD		dwResult = 0;
	CFindFile	Search;

	bool bFound = Search.FindFirst( wszDir, wOptions, NULL, NULL );

	while( bFound )
	{
		++dwResult;
		bFound = Search.Next( NULL, NULL, NULL );		
	};

	return dwResult;
}


DWORDLONG CDirTools::FilesSize( LPCWSTR wszDir, WORD wOptions )
{
	DWORDLONG	        dwResult    = 0;
    WIN32_FIND_DATAW    fd          = { 0 };
	CFindFile	        Search;
    

	bool bFound = Search.FindFirst( wszDir, wOptions, NULL, &fd );

	while( bFound )
	{
        dwResult += ( fd.nFileSizeHigh << 32 ) | fd.nFileSizeLow;
		bFound = Search.Next( NULL, NULL, &fd );
	};

	return dwResult;
}


/*
	Checks if wszPath1 and wszPath2 are contained in one another
	wszPath1 and wszPath2 are expected to be fully qualified paths
	Return value:
		0 - paths are not nested
		1 - wszPath1 is subdir of wszPath2
		2 - wszPath2 is subdir of wszPath1
		3 - wszPath1 == wszPath2
*/
int	CDirTools::DoPathsNest( LPCWSTR wszPath1, LPCWSTR wszPath2 )
{
	_ASSERT( ( wszPath1 != NULL ) && ( wszPath2 != NULL ) );

	WCHAR	wszP1[ MAX_PATH + 1 ];
	WCHAR	wszP2[ MAX_PATH + 2 ];

	VERIFY( ::PathCanonicalizeW( wszP1, wszPath1 ) );
	VERIFY( ::PathCanonicalizeW( wszP2, wszPath2 ) );
	::PathAddBackslashW( wszP1 );
	::PathAddBackslashW( wszP2 );

	// No both paths end with backslash

	size_t	nLen1 = ::wcslen( wszP1 );
	size_t	nLen2 = ::wcslen( wszP2 );

	// Strings have nothing in common
	if ( ::_wcsnicmp( wszP1, wszP2, min( nLen1, nLen2 ) ) != 0 ) return 0;
	
	// If wszPath1 is shorter - wszPath2 is subdir
	if ( nLen1 < nLen2 )
	{
		return 2;
	}
	else if ( nLen1 > nLen2 )
	{
		return 1;
	}
	// nLen1 == nLen 2 - paths match
	else
	{
		return 3;
	}
}



// CTempDir implementation
/////////////////////////////////////////////////////////////////////////////////////////
CTempDir::CTempDir( LPCWSTR wszTemplate /*= L"Migr"*/ )
{
    WCHAR	wszTempPath[ MAX_PATH + 1 ];
	WCHAR	wszBuffer[ MAX_PATH + 1 ];
		
	// Get the temp path
	// The temp path always ends with slash		
	VERIFY( ::GetTempPathW( MAX_PATH + 1, wszTempPath ) != 0 );
	
	// Build the name of the dir ( get the first 4 symbols from wszTemplate )
	::swprintf( wszBuffer, L"~%.4s", wszTemplate );

    // Build the full template ( the temp path + the first 4 symbols from the wszTemplate
	// The result will look simething like "c:\Temp\~Tmpl\"
	CDirTools::PathAppendLocal( wszTempPath, wszTempPath, wszBuffer );	

	// Try to create the temp subdir
	BYTE nIndex	= 0;

	while( nIndex < UCHAR_MAX )
	{
		// Build the full temp path ( including the dir index )
		::swprintf( wszBuffer, L"%s_%02d\\", wszTempPath, ++nIndex );

		// Try to create that dir
		if ( !::CreateDirectoryW( wszBuffer, NULL ) )
		{
			// The error is not that the dir exists - nothing more to do here
			if ( ::GetLastError() != ERROR_ALREADY_EXISTS )
			{
				throw CObjectException( IDS_E_CANNOT_CREATE_TEMPDIR, wszBuffer );
			}
		}
		else
		{
			// Exit the loop - we have temp dir now
			break;
		}
	};

	m_strDir = wszBuffer;
}


CTempDir::~CTempDir()
{
	try
	{
        CleanUp();
	}
	catch(...)
	{
		if ( !std::uncaught_exception() )
		{
			throw;
		}
	}
}


void CTempDir::CleanUp( bool bReportErrors /*=false*/ )
{
	if ( !m_strDir.empty() )
	{
		CDirTools::CleanupDir( m_strDir.c_str(), true, bReportErrors );
		m_strDir.erase();
	}
}





// CTools implementation
/////////////////////////////////////////////////////////////////////////////////////////

/* 
	Return true if the current user is member of the Administrators group.
	Caller is NOT expected to be impersonating anyone and is expected to be able to open their own process and process token.
*/
bool CTools::IsAdmin()
{
	BOOL						bIsAdmin		= FALSE;
	SID_IDENTIFIER_AUTHORITY	NtAuthority = SECURITY_NT_AUTHORITY;
	PSID						AdminSid	= { 0 };	

	if ( ::AllocateAndInitializeSid(	&NtAuthority,
										2,	// Number of subauthorities
										SECURITY_BUILTIN_DOMAIN_RID,
										DOMAIN_ALIAS_RID_ADMINS,
										0, 
										0, 
										0, 
										0, 
										0, 
										0,
										&AdminSid ) ) 
	{
		if ( !::CheckTokenMembership( NULL, AdminSid, &bIsAdmin ) ) 
		{
			bIsAdmin = FALSE;
		}
    }

	::GlobalFree( AdminSid );
	
	return ( bIsAdmin != FALSE );
}


/*
	Returns true if the IISAdmin service is running
	We do not check for W3svc as we need the metadata only
*/
bool CTools::IsIISRunning()
{
	bool bResult = false;

	LPCWSTR	SERVICE_NAME = L"IISADMIN";

	// Open the SCM on the local machine
    SC_HANDLE   schSCManager = ::OpenSCManagerW( NULL, NULL, SC_MANAGER_ALL_ACCESS );
	_ASSERT( schSCManager != NULL );	// We alredy checked that we are Admins
     
    SC_HANDLE   schService = ::OpenServiceW( schSCManager, SERVICE_NAME, SERVICE_QUERY_STATUS );
    
	// The service is not installed
	if ( schService != NULL )
	{
        SERVICE_STATUS ssStatus;

		VERIFY( ::QueryServiceStatus( schService, &ssStatus ) );
    
		bResult = ( ssStatus.dwCurrentState == SERVICE_RUNNING );
    
		VERIFY( ::CloseServiceHandle( schService ) );
	}
    
	VERIFY( ::CloseServiceHandle( schSCManager ) );
    
	return bResult;
}


/* 
	Returns the OS ver in format ###. First digit is Major version, second - minor version,
	Third - 0 if Workstation, 1 if server
	The function returns 0 if the platform is not supported in terms of the Migration Project
	( supported platforms are WinNT ver4.0 and above )

*/
WORD CTools::GetOSVer()
{
	OSVERSIONINFOEXW	vi		= { sizeof( OSVERSIONINFOEXW ) };
	WORD				wRes	= 0;

	VERIFY( ::GetVersionExW( reinterpret_cast<OSVERSIONINFOW*>( &vi ) ) );

	if ( VER_PLATFORM_WIN32_NT == vi.dwPlatformId )
	{
		wRes = static_cast<WORD>( ( vi.dwMajorVersion * 100 ) + ( vi.dwMinorVersion * 10 ) );
		
		if ( ( VER_NT_SERVER == vi.wProductType ) || ( VER_NT_DOMAIN_CONTROLLER == vi.wProductType ) )
		{
			wRes += 1;
		}
	}

	return wRes;
}


/*
	Returns true if the system drive is NTFS volume
*/
bool CTools::IsNTFS()
{
	const UINT BUFF_LEN = 32;	// Should be large enough to hold the volume and the file system type

	WCHAR wszBuffer[ BUFF_LEN ];

	// Get the system drive letter
	VERIFY( ::ExpandEnvironmentStringsW( L"%SystemDrive%", wszBuffer, BUFF_LEN ) != 0 );

	// wszBuffer containts the drive only - add the slash to make the volume string
	::wcscat( wszBuffer, L"\\" );

	DWORD dwMaxComponentLength	= 0;
	DWORD dwSystemFlags			= 0;

	WCHAR wszFileSystem[ BUFF_LEN ];
	
	VERIFY( ::GetVolumeInformationW(	wszBuffer,
										NULL,
										0,
										NULL,
										&dwMaxComponentLength,
										&dwSystemFlags,
										wszFileSystem,
										BUFF_LEN ) );

	return ::StrCmpIW( wszFileSystem, L"NTFS" ) == 0;
}



/*
	Sets the COM error info in the current thread
*/
void CTools::SetErrorInfo( LPCWSTR wszError )
{
	_ASSERT( wszError != NULL );

	IErrorInfoPtr			spErrorInfo;
	ICreateErrorInfoPtr		spNewErrorInfo;

	VERIFY( SUCCEEDED( ::CreateErrorInfo( &spNewErrorInfo ) ) );

	VERIFY( SUCCEEDED( spNewErrorInfo->SetDescription( const_cast<LPOLESTR>( wszError ) ) ) );

	spErrorInfo = spNewErrorInfo;
	
	VERIFY( SUCCEEDED( ::SetErrorInfo( 0, spErrorInfo ) ) );
}



void CTools::SetErrorInfoFromRes( UINT nResID )
{
	_ASSERT( nResID != 0 );

	WCHAR wszBuffer[ 1024 ];	

	VERIFY( ::LoadStringW( _Module.GetModuleInstance(), nResID, wszBuffer, 1024 ) );

	SetErrorInfo( wszBuffer );
}



// Implementation idea borrowed from trustapi.cpp
bool CTools::IsSelfSignedCert( PCCERT_CONTEXT pCert )
{
	_ASSERT( pCert != NULL );

	if ( !::CertCompareCertificateName(	pCert->dwCertEncodingType,
										&pCert->pCertInfo->Issuer,
										&pCert->pCertInfo->Subject ) )
    {
        return false;
    }

    DWORD   dwFlag = CERT_STORE_SIGNATURE_FLAG;

	if (	!::CertVerifySubjectCertificateContext( pCert, pCert, &dwFlag ) || 
			( dwFlag & CERT_STORE_SIGNATURE_FLAG ) )
    {
        return false;
    }

    return true;
}


/*
	Checks a certificate against the local base certificate policy
*/
bool CTools::IsValidCert( PCCERT_CONTEXT hCert, DWORD& rdwError )
{
	_ASSERT( hCert != NULL );

    rdwError = ERROR_SUCCESS;

	// First - try to create a certificate chain for this cert
	PCCERT_CHAIN_CONTEXT	pCertChainContext = NULL;

	// Use default chain parameters
	CERT_CHAIN_PARA CertChainPara = { sizeof( CERT_CHAIN_PARA ) };

	if ( !::CertGetCertificateChain(	HCCE_LOCAL_MACHINE,
										hCert,
										NULL,
										NULL,
										&CertChainPara,
										0,
										NULL,
										&pCertChainContext ) )
	{
		// Chain cannot be created - the certificate is not valid ( possible reason is that a issuer is missing )
		rdwError = ::GetLastError();
		return false;
	}

	CERT_CHAIN_POLICY_PARA		PolicyParam		= { sizeof( CERT_CHAIN_POLICY_PARA ) };
	CERT_CHAIN_POLICY_STATUS	PolicyStatus	= { sizeof( CERT_CHAIN_POLICY_STATUS ) };
		
	if ( !::CertVerifyCertificateChainPolicy(	CERT_CHAIN_POLICY_BASE,
												pCertChainContext,
												&PolicyParam,
												&PolicyStatus ) )
	{
		rdwError = PolicyStatus.dwError;
		return false;
	}

	return true;
}


/*
	Adds a certificate context to one of the system cert stores ( "ROOT", "MY", "CA" )
	Returns the context of the inserted cert
*/
const TCertContextHandle CTools::AddCertToSysStore( PCCERT_CONTEXT pContext, LPCWSTR wszStore, bool bReuseCerts )
{
	_ASSERT( pContext != NULL );
	_ASSERT( wszStore != NULL );

	TCertContextHandle  shResult;
	TCertStoreHandle    shStore( ::CertOpenSystemStoreW( NULL, wszStore ) );

	IF_FAILED_BOOL_THROW(	shStore.IsValid(),
							CBaseException( IDS_E_OPEN_CERT_STORE ) );

	IF_FAILED_BOOL_THROW(	::CertAddCertificateContextToStore(	shStore.get(),
																pContext,
																bReuseCerts ? 
																	CERT_STORE_ADD_USE_EXISTING : 
																	CERT_STORE_ADD_REPLACE_EXISTING,
																&shResult ),
								CBaseException( IDS_E_ADD_CERT_STORE ) );
	return shResult;
}



/* 
    Obtains a crypt key derived from the password
*/
const TCryptKeyHandle CTools::GetCryptKeyFromPwd( HCRYPTPROV hCryptProv, LPCWSTR wszPassword )
{
    _ASSERT( hCryptProv != NULL );
    _ASSERT( wszPassword != NULL );

    TCryptKeyHandle     shKey;
    TCryptHashHandle    shHash;

    IF_FAILED_BOOL_THROW(   ::CryptCreateHash(    hCryptProv,
                                                  CALG_MD5,
                                                  NULL,
                                                  0,
                                                  &shHash ),
                            CBaseException( IDS_E_CRYPT_KEY_OR_HASH ) );

    // Add the password to the hash
    IF_FAILED_BOOL_THROW(   ::CryptHashData(    shHash.get(),
                                                ( BYTE* )( wszPassword ), 
                                                static_cast<DWORD>( ::wcslen( wszPassword ) * sizeof( WCHAR ) ),
                                                0 ),
                            CBaseException( IDS_E_CRYPT_KEY_OR_HASH ) );

    // Get a key derived from the password
    // Stream cypher is used
    IF_FAILED_BOOL_THROW(   ::CryptDeriveKey(   hCryptProv,
                                                CALG_RC4,
                                                shHash.get(),
                                                0x00800000 | CRYPT_CREATE_SALT,    // 128bit RC4 key
                                                &shKey ),
                            CBaseException( IDS_E_CRYPT_KEY_OR_HASH ) );

    return shKey;
}



std::wstring CTools::GetMachineName()
{
	DWORD dwLen = MAX_COMPUTERNAME_LENGTH + 1;
	WCHAR wszCompName[ MAX_COMPUTERNAME_LENGTH + 1 ];
	VERIFY( ::GetComputerNameW( wszCompName, &dwLen ) );

	return std::wstring( wszCompName );
}



ULONGLONG CTools::GetFilePtrPos( HANDLE hFile )
{
	_ASSERT( ( hFile != NULL ) && ( hFile != INVALID_HANDLE_VALUE ) );

	LONG	nHigh = 0;
	DWORD	dwLow = ::SetFilePointer( hFile, 0, &nHigh, FILE_CURRENT );

	IF_FAILED_BOOL_THROW(	( dwLow != INVALID_SET_FILE_POINTER ) || ( ::GetLastError() == ERROR_SUCCESS ),
							CBaseException( IDS_E_SEEK_PKG ) );

	return ( ( nHigh << 32 ) | dwLow );
}



void CTools::SetFilePtrPos( HANDLE hFile, DWORDLONG nOffset )
{
    _ASSERT( ( hFile != NULL ) && ( hFile != INVALID_HANDLE_VALUE ) );

    LONG	nHigh = static_cast<LONG>( nOffset >> 32 );
    DWORD	dwLow = ::SetFilePointer(   hFile, 
                                        static_cast<LONG>( nOffset & ULONG_MAX ), 
                                        &nHigh, 
                                        FILE_BEGIN );

	IF_FAILED_BOOL_THROW(	( dwLow != INVALID_SET_FILE_POINTER ) || ( ::GetLastError() == ERROR_SUCCESS ),
							CBaseException( IDS_E_SEEK_PKG ) );
}





// CFindFile implementation
/////////////////////////////////////////////////////////////////////////////////////////
CFindFile::CFindFile()
{
	m_wOptions = 0;
}



CFindFile::~CFindFile()
{
	try
	{
        Close();
	}
	catch(...)
	{
		if ( !std::uncaught_exception() )
		{
			throw;
		}
	}
}



bool CFindFile::FindFirst(	LPCWSTR wszDirToScan, 
							WORD wOptions,
							LPWSTR wszFileDir,
							WIN32_FIND_DATAW* pData )
{
	_ASSERT( wszDirToScan != NULL );
	_ASSERT( ::PathIsDirectory( wszDirToScan ) );
	_ASSERT( !m_shSearch.IsValid() );	// Call Close() first

	// Must search for at least files or dirs
	_ASSERT( ( wOptions & ffGetFiles ) || ( wOptions & ffGetDirs ) );

	m_wOptions = wOptions;
	bool bFound	= false;

	// Push the root dir into the list
	m_DirsToScan.push_front( std::wstring( L"\\" ) );

	// Set the search path
	m_strRootDir = wszDirToScan;

	// Get the first match ( if any )
	bFound = Next( NULL, wszFileDir, pData );
	
	return bFound;
}


/*
	Gets the next file from e previously opened search

	*pbDirchanged is set to TRUE when the file is found, but not in the last dir scanned
	For example if the search was opened in the Dir "c:\\", the first time a file from "c:\\Temp"
	is returned, *pbDirChagned will be true

	wszDir will hold the dir where the object was found, relative to the search root dir
	For example if the search was opened in "c:\\", and a matching object was found in c:\\Temp" - 
	wszDir will be "Temp"
	If ffAbsolutePaths is specified, the wszDir will be absolute ( includeing the name of the root dir )

	pData will be filled with the info about the match found	
*/
bool CFindFile::Next(	bool* pbDirChanged,
						LPWSTR wszDir,
						WIN32_FIND_DATAW* pData )
{
	WCHAR	wszBuffer[ MAX_PATH + 1 ];
	bool	bDirChanged	= true;
	bool	bFound		= false;

	WIN32_FIND_DATAW fd = { 0 };

	// Try to find a match in the current search
	if ( m_shSearch.IsValid() )
	{
		bFound = ContinueCurrent( /*r*/fd );
		bDirChanged = !bFound;	// No file was found in the current dir - new dir will be scanned
	}

	// If nothing found - try to find something in the rest of the subdirs
	while( !bFound && !m_DirsToScan.empty() )
	{
		// Get a dir from the list with pending dirs
		const std::wstring strCurrentDir = m_DirsToScan.front();
		m_DirsToScan.pop_front();

		// Create the full path to the current dir
		CDirTools::PathAppendLocal( wszBuffer, m_strRootDir.c_str(), strCurrentDir.c_str() );

		bFound = ScanDir( wszBuffer, strCurrentDir.c_str(), /*r*/fd );
	};

	if ( bFound )
	{
        // Set the dir where the file was found
		// It will be absolute or relative to the search root
		if ( wszDir != NULL )
		{
			CDirTools::PathAppendLocal( wszDir, 
										ffAbsolutePaths & m_wOptions ? m_strRootDir.c_str() : L"", 
										m_strCurrentDir.c_str() );

			// Add the filename if needed
			if ( ffAddFilename & m_wOptions )
			{
				CDirTools::PathAppendLocal( wszDir, wszDir, fd.cFileName );
			}
		}
	
        if ( pbDirChanged != NULL )
		{
			*pbDirChanged = ( bFound ? bDirChanged : false );
		}

		if ( pData != NULL )
		{
			*pData = fd;
		}
	}
	else
	{
		if ( wszDir != NULL )
		{
			wszDir[ 0 ] = L'\0';
		}

        // Close the search if no more matches
		Close();
	}

	return bFound;
}



void CFindFile::Close()
{
	m_wOptions = 0;
	m_shSearch.Close();	
	m_DirsToScan.clear();
	m_strRootDir.erase();
	m_strCurrentDir.erase();
}


/* 
	Scans only the wszDir for appropriate result
*/
bool CFindFile::ScanDir( LPCWSTR wszDirToScan, LPCWSTR wszRelativeDir, WIN32_FIND_DATAW& FileData )
{
	_ASSERT( wszDirToScan != NULL );
	_ASSERT( wszRelativeDir != NULL );

	WCHAR	            wszBuffer[ MAX_PATH + 1 ];
    WIN32_FIND_DATAW    fd = { 0 };

    ::ZeroMemory( &FileData, sizeof( FileData ) );
    	
	// Build the search string
	CDirTools::PathAppendLocal( wszBuffer, wszDirToScan, L"*.*" );

	m_shSearch	= ::FindFirstFileW( wszBuffer, &fd );
		
	if ( !m_shSearch.IsValid() ) throw CObjectException( IDS_E_ENUM_FILES, wszDirToScan );

	bool bFileFound = false;

	// Find the first file/dir to return
	do
	{
		bFileFound = CheckFile( wszRelativeDir, fd );

	}while( !bFileFound && ::FindNextFileW( m_shSearch.get(), &fd ) );

	// Close the search if a file was not found - we don't need it anymore
	if ( !bFileFound )
	{
		m_shSearch.Close();
		m_strCurrentDir.erase();
	}
	else
	{
		m_strCurrentDir = wszRelativeDir;
	}

    FileData = fd;

	return bFileFound;
}


/* 
	Check if data in 'fd' is a match for us
	If the file is a dir, it will be added to the pending dirs
	Returns True if the file is OK. or False if search must continue
*/
bool CFindFile::CheckFile( LPCWSTR wszRelativeDir, const WIN32_FIND_DATAW& fd )
{
	WCHAR	wszBuffer[ MAX_PATH + 1 ];
	bool	bFileFound = false;

	// Current file is dir
	if ( ( fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) != 0 )
	{
		// Every dir contains at least two dirs - "." and "..". Skip them
		if ( fd.cFileName[ 0 ] != L'.' )
		{
			// If we do a recursive search - add the dir name to the relative path 
			// and push it in the list. This dir will be scaned later for files/dirs
			if ( m_wOptions & ffRecursive )
			{
                CDirTools::PathAppendLocal( wszBuffer, wszRelativeDir, fd.cFileName );
				m_DirsToScan.push_back( std::wstring( wszBuffer ) );
			}

			// If we are searching for dirs - we have the result
			bFileFound = ( m_wOptions & ffGetDirs ) != 0;
		}
	}
	else
	{
		// File is found.
		// If we are searching for files - we have the result
		bFileFound = ( m_wOptions & ffGetFiles ) != 0;
	}
	
	return bFileFound;
}



/* 
	Try to find a match from the current m_shSearch.
	Return True if there is a match. False otherwise
*/
bool CFindFile::ContinueCurrent( WIN32_FIND_DATAW& FileData )
{
	_ASSERT( m_shSearch.IsValid() );

	bool bFileFound	= false;

	while( !bFileFound && ::FindNextFileW( m_shSearch.get(), &FileData ) )
	{
		bFileFound = CheckFile( m_strCurrentDir.c_str(), FileData );
	};

	// Close the current search handle. Not needed anymore
    if ( !bFileFound )
	{
		m_shSearch.Close();
		m_strCurrentDir.erase();
	}

	return bFileFound;
}




// CXMLTools implementation
/////////////////////////////////////////////////////////////////////////////////////////
IXMLDOMElementPtr CXMLTools::AddTextNode(	const IXMLDOMDocumentPtr& spDoc,
											const IXMLDOMElementPtr& spEl,
											LPCWSTR wszNodeName,
											LPCWSTR wszValue )
{
	IXMLDOMElementPtr	spNode;
	IXMLDOMTextPtr		spText;
	_bstr_t				bstrName( wszNodeName );
	_bstr_t				bstrValue( wszValue );

	IF_FAILED_HR_THROW( spDoc->createElement( bstrName, &spNode ),
						CBaseException( IDS_E_XML_GENERATE ) );
    
	IF_FAILED_HR_THROW( spDoc->createTextNode( bstrValue, &spText ),
						CBaseException( IDS_E_XML_GENERATE ) );

    IF_FAILED_HR_THROW( spNode->appendChild( spText, NULL ),
						CBaseException( IDS_E_XML_GENERATE ) );
	
	IF_FAILED_HR_THROW( spEl->appendChild( spNode, NULL ),
						CBaseException( IDS_E_XML_GENERATE ) );

	return spNode;
}



const std::wstring CXMLTools::GetAttrib( const IXMLDOMNodePtr& spElement, LPCWSTR wszName )
{
	_ASSERT( spElement != NULL );
	_ASSERT( wszName != NULL );

	IXMLDOMNamedNodeMapPtr	spAttribs;
	IXMLDOMNodePtr			spNode;
    CComBSTR                bstrRes;

	// Get the attribs collection
	IF_FAILED_HR_THROW(	spElement->get_attributes( &spAttribs ),
						CBaseException( IDS_E_XML_PARSE ) );

	// Get the attrib of interest
	// This succeeds even if the item is not found
	IF_FAILED_HR_THROW( spAttribs->getNamedItem( _bstr_t( wszName ), &spNode ),
						CBaseException( IDS_E_XML_PARSE ) );

	if ( spNode == NULL ) throw CBaseException( IDS_E_XML_PARSE, ERROR_NOT_FOUND );
    
    // Get the value
	IF_FAILED_HR_THROW( spNode->get_text( &bstrRes ),
						CBaseException( IDS_E_XML_PARSE ) );

    return std::wstring( bstrRes );
}


void CXMLTools::LoadXMLFile( LPCWSTR wszFile, IXMLDOMDocumentPtr& rspDoc )
{
	_variant_t			vntFile = wszFile;
	VARIANT_BOOL		vntRes	= VARIANT_FALSE;
	IXMLDOMDocumentPtr	spDoc;

	// Create doc instance
	IF_FAILED_HR_THROW(	spDoc.CreateInstance( CLSID_DOMDocument ),
						CBaseException( IDS_E_NO_XML_PARSER ) );	
		
	// Retursn success always
	VERIFY( SUCCEEDED( spDoc->load( vntFile, &vntRes ) ) );	

	if ( vntRes != VARIANT_TRUE )
	{
		throw CObjectException( IDS_E_READFILE, wszFile );
	}

	rspDoc.Attach( spDoc.Detach() );
}


/*
	Removes all nodes that match the specified XPath query
*/
void CXMLTools::RemoveNodes( const IXMLDOMElementPtr& spContext, LPCWSTR wszXPath )
{
	IXMLDOMNodeListPtr	spList;
	IXMLDOMNodePtr		spNode;

	IF_FAILED_HR_THROW( spContext->selectNodes( _bstr_t( wszXPath ), &spList ),
						CBaseException( IDS_E_XML_PARSE ) );

	while( S_OK == spList->nextNode( &spNode ) )
	{
		IXMLDOMNodePtr spParent;

		IF_FAILED_HR_THROW( spNode->get_parentNode( &spParent ),
							CBaseException( IDS_E_XML_GENERATE ) );

		IF_FAILED_HR_THROW( spParent->removeChild( spNode, NULL ),
							CBaseException( IDS_E_XML_GENERATE ) );
	};
}



/* 
    Get's a data from an XML doc
    If an attrib name is specified - the attrib value is returned. Otherwise - the element's text
    The data is located with an XPath query. It is an error fo this query to return more then 1 node
    If the data is missing - the default value is used. If no default value - it's an error for the data to be missing
*/
const std::wstring CXMLTools::GetDataValue( const IXMLDOMNodePtr& spRoot,
                                            LPCWSTR wszQuery, 
                                            LPCWSTR wszAttrib, 
                                            LPCWSTR wszDefault )
{
    _ASSERT( wszQuery != NULL );
    _ASSERT( spRoot != NULL );

    IXMLDOMNodeListPtr  spList;
    IXMLDOMNodePtr      spDataEl;
    std::wstring        strRes( wszDefault != NULL ? wszDefault : L"" );

    // Get the node 
    IF_FAILED_HR_THROW( spRoot->selectNodes( _bstr_t( wszQuery ), &spList ),
                        CBaseException( IDS_E_XML_PARSE ) );
    long nCount = 0;
    if (    FAILED( spList->get_length( &nCount ) ) || ( nCount > 1 ) )
    {
        throw CBaseException( IDS_E_XML_PARSE, ERROR_INVALID_DATA );
    }

    if ( 0 == nCount )
    {
        // The data is missing and no default was provided - error
        IF_FAILED_BOOL_THROW( wszDefault != NULL, CBaseException( IDS_E_XML_PARSE, ERROR_NOT_FOUND ) );
    }
    else
    {
        VERIFY( S_OK == spList->nextNode( &spDataEl ) );

        if ( wszAttrib != NULL )
        {
            strRes = CXMLTools::GetAttrib( spDataEl, wszAttrib );
        }
        else
        {
            CComBSTR bstrData;
            IF_FAILED_HR_THROW( spDataEl->get_text( &bstrData ),
                                CBaseException( IDS_E_XML_PARSE ) );
            strRes = bstrData;
        }
    }
    
    return strRes;
}



const std::wstring CXMLTools::GetDataValueAbs(  const IXMLDOMDocumentPtr& spDoc,
                                                LPCWSTR wszQuery, 
                                                LPCWSTR wszAttrib,
                                                LPCWSTR wszDefault )
{
    IXMLDOMElementPtr spRoot;

    IF_FAILED_HR_THROW( spDoc->get_documentElement( &spRoot ),
                        CBaseException( IDS_E_XML_PARSE ) );

    return GetDataValue( spRoot, wszQuery, wszAttrib, wszDefault );
}


/*
    Changes a element value or element's attrib value
    The element is located with the wszQuery XPath
    wszAttrib is the name of the attrib to change. If NULL - the element value is changed
    The new value is wszNewValue
    If the element cannot be find, a new child element is added to spRoot with tha wszNeElName name
    and the data is set either is the element text or as an attrib ( depending on wszAttrib value )
*/
const IXMLDOMNodePtr CXMLTools::SetDataValue(   const IXMLDOMNodePtr& spRoot,
                                                LPCWSTR wszQuery, 
                                                LPCWSTR wszAttrib,
                                                LPCWSTR wszNewValue,
                                                LPCWSTR wszNewElName /*=NULL*/ )
{
    _ASSERT( wszQuery != NULL );
    _ASSERT( spRoot != NULL );
    
    IXMLDOMNodeListPtr  spList;
    IXMLDOMNodePtr      spDataEl;
    
    // Get the node 
    IF_FAILED_HR_THROW( spRoot->selectNodes( _bstr_t( wszQuery ), &spList ),
                        CBaseException( IDS_E_XML_PARSE ) );
    long nCount = 0;
    IF_FAILED_BOOL_THROW(   SUCCEEDED( spList->get_length( &nCount ) ) && ( 1 == nCount ),
                            CBaseException( IDS_E_XML_PARSE, ERROR_INVALID_DATA ) );
    
    // If the value is not already here and a name is provided - add it
    if ( S_FALSE == spList->nextNode( &spDataEl ) )
    {
        IF_FAILED_BOOL_THROW(   wszNewElName != NULL,
                                CBaseException( IDS_E_XML_PARSE, ERROR_NOT_FOUND ) );
        IXMLDOMDocumentPtr spDoc;
        IF_FAILED_HR_THROW( spRoot->get_ownerDocument( &spDoc ),
                            CBaseException( IDS_E_XML_PARSE ) );

        spDataEl = CreateSubNode( spDoc, spRoot, wszNewElName );
    }

    if ( wszAttrib != NULL )
    {
        CXMLTools::SetAttrib( spDataEl, wszAttrib, wszNewValue );
    }
    else
    {
        IF_FAILED_HR_THROW( spDataEl->put_text( _bstr_t( wszNewValue ) ),
                            CBaseException( IDS_E_XML_PARSE ) );
    }

    return spDataEl;
}








// Convert class implementation
/////////////////////////////////////////////////////////////////////////////////////////
const std::wstring Convert::ToString( const BYTE* pvData, DWORD dwSize )
{
    // Each byte takes 2 symbols. And we need one symbol for the '\0'
    std::wstring str( ( dwSize * 2 ) + 1, L' ' );

    for ( UINT x = 0, y = 0 ; x < dwSize ; ++x )
    {
        str[ y++ ] = ByteToWChar( pvData[ x ] >> 4 );
        str[ y++ ] = ByteToWChar( pvData[ x ] & 0x0f );
    }
    str[ y ] = L'\0';

    return str;
}



void Convert::ToBLOB( LPCWSTR wszData, TByteAutoPtr& rspData, DWORD& rdwDataSize )
{
    _ASSERT( wszData != NULL );
    _ASSERT( ::wcscspn( wszData, L"ABCDEF" ) == ::wcslen( wszData ) );    // The string must be lower-case!!!
    _ASSERT( ( ::wcslen( wszData ) % 2 ) == 0 );

     // Calc the size
    DWORD dwSize = static_cast<DWORD>( ::wcslen( wszData ) / 2 );    // Each byte takes 2 symbols
    // Alloc the buffer
    TByteAutoPtr spData( new BYTE[ dwSize ] );

    BYTE* pbtDest = spData.get();

    DWORD dwSymbol    = 0;
    DWORD dwByte    = 0;

    while( wszData[ dwSymbol ] != L'\0' )
    {
        pbtDest[ dwByte ] = WCharsToByte( wszData[ dwSymbol + 1 ], wszData[ dwSymbol ] );
        ++dwByte;
        dwSymbol += 2;
    };

    rspData     = spData;
    rdwDataSize = dwSize;
}


DWORD Convert::ToDWORD( LPCWSTR wszData )
{
    int nRes = 0;

    IF_FAILED_BOOL_THROW(   ::StrToIntExW( wszData, STIF_DEFAULT, &nRes ),
                            CBaseException( IDS_E_INVALIDARG, ERROR_INVALID_DATA ) );
    return static_cast<DWORD>( nRes );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\core\wrappers.h ===
/*
****************************************************************************
|	Copyright (C) 2002  Microsoft Corporation
|
|	Component / Subcomponent
|		IIS 6.0 / IIS Migration Wizard
|
|	Based on:
|		http://iis6/Specs/IIS%20Migration6.0_Final.doc
|
|   Abstract:
|		Wrapper classes
|
|   Author:
|        ivelinj
|
|   Revision History:
|        V1.00	March 2002
|
****************************************************************************
*/
#pragma once




// Class for auto managing handles ( smart handle )
////////////////////////////////////////////////////////////////////////////
template <typename T, BOOL (__stdcall *PFN_FREE)( T ), T InvalidVal = NULL> 
class THandle
{
public:
	THandle()
	{
		m_Handle = InvalidVal;
	}

	explicit THandle( const T& handle )
	{
		m_Handle = handle;
	}

	THandle( const THandle<T, PFN_FREE, InvalidVal>& src )
	{
		m_Handle = src.Relase();
	}

	~THandle()
	{
		Close();
	}

	void Attach( const T& NewVal )
	{
		Close();
		m_Handle = NewVal;
	}

	const T Detach()
	{
		T Result = m_Handle;
		m_Handle = InvalidVal;

		return Result;
	}

	void Close()
	{
		if ( m_Handle != InvalidVal )
		{
            VERIFY( PFN_FREE( m_Handle ) );
			m_Handle = InvalidVal;
		}
	}

	bool IsValid()const{ return m_Handle != InvalidVal; }

	T* operator &(){ Close(); return &m_Handle; }

	const T get()const { return m_Handle;}

	void operator= ( const T& RVal )
	{
		Close();
		m_Handle = RVal;
	}

	THandle<T, PFN_FREE, InvalidVal>& operator=( const THandle<T, PFN_FREE, InvalidVal>& RVal )
	{
		Close();
		m_Handle = RVal.Relase();

		return *this;
	}


private:
	const T Relase()const
	{ 
		T Result = m_Handle;
		m_Handle = InvalidVal;

		return Result;
	}


private:
	mutable T		m_Handle;
};



// Adaptor for WINAPI functions that accept second DWORD param, which is always 0
template<typename T, BOOL (__stdcall *PFN_FREE)( T, DWORD ) >
inline BOOL __stdcall Adapt2nd( T hCtx )
{
	return PFN_FREE( hCtx, 0 );
}


// Adaptor for WINAPI functions that do not retun result
template<typename T, void (__stdcall *PFN_FREE)( T ) >
inline BOOL __stdcall AdaptNoRet( T hCtx )
{
	PFN_FREE( hCtx );
    return TRUE;
}




// Predefined wrappers
/////////////////////////////////////////////////////////////////////////////////////////

// General
typedef THandle<HANDLE, ::CloseHandle, INVALID_HANDLE_VALUE>	TFileHandle;			// Win32 Files
typedef THandle<HANDLE, ::CloseHandle>					        TStdHandle;			    // Win32 HANDLEs
typedef THandle<HANDLE, ::FindClose, INVALID_HANDLE_VALUE>		TSearchHandle;		    // FindFirstFile handles
typedef THandle<HMODULE, ::FreeLibrary>                         TLibHandle;             // DLL module handle

// Crypt
#ifdef __WINCRYPT_H__

typedef THandle<HCRYPTPROV, 
				Adapt2nd<HCRYPTPROV, ::CryptReleaseContext> >	TCryptProvHandle;	    // Crypt provider
typedef THandle<HCRYPTHASH, ::CryptDestroyHash>					TCryptHashHandle;	    // Crypt hash
typedef THandle<HCRYPTKEY, ::CryptDestroyKey>					TCryptKeyHandle;		// Crypt key
typedef THandle<HCERTSTORE,
				Adapt2nd<HCERTSTORE, ::CertCloseStore> >		TCertStoreHandle;	    // Cert store
typedef THandle<PCCERT_CONTEXT, ::CertFreeCertificateContext>	TCertContextHandle;	    // Cert context*/
typedef THandle<PCCERT_CHAIN_CONTEXT,
                AdaptNoRet<PCCERT_CHAIN_CONTEXT, ::CertFreeCertificateChain> >  TCertChainHandle;    // Cert chain

#endif








// Used instead of auto_ptr as auto_ptr cannot be used with STL containers
// See CInPackage class for usage details
/////////////////////////////////////////////////////////////////////////////////////////
class _sid_ptr
{
public:
	explicit _sid_ptr( PSID pSID )
	{
		CopyFrom( pSID );	
	}

	_sid_ptr( const _sid_ptr& s )
	{
		CopyFrom( s.m_pSid );
	}

	~_sid_ptr()
	{
		delete m_pSid;
	}

	PSID get()const{ return m_pSid; }

private:
	PSID	m_pSid;

private:
	void operator=( const _sid_ptr& );
	void operator==( const _sid_ptr& );

	void CopyFrom( PSID pSID )
	{
		_ASSERT( ::IsValidSid( pSID ) );
		m_pSid = new BYTE[ ::GetLengthSid( pSID ) ];

		VERIFY( ::CopySid( ::GetLengthSid( pSID ), m_pSid, pSID ) );
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\core\utils.h ===
/*
****************************************************************************
|    Copyright (C) 2002  Microsoft Corporation
|
|    Component / Subcomponent
|        IIS 6.0 / IIS Migration Wizard
|
|    Based on:
|        http://iis6/Specs/IIS%20Migration6.0_Final.doc
|
|   Abstract:
|        Utility helpers for migration
|
|   Author:
|        ivelinj
|
|   Revision History:
|        V1.00    March 2002
|
****************************************************************************
*/
#pragma once

#include "Wrappers.h"
#include "resource.h"


// Directory utilities
class CDirTools
{
private:
    CDirTools();    // Do not instantiate


public:
    static void     PathAppendLocal     (   LPWSTR wszBuffer, LPCWSTR wszPath, LPCWSTR wszPathToAppend );
    static void     CleanupDir          (   LPCWSTR wszDir, 
                                            bool bRemoveRoot = true,
                                            bool bReportErrors = false );
    static DWORD    FileCount           (   LPCWSTR wszDir, WORD wOptions );
    static DWORDLONG FilesSize          (   LPCWSTR wszDir, WORD wOptions );
    static int      DoPathsNest         (   LPCWSTR wszPath1, LPCWSTR wszPath2 );
};




// CTempDir - used to create, store and autoclean tempdirs
/////////////////////////////////////////////////////////////////////////////////////////
class CTempDir
{
public:
    CTempDir                (   LPCWSTR wszTemplate = L"Migr" );
    ~CTempDir               (   void );

public:
    void        CleanUp     (    bool bReportErrors = false );
    
    operator LPCWSTR        (    void )const
    {
        return m_strDir.c_str();
    }

private:
    std::wstring        m_strDir;
};



// Class for any additional tool procs
/////////////////////////////////////////////////////////////////////////////////////////
class CTools
{
private:
    CTools();


public:
    static bool         IsAdmin             (    void );
    static bool         IsIISRunning        (    void );
    static HRESULT      CopyBSTR            (    const _bstr_t& bstrSource, BSTR* pVal );
    static WORD         GetOSVer            (    void );
    static bool         IsNTFS              (    void );
    static void         SetErrorInfo        (    LPCWSTR wszError );
    static void         SetErrorInfoFromRes (    UINT nResID );
    static bool         IsSelfSignedCert    (    PCCERT_CONTEXT pContext );
    static bool         IsValidCert         (    PCCERT_CONTEXT hCert, DWORD& rdwError );
    static std::wstring GetMachineName      (    void );
    static void         WriteFile           (    HANDLE hFile, LPCVOID pvData, DWORD dwSize );
    static ULONGLONG    GetFilePtrPos       (    HANDLE hFile );
    static void         SetFilePtrPos       (    HANDLE hFile, DWORDLONG nOffset );
    
    static const TCertContextHandle AddCertToSysStore(   PCCERT_CONTEXT pContext, 
                                                        LPCWSTR wszStore, 
                                                        bool bReuseCert );
    static const TCryptKeyHandle GetCryptKeyFromPwd( HCRYPTPROV hCryptProv, LPCWSTR wszPassword );
    
    static int    __cdecl BadAllocHandler  (    size_t )
    {
        // Installed at startup time for handling mem alloc failures
        throw CBaseException( IDS_E_OUTOFMEM, ERROR_SUCCESS );
    }
               
};


// CTools inline implementation
/////////////////////////////////////////////////////////////////////////////////////////
inline HRESULT CTools::CopyBSTR( const _bstr_t& bstrSource , BSTR* pVal )
{
    _ASSERT( pVal != NULL );

    *pVal = ::SysAllocString( bstrSource );

    return ( (*pVal) != NULL ? S_OK : E_OUTOFMEMORY );
}


inline void CTools::WriteFile( HANDLE hFile, LPCVOID pvData, DWORD dwSize )
{
    _ASSERT( ( hFile != NULL ) && ( hFile != INVALID_HANDLE_VALUE ) );
    _ASSERT( pvData != NULL );

    DWORD dwUnused = 0;

    // dwSize can be 0
    IF_FAILED_BOOL_THROW(   ::WriteFile( hFile, pvData, dwSize, &dwUnused, NULL ),
                            CBaseException( IDS_E_WRITE_OUTPUT ) );
}



// CFindFile - class that behaves like FindFirstFile with the only difference
// that it works all the way down the tree ( all files from subdirs are retruned as well
// No file mask currently implemented - if needed - store the mask and pass it on every FindFirstFile API
/////////////////////////////////////////////////////////////////////////////////////////
class CFindFile
{
// Data types
public:
    // Use this options to refine the search criteria
    enum SearchOptions
    {
        ffRecursive     = 0x0001,    // If set - subdirs are searched for matches. Else - only the root dir is searched
        ffGetFiles      = 0x0002,    // If set - file objects are considered a match
        ffGetDirs       = 0x0004,    // If set - directory objects are considered a match
        ffAbsolutePaths = 0x0008,    // If set - the dir names, returned from FindFirst and Next will be absolute. 
        ffAddFilename   = 0x0010,    // If set - the dir names, returned from FindFirst and Next will include the name of the object. 
    };



// Construction / Destruction
public:
    CFindFile               (    void );
    ~CFindFile              (    void );


// Interface
public:
    bool    FindFirst       (   LPCWSTR wszDirToScan, 
                                WORD wOptions,
                                LPWSTR wszDir,
                                WIN32_FIND_DATAW* pData );
    bool    Next            (   bool* pbDirChanged,
                                LPWSTR wszDir,
                                WIN32_FIND_DATAW* pData );
    void    Close           (   void );

// Implementation
private:
    bool    CheckFile       (   LPCWSTR wszRelativeDir, const WIN32_FIND_DATAW& fd );
    bool    ScanDir         (   LPCWSTR wszDirToScan,
                                LPCWSTR wszRelative,
                                WIN32_FIND_DATAW& FileData );
    bool    ContinueCurrent (   WIN32_FIND_DATAW& FilepData );
    
// Data members
private:
    WORD                    m_wOptions;         // Search options ( bitmask with SearchOptions enum values )
    TStringList             m_DirsToScan;       // Dirs that will be scaned after the current one
    TSearchHandle           m_shSearch;         // Search Handle
    std::wstring            m_strRootDir;       // Dir that is searched ( search root )
    std::wstring            m_strCurrentDir;    // Dir where m_hSearch is opened
};




// CXMLTools - class for XML input/output support
// You may need the Convert class for easier handling different types of in/out XML data
/////////////////////////////////////////////////////////////////////////////////////////
class CXMLTools
{
private:
    CXMLTools();


public:
    static IXMLDOMElementPtr AddTextNode(   const IXMLDOMDocumentPtr& spDoc,
                                            const IXMLDOMElementPtr& spEl,
                                            LPCWSTR wszName,
                                            LPCWSTR wszValue );
    static const std::wstring GetAttrib (   const IXMLDOMNodePtr& spEl, LPCWSTR wszName );
    static void               SetAttrib (   const IXMLDOMElementPtr& spEl, LPCWSTR wszName, LPCWSTR wszData );
    

    static void             LoadXMLFile (   LPCWSTR wszFile, IXMLDOMDocumentPtr& rspDoc );

    static IXMLDOMElementPtr CreateSubNode( const IXMLDOMDocumentPtr& spDoc,
                                            const IXMLDOMElementPtr& spParent,
                                            LPCWSTR wszName );

    static void             RemoveNodes (   const IXMLDOMElementPtr& spContext, LPCWSTR wszXPath );

    static const std::wstring GetDataValue( const IXMLDOMNodePtr& spRoot,
                                            LPCWSTR wszQuery, 
                                            LPCWSTR wszAttrib,
                                            LPCWSTR wszDefaut );
    static const std::wstring GetDataValueAbs(  const IXMLDOMDocumentPtr& spRoot,
                                                LPCWSTR wszQuery, 
                                                LPCWSTR wszAttrib,
                                                LPCWSTR wszDefaut );

    static const IXMLDOMNodePtr SetDataValue(  const IXMLDOMNodePtr& spRoot,
                                            LPCWSTR wszQuery, 
                                            LPCWSTR wszAttrib,
                                            LPCWSTR wszNewValue,
                                            LPCWSTR wszNewElName = NULL );
};


// CXMLTols inline implementation
/////////////////////////////////////////////////////////////////////////////////////////
inline void CXMLTools::SetAttrib(   const IXMLDOMElementPtr& spEl, 
                                    LPCWSTR wszName,
                                    LPCWSTR wszData )
{
    _ASSERT( spEl != NULL );
    _ASSERT( wszName != NULL );
    _ASSERT( wszData != NULL );

    IF_FAILED_HR_THROW( spEl->setAttribute( _bstr_t( wszName ), _variant_t( wszData ) ),
                        CBaseException( IDS_E_XML_GENERATE ) );
}


inline IXMLDOMElementPtr CXMLTools::CreateSubNode(  const IXMLDOMDocumentPtr& spDoc,
                                                    const IXMLDOMElementPtr& spParent,
                                                    LPCWSTR wszName )
{
    _ASSERT( spDoc != NULL );
    _ASSERT( spParent != NULL );

    IXMLDOMElementPtr spResult;

    IF_FAILED_HR_THROW( spDoc->createElement( _bstr_t( wszName ), &spResult ),
                        CBaseException( IDS_E_XML_GENERATE ) );
    IF_FAILED_HR_THROW( spParent->appendChild( spResult, NULL ),
                        CBaseException( IDS_E_XML_GENERATE ) );

    return spResult;
}




// Convert class - simple class for providing basic type conversions. 
/////////////////////////////////////////////////////////////////////////////////////////
class Convert
{
private:
    Convert();

public:
    static const std::wstring   ToString    (   BYTE btVal );
    static const std::wstring   ToString    (   DWORD dwVal );
    static const std::wstring   ToString    (   DWORDLONG dwVal );
    static const std::wstring   ToString    (   bool bVal );
    static const std::wstring   ToString    (   const BYTE* pvData, DWORD dwSize );

    static void                 ToBLOB      (   LPCWSTR wszData, TByteAutoPtr& rspData, DWORD&dwSize );

    static DWORD                ToDWORD     (   LPCWSTR wszData );
    static DWORDLONG            ToDWORDLONG (   LPCWSTR wszData );

    static bool                 ToBool      (   LPCWSTR wszData );



private:
    static WCHAR ByteToWChar( BYTE b );
    static BYTE WCharsToByte( WCHAR chLow, WCHAR chHigh );
};



// Convert class inline implementation
inline const std::wstring Convert::ToString( DWORD dwVal )
{
    WCHAR wszBuff[ 16 ];
    ::swprintf( wszBuff, L"%u", dwVal );
    return std::wstring( wszBuff );
}

inline const std::wstring Convert::ToString( DWORDLONG dwVal )
{
    WCHAR wszBuff[ 32 ];
    ::_ui64tow( dwVal, wszBuff, 10 );
    return std::wstring( wszBuff );
}

inline const std::wstring Convert::ToString( bool bVal )
{
    return std::wstring( bVal ? L"True" : L"False" );
}

inline WCHAR Convert::ByteToWChar( BYTE b )
{
    _ASSERT( b < 17 );
    return static_cast<WCHAR>( b >= 10 ? L'a' + b - 10 : L'0' + b );
}

inline BYTE Convert::WCharsToByte( WCHAR chLow, WCHAR chHigh )
{
    _ASSERT(    ( ( chLow >= L'0' ) && ( chLow <= L'9' ) ) ||
                ( ( chLow >= L'a' ) && ( chLow <= 'f' ) ) );
    _ASSERT(    ( ( chHigh >= L'0' ) && ( chHigh <= L'9' ) ) ||
                ( ( chHigh >= L'a' ) && ( chHigh <= 'f' ) ) );

    BYTE bt = static_cast<BYTE>( ( chHigh >= L'a' ? chHigh - L'a' + 10 : chHigh - L'0' ) << 4 );

    bt = static_cast<BYTE>( bt + ( chLow >= L'a' ? chLow - L'a' + 10 : chLow - L'0' ) );

    return bt;
}

inline DWORDLONG Convert::ToDWORDLONG( LPCWSTR wszData )
{
    return static_cast<DWORDLONG>( ::_wtoi64( wszData ) );
}

inline const std::wstring Convert::ToString( BYTE btVal )
{
    return ToString( static_cast<DWORD>( btVal ) );
}

inline bool Convert::ToBool( LPCWSTR wszData )
{
    return ::_wcsicmp( wszData, L"true" ) == 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\commanddlg.h ===
#pragma once

#include "UIUtils.h"

class CCommandDlg : public CDialogImpl<CCommandDlg>
{
public:

    enum { IDD = IDD_POSTPROCESS_CMD };

    static const CMD_MAX_LEN = 2 * 1024;

    BEGIN_MSG_MAP(CMyDialog)
        MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog )
        COMMAND_ID_HANDLER( IDOK, OnOK )
        COMMAND_ID_HANDLER( IDCANCEL, OnCancel )
        COMMAND_CODE_HANDLER( EN_CHANGE, OnCmdChange )
    END_MSG_MAP()

        CCommandDlg(void)
        {
            m_bIgnoreErrors = false;
            m_dwTimeout     = 0;
        }


    LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/ )
    {
        VERIFY( SetDlgItemText( IDC_CMDTEXT, m_strText ) );

        Edit_LimitText( GetDlgItem( IDC_CMDTEXT ), CMD_MAX_LEN );
        Edit_LimitText( GetDlgItem( IDC_TIMEOUT ), 8 );
        Button_SetCheck( GetDlgItem( IDC_IGNOREERRORS ), m_bIgnoreErrors );
        SetDlgItemInt( IDC_TIMEOUT, m_dwTimeout, FALSE );

        ::EnableWindow( GetDlgItem( IDOK ), m_strText.GetLength() > 0 );
          
        return 1;
    }


    LRESULT OnOK( WORD wNotifyCode, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& bHandled )
    {
        m_bIgnoreErrors  = Button_GetCheck( GetDlgItem( IDC_IGNOREERRORS ) ) != FALSE;
        GetDlgItemText( IDC_CMDTEXT, m_strText.GetBuffer( CMD_MAX_LEN + 1 ), CMD_MAX_LEN );
        m_strText.ReleaseBuffer();

        BOOL bTranslated = FALSE;
        m_dwTimeout      = GetDlgItemInt( IDC_TIMEOUT, &bTranslated, FALSE );

        if ( !bTranslated )
        {
            UIUtils::MessageBox( m_hWnd, IDS_E_NOTNUMERIC, IDS_APPTITLE, MB_OK | MB_ICONERROR );
            ::SetFocus( GetDlgItem( IDC_TIMEOUT ) );
        }
        else
        {
            EndDialog( IDOK );
        }

        return 0;
    }

    LRESULT OnCancel( WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/ )
    {
        EndDialog( IDCANCEL );

        return 0;
    }


    LRESULT OnCmdChange( WORD /*wNotifyCode*/, WORD wID, HWND hWndCtl, BOOL& bHandled )
    {
        if ( wID != IDC_CMDTEXT ) 
        {
            bHandled = FALSE;
            return 0;
        }

        CEdit   ctrl( hWndCtl );

        ::EnableWindow( GetDlgItem( IDOK ), ctrl.GetWindowTextLength() > 0 );

        return 0;
    }

public:
    bool    m_bIgnoreErrors;
    DWORD   m_dwTimeout;
    CString m_strText;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\exportfinishpage.cpp ===
#include "stdafx.h"

#include "WizardSheet.h"

LRESULT CExportFinishPage::OnInitDialog( UINT, WPARAM, LPARAM, BOOL& )
{
    // Set the fonts
	SetWindowFont( GetDlgItem( IDC_TITLE ), m_pTheSheet->m_fontTitles.get(), FALSE );

    CString strMsg;

    strMsg.Format(  IDS_FINISH_MSG_EXP, 
                    m_pTheSheet->m_pageSelectSite.m_strSiteName,
                    m_pTheSheet->m_pagePkgCfg.m_strFilename );

    VERIFY( SetDlgItemText( IDC_MSG, strMsg ) );
    	
    return 1;
}



BOOL CExportFinishPage::OnSetActive()
{
    SetWizardButtons( PSWIZB_FINISH );
        
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\exportfinishpage.h ===
#pragma once

class CExportFinishPage : public CPropertyPageImpl<CExportFinishPage>
{
    typedef CPropertyPageImpl<CExportFinishPage>	BaseClass;

public:

	enum{ IDD = IDD_WPEXP_FINISH };

	BEGIN_MSG_MAP(CExportFinishPage)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		CHAIN_MSG_MAP(BaseClass)
	END_MSG_MAP()


    CExportFinishPage( CWizardSheet* pTheSheet ) :
        m_pTheSheet( pTheSheet )
    {
        m_psp.dwFlags |= PSP_HIDEHEADER;
    }

	LRESULT OnInitDialog( UINT, WPARAM, LPARAM, BOOL& );	
    BOOL OnSetActive();


private:
	CWizardSheet*   m_pTheSheet;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\exportsummary.h ===
#pragma once

class CExportSummary : public CPropertyPageImpl<CExportSummary>
{
    typedef CPropertyPageImpl<CExportSummary> BaseClass;

    
public:
    enum { IDD = IDD_WPEXP_SUMMARY };

    BEGIN_MSG_MAP(CExportSummary)
		CHAIN_MSG_MAP(BaseClass)
	END_MSG_MAP()

    CExportSummary      (   CWizardSheet* pTheSheet );

    int     OnWizardBack    (   void );
    BOOL    OnSetActive     (   void );


private:
    CWizardSheet*       m_pTheSheet;
    CString             m_strTitle;
    CString             m_strSubTitle;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\exportprogress.h ===
#pragma once

extern _ATL_FUNC_INFO StateChangeInfo;



class CExportProgress : public CPropertyPageImpl<CExportProgress>,
    public IDispEventSimpleImpl<1, CExportProgress, &__uuidof( _IExportEvents )>
    
{
    typedef CPropertyPageImpl<CExportProgress>	BaseClass;

public:

    enum{ IDD = IDD_WPEXP_PROGRESS };

    //static const int    PROGRESS_MAX    = 10000;    // ProgressBar steps
    static const UINT   MSG_COMPLETE    = WM_USER + 1;  // Indicates export is completed

    BEGIN_MSG_MAP(CExportProgress)
        MESSAGE_HANDLER( MSG_COMPLETE, OnExportComplete );
        CHAIN_MSG_MAP(BaseClass)
	END_MSG_MAP()

    BEGIN_SINK_MAP( CExportProgress )
        SINK_ENTRY_INFO( 1, __uuidof( _IExportEvents ), 1/*dispid*/, OnStateChange, &StateChangeInfo )
    END_SINK_MAP()


    CExportProgress         (   CWizardSheet* pTheSheet ); 

    BOOL    OnSetActive     (   void );
    BOOL    OnQueryCancel   (   void );

    LRESULT OnExportComplete(   UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );

    // Event from the COM object for progress indications
    VARIANT_BOOL __stdcall OnStateChange(    enExportState State,
							                VARIANT vntArg1,
							                VARIANT vntArg2,
							                VARIANT vntArg3 );


private:
    void    AddStatusText   (   UINT nID, LPCWSTR wszText = NULL, DWORD dw1 = 0, DWORD dw2 = 0 );
    void    SetCompleteStat (   void );
    void    GetOptions      (   LONG& rnSiteOpt, LONG& rnPkgOpt );

    static unsigned __stdcall ThreadProc( void* pCtx );


public:
    CString             m_strExportError;
    
    
private:
    CWizardSheet*       m_pTheSheet;
    CString             m_strTitle;
    CString             m_strSubTitle;
    LONG                m_nExportCanceled;  // 1 = canceled, 0 = not canceled
    TStdHandle          m_shThread;
    CProgressBarCtrl    m_ProgressBar;    
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\importfinishpage.h ===
#pragma once

class CImportFinishPage : public CPropertyPageImpl<CImportFinishPage>
{
    typedef CPropertyPageImpl<CImportFinishPage>	BaseClass;

public:

	enum{ IDD = IDD_WPIMP_FINISH };

	BEGIN_MSG_MAP(CImportFinishPage)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		CHAIN_MSG_MAP(BaseClass)
	END_MSG_MAP()


    CImportFinishPage( CWizardSheet* pTheSheet ) :
        m_pTheSheet( pTheSheet )
    {
        m_psp.dwFlags |= PSP_HIDEHEADER;
    }

	LRESULT OnInitDialog( UINT, WPARAM, LPARAM, BOOL& );	
    BOOL OnSetActive();


private:
	CWizardSheet*   m_pTheSheet;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\exportsummary.cpp ===
#include "stdafx.h"

#include "WizardSheet.h"


CExportSummary::CExportSummary( CWizardSheet* pTheSheet ) :
        m_pTheSheet( pTheSheet )
{
    m_strTitle.LoadString( IDS_TITLE_EXPORT_SUMMARY );
    m_strSubTitle.LoadString( IDS_SUBTITLE_EXPORT_SUMMARY );

    SetHeaderTitle( m_strTitle );
    SetHeaderSubTitle( m_strSubTitle );
}

int CExportSummary::OnWizardBack()
{
    return m_pTheSheet->m_pagePkgCfg.m_bPostProcess ? IDD_WPEXP_POSTPROCESS : IDD_WPEXP_PKG;
}



BOOL CExportSummary::OnSetActive()
{
    SetWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );

    CTreeViewCtrl Tree( GetDlgItem( IDC_SUMMARY ) );

    VERIFY( Tree.DeleteAllItems() );

    CString str;

    CString strYes, strNo;

    VERIFY( strYes.LoadString( IDS_YES ) );
    VERIFY( strNo.LoadString( IDS_NO ) );

    HTREEITEM hRoot = Tree.InsertItem( m_pTheSheet->m_pageSelectSite.m_strSiteName, NULL, NULL );
    
    str.Format( IDS_TV_SITEID, m_pTheSheet->m_pageSelectSite.m_dwSiteID );
    Tree.InsertItem( str, hRoot, TVI_LAST );

    str.Format( IDS_TV_PKGFILE, m_pTheSheet->m_pagePkgCfg.m_strFilename );
    Tree.InsertItem( str, hRoot, TVI_LAST );

    str.Format( IDS_TV_ENCRYPT, m_pTheSheet->m_pagePkgCfg.m_bEncrypt ? strYes : strNo );
    Tree.InsertItem( str, hRoot, TVI_LAST );

    str.Format( IDS_TV_COMPRESS, m_pTheSheet->m_pagePkgCfg.m_bCompress ? strYes : strNo );
    Tree.InsertItem( str, hRoot, TVI_LAST );

    str.Format( IDS_TV_EXPORTCONTENT, m_pTheSheet->m_pageSelectSite.m_bExportContent ? strYes : strNo );
    Tree.InsertItem( str, hRoot, TVI_LAST );

    str.Format( IDS_TV_EXPORTCERTIFICATE, m_pTheSheet->m_pageSelectSite.m_bExportCert ? strYes : strNo );
    Tree.InsertItem( str, hRoot, TVI_LAST );

    str.Format( IDS_TV_EXPORTACLS, m_pTheSheet->m_pageSelectSite.m_bExportACLs ? strYes : strNo );
    Tree.InsertItem( str, hRoot, TVI_LAST );

    Tree.Expand( hRoot );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\exportprogress.cpp ===
#include "stdafx.h"

#include "WizardSheet.h"
#include "UIUtils.h"


static _ATL_FUNC_INFO StateChangeInfo = {  CC_STDCALL, 
                                           VT_BOOL,
                                           4,
                                           { VT_I4, VT_VARIANT, VT_VARIANT, VT_VARIANT }
                                         };



CExportProgress::CExportProgress( CWizardSheet* pTheSheet ) :
        m_pTheSheet( pTheSheet )
{
    m_strTitle.LoadString( IDS_TITLE_EXPORT_PROGRESS );
    m_strSubTitle.LoadString( IDS_SUBTITLE_EXPORT_PROGRESS );

    SetHeaderTitle( m_strTitle );
    SetHeaderSubTitle( m_strSubTitle );
}



BOOL CExportProgress::OnSetActive()
{
    SetWizardButtons( 0 );
    ListBox_ResetContent( GetDlgItem( IDC_OPLIST ) );

    AddStatusText( IDC_OPS_INITENGINE );
    
    m_ProgressBar = GetDlgItem( IDC_PROGRESS );
    m_ProgressBar.SetPos( 0 );
    VERIFY( SetDlgItemText( IDC_STATUS, L"" ) );
    m_strExportError.Empty();

    m_nExportCanceled   = 0;

    UINT nThreadID = 0;
    // Start the thread where the actuall export process will take place
    m_shThread =  reinterpret_cast<HANDLE>( ::_beginthreadex(   NULL,
                                                                0,
                                                                CExportProgress::ThreadProc,
                                                                this,
                                                                0,
                                                                &nThreadID ) );
    return TRUE;
}


BOOL CExportProgress::OnQueryCancel( void )
{
    // If Export is not in progress - allow exit
    if ( !m_shThread.IsValid() ) return TRUE;

    // Preven reentrancy ( Cancel the export when it's already cancedl )
    // while we wait for next event from the COM object
    if ( m_nExportCanceled != 0 ) return FALSE;

    if ( UIUtils::MessageBox( m_hWnd, IDS_MSG_CANCELEXPORT, IDS_APPTITLE, MB_YESNO | MB_ICONQUESTION ) != IDYES )
    {
        return FALSE;
    }

    // m_nExportCanceled is used by the event handler which is another thread
    ::InterlockedIncrement( &m_nExportCanceled );

    // Set the status text 
    CString str;
    VERIFY( str.LoadString( IDS_PRG_EXPORTCANCELED ) );
    SetDlgItemText( IDC_STATUS, str );

    HANDLE hThread = m_shThread.get();

    do
    {
        DWORD dwWaitRes = ::MsgWaitForMultipleObjects( 1, &hThread, FALSE, INFINITE, QS_ALLEVENTS );

        if ( dwWaitRes == ( WAIT_OBJECT_0 + 1 ) )
        {
            // MSG

            MSG msg;
            ::GetMessage( &msg, NULL, 0, 0 );
            ::TranslateMessage( &msg );
            ::DispatchMessage( &msg );
        }
        else
        {
            break;
        }
    }while( true );
    

    return TRUE;
}



unsigned __stdcall CExportProgress::ThreadProc( void* pCtx )
{
    CExportProgress* pThis = reinterpret_cast<CExportProgress*>( pCtx );

    pThis->SetCompleteStat();
    pThis->AddStatusText( IDS_OPS_CONFIGENGINE );

    HRESULT             hr = ::CoInitialize( NULL );
    IExportPackagePtr   spExport;

    LONG    nSiteOpt    = 0;
    LONG    nPkgOpt     = 0;
    LONG    nSiteID     = static_cast<LONG>( pThis->m_pTheSheet->m_pageSelectSite.m_dwSiteID );
    bool    bAdvised    = false; // Is connected to the event source

    pThis->GetOptions( /*r*/nSiteOpt, /*r*/nPkgOpt );

    if ( SUCCEEDED( hr ) )
    {
        hr = spExport.CreateInstance( CLSID_ExportPackage );
        
        if ( FAILED( hr ) )
        {
            VERIFY( pThis->m_strExportError.LoadString( IDS_E_NOENGINE ) );
        }
    }

    if ( SUCCEEDED( hr ) )
    {
        hr = spExport->AddSite( nSiteID, nSiteOpt );
    }

    // Add the post processing stuff if any
    if ( pThis->m_pTheSheet->m_pagePkgCfg.m_bPostProcess )
    {
        const TStringList&  Files = pThis->m_pTheSheet->m_pagePostProcess.m_Files;
        const CPostProcessAdd::TCmdList& Cmds = pThis->m_pTheSheet->m_pagePostProcess.m_Commands;

        CComBSTR bstr;

        // Add the files
        for (   TStringList::const_iterator it = Files.begin();
                SUCCEEDED( hr ) && ( it != Files.end() );
                ++it )
        {
            bstr = it->c_str();

            if ( NULL == bstr.m_str ) hr = E_OUTOFMEMORY;

            if ( SUCCEEDED( hr ) )
            {
                hr = spExport->PostProcessAddFile( nSiteID, bstr );
            }
        }

        // Add the commands
        for (   CPostProcessAdd::TCmdList::const_iterator it = Cmds.begin();
                SUCCEEDED( hr ) && ( it != Cmds.end() );
                ++it )
        {
            bstr = it->strText;

            if ( NULL == bstr.m_str ) hr = E_OUTOFMEMORY;

            if ( SUCCEEDED( hr ) )
            {
                hr = spExport->PostProcessAddCommand(   nSiteID, 
                                                        bstr,
                                                        it->dwTimeout,
                                                        it->bIgnoreErrors ? VARIANT_TRUE : VARIANT_FALSE );
            }
        }
    }

    // Advise to the state events
    if ( SUCCEEDED( hr ) )
    {
        hr = pThis->DispEventAdvise( spExport.GetInterfacePtr() );
        bAdvised = SUCCEEDED( hr );
    }

    // Create the package
    if ( SUCCEEDED( hr ) )
    {
        CComBSTR    bstrPkgName( pThis->m_pTheSheet->m_pagePkgCfg.m_strFilename );
        CComBSTR    bstrPwd( pThis->m_pTheSheet->m_pagePkgCfg.m_strPassword );
        CComBSTR    bstrComment( pThis->m_pTheSheet->m_pagePkgCfg.m_strComment );

        if (    ( NULL == bstrPkgName.m_str ) || 
                ( NULL == bstrComment.m_str ) ||
                ( NULL == bstrPwd.m_str ) )
        {
            hr = E_OUTOFMEMORY;
        }

        if ( SUCCEEDED( hr ) )
        {
            hr = spExport->WritePackage( bstrPkgName, bstrPwd, nPkgOpt, bstrComment );
        }
    }

    // Get the error
    if ( pThis->m_strExportError.IsEmpty() && FAILED( hr ) )
    {
        CComBSTR        bstrText( L"Unknown Error" );;
        IErrorInfoPtr   spInfo;

        VERIFY( SUCCEEDED( ::GetErrorInfo( 0, &spInfo ) ) );
        if ( spInfo != NULL )
        {
            VERIFY( SUCCEEDED( spInfo->GetDescription( &bstrText ) ) );
        }

        pThis->m_strExportError = bstrText;
    }

    // Disconnect from the event source
    if ( bAdvised )
    {
        VERIFY( SUCCEEDED( pThis->DispEventUnadvise( spExport.GetInterfacePtr() ) ) );
    }

    spExport = NULL;

    ::CoUninitialize();

    // Notify the dialog that the export is complete
    VERIFY( ::PostMessage( pThis->m_hWnd, MSG_COMPLETE, hr, 0 ) );

    return 0;
}

void CExportProgress::AddStatusText( UINT nID, LPCWSTR wszText /*= NULL*/, DWORD dw1 /*= 0*/, DWORD dw2 /*= 0*/ )
{
    CString str;

    str.Format( nID, wszText, dw1, dw2 );

    ListBox_InsertString( GetDlgItem( IDC_OPLIST ), -1, str );
}


void CExportProgress::SetCompleteStat()
{
    CListBox    LB( GetDlgItem( IDC_OPLIST ) );
    int         iLast = LB.GetCount() - 1;

    _ASSERT( iLast >= 0 );

    CString strCurrent;
    LB.GetText( iLast, strCurrent );

    strCurrent += L"OK";
    LB.InsertString( iLast, strCurrent );
    LB.DeleteString( iLast + 1 );
}



void CExportProgress::GetOptions( LONG& rnSiteOpt, LONG& rnPkgOpt )
{
    rnSiteOpt   = asDefault;
    rnPkgOpt    = wpkgDefault;

    if ( !m_pTheSheet->m_pageSelectSite.m_bExportACLs )
    {
        rnSiteOpt |= asNoContentACLs;
    }

    if ( !m_pTheSheet->m_pageSelectSite.m_bExportContent )
    {
        rnSiteOpt |= asNoContent;
    }

    if ( !m_pTheSheet->m_pageSelectSite.m_bExportCert )
    {
        rnSiteOpt |= asNoCertificates;
    }

    if ( m_pTheSheet->m_pagePkgCfg.m_bCompress )
    {
        rnPkgOpt |= wpkgCompress;
    }

    if ( m_pTheSheet->m_pagePkgCfg.m_bEncrypt )
    {
        rnPkgOpt |= wpkgEncrypt;
    }
}


/* 
    This is the event handler that will be fired for status notifications by the COM Object
    Note that this will execute in different thread then the Wizard code
*/
VARIANT_BOOL __stdcall CExportProgress::OnStateChange(  IN enExportState State,
            							                IN VARIANT vntArg1,
							                            IN VARIANT vntArg2,
							                            IN VARIANT vntArg3 )
{
    static enExportState    CurrentState = estInitializing;

    WCHAR   wszPath[ MAX_PATH ];
    CString strStatus;

    bool    bNewState           = ( State != CurrentState );

    // This is the progress range which each state can use
    const int anStatePrgRange[ estStateCount ] = {  10,     // estInitializing
                                                    10,     // estSiteBegin
                                                    10,     // estExportingConfig
                                                    10,     // estExportingCertificate
                                                    10,     // estAnalyzingContent
                                                    1000,   // estExportingContent
                                                    100,    // estExportingPostImport
                                                    10,     // estExportingFrontPage
                                                    10 };   // estFinalizing

    // This is the initial progress position for each state
    static int anStatePrgFirst[ estStateCount ];

    // If the user canceled the export - notify the COM object that we want to terminate the export
    if ( m_nExportCanceled != 0 )
    {
        return VARIANT_FALSE;
    }

     // We can receive a particular state more then once
    // But when we moove to the next state we need to update the status list box
    if ( bNewState )
    {
        // End the old state in the LB
        SetCompleteStat();
        CurrentState = State;

        // Set the progress to the initial pos for this state
        m_ProgressBar.SetPos( anStatePrgFirst[ State ] );
    }

    switch( State )
    {
    case estInitializing:
        // Adjust the progress bar
        anStatePrgFirst[ 0 ] = 1;
        for ( int i = 1; i < estStateCount; ++i )
        {
            anStatePrgFirst[ i ] = anStatePrgFirst[ i - 1 ] + anStatePrgRange[ i - 1 ];
        }
        
        m_ProgressBar.SetRange32( 0, anStatePrgFirst[ estStateCount - 1 ] + anStatePrgRange[ estStateCount - 1 ] );
        break;

    case estSiteBegin:
        // This is one-time notification        
        AddStatusText( IDS_PRG_SITEBEGIN, V_BSTR( &vntArg1 ) );
        break;

    case estExportingConfig:
        // This is one-time notification        
        AddStatusText( IDS_PRG_EXPORTCFG );
        break;

    case estExportingCertificate:
        // This is one-time notification        
        AddStatusText( IDS_PRG_EXPORTCERT );
        break;

    case estAnalyzingContent:
        // This is a multiple-time event
        if ( bNewState )
        {
            AddStatusText( IDS_PRG_ANALYZECONTEN );            
        }

        if ( V_VT( &vntArg1 ) != VT_EMPTY )
        {
            strStatus.Format( IDS_PRG_VDIR_SCAN, V_BSTR( &vntArg1 ), V_I4( &vntArg2 ), V_I4( &vntArg3 ) );
            VERIFY( SetDlgItemText( IDC_STATUS, strStatus ) );
        }
        break;

    case estExportingContent:
        // This is a multiple-time event
        if ( bNewState )
        {
            AddStatusText( IDS_PRG_EXPORTCONTENT );
        }

        VERIFY( ::PathCompactPathExW( wszPath, V_BSTR( &vntArg1 ), 70, 0 ) );
        strStatus.Format( IDS_PRG_STATCONTENT, wszPath );
        VERIFY( SetDlgItemText( IDC_STATUS, strStatus ) );

        m_ProgressBar.SetPos(   anStatePrgFirst[ estExportingContent ] + 
                                min(    V_I4( &vntArg2 ) * 
                                            anStatePrgRange[ estExportingContent ]  / 
                                            V_I4( &vntArg3 ), 
                                        anStatePrgRange[ estExportingContent ] ) );
        break;

    case estExportingPostImport:
        // This is a multiple-time event
        if ( bNewState )
        {
            AddStatusText( IDS_PRG_EXPORTPOSTPROCESS );
        }

        if ( V_VT( &vntArg3 ) != VT_EMPTY )
        {
            VERIFY( ::PathCompactPathExW( wszPath, V_BSTR( &vntArg3 ), 70, 0 ) );
            strStatus.Format( IDS_PRG_STATCONTENT, wszPath );
            VERIFY( SetDlgItemText( IDC_STATUS, strStatus ) );
        }
        else
        {
            VERIFY( SetDlgItemText( IDC_STATUS, L"" ) );
        }        

        m_ProgressBar.SetPos(   anStatePrgFirst[ estExportingPostImport ] + 
                                min(    V_I4( &vntArg1 ) * 
                                            anStatePrgRange[ estExportingPostImport ]  / 
                                            V_I4( &vntArg2 ), 
                                        anStatePrgRange[ estExportingPostImport ] ) );
        break;

    case estFinalizing:
        // This is one-time notification        
        AddStatusText( IDS_PRG_FINALIZING );
        break;
    }

    return VARIANT_TRUE;
}





LRESULT CExportProgress::OnExportComplete( UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/ )
{
    m_shThread.Close();

    if ( FAILED( wParam ) )
    {
        CString strError;
        CString strTitle;

        strError.Format( IDS_E_EXPORT, static_cast<LPCWSTR>( m_strExportError ) );
        strTitle.LoadString( IDS_APPTITLE );

        ::MessageBox( m_hWnd, strError, strTitle, MB_OK | MB_ICONSTOP );

        // Go to the summary page
        m_pTheSheet->SetActivePageByID( IDD_WPEXP_SUMMARY );
    }
    else
    {
        CString strTip;
        VERIFY( strTip.LoadString( IDS_TIP_PRESSNEXT ) );
        VERIFY( SetDlgItemText( IDC_TIP, strTip ) );
        SetWindowFont( GetDlgItem( IDC_TIP ), m_pTheSheet->m_fontBold.get(), TRUE );

        SetCompleteStat();
        VERIFY( SetDlgItemText( IDC_STATUS, L"" ) );

        SetWizardButtons( PSWIZB_NEXT );
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\importfinishpage.cpp ===
#include "stdafx.h"

#include "WizardSheet.h"

LRESULT CImportFinishPage::OnInitDialog( UINT, WPARAM, LPARAM, BOOL& )
{
    // Set the fonts
	SetWindowFont( GetDlgItem( IDC_TITLE ), m_pTheSheet->m_fontTitles.get(), FALSE );

    return 1;
}



BOOL CImportFinishPage::OnSetActive()
{
    SetWizardButtons( PSWIZB_FINISH );
        
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\importoptions.cpp ===
#include "stdafx.h"

#include "WizardSheet.h"
#include "UIUtils.h"


// Valid indexees for the different options in OptNames, OptValues
enum OptIndex
{
    optInherited = 0,
    optContent,
    optCert,
    optReuseCerts,
    optPostProcess,
    optACLs,
    optPurgeOld,
    OptCount
};


static bool CImportOptions::*  OptValues[ OptCount ]   = {  &CImportOptions::m_bImportInherited,
                                                            &CImportOptions::m_bImportContent,
                                                            &CImportOptions::m_bImportCert,
                                                            &CImportOptions::m_bReuseCerts,
                                                            &CImportOptions::m_bPerformPostProcess,
                                                            &CImportOptions::m_bApplyACLs,
                                                            &CImportOptions::m_bPurgeOldData };



CImportOptions::CImportOptions( CWizardSheet* pTheSheet ) :
    m_pTheSheet( pTheSheet )
{
    m_strTitle.LoadString( IDS_TITLE_IMPOPT );
    m_strSubTitle.LoadString( IDS_SUBTITLE_IMPOPT );

    SetHeaderTitle( m_strTitle );
    SetHeaderSubTitle( m_strSubTitle );
}


LRESULT CImportOptions::OnInitDialog( UINT, WPARAM, LPARAM, BOOL& )
{
    Edit_LimitText( GetDlgItem( IDC_PATH ), MAX_PATH );

    // Enable auto complete for the filename control
    m_pTheSheet->SetAutocomplete( GetDlgItem( IDC_PATH ), SHACF_FILESYSTEM );

    m_Options = GetDlgItem( IDC_OPTIONS );

    CRect rectOpt;
    ::GetClientRect( m_Options.m_hWnd, &rectOpt );
    m_Options.InsertColumn( 0, NULL, LVCFMT_LEFT, rectOpt.Width(), 0);

    m_Options.SetExtendedListViewStyle( LVS_EX_CHECKBOXES );

    return 1;
}



LRESULT CImportOptions::OnBrowse( WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/ )
{
    CString         strTitle;
    strTitle.LoadString( IDS_MSG_WEBROOT );

    CFolderDialog   dlg( m_hWnd, strTitle );

    if ( dlg.DoModal() == IDOK )
    {
        VERIFY( SetDlgItemText( IDC_PATH, dlg.m_szFolderPath ) );
    }

    return 0;
}



LRESULT CImportOptions::OnCustomPath( WORD /*wNotifyCode*/, WORD /*wID*/, HWND hWndCtl, BOOL& /*bHandled*/ )
{
    BOOL bCustomEnabled = Button_GetCheck( hWndCtl );

    ::EnableWindow( GetDlgItem( IDC_PATH ), bCustomEnabled );
    ::EnableWindow( GetDlgItem( IDC_BROWSE ), bCustomEnabled );
    ::EnableWindow( GetDlgItem( IDC_PATHLABEL ), bCustomEnabled );

    return 0;
}



BOOL CImportOptions::OnSetActive()
{
    SetWizardButtons( PSWIZB_NEXT | PSWIZB_BACK );
    SetupOptions();

    return TRUE;
}



int CImportOptions::OnWizardNext()
{
    bool bContinue = true;

    if ( Button_GetCheck( GetDlgItem( IDC_CUSTOMPATH ) ) )
    {
        m_bUseCustomPath = true;
        GetDlgItemText( IDC_PATH, m_strCustomPath.GetBuffer( MAX_PATH + 1 ), MAX_PATH );
        m_strCustomPath.ReleaseBuffer();

        bContinue = VerifyCustomPath();
    }
    else
    {
        m_bUseCustomPath = false;
        m_strCustomPath.Empty();
    }

    // Parse the options
    if ( bContinue )
    {   
        ParseSelectedOptions();
    }
        
    return bContinue ? 0 : -1;
}



void CImportOptions::SetupOptions()
{
    int     nIndex = 0;
    
    VARIANT_BOOL        vbFlag = VARIANT_FALSE;
    IImportPackagePtr   spImport;
    ISiteInfoPtr        spInfo;

    VERIFY( m_Options.DeleteAllItems() );

    // The "import inherited" and "PurgeOldData" always exists
    CString strOptName;
    VERIFY( strOptName.LoadString( IDS_IMPOPT_INHERITED ) );
    nIndex = m_Options.InsertItem( 0, strOptName, 0 );
    m_Options.SetItemData( nIndex, optInherited );

    VERIFY( strOptName.LoadString( IDS_IMPOPT_PURGEOLDDATA ) );
    nIndex = m_Options.InsertItem( 0, strOptName, 0 );
    m_Options.SetItemData( nIndex, optPurgeOld );

    HRESULT hr = spImport.CreateInstance( CLSID_ImportPackage );
    
    if ( SUCCEEDED( hr ) )
    {
        CComBSTR bstrPkg( m_pTheSheet->m_pageLoadPkg.m_strFilename );
        CComBSTR bstrPwd( m_pTheSheet->m_pageLoadPkg.m_strPassword );

        if ( ( NULL != bstrPkg.m_str ) && ( NULL != bstrPwd.m_str ) )
        {
            hr = spImport->LoadPackage( bstrPkg, bstrPwd );    
        }
    }

    if ( SUCCEEDED( hr ) )
    {
        hr = spImport->GetSiteInfo( 0, &spInfo );
    }

    if ( SUCCEEDED( hr ) )
    {
        hr = spInfo->get_ContentIncluded( &vbFlag );
    

        if ( SUCCEEDED( hr ) && ( vbFlag != VARIANT_FALSE ) )
        {
            VERIFY( strOptName.LoadString( IDS_IMPOPT_CONTENT ) );
            nIndex = m_Options.InsertItem( 0, strOptName, 0 );
            m_Options.SetItemData( nIndex, optContent );
        }
    }

    if ( SUCCEEDED( hr ) )
    {
        hr = spInfo->get_ACLsIncluded( &vbFlag );
    
        if ( SUCCEEDED( hr ) && ( vbFlag != VARIANT_FALSE ) )
        {
            VERIFY( strOptName.LoadString( IDS_IMPOPT_APPLYACLS ) );
            nIndex = m_Options.InsertItem( 0, strOptName, 0 );
            m_Options.SetItemData( nIndex, optACLs );
        }
    }

    if ( SUCCEEDED( hr ) )
    {
        hr = spInfo->get_HaveCommands( &vbFlag );
    
        if ( SUCCEEDED( hr ) && ( vbFlag != VARIANT_FALSE ) )
        {
            VERIFY( strOptName.LoadString( IDS_IMPOPT_DOPOSTPROCESS ) );
            nIndex = m_Options.InsertItem( 0, strOptName, 0 );
            m_Options.SetItemData( nIndex, optPostProcess );
        }
    }

    if ( SUCCEEDED( hr ) )
    {
        hr = spInfo->get_HaveCertificates( &vbFlag );
    
        if ( SUCCEEDED( hr ) && ( vbFlag != VARIANT_FALSE ) )
        {
            VERIFY( strOptName.LoadString( IDS_IMPOPT_CERT ) );
            nIndex = m_Options.InsertItem( 0, strOptName, 0 );
            m_Options.SetItemData( nIndex, optCert );

            VERIFY( strOptName.LoadString( IDS_IMPOPT_REUSECERTS ) );
            nIndex = m_Options.InsertItem( 0, strOptName, 0 );
            m_Options.SetItemData( nIndex, optReuseCerts );
        }
    }

    if ( FAILED( hr ) )
    {
        m_Options.DeleteAllItems();
        UIUtils::ShowCOMError( m_hWnd, IDS_E_LOAD_PKG, IDS_APPTITLE, hr );
        SetWizardButtons( PSWIZB_BACK );
    }
}



void CImportOptions::ParseSelectedOptions()
{
    for ( int i = 0; i < OptCount; ++i )
    {
        this->*OptValues[ i ] = false;
    }

    for ( int i = 0; i < m_Options.GetItemCount(); ++i )
    {
        OptIndex Index = static_cast<OptIndex>( m_Options.GetItemData( i ) );

        this->*OptValues[ Index ] = m_Options.GetCheckState( i ) != FALSE;
    }
}



bool CImportOptions::VerifyCustomPath()
{
    // Check that this is a path
    if ( !::PathIsDirectoryW( m_strCustomPath ) )
    {
        UIUtils::MessageBox( m_hWnd, IDS_E_CUSTOMPATH_INVALID, IDS_APPTITLE, MB_OK | MB_ICONSTOP );
        return false;
    }

    // Check if it is empty
    if ( !::PathIsDirectoryEmptyW( m_strCustomPath ) )
    {
        int nRes = UIUtils::MessageBox( m_hWnd, IDS_W_CUSTOMPATH_NOTEMPTY, IDS_APPTITLE, MB_YESNO | MB_ICONWARNING );

        if ( nRes == IDNO ) return false;
    }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\importorexport.h ===
#pragma once


class CImportOrExport : public CPropertyPageImpl<CImportOrExport>
{
    typedef CPropertyPageImpl<CImportOrExport>	BaseClass;

public:

    enum{ IDD = IDD_WP_IMPORTOREXPORT };

    BEGIN_MSG_MAP(CImportOrExport)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        COMMAND_CODE_HANDLER( BN_DBLCLK, OnDoubleClick )
		CHAIN_MSG_MAP(BaseClass)
	END_MSG_MAP()


    CImportOrExport         (   CWizardSheet* pTheSheet ); 

    int     OnWizardNext    (   void );
    BOOL    OnSetActive     (   void );
    LRESULT OnInitDialog    (   UINT, WPARAM, LPARAM, BOOL& );
    LRESULT OnDoubleClick   (   WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );


private:
    CWizardSheet*       m_pTheSheet;
    CString             m_strTitle;
    CString             m_strSubTitle;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\importorexport.cpp ===
#include "stdafx.h"

#include "WizardSheet.h"

CImportOrExport::CImportOrExport( CWizardSheet* pTheSheet ) :
    m_pTheSheet( pTheSheet )
{
    m_strTitle.LoadString( IDS_TITLE_IMPORTOREXPORT );
    m_strSubTitle.LoadString( IDS_SUBTITLE_IMPORTOREXPORT );

    SetHeaderTitle( m_strTitle );
    SetHeaderSubTitle( m_strSubTitle );
}

int CImportOrExport::OnWizardNext()
{
    return Button_GetCheck( GetDlgItem( IDC_IMPORT ) ) ? IDD_WPIMP_LOADPKG : IDD_WPEXP_SELECTSITE;
}

BOOL CImportOrExport::OnSetActive()
{
    SetWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );
    return TRUE;
}

LRESULT CImportOrExport::OnInitDialog( UINT, WPARAM, LPARAM, BOOL& )
{
    Button_SetCheck( GetDlgItem( IDC_EXPORT ), TRUE );
    SetWindowFont( GetDlgItem( IDC_EXPORT ), m_pTheSheet->m_fontBold.get(), FALSE );
    SetWindowFont( GetDlgItem( IDC_IMPORT ), m_pTheSheet->m_fontBold.get(), FALSE );

    return 0;
}



LRESULT CImportOrExport::OnDoubleClick( WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/ )
{
    ::PostMessage(  m_pTheSheet->m_hWnd,
                    WM_COMMAND,
                    MAKEWPARAM( ID_WIZNEXT, BN_CLICKED ),
                    NULL );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\importoptions.h ===
#pragma once

class CImportOptions : public CPropertyPageImpl<CImportOptions>
{
    typedef CPropertyPageImpl<CImportOptions>	BaseClass;

public:
    enum{ IDD = IDD_WPIMP_OPTIONS };

    BEGIN_MSG_MAP(CImportOptions)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        COMMAND_ID_HANDLER( IDC_BROWSE, OnBrowse )
        COMMAND_ID_HANDLER( IDC_CUSTOMPATH, OnCustomPath )
		CHAIN_MSG_MAP(BaseClass)
	END_MSG_MAP()

    CImportOptions          (   CWizardSheet* pTheSheet );
    
    BOOL    OnSetActive     (   void );
    LRESULT OnInitDialog    (   UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnBrowse        (   WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnCustomPath    (   WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    int     OnWizardNext    (   void );


private:
    void    SetupOptions    (   void );
    bool    VerifyCustomPath(   void );

    void    ParseSelectedOptions(   void );


// Shared data
public:
    bool            m_bImportInherited;
    bool            m_bImportContent;
    bool            m_bImportCert;
    bool            m_bReuseCerts;
    bool            m_bPerformPostProcess;
    bool            m_bApplyACLs;
    bool            m_bPurgeOldData;
    bool            m_bUseCustomPath;

    CString         m_strCustomPath;
       

// Data members
private:
    CWizardSheet*   m_pTheSheet;
    CString         m_strTitle;
    CString         m_strSubTitle;
    CListViewCtrl   m_Options;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\loadpackage.h ===
#pragma once

class CLoadPackage : public CPropertyPageImpl<CLoadPackage>
{
    typedef CPropertyPageImpl<CLoadPackage>	BaseClass;

public:
    enum{ IDD = IDD_WPIMP_LOADPKG };

    BEGIN_MSG_MAP(CLoadPackage)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        COMMAND_ID_HANDLER( IDC_BROWSE, OnBrowse )
        COMMAND_CODE_HANDLER( EN_CHANGE, OnEditChange )
		CHAIN_MSG_MAP(BaseClass)
	END_MSG_MAP()

    CLoadPackage             (   CWizardSheet* pTheSheet );
    
    BOOL    OnSetActive     (   void );
    LRESULT OnInitDialog    (   UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnBrowse        (   WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnEditChange    (   WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    int     OnWizardNext    (   void );
    int     OnWizardBack    (   void );


// Shared data
public:
    CString         m_strFilename;
    CString         m_strPassword;    

// Data members
private:
    CWizardSheet*   m_pTheSheet;
    CString         m_strTitle;
    CString         m_strSubTitle;

    CEdit           m_editPwd;;
    CEdit           m_editPkgName;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\loadpackage.cpp ===
#include "StdAfx.h"

#include "WizardSheet.h"
#include "UIUtils.h"

CLoadPackage::CLoadPackage( CWizardSheet* pTheSheet ) :
    m_pTheSheet( pTheSheet )
{
    m_strTitle.LoadString( IDS_TITLE_LOADPKG );
    m_strSubTitle.LoadString( IDS_SUBTITLE_LOADPKG );

    SetHeaderTitle( m_strTitle );
    SetHeaderSubTitle( m_strSubTitle );
}


BOOL CLoadPackage::OnSetActive()
{
    bool bHavePwd = m_editPwd.GetWindowTextLength() > 0;
    bool bHaveName= m_editPkgName.GetWindowTextLength() > 0;

    SetWizardButtons( PSWIZB_BACK | ( bHaveName && bHavePwd ? PSWIZB_NEXT : 0 ) );

    return TRUE;
}


LRESULT CLoadPackage::OnInitDialog( UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/ )
{
    Edit_LimitText( GetDlgItem( IDC_PWD ), CPackageConfig::MAX_PWD_LEN );
    Edit_LimitText( GetDlgItem( IDC_PKGNAME ), MAX_PATH );

    // Enable autocomplete
    m_pTheSheet->SetAutocomplete( GetDlgItem( IDC_PKGNAME ), SHACF_FILESYSTEM );

    m_editPwd       = GetDlgItem( IDC_PWD );
    m_editPkgName   = GetDlgItem( IDC_PKGNAME );

    return 1;
}


LRESULT CLoadPackage::OnBrowse( WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/ )
{
    CString strFilter;
    UIUtils::LoadOFNFilterFromRes( IDS_FILTER_PACKAGE, /*r*/strFilter );

    CFileDialog dlg(    TRUE,
                        NULL,
                        NULL,
                        OFN_ENABLESIZING | OFN_EXPLORER | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY,
                        strFilter,
                        m_hWnd );

    if ( dlg.DoModal() == IDCANCEL ) return 0;

    VERIFY( SetDlgItemText( IDC_PKGNAME, dlg.m_szFileName ) );

    return 0;
}



int CLoadPackage::OnWizardNext()
{
    GetDlgItemText( IDC_PKGNAME, m_strFilename.GetBuffer( MAX_PATH + 1 ), MAX_PATH );
    GetDlgItemText( IDC_PWD, m_strPassword.GetBuffer( CPackageConfig::MAX_PWD_LEN + 1 ), CPackageConfig::MAX_PWD_LEN );
    m_strFilename.ReleaseBuffer();
    m_strPassword.ReleaseBuffer();

    TFileHandle shFile( ::CreateFile(   m_strFilename,
                                        GENERIC_READ,
                                        0,
                                        NULL,
                                        OPEN_EXISTING,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL ) );

    // Check the existance only. Other errors will be handled by the engine
    if ( !shFile.IsValid() && ( ::GetLastError() == ERROR_FILE_NOT_FOUND ) )
    {
        UIUtils::MessageBox( m_hWnd, IDC_PKGFILE_NOTFOUND, IDS_APPTITLE, MB_OK | MB_ICONSTOP );
        m_editPkgName.SetFocus();
        return -1;
    }

    shFile.Close();

    // Check if we can load the package
    IImportPackagePtr   spImport;
    HRESULT hr = spImport.CreateInstance( CLSID_ImportPackage );
    
    if ( SUCCEEDED( hr ) )
    {
        CComBSTR bstrPkg( m_pTheSheet->m_pageLoadPkg.m_strFilename );
        CComBSTR bstrPwd( m_pTheSheet->m_pageLoadPkg.m_strPassword );

        if ( ( NULL != bstrPkg.m_str ) && ( NULL != bstrPwd.m_str ) )
        {
            hr = spImport->LoadPackage( bstrPkg, bstrPwd );    
        }
    }

    if ( FAILED( hr ) )
    {
        UIUtils::ShowCOMError( m_hWnd, IDS_E_LOAD_PKG, IDS_APPTITLE, hr );
        return -1;
    }

    return 0;
}



LRESULT CLoadPackage::OnEditChange( WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/ )
{
    bool bHavePwd = m_editPwd.GetWindowTextLength() > 0;
    bool bHaveName= m_editPkgName.GetWindowTextLength() > 0;

    SetWizardButtons( PSWIZB_BACK | ( bHaveName && bHavePwd ? PSWIZB_NEXT : 0 ) );

    return 0;
}



int CLoadPackage::OnWizardBack()
{
    return IDD_WP_IMPORTOREXPORT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\importprogress.h ===
#pragma once

extern _ATL_FUNC_INFO StateChangeInfo;



class CImportProgress : public CPropertyPageImpl<CImportProgress>,
    public IDispEventSimpleImpl<1, CImportProgress, &__uuidof( _IImportEvents )>
    
{
    typedef CPropertyPageImpl<CImportProgress>	BaseClass;

public:

    enum{ IDD = IDD_WPIMP_PROGRESS };

    static const UINT   MSG_COMPLETE    = WM_USER + 1;  // Indicates export is completed

    BEGIN_MSG_MAP(CImportProgress)
        MESSAGE_HANDLER( MSG_COMPLETE, OnImportComplete );
        CHAIN_MSG_MAP(BaseClass)
	END_MSG_MAP()

    BEGIN_SINK_MAP( CImportProgress )
        SINK_ENTRY_INFO( 1, __uuidof( _IImportEvents ), 1/*dispid*/, OnStateChange, &StateChangeInfo )
    END_SINK_MAP()


    CImportProgress         (   CWizardSheet* pTheSheet ); 

    BOOL    OnSetActive     (   void );
    BOOL    OnQueryCancel   (   void );

    LRESULT OnImportComplete(   UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );

    // Event from the COM object for progress indications
    VARIANT_BOOL __stdcall OnStateChange(    enExportState State,
							                VARIANT vntArg1,
							                VARIANT vntArg2,
							                VARIANT vntArg3 );


private:
    void    AddStatusText   (   UINT nID, LPCWSTR wszText = NULL, DWORD dw1 = 0, DWORD dw2 = 0 );
    void    SetCompleteStat (   void );
    void    GetOptions      (   LONG& rnImpportOpt );

    static unsigned __stdcall ThreadProc( void* pCtx );


public:
    CString             m_strImportError;
    
    
private:
    CWizardSheet*       m_pTheSheet;
    CString             m_strTitle;
    CString             m_strSubTitle;
    LONG                m_nImportCanceled;  // 1 = canceled, 0 = not canceled
    TStdHandle          m_shThread;
    CProgressBarCtrl    m_ProgressBar;    
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\importprogress.cpp ===
#include "stdafx.h"

#include "WizardSheet.h"
#include "UIUtils.h"


static _ATL_FUNC_INFO StateChangeInfo =    {  CC_STDCALL, 
                                                VT_BOOL,
                                                4,
                                                { VT_I4, VT_VARIANT, VT_VARIANT, VT_VARIANT }
                                             };



CImportProgress::CImportProgress( CWizardSheet* pTheSheet ) :
        m_pTheSheet( pTheSheet )
{
    m_strTitle.LoadString( IDS_TITLE_IMPORT_PROGRESS );
    m_strSubTitle.LoadString( IDS_SUBTITLE_IMPORT_PROGRESS );

    SetHeaderTitle( m_strTitle );
    SetHeaderSubTitle( m_strSubTitle );
}



BOOL CImportProgress::OnSetActive()
{
    SetWizardButtons( 0 );
    ListBox_ResetContent( GetDlgItem( IDC_OPLIST ) );

    AddStatusText( IDC_OPS_INITENGINE );
    
    m_ProgressBar = GetDlgItem( IDC_PROGRESS );
    m_ProgressBar.SetPos( 0 );
    VERIFY( SetDlgItemText( IDC_STATUS, L"" ) );
    m_strImportError.Empty();

    m_nImportCanceled   = 0;

    UINT nThreadID = 0;
    // Start the thread where the actuall export process will take place
    m_shThread =  reinterpret_cast<HANDLE>( ::_beginthreadex(   NULL,
                                                                0,
                                                                CImportProgress::ThreadProc,
                                                                this,
                                                                0,
                                                                &nThreadID ) );
    return TRUE;
}


BOOL CImportProgress::OnQueryCancel( void )
{
    // If Export is not in progress - allow exit
    if ( !m_shThread.IsValid() ) return TRUE;

    // Preven reentrancy ( Cancel the export when it's already cancedl )
    // while we wait for next event from the COM object
    if ( m_nImportCanceled != 0 ) return FALSE;

    if ( UIUtils::MessageBox( m_hWnd, IDS_MSG_CANCELIMPORT, IDS_APPTITLE, MB_YESNO | MB_ICONQUESTION ) != IDYES )
    {
        return FALSE;
    }

    // m_nImportCanceled is used by the event handler which is another thread
    ::InterlockedIncrement( &m_nImportCanceled );

    // Set the status text 
    CString str;
    VERIFY( str.LoadString( IDS_PRG_IMPORTCANCELED ) );
    SetDlgItemText( IDC_STATUS, str );

    HANDLE hThread = m_shThread.get();

    do
    {
        DWORD dwWaitRes = ::MsgWaitForMultipleObjects( 1, &hThread, FALSE, INFINITE, QS_ALLEVENTS );

        if ( dwWaitRes == ( WAIT_OBJECT_0 + 1 ) )
        {
            // MSG

            MSG msg;
            ::GetMessage( &msg, NULL, 0, 0 );
            ::TranslateMessage( &msg );
            ::DispatchMessage( &msg );
        }
        else
        {
            break;
        }
    }while( true );
    

    return TRUE;
}



unsigned __stdcall CImportProgress::ThreadProc( void* pCtx )
{
    CImportProgress* pThis = reinterpret_cast<CImportProgress*>( pCtx );

    pThis->SetCompleteStat();
    pThis->AddStatusText( IDS_OPS_CONFIGENGINE );

    HRESULT             hr = ::CoInitialize( NULL );
    IImportPackagePtr   spImport;

    LONG    nOpt    = 0;    
    bool    bAdvised    = false; // Is connected to the event source

    pThis->GetOptions( /*r*/nOpt );

    if ( SUCCEEDED( hr ) )
    {
        hr = spImport.CreateInstance( CLSID_ImportPackage );
        
        if ( FAILED( hr ) )
        {
            VERIFY( pThis->m_strImportError.LoadString( IDS_E_NOENGINE ) );
        }
    }

    // Advise to the state events
    if ( SUCCEEDED( hr ) )
    {
        hr = pThis->DispEventAdvise( spImport.GetInterfacePtr() );

        bAdvised = SUCCEEDED( hr );
    }

    if ( SUCCEEDED( hr ) )
    {
        CComBSTR bstrPkg( pThis->m_pTheSheet->m_pageLoadPkg.m_strFilename );
        CComBSTR bstrPwd( pThis->m_pTheSheet->m_pageLoadPkg.m_strPassword );

        if ( ( NULL != bstrPkg.m_str ) && ( NULL != bstrPwd.m_str ) )
        {
            hr = spImport->LoadPackage( bstrPkg, bstrPwd );    
        }
    }

    // Import the site
    if ( SUCCEEDED( hr ) )
    {
        CComBSTR    bstrCustomPath;
        
        if ( pThis->m_pTheSheet->m_pageImpOpt.m_bUseCustomPath )
        {
            bstrCustomPath = pThis->m_pTheSheet->m_pageImpOpt.m_strCustomPath;
               
            if ( NULL == bstrCustomPath.m_str )
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if ( SUCCEEDED( hr ) )
        {
            hr = spImport->ImportSite( 0, bstrCustomPath, nOpt );
        }
    }

    // Get the error
    if ( pThis->m_strImportError.IsEmpty() && FAILED( hr ) )
    {
        CComBSTR        bstrText( L"Unknown Error" );;
        IErrorInfoPtr   spInfo;

        VERIFY( SUCCEEDED( ::GetErrorInfo( 0, &spInfo ) ) );
        if ( spInfo != NULL )
        {
            VERIFY( SUCCEEDED( spInfo->GetDescription( &bstrText ) ) );
        }

        pThis->m_strImportError = bstrText;
    }

    // Disconnect from the event source
    if ( bAdvised )
    {
        VERIFY( SUCCEEDED( pThis->DispEventUnadvise( spImport.GetInterfacePtr() ) ) );
    }

    spImport = NULL;

    ::CoUninitialize();

    // Notify the dialog that the export is complete
    VERIFY( ::PostMessage( pThis->m_hWnd, MSG_COMPLETE, hr, 0 ) );

    return 0;
}

void CImportProgress::AddStatusText( UINT nID, LPCWSTR wszText /*= NULL*/, DWORD dw1 /*= 0*/, DWORD dw2 /*= 0*/ )
{
    CString str;

    str.Format( nID, wszText, dw1, dw2 );

    ListBox_InsertString( GetDlgItem( IDC_OPLIST ), -1, str );
}


void CImportProgress::SetCompleteStat()
{
    CListBox    LB( GetDlgItem( IDC_OPLIST ) );
    int         iLast = LB.GetCount() - 1;

    _ASSERT( iLast >= 0 );

    CString strCurrent;
    LB.GetText( iLast, strCurrent );

    strCurrent += L"OK";
    LB.InsertString( iLast, strCurrent );
    LB.DeleteString( iLast + 1 );
}



void CImportProgress::GetOptions( LONG& rnImpportOpt )
{
    rnImpportOpt = impDefault;

    if ( !m_pTheSheet->m_pageImpOpt.m_bApplyACLs )
    {
        rnImpportOpt |= impSkipFileACLs;
    }

    if ( !m_pTheSheet->m_pageImpOpt.m_bImportCert )
    {
        rnImpportOpt |= impSkipCertificate;
    }

    if ( !m_pTheSheet->m_pageImpOpt.m_bImportContent )
    {
        rnImpportOpt |= impSkipContent;
    }

    if ( m_pTheSheet->m_pageImpOpt.m_bImportInherited )
    {
        rnImpportOpt |= impImortInherited;
    }

    if ( !m_pTheSheet->m_pageImpOpt.m_bPerformPostProcess )
    {
        rnImpportOpt |= impSkipPostProcess;
    }

    if ( m_pTheSheet->m_pageImpOpt.m_bPurgeOldData )
    {
        rnImpportOpt |= impPurgeOldData;
    }

    if ( m_pTheSheet->m_pageImpOpt.m_bReuseCerts )
    {
        rnImpportOpt |= impUseExistingCerts;
    }
}


/* 
    This is the event handler that will be fired for status notifications by the COM Object
    Note that this will execute in different thread then the Wizard code
*/
VARIANT_BOOL __stdcall CImportProgress::OnStateChange(  IN enExportState State,
            							                IN VARIANT vntArg1,
							                            IN VARIANT vntArg2,
							                            IN VARIANT vntArg3 )
{
    static enExportState    CurrentState = estInitializing;

    WCHAR   wszPath[ MAX_PATH ];
    CString strStatus;

    // If the user canceled the import - notify the COM object that we want to terminate the export
    if ( m_nImportCanceled != 0 )
    {
        return VARIANT_FALSE;
    }

    // We can receive a particular state more then once
    // But when we moove to the next state we need to update the status list box

    switch( State )
    {
    case istProgressInfo:
        // Set the progress range
        m_ProgressBar.SetRange( 0, V_I4( &vntArg1 ) );
        m_ProgressBar.SetStep( 1 );
        m_ProgressBar.SetPos( 0 );
        break;

    case istImportingVDir:
        SetCompleteStat();
        strStatus.Format( IDS_PRG_IMPORTINGVDIR, V_BSTR( &vntArg1 ), V_BSTR( &vntArg2 ));
        ListBox_InsertString( GetDlgItem( IDC_OPLIST ), -1, strStatus );
        
        m_ProgressBar.StepIt();
        break;

    case istImportingFile:
        VERIFY( ::PathCompactPathExW( wszPath, V_BSTR( &vntArg1 ), 70, 0 ) );
        strStatus.Format( IDS_PRG_EXTRACTING_FILE, wszPath );
        VERIFY( SetDlgItemText( IDC_STATUS, strStatus ) );
        m_ProgressBar.StepIt();
        break;

    case istImportingCertificate:
        SetCompleteStat();
        AddStatusText( IDS_PRG_IMPORT_CERT );
        break;

    case istImportingConfig:
        SetCompleteStat();
        AddStatusText( IDS_PRG_IMPORT_CONFIG );
        break;

    case istPostProcess:
        SetCompleteStat();
        AddStatusText( IDS_PRG_IMPORT_POSTPROCESS );

        if ( V_BOOL( &vntArg1 ) != VARIANT_FALSE )
        {
            strStatus.Format( IDS_PRG_EXEC_PP_FILE, V_BSTR( &vntArg2 ) );
        }
        else
        {
            strStatus.Format( IDS_PRG_EXEC_PP_CMD, V_BSTR( &vntArg2 ) );
        }
        VERIFY( SetDlgItemText( IDC_STATUS, strStatus ) );
        break;

    case istFinalizing:
        SetCompleteStat();
        AddStatusText( IDS_PRG_FINALIZING );
        break;        
    };

    return VARIANT_TRUE;
}



LRESULT CImportProgress::OnImportComplete( UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/ )
{
    m_shThread.Close();

    if ( FAILED( wParam ) )
    {
        CString strError;
        CString strTitle;

        strError.Format( IDS_E_IMPORT, static_cast<LPCWSTR>( m_strImportError ) );
        strTitle.LoadString( IDS_APPTITLE );

        ::MessageBox( m_hWnd, strError, strTitle, MB_OK | MB_ICONSTOP );

        // Go to the summary page
        m_pTheSheet->SetActivePageByID( IDD_WPIMP_OPTIONS );
    }
    else
    {
        CString strTip;
        VERIFY( strTip.LoadString( IDS_TIP_PRESSNEXT ) );
        VERIFY( SetDlgItemText( IDC_TIP, strTip ) );
        SetWindowFont( GetDlgItem( IDC_TIP ), m_pTheSheet->m_fontBold.get(), TRUE );

        SetCompleteStat();
        VERIFY( SetDlgItemText( IDC_STATUS, L"" ) );

        SetWizardButtons( PSWIZB_NEXT );
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\packageconfig.cpp ===
#include "stdafx.h"

#include "WizardSheet.h"
#include "UIUtils.h"


CPackageConfig::CPackageConfig( CWizardSheet* pTheSheet ) :
    m_pTheSheet( pTheSheet )
{
    m_strTitle.LoadString( IDS_TITLE_PKG );
    m_strSubTitle.LoadString( IDS_SUBTITLE_PKG );

    SetHeaderTitle( m_strTitle );
    SetHeaderSubTitle( m_strSubTitle );
}


LRESULT CPackageConfig::OnInitDialog( UINT, WPARAM, LPARAM, BOOL& )
{
    Edit_LimitText( GetDlgItem( IDC_PWD ), MAX_PWD_LEN );
    Edit_LimitText( GetDlgItem( IDC_CONFIRM ), MAX_PWD_LEN );
    Edit_LimitText( GetDlgItem( IDC_PKGNAME ), MAX_PATH );

    // Enable auto complete for the filename control
    m_pTheSheet->SetAutocomplete( GetDlgItem( IDC_PKGNAME ), SHACF_FILESYSTEM );

	return 0;
}



LRESULT CPackageConfig::OnBrowse( WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/ )
{
    CString strFilter;
    UIUtils::LoadOFNFilterFromRes( IDS_FILTER_PACKAGE, /*r*/strFilter );

    CFileDialog dlg(    FALSE,
                        L"*.pkg",
                        NULL,
                        OFN_ENABLESIZING | OFN_EXPLORER,
                        strFilter,
                        m_hWnd );

    if ( dlg.DoModal() == IDCANCEL ) return 0;

    VERIFY( SetDlgItemText( IDC_PKGNAME, dlg.m_szFileName ) );

    return 0;
}



int CPackageConfig::OnWizardNext()
{
    UINT nErrorID = 0;

    GetDlgItemText( IDC_PKGNAME, m_strFilename.GetBuffer( MAX_PATH + 1 ), MAX_PATH );
    m_strFilename.ReleaseBuffer();

    // Check the package filename is valid
    TFileHandle shFile( ::CreateFile(   m_strFilename,
                                        GENERIC_WRITE,
                                        0,
                                        NULL,
                                        OPEN_ALWAYS,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL ) );

    CString strPwd;
    CString strPwdConfirm;

    // Check the password is confirmed properly
    GetDlgItemText( IDC_PWD, strPwd.GetBuffer( MAX_PWD_LEN + 1 ), MAX_PWD_LEN );
    GetDlgItemText( IDC_CONFIRM, strPwdConfirm.GetBuffer( MAX_PWD_LEN + 1 ), MAX_PWD_LEN );
    strPwd.ReleaseBuffer();
    strPwdConfirm.ReleaseBuffer();

    if ( !shFile.IsValid() )
    {
        nErrorID = IDS_E_WRONGPKGNAME;
        ::SetFocus( GetDlgItem( IDC_PKGNAME ) );
    }
    else if ( strPwd.IsEmpty() )
    {
        nErrorID = IDS_E_PASSWORD_EMPTY;
        ::SetFocus( GetDlgItem( IDC_PWD ) );
    }
    else if ( strPwd != strPwdConfirm )
    {
        nErrorID = IDS_E_PWDS_DIFFER;
        ::SetFocus( GetDlgItem( IDC_CONFIRM ) );
    }
    
    if ( nErrorID != 0 )
    {
        UIUtils::MessageBox( m_hWnd, nErrorID, IDS_APPTITLE, MB_OK | MB_ICONSTOP );
        return -1;
    }

    // Get the data
    GetDlgItemText( IDC_COMMENT, m_strComment.GetBuffer( 1024 + 1 ), 1024 );
    m_strComment.ReleaseBuffer();

    m_strPassword = strPwd;

    m_bCompress     = Button_GetCheck( GetDlgItem( IDC_COMPRESS ) ) != FALSE;
    m_bEncrypt      = Button_GetCheck( GetDlgItem( IDC_ENCRYPT ) ) != FALSE;
    m_bPostProcess  = Button_GetCheck( GetDlgItem( IDC_ADDPOSTPROCESS ) ) != FALSE;

    // We will display either the post-import dlg or the summary page
    return Button_GetCheck( GetDlgItem( IDC_ADDPOSTPROCESS ) ) ? IDD_WPEXP_POSTPROCESS : IDD_WPEXP_SUMMARY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\packageconfig.h ===
#pragma once

class CPackageConfig : public CPropertyPageImpl<CPackageConfig>
{
    typedef CPropertyPageImpl<CPackageConfig>	BaseClass;

public:
    enum{ IDD = IDD_WPEXP_PKG };

    static const int MAX_PWD_LEN = 8;

    BEGIN_MSG_MAP(CPackageConfig)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        COMMAND_ID_HANDLER( IDC_BROWSE, OnBrowse )
		CHAIN_MSG_MAP(BaseClass)
	END_MSG_MAP()

    CPackageConfig              (   CWizardSheet* pTheSheet );
        
    LRESULT OnInitDialog        (   UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnBrowse            (   WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    int     OnWizardNext        (   void );


// Shared data
public:
    CString         m_strFilename;
    CString         m_strComment;
    CString         m_strPassword;
    bool            m_bCompress;
    bool            m_bEncrypt;
    bool            m_bPostProcess;
    
// Data members
private:
    CWizardSheet*   m_pTheSheet;
    CString         m_strTitle;
    CString         m_strSubTitle;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\packageinfo.h ===
#pragma once

class CPackageInfo : public CPropertyPageImpl<CPackageInfo>
{
    typedef CPropertyPageImpl<CPackageInfo>	BaseClass;

public:
    enum{ IDD = IDD_WPIMP_PKGINFO };

    BEGIN_MSG_MAP(CPackageInfo)
		CHAIN_MSG_MAP(BaseClass)
	END_MSG_MAP()

    CPackageInfo            (   CWizardSheet* pTheSheet );
    
    BOOL    OnSetActive     (   void );  


private:
    void    SetupOptions    (   void );
    void    SetDate         (   const IImportPackagePtr& spImport );
    void    SetMachine      (   const IImportPackagePtr& spImport );
    void    SetOS           (   const IImportPackagePtr& spImport );
    void    SetSiteName     (   const IImportPackagePtr& spImport );
    void    SetComment      (   const IImportPackagePtr& spImport );
    

// Shared data
public:
    CString         m_strSiteName;
       

// Data members
private:
    CWizardSheet*   m_pTheSheet;
    CString         m_strTitle;
    CString         m_strSubTitle;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\postprocessadd.h ===
#pragma once

class CPostProcessAdd : public CPropertyPageImpl<CPostProcessAdd>
{
    typedef CPropertyPageImpl<CPostProcessAdd>	BaseClass;

public:
    struct CmdInfo
    {
        CString strText;
        DWORD   dwTimeout;
        bool    bIgnoreErrors;
    };

    typedef std::vector<CmdInfo>  TCmdList;

    enum{ IDD = IDD_WPEXP_POSTPROCESS };

	BEGIN_MSG_MAP(CPostProcessAdd)
        COMMAND_ID_HANDLER( IDC_ADDFILE, OnAddFile );
        COMMAND_ID_HANDLER( IDC_ADDCMD, OnAddCmd );
        COMMAND_ID_HANDLER( IDC_DELFILE, OnDelFile );
        COMMAND_ID_HANDLER( IDC_DELCMD, OnDelCmd );
        COMMAND_ID_HANDLER( IDC_EDITCMD, OnEditCmd );
        COMMAND_CODE_HANDLER( LBN_SELCHANGE, LBSelChanged );
        COMMAND_CODE_HANDLER( LBN_DBLCLK, LBDoubleClick );
        COMMAND_ID_HANDLER( IDC_MOVEUP, OnMoveUp );
        COMMAND_ID_HANDLER( IDC_MOVEDOWN, OnMoveDown );
		CHAIN_MSG_MAP(BaseClass)
	END_MSG_MAP()


    CPostProcessAdd         (   CWizardSheet* pTheSheet );

    LRESULT OnAddFile       (   WORD wNotifyCode, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& bHandled );
    LRESULT OnDelFile       (   WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT LBSelChanged    (   WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnAddCmd        (   WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnDelCmd        (   WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnEditCmd       (   WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT LBDoubleClick   (   WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnMoveUp        (   WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnMoveDown      (   WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );

    int    OnWizardNext    (   void );

private:
    void    LBSwapElements  (   HWND hwndLB, int iSrc, int iTarget );


// SHared data
public:
    TStringList         m_Files;
    TCmdList            m_Commands;


private:
    CWizardSheet*       m_pTheSheet;
    CString             m_strTitle;
    CString             m_strSubTitle;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\packageinfo.cpp ===
#include "stdafx.h"

#include "WizardSheet.h"
#include "UIUtils.h"



CPackageInfo::CPackageInfo( CWizardSheet* pTheSheet ) :
    m_pTheSheet( pTheSheet )
{
    m_strTitle.LoadString( IDS_TITLE_PKGINFO );
    m_strSubTitle.LoadString( IDS_SUBTITLE_PKGINFO );

    SetHeaderTitle( m_strTitle );
    SetHeaderSubTitle( m_strSubTitle );
}


BOOL CPackageInfo::OnSetActive()
{
    CString             strError;
    IImportPackagePtr   spImport;
    ISiteInfoPtr        spSite;

    CComBSTR            bstrData;
    CString             strEntry;

    strEntry.Format( IDS_PKGINFO_PKGNAME, m_pTheSheet->m_pageLoadPkg.m_strFilename );
    ListBox_InsertString( GetDlgItem( IDC_INFO ), -1, strEntry );
    
    
    HRESULT hr = spImport.CreateInstance( CLSID_ImportPackage );
    if ( FAILED( hr ) )
    {
        strError.LoadString( IDS_E_NOENGINE );
    }

    if ( SUCCEEDED( hr ) )
    {
        CComBSTR bstrPkg( m_pTheSheet->m_pageLoadPkg.m_strFilename );
        CComBSTR bstrPwd( m_pTheSheet->m_pageLoadPkg.m_strPassword );

        if ( ( NULL == bstrPkg.m_str ) || ( NULL == bstrPwd.m_str ) )
        {
            strError = L"Out of memory!";
        }

        hr = spImport->LoadPackage( bstrPkg, bstrPwd );
    }

    if ( SUCCEEDED( hr ) )
    {
        SetDate( spImport );
        SetMachine( spImport );
        SetOS( spImport );
        SetSiteName( spImport );
        SetComment( spImport );
    }

    if ( FAILED( hr ) )
    {
        UIUtils::ShowCOMError( m_hWnd, IDS_E_LOAD_PKG, IDS_APPTITLE, hr );
        SetWizardButtons( PSWIZB_BACK );
    }
   
    // Allow the page to be displayd, becasue otherwise the sheet will display the next page
    return TRUE;
}



void CPackageInfo::SetDate( const IImportPackagePtr& spImport )
{
    DATE        dtCreated   = 0.0;
    _variant_t  vntDateStr;
    CString     strEntry;
    CString     strData;

    strData.LoadString( IDS_PKGINFO_ERROR );

    HRESULT hr = spImport->get_TimeCreated( &dtCreated );

    if ( SUCCEEDED( hr ) )
    {
        _variant_t vntDate( dtCreated );
        
        V_VT( &vntDate ) = VT_DATE;

        hr = ::VariantChangeType( &vntDateStr, &vntDate, 0, VT_BSTR );
 
        if ( SUCCEEDED( hr ) )
        {
            strData = V_BSTR( &vntDateStr );
        }
    }
     
    strEntry.Format( IDS_PKGINFO_PKGDATE, static_cast<LPCWSTR>( strData ) );
    ListBox_InsertString( GetDlgItem( IDC_INFO ), -1, strEntry );
}



void CPackageInfo::SetMachine( const IImportPackagePtr& spImport )
{
    CString     strEntry;
    CComBSTR    bstrData;
    CString     strData;

    strData.LoadString( IDS_PKGINFO_ERROR );

    HRESULT hr = spImport->get_SourceMachine( &bstrData );

    if ( SUCCEEDED( hr ) )
    {
        strData = bstrData;
    }

    strEntry.Format( IDS_PKGINFO_MACHINE, static_cast<LPCWSTR>( strData ) );
    ListBox_InsertString( GetDlgItem( IDC_INFO ), -1, strEntry );
}


void CPackageInfo::SetOS( const IImportPackagePtr& spImport )
{
    BYTE            btMajor     = 0;
    BYTE            btMinor     = 0;
    VARIANT_BOOL    vbIsServer  = VARIANT_FALSE;

    CString strEntry, strData;
    strData.LoadString( IDS_PKGINFO_ERROR );

    HRESULT hr = spImport->GetSourceOSVer( &btMajor, &btMinor, &vbIsServer );

    if ( SUCCEEDED( hr ) )
    {
        WCHAR wszBuffer[ 1024 ] = L"Microsoft Windows ";

        switch ( btMajor )
        {
        case 4:
            ::wcscat( wszBuffer, L"NT 4.0" );
            if ( vbIsServer != VARIANT_FALSE )
            {
                ::wcscat( wszBuffer, L" Server" );
            }
    
            break;

        case 5:
            switch( btMinor )
            {
            case 0:
                ::wcscat( wszBuffer, L"2000" );
                if ( vbIsServer != VARIANT_FALSE )
                {
                    ::wcscat( wszBuffer, L" Server" );
                }
        
                break;

            case 1:
                ::wcscat( wszBuffer, L"XP" );
                break;

            case 2:
                ::wcscat( wszBuffer, L"Server 2003" );
        
                break;
            };
            break;        
        }

        strData = wszBuffer;
    }

    strEntry.Format( IDS_PKGINFO_OS, static_cast<LPCWSTR>( strData ) );
    ListBox_InsertString( GetDlgItem( IDC_INFO ), -1, strEntry );
}


void CPackageInfo::SetSiteName( const IImportPackagePtr& spImport )
{
    CComBSTR        bstr;
    ISiteInfoPtr    spInfo;

    CString strData, strEntry;
    strData.LoadString( IDS_PKGINFO_ERROR );

    HRESULT hr = spImport->GetSiteInfo( 0, &spInfo );

    if ( SUCCEEDED( hr ) )
    {
        hr = spInfo->get_DisplayName( &bstr );
    }

    if ( SUCCEEDED( hr ) )
    {
        strData = bstr;
    }

    strEntry.Format( IDS_PKGINFO_COMMENT, static_cast<LPCWSTR>( strData ) );
    ListBox_InsertString( GetDlgItem( IDC_INFO ), -1, strEntry );
}
    

void CPackageInfo::SetComment( const IImportPackagePtr& spImport )
{
    CComBSTR bstr;

    CString strData, strEntry;
    strData.LoadString( IDS_PKGINFO_ERROR );

    HRESULT hr = spImport->get_Comment( &bstr );

    if ( SUCCEEDED( hr ) )
    {
        strData = bstr;
    }

    strEntry.Format( IDS_PKGINFO_COMMENT, static_cast<LPCWSTR>( strData ) );
    ListBox_InsertString( GetDlgItem( IDC_INFO ), -1, strEntry );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\postprocessadd.cpp ===
#include "stdafx.h"

#include "WizardSheet.h"
#include "CommandDlg.h"

CPostProcessAdd::CPostProcessAdd( CWizardSheet* pTheSheet ) :
    m_pTheSheet( pTheSheet )
{
    m_strTitle.LoadString( IDS_TITLE_POSTPROCESS );
    m_strSubTitle.LoadString( IDS_SUBTITLE_POSTPROCESS );

    SetHeaderTitle( m_strTitle );
    SetHeaderSubTitle( m_strSubTitle );
}



LRESULT CPostProcessAdd::OnAddFile( WORD wNotifyCode, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& bHandled )
{
    CString strFilter;
    
    UIUtils::LoadOFNFilterFromRes( IDS_FILTER_POSTPROCESSFILES, /*r*/strFilter );

    CFileDialog dlg(    TRUE,
                        NULL,
                        NULL,
                        OFN_ENABLESIZING | OFN_EXPLORER | OFN_NOREADONLYRETURN | OFN_FILEMUSTEXIST,
                        strFilter,
                        m_hWnd );

    if ( dlg.DoModal() == IDCANCEL ) return 0;

    // File names must be unique as the path is not preserved
    // Check if there is already a file with the same name

    WCHAR wszNew[ MAX_PATH + 1 ];
    ::wcscpy( wszNew, dlg.m_szFileName );
    ::PathStripPath( wszNew );
            
    for (   TStringList::const_iterator it = m_Files.begin();
            it != m_Files.end();
            ++it )
    {
        WCHAR wszCurrent[ MAX_PATH + 1 ];
        ::wcscpy( wszCurrent, it->c_str() );
        ::PathStripPathW( wszCurrent );

        if ( ::_wcsicmp( wszCurrent, wszNew ) == 0 )
        {
            UIUtils::MessageBox( m_hWnd, IDS_E_PPFILENOTUNIQUE, IDS_APPTITLE, MB_OK | MB_ICONSTOP );
            return 0 ;
        }
    }

    m_Files.push_back( std::wstring( dlg.m_szFileName ) );
    ::wcscpy( wszNew, dlg.m_szFileName );
    UIUtils::PathCompatCtrlWidth( GetDlgItem( IDC_FILES ), wszNew, ::GetSystemMetrics( SM_CXVSCROLL ) );


    ListBox_AddString( GetDlgItem( IDC_FILES ), wszNew );

    return 0;
}



LRESULT CPostProcessAdd::OnDelFile( WORD wNotifyCode, WORD /*wID*/, HWND hWndCtl, BOOL& bHandled )
{
    HWND hwndFiles = GetDlgItem( IDC_FILES );

    int nCurSel = ListBox_GetCurSel( hwndFiles );
    _ASSERT( nCurSel != LB_ERR );

    ListBox_DeleteString( hwndFiles, nCurSel );

    if ( ListBox_GetCount( hwndFiles ) > 0 )
    {
        ListBox_SetCurSel( hwndFiles, max( nCurSel - 1, 0 ) );
    }
    else
    {
        ::EnableWindow( hWndCtl, FALSE );
    }

    return 0;
}

LRESULT CPostProcessAdd::LBSelChanged( WORD /*wNotifyCode*/, WORD wID, HWND hWndCtl, BOOL& /*bHandled*/ )
{
    // If selection is not changed - do nothing
    if ( ListBox_GetCurSel( hWndCtl ) == LB_ERR ) return 0;

    if ( wID == IDC_FILES )
    {
        ::EnableWindow( GetDlgItem( IDC_DELFILE ), TRUE );
    }
    else if ( wID == IDC_COMMANDS )
    {
        ::EnableWindow( GetDlgItem( IDC_DELCMD ), TRUE );
        ::EnableWindow( GetDlgItem( IDC_EDITCMD ), TRUE );

        int iLastEl = ListBox_GetCount( hWndCtl ) - 1;
        int iCurSel = ListBox_GetCurSel( hWndCtl );
        _ASSERT( iCurSel != LB_ERR );

        // Enable / Disable the MoveUp and MoveDown Btns
        ::EnableWindow( GetDlgItem( IDC_MOVEUP ), iCurSel > 0 );
        ::EnableWindow( GetDlgItem( IDC_MOVEDOWN ), iCurSel < iLastEl );
    }

    return 0;
}



LRESULT CPostProcessAdd::OnAddCmd( WORD wNotifyCode, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& bHandled )
{
    CCommandDlg dlg;

    if ( dlg.DoModal() != IDOK ) return 0;

    CmdInfo Cmd;
    Cmd.bIgnoreErrors   = dlg.m_bIgnoreErrors;
    Cmd.dwTimeout       = dlg.m_dwTimeout;
    Cmd.strText         = dlg.m_strText;

    m_Commands.push_back( Cmd );

    UIUtils::TrimTextToCtrl(    GetDlgItem( IDC_COMMANDS ), 
                                dlg.m_strText.GetBuffer( dlg.m_strText.GetLength() ), 
                                ::GetSystemMetrics( SM_CXVSCROLL ) );
    dlg.m_strText.ReleaseBuffer();

    BOOL bUnused = FALSE;;

    ListBox_InsertString( GetDlgItem( IDC_COMMANDS ), -1, dlg.m_strText );
    LBSelChanged( LBN_SELCHANGE, IDC_COMMANDS, GetDlgItem( IDC_COMMANDS ), bUnused );

    return 0;
}


LRESULT CPostProcessAdd::OnDelCmd( WORD wNotifyCode, WORD /*wID*/, HWND hWndCtl, BOOL& bHandled )
{
    HWND hwndCmds = GetDlgItem( IDC_COMMANDS );

    int nCurSel = ListBox_GetCurSel( hwndCmds );
    _ASSERT( nCurSel != LB_ERR );

    ListBox_DeleteString( hwndCmds, nCurSel );
    m_Commands.erase( m_Commands.begin() + nCurSel );

    if ( ListBox_GetCount( hwndCmds ) > 0 )
    {
        BOOL bUnused = FALSE;

        ListBox_SetCurSel( hwndCmds, max( nCurSel - 1, 0 ) );
        LBSelChanged( LBN_SELCHANGE, IDC_COMMANDS, GetDlgItem( IDC_COMMANDS ), bUnused );
    }
    else
    {
        ::EnableWindow( hWndCtl, FALSE );
        ::EnableWindow( GetDlgItem( IDC_EDITCMD ), FALSE );
    }

    return 0;
}



LRESULT CPostProcessAdd::OnEditCmd( WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/ )
{
    HWND hwndCmds = GetDlgItem( IDC_COMMANDS );

    int iCmd = ListBox_GetCurSel( hwndCmds );
    if ( LB_ERR == iCmd ) return 0;

    CCommandDlg dlg;

    dlg.m_bIgnoreErrors = m_Commands[ iCmd ].bIgnoreErrors;
    dlg.m_dwTimeout     = m_Commands[ iCmd ].dwTimeout;
    dlg.m_strText       = m_Commands[ iCmd ].strText;

    if ( dlg.DoModal() != IDOK ) return 0;

    m_Commands[ iCmd ].bIgnoreErrors    = dlg.m_bIgnoreErrors;
    m_Commands[ iCmd ].dwTimeout        = dlg.m_dwTimeout;
    m_Commands[ iCmd ].strText          = dlg.m_strText;

    UIUtils::TrimTextToCtrl(    hwndCmds, 
                                dlg.m_strText.GetBuffer( dlg.m_strText.GetLength() ), 
                                ::GetSystemMetrics( SM_CXVSCROLL ) );
    dlg.m_strText.ReleaseBuffer();

    ListBox_InsertString( hwndCmds, iCmd, dlg.m_strText );
    ListBox_DeleteString( hwndCmds, iCmd + 1 );
    ListBox_SetCurSel( hwndCmds, iCmd );

    return 0;
}



LRESULT CPostProcessAdd::LBDoubleClick( WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/ )
{
    if ( wID != IDC_COMMANDS ) return 0;

    BOOL bUnused = FALSE;
    OnEditCmd( BN_CLICKED, IDC_EDITCMD, GetDlgItem( IDC_EDITCMD ), bUnused );

    return 0;
}



LRESULT CPostProcessAdd::OnMoveUp( WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/ )
{
    HWND hwndCmds = GetDlgItem( IDC_COMMANDS );

    int iSel = ListBox_GetCurSel( hwndCmds );
    _ASSERT( ( iSel != LB_ERR ) && ( iSel > 0 ) );
    LBSwapElements( hwndCmds, iSel, iSel - 1 );
    ListBox_SetCurSel( hwndCmds, iSel - 1 );

    BOOL bUnused = FALSE;
    LBSelChanged( LBN_SELCHANGE, IDC_COMMANDS, GetDlgItem( IDC_COMMANDS ), bUnused );

    CmdInfo cmdTemp = m_Commands[ iSel ];
    m_Commands[ iSel ] = m_Commands[ iSel - 1 ];
    m_Commands[ iSel - 1 ] = cmdTemp;

    return 0;
}



LRESULT CPostProcessAdd::OnMoveDown( WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/ )
{
    HWND hwndCmds = GetDlgItem( IDC_COMMANDS );

    int iSel = ListBox_GetCurSel( hwndCmds );
    _ASSERT( ( iSel != LB_ERR ) && ( iSel < ( ListBox_GetCount( hwndCmds ) - 1 ) ) );
    LBSwapElements( hwndCmds, iSel, iSel + 1 );
    ListBox_SetCurSel( hwndCmds, iSel + 1 );

    BOOL bUnused = FALSE;
    LBSelChanged( LBN_SELCHANGE, IDC_COMMANDS, GetDlgItem( IDC_COMMANDS ), bUnused );

    CmdInfo cmdTemp = m_Commands[ iSel ];
    m_Commands[ iSel ] = m_Commands[ iSel + 1 ];
    m_Commands[ iSel + 1 ] = cmdTemp;

    return 0;
}



void CPostProcessAdd::LBSwapElements( HWND hwndLB, int iSrc, int iTarget )
{
    _ASSERT( hwndLB != NULL );
    _ASSERT( iSrc != iTarget );
    
    CString strSrc;
    CString strTarget;

    ListBox_GetText( hwndLB, iSrc, strSrc.GetBuffer( ListBox_GetTextLen( hwndLB, iSrc ) + 1 ) );
    ListBox_GetText( hwndLB, iTarget, strTarget.GetBuffer( ListBox_GetTextLen( hwndLB, iTarget ) + 1 ) );
    strSrc.ReleaseBuffer();
    strTarget.ReleaseBuffer();

    ListBox_InsertString( hwndLB, iTarget, strSrc );
    ListBox_DeleteString( hwndLB, iTarget + 1 );

    ListBox_InsertString( hwndLB, iSrc, strTarget );
    ListBox_DeleteString( hwndLB, iSrc + 1 );
}



int CPostProcessAdd::OnWizardNext()
{
    int nRet    = 0;    // Goto next page
    int nMsgRes = 0;

    // Check if there are files, but no commands
    if ( m_Commands.empty() && !m_Files.empty() )
    {
        nMsgRes = UIUtils::MessageBox( m_hWnd, IDS_W_NOCMDS, IDS_APPTITLE, MB_YESNO | MB_ICONWARNING );

        // User wants to continue and ignore the files
        if ( IDYES == nMsgRes )
        {
            m_Files.clear();
            ListBox_ResetContent( GetDlgItem( IDC_FILES ) );
        }
        else
        {
            nRet = -1;  // Stay on this page
        }
    }

    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by UI.rc
//
#define IDR_MAINFRAME                   128
#define IDS_APPTITLE                    129
#define IDS_TITLE_IMPORTOREXPORT        130
#define IDS_SUBTITLE_IMPORTOREXPORT     131
#define IDS_TITLE_SELECTSITE            132
#define IDS_SUBTITLE_SELECTSITE         133
#define IDS_TITLE_PKG                   134
#define IDS_SUBTITLE_PKG                135
#define IDS_TITLE_POSTPROCESS           136
#define IDS_SUBTITLE_POSTPROCESS        137
#define IDS_FILTER_PACKAGE              138
#define IDS_FILTER_POSTPROCESSFILES     139
#define IDS_E_PPFILENOTUNIQUE           140
#define IDS_E_NOTNUMERIC                141
#define IDS_TITLE_EXPORT_SUMMARY        142
#define IDS_SUBTITLE_EXPORT_SUMMARY     143
#define IDS_WAIT_LOADSITES              144
#define IDS_TV_PKG_ROOT                 145
#define IDS_TV_SITEID                   146
#define IDS_TV_PKGFILE                  147
#define IDS_TV_ENCRYPT                  148
#define IDS_TV_COMPRESS                 149
#define IDS_TV_EXPORTCONTENT            150
#define IDS_MSG_CANCELEXPORT            151
#define IDS_TV_EXPORTCERTIFICATE        152
#define IDS_YES                         153
#define IDS_NO                          154
#define IDS_TV_EXPORTACLS               155
#define IDS_PRG_EXPORTCANCELED          156
#define IDC_OPS_INITENGINE              157
#define IDS_OPS_CONFIGENGINE            158
#define IDS_W_NOCMDS                    159
#define IDS_PRG_SITEBEGIN               160
#define IDS_PRG_EXPORTCFG               161
#define IDS_PRG_EXPORTCERT              162
#define IDS_PRG_VDIR_SCAN               163
#define IDS_PRG_ANALYZECONTEN           164
#define IDS_PRG_EXPORTCONTENT           165
#define IDS_PRG_STATCONTENT             166
#define IDS_PRG_EXPORTPOSTPROCESS       167
#define IDS_TITLE_LOADPKG               168
#define IDS_SUBTITLE_LOADPKG            169
#define IDC_PKGFILE_NOTFOUND            170
#define IDS_TITLE_IMPOPT                171
#define IDS_SUBTITLE_IMPOPT             172
#define IDS_TITLE_PKGINFO               173
#define IDS_SUBTITLE_PKGINFO            174
#define IDS_PKGINFO_PKGNAME             175
#define IDS_PKGINFO_PKGDATE             176
#define IDS_PKGINFO_MACHINE             177
#define IDS_PKGINFO_OS                  178
#define IDS_PKGINFO_ERROR               179
#define IDS_PKGINFO_COMMENT             180
#define IDS_MSG_WEBROOT                 181
#define IDS_IMPOPT_INHERITED            182
#define IDS_IMPOPT_CONTENT              183
#define IDS_IMPOPT_CERT                 184
#define IDS_IMPOPT_REUSECERTS           185
#define IDS_IMPOPT_DOPOSTPROCESS        186
#define IDS_IMPOPT_APPLYACLS            187
#define IDS_IMPOPT_PURGEOLDDATA         188
#define IDS_TITLE_IMPORT_PROGRESS       189
#define IDS_SUBTITLE_IMPORT_PROGRESS    190
#define IDS_MSG_CANCELIMPORT            191
#define IDS_E_IMPORT                    192
#define IDS_E_LOAD_PKG                  193
#define IDD_WP_WELCOME                  202
#define IDB_WZ_SIDE                     203
#define IDB_BITMAP1                     205
#define IDB_WZ_HEADER                   205
#define IDD_WP_IMPORTOREXPORT           206
#define IDD_WPEXP_SELECTSITE            207
#define IDD_WPEXP_PKG                   208
#define IDD_WPEXP_POSTPROCESS           209
#define IDD_WP_SUMMARY                  210
#define IDD_WPEXP_SUMMARY               210
#define IDD_WP_                         211
#define IDD_WP_PROGRESS                 212
#define IDD_WPEXP_PROGRESS              212
#define IDD_POSTPROCESS_CMD             213
#define IDD_WAITDLG                     214
#define IDS_PRG_FINALIZING              215
#define IDD_WPEXP_FINISH                215
#define IDS_FINISHTITLE_EXP             216
#define IDD_WPIMP_LOADPKG               216
#define IDS_FINISHTITLE_IMP             217
#define IDD_WPIMP_PKGINFO               217
#define IDS_FINISH_MSG_EXP              218
#define IDD_WPIMP_OPTIONS               218
#define IDS_FINISH_MSG2_EXP             219
#define IDD_WPIMP_PROGRESS              219
#define IDS_TIP_PRESSNEXT               220
#define IDD_WPIMP_FINISH                220
#define IDS_W_CUSTOMPATH_NOTEMPTY       221
#define IDS_PRG_IMPORTCANCELED          222
#define IDS_PRG_IMPORTINGVDIR           223
#define IDS_PRG_EXTRACTING_FILE         224
#define IDS_PRG_IMPORT_CERT             225
#define IDS_PRG_IMPORT_CONFIG           226
#define IDS_PRG_IMPORT_POSTPROCESS      227
#define IDS_PRG_EXEC_PP_CMD             228
#define IDS_PRG_EXEC_PP_FILE            229
#define IDS_E_NOTADMIN                  500
#define IDS_E_NOIIS                     501
#define IDS_E_WRONGPKGNAME              502
#define IDS_E_PWDS_DIFFER               503
#define IDS_E_PASSWORD_EMPTY            504
#define IDS_TITLE_EXPORT_PROGRESS       505
#define IDS_SUBTITLE_EXPORT_PROGRESS    506
#define IDS_E_EXPORT                    507
#define IDS_E_NOENGINE                  508
#define IDS_E_CUSTOMPATH_INVALID        509
#define IDC_EXPORT                      1000
#define IDC_IMPORT                      1001
#define IDC_SITELIST                    1002
#define IDC_CONTENT                     1003
#define IDC_ACLS                        1004
#define IDC_PKGNAME                     1004
#define IDC_CERTIFICATE                 1005
#define IDC_BROWSE                      1006
#define IDC_COMMENT                     1007
#define IDC_PWD                         1008
#define IDC_CONFIRM                     1009
#define IDC_COMPRESS                    1010
#define IDC_ENCRYPT                     1011
#define IDC_FILES                       1011
#define IDC_ADDPOSTPROCESS              1012
#define IDC_COMMANDS                    1012
#define IDC_MOVEUP                      1013
#define IDC_MOVEDOWN                    1014
#define IDC_ADDFILE                     1015
#define IDC_DELFILE                     1016
#define IDC_ADDCMD                      1017
#define IDC_DELCMD                      1018
#define IDC_EDITCMD                     1019
#define IDC_SUMMARY                     1019
#define IDC_OPLIST                      1020
#define IDC_STATUS                      1021
#define IDC_PROGRESS                    1022
#define IDC_TITLE                       1023
#define IDC_TIP                         1024
#define IDC_ERRORICON                   1025
#define IDC_ERROR                       1026
#define IDC_CMDTEXT                     1027
#define IDC_TIMEOUT                     1028
#define IDC_IGNOREERRORS                1029
#define IDC_TEXT                        1030
#define IDC_MSG                         1031
#define IDC_INFO                        1034
#define IDC_OPTIONS                     1035
#define IDC_CUSTOMPATH                  1036
#define IDC_PATH                        1037
#define IDC_PATHLABEL                   1039
#define IDI_WARNINGSIGN                 32515

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        223
#define _APS_NEXT_COMMAND_VALUE         32772
#define _APS_NEXT_CONTROL_VALUE         1041
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\selectsite.h ===
#pragma once

class CSelectSite : public CPropertyPageImpl<CSelectSite>
{
    typedef CPropertyPageImpl<CSelectSite>	BaseClass;

public:
    enum{ IDD = IDD_WPEXP_SELECTSITE };

    BEGIN_MSG_MAP(CSelectSite)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        COMMAND_CODE_HANDLER( LBN_SELCHANGE, OnSelChange )
        COMMAND_CODE_HANDLER( BN_CLICKED, OnAclChange )
		CHAIN_MSG_MAP(BaseClass)
	END_MSG_MAP()

    CSelectSite             (   CWizardSheet* pTheSheet );
    
    BOOL    OnSetActive     (   void );
    void    AddSite         (   const IMSAdminBasePtr& spABO, LPCWSTR wszPath, LPCWSTR wszSiteID );
    void    LoadWebSites    (   void );
    LRESULT OnInitDialog    (   UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnSelChange     (   WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnAclChange     (   WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    int     OnWizardNext    (   void );


// Shared data
public:
    DWORD           m_dwSiteID;
    CString         m_strSiteName;
    bool            m_bExportContent;
    bool            m_bExportCert;
    bool            m_bExportACLs;
    
// Data members
private:
    CWizardSheet*   m_pTheSheet;
    CString         m_strTitle;
    CString         m_strSubTitle;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	UI.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#if (_ATL_VER < 0x0700)
#include <atlimpl.cpp>
#endif //(_ATL_VER < 0x0700)

#include <IISMigrTool_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\selectsite.cpp ===
#include "stdafx.h"

#include "WizardSheet.h"
#include "WaitDlg.h"


CSelectSite::CSelectSite( CWizardSheet* pTheSheet ) :
    m_pTheSheet( pTheSheet )
{
    m_strTitle.LoadString( IDS_TITLE_SELECTSITE );
    m_strSubTitle.LoadString( IDS_SUBTITLE_SELECTSITE );

    SetHeaderTitle( m_strTitle );
    SetHeaderSubTitle( m_strSubTitle );
}



BOOL CSelectSite::OnSetActive()
{
    bool bHaveSel = ListBox_GetCurSel( GetDlgItem( IDC_SITELIST ) ) != LB_ERR;

    SetWizardButtons( PSWIZB_BACK | ( bHaveSel ? PSWIZB_NEXT : 0 ) );
    
    return TRUE;
}



void CSelectSite::AddSite( const IMSAdminBasePtr& spABO, LPCWSTR wszPath, LPCWSTR wszSiteID )
{
    WCHAR           wszBuffer[ METADATA_MAX_NAME_LEN ];
    METADATA_HANDLE hWeb        = NULL;        
    METADATA_RECORD md          = { 0 };
    DWORD           dwNotUsed   = 0;

    md.dwMDIdentifier   = MD_KEY_TYPE;
    md.dwMDDataType     = STRING_METADATA;
    md.dwMDUserType     = ALL_METADATA;
    md.dwMDDataLen      = METADATA_MAX_NAME_LEN * sizeof( WCHAR );
    md.pbMDData         = reinterpret_cast<BYTE*>( wszBuffer );        

    HRESULT hr = spABO->OpenKey(    METADATA_MASTER_ROOT_HANDLE,
                                    wszPath,
                                    METADATA_PERMISSION_READ,
                                    3000,
                                    &hWeb );

    if ( SUCCEEDED( hr ) )
    {
        hr = spABO->GetData( hWeb, NULL, &md, &dwNotUsed );
    }

    if ( SUCCEEDED( hr ) )
    {
        hr = ::_wcsicmp( wszBuffer, L"IISWebServer" ) == 0 ? S_OK : E_FAIL;
    }

    if ( SUCCEEDED( hr ) )
    {
        md.dwMDIdentifier   = MD_SERVER_COMMENT;
        md.dwMDDataLen      = METADATA_MAX_NAME_LEN * sizeof( WCHAR );

        hr = spABO->GetData( hWeb, NULL, &md, &dwNotUsed );
    }

    if ( SUCCEEDED( hr ) )
    {
        int iItem = ListBox_AddString( GetDlgItem( IDC_SITELIST ), wszBuffer );

        if ( iItem != LB_ERR )
        {
            DWORD dwSiteID = 0;

            VERIFY( ::swscanf( wszSiteID, L"%u", &dwSiteID ) );

            ListBox_SetItemData( GetDlgItem( IDC_SITELIST ), iItem, dwSiteID );
        }
    }
}



void CSelectSite::LoadWebSites()
{
    IMSAdminBasePtr     spABO;
    WCHAR               wszBuffer[ METADATA_MAX_NAME_LEN ];
    WCHAR               wszWebPath[ 2 * METADATA_MAX_NAME_LEN ];

    HRESULT hr = spABO.CreateInstance( CLSID_MSAdminBase );

    if ( SUCCEEDED( hr ) )
    {
        for ( int i = 0; SUCCEEDED( hr ); ++i )
        {
            hr = spABO->EnumKeys( METADATA_MASTER_ROOT_HANDLE, L"LM/W3SVC", wszBuffer, i );

            if ( SUCCEEDED( hr ) )
            {
                ::swprintf( wszWebPath, L"LM/W3SVC/%s", wszBuffer );

                AddSite( spABO, wszWebPath, wszBuffer );
            }
        }
    }
}



LRESULT CSelectSite::OnInitDialog( UINT, WPARAM, LPARAM, BOOL& )
{
    CWaitDlg dlg( m_hWnd, IDS_WAIT_LOADSITES );
    
	LoadWebSites();
        
	return 0;
}



LRESULT CSelectSite::OnSelChange( WORD /*wNotifyCode*/, WORD /*wID*/, HWND hWndCtl, BOOL& /*bHandled*/ )
{
    if ( ListBox_GetCurSel( hWndCtl ) != LB_ERR )
    {
        SetWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );

        ::EnableWindow( GetDlgItem( IDC_ACLS ), TRUE );
        ::EnableWindow( GetDlgItem( IDC_CONTENT ), TRUE );
        ::EnableWindow( GetDlgItem( IDC_CERTIFICATE ), TRUE );
    }

    return 0;
}



int CSelectSite::OnWizardNext()
{
    CListBox LB( GetDlgItem( IDC_SITELIST ) );

    LB.GetText( LB.GetCurSel(), /*r*/m_strSiteName );
    
    m_dwSiteID = LB.GetItemData( LB.GetCurSel() );

    m_bExportContent    = Button_GetCheck( GetDlgItem( IDC_CONTENT ) ) != FALSE;
    m_bExportCert       = Button_GetCheck( GetDlgItem( IDC_CERTIFICATE ) ) != FALSE;
    m_bExportACLs       = Button_GetCheck( GetDlgItem( IDC_ACLS ) ) != FALSE;

    return 0;
}




LRESULT CSelectSite::OnAclChange( WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/ )
{
    if ( IDC_CONTENT == wID )
    {
        if ( !Button_GetCheck( GetDlgItem( IDC_CONTENT ) ) )
        {
            Button_SetCheck( GetDlgItem( IDC_ACLS ), FALSE );
        }
    }
    else if ( IDC_ACLS == wID )
    {
        if ( Button_GetCheck( GetDlgItem( IDC_ACLS ) ) )
        {
            Button_SetCheck( GetDlgItem( IDC_CONTENT ), TRUE );
        }        
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#pragma once

#ifndef UNICODE
#define _UNICODE
#define UNICODE
#endif



#ifndef _WIN32_WINNT
#define _WIN32_WINNT	0x0400
#endif

#ifndef _WIN32_IE
#define _WIN32_IE	    0x0500
#endif

#include <windows.h>
#include <shellapi.h>
#include <process.h>

#include <atlbase.h>
#include <atlapp.h>

extern CAppModule _Module;

#pragma warning( push, 3 )
#include <atlcom.h>
#pragma warning( pop )

#include <atlwin.h>
#include <atlmisc.h>
#include <atlframe.h>
#include <atlctrls.h>
#include <atldlgs.h>
#include <atlctrlx.h>
#include <windowsx.h>
#include <comdef.h>
#include <initguid.h>
#include <iadmw.h>      // ABO definition
#include <iiscnfg.h>    // MD_ & IIS_MD_ defines


// STL
#pragma warning( push, 3 )
#include <list>
#include <memory>
#include <string>
#include <map>
#include <queue>
#include <algorithm>
#pragma warning( pop )

#pragma comment( lib, "comctl32.lib" )
#pragma comment( lib, "Shlwapi.lib" )


typedef std::list<std::wstring>	TStringList;
typedef std::auto_ptr<BYTE>	        TByteAutoPtr;


// IIS Migr tool shared
#include <iismigrtool.h>    // IIS Migr Tool COM object
#include <Macros.h>
#include <Wrappers.h>
#include <Exceptions.h>



_COM_SMARTPTR_TYPEDEF( IMSAdminBase, __uuidof( IMSAdminBase ) );
_COM_SMARTPTR_TYPEDEF( IExportPackage, __uuidof( IExportPackage ) );
_COM_SMARTPTR_TYPEDEF( IImportPackage, __uuidof( IImportPackage ) );
_COM_SMARTPTR_TYPEDEF( ISiteInfo, __uuidof( ISiteInfo ) );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\ui.h ===
// UI.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\uiutils.h ===
#pragma once

class UIUtils
{
public:
    static int  MessageBox              (   HWND hwndParent, UINT nTextID, UINT nTitleID, UINT nTyoe );
    static bool LoadOFNFilterFromRes    (   UINT nResID, CString& rstrFilter );
    static void PathCompatCtrlWidth     (   HWND hwndCtrl, LPWSTR wszPath, int nCorrection = 0 );
    static void TrimTextToCtrl          (   HWND hwndCtrl, LPWSTR wszText, int nCorrection = 0 );                
    static void ShowCOMError            (   HWND hwndParent, UINT nTextID, UINT nTitleID, HRESULT hr );


private:
    UIUtils(void);
    ~UIUtils(void);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\waitdlg.h ===
#pragma once


class CWaitDlg : public CDialogImpl<CWaitDlg>
{
public:

    enum { IDD = IDD_WAITDLG };


    BEGIN_MSG_MAP(CMyDialog)
        MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog )
    END_MSG_MAP()

    CWaitDlg( HWND hParent, UINT nResID ) : 
        m_nTextResID( nResID )
    {
        Create( hParent );
        ShowWindow( SW_SHOW );
        UpdateWindow();
    }

    ~CWaitDlg()
    {
        if ( m_hWnd != NULL )
        {
            VERIFY( DestroyWindow() );
        }
    }

    LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/ )
    {
        CString strText;
        VERIFY( strText.LoadString( m_nTextResID ) );

        VERIFY( SetDlgItemText( IDC_TEXT, strText ) );

        return 1;
    }

private:
    CWaitCursor wc;
    UINT        m_nTextResID;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\uiutils.cpp ===
#include "StdAfx.h"
#include "uiutils.h"

// UIUtils implementation
/////////////////////////////////////////////////////////////////////////////////////////


/* 
    Displays a message box just like the default one but get's the text from the resources
*/
int UIUtils::MessageBox( HWND hwndParen, UINT nTextID, UINT nTitleID, UINT nType )
{
    CString strText;
    CString strTitle;

    VERIFY( strText.LoadString( nTextID ) );
    VERIFY( strTitle.LoadString( nTitleID ) );

    return ::MessageBox( hwndParen, strText, strTitle, nType );
}



/* 
    Loads filter string for GetOpen[Save]FileName API from the resources
    The string in the resources contains '|' instead of zero chars. This function will
    replace the '|' chars with zero
*/
bool UIUtils::LoadOFNFilterFromRes( UINT nResID, CString& rstrFilter )
{
    _ASSERT( nResID != 0 );

    if ( rstrFilter.LoadString( nResID ) )
    {
        int nLength = rstrFilter.GetLength();

        LPWSTR wszBuffer = rstrFilter.GetBuffer( nLength );
        
        while( *wszBuffer != L'\0' )
        {
            if ( *wszBuffer == L'|' )
            {
                *wszBuffer = L'\0';
            }

            ++wszBuffer;
        }

        rstrFilter.ReleaseBuffer( nLength );
        return true;
    }
    
    return false;
}



/* 
    Compacts a path to fit a control's width. Cimilar to PathSetDlgItemPath but can be used with list boxes
    as well. Use nCorrection to change the default width ( for example pass the width of the vert scrollbar )
*/
void UIUtils::PathCompatCtrlWidth( HWND hwndCtrl, LPWSTR wszPath, int nCorrection /*=0*/ )
{
    _ASSERT( hwndCtrl != NULL );
    _ASSERT( wszPath != NULL );

    HDC     hDC     = ::GetDC( hwndCtrl );
    RECT    rect    = { 0 };
    HFONT   fontOld = NULL;
    
    ::GetClientRect( hwndCtrl, &rect );

    // We must select the control font in the DC for the API to properly calc the text width
    fontOld = SelectFont( hDC, GetWindowFont( hwndCtrl ) );

    // Substract some pixels, as the API formats the text slightly wider then it should be
    VERIFY( ::PathCompactPathW( hDC, wszPath, rect.right - rect.left - 6 - nCorrection ) );

    SelectFont( hDC, fontOld );
    ::ReleaseDC( hwndCtrl, hDC );    
}


/* 
    Similar to the PathCompactCtrlWidth, but for general strings
    The string is truncated to fit the control width and "..." as added to the end of it
    Use nCorrection to correct the control width for which the calculations will be made
*/
void UIUtils::TrimTextToCtrl( HWND hwndCtrl, LPWSTR wszText, int nCorrection /*= 0*/ )
{
    _ASSERT( hwndCtrl != NULL );
    _ASSERT( wszText != NULL );

    HDC     hDC         = ::GetDC( hwndCtrl );
    RECT    rect        = { 0 };
    HFONT   fontOld     = NULL;
    SIZE    sizeText    = { 0 };
        
    ::GetClientRect( hwndCtrl, &rect );

    int    nWidth  = ( rect.right - rect.left ) - nCorrection;
    int    nStrLen = ::wcslen( wszText );

    fontOld = SelectFont( hDC, GetWindowFont( hwndCtrl ) );

    VERIFY( ::GetTextExtentPoint32( hDC, wszText, nStrLen, &sizeText ) );

    if ( sizeText.cx > nWidth )
    {
        // Calc the average width of a symbol and terminate the string
        int nPixPerSymb = sizeText.cx / nStrLen;
        
        nStrLen = min( nStrLen, ( nWidth ) / nPixPerSymb );
        wszText[ nStrLen - 1 ] = L'\0';
        ::wcscat( wszText, L"..." );
        nStrLen += 3;
        

        // Adjust the string removing one symbol at a time
        do
        {
            // Make the string one symbol shorter
            // Make the last non '.' symbol a '.' symbol and make the whole string one char less long
            wszText[ nStrLen - 4 ] = L'.';
            wszText[ nStrLen - 1 ] = L'\0';
            --nStrLen;

            VERIFY( ::GetTextExtentPoint32( hDC, wszText, nStrLen, &sizeText ) );

        }while( sizeText.cx > nWidth );
    }

    SelectFont( hDC, fontOld );
    ::ReleaseDC( hwndCtrl, hDC );    
}



void UIUtils::ShowCOMError( HWND hwndParent, UINT nTextID, UINT nTitleID, HRESULT hr )
{
    _ASSERT( FAILED( hr ) );

    CString strText;
    CString strTitle;

    VERIFY( strTitle.LoadString( nTitleID ) );

    // Try to get the string from the system
    if ( E_FAIL != E_FAIL )
    {
        const int MaxErrorBuff = 512;

        WCHAR	wszText[ MaxErrorBuff ] = L"";

		VERIFY( ::FormatMessageW(	FORMAT_MESSAGE_FROM_SYSTEM,
									NULL,
									hr,
									0,
									wszText,
									MaxErrorBuff,
									NULL ) != 0 );

        strText.Format( nTextID, wszText );
    }
    else
    {
        IErrorInfoPtr	spErrorInfo;
		CComBSTR		bstrError;

		VERIFY( SUCCEEDED( ::GetErrorInfo( 0, &spErrorInfo ) ) );
		VERIFY( SUCCEEDED( spErrorInfo->GetDescription( &bstrError ) ) );

        strText.Format( nTextID, bstrError.m_str );
    }

    ::MessageBox( hwndParent, strText, strTitle, MB_OK | MB_ICONWARNING );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\ui.cpp ===
// UI.cpp : main source file for UI.exe
//

#include "stdafx.h"
#include "WizardSheet.h"


CAppModule _Module;

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE /*hPrevInstance*/, LPSTR /*wszCmdLine*/, int /*nCmdShow*/ )
{
	HRESULT hRes = ::CoInitialize(NULL);
	ATLASSERT(SUCCEEDED(hRes));

	hRes = _Module.Init(NULL, hInstance);
	ATLASSERT(SUCCEEDED(hRes));

	// This is the shared data
    
    CWizardSheet Sheet;

    Sheet.DoModal();

	_Module.Term();
	::CoUninitialize();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\welcomepage.h ===
#pragma once

class CWelcomePage : public CPropertyPageImpl<CWelcomePage>
{
    typedef CPropertyPageImpl<CWelcomePage>	BaseClass;

public:

	enum{ IDD = IDD_WP_WELCOME };

	BEGIN_MSG_MAP(CWelcomePage)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		CHAIN_MSG_MAP(BaseClass)
	END_MSG_MAP()


    CWelcomePage( CWizardSheet* pTheSheet ) :
        m_pTheSheet( pTheSheet ),
        BaseClass( IDS_APPTITLE )
    {
        m_psp.dwFlags |= PSP_HIDEHEADER;
    }

	LRESULT OnInitDialog( UINT, WPARAM, LPARAM, BOOL& );	
    BOOL OnSetActive();


private:
    bool CanRun();
    bool IsAdmin();
    bool IsIISRunning();
    
private:
	CWizardSheet*   m_pTheSheet;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\welcomepage.cpp ===
#include "stdafx.h"

#include "WizardSheet.h"

LRESULT CWelcomePage::OnInitDialog( UINT, WPARAM, LPARAM, BOOL& )
{
	// Set the fonts
	SetWindowFont( GetDlgItem( IDC_TITLE ), m_pTheSheet->m_fontTitles.get(), FALSE );
	SetWindowFont( GetDlgItem( IDC_TIP ), m_pTheSheet->m_fontBold.get(), FALSE );

    // Center the property sheet on the screen
    CWindow wnd( m_pTheSheet->m_hWnd );
    wnd.CenterWindow();
    
    return 0;
}



BOOL CWelcomePage::OnSetActive()
{
    if ( CanRun() )
    {
        SetWizardButtons( PSWIZB_NEXT );
    }
    else
    {
        ::ShowWindow( GetDlgItem( IDC_ERRORICON ), SW_SHOW );
        ::ShowWindow( GetDlgItem( IDC_ERROR ), SW_SHOW );
        ::ShowWindow( GetDlgItem( IDC_TIP ), SW_HIDE );
        
        SetWizardButtons( 0 );
    }
    
    return TRUE;
}



bool CWelcomePage::CanRun()
{
    UINT nResID = 0;

    if ( !IsAdmin() )
    {
        nResID = IDS_E_NOTADMIN;
    }
    else if ( !IsIISRunning() )
    {
        nResID = IDS_E_NOIIS;
    }

    if ( nResID != 0 )
    {
        CString strText;
        strText.LoadString( nResID );

        ::SetWindowText( GetDlgItem( IDC_ERROR ), strText );
    }

    return ( nResID == 0 );
}



bool CWelcomePage::IsAdmin()
{
	BOOL						bIsAdmin		= FALSE;
	SID_IDENTIFIER_AUTHORITY	NtAuthority = SECURITY_NT_AUTHORITY;
	PSID						AdminSid	= { 0 };	

	if ( ::AllocateAndInitializeSid(	&NtAuthority,
										2,	// Number of subauthorities
										SECURITY_BUILTIN_DOMAIN_RID,
										DOMAIN_ALIAS_RID_ADMINS,
										0, 
										0, 
										0, 
										0, 
										0, 
										0,
										&AdminSid ) ) 
	{
		if ( !::CheckTokenMembership( NULL, AdminSid, &bIsAdmin ) ) 
		{
			bIsAdmin = FALSE;
		}
    }

	::GlobalFree( AdminSid );
    
	return ( bIsAdmin != FALSE );
}



bool CWelcomePage::IsIISRunning()
{
	bool bResult = false;

	LPCWSTR	SERVICE_NAME = L"IISADMIN";

	// Open the SCM on the local machine
    SC_HANDLE   schSCManager = ::OpenSCManagerW( NULL, NULL, SC_MANAGER_ALL_ACCESS );
	_ASSERT( schSCManager != NULL );	// We alredy checked that we are Admins
        
    SC_HANDLE   schService = ::OpenServiceW( schSCManager, SERVICE_NAME, SERVICE_QUERY_STATUS );
    
	// The service is not installed
	if ( schService != NULL )
	{
        SERVICE_STATUS ssStatus;

		VERIFY( ::QueryServiceStatus( schService, &ssStatus ) );
    
		bResult = ( ssStatus.dwCurrentState == SERVICE_RUNNING );
    
		VERIFY( ::CloseServiceHandle( schService ) );
	}
    
	VERIFY( ::CloseServiceHandle( schSCManager ) );
    
	return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\migrtool\ui\wizardsheet.h ===
#pragma once

class CWizardSheet;

#include "resource.h"
#include "WelcomePage.h"
#include "ImportOrExport.h"
#include "SelectSite.h"
#include "PackageConfig.h"
#include "PostProcessAdd.h"
#include "ExportSummary.h"
#include "ExportProgress.h"
#include "ExportFinishPage.h"
#include "LoadPackage.h"
#include "PackageInfo.h"
#include "ImportOptions.h"
#include "ImportProgress.h"
#include "ImportFinishPage.h"


class CWizardSheet : public CPropertySheetImpl<CWizardSheet>
{
public:
    typedef THandle<HGDIOBJ, ::DeleteObject>	TGdiObjHandle;

    typedef HRESULT (__stdcall *PFN_AUTOCOMPLETE)( HWND, DWORD );

    CWizardSheet() : 
        m_pageWelcome( this ),
        m_pageImportOrExport( this ),
        m_pageSelectSite( this ),
        m_pagePkgCfg( this ),
        m_pagePostProcess( this ),
        m_pageExportSummary( this ),
        m_pageExportProgress( this ),
        m_pageExportFinish( this ),
        m_pageLoadPkg( this ),
        m_pagePkgInfo( this ),
        m_pageImpOpt( this ),
        m_pageImportProgress( this ),
        m_PageImportFinish( this )
    {
        // Create the font for the wizard title texts and for the text of tipd
	    NONCLIENTMETRICS ncm	= { 0 };
        ncm.cbSize				= sizeof( ncm );
        ::SystemParametersInfo( SPI_GETNONCLIENTMETRICS, 0, &ncm, 0 );


	    LOGFONTW TitleLogFont	= ncm.lfMessageFont;
        TitleLogFont.lfWeight	= FW_BOLD;
	    ::wcscpy( TitleLogFont.lfFaceName, L"Verdana" );

	    // Create the tips font
	    m_fontBold			= ::CreateFontIndirect( &TitleLogFont );

	    // Create the intro/end title font
        HDC hDC					= ::GetDC(NULL); // Gets the screen DC
	    TitleLogFont.lfHeight	= -::MulDiv( 12, ::GetDeviceCaps(hDC, LOGPIXELSY), 72);
	    m_fontTitles			= ::CreateFontIndirect( &TitleLogFont );

        ::ReleaseDC( NULL, hDC );
	    hDC = NULL;

        // Adjust the wizard style
        SetWatermark( MAKEINTRESOURCE( IDB_WZ_SIDE ) );
        SetHeader( MAKEINTRESOURCE( IDB_BITMAP1 ) );        

        // Add the pages
        AddPage( m_pageWelcome );
        AddPage( m_pageImportOrExport );
        AddPage( m_pageSelectSite );
        AddPage( m_pagePkgCfg );
        AddPage( m_pagePostProcess );
        AddPage( m_pageExportSummary );
        AddPage( m_pageExportProgress );
        AddPage( m_pageExportFinish );

        AddPage( m_pageLoadPkg );
        AddPage( m_pagePkgInfo );
        AddPage( m_pageImpOpt );
        AddPage( m_pageImportProgress );
        AddPage( m_PageImportFinish );


        // We will use the shell autocomplete for most of the file/path edit controls
        // Sicne this function requires IE5, we will load it dynamicaly
        m_shShellLib = ::LoadLibraryW( L"Shlwapi.dll" );
        if ( m_shShellLib.IsValid() )
        {
            m_pfnAutocomplete = reinterpret_cast<PFN_AUTOCOMPLETE>( ::GetProcAddress( m_shShellLib.get(), "SHAutoComplete" ) );

            if ( NULL == m_pfnAutocomplete )
            {
                m_shShellLib.Close();
            }
        }
    }



    void SetAutocomplete( HWND hwnd, DWORD dwFlags )
    {
        _ASSERT( hwnd != NULL );

        if ( m_pfnAutocomplete != NULL )
        {
            VERIFY( SUCCEEDED( m_pfnAutocomplete( hwnd, dwFlags ) ) );
        }
    }


public:
    TGdiObjHandle	    m_fontTitles;
	TGdiObjHandle	    m_fontBold;

    TLibHandle          m_shShellLib;
    PFN_AUTOCOMPLETE    m_pfnAutocomplete;      // The shell autocomplete API

    CWelcomePage        m_pageWelcome;    
    CImportOrExport     m_pageImportOrExport;
    CSelectSite         m_pageSelectSite;
    CPackageConfig      m_pagePkgCfg;
    CPostProcessAdd     m_pagePostProcess;
    CExportSummary      m_pageExportSummary;
    CExportProgress     m_pageExportProgress;
    CExportFinishPage   m_pageExportFinish;

    CLoadPackage        m_pageLoadPkg;
    CPackageInfo        m_pagePkgInfo;
    CImportOptions      m_pageImpOpt;
    CImportProgress     m_pageImportProgress;
    CImportFinishPage   m_PageImportFinish;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\movesite\auth.h ===
#ifndef __METAEXP_AUTH__
#define __METAEXP_AUTH__

#include <iadmw.h>  // COM Interface header file. 




// Validates that the user had privleges to open a metabase handle
BOOL AUTHUSER( COSERVERINFO * pCoServerInfo );

// Validate that the node is of a given KeyType
BOOL ValidateNode(COSERVERINFO * pCoServerInfo, WCHAR *pwszMBPath, WCHAR* KeyType );
BOOL ValidateNode(COSERVERINFO * pCoServerInfo, WCHAR *pwszMBPath, DWORD KeyType );

// Create CoServerInfoStruct
COSERVERINFO * CreateServerInfoStruct(WCHAR* pwszServer, WCHAR* pwszUser, WCHAR* pwszDomain,
									  WCHAR* pwszPassword, DWORD dwAuthnLevel, BOOL bUsesImpersonation = true);
VOID FreeServerInfoStruct(COSERVERINFO * pServerInfo);

BOOL UsesImpersonation(COSERVERINFO * pServerInfo); 




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\movesite\auth.cpp ===
#define _WIN32_DCOM

#include "util.h"
#include <atlbase.h>
#include <initguid.h>
#include <comdef.h>

#include <stdlib.h>
#include <stdio.h>
#include <wchar.h>

#include <iiscnfg.h>  // MD_ & IIS_MD_ #defines header file.

#include "common.h"  // log file routines
#include "auth.h"


COSERVERINFO * CreateServerInfoStruct(WCHAR* pwszServer, WCHAR* pwszUser, WCHAR* pwszDomain,
									  WCHAR* pwszPassword, DWORD dwAuthnLevel, BOOL bUsesImpersonation )
{
      
    COSERVERINFO * pcsiName = NULL;

       pcsiName = new COSERVERINFO;

        if (!pcsiName)
        {
			return NULL;
        }
		ZeroMemory(pcsiName, sizeof(COSERVERINFO));

	
    if( !bUsesImpersonation )
	{
		pcsiName->pwszName = pwszServer;
		return pcsiName;
	}
    
		
	// Build the COAUTHIDENTITY STRUCT	
	COAUTHIDENTITY * pAuthIdentityData = new COAUTHIDENTITY;

    if (!pAuthIdentityData)
    {
        return NULL;
    }
    ZeroMemory(pAuthIdentityData, sizeof(COAUTHIDENTITY));

	if( pwszUser )
	{
		pAuthIdentityData->User = new WCHAR[32];
		wcscpy(pAuthIdentityData->User, pwszUser);
		pAuthIdentityData->UserLength = wcslen(pwszUser);

		if( pwszPassword ) 
		{
			pAuthIdentityData->Password = new WCHAR[32];
			wcscpy(pAuthIdentityData->Password, pwszPassword);
			pAuthIdentityData->PasswordLength = wcslen(pwszPassword);
		}

		if( pwszDomain )
		{
			pAuthIdentityData->Domain = new WCHAR[32];
			wcscpy(pAuthIdentityData->Domain, pwszDomain);
			pAuthIdentityData->DomainLength = wcslen(pwszDomain);
		}
	}

	pAuthIdentityData->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
	
	COAUTHINFO * pAuthInfo = new COAUTHINFO;

    if (!pAuthInfo)
    {
        return NULL;
    }

    ZeroMemory(pAuthInfo, sizeof(COAUTHINFO));

	pAuthInfo->dwAuthnSvc = RPC_C_AUTHN_WINNT ;
	pAuthInfo->dwAuthzSvc = RPC_C_AUTHZ_NONE;
	pAuthInfo->dwAuthnLevel = dwAuthnLevel;
	pAuthInfo->dwImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
	pAuthInfo->pAuthIdentityData = pAuthIdentityData;


	pcsiName->pAuthInfo = pAuthInfo;
	pcsiName->pwszName = pwszServer;

	return pcsiName;

}


// Validate that the user passed into the program has the rights to 
// connnect to the IMSAdminBaseObject on both machines.

BOOL ValidateNode(COSERVERINFO * pCoServerInfo, WCHAR *pwszMBPath, WCHAR* KeyType )
{
  HRESULT hRes;
  METADATA_HANDLE hKey;   
  CComPtr <IMSAdminBase> pIMeta = 0L; 
  MULTI_QI rgmqi[1] = { &IID_IMSAdminBase,0,0 };
  BOOL bReturn = false;

  if( !pCoServerInfo )
		return false;


  if( SUCCEEDED(hRes = CoCreateInstanceEx(CLSID_MSAdminBase,NULL, 
	  CLSCTX_ALL, pCoServerInfo,1, rgmqi) ) )
	  pIMeta = reinterpret_cast<IMSAdminBase*>(rgmqi[0].pItf);
  else
  {
	  fwprintf( stderr, L"error creating IMSAdminbase on machine: %s. HRESULT=%x\n", 
			pCoServerInfo->pwszName, hRes);
	  return false;
  }

  if( UsesImpersonation(pCoServerInfo) )
  {
		if (!SUCCEEDED(hRes = SetBlanket(pIMeta,pCoServerInfo->pAuthInfo->pAuthIdentityData->User,
				pCoServerInfo->pAuthInfo->pAuthIdentityData->Domain,
				pCoServerInfo->pAuthInfo->pAuthIdentityData->Password) ) )
			{
				fwprintf( stderr, L"error setting CoSetProxyBlanket on machine: %s for user: %s  HRESULT=%x\n",
					pCoServerInfo->pwszName,pCoServerInfo->pAuthInfo->pAuthIdentityData->User, hRes);
				pIMeta = 0;
				return false;
			}
  }

// Try to open a handle to the metabase to verify that the user can connect to the
// web services key in the metabase

  if( !SUCCEEDED( hRes = pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE, L"/LM",
     METADATA_PERMISSION_READ , 10000, &hKey) ) )
  {
	  fwprintf( stderr, L"Error opening key: /LM on computer: %s. HRESULT=%x\n", 
			pCoServerInfo->pwszName, hRes);
	  pIMeta = 0;
	  return false;
  }

  bReturn = IsKeyType(pIMeta,hKey,pwszMBPath,KeyType);

  if( !SUCCEEDED(hRes = pIMeta->CloseKey(hKey) ) )
  {
	  fwprintf( stderr, L"Error closing key: /LM/W3SVC on computer: %s. HRESULT=%x\n", 
			pCoServerInfo->pwszName, hRes);
  }
  
  pIMeta = 0;
  return bReturn;

}

BOOL AUTHUSER(COSERVERINFO * pCoServerInfo)
{
  HRESULT hRes;
  METADATA_HANDLE hKey;   
  CComPtr <IMSAdminBase> pIMeta = 0L; 
  MULTI_QI rgmqi[1] = { &IID_IMSAdminBase,0,0 };


  if( !pCoServerInfo )
		return false;


  if( SUCCEEDED(hRes = CoCreateInstanceEx(CLSID_MSAdminBase,NULL, 
	  CLSCTX_ALL, pCoServerInfo,1, rgmqi) ) )
	  pIMeta = reinterpret_cast<IMSAdminBase*>(rgmqi[0].pItf);
  else
  {
	  fwprintf( stderr, L"error creating IMSAdminbase on machine: %s. HRESULT=%x\n", 
			pCoServerInfo->pwszName, hRes);
	  return false;
  }

  if( UsesImpersonation(pCoServerInfo) )
  {
		if (!SUCCEEDED(hRes = SetBlanket(pIMeta,pCoServerInfo->pAuthInfo->pAuthIdentityData->User,
				pCoServerInfo->pAuthInfo->pAuthIdentityData->Domain,
				pCoServerInfo->pAuthInfo->pAuthIdentityData->Password) ) )
			{
				fwprintf( stderr, L"error setting CoSetProxyBlanket on machine: %s for user: %s  HRESULT=%x\n",
					pCoServerInfo->pwszName,pCoServerInfo->pAuthInfo->pAuthIdentityData->User, hRes);
				pIMeta = 0;
				return false;
			}
  }

// Try to open a handle to the metabase to verify that the user can connect to the
// web services key in the metabase

  if( !SUCCEEDED( hRes = pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE, L"/LM/W3SVC",
     METADATA_PERMISSION_READ , 10000, &hKey) ) )
  {
	  fwprintf( stderr, L"Error opening key: /LM/W3SVC on computer: %s. HRESULT=%x\n", 
			pCoServerInfo->pwszName, hRes);
	  pIMeta = 0;
	  return false;
  }

  if( !SUCCEEDED(hRes = pIMeta->CloseKey(hKey) ) )
  {
	  fwprintf( stderr, L"Error closing key: /LM/W3SVC on computer: %s. HRESULT=%x\n", 
			pCoServerInfo->pwszName, hRes);
  }
  
  pIMeta = 0;
  return true;
}

VOID FreeServerInfoStruct(
     COSERVERINFO * pServerInfo
    ) 
/*++

Routine Description:

    As mentioned above -- free the server info structure

Arguments:

    COSERVERINFO * pServerInfo  : Server info structure

Return Value:

    None

--*/
{
    if (pServerInfo)
    {
        if (pServerInfo->pAuthInfo)
        {
            if (pServerInfo->pAuthInfo->pAuthIdentityData)
            {
                
                    delete pServerInfo->pAuthInfo->pAuthIdentityData->User;
                    delete pServerInfo->pAuthInfo->pAuthIdentityData->Domain;
                    delete pServerInfo->pAuthInfo->pAuthIdentityData->Password;
                    
                
				delete pServerInfo->pAuthInfo->pAuthIdentityData;
            }

            delete pServerInfo->pAuthInfo;
        }

        delete pServerInfo;
    }
}

BOOL UsesImpersonation(COSERVERINFO * pServerInfo)
{
	if( !pServerInfo )
		return false;

	if( pServerInfo->pAuthInfo )
	{
		if( pServerInfo->pAuthInfo->pAuthIdentityData )
			if(pServerInfo->pAuthInfo->pAuthIdentityData->User )
				return true;
	}

	return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\movesite\common.h ===
#pragma once

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#ifndef _WIN32_WINNT		// Allow use of features specific to Windows NT 4 or later.
#define _WIN32_WINNT 0x0510		// Change this to the appropriate value to target Windows 98 and Windows 2000 or later.
#endif						

#include <windows.h>
#include <tchar.h>
#include <stdio.h>

void MyOutputDebug(TCHAR *fmt, ...);
void ClearLog();
void Log( LPCTSTR fmt, ... );
void LogError( PTCHAR szAction, DWORD dwErrorCode );
bool GetUDDIInstallPath( PTCHAR szInstallPath, DWORD dwLen );

#define ENTER()	CFunctionMarker fa( __FUNCTION__ )

class CFunctionMarker
{
private:
	TCHAR m_szFunctionName[100];

public:
	CFunctionMarker( char *aszFunctionName )
	{
#ifdef _UNICODE
		int iCount = MultiByteToWideChar( 
			CP_ACP, 
			0, 
			aszFunctionName, 
			-1, 
			m_szFunctionName, 
			sizeof( m_szFunctionName ) / sizeof( TCHAR ) );
#else
		strncpy( m_szFunctionName, aszFunctionName, sizeof( m_szFunctionName ) );
#endif
		Log( TEXT( "Entering %s" ), m_szFunctionName );
	}

	~CFunctionMarker()
	{
		Log( TEXT( "Leaving %s" ), m_szFunctionName );
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\movesite\common.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif

#include <windows.h>
#include <tchar.h>

#include <assert.h>
#include <time.h>

#include "common.h"


//--------------------------------------------------------------------------

void MyOutputDebug(TCHAR *fmt, ...)
{
#if defined( DBG ) || defined( _DEBUG )
	TCHAR szTime[ 10 ];
	TCHAR szDate[ 10 ];
	::_tstrtime( szTime );
	::_tstrdate( szDate );

	va_list marker;
	TCHAR szBuf[1024];

	size_t cbSize = ( sizeof( szBuf ) / sizeof( TCHAR ) ) - 1; // one byte for null
	_sntprintf( szBuf, cbSize, TEXT( "%s %s: " ), szDate, szTime );
	szBuf[ 1023 ] = '\0';
	cbSize -= _tcslen( szBuf );

	va_start( marker, fmt );

	_vsntprintf( szBuf + _tcslen( szBuf ), cbSize, fmt, marker );
	szBuf[ 1023 ] = '\0';
	cbSize -= _tcslen( szBuf );

	va_end( marker );

	_tcsncat(szBuf, TEXT("\r\n"), cbSize );

	OutputDebugString(szBuf);
#endif
}
//--------------------------------------------------------------------------

void Log( LPCTSTR fmt, ... )
{
	TCHAR szTime[ 10 ];
	TCHAR szDate[ 10 ];
	::_tstrtime( szTime );
	::_tstrdate( szDate );

	va_list marker;
	TCHAR szBuf[1024];

	size_t cbSize = ( sizeof( szBuf ) / sizeof( TCHAR ) ) - 1; // one byte for null
	_sntprintf( szBuf, cbSize, TEXT( "%s %s: " ), szDate, szTime );
	szBuf[ 1023 ] = '\0';
	cbSize -= _tcslen( szBuf );

	va_start( marker, fmt );

	_vsntprintf( szBuf + _tcslen( szBuf ), cbSize, fmt, marker );
	szBuf[ 1023 ] = '\0';
	cbSize -= _tcslen( szBuf );

	va_end( marker );

	_tcsncat(szBuf, TEXT("\r\n"), cbSize );

#if defined( DBG ) || defined( _DEBUG )
	OutputDebugString(szBuf);
#endif

	// write the data out to the log file
	//char szBufA[ 1024 ];
	//WideCharToMultiByte( CP_ACP, 0, szBuf, -1, szBufA, 1024, NULL, NULL );

	TCHAR szLogFile[ MAX_PATH + 1 ];
	if( 0 == GetWindowsDirectory( szLogFile, MAX_PATH + 1 ) )
		return;


	_tcsncat( szLogFile, TEXT( "\\iismigration.log" ), MAX_PATH - _tcslen( szLogFile ) );
	szLogFile[ MAX_PATH ] = NULL;

	HANDLE hFile = CreateFile(
		szLogFile,                    // file name
		GENERIC_WRITE,                // open for writing 
		0,                            // do not share 
		NULL,                         // no security 
		OPEN_ALWAYS,                  // open and create if not exists
		FILE_ATTRIBUTE_NORMAL,        // normal file 
		NULL);                        // no attr. template 

	if( hFile == INVALID_HANDLE_VALUE )
	{ 
		assert( false );
		return;
	}

	//
	// move the file pointer to the end so that we can append
	//
	SetFilePointer( hFile, 0, NULL, FILE_END );

	DWORD dwNumberOfBytesWritten;
	BOOL bOK = WriteFile(
		hFile,
		szBuf,
		(UINT) _tcslen( szBuf ) * sizeof( TCHAR ),     // number of bytes to write
		&dwNumberOfBytesWritten,                       // number of bytes written
		NULL);                                         // overlapped buffer

	assert( bOK );

	FlushFileBuffers ( hFile );
	CloseHandle( hFile );
}

//-----------------------------------------------------------------------------------------

void ClearLog()
{
	/*
	TCHAR szLogFile[ MAX_PATH ];
	if( 0 == GetWindowsDirectory( szLogFile, MAX_PATH ))
	{
		return;
	}
	_tcscat( szLogFile, TEXT( "\\" ) );
	_tcscat( szLogFile, UDDI_SETUP_LOG );

	::DeleteFile( szLogFile );
	*/
	Log( TEXT( "*******************************************************" ) );
	Log( TEXT( "********** Starting a new log *************************" ) );
	Log( TEXT( "*******************************************************" ) );
}

//-----------------------------------------------------------------------------------------

void LogError( PTCHAR szAction, DWORD dwErrorCode )
{
	LPVOID lpMsgBuf;

	FormatMessage( 
		FORMAT_MESSAGE_ALLOCATE_BUFFER | 
		FORMAT_MESSAGE_FROM_SYSTEM | 
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		dwErrorCode,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
		(LPTSTR) &lpMsgBuf,
		0,
		NULL 
	);

	Log( TEXT( "----------------------------------------------------------" ) );
	Log( TEXT( "An error occurred during installation. Details follow:" ) );
	Log( TEXT( "Action: %s" ), szAction );
	Log( TEXT( "Message: %s" ), lpMsgBuf );
	Log( TEXT( "----------------------------------------------------------" ) );

	LocalFree( lpMsgBuf );
}

//--------------------------------------------------------------------------
/*
void Enter( PTCHAR szMsg )
{
#ifdef _DEBUG
	TCHAR szEnter[ 512 ];
	_stprintf( szEnter, TEXT( "Entering %s..." ), szMsg );
	Log( szEnter );
#endif
}
*/
//--------------------------------------------------------------------------
//
// NOTE: The install path has a trailing backslash
//
bool GetUDDIInstallPath( PTCHAR szInstallPath, DWORD dwLen )
{
	HKEY hKey;

	//
	// get the UDDI installation folder [TARGETDIR] from the registry.  The installer squirrels it away there.
	//
	LONG iRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE, TEXT( "SOFTWARE\\Microsoft\\UDDI" ), NULL, KEY_READ, &hKey );
	if( ERROR_SUCCESS != iRet )
	{
		LogError( TEXT( "Unable to open the UDDI registry key" ), iRet );
		return false;
	}
	
	DWORD dwType = REG_SZ;
	iRet = RegQueryValueEx(hKey, TEXT( "InstallRoot" ), 0, &dwType, (PBYTE) szInstallPath, &dwLen );
	if( ERROR_SUCCESS != iRet )
	{
		LogError( TEXT( "UDDI registry key did not have the InstallRoot value or buffer size was too small" ), iRet );
		return false;
	}

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\movesite\mbase.h ===
#ifndef __METAEXP_MBASE__
#define __METAEXP_MBASE__

#include <atlbase.h>
#include <initguid.h>
#include <comdef.h>

#include <iadmw.h>  // COM Interface header file. 
#include "common.h"

void TraceProperty( PMETADATA_RECORD pmRec, WCHAR* pwszMDPath );

HRESULT EnumProperties(IMSAdminBase* pIMetaSource, METADATA_HANDLE hKeySource, wchar_t* SourceMDPath,
					IMSAdminBase* pIMetaTarget, METADATA_HANDLE hKeyTarget, wchar_t* TargetMDPath );


HRESULT CreateAndCopyKey(
  IMSAdminBase* pIMetaSource,
  METADATA_HANDLE hMDSourceHandle, //metabase handle to the source key. 
  wchar_t* pszMDSourcePath,   //path of the source relative to hMDSourceHandle. 
  IMSAdminBase* pIMetaTarget,
  METADATA_HANDLE hMDDestHandle, //metabase handle to the destination. 
  wchar_t* pszMDDestPath,     //path of the destination, relative to hMDDestHandle. 
  BOOL bMDCopySubKeys     //whether to copy all subkey data 
  );


HRESULT CopyIISConfig(COSERVERINFO *pCoServerInfoSource,COSERVERINFO *pCoServerInfoTarget, WCHAR *pwszSourceKey, 
			_bstr_t &bstrTargetKey );
HRESULT AppPoolFixUp(COSERVERINFO *pCoServerInfo, WCHAR * pwszKey, WCHAR * pwszAppPoolID );
HRESULT CreateAppPool(IMSAdminBase* pIMeta,METADATA_HANDLE hKey,WCHAR *pAppPoolID);
HRESULT ApplyMBFixUp(COSERVERINFO *pCoServerInfo, WCHAR * pwszKey, WCHAR * pwszAppPoolID,
					 PXCOPYTASKITEM pXCOPYList, WCHAR * pwszServerBinding, BOOL bApplyFPSE);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\movesite\filecopy.cpp ===
#define _WIN32_DCOM

#include <atlbase.h>
#include <atlconv.h>

#include <initguid.h>
#include <comdef.h>

#include <stdio.h>

#include <iadmw.h>  // COM Interface header file. 
#include <iiscnfg.h>  // MD_ & IIS_MD_ #defines header file.

#include "util.h"
#include "common.h"
#include "filecopy.h"



DWORD CannonicalizePath(WCHAR *pszPath)
{
	ATLASSERT(pszPath);
	DWORD dwLen = wcslen(pszPath);

	if( pszPath[dwLen-1] == '\\' )
		return ERROR_SUCCESS;

	wcscat(pszPath,L"\\");

	return ERROR_SUCCESS;
}


// Inputs:  Metabase Key Path, Root Folder Path
// Outputs:  Folder path appended with the key name from the metabase path
DWORD CreateVirtualRootPath(const WCHAR* pwszMDKeyPath, const WCHAR *pwszRootFolderPath,
							WCHAR *pwszPath, DWORD dwSize)
{
	ATLASSERT(pwszMDKeyPath);
	ATLASSERT(pwszRootFolderPath);
	ATLASSERT(pwszPath);

	WCHAR *pRoot = wcsstr(_wcslwr((wchar_t*)pwszMDKeyPath),L"/root");
	
	if(!pRoot)
		return -1;

	wcscpy(pwszPath, pwszRootFolderPath);

	// if the metabase path is the root folder then return the root path passed in
	if( _wcsicmp(pRoot,L"/root") == 0 )
	{
		return ERROR_SUCCESS;
	}
    	
	if ( pwszPath[wcslen(pwszPath)-1] != '\\' )
		wcscat(pwszPath,L"\\");
	
	// tack on the remainder of the metabase key
	wcscat(pwszPath, pRoot + wcslen(L"/root/"));

	// fix the backslash
	for( DWORD i = 0; i < wcslen(pwszPath); i++ )
	{
		if( pwszPath[i] == '/' )
			pwszPath[i] = '\\';
	}

	return ERROR_SUCCESS;
}

DWORD AddListItem( PXCOPYTASKITEM *ppTaskItemList , const PXCOPYTASKITEM pTaskItem )
{
	PXCOPYTASKITEM pHead;
	
	ATLASSERT(ppTaskItemList);
	ATLASSERT(pTaskItem);

	pHead = *ppTaskItemList;
	if( pHead == NULL )
	{
		*ppTaskItemList = pTaskItem;
		return ERROR_SUCCESS;
	}
	
	while(pHead->pNextItem != NULL)
		pHead = pHead->pNextItem;

	pHead->pNextItem = pTaskItem;

	return ERROR_SUCCESS;
}

DWORD BuildAdminSharePathName(const WCHAR* pwszPath, const WCHAR* pwszServer,  
					                 WCHAR* pwszAdminPath, DWORD dwPathBuffer )
{
	WCHAR buffer[MAX_PATH];
	ZeroMemory( buffer,sizeof(buffer) );

	wcscpy(buffer,L"\\\\");
	wcscat(buffer,pwszServer);
	wcscat(buffer,L"\\");
	wcsncat(buffer, pwszPath, 1);
	wcscat(buffer,L"$");
	wcscat(buffer,pwszPath+2);

	DWORD wsz = wcslen(buffer);

	if (wsz > dwPathBuffer)
		return -1;

	wcscpy(pwszAdminPath,buffer);

	return ERROR_SUCCESS;

}




HRESULT BuildXCOPYTaskList(IMSAdminBase* pIMeta, METADATA_HANDLE hKey, WCHAR* pwszKeyPath, WCHAR* pwszRootFolderPath,
						   COSERVERINFO * pCoServerInfo, PXCOPYTASKITEM *ppTaskItemList  )
{
  HRESULT hRes = 0L; 
  DWORD indx = 0;
  WCHAR SubKeyName[MAX_PATH*2];
  PXCOPYTASKITEM pHead = NULL;
  WCHAR SourcePath[MAX_PATH+2];
  WCHAR PathDataBuf[MAX_PATH+2];
  DWORD dwReqBufLen = MAX_PATH+2;
  PXCOPYTASKITEM pNewItem;
  WCHAR KeyName[MAX_PATH];

  _bstr_t bstrKey;


  while (SUCCEEDED(hRes))
	{ 
			hRes = pIMeta->EnumKeys(hKey, pwszKeyPath, SubKeyName, indx); 
			// RECURSIVELY SERARCH ALL SUB-FOLDERS
			if(SUCCEEDED(hRes)) {
				bstrKey = pwszKeyPath; bstrKey += L"/"; bstrKey += SubKeyName;
     			BuildXCOPYTaskList(pIMeta,hKey,bstrKey,pwszRootFolderPath, 
					pCoServerInfo,ppTaskItemList  );
			}
			indx++;
	} //while (SUCCEEDED(hRes))

  // Read the PATH data 
  hRes = GetPropertyData(pIMeta,hKey,pwszKeyPath,MD_VR_PATH,METADATA_ISINHERITED,ALL_METADATA,ALL_METADATA,
		PathDataBuf, &dwReqBufLen );
  
  if( !SUCCEEDED(hRes) )
		return hRes;

  // Special case:  if the virtual directory is a front page virtual directory, 
  // then don't add it to the list
  GetKeyNameFromPath(pwszKeyPath,KeyName,MAX_PATH);
  if( wcsstr(_wcslwr(KeyName),L"_vti") != NULL )
	  return S_OK;

  if( !IsServerLocal((char*)_bstr_t(pCoServerInfo->pwszName) ) )
	  BuildAdminSharePathName(PathDataBuf,pCoServerInfo->pwszName,SourcePath, MAX_PATH);
 
	pNewItem = new XCOPYTASKITEM;
	ZeroMemory(pNewItem,sizeof(XCOPYTASKITEM));

	pNewItem->pwszMBPath = new WCHAR[MAX_PATH];
	wcscpy(pNewItem->pwszMBPath,pwszKeyPath);

	pNewItem->pwszSourcePath = new WCHAR[MAX_PATH + 2];
	wcscpy(pNewItem->pwszSourcePath, SourcePath );

	pNewItem->pwszDestPath = new WCHAR[MAX_PATH + 2];

	// If a target root directory is not specified, then we are using the path read from 
	// the source metabase
	if( !pwszRootFolderPath )
		wcscpy(pNewItem->pwszDestPath, PathDataBuf );
	
	// a path is specified, we will need to create the sub folder structure for virtual dirs
	// ex:
	// if path = w3svc/1/root target = c:\inetpub\wwwroot  result = c:\inetpub\wwwroot
	//  w3svc/1/root/app1 , target = c:\inetpub\wwwroot , result = c:\inetpub\wwwroot\app1
	//  w3svc/1/root/app1/app2  result = result = c:\inetpub\wwwroot\app1\app2
	else
		CreateVirtualRootPath(pwszKeyPath,pwszRootFolderPath,pNewItem->pwszDestPath,MAX_PATH+2);
	

 // if ( !pxcopytaskitemlist )
//	  pxcopytaskitemlist = pNewItem;
  //else
	  AddListItem(ppTaskItemList ,pNewItem);

  return hRes;

}


HRESULT CopyContent(COSERVERINFO * pCoServerInfo, WCHAR* pwszSourceMBKeyPath,
					WCHAR* pwszRootFolderPath,PXCOPYTASKITEM *ppTaskItemList, BOOL bEnumFoldersOnly  )
{
  HRESULT hRes = 0L; 
  METADATA_HANDLE hKey;  
  CComPtr <IMSAdminBase> pIMetaSource = 0L; 
  MULTI_QI rgmqi[1] = { &IID_IMSAdminBase,0,0 };


  if( !pCoServerInfo || !pwszSourceMBKeyPath)
	  return E_UNEXPECTED;

  hRes = CoCreateInstanceEx(CLSID_MSAdminBase,NULL, CLSCTX_ALL, pCoServerInfo,
				1, rgmqi); 

  if(SUCCEEDED(hRes))
		pIMetaSource = reinterpret_cast<IMSAdminBase*>(rgmqi[0].pItf);
  else
	  return hRes;

  if( pCoServerInfo->pAuthInfo->pAuthIdentityData->User != NULL )
  {
	  hRes = SetBlanket(pIMetaSource,pCoServerInfo->pAuthInfo->pAuthIdentityData->User,
		  pCoServerInfo->pAuthInfo->pAuthIdentityData->Domain,pCoServerInfo->pAuthInfo->pAuthIdentityData->Password);

	  if( !SUCCEEDED(hRes) )
		  return hRes;
  }

    // Open the metabase path and loop through all the sub keys
  hRes = pIMetaSource->OpenKey(METADATA_MASTER_ROOT_HANDLE, L"/LM",
     METADATA_PERMISSION_READ, 10000, &hKey);

  if( !SUCCEEDED(hRes) )
	  return hRes;

  BuildXCOPYTaskList(pIMetaSource,hKey,pwszSourceMBKeyPath,pwszRootFolderPath,
						pCoServerInfo, ppTaskItemList  );

  pIMetaSource->CloseKey(hKey);

//  DEBUGPRINTLIST(ppTaskItemList);
  // Call XCOPY on list items.
  if( bEnumFoldersOnly )
		XCOPY(ppTaskItemList);

  return hRes;

}

VOID FreeXCOPYTaskList(PXCOPYTASKITEM pList)
{
	if( !pList )
		return;

	PXCOPYTASKITEM pHead = pList;
	PXCOPYTASKITEM pNext = pList->pNextItem;

	while( pNext )
	{
		pHead = pNext;
		pNext = pNext->pNextItem;
		delete pHead->pwszDestPath;
		delete pHead->pwszMBPath;
		delete pHead->pwszSourcePath;
		delete pHead;
	}

}
DWORD XCOPY(PXCOPYTASKITEM *pTaskItemList,  WCHAR* args )
{
	
	PXCOPYTASKITEM pHead = *pTaskItemList;

	if( !pHead)
		return -1;

	while (pHead->pNextItem)
	{
		XCOPY(pHead->pwszSourcePath,pHead->pwszDestPath,args);
		pHead = pHead->pNextItem;
	}

	XCOPY(pHead->pwszSourcePath,pHead->pwszDestPath,args);

	return ERROR_SUCCESS;
}

DWORD XCOPY(WCHAR* source, WCHAR* target, WCHAR* args )
{
	STARTUPINFO si = {0};
	si.cb = sizeof( si );

	PROCESS_INFORMATION pi = {0};

	_bstr_t bstrSourcePath(source);
	_bstr_t bstrTargetPath(target);
	
	TCHAR szSystemFolder[ MAX_PATH ];
	
	if( 0 == GetSystemDirectory( szSystemFolder, MAX_PATH ) )
	{
		return GetLastError();
	}

	bstr_t cApplicationName( szSystemFolder );
	cApplicationName += ( TEXT( "\\xcopy.exe" ) );

	bstr_t cCommandLine( cApplicationName);
	cCommandLine += ( TEXT(" ") );
	cCommandLine += _bstr_t("\"") + bstrSourcePath + _bstr_t("\"") ;
	cCommandLine += ( TEXT(" ") );
	cCommandLine += _bstr_t("\"") + bstrTargetPath + _bstr_t("\"") ;
	cCommandLine += ( TEXT(" /E /I /K /Y /H") );

	Log( TEXT("executing: %s"), (char*)cCommandLine );
	
//cCommandLine.append( args );

//	_tprintf( TEXT("executing: %s\n"), (char*)cCommandLine );

//	return 0;

	BOOL bOK = CreateProcess( 
		(char*)cApplicationName,	//  LPCTSTR lpApplicationName,                 // name of executable module
		(char*) cCommandLine,	//  LPTSTR lpCommandLine,                      // command line string
		NULL,					//  LPSECURITY_ATTRIBUTES lpProcessAttributes, // SD
		NULL,					//  LPSECURITY_ATTRIBUTES lpThreadAttributes,  // SD
		NULL,					//  BOOL bInheritHandles,                      // handle inheritance option
		CREATE_NEW_PROCESS_GROUP,		//  DWORD dwCreationFlags,                     // creation flags
		NULL,					//  LPVOID lpEnvironment,                      // new environment block
		NULL,					//  LPCTSTR lpCurrentDirectory,                // current directory name
		&si,					//  LPSTARTUPINFO lpStartupInfo,               // startup information
		&pi );					//  LPPROCESS_INFORMATION lpProcessInformation // process information

	if( !bOK )
	{
		Log( TEXT( "FAIL: CreateProcess() failed, error code=%d" ), GetLastError() );
		return GetLastError();
	}

	DWORD dwRet = WaitForSingleObject( pi.hProcess, 360000 );

	if( dwRet == WAIT_TIMEOUT )
	{
		Log( TEXT( "FAIL: CreateProcess() timed out" ) );
		return ERROR_SEM_TIMEOUT;
	}
	else if( dwRet == WAIT_ABANDONED )
	{
		Log( TEXT( "FAIL: WaitForSingleObject() failed on WAIT_ABANDONED" ) );
		return ERROR_SEM_TIMEOUT;
	}
	else if( dwRet == WAIT_FAILED )
	{
		LogError( TEXT( "FAIL: WaitForSingleObject() failed" ), GetLastError() );
		return GetLastError();
	}

	DWORD dwExitCode = 0;
	if( GetExitCodeProcess( pi.hProcess, &dwExitCode ) )
	{
		if( dwExitCode )
		{
			Log( TEXT( "FAIL: xcopy() threw an error=%d" ), dwExitCode );
			return dwExitCode;
		}
		else
		{
			Log( TEXT( "CreateProcess() succeeded" ) );
		}
	}
	else
	{
		LogError( TEXT( "GetExitCodeProcess()" ), GetLastError() );
		return GetLastError();
	}

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\movesite\mbase.cpp ===
#define _WIN32_DCOM

#include <atlbase.h>
#include <atlconv.h>

#include <initguid.h>
#include <comdef.h>

#include <stdio.h>
#include <iadmw.h>  // COM Interface header file. 
#include <iiscnfg.h>  // MD_ & IIS_MD_ #defines header file.

#include <conio.h>

#include <shlobj.h>
#include <Shlwapi.h>

#include "util.h"
#include "auth.h"
#include "filecopy.h"
#include "mbase.h"

#define ORIGINAL_BUFFER_SIZE 256
#define KEYTYPE_NAME_BUFFER 32

#pragma comment(lib,"Shlwapi.lib")



HRESULT CreateAndCopyKey(
  IMSAdminBase* pIMetaSource,
  METADATA_HANDLE hMDSourceHandle, //metabase handle to the source key. 
  wchar_t* pszMDSourcePath,   //path of the source relative to hMDSourceHandle. 
  IMSAdminBase* pIMetaTarget,
  METADATA_HANDLE hMDDestHandle, //metabase handle to the destination. 
  wchar_t* pszMDDestPath,     //path of the destination, relative to hMDDestHandle. 
  BOOL bMDCopySubKeys     //whether to copy all subkey data 
  )
{

	HRESULT hRes = S_OK;

	DWORD indx = 0;
	WCHAR SubKeyName[MAX_PATH*2];
	_bstr_t bstrTargetSubKeyPath;
	_bstr_t bstrSourceSubKeyPath;

	ATLASSERT(pIMetaSource != NULL);
	ATLASSERT(pIMetaTarget != NULL);
	ATLASSERT(pszMDSourcePath);
	ATLASSERT(pszMDDestPath);


	// first this will create the destination key.
	pIMetaTarget->AddKey(hMDDestHandle,pszMDDestPath);

	while (SUCCEEDED(hRes))
	{ 
			hRes = pIMetaSource->EnumKeys(hMDSourceHandle, pszMDSourcePath, SubKeyName, indx); 
			if(SUCCEEDED(hRes)) {
					
				    bstrTargetSubKeyPath = pszMDDestPath;
					bstrTargetSubKeyPath += L"/";
					bstrTargetSubKeyPath += SubKeyName;
					
					bstrSourceSubKeyPath = pszMDSourcePath;
					bstrSourceSubKeyPath += L"/";
					bstrSourceSubKeyPath += SubKeyName;

					//wprintf(L"%s %s\n",SubKeyName,KeyType);
					CreateAndCopyKey (pIMetaSource,hMDSourceHandle,bstrSourceSubKeyPath,pIMetaTarget,
						hMDDestHandle,bstrTargetSubKeyPath, bMDCopySubKeys);
			
			}
			indx++;
	 
	} //while (SUCCEEDED(hRes))
	
	hRes = EnumProperties(pIMetaSource,hMDSourceHandle,pszMDSourcePath,pIMetaTarget,hMDDestHandle,pszMDDestPath);

	return hRes;
}
 


HRESULT EnumProperties(IMSAdminBase* pIMetaSource, METADATA_HANDLE hKeySource, wchar_t* SourceMDPath,
					IMSAdminBase* pIMetaTarget, METADATA_HANDLE hKeyTarget, wchar_t* TargetMDPath )
{

HRESULT hRes = 0;
METADATA_RECORD mRec;
DWORD indx = 0;
DWORD dwReqBufLen = 0; 
DWORD dwBufLen = ORIGINAL_BUFFER_SIZE;
PBYTE pbBuffer = new BYTE[dwBufLen];
wchar_t *ptemp = 0;


while (SUCCEEDED(hRes)){ 

	mRec.dwMDAttributes = METADATA_ISINHERITED;
    mRec.dwMDUserType = ALL_METADATA; //IIS_MD_UT_FILE ; 
    mRec.dwMDDataType = ALL_METADATA; 
    mRec.dwMDDataLen = dwBufLen; 
    mRec.pbMDData = pbBuffer; 
 
    hRes = pIMetaSource->EnumData(hKeySource, SourceMDPath, &mRec, indx, &dwReqBufLen); 
    if (hRes == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER)) { 
      delete [] (pbBuffer); 
      pbBuffer = new BYTE[dwReqBufLen]; 
      dwBufLen = dwReqBufLen; 
      mRec.dwMDDataLen = dwReqBufLen; 
      mRec.pbMDData = pbBuffer; 
      hRes = pIMetaSource->EnumData(hKeySource, SourceMDPath, &mRec, indx, &dwReqBufLen); 
    } 
    
	if ( SUCCEEDED(hRes) )
	{ 

		// write the property to the target
		if( mRec.dwMDIdentifier == MD_APP_ROOT )
		{
		//	mRec.pbMDData = new WCHAR[MAX_PATH];
			wcscpy((LPWSTR)mRec.pbMDData, _bstr_t(L"/LM") + _bstr_t(TargetMDPath) );
			mRec.dwMDDataLen = (DWORD)(wcslen((LPWSTR)mRec.pbMDData)+1)*2;

		}
		hRes = pIMetaTarget->SetData(hKeyTarget,TargetMDPath,&mRec);
		if( !SUCCEEDED(hRes) )
			return hRes;
	} 
    // Increment the index. 
    indx++; 
  } // End while.

delete pbBuffer;
//wprintf(L"Done numerating properties set at: %s ...\n",SourceMDPath);

return S_OK;
}


// INPUT canonicalized source path node in relation to the root key "/LM" ex:  /w3svc/1
HRESULT CopyIISConfig(COSERVERINFO *pCoServerInfoSource, COSERVERINFO *pCoServerInfoTarget,
					  WCHAR *pwszSourceKey, _bstr_t &bstrTargetKey)
{
  
  HRESULT hRes;
  METADATA_HANDLE hKeySource;  
  METADATA_HANDLE hKeyTarget;  
  CComPtr <IMSAdminBase> pIMetaSource = 0L; 
  CComPtr <IMSAdminBase> pIMetaTarget = 0L;
  BOOL bIsLocal;
   _bstr_t bstrRootKey = L"/LM";
   _bstr_t bstrTargetNode;

   long lTargetSiteID;


    // Declare a MULTI_QI for remote usage
  MULTI_QI rgmqi[1] = { &IID_IMSAdminBase,0,0 };

  
  ATLASSERT(pCoServerInfoSource);
  ATLASSERT(pCoServerInfoTarget);

  bIsLocal = IsServerLocal( (char*)_bstr_t(pCoServerInfoSource->pwszName) );

  hRes = CoCreateInstanceEx(CLSID_MSAdminBase,NULL, CLSCTX_ALL, pCoServerInfoSource,
				1, rgmqi); 
  
  if(SUCCEEDED(hRes))
			pIMetaSource = reinterpret_cast<IMSAdminBase*>(rgmqi[0].pItf);
  else
  {
	  wprintf( L"error creating IMSAdminbase on machine: %s. HRESULT=%x\n", pCoServerInfoSource->pwszName, hRes);
	  return hRes;
  }

  if( pCoServerInfoSource->pAuthInfo->pAuthIdentityData->User )
  {
  			//hRes = SetBlanket(pIMetaSource);
			if (!SUCCEEDED(SetBlanket(pIMetaSource,pCoServerInfoSource->pAuthInfo->pAuthIdentityData->User,
				pCoServerInfoSource->pAuthInfo->pAuthIdentityData->Domain,
				pCoServerInfoSource->pAuthInfo->pAuthIdentityData->Password) ) )
			{
				_tprintf(_T("error setting COM impersonation:  HRESULT=%x\n"), hRes);
				return hRes;
			}
  }

  if(bIsLocal)
		//hRes = pIMetaSource->QueryInterface(IID_IMSAdminBase,(void**)&pIMetaTarget);
		pIMetaTarget = pIMetaSource;
  else
  {
	// Create the IMSAdminBase object on the target server
	rgmqi[0].pItf = 0L;
	rgmqi[0].hr = 0L;

	hRes = CoCreateInstanceEx(CLSID_MSAdminBase,NULL, CLSCTX_ALL, pCoServerInfoTarget,
					1, rgmqi); 

	if(SUCCEEDED(hRes))
		pIMetaTarget = reinterpret_cast<IMSAdminBase*>(rgmqi[0].pItf);
	else
	{
		_tprintf(_T("error creating IMSAdminbase on this machine: %s. HRESULT=%x\n"), 
				(char*)_bstr_t(pCoServerInfoTarget->pwszName), hRes);
		return hRes;
	}
  }

// Open the metabase on the source and target
if( bIsLocal )

{
 if( !SUCCEEDED( hRes = pIMetaSource->OpenKey(METADATA_MASTER_ROOT_HANDLE, bstrRootKey,
     METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE, 10000, &hKeySource) ) )
 {   
	 _tprintf( _T("OpenKey() failed on the root key %s on server: %s,  hr = %x\n"),
		 (char*)bstrRootKey, (char*)_bstr_t(pCoServerInfoSource->pwszName), hRes );
	 return hRes;
 }
 hKeyTarget = hKeySource;
}
else
{
	 
	// Get a handle to the Root key of the Source machine
	 if( !SUCCEEDED( hRes = pIMetaSource->OpenKey(METADATA_MASTER_ROOT_HANDLE, bstrRootKey,
		METADATA_PERMISSION_READ , 10000, &hKeySource) )) 
	 {
		 _tprintf( _T("OpenKey() failed on the root key %s on server: %s,  hr = %x\n"),
		 (char*)bstrRootKey, (char*)_bstr_t(pCoServerInfoSource->pwszName), hRes );
		 return hRes;
	 }
	
	 // Get a handle to the Root key of the Target machine
	 if( !SUCCEEDED( hRes = pIMetaTarget->OpenKey(METADATA_MASTER_ROOT_HANDLE, bstrRootKey,
         METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE, 10000, &hKeyTarget) )) 
	 {
		 _tprintf( _T("OpenKey() failed on the root key %s on server: %s,  hr = %x\n"),
		 (char*)bstrRootKey, (char*)_bstr_t(pCoServerInfoTarget->pwszName), hRes );

		 pIMetaSource->CloseKey(hKeySource);
		 return hRes;
	 }
}

if( bstrTargetKey.length() == 0 )
{
	lTargetSiteID = GetAvailableSiteID(pIMetaTarget,hKeyTarget);
	bstrTargetNode = L"/W3SVC/";
	bstrTargetNode += _bstr_t(lTargetSiteID);
	bstrTargetKey = bstrTargetNode;
}
else
    bstrTargetNode = bstrTargetKey;

// replicate the metabase node
fwprintf(stderr, L"replicating IIS metabase properties set at: %s ...\n",pwszSourceKey);
hRes = CreateAndCopyKey(pIMetaSource,hKeySource, pwszSourceKey,
						pIMetaTarget, hKeyTarget,bstrTargetNode, true );


if( !SUCCEEDED(hRes) )
	{
		_tprintf( _T("Error encountered in metabase copy operation\n") );
	}	


pIMetaSource->CloseKey(hKeySource);
if( !bIsLocal )
	pIMetaTarget->CloseKey( hKeyTarget );

pIMetaSource = 0;
pIMetaTarget = 0;

return hRes;
}

HRESULT ApplyMBFixUp(COSERVERINFO *pCoServerInfo, WCHAR * pwszKey, WCHAR * pwszAppPoolID,
					 PXCOPYTASKITEM pXCOPYList, WCHAR * pwszServerBinding, BOOL bApplyFPSE)
{
  HRESULT hRes;
  METADATA_HANDLE hKey;   
  CComPtr <IMSAdminBase> pIMeta = 0L; 
  MULTI_QI rgmqi[1] = { &IID_IMSAdminBase,0,0 };
  	WCHAR DataBuf[MAX_PATH];
	memset (DataBuf,0,sizeof(DataBuf) );
  PXCOPYTASKITEM pList = pXCOPYList;
  bstr_t bstrRealTargetPath;
  WCHAR *pTemp = NULL;
  DWORD dwFPSEBOOL;
  DWORD dwSize = sizeof(DWORD);
  _bstr_t bstrCommandline;
  TCHAR szOwsAdmPath[MAX_PATH];

  ZeroMemory(szOwsAdmPath,sizeof(szOwsAdmPath));

  ATLASSERT(pwszKey);

  if( !pCoServerInfo )
		return E_UNEXPECTED;

  if( SUCCEEDED(hRes = CoCreateInstanceEx(CLSID_MSAdminBase,NULL, 
	  CLSCTX_ALL, pCoServerInfo,1, rgmqi) ) )
	  pIMeta = reinterpret_cast<IMSAdminBase*>(rgmqi[0].pItf);
  else
  {
	  fwprintf( stderr, L"error creating IMSAdminbase on machine: %s. HRESULT=%x\n", 
			pCoServerInfo->pwszName, hRes);
	  return hRes;
  }

  if( UsesImpersonation(pCoServerInfo) )
  {
		if (!SUCCEEDED(hRes = SetBlanket(pIMeta,pCoServerInfo->pAuthInfo->pAuthIdentityData->User,
				pCoServerInfo->pAuthInfo->pAuthIdentityData->Domain,
				pCoServerInfo->pAuthInfo->pAuthIdentityData->Password) ) )
			{
				fwprintf( stderr, L"error setting CoSetProxyBlanket on machine: %s for user: %s  HRESULT=%x\n",
					pCoServerInfo->pwszName,pCoServerInfo->pAuthInfo->pAuthIdentityData->User, hRes);
				pIMeta = 0;
				return hRes;
			}
  }

  if( !SUCCEEDED( hRes = pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE, L"/LM",
     METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE , 10000, &hKey) ) )
  {
	  fwprintf( stderr, L"Error opening key: %s on computer: %s. HRESULT=%x\n", 
			L"/LM", pCoServerInfo->pwszName, hRes);
	  pIMeta = 0;
	  return hRes;
  }

  if( !SUCCEEDED( hRes = CreateAppPool(pIMeta,hKey,pwszAppPoolID) ) )
  {
	  return hRes;
  }


    // Now set the AppPoolID property of the Key
//	wcscpy((LPWSTR)DataBuf, pwszAppPoolID);

  hRes = SetPropertyData(pIMeta,hKey,_bstr_t(pwszKey) + _bstr_t(L"/root"), MD_APP_APPPOOL_ID, METADATA_INHERIT,
				IIS_MD_UT_SERVER,STRING_METADATA, (PBYTE)pwszAppPoolID, (wcslen(pwszAppPoolID) + 1) * sizeof(WCHAR) );

// Loope thought the list and reset any Path direcrories
  if( pList )
  {
	  ATLASSERT(pList->pwszMBPath);
	  ATLASSERT(pList->pwszDestPath);
	  
	  pTemp = wcsstr(_wcslwr(pList->pwszMBPath),L"/root");
	  bstrRealTargetPath = _bstr_t(pwszKey) + _bstr_t(pTemp);


	  hRes = SetPropertyData(pIMeta,hKey,bstrRealTargetPath, MD_VR_PATH, METADATA_INHERIT,
		IIS_MD_UT_FILE,STRING_METADATA, pList->pwszDestPath, (wcslen(pList->pwszDestPath) + 1) * sizeof(WCHAR) );
	  
	  while( pList->pNextItem )
	  {
			pList = pList->pNextItem;
			pTemp = wcsstr(_wcslwr(pList->pwszMBPath),L"/root");
			bstrRealTargetPath = _bstr_t(pwszKey) + _bstr_t(pTemp);
			hRes = SetPropertyData(pIMeta,hKey,bstrRealTargetPath, MD_VR_PATH, METADATA_INHERIT,
					IIS_MD_UT_FILE,STRING_METADATA, pList->pwszDestPath, (wcslen(pList->pwszDestPath) + 1) * sizeof(WCHAR) );
	  }
  }

  // Set the serverbinding string if present
  if( pwszServerBinding )
  {

	hRes = SetPropertyData(pIMeta,hKey,pwszKey, MD_SERVER_BINDINGS, METADATA_NO_ATTRIBUTES,
				IIS_MD_UT_SERVER,MULTISZ_METADATA, pwszServerBinding, (wcslen(pwszServerBinding) + 1) * sizeof(WCHAR) + 1 * sizeof(WCHAR));
  }

  if (bApplyFPSE)
  {
	  // Check to see if the web is front page extended
	  bstrCommandline = "-o install -p /lm";
	  bstrCommandline += _bstr_t(pwszKey);
	  hRes = GetPropertyData(pIMeta,hKey,pwszKey,MD_FRONTPAGE_WEB,METADATA_NO_ATTRIBUTES,
		  IIS_MD_UT_SERVER, DWORD_METADATA, &dwFPSEBOOL, &dwSize );

	  if( SUCCEEDED(hRes) )
	  {
		if(SUCCEEDED(SHGetFolderPath(NULL, CSIDL_PROGRAM_FILES_COMMON , NULL, SHGFP_TYPE_CURRENT, szOwsAdmPath)) ) 
		{
			PathAppend(szOwsAdmPath, TEXT("Microsoft Shared\\Web Server Extensions\\50\\bin\\owsadm.exe") );	
		}
	  }
  }

  if( !SUCCEEDED(hRes = pIMeta->CloseKey(hKey) ) )
  {
	  fwprintf( stderr, L"Error closing key: /LM/W3SVC on computer: %s. HRESULT=%x\n", 
			pCoServerInfo->pwszName, hRes);
  }
  
  pIMeta = 0;

  if( bApplyFPSE )
  {
	    fwprintf(stderr,L"reconfiguring FPSE settings...\n" );
		MyCreateProcess(szOwsAdmPath,bstrCommandline,CREATE_NEW_PROCESS_GROUP,360000);
  }

  return hRes;
}

HRESULT CreateAppPool(IMSAdminBase* pIMeta,METADATA_HANDLE hKey,WCHAR *pAppPoolID)
{
	HRESULT hRes;

	_bstr_t bstrAppPoolPath(L"/w3svc/AppPools/");
	WCHAR DataBuf[MAX_PATH];
	memset (DataBuf,0,sizeof(DataBuf) );


	bstrAppPoolPath += pAppPoolID;

	hRes = pIMeta->AddKey(hKey,bstrAppPoolPath);

// Set the KeyType property of the AppPool
//	hRes = SetKeyType( pIMeta, hKey, bstrAppPoolPath, L"IIsApplicationPool"  );
	hRes = SetPropertyData(pIMeta,hKey,bstrAppPoolPath,MD_KEY_TYPE,METADATA_NO_ATTRIBUTES,
		IIS_MD_UT_SERVER,STRING_METADATA,L"IIsApplicationPool",(wcslen(L"IIsApplicationPool") + 1) * sizeof(WCHAR) );


	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\movesite\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	MetaExp.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\schemagen\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\movesite\filecopy.h ===
#ifndef __METAEXP_FILECOPY__
#define __METAEXP_FILECOPY__

#include <iadmw.h>  // COM Interface header file. 


typedef struct _XCOPYTASKITEM
{
	WCHAR* pwszMBPath;
	WCHAR* pwszSourcePath;
	WCHAR* pwszDestPath;
	_XCOPYTASKITEM *pNextItem;
}
XCOPYTASKITEM;

typedef XCOPYTASKITEM* PXCOPYTASKITEM;



DWORD XCOPY(WCHAR* source, WCHAR* target, WCHAR* args = NULL);
DWORD XCOPY(PXCOPYTASKITEM *pTaskItemList,  WCHAR* args = NULL);

HRESULT CopyContent(COSERVERINFO * pCoServerInfo, WCHAR* pwszSourceMBKeyPath,
					WCHAR* pwszRootFolderPath, PXCOPYTASKITEM *ppTaskItemList, BOOL bEnumFoldersOnly = false );

HRESULT BuildXCOPYTaskList(IMSAdminBase* pIMeta, METADATA_HANDLE hKey, WCHAR* pwszKeyPath, WCHAR* pwszRootFolderPath,
						   COSERVERINFO * pCoServerInfo, PXCOPYTASKITEM *ppTaskItemList );

VOID FreeXCOPYTaskList(PXCOPYTASKITEM pList);

DWORD BuildAdminSharePathName(const WCHAR* pwszPath, const WCHAR* pwszServer,  
					                 WCHAR* pwszAdminPath, DWORD dwPathBuffer );

DWORD AddListItem( PXCOPYTASKITEM *ppTaskItemList , const PXCOPYTASKITEM pTaskItem );

DWORD CannonicalizePath(WCHAR *pszPath);

DWORD CreateVirtualRootPath(const WCHAR* pwszMDKeyPath, const WCHAR *pwszRootFolderPath,
							WCHAR *pwszPath, DWORD dwSize);




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\movesite\metaexp.cpp ===
// MetaExp.cpp : Defines the entry point for the console application.
//

#define _WIN32_DCOM

#include <atlbase.h>
#include <atlconv.h>
#include <initguid.h>
#include <comdef.h>
#include <stdio.h>
#include <iadmw.h>  // COM Interface header file. 
#include <iiscnfg.h>  // MD_ & IIS_MD_ #defines header file.
#include <conio.h>

#include "util.h"
#include "auth.h"
#include "filecopy.h"
#include "mbase.h"


#define DEFAULT_APP_POOL_ID L"ImportedAppPool"
PXCOPYTASKITEM g_pTaskItemList;

void Usage(WCHAR* image)
{
	wprintf( L"\nDescription: Utility for moving IIS web sites from server to server\n\n"  );
	wprintf( L"Usage: %s <source machine name> <metabase path> [/o /d:<root directory> /a:<app pool id> /s /c]\n\n", image  );
	wprintf( L"\t/d:<path> specify root directory path\n");
	wprintf( L"\t/m:<metabase path> specify metabase path for target server\n");
	wprintf( L"\t/a:<apppool> specify app pool ID\n");
	wprintf( L"\t/b:<serverbinding> serverbindings string\n");
	wprintf( L"\t/c copy IIS configuration only\n");
	wprintf( L"\t/u:<user> username to connect to source server\n");
	wprintf( L"\t/p:<pwd> password to connect to source server\n\n");
    wprintf( L"Examples:\n\t%s IIS-01 /lm/w3svc/1\n", image ); 
	wprintf( L"\t%s IIS-01 /lm/w3svc/2 /d:f:\\inetpub\\wwwroot /c\n", image );
	wprintf( L"\t%s IIS-01 /lm/w3svc/2 /d:f:\\inetpub\\wwwroot /m:w3svc/3\n", image );
	wprintf( L"\t%s IIS-01 /lm/w3svc/2 /d:f:\\inetpub\\wwwroot /a:MyAppPool\n", image );
	wprintf( L"\t%s IIS-01 /lm/w3svc/2 /d:f:\\inetpub\\wwwroot /b:192.168.1.1:80:www.mysite.com\n", image );
	wprintf( L"\n");

}


int 
wmain(int argc, wchar_t* argv[])
{
  
  HRESULT hRes = 0L; 
  wchar_t** argp;
  
  _bstr_t bstrRootKey = L"/LM";
  _bstr_t bstrSourceServer;
  _bstr_t bstrSourceNode;
  _bstr_t bstrArgz;
  _bstr_t bstrTargetNode;
  _bstr_t bstrTargetDir;
  _bstr_t bstrAppPoolID = DEFAULT_APP_POOL_ID;
  _bstr_t bstrRemoteUserName;
  _bstr_t bstrRemoteUserPass;
  _bstr_t bstrDomainName;
  _bstr_t bstrServerBindings;

  char userpassword[81];
  
  BOOL bCopyContent = true;
  BOOL bCopySubKeys = true;
  BOOL bIsLocal = false;
  BOOL bUsesImpersonation = false;


  COSERVERINFO *pServerInfoSource = NULL;
  COSERVERINFO *pServerInfoTarget = NULL;
  PXCOPYTASKITEM pListItem = NULL;

  g_pTaskItemList = NULL;

  hRes = CoInitialize(NULL);

  // check for the required command-line arguments
  if( argc < 3) {
		Usage( argv[0] );
		return -1;
		}
  
  bstrSourceServer = argv[1];
  // cannonicalize the node value
  bstrSourceNode = argv[2];
  //bstrSourceNode += wcsstr( _wcslwr( argv[2] ), L"w3svc") ;
  
  for (argp = argv + 3; *argp != NULL; argp++ ) {
	  if( (**argp == '/') || (**argp == '-') )
	  {
		  bstrArgz = *argp+1;  
		  if( !_strnicmp( (char*)bstrArgz, "M:", sizeof("M:")-1) ) 
		  {
			  bstrTargetNode =  *argp + sizeof("M:")  ;
			  _tprintf(_T("target metabase key: %s\n"),(char *)bstrTargetNode);
			  continue;
		  }
		  if( !_strnicmp( (char*)bstrArgz, "D:", sizeof("D:")-1) ) 
		  {  
			  bstrTargetDir = *argp + sizeof("D:");
			  _tprintf(_T("target dir: %s\n"),(char *)bstrTargetDir);
			  continue;
		  } 
		  if( !_strnicmp( (char*)bstrArgz, "C", sizeof("C")-1) ) 
		  {  
			  bCopyContent = false;
			  _tprintf(_T("copy metabase configuration only: true\n"));
			  continue;
		  } 
		  if( !_strnicmp( (char*)bstrArgz, "A:", sizeof("A:")-1) ) 
		  {  
			  bstrAppPoolID = *argp + sizeof("A:");
			  _tprintf(_T("app pool ID: %s\n"),(char *)bstrAppPoolID);
			  continue;
		  } 
		  if( !_strnicmp( (char*)bstrArgz, "B:", sizeof("B:")-1) ) 
		  {  
			  bstrServerBindings  = *argp + sizeof("B:");
			  _tprintf(_T("ServerBindings: %s\n"),(char *)bstrServerBindings);
			  continue;
		  } 

		  if( !_strnicmp( (char*)bstrArgz, "U:", sizeof("U:")-1) ) 
		  {  
			  bstrRemoteUserName = *argp + sizeof("U:");
			  bUsesImpersonation = true;
			  _tprintf(_T("Remote User Name: %s\n"), (char*)bstrRemoteUserName );
			  continue;
		  } 

		  if( !_strnicmp( (char*)bstrArgz, "P:", sizeof("P:")-1) ) 
		  {  
			  bstrRemoteUserPass = *argp + sizeof("U:");
			  _tprintf(_T("Remote User Name: *********\n"));
			  continue;
		  } 

		  fprintf(stderr, "unknown option  '%s'\n", *argp+1);
		  return 1;			
	  }
	  else
	  {
		  fprintf(stderr, "unknown option  '%s'\n", (char *)bstrArgz);
		  return 1;
	  }				
  }

  // If the user password is not present, then read from the command line
  // echo '*' characters to obfuscate passord
  if( (bstrRemoteUserName.length() > 0) && (bstrRemoteUserPass.length() < 1) )
  {
	 _tprintf(_T("Enter the password for %s "), (char*)bstrRemoteUserName);
	 char ch;
	 int i;

	 ch = getch();
	 for( i = 0;i < 80; i++)
	 {
		 if(ch == 13)
			 break;
		 userpassword[i] = ch;
		 putch('*');
		 ch = getch();
	 }
	 userpassword[i] = NULL;
	 bstrRemoteUserPass = userpassword;
  }

  // cannonicalize the source metabase node
  if( NULL == wcsstr( _wcslwr( bstrSourceNode ), L"w3svc") )
  {
	  fwprintf(stderr,L"source path value %s is invalid format\n", bstrSourceNode.GetBSTR() );
	  return 1;
  }
  bstrSourceNode = _bstr_t("/") + _bstr_t(wcsstr( _wcslwr( bstrSourceNode ), L"w3svc") ) ;
  _tprintf(_T("Source metabase key: %s\n"), (char*)bstrSourceNode );
  
  // cannonicalize the target metabase node if present, otherwise it is the source
  if( bstrTargetNode.length() > 0 )
  {
	if( NULL == wcsstr( _wcslwr( bstrTargetNode ), L"w3svc") )
	{
		fwprintf(stderr,L"target path value %s is invalid format\n", bstrTargetNode.GetBSTR() );
		return 1;
	}
	bstrTargetNode = _bstr_t("/") + _bstr_t(wcsstr( _wcslwr( bstrTargetNode ), L"w3svc") ) ;
	_tprintf(_T("Target metabase key: %s\n"), (char*)bstrTargetNode );
  }
 
   
 if( IsServerLocal((char*)bstrSourceServer) )
 {
	 bIsLocal = true;
	 if( bstrSourceNode == bstrTargetNode )
	 {
		 fwprintf(stderr,L"cannot import same node for local copy. Program exiting\n");
		 return 1;
	 }

	 if( bCopyContent && !bstrTargetDir)
	 {
		 fwprintf(stderr,L"cannot overwrite directory same node for local copy. Program exiting\n");
		 return 1;
	 }

 }

// Create COSERVERINFO structs used for DCOM connection to source and
// target servers
  pServerInfoSource = CreateServerInfoStruct(bstrSourceServer,bstrRemoteUserName,bstrDomainName,
	  bstrRemoteUserPass,RPC_C_AUTHN_LEVEL_CONNECT);
  ATLASSERT( pServerInfoSource );

  pServerInfoTarget = CreateServerInfoStruct(L"localhost",NULL,NULL,NULL,0,false);
  ATLASSERT( pServerInfoTarget );


  // check if user can connect and open a metabase key on the source machine
  if( !AUTHUSER(pServerInfoSource) )
  {
	  fwprintf(stderr,L"could not open metabase on server %s. Program exiting\n",
		  pServerInfoSource->pwszName );
	  return 1;
  }

    // check if user can connect and open a metabase key on the target machine
  if( !AUTHUSER(pServerInfoTarget) )
  {
	  fwprintf(stderr,L"could not open metabase on server %s. Program exiting\n",
		  pServerInfoTarget->pwszName );
	  goto cleanup;
  }

  // Check to see if the node is of type IIsWebServer
  if( !ValidateNode(pServerInfoSource,bstrSourceNode,L"IIsWebServer") )
  {
	  fwprintf(stderr,L"source key %s must be of type IIsWebServer. Program exiting\n",
		  bstrSourceNode );
	  goto cleanup;
  }
	 
  if( bIsLocal && (bstrTargetDir.length() < 1) )
		fwprintf(stderr,L"skipping content copy for local copy\n");
  
  else
	{
	    if( bUsesImpersonation )  // use "net use" command to connect to the remote comupter so Admin shares can
								  // be used
			if ( ERROR_SUCCESS != NET(bstrSourceServer,bstrRemoteUserName,bstrRemoteUserPass) )
				{
					_tprintf( _T("Error encountered in NET USE operation\n") );
					goto cleanup;
				
				}
		
        // if bCopyContent parameter is true, then this function will actually copy the content
		// otherwise it just builds a TaskItemList of nodes that will need their Path parameter reset
		CopyContent(pServerInfoSource,bstrSourceNode + _bstr_t(L"/root"),bstrTargetDir,
			&pListItem, bCopyContent );
	}
 

  
  // bstrTarget node will be returned with the target node of the target, if it is passed in as blank.
  hRes = CopyIISConfig(pServerInfoSource,pServerInfoTarget,bstrSourceNode,bstrTargetNode);

  if( !SUCCEEDED(hRes) )
  {
	  fwprintf(stderr,L"Error encountered with metabase copy. HRESULT = %x\n",hRes);
	  goto cleanup;
  }

  hRes = ApplyMBFixUp(pServerInfoTarget,bstrTargetNode,bstrAppPoolID,
	 pListItem, bstrServerBindings, true );

  _tprintf(_T("finished.\n") );
  

cleanup:

FreeServerInfoStruct(pServerInfoSource);
FreeServerInfoStruct(pServerInfoTarget);
FreeXCOPYTaskList(pListItem);
  
CoUninitialize();
  
  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\movesite\util.cpp ===
#define _WIN32_DCOM

#include "util.h"
#include <atlbase.h>
#include <initguid.h>
#include <comdef.h>

#include <stdlib.h>
#include <stdio.h>
#include <wchar.h>

#include <iiscnfg.h>  // MD_ & IIS_MD_ #defines header file.

#include "common.h"  // log file routines
#include "filecopy.h"

#define BUFFER_SIZE 255
#define CHUNK_SIZE 4098




DWORD GetKeyNameFromPath(const WCHAR *pMBPath, WCHAR *pName, DWORD dwSize)
{

	ATLASSERT(pMBPath);
	ATLASSERT(pName);

	DWORD dwLen = wcslen(pMBPath);
	DWORD pos = 0;
	ZeroMemory(pName,dwSize);
	for(DWORD i = dwLen-1; i >= 0; i--)
	{
		if( pMBPath[i] == '/' )
			break;
	}

	for( i = i+1; i < dwLen; i++ )
		pName[pos++] = pMBPath[i];


	return ERROR_SUCCESS;
}

long GetAvailableSiteID(IMSAdminBase* pIMeta, METADATA_HANDLE hRootKey)
{
	DWORD indx = 0;
	WCHAR SubKeyName[MAX_PATH*2];
	HRESULT hRes = 0;
	WCHAR KeyType[256];
	long siteID = -1;

	while (SUCCEEDED(hRes)){ 
		hRes = pIMeta->EnumKeys(hRootKey, L"/W3SVC", SubKeyName, indx); 
		if(SUCCEEDED(hRes)) {
			
			GetKeyTypeProperty(pIMeta,hRootKey,_bstr_t(L"/W3SVC/") + _bstr_t(SubKeyName),KeyType,256);
			
			if( _wcsicmp(KeyType,L"IIsWebServer") == 0 )
			{
				
				siteID = _wtol(SubKeyName);

				//wprintf(L"%s %s\n",SubKeyName,KeyType);
			}
			 // Increment the index. 
		}
    	indx++; 
	}
	siteID++;
	//wprintf(L"new site ID %d\n", siteID);
	return siteID;
}


BOOL IsKeyType(IMSAdminBase* pIMeta, METADATA_HANDLE hKey, wchar_t * pwszPath, wchar_t * key)
{

	HRESULT hRes = 0;
	WCHAR KeyType[256];		
	hRes = GetKeyTypeProperty(pIMeta,hKey,pwszPath,KeyType,256);
	if( _wcsicmp(KeyType,key) == 0 )
			{
				
				return true;
	
			}
	return false;
}




// Function to return the key type property of an hKey
// 1002 is metabase ID code for KeyType property
HRESULT GetKeyTypeProperty(IMSAdminBase* pIMeta, METADATA_HANDLE hKey, wchar_t * pwszPath, wchar_t *pwszBuffer, DWORD dwMDDataLen )
{
	
	HRESULT hRes;
	METADATA_RECORD mRec;
	DWORD dwReqBufLen = 0; 
	DWORD dwBufLen = BUFFER_SIZE;
    PBYTE pbBuffer = new BYTE[dwBufLen];

	if( !pIMeta || !hKey || !pwszPath)
		return E_UNEXPECTED;

	// this is the property for keytype
	mRec.dwMDIdentifier = 1002;
	mRec.dwMDAttributes = METADATA_INSERT_PATH;
    mRec.dwMDUserType = ALL_METADATA; //IIS_MD_UT_FILE ; 
    mRec.dwMDDataType = ALL_METADATA; 
    mRec.dwMDDataLen = dwBufLen; 
    mRec.pbMDData = pbBuffer; 

	// Open the key, if the key fails return false
	hRes = pIMeta->GetData(hKey, pwszPath, &mRec, &dwReqBufLen); 

	if( !SUCCEEDED(hRes) )
		return hRes;

	wcscpy(pwszBuffer,(WCHAR *)mRec.pbMDData);
	//wprintf(L"The keytype property is: %s\n", pwszBuffer);
	return hRes;

}


// Generic wrapper to read property data
HRESULT GetPropertyData(IMSAdminBase* pIMeta, METADATA_HANDLE hKey, wchar_t *pwszMDPath,
			DWORD dwMDIdentifier, DWORD dwMDAttributes, DWORD dwMDUserType, DWORD dwMDDataType, 
			VOID * pData, DWORD *dwReqBufLen)
{

	METADATA_RECORD mRec;
	ATLASSERT(pIMeta);
	if( !pIMeta )
		return E_UNEXPECTED;

	mRec.dwMDIdentifier = dwMDIdentifier;
	mRec.dwMDAttributes = dwMDAttributes;
    mRec.dwMDUserType = dwMDUserType; 
    mRec.dwMDDataType = dwMDDataType; 
    mRec.dwMDDataLen = *dwReqBufLen; 
    mRec.pbMDData = (PBYTE)pData; 

	return pIMeta->GetData(hKey, pwszMDPath, &mRec, dwReqBufLen);

}

// Generic wrapper to write property data
HRESULT SetPropertyData(IMSAdminBase* pIMeta, METADATA_HANDLE hKey, wchar_t *pwszMDPath,
			DWORD dwMDIdentifier, DWORD dwMDAttributes, DWORD dwMDUserType,
			DWORD dwMDDataType, VOID * pData, DWORD dwDataLen)
{
	HRESULT hRes = S_OK;
	METADATA_RECORD mRec;

	ATLASSERT( pIMeta );

	mRec.dwMDIdentifier = dwMDIdentifier;
	mRec.dwMDAttributes = dwMDAttributes;
	mRec.dwMDUserType = dwMDUserType;
	mRec.dwMDDataType = dwMDDataType;
	mRec.pbMDData =  (PBYTE)pData;
	mRec.dwMDDataLen = dwDataLen;

	return pIMeta->SetData(hKey, pwszMDPath, &mRec);

}

DWORD MyCreateProcess( LPTSTR appName, LPTSTR cmdLine, DWORD dwCreationFlags, DWORD dwTimeOut )
{
	STARTUPINFO si = {0};
	si.cb = sizeof( si );

	PROCESS_INFORMATION pi = {0};

	bstr_t cApplicationName( appName );

	bstr_t cCommandLine( cApplicationName);
	//cCommandLine += ( TEXT(" ") );
	cCommandLine = cmdLine;

	Log( TEXT("executing: %s"), (char*)cCommandLine );
	
	BOOL bOK = CreateProcess( 
		(char*)cApplicationName,	//  LPCTSTR lpApplicationName,                 // name of executable module
		(char*) cCommandLine,	//  LPTSTR lpCommandLine,                      // command line string
		NULL,					//  LPSECURITY_ATTRIBUTES lpProcessAttributes, // SD
		NULL,					//  LPSECURITY_ATTRIBUTES lpThreadAttributes,  // SD
		NULL,					//  BOOL bInheritHandles,                      // handle inheritance option
		dwCreationFlags,		//  DWORD dwCreationFlags,                     // creation flags
		NULL,					//  LPVOID lpEnvironment,                      // new environment block
		NULL,					//  LPCTSTR lpCurrentDirectory,                // current directory name
		&si,					//  LPSTARTUPINFO lpStartupInfo,               // startup information
		&pi );					//  LPPROCESS_INFORMATION lpProcessInformation // process information

	if( !bOK )
	{
		Log( TEXT( "FAIL: CreateProcess() failed, error code=%d" ), GetLastError() );
		return GetLastError();
	}

	DWORD dwRet = WaitForSingleObject( pi.hProcess, dwTimeOut );

	if( dwRet == WAIT_TIMEOUT )
	{
		Log( TEXT( "FAIL: CreateProcess() timed out" ) );
		return ERROR_SEM_TIMEOUT;
	}
	else if( dwRet == WAIT_ABANDONED )
	{
		Log( TEXT( "FAIL: WaitForSingleObject() failed on WAIT_ABANDONED" ) );
		return ERROR_SEM_TIMEOUT;
	}
	else if( dwRet == WAIT_FAILED )
	{
		LogError( TEXT( "FAIL: WaitForSingleObject() failed" ), GetLastError() );
		return GetLastError();
	}

	DWORD dwExitCode = 0;
	if( GetExitCodeProcess( pi.hProcess, &dwExitCode ) )
	{
		if( dwExitCode )
		{
			Log( TEXT( "FAIL: net.exe() threw an error=%d" ), dwExitCode );
			return dwExitCode;
		}
		else
		{
			Log( TEXT( "CreateProcess() succeeded" ) );
		}
	}
	else
	{
		LogError( TEXT( "GetExitCodeProcess()" ), GetLastError() );
		return GetLastError();
	}

	return ERROR_SUCCESS;
}



DWORD NET(WCHAR* device, WCHAR* user, WCHAR* password)
{
	STARTUPINFO si = {0};
	si.cb = sizeof( si );

	PROCESS_INFORMATION pi = {0};
	
	TCHAR szSystemFolder[ MAX_PATH ];
	
	if( 0 == GetSystemDirectory( szSystemFolder, MAX_PATH ) )
	{
		return GetLastError();
	}

	bstr_t cApplicationName( szSystemFolder );
	cApplicationName += ( TEXT( "\\net.exe" ) );

	bstr_t cCommandLine( cApplicationName);
	cCommandLine += ( TEXT(" use \\\\") );
	cCommandLine += device;
	cCommandLine += ( TEXT(" /user:") );
	cCommandLine += user;
	cCommandLine += ( TEXT(" ") );
	cCommandLine += password;

	Log( TEXT("executing: %s"), (char*)cCommandLine );
	
	BOOL bOK = CreateProcess( 
		(char*)cApplicationName,	//  LPCTSTR lpApplicationName,                 // name of executable module
		(char*) cCommandLine,	//  LPTSTR lpCommandLine,                      // command line string
		NULL,					//  LPSECURITY_ATTRIBUTES lpProcessAttributes, // SD
		NULL,					//  LPSECURITY_ATTRIBUTES lpThreadAttributes,  // SD
		NULL,					//  BOOL bInheritHandles,                      // handle inheritance option
		CREATE_NEW_PROCESS_GROUP,		//  DWORD dwCreationFlags,                     // creation flags
		NULL,					//  LPVOID lpEnvironment,                      // new environment block
		NULL,					//  LPCTSTR lpCurrentDirectory,                // current directory name
		&si,					//  LPSTARTUPINFO lpStartupInfo,               // startup information
		&pi );					//  LPPROCESS_INFORMATION lpProcessInformation // process information

	if( !bOK )
	{
		Log( TEXT( "FAIL: CreateProcess() failed, error code=%d" ), GetLastError() );
		return GetLastError();
	}

	DWORD dwRet = WaitForSingleObject( pi.hProcess, 15000 );

	if( dwRet == WAIT_TIMEOUT )
	{
		Log( TEXT( "FAIL: CreateProcess() timed out" ) );
		return ERROR_SEM_TIMEOUT;
	}
	else if( dwRet == WAIT_ABANDONED )
	{
		Log( TEXT( "FAIL: WaitForSingleObject() failed on WAIT_ABANDONED" ) );
		return ERROR_SEM_TIMEOUT;
	}
	else if( dwRet == WAIT_FAILED )
	{
		LogError( TEXT( "FAIL: WaitForSingleObject() failed" ), GetLastError() );
		return GetLastError();
	}

	DWORD dwExitCode = 0;
	if( GetExitCodeProcess( pi.hProcess, &dwExitCode ) )
	{
		if( dwExitCode )
		{
			Log( TEXT( "FAIL: net.exe() threw an error=%d" ), dwExitCode );
			return dwExitCode;
		}
		else
		{
			Log( TEXT( "CreateProcess() succeeded" ) );
		}
	}
	else
	{
		LogError( TEXT( "GetExitCodeProcess()" ), GetLastError() );
		return GetLastError();
	}

	return ERROR_SUCCESS;
}



BOOL
IsServerLocal(
    IN LPCTSTR lpszServer
    )
/*++

Routine Description:

    Check to see if the given name refers to the local machine

Arguments:

    LPCTSTR lpszServer   : Server name

Return Value:

    TRUE if the given name refers to the local computer, FALSE otherwise

Note:

    Doesn't work if the server is an ip address

--*/
{
    TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwSize = sizeof(szComputerName);

    //
    // CODEWORK(?): we're not checking for all the ip addresses
    //              on the local box or full dns names.
    //
    //              Try GetComputerNameEx when we're building with NT5 
    //              settings.
    //
    return (!_tcsicmp(_T("localhost"), PURE_COMPUTER_NAME(lpszServer))
         || !_tcscmp( _T("127.0.0.1"), PURE_COMPUTER_NAME(lpszServer)))
         || (GetComputerName(szComputerName, &dwSize) 
             && !_tcsicmp(szComputerName, PURE_COMPUTER_NAME(lpszServer)));
}

 HRESULT SetBlanket(LPUNKNOWN pIUnk, WCHAR* user, WCHAR* domain, WCHAR* password)
{
  
	SEC_WINNT_AUTH_IDENTITY_W* pAuthIdentity = 
   new SEC_WINNT_AUTH_IDENTITY_W;
ZeroMemory(pAuthIdentity, sizeof(SEC_WINNT_AUTH_IDENTITY_W) );

if( !pIUnk || !user )
	return E_UNEXPECTED;


pAuthIdentity->User = new WCHAR[32];
wcscpy(pAuthIdentity->User , user);
pAuthIdentity->UserLength = wcslen(pAuthIdentity->User );

if( domain )
{
	pAuthIdentity-> Domain = new WCHAR[32];
	wcscpy(pAuthIdentity->Domain, domain );
	pAuthIdentity->DomainLength = wcslen( pAuthIdentity->Domain);
}

if( password )
{
	pAuthIdentity-> Password = new WCHAR[32];
	pAuthIdentity->Password = password;
	pAuthIdentity->PasswordLength = wcslen( pAuthIdentity->Password );
}

pAuthIdentity->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;


  return CoSetProxyBlanket( pIUnk,
                            RPC_C_AUTHN_WINNT,    // NTLM authentication service
                            RPC_C_AUTHZ_NONE,     // default authorization service...
                            NULL,                 // no mutual authentication
                            RPC_C_AUTHN_LEVEL_DEFAULT,      // authentication level
                            RPC_C_IMP_LEVEL_IMPERSONATE,    // impersonation level
                            pAuthIdentity,                 // use current token
                            EOAC_NONE );          // no special capabilities    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\movesite\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__FFD5913D_C222_449E_BAD2_BBD16EC43268__INCLUDED_)
#define AFX_STDAFX_H__FFD5913D_C222_449E_BAD2_BBD16EC43268__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <atlbase.h>
//#include <atlcom.h>
// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__FFD5913D_C222_449E_BAD2_BBD16EC43268__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\movesite\util.h ===
#ifndef __METAEXP_UTIL__
#define __METAEXP_UTIL__

#include <atlbase.h>
#include <initguid.h>
#include <comdef.h>

#include <iadmw.h>  // COM Interface header file. 
#include "common.h"




#define IS_NETBIOS_NAME(lpstr) (*lpstr == _T('\\'))
//
// Return the portion of a computer name without the backslashes
//
#define PURE_COMPUTER_NAME(lpstr) (IS_NETBIOS_NAME(lpstr) ? lpstr + 2 : lpstr)

DWORD GetKeyNameFromPath(const WCHAR *pMBPath, WCHAR *pName, DWORD dwSize);
	
HRESULT SetBlanket(LPUNKNOWN pIUnk, WCHAR* user, WCHAR* domain, WCHAR* password);
BOOL IsKeyType(IMSAdminBase* pIMeta, METADATA_HANDLE hKey, 
			   wchar_t * pwszPath, wchar_t * key);

HRESULT GetKeyTypeProperty(IMSAdminBase* pIMeta, METADATA_HANDLE hKey, wchar_t * pwszPath, wchar_t *pwszBuffer, DWORD dwMDDataLen );

long GetAvailableSiteID(IMSAdminBase* pIMeta, METADATA_HANDLE hRootKey);

DWORD NET(WCHAR* device, WCHAR* user, WCHAR* password);

HRESULT SetPropertyData(IMSAdminBase* pIMeta, METADATA_HANDLE hKey, wchar_t *pwszMDPath,
			DWORD dwMDIdentifier, DWORD dwMDAttributes, DWORD dwMDUserType, DWORD dwMDDataType, 
			VOID * pData, DWORD dwDataLen);

HRESULT GetPropertyData(IMSAdminBase* pIMeta, METADATA_HANDLE hKey, wchar_t *pwszMDPath,
			DWORD dwMDIdentifier, DWORD dwMDAttributes, DWORD dwMDUserType, DWORD dwMDDataType, VOID * pData, DWORD *dwDataBuf);

DWORD MyCreateProcess( LPTSTR appName, LPTSTR cmdLine, DWORD dwCreationFlags, DWORD dwTimeOut );

BOOL IsServerLocal(
    IN LPCTSTR lpszServer
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\schemagen\xformer.cs ===
using System;

namespace xmlXformer
{
	using System.Xml;
	using System.Collections;
	using System.IO;

	class Record : IComparable
	{
		public int _id;
		public string _name;
		public string _type;
		public string _userType;
		public string _attr;
		public string _flagsEx;

		public Record()
		{
			_id = 0;
		}

		public int CompareTo(object a)
		{
			Record t = (Record)a;
			return this._id - t._id;
		}

		public string AttributeString()
		{
			if (_attr == null)
			{
				return "METADATA_NO_ATTRIBUTES";
			}
			else
			{
				char[] delim = { '|' };
				char[] whitespace = { ' ' };
				string[] subAttr = _attr.Split(delim);
				string temp = "METADATA_";
				for (int i = 0; i < subAttr.Length; i++)
				{
					if (i > 0)
					{
						temp = temp + " | METADATA_";
					}
					temp = temp + subAttr[i].Trim(whitespace);
				}
				return temp;
			}
		}
		public string ResourceID()
		{
			if (isHidden())
			{
				return "0 /* " + _name + " */";
			}
			else
			{
				string temp = "IDS_" + _name;
				return temp;
			}
		}
		public string MetadataType()
		{
			string temp;
			if (_type == "NTACL" || _type == "IPSECLIST")
				_type = "BINARY";
			else if (_type == "BOOL")
				_type = "DWORD";
			else if (_type == "MIMEMAP")
				_type = "MULTISZ";
			temp = _type + "_METADATA";
			return temp;
		}
		public bool isHidden()
		{
			return _flagsEx == "HIDDEN";
		}
	}

	/// <summary>
	/// Summary description for XFormer.
	/// </summary>
	class XFormer
	{
		const int cutoff_id = 10000;

		static void Main(string[] args)
		{
			bool found = false;
			bool in_prop = false;
			string fileName;
			int last_id = cutoff_id;
			if (args.Length == 0)
			{
				Console.WriteLine("Usage:\r\nschemagen <path to IISMeta.xml> <biggest meta id, default = 10000>");
				return;
			}
			fileName = args[0];
			if (args.Length > 1)
			{
				last_id = int.Parse(args[1]);
			}

			XmlTextReader rdr = new XmlTextReader(fileName);
			ArrayList list = new ArrayList();

			while (rdr.Read())
			{
				if (rdr.NodeType != XmlNodeType.Element)
					continue;
				if (rdr.Name == "Collection" && rdr.HasAttributes)
				{
					if (!found)
					{
						for (int i = 0; i < rdr.AttributeCount; i++)
						{
							rdr.MoveToAttribute(i);
							if (rdr.Name == "InternalName" && rdr.Value == "IIsConfigObject")
							{
								found = true;
								break;
							}
						}
						rdr.MoveToElement();
					}
					else if (in_prop)
					{
						break;
					}
				}
				else if (rdr.Name == "Property")
				{
					if (found)
					{
						Record rec = new Record();
						for (int i = 0; i < rdr.AttributeCount; i++)
						{
							rdr.MoveToAttribute(i);
							if (rdr.Name == "InternalName")
							{
								rec._name = rdr.Value;
							}
							else if (rdr.Name == "ID")
							{
								rec._id = int.Parse(rdr.Value);
							}
							else if (rdr.Name == "Type")
							{
								rec._type = rdr.Value;
							}
							else if (rdr.Name == "UserType")
							{
								rec._userType = rdr.Value;
							}
							else if (rdr.Name == "Attributes")
							{
								rec._attr = rdr.Value;
							}
							else if (rdr.Name == "MetaFlagsEx")
							{
								rec._flagsEx = rdr.Value;
							}
						}
						rdr.MoveToElement();
						if (rec._id != 0)
						{
							list.Add(rec);
						}
					}
				}
			}
			if (list.Count > 0)
			{
				FileInfo f1 = new FileInfo("mbschema.cpp");
				StreamWriter mdkeys = f1.CreateText();
				FileInfo f2 = new FileInfo("mbschema.rc");
				StreamWriter rc = f2.CreateText();
				FileInfo f3 = new FileInfo("mbschema.h");
				StreamWriter res = f3.CreateText();
				int res_base = 60000;

				mdkeys.WriteLine("//");
				mdkeys.WriteLine("// This is computer generated code");
				mdkeys.WriteLine("// please don't edit it manually.");
				mdkeys.WriteLine("//");
				mdkeys.WriteLine("#include \"stdafx.h\"");
				mdkeys.WriteLine("#include \"common.h\"");
				mdkeys.WriteLine("#include <iiscnfg.h>");
				mdkeys.WriteLine("#include \"mdkeys.h\"");
				mdkeys.WriteLine("#include \"mbschema.h\"");
				mdkeys.WriteLine("");
				mdkeys.WriteLine("const CMetaKey::MDFIELDDEF CMetaKey::s_rgMetaTable[] =");
				mdkeys.WriteLine("{");

				rc.WriteLine("//");
				rc.WriteLine("// This is computer generated code");
				rc.WriteLine("// please don't edit it manually.");
				rc.WriteLine("//");
				rc.WriteLine("#include \"mbschema.h\"");
				rc.WriteLine("");
				rc.WriteLine("STRINGTABLE DISCARDABLE");
				rc.WriteLine("BEGIN");

				res.WriteLine("//");
				res.WriteLine("// This is computer generated code");
				res.WriteLine("// please don't edit it manually.");
				res.WriteLine("//");
				res.WriteLine("#ifndef IDS_MD_BEGIN_TABLE");
				res.WriteLine("#define IDS_MD_BEGIN_TABLE\t" + res_base);
				res.WriteLine("#endif\n");

				list.Sort();

				int prev_id = 0;

				for (int i = 0; i < list.Count; i++)
				{
					Record rec = (Record)list[i];
					if (rec._id > last_id)
					{
						break;
					}
					if (rec._id == prev_id)
					{
						continue;
					}
					mdkeys.Write("\t{ ");
					mdkeys.Write("{0}, {1}, {2}, {3}, {4}",
						rec._id, 
						rec.AttributeString(),
						rec._userType, 
						rec.MetadataType(), 
						rec.ResourceID());
					mdkeys.WriteLine(" },");

					if (!rec.isHidden())
					{
						rc.WriteLine("\t{0}\t{1}", rec.ResourceID().PadRight(40, ' '), '"' + rec._name + '"');
						res.Write("#define " + rec.ResourceID().PadRight(40, ' '));
						res.WriteLine("(IDS_MD_BEGIN_TABLE+{0})", i);
					}
					prev_id = rec._id;
				}
				mdkeys.WriteLine("};");
				mdkeys.WriteLine("");
				mdkeys.WriteLine("const int CMetaKey::s_MetaTableSize = sizeof(CMetaKey::s_rgMetaTable) / sizeof(CMetaKey::s_rgMetaTable[0]);");
				mdkeys.WriteLine("");

				rc.WriteLine("END");

				mdkeys.Close();
				rc.Close();
				res.Close();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\sco\iisscov50\iissco50.h ===
// IISSCO50.h : Declaration of the CIISSCO50

#ifndef __IISSCO50_H_
#define __IISSCO50_H_

#include "resource.h"       // main symbols

#include <map>              // Used for enum property key value pairs
#include <string>           // Used in parseBSTR and AddBackSlashesToString
using namespace std;

typedef map<CComBSTR,CComBSTR> Map;

enum IIsAction { start, stop, pause };  // Actions related to start/stopping webs


/////////////////////////////////////////////////////////////////////////////
// CIISSCO50
class ATL_NO_VTABLE CIISSCO50 : 
    public CComCoClass<CIISSCO50, &CLSID_IISSCO50>,
    public CProvProviderBase<&LIBID_IISSCOV50Lib>
{
public:

    //Declarations of functions for EnumConfigRecursive Action
    HRESULT EnumConfigRecursive_Execute(IXMLDOMNode *pXMLNode);

    //Declarations of functions for EnumConfigRecursive Action
    //HRESULT EnumConfigRecursive_Execute(IXMLDOMNode *pXMLNode);

    //Declarations of functions for EnumConfig Action
    HRESULT EnumConfig_Execute(IXMLDOMNode *pXMLNode);

    //Declarations of functions for GetConfigProperty Action
    HRESULT GetConfigProperty_Execute(IXMLDOMNode *pXMLNode);

    //Declarations of functions for SetConfigProperty Action
    HRESULT SetConfigProperty_Execute(IXMLDOMNode *pXMLNode);
    HRESULT SetConfigProperty_Rollback(IXMLDOMNode *pXMLNode);

    //Declarations of functions for DeleteVDir Action
    HRESULT DeleteVDir_Execute(IXMLDOMNode *pXMLNode);
    HRESULT DeleteVDir_Rollback(IXMLDOMNode *pXMLNode);

    //Declarations of functions for CreateVDir Action
    HRESULT CreateVDir_Execute(IXMLDOMNode *pXMLNode);
    HRESULT CreateVDir_Rollback(IXMLDOMNode *pXMLNode);

    //Declarations of functions for DeleteFTPSite Action
    HRESULT DeleteFTPSite_Execute(IXMLDOMNode *pXMLNode);
    HRESULT DeleteFTPSite_Rollback(IXMLDOMNode *pXMLNode);

    //Declarations of functions for CreateFTPSite Action
    HRESULT CreateFTPSite_Execute(IXMLDOMNode *pXMLNode);
    HRESULT CreateFTPSite_Rollback(IXMLDOMNode *pXMLNode);

    //Declarations of functions for DeleteWebSite Action
    HRESULT DeleteWebSite_Execute(IXMLDOMNode *pXMLNode);
    HRESULT DeleteWebSite_Rollback(IXMLDOMNode *pXMLNode);

    //Declarations of functions for CreateWebSite Action
    HRESULT CreateWebSite_Execute(IXMLDOMNode *pXMLNode);
    HRESULT CreateWebSite_Rollback(IXMLDOMNode *pXMLNode);

DECLARE_REGISTRY_RESOURCEID(IDR_IISSCO50)

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CIISSCO50)
    COM_INTERFACE_ENTRY(IProvProvider)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

HRESULT FinalConstruct();

//Mapping Action/Rollback to NameSpaces.
BEGIN_ACTION_MAP(CIISSCO50)
//
    ACTION_MAP_ENTRY_NOROLLBACK("EnumConfigRecursive", EnumConfigRecursive_Execute)
    ACTION_MAP_ENTRY_NOROLLBACK("EnumConfig", EnumConfig_Execute)
    ACTION_MAP_ENTRY_NOROLLBACK("GetConfigProperty", GetConfigProperty_Execute)
    ACTION_MAP_ENTRY("SetConfigProperty", SetConfigProperty_Execute, SetConfigProperty_Rollback)
    ACTION_MAP_ENTRY("DeleteVDir", DeleteVDir_Execute, DeleteVDir_Rollback)
    ACTION_MAP_ENTRY("CreateVDir", CreateVDir_Execute, CreateVDir_Rollback)
    ACTION_MAP_ENTRY("DeleteFTPSite", DeleteFTPSite_Execute, DeleteFTPSite_Rollback)
    ACTION_MAP_ENTRY("CreateFTPSite", CreateFTPSite_Execute, CreateFTPSite_Rollback)
    ACTION_MAP_ENTRY("DeleteWebSite", DeleteWebSite_Execute, DeleteWebSite_Rollback)
    ACTION_MAP_ENTRY("CreateWebSite", CreateWebSite_Execute, CreateWebSite_Rollback)
//    ACTION_MAP_ENTRY("SignupUser", Action1, Rollback1)
//    ACTION_MAP_ENTRY_NOROLLBACK("UnsubscribeUser", Action2)
//    ACTION_MAP_ENTRY_TWOPHASE("CreateOrg", Action3, Rollback3, Prepare3,
//                               Commit3)
END_ACTION_MAP()


private:
	// Used with IIsScoLogFailure(failstring) macro
	HINSTANCE g_ErrorModule;

    // adsi helper methods used by SCO action handlers
    HRESULT GetMetaPropertyValue(CComPtr<IADs> pADs, CComBSTR bstrName, CComBSTR& pVal);
    HRESULT SetMetaPropertyValue(CComPtr<IADs> pADs, CComBSTR bstrName, CComBSTR bstrValue);
    HRESULT DeleteMetaPropertyValue(CComPtr<IADs> pADs, CComBSTR bstrName);

	HRESULT CreateIIs50Site(CComBSTR bstrType,CComBSTR bADsPath, 
			                    CComBSTR bServerNumber, CComBSTR &bstrConfigPath);
    HRESULT DeleteIIs50Site(CComBSTR bstrType,CComBSTR bADsPath,CComBSTR bServerNumber);

    HRESULT CreateIIs50VDir(CComBSTR bstrType,CComBSTR bADsPath, CComBSTR bVDirName,
			                    CComBSTR bAppFriendName, CComBSTR bVDirPath,CComBSTR &bstrConfigPath);
    HRESULT DeleteIIs50VDir(CComBSTR bstrType,CComBSTR bADsPath,CComBSTR bVDirName);
    HRESULT SetVDirProperty(CComPtr<IADs> pADs, CComBSTR bVDirProperty,CComBSTR bVDirValue);

	HRESULT EnumPropertyValue(CComBSTR bstrPath, CComBSTR bstrIsInHerit, Map& mVar);
    HRESULT EnumPaths(BOOL bRecursive, CComBSTR bstrPath, Map& mVar);
    BOOL EnumIsSet(CComPtr<IISBaseObject> pBase, CComBSTR bstrPath, CComBSTR bstrProperty);


	// misc adsi helper methods
	HRESULT IIsServerAction(CComBSTR bADsPath,IIsAction action);

    HRESULT ParseBSTR(CComBSTR bString,CComBSTR sDelim, int iFirstPiece, int iLastPiece,CComBSTR &pVal);

    void AddBackSlashesToString(CComBSTR& bString);

    HRESULT GetNextIndex(CComBSTR bstrPath, CComBSTR& pIndex);

    HRESULT CheckBindings(CComBSTR bADsPath, CComBSTR bstrNewBindings);

    HRESULT CreateBindingString(CComBSTR bstrIP,CComBSTR bstrPort, 
			                   CComBSTR bstrHostName,CComBSTR& bstrString);

	BOOL IsPositiveInteger(CComBSTR bstrPort);
	BOOL StringCompare(CComBSTR bstrString1, CComBSTR bstrString2);
	int NumberOfDelims(CComBSTR& bString, CComBSTR sDelim);

	// xml helper methods used by SCO action handlers above
    HRESULT GetInputParam(CComPtr<IXMLDOMNode> pNode, CComBSTR elementName, CComBSTR& pVal);
    HRESULT GetInputAttr(CComPtr<IXMLDOMNode> pNode, CComBSTR elementName, CComBSTR AttributeName, CComBSTR& pVal);
    HRESULT PutElement(CComPtr<IXMLDOMNode> pNode, CComBSTR elementName, CComBSTR newVal);
    HRESULT AppendElement(CComPtr<IXMLDOMNode> pNode, CComBSTR xmlString,CComPtr<IXMLDOMNode>& pNewNode);
    HRESULT GetNodeLength(CComPtr<IXMLDOMNode> pTopNode, CComBSTR elementName, long *lLength);
    HRESULT GetElementValueByAttribute(CComPtr<IXMLDOMNode> pTopNode,CComBSTR elementName, 
		                               CComBSTR attributeName, CComBSTR& pVal);

};

#endif //__IISSCO50_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\sco\iisscov50\iisscov50.cpp ===
// IISSCOv50.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f SCOTestps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "IISSCOv50.h"

#include "IISSCOv50_i.c"
#include "IISSCO50.h"

CComModule _Module;


BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_IISSCO50, CIISSCO50)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_IISSCOV50Lib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
    }

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{

    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
	//hr = _Module.RegisterServer(TRUE);


}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\sco\iisscov50\iisscov50.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0280 */
/* at Fri Aug 24 09:39:49 2001
 */
/* Compiler settings for D:\IIS\IIS Hosting Kit\Russ\IIS5SCO\IISSCOv50\IISSCOv50.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __IISSCOv50_h__
#define __IISSCOv50_h__

/* Forward Declarations */ 

#ifndef __IISSCO50_FWD_DEFINED__
#define __IISSCO50_FWD_DEFINED__

#ifdef __cplusplus
typedef class IISSCO50 IISSCO50;
#else
typedef struct IISSCO50 IISSCO50;
#endif /* __cplusplus */

#endif 	/* __IISSCO50_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "Provisioning.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __IISSCOV50Lib_LIBRARY_DEFINED__
#define __IISSCOV50Lib_LIBRARY_DEFINED__

/* library IISSCOV50Lib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_IISSCOV50Lib;

EXTERN_C const CLSID CLSID_IISSCO50;

#ifdef __cplusplus

class DECLSPEC_UUID("B83A63A9-7132-49EA-B6F2-A454E5F37A41")
IISSCO50;
#endif
#endif /* __IISSCOV50Lib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\sco\iisscov50\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\sco\iisscov50\iissco50.cpp ===
//***************************************************************
// IISSCO50.cpp : Implementation of CIISSCO50
// Author:    Russ Gibfried
//***************************************************************

#include "stdafx.h"
#include "IISSCOv50.h"
#include "IISSCO50.h"

#include "macrohelpers.h"

#include "MessageFile\message.h"


/////////////////////////////////////////////////////////////////////////////
// CIISSCO50
// Provider Action handlers should be implemented here with the following prototypes:
//		HRESULT CIISSCO50::Action();
//		HRESULT CIISSCO50::ActionRollback();

HRESULT CIISSCO50::FinalConstruct( )
{
    HRESULT hr = S_OK;

    LONG lRes;
    HKEY hkey = NULL;
	WCHAR szLibReg[1024];
    DWORD dwPathSize = 0;

    // Open the registry key where IISScoMessageFile.dll (in EventLog)  
	lRes = RegOpenKeyEx( HKEY_LOCAL_MACHINE , 
		                 L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\IISSCOv50",
						 0, KEY_ALL_ACCESS, &hkey );

	if (lRes != ERROR_SUCCESS)
		goto LocalCleanup;

	// Get the Path size of EventMessageFile.  
   lRes = RegQueryValueEx( hkey, L"EventMessageFile", NULL, 
		                    NULL, NULL, &dwPathSize );

	if (lRes != ERROR_SUCCESS)
		goto LocalCleanup;

    // Get the value of EventMessageFile.  This is set when IISScoMessageFile.dll is registered
    lRes = RegQueryValueEx( hkey, L"EventMessageFile", NULL, 
		                    NULL, (LPBYTE)szLibReg, &dwPathSize );

	if (lRes != ERROR_SUCCESS)
		goto LocalCleanup;

     RegCloseKey( hkey );

     g_ErrorModule = LoadLibrary( szLibReg );

     if (g_ErrorModule == NULL)
     {
        hr = E_OUTOFMEMORY;
     }

	return hr;

LocalCleanup:

    RegCloseKey( hkey );
    return E_FAIL; 
}


///////////////////////////////////////////////////////////////////////////////
//  CIISSCO50::CreateWebSite_Execute
// Author:    Russ Gibfried
// Params:    [in]  none
//            [out] none
// Purpose:   Called by MAPS framework when is encounters an action
//            tag: CreateWebSite.  Code creates and IIS 5 web site
//             
//------------------------------------------------------------- 
HRESULT  CIISSCO50::CreateWebSite_Execute( IXMLDOMNode *pXMLNode )
{

    TRACE_ENTER(L"CIISSCO50::CreateWebSite");

	CComBSTR bWebADsPath;       // adsPath:   IIS://server/W3SVC
	CComBSTR bstrRoot;          // root directory path: c:/inetpub
	CComBSTR bstrServer;        // Server name; localhost if black
	CComBSTR bstrSiteName;      // site name; www.mysite.com
	CComBSTR bstrHost;          // Web Hostname
	CComBSTR bstrPort;          // Web port number
	CComBSTR bstrIP;            // Web IP address 
	CComBSTR bstrSBindings;     // Server bindings:  IP:Post:HostName
	CComBSTR bServerNumber;     // WebSite number: 3
	//CComBSTR bFilePermissions;  // File permissions: domain\user:F
	CComBSTR bstrStart;         // Start site when done? TRUE/FALSE
	CComBSTR bstrConfigPath;    // Created sites ADsPath:  /W3SVC/3
	CComPtr<IXMLDOMNode> pNode; // xml node <website>

	HRESULT hr = S_OK;

	// Get node in format: <executeData><Website number=''><Root />...
	hr = pXMLNode->selectSingleNode( L"//executeXml/executeData", &pNode );

	// Debug code to view passed in Node
	CComBSTR bstrDebug;
	hr = pNode->get_xml(&bstrDebug);
	ATLTRACE(_T("\t>>> xml = : %ls\n"), bstrDebug.m_str);


	// Get properties from XML
	hr = GetInputAttr(pNode, L"./Website", L"number", bServerNumber);
	hr = GetInputParam(pNode,L"./Website/Root", bstrRoot);
	hr = GetInputParam(pNode,L"./Website/Server", bstrServer);
    hr = GetInputParam(pNode,L"./Website/SiteName", bstrSiteName);
	hr = GetInputParam(pNode,L"./Website/HostName", bstrHost);
	hr = GetInputParam(pNode,L"./Website/PortNumber", bstrPort);
	hr = GetInputParam(pNode,L"./Website/IPAddress", bstrIP);
	hr = GetInputParam(pNode,L"./Website/StartOnCreate", bstrStart);
	//hr = GetInputParam(pNode,L"./Website/FilePermissions", bFilePermissions);

	// Create a IIS metabase path.  ex. IIS://localhost/W3SVC 
    bWebADsPath = IIS_PREFIX;
	if ( bstrServer.Length() == 0 )
		bstrServer = IIS_LOCALHOST;

	bWebADsPath.AppendBSTR(bstrServer);
	bWebADsPath.Append(IIS_W3SVC);



	// Step .5:  If port number missing, set to default (ie, 80)
	if ( bstrPort.Length() == 0 )
       bstrPort = IIS_DEFAULT_WEB_PORT;

	if ( IsPositiveInteger(bstrPort) )
	{
	
	  // Step 1:  Create the ServerBinding string then check bindings to make sure 
	  //          there is not a duplicate server
	  hr = CreateBindingString(bstrIP, bstrPort, bstrHost, bstrSBindings);

      hr = CheckBindings(bWebADsPath, bstrSBindings);
	  if (SUCCEEDED(hr) )
	  {

		// Step 2:  Get Next available Server Number
		if ( bServerNumber.Length() == 0 )
			  hr = GetNextIndex(bWebADsPath,bServerNumber);

		// Step 3: Create the Web Site on given path, ServerNumber.
		if (SUCCEEDED(hr)) hr = CreateIIs50Site(IIS_IISWEBSERVER,bWebADsPath, bServerNumber, bstrConfigPath);
        IIsScoLogFailure();

		// Step 4: Create a Virtual directory on new IIsWebServer configPath
		if (SUCCEEDED(hr))
		{
			CComBSTR bstrVDirAdsPath;
	        hr = CreateIIs50VDir(IIS_IISWEBVIRTUALDIR,bstrConfigPath,L"ROOT", L"Default Application", bstrRoot, bstrVDirAdsPath);
            IIsScoLogFailure();

			// Step 5: set each property; ie, server bindings

			// Bind to ADs object
			CComPtr<IADs> pADs;
			if (SUCCEEDED(hr)) hr = ADsGetObject(bstrConfigPath, IID_IADs, (void**) &pADs );
			if ( FAILED(hr) )
			{
				hr = E_SCO_IIS_ADS_CREATE_FAILED;
				IIsScoLogFailure();
			}

			// Set "ServerComment" property
			if (SUCCEEDED(hr) && bstrSiteName.Length() > 0 ) 
			{
				hr = SetMetaPropertyValue(pADs, L"ServerComment", bstrSiteName);
				IIsScoLogFailure();
			}

			// Set "ServerBindings" property
			if (SUCCEEDED(hr)) hr = SetMetaPropertyValue(pADs, L"ServerBindings", bstrSBindings);
			IIsScoLogFailure();


			// Step 6:  Start Server if required   IIS_FALSE
			bstrStart.ToUpper();
			if ( SUCCEEDED(hr) && !StringCompare(bstrStart, IIS_FALSE) )
			{
				hr = SetMetaPropertyValue(pADs, L"ServerAutoStart", IIS_TRUE);
				IIsScoLogFailure();

				hr = IIsServerAction(bstrConfigPath,start);
				IIsScoLogFailure();
			}
			else
			{
			   hr = SetMetaPropertyValue(pADs, L"ServerAutoStart", IIS_FALSE);
			   IIsScoLogFailure();

			}


			// Step 7: write output to ConfigPath node <ConfigPath>/W3SVC/n</ConfigPath>
			if (SUCCEEDED(hr) )
			{
				CComBSTR bstrXML1 = IIS_W3SVC;
				bstrXML1.Append(L"/");
				bstrXML1.AppendBSTR(bServerNumber.m_str);

				// Helper function to write to DOM
				hr = PutElement(pNode, L"./Website/ConfigPath", bstrXML1.m_str);
				IIsScoLogFailure();


			}
			// If there is a failure, then deleted the web site created in step 3
			else
			{
			   // First delete any webseites that were created in the method.  Do this here because a RollBack
			   // will only get called on a completed previous <step>, not a failed step.
			   DeleteIIs50Site(IIS_IISWEBSERVER,bWebADsPath,bServerNumber);
			}

		} // end if Step 4

	  } // end if 'CheckBindings'
	}
	else
	{
		hr = E_SCO_IIS_PORTNUMBER_NOT_VALID;
	}

	// If there is a failure.
	if ( FAILED(hr) )
	{
		// Log failure.
		IIsScoLogFailure();
    }
	else
    {
		// WebSite successfully created.  Set Rollback data incase another step fails
		// a a ROllBack is initiated.
		CComVariant varData1(bWebADsPath);
		CComVariant varData2(bServerNumber);
		hr = m_pProvHelper->SetRollbackData(IIS_ROLL_ADSPATH, varData1);
		hr = m_pProvHelper->SetRollbackData(IIS_ROLL_SERVERNUMBER, varData2);
	}

   
    TRACE_EXIT(L"CIISSCO50::CreateWebSite");
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//  CIISSCO50::CreateWebSite_Rollback
// Author:    Russ Gibfried
// Params:    [in]  none
//            [out] none
// Purpose:   Called by MAPS framework when is encounters a failure during
//            'CreateWebSite'.  The Rollback deletes the WebSite if it exists.
//------------------------------------------------------------- 
HRESULT  CIISSCO50::CreateWebSite_Rollback( IXMLDOMNode *pXMLNode )
{
  TRACE_ENTER(L"CIISSCO50::CreateWebSiteRollback");

    HRESULT hr = S_OK;
    CComBSTR bWebADsPath;     // AdsPath:   IIS://server/W3SVC
    CComBSTR bServerNumber;   // Web server number
	CComBSTR bstrConfigPath;   // Complete ADsPath to check: IIS://localhost/W3SVC/1


	CComVariant    varWebADsPath;
	CComVariant    varServerNumber;

	// Read ADsWebPath and ServerNumber to form:   IIS://localhost/W3SVC/1
	hr = m_pProvHelper->GetRollbackData(IIS_ROLL_ADSPATH, &varWebADsPath);
	if (SUCCEEDED(hr) )	hr = m_pProvHelper->GetRollbackData(IIS_ROLL_SERVERNUMBER, &varServerNumber);

	if (SUCCEEDED(hr) )	
	{
       bServerNumber = varServerNumber.bstrVal;
	   bWebADsPath = varWebADsPath.bstrVal;
	

	   if ( bServerNumber.Length() > 0 )
	   {
	      bstrConfigPath = bWebADsPath.Copy();
	      bstrConfigPath.Append(L"/");
	      bstrConfigPath.AppendBSTR(bServerNumber.m_str);


	      // Step 1:  ShutDown Server
	      hr = IIsServerAction(bstrConfigPath,stop);

	      // Step 2:  Delete the server
	      if (SUCCEEDED(hr) ) hr = DeleteIIs50Site(IIS_IISWEBSERVER,bWebADsPath,bServerNumber);
	      IIsScoLogFailure();
	   }
	   else
	   {
           hr = E_SCO_IIS_INVALID_INDEX;

	   }
	}
	else
	{
        hr = E_SCO_IIS_INVALID_INDEX;
	}


	// Log failure.
	IIsScoLogFailure();

    TRACE_EXIT(L"CIISSCO50::CreateWebSiteRollback");

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//  CIISSCO50::DeleteWebSite_Execute
// Author:    Russ Gibfried
// Params:    [in]  none
//            [out] none
// Purpose:   Called by MAPS framework when is encounters an action
//            tag: DeleteWebSite.  Code deletes a IIS 5 web site
//             
//------------------------------------------------------------- 
HRESULT  CIISSCO50::DeleteWebSite_Execute( IXMLDOMNode *pXMLNode )
{
    TRACE_ENTER(L"CIISSCO50::DeleteWebSite");

	CComBSTR bWebADsPath;       // adsPath:   IIS://server/W3SVC
	CComBSTR bstrServer;        // Server name; localhost if black
	CComBSTR bServerNumber;     // WebSite number: 3
	CComBSTR bstrConfigPath;    // Full configuartion path:  IIS://localhost/W3SVC/3
	CComPtr<IXMLDOMNode> pNode; // xml node <website>

	HRESULT hr = S_OK;

	// Get node in format: <executeData><Website number=''><Root />...
	CComBSTR bstrDebug;
	//hr = pXMLNode->get_xml(&bstrDebug);

	hr = pXMLNode->selectSingleNode( L"//executeXml/executeData", &pNode );
	hr = pNode->get_xml(&bstrDebug);
	ATLTRACE(_T("\t>>> xml = : %ls\n"), bstrDebug.m_str);

	// Get properties from XML
	hr = GetInputAttr(pNode, L"./Website", L"number", bServerNumber);
	hr = GetInputParam(pNode,L"./Website/Server", bstrServer);

	// Create a IIS metabase path.  ex. IIS://localhost/W3SVC 
    bWebADsPath = IIS_PREFIX;
	if ( bstrServer.Length() == 0 )
		bstrServer = IIS_LOCALHOST;

	bWebADsPath.AppendBSTR(bstrServer);
	bWebADsPath.Append(IIS_W3SVC);

	// CreateFull configuartion path:  IIS://localhost/W3SVC/3
	bstrConfigPath = bWebADsPath.Copy();
	bstrConfigPath.Append(L"/");
	bstrConfigPath.AppendBSTR(bServerNumber.m_str);

	if ( bServerNumber.Length() > 0 )
	{

	     // Step 1:  ShutDown Server
	    hr = IIsServerAction(bstrConfigPath,stop);
        IIsScoLogFailure();

	    // Step 2:  Delete the server
	    if (SUCCEEDED(hr) ) hr = DeleteIIs50Site(IIS_IISWEBSERVER,bWebADsPath,bServerNumber);
        IIsScoLogFailure();

	    if ( SUCCEEDED(hr) )
		{
		
		    // DeleteSite successfully.  Set Rollback data to be whole xml node
		    // incase another step in SCO fails a RollBack is required.
		    CComBSTR webXML;
		    hr = pNode->get_xml(&webXML);

			// convert BSTR to Variant and save in RollbackData
			CComVariant  varData(webXML);
		    hr = m_pProvHelper->SetRollbackData(IIS_ROLL_XNODE, varData);
		}
	}
	else
	{
       hr = E_SCO_IIS_INVALID_INDEX;
	}

	if ( FAILED(hr) )
		IIsScoLogFailure();

    TRACE_EXIT(L"CIISSCO50::DeleteWebSite");

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//  CIISSCO50::DeleteWebSite_Rollback
// Author:    Russ Gibfried
// Params:    [in]  none
//            [out] none
// Purpose:   Called by MAPS framework when is encounters a failure during
//            'DeleteWebSite'.  The Rollback recreates the WebSite if it can.
//            MAPS returns data in the format: <executeData><Website number=''>...
//------------------------------------------------------------- 
HRESULT  CIISSCO50::DeleteWebSite_Rollback( IXMLDOMNode *pXMLNode )
{
    //hr = m_pProvHelper->GetRollbackData(L"key", &varData );

	  TRACE_ENTER(L"CIISSCO50::DeleteWebSiteRollback");

	CComBSTR bWebADsPath;       // adsPath:   IIS://server/W3SVC
	CComBSTR bstrRoot;          // root directory path: c:/inetpub
	CComBSTR bstrServer;        // Server name; localhost if black
	CComBSTR bstrSiteName;      // site name; www.mysite.com
	CComBSTR bstrHost;          // Web Hostname
	CComBSTR bstrPort;          // Web port number
	CComBSTR bstrIP;            // Web IP address 
	CComBSTR bstrSBindings;     // Server bindings:  IP:Post:HostName
	CComBSTR bServerNumber;     // WebSite number: 3
	//CComBSTR bFilePermissions;  // File permissions: domain\user:F
	CComBSTR bstrStart;         // Start site when done? TRUE/FALSE
	CComBSTR bConfigPath;      // Initial <ConfigPath> value:  /W3SVC/3
	CComBSTR bstrConfigPath;    // Created sites ADsPath:  /W3SVC/3

	CComVariant xmlString;     // Variant string returned by MAPS

	CComPtr<IXMLDOMDocument> pDoc;       // xml document 
	CComPtr<IXMLDOMNodeList> pNodeList; // xml node list <website>
	CComPtr<IXMLDOMNode> pNode; // xml node <website>

	HRESULT hr = S_OK;

	// Get RollBack data.  Will bein form:  <executeData><Website number=''>...
	hr = m_pProvHelper->GetRollbackData(IIS_ROLL_XNODE, &xmlString);

	// load xml string into XML Dom
	if ( xmlString.bstrVal != NULL )
	{
		hr = CoCreateInstance(
                __uuidof(DOMDocument),
                NULL,
                CLSCTX_ALL,
                __uuidof(IXMLDOMDocument),
                (LPVOID*)&pDoc);

		VARIANT_BOOL bSuccess = VARIANT_FALSE;
        hr = pDoc->loadXML(xmlString.bstrVal, &bSuccess);

        if ( SUCCEEDED(hr) && bSuccess != VARIANT_FALSE) 
		{
           // Check that there is a <Website> tag
	       hr = pDoc->getElementsByTagName(L"Website",&pNodeList);
		   long numChild = 0;
		   if (SUCCEEDED(hr)) hr = pNodeList->get_length(&numChild);

		   if ( numChild > 0 )
		   {
			    // Get the next node which is <Website number=''>
                hr = pNodeList->nextNode(&pNode);


			  // Get Server number from attribute map <Website number=2">
		      if (SUCCEEDED(hr) )
			  {
				  hr = GetInputAttr(pNode, L"", L"number", bServerNumber);
				  if ( !IsPositiveInteger(bServerNumber) )
				  {
					  //hr = GetElement(pNode, L"ConfigPath", bConfigPath);
					  hr = ParseBSTR(bConfigPath,L'/', 2, 99, bServerNumber);
				  }

		          // Check Server number is valid
		          if ( !IsPositiveInteger(bServerNumber) )
				  {
		             hr = E_SCO_IIS_INVALID_INDEX;
                     IIsScoLogFailure();
				  }
			  }

	          // Get properties from XML
	          if (SUCCEEDED(hr) ) hr = GetInputParam(pNode, L"./Root", bstrRoot);
	          if (SUCCEEDED(hr) ) hr = GetInputParam(pNode, L"./Server", bstrServer);
	          if (SUCCEEDED(hr) ) hr = GetInputParam(pNode, L"./SiteName", bstrSiteName);
	          if (SUCCEEDED(hr) ) hr = GetInputParam(pNode, L"./HostName", bstrHost);
	          if (SUCCEEDED(hr) ) hr = GetInputParam(pNode, L"./PortNumber", bstrPort);
	          if (SUCCEEDED(hr) ) hr = GetInputParam(pNode, L"./IPAddress", bstrIP);
	          if (SUCCEEDED(hr) ) hr = GetInputParam(pNode, L"./StartOnCreate", bstrStart);
	          //if (SUCCEEDED(hr) ) hr = GetInputParam(pNode, L"./FilePermissions", bFilePermissions);

	          // Create a IIS metabase path.  ex. IIS://localhost/W3SVC 
              bWebADsPath = IIS_PREFIX;
	          if ( bstrServer.Length() == 0 )
		         bstrServer = IIS_LOCALHOST;

	          bWebADsPath.AppendBSTR(bstrServer);
	          bWebADsPath.Append(IIS_W3SVC);

	          // Step .5:  If port number missing, set to default (ie, 80)
	          if ( bstrPort.Length() == 0 )
                  bstrPort = IIS_DEFAULT_WEB_PORT;

	          if ( IsPositiveInteger(bstrPort) )
			  {

				   // Step 1:  Create the ServerBinding string then check bindings to make sure 
				  //         there is not a duplicate server
				  CreateBindingString(bstrIP, bstrPort, bstrHost, bstrSBindings);

				  if (SUCCEEDED(hr) ) hr = CheckBindings(bWebADsPath, bstrSBindings);
				  IIsScoLogFailure();

				  // Step 2: Recreate Web Server
				  if (SUCCEEDED(hr) )
				  {

					 // Step 3: Create the Web Site on given path, ServerNumber.
					 if (SUCCEEDED(hr)) hr = CreateIIs50Site(IIS_IISWEBSERVER,bWebADsPath, bServerNumber, bstrConfigPath);
					 IIsScoLogFailure();

					 // Step 4: Create a Virtual directory on new IIsWebServer configPath
					 if (SUCCEEDED(hr)) 
					 {
					    CComBSTR bstrVDirAdsPath;
					    hr = CreateIIs50VDir(IIS_IISWEBVIRTUALDIR, bstrConfigPath,L"ROOT", L"Default Application", bstrRoot, bstrVDirAdsPath);
					    IIsScoLogFailure();

					    // Step 5: set each property; ie, server bindings
					    // Bind to ADs object
					    CComPtr<IADs> pADs;
					    if (SUCCEEDED(hr)) hr = ADsGetObject(bstrConfigPath, IID_IADs, (void**) &pADs );
					    if ( FAILED(hr) )
						{
						    hr = E_SCO_IIS_ADS_CREATE_FAILED;
						}
 
					    // Set "ServerComment" property
		                if (SUCCEEDED(hr) && bstrSiteName.Length() > 0 ) 
						{
		                   hr = SetMetaPropertyValue(pADs, L"ServerComment", bstrSiteName);
                           IIsScoLogFailure();
						}

					    if (SUCCEEDED(hr)) hr = SetMetaPropertyValue(pADs, L"ServerBindings", bstrSBindings);
					    IIsScoLogFailure();


					    // Step 6:  Start Server if required   IIS_FALSE
					    bstrStart.ToUpper();
					    if ( SUCCEEDED(hr) )
						{
						   if ( !StringCompare(bstrStart, IIS_FALSE) )
						   {
						       hr = SetMetaPropertyValue(pADs, L"ServerAutoStart", IIS_TRUE);
						       IIsScoLogFailure();

						       hr = IIsServerAction(bstrConfigPath,start);
						       IIsScoLogFailure();
						   }
					       else
						   {
					           hr = SetMetaPropertyValue(pADs, L"ServerAutoStart", IIS_FALSE);
					           IIsScoLogFailure();

						   }
						}

					    // If there is a failure, 'IIsScoLogFailure' macro will log error
					    if ( FAILED(hr) )
						{
						    // First delete any webseites that were created in the method.  Do this here because a RollBack
						    // will only get called on a completed previous <step>, not a failed step.
						    DeleteIIs50Site(IIS_IISWEBSERVER,bWebADsPath,bServerNumber);

						}
					 } // if Step 4

				  } // if Step 3
			  } 
	          else
			  {
		           hr = E_SCO_IIS_PORTNUMBER_NOT_VALID;
                   IIsScoLogFailure();
			  }  // portnumber positive

		   }  // if hasChild
		}  // if isSuccessfull
	}

	// Log failure.
	if ( FAILED(hr))
        IIsScoLogFailure();


    TRACE_EXIT(L"CIISSco50Obj::DeleteWebSiteRollback");

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//  CIISSCO50::CreateFTPSite_Execute
// Author:    Russ Gibfried
// Params:    [in]  none
//            [out] none
// Purpose:   Called by MAPS framework when is encounters an action
//            tag: CreateFTPSite.  Code creates a IIS 5 ftp site
//             
//------------------------------------------------------------- 
HRESULT  CIISSCO50::CreateFTPSite_Execute( IXMLDOMNode *pXMLNode )
{
    TRACE_ENTER(L"CIISSCO50::CreateFTPSite");
	HRESULT hr = S_OK;

	CComBSTR bFTPADsPath;       // adsPath:   IIS://server/MSFTPSVC
	CComBSTR bstrRoot;          // root directory path: c:/inetpub
	CComBSTR bstrServer;        // Server name; localhost if black
	CComBSTR bstrSiteName;      // site name; www.mysite.com
	CComBSTR bstrPort;          // Web port number
	CComBSTR bstrIP;            // Web IP address 
	CComBSTR bstrSBindings;     // Server bindings:  IP:Post:HostName
	CComBSTR bServerNumber;     // WebSite number: 3
	//CComBSTR bFilePermissions;  // File permissions: domain\user:F
	CComBSTR bstrStart;         // Start site when done? TRUE/FALSE
	CComBSTR bstrConfigPath;    // Created sites ADsPath:  /MSFTPSVC/3
	CComPtr<IXMLDOMNode> pNode; // xml node <website>

	// Get node in format: <executeData><FTPsite number=''><Root />...
	hr = pXMLNode->selectSingleNode( L"//executeXml/executeData", &pNode );


	// Get properties from XML
	hr = GetInputAttr(pNode, L"./FTPsite", L"number", bServerNumber);
	hr = GetInputParam(pNode,L"./FTPsite/Root", bstrRoot);
	hr = GetInputParam(pNode,L"./FTPsite/Server", bstrServer);
	hr = GetInputParam(pNode,L"./FTPsite/SiteName", bstrSiteName);
	hr = GetInputParam(pNode,L"./FTPsite/PortNumber", bstrPort);
	hr = GetInputParam(pNode,L"./FTPsite/IPAddress", bstrIP);
	hr = GetInputParam(pNode,L"./FTPsite/StartOnCreate", bstrStart);
	//hr = GetInputParam(pNode,L"./FTPsite/FilePermissions", bFilePermissions);

	// Create a IIS metabase path.  ex. IIS://localhost/MSFTPSVC 
    bFTPADsPath = IIS_PREFIX;
	if ( bstrServer.Length() == 0 )
		bstrServer = IIS_LOCALHOST;

	bFTPADsPath.AppendBSTR(bstrServer);
	bFTPADsPath.Append(IIS_MSFTPSVC);

	// Step .5:  If port number missing, set to default (ie, 21)
	if ( bstrPort.Length() == 0 )
       bstrPort = IIS_DEFAULT_FTP_PORT;

	if ( IsPositiveInteger(bstrPort) )
	{

		// Step 1:  Create the ServerBinding string to make sure not a duplicate server
		hr = CreateBindingString(bstrIP, bstrPort, L"", bstrSBindings);

		hr = CheckBindings(bFTPADsPath, bstrSBindings);
		if (SUCCEEDED(hr) )
		{

			// Step 2:  Get Next available Server Index
			if ( bServerNumber.Length() == 0 )
				hr = GetNextIndex(bFTPADsPath,bServerNumber);


			// Step 3: Create the Web Site on given path, ServerNumber.
			if (SUCCEEDED(hr)) hr = CreateIIs50Site(IIS_IISFTPSERVER,bFTPADsPath, bServerNumber, bstrConfigPath);

			if (SUCCEEDED(hr))
			{

			   // Step 4: Create a Virtual directory on new IIsWebServer configPath
			   CComBSTR bstrVDirAdsPath;
			   hr = CreateIIs50VDir(IIS_FTPVDIR,bstrConfigPath,L"ROOT", L"Default Application", bstrRoot, bstrVDirAdsPath);
			   IIsScoLogFailure();
			   
			   // Step 5: set each property
			   CComPtr<IADs> pADs;
			   if (SUCCEEDED(hr)) hr = ADsGetObject(bstrConfigPath, IID_IADs, (void**) &pADs );

			   if (SUCCEEDED(hr)) 
			   {

				  // Set "ServerComment" property
		          if (bstrSiteName.Length() > 0 ) 
				  {
		             hr = SetMetaPropertyValue(pADs, L"ServerComment", bstrSiteName);
                     IIsScoLogFailure();
				  }

				  // Set "ServerBindings"
				  if (SUCCEEDED(hr)) hr = SetMetaPropertyValue(pADs, L"ServerBindings", bstrSBindings);
				  IIsScoLogFailure();


				   // Step 6:  Start Server if required   IIS_FALSE
				   bstrStart.ToUpper();
				   if ( SUCCEEDED(hr) && !StringCompare(bstrStart, IIS_FALSE) )
				   {
						hr = SetMetaPropertyValue(pADs, L"ServerAutoStart", IIS_TRUE);
						IIsScoLogFailure();

						hr = IIsServerAction(bstrConfigPath,start);
						IIsScoLogFailure();
				   }
				   else
				   {
					   hr = SetMetaPropertyValue(pADs, L"ServerAutoStart", IIS_FALSE);
					   IIsScoLogFailure();

				   }


				  // Step 7: write ConfigPath to output.
				  if (SUCCEEDED(hr) )
				  {
					   CComBSTR bstrXML1 = IIS_MSFTPSVC;
					   bstrXML1.Append(L"/");
					   bstrXML1.AppendBSTR(bServerNumber.m_str);

					   // Helper function to write to DOM
			            hr = PutElement(pNode, L"./FTPsite/ConfigPath", bstrXML1.m_str);
						IIsScoLogFailure();

				  }

			   }
			   else
			   {
				   hr = E_SCO_IIS_ADS_CREATE_FAILED;
				   IIsScoLogFailure();

			   }  // end step 4

			   // If something failed between steps 5-7, delete FTP site created in step 3
			   if ( FAILED(hr) )
			   {
				  // First delete any ftp sites that were created in the method.  Do this here because a RollBack
				  // will only get called on a completed previous <step>, not a failed step.
				  DeleteIIs50Site(IIS_IISFTPSERVER,bFTPADsPath,bServerNumber);
			   }

			}  // end if  L"CreateFTPSite:  Could not create FTP site."
		   
		} // end if FTP ServerBindings already existed."
	}
	else
	{
		// L"CreateFTPSite: Port number must be positive value."
		hr = E_SCO_IIS_PORTNUMBER_NOT_VALID;
	}


	// If there is a failure.
	if ( FAILED(hr) )
	{
		// L"CreateFTPSite failed."
		IIsScoLogFailure();
    }
	else
    {
		// FTP Site successfully created.  Set Rollback data incase another step fails
		CComVariant varData1(bFTPADsPath);
		CComVariant varData2(bServerNumber);
		hr = m_pProvHelper->SetRollbackData(IIS_ROLL_ADSPATH, varData1);
		hr = m_pProvHelper->SetRollbackData(IIS_ROLL_SERVERNUMBER, varData2);
	}


    TRACE_EXIT(L"CIISSCO50::CreateFTPSite");
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//  CIISSCO50::CreateFTPSite_Rollback
// Author:    Russ Gibfried
// Params:    [in]  none
//            [out] none
// Purpose:   Called by MAPS framework when is encounters a failure during
//            'CreateFTPSite'.  The Rollback deletes the ftp if it can.
//------------------------------------------------------------- 
HRESULT  CIISSCO50::CreateFTPSite_Rollback( IXMLDOMNode *pXMLNode )
{
    TRACE_ENTER(L"CIISSCO50::CreateFTPSiteRollback");
    HRESULT hr = S_OK;
    CComBSTR bFTPADsPath;     // AdsPath:   IIS://server/MSFTPSVC
    CComBSTR bServerNumber;   // Web server number
	CComBSTR bstrConfigPath;   // Complete ADsPath to check: IIS://localhost/MSFTPSVC/1

	CComVariant    varFTPADsPath;
	CComVariant    varServerNumber;

	// Read ADsFTPPath and ServerNumber to form:   IIS://localhost/MSFTPSVC/1
	hr = m_pProvHelper->GetRollbackData(IIS_ROLL_ADSPATH, &varFTPADsPath);
	if (SUCCEEDED(hr) )	hr = m_pProvHelper->GetRollbackData(IIS_ROLL_SERVERNUMBER, &varServerNumber);

	if (SUCCEEDED(hr) )	
	{
       bServerNumber = varServerNumber.bstrVal;
	   bFTPADsPath = varFTPADsPath.bstrVal;

	   bstrConfigPath = bFTPADsPath.Copy();
	   bstrConfigPath.Append(L"/");
	   bstrConfigPath.AppendBSTR(bServerNumber.m_str);
	}


	// Step 1:  ShutDown Server
	if (SUCCEEDED(hr)) hr = IIsServerAction(bstrConfigPath,stop);

    // Only a warning if can't stop/start server given correct server path

	// Step 2:  Delete the server
    hr = DeleteIIs50Site(IIS_IISFTPSERVER,bFTPADsPath,bServerNumber);
	IIsScoLogFailure();


    TRACE_EXIT(L"CIISSCO50::CreateFTPSiteRollback");

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//  CIISSCO50::DeleteFTPSite_Execute
// Author:    Russ Gibfried
// Params:    [in]  none
//            [out] none
// Purpose:   Called by MAPS framework when is encounters an action
//            tag: DeleteFTPSite.  Code deletes a IIS 5 ftp site
//             
//------------------------------------------------------------- 
HRESULT  CIISSCO50::DeleteFTPSite_Execute( IXMLDOMNode *pXMLNode )
{
    TRACE_ENTER(L"CIISSCO50::DeleteFTPSite");

	CComBSTR bFTPADsPath;       // adsPath:   IIS://server/MSFTPSVC
	CComBSTR bstrServer;        // Server name; localhost if blank
	CComBSTR bServerNumber;     // WebSite number: 3
	CComBSTR bstrConfigPath;    // Full configuartion path:  IIS://localhost/MSFTPSVC/3
	CComPtr<IXMLDOMNode> pNode; // xml node <website>

	HRESULT hr = S_OK;

	// Get node in format: <executeData><FTPsite number=''><Root />...
	hr = pXMLNode->selectSingleNode( L"//executeXml/executeData", &pNode );


	// Get properties from XML
	hr = GetInputAttr(pNode, L"./FTPsite", L"number", bServerNumber);
	hr = GetInputParam(pNode,L"./FTPsite/Server", bstrServer);

	// Step .5:  Make sure Server Number is a positive integer
	if ( IsPositiveInteger(bServerNumber) )
	{


		// Create a IIS metabase path.  ex. IIS://localhost/MSFTPSVC 
		bFTPADsPath = IIS_PREFIX;
		if ( bstrServer.Length() == 0 )
			bstrServer = IIS_LOCALHOST;

		bFTPADsPath.AppendBSTR(bstrServer);
		bFTPADsPath.Append(IIS_MSFTPSVC);

		// Create metabase path to object:  IIS://localhost/MSFTPSVC/1
		bstrConfigPath = bFTPADsPath.Copy();
		bstrConfigPath.Append(L"/");
		bstrConfigPath.AppendBSTR(bServerNumber.m_str);

		// Step 1:  ShutDown Server
		hr = IIsServerAction(bstrConfigPath,stop);

		// Only a warning if can't stop/start server

		// Step 2:  Delete the server
		hr = DeleteIIs50Site(IIS_IISFTPSERVER,bFTPADsPath,bServerNumber);
		IIsScoLogFailure();
	}
	else
	{
		// L"DeleteFTPSite: Invalid Server number."
		hr = E_SCO_IIS_INVALID_INDEX;
		IIsScoLogFailure();

	}

	// If there is a failure
	if ( FAILED(hr) )
	{
		// L"DeleteFTPSite failed."
		IIsScoLogFailure();
    }
	else
    {
		// DeleteSite successfully.  Set Rollback data to be whole xml node
		// incase another step in SCO fails a RollBack is required.
		CComBSTR webXML;
		hr = pNode->get_xml(&webXML);

		// convert BSTR to Variant and save in RollbackData
		CComVariant  varData(webXML);
		hr = m_pProvHelper->SetRollbackData(IIS_ROLL_XNODE, varData);
	}

    TRACE_EXIT(L"CIISSCO50::DeleteFTPSite");

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//  CIISSCO50::DeleteFTPSite_Rollback
// Author:    Russ Gibfried
// Params:    [in]  none
//            [out] none
// Purpose:   Called by MAPS framework when is encounters a failure during
//            'DeleteFTPSite'.  The Rollback recreates the ftp Site if it can.
//------------------------------------------------------------- 
HRESULT  CIISSCO50::DeleteFTPSite_Rollback( IXMLDOMNode *pXMLNode )
{
    TRACE_ENTER(L"CIISSCO50::DeleteFTPSiteRollback");

	CComBSTR bFTPADsPath;       // adsPath:   IIS://server/MSFTPSVC
	CComBSTR bstrRoot;          // root directory path: c:/inetpub
	CComBSTR bstrServer;        // Server name; localhost if black
	CComBSTR bstrSiteName;      // site name; www.mysite.com
	CComBSTR bstrPort;          // Web port number
	CComBSTR bstrIP;            // Web IP address 
	CComBSTR bstrSBindings;     // Server bindings:  IP:Post:HostName
	CComBSTR bServerNumber;     // WebSite number: 3
	//CComBSTR bFilePermissions;  // File permissions: domain\user:F
	CComBSTR bstrStart;         // Start site when done? TRUE/FALSE
	CComBSTR bConfigPath;      // Initial <ConfigPath> value:  /MSFTPSVC/3
	CComBSTR bstrConfigPath;    // Created sites ADsPath:  /MSFTPSVC/3

	CComVariant xmlString;

	CComPtr<IXMLDOMDocument> pDoc;           // xml document 
	CComPtr<IXMLDOMNodeList> pNodeList;      // xml node list <website>
	CComPtr<IXMLDOMNode> pNode;              // xml node <website>

	HRESULT hr = S_OK;

	// Get RollBack data.  Will bein form:  <executeData><Website number=''>...
	hr = m_pProvHelper->GetRollbackData(IIS_ROLL_XNODE, &xmlString);

	// load xml string into XML Dom
	if ( xmlString.bstrVal != NULL )
	{

		hr = CoCreateInstance(
                __uuidof(DOMDocument),
                NULL,
                CLSCTX_ALL,
                __uuidof(IXMLDOMDocument),
                (LPVOID*)&pDoc);

		VARIANT_BOOL bSuccess = VARIANT_FALSE;
        if ( SUCCEEDED(hr) ) hr = pDoc->loadXML(xmlString.bstrVal, &bSuccess);

        if ( SUCCEEDED(hr) && bSuccess != VARIANT_FALSE) 
		{
		   // Check that there is a <FTPSite number= > tag
		   hr = pDoc->getElementsByTagName(L"FTPsite",&pNodeList);
		   long numChild = 0;
		   if (SUCCEEDED(hr)) hr = pNodeList->get_length(&numChild);

		   if ( numChild > 0 )
		   {
              hr = pNodeList->nextNode(&pNode);

			  // Get Server number from attribute map <FTPSite number=2">
		      if (SUCCEEDED(hr) ) hr = GetInputAttr(pNode, L"", L"number", bServerNumber);

		      // Check Server number is valid
		      if ( !IsPositiveInteger(bServerNumber) )
			  {
				  // L"DeleteFTPSiteRollback:  FTP Server Number missing."
		          hr = E_SCO_IIS_INVALID_INDEX;
                  IIsScoLogFailure();
			  }

	          // Get properties from XML
	          if (SUCCEEDED(hr) ) hr = GetInputParam(pNode, L"./Root", bstrRoot);
	          if (SUCCEEDED(hr) ) hr = GetInputParam(pNode, L"./Server", bstrServer);
	          if (SUCCEEDED(hr) ) hr = GetInputParam(pNode, L"./SiteName", bstrSiteName);
	          if (SUCCEEDED(hr) ) hr = GetInputParam(pNode, L"./PortNumber", bstrPort);
	          if (SUCCEEDED(hr) ) hr = GetInputParam(pNode, L"./IPAddress", bstrIP);
	          if (SUCCEEDED(hr) ) hr = GetInputParam(pNode, L"./StartOnCreate", bstrStart);
	          //if (SUCCEEDED(hr) ) hr = GetInputParam(pNode, L"./FilePermissions", bFilePermissions);
	          if (SUCCEEDED(hr) ) hr = GetInputParam(pNode, L"./ConfigPath", bConfigPath);

	          // Create a IIS metabase path.  ex. IIS://localhost/W3SVC 
              bFTPADsPath = IIS_PREFIX;
	          if ( bstrServer.Length() == 0 )
		         bstrServer = IIS_LOCALHOST;

	          bFTPADsPath.AppendBSTR(bstrServer);
	          bFTPADsPath.Append(IIS_MSFTPSVC);

			  // Step .5:  If port number missing, set to default (ie, 21)
	          if ( bstrPort.Length() == 0 )
                  bstrPort = IIS_DEFAULT_FTP_PORT;

	          if ( IsPositiveInteger(bstrPort) )
			  {


				  // Step 1:  Create the ServerBinding string to make sure not a duplicate server
				  hr = CreateBindingString(bstrIP, bstrPort, L"", bstrSBindings);

				  if (SUCCEEDED(hr)) hr = CheckBindings(bFTPADsPath, bstrSBindings);
				  IIsScoLogFailure();


				  // Step 2 Recreate FTP Server
				  if (SUCCEEDED(hr) )
				  {

					   // Step 3: Create the Web Site on given path, ServerNumber.
					  hr = CreateIIs50Site(IIS_IISFTPSERVER,bFTPADsPath, bServerNumber, bstrConfigPath);
					  IIsScoLogFailure();

					  // Step 4: Create a Virtual directory on new IIsFtpVirtualDir configPath
					  if (SUCCEEDED(hr) )
					  {
						 CComBSTR bstrVDirAdsPath;
						 hr = CreateIIs50VDir(IIS_FTPVDIR,bstrConfigPath,L"ROOT", L"Default Application", bstrRoot, bstrVDirAdsPath);
						 IIsScoLogFailure();				     
				
						 // Step 5 - set properties
						 if (SUCCEEDED(hr) )
						 {

							 CComPtr<IADs> pADs;
							 hr = ADsGetObject(bstrConfigPath, IID_IADs, (void**) &pADs );
							 if ( FAILED(hr) )
							 {
								 // L"DeleteFTPSiteRollback: Create FTP adsi object failed."
								 hr = E_SCO_IIS_ADS_CREATE_FAILED;
								 IIsScoLogFailure();
							 }
							 else
							 {
								  // Set "ServerComment" property
								  if (bstrSiteName.Length() > 0 ) 
								  {
									 hr = SetMetaPropertyValue(pADs, L"ServerComment", bstrSiteName);
									 IIsScoLogFailure();
								  }

								  // Set "ServerBindings"
								  if (SUCCEEDED(hr)) hr = SetMetaPropertyValue(pADs, L"ServerBindings", bstrSBindings);
								  IIsScoLogFailure();


								   // Step 6:  Start Server if required   IIS_FALSE
								   bstrStart.ToUpper();
								   if ( SUCCEEDED(hr) && !StringCompare(bstrStart, IIS_FALSE) )
								   {
										hr = SetMetaPropertyValue(pADs, L"ServerAutoStart", IIS_TRUE);
										IIsScoLogFailure();

										hr = IIsServerAction(bstrConfigPath,start);
										IIsScoLogFailure();
								   }
								   else
								   {
									   if (SUCCEEDED(hr)) hr = SetMetaPropertyValue(pADs, L"ServerAutoStart", IIS_FALSE);
									   IIsScoLogFailure();

								   }

							 } // end if Step 5
						 }

						 // If failure, delete the FTP site
						 if ( FAILED(hr))
						 {
							 DeleteIIs50Site(IIS_IISFTPSERVER,bFTPADsPath,bServerNumber);
						 }
					  }  // end step 4


					} // end if Step 2
			  } 
	          else
			  {
				  // L"DeleteWebSiteRollback:  Port number not a positive integer."
		          hr = E_SCO_IIS_PORTNUMBER_NOT_VALID;

			  }  // step .5 portnumber positive

		   }  // if numChild > 0

		}  // if isSuccessfull
	}

	if ( FAILED(hr) )
	{
		// DeleteFTPSiteRollback failed."
		IIsScoLogFailure();
	}


    TRACE_EXIT(L"CIISSCO50::DeleteFTPSiteRollback");

  return hr;

}

///////////////////////////////////////////////////////////////////////////////
//  CIISSCO50::CreateVDir_Execute
// Author:    Russ Gibfried
// Params:    [in]  none
//            [out] none
// Purpose:   Called by MAPS framework when is encounters an action
//            tag: CreateVDir.  Code creates a IIS 5 Virtual Directory
//             
//------------------------------------------------------------- 
HRESULT  CIISSCO50::CreateVDir_Execute( IXMLDOMNode *pXMLNode )
{
    TRACE_ENTER(L"CIISSCO50::CreateVDir");

	CComBSTR bstrConfigPath;    // adsPath:   IIS://server/W3SVC/1/ROOT/MyDir
	CComBSTR bServerNumber;     // Server number
	CComBSTR bstrServer;        // Server name; localhost if blank
	//CComBSTR bFilePermissions;  // File permissions: domain\user:F
	CComBSTR bstrDirPath;          // root directory path: c:/inetpub
	CComBSTR bstrVDirName;      // Virtual Directory name; MyDir
	CComBSTR bstrFriendlyName;  // Display name or AppFriendlyName
	CComBSTR bstrAppCreate;     // AppCreate flag -- TRUE/FALSE
	CComBSTR bstrIsoLevel;      // AppIsolationLevel 
	CComBSTR bstrAccessRead;    // AccessFalgs - AccessRead = TRUE/FALSE
	CComBSTR bstrAccessScript;  // AccessFalgs - AccessScript = TRUE/FALSE
	CComBSTR bstrAccessWrite;    // AccessFalgs - AccessWrite = TRUE/FALSE
	CComBSTR bstrAccessExecute;  // AccessFalgs - AccessExecute = TRUE/FALSE

	CComPtr<IXMLDOMNode> pNode; // xml node.  will be <executeData><VirtualDirectory>

	HRESULT hr = S_OK;

	// Get node in format: <executeData><VirtualDirectory number=''><Root />...
	hr = pXMLNode->selectSingleNode( L"//executeXml/executeData", &pNode );

	// Get properties from XML
	hr = GetInputAttr(pNode,L"./VirtualDirectory", L"number", bServerNumber);
	hr = GetInputParam(pNode,L"./VirtualDirectory/Server", bstrServer);
	//hr = GetInputParam(pNode,L"./VirtualDirectory/FilePermissions", bFilePermissions);
	hr = GetInputParam(pNode,L"./VirtualDirectory/Path", bstrDirPath);
	hr = GetInputParam(pNode,L"./VirtualDirectory/VDirName", bstrVDirName);
	hr = GetInputParam(pNode,L"./VirtualDirectory/DisplayName", bstrFriendlyName);
	hr = GetInputParam(pNode,L"./VirtualDirectory/AppCreate", bstrAppCreate);
	hr = GetInputParam(pNode,L"./VirtualDirectory/AppIsolationLevel", bstrIsoLevel);
	hr = GetInputParam(pNode,L"./VirtualDirectory/AccessRead", bstrAccessRead);
	hr = GetInputParam(pNode,L"./VirtualDirectory/AccessScript", bstrAccessScript);
	hr = GetInputParam(pNode,L"./VirtualDirectory/AccessWrite", bstrAccessWrite);
	hr = GetInputParam(pNode,L"./VirtualDirectory/AccessExecute", bstrAccessExecute);


	// Step 1:  Get Server number where VDir will be created
	if ( !IsPositiveInteger(bServerNumber))
	{
		 // "CreateVDir: Server number missing."
		 hr = E_SCO_IIS_INVALID_INDEX;
		 IIsScoLogFailure();
	}
	else
	{


	   // Step 2: Construct the Metabase path that VDir will be created on.  
	   //         ex)  IIS://localhost/W3SVC/1/ROOT
       bstrConfigPath = IIS_PREFIX;

	   // append server name, W3SVC and server number
	   if ( bstrServer.Length() == 0 )
		  bstrServer = IIS_LOCALHOST;

	   bstrConfigPath.AppendBSTR(bstrServer);
	   bstrConfigPath.Append(IIS_W3SVC);
	   bstrConfigPath.Append(L"/");
	   bstrConfigPath.AppendBSTR(bServerNumber);

	   // if there is a VDir name, then it must be under 'ROOT'
	   if ( bstrVDirName.Length() == 0 )
	   {
		  bstrVDirName = IIS_VROOT;
	   }
	   else
	   {
	      bstrConfigPath.Append(L"/");
	      bstrConfigPath.Append(IIS_VROOT);
	   }

	   //Step 2:  Get the AppFriendlyName
	   if ( bstrFriendlyName.Length() == 0 )
	     bstrFriendlyName = IIS_VDEFAULT_APP;

	   // Step 3: Create a Virtual directory on new IIsWebServer configPath
	   CComBSTR bstrVDirAdsPath;
	   hr = CreateIIs50VDir(IIS_IISWEBVIRTUALDIR,bstrConfigPath,bstrVDirName, bstrFriendlyName, bstrDirPath, bstrVDirAdsPath);
	   IIsScoLogFailure();

	   if ( SUCCEEDED(hr))
	   {
			// Step 4: set each of the properties
			// Set the server bindings
            CComPtr<IADs> pADs;
	        if (SUCCEEDED(hr)) hr = ADsGetObject( bstrVDirAdsPath,IID_IADs, (void **)&pADs);
			if ( FAILED(hr))
			{
				// "CreateVDir: Failed to create IADs object for VDir path."
				hr = E_SCO_IIS_ADS_CREATE_FAILED;
	            IIsScoLogFailure();
			}

			// Bug# 453928 -- Default AppIsolationLevel is 2
	        if ( !IsPositiveInteger(bstrIsoLevel))
				bstrIsoLevel = IIS_DEFAULT_APPISOLATED;

			// Set AppIsolationLevel -- 'AppIsolated'
            if (SUCCEEDED(hr)) hr = SetVDirProperty(pADs, L"AppIsolated",bstrIsoLevel);
	        IIsScoLogFailure();

			// Set AccessFlags' 
			if ( bstrAccessRead.Length() > 0 && SUCCEEDED(hr))
			{
               hr = SetVDirProperty(pADs, L"AccessRead",bstrAccessRead);
	           IIsScoLogFailure();
			}

			if ( bstrAccessRead.Length() > 0 && SUCCEEDED(hr))
			{
               hr = SetVDirProperty(pADs, L"AccessScript",bstrAccessScript);
	           IIsScoLogFailure();
			}

			if ( bstrAccessRead.Length() > 0 && SUCCEEDED(hr))
			{
               hr = SetVDirProperty(pADs, L"AccessWrite",bstrAccessWrite);
	           IIsScoLogFailure();
			}

			if ( bstrAccessRead.Length() > 0 && SUCCEEDED(hr))
			{
               hr = SetVDirProperty(pADs, L"AccessExecute",bstrAccessExecute);
	           IIsScoLogFailure();
			}

			// Step 5:  If AppCreate is FALSE, then remove the following properties.
			// Bug# 453923
			bstrAppCreate.ToUpper();
			if ( SUCCEEDED(hr) && StringCompare(bstrAppCreate, IIS_FALSE) )
			{
				hr = DeleteMetaPropertyValue(pADs, L"AppIsolated");

				if SUCCEEDED(hr) hr = DeleteMetaPropertyValue(pADs, L"AppRoot");

				if SUCCEEDED(hr) hr = DeleteMetaPropertyValue(pADs, L"AppFriendlyName");

				IIsScoLogFailure();
			}




			// If there is a failure.
	        if ( FAILED(hr) )
			{
		        // First delete any virtual directories that were created in the method.  Do this here because a RollBack
		        // will only get called on a completed previous <step>, not a failed step.
		        DeleteIIs50VDir(IIS_IISWEBVIRTUALDIR,bstrConfigPath, bstrVDirName);
			}
			else
			{
			   CComBSTR bstrXML1;
			   // ParseBSTR
               // Input:   IIS://MyServer/W3SVC/1/ROOT/MyDir
			   // Output:  /W3SVC/1/ROOT/MyDir
			   hr = ParseBSTR(bstrVDirAdsPath,bstrServer, 1, 99,bstrXML1);
						  
			   // Matches line:  <output type="WebSiteOutput" root="VirtualDirectory">
			   hr = PutElement(pNode, L"./VirtualDirectory/ConfigPath", bstrXML1.m_str);
			}

		}

	}

	// If there is a failure.
	if ( FAILED(hr) )
	{
		// CreateVDir failed.
		IIsScoLogFailure();
    }
	else
    {
		// WebSite successfully created.  Set Rollback data incase another step fails
		// a a ROllBack is initiated.
		CComVariant varData1(bstrConfigPath);
		CComVariant varData2(bstrVDirName);
		hr = m_pProvHelper->SetRollbackData(IIS_ROLL_ADSPATH, varData1);
		hr = m_pProvHelper->SetRollbackData(IIS_ROLL_VNAME, varData2);

	}

   
    TRACE_EXIT(L"CIISSCO50::CreateVDir");

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//  CIISSCO50::CreateVDir_Rollback
// Author:    Russ Gibfried
// Params:    [in]  none
//            [out] none
// Purpose:   Called by MAPS framework when is encounters a failure during
//            'CreateVDir'.  The Rollback deletes the virtual directory if it can.
//------------------------------------------------------------- 
HRESULT  CIISSCO50::CreateVDir_Rollback( IXMLDOMNode *pXMLNode )
{

  TRACE_ENTER(L"CIISSCO50::CreateVDirRollback");

    HRESULT hr = S_OK;
    CComBSTR bstrVDirName;     // Virtual Directory name, ie, MyDir
	CComBSTR bstrConfigPath;   // Complete ADsPath to VDir: IIS://localhost/W3SVC/1/ROOT

	CComVariant    varConfigPath;
	CComVariant    varVDirName;

	// Read ADsWebPath and ServerNumber to form:   IIS://localhost/W3SVC/1
	hr = m_pProvHelper->GetRollbackData(IIS_ROLL_ADSPATH, &varConfigPath);
	if (SUCCEEDED(hr) )	hr = m_pProvHelper->GetRollbackData(IIS_ROLL_VNAME, &varVDirName);

	if ( SUCCEEDED(hr))
	{
	   bstrVDirName = varVDirName.bstrVal;
	   bstrConfigPath = varConfigPath.bstrVal;

	    // Step 1:  Delete the VDir
	    hr = DeleteIIs50VDir(IIS_IISWEBVIRTUALDIR,bstrConfigPath, bstrVDirName);
        IIsScoLogFailure();
	}
	else
	{
		// "CreateVDirRollback: Failed to retrieve rollback properties."
        hr = E_SCO_IIS_MISSING_FIELD;
	    IIsScoLogFailure();
	}

  TRACE_EXIT(L"CIISSCO50::CreateVDirRollback");

  return hr;
}

///////////////////////////////////////////////////////////////////////////////
//  CIISSCO50::DeleteVDir_Execute
// Author:    Russ Gibfried
// Params:    [in]  none
//            [out] none
// Purpose:   Called by MAPS framework when is encounters an action
//            tag: DeleteVDir.  Code deletes a IIS 5 virtual directory
//             
//------------------------------------------------------------- 
HRESULT  CIISSCO50::DeleteVDir_Execute( IXMLDOMNode *pXMLNode )
{
    TRACE_ENTER(L"CIISSCO50::DeleteVDir");

	CComBSTR bstrServer;        // Server name; localhost if blank
	CComBSTR bstrVDirName;      // VDir name
	CComBSTR bServerNumber;     // WebSite number: 3
	CComBSTR bstrConfigPath;    // Full configuartion path:  IIS://server/W3SVC/1/ROOT/MyDir
	CComPtr<IXMLDOMNode> pNode; // xml node <website>

	HRESULT hr = S_OK;

	CComBSTR bstrDebug;
	hr = pXMLNode->selectSingleNode( L"//executeXml/executeData", &pNode );
	hr = pNode->get_xml(&bstrDebug);
	ATLTRACE(_T("\t>>>DeleteVDir_Execute: xml = : %ls\n"), bstrDebug.m_str);

	// Get properties from XML
	hr = GetInputAttr(pNode, L"./VirtualDirectory", L"number", bServerNumber);
	hr = GetInputParam(pNode,L"./VirtualDirectory/Server", bstrServer);
	hr = GetInputParam(pNode,L"./VirtualDirectory/VDirName", bstrVDirName);

	// Step 1:  Get Server number where VDir will be created
	if ( !IsPositiveInteger(bServerNumber) )
	{
		  hr = E_SCO_IIS_INVALID_INDEX;
		  IIsScoLogFailure();
    }

	if (SUCCEEDED(hr))
	{

	   // Step 2: Construct the Metabase path that VDir will be created on.  
	   //         ex)  IIS://localhost/W3SVC/1/ROOT
       bstrConfigPath = IIS_PREFIX;

	   // append server name, W3SVC and server number
	   if ( bstrServer.Length() == 0 )
		  bstrServer = IIS_LOCALHOST;

	   bstrConfigPath.AppendBSTR(bstrServer);
	   bstrConfigPath.Append(IIS_W3SVC);
	   bstrConfigPath.Append("/");
	   bstrConfigPath.AppendBSTR(bServerNumber);

	   // if there is a VDir name, then it must be under 'ROOT'
	   if ( bstrVDirName.Length() == 0 )
	   {
		  bstrVDirName = IIS_VROOT;
	   }
	   else
	   {
	      bstrConfigPath.Append(L"/");
		  bstrConfigPath.Append(IIS_VROOT);
	   }


	   // Step 2:  Delete the server
	   if (SUCCEEDED(hr)) hr = DeleteIIs50VDir(IIS_IISWEBVIRTUALDIR,bstrConfigPath, bstrVDirName);
       IIsScoLogFailure();

	}

	// If there is a failure
	if ( FAILED(hr) )
	{
		// "DeleteVDir failed."
		IIsScoLogFailure();
    }
	else
    {
		// DeleteSite successfully.  Set Rollback data to be whole xml node
		// incase another step in SCO fails a RollBack is required.
		CComBSTR webXML;
		hr = pNode->get_xml(&webXML);

		// convert BSTR to Variant and save in RollbackData
		CComVariant  varData(webXML);
		hr = m_pProvHelper->SetRollbackData(IIS_ROLL_XNODE, varData);

	}


    TRACE_EXIT(L"CIISSCO50::DeleteVDir");

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//  CIISSCO50::DeleteVDir_Rollback
// Author:    Russ Gibfried
// Params:    [in]  none
//            [out] none
// Purpose:   Called by MAPS framework when is encounters a failure during
//            'DeleteVDir'.  The Rollback recreates the virtual directory if it can.
//------------------------------------------------------------- 
HRESULT  CIISSCO50::DeleteVDir_Rollback( IXMLDOMNode *pXMLNode )
{
  TRACE_ENTER(L"CIISSCO50::DeleteVDirRollback");

	CComBSTR bstrConfigPath;    // adsPath:   IIS://server/W3SVC/1/ROOT/MyDir
	CComBSTR bServerNumber;     // Server number
	CComBSTR bstrServer;        // Server name; localhost if blank
	//CComBSTR bFilePermissions;  // File permissions: domain\user:F
	CComBSTR bstrDirPath;          // root directory path: c:/inetpub
	CComBSTR bstrVDirName;      // Virtual Directory name; MyDir
	CComBSTR bstrFriendlyName;  // Display name or AppFriendlyName
	CComBSTR bstrAppCreate;     // AppCreate flag -- TRUE/FALSE
	CComBSTR bstrIsoLevel;      // AppIsolationLevel 
	CComBSTR bstrAccessRead;    // AccessFalgs - AccessRead = TRUE/FALSE
	CComBSTR bstrAccessScript;  // AccessFalgs - AccessScript = TRUE/FALSE
	CComBSTR bstrAccessWrite;    // AccessFalgs - AccessWrite = TRUE/FALSE
	CComBSTR bstrAccessExecute;  // AccessFalgs - AccessExecute = TRUE/FALSE

	CComVariant xmlString;

	CComPtr<IXMLDOMDocument> pDoc;       // xml document 
	CComPtr<IXMLDOMNodeList> pNodeList; // xml node list <website>
	CComPtr<IXMLDOMNode> pNode; // xml node <website>

	HRESULT hr = S_OK;

	// Get RollBack data.  Will bein form:  <executeData><Website number=''>...
	hr = m_pProvHelper->GetRollbackData(IIS_ROLL_XNODE, &xmlString);

	// load xml string into XML Dom
	if ( xmlString.bstrVal != NULL )
	{
		hr = CoCreateInstance(
                __uuidof(DOMDocument),
                NULL,
                CLSCTX_ALL,
                __uuidof(IXMLDOMDocument),
                (LPVOID*)&pDoc);

		VARIANT_BOOL bSuccess = VARIANT_FALSE;
        hr = pDoc->loadXML(xmlString.bstrVal, &bSuccess);

        if ( SUCCEEDED(hr) && bSuccess != VARIANT_FALSE) 
		{
		   hr = pDoc->getElementsByTagName(XML_NODE_VDIR,&pNodeList);
		   long numChild = 0;
		   if (SUCCEEDED(hr)) hr = pNodeList->get_length(&numChild);

		   if ( numChild > 0 )
		   {
              hr = pNodeList->nextNode(&pNode);

			  // Get Server number from attribute map <VirtualDirectory number=2">
		      if (SUCCEEDED(hr) ) hr = GetInputAttr(pNode, L"", L"number", bServerNumber);
              IIsScoLogFailure();

		      // Check Server number is valid
		      if ( !IsPositiveInteger(bServerNumber) )
			  {
		          hr = E_SCO_IIS_INVALID_INDEX;
                  IIsScoLogFailure();
			  }

	          // Get properties from XML
	          if (SUCCEEDED(hr) ) hr = GetInputParam(pNode, L"./VirtualDirectory/Server", bstrServer);
	          //if (SUCCEEDED(hr) ) hr = GetInputParam(pNode, L"./VirtualDirectory/FilePermissions", bFilePermissions);
	          if (SUCCEEDED(hr) ) hr = GetInputParam(pNode, L"./VirtualDirectory/Path", bstrDirPath);
	          if (SUCCEEDED(hr) ) hr = GetInputParam(pNode, L"./VirtualDirectory/VDirName", bstrVDirName);
	          if (SUCCEEDED(hr) ) hr = GetInputParam(pNode, L"./VirtualDirectory/DisplayName", bstrFriendlyName);
	          if (SUCCEEDED(hr) ) hr = GetInputParam(pNode, L"./VirtualDirectory/AppCreate", bstrAppCreate);
	          if (SUCCEEDED(hr) ) hr = GetInputParam(pNode, L"./VirtualDirectory/AppIsolationLevel", bstrIsoLevel);
	          if (SUCCEEDED(hr) ) hr = GetInputParam(pNode, L"./VirtualDirectory/AccessRead", bstrAccessRead);
	          if (SUCCEEDED(hr) ) hr = GetInputParam(pNode, L"./VirtualDirectory/AccessScript", bstrAccessScript);
	          if (SUCCEEDED(hr) ) hr = GetInputParam(pNode, L"./VirtualDirectory/AccessWrite", bstrAccessWrite);
	          if (SUCCEEDED(hr) ) hr = GetInputParam(pNode, L"./VirtualDirectory/AccessExecute", bstrAccessExecute);


	          // Create a IIS metabase path.  ex. IIS://localhost/W3SVC/1/ROOT 
              bstrConfigPath = IIS_PREFIX;

	          // append server name, W3SVC and server number
	          if ( bstrServer.Length() == 0 )
		        bstrServer = IIS_LOCALHOST;

	          bstrConfigPath.AppendBSTR(bstrServer);
	          bstrConfigPath.Append(IIS_W3SVC);
	          bstrConfigPath.Append(L"/");
	          bstrConfigPath.AppendBSTR(bServerNumber);

	           // if there is a VDir name, then it must be under 'ROOT'
	          if ( bstrVDirName.Length() == 0 )
			  {
		         bstrVDirName = IIS_VROOT;
			  }
	          else
			  {
	              bstrConfigPath.Append(L"/");
	              bstrConfigPath.Append(IIS_VROOT);
			  }


	          //Step 2:  Get the AppFriendlyName
	         if ( bstrFriendlyName.Length() == 0 )
	             bstrFriendlyName = IIS_VDEFAULT_APP;

	         // Step 3: Create a Virtual directory on new IIsWebServer configPath
	         CComBSTR bstrVDirAdsPath;
	         hr = CreateIIs50VDir(IIS_IISWEBVIRTUALDIR,bstrConfigPath,bstrVDirName, bstrFriendlyName, bstrDirPath, bstrVDirAdsPath);
	         IIsScoLogFailure();

	         if ( SUCCEEDED(hr))
			 {
			     // Step 4: set each of the properties
			     // Set the server bindings
                 CComPtr<IADs> pADs;
	             hr = ADsGetObject( bstrVDirAdsPath,IID_IADs, (void **)&pADs);
				 if ( FAILED(hr) )
				 {
					// "DeleteVDirRollback: Failed to create IADs object for VDir path."
					hr = E_SCO_IIS_ADS_CREATE_FAILED;
	                IIsScoLogFailure();
                 }

				 // Bug# 453928 -- Default AppIsolationLevel is 2
	             if ( !IsPositiveInteger(bstrIsoLevel))
				     bstrIsoLevel = IIS_DEFAULT_APPISOLATED;

			     // Set AppIsolationLevel -- 'AppIsolated'
                 if (SUCCEEDED(hr)) hr = SetVDirProperty(pADs, L"AppIsolated",bstrIsoLevel);
	             IIsScoLogFailure();

			     // Set AccessFlags' 
			     if ( bstrAccessRead.Length() > 0 && SUCCEEDED(hr))
				 {
                     hr = SetVDirProperty(pADs, L"AccessRead",bstrAccessRead);
	                IIsScoLogFailure();
				 }

			     if ( bstrAccessRead.Length() > 0 && SUCCEEDED(hr))
				 {
                    hr = SetVDirProperty(pADs, L"AccessScript",bstrAccessScript);
	                IIsScoLogFailure();
				 }

			     if ( bstrAccessRead.Length() > 0 && SUCCEEDED(hr))
				 {
                    hr = SetVDirProperty(pADs, L"AccessWrite",bstrAccessWrite);
	                IIsScoLogFailure();
				 }

			     if ( bstrAccessRead.Length() > 0 && SUCCEEDED(hr))
				 {
                     hr = SetVDirProperty(pADs, L"AccessExecute",bstrAccessExecute);
	                 IIsScoLogFailure();
				 }

				 // Step 5:  If AppCreate is FALSE, then remove the following properties.
				 bstrAppCreate.ToUpper();
				 if ( SUCCEEDED(hr) && StringCompare(bstrAppCreate, IIS_FALSE) )
				 {
					hr = DeleteMetaPropertyValue(pADs, L"AppIsolated");

					if SUCCEEDED(hr) hr = DeleteMetaPropertyValue(pADs, L"AppRoot");

					if SUCCEEDED(hr) hr = DeleteMetaPropertyValue(pADs, L"AppFriendlyName");

					IIsScoLogFailure();
				 }



			 } // end if step 3
		 }  
		 else
		 {
		    // L"DeleteVDirRollback: VirtualDirectory child node missing from XML DOM Rollback data."
            IIsScoLogFailure();

		 } // end if child node

	   }
	   else
	   {
		// L"DeleteVDirRollback: Could not load XML DOM from Rollback data."
        IIsScoLogFailure();

	   } // end if loadXML
	}
	else
	{
		// L"DeleteVDirRollback: xml string from Rollback data NULL."
        IIsScoLogFailure();

	}  // end if xmlString != NULL


   // "DeleteVDirRollback failed."
  if ( FAILED(hr) )
	    IIsScoLogFailure();


  TRACE_EXIT(L"CIISSCO50::DeleteVDirRollback");

  return hr;
}

///////////////////////////////////////////////////////////////////////////////
//  CIISSCO50::SetConfigProperty_Execute
// Author:    Russ Gibfried
// Params:    [in]  none
//            [out] none
// Purpose:   Called by MAPS framework to set a IIS property value. 
//------------------------------------------------------------- 
HRESULT  CIISSCO50::SetConfigProperty_Execute( IXMLDOMNode *pXMLNode )
{
    TRACE_ENTER(L"CIISSCO50::SetConfigProperty");

	HRESULT hr = S_OK;
	CComBSTR bstrPathXML;           // metabase path
	CComBSTR bstrPropertyXML;       // IIS property to set
	CComBSTR bstrNewValueXML;       // new property value
	CComBSTR bstrOldValue;          // current value for roll-back 
	CComBSTR bstrAdsiPath;          // adsi path: IIS:// + bstrPathXML

	CComPtr<IXMLDOMNode> pNode;
	CComBSTR propertyXML;

	// Get node in format: <executeData><Website number=''><Root />...
	hr = pXMLNode->selectSingleNode( L"//executeXml/executeData", &pNode );

	CComBSTR bstrDebug;
	hr = pNode->get_xml(&bstrDebug);
	ATLTRACE(_T("\t>>>SetConfigProperty_Execute: xml = : %ls\n"), bstrDebug.m_str);
	

	// Step 1:  Get the metabase path, property name and pointer to Property Node
	hr = GetInputAttr(pNode, L"./ConfigPath", L"name", bstrPathXML);
	if (SUCCEEDED(hr)) hr = GetInputAttr(pNode, L"./Property", L"name", bstrPropertyXML);
	if (SUCCEEDED(hr)) hr = GetInputParam(pNode, L"./Property", bstrNewValueXML);

	// Step 2:  Get current value
    if (SUCCEEDED(hr))
	{
		// Create a IIS metabase path.  ex. IIS://W3SVC/MyServer/1 
        bstrAdsiPath = IIS_PREFIX;
		bstrAdsiPath.AppendBSTR(bstrPathXML);

		// Bind to ADs object
		CComPtr<IADs> pADs;
		hr = ADsGetObject(bstrAdsiPath, IID_IADs, (void**) &pADs );
	    if (SUCCEEDED(hr)) 
		{
			 hr = GetMetaPropertyValue(pADs, bstrPropertyXML, bstrOldValue);
			 IIsScoLogFailure();

			 //Step 3:  Set property data
			 if (SUCCEEDED(hr))
			 {
				    hr = SetMetaPropertyValue(pADs, bstrPropertyXML, bstrNewValueXML);
					IIsScoLogFailure();

			 }  // End if 'GetIIsPropertyValue'
		}
		else
		{
			// "SetConfigProperty: Failed to bind to ADs object."
			hr = E_SCO_IIS_ADS_CREATE_FAILED;
            IIsScoLogFailure();
		}
	}  
    else
    {
		hr = E_SCO_IIS_MISSING_FIELD;
	}   //End if 'Step 2'


	// If there is a failure
	if ( FAILED(hr) )
	{
		// SetConfigProperty Failed
		IIsScoLogFailure();
	}
	else
	{
		// convert BSTR to Variant and save in RollbackData
		CComVariant  varData1(bstrAdsiPath);
		hr = m_pProvHelper->SetRollbackData(L"ConfigPath", varData1);

		// convert BSTR to Variant and save in RollbackData
		CComVariant  varData2(bstrPropertyXML);
		hr = m_pProvHelper->SetRollbackData(L"Property", varData2);

		// convert BSTR to Variant and save in RollbackData
		CComVariant  varData3(bstrOldValue);
		hr = m_pProvHelper->SetRollbackData(L"Value", varData3);

    }

	
	TRACE_EXIT(L"CIISSCO50::SetConfigProperty");

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//  CIISSCO50::SetConfigProperty_Rollback
// Author:    Russ Gibfried
// Params:    [in]  none
//            [out] none
// Purpose:   Called by MAPS framework to rollback a failed called
//            tp 'SetMbProperty' above. 
//------------------------------------------------------------- 
HRESULT  CIISSCO50::SetConfigProperty_Rollback( IXMLDOMNode *pXMLNode )
{
	TRACE_EXIT(L"CIISSCO50::SetConfigPropertyRollback");

    HRESULT hr = S_OK;
	
	CComBSTR bstrAdsiPath;
	CComBSTR bstrPropertyXML;
	CComBSTR bstrOldValue;


	// Get Rollback values, then convert from variants to BSTRs
    CComVariant varAdsiPath;
	hr = m_pProvHelper->GetRollbackData(L"ConfigPath", &varAdsiPath);

	CComVariant varPropertyXML;
	if (SUCCEEDED(hr)) hr = m_pProvHelper->GetRollbackData(L"Property", &varPropertyXML);

	CComVariant varOldValue;
	if (SUCCEEDED(hr)) hr = m_pProvHelper->GetRollbackData(L"Value", &varOldValue);

	if (SUCCEEDED(hr)) 
	{
		// Convert to BSTRs
		bstrAdsiPath = varAdsiPath.bstrVal;
		bstrPropertyXML = varPropertyXML.bstrVal;
		bstrOldValue = varOldValue.bstrVal;


		// Bind to ADs object
		CComPtr<IADs> pADs;
		hr = ADsGetObject(bstrAdsiPath, IID_IADs, (void**) &pADs );
	    if (SUCCEEDED(hr)) 
		{
			hr = SetMetaPropertyValue(pADs, bstrPropertyXML, bstrOldValue);
			IIsScoLogFailure();
        }
		else
		{
			hr = E_SCO_IIS_ADS_CREATE_FAILED;
            IIsScoLogFailure();
		}
	}
	else
	{
		// "SetConfigPropertyRollback: Failed to retrieve required rollback property ."
		hr = E_SCO_IIS_MISSING_FIELD;
        IIsScoLogFailure();
	}

	// Log failure -- SetConfigPropertyRollback Failed
	if ( FAILED(hr) )
		IIsScoLogFailure();

 	TRACE_EXIT(L"CIISSCO50::SetConfigPropertyRollback");

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//  CIISSCO50::GetConfigProperty_Execute
// Method:    GetConfigProperty
// Author:    Russ Gibfried
// Params:    [in]  none
//            [out] none
// Purpose:   Called by MAPS framework to get a IIS property value. 
//------------------------------------------------------------- 
HRESULT  CIISSCO50::GetConfigProperty_Execute( IXMLDOMNode *pXMLNode )
{
 	TRACE_ENTER(L"CIISSco50Obj::GetConfigProperty");

    HRESULT hr = S_OK;
	CComBSTR bstrPathXML;           // metabase path
	CComBSTR bstrPropertyXML;       // IIS property to set
	CComBSTR bstrValue;             // property value
	CComBSTR bstrAdsiPath;          // complete IIS metabase path
	CComPtr<IXMLDOMNode> pNode;     // xml node <property>

	// Get node in format: <executeData><Website number=''><Root />...
	hr = pXMLNode->selectSingleNode( L"//executeXml/executeData", &pNode );

	CComBSTR bstrDebug;
	hr = pNode->get_xml(&bstrDebug);
	ATLTRACE(_T("\t>>>GetConfigProperty_Execute: xml = : %ls\n"), bstrDebug.m_str);
	

	// Step 1:  Get the metabase path, property name and pointer to Property Node
	hr = GetInputAttr(pNode, L"./ConfigPath", L"name", bstrPathXML);
	hr = GetInputAttr(pNode, L"./Property", L"name", bstrPropertyXML);

	// Step 2:  Get current value
    if (SUCCEEDED(hr))
	{
		// Create a IIS metabase path.  ex. IIS://W3SVC/MyServer/1 
        bstrAdsiPath.Append(IIS_PREFIX);
		bstrAdsiPath.AppendBSTR(bstrPathXML);

		// Bind to ADs object
		CComPtr<IADs> pADs;
		hr = ADsGetObject(bstrAdsiPath, IID_IADs, (void**) &pADs );

	    if (SUCCEEDED(hr))
		{
			hr = GetMetaPropertyValue(pADs, bstrPropertyXML, bstrValue);
            if (SUCCEEDED(hr))
			{
			    // Set the element value
				hr = PutElement(pNode, L"./Property", bstrValue.m_str);
				
				// Debug render the xml
				CComBSTR bstring;
				hr = pNode->get_xml(&bstring);
				ATLTRACE(_T("\tGetConfigProperty: %ws\n"), bstring);

	            IIsScoLogFailure();

			}
	        else
			{
				// "GetConfigProperty: Failed to get property."
		        hr = E_SCO_IIS_GET_PROPERTY_FAILED;
	            IIsScoLogFailure();
			}  // End if 'GetIIsPropertyValue'
		}
		else
		{
			// "GetConfigProperty: Failed to bind to ADs object."
			hr = E_SCO_IIS_ADS_CREATE_FAILED;
            IIsScoLogFailure();
		}
	}  
    else
	{
		// "GetConfigProperty: Input values missing."
		hr =  E_SCO_IIS_MISSING_FIELD;
        IIsScoLogFailure();
	}   

	// GetConfigProperty failed
	if ( FAILED(hr) )
		IIsScoLogFailure();

	TRACE_EXIT(L"CIISSco50Obj::GetConfigProperty");

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//  CIISSCO50::EnumConfig_Execute
// Params:    [in]  none
//            [out] none
// Purpose:   Called by MAPS framework to list properties on a given adsi path.
//            It will also list subnodes
//            This is analogous to adsutil enum /w3svc/1 
//------------------------------------------------------------- 
HRESULT  CIISSCO50::EnumConfig_Execute( IXMLDOMNode *pXMLNode )
{
    TRACE_ENTER(L"CIISSCO50::EnumConfig");

	HRESULT hr = S_OK;
	CComBSTR bstrPathXML;           // metabase path
	CComBSTR bstrAdsiPath;          // adsi path: IIS:// + bstrPathXML
	CComBSTR bstrIsInherit;         // True or false to check inheritable properties

	CComPtr<IXMLDOMNode> pNode;
	CComPtr<IXMLDOMNode> pConfigNode;
	CComPtr<IXMLDOMNode> pTemp;
	CComBSTR xmlString;

	// Get node in format: <executeData><Website number=''><Root />...
	hr = pXMLNode->selectSingleNode( L"//executeXml/executeData", &pNode );

	CComBSTR bstrDebug;
	hr = pNode->get_xml(&bstrDebug);
	ATLTRACE(_T("\t>>>EnumConfig_Execute: xml = : %ls\n"), bstrDebug.m_str);
	

    // Step .5:  Get isInheritable flag.  If blank, then default = TRUE
	hr = GetInputAttr(pNode, L"./ConfigPath", XML_ATT_ISINHERITABLE, bstrIsInherit);
	
	// Step 1:  Get the metabase path
	hr = GetInputAttr(pNode, L"./ConfigPath", L"name", bstrPathXML);


    if (SUCCEEDED(hr))
	{
		// Step 2 Create a IIS metabase path to find properties on.  ex. IIS://W3SVC/MyServer/1 
        bstrAdsiPath = IIS_PREFIX;
		bstrAdsiPath.AppendBSTR(bstrPathXML);

		// Step 3: Returns map of all properties set on this path (not inherited)
		Map myProps;
		hr = EnumPropertyValue(bstrAdsiPath, bstrIsInherit, myProps);

		if (SUCCEEDED(hr) )
		{
		   // Step 4:  Create the <ConfigPath> element and append to pNode
		   xmlString = "<ConfigPath name='";
		   xmlString.AppendBSTR(bstrAdsiPath);
		   xmlString.Append(L"'></ConfigPath>");
	       hr = AppendElement(pNode,xmlString,pConfigNode);

		   if ( SUCCEEDED(hr))
		   {

		      // Iterate through property Map and append to pNode
		      Map::iterator it;
		      for (it=myProps.begin(); it != myProps.end(); it++)
			  {
			    // Create property element: <Property name='myProp'>ItsValue</Property>
			    xmlString = "<Property name='";
		        xmlString.AppendBSTR((*it).first);
		        xmlString.Append(L"'>");
		        xmlString.AppendBSTR((*it).second);
		        xmlString.Append(L"</Property>");
			    hr = AppendElement(pConfigNode,xmlString,pTemp);
			    pTemp = NULL;
			  }
		   }
		   else
		   {
			  // "EnumConfig: Call to AppendElement failed."
              IIsScoLogFailure();
		   }

		    // Step 5: Get a List of subnodes and append to pNode
  		    Map myNode;
		    int iCount = 0;
		    hr = EnumPaths(false,bstrAdsiPath,myNode);
		    if (SUCCEEDED(hr) )
			{
			   // Iterate through subnodes and append to pNode
 		      Map::iterator it;
              for (it=myNode.begin(); it != myNode.end(); it++)
			   {
				   // In this case, skip the first element since it will
				   // be the <ConfigPath> already listed above.
				   if ( iCount != 0 )
				   {
			          xmlString = "<ConfigPath name='";
		              xmlString.AppendBSTR((*it).first);
		              xmlString.Append(L"' />");
			          hr = AppendElement(pNode,xmlString,pTemp);
				      pTemp = NULL;
				   }
				   iCount++;

			   }
			   
			}
		    else
			{
				// "EnumConfig: Failed to enumerate paths."
				IIsScoLogFailure();
			}

		}
		else
		{
			// "EnumConfig: Failed to enumerate properties."
			IIsScoLogFailure();
		}

	}  
    else
    {
		// "EnumConfig: Input parameter missing."
		hr = E_SCO_IIS_MISSING_FIELD;
		IIsScoLogFailure();
	}   //End if 'Step 2'


	
	TRACE_EXIT(L"CIISSco50Obj::EnumConfig");

	return hr;
 
}

///////////////////////////////////////////////////////////////////////////////
//  CIISSCO50::EnumConfigRecursive_Execute
// Author:    Russ Gibfried
// Params:    [in]  none
//            [out] none
// Purpose:   Called by MAPS framework to list properties on a given adsi path plus
//            recursively list all subnodes and their properties
//            This is analogous to adsutil enum_all /w3svc/1 
//            Note:  Only mandatory and optional properties specifically set
//                   on a given node are listed since listing all inherited properties
//                   would result in a huge output to MAPS
//------------------------------------------------------------- 
HRESULT  CIISSCO50::EnumConfigRecursive_Execute( IXMLDOMNode *pXMLNode )
{
    TRACE_ENTER(L"CIISSCO50::EnumConfigRecursive");

	HRESULT hr = S_OK;
	CComBSTR bstrPathXML;           // metabase path
	CComBSTR bstrAdsiPath;          // adsi path: IIS:// + bstrPathXML
	CComBSTR bstrIsInherit;         // isInheritable flag (default is true)

	CComPtr<IXMLDOMNode> pNode;
	CComPtr<IXMLDOMNode> pConfigNode;
	CComPtr<IXMLDOMNode> pTemp;
	CComBSTR xmlString;
  	Map myNode;                    // map of adsi paths
	Map myProps;                   // map of property/values
	Map::iterator it1;
	Map::iterator it2;


	// Get node in format: <executeData><Website number=''><Root />...
	hr = pXMLNode->selectSingleNode( L"//executeXml/executeData", &pNode );

	CComBSTR bstrDebug;
	hr = pNode->get_xml(&bstrDebug);
	ATLTRACE(_T("\t>>>EnumConfigRecursive_Execute: xml = : %ls\n"), bstrDebug.m_str);
	

	// Step .5:  Get isInheritable flag.  If blank, then default = TRUE
	hr = GetInputAttr(pNode, L"./ConfigPath", XML_ATT_ISINHERITABLE, bstrIsInherit);

	// Step 1:  Get the metabase path
	hr = GetInputAttr(pNode, L"./ConfigPath", L"name", bstrPathXML);


    if (SUCCEEDED(hr))
	{
		// Step 2 Create a IIS metabase path to find properties on.  ex. IIS://W3SVC/MyServer/1 
        bstrAdsiPath = IIS_PREFIX;
		bstrAdsiPath.AppendBSTR(bstrPathXML);

		// Step 3: Get a list of all nodes; 'true' for recursive
		hr = EnumPaths(true,bstrAdsiPath,myNode);
		if (SUCCEEDED(hr) )
		{
		   // Iterate through subnodes and append to pNode
           for (it1=myNode.begin(); it1 != myNode.end(); it1++)
		   {

			   xmlString = "<ConfigPath name='";
		       xmlString.AppendBSTR((*it1).first);
		       xmlString.Append(L"'></ConfigPath>");
			   hr = AppendElement(pNode,xmlString,pConfigNode);

		       // Step 4: Returns map of all properties set on this path (not inherited)
			   if ( SUCCEEDED(hr))
			   {
                  myProps.clear();
				  // Pass in the path from map (ie, IIS:/w3svc/localhost/1/root )
		          hr = EnumPropertyValue((*it1).first,bstrIsInherit, myProps);

		          if (SUCCEEDED(hr) )
				  {
		              // Iterate through property Map and append to pNode
		              for (it2=myProps.begin(); it2 != myProps.end(); it2++)
					  {
			             // Create property element: <Property name='myProp'>ItsValue</Property>
			             xmlString = "<Property name='";
						 xmlString.AppendBSTR((*it2).first);
						 xmlString.Append(L"'>");
						 xmlString.AppendBSTR((*it2).second);
						 xmlString.Append(L"</Property>");
						 hr = AppendElement(pConfigNode,xmlString,pTemp);
						 pTemp = NULL;
					  }

					  // Done with pConfigNode so set it to NULL
					  pConfigNode = NULL;

				   }
				   else
				   {
					   // "EnumConfigRecursive: Call to EnumPropertyValue failed."
					  IIsScoLogFailure();
				   }
			   } 
			   else
			   {
				   // "EnumConfigRecursive: Call to AppendElement failed."
				   IIsScoLogFailure();

			   }

		   } // end for myNode


		}
		else
		{
			// "EnumConfigRecursive: Failed to enumerate paths."
			IIsScoLogFailure();
		}

	}  
    else
    {
		// "EnumConfigRecursive: Input parameter missing."
		hr = E_SCO_IIS_MISSING_FIELD;
		IIsScoLogFailure();
	}   //End if 'Step 2'


	TRACE_EXIT(L"CIISSCO50::EnumConfigRecursive");

	return hr;
}


//--------------------------- ADSI Helper Methods ------------------------------//

//-----------------------------------------------------------
// Method:    GetMetaPropertyValue
// Author:    Russ Gibfried
// Params:    [in]  pADs     -- IADs pointer to metabase path for property value
//                  bstrName -- name or property
//            [out] pVal -- value of property
// Purpose:   Return value of particular property 
//------------------------------------------------------------- 
HRESULT CIISSCO50::GetMetaPropertyValue(CComPtr<IADs> pADs, CComBSTR bstrName, CComBSTR& pVal)
{
    HRESULT hr;
	CComVariant var;
	CComBSTR bValue;
 
	hr = pADs->Get(bstrName, &var);
    if (SUCCEEDED(hr))
	{

		switch (var.vt)
		{	case VT_EMPTY:
			{	
				break;
			}
			case VT_NULL:
			{	
				break;
			}
			case VT_I4:
			{	
				hr = var.ChangeType(VT_BSTR);
			    if ( SUCCEEDED(hr) ) pVal = V_BSTR(&var);

			break;
				}
			case VT_BSTR:
			{	
				pVal = V_BSTR(&var);
				break;
			}
			case VT_BOOL:
			{	
				
				if (var.boolVal == 0)
				{	
					pVal = L"False";
				}
				else
				{	
					pVal = L"True";
				}
				break;
			}
			case VT_ARRAY|VT_VARIANT:	// SafeArray of Variants
			{	
				
			    LONG lstart, lend;
                SAFEARRAY *sa = V_ARRAY( &var );
                VARIANT varItem;
 
                // Get the lower and upper bound
                hr = SafeArrayGetLBound( sa, 1, &lstart );
                hr = SafeArrayGetUBound( sa, 1, &lend );
 
                // Now iterate and print the content
                VariantInit(&varItem);
			    CComBSTR bString;
                for ( long idx=lstart; idx <= lend; idx++ )
				{
                  hr = SafeArrayGetElement( sa, &idx, &varItem );
                  pVal = V_BSTR(&varItem);
                  VariantClear(&varItem);
				}
				 
				break;
			}
			case VT_DISPATCH:
			{	
				//if (!_wcsicmp(bstrName, L"ipsecurity"))
				break;
			} 
			default:
			{	break;
			}
		}


	}

	if ( FAILED(hr))
		hr = E_SCO_IIS_GET_PROPERTY_FAILED;

	return hr;

}


//-----------------------------------------------------------
// Method:    SetMetaPropertyValue
// Author:    Russ Gibfried
// Params:    [in]  pADs     -- pointer to metabase path object; ie 'IIS://MachineName/W3SVC/1'  
//                  bstrName -- name or property
//                  bstrValue -- property value to set
//            [out] none
// Purpose:   Set the value of particular a particular property 
//------------------------------------------------------------- 
HRESULT CIISSCO50::SetMetaPropertyValue(CComPtr<IADs> pADs, CComBSTR bstrName, CComBSTR bstrValue)
{
    HRESULT hr = E_SCO_IIS_SET_PROPERTY_FAILED;


	hr = pADs->Put(bstrName, CComVariant(bstrValue));
	if (SUCCEEDED(hr))
	{
		hr = pADs->SetInfo();
	}

	return hr;

}

//-----------------------------------------------------------
// Method:    DeleteMetaPropertyValue
// Author:    Russ Gibfried
// Params:    [in]  pADs     -- pointer to metabase path object; ie 'IIS://MachineName/W3SVC/1'  
//                  bstrName -- name or property
//                  bstrValue -- property value to set
//            [out] none
// Purpose:   Set the value of particular a particular property 
//------------------------------------------------------------- 
HRESULT CIISSCO50::DeleteMetaPropertyValue(CComPtr<IADs> pADs, CComBSTR bstrName)
{
    HRESULT hr = E_SCO_IIS_SET_PROPERTY_FAILED;


	VARIANT vProp;
	VariantInit(&vProp);
	hr = pADs->PutEx(1, bstrName, vProp); // 1 = Clear
	if (SUCCEEDED(hr))
	{
		hr = pADs->SetInfo();
	}

	VariantClear(&vProp);
	return hr;

}


//-----------------------------------------------------------
// Method:    CreateIIs50Site
// Author:    Russ Gibfried
// Params:    [in]  bstrType     -- 'Type' of site, ie 'IIsWebServer' or 'IIsFtpServer
//                  bWebADsPath  -- AdsPath,  ex. IIS:/localhost/w3svc
//                  bSiteIndex   -- Site number, ie, 1

//            [out] bstrConfigPath -- craeted adsi path, ex. IIS://localhost/W3SVC/1
// Purpose:   Set the value of particular a particular property 
//------------------------------------------------------------- 
HRESULT CIISSCO50::CreateIIs50Site(CComBSTR bstrType,CComBSTR bWebADsPath, 
								  CComBSTR bServerNumber,CComBSTR &bstrConfigPath)
{
	HRESULT hr = S_OK;
	CComPtr<IADs> pADs;
	CComPtr<IADsContainer> pCont;
	IDispatch* pDisp;
	CComVariant var;

    // Bind to a domain object:  'IIS://MachineName/W3SVC'   
	hr = ADsGetObject( bWebADsPath,IID_IADsContainer, (void **)&pCont);
    if (SUCCEEDED(hr))
	{

	    //Create a virtual web server
		hr = pCont->Create(bstrType,bServerNumber,&pDisp);
		if ( SUCCEEDED(hr)) 
		{

		     // Get the newly created ConfigPath value
		     hr = pDisp->QueryInterface(IID_IADs, (void**)&pADs);
		     if ( SUCCEEDED(hr)) 
			 {
                 // Release the IDispath pointer
			     pDisp->Release();

				 // Get the newly created ADsPath for this Server
			     if (SUCCEEDED(hr)) hr = pADs->get_ADsPath(&bstrConfigPath);
			     hr = pADs->SetInfo();

				 // Return the correct HRESULT depending is Web Site of FTP Site
				 if (FAILED(hr))
				 {
					 if (StringCompare(bstrType,IIS_IISWEBSERVER))
					 {
						 hr = E_SCO_IIS_CREATE_WEB_FAILED;
					 } 
					 else 
					 {
						 hr = E_SCO_IIS_CREATE_FTP_FAILED;
					 }
				 }
						 
		
			 }

		} // end if Create
		else
		{
			 // Return the correct HRESULT depending is Web Site of FTP Site
			 if (StringCompare(bstrType,IIS_IISWEBSERVER))
			 {
				 hr = E_SCO_IIS_CREATE_WEB_FAILED;
			 } 
			 else 
			 {
				 hr = E_SCO_IIS_CREATE_FTP_FAILED;
			 }
		}
   
    } // end if ADsGetObject
	else
	{
        hr = E_SCO_IIS_ADS_CREATE_FAILED;
	}


	return hr;
}


//-----------------------------------------------------------
// Method:    DeleteIIs50Site
// Author:    Russ Gibfried
// Params:    [in]  bstrType      -- 'Type' of site, ie 'IIsWebServer' or 'IIsFtpServer
//                  bWebADsPath      -- server adsi path ex. IIS://localhost/W3SVC
//                  bServerNumber -- Server index number to delete
// Purpose:   Delete a Web or FTP server 
//------------------------------------------------------------- 
HRESULT CIISSCO50::DeleteIIs50Site(CComBSTR bstrType,CComBSTR bWebADsPath,CComBSTR bServerNumber)
{
	HRESULT hr = S_OK;
	CComPtr<IADsContainer> pCont;

    // Bind to a domain object:  'IIS://MachineName/W3SVC'   
	hr = ADsGetObject( bWebADsPath,IID_IADsContainer, (void **)&pCont);

	//Delete a virtual web server
    if (SUCCEEDED(hr))
	{
		hr = pCont->Delete(bstrType,bServerNumber);
		if (FAILED(hr)) 
		{

			 // Return the correct HRESULT depending is Web Site of FTP Site
			 if (StringCompare(bstrType,IIS_IISWEBSERVER))
			 {
				 hr = E_SCO_IIS_DELETE_WEB_FAILED;
			 } 
			 else 
			 {
				 hr = E_SCO_IIS_DELETE_FTP_FAILED;
			 }
			
			
		}
	}
	else
	{
		hr = E_SCO_IIS_ADSCONTAINER_CREATE_FAILED;
	}

	return hr;
}


//-----------------------------------------------------------
// Method:    CreateIIs50VDir
// Author:    Russ Gibfried
// Params:    [in]  bstrType     -- 'Type' of site, ie 'IIsWebVirtualDir"
//                  bWebADsPath     -- IIS://localhost/W3SVC/1
//                  bVDirName   -- url, ex. 'ROOT'
//                  bAppFriendName -- 'Default Application'
//                  bVDirPath   -- url, ex.  c:/inetpub/myDir
//
//            [out] bstrConfigPath -- created adsi path, ex. IIS://localhost/W3SVC/1/ROOT
// Purpose:   Set the value of particular a particular property 
//------------------------------------------------------------- 
HRESULT CIISSCO50::CreateIIs50VDir(CComBSTR bstrType,CComBSTR bWebADsPath, CComBSTR bVDirName,
								 CComBSTR bAppFriendName, CComBSTR bVDirPath,CComBSTR &bstrConfigPath)
{
	HRESULT hr = S_OK;
	CComPtr<IADs> pADs;
	CComPtr<IADsContainer> pCont;
	IDispatch* pDisp;
	CComVariant var;


    // Bind to a domain object:  'IIS://MachineName/W3SVC/1'   
	hr = ADsGetObject( bWebADsPath,IID_IADsContainer, (void **)&pCont);
    if (SUCCEEDED(hr))
	{

	    //Create a virtual directory for web server
		hr = pCont->Create(bstrType,bVDirName,&pDisp);
		if ( SUCCEEDED(hr)) 
		{

		     // Get the newly created ConfigPath value
		     hr = pDisp->QueryInterface(IID_IADs, (void**)&pADs);
		     if ( SUCCEEDED(hr)) 
			 {

				 // Release the IDispath pointer
			     pDisp->Release();

				 // Set Root path and AccessRead
				 if (SUCCEEDED(hr)) hr = pADs->Put(L"Path",CComVariant(bVDirPath));
				 if (SUCCEEDED(hr)) hr = pADs->Put(L"AccessRead",CComVariant(L"TRUE"));

				 // Get the newly created ADsPath for this Server
			     if (SUCCEEDED(hr)) hr = pADs->get_ADsPath(&bstrConfigPath);

				 // Set the info
			     if (SUCCEEDED(hr)) hr = pADs->SetInfo();

				 //-----------------------------------------------------
				 // RG:  Now call AppCreate through IDispatch to set the application
				 //       Note:  This only seems to work for 'IIsWebVirtualDir'??
				 //-----------------------------------------------------
				 if ( bstrType == "IIsWebVirtualDir" && SUCCEEDED(hr) )
				 {
				     DISPID dispid;
				     LPOLESTR str = OLESTR("AppCreate");

				     // Get a pointer to IDispatch from object
                     hr = pCont->GetObject(bstrType,bVDirName,&pDisp);

				     // See if object supports 'AppCreate' and dispid
				     if (SUCCEEDED(hr)) hr = pDisp->GetIDsOfNames(IID_NULL, &str, 1, LOCALE_SYSTEM_DEFAULT, &dispid);

				     // Set the parameters
				     VARIANT myVars[1];
				     VariantInit(&myVars[0]);
				     myVars[0].vt =	VT_BOOL;
				     myVars[0].boolVal = true;

				     DISPPARAMS params = {myVars,0,1,0};

				     // Invoke 'AppCreate'
				     if (SUCCEEDED(hr)) hr = pDisp->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT,
					           DISPATCH_METHOD,&params, NULL, NULL, NULL);

				     // Cleanup
				     if (SUCCEEDED(hr)) hr = pDisp->Release();
				     //VariantClear(&myVars);

				     // Set AppFriendlyName
				     if (SUCCEEDED(hr)) hr = pADs->Put(L"AppFriendlyName",CComVariant(bAppFriendName));

				     // Set the info
			         if (SUCCEEDED(hr)) hr = pADs->SetInfo();

				 }

				 // Check for failure
				 if ( FAILED(hr)) hr = E_SCO_IIS_CREATE_VDIR_FAILED;


			 }
			 else
			 {
                hr = E_SCO_IIS_ADS_CREATE_FAILED;
			 }

		} // end if Create
	    else
		{
           hr = E_SCO_IIS_CREATE_VDIR_FAILED;
		}
   
    } // end if ADsGetObject
	else
	{
       hr = E_SCO_IIS_ADSCONTAINER_CREATE_FAILED;
	}


	return hr;
}


//-----------------------------------------------------------
// Method:    DeleteIIs50VDir
// Author:    Russ Gibfried
// Params:    [in]  bstrType     -- 'Type' of site, ie 'IIsWebVirtualDir"
//                  bWebADsPath     -- IIS://localhost/W3SVC/1
//                  bVDirName   -- url, ex. 'ROOT'
//
//            [out] bstrConfigPath -- created adsi path, ex. IIS://localhost/W3SVC/1/ROOT
// Purpose:   Set the value of particular a particular property 
//------------------------------------------------------------- 
HRESULT CIISSCO50::DeleteIIs50VDir(CComBSTR bstrType,CComBSTR bWebADsPath, CComBSTR bVDirName)
{
	HRESULT hr = S_OK;
	CComPtr<IADsContainer> pCont;
	IDispatch* pDisp;



    // Bind to a domain object:  'IIS://MachineName/W3SVC/1'   
	hr = ADsGetObject( bWebADsPath,IID_IADsContainer, (void **)&pCont);
    if (SUCCEEDED(hr))
	{

		//-----------------------------------------------------
		// RG:  Now call AppDelete through IDispatch to set the application
		//-----------------------------------------------------
		DISPID dispid;
		LPOLESTR str = OLESTR("AppDelete");

		// Get a pointer to IDispatch from object
        if (SUCCEEDED(hr)) hr = pCont->GetObject(bstrType,bVDirName,&pDisp);

		// See if object supports 'AppCreate' and dispid
		if (SUCCEEDED(hr)) hr = pDisp->GetIDsOfNames(IID_NULL, &str, 1, LOCALE_SYSTEM_DEFAULT, &dispid);

		// Set the parameters
		//VARIANT myVars[1];
		//VariantInit(&myVars[0]);
		//myVars[0].vt =	VT_BOOL;
		///myVars[0].boolVal = true;

		DISPPARAMS params = {NULL,NULL,0,0};

		// Invoke 'AppCreate'
		if (SUCCEEDED(hr)) hr = pDisp->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT,
					           DISPATCH_METHOD,&params, NULL, NULL, NULL);

		// Cleanup
		if (SUCCEEDED(hr)) hr = pDisp->Release();
		//VariantClear(&myVars);


	    //Delete the virtual directory at VDirName
		if (SUCCEEDED(hr)) hr = pCont->Delete(bstrType,bVDirName);

		if ( FAILED(hr) )
		   hr = E_SCO_IIS_DELETE_VDIR_FAILED;


    } // end if ADsGetObject
	else
	{
       hr = E_SCO_IIS_ADSCONTAINER_CREATE_FAILED;
	}


	return hr;
}


//-----------------------------------------------------------
// Method:    SetVDirProperty
// Author:    Russ Gibfried
// Params:    [in]  
//                  pADs            -- pointer to ADs object for something like IIS://localhost/W3SVC/1/ROOT
//                  bVDirProperty   -- , ex. 'AuthFlags'
//                  bVDirValue      -- property value
//
//            [out] none
// Purpose:   Set the value of particular a particular property for a Virtual Directory
//------------------------------------------------------------- 
HRESULT CIISSCO50::SetVDirProperty(CComPtr<IADs> pADs, CComBSTR bVDirProperty,CComBSTR bVDirValue)
{
	HRESULT hr = E_FAIL;

    // Bind to a domain object:  'IIS://MachineName/W3SVC/1/ROOT'   
    if ( pADs != NULL )
	{

		// Set the property
		hr = pADs->Put(bVDirProperty,CComVariant(bVDirValue));

		// Set the info
        if (SUCCEEDED(hr)) hr = pADs->SetInfo();

   
    } // end if ADsGetObject

	if ( FAILED(hr))
		hr = E_SCO_IIS_SET_PROPERTY_FAILED;


	return hr;
}


//-----------------------------------------------------------
// Method:    EnumPaths
// Author:    Russ Gibfried
// Params:    [in]  bRecursive -- Boolean; true to recursely iterate through subnodes
//                  bstrPath -- metabase path for key to Enumerate
//            [out] variant SafeArray
// Purpose:   Enumerate the keys/nodes for a given ADsPath
//            Example:  IIS://localhost/W3SVC/1  yields IISCertMapper and Root
//------------------------------------------------------------- 
HRESULT CIISSCO50::EnumPaths(BOOL bRecursive,CComBSTR bstrPath, Map& mVar)
{
	//initialize
    HRESULT hr = E_FAIL;
    IADs         *pADs;
    CComPtr<IADsContainer> pCont;
    VARIANT       var;
    ULONG         lFetch;
    IDispatch    *pDisp;
	IEnumVARIANT *pEnum;


	// Get the container object for given ADsPath
	hr = ADsGetObject(bstrPath, IID_IADsContainer, (void**) &pCont );

	if ( SUCCEEDED(hr))
	{
		//add to Map
        mVar[bstrPath] = bstrPath;

		// Create a Enum object in container
	    hr = ADsBuildEnumerator(pCont, &pEnum);

	    // Walk through all providers
	    while (hr == S_OK)
		{
		    hr = ADsEnumerateNext(pEnum,1,&var,&lFetch);
		    if ( lFetch == 1)
			{
			    pDisp = V_DISPATCH(&var);
			    pDisp->QueryInterface(IID_IADs, (void**)&pADs);
		    	pDisp->Release();

                BSTR bstr;
				pADs->get_ADsPath(&bstr);
			    pADs->Release();

				// true if we are to recursively navigate lower nodes
				if ( bRecursive )
				{
					EnumPaths(bRecursive,bstr, mVar);
				}
				else
				{
					mVar[bstr] = bstr;
				}

				SysFreeString(bstr);


			}
		}

	    if ( pEnum )
		    ADsFreeEnumerator(pEnum);
	}
	else
	{
		hr = E_SCO_IIS_ADS_CREATE_FAILED;
	}

    return hr;
}


//-----------------------------------------------------------
// Method:    EnumPropertyValue
// Author:    Russ Gibfried
// Params:    [in]  bstrPath -- metabase path for key to Enumerate
//            [in]  bstrIsInHerit -- True/False if required to display inheritable properties
//            [out] variant SafeArray
// Purpose:   Make sure IIS://localhost/W3SVC/2 
//------------------------------------------------------------- 
HRESULT CIISSCO50::EnumPropertyValue(CComBSTR bstrPath, CComBSTR bstrIsInHerit, Map& mVar)
{
	//initialize
    HRESULT hr = S_OK;
    CComPtr<IADs>          pADs;
	CComPtr<IADsClass>     pCls;
	CComBSTR               bstrSchema;

	CComPtr<IISBaseObject> pBase;

	// variables for SafeArray or properties
    LONG lstart, lend;
	CComBSTR bstrProperty;
	CComBSTR bstrValue;

	// Set bstrIsInHerit to uppercase
	bstrIsInHerit.ToUpper();

    // Bind to a domain object -- this will give us schema, class and name
    hr = ADsGetObject(bstrPath, IID_IADs, (void**) &pADs );
    if ( SUCCEEDED(hr)) hr = pADs->get_Schema(&bstrSchema);

	if ( SUCCEEDED(hr))
	{
         // Bind to IIS Admin Object so we can determine if properties are inherited or not
	     hr = ADsGetObject(bstrPath, IID_IISBaseObject, (void**) &pBase );

		 if ( SUCCEEDED(hr))
		 {
	          // Bind to schema object and get all optional properties
	          hr = ADsGetObject(bstrSchema,IID_IADsClass, (void**)&pCls);

	         if ( SUCCEEDED(hr))
			 {
		         //********** Get Mandatory Properties ************************
	             VARIANT varProperty;
	             VariantInit(&varProperty);
	             hr = pCls->get_MandatoryProperties(&varProperty);

		         // iterate through properties
                 if ( SUCCEEDED(hr))
				 {
                     VARIANT varItem;
                     SAFEARRAY *sa = V_ARRAY( &varProperty );
                     hr = SafeArrayGetLBound( sa, 1, &lstart );
                     hr = SafeArrayGetUBound( sa, 1, &lend );
                     VariantInit(&varItem);

				     // For loop through properties
                    for ( long idx=lstart; idx <= lend; idx++ ) 
					{
					    // Get a property 
                        hr = SafeArrayGetElement( sa, &idx, &varItem );
                        bstrProperty = V_BSTR(&varItem);
                        VariantClear(&varItem);

	  		            // if isInheriable = false, then properties must be set on path
			            if ( SUCCEEDED(hr) && !StringCompare(bstrIsInHerit, IIS_FALSE) )
						{
							// True -- just return property
							hr = GetMetaPropertyValue(pADs, bstrProperty, bstrValue);
		                    if ( SUCCEEDED(hr) ) mVar[bstrProperty] = bstrValue;

						}
						else
						{

							// False -- Check if property set on this path
							if ( EnumIsSet(pBase,bstrPath,bstrProperty))
							{
							   // This property was set on this path.  Get the value and add to map
							   hr = GetMetaPropertyValue(pADs, bstrProperty, bstrValue);
							   if ( SUCCEEDED(hr) ) mVar[bstrProperty] = bstrValue;
							}
						}

					} // end For

				 }

			     //********** Repeat for Optional Properties ************************
	             VariantClear(&varProperty);
			     VariantInit(&varProperty);
	             hr = pCls->get_OptionalProperties(&varProperty);  

		         // iterate through properties
                 if ( SUCCEEDED(hr))
				 {
                    VARIANT varItem;
                    SAFEARRAY *sa = V_ARRAY( &varProperty );
                    hr = SafeArrayGetLBound( sa, 1, &lstart );
                    hr = SafeArrayGetUBound( sa, 1, &lend );
                    VariantInit(&varItem);

				    // For loop through properties
                    for ( long idx=lstart; idx <= lend; idx++ ) 
					{
					   // Get a property 
                       hr = SafeArrayGetElement( sa, &idx, &varItem );
                       bstrProperty = V_BSTR(&varItem);
                       VariantClear(&varItem);

	  		            // if isInheriable = false, then properties must be set on path
			            if ( SUCCEEDED(hr) && !StringCompare(bstrIsInHerit, IIS_FALSE) )
						{
							// True -- just return property
							hr = GetMetaPropertyValue(pADs, bstrProperty, bstrValue);
		                    if ( SUCCEEDED(hr) ) mVar[bstrProperty] = bstrValue;

						}
						else
						{

							// False -- Check if property set on this path
							if ( EnumIsSet(pBase,bstrPath,bstrProperty))
							{
							   // This property was set on this path.  Get the value and add to map
							   hr = GetMetaPropertyValue(pADs, bstrProperty, bstrValue);
							   if ( SUCCEEDED(hr) ) mVar[bstrProperty] = bstrValue;
							}
						}


					} // end For


				 }  // end if
			     VariantClear(&varProperty);
			 }
			 else
			 {
				 // failed to bind to schema
                 hr = E_SCO_IIS_ADSCLASS_CREATE_FAILED;
			 }
		}
		else
		{
			// failed to bind to IIS BaseObject
            hr = E_SCO_IIS_BASEADMIN_CREATE_FAILED;
		}
	}
	else
	{
		// failed to bind to ADs Object
        hr = E_SCO_IIS_ADS_CREATE_FAILED;
	}



    return hr;
}


//-----------------------------------------------------------
// Method:    EnumIsSet
// Params:    [in]  pBase        -- pointer to IISBaseObject for given 'bstrPath'
//                  bstrPath     -- adsi Path; IIS://localhost/W3SVC/2
//                  bstrProperty -- property found in schema for this path
//            [out] Boolean -       True is the property was set for given path and not
//                                  inherited from another key.
// Purpose:   Function checks the paths returned by 'GetDataPaths' for a given property
//            to current path to determine if property was actually set at this path.
//
// Note:      You can easily extend this function by adding a flag to only check
//            for inheritable properties, all properties or non-inheritable.
//------------------------------------------------------------- 
BOOL CIISSCO50::EnumIsSet(CComPtr<IISBaseObject> pBase, CComBSTR bstrPath, CComBSTR bstrProperty)
{
	VARIANT     pvPaths;    // list of paths returned by 'GetDataPaths'
	VARIANT     *varPath;   // property path
	SAFEARRAY   *PathArray; // SafeArray to hold pvPaths
	BOOL bFound = false;
	HRESULT hr;

	// Get Property paths
	VariantInit(&pvPaths);
    VariantClear(&pvPaths);

	// Check if this is a inheritable property
	hr = pBase->GetDataPaths(bstrProperty,1,&pvPaths);

	if ( SUCCEEDED(hr) )
	{
		//Any property
		PathArray = pvPaths.parray;
		varPath = (VARIANT*)PathArray->pvData;
 
		if ( varPath->vt == VT_BSTR)
		{
			if ( !_wcsicmp(varPath->bstrVal,bstrPath.m_str) )
			{
				// This property was set on this path.
				bFound = true;
			}
		}
	}
	// Check if this is not an inheritable property
	else
	{
		VariantClear(&pvPaths);
		VariantInit(&pvPaths);
		hr = pBase->GetDataPaths(bstrProperty,0,&pvPaths);

		if ( SUCCEEDED(hr) )
		{
			//Inheritable property
			PathArray = pvPaths.parray;
			varPath = (VARIANT*)PathArray->pvData;
			if ( varPath->vt == VT_BSTR)
			{
				if ( !_wcsicmp(varPath->bstrVal,bstrPath.m_str))
				{
					// This property was set on this path.  Get the value and add to map
					bFound = true;

				}  
			} 

		} // end if GetDataPaths -- IIS_ANY_PROPERTY

	} // end if GetDataPaths -- IIS_INHERITABLE_ONLY

    VariantClear(&pvPaths);
    return bFound;
}



//-----------------------------------------------------------
// Method:    IIsServerAction
// Author:    Russ Gibfried
// Params:    [in]  bWebADsPath     -- IIS://localhost/W3SVC/1
//                  action       --  Start, Stop or Pause
//
//            [out] HRESULT
// Purpose:   Start, stop or pause a web site
//------------------------------------------------------------- 
HRESULT CIISSCO50::IIsServerAction(CComBSTR bWebADsPath,IIsAction action)
{
    HRESULT hr = E_FAIL;
	CComPtr<IADsServiceOperations> pService;


    // Bind to a domain object:  'IIS://MachineName/W3SVC/1'   
	hr = ADsGetObject( bWebADsPath,IID_IADsServiceOperations, (void **)&pService);
    if (SUCCEEDED(hr))
	{
		// Perform the action on the server
		switch ( action )
		{

			// Start the server
            case start:
				hr = pService->Start();
				break;

			// Stop the server
			case stop:
				hr = pService->Stop();
				break;

			// Pause the Server
			case pause:
				hr = pService->Pause();
				break;

			default:
				break;

		} // end switch
	} // end if
	else
	{
         hr = E_SCO_IIS_ADSSERVICE_CREATE_FAILED;
	}

	return hr;
}


//-----------------------------------------------------------
// Method:    GetNextIndex
// Author:    Russ Gibfried
// Params:    [in]  bstrPath -- metabase path for IIsWebService
//                  bstrName -- name or property
//                  bstrValue -- property value to set
//            [out] none
// Purpose:   Set the value of particular a particular property 
//------------------------------------------------------------- 
HRESULT CIISSCO50::GetNextIndex(CComBSTR bstrPath, CComBSTR& pIndex)
{
	// initialize
    HRESULT hr = S_OK;
	CComPtr<IADs> pObj;
	long lCount = 1;
	CComVariant var = lCount;

	// initialize starting path:  IIS://MyServer/W3SVC/
	CComBSTR tempPath = bstrPath.Copy();
	tempPath.Append(L"/");

	// Append 1 to starting path:  IIS://MyServer/W3SVC/1 
	var.ChangeType(VT_BSTR);
	tempPath.Append(var.bstrVal);

    // Loop through each server until fails, then we have the next server number
	try
	{
	    while ( SUCCEEDED( ADsGetObject( tempPath,IID_IADs, (void **)&pObj) ))
		{
		    lCount++;
		    tempPath = bstrPath.Copy();
		    tempPath.Append(L"/");
		    var = lCount;
			var.ChangeType(VT_BSTR);
		    tempPath.Append(var.bstrVal);
			pObj = NULL;
		}
	}
	catch(...)
	{
		// unhandled exception
		hr=E_FAIL;
	}

	var.ChangeType(VT_BSTR);
	ChkAllocBstr(pIndex,var.bstrVal);
	return hr;

}


//------------------------------------------------------------------------------
// Method:    CreateBindingString
// Author:    Russ Gibfried
// Params:    [in]  bstrIP       -- site IP
//                  bstrPort     -- site port
//                  bstrHostName -- site HostName
//            [out] bstrString   -- server binding string 
// Purpose:   Creates a binding string in the format IP:Port:Hostname. 
//            Used in other methods to check existing server bindings and
//            set new bindings. Both the IP and Hostname parameter of the string are optional. 
//------------------------------------------------------------------------------- 
HRESULT CIISSCO50::CreateBindingString(CComBSTR bstrIP,CComBSTR bstrPort, 
			                   CComBSTR bstrHostName,CComBSTR& bstrString)
{
	bstrString.AppendBSTR(bstrIP);
    bstrString.Append(L":");
    bstrString.AppendBSTR(bstrPort);
    bstrString.Append(L":");
    bstrString.AppendBSTR(bstrHostName);

	return 0;
}

//------------------------------------------------------------------------------
// Method:    CheckBindings
// Author:    Russ Gibfried
// Params:    [in]  bWebADsPath        -- ADs path to bind to search
//                  bstrNewBindings -- site IP
//            [out] none
// Purpose:   This compares current server bindings to the requested new bindings
//            to make sure there is not a duplicate server already running.  Binding 
//            string format is IP:Port:Hostname. 
//
//            Note   Both the IP and Hostname parameter of the string are optional. 
//            Any unspecified parameters default to an all-inclusive wildcard.
//
//               Metabase Path      Key Type 
//               /LM/MSFTPSVC/N     IIsFtpServer 
//               /LM/W3SVC/N        IIsWebServer 
//------------------------------------------------------------------------------- 
HRESULT CIISSCO50::CheckBindings(CComBSTR bWebADsPath, CComBSTR bstrNewBindings)
{
	// initialize
    HRESULT hr = E_FAIL;
	CComPtr<IADsContainer> pCont;
	IADs* pADs;
	CComVariant vBindings;
	BSTR bstr;
	IEnumVARIANT* pEnum;
	LPUNKNOWN     pUnk;
    VARIANT       var;
    IDispatch    *pDisp;
    ULONG         lFetch;
    VariantInit(&var);

	// Get a container to IIsWebService object
	hr = ADsGetObject(bWebADsPath, IID_IADsContainer, (void**) &pCont );
    if ( !SUCCEEDED(hr) )
    {
        return E_SCO_IIS_ADSCONTAINER_CREATE_FAILED;
    }
   
	// Get an enumeration of all objects below it
	pCont->get__NewEnum(&pUnk);
 
    pUnk->QueryInterface(IID_IEnumVARIANT, (void**) &pEnum);
    pUnk->Release();
 
     // Now Enumerate through objects
    hr = pEnum->Next(1, &var, &lFetch);
    while(hr == S_OK)
	{
        if (lFetch == 1)
		{
           pDisp = V_DISPATCH(&var);
           pDisp->QueryInterface(IID_IADs, (void**)&pADs);
		   
           pDisp->Release();
           pADs->get_Class(&bstr);   // Debug to see Class
		   SysFreeString(bstr);

		   hr = pADs->Get(L"ServerBindings",&vBindings);

		   // Check server bindings for this class
           if ( SUCCEEDED(hr) )
		   {

			   LONG lstart, lend;
               SAFEARRAY *sa = V_ARRAY( &vBindings );
               VARIANT varItem;
 
               // Get the lower and upper bound
               hr = SafeArrayGetLBound( sa, 1, &lstart );
               hr = SafeArrayGetUBound( sa, 1, &lend );
 
               // Now iterate and print the content
               VariantInit(&varItem);
			   CComBSTR bString;
               for ( long idx=lstart; idx <= lend; idx++ )
			   {
                 hr = SafeArrayGetElement( sa, &idx, &varItem );
				 
                 bString = V_BSTR(&varItem);
                 VariantClear(&varItem);
			   }

			   // Checkbindings.  If match then fail;
			   if ( bstrNewBindings == bString)
			   {
				   hr = E_SCO_IIS_DUPLICATE_SITE;
				   pEnum->Release();
				   VariantClear(&var);
				   goto Leave;

			   }
 
		   }  // end if 'bindings'
 
		} // end if 'enum'

        VariantClear(&var);
        hr = pEnum->Next(1, &var, &lFetch);

	};  // end while

	pEnum->Release();

Leave:
    return hr;
}


//-----------------------------------------------------------
// Method:    AddBackSlashesToString
// Author:    Russ Gibfried
// Params:    [in]  bString -- BSTR to parse; ie 'redmond\bob:F'
//
//            [out] bString -- 'redmond\\bob:F'
// Purpose:   If string has only one backslash, add two since backslash is an 
//             escape character. 
//------------------------------------------------------------- 
void CIISSCO50::AddBackSlashesToString(CComBSTR& bString)
{

	// initialize variables
    size_t start, length, db;    // string counters
	start = 0;                   // start of string
	db = 0;                      // index if '\\' found ( db = double backslash)


	// Convert the BSTR to a std:string
	USES_CONVERSION;
	std::string s = OLE2A(bString.m_str);
	std::string temp1,temp2,temp3 = "";
	length = s.length();

	// Loop through string looking for single slashes
    for (size_t pos = s.find("\\")+1; pos < length; pos = s.find("\\", pos+2)+1)
	{
	   // pos = 0 when it goes off end of string
	   if ( pos == 0 ) break;

	   // find location of double slash
	   db = s.find("\\\\",pos-2)+1;

	   // pos is the location of a single slash, if it matches db then we really have
	   // the first part of a double slash; so skip
       if ( pos != db )
	   {
		  // replace the single slash with a double '\\'
		  temp1 = s.substr(start,pos-1);
		  temp2 = s.substr(pos,length);
		  s = temp1 + "\\\\" + temp2;
	   }
	}

	// return
    bString = A2BSTR(s.c_str());
}


//-----------------------------------------------------------
// Method:    ParseBSTR
// Author:    Russ Gibfried
// Params:    [in]  bString -- BSTR to parse; ie 'redmond\bob:F'
//                  delim   -- deliminator; ie ':' or 'IIS://'
//                  iFirstPiece  -- starting piece of BSTR to return; ie 1
//                  iLastPiece   -- ending piece of BSTR to return; ie 99
//
//            [out] pVal    -- piece of BSTR; ie, 'redmond\bob'
// Purpose:   uses std:string functionality to parse an BSTR given a deliminator
//            and which part of BSTR should be returned.
//            ex)  bString = "IIS://localhost/W3SVC/1/ROOT/1
//                  (bString,1,99,'host') --> /W3SVC/1/ROOT/1
//                  (bString,2,3,'/')     --> localhost
//                  (bString,4,99,'/')    --> 1 
//                  (bString,2,4,'/')     --> localhost/W3SVC
//------------------------------------------------------------- 
HRESULT CIISSCO50::ParseBSTR(CComBSTR bString,CComBSTR sDelim, int iFirstPiece, int iLastPiece,CComBSTR &pVal)
{

	// ------ initialize variables ------------------
	// start = begining of substring
	// end   = end of substring
	// count = counter of number of deliminators found
	// done  = variable to end while loop for each piece
	// length = length of original string
	//--------------------------------------
	HRESULT hr = S_OK;
	size_t start,end;       
	int iCount, done, iLength;
	done = start = end = 0;
	iCount = 0;                // first piece to look for.

	// If last piece is not greater that fist then end
	if ( iLastPiece < iFirstPiece)
		done=1;

	USES_CONVERSION;
	// deliminator
	std::string myDelim = OLE2A(sDelim.m_str);
    long iDelimLen = myDelim.length();

	// my string
	std::string myString = OLE2A(bString.m_str);
    iLength = myString.length();

	// temp and new string
	std::string newString = "";
	std::string tmpString = "";

    while (!done)
	{
		// find the start of the piece
		end = myString.find(myDelim,start);

		if ( iCount >= iFirstPiece && iCount <= (iLastPiece-1))
		{
			//we want this piece
			tmpString = myString.substr(start,end-start);
			newString.append(tmpString);

			// if iCount < iLastPiece and we're not at the end, then append deliminator too
			if ( iCount < (iLastPiece-1) && end < iLength)
				newString.append(myDelim);
		}

		// if we have gone passed end of string quit, else increment
		// deliminator and string counters.
		if ( end >= iLength || iCount >= (iLastPiece-1))
		{
		       done = 1;
		}
		else
		{
			   start = end + iDelimLen;  // increment start
			   iCount++;
		}

	}

	//convert string back to BSTR -- A2BSTR
	pVal = A2BSTR(newString.c_str());

	return hr;
}

//-----------------------------------------------------------
// Method:    NumberOfDelims
// Author:    Russ Gibfried
// Params:    [in]  bString -- BSTR to parse; ie 'redmond\bob:F'
//                  sDelim  -- deliminator to find
//
//            [out] int     -- number of deliminators found in string
// Purpose:   Return the number of deliminators found in a string.  This is used
//            by 'PutElement'
//------------------------------------------------------------- 
int CIISSCO50::NumberOfDelims(CComBSTR& bString, CComBSTR bDelim)
{

	// initialize variables
	int iCount = 0;
	int length;


	// Convert the BSTR to a std:string
	USES_CONVERSION;
	std::string s = OLE2A(bString.m_str);
	std::string sDelim = OLE2A(bDelim.m_str);

	length = s.length();

	// Loop through string looking for deliminator
    for (size_t pos = s.find(sDelim)+1; pos < length; pos = s.find(sDelim, pos+2)+1)
	{
	   // pos = 0 when it goes off end of string
	   if ( pos == 0 ) break;
	   iCount++;

	}

	// return
    return iCount;
}

/* --------------------- XML Helper Methods ------------------------------- */

//-----------------------------------------------------------
// Method:    GetElementValueByAttribute
// Author:    Russ Gibfried
// Params:    [in]  elementName -- element name to look for
//            [out] pVal -- value of element
// Purpose:   Return value of particular element in  XML document
//             <Property name="someName">someValue</Property> 
//------------------------------------------------------------- 
HRESULT CIISSCO50::GetElementValueByAttribute(CComPtr<IXMLDOMNode> pTopNode,CComBSTR elementName, CComBSTR attributeName, CComBSTR& pVal)
{

	HRESULT hr = S_OK;
	CComPtr<IXMLDOMNodeList> pNodeList;          // List of nodes matching elementName
	CComPtr<IXMLDOMNode> pNode;                 // individual node
	CComPtr<IXMLDOMNamedNodeMap> pAttributeMap; 
	CComPtr<IXMLDOMNode> pXMLElement;


	// Get a node list, ie, all <Property> tags
    if (S_OK == (hr = pTopNode->selectNodes(elementName,&pNodeList)))
	{

        // Get the number of nodes and loop through them looking for
		// specific Property found in attribute 'name='
		long lLength;
	    pNodeList->get_length(&lLength);
		for ( int i=0; i < lLength; i++)
		{
			// Get a node
			hr = pNodeList->get_item(i,&pNode);
			if ( SUCCEEDED(hr))
			{
		
				//Get 'name' attribute of this nodes <Property> tag
			    hr = pNode->get_attributes(&pAttributeMap);
			    if ( SUCCEEDED(hr))
				{

					BSTR bstrProperty = SysAllocString(L"");

					hr = pAttributeMap->getNamedItem(L"name",&pXMLElement);
					if (SUCCEEDED(hr)) hr = pXMLElement->get_text(&bstrProperty);
					if (SUCCEEDED(hr))
					{
						// If the property in attribute name is the same as passed in, then get value
						if ( bstrProperty == attributeName.m_str)
						{	
							// Setup a BSTR to get element value
						    BSTR bstrTemp = SysAllocString(L"");
							hr = pXMLElement->get_text(&bstrTemp);

							// Copy BSTR to CComBSTR and free it
							if (SUCCEEDED(hr)) hr = pVal.CopyTo(&bstrTemp);
							SysFreeString(bstrTemp);
							i = lLength;

						} 
					} // end if attribute
				} // end if node
			} //end if pNode
		} // end for

	}
    else
	{
		// element name doesn't exists
        hr = E_FAIL;
	}


	return hr;
}

//-----------------------------------------------------------
// Method:    GetInputAttr
// Author:    Russ Gibfried
// Params:    [in]  pTopNode      -- xml Node pointer
//                  AttributeName -- attribute name to look for
//                   elementName  -- element name
//            [out] pVal -- value of attribute
// Purpose:   Select a tag based on its name (elementName) and
//             Return the value of particular attribute in  XML document 
//------------------------------------------------------------- 
HRESULT CIISSCO50::GetInputAttr(CComPtr<IXMLDOMNode> pTopNode, CComBSTR elementName, CComBSTR AttributeName, CComBSTR& pVal)
{
	HRESULT hr = E_FAIL;
	CComPtr<IXMLDOMNamedNodeMap> pAttributeMap; 
	CComPtr<IXMLDOMNode> pNode;
	CComPtr<IXMLDOMNode> pXMLElement;



	if ( pTopNode != NULL )
	{
	   // if elementName = "", then at current node
	   if ( elementName.Length() == 0  )
	   { 
            pNode = pTopNode;
			hr = S_OK;
	   }
	   else
	   {
		     // Get the node of the element we are looking for ie, "./Website"
             hr = pTopNode->selectSingleNode(elementName,&pNode);
	   }

	   // Get the attribute value
       if (SUCCEEDED(hr) && pNode != NULL)
	   {
 
	       //Get 'name' attribute of this nodes <Property name=''> tag
		   hr = pNode->get_attributes(&pAttributeMap);
		   if ( SUCCEEDED(hr))
		   {
               // Return the attributes value
			   hr = pAttributeMap->getNamedItem(AttributeName,&pXMLElement);
			   if (SUCCEEDED(hr)) hr = pXMLElement->get_text(&pVal);
		   }
        }
	}

	if ( FAILED(hr) ) hr = E_SCO_IIS_XML_ATTRIBUTE_MISSING;

	return hr;

}

//-----------------------------------------------------------
// Method:    GetInputParam
// Author:    Russ Gibfried
// Params:    [in]  elementName -- element name to look for.    ie IpAddress
//            [out] pVal -- value of element                    ie. 10.2.1.10
// Purpose:   Return value of particular element in  XML document 
//            ex) <IpAddress>10.2.1.10</IpAddress>
//------------------------------------------------------------- 
HRESULT CIISSCO50::GetInputParam(CComPtr<IXMLDOMNode> pNode,CComBSTR elementName,CComBSTR& pVal)
{

	HRESULT hr = E_FAIL;
	CComPtr<IXMLDOMNode> pXMLElement;

	if ( pNode != NULL )
	{
       if (S_OK == (hr = pNode->selectSingleNode(elementName,&pXMLElement)))
	   {
		  pXMLElement->get_text(&pVal);
	   }
    }

	return hr;
}


//-----------------------------------------------------------
// Method:    PutElement
// Author:    Russ Gibfried
// Params:    [in]  pNode        -- xml node pointer
//                  elementName  -- element name to look for
//            [in]  newVal       -- new value of element
// Purpose:   Return HRESULT 
//------------------------------------------------------------- 
HRESULT CIISSCO50::PutElement(CComPtr<IXMLDOMNode> pNode, CComBSTR elementName, CComBSTR newVal)
{

	HRESULT hr = S_OK;

	CComPtr<IXMLDOMDocument> pDoc;
	CComPtr<IXMLDOMNode>     pNewNode;
	CComPtr<IXMLDOMNode>     pLastChild;
	CComPtr<IXMLDOMNode>     pTempNode;

	if ( pNode != NULL )
    {

	   // Find the Element 'elementName'
       if (S_OK != (hr = pNode->selectSingleNode(elementName,&pNewNode)))
	   {

		   // Could not find element so create new node and add to DOM 
		   hr = CoCreateInstance(
                __uuidof(DOMDocument),
                NULL,
                CLSCTX_ALL,
                __uuidof(IXMLDOMDocument),
                (LPVOID*)&pDoc);

		   // Get the node name from the element path.  ie, './WebSite/ConfigPath' yields 'ConfigPath'
		   int iCount = NumberOfDelims(elementName, L"/");
		   CComBSTR bstrElement;
		   if ( SUCCEEDED(hr)) hr = ParseBSTR(elementName, L"/", iCount, 99, bstrElement);

           // Create the new node
		   VARIANT vtTemp;
		   vtTemp.vt = VT_I2;
		   vtTemp.iVal = NODE_ELEMENT;
		   if ( SUCCEEDED(hr)) hr = pDoc->createNode(vtTemp,bstrElement,NULL, &pNewNode);

           // Insert text in new node
		   if ( SUCCEEDED(hr)) hr= pNewNode->put_text(newVal.m_str);

		   // Get the last child node
		   if ( SUCCEEDED(hr)) hr = pNode->get_lastChild(&pLastChild);

		   // Append our new node to the end of the last child node
		   if ( SUCCEEDED(hr)) hr = pLastChild->appendChild(pNewNode,&pTempNode);
			 
		   // Debug code to verify node built correctly.
		   if ( SUCCEEDED(hr))
		   {
		      CComBSTR bstrDebug;
	          hr = pNode->get_xml(&bstrDebug);
	          ATLTRACE(_T("\t>>>PutElement: xml = : %ls\n"), bstrDebug.m_str);
		   }

			 
	   } 
	   else
	   {
		  hr = pNewNode->put_text(newVal.m_str);
	   }
	}
  
    return hr;
}


//-----------------------------------------------------------
// Method:    AppendElement
// Author:    Russ Gibfried
// Params:    [in]  pNode        -- xml node pointer
//                  xmlString    -- well formed XML fragment; ie <Property></Property>
//            [out] pNewNode     -- xml pointer to new node
// Purpose:   Return HRESULT 
//            Appends a XML tag to the end of a given node.
//------------------------------------------------------------- 
HRESULT CIISSCO50::AppendElement(CComPtr<IXMLDOMNode> pNode, CComBSTR xmlString,CComPtr<IXMLDOMNode>& pNewNode)
{

	HRESULT hr = E_FAIL;

	CComPtr<IXMLDOMDocument> pDoc;
	CComPtr<IXMLDOMElement>  pNewElement;
	VARIANT_BOOL bSuccess = VARIANT_FALSE;

	if ( pNode != NULL )
    {
		// Load string into XML Document
		hr = CoCreateInstance(
                __uuidof(DOMDocument),
                NULL,
                CLSCTX_ALL,
                __uuidof(IXMLDOMDocument),
                (LPVOID*)&pDoc);
		
        if (SUCCEEDED(hr)) hr = pDoc->loadXML(xmlString, &bSuccess);
        if ( SUCCEEDED(hr) && bSuccess != VARIANT_FALSE)
		{
			// Get the document element
			hr = pDoc->get_documentElement(&pNewElement);
            if ( SUCCEEDED(hr))
			{
				// append new element to XML node passed in
		        hr = pNode->appendChild(pNewElement,&pNewNode);
			}
		} 
	}
  
    return hr;
}



//-----------------------------------------------------------
// Method:    GetNodeLength
// Author:    Russ Gibfried
// Params:    [in]   pNode        -- pointer to xml node
//                   elementName -- element name to look for
//            [out]  iLength -- number of elements matching that name
// Purpose:   Return HRESULT 
//------------------------------------------------------------- 
HRESULT CIISSCO50::GetNodeLength(CComPtr<IXMLDOMNode> pTopNode, CComBSTR elementName, long *lLength)
{

	// initialize variables
	HRESULT hr = S_OK;
	CComPtr<IXMLDOMNodeList> pXMLNode;
	long lTemp = 0;
    lLength = &lTemp;

	// Get a node list, ie, all <Property> tags
    if (S_OK == (hr = pTopNode->selectNodes(elementName,&pXMLNode)))
	{
	   pXMLNode->get_length(lLength);
	}


	return hr;

}


//-----------------------------------------------------------
// Method:    IsPositiveInteger
// Author:    Russ Gibfried
// Params:    [in]  
//                  bstrPort     -- port number as a string
//            [out] Boolean -       True if the port is a positive integer
// Purpose:   Function checks if the port or server number is a posivive integer
//            and less than 20,000
//
//------------------------------------------------------------- 
BOOL CIISSCO50::IsPositiveInteger(CComBSTR bstrPort)
{
	BOOL bInteger = false;
	long iPort = 0;

    CComVariant var(bstrPort.m_str);

    // We're
    var.ChangeType(VT_I4);
    iPort = var.lVal;

	if ( iPort > 0 && iPort <= IIS_SERVER_MAX)
		bInteger = true;


    return bInteger;
}


//-----------------------------------------------------------
// Method:    StringCompare
// Author:    Russ Gibfried
// Params:    [in]  bString1 -- BSTR string1
//                  bString2 -- BSTR string2
//
//            [out] Boolean - True/False if string1 and string2 equal
// Purpose:   Compares to strings and returns 'true' if they are equal. 
//------------------------------------------------------------- 
BOOL CIISSCO50::StringCompare(CComBSTR bstrString1, CComBSTR bstrString2)
{

	// initialize variables
	bool bEqual = false;

    bEqual = (wcscmp(bstrString1.m_str, bstrString2.m_str) == 0)  ? true : false;

	return bEqual;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\sco\iisscov50\iisscov50_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0280 */
/* at Fri Aug 24 09:39:49 2001
 */
/* Compiler settings for D:\IIS\IIS Hosting Kit\Russ\IIS5SCO\IISSCOv50\IISSCOv50.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_IISSCOV50Lib,0x43C9637B,0xE647,0x4E82,0xAE,0x38,0x20,0x16,0x45,0x4A,0x72,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_IISSCO50,0xB83A63A9,0x7132,0x49EA,0xB6,0xF2,0xA4,0x54,0xE5,0xF3,0x7A,0x41);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\sco\iisscov50\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by IISSCOv50.rc
//
#define IDS_PROJNAME                    100
#define IDR_IISSCO50               101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\sco\iisscov50\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__01148860_31F4_4929_9F71_1FE393C58ED5__INCLUDED_)
#define AFX_STDAFX_H__01148860_31F4_4929_9F71_1FE393C58ED5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include "ProvProviderBase.h"

#include <activeds.h>   // include in project activeds.lib and adsiid.lib
#include <initguid.h>   // Required to use IISBaseObject, enum properties
#include <iiis.h>


#include "macrohelpers.h"


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__01148860_31F4_4929_9F71_1FE393C58ED5__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\sco\iisscov50\macrohelpers.h ===
//***************************************************************
// macrohelper.h
// Author:    Russ Gibfried
//***************************************************************

/*** ChkAlloc macro : Allocates memory and checks for memalloc errors ***/
#define ChkAlloc(var, init)             \
    var = init;                         \
    if(var == NULL)                     \
    {                                   \
        hr = E_OUTOFMEMORY;             \
    }

#define ChkAllocBstr(var, init)             \
    var = init;                             \
    if(var.m_str == NULL)                   \
    {                                       \
        hr = E_OUTOFMEMORY;                 \
    }
 


//------------------------------------------------------------------------------
// Global macros and constants
//------------------------------------------------------------------------------
#define TRACE_ENTER(x)        ATLTRACE(_T("\t>>> Entering: %ls\n"), x) 
#define TRACE_EXIT(x)         ATLTRACE(_T("\t<<< Leaving: %ls\n"), x)


#define IIsScoLogFailure()                                             \
    if (FAILED(hr)){                                                   \
	    WCHAR  wszErrorDesc[1024];                                     \
	    DWORD err = ::FormatMessage( FORMAT_MESSAGE_IGNORE_INSERTS |   \
                                     FORMAT_MESSAGE_FROM_HMODULE |     \
                                     FORMAT_MESSAGE_FROM_SYSTEM | 72,  \
                                g_ErrorModule,                         \
                                hr,                                    \
                                0,                                     \
                                wszErrorDesc,                          \
                                sizeof(wszErrorDesc) / sizeof(wszErrorDesc[0]) - 1, \
                                NULL );                                \
                                                                       \
        AtlReportError(CLSID_IISSCO50, wszErrorDesc, __uuidof(IProvProvider), hr); \
		LocalFree(wszErrorDesc);                                      \
    } 


//-----------------------------------------------------------------------------
//  Global SCO definitions
//------------------------------------------------------------------------------

// SCO xml nodes and elements 
#define     XML_NODE_WEBSITE		L"Website"
#define     XML_NODE_FTPSITE		L"FTPsite"
#define     XML_NODE_VDIR			L"VirtualDirectory"
#define		XML_NODE_PATHLIST		L"PathList"
#define		XML_NODE_PROPERTYLIST	L"PropertyList"

#define		XML_ELE_PROPERTY		L"Property"

#define     XML_ATT_NUMBER			L"number"
#define		XML_ATT_NAME			L"name"
#define     XML_ATT_ISINHERITABLE   L"isInheritable"

// SCO rollback definitions 
#define     IIS_ROLL_ADSPATH		L"ADsPath"
#define     IIS_ROLL_SERVERNUMBER	L"ServerNumber"
#define     IIS_ROLL_XNODE			L"XML_NODE"
#define     IIS_ROLL_VNAME			L"VDirName"

// IIS commonly used definitions/values
#define		IIS_PREFIX  			L"IIS://"
#define		IIS_W3SVC			    L"/W3SVC"
#define		IIS_MSFTPSVC			L"/MSFTPSVC"
#define		IIS_LOCALHOST			L"LocalHost"
#define		IIS_VROOT				L"ROOT"
#define		IIS_VDEFAULT_APP		L"Default Application"

// IIS services
#define		IIS_IISWEBSERVER		L"IIsWebServer"
#define		IIS_IISFTPSERVER		L"IIsFtpServer"
#define		IIS_IISWEBVIRTUALDIR	L"IIsWebVirtualDir"
#define		IIS_FTPVDIR				L"IIsFtpVirtualDir"

// IIS numeric defaults -- max web sites, port number etc..
#define		IIS_SERVER_MAX			20000
#define		IIS_DEFAULT_WEB_PORT	L"80"
#define		IIS_DEFAULT_FTP_PORT	L"21"
#define		IIS_DEFAULT_APPISOLATED	L"2"

// True/False values
#define		IIS_FALSE				L"FALSE"
#define		IIS_TRUE				L"TRUE"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\sco\iisscov50\messagefile\message.h ===
//----------------------------------------------------------------------------------------
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//-----------------------------------------------------------------------------------------
//
// MessageId = [number|+number]
// Severity = severity_name
// Facility = facility_name
// SymbolicName = name
// OutputBase = {number}
//
// MessageId = [number|+number]
//   The MessageId statement marks the beginning of the message definition. A MessageID statement
//   is required for each message, although the value is optional. If no value is specified, the
//   value used is the previous value for the facility plus one. If the value is specified as
//   +number then the value used is the previous value for the facility, plus the number after the
//   plus sign. Otherwise, if a numeric value is given, that value is used. Any MessageId value that
//   does not fit in 16 bits is an error.
//
// SeverityNames = (name=number[:name]) 
//   Defines the set of names that are allowed as the value of the Severity keyword in the message
//   definition. The set is delimited by left and right parentheses. Associated with each severity
//   name is a number that, when shifted left by 30, gives the bit pattern to logical-OR with the
//   Facility value and MessageId value to form the full 32-bit message code. 
//
//   Severity values occupy the high two bits of a 32-bit message code. Any severity value that does
//   not fit in two bits is an error. The severity codes can be given symbolic names by following each
//   value with :name 
//
// FacilityNames = (name=number[:name]) 
//   Defines the set of names that are allowed as the value of the Facility keyword in the message
//   definition. The set is delimited by left and right parentheses. Associated with each facility
//   name is a number that, when shifted left by 16 bits, gives the bit pattern to logical-OR with
//   the Severity value and MessageId value to form the full 32-bit message code. 
//
//   Facility codes occupy the low-order 12 bits of the high-order 16 bits of a 32-bit message code.
//   Any facility code that does not fit in 12 bits is an error. This allows for 4096 facility codes.
//   The first 256 codes are reserved for use by the system software. The facility codes can be given
//   symbolic names by following each value with :name 
// OutputBase = {number} 
//   Sets the output radix for the message constants output to the C/C++ include file. It does not
//   set the radix for the Severity and Facility constants; these default to HEX, but can be output
//   in decimal by using the -d switch. If present, OutputBase overrides the -d switch for message
//   constants in the include file. The legal values for number are 10 and 16. 
//
//   You can use OutputBase in both the header section and the message definition section of the input
//   file. You can change OutputBase as often as you like. 
//------------------------- Supported languages -------------------------------------------
//-------------------------- Supported severities -----------------------------------------
//------------------------- Supported Facilities ------------------------------------------
//---------------------NOTE: These must match in the Event logger code---------------------
//--------------------------IIS SCO MAPS Messages------------------------------
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define IISSco                           0x101
#define Generic                          0x100


//
// Define the severity codes
//


//
// MessageId: E_SCO_IIS_INVALID_INDEX
//
// MessageText:
//
//  [%1] Server index number is invalid or missing.
//
#define E_SCO_IIS_INVALID_INDEX          0xC1010190L

//
// MessageId: E_SCO_IIS_MISSING_FIELD
//
// MessageText:
//
//  [%1] Required field is missing in MAPS request data.
//
#define E_SCO_IIS_MISSING_FIELD          0xC1010191L

//
// MessageId: E_SCO_IIS_DUPLICATE_SITE
//
// MessageText:
//
//  [%1] Server already exists at current ipAddress:port:hostname.
//
#define E_SCO_IIS_DUPLICATE_SITE         0xC1010192L

//
// MessageId: E_SCO_IIS_CREATE_FAILED
//
// MessageText:
//
//  [%1] Failed to created requested IIS element.
//
#define E_SCO_IIS_CREATE_FAILED          0xC1010193L

//
// MessageId: E_SCO_IIS_SET_NODE_FAILED
//
// MessageText:
//
//  [%1] Failed to set required MAPS response parameters.
//
#define E_SCO_IIS_SET_NODE_FAILED        0xC1010194L

//
// MessageId: E_SCO_IIS_DELETE_FAILED
//
// MessageText:
//
//  [%1] Failed to delete requested IIS element.
//
#define E_SCO_IIS_DELETE_FAILED          0xC1010195L

//
// MessageId: E_SCO_IIS_GET_PROPERTY_FAILED
//
// MessageText:
//
//  [%1] Failed to get IIS adsi property value.
//
#define E_SCO_IIS_GET_PROPERTY_FAILED    0xC1010196L

//
// MessageId: E_SCO_IIS_SET_PROPERTY_FAILED
//
// MessageText:
//
//  [%1] Failed to set IIS adsi property value.
//
#define E_SCO_IIS_SET_PROPERTY_FAILED    0xC1010197L

//
// MessageId: E_SCO_IIS_CREATE_WEB_FAILED
//
// MessageText:
//
//  [%1] Failed to created IIS Web site.
//
#define E_SCO_IIS_CREATE_WEB_FAILED      0xC1010198L

//
// MessageId: E_SCO_IIS_DELETE_WEB_FAILED
//
// MessageText:
//
//  [%1] Failed to delete IIS Web site.
//
#define E_SCO_IIS_DELETE_WEB_FAILED      0xC1010199L

//
// MessageId: E_SCO_IIS_CREATE_VDIR_FAILED
//
// MessageText:
//
//  [%1] Failed to created IIS virtual directory.
//
#define E_SCO_IIS_CREATE_VDIR_FAILED     0xC101019AL

//
// MessageId: E_SCO_IIS_DELETE_VDIR_FAILED
//
// MessageText:
//
//  [%1] Failed to delete IIS virtual directory.
//
#define E_SCO_IIS_DELETE_VDIR_FAILED     0xC101019BL

//
// MessageId: E_SCO_IIS_ADS_CREATE_FAILED
//
// MessageText:
//
//  [%1] Failed to bind to ADSI ADs object.
//
#define E_SCO_IIS_ADS_CREATE_FAILED      0xC101019CL

//
// MessageId: E_SCO_IIS_ADSCONTAINER_CREATE_FAILED
//
// MessageText:
//
//  [%1] Failed to bind to ADSI ADsContainer object.
//
#define E_SCO_IIS_ADSCONTAINER_CREATE_FAILED 0xC101019DL

//
// MessageId: E_SCO_IIS_XML_ATTRIBUTE_MISSING
//
// MessageText:
//
//  [%1] Failed to retrieve xml attribute value.
//
#define E_SCO_IIS_XML_ATTRIBUTE_MISSING  0xC101019EL

//
// MessageId: E_SCO_IIS_ADSSERVICE_CREATE_FAILED
//
// MessageText:
//
//  [%1] Failed to bind to IID_IADsServiceOperations to stop or start IIS service.
//
#define E_SCO_IIS_ADSSERVICE_CREATE_FAILED 0xC101019FL

//
// MessageId: E_SCO_IIS_ADSCLASS_CREATE_FAILED
//
// MessageText:
//
//  [%1] Failed to bind to IID_IADsClass to get schema object.
//
#define E_SCO_IIS_ADSCLASS_CREATE_FAILED 0xC10101A0L

//
// MessageId: E_SCO_IIS_BASEADMIN_CREATE_FAILED
//
// MessageText:
//
//  [%1] Failed to bind to IID_IISBASEOBJECT to get Admin Base Object.
//
#define E_SCO_IIS_BASEADMIN_CREATE_FAILED 0xC10101A1L

//
// MessageId: E_SCO_IIS_PORTNUMBER_NOT_VALID
//
// MessageText:
//
//  [%1] Port number must be a positive integer.
//
#define E_SCO_IIS_PORTNUMBER_NOT_VALID   0xC10101A2L

//
// MessageId: E_SCO_IIS_CREATE_FTP_FAILED
//
// MessageText:
//
//  [%1] Failed to created IIS FTP site.
//
#define E_SCO_IIS_CREATE_FTP_FAILED      0xC10101A3L

//
// MessageId: E_SCO_IIS_DELETE_FTP_FAILED
//
// MessageText:
//
//  [%1] Failed to delete IIS FTP site.
//
#define E_SCO_IIS_DELETE_FTP_FAILED      0xC10101A4L
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\sco\iisscov50\messagefile\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MessageFile.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\sco\iisscov50\messagefile\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	MessageFile.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\sco\iisscov50\messagefile\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__E8C96FF5_CB6C_11D2_8476_00105ACA7AE9__INCLUDED_)
#define AFX_STDAFX_H__E8C96FF5_CB6C_11D2_8476_00105ACA7AE9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>
#include <stdio.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__E8C96FF5_CB6C_11D2_8476_00105ACA7AE9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\sco\iisscov50\messagefile\messagefile.cpp ===
// MessageFile.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"

// RG ---------- Part of message file registration -------------
static CHAR s_pwszEventSource[] = "IISSCOv50";
HINSTANCE g_hDllInst;
CHAR c_szMAPS[11] = "IISSCOv50";
//-------------- end RG -----------------------------------------

BOOL APIENTRY DllMain( HINSTANCE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    g_hDllInst = hModule;
	return true;
}

	/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{

	// -------Added by to register message file -----------------------
	HRESULT hr = E_FAIL;

    TCHAR szModulePath[200];
    DWORD cPathLen, dwData;
    LONG lRes;
    HKEY hkey = NULL, hkApp = NULL;

	// RG - This returns full filename and path to this DLL.  I just want the directory
    cPathLen = GetModuleFileName(g_hDllInst, szModulePath,
		                         sizeof(szModulePath)/sizeof(TCHAR));
    

    if (cPathLen == 0)
        goto LocalCleanup;

    lRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        "SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\",
                        0, KEY_ALL_ACCESS, &hkey);

    if (lRes != ERROR_SUCCESS)
        goto LocalCleanup;

    lRes = RegCreateKeyEx(hkey, c_szMAPS, 0, NULL, REG_OPTION_NON_VOLATILE,
                          KEY_ALL_ACCESS, NULL, &hkApp, NULL);

    if (lRes != ERROR_SUCCESS)
        goto LocalCleanup;


    lRes = RegSetValueEx(hkApp, "EventMessageFile",
                        0, REG_EXPAND_SZ,
                        (LPBYTE) szModulePath,
                       (sizeof(szModulePath[0]) * cPathLen) + 1);


    if (lRes != ERROR_SUCCESS)
        goto LocalCleanup;

    dwData = (EVENTLOG_ERROR_TYPE
              | EVENTLOG_WARNING_TYPE
              | EVENTLOG_INFORMATION_TYPE); 

    lRes = RegSetValueEx(hkApp, "TypesSupported",
                         0, REG_DWORD,
                         (LPBYTE) &dwData,
                         sizeof(dwData));
    if (lRes != ERROR_SUCCESS)
        goto LocalCleanup;

	hr = S_OK;
    
 LocalCleanup:
    if (hkApp)
    {
        RegCloseKey(hkApp);
    }
    if (hkey)
    {
        // Cleanup on complete failure
        if (FAILED(hr))
        {
            RegDeleteKey(hkey, c_szMAPS);
        }
        RegCloseKey(hkey);
    }
    
    return hr;
	//-----------  End of Register IISScoMessageFile.dll  -----------
    //return TRUE;
}
STDAPI DllUnregisterServer(void)
{
	return S_OK;
}
void __declspec( dllexport ) dummyfunc( void )
{
	return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\sco\iisscov50\messagefile\versions.h ===
#define PRODUCT_MAJOR_VERSION 4
#define PRODUCT_MINOR_VERSION 0
#define PRODUCT_REVISION 0
#define PRODUCT_BUILD 6
#define PRODUCT_VERSION_STRING "4.0.6\0"
#define FILE_MAJOR_VERSION 4
#define FILE_MINOR_VERSION 0
#define FILE_REVISION 0
#define FILE_BUILD 6
#define FILE_VERSION_STRING "4.0.6\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\secconlib\debug.cpp ===
#include <stdio.h>
#include <stdarg.h>
#include "debug.h"

#if DBG

void __cdecl
Trace(
    LPCWSTR ptszFormat,
    ...)
{
    WCHAR tszBuff[2048];
    va_list args;
    
    va_start(args, ptszFormat);
    vswprintf(tszBuff, ptszFormat, args);
    va_end(args);
    OutputDebugString(tszBuff);
}

void __cdecl
Assert(
    LPCSTR  pszFile,
    DWORD   dwLine,
    LPCSTR  pszCond)
{
    CHAR pszBuf[2048];

    _snprintf( 
        pszBuf, 
        2048, 
        "%s, Line %u, Assertion failed: %s\n",
        pszFile,
        dwLine,
        pszCond);

    pszBuf[2047] = L'\0';

    OutputDebugStringA(pszBuf);
    DebugBreak();
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\sitecreator\debug.cpp ===
#include <stdio.h>
#include <stdarg.h>
#include "debug.h"

#if DBG

void __cdecl
Trace(
    LPCWSTR ptszFormat,
    ...)
{
    WCHAR tszBuff[2048];
    va_list args;
    
    va_start(args, ptszFormat);
    vswprintf(tszBuff, ptszFormat, args);
    va_end(args);
    OutputDebugString(tszBuff);
}

void __cdecl
Assert(
    LPCSTR  pszFile,
    DWORD   dwLine,
    LPCSTR  pszCond)
{
    CHAR pszBuf[2048];

    _snprintf( 
        pszBuf, 
        2048, 
        "%s, Line %u, Assertion failed: %s\n",
        pszFile,
        dwLine,
        pszCond);

    pszBuf[2047] = L'\0';

    OutputDebugStringA(pszBuf);
    DebugBreak();
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\secconlib\safecs.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        SafeCS.h
//
// Contents:    CSafeAutoCriticalSection, protects CriticalSection against AV via try,catch
//
//------------------------------------------------------------------------
#ifndef _SAFECS_H_
#define _SAFECS_H_

class CSafeAutoCriticalSection
{
public:


    CSafeAutoCriticalSection();
    ~CSafeAutoCriticalSection();

    DWORD Lock();
    DWORD  Unlock();

    BOOL IsInitialized() { return (STATE_INITIALIZED == m_lState);}

private:

    enum
    {
        STATE_UNINITIALIZED = 0,
        STATE_INITIALIZED   = 1
    };

    CRITICAL_SECTION    m_cs;
    LONG                m_lState;
	DWORD               m_dwError;

};

class CSafeLock 
{
public:
	CSafeLock (CSafeAutoCriticalSection* val);
	CSafeLock (CSafeAutoCriticalSection& val);

	~CSafeLock ();

	DWORD Lock ();
	DWORD Unlock ();
private:

private:
	BOOL m_locked;
	CSafeAutoCriticalSection* m_pSem;
};

#endif // _SAFECS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\sitecreator\safecs.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        SafeCS.h
//
// Contents:    CSafeAutoCriticalSection, protects CriticalSection against AV via try,catch
//
//------------------------------------------------------------------------
#ifndef _SAFECS_H_
#define _SAFECS_H_

class CSafeAutoCriticalSection
{
public:


    CSafeAutoCriticalSection();
    ~CSafeAutoCriticalSection();

    DWORD Lock();
    DWORD  Unlock();

    BOOL IsInitialized() { return (STATE_INITIALIZED == m_lState);}

private:

    enum
    {
        STATE_UNINITIALIZED = 0,
        STATE_INITIALIZED   = 1
    };

    CRITICAL_SECTION    m_cs;
    LONG                m_lState;
	DWORD               m_dwError;

};

class CSafeLock 
{
public:
	CSafeLock (CSafeAutoCriticalSection* val);
	CSafeLock (CSafeAutoCriticalSection& val);

	~CSafeLock ();

	DWORD Lock ();
	DWORD Unlock ();
private:

private:
	BOOL m_locked;
	CSafeAutoCriticalSection* m_pSem;
};

#endif // _SAFECS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\secconlib\secconlib.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    SecConLib.h

Abstract:

    Implementation of:
        CSecConLib

Author:

    Brent R. Midwood            Apr-2002

Revision History:

--*/

#ifndef __secconlib_h__
#define __secconlib_h__

#if _MSC_VER > 1000
#pragma once
#endif 

#include <iadmw.h>
#include "SafeCS.h"
#include <atlbase.h>

class CSecConLib
{
private:
    CSafeAutoCriticalSection m_SafeCritSec;
    CComPtr<IMSAdminBase>    m_spIABase;
    bool                     m_bInit;

    HRESULT InternalInitIfNecessary();

    HRESULT GetMultiSZPropVal(
        LPCWSTR wszPath,
        DWORD   dwMetaID,
        WCHAR  **ppBuffer,
        DWORD  *dwBufSize);

    HRESULT SetMultiSZPropVal(
        LPCWSTR wszPath,
        DWORD   dwMetaID,
        WCHAR  *pBuffer,
        DWORD   dwBufSize);

    HRESULT StatusExtensionFile(
        /* [in]  */ bool      bEnable,
        /* [in]  */ LPCWSTR   wszExFile,
        /* [in]  */ LPCWSTR   wszPath);
        
    HRESULT StatusWServEx(
        /* [in]  */ bool      bEnable,
        /* [in]  */ LPCWSTR   wszWServEx,
        /* [in]  */ LPCWSTR   wszPath);
        
public:
    CSecConLib();

    CSecConLib(
        IMSAdminBase* pIABase);

    virtual ~CSecConLib();

    HRESULT STDMETHODCALLTYPE EnableApplication(
        /* [in]  */ LPCWSTR   wszApplication,
        /* [in]  */ LPCWSTR   wszPath);

    HRESULT STDMETHODCALLTYPE RemoveApplication(
        /* [in]  */ LPCWSTR   wszApplication,
        /* [in]  */ LPCWSTR   wszPath);

    HRESULT STDMETHODCALLTYPE ListApplications(
        /* [in]  */ LPCWSTR   wszPath,
        /* [out] */ WCHAR   **pszBuffer,       // MULTI_SZ - allocated inside ListApplications, caller should delete
        /* [out] */ DWORD    *pdwBufferSize);  // length includes ending double null

    HRESULT STDMETHODCALLTYPE QueryGroupIDStatus(
        /* [in]  */ LPCWSTR   wszPath,
        /* [in]  */ LPCWSTR   wszGroupID,
        /* [out] */ WCHAR   **pszBuffer,       // MULTI_SZ - allocated inside QueryGroupIDStatus, caller should delete
        /* [out] */ DWORD    *pdwBufferSize);  // length includes ending double null

    HRESULT STDMETHODCALLTYPE AddDependency(
        /* [in]  */ LPCWSTR   wszApplication,
        /* [in]  */ LPCWSTR   wszGroupID,
        /* [in]  */ LPCWSTR   wszPath);

    HRESULT STDMETHODCALLTYPE RemoveDependency(
        /* [in]  */ LPCWSTR   wszApplication,
        /* [in]  */ LPCWSTR   wszGroupID,
        /* [in]  */ LPCWSTR   wszPath);

    HRESULT STDMETHODCALLTYPE EnableWebServiceExtension(
        /* [in]  */ LPCWSTR   wszExtension,
        /* [in]  */ LPCWSTR   wszPath);

    HRESULT STDMETHODCALLTYPE DisableWebServiceExtension(
        /* [in]  */ LPCWSTR   wszExtension,
        /* [in]  */ LPCWSTR   wszPath);

    HRESULT STDMETHODCALLTYPE ListWebServiceExtensions(
        /* [in]  */ LPCWSTR   wszPath,
        /* [out] */ WCHAR   **pszBuffer,      // MULTI_SZ - allocated in here, caller should delete
        /* [out] */ DWORD    *pdwBufferSize); // length includes double null

    HRESULT STDMETHODCALLTYPE EnableExtensionFile(
        /* [in]  */ LPCWSTR   wszExFile,
        /* [in]  */ LPCWSTR   wszPath);

    HRESULT STDMETHODCALLTYPE DisableExtensionFile(
        /* [in]  */ LPCWSTR   wszExFile,
        /* [in]  */ LPCWSTR   wszPath);

    HRESULT STDMETHODCALLTYPE AddExtensionFile(
        /* [in]  */ LPCWSTR   bstrExtensionFile,
        /* [in]  */ bool      bAccess,
        /* [in]  */ LPCWSTR   bstrGroupID,
        /* [in]  */ bool      bCanDelete,
        /* [in]  */ LPCWSTR   bstrDescription,
        /* [in]  */ LPCWSTR   wszPath);

    HRESULT STDMETHODCALLTYPE DeleteExtensionFileRecord(
        /* [in]  */ LPCWSTR   wszExFile,
        /* [in]  */ LPCWSTR   wszPath);

    HRESULT STDMETHODCALLTYPE ListExtensionFiles(
        /* [in]  */ LPCWSTR   wszPath,
        /* [out] */ WCHAR   **pszBuffer,      // MULTI_SZ - allocated in here, caller should delete
        /* [out] */ DWORD    *pdwBufferSize); // length includes double null
};

#endif // __secconlib_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\secconlib\secconlib.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    SecConLib.cpp

Abstract:

    Implementation of:
        CSecConLib

Author:

    Brent R. Midwood            Apr-2002

Revision History:

--*/

#include "secconlib.h"
#include "debug.h"
#include "iiscnfg.h"

#define BAIL_ON_FAILURE(hr)           if (FAILED(hr)) { goto done; }
#define DEFAULT_TIMEOUT_VALUE         30000
#define SEMICOLON_STRING              L";"
#define SEMICOLON_CHAR                L';'
#define COMMA_STRING                  L","
#define COMMA_CHAR                    L','
#define ZERO_STRING                   L"0"
#define ZERO_CHAR                     L'0'
#define ONE_STRING                    L"1"
#define ONE_CHAR                      L'1'

CSecConLib::CSecConLib()
{
    m_bInit = false;
}

CSecConLib::CSecConLib(
            IMSAdminBase* pIABase)
{
    SC_ASSERT(pIABase != NULL);
    m_spIABase = pIABase;
    m_bInit    = true;
}

CSecConLib::~CSecConLib()
{
}

HRESULT
CSecConLib::InternalInitIfNecessary()
{
    HRESULT   hr = S_OK;
    CSafeLock csSafe(m_SafeCritSec);

    if(m_bInit)
    {
        return hr;
    }

    hr = csSafe.Lock();
    hr = HRESULT_FROM_WIN32(hr);
    if(FAILED(hr))
    {
        return hr;
    }

    if(!m_bInit)
    {
        hr = CoCreateInstance(
            CLSID_MSAdminBase,
            NULL,
            CLSCTX_ALL,
            IID_IMSAdminBase,
            (void**)&m_spIABase);
        if(FAILED(hr))
        {
            m_bInit = false;
        }
        else
        {
            m_bInit = true;
        }
    }

    csSafe.Unlock();

    return hr;
}

STDMETHODIMP CSecConLib::EnableApplication(
        /* [in]  */ LPCWSTR   wszApplication,
        /* [in]  */ LPCWSTR   wszPath)
{
    DWORD   dwAppNameSz  = 0;
    WCHAR  *pwszAppProp  = NULL;
    DWORD   dwAppPropSz  = 0;
    HRESULT hr           = S_OK;
    bool    bFound       = false;
    WCHAR  *pTop         = NULL;

    // compute arg length
    dwAppNameSz = (DWORD)wcslen(wszApplication);

    hr = InternalInitIfNecessary();
    if (FAILED(hr))
    {
        BAIL_ON_FAILURE(hr);
    }

    // get the current property value for applicationdep list
    hr = GetMultiSZPropVal(wszPath, MD_APP_DEPENDENCIES, &pwszAppProp, &dwAppPropSz);

    BAIL_ON_FAILURE(hr);

    if (NULL == pwszAppProp)
    {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pTop = pwszAppProp;

    // go thru the apps one by one
    while (pwszAppProp[0])
    {
        DWORD dwTokSz = (DWORD)wcslen(pwszAppProp) + 1;

        // check to see if the app matches
        if (!_wcsnicmp(wszApplication, pwszAppProp, dwAppNameSz) &&
            pwszAppProp[dwAppNameSz] == SEMICOLON_CHAR)
        {
            bFound = true;

            WCHAR *pGroups = &pwszAppProp[dwAppNameSz + ((DWORD)sizeof(SEMICOLON_CHAR) / (DWORD)sizeof(WCHAR))];

            while (pGroups)
            {
                WCHAR *pTemp = wcschr(pGroups, COMMA_CHAR);
                
                if (pTemp)
                {
                    *pTemp = 0;  // replace comma w/ null    
                }

                hr = EnableWebServiceExtension(pGroups, wszPath);
                BAIL_ON_FAILURE(hr);

                if (pTemp)
                {
                    pGroups = pTemp + 1;  // go past comma
                }
                else
                {
                    pGroups = NULL;
                }
            }
        }
        pwszAppProp += dwTokSz; // go to the next part of the multisz
    }

    if (!bFound)
    {
        BAIL_ON_FAILURE(hr = MD_ERROR_DATA_NOT_FOUND);    
    }

done:
    if (pTop)
    {
        delete [] pTop;
    }

    return hr;
}

HRESULT CSecConLib::SetMultiSZPropVal(
    LPCWSTR wszPath,
    DWORD   dwMetaId,
    WCHAR  *pBuffer,
    DWORD   dwBufSize)
{
    HRESULT hr = S_OK;
    METADATA_RECORD mdrMDData;
    METADATA_HANDLE hObjHandle = NULL;

    hr = m_spIABase->OpenKey(
                METADATA_MASTER_ROOT_HANDLE,
                wszPath,
                METADATA_PERMISSION_WRITE,
                DEFAULT_TIMEOUT_VALUE,
                &hObjHandle
                );

    BAIL_ON_FAILURE(hr);

    if (!pBuffer)
    {
        hr = m_spIABase->DeleteData(
                              hObjHandle,
                              (LPWSTR)L"",
                              dwMetaId,
                              ALL_METADATA
                              );

        BAIL_ON_FAILURE(hr);
    }

    else
    {
        MD_SET_DATA_RECORD(&mdrMDData,
                           dwMetaId, 
                           METADATA_NO_ATTRIBUTES,
                           IIS_MD_UT_SERVER,
                           MULTISZ_METADATA,
                           dwBufSize * sizeof(WCHAR),
                           pBuffer);

        hr = m_spIABase->SetData(
               hObjHandle,
               L"",
               &mdrMDData
               );
    
        BAIL_ON_FAILURE(hr);
    }

done:

    m_spIABase->CloseKey(hObjHandle);

    return hr;
}

HRESULT CSecConLib::GetMultiSZPropVal(
    LPCWSTR wszPath,
    DWORD   dwMetaId,
    WCHAR  **ppBuffer,
    DWORD  *dwBufSize)
{
    HRESULT hr = S_OK;
    DWORD dwBufferSize = 0;
    METADATA_RECORD mdrMDData;
    WCHAR *pBuffer = NULL;
    METADATA_HANDLE hObjHandle = NULL;

    hr = m_spIABase->OpenKey(
                METADATA_MASTER_ROOT_HANDLE,
                wszPath,
                METADATA_PERMISSION_READ,
                DEFAULT_TIMEOUT_VALUE,
                &hObjHandle
                );

    BAIL_ON_FAILURE(hr);

    MD_SET_DATA_RECORD(&mdrMDData,
                       dwMetaId, 
                       METADATA_NO_ATTRIBUTES,
                       IIS_MD_UT_SERVER,
                       MULTISZ_METADATA,
                       dwBufferSize,
                       pBuffer);

    hr = m_spIABase->GetData(
             hObjHandle,
             L"",
             &mdrMDData,
             &dwBufferSize
             );

    if (dwBufferSize > 0)
    {
        *dwBufSize = dwBufferSize / sizeof(WCHAR);
        pBuffer = (WCHAR*) new BYTE[dwBufferSize];
        
        if (!pBuffer) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        MD_SET_DATA_RECORD(&mdrMDData,
                           dwMetaId, 
                           METADATA_NO_ATTRIBUTES,
                           IIS_MD_UT_SERVER,
                           MULTISZ_METADATA,
                           dwBufferSize,
                           pBuffer);

        hr = m_spIABase->GetData(
                 hObjHandle,
                 L"",
                 &mdrMDData,
                 &dwBufferSize
                 );
    }

    BAIL_ON_FAILURE(hr);

    *ppBuffer  = pBuffer;

    hr = m_spIABase->CloseKey(hObjHandle);

    return hr;

done:

    if (pBuffer) {
        delete [] pBuffer;
    }

    m_spIABase->CloseKey(hObjHandle);
    
    return hr;
}

STDMETHODIMP CSecConLib::RemoveApplication(
        /* [in]  */ LPCWSTR   wszApplication,
        /* [in]  */ LPCWSTR   wszPath)
{
    DWORD   dwAppNameSz  = 0;
    WCHAR  *pwszOrig     = NULL;
    WCHAR  *pTopOrig     = NULL;
    WCHAR  *pwszAppProp  = NULL;
    DWORD   dwAppPropSz  = 0;
    HRESULT hr           = S_OK;
    bool    bFound       = false;

    // compute arg length
    dwAppNameSz = (DWORD)wcslen(wszApplication);

    hr = InternalInitIfNecessary();
    if (FAILED(hr))
    {
        BAIL_ON_FAILURE(hr);
    }

    // get the current property value for applicationdep list
    hr = GetMultiSZPropVal(wszPath, MD_APP_DEPENDENCIES, &pwszAppProp, &dwAppPropSz);

    BAIL_ON_FAILURE(hr);

    // remove the application

    // copy the property
    pwszOrig = new WCHAR[dwAppPropSz];
    pTopOrig = pwszOrig;

    if (!pwszOrig)
    {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    memcpy(pwszOrig, pwszAppProp, dwAppPropSz * sizeof(WCHAR));

    dwAppPropSz = 1;  //reset size to contain one for the last null
    WCHAR* pMidBuf = pwszAppProp;

    // copy the old apps one by one
    while (pwszOrig[0])
    {
        DWORD dwTokSz = (DWORD)wcslen(pwszOrig) + 1;

        // check to see if the app already exists
        if (!_wcsnicmp(wszApplication, pwszOrig, dwAppNameSz) &&
            pwszOrig[dwAppNameSz] == SEMICOLON_CHAR)
        {
            bFound = true;
        }
        else
        {
            // copy it in
            if (NULL == pMidBuf)
            {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
            wcscpy(pMidBuf, pwszOrig);
            pMidBuf += dwTokSz;  // advance past null
            *pMidBuf = 0;  // add the last null
            dwAppPropSz += dwTokSz;
        }
        pwszOrig += dwTokSz; // go to the next part of the multisz
    }

    if (!bFound)
    {
        BAIL_ON_FAILURE(hr = MD_ERROR_DATA_NOT_FOUND);    
    }

    // set the new property value for property
    if (dwAppPropSz < 3)
    {
        // handle deleting the last one
        hr = SetMultiSZPropVal(wszPath, MD_APP_DEPENDENCIES, NULL, 0);
    }
    else
    {
        hr = SetMultiSZPropVal(wszPath, MD_APP_DEPENDENCIES, pwszAppProp, dwAppPropSz);
    }

    BAIL_ON_FAILURE(hr);

done:
    if (pTopOrig)
    {
        delete [] pTopOrig;
    }

    if (pwszAppProp)
    {
        delete [] pwszAppProp;
    }

    return hr;
}

STDMETHODIMP CSecConLib::QueryGroupIDStatus(
        /* [in]  */ LPCWSTR   wszPath,
        /* [in]  */ LPCWSTR   wszGroupID,
        /* [out] */ WCHAR   **pszBuffer,      // MULTI_SZ - allocated in here, caller should delete
        /* [out] */ DWORD    *pdwBufferSize)  // length includes double null
{
    WCHAR  *pwszAppProp  = NULL;
    DWORD   dwAppPropSz  = 0;
    WCHAR  *pList        = NULL;
    WCHAR  *pTempList    = NULL;
    DWORD   dwListLen    = 1;  // one for the extra null at the end
    DWORD   dwOldListLen = 1;
    HRESULT hr           = S_OK;
    WCHAR  *pTop         = NULL;

    hr = InternalInitIfNecessary();
    if (FAILED(hr))
    {
        BAIL_ON_FAILURE(hr);
    }

    // get the current property value for applicationdep list
    hr = GetMultiSZPropVal(wszPath, MD_APP_DEPENDENCIES, &pwszAppProp, &dwAppPropSz);

    BAIL_ON_FAILURE(hr);

    if (NULL == pwszAppProp)
    {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pTop = pwszAppProp;

    // iterate through the apps
    while (pwszAppProp[0])
    {
        // reset bFound
        bool bFound = false;

        WCHAR* pMidBuf = wcschr(pwszAppProp, SEMICOLON_CHAR);
        if (!pMidBuf)
        {
            BAIL_ON_FAILURE(hr = E_FAIL);    
        }

        // null the semicolon and go past it
        *pMidBuf = 0;
        *pMidBuf++;
        
        // does this app have a dependency on the GroupID that got passed in?
        WCHAR* pGroupID = NULL;
        WCHAR* pGroups = new WCHAR[(DWORD)wcslen(pMidBuf) + 1];
        if (!pGroups)
        {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        // copy in the GroupIDs
        wcscpy(pGroups, pMidBuf);

        // look at each GroupID
        pGroupID = wcstok(pGroups, COMMA_STRING);

        while (pGroupID && !bFound)
        {
            if (!wcscmp(pGroupID, wszGroupID))
            {
                bFound = true;
            }

            pGroupID = wcstok(NULL, COMMA_STRING);
        }

        if (pGroups)
        {
            delete [] pGroups;
        }

        // do we want to add this app to the list?
        if (bFound)
        {
            // allocate the memory
            dwListLen += (DWORD)wcslen(pwszAppProp) + 1;  // for the null
            pTempList = new WCHAR[dwListLen];
        
            if (!pTempList)
            {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            if (pList)
            {
                // copy the previous list
                memcpy(pTempList, pList, dwOldListLen * sizeof(WCHAR));
                delete [] pList;    
            }

            // copy on the app name
            wcscpy(&pTempList[dwOldListLen - 1], pwszAppProp);
            pTempList[dwListLen-1] = 0;
            pTempList[dwListLen-2] = 0;

            pList = pTempList;
            dwOldListLen = dwListLen;
        }

        // now go to the next application
        pwszAppProp = pMidBuf + (DWORD)wcslen(pMidBuf) + 1;
    }

    *pszBuffer     = pList;
    *pdwBufferSize = dwListLen;

done:
    if (pTop)
    {
        delete [] pTop;
    }

    return hr;
}

STDMETHODIMP CSecConLib::ListApplications(
        /* [in]  */ LPCWSTR   wszPath,
        /* [out] */ WCHAR   **pszBuffer,      // MULTI_SZ - allocated in here, caller should delete
        /* [out] */ DWORD    *pdwBufferSize)  // length includes double null
{
    WCHAR  *pwszAppProp  = NULL;
    DWORD   dwAppPropSz  = 0;
    WCHAR  *pList        = NULL;
    WCHAR  *pTempList    = NULL;
    DWORD   dwListLen    = 1;  // one for the extra null at the end
    DWORD   dwOldListLen = 1;
    HRESULT hr           = S_OK;
    WCHAR  *pTop         = NULL;
    
    hr = InternalInitIfNecessary();
    if (FAILED(hr))
    {
        BAIL_ON_FAILURE(hr);
    }

    // get the current property value for applicationdep list
    hr = GetMultiSZPropVal(wszPath, MD_APP_DEPENDENCIES, &pwszAppProp, &dwAppPropSz);

    BAIL_ON_FAILURE(hr);

    if (NULL == pwszAppProp)
    {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pTop = pwszAppProp;

    // iterate through the apps
    while (pwszAppProp[0])
    {
        WCHAR* pMidBuf = wcschr(pwszAppProp, SEMICOLON_CHAR);
        if (!pMidBuf)
        {
            BAIL_ON_FAILURE(hr = E_FAIL);    
        }

        // null the semicolon and go past it
        *pMidBuf = 0;
        *pMidBuf++;
        
        // allocate the memory
        dwListLen += (DWORD)wcslen(pwszAppProp) + 1;  // for the null
        pTempList = new WCHAR[dwListLen];
        
        if (!pTempList)
        {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        if (pList)
        {
            // copy the previous list
            memcpy(pTempList, pList, dwOldListLen * sizeof(WCHAR));
            delete [] pList;    
        }

        // copy on the app name
        wcscpy(&pTempList[dwOldListLen - 1], pwszAppProp);
        pTempList[dwListLen-1] = 0;
        pTempList[dwListLen-2] = 0;

        pList = pTempList;
        dwOldListLen = dwListLen;

        // now go to the next application
        pwszAppProp = pMidBuf + (DWORD)wcslen(pMidBuf) + 1;
    }

    if (!pList)
    {
        // make it a valid empty multisz
        dwListLen = 2;
        pList = new WCHAR[dwListLen];
        if (!pList)
        {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        wmemset(pList, 0, dwListLen);
    }

    *pszBuffer     = pList;
    *pdwBufferSize = dwListLen;

done:
    if (pTop)
    {
        delete [] pTop;
    }

    return hr;
}

STDMETHODIMP CSecConLib::AddDependency(
        /* [in]  */ LPCWSTR   wszApplication,
        /* [in]  */ LPCWSTR   wszGroupID,
        /* [in]  */ LPCWSTR   wszPath)
{
    WCHAR  *pwszAppProp  = NULL;
    WCHAR  *pwszOrig     = NULL;
    WCHAR  *pwszTopOrig  = NULL;
    DWORD   dwAppPropSz  = 0;
    DWORD   dwAppNameSz  = 0;
    DWORD   dwGroupIDSz  = 0;
    HRESULT hr           = S_OK;
    bool    bDone        = false;

    // compute arg length
    dwAppNameSz = (DWORD)wcslen(wszApplication);
    dwGroupIDSz = (DWORD)wcslen(wszGroupID);

    hr = InternalInitIfNecessary();
    if (FAILED(hr))
    {
        BAIL_ON_FAILURE(hr);
    }

    // get the current property value for applicationdep list
    hr = GetMultiSZPropVal(wszPath, MD_APP_DEPENDENCIES, &pwszAppProp, &dwAppPropSz);

    if (MD_ERROR_DATA_NOT_FOUND == hr)
    {
        // this is okay, we just need to create the property.
        hr = S_OK;
        dwAppPropSz = 0;
    }

    BAIL_ON_FAILURE(hr);

    // add the dependency
    
    if (!dwAppPropSz)
    {
        // create the property

        // size of the property = len(App) + 1(semicolon) + len(GID) + 2(double null MULTISZ)
        dwAppPropSz = dwAppNameSz + (DWORD)wcslen(SEMICOLON_STRING) + dwGroupIDSz + 2;

        // No Leak
        // pwszAppProp never got alloced since we didn't get any value back,
        // so no need to delete first...

        pwszAppProp = new WCHAR[dwAppPropSz];
        if (!pwszAppProp)
        {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        wcscpy(pwszAppProp, wszApplication);
        wcscat(pwszAppProp, SEMICOLON_STRING);
        wcscat(pwszAppProp, wszGroupID);
        
        // add the double null
        pwszAppProp[dwAppPropSz-1] = 0;
        pwszAppProp[dwAppPropSz-2] = 0;
    }
    
    else
    {
        // property already exists

        // copy the property
        pwszOrig = new WCHAR[dwAppPropSz];
        pwszTopOrig = pwszOrig;

        if (!pwszOrig)
        {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        memcpy(pwszOrig, pwszAppProp, dwAppPropSz * sizeof(WCHAR));

        // resize the new property to the biggest possible
        if (pwszAppProp)
        {
            delete [] pwszAppProp;
        }

        // max new size is old size + len(app) + 1(semicolon) + len(GID) + null
        dwAppPropSz = dwAppPropSz + dwAppNameSz + (DWORD)wcslen(SEMICOLON_STRING) + 
                      dwGroupIDSz + 1;

        pwszAppProp = new WCHAR[dwAppPropSz];
        if (!pwszAppProp)
        {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        WCHAR* pMidBuf = pwszAppProp;

        // copy the old dependencies one by one
        while (pwszOrig[0])
        {
            wcscpy(pMidBuf, pwszOrig);

            // check to see if the app already exists
            if (!_wcsnicmp(wszApplication, pMidBuf, dwAppNameSz) &&
                pMidBuf[dwAppNameSz] == SEMICOLON_CHAR)
            {
                // since we're not adding the app, subtract the size of the app and trailing null
                dwAppPropSz = dwAppPropSz - dwAppNameSz - 1;

                // this is the correct app, so now look for the GroupID
                pMidBuf += dwAppNameSz + 1; // go to the first GroupID
                
                // need a temp copy, sinc wcstok modifies the string
                WCHAR* pTokTemp = new WCHAR[(DWORD)wcslen(pMidBuf) + 1];
                if (!pTokTemp)
                {
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                }
                wcscpy(pTokTemp, pMidBuf);

                WCHAR* token = wcstok( pTokTemp, COMMA_STRING );
                while (token && !bDone)
                {
                    if (!_wcsicmp(token, wszGroupID))
                    {
                        // we found the group ID, so the user is trying
                        // to add a dependency that is already there
                        if (pTokTemp)
                        {
                            delete [] pTokTemp;    
                        }
        
                        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(ERROR_DUP_NAME));
                    }
                    token = wcstok( NULL, COMMA_STRING );
                }
                
                if (pTokTemp)
                {
                    delete [] pTokTemp;    
                }

                pMidBuf += (DWORD)wcslen(pMidBuf);  // go to the null at the end of this part

                if (!bDone)
                {
                    // we didn't find the GroupID, so add it
                    wcscat(pMidBuf, COMMA_STRING);
                    wcscat(pMidBuf, wszGroupID);
                    pMidBuf += (DWORD)wcslen(pMidBuf);  // go to the null at the end of this part
                    bDone = true;
                }

                pMidBuf++;  // go to the next char and make it a null
                pMidBuf[0] = 0;
            }

            else // no change here, move pMidBuf along...
            {
                pMidBuf += (DWORD)wcslen(pMidBuf) + 1;  // go past the null    
            }

            pwszOrig += (DWORD)wcslen(pwszOrig) + 1; // go to the next part of the multisz
        }

        if (!bDone)
        {
            // we didn't even find the application, so add both app & groupID
            wcscpy(pMidBuf, wszApplication);
            wcscat(pMidBuf, SEMICOLON_STRING);
            wcscat(pMidBuf, wszGroupID);
            pMidBuf[(DWORD)wcslen(pMidBuf)+1] = 0; // add the last null
        }
    }

    // set the new property value for property
    hr = SetMultiSZPropVal(wszPath, MD_APP_DEPENDENCIES, pwszAppProp, dwAppPropSz);

    BAIL_ON_FAILURE(hr);

done:
    if (pwszTopOrig)
    {
        delete [] pwszTopOrig;
    }

    if (pwszAppProp)
    {
        delete [] pwszAppProp;
    }

    return hr;
}

STDMETHODIMP CSecConLib::RemoveDependency(
        /* [in]  */ LPCWSTR   wszApplication,
        /* [in]  */ LPCWSTR   wszGroupID,
        /* [in]  */ LPCWSTR   wszPath)
{
    HRESULT hr = S_OK;
    WCHAR  *pwszOrig     = NULL;
    WCHAR  *pwszTopOrig  = NULL;
    WCHAR  *pwszAppProp  = NULL;
    WCHAR  *pStartStr    = NULL;
    DWORD   dwAppPropSz  = 0;
    DWORD   dwAppNameSz  = 0;
    DWORD   dwGroupIDSz  = 0;
    bool    bFound       = false;
    bool    bOtherGIDs   = false;

    // compute arg length
    dwAppNameSz = (DWORD)wcslen(wszApplication);
    dwGroupIDSz = (DWORD)wcslen(wszGroupID);

    hr = InternalInitIfNecessary();
    if (FAILED(hr))
    {
        BAIL_ON_FAILURE(hr);
    }

    // get the current property value for applicationdep list
    hr = GetMultiSZPropVal(wszPath, MD_APP_DEPENDENCIES, &pwszAppProp, &dwAppPropSz);

    BAIL_ON_FAILURE(hr);

    // remove the dependency

    // copy the property
    pwszOrig = new WCHAR[dwAppPropSz];
    pwszTopOrig = pwszOrig;

    if (!pwszOrig)
    {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    memcpy(pwszOrig, pwszAppProp, dwAppPropSz * sizeof(WCHAR));

    WCHAR* pMidBuf = pwszAppProp;

    // copy the old dependencies one by one
    while (pwszOrig[0])
    {
        // check to see if the app already exists
        if (!_wcsnicmp(wszApplication, pwszOrig, dwAppNameSz) &&
            pwszOrig[dwAppNameSz] == SEMICOLON_CHAR)
        {
            pStartStr = pMidBuf;

            // this is the correct app, so now look for the GroupID
            pMidBuf += dwAppNameSz + 1; // go to the first GroupID

            // need a temp copy, sinc wcstok modifies the string
            WCHAR* pTokTemp = new WCHAR[(DWORD)wcslen(pMidBuf) + 1];
            if (!pTokTemp)
            {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
            wcscpy(pTokTemp, pMidBuf);

            WCHAR* token = wcstok( pTokTemp, COMMA_STRING );
            while (token)
            {
                if (bOtherGIDs)
                {
                    wcscpy(pMidBuf, COMMA_STRING);
                    pMidBuf += (DWORD)wcslen(pMidBuf);
                }

                if (!wcscmp(token, wszGroupID))
                {
                    // we found the group ID
                    bFound = true;

                    // adjust the final length = no comma, no GID
                    dwAppPropSz = dwAppPropSz - (DWORD)wcslen(COMMA_STRING) - dwGroupIDSz;

                    if (bOtherGIDs)
                    {
                        // need to backup over the last comma we inserted
                        pMidBuf -= (DWORD)wcslen(COMMA_STRING);
                        *pMidBuf = 0;
                    }
                }
                else
                {
                    bOtherGIDs = true;
                    wcscpy(pMidBuf, token);
                    pMidBuf += (DWORD)wcslen(pMidBuf);
                }

                token = wcstok( NULL, COMMA_STRING );
            }

            if (pTokTemp)
            {
                delete [] pTokTemp;    
            }

            if (!bOtherGIDs)
            {
                // deleted last dependency, so delete the app
                pMidBuf = pStartStr;
				dwAppPropSz = dwAppPropSz - dwAppNameSz - 1; // account for null
            }
            else
            {
                pMidBuf++;
                *pMidBuf = 0;
            }
        }

        else // no change here, move pMidBuf along...
        {
            if (NULL == pMidBuf)
            {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
            wcscpy(pMidBuf, pwszOrig);   // copy the part without mods
            pMidBuf += (DWORD)wcslen(pMidBuf) + 1;  // go past the null    
        }

        pwszOrig += (DWORD)wcslen(pwszOrig) + 1; // go to the next part of the multisz
    }

    if (!bFound)
    {
        // user is trying to remove a non-existent dependency
        BAIL_ON_FAILURE(hr = MD_ERROR_DATA_NOT_FOUND);    
    }

    *pMidBuf = 0;

    // set the new property value for property
    if (dwAppPropSz < 3)
    {
        // handle deleting the last one
        hr = SetMultiSZPropVal(wszPath, MD_APP_DEPENDENCIES, NULL, 0);
    }
    else
    {
        hr = SetMultiSZPropVal(wszPath, MD_APP_DEPENDENCIES, pwszAppProp, dwAppPropSz);
    }

    BAIL_ON_FAILURE(hr);

done:
    if (pwszTopOrig)
    {
        delete [] pwszTopOrig;
    }

    if (pwszAppProp)
    {
        delete [] pwszAppProp;
    }

    return hr;
}

STDMETHODIMP CSecConLib::EnableWebServiceExtension(
        /* [in]  */ LPCWSTR   wszExtension,
        /* [in]  */ LPCWSTR   wszPath)
{
    HRESULT hr = S_OK;
    
    hr = InternalInitIfNecessary();
    if (FAILED(hr))
    {
        BAIL_ON_FAILURE(hr);
    }

    hr = StatusWServEx(true, wszExtension, wszPath);
    if (FAILED(hr))
    {
        BAIL_ON_FAILURE(hr);
    }

done:

    return hr;
}

STDMETHODIMP CSecConLib::DisableWebServiceExtension(
        /* [in]  */ LPCWSTR   wszExtension,
        /* [in]  */ LPCWSTR   wszPath)
{
    HRESULT hr = S_OK;
    
    hr = InternalInitIfNecessary();
    if (FAILED(hr))
    {
        BAIL_ON_FAILURE(hr);
    }

    hr = StatusWServEx(false, wszExtension, wszPath);
    if (FAILED(hr))
    {
        BAIL_ON_FAILURE(hr);
    }

done:

    return hr;
}

STDMETHODIMP CSecConLib::ListWebServiceExtensions(
        /* [in]  */ LPCWSTR   wszPath,
        /* [out] */ WCHAR   **pszBuffer,      // MULTI_SZ - allocated in here, caller should delete
        /* [out] */ DWORD    *pdwBufferSize) // length includes double null
{
    WCHAR  *pwszRListProp  = NULL;
    DWORD   dwRListPropSz  = 0;
    WCHAR  *pList          = NULL;
    WCHAR  *pTempList      = NULL;
    DWORD   dwListLen      = 1;  // one for the extra null at the end
    DWORD   dwOldListLen   = 1;
    HRESULT hr             = S_OK;
    WCHAR  *pTop           = NULL;
    WCHAR  *pMidBuf        = NULL;
    bool    bFound         = false;
    bool    bSpecial       = false;

    hr = InternalInitIfNecessary();
    if (FAILED(hr))
    {
        BAIL_ON_FAILURE(hr);
    }

    // get the current property value for applicationdep list
    hr = GetMultiSZPropVal(wszPath, MD_WEB_SVC_EXT_RESTRICTION_LIST, &pwszRListProp, &dwRListPropSz);

    BAIL_ON_FAILURE(hr);

    if (NULL == pwszRListProp)
    {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pTop = pwszRListProp;

    // iterate through the files
    while (pwszRListProp[0])
    {
        // get to the group ID
        for (int i=0; i<3; i++)
        {
            pMidBuf = wcschr(pwszRListProp, COMMA_CHAR);
            if (!pMidBuf)
            {
                // don't fail.  just treat this as a special case and break out
                bSpecial = true;
                pMidBuf = pwszRListProp;
                break;
            }

            // null the comma and go past it
            *pMidBuf = 0;
            *pMidBuf++;
            pwszRListProp = pMidBuf;
        }

        if (COMMA_CHAR == pMidBuf[0])
        {
            bSpecial = true;
            pMidBuf = pwszRListProp;
        }

        if (!bSpecial)
        {
            // now we're looking at the group ID
            pMidBuf = wcschr(pwszRListProp, COMMA_CHAR);
            
            // if we can't find the comma, just treat the whole thing as a GroupID
            // otherwise, the GroupID ends at the comma
            if (pMidBuf)
            {
                // null the comma and go past it
                *pMidBuf = 0;
                *pMidBuf++;
            }

            // check to see if the entry is in the list already
            WCHAR *pCheck = pList;
            while (pCheck && *pCheck)
            {
                if (!_wcsicmp(pCheck, pwszRListProp))
                {
                    bFound = true;
                    pCheck = NULL;
                }
                else
                {
                    pCheck += (DWORD)wcslen(pCheck) + 1; 
                }
            }

            if (!bFound)
            {
                // allocate the memory
                dwListLen += (DWORD)wcslen(pwszRListProp) + 1;  // for the null
                pTempList = new WCHAR[dwListLen];
        
                if (!pTempList)
                {
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                }

                if (pList)
                {
                    // copy the previous list
                    memcpy(pTempList, pList, dwOldListLen * sizeof(WCHAR));
                    delete [] pList;    
                }

                // copy on the file name
                wcscpy(&pTempList[dwOldListLen - 1], pwszRListProp);
                pTempList[dwListLen-1] = 0;
                pTempList[dwListLen-2] = 0;

                pList = pTempList;
                dwOldListLen = dwListLen;
            }
        }

        // now go to the next application
        pwszRListProp = pMidBuf + (DWORD)wcslen(pMidBuf) + 1;
        bFound = false;
        bSpecial = false;
    }

    if (!pList)
    {
        // make it a valid empty multisz
        dwListLen = 2;
        pList = new WCHAR[dwListLen];
        if (!pList)
        {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        wmemset(pList, 0, dwListLen);
    }

    *pszBuffer     = pList;
    *pdwBufferSize = dwListLen;

done:
    if (pTop)
    {
        delete [] pTop;
    }

    return hr;
}

STDMETHODIMP CSecConLib::EnableExtensionFile(
        /* [in]  */ LPCWSTR   wszExFile,
        /* [in]  */ LPCWSTR   wszPath)
{
    HRESULT hr = S_OK;
    
    hr = InternalInitIfNecessary();
    if (FAILED(hr))
    {
        BAIL_ON_FAILURE(hr);
    }

    hr = StatusExtensionFile(true, wszExFile, wszPath);
    if (FAILED(hr))
    {
        BAIL_ON_FAILURE(hr);
    }

done:

    return hr;
}

STDMETHODIMP CSecConLib::DisableExtensionFile(
        /* [in]  */ LPCWSTR   wszExFile,
        /* [in]  */ LPCWSTR   wszPath)
{
    HRESULT hr = S_OK;
    
    hr = InternalInitIfNecessary();
    if (FAILED(hr))
    {
        BAIL_ON_FAILURE(hr);
    }

    hr = StatusExtensionFile(false, wszExFile, wszPath);
    if (FAILED(hr))
    {
        BAIL_ON_FAILURE(hr);
    }

done:

    return hr;
}

HRESULT CSecConLib::StatusWServEx(
        /* [in]  */ bool      bEnable,
        /* [in]  */ LPCWSTR   wszWServEx,
        /* [in]  */ LPCWSTR   wszPath)
{
    WCHAR  *pwszRListProp  = NULL;
    WCHAR  *pTop           = NULL;
    DWORD   dwRListPropSz  = 0;
    HRESULT hr             = S_OK;
    DWORD   dwWServExSz       = 0;
    bool    bFound         = false;

    // compute arg length
    dwWServExSz = (DWORD)wcslen(wszWServEx);
    
    // get the current property value for restriction list
    hr = GetMultiSZPropVal(wszPath, MD_WEB_SVC_EXT_RESTRICTION_LIST, &pwszRListProp, &dwRListPropSz);

    BAIL_ON_FAILURE(hr);

    if (NULL == pwszRListProp)
    {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pTop = pwszRListProp;

    // look at the files one by one
    while (pwszRListProp[0])
    {
        DWORD dwTokSz = (DWORD)wcslen(pwszRListProp) + 1;
        WCHAR *pFileTemp = new WCHAR[dwTokSz];
        WCHAR *pToken;

        if (!pFileTemp)
        {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        
        // check to see if we're at the right group
        wcscpy(pFileTemp, pwszRListProp);

        pToken = wcstok( pFileTemp, COMMA_STRING );

        // look at the group ID
        for (int i=0; i<3; i++)
        {
            if (pToken)
            {
                pToken = wcstok( NULL, COMMA_STRING );
            }
        }

        if (pToken && (!wcscmp(pToken, wszWServEx)))
        {
            bFound = true;
            if (bEnable)
            {
                pwszRListProp[0] = ONE_CHAR;
            }
            else
            {
                pwszRListProp[0] = ZERO_CHAR;
            }
        }
        pwszRListProp += dwTokSz;  // go to the next part of the multisz

        if (pFileTemp)
        {
            delete [] pFileTemp;
        }
    }

    if (!bFound)
    {
        BAIL_ON_FAILURE(hr = MD_ERROR_DATA_NOT_FOUND);    
    }

    // set the new property value for property
    hr = SetMultiSZPropVal(wszPath, MD_WEB_SVC_EXT_RESTRICTION_LIST, pTop, dwRListPropSz);

    BAIL_ON_FAILURE(hr);

done:

    if (pTop)
    {
        delete [] pTop;
    }

    return hr;
}

HRESULT CSecConLib::StatusExtensionFile(
        /* [in]  */ bool      bEnable,
        /* [in]  */ LPCWSTR   wszExFile,
        /* [in]  */ LPCWSTR   wszPath)
{
    WCHAR  *pwszRListProp  = NULL;
    WCHAR  *pTop           = NULL;
    DWORD   dwRListPropSz  = 0;
    HRESULT hr             = S_OK;
    DWORD   dwFileNameSz   = 0;
    bool    bFound         = false;

    // compute arg length
    dwFileNameSz = (DWORD)wcslen(wszExFile);
    
    // get the current property value for restriction list
    hr = GetMultiSZPropVal(wszPath, MD_WEB_SVC_EXT_RESTRICTION_LIST, &pwszRListProp, &dwRListPropSz);

    BAIL_ON_FAILURE(hr);

    if (NULL == pwszRListProp)
    {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pTop = pwszRListProp;

    // look at the files one by one
    while (pwszRListProp[0])
    {
        DWORD dwTokSz = (DWORD)wcslen(pwszRListProp) + 1;

        // check to see if we're at the right file
        // look past the bool(1) + comma(sizof_comma_char)
        DWORD dwTemp = (DWORD)sizeof(COMMA_CHAR) / (DWORD)sizeof(WCHAR);

        if ((!_wcsnicmp(wszExFile, &pwszRListProp[1 + dwTemp], dwFileNameSz)) &&
            ((pwszRListProp[dwFileNameSz + dwTemp + 1] == COMMA_CHAR) ||
             (pwszRListProp[dwFileNameSz + dwTemp + 1] == NULL)
            )
           )
        {
            bFound = true;
            if (bEnable)
            {
                pwszRListProp[0] = ONE_CHAR;
            }
            else
            {
                pwszRListProp[0] = ZERO_CHAR;
            }
        }
        pwszRListProp += dwTokSz;  // go to the next part of the multisz
    }

    if (!bFound)
    {
        BAIL_ON_FAILURE(hr = MD_ERROR_DATA_NOT_FOUND);    
    }

    // set the new property value for property
    hr = SetMultiSZPropVal(wszPath, MD_WEB_SVC_EXT_RESTRICTION_LIST, pTop, dwRListPropSz);

    BAIL_ON_FAILURE(hr);

done:

    if (pTop)
    {
        delete [] pTop;
    }

    return hr;
}

STDMETHODIMP CSecConLib::AddExtensionFile(
        /* [in]  */ LPCWSTR   bstrExtensionFile,
        /* [in]  */ bool      bAccess,
        /* [in]  */ LPCWSTR   bstrGroupID,
        /* [in]  */ bool      bCanDelete,
        /* [in]  */ LPCWSTR   bstrDescription,
        /* [in]  */ LPCWSTR   wszPath)
{
    HRESULT hr            = S_OK;
    WCHAR  *pwszRListProp = NULL;
    WCHAR  *pwszOrig      = NULL;
    WCHAR  *pwszTopOrig   = NULL;
    DWORD   dwRListPropSz = 0;
    DWORD   dwFileNameSz  = 0;
    DWORD   dwGroupIDSz   = 0;
    DWORD   dwDescSz      = 0;

    // compute arg length
    dwFileNameSz = (DWORD)wcslen(bstrExtensionFile);
    dwGroupIDSz  = (DWORD)wcslen(bstrGroupID);
    dwDescSz     = (DWORD)wcslen(bstrDescription);

    hr = InternalInitIfNecessary();
    if (FAILED(hr))
    {
        BAIL_ON_FAILURE(hr);
    }

    // get the current property value for restriction list
    hr = GetMultiSZPropVal(wszPath, MD_WEB_SVC_EXT_RESTRICTION_LIST, &pwszRListProp, &dwRListPropSz);

    if (MD_ERROR_DATA_NOT_FOUND == hr)
    {
        // this is okay, we just need to create the property.
        hr = S_OK;
        dwRListPropSz = 0;
    }

    BAIL_ON_FAILURE(hr);

    if (!dwRListPropSz)
    {
        // create the property        

        // size of the property = 1(0 or 1) + 1(comma) + len(file) + 1(comma) + 1(0 or 1) +
        //                        1(comma) + len(GID) + 1(comma) + len(descr) + 2(double null MULTISZ)
        dwRListPropSz = 1 + (DWORD)wcslen(COMMA_STRING) + dwFileNameSz + (DWORD)wcslen(COMMA_STRING) + 
                        1 + (DWORD)wcslen(COMMA_STRING) + dwGroupIDSz + (DWORD)wcslen(COMMA_STRING) + dwDescSz + 2;

        // No Leak
        // pwszRListProp never got alloced since we didn't get any value back,
        // so no need to delete first...

        pwszRListProp = new WCHAR[dwRListPropSz];
        if (!pwszRListProp)
        {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        if (bAccess)
        {
            wcscpy(pwszRListProp, ONE_STRING);
        }
        else
        {
            wcscpy(pwszRListProp, ZERO_STRING);
        }
        wcscat(pwszRListProp, COMMA_STRING);
        wcscat(pwszRListProp, bstrExtensionFile);
        wcscat(pwszRListProp, COMMA_STRING);
        if (bCanDelete)
        {
            wcscat(pwszRListProp, ONE_STRING);
        }
        else
        {
            wcscat(pwszRListProp, ZERO_STRING);
        }
        wcscat(pwszRListProp, COMMA_STRING);
        wcscat(pwszRListProp, bstrGroupID);
        wcscat(pwszRListProp, COMMA_STRING);
        wcscat(pwszRListProp, bstrDescription);

        // add the double null
        pwszRListProp[dwRListPropSz-1] = 0;
        pwszRListProp[dwRListPropSz-2] = 0;
    }
    
    else
    {
        // property already exists   

        // copy the property
        pwszOrig = new WCHAR[dwRListPropSz];
        pwszTopOrig = pwszOrig;

        if (!pwszOrig)
        {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        memcpy(pwszOrig, pwszRListProp, dwRListPropSz * sizeof(WCHAR));

        // resize the new property to the biggest possible
        if (pwszRListProp)
        {
            delete [] pwszRListProp;
        }

        // max new size is old size + new stuff
        // new stuff = 1(0 or 1) + 1(comma) + len(file) + 1(comma) + 1(0 or 1) +
        //             1(comma) + len(GID) + 1(comma) + len(descr) + 1(null)
        dwRListPropSz = dwRListPropSz +
                        1 + (DWORD)wcslen(COMMA_STRING) + dwFileNameSz + (DWORD)wcslen(COMMA_STRING) + 
                        1 + (DWORD)wcslen(COMMA_STRING) + dwGroupIDSz + (DWORD)wcslen(COMMA_STRING) + dwDescSz + 1;

        pwszRListProp = new WCHAR[dwRListPropSz];
        if (!pwszRListProp)
        {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        WCHAR* pMidBuf = pwszRListProp;

        // copy the old list entries one by one
        while (pwszOrig[0])
        {
            wcscpy(pMidBuf, pwszOrig);
            
            // skip over the #,
            pMidBuf += 1 + (DWORD)wcslen(COMMA_STRING);

            // check to see if the app already exists
            if ((!_wcsnicmp(bstrExtensionFile, pMidBuf, dwFileNameSz)) &&
                ((pMidBuf[dwFileNameSz] == COMMA_CHAR) ||
                 (pMidBuf[dwFileNameSz] == NULL)
                )
               )
            {
                BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(ERROR_DUP_NAME));
            }

            pwszOrig += (DWORD)wcslen(pwszOrig) + 1; // go to the next part of the multisz
            pMidBuf  += (DWORD)wcslen(pMidBuf)  + 1; // go past the null
        }

        // now copy the new file entry on

        if (bAccess)
        {
            wcscpy(pMidBuf, ONE_STRING);
        }
        else
        {
            wcscpy(pMidBuf, ZERO_STRING);
        }
        wcscat(pMidBuf, COMMA_STRING);
        wcscat(pMidBuf, bstrExtensionFile);
        wcscat(pMidBuf, COMMA_STRING);
        if (bCanDelete)
        {
            wcscat(pMidBuf, ONE_STRING);
        }
        else
        {
            wcscat(pMidBuf, ZERO_STRING);
        }
        wcscat(pMidBuf, COMMA_STRING);
        wcscat(pMidBuf, bstrGroupID);
        wcscat(pMidBuf, COMMA_STRING);
        wcscat(pMidBuf, bstrDescription);

        // add the last null
        pMidBuf += (DWORD)wcslen(pMidBuf) + 1;
        *pMidBuf = 0;
    }

    // set the new property value for property
    hr = SetMultiSZPropVal(wszPath, MD_WEB_SVC_EXT_RESTRICTION_LIST, pwszRListProp, dwRListPropSz);

    BAIL_ON_FAILURE(hr);

done:
    if (pwszTopOrig)
    {
        delete [] pwszTopOrig;
    }

    if (pwszRListProp)
    {
        delete [] pwszRListProp;
    }

    return hr;
}

STDMETHODIMP CSecConLib::DeleteExtensionFileRecord(
        /* [in]  */ LPCWSTR   wszExFile,
        /* [in]  */ LPCWSTR   wszPath)
{
    HRESULT hr             = S_OK;
    WCHAR  *pwszRListProp  = NULL;
    WCHAR  *pwszOrig       = NULL;
    WCHAR  *pTopOrig       = NULL;
    DWORD   dwRListPropSz  = 0;
    DWORD   dwFileNameSz   = 0;
    bool    bFound         = false;

    // compute arg length
    dwFileNameSz = (DWORD)wcslen(wszExFile);

    hr = InternalInitIfNecessary();
    if (FAILED(hr))
    {
        BAIL_ON_FAILURE(hr);
    }

    // get the current property value for applicationdep list
    hr = GetMultiSZPropVal(wszPath, MD_WEB_SVC_EXT_RESTRICTION_LIST, &pwszRListProp, &dwRListPropSz);

    BAIL_ON_FAILURE(hr);

    // remove the application

    // copy the property
    pwszOrig = new WCHAR[dwRListPropSz];
    pTopOrig = pwszOrig;

    if (!pwszOrig)
    {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    memcpy(pwszOrig, pwszRListProp, dwRListPropSz * sizeof(WCHAR));

    dwRListPropSz = 1;  //reset size to contain one for the last null
    WCHAR* pMidBuf = pwszRListProp;

    // copy the old apps one by one
    while (pwszOrig[0])
    {
        DWORD dwTokSz = (DWORD)wcslen(pwszOrig) + 1;

        // check to see if we're at the right file
        // look past the bool(1) + comma(sizof_comma_char)
        DWORD dwTemp = (DWORD)sizeof(COMMA_CHAR) / (DWORD)sizeof(WCHAR);
        if (!_wcsnicmp(wszExFile, &pwszOrig[1 + dwTemp], dwFileNameSz) &&
            pwszOrig[dwFileNameSz + dwTemp + 1] == COMMA_CHAR)
        {
            bFound = true;

            // we don't want to do this... spec change in progress
            // check if this is deletable or not - if not, bail with an error
            //if (pwszOrig[dwFileNameSz + 1 + (2 * dwTemp)] == ZERO_CHAR)
            //{
            //    BAIL_ON_FAILURE(hr = E_FAIL);
            //}
        }
        else
        {
            // copy it in
            wcscpy(pMidBuf, pwszOrig);
            pMidBuf += dwTokSz;  // advance past null
            *pMidBuf = 0;  // add the last null
            dwRListPropSz += dwTokSz;
        }
        pwszOrig += dwTokSz;  // go to the next part of the multisz
    }

    if (!bFound)
    {
        BAIL_ON_FAILURE(hr = MD_ERROR_DATA_NOT_FOUND);    
    }

    // set the new property value for property
    if (dwRListPropSz < 3)
    {
        // handle deleting the last one
        hr = SetMultiSZPropVal(wszPath, MD_WEB_SVC_EXT_RESTRICTION_LIST, NULL, 0);
    }
    else
    {
        hr = SetMultiSZPropVal(wszPath, MD_WEB_SVC_EXT_RESTRICTION_LIST, pwszRListProp, dwRListPropSz);
    }

    BAIL_ON_FAILURE(hr);

done:
    if (pTopOrig)
    {
        delete [] pTopOrig;
    }

    if (pwszRListProp)
    {
        delete [] pwszRListProp;
    }

    return hr;
}

STDMETHODIMP CSecConLib::ListExtensionFiles(
        /* [in]  */ LPCWSTR   wszPath,
        /* [out] */ WCHAR   **pszBuffer,      // MULTI_SZ - allocated in here, caller should delete
        /* [out] */ DWORD    *pdwBufferSize)  // length includes double null
{
    WCHAR  *pwszRListProp  = NULL;
    DWORD   dwRListPropSz  = 0;
    WCHAR  *pList          = NULL;
    WCHAR  *pTempList      = NULL;
    DWORD   dwListLen      = 1;  // one for the extra null at the end
    DWORD   dwOldListLen   = 1;
    HRESULT hr             = S_OK;
    WCHAR  *pTop           = NULL;

    hr = InternalInitIfNecessary();
    if (FAILED(hr))
    {
        BAIL_ON_FAILURE(hr);
    }

    // get the current property value for applicationdep list
    hr = GetMultiSZPropVal(wszPath, MD_WEB_SVC_EXT_RESTRICTION_LIST, &pwszRListProp, &dwRListPropSz);

    BAIL_ON_FAILURE(hr);

    if (NULL == pwszRListProp)
    {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pTop = pwszRListProp;

    // iterate through the files
    while (pwszRListProp[0])
    {
        pwszRListProp += 1 + ((DWORD)sizeof(COMMA_CHAR)/(DWORD)sizeof(WCHAR));

        WCHAR* pMidBuf = wcschr(pwszRListProp, COMMA_CHAR);
        if (pMidBuf)
        {
            // null the comma and go past it
            *pMidBuf = 0;
            *pMidBuf++;

            // allocate the memory
            dwListLen += (DWORD)wcslen(pwszRListProp) + 1;  // for the null
            pTempList = new WCHAR[dwListLen];
            
            if (!pTempList)
            {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
    
            if (pList)
            {
                // copy the previous list
                memcpy(pTempList, pList, dwOldListLen * sizeof(WCHAR));
                delete [] pList;    
            }
    
            // copy on the file name
            wcscpy(&pTempList[dwOldListLen - 1], pwszRListProp);
            pTempList[dwListLen-1] = 0;
            pTempList[dwListLen-2] = 0;
    
            pList = pTempList;
            dwOldListLen = dwListLen;
        }
        else
        {
            pMidBuf = pwszRListProp + (DWORD)wcslen(pwszRListProp) + 1;
        }
        // now go to the next application
        pwszRListProp = pMidBuf + (DWORD)wcslen(pMidBuf) + 1;
    }

    if (!pList)
    {
        // make it a valid empty multisz
        dwListLen = 2;
        pList = new WCHAR[dwListLen];
        if (!pList)
        {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        wmemset(pList, 0, dwListLen);
    }

    *pszBuffer     = pList;
    *pdwBufferSize = dwListLen;

done:
    if (pTop)
    {
        delete [] pTop;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\secconlib\debug.h ===
/*
 * Some simple debugging macros that look and behave a lot like their
 * namesakes in MFC.  These macros should work in both C and C++ and
 * do something useful with almost any Win32 compiler.
 *
 * George V. Reilly  <georger@microcrafts.com>  <a-georgr@microsoft.com>
 */

#ifndef __DEBUG_H__
#define __DEBUG_H__

#if DBG
#include <crtdbg.h>
#include <windows.h>
# define SC_TRACE                   Trace
# define SC_TRACE0(psz)             Trace(L"%s", psz)
# define SC_TRACE1(psz, p1)         Trace(psz, p1)
# define SC_TRACE2(psz, p1, p2)     Trace(psz, p1, p2)
# define SC_TRACE3(psz, p1, p2, p3) Trace(psz, p1, p2, p3)
# define SC_ASSERT(bCond)           if(bCond == false) Assert(__FILE__, __LINE__, #bCond)
#else /* !DBG */
  /* These macros should all compile away to nothing */
# define SC_TRACE
# define SC_TRACE0(psz)
# define SC_TRACE1(psz, p1)
# define SC_TRACE2(psz, p1, p2)
# define SC_TRACE3(psz, p1, p2, p3)
# define SC_ASSERT(bCond)
#endif /* !DBG*/

#if DBG

/* in debug version, writes trace messages to debug stream */
void __cdecl
Trace(
    LPCWSTR pszFormat,
    ...);

void __cdecl
Assert(
    LPCSTR pszFile,
    DWORD  dwLine,
    LPCSTR pszCond);

#endif /* DBG */

#endif /* __DEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\secconlib\unicode.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// unicode.h
//
// Header file that forcibly turns on a unicode compile
//

#ifndef UNICODE
#define UNICODE
#endif

#ifndef _UNICODE
#define _UNICODE
#endif

#undef MBCS
#undef _MBCS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\secconlib\safecs.cpp ===
#include <unicode.h>
#include <windows.h>
#include "SafeCS.h"


//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        SafeCS.cpp
//
// Contents:    CSafeAutoCriticalSection implementation
//              CSafeLock implementation
//
//------------------------------------------------------------------------

//+--------------------------------------------------------------------------
//
//  Class:      CSafeAutoCriticalSection
//
//  Purpose:    Wrapper for initializing critical-sections.
//
//  Interface:  Lock			- locks the critical section
//				Unlock			- unlocks the critical section
//				Constructor		- initializes the critical section
//				Detructor		- uninitializes the critical section 
//
//  Notes:		This provides a convenient way to ensure that you're
//              you wrap InitializeCriticalSection and 
//              UnInitializeCriticalSection in try catches which is useful 
//              in low-mem conditions
//
//---------------------------------------------------------------------------

//+-------------------------------------------------------------------------- 
// Default constructor - Initializes the critical section and sets the state 
// flag to initialized
//+-------------------------------------------------------------------------- 

CSafeAutoCriticalSection::CSafeAutoCriticalSection()
{
    m_lState = STATE_UNINITIALIZED;
	m_dwError = ERROR_SUCCESS;

    __try
    {
	    LONG  lPreviousState;

        // try to set state flag
        lPreviousState = InterlockedCompareExchange(&m_lState,
                                                    STATE_INITIALIZED,
                                                    STATE_UNINITIALIZED);

        // if this critical section was not initialized
        if(STATE_UNINITIALIZED == lPreviousState)
        {
			//
			// Note we can call InitializeCriticalSectionAndSpinCount here
			// and thereby eliminate the need for a try catch in 
			// EnterCriticalSection. But the docs say that 
			// InitializeCriticalSectionAndSpinCount is valid on NT4.0 SP3
			// onwards and we need to run on plain NT4.0 - hence we call
			// InitializeCriticalSection
			//

			InitializeCriticalSection(&m_cs);
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        m_dwError = _exception_code();
    }

    // failed to initialize - need to reset
    if(ERROR_SUCCESS != m_dwError)
    {
        m_lState = STATE_UNINITIALIZED;
    }

}

//+-------------------------------------------------------------------------- 
// Destructor
//+-------------------------------------------------------------------------- 

CSafeAutoCriticalSection::~CSafeAutoCriticalSection()
{
    LONG                lPreviousState;

    // try to reset the the state to uninitialized
    lPreviousState = InterlockedCompareExchange(&m_lState,
                                                STATE_UNINITIALIZED,
                                                STATE_INITIALIZED);

    // if the object was initialized delete the critical section
    if(STATE_INITIALIZED == lPreviousState)
    {
        DeleteCriticalSection(&m_cs);
    }
}

//+-------------------------------------------------------------------------- 
// Enters critical section, if needed initializes critical section
// before entering
//
// Returns 
//	DWORD -	ERROR_SUCCESS if everything is fine
//			ERROR_OUTOFMEMORY if failed to create or enter critical section
//+-------------------------------------------------------------------------- 

DWORD CSafeAutoCriticalSection::Lock()
{
    DWORD dwError = ERROR_SUCCESS;

    if(!IsInitialized())
    {
        return m_dwError;
    }

    __try
    {
        EnterCriticalSection(&m_cs);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
	    dwError = _exception_code();
    }

    return dwError;
}

//+-------------------------------------------------------------------------- 
// Leaves critical section
//+-------------------------------------------------------------------------- 
DWORD CSafeAutoCriticalSection::Unlock()
{
    if(!IsInitialized())
    {
        return m_dwError;
    }

    LeaveCriticalSection(&m_cs);

    return ERROR_SUCCESS;

}

//+--------------------------------------------------------------------------
//
//  Class:      CSafeLock
//
//  Purpose:    Auto-unlocking critical-section services
//
//  Interface:  Lock			- locks the critical section
//				Unlock			- unlocks the critical section
//				Constructor		- locks the critical section (unless told 
//								  otherwise)
//				Detructor		- unlocks the critical section if its locked
//
//  Notes:		This provides a convenient way to ensure that you're
//              unlocking a CSemExclusive, which is useful if your routine
//              can be left via several returns and/or via exceptions....
//
//---------------------------------------------------------------------------

CSafeLock::CSafeLock(CSafeAutoCriticalSection* val) : 
m_pSem(val),
m_locked(FALSE)
{
}

CSafeLock::CSafeLock(CSafeAutoCriticalSection& val) : 
m_pSem(&val),
m_locked(FALSE)
{
}

CSafeLock::~CSafeLock() 
{	
	if (m_locked) 
	{
		m_pSem->Unlock(); 
	}
}

DWORD CSafeLock::Lock() 
{
	DWORD dwError = ERROR_SUCCESS;

	if(!m_locked) 
	{ 
		dwError = m_pSem->Lock(); 

		if(ERROR_SUCCESS == dwError)
		{
			m_locked = TRUE; 
		}
	}

	return dwError;
}


DWORD CSafeLock::Unlock() 
{
	DWORD dwError = ERROR_SUCCESS;

	if(m_locked) 
	{ 
		dwError = m_pSem->Unlock(); 
		m_locked = FALSE; 
	}

	return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\sitecreator\debug.h ===
/*
 * Some simple debugging macros that look and behave a lot like their
 * namesakes in MFC.  These macros should work in both C and C++ and
 * do something useful with almost any Win32 compiler.
 *
 * George V. Reilly  <georger@microcrafts.com>  <a-georgr@microsoft.com>
 */

#ifndef __DEBUG_H__
#define __DEBUG_H__

#if DBG
#include <crtdbg.h>
#include <windows.h>
# define SC_TRACE                   Trace
# define SC_TRACE0(psz)             Trace(L"%s", psz)
# define SC_TRACE1(psz, p1)         Trace(psz, p1)
# define SC_TRACE2(psz, p1, p2)     Trace(psz, p1, p2)
# define SC_TRACE3(psz, p1, p2, p3) Trace(psz, p1, p2, p3)
# define SC_ASSERT(bCond)           if(bCond == false) Assert(__FILE__, __LINE__, #bCond)
#else /* !DBG */
  /* These macros should all compile away to nothing */
# define SC_TRACE
# define SC_TRACE0(psz)
# define SC_TRACE1(psz, p1)
# define SC_TRACE2(psz, p1, p2)
# define SC_TRACE3(psz, p1, p2, p3)
# define SC_ASSERT(bCond)
#endif /* !DBG*/

#if DBG

/* in debug version, writes trace messages to debug stream */
void __cdecl
Trace(
    LPCWSTR pszFormat,
    ...);

void __cdecl
Assert(
    LPCSTR pszFile,
    DWORD  dwLine,
    LPCSTR pszCond);

#endif /* DBG */

#endif /* __DEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\sitecreator\safecs.cpp ===
#include <unicode.h>
#include <windows.h>
#include "SafeCS.h"


//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        SafeCS.cpp
//
// Contents:    CSafeAutoCriticalSection implementation
//              CSafeLock implementation
//
//------------------------------------------------------------------------

//+--------------------------------------------------------------------------
//
//  Class:      CSafeAutoCriticalSection
//
//  Purpose:    Wrapper for initializing critical-sections.
//
//  Interface:  Lock			- locks the critical section
//				Unlock			- unlocks the critical section
//				Constructor		- initializes the critical section
//				Detructor		- uninitializes the critical section 
//
//  Notes:		This provides a convenient way to ensure that you're
//              you wrap InitializeCriticalSection and 
//              UnInitializeCriticalSection in try catches which is useful 
//              in low-mem conditions
//
//---------------------------------------------------------------------------

//+-------------------------------------------------------------------------- 
// Default constructor - Initializes the critical section and sets the state 
// flag to initialized
//+-------------------------------------------------------------------------- 

CSafeAutoCriticalSection::CSafeAutoCriticalSection()
{
    m_lState = STATE_UNINITIALIZED;
	m_dwError = ERROR_SUCCESS;

    __try
    {
	    LONG  lPreviousState;

        // try to set state flag
        lPreviousState = InterlockedCompareExchange(&m_lState,
                                                    STATE_INITIALIZED,
                                                    STATE_UNINITIALIZED);

        // if this critical section was not initialized
        if(STATE_UNINITIALIZED == lPreviousState)
        {
			//
			// Note we can call InitializeCriticalSectionAndSpinCount here
			// and thereby eliminate the need for a try catch in 
			// EnterCriticalSection. But the docs say that 
			// InitializeCriticalSectionAndSpinCount is valid on NT4.0 SP3
			// onwards and we need to run on plain NT4.0 - hence we call
			// InitializeCriticalSection
			//

			InitializeCriticalSection(&m_cs);
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        m_dwError = _exception_code();
    }

    // failed to initialize - need to reset
    if(ERROR_SUCCESS != m_dwError)
    {
        m_lState = STATE_UNINITIALIZED;
    }

}

//+-------------------------------------------------------------------------- 
// Destructor
//+-------------------------------------------------------------------------- 

CSafeAutoCriticalSection::~CSafeAutoCriticalSection()
{
    LONG                lPreviousState;

    // try to reset the the state to uninitialized
    lPreviousState = InterlockedCompareExchange(&m_lState,
                                                STATE_UNINITIALIZED,
                                                STATE_INITIALIZED);

    // if the object was initialized delete the critical section
    if(STATE_INITIALIZED == lPreviousState)
    {
        DeleteCriticalSection(&m_cs);
    }
}

//+-------------------------------------------------------------------------- 
// Enters critical section, if needed initializes critical section
// before entering
//
// Returns 
//	DWORD -	ERROR_SUCCESS if everything is fine
//			ERROR_OUTOFMEMORY if failed to create or enter critical section
//+-------------------------------------------------------------------------- 

DWORD CSafeAutoCriticalSection::Lock()
{
    DWORD dwError = ERROR_SUCCESS;

    if(!IsInitialized())
    {
        return m_dwError;
    }

    __try
    {
        EnterCriticalSection(&m_cs);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
	    dwError = _exception_code();
    }

    return dwError;
}

//+-------------------------------------------------------------------------- 
// Leaves critical section
//+-------------------------------------------------------------------------- 
DWORD CSafeAutoCriticalSection::Unlock()
{
    if(!IsInitialized())
    {
        return m_dwError;
    }

    LeaveCriticalSection(&m_cs);

    return ERROR_SUCCESS;

}

//+--------------------------------------------------------------------------
//
//  Class:      CSafeLock
//
//  Purpose:    Auto-unlocking critical-section services
//
//  Interface:  Lock			- locks the critical section
//				Unlock			- unlocks the critical section
//				Constructor		- locks the critical section (unless told 
//								  otherwise)
//				Detructor		- unlocks the critical section if its locked
//
//  Notes:		This provides a convenient way to ensure that you're
//              unlocking a CSemExclusive, which is useful if your routine
//              can be left via several returns and/or via exceptions....
//
//---------------------------------------------------------------------------

CSafeLock::CSafeLock(CSafeAutoCriticalSection* val) : 
m_pSem(val),
m_locked(FALSE)
{
}

CSafeLock::CSafeLock(CSafeAutoCriticalSection& val) : 
m_pSem(&val),
m_locked(FALSE)
{
}

CSafeLock::~CSafeLock() 
{	
	if (m_locked) 
	{
		m_pSem->Unlock(); 
	}
}

DWORD CSafeLock::Lock() 
{
	DWORD dwError = ERROR_SUCCESS;

	if(!m_locked) 
	{ 
		dwError = m_pSem->Lock(); 

		if(ERROR_SUCCESS == dwError)
		{
			m_locked = TRUE; 
		}
	}

	return dwError;
}


DWORD CSafeLock::Unlock() 
{
	DWORD dwError = ERROR_SUCCESS;

	if(m_locked) 
	{ 
		dwError = m_pSem->Unlock(); 
		m_locked = FALSE; 
	}

	return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\sitecreator\sitecreator.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    SiteCreator.h

Abstract:

    Definition of:
        CSiteCreator

    The public methods are thread-safe.

Author:

    Mohit Srivastava            21-Mar-2001

Revision History:

--*/

#ifndef __sitecreator_h__
#define __sitecreator_h__

#if _MSC_VER > 1000
#pragma once
#endif 

#include <windows.h>
#include <atlbase.h>
#include <iadmw.h>
#include <iwamreg.h>
#include "SafeCS.h"

typedef /* [v1_enum] */ 
enum tag_SC_SUPPORTED_SERVICES
{
    SC_W3SVC    = 1,
    SC_MSFTPSVC = 2
} eSC_SUPPORTED_SERVICES;

struct TService
{
    eSC_SUPPORTED_SERVICES   eId;
    LPCWSTR                  wszMDPath;
    ULONG                    cchMDPath;
    LPCWSTR                  wszServerKeyType;
    ULONG                    cchServerKeyType;
    LPCWSTR                  wszServerVDirKeyType;
    ULONG                    cchServerVDirKeyType;
};

struct TServiceData
{
    static TService  W3Svc;
    static TService  MSFtpSvc;

    static TService* apService[];
};

//
// CSiteCreator
//
class CSiteCreator
{
public:
    CSiteCreator();

    CSiteCreator(
        IMSAdminBase* pIABase);

    virtual ~CSiteCreator();

    HRESULT STDMETHODCALLTYPE CreateNewSite(
        /* [in]  */ eSC_SUPPORTED_SERVICES  eServiceId,
        /* [in]  */ LPCWSTR                 wszServerComment,
        /* [out] */ PDWORD                  pdwSiteId,
        /* [in]  */ PDWORD                  pdwRequestedSiteId=NULL);

    HRESULT STDMETHODCALLTYPE CreateNewSite2(
        /* [in]  */ eSC_SUPPORTED_SERVICES  eServiceId,
        /* [in]  */ LPCWSTR                 wszServerComment,
        /* [in]  */ LPCWSTR                 mszServerBindings,
        /* [in]  */ LPCWSTR                 wszPathOfRootVirtualDir,
        /* [in]  */ IIISApplicationAdmin*   pIApplAdmin,
        /* [out] */ PDWORD                  pdwSiteId,
        /* [in]  */ PDWORD                  pdwRequestedSiteId=NULL);

private:
    HRESULT InternalInitIfNecessary();

    HRESULT InternalCreateNewSite(
        eSC_SUPPORTED_SERVICES    i_eServiceId,
        LPCWSTR                   i_wszServerComment,
        LPCWSTR                   i_mszServerBindings,
        LPCWSTR                   i_wszPathOfRootVirtualDir,
        IIISApplicationAdmin*     i_pIApplAdmin,
        PDWORD                    o_pdwSiteId,
        PDWORD                    i_pdwRequestedSiteId=NULL);

    HRESULT InternalSetData(
        METADATA_HANDLE  i_hMD,
        LPCWSTR          i_wszPath,
        DWORD            i_dwIdentifier,
        LPBYTE           i_pData,
        DWORD            i_dwNrBytes,
        DWORD            i_dwAttributes,
        DWORD            i_dwDataType,
        DWORD            i_dwUserType
        );

    HRESULT InternalCreateNode(
        TService*        i_pService,
        LPCWSTR          i_wszServerComment,
        PMETADATA_HANDLE o_phService,
        PDWORD           o_pdwSiteId,
        const PDWORD     i_pdwRequestedSiteId=NULL);

	HRESULT SetAdminACL(
		METADATA_HANDLE hW3Svc, 
		LPCWSTR szKeyPath);

    DWORD GetMajorVersion(METADATA_HANDLE hKey);

    CSafeAutoCriticalSection m_SafeCritSec;
    CComPtr<IMSAdminBase>    m_spIABase;
    bool                     m_bInit;
};

#endif // __sitecreator_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\sitecreator\sitecreator.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    SiteCreator.cpp

Abstract:

    Implementation of:
        CSiteCreator

    The public methods are thread-safe.

Author:

    Mohit Srivastava            21-Mar-2001

Revision History:

--*/

#include "sitecreator.h"
#include <iiscnfg.h>
#include <iiscnfgp.h> // internal 
#include <hashfn.h>
#include <limits.h>
#include <mdmsg.h>
#include "debug.h"

//
// consts
//

static const DWORD  DW_MAX_SITEID        = INT_MAX;
static const DWORD  DW_TIMEOUT           = 30000;

//
// Number of ERROR_PATH_BUSY's before we give up
//
static const DWORD  DW_NUM_TRIES         = 1;   

static LPCWSTR      WSZ_SLASH_ROOT       = L"/root/";
static LPCWSTR      WSZ_SLASH_FILTERS    = L"/filters/";
static ULONG        CCH_SLASH_ROOT       = wcslen(WSZ_SLASH_ROOT);

#define             WSZ_PATH_W3SVC       L"/LM/w3svc/"
#define             WSZ_PATH_MSFTPSVC    L"/LM/msftpsvc/"

#define             WSZ_IISWEBSERVER     L"IIsWebServer"
#define             WSZ_IISWEBVIRTUALDIR L"IIsWebVirtualDir"
#define             WSZ_IISFTPSERVER     L"IIsFtpServer"
#define             WSZ_IISFTPVIRTUALDIR L"IIsFtpVirtualDir"
#define             WSZ_IISFILTERS       L"IIsFilters"

//
// W3Svc
//
TService TServiceData::W3Svc =
{
    SC_W3SVC,
    WSZ_PATH_W3SVC,
    sizeof(WSZ_PATH_W3SVC)/sizeof(WCHAR)-1,
    WSZ_IISWEBSERVER,
    sizeof(WSZ_IISWEBSERVER)/sizeof(WCHAR)-1,
    WSZ_IISWEBVIRTUALDIR,
    sizeof(WSZ_IISWEBVIRTUALDIR)/sizeof(WCHAR)-1
};

//
// MSFtpSvc
//
TService TServiceData::MSFtpSvc =
{
    SC_MSFTPSVC,
    WSZ_PATH_MSFTPSVC,
    sizeof(WSZ_PATH_MSFTPSVC)/sizeof(WCHAR)-1,
    WSZ_IISFTPSERVER,
    sizeof(WSZ_IISFTPSERVER)/sizeof(WCHAR)-1,
    WSZ_IISFTPVIRTUALDIR,
    sizeof(WSZ_IISFTPVIRTUALDIR)/sizeof(WCHAR)-1
};

//
// Collection of supported services
//
TService* TServiceData::apService[] =
{
    &W3Svc,
    &MSFtpSvc,
    NULL
};

//
// public
//

CSiteCreator::CSiteCreator()
{
    m_bInit        = false;
}

CSiteCreator::CSiteCreator(
    IMSAdminBase* pIABase)
{
    SC_ASSERT(pIABase != NULL);

    m_spIABase = pIABase;
    m_bInit    = true;
}

CSiteCreator::~CSiteCreator()
{
}

DWORD 
CSiteCreator::GetMajorVersion(METADATA_HANDLE hKey)
{
    DWORD dwMajorVersion = 0;
    DWORD dwMDRequiredDataLen = 0;

    METADATA_RECORD mr;
    mr.dwMDIdentifier = MD_SERVER_VERSION_MAJOR;
    mr.dwMDAttributes = 0;
    mr.dwMDUserType   = IIS_MD_UT_SERVER;
    mr.dwMDDataType   = DWORD_METADATA;
    mr.dwMDDataLen    = sizeof(dwMajorVersion);
    mr.pbMDData       = reinterpret_cast<unsigned char *>(&dwMajorVersion);

    m_spIABase->GetData(hKey, L"Info", &mr, &dwMDRequiredDataLen);
    return dwMajorVersion;
}


HRESULT
CSiteCreator::CreateNewSite2(
    /* [in]  */ eSC_SUPPORTED_SERVICES  eServiceId,
    /* [in]  */ LPCWSTR                 wszServerComment,
    /* [in]  */ LPCWSTR                 mszServerBindings,
    /* [in]  */ LPCWSTR                 wszPathOfRootVirtualDir,
    /* [in]  */ IIISApplicationAdmin*   pIApplAdmin,
    /* [out] */ PDWORD                  pdwSiteId,
    /* [in]  */ PDWORD                  pdwRequestedSiteId)
{
    if( wszServerComment        == NULL ||
        mszServerBindings       == NULL ||
        wszPathOfRootVirtualDir == NULL ||
        pdwSiteId               == NULL ||
        (m_bInit && m_spIABase == NULL) ) // means you used constructor incorrectly
    {
        return E_INVALIDARG;
    }

    HRESULT hr = InternalCreateNewSite(
        eServiceId,
        wszServerComment,
        mszServerBindings,
        wszPathOfRootVirtualDir,
        pIApplAdmin,
        pdwSiteId,
        pdwRequestedSiteId);

    return hr;
}

HRESULT
CSiteCreator::CreateNewSite(
    /* [in]  */ eSC_SUPPORTED_SERVICES  eServiceId,
    /* [in]  */ LPCWSTR                 wszServerComment,
    /* [out] */ PDWORD                  pdwSiteId,
    /* [in]  */ PDWORD                  pdwRequestedSiteId)
{
    if( wszServerComment        == NULL ||
        pdwSiteId               == NULL ||
        (m_bInit && m_spIABase == NULL) ) // means you used constructor incorrectly
    {
        return E_INVALIDARG;
    }
    return InternalCreateNewSite(
        eServiceId, wszServerComment, NULL, NULL, NULL, pdwSiteId, pdwRequestedSiteId);
}

//
// private
//

HRESULT
CSiteCreator::InternalCreateNewSite(
    eSC_SUPPORTED_SERVICES    i_eServiceId,
    LPCWSTR                   i_wszServerComment,
    LPCWSTR                   i_mszServerBindings,
    LPCWSTR                   i_wszPathOfRootVirtualDir,
    IIISApplicationAdmin*     i_pIApplAdmin,
    PDWORD                    o_pdwSiteId,
    PDWORD                    i_pdwRequestedSiteId)
{
    SC_ASSERT(o_pdwSiteId);

    HRESULT         hr          = S_OK;
    METADATA_HANDLE hW3Svc      = 0;
    bool            bOpenHandle = false;
    DWORD           dwSiteId    = 0;
    WCHAR           wszSiteId[20] = {0};

    if ((i_pdwRequestedSiteId) && (0 >= (LONG)(*i_pdwRequestedSiteId)))
    {
        return(E_INVALIDARG);
    }

    //
    // Lookup the service
    //
    TService** ppService = NULL;
    for(ppService = TServiceData::apService; *ppService != NULL; ppService++)
    {
        if((*ppService)->eId == i_eServiceId)
        {
            break;
        }
    }
    if(*ppService == NULL)
    {
        return E_INVALIDARG;
    }

    hr = InternalCreateNode(
        *ppService,
        (i_wszServerComment == NULL) ? L"" : i_wszServerComment,
        &hW3Svc,
        &dwSiteId,
        i_pdwRequestedSiteId);
    if(FAILED(hr))
    {
        return hr;
    }

    //
    // We now have an open metadata handle that must be closed.
    //
    bOpenHandle = true;

    //
    // w3svc/n/KeyType="IIsWebServer"
    //
    hr = InternalSetData(
        hW3Svc,
        _ultow(dwSiteId, wszSiteId, 10),
        MD_KEY_TYPE,
        (LPBYTE)(*ppService)->wszServerKeyType,
        ((*ppService)->cchServerKeyType + 1) * sizeof(WCHAR),
        METADATA_NO_ATTRIBUTES,
        STRING_METADATA,
        IIS_MD_UT_SERVER);
    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // w3svc/n/ServerComment=i_wszServerComment
    //
    if(i_wszServerComment != NULL)
    {
        hr = InternalSetData(
            hW3Svc,
            wszSiteId,
            MD_SERVER_COMMENT,
            (LPBYTE)i_wszServerComment,
            (wcslen(i_wszServerComment) + 1) * sizeof(WCHAR),
            METADATA_INHERIT,
            STRING_METADATA,
            IIS_MD_UT_SERVER);
        if(FAILED(hr))
        {
            goto exit;
        }
    }

    //
    // w3svc/n/ServerBindings=i_mszServerBindings
    //
    if(i_mszServerBindings != NULL)
    {
        ULONG cEntriesCur = 0;
        ULONG cEntries    = 0;
        do
        {
            cEntriesCur  = wcslen(i_mszServerBindings + cEntries) + 1;
            cEntries    += cEntriesCur;
        }
        while(cEntriesCur > 1);

        if(cEntries > 1)
        {
            hr = InternalSetData(
                hW3Svc,
                wszSiteId,
                MD_SERVER_BINDINGS,
                (LPBYTE)i_mszServerBindings,
                cEntries * sizeof(WCHAR),
                METADATA_NO_ATTRIBUTES,
                MULTISZ_METADATA,
                IIS_MD_UT_SERVER);
            if(FAILED(hr))
            {
                goto exit;
            }
        }
    }

    //
    // w3svc/n/AuthAnonymous
    //
    DWORD noAccess = 0;
    hr = InternalSetData(
        hW3Svc,
        wszSiteId,
        MD_AUTHORIZATION,         // AuthFlags
        (LPBYTE)&noAccess,
        sizeof(DWORD),
        METADATA_INHERIT,
        DWORD_METADATA,
        IIS_MD_UT_FILE);
        
    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // w3svc/n/Filters
    //
    if(i_eServiceId == SC_W3SVC)
    {
        if (GetMajorVersion(hW3Svc) >= 6)
        {
            SC_ASSERT((sizeof(wszSiteId)/sizeof(WCHAR) + CCH_SLASH_ROOT + 1) <= 30);

            WCHAR wszFiltersPath[30];
            wcscpy(wszFiltersPath, wszSiteId);
            wcscat(wszFiltersPath, WSZ_SLASH_FILTERS);
            hr = m_spIABase->AddKey(
                hW3Svc,
                wszFiltersPath);
            if(FAILED(hr))
            {
                goto exit;
            }

            //
            // w3svc/n/Filters/KeyType="IIsFilters"
            //
            WCHAR * wszFiltersNode = WSZ_IISFILTERS;
            hr = InternalSetData(
                hW3Svc,
                wszFiltersPath,
                MD_KEY_TYPE,
                (LPBYTE) wszFiltersNode,
                ((wcslen(wszFiltersNode) + 1) * sizeof(WCHAR)),
                METADATA_NO_ATTRIBUTES,
                STRING_METADATA,
                IIS_MD_UT_SERVER);
            if(FAILED(hr))
            {
                goto exit;
            }


            // Must set AdminAcl on Filters for iis6
            // BUG:692660
            hr = SetAdminACL(hW3Svc,wszFiltersPath);
            if(FAILED(hr))
            {
                //Trace(L"SetAdminACL:FAILED:hr=0x%x\r\n",hr);
                // if any failure happens while trying to set the AdminACL
                // forget it... just ignore the error, this is because
                // the AdminACL on Filters node is only for the UI
                // to display the filters being loaded correctly or not.
                //
                // We don't want to not let the user create a site just because
                // of this failure...
                //goto exit;
            }
        }
    }

    //
    // Create w3svc/n/root and associated properties only if i_wszPathOfRootVirtualDir
    // was specified.
    //
    if(i_wszPathOfRootVirtualDir != NULL)
    {
        //
        // w3svc/n/root
        //
        SC_ASSERT((sizeof(wszSiteId)/sizeof(WCHAR) + CCH_SLASH_ROOT + 1) <= 30);
        WCHAR wszVdirPath[30];
        wcscpy(wszVdirPath, wszSiteId);
        wcscat(wszVdirPath, WSZ_SLASH_ROOT);
        hr = m_spIABase->AddKey(
            hW3Svc,
            wszVdirPath);
        if(FAILED(hr))
        {
            goto exit;
        }

        //
        // w3svc/n/root/KeyType="IIsWebVirtualDir"
        //
        hr = InternalSetData(
            hW3Svc,
            wszVdirPath,
            MD_KEY_TYPE,
            (LPBYTE)(*ppService)->wszServerVDirKeyType,
            ((*ppService)->cchServerVDirKeyType + 1) * sizeof(WCHAR),
            METADATA_NO_ATTRIBUTES,
            STRING_METADATA,
            IIS_MD_UT_SERVER);
        if(FAILED(hr))
        {
            goto exit;
        }

        //
        // w3svc/n/root/Path=wszPathOfRootVirtualDir
        //
        hr = InternalSetData(
            hW3Svc,
            wszVdirPath,
            MD_VR_PATH,
            (LPBYTE)i_wszPathOfRootVirtualDir,
            (wcslen(i_wszPathOfRootVirtualDir) + 1) * sizeof(WCHAR),
            METADATA_INHERIT,
            STRING_METADATA,
            IIS_MD_UT_FILE);
        if(FAILED(hr))
        {
            goto exit;
        }

        //
        // w3svc/n/root/AppRoot="/LM/w3svc/n/root/"
        //
        if(i_eServiceId == SC_W3SVC && i_pIApplAdmin != NULL)
        {
            SC_ASSERT(((*ppService)->cchMDPath + sizeof(wszVdirPath)/sizeof(WCHAR) + 1) <= 50);
            WCHAR wszAppRoot[50];
            wcscpy(wszAppRoot, (*ppService)->wszMDPath);
            wcscat(wszAppRoot, wszVdirPath);

            m_spIABase->CloseKey(hW3Svc);
            bOpenHandle = false;

            hr = i_pIApplAdmin->CreateApplication(wszAppRoot, 2, NULL, FALSE);
            if(FAILED(hr))
            {
                // DBGPRINTF((DBG_CONTEXT, "[%s] CreateAppl failed, hr=0x%x\n", __FUNCTION__, hr));
                goto exit;
            }
        }
    }

    //
    // Set out parameters if everything succeeded
    //
    *o_pdwSiteId = dwSiteId;

exit:
    if(bOpenHandle)
    {
        m_spIABase->CloseKey(hW3Svc);
        bOpenHandle = false;
    }
    return hr;
}

HRESULT 
CSiteCreator::InternalSetData(
    METADATA_HANDLE  i_hMD,
    LPCWSTR          i_wszPath,
    DWORD            i_dwIdentifier,
    LPBYTE           i_pData,
    DWORD            i_dwNrBytes,
    DWORD            i_dwAttributes,
    DWORD            i_dwDataType,
    DWORD            i_dwUserType
)
{
    HRESULT hr = S_OK;

    METADATA_RECORD mr;
    memset(&mr, 0, sizeof(METADATA_RECORD));

    mr.dwMDIdentifier = i_dwIdentifier;
    mr.pbMDData       = i_pData;
    mr.dwMDDataLen    = i_dwNrBytes;
    mr.dwMDAttributes = i_dwAttributes;
    mr.dwMDDataType   = i_dwDataType;
    mr.dwMDUserType   = i_dwUserType;

    hr = m_spIABase->SetData(
        i_hMD,
        i_wszPath,
        &mr);

    return hr;
}

HRESULT
CSiteCreator::InternalCreateNode(
    TService*        i_pService,
    LPCWSTR          i_wszServerComment,
    PMETADATA_HANDLE o_phService,
    PDWORD           o_pdwSiteId,
    const PDWORD     i_pdwRequestedSiteId)
{
    DWORD dwFalse = FALSE;
    
    METADATA_RECORD mr = {
        MD_SERVER_AUTOSTART, 
        METADATA_INHERIT,
        IIS_MD_UT_SERVER,
        DWORD_METADATA,
        sizeof(DWORD),
        (unsigned char*)&dwFalse,  // FALSE
        0
        };  

    HRESULT hr = InternalInitIfNecessary();
    if(FAILED(hr))
    {
        return hr;
    }

    SC_ASSERT(i_pService         != NULL);
    SC_ASSERT(i_wszServerComment != NULL);
    SC_ASSERT(o_phService        != NULL);
    SC_ASSERT(o_pdwSiteId        != NULL);

    *o_pdwSiteId = 0;
    *o_phService   = 0;

    DWORD           idx           = 0;  // current index of for loop
    DWORD           dwStart       = -1; // starting index
    METADATA_HANDLE hService      = 0;
    WCHAR           wszSiteId[20] = {0};

    for(ULONG i = 0; i < DW_NUM_TRIES; i++)
    {
        hr = m_spIABase->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            i_pService->wszMDPath,
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            DW_TIMEOUT,
            &hService);
        if( hr == HRESULT_FROM_WIN32(ERROR_PATH_BUSY) )
        {
            continue;
        }
        else if( FAILED(hr) )
        {
            return hr;
        }
        else
        {
            break;
        }
    }
    if(FAILED(hr))
    {
        return hr;
    }

    if(i_pdwRequestedSiteId == NULL)
    {
        dwStart = ( HashFn::HashStringNoCase(i_wszServerComment) % DW_MAX_SITEID ) + 1;
        SC_ASSERT(dwStart != 0);
        SC_ASSERT(dwStart <= DW_MAX_SITEID);

        DWORD dwNrSitesTried = 0;
        for(idx = dwStart; 
            dwNrSitesTried < DW_MAX_SITEID; 
            dwNrSitesTried++, idx = (idx % DW_MAX_SITEID) + 1)
        {
            SC_ASSERT(idx != 0);               // 0 is not a valid site id
            SC_ASSERT(idx <= DW_MAX_SITEID);
            hr = m_spIABase->AddKey(
                hService,
                _ultow(idx, wszSiteId, 10));
            if( hr == HRESULT_FROM_WIN32(ERROR_DUP_NAME) ||
                hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) )
            {
                continue;
            }
            else if(SUCCEEDED(hr))
            {
                break;
            }
            else
            {
                goto exit;
            }
        }
        if(FAILED(hr))
        {
            //
            // Tried everything, still failed!
            //
            goto exit;
        }
    }
    else
    {
        idx = *i_pdwRequestedSiteId;
        hr  = m_spIABase->AddKey(
            hService, 
            _ultow(idx, wszSiteId, 10));
        if(FAILED(hr))
        {
            goto exit;
        }
    }

    // Set ServerAutoStart = FALSE
    hr = m_spIABase->SetData(
        hService,
        _ultow(idx, wszSiteId, 10),
        &mr );
    if(FAILED(hr))
    {
        goto exit;
    }
    
    //
    // Set out parameters if everything succeeded
    //
    *o_pdwSiteId   = idx;
    *o_phService   = hService;

exit:
    if(FAILED(hr))
    {
        m_spIABase->CloseKey(
            hService);
    }
    return hr;
}

HRESULT
CSiteCreator::InternalInitIfNecessary()
{
    HRESULT   hr = S_OK;
    CSafeLock csSafe(m_SafeCritSec);

    if(m_bInit)
    {
        return hr;
    }

    hr = csSafe.Lock();
    hr = HRESULT_FROM_WIN32(hr);
    if(FAILED(hr))
    {
        return hr;
    }

    if(!m_bInit)
    {
        hr = CoCreateInstance(
            CLSID_MSAdminBase,
            NULL,
            CLSCTX_ALL,
            IID_IMSAdminBase,
            (void**)&m_spIABase);
        if(FAILED(hr))
        {
            m_bInit = false;
        }
        else
        {
            m_bInit = true;
        }
    }

    csSafe.Unlock();

    return hr;
}

HRESULT
CSiteCreator::SetAdminACL(METADATA_HANDLE hW3Svc, LPCWSTR szKeyPath)
{
    HRESULT hr = S_OK;
    METADATA_RECORD mr;
    LPBYTE pBuffer = NULL;
    DWORD dwBufferSize = 0;
    DWORD dwMDRequiredDataLen = 0;

    mr.dwMDIdentifier = MD_ADMIN_ACL;
    mr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    mr.dwMDUserType   = ALL_METADATA;
    mr.dwMDDataType   = BINARY_METADATA;
    mr.dwMDDataLen    = dwBufferSize;
    mr.pbMDData       = reinterpret_cast<unsigned char *>(pBuffer);

    hr = m_spIABase->GetData(
             hW3Svc,
             L"filters/",
             &mr,
             &dwBufferSize
             );
    if (FAILED(hr) && (hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)))
    {
        if (hr == MD_WARNING_PATH_NOT_FOUND || hr == MD_ERROR_DATA_NOT_FOUND)
        {
            // the filters node might not have an AdminAcl, if it doesn't
            // just return s_ok
            hr = S_OK;
        }
        goto SetAdminACL_Exit;
    }

    pBuffer = (LPBYTE) LocalAlloc(LPTR,dwBufferSize);
    if (!pBuffer) 
    {
        hr = E_OUTOFMEMORY;
        goto SetAdminACL_Exit;
    }

    mr.dwMDIdentifier = MD_ADMIN_ACL;
    mr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    mr.dwMDUserType   = ALL_METADATA;
    mr.dwMDDataType   = BINARY_METADATA;
    mr.dwMDDataLen    = dwBufferSize;
    mr.pbMDData       = reinterpret_cast<unsigned char *>(pBuffer);

    hr = m_spIABase->GetData(
             hW3Svc,
             L"filters/",
             &mr,
             &dwMDRequiredDataLen
             );
    if (FAILED(hr))
    {
        if (hr == MD_WARNING_PATH_NOT_FOUND || hr == MD_ERROR_DATA_NOT_FOUND)
        {
            // the filters node might not have an AdminAcl, if it doesn't
            // just return s_ok
            hr = S_OK;
        }
        goto SetAdminACL_Exit;
    }

    // Default error if there is a problem from here on...
    hr = E_UNEXPECTED;
    if (mr.pbMDData && (mr.dwMDDataLen > 0))
    {
        // We have a AdminACL from the /w3svc/Filters Branch
        // lets write it to the new sites /w3svc/newsiteid/filters node.
        if (IsValidSecurityDescriptor(pBuffer))
        {
            hr = InternalSetData(hW3Svc,
                            szKeyPath,
                            MD_ADMIN_ACL,
                            (LPBYTE) mr.pbMDData,
                            mr.dwMDDataLen,
                            METADATA_INHERIT | METADATA_SECURE | METADATA_REFERENCE,
                            BINARY_METADATA,
                            IIS_MD_UT_SERVER);
         }
    }
    
SetAdminACL_Exit:
    if (pBuffer)
    {
        LocalFree(pBuffer);
        pBuffer = NULL;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\sitecreator\unicode.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// unicode.h
//
// Header file that forcibly turns on a unicode compile
//

#ifndef UNICODE
#define UNICODE
#endif

#ifndef _UNICODE
#define _UNICODE
#endif

#undef MBCS
#undef _MBCS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\aclpage.cpp ===
// AclPage.cpp : Implementation of ISecurityInformation and IDataObject

#include "stdafx.h"
#include "AclPage.h"
#include "windns.h"
#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////
// class CFileSecurityDataObject

CFileSecurityDataObject::CFileSecurityDataObject()
: m_cRef(1)
{
}

CFileSecurityDataObject::~CFileSecurityDataObject()
{
  TRACE(_T("CFileSecurityDataObject::~CFileSecurityDataObject m_cRef=%d\n"), m_cRef);
}

void
CFileSecurityDataObject::Initialize(
    IN LPCTSTR lpszComputerName,
    IN LPCTSTR lpszFolder
)
{
  m_cstrComputerName = lpszComputerName;
  m_cstrFolder = lpszFolder;

  GetFullPathLocalOrRemote(lpszComputerName, lpszFolder, m_cstrPath);

  m_cfIDList = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_SHELLIDLIST);
}

////////////////////////////////
// IUnknown methods
////////////////////////////////
STDMETHODIMP
CFileSecurityDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
  if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IDataObject))
  {
    *ppv = this;
    m_cRef++;
    return S_OK;
  } else
  {
    *ppv = NULL;
    return E_NOINTERFACE;
  }
}

STDMETHODIMP_(ULONG)
CFileSecurityDataObject::AddRef()
{
  return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CFileSecurityDataObject::Release()
{
  if (--m_cRef == 0)
  {
    delete this;
    return 0;
  }

  return m_cRef;
}

STDMETHODIMP
CFileSecurityDataObject::GetData(
    FORMATETC __RPC_FAR * pFormatEtcIn,
    STGMEDIUM __RPC_FAR * pMedium
)
{
  ASSERT(pFormatEtcIn);
  ASSERT(pMedium);

  if (m_cfIDList != pFormatEtcIn->cfFormat)
    return DV_E_FORMATETC;

  LPITEMIDLIST      pidl = NULL;
  LPITEMIDLIST      pidlR = NULL;
  HRESULT           hr = GetFolderPIDList(&pidl);
  if (SUCCEEDED(hr))
  {
    pidlR = ILClone(ILFindLastID(pidl));  // relative IDList
    ILRemoveLastID(pidl);                 // folder IDList

    int  cidl = 1;
    UINT offset = sizeof(CIDA) + sizeof(UINT)*cidl;
    UINT cbFolder = ILGetSize(pidl);
    UINT cbRelative = ILGetSize(pidlR);
    UINT cbTotal = offset + cbFolder + cbRelative;

    HGLOBAL hGlobal = ::GlobalAlloc (GPTR, cbTotal);
    if ( hGlobal )
    {
      LPIDA pida = (LPIDA)hGlobal;

      pida->cidl = cidl;
      pida->aoffset[0] = offset;
      MoveMemory(((LPBYTE)hGlobal+offset), pidl, cbFolder);

      offset += cbFolder;
      pida->aoffset[1] = offset;
      MoveMemory(((LPBYTE)hGlobal+offset), pidlR, cbRelative);

      pMedium->hGlobal = hGlobal;
    } else
    {
      hr = E_OUTOFMEMORY;
    }

    if (pidl)
      ILFree(pidl);
    if (pidlR)
      ILFree(pidlR);
  }

  return hr;
}

HRESULT
CFileSecurityDataObject::GetFolderPIDList(
    OUT LPITEMIDLIST *ppidl
)
{
  ASSERT(!m_cstrPath.IsEmpty());
  ASSERT(ppidl);
  ASSERT(!*ppidl);  // prevent memory leak

  *ppidl = ILCreateFromPath(m_cstrPath);

  return ((*ppidl) ? S_OK : E_FAIL);
}

///////////////////////////////////////////////
// File security

// Security Shell extension CLSID - {1F2E5C40-9550-11CE-99D2-00AA006E086C}
const CLSID CLSID_ShellExtSecurity =
 {0x1F2E5C40, 0x9550, 0x11CE, {0x99, 0xD2, 0x0, 0xAA, 0x0, 0x6E, 0x08, 0x6C}};

BOOL CALLBACK
AddPageProc(HPROPSHEETPAGE hPage, LPARAM lParam)
{
  // pass out the created page handle
  *((HPROPSHEETPAGE *)lParam) = hPage;

  return TRUE;
}

HRESULT
CreateFileSecurityPropPage(
    HPROPSHEETPAGE *phOutPage,
    LPDATAOBJECT pDataObject
)
{
  ASSERT(phOutPage);
  ASSERT(pDataObject);

  IShellExtInit *piShellExtInit = NULL;
  HRESULT hr = CoCreateInstance(CLSID_ShellExtSecurity,
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        IID_IShellExtInit,
                        (void **)&piShellExtInit);
  if (SUCCEEDED(hr))
  {
    hr = piShellExtInit->Initialize(NULL, pDataObject, 0);
    if (SUCCEEDED(hr))
    {
      IShellPropSheetExt *piSPSE = NULL;
      hr = piShellExtInit->QueryInterface(IID_IShellPropSheetExt, (void **)&piSPSE);
      if (SUCCEEDED(hr))
      {
        hr = piSPSE->AddPages(AddPageProc, (LPARAM)phOutPage);
        piSPSE->Release();
      }
    }
    piShellExtInit->Release();
  }

  return hr;
}

INT_PTR 
PopupPermissionDialog(
    HWND hWnd,
    LPCTSTR target,
    LPCTSTR folder
    )
{
    INT_PTR iReturn = -2;
    HPROPSHEETPAGE phPages[1];
    int cPages = 1;
    CString cstrSheetTitle = folder;
    CString path;

    GetFullPathLocalOrRemote(target, folder, path);
    if (!SupportsSecurityACLs(path))
    {
        DoHelpMessageBox(hWnd,IDS_FAT_DRIVE_WARNING, MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION, 0);
        return 0;
    }

    phPages[0] = 0;
   
    HRESULT hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    if (FAILED(hr))
        {return iReturn;}

    // create "File Security" property page
    CFileSecurityDataObject *pfsDataObject = new CFileSecurityDataObject;
    if (!pfsDataObject)
    {
        hr = E_OUTOFMEMORY;
        // destroy pages that have not been passed to the PropertySheet function
        DestroyPropertySheetPage(phPages[0]);
        goto PopupPermissionDialog_Exit;
    }
    pfsDataObject->Initialize(target, folder);
    hr = CreateFileSecurityPropPage(&(phPages[0]), pfsDataObject);
    if (SUCCEEDED(hr))
    {
        cPages = 1;

        PROPSHEETHEADER psh;
        ZeroMemory(&psh, sizeof(psh));
        psh.dwSize = sizeof(psh);
        psh.dwFlags = PSH_DEFAULT | PSH_NOAPPLYNOW;
        psh.hwndParent = hWnd;
        psh.hInstance = AfxGetResourceHandle();
        psh.pszCaption = cstrSheetTitle;
        psh.nPages = cPages;
        psh.phpage = phPages;

        // create the property sheet
        iReturn = PropertySheet(&psh);
    }
    pfsDataObject->Release();

PopupPermissionDialog_Exit:
    CoUninitialize();
    return iReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\add_app_pool.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        app_app_pool.cpp

   Abstract:
        Add new IIS Application Pool node

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
        12/26/2000      sergeia     Initial creation

--*/
#include "stdafx.h"
#include "common.h"
#include "resource.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "iisobj.h"
#include "add_app_pool.h"
#include "shts.h"
#include "app_sheet.h"
#include "app_pool_sheet.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
#define new DEBUG_NEW

extern CInetmgrApp theApp;

CAddAppPoolDlg::CAddAppPoolDlg(
    CAppPoolsContainer * pCont,
    CPoolList * pools,
    CWnd * pParent)
    : CDialog(CAddAppPoolDlg::IDD, pParent),
    m_pCont(pCont),
    m_pool_list(pools),
    m_fUseMaster(TRUE)
{
}

CAddAppPoolDlg::~CAddAppPoolDlg()
{
}

void 
CAddAppPoolDlg::DoDataExchange(CDataExchange * pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAddAppPoolDlg)
    DDX_Control(pDX, IDC_EDIT_POOL_ID, m_edit_PoolId);
    DDX_Control(pDX, IDC_USE_MASTER, m_button_UseMaster);
    DDX_Control(pDX, IDC_USE_POOL, m_button_UsePool);
    DDX_Control(pDX, IDC_POOLS, m_combo_Pool);
    DDX_CBIndex(pDX, IDC_POOLS, m_PoolIdx);
    //}}AFX_DATA_MAP
    DDX_Text(pDX, IDC_EDIT_POOL_ID, m_strPoolId);
    if (pDX->m_bSaveAndValidate)
    {
		TCHAR bad_chars[] = _T("\\/");
		if (m_strPoolId.GetLength() != _tcscspn(m_strPoolId, bad_chars))
		{
			DDV_ShowBalloonAndFail(pDX, IDS_ERR_INVALID_POOLID_CHARS);
		}

		// bug:629607 don't do this check htere
        // check that pool id is unique
		//if (!IsUniqueId(m_strPoolId)){DDV_ShowBalloonAndFail(pDX, IDS_ERR_DUP_POOLID);}
    }
}

void 
CAddAppPoolDlg::OnOK() 
{
    if (UpdateData(TRUE))
    {
		// bug:629607 do this check htere
		if (!IsUniqueId(m_strPoolId,TRUE))
		{
            //::AfxMessageBox(IDS_ERR_DUP_POOLID,MB_ICONEXCLAMATION);
            DoHelpMessageBox(m_hWnd,IDS_ERR_DUP_POOLID, MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION, 0);
		}
		else
		{
			CDialog::OnOK();
		}
    }
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CAddAppPoolDlg, CDialog)
    //{{AFX_MSG_MAP(CAddAppPoolDlg)
    ON_BN_CLICKED(IDC_USE_MASTER, OnButtonUseMaster)
    ON_BN_CLICKED(IDC_USE_POOL, OnButtonUsePool)
    ON_BN_CLICKED(ID_HELP, OnHelp)
    ON_EN_CHANGE(IDC_EDIT_POOL_ID, OnItemChanged)
    ON_CBN_SELCHANGE(IDC_POOLS, OnItemChanged)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void
CAddAppPoolDlg::OnItemChanged()
{
    SetControlStates();
}

void
CAddAppPoolDlg::OnButtonUseMaster()
{
    m_fUseMaster = TRUE;
    SetControlStates();
}

void
CAddAppPoolDlg::OnButtonUsePool()
{
    m_fUseMaster = FALSE;
    SetControlStates();
}

void
CAddAppPoolDlg::SetControlStates()
{
    m_button_UseMaster.SetCheck(m_fUseMaster);
    m_button_UsePool.SetCheck(!m_fUseMaster);
    m_combo_Pool.EnableWindow(!m_fUseMaster);
    UpdateData();
    BOOL fGoodData = 
        !m_strPoolId.IsEmpty()
        && IsUniqueId(m_strPoolId, FALSE);
    GetDlgItem(IDOK)->EnableWindow(fGoodData);
}

BOOL 
CAddAppPoolDlg::OnInitDialog() 
{
    CDialog::OnInitDialog();

    CString def_pool;
    m_pCont->QueryDefaultPoolId(def_pool);

	CAppPoolNode * pDefPool = NULL;
    POSITION pos = m_pool_list->GetHeadPosition();
    int sel_idx = 0;
    while (pos != NULL)
    {
        CAppPoolNode * pPool = m_pool_list->GetNext(pos);
        int i = m_combo_Pool.AddString(pPool->QueryDisplayName());
        if (def_pool.CompareNoCase(pPool->QueryNodeName()) == 0)
        {
            sel_idx = i;
			pDefPool = pPool;
        }
        if (i != CB_ERR)
        {
            m_combo_Pool.SetItemDataPtr(i, pPool);
        }
    }
    m_combo_Pool.SetCurSel(sel_idx);
	m_strPoolId.LoadString(IDS_DEFAULT_APP_POOL);
    MakeUniquePoolId(m_strPoolId);
    UpdateData(FALSE);
    SetControlStates();

    return TRUE;
}

BOOL
CAddAppPoolDlg::IsUniqueId(CString& id, BOOL bCheckMetabase) 
{
    BOOL bRes = TRUE;

    POSITION pos = m_pool_list->GetHeadPosition();
    while (pos != NULL)
    {
        CAppPoolNode * pPool = m_pool_list->GetNext(pos);
        if (id.CompareNoCase(pPool->QueryNodeName()) == 0)
        {
            bRes = FALSE;
            break;
        }
    }

    // check the metabase when asked to.
    if (bRes)
    {
        if (bCheckMetabase)
        {
            if (m_pCont)
            {
                CComBSTR cont_path;
                CMetaInterface * pInterface = NULL;
                CError err;

                m_pCont->BuildMetaPath(cont_path);
                CMetabasePath path(FALSE, cont_path, id);

                // check if path exists...
                pInterface = m_pCont->QueryInterface();
                if (pInterface)
                {
		            CMetaKey mk(pInterface, path, METADATA_PERMISSION_READ);
		            err = mk.QueryResult();
                    if (err.Succeeded())
                    {
                        bRes = FALSE;
                    }
                }
            }
        }
    }
    return bRes;
}

void
CAddAppPoolDlg::MakeUniquePoolId(CString& id)
{
	TCHAR fmt[] = _T("%s #%d");
    CString unique;
    for (int n = 1; n < 100; n++)
    {
        unique.Format(fmt, id, n);
        if (IsUniqueId(unique,FALSE))
            break;
    }
    id = unique;
}

void
CAddAppPoolDlg::OnHelp()
{
    WinHelpDebug(0x20000 + CAddAppPoolDlg::IDD);
	::WinHelp(m_hWnd, theApp.m_pszHelpFilePath, HELP_CONTEXT, 0x20000 + CAddAppPoolDlg::IDD);
}


///////////////////////////////////////////////////////////////

HRESULT
CIISMBNode::AddAppPool(
      const CSnapInObjectRootBase * pObj,
      DATA_OBJECT_TYPES type,
      CAppPoolsContainer * pCont,
      CString& name
      )
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());
    HRESULT hr = S_OK;

    IConsoleNameSpace2 * pConsole 
           = (IConsoleNameSpace2 *)GetOwner()->GetConsoleNameSpace();
    ASSERT(pConsole != NULL);
    HSCOPEITEM hChild = NULL, hCurrent;
    LONG_PTR cookie;
    hr = pConsole->Expand(pCont->QueryScopeItem());
    if (SUCCEEDED(hr))
    {
        pConsole->GetChildItem(pCont->QueryScopeItem(), &hChild, &cookie);
        CAppPoolNode * pPool;
        CPoolList pool_list;
        while (SUCCEEDED(hr) && hChild != NULL)
        {
            pPool = (CAppPoolNode *)cookie;
            ASSERT(pPool != NULL);
            pool_list.AddTail(pPool);
            hCurrent = hChild;
            hr = pConsole->GetNextItem(hCurrent, &hChild, &cookie);
        }

        CThemeContextActivator activator(theApp.GetFusionInitHandle());

        CAddAppPoolDlg dlg(pCont, &pool_list, GetMainWindow(GetConsole()));
        if (dlg.DoModal() == IDOK)
        {
            CComBSTR cont_path;
            pCont->BuildMetaPath(cont_path);
            CMetabasePath path(FALSE, cont_path, dlg.m_strPoolId);
            CIISAppPool pool(QueryAuthInfo(), path);
            if (SUCCEEDED(hr = pool.QueryResult()))
            {
                hr = pool.Create();
                if (SUCCEEDED(hr))
                {
                   name = dlg.m_strPoolId;
                   if (!dlg.UseMaster())
                   {
                      POSITION pos = pool_list.FindIndex(dlg.m_PoolIdx);
                      CMetabasePath model_path(FALSE, cont_path, 
                            pool_list.GetAt(pos)->QueryNodeName());
                      CAppPoolProps model(QueryAuthInfo(), model_path, FALSE);
                      if (SUCCEEDED(hr = model.LoadData()))
                      {
                         CAppPoolProps new_pool(QueryAuthInfo(), path);
                         new_pool.InitFromModel(model);
                         hr = new_pool.WriteDirtyProps();
                      }
                   }
                   else
                   {
                         CAppPoolProps new_pool(QueryAuthInfo(), path);
                         hr = new_pool.WriteDirtyProps();
                   }
                }
            }
        }
        else
        {
            hr = CError::HResult(ERROR_CANCELLED);
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\aclpage.h ===
#ifndef __ACLPAGE_H__
#define __ACLPAGE_H__

#include "aclui.h"

#define DONT_WANT_SHELLDEBUG
#include "shlobj.h"     // LPITEMIDLIST
#include "shlobjp.h"

#define SHARE_PERM_FULL_CONTROL       FILE_ALL_ACCESS
#define SHARE_PERM_READ_ONLY          (FILE_GENERIC_READ | FILE_EXECUTE)
#define ACCOUNT_EVERYONE              _T("everyone")
#define ACCOUNT_ADMINISTRATORS        _T("administrators")
#define ACCOUNT_SYSTEM                _T("system")
#define ACCOUNT_INTERACTIVE           _T("interactive")

/////////////////////////////////////////////////////////////////////////////
// CFileSecurityDataObject

class CFileSecurityDataObject: public IDataObject
{
protected:
  UINT m_cRef;
  CString m_cstrComputerName;
  CString m_cstrFolder;
  CString m_cstrPath;
  CLIPFORMAT m_cfIDList;

public:
  CFileSecurityDataObject();
  ~CFileSecurityDataObject();
  void Initialize(
      IN LPCTSTR lpszComputerName,
      IN LPCTSTR lpszFolder
  );

  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(REFIID, LPVOID *);
  STDMETHOD_(ULONG, AddRef)();
  STDMETHOD_(ULONG, Release)();

  // *** IDataObject methods ***
  STDMETHOD(GetData)(LPFORMATETC pFEIn, LPSTGMEDIUM pSTM);
  inline STDMETHOD(GetDataHere)(LPFORMATETC pFE, LPSTGMEDIUM pSTM) {return E_NOTIMPL;}
  inline STDMETHOD(QueryGetData)(LPFORMATETC pFE) {return E_NOTIMPL;}
  inline STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC pFEIn, LPFORMATETC pFEOut) {return E_NOTIMPL;}
  inline STDMETHOD(SetData)(LPFORMATETC pFE, LPSTGMEDIUM pSTM, BOOL fRelease) {return E_NOTIMPL;}
  inline STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC *ppEnum) {return E_NOTIMPL;}
  inline STDMETHOD(DAdvise)(LPFORMATETC pFE, DWORD grfAdv, LPADVISESINK pAdvSink, LPDWORD pdwConnection) {return E_NOTIMPL;}
  inline STDMETHOD(DUnadvise)(DWORD dwConnection) {return E_NOTIMPL;}
  inline STDMETHOD(EnumDAdvise)(LPENUMSTATDATA *ppEnum) {return E_NOTIMPL;}

  HRESULT GetFolderPIDList(OUT LPITEMIDLIST *ppidl);
};

HRESULT
CreateFileSecurityPropPage(
    HPROPSHEETPAGE *phOutPage,
    LPDATAOBJECT pDataObject
);

INT_PTR
PopupPermissionDialog(
    HWND hWnd,
    LPCTSTR target,
    LPCTSTR folder
);

#endif // __ACLPAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\add_app_pool.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        app_app_pool.h

   Abstract:
        Add new IIS Application Pool node classes

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
        12/26/2000      sergeia     Initial creation

--*/
#ifndef _ADD_APP_POOL_H
#define _ADD_APP_POOL_H

class CAddAppPoolDlg : public CDialog
{
public:
    CAddAppPoolDlg(
        CAppPoolsContainer * pCont, 
        CPoolList * pools,
        CWnd * pParent = NULL);
    ~CAddAppPoolDlg();

    BOOL UseMaster() { return m_fUseMaster; }

public:
    //{{AFX_DATA(CAddAppPoolDlg)
    enum { IDD = IDD_ADD_APP_POOL };
    CEdit m_edit_PoolName;
    CString m_strPoolName;
    CEdit m_edit_PoolId;
    CString m_strPoolId;
    CButton m_button_UseMaster;
    CButton m_button_UsePool;
    CComboBox m_combo_Pool;
    int m_PoolIdx;
    //}}AFX_DATA

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAddAppPoolDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:

    // Generated message map functions
    //{{AFX_MSG(CAddAppPoolDlg)
    afx_msg void OnButtonUseMaster();
    afx_msg void OnButtonUsePool();
    virtual BOOL OnInitDialog();
	virtual void OnOK();
    //}}AFX_MSG
    afx_msg void OnItemChanged();
	afx_msg void OnHelp();

    DECLARE_MESSAGE_MAP()

    void SetControlStates();

    BOOL IsUniqueId(CString& id,BOOL bCheckMetabase);
    void MakeUniquePoolId(CString& str);
    void MakeUniquePoolName(CString& str);

private:
    BOOL m_fUseMaster;
    CAppPoolsContainer * m_pCont;
    CPoolList * m_pool_list;
};

#endif //_ADD_APP_POOL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\anondlg.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        anondlg.h

   Abstract:

        WWW Anonymous account dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _ANONDLG_H_
#define _ANONDLG_H_




class CAnonymousDlg : public CDialog
/*++

Class Description:

    Anonymous authentication dialog

Public Interface:

    CAnonymousDlg       : Constructor

    GetUserName         : Get user name entered
    GetPassword         : Get password entered
    GetPasswordSync     : Get password sync entered

--*/
{
//
// Construction
//
public:
    //
    // standard constructor
    //
    CAnonymousDlg(
        IN CString & strServerName,
        IN CString & strUserName,
        IN CString & strPassword,
        IN BOOL & fPasswordSync,
        IN CWnd * pParent = NULL
        );   

//
// Access
//
public:
    CString & GetUserName()  { return m_strUserName; }
    CStrPassword & GetPassword()  { return m_strPassword; }
    BOOL & GetPasswordSync() { return m_fPasswordSync; }

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CAnonymousDlg)
    enum { IDD = IDD_ANONYMOUS };
    CEdit   m_edit_UserName;
    CEdit   m_edit_Password;
    CStatic m_static_Username;
    CStatic m_static_Password;
    CButton m_button_CheckPassword;
    CButton m_group_AnonymousLogon;
    CButton m_chk_PasswordSync;
    //}}AFX_DATA

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAnonymousDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:

    // Generated message map functions
    //{{AFX_MSG(CAnonymousDlg)
    afx_msg void OnButtonBrowseUsers();
    afx_msg void OnButtonCheckPassword();
    afx_msg void OnCheckEnablePwSynchronization();
    afx_msg void OnChangeEditUsername();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()
    
    void SetControlStates();

private:
    BOOL m_fPasswordSyncChanged;
    BOOL m_fPasswordSyncMsgShown;
    BOOL m_fUserNameChanged;
    BOOL m_fPasswordSync;
    CString m_strUserName;
    CStrPassword m_strPassword;
    CString & m_strServerName;
};



#endif // _ANONDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\app_pool_sheet.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        app_pool_sheet.h

   Abstract:
        Application Pool Property Sheet

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#ifndef _APP_POOL_SHEET_H
#define _APP_POOL_SHEET_H

class CAppPoolProps : public CMetaProperties
{
public:
   CAppPoolProps(CComAuthInfo * pAuthInfo, LPCTSTR meta_path, BOOL fInherit = TRUE);
   CAppPoolProps(CMetaInterface * pInterface, LPCTSTR meta_path, BOOL fInherit = TRUE);
   CAppPoolProps(CMetaKey * pInterface, LPCTSTR meta_path, BOOL fInherit = TRUE);

   virtual HRESULT WriteDirtyProps();
   void InitFromModel(CAppPoolProps& model);
   HRESULT ChangeState(DWORD dwCommand);

protected:
   virtual void ParseFields();

public:
   MP_CString m_strTemplateName;
   MP_DWORD m_dwPeriodicRestartTime;
   MP_DWORD m_dwRestartRequestCount;
   MP_DWORD m_dwPeriodicRestartVMemory;
   MP_DWORD m_dwPeriodicRestartUMemory;
   MP_CStringListEx m_RestartSchedule;
   MP_DWORD m_dwIdleTimeout;
   MP_DWORD m_dwQueueSize;
   MP_DWORD m_dwMaxCPU_Use;
   MP_DWORD m_dwRefreshTime;
   MP_DWORD m_ActionIndex;
   MP_DWORD m_dwMaxProcesses;
   MP_BOOL m_fDoEnablePing;
   MP_DWORD m_dwPingInterval;
   MP_BOOL m_fDoEnableRapidFail;
   MP_DWORD m_dwCrashesCount;
   MP_DWORD m_dwCheckInterval;
   MP_DWORD m_dwStartupLimit;
   MP_DWORD m_dwShutdownLimit;
   MP_BOOL  m_fDoEnableDebug;
   MP_CString m_DebuggerFileName;
   MP_CString m_DebuggerParams;
   MP_DWORD m_dwIdentType;
   MP_CString m_strUserName;
   MP_CStrPassword m_strUserPass;
   MP_DWORD m_dwState;
   MP_DWORD m_dwWin32Error;
};


class CAppPoolSheet : public CInetPropertySheet
{
   DECLARE_DYNAMIC(CAppPoolSheet)

public:
   CAppPoolSheet(
        CComAuthInfo * pAuthInfo,
        LPCTSTR lpszMetaPath,
        CWnd * pParentWnd  = NULL,
        LPARAM lParam = 0L,
        LPARAM lParamParent = 0L,
        UINT iSelectPage = 0
        );

   virtual ~CAppPoolSheet();

public:
   // The following methods have predefined names to be compatible with
   // BEGIN_META_INST_READ and other macros.
   HRESULT QueryInstanceResult() const;
   CAppPoolProps & GetInstanceProperties() { return *m_pprops; }

   virtual HRESULT LoadConfigurationParameters();
   virtual void FreeConfigurationParameters();

   //{{AFX_MSG(CAppPoolSheet)
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()

private:
   BOOL m_fUseTemplate;
   CAppPoolProps * m_pprops;
};

class CAppPoolRecycle : public CInetPropertyPage
{
   DECLARE_DYNCREATE(CAppPoolRecycle)

public:
   CAppPoolRecycle(CInetPropertySheet * pSheet = NULL);
   virtual ~CAppPoolRecycle();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CAppPoolRecycle)
    enum { IDD = IDD_APP_POOL_RECYCLE };
    BOOL m_fDoRestartOnTime;
    CButton m_bnt_DoRestartOnTime;
    DWORD m_dwPeriodicRestartTime;
    CEdit m_Timespan;
    CSpinButtonCtrl m_TimespanSpin;
    BOOL m_fDoRestartOnCount;
    CButton m_btn_DoRestartOnCount;
    DWORD m_dwRestartRequestCount;
    CEdit m_Requests;
    CSpinButtonCtrl m_RequestsSpin;
    BOOL m_fDoRestartOnSchedule;
    CButton m_btn_DoRestartOnSchedule;
    CListBox m_lst_Schedule;
    CButton m_btn_Add;
    CButton m_btn_Remove;
    CButton m_btn_Edit;
    BOOL m_fDoRestartOnVMemory;
    CButton m_btn_DoRestartOnVMemory;
    DWORD m_dwPeriodicRestartVMemoryDisplay;
    CEdit m_VMemoryLimit;
    CSpinButtonCtrl m_VMemoryLimitSpin;
    BOOL m_fDoRestartOnUMemory;
    CButton m_btn_DoRestartOnUMemory;
    DWORD m_dwPeriodicRestartUMemoryDisplay;
    CEdit m_UMemoryLimit;
    CSpinButtonCtrl m_UMemoryLimitSpin;
    //}}AFX_DATA
    CStringListEx m_RestartSchedule;
    DWORD m_dwPeriodicRestartVMemory;
    DWORD m_dwPeriodicRestartUMemory;

    //{{AFX_MSG(CAppPoolRecycle)
    virtual BOOL OnInitDialog();
    afx_msg int OnCompareItem(UINT nID, LPCOMPAREITEMSTRUCT cmpi);
    afx_msg void OnMeasureItem(UINT nID, LPMEASUREITEMSTRUCT mi);
    afx_msg void OnDrawItem(UINT nID, LPDRAWITEMSTRUCT di);
    afx_msg void OnDoRestartOnTime();
    afx_msg void OnDoRestartOnCount();
    afx_msg void OnDoRestartOnSchedule();
    afx_msg void OnDoRestartOnVMemory();
    afx_msg void OnDoRestartOnUMemory();
    afx_msg void OnAddTime();
    afx_msg void OnDeleteTime();
    afx_msg void OnChangeTime();
    afx_msg void OnItemChanged();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CAppPoolRecycle)
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();
    void SetControlsState();
};

class CAppPoolPerf : public CInetPropertyPage
{
   DECLARE_DYNCREATE(CAppPoolPerf)

public:
   CAppPoolPerf(CInetPropertySheet * pSheet = NULL);
   virtual ~CAppPoolPerf();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CAppPoolPerf)
    enum { IDD = IDD_APP_POOL_PERF };
    BOOL m_fDoIdleShutdown;
    CButton m_bnt_DoIdleShutdown;
    DWORD m_dwIdleTimeout;
    CEdit m_IdleTimeout;
    CSpinButtonCtrl m_IdleTimeoutSpin;
    
    BOOL m_fDoLimitQueue;
    CButton m_btn_DoLimitQueue;
    DWORD m_dwQueueSize;
    CEdit m_QueueSize;
    CSpinButtonCtrl m_QueueSizeSpin;

    BOOL m_fDoEnableCPUAccount;
    CButton m_btn_DoEnableCPUAccount;
    DWORD m_dwMaxCPU_UseVisual;
    CEdit m_MaxCPU_Use;
    CSpinButtonCtrl m_MaxCPU_UseSpin;
    DWORD m_dwRefreshTime;
    CEdit m_RefreshTime;
    CSpinButtonCtrl m_RefreshTimeSpin;
    int m_ActionIndex;
    CComboBox m_Action;
    DWORD m_dwMaxProcesses;
    CEdit m_MaxProcesses;
    CSpinButtonCtrl m_MaxProcessesSpin;
    //}}AFX_DATA

    //{{AFX_MSG(CAppPoolPerf)
    virtual BOOL OnInitDialog();
    afx_msg void OnDoIdleShutdown();
    afx_msg void OnDoLimitQueue();
    afx_msg void OnDoEnableCPUAccount();
    afx_msg void OnItemChanged();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
    DWORD m_dwMaxCPU_Use;

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CAppPoolPerf)
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();
    void SetControlsState();

};


class CAppPoolHealth : public CInetPropertyPage
{
   DECLARE_DYNCREATE(CAppPoolHealth)

public:
   CAppPoolHealth(CInetPropertySheet * pSheet = NULL);
   virtual ~CAppPoolHealth();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CAppPoolHealth)
    enum { IDD = IDD_APP_POOL_HEALTH };
    BOOL m_fDoEnablePing;
    CButton m_bnt_DoEnablePing;
    DWORD m_dwPingInterval;
    CEdit m_PingInterval;
    CSpinButtonCtrl m_PingIntervalSpin;
    
    BOOL m_fDoEnableRapidFail;
    CButton m_btn_DoEnableRapidFail;
    DWORD m_dwCrashesCount;
    CEdit m_CrashesCount;
    CSpinButtonCtrl m_CrashesCountSpin;
    DWORD m_dwCheckInterval;
    CEdit m_CheckInterval;
    CSpinButtonCtrl m_CheckIntervalSpin;

    DWORD m_dwStartupLimit;
    CEdit m_StartupLimit;
    CSpinButtonCtrl m_StartupLimitSpin;
    DWORD m_dwShutdownLimit;
    CEdit m_ShutdownLimit;
    CSpinButtonCtrl m_ShutdownLimitSpin;
    //}}AFX_DATA

    //{{AFX_MSG(CAppPoolPerf)
    virtual BOOL OnInitDialog();
    afx_msg void OnDoEnablePinging();
    afx_msg void OnDoEnableRapidFail();
    afx_msg void OnItemChanged();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CAppPoolPerf)
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

};
#if 0
class CAppPoolDebug : public CInetPropertyPage
{
   DECLARE_DYNCREATE(CAppPoolDebug)

public:
   CAppPoolDebug(CInetPropertySheet * pSheet = NULL);
   virtual ~CAppPoolDebug();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CAppPoolDebug)
    enum { IDD = IDD_APP_POOL_DEBUG };
    BOOL m_fDoEnableDebug;
    CButton m_bnt_DoEnableDebug;
    CString m_DebuggerFileName;
    CEdit m_FileName;
    CButton m_Browse;
    CString m_DebuggerParams;
    CEdit m_Params;
    //}}AFX_DATA

    //{{AFX_MSG(CAppPoolPerf)
    virtual BOOL OnInitDialog();
    afx_msg void OnDoEnableDebug();
    afx_msg void OnBrowse();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CAppPoolPerf)
    virtual void DoDataExchange(CDataExchange * pDX);
    afx_msg void OnItemChanged();
    //}}AFX_VIRTUAL
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();
    void SetControlState();

};
#endif
class CAppPoolIdent : public CInetPropertyPage
{
   DECLARE_DYNCREATE(CAppPoolIdent)

public:
   CAppPoolIdent(CInetPropertySheet * pSheet = NULL);
   virtual ~CAppPoolIdent();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CAppPoolIdent)
    enum { IDD = IDD_APP_POOL_IDENT };
    CButton m_bnt_Predefined;
    CButton m_bnt_Configurable;
    CComboBox m_PredefList;
    int m_PredefIndex;
    CString m_strUserName;
    CStrPassword m_strUserPass;
    CEdit m_UserName;
    CEdit m_UserPass;
    CButton m_Browse;
    //}}AFX_DATA
    BOOL m_fPredefined;
    DWORD m_dwIdentType;

    //{{AFX_MSG(CAppPoolPerf)
    virtual BOOL OnInitDialog();
    afx_msg void OnPredefined();
    afx_msg void OnBrowse();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CAppPoolPerf)
    virtual void DoDataExchange(CDataExchange * pDX);
    afx_msg void OnItemChanged();
    afx_msg void OnSysAccountChanged();
    //}}AFX_VIRTUAL
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    void SetControlState();

	BOOL m_bAssCovered;
};
#if 0
class CAppPoolCache : public CAppCache
{
public:
    CAppPoolCache(CInetPropertySheet * pSheet)
        : CAppCache(pSheet)
    {
    }
    virtual ~CAppPoolCache()
    {
    }
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();
};

class CPoolProcessOpt : public CProcessOptPage
{
public:
    CPoolProcessOpt(CInetPropertySheet * pSheet)
        : CProcessOptPage(pSheet)
    {
    }
    virtual ~CPoolProcessOpt()
    {
    }
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();
};
#endif
//
// BUGBUG: Returns S_OK if object not present
//
inline HRESULT CAppPoolSheet::QueryInstanceResult() const 
{ 
    return m_pprops ? m_pprops->QueryResult() : S_OK;
}

#endif //_APP_POOL_SHEET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\app_pool_sheet.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        app_pool_sheet.cpp

   Abstract:
        Application Pools Property Sheet and Pages

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
        11/16/2000         sergeia           Initial creation

--*/

//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "shts.h"
#include "iisobj.h"
#include "app_sheet.h"
#include "app_pool_sheet.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
#define new DEBUG_NEW

#define TIMESPAN_MIN          (int)1
#define TIMESPAN_MAX          (int)(4000000)
#define REQUESTS_MIN          (int)1
#define REQUESTS_MAX          (int)(4000000)
#define VMEMORY_MIN            (int)1
#define VMEMORY_MAX            (int)(2000000)
#define UMEMORY_MIN            (int)1
#define UMEMORY_MAX            (int)(2000000)
#define TIMEOUT_MIN           (int)1
#define TIMEOUT_MAX           (int)(4000000)
#define QUEUESIZE_MIN         (int)0
#define QUEUESIZE_MAX         (int)(65535)
#define REFRESH_TIME_MIN      (int)1
#define REFRESH_TIME_MAX      (int)(4000000)
#define MAXPROCESSES_MIN      (int)1
#define MAXPROCESSES_MAX      (int)(4000000)
#define PING_INTERVAL_MIN     (int)1
#define PING_INTERVAL_MAX     (int)(4000000)
#define CRASHES_COUNT_MIN     (int)1
#define CRASHES_COUNT_MAX     (int)(4000000)
#define CHECK_INTERVAL_MIN    (int)1
#define CHECK_INTERVAL_MAX    (int)(4000000)
#define STARTUP_LIMIT_MIN     (int)1
#define STARTUP_LIMIT_MAX     (int)(4000000)
#define SHUTDOWN_LIMIT_MIN    (int)1
#define SHUTDOWN_LIMIT_MAX    (int)(4000000)
#define CPU_LIMIT_MIN         (int)0
#define CPU_LIMIT_MAX         (int)100
#define CPU_RESET_TIME_MIN    (int)1
#define CPU_RESET_TIME_MAX    (int)1440

#define IDENT_TYPE_LOCALSYSTEM      0
#define IDENT_TYPE_LOCALSERVICE     1
#define IDENT_TYPE_NETWORKSERVICE   2
#define IDENT_TYPE_CONFIGURABLE     3

#define PERIODIC_RESTART_TIME_DEF      120
#define PERIODIC_RESTART_REQ_DEF       35000
#define VMEMORY_DEF                    500            // In MB
#define UMEMORY_DEF                    192            // In MB
#define IDLE_TIMEOUT_DEF               20
#define QUEUE_SIZE_DEF                 2000
#define CPU_USE_DEF                    100
#define CPU_RESET_TIME_DEF             5
#define ACTION_INDEX_DEF               0
#define MAX_PROCESSES_DEF              1
#define PING_INTERVAL_DEF              240
#define CRASHES_COUNT_DEF              5
#define CHECK_INTERVAL_DEF             5
#define STARTUP_LIMIT_DEF              90
#define SHUTDOWN_LIMIT_DEF             90

#define SLEEP_INTERVAL (500L)
//
// Maximum time to wait for service to attain desired state
//
#define MAX_SLEEP        (180000)       // For a service
#define MAX_SLEEP_POOL   ( 30000)       // For an instance

#define INIT_MEMBERS_DEF()\
   m_dwPeriodicRestartTime(PERIODIC_RESTART_TIME_DEF),\
   m_dwRestartRequestCount(PERIODIC_RESTART_REQ_DEF),\
   m_dwPeriodicRestartVMemory(0),\
   m_dwPeriodicRestartUMemory(0),\
   m_dwIdleTimeout(IDLE_TIMEOUT_DEF),\
   m_dwQueueSize(QUEUE_SIZE_DEF),\
   m_dwMaxCPU_Use(CPU_USE_DEF * 1000),\
   m_dwRefreshTime(0),\
   m_ActionIndex(ACTION_INDEX_DEF),\
   m_dwMaxProcesses(MAX_PROCESSES_DEF),\
   m_dwPingInterval(PING_INTERVAL_DEF),\
   m_dwCrashesCount(CRASHES_COUNT_DEF),\
   m_dwCheckInterval(CHECK_INTERVAL_DEF),\
   m_dwStartupLimit(STARTUP_LIMIT_DEF),\
   m_dwShutdownLimit(SHUTDOWN_LIMIT_DEF),\
   m_fDoEnablePing(TRUE),\
   m_fDoEnableRapidFail(TRUE),\
   m_dwIdentType(IDENT_TYPE_NETWORKSERVICE),\
   m_dwState(MD_APPPOOL_STATE_STOPPED)


/////////////////////////////////////////////////////////////////////////////
// CAppPoolProps implementation

CAppPoolProps::CAppPoolProps(
   CComAuthInfo * pAuthInfo, LPCTSTR meta_path, BOOL fInherit
   )
   : CMetaProperties(pAuthInfo, meta_path),
   INIT_MEMBERS_DEF()
{
   m_fInherit = fInherit;
}

CAppPoolProps::CAppPoolProps(
   CMetaInterface * pInterface, LPCTSTR meta_path, BOOL fInherit
   )
   : CMetaProperties(pInterface, meta_path),
   INIT_MEMBERS_DEF()
{
   m_fInherit = fInherit;
}

CAppPoolProps::CAppPoolProps(
   CMetaKey * pKey, LPCTSTR meta_path, BOOL fInherit
   )
   : CMetaProperties(pKey, meta_path),
   INIT_MEMBERS_DEF()
{
   m_fInherit = fInherit;
}

#define HANDLE_LOCAL_META_RECORD(id,v) \
        case id: \
            FetchMetaValue(pAllRecords, i, MP_V(v)); \
            v.m_fDirty = (pAllRecords[i].dwMDAttributes & METADATA_ISINHERITED) == 0; \
            break;

void
CAppPoolProps::ParseFields()
{
//	m_AspMaxDiskTemplateCacheFiles = 0;
    if (!m_fInherit)
    {
        // If we want only data defined on this node, we will set dirty flag for these props
        BOOL f;
        BEGIN_PARSE_META_RECORDS(m_dwNumEntries, m_pbMDData)
            HANDLE_LOCAL_META_RECORD(MD_APPPOOL_PERIODIC_RESTART_TIME, m_dwPeriodicRestartTime)
            HANDLE_LOCAL_META_RECORD(MD_APPPOOL_PERIODIC_RESTART_SCHEDULE, m_RestartSchedule)
            HANDLE_LOCAL_META_RECORD(MD_APPPOOL_PERIODIC_RESTART_REQUEST_COUNT, m_dwRestartRequestCount)
            HANDLE_LOCAL_META_RECORD(MD_APPPOOL_PERIODIC_RESTART_MEMORY, m_dwPeriodicRestartVMemory)
            HANDLE_LOCAL_META_RECORD(MD_APPPOOL_PERIODIC_RESTART_PRIVATE_MEMORY, m_dwPeriodicRestartUMemory)
            HANDLE_LOCAL_META_RECORD(MD_APPPOOL_IDLE_TIMEOUT, m_dwIdleTimeout)
            HANDLE_LOCAL_META_RECORD(MD_APPPOOL_UL_APPPOOL_QUEUE_LENGTH, m_dwQueueSize)
            HANDLE_LOCAL_META_RECORD(MD_CPU_RESET_INTERVAL, m_dwRefreshTime)
            HANDLE_LOCAL_META_RECORD(MD_APPPOOL_MAX_PROCESS_COUNT, m_dwMaxProcesses)
            HANDLE_LOCAL_META_RECORD(MD_CPU_LIMIT, m_dwMaxCPU_Use)
            HANDLE_LOCAL_META_RECORD(MD_CPU_ACTION, m_ActionIndex)
            HANDLE_LOCAL_META_RECORD(MD_APPPOOL_PINGING_ENABLED, m_fDoEnablePing)
            HANDLE_LOCAL_META_RECORD(MD_APPPOOL_PING_INTERVAL, m_dwPingInterval)
            HANDLE_LOCAL_META_RECORD(MD_APPPOOL_RAPID_FAIL_PROTECTION_ENABLED, m_fDoEnableRapidFail)
            HANDLE_LOCAL_META_RECORD(MD_RAPID_FAIL_PROTECTION_MAX_CRASHES, m_dwCrashesCount)
            HANDLE_LOCAL_META_RECORD(MD_RAPID_FAIL_PROTECTION_INTERVAL, m_dwCheckInterval)
            HANDLE_LOCAL_META_RECORD(MD_APPPOOL_STARTUP_TIMELIMIT, m_dwStartupLimit)
            HANDLE_LOCAL_META_RECORD(MD_APPPOOL_SHUTDOWN_TIMELIMIT, m_dwShutdownLimit)
            HANDLE_LOCAL_META_RECORD(MD_APPPOOL_ORPHAN_PROCESSES_FOR_DEBUGGING, m_fDoEnableDebug)
            HANDLE_LOCAL_META_RECORD(MD_APPPOOL_ORPHAN_ACTION_EXE, m_DebuggerFileName)
            HANDLE_LOCAL_META_RECORD(MD_APPPOOL_ORPHAN_ACTION_PARAMS, m_DebuggerParams)
            HANDLE_LOCAL_META_RECORD(MD_APPPOOL_IDENTITY_TYPE, m_dwIdentType)
            HANDLE_LOCAL_META_RECORD(MD_WAM_USER_NAME, m_strUserName)
            HANDLE_LOCAL_META_RECORD(MD_WAM_PWD, m_strUserPass)
            HANDLE_LOCAL_META_RECORD(MD_APPPOOL_STATE, m_dwState)
			HANDLE_LOCAL_META_RECORD(MD_WIN32_ERROR, m_dwWin32Error)
        END_PARSE_META_RECORDS
    }
    else
    {
        BEGIN_PARSE_META_RECORDS(m_dwNumEntries, m_pbMDData)
			HANDLE_META_RECORD(MD_APPPOOL_PERIODIC_RESTART_TIME,            m_dwPeriodicRestartTime)
			HANDLE_META_RECORD(MD_APPPOOL_PERIODIC_RESTART_SCHEDULE,        m_RestartSchedule)
			HANDLE_META_RECORD(MD_APPPOOL_PERIODIC_RESTART_REQUEST_COUNT,   m_dwRestartRequestCount)
			HANDLE_META_RECORD(MD_APPPOOL_PERIODIC_RESTART_MEMORY,          m_dwPeriodicRestartVMemory)
			HANDLE_META_RECORD(MD_APPPOOL_PERIODIC_RESTART_PRIVATE_MEMORY,  m_dwPeriodicRestartUMemory)
			HANDLE_META_RECORD(MD_APPPOOL_IDLE_TIMEOUT,                     m_dwIdleTimeout)
			HANDLE_META_RECORD(MD_APPPOOL_UL_APPPOOL_QUEUE_LENGTH,          m_dwQueueSize)
			HANDLE_META_RECORD(MD_CPU_RESET_INTERVAL,                       m_dwRefreshTime)
			HANDLE_META_RECORD(MD_APPPOOL_MAX_PROCESS_COUNT,                m_dwMaxProcesses)
			HANDLE_META_RECORD(MD_CPU_LIMIT,                                m_dwMaxCPU_Use)
			HANDLE_META_RECORD(MD_CPU_ACTION,                               m_ActionIndex)
			HANDLE_META_RECORD(MD_APPPOOL_PINGING_ENABLED,                  m_fDoEnablePing)
			HANDLE_META_RECORD(MD_APPPOOL_PING_INTERVAL,                    m_dwPingInterval)
			HANDLE_META_RECORD(MD_APPPOOL_RAPID_FAIL_PROTECTION_ENABLED,    m_fDoEnableRapidFail)
			HANDLE_META_RECORD(MD_RAPID_FAIL_PROTECTION_MAX_CRASHES,        m_dwCrashesCount)
			HANDLE_META_RECORD(MD_RAPID_FAIL_PROTECTION_INTERVAL,           m_dwCheckInterval)
			HANDLE_META_RECORD(MD_APPPOOL_STARTUP_TIMELIMIT,                m_dwStartupLimit)
			HANDLE_META_RECORD(MD_APPPOOL_SHUTDOWN_TIMELIMIT,               m_dwShutdownLimit)
			HANDLE_META_RECORD(MD_APPPOOL_ORPHAN_PROCESSES_FOR_DEBUGGING,   m_fDoEnableDebug)
			HANDLE_META_RECORD(MD_APPPOOL_ORPHAN_ACTION_EXE,                m_DebuggerFileName)
			HANDLE_META_RECORD(MD_APPPOOL_ORPHAN_ACTION_PARAMS,             m_DebuggerParams)
			HANDLE_META_RECORD(MD_APPPOOL_IDENTITY_TYPE,                    m_dwIdentType)
			HANDLE_META_RECORD(MD_WAM_USER_NAME,                            m_strUserName)
			HANDLE_META_RECORD(MD_WAM_PWD,                                  m_strUserPass)
			HANDLE_META_RECORD(MD_APPPOOL_STATE, m_dwState)
			HANDLE_META_RECORD(MD_WIN32_ERROR, m_dwWin32Error)
		END_PARSE_META_RECORDS
    }
}

/* virtual */
HRESULT
CAppPoolProps::WriteDirtyProps()
/*++

Routine Description:

    Write the dirty properties to the metabase

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;
    BEGIN_META_WRITE()
       META_WRITE(MD_APPPOOL_PERIODIC_RESTART_TIME,            m_dwPeriodicRestartTime)
       META_WRITE(MD_APPPOOL_PERIODIC_RESTART_SCHEDULE,        m_RestartSchedule)
       META_WRITE(MD_APPPOOL_PERIODIC_RESTART_REQUEST_COUNT,   m_dwRestartRequestCount)
       META_WRITE(MD_APPPOOL_PERIODIC_RESTART_MEMORY,          m_dwPeriodicRestartVMemory)
       META_WRITE(MD_APPPOOL_PERIODIC_RESTART_PRIVATE_MEMORY,  m_dwPeriodicRestartUMemory)

       META_WRITE(MD_APPPOOL_IDLE_TIMEOUT,                     m_dwIdleTimeout)
       META_WRITE(MD_APPPOOL_UL_APPPOOL_QUEUE_LENGTH,          m_dwQueueSize)
       META_WRITE(MD_CPU_RESET_INTERVAL,                       m_dwRefreshTime)
       META_WRITE(MD_APPPOOL_MAX_PROCESS_COUNT,                m_dwMaxProcesses)
       META_WRITE(MD_CPU_LIMIT,                                m_dwMaxCPU_Use)
       META_WRITE(MD_CPU_ACTION,                               m_ActionIndex)

       META_WRITE(MD_APPPOOL_PINGING_ENABLED,                  m_fDoEnablePing)
       META_WRITE(MD_APPPOOL_PING_INTERVAL,                    m_dwPingInterval)
       META_WRITE(MD_APPPOOL_RAPID_FAIL_PROTECTION_ENABLED,    m_fDoEnableRapidFail)
	   META_WRITE(MD_RAPID_FAIL_PROTECTION_MAX_CRASHES,        m_dwCrashesCount)
       META_WRITE(MD_RAPID_FAIL_PROTECTION_INTERVAL,           m_dwCheckInterval)
       META_WRITE(MD_APPPOOL_STARTUP_TIMELIMIT,                m_dwStartupLimit)
       META_WRITE(MD_APPPOOL_SHUTDOWN_TIMELIMIT,               m_dwShutdownLimit)
       META_WRITE(MD_APPPOOL_ORPHAN_PROCESSES_FOR_DEBUGGING,   m_fDoEnableDebug)
       META_WRITE(MD_APPPOOL_ORPHAN_ACTION_EXE,                m_DebuggerFileName)
       META_WRITE(MD_APPPOOL_ORPHAN_ACTION_PARAMS,             m_DebuggerParams)
       META_WRITE(MD_APPPOOL_IDENTITY_TYPE,                    m_dwIdentType)
       META_WRITE(MD_WAM_USER_NAME,                            m_strUserName)
       META_WRITE(MD_WAM_PWD,                                  m_strUserPass)
    END_META_WRITE(err);

    return err;
}

void
CAppPoolProps::InitFromModel(CAppPoolProps& model)
{
   m_dwPeriodicRestartTime = model.m_dwPeriodicRestartTime;
   m_dwRestartRequestCount = model.m_dwRestartRequestCount;
   m_dwPeriodicRestartVMemory = model.m_dwPeriodicRestartVMemory;
   m_dwPeriodicRestartUMemory = model.m_dwPeriodicRestartUMemory;
   m_RestartSchedule = model.m_RestartSchedule;
   m_dwIdleTimeout = model.m_dwIdleTimeout;
   m_dwQueueSize = model.m_dwQueueSize;
   m_dwMaxCPU_Use = model.m_dwMaxCPU_Use;
   m_dwRefreshTime = model.m_dwRefreshTime;
   m_ActionIndex = model.m_ActionIndex;
   m_dwMaxProcesses = model.m_dwMaxProcesses;
   m_fDoEnablePing = model.m_fDoEnablePing;
   m_dwPingInterval = model.m_dwPingInterval;
   m_fDoEnableRapidFail = model.m_fDoEnableRapidFail;
   m_dwCrashesCount = model.m_dwCrashesCount;
   m_dwCheckInterval = model.m_dwCheckInterval;
   m_dwStartupLimit = model.m_dwStartupLimit;
   m_dwShutdownLimit = model.m_dwShutdownLimit;
   m_fDoEnableDebug = model.m_fDoEnableDebug;
   m_DebuggerFileName = model.m_DebuggerFileName;
   m_DebuggerParams = model.m_DebuggerParams;
   m_dwIdentType = model.m_dwIdentType;
   m_strUserName = model.m_strUserName;
   m_strUserPass = model.m_strUserPass;
}

HRESULT
CAppPoolProps::ChangeState(DWORD dwCommand)
/*++

Routine Description:
    Change the state of the pool

Arguments:
    DWORD dwCommand     : Command

Return Value:
    HRESULT

--*/
{
    DWORD  dwTargetState;
    DWORD  dwPendingState;
    CError err;

    switch(dwCommand)
    {
    case MD_APPPOOL_COMMAND_STOP:
        dwTargetState = MD_APPPOOL_STATE_STOPPED;
        dwPendingState = MD_APPPOOL_STATE_STOPPING;
        break;

    case MD_APPPOOL_COMMAND_START:
        dwTargetState = MD_APPPOOL_STATE_STARTED;
        dwPendingState = MD_APPPOOL_STATE_STARTING;
        break;

    default:
        ASSERT_MSG("Invalid service state requested");
        err = ERROR_INVALID_PARAMETER;
    }

    err = OpenForWriting(FALSE);
    if (err.Succeeded())
    {
        m_dwWin32Error = 0;
        err = SetValue(MD_WIN32_ERROR, m_dwWin32Error);
		if (err.Succeeded())
		{
			err = SetValue(MD_APPPOOL_COMMAND, dwCommand);
		}
        Close();
    }

    if (err.Succeeded())
    {
        //
        // Wait for the service to attain desired state, timeout
        // after specified interval
        //
        DWORD dwSleepTotal = 0L;
        DWORD dwOldState = m_dwState;

        if (dwOldState == dwTargetState)
        {
            //
            // Current state matches desired
            // state already.  ISM must be behind
            // the times.  
            //
            return err;
        }

        while (dwSleepTotal < MAX_SLEEP_POOL)
        {
            err = LoadData();

            if (err.Failed())
            {
                break;
            }

            if ((m_dwState != dwPendingState && m_dwState != dwOldState) 
              || m_dwWin32Error != ERROR_SUCCESS
               )
            {
                //
                // Done one way or another
                //
                if (m_dwState != dwTargetState)
                {
                    //
                    // Did not achieve desired result. Something went
                    // wrong.
                    //
                    if (m_dwWin32Error)
                    {
                        err = m_dwWin32Error;
                    }
                }

                break;
            }

            //
            // Still pending...
            //
            ::Sleep(SLEEP_INTERVAL);

            dwSleepTotal += SLEEP_INTERVAL;
        }

        if (dwSleepTotal >= MAX_SLEEP_POOL)
        {
            //
            // Timed out.  If there is a real error in the metabase
            // use it, otherwise use a generic timeout error
            //
//            err = m_dwWin32Error;

            if (err.Succeeded())
            {
                err = ERROR_SERVICE_REQUEST_TIMEOUT;
            }
        }
    }

    return err;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CAppPoolSheet, CInetPropertySheet)

CAppPoolSheet::CAppPoolSheet(
      CComAuthInfo * pAuthInfo,
      LPCTSTR lpszMetaPath,
      CWnd * pParentWnd,
      LPARAM lParam,
      LPARAM lParamParent,
      UINT iSelectPage
      )
      : CInetPropertySheet(
         pAuthInfo, lpszMetaPath, pParentWnd, lParam, lParamParent, iSelectPage),
      m_pprops(NULL)
{
   CString last;
   CMetabasePath::GetLastNodeName(lpszMetaPath, last);
   SetIsMasterInstance(last.CompareNoCase(SZ_MBN_APP_POOLS) == 0);
}

CAppPoolSheet::~CAppPoolSheet()
{
   FreeConfigurationParameters();
}

HRESULT
CAppPoolSheet::LoadConfigurationParameters()
{
   //
   // Load base properties
   //
   CError err;

   if (m_pprops == NULL)
   {
      //
      // First call -- load values
      //
      m_pprops = new CAppPoolProps(QueryAuthInfo(), QueryMetaPath());
      if (!m_pprops)
      {
         TRACEEOLID("LoadConfigurationParameters: OOM");
         err = ERROR_NOT_ENOUGH_MEMORY;
         return err;
      }
      err = m_pprops->LoadData();
      if (IsMasterInstance())
      {
         CAppPoolsContainer * pObject = (CAppPoolsContainer *)GetParameter();
      }
   }
   
   return err;
}

void
CAppPoolSheet::FreeConfigurationParameters()
{
   CInetPropertySheet::FreeConfigurationParameters();
   delete m_pprops;
}

BEGIN_MESSAGE_MAP(CAppPoolSheet, CInetPropertySheet)
    //{{AFX_MSG_MAP(CAppPoolSheet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CAppPoolRecycle, CInetPropertyPage)

CAppPoolRecycle::CAppPoolRecycle(CInetPropertySheet * pSheet)
    : CInetPropertyPage(CAppPoolRecycle::IDD, pSheet),
    m_fDoRestartOnTime(FALSE),
	m_dwPeriodicRestartTime(PERIODIC_RESTART_TIME_DEF),
    m_fDoRestartOnCount(FALSE),
	m_dwRestartRequestCount(PERIODIC_RESTART_REQ_DEF),
    m_fDoRestartOnSchedule(FALSE),
    m_fDoRestartOnVMemory(FALSE),
    m_fDoRestartOnUMemory(FALSE),
	m_dwPeriodicRestartVMemory(VMEMORY_DEF * 1024),
	m_dwPeriodicRestartUMemory(UMEMORY_DEF * 1024)
{
}

CAppPoolRecycle::~CAppPoolRecycle()
{
}

/* virtual */
HRESULT
CAppPoolRecycle::FetchLoadedValues()
{
   CError err;

   BEGIN_META_INST_READ(CAppPoolSheet)
      FETCH_INST_DATA_FROM_SHEET(m_dwPeriodicRestartTime);
      FETCH_INST_DATA_FROM_SHEET(m_dwRestartRequestCount);
      FETCH_INST_DATA_FROM_SHEET(m_RestartSchedule);
      FETCH_INST_DATA_FROM_SHEET(m_dwPeriodicRestartVMemory);
      FETCH_INST_DATA_FROM_SHEET(m_dwPeriodicRestartUMemory);
   END_META_INST_READ(err)

   m_fDoRestartOnTime = m_dwPeriodicRestartTime != 0;
   if (!m_fDoRestartOnTime)
   {
       m_dwPeriodicRestartTime = PERIODIC_RESTART_TIME_DEF;
   }
   m_fDoRestartOnCount = m_dwRestartRequestCount != 0;
   if (!m_fDoRestartOnCount)
   {
       m_dwRestartRequestCount = PERIODIC_RESTART_REQ_DEF;
   }
   m_fDoRestartOnSchedule = m_RestartSchedule.GetCount() > 0;
   m_fDoRestartOnVMemory = m_dwPeriodicRestartVMemory != 0;
   if (!m_fDoRestartOnVMemory)
   {
       m_dwPeriodicRestartVMemoryDisplay = VMEMORY_DEF;
   }
   else
   {
       m_dwPeriodicRestartVMemoryDisplay = m_dwPeriodicRestartVMemory / 1024;
   }
   m_fDoRestartOnUMemory = m_dwPeriodicRestartUMemory != 0;
   if (!m_fDoRestartOnUMemory)
   {
       m_dwPeriodicRestartUMemoryDisplay = UMEMORY_DEF;
   }
   else
   {
       m_dwPeriodicRestartUMemoryDisplay = m_dwPeriodicRestartUMemory / 1024;
   }

   return err;
}

/* virtual */
HRESULT
CAppPoolRecycle::SaveInfo()
{
   ASSERT(IsDirty());
   CError err;

   int count = m_lst_Schedule.GetCount();
   TCHAR buf[32];
   SYSTEMTIME tm;
   ::GetSystemTime(&tm);
   m_RestartSchedule.RemoveAll();
   if (m_fDoRestartOnSchedule)
   {
      CString buf;
      for (int i = 0; i < count; i++)
      {
         buf = (LPCTSTR)m_lst_Schedule.GetItemDataPtr(i);
         m_RestartSchedule.AddTail(buf);
      }
   }
   DWORD d;
   CStringListEx list;
   BEGIN_META_INST_WRITE(CAppPoolSheet)
      d = m_dwPeriodicRestartTime; 
      if (!m_fDoRestartOnTime) 
         m_dwPeriodicRestartTime = 0;
      STORE_INST_DATA_ON_SHEET(m_dwPeriodicRestartTime)
      m_dwPeriodicRestartTime = d;
      d = m_dwRestartRequestCount;
      if (!m_fDoRestartOnCount)
         m_dwRestartRequestCount = 0;
      STORE_INST_DATA_ON_SHEET(m_dwRestartRequestCount)
      m_dwRestartRequestCount = d;
      list = m_RestartSchedule;
      if (!m_fDoRestartOnSchedule)
         m_RestartSchedule.RemoveAll();
      STORE_INST_DATA_ON_SHEET(m_RestartSchedule)
      m_RestartSchedule = list;
      m_dwPeriodicRestartVMemory = m_dwPeriodicRestartVMemoryDisplay * 1024;
      if (!m_fDoRestartOnVMemory)
         m_dwPeriodicRestartVMemory = 0;
      STORE_INST_DATA_ON_SHEET(m_dwPeriodicRestartVMemory)
      m_dwPeriodicRestartUMemory = m_dwPeriodicRestartUMemoryDisplay * 1024;
      if (!m_fDoRestartOnUMemory)
         m_dwPeriodicRestartUMemory = 0;
      STORE_INST_DATA_ON_SHEET(m_dwPeriodicRestartUMemory)
   END_META_INST_WRITE(err)

   return err;
}

void
CAppPoolRecycle::DoDataExchange(CDataExchange * pDX)
{
   CInetPropertyPage::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CAppPoolRecycle)
   DDX_Check(pDX, IDC_RECYCLE_TIMESPAN, m_fDoRestartOnTime);
   DDX_Control(pDX, IDC_RECYCLE_TIMESPAN, m_bnt_DoRestartOnTime);
   // This Needs to come before DDX_Text which will try to put text big number into small number
   DDV_MinMaxBalloon(pDX, IDC_TIMESPAN, TIMESPAN_MIN, TIMESPAN_MAX);
   DDX_TextBalloon(pDX, IDC_TIMESPAN, m_dwPeriodicRestartTime);
   DDX_Control(pDX, IDC_TIMESPAN, m_Timespan);
   DDX_Control(pDX, IDC_TIMESPAN_SPIN, m_TimespanSpin);
   DDX_Check(pDX, IDC_RECYCLE_REQUESTS, m_fDoRestartOnCount);
   DDX_Control(pDX, IDC_RECYCLE_REQUESTS, m_btn_DoRestartOnCount);
   // This Needs to come before DDX_Text which will try to put text big number into small number
   DDV_MinMaxBalloon(pDX, IDC_REQUEST_LIMIT, REQUESTS_MIN, REQUESTS_MAX);
   DDX_TextBalloon(pDX, IDC_REQUEST_LIMIT, m_dwRestartRequestCount);
   DDX_Control(pDX, IDC_REQUEST_LIMIT, m_Requests);
   DDX_Control(pDX, IDC_REQUESTS_SPIN, m_RequestsSpin);
   DDX_Check(pDX, IDC_RECYCLE_TIMER, m_fDoRestartOnSchedule);
   DDX_Control(pDX, IDC_RECYCLE_TIMER, m_btn_DoRestartOnSchedule);
   DDX_Control(pDX, IDC_TIMES_LIST, m_lst_Schedule);
   DDX_Control(pDX, IDC_ADD_TIME, m_btn_Add);
   DDX_Control(pDX, IDC_DELETE_TIME, m_btn_Remove);
   DDX_Control(pDX, IDC_CHANGE_TIME, m_btn_Edit);

   DDX_Check(pDX, IDC_RECYCLE_VMEMORY, m_fDoRestartOnVMemory);
   DDX_Control(pDX, IDC_RECYCLE_VMEMORY, m_btn_DoRestartOnVMemory);
   // This Needs to come before DDX_Text which will try to put text big number into small number
   DDV_MinMaxBalloon(pDX, IDC_VMEMORY_LIMIT, VMEMORY_MIN, VMEMORY_MAX);
   DDX_TextBalloon(pDX, IDC_VMEMORY_LIMIT, m_dwPeriodicRestartVMemoryDisplay);
   DDX_Control(pDX, IDC_VMEMORY_LIMIT, m_VMemoryLimit);
   DDX_Control(pDX, IDC_VMEMORY_SPIN, m_VMemoryLimitSpin);

   DDX_Check(pDX, IDC_RECYCLE_UMEMORY, m_fDoRestartOnUMemory);
   DDX_Control(pDX, IDC_RECYCLE_UMEMORY, m_btn_DoRestartOnUMemory);
   // This Needs to come before DDX_Text which will try to put text big number into small number
   DDV_MinMaxBalloon(pDX, IDC_UMEMORY_LIMIT, UMEMORY_MIN, UMEMORY_MAX);
   DDX_TextBalloon(pDX, IDC_UMEMORY_LIMIT, m_dwPeriodicRestartUMemoryDisplay);
   DDX_Control(pDX, IDC_UMEMORY_LIMIT, m_UMemoryLimit);
   DDX_Control(pDX, IDC_UMEMORY_SPIN, m_UMemoryLimitSpin);
   //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAppPoolRecycle, CInetPropertyPage)
    //{{AFX_MSG_MAP(CAppPoolRecycle)
    ON_WM_COMPAREITEM()
    ON_WM_MEASUREITEM()
    ON_WM_DRAWITEM()
    ON_BN_CLICKED(IDC_RECYCLE_TIMESPAN, OnDoRestartOnTime)
    ON_BN_CLICKED(IDC_RECYCLE_REQUESTS, OnDoRestartOnCount)
    ON_BN_CLICKED(IDC_RECYCLE_TIMER, OnDoRestartOnSchedule)
    ON_BN_CLICKED(IDC_RECYCLE_VMEMORY, OnDoRestartOnVMemory)
    ON_BN_CLICKED(IDC_RECYCLE_UMEMORY, OnDoRestartOnUMemory)
    ON_BN_CLICKED(IDC_ADD_TIME, OnAddTime)
    ON_BN_CLICKED(IDC_DELETE_TIME, OnDeleteTime)
    ON_BN_CLICKED(IDC_CHANGE_TIME, OnChangeTime)
    ON_EN_CHANGE(IDC_TIMESPAN, OnItemChanged)
    ON_EN_CHANGE(IDC_REQUEST_LIMIT, OnItemChanged)
    ON_EN_CHANGE(IDC_VMEMORY_LIMIT, OnItemChanged)
    ON_EN_CHANGE(IDC_UMEMORY_LIMIT, OnItemChanged)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL
CAppPoolRecycle::OnInitDialog()
{
   UDACCEL toAcc[3] = {{1, 1}, {3, 5}, {6, 10}};

   CInetPropertyPage::OnInitDialog();

   SETUP_EDIT_SPIN(m_fDoRestartOnTime, m_Timespan, m_TimespanSpin, 
      TIMESPAN_MIN, TIMESPAN_MAX, m_dwPeriodicRestartTime);
   SETUP_EDIT_SPIN(m_fDoRestartOnCount, m_Requests, m_RequestsSpin, 
      REQUESTS_MIN, REQUESTS_MAX, m_dwRestartRequestCount);
   SETUP_EDIT_SPIN(m_fDoRestartOnVMemory, m_VMemoryLimit, m_VMemoryLimitSpin, 
      VMEMORY_MIN, VMEMORY_MAX, m_dwPeriodicRestartVMemoryDisplay);
   SETUP_EDIT_SPIN(m_fDoRestartOnUMemory, m_UMemoryLimit, m_UMemoryLimitSpin, 
      UMEMORY_MIN, UMEMORY_MAX, m_dwPeriodicRestartUMemoryDisplay);

   POSITION pos = m_RestartSchedule.GetHeadPosition();
   while (pos != NULL)
   {
      CString& str = m_RestartSchedule.GetNext(pos);
      m_lst_Schedule.AddString(str);
   }
   m_lst_Schedule.SetCurSel(0);

   SetControlsState();

   return TRUE;
}

void
CAppPoolRecycle::SetControlsState()
{
   m_Timespan.EnableWindow(m_fDoRestartOnTime);
   m_TimespanSpin.EnableWindow(m_fDoRestartOnTime);

   m_Requests.EnableWindow(m_fDoRestartOnCount);
   m_RequestsSpin.EnableWindow(m_fDoRestartOnCount);

   m_VMemoryLimit.EnableWindow(m_fDoRestartOnVMemory);
   m_VMemoryLimitSpin.EnableWindow(m_fDoRestartOnVMemory);

   m_UMemoryLimit.EnableWindow(m_fDoRestartOnUMemory);
   m_UMemoryLimitSpin.EnableWindow(m_fDoRestartOnUMemory);

   m_lst_Schedule.EnableWindow(m_fDoRestartOnSchedule);
   m_btn_Add.EnableWindow(m_fDoRestartOnSchedule);
   int idx = m_lst_Schedule.GetCurSel();
   m_btn_Remove.EnableWindow(m_fDoRestartOnSchedule && idx != LB_ERR);
   m_btn_Edit.EnableWindow(m_fDoRestartOnSchedule && idx != LB_ERR);
}

void
CAppPoolRecycle::OnItemChanged()
{
    SetModified(TRUE);
}

int
CAppPoolRecycle::OnCompareItem(UINT nID, LPCOMPAREITEMSTRUCT cmpi)
{
   if (nID == IDC_TIMES_LIST)
   {
      ASSERT(cmpi->CtlType == ODT_LISTBOX);
      LPCTSTR p1 = (LPCTSTR)cmpi->itemData1;
      LPCTSTR p2 = (LPCTSTR)cmpi->itemData2;
      return StrCmp(p1, p2);
   }
   ASSERT(FALSE);
   return 0;
}

void
CAppPoolRecycle::OnMeasureItem(UINT nID, LPMEASUREITEMSTRUCT mi)
{
   if (nID == IDC_TIMES_LIST)
   {
      HWND hwnd = ::GetDlgItem(m_hWnd, IDC_TIMES_LIST);
      HDC hdc = ::GetDC(hwnd);
      HFONT hFont = (HFONT)SendDlgItemMessage(IDC_TIMES_LIST, WM_GETFONT, 0, 0);
      HFONT hf = (HFONT)::SelectObject(hdc, hFont);
      TEXTMETRIC tm;
      ::GetTextMetrics(hdc, &tm);
      ::SelectObject(hdc, hf);
      ::ReleaseDC(hwnd, hdc);
      RECT rc;
      ::GetClientRect(hwnd, &rc);
      mi->itemHeight = tm.tmHeight;
      mi->itemWidth = rc.right - rc.left;
   }
}

void
CAppPoolRecycle::OnDrawItem(UINT nID, LPDRAWITEMSTRUCT di)
{
   if (nID == IDC_TIMES_LIST && di->itemID != -1)
   {
      LPCTSTR p = (LPCTSTR)di->itemData;
      HBRUSH hBrush;
      COLORREF prevText;
	  COLORREF prevBk;
      switch (di->itemAction) 
      { 
      case ODA_SELECT: 
      case ODA_DRAWENTIRE: 
         if (di->itemState & ODS_SELECTED) 
         {
            hBrush = ::CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT));
            prevText = ::SetTextColor(di->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
            prevBk = ::SetBkColor(di->hDC, GetSysColor(COLOR_HIGHLIGHT));
         }
         else
         {
            hBrush = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
            prevText = ::SetTextColor(di->hDC, GetSysColor(COLOR_WINDOWTEXT));
            prevBk = ::SetBkColor(di->hDC, GetSysColor(COLOR_WINDOW));
         }
         ::FillRect(di->hDC, &di->rcItem, hBrush);
         ::DrawText(di->hDC, p, -1, &di->rcItem, DT_LEFT | DT_VCENTER | DT_EXTERNALLEADING);
         ::SetTextColor(di->hDC, prevText);
         ::SetTextColor(di->hDC, prevBk);
         ::DeleteObject(hBrush);
         break; 
       
      case ODA_FOCUS: 
         break; 
      } 
   }
}

void
CAppPoolRecycle::OnDoRestartOnTime()
{
   m_fDoRestartOnTime = !m_fDoRestartOnTime;
   SetControlsState();
   SetModified(TRUE);
}

void
CAppPoolRecycle::OnDoRestartOnCount()
{
   m_fDoRestartOnCount = !m_fDoRestartOnCount;
   SetControlsState();
   SetModified(TRUE);
}

void
CAppPoolRecycle::OnDoRestartOnSchedule()
{
   m_fDoRestartOnSchedule = !m_fDoRestartOnSchedule;
   SetControlsState();
   SetModified(TRUE);
}

void
CAppPoolRecycle::OnDoRestartOnVMemory()
{
   m_fDoRestartOnVMemory = !m_fDoRestartOnVMemory;
   SetControlsState();
   SetModified(TRUE);
}

void
CAppPoolRecycle::OnDoRestartOnUMemory()
{
   m_fDoRestartOnUMemory = !m_fDoRestartOnUMemory;
   SetControlsState();
   SetModified(TRUE);
}

class CTimePickerDlg : public CDialog
{
   DECLARE_DYNCREATE(CTimePickerDlg)

public:
   CTimePickerDlg()
      : CDialog(CTimePickerDlg::IDD),
      m_TopLeft(0, 0)
   {
   }
   ~CTimePickerDlg()
   {
   }
   void SetTime(CTime& tm)
   {
      m_time = tm;
   }
   CTime& GetTime()
   {
      return m_time;
   }
   void SetPos(const CPoint& pt)
   {
      m_TopLeft = pt;
   }

//
// Dialog Data
//
protected:
   //{{AFX_DATA(CTimePickerDlg)
   enum {IDD = IDD_TIME_PICKER};
   CDateTimeCtrl m_Timer;
   CTime m_time;
   //}}AFX_DATA
   CPoint m_TopLeft;

   //{{AFX_MSG(CTimePickerDlg)
   BOOL OnInitDialog();
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()

protected:
    //{{AFX_VIRTUAL(CTimePickerDlg)
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL
};

void
CTimePickerDlg::DoDataExchange(CDataExchange * pDX)
{
   CDialog::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CAppPoolRecycle)
   DDX_DateTimeCtrl(pDX, IDC_TIME_PICKER, m_time);
   DDX_Control(pDX, IDC_TIME_PICKER, m_Timer);
   //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CTimePickerDlg, CDialog)
    //{{AFX_MSG_MAP(CTimePickerDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

IMPLEMENT_DYNCREATE(CTimePickerDlg, CDialog)

BOOL
CTimePickerDlg::OnInitDialog()
{
   CDialog::OnInitDialog();

   m_Timer.SetFormat(_T("HH:mm"));
   m_Timer.SetTime(&m_time);
   SetWindowPos(NULL, m_TopLeft.x, m_TopLeft.y, 0, 0, SWP_NOSIZE | SWP_NOZORDER);

   return TRUE;
}

void
CAppPoolRecycle::OnAddTime()
{
   CTimePickerDlg dlg;
   RECT rc;
   m_btn_Add.GetWindowRect(&rc);
   dlg.SetPos(CPoint(rc.left, rc.bottom));
   dlg.SetTime(CTime::GetCurrentTime());
   if (dlg.DoModal() == IDOK)
   {
      int idx;
      TCHAR buf[6];
      CTime tm = dlg.GetTime();
      wsprintf(buf, _T("%02d:%02d"), tm.GetHour(), tm.GetMinute());
      if ((idx = m_lst_Schedule.FindString(-1, buf)) == LB_ERR)
      {
	     idx = m_lst_Schedule.AddString(StrDup(buf));
         m_lst_Schedule.SetCurSel(idx);
         m_btn_Edit.EnableWindow(idx != LB_ERR);
         m_btn_Remove.EnableWindow(idx != LB_ERR);
         SetModified(idx != LB_ERR);
      }
      m_lst_Schedule.SetCurSel(idx);
   }
}

void
CAppPoolRecycle::OnChangeTime()
{
   CTimePickerDlg dlg;
   RECT rc;
   m_btn_Edit.GetWindowRect(&rc);
   dlg.SetPos(CPoint(rc.left, rc.bottom));
   int idx = m_lst_Schedule.GetCurSel();
   CString ts = (LPCTSTR)m_lst_Schedule.GetItemDataPtr(idx);
   // Looks like we have to init the struct properly
   SYSTEMTIME tm;
   ::GetSystemTime(&tm);
   int n = ts.Find(_T(':'));
   int len = ts.GetLength();
   tm.wMinute = (WORD)StrToInt(ts.Right(len - n - 1));
   tm.wHour = (WORD)StrToInt(ts.Left(n));
   tm.wSecond = 0;
   dlg.SetTime(CTime(tm));
   if (dlg.DoModal() == IDOK)
   {
      CTime time = dlg.GetTime();
      TCHAR buf[6];
      wsprintf(buf, _T("%02d:%02d"), time.GetHour(), time.GetMinute());
	  int idx2;
      if ((idx2 = m_lst_Schedule.FindString(-1, buf)) == LB_ERR)
      {
         m_lst_Schedule.DeleteString(idx);
	     idx2 = m_lst_Schedule.AddString(StrDup(buf));
		 m_lst_Schedule.GetItemRect(idx2, &rc);
		 m_lst_Schedule.InvalidateRect(&rc, TRUE);
		 SetModified(TRUE);
	  }
	  m_lst_Schedule.SetCurSel(idx2);
   }
}

void
CAppPoolRecycle::OnDeleteTime()
{
   int idx = m_lst_Schedule.GetCurSel();
   int count;
   if (idx != LB_ERR)
   {
      m_lst_Schedule.DeleteString(idx);
      SetModified(TRUE);
      if ((count = m_lst_Schedule.GetCount()) == 0)
      {
         m_btn_Remove.EnableWindow(FALSE);
         m_btn_Edit.EnableWindow(FALSE);
      }
      else
      {
         m_lst_Schedule.SetCurSel(idx == count ? --idx : idx);
      }
   }
}

//////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CAppPoolPerf, CInetPropertyPage)

CAppPoolPerf::CAppPoolPerf(CInetPropertySheet * pSheet)
    : CInetPropertyPage(CAppPoolPerf::IDD, pSheet),
    m_fDoIdleShutdown(FALSE),
    m_dwIdleTimeout(IDLE_TIMEOUT_DEF),
    m_fDoLimitQueue(FALSE),
    m_dwQueueSize(QUEUE_SIZE_DEF),
    m_fDoEnableCPUAccount(FALSE),
    m_dwMaxCPU_Use(CPU_USE_DEF * 1000),
    m_dwRefreshTime(0),
    m_ActionIndex(ACTION_INDEX_DEF),
    m_dwMaxProcesses(MAX_PROCESSES_DEF)
{
}

CAppPoolPerf::~CAppPoolPerf()
{
}

/* virtual */
HRESULT
CAppPoolPerf::FetchLoadedValues()
{
   CError err;

   BEGIN_META_INST_READ(CAppPoolSheet)
      FETCH_INST_DATA_FROM_SHEET(m_dwIdleTimeout);
      FETCH_INST_DATA_FROM_SHEET(m_dwQueueSize);
      FETCH_INST_DATA_FROM_SHEET(m_dwMaxCPU_Use);
      FETCH_INST_DATA_FROM_SHEET(m_dwRefreshTime);
      FETCH_INST_DATA_FROM_SHEET(m_dwMaxProcesses);
      FETCH_INST_DATA_FROM_SHEET(m_ActionIndex);
   END_META_INST_READ(err)

   m_fDoIdleShutdown = m_dwIdleTimeout != 0;
   if (!m_fDoIdleShutdown)
   {
       m_dwIdleTimeout = IDLE_TIMEOUT_DEF;
   }
   m_fDoLimitQueue = m_dwQueueSize != (DWORD)65535;
   if (!m_fDoLimitQueue)
   {
       m_dwQueueSize = QUEUE_SIZE_DEF;
   }
   m_fDoEnableCPUAccount = m_dwMaxCPU_Use > 0 /*&& m_dwRefreshTime > 0*/;
   if (!m_fDoEnableCPUAccount)
   {
       m_dwMaxCPU_UseVisual = CPU_USE_DEF;
       m_dwRefreshTime = CPU_RESET_TIME_DEF;
       m_ActionIndex = ACTION_INDEX_DEF;
   }
   else
   {
	   m_dwMaxCPU_UseVisual = m_dwMaxCPU_Use / 1000;
   }

   return err;
}

/* virtual */
HRESULT
CAppPoolPerf::SaveInfo()
{
   ASSERT(IsDirty());
   CError err;

   m_dwMaxCPU_Use = m_dwMaxCPU_UseVisual * 1000;

   DWORD t = m_dwIdleTimeout;
   DWORD q = m_dwQueueSize;
   DWORD r = m_dwRefreshTime;

   BEGIN_META_INST_WRITE(CAppPoolSheet)
      if (!m_fDoIdleShutdown)
      { 
         m_dwIdleTimeout = 0;
	  }
      if (!m_fDoLimitQueue)
	  {
         m_dwQueueSize = (DWORD)65535;
	  }
      if (!m_fDoEnableCPUAccount)
      {
//         m_dwRefreshTime = 0;
         m_dwMaxCPU_Use = 0;
      }
      STORE_INST_DATA_ON_SHEET(m_dwQueueSize)
      STORE_INST_DATA_ON_SHEET(m_dwIdleTimeout)
      STORE_INST_DATA_ON_SHEET(m_dwRefreshTime)
      STORE_INST_DATA_ON_SHEET(m_dwMaxCPU_Use)
      STORE_INST_DATA_ON_SHEET(m_ActionIndex)
      STORE_INST_DATA_ON_SHEET(m_dwMaxProcesses)
   END_META_INST_WRITE(err)

   m_dwQueueSize = q;
   m_dwIdleTimeout = t;
   m_dwRefreshTime = r;

   return err;
}

void
CAppPoolPerf::DoDataExchange(CDataExchange * pDX)
{
   CInetPropertyPage::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CAppPoolRecycle)
   DDX_Check(pDX, IDC_PERF_IDLE_TIMEOUT, m_fDoIdleShutdown);
   DDX_Control(pDX, IDC_PERF_IDLE_TIMEOUT, m_bnt_DoIdleShutdown);
   // This Needs to come before DDX_Text which will try to put text big number into small number
   DDV_MinMaxBalloon(pDX, IDC_IDLETIME, TIMEOUT_MIN, TIMEOUT_MAX);
   DDX_TextBalloon(pDX, IDC_IDLETIME, m_dwIdleTimeout);
   DDX_Control(pDX, IDC_IDLETIME, m_IdleTimeout);
   DDX_Control(pDX, IDC_IDLETIME_SPIN, m_IdleTimeoutSpin);

   DDX_Check(pDX, IDC_LIMIT_QUEUE, m_fDoLimitQueue);
   DDX_Control(pDX, IDC_LIMIT_QUEUE, m_btn_DoLimitQueue);
   // This Needs to come before DDX_Text which will try to put text big number into small number
   DDV_MinMaxBalloon(pDX, IDC_QUEUESIZE, QUEUESIZE_MIN, QUEUESIZE_MAX); 
   DDX_TextBalloon(pDX, IDC_QUEUESIZE, m_dwQueueSize);
   DDX_Control(pDX, IDC_QUEUESIZE, m_QueueSize);
   DDX_Control(pDX, IDC_QUEUESIZE_SPIN, m_QueueSizeSpin);

   DDX_Check(pDX, IDC_ENABLE_CPU_ACCOUNTING, m_fDoEnableCPUAccount);
   DDX_Control(pDX, IDC_ENABLE_CPU_ACCOUNTING, m_btn_DoEnableCPUAccount);
   // This Needs to come before DDX_Text which will try to put text big number into small number
   DDV_MinMaxBalloon(pDX, IDC_CPU_USE, CPU_LIMIT_MIN, CPU_LIMIT_MAX); 
   DDX_TextBalloon(pDX, IDC_CPU_USE, m_dwMaxCPU_UseVisual);
   DDX_Control(pDX, IDC_CPU_USE, m_MaxCPU_Use);
   DDX_Control(pDX, IDC_CPU_USE_SPIN, m_MaxCPU_UseSpin);
   // This Needs to come before DDX_Text which will try to put text big number into small number
   DDV_MinMaxBalloon(pDX, IDC_REFRESHTIME, CPU_RESET_TIME_MIN, CPU_RESET_TIME_MAX);
   DDX_TextBalloon(pDX, IDC_REFRESHTIME, m_dwRefreshTime);
   DDX_Control(pDX, IDC_REFRESHTIME, m_RefreshTime);
   DDX_Control(pDX, IDC_REFRESHTIME_SPIN, m_RefreshTimeSpin);
   DDX_Control(pDX, IDC_EXCEED_ACTION, m_Action);
   DDX_CBIndex(pDX, IDC_EXCEED_ACTION, m_ActionIndex);

   // This Needs to come before DDX_Text which will try to put text big number into small number
   DDV_MinMaxBalloon(pDX, IDC_MAXPROCESSES, MAXPROCESSES_MIN, MAXPROCESSES_MAX);
   DDX_TextBalloon(pDX, IDC_MAXPROCESSES, m_dwMaxProcesses);
   DDX_Control(pDX, IDC_MAXPROCESSES, m_MaxProcesses);
   DDX_Control(pDX, IDC_MAXPROCESSES_SPIN, m_MaxProcessesSpin);
   //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAppPoolPerf, CInetPropertyPage)
    //{{AFX_MSG_MAP(CAppPoolRecycle)
    ON_BN_CLICKED(IDC_PERF_IDLE_TIMEOUT, OnDoIdleShutdown)
    ON_BN_CLICKED(IDC_LIMIT_QUEUE, OnDoLimitQueue)
    ON_BN_CLICKED(IDC_ENABLE_CPU_ACCOUNTING, OnDoEnableCPUAccount)
    ON_EN_CHANGE(IDC_IDLETIME, OnItemChanged)
    ON_EN_CHANGE(IDC_QUEUESIZE, OnItemChanged)
    ON_EN_CHANGE(IDC_CPU_USE, OnItemChanged)
    ON_EN_CHANGE(IDC_REFRESHTIME, OnItemChanged)
    ON_EN_CHANGE(IDC_MAXPROCESSES, OnItemChanged)
    ON_CBN_SELCHANGE(IDC_EXCEED_ACTION, OnItemChanged)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL
CAppPoolPerf::OnInitDialog()
{
   UDACCEL toAcc[3] = {{1, 1}, {3, 5}, {6, 10}};

   CInetPropertyPage::OnInitDialog();

   SETUP_EDIT_SPIN(m_fDoIdleShutdown, m_IdleTimeout, m_IdleTimeoutSpin, 
      TIMEOUT_MIN, TIMEOUT_MAX, m_dwIdleTimeout);
   SETUP_EDIT_SPIN(m_fDoLimitQueue, m_QueueSize, m_QueueSizeSpin, 
      QUEUESIZE_MIN, QUEUESIZE_MAX, m_dwQueueSize);
   SETUP_EDIT_SPIN(m_fDoEnableCPUAccount, m_MaxCPU_Use, m_MaxCPU_UseSpin, 
      CPU_LIMIT_MIN, CPU_LIMIT_MAX, m_dwMaxCPU_UseVisual);
   SETUP_EDIT_SPIN(m_fDoEnableCPUAccount, m_RefreshTime, m_RefreshTimeSpin, 
      REFRESH_TIME_MIN, REFRESH_TIME_MAX, m_dwRefreshTime);
   SETUP_SPIN(m_MaxProcessesSpin, 
      MAXPROCESSES_MIN, MAXPROCESSES_MAX, m_dwMaxProcesses);

   CString str;
   str.LoadString(IDS_NO_ACTION);
   m_Action.AddString(str);
//   str.LoadString(IDS_THROTTLE_BACK);
//   m_Action.AddString(str);
//   str.LoadString(IDS_TURN_ON_TRACING);
//   m_Action.AddString(str);
   str.LoadString(IDS_SHUTDOWN);
   m_Action.AddString(str);
   if (m_ActionIndex < 0 || m_ActionIndex > 1)
       m_ActionIndex = ACTION_INDEX_DEF; 
   m_Action.SetCurSel(m_ActionIndex);

   SetControlsState();

   return TRUE;
}

void
CAppPoolPerf::OnDoIdleShutdown()
{
   m_fDoIdleShutdown = !m_fDoIdleShutdown;
   SetControlsState();
   SetModified(TRUE);
}

void
CAppPoolPerf::OnDoLimitQueue()
{
   m_fDoLimitQueue = !m_fDoLimitQueue;
   SetControlsState();
   SetModified(TRUE);
}

void
CAppPoolPerf::OnDoEnableCPUAccount()
{
   m_fDoEnableCPUAccount = !m_fDoEnableCPUAccount;
   SetControlsState();
   SetModified(TRUE);
}

void
CAppPoolPerf::OnItemChanged()
{
    SetModified(TRUE);
}

void
CAppPoolPerf::SetControlsState()
{
   m_bnt_DoIdleShutdown.SetCheck(m_fDoIdleShutdown);
   m_IdleTimeout.EnableWindow(m_fDoIdleShutdown);
   m_IdleTimeoutSpin.EnableWindow(m_fDoIdleShutdown);

   m_btn_DoLimitQueue.SetCheck(m_fDoLimitQueue);
   m_QueueSize.EnableWindow(m_fDoLimitQueue);
   m_QueueSizeSpin.EnableWindow(m_fDoLimitQueue);

   m_btn_DoEnableCPUAccount.SetCheck(m_fDoEnableCPUAccount);
   m_MaxCPU_Use.EnableWindow(m_fDoEnableCPUAccount);
   m_MaxCPU_UseSpin.EnableWindow(m_fDoEnableCPUAccount);
   m_RefreshTime.EnableWindow(m_fDoEnableCPUAccount);
   m_RefreshTimeSpin.EnableWindow(m_fDoEnableCPUAccount);
   m_Action.EnableWindow(m_fDoEnableCPUAccount);
}

/////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CAppPoolHealth, CInetPropertyPage)

CAppPoolHealth::CAppPoolHealth(CInetPropertySheet * pSheet)
    : CInetPropertyPage(CAppPoolHealth::IDD, pSheet),
    m_fDoEnablePing(TRUE),
    m_dwPingInterval(PING_INTERVAL_DEF),
    m_fDoEnableRapidFail(TRUE),
    m_dwCrashesCount(CRASHES_COUNT_DEF),
    m_dwCheckInterval(CHECK_INTERVAL_DEF),
    m_dwStartupLimit(STARTUP_LIMIT_DEF),
    m_dwShutdownLimit(SHUTDOWN_LIMIT_DEF)
{
}

CAppPoolHealth::~CAppPoolHealth()
{
}

/* virtual */
HRESULT
CAppPoolHealth::FetchLoadedValues()
{
   CError err;

   BEGIN_META_INST_READ(CAppPoolSheet)
      FETCH_INST_DATA_FROM_SHEET(m_fDoEnablePing);
      FETCH_INST_DATA_FROM_SHEET(m_dwPingInterval);
      FETCH_INST_DATA_FROM_SHEET(m_fDoEnableRapidFail);
      FETCH_INST_DATA_FROM_SHEET(m_dwCrashesCount);
      FETCH_INST_DATA_FROM_SHEET(m_dwCheckInterval);
      FETCH_INST_DATA_FROM_SHEET(m_dwStartupLimit);
      FETCH_INST_DATA_FROM_SHEET(m_dwShutdownLimit);
   END_META_INST_READ(err)

   return err;
}

/* virtual */
HRESULT
CAppPoolHealth::SaveInfo()
{
   ASSERT(IsDirty());
   CError err;

   BEGIN_META_INST_WRITE(CAppPoolSheet)
      STORE_INST_DATA_ON_SHEET(m_fDoEnablePing);
      STORE_INST_DATA_ON_SHEET(m_dwPingInterval);
      STORE_INST_DATA_ON_SHEET(m_fDoEnableRapidFail);
      STORE_INST_DATA_ON_SHEET(m_dwCrashesCount);
      STORE_INST_DATA_ON_SHEET(m_dwCheckInterval);
      STORE_INST_DATA_ON_SHEET(m_dwStartupLimit);
      STORE_INST_DATA_ON_SHEET(m_dwShutdownLimit);
   END_META_INST_WRITE(err)

   return err;
}

void
CAppPoolHealth::DoDataExchange(CDataExchange * pDX)
{
   CInetPropertyPage::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CAppPoolHealth)
   DDX_Check(pDX, IDC_ENABLE_PING, m_fDoEnablePing);
   DDX_Control(pDX, IDC_ENABLE_PING, m_bnt_DoEnablePing);
   // This Needs to come before DDX_Text which will try to put text big number into small number
   DDV_MinMaxBalloon(pDX, IDC_PINGINTERVAL, PING_INTERVAL_MIN, PING_INTERVAL_MAX);
   DDX_TextBalloon(pDX, IDC_PINGINTERVAL, m_dwPingInterval);
   DDX_Control(pDX, IDC_PINGINTERVAL, m_PingInterval);
   DDX_Control(pDX, IDC_PINGINTERVAL_SPIN, m_PingIntervalSpin);

   DDX_Check(pDX, IDC_ENABLE_RAPID_FAIL, m_fDoEnableRapidFail);
   DDX_Control(pDX, IDC_ENABLE_RAPID_FAIL, m_btn_DoEnableRapidFail);
   // This Needs to come before DDX_Text which will try to put text big number into small number
   DDV_MinMaxBalloon(pDX, IDC_CRASHES_COUNT, CRASHES_COUNT_MIN, CRASHES_COUNT_MAX);
   DDX_TextBalloon(pDX, IDC_CRASHES_COUNT, m_dwCrashesCount);
   DDX_Control(pDX, IDC_CRASHES_COUNT, m_CrashesCount);
   DDX_Control(pDX, IDC_CRASHES_COUNT_SPIN, m_CrashesCountSpin);
   // This Needs to come before DDX_Text which will try to put text big number into small number
   DDV_MinMaxBalloon(pDX, IDC_CHECK_TIME, CHECK_INTERVAL_MIN, CHECK_INTERVAL_MAX);
   DDX_TextBalloon(pDX, IDC_CHECK_TIME, m_dwCheckInterval);
   DDX_Control(pDX, IDC_CHECK_TIME, m_CheckInterval);
   DDX_Control(pDX, IDC_CHECK_TIME_SPIN, m_CheckIntervalSpin);

   // This Needs to come before DDX_Text which will try to put text big number into small number
   DDV_MinMaxBalloon(pDX, IDC_STARTUP_LIMIT, STARTUP_LIMIT_MIN, STARTUP_LIMIT_MAX);
   DDX_TextBalloon(pDX, IDC_STARTUP_LIMIT, m_dwStartupLimit);
   DDX_Control(pDX, IDC_STARTUP_LIMIT, m_StartupLimit);
   DDX_Control(pDX, IDC_STARTUP_LIMIT_SPIN, m_StartupLimitSpin);

   // This Needs to come before DDX_Text which will try to put text big number into small number
   DDV_MinMaxBalloon(pDX, IDC_SHUTDOWN_LIMIT, SHUTDOWN_LIMIT_MIN, SHUTDOWN_LIMIT_MAX);
   DDX_TextBalloon(pDX, IDC_SHUTDOWN_LIMIT, m_dwShutdownLimit);
   DDX_Control(pDX, IDC_SHUTDOWN_LIMIT, m_ShutdownLimit);
   DDX_Control(pDX, IDC_SHUTDOWN_LIMIT_SPIN, m_ShutdownLimitSpin);
   //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAppPoolHealth, CInetPropertyPage)
    //{{AFX_MSG_MAP(CAppPoolHealth)
    ON_BN_CLICKED(IDC_ENABLE_PING, OnDoEnablePinging)
    ON_BN_CLICKED(IDC_ENABLE_RAPID_FAIL, OnDoEnableRapidFail)
    ON_EN_CHANGE(IDC_PINGINTERVAL, OnItemChanged)
    ON_EN_CHANGE(IDC_CRASHES_COUNT, OnItemChanged)
    ON_EN_CHANGE(IDC_CHECK_TIME, OnItemChanged)
    ON_EN_CHANGE(IDC_STARTUP_LIMIT, OnItemChanged)
    ON_EN_CHANGE(IDC_SHUTDOWN_LIMIT, OnItemChanged)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL
CAppPoolHealth::OnInitDialog()
{
   UDACCEL toAcc[3] = {{1, 1}, {3, 5}, {6, 10}};

   CInetPropertyPage::OnInitDialog();

   SETUP_EDIT_SPIN(m_fDoEnablePing, m_PingInterval, m_PingIntervalSpin, 
      PING_INTERVAL_MIN, PING_INTERVAL_MAX, m_dwPingInterval);
   SETUP_EDIT_SPIN(m_fDoEnableRapidFail, m_CrashesCount, m_CrashesCountSpin, 
      CRASHES_COUNT_MIN, CRASHES_COUNT_MAX, m_dwCrashesCount);
   SETUP_EDIT_SPIN(m_fDoEnableRapidFail, m_CheckInterval, m_CheckIntervalSpin, 
      CHECK_INTERVAL_MIN, CHECK_INTERVAL_MAX, m_dwCheckInterval);
   SETUP_SPIN(m_StartupLimitSpin, 
      STARTUP_LIMIT_MIN, STARTUP_LIMIT_MAX, m_dwStartupLimit);
   SETUP_SPIN(m_ShutdownLimitSpin, 
      SHUTDOWN_LIMIT_MIN, SHUTDOWN_LIMIT_MAX, m_dwShutdownLimit);

   return TRUE;
}

void
CAppPoolHealth::OnDoEnablePinging()
{
   m_fDoEnablePing = !m_fDoEnablePing;
   m_bnt_DoEnablePing.SetCheck(m_fDoEnablePing);
   m_PingInterval.EnableWindow(m_fDoEnablePing);
   m_PingIntervalSpin.EnableWindow(m_fDoEnablePing);
   SetModified(TRUE);
}

void
CAppPoolHealth::OnDoEnableRapidFail()
{
   m_fDoEnableRapidFail = !m_fDoEnableRapidFail;
   m_btn_DoEnableRapidFail.SetCheck(m_fDoEnableRapidFail);
   m_CrashesCount.EnableWindow(m_fDoEnableRapidFail);
   m_CrashesCountSpin.EnableWindow(m_fDoEnableRapidFail);
   m_CheckInterval.EnableWindow(m_fDoEnableRapidFail);
   m_CheckIntervalSpin.EnableWindow(m_fDoEnableRapidFail);
   SetModified(TRUE);
}

void
CAppPoolHealth::OnItemChanged()
{
   SetModified(TRUE);
}

///////////////////////////////////////////////////////////////////////////////////////////
#if 0
IMPLEMENT_DYNCREATE(CAppPoolDebug, CInetPropertyPage)

CAppPoolDebug::CAppPoolDebug(CInetPropertySheet * pSheet)
    : CInetPropertyPage(CAppPoolDebug::IDD, pSheet),
    m_fDoEnableDebug(TRUE)
{
}

CAppPoolDebug::~CAppPoolDebug()
{
}

/* virtual */
HRESULT
CAppPoolDebug::FetchLoadedValues()
{
   CError err;

   BEGIN_META_INST_READ(CAppPoolSheet)
      FETCH_INST_DATA_FROM_SHEET(m_fDoEnableDebug);
      FETCH_INST_DATA_FROM_SHEET(m_DebuggerFileName);
      FETCH_INST_DATA_FROM_SHEET(m_DebuggerParams);
   END_META_INST_READ(err)

   return err;
}

/* virtual */
HRESULT
CAppPoolDebug::SaveInfo()
{
   ASSERT(IsDirty());
   CError err;

   BEGIN_META_INST_WRITE(CAppPoolSheet)
      STORE_INST_DATA_ON_SHEET(m_fDoEnableDebug);
      STORE_INST_DATA_ON_SHEET(m_DebuggerFileName);
      STORE_INST_DATA_ON_SHEET(m_DebuggerParams);
   END_META_INST_WRITE(err)

   return err;
}

void
CAppPoolDebug::DoDataExchange(CDataExchange * pDX)
{
   CInetPropertyPage::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CAppPoolHealth)
   DDX_Check(pDX, IDC_ENABLE_DEBUG, m_fDoEnableDebug);
   DDX_Control(pDX, IDC_ENABLE_DEBUG, m_bnt_DoEnableDebug);
   DDX_Control(pDX, IDC_FILE_NAME, m_FileName);
   DDX_Control(pDX, IDC_BROWSE, m_Browse);
   DDX_Text(pDX, IDC_PARAMETERS, m_DebuggerParams);
   DDX_Control(pDX, IDC_PARAMETERS, m_Params);
   //}}AFX_DATA_MAP
   DDX_Text(pDX, IDC_FILE_NAME, m_DebuggerFileName);
   if (pDX->m_bSaveAndValidate && m_fDoEnableDebug)
   {
	   DDV_FilePath(pDX, m_DebuggerFileName, GetSheet()->IsLocal());
   }
}

BEGIN_MESSAGE_MAP(CAppPoolDebug, CInetPropertyPage)
    //{{AFX_MSG_MAP(CAppPoolHealth)
    ON_BN_CLICKED(IDC_ENABLE_DEBUG, OnDoEnableDebug)
    ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
    ON_EN_CHANGE(IDC_FILE_NAME, OnItemChanged)
    ON_EN_CHANGE(IDC_PARAMETERS, OnItemChanged)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL
CAppPoolDebug::OnInitDialog()
{
   CInetPropertyPage::OnInitDialog();

   if (m_DebuggerFileName.IsEmpty())
      m_fDoEnableDebug = FALSE;

   SetControlState();
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
   LimitInputPath(CONTROL_HWND(IDC_FILE_NAME),TRUE);
#else
   LimitInputPath(CONTROL_HWND(IDC_FILE_NAME),FALSE);
#endif

   return TRUE;
}

void
CAppPoolDebug::SetControlState()
{
   m_bnt_DoEnableDebug.SetCheck(m_fDoEnableDebug);
   m_FileName.EnableWindow(m_fDoEnableDebug);
   m_Browse.EnableWindow(GetSheet()->IsLocal() && m_fDoEnableDebug);
   m_Params.EnableWindow(m_fDoEnableDebug);
}

void
CAppPoolDebug::OnItemChanged()
{
   SetModified(TRUE);
}

void
CAppPoolDebug::OnDoEnableDebug()
{
   m_fDoEnableDebug = !m_fDoEnableDebug;
   SetControlState();
   SetModified(TRUE);
}

void
CAppPoolDebug::OnBrowse()
{
    CString mask((LPCTSTR)IDS_DEBUG_EXEC_MASK);

    //
    // CODEWORK: Derive a class from CFileDialog that allows
    // the setting of the initial path
    //

    //CString strPath;
    //m_edit_Executable.GetWindowText(strPath);

    CFileDialog dlgBrowse(
        TRUE, 
        NULL, 
        NULL, 
        OFN_HIDEREADONLY, 
        mask, 
        this
        );
    // Disable hook to get Windows 2000 style dialog
	dlgBrowse.m_ofn.Flags &= ~(OFN_ENABLEHOOK);
	dlgBrowse.m_ofn.Flags |= OFN_DONTADDTORECENT|OFN_FILEMUSTEXIST;

    if (dlgBrowse.DoModal() == IDOK)
    {
        m_FileName.SetWindowText(dlgBrowse.GetPathName());
    }

    OnItemChanged();
}
#endif
/////////////////////////////////////////////////////////////////////////////////////

#define LOCAL_SYSTEM_IDX	2
#define LOCAL_SERVICE_IDX	1
#define NETWORK_SERVICE_IDX	0

IMPLEMENT_DYNCREATE(CAppPoolIdent, CInetPropertyPage)

CAppPoolIdent::CAppPoolIdent(CInetPropertySheet * pSheet)
    : CInetPropertyPage(CAppPoolIdent::IDD, pSheet),
    m_fPredefined(FALSE)
{
}

CAppPoolIdent::~CAppPoolIdent()
{
}

/* virtual */
HRESULT
CAppPoolIdent::FetchLoadedValues()
{
   CError err;

   BEGIN_META_INST_READ(CAppPoolSheet)
      FETCH_INST_DATA_FROM_SHEET(m_dwIdentType);
      FETCH_INST_DATA_FROM_SHEET(m_strUserName);
      FETCH_INST_DATA_FROM_SHEET_PASSWORD(m_strUserPass);
   END_META_INST_READ(err)

   m_fPredefined = m_dwIdentType != IDENT_TYPE_CONFIGURABLE;
   switch (m_dwIdentType)
   {
   case IDENT_TYPE_LOCALSYSTEM:
      m_PredefIndex = LOCAL_SYSTEM_IDX;
      break;
   case IDENT_TYPE_LOCALSERVICE:
      m_PredefIndex = LOCAL_SERVICE_IDX;
      break;
   case IDENT_TYPE_NETWORKSERVICE:
      m_PredefIndex = NETWORK_SERVICE_IDX;
      break;
   default:
      m_PredefIndex = -1;
      break;
   }

   return err;
}

/* virtual */
HRESULT
CAppPoolIdent::SaveInfo()
{
   ASSERT(IsDirty());
   CError err;

   BEGIN_META_INST_WRITE(CAppPoolSheet)
      if (m_fPredefined)
      {
		  switch (m_PredefIndex)
		  {
		  case LOCAL_SYSTEM_IDX:
			 m_dwIdentType = IDENT_TYPE_LOCALSYSTEM;
			 break;
		  case LOCAL_SERVICE_IDX:
			 m_dwIdentType = IDENT_TYPE_LOCALSERVICE;
			 break;
		  case NETWORK_SERVICE_IDX:
			 m_dwIdentType = IDENT_TYPE_NETWORKSERVICE;
			 break;
		  default:
			 break;
		 }
      }
      else
      {
         m_dwIdentType = IDENT_TYPE_CONFIGURABLE;
         STORE_INST_DATA_ON_SHEET(m_strUserName);
         STORE_INST_DATA_ON_SHEET(m_strUserPass);
      }
      STORE_INST_DATA_ON_SHEET(m_dwIdentType);
   END_META_INST_WRITE(err)

   return err;
}

void
CAppPoolIdent::SetControlState()
{
   m_bnt_Predefined.SetCheck(m_fPredefined);
   m_bnt_Configurable.SetCheck(!m_fPredefined);
   m_PredefList.EnableWindow(m_fPredefined);
   m_UserName.EnableWindow(!m_fPredefined);
   m_UserPass.EnableWindow(!m_fPredefined);
   m_Browse.EnableWindow(!m_fPredefined);
}

void
CAppPoolIdent::DoDataExchange(CDataExchange * pDX)
{
   CInetPropertyPage::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CAppPoolIdent)
   DDX_Control(pDX, IDC_PREDEFINED, m_bnt_Predefined);
   DDX_Control(pDX, IDC_CONFIGURABLE, m_bnt_Configurable);
   DDX_CBIndex(pDX, IDC_SYSTEM_ACCOUNTS, m_PredefIndex);
   DDX_Control(pDX, IDC_SYSTEM_ACCOUNTS, m_PredefList);
   DDX_Text(pDX, IDC_USER_NAME, m_strUserName);
   DDX_Control(pDX, IDC_USER_NAME, m_UserName);
   DDX_Control(pDX, IDC_BROWSE, m_Browse);
   //DDX_Password(pDX, IDC_USER_PASS, m_strUserPass, _T("***********"));
   DDX_Password_SecuredString(pDX, IDC_USER_PASS, m_strUserPass, _T("***********"));
   DDX_Control(pDX, IDC_USER_PASS, m_UserPass);
   //}}AFX_DATA_MAP
   if (pDX->m_bSaveAndValidate 
	   && m_fPredefined 
	   && m_PredefIndex == LOCAL_SYSTEM_IDX
	   && !m_bAssCovered
	   )
   {
	    if (IsDirty())
		{
			if (!NoYesMessageBox(IDS_SYSIDENT_CONFIRM))
			{
				m_PredefList.SetFocus();
				pDX->Fail();
			}
			m_bAssCovered = TRUE;
		}
    }
}

BEGIN_MESSAGE_MAP(CAppPoolIdent, CInetPropertyPage)
    //{{AFX_MSG_MAP(CAppPoolIdent)
    ON_BN_CLICKED(IDC_PREDEFINED, OnPredefined)
    ON_BN_CLICKED(IDC_CONFIGURABLE, OnPredefined)
    ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
    ON_EN_CHANGE(IDC_USER_NAME, OnItemChanged)
    ON_EN_CHANGE(IDC_USER_PASS, OnItemChanged)
    ON_CBN_SELCHANGE(IDC_SYSTEM_ACCOUNTS, OnSysAccountChanged)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL
CAppPoolIdent::OnInitDialog()
{
   CInetPropertyPage::OnInitDialog();

   CString buf;
   buf.LoadString(IDS_NETSERVICE);
   m_PredefList.AddString(buf);
   buf.LoadString(IDS_LOCALSERVICE);
   m_PredefList.AddString(buf);
   buf.LoadString(IDS_LOCALSYSTEM);
   m_PredefList.AddString(buf);
   if (!m_fPredefined)
   {
       m_PredefIndex = 0;
   }
   m_PredefList.SetCurSel(m_PredefIndex);

   SetControlState();
   m_bAssCovered = FALSE;

   return TRUE;
}

void
CAppPoolIdent::OnPredefined()
{
   m_fPredefined = !m_fPredefined;
   SetControlState();
   SetModified(TRUE);
}

void
CAppPoolIdent::OnBrowse()
{
   // User browser like in other places
   CString user;
   if (GetIUsrAccount(user))
   {
      if (user.CompareNoCase(m_strUserName) != 0)
      {
         m_strUserPass.Empty();
      }
      m_strUserName = user;
	  SetModified(TRUE);
      UpdateData(FALSE);
   }
}

void
CAppPoolIdent::OnItemChanged()
{
   SetModified(TRUE);
}

void
CAppPoolIdent::OnSysAccountChanged()
{
   SetModified(TRUE);
}
#if 0
HRESULT
CAppPoolCache::FetchLoadedValues()
{
   CError err;

   BEGIN_META_INST_READ(CAppPoolSheet)
      FETCH_INST_DATA_FROM_SHEET(m_ScriptEngCacheMax);
      FETCH_INST_DATA_FROM_SHEET(m_NoCache);
      FETCH_INST_DATA_FROM_SHEET(m_LimCache);
      FETCH_INST_DATA_FROM_SHEET(m_UnlimCache);
      FETCH_INST_DATA_FROM_SHEET(m_LimDiskCache);
      FETCH_INST_DATA_FROM_SHEET(m_LimCacheMemSize);
      FETCH_INST_DATA_FROM_SHEET(m_LimCacheDiskSize);
      FETCH_INST_DATA_FROM_SHEET(m_DiskCacheDir);
   END_META_INST_READ(err)

   return err;
}

HRESULT
CAppPoolCache::SaveInfo()
{
   ASSERT(IsDirty());
   CError err;

   BEGIN_META_INST_WRITE(CAppPoolSheet)
      STORE_INST_DATA_ON_SHEET(m_ScriptEngCacheMax)
      STORE_INST_DATA_ON_SHEET(m_NoCache);
      STORE_INST_DATA_ON_SHEET(m_LimCache);
      STORE_INST_DATA_ON_SHEET(m_UnlimCache);
      STORE_INST_DATA_ON_SHEET(m_LimDiskCache);
      STORE_INST_DATA_ON_SHEET(m_LimCacheMemSize);
      STORE_INST_DATA_ON_SHEET(m_LimCacheDiskSize);
      STORE_INST_DATA_ON_SHEET(m_DiskCacheDir);
   END_META_INST_WRITE(err)

   return err;
}

HRESULT
CPoolProcessOpt::FetchLoadedValues()
{
   CError err;

   BEGIN_META_INST_READ(CAppPoolSheet)
      FETCH_INST_DATA_FROM_SHEET(m_LogFailures);
      FETCH_INST_DATA_FROM_SHEET(m_DebugExcept);
      FETCH_INST_DATA_FROM_SHEET(m_CgiTimeout);
      FETCH_INST_DATA_FROM_SHEET(m_HTMLFallback);
   END_META_INST_READ(err)

   return err;
}

HRESULT
CPoolProcessOpt::SaveInfo()
{
   ASSERT(IsDirty());
   CError err;

   BEGIN_META_INST_WRITE(CAppPoolSheet)
      STORE_INST_DATA_ON_SHEET(m_LogFailures);
      STORE_INST_DATA_ON_SHEET(m_DebugExcept);
      STORE_INST_DATA_ON_SHEET(m_CgiTimeout);
      STORE_INST_DATA_ON_SHEET(m_HTMLFallback);
   END_META_INST_WRITE(err)

   return err;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\anondlg.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        anondlg.cpp

   Abstract:

        WWW Anonymous account dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


//
// Include Files
//
#include "stdafx.h"
#include "resource.h"
#include "common.h"
#include "inetprop.h"
#include "inetmgrapp.h"
//#include "supdlgs.h"
#include "anondlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CAnonymousDlg::CAnonymousDlg(
    IN CString & strServerName,
    IN CString & strUserName,
    IN CString & strPassword,
    IN BOOL & fPasswordSync,
    IN CWnd * pParent  OPTIONAL
    )
/*++

Routine Description:

    Constructor

Arguments:

    CString & strServerName     : Server name
    CString & strUserName       : User name
    CString & strPassword       : Password
    BOOL & fPasswordSync        : TRUE for password sync
    CWnd * pParent              : Optional parent window

Return Value:

    N/A

--*/
    : CDialog(CAnonymousDlg::IDD, pParent),
      m_strServerName(strServerName),
      m_strUserName(strUserName),
      m_strPassword(strPassword),
      m_fPasswordSync(fPasswordSync),
      m_fPasswordSyncChanged(FALSE),
      m_fUserNameChanged(FALSE),
      m_fPasswordSyncMsgShown(FALSE)
{
#if 0 // Keep class wizard happy

    //{{AFX_DATA_INIT(CAnonymousDlg)
    m_strUserName = _T("");
    m_fPasswordSync = FALSE;
    //}}AFX_DATA_INIT

    m_strPassword = _T("");

#endif // 0

}


void 
CAnonymousDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAnonymousDlg)
    DDX_Check(pDX, IDC_CHECK_ENABLE_PW_SYNCHRONIZATION, m_fPasswordSync);
    DDX_Control(pDX, IDC_EDIT_USERNAME, m_edit_UserName);
    DDX_Control(pDX, IDC_EDIT_PASSWORD, m_edit_Password);
    DDX_Control(pDX, IDC_STATIC_USERNAME, m_static_Username);
    DDX_Control(pDX, IDC_STATIC_PASSWORD, m_static_Password);
    DDX_Control(pDX, IDC_STATIC_ANONYMOUS_LOGON, m_group_AnonymousLogon);
    DDX_Control(pDX, IDC_CHECK_ENABLE_PW_SYNCHRONIZATION, m_chk_PasswordSync);
    DDX_Control(pDX, IDC_BUTTON_CHECK_PASSWORD, m_button_CheckPassword);
    //}}AFX_DATA_MAP

    DDX_Text(pDX, IDC_EDIT_USERNAME, m_strUserName);
    DDV_MinMaxChars(pDX, m_strUserName, 1, UNLEN);

    //
    // Some people have a tendency to add "\\" before
    // the computer name in user accounts.  Fix this here.
    //
    m_strUserName.TrimLeft();
    while (*m_strUserName == '\\')
    {
        m_strUserName = m_strUserName.Mid(2);
    }

    //
    // Display the remote password sync message if
    // password sync is on, the account is not local,
    // password sync has changed or username has changed
    // and the message hasn't already be shown.
    //
    if (pDX->m_bSaveAndValidate && m_fPasswordSync 
        && !IsLocalAccount(m_strUserName)
        && (m_fPasswordSyncChanged || m_fUserNameChanged)
        && !m_fPasswordSyncMsgShown
        )
    {
        if (::AfxMessageBox(
            IDS_WRN_PWSYNC, 
            MB_YESNO | MB_DEFBUTTON2 | MB_ICONQUESTION
            ) != IDYES)
        {
            pDX->Fail();
        }

        //
        // Don't show it again
        //
        m_fPasswordSyncMsgShown = TRUE;
    }

    if (!m_fPasswordSync || !pDX->m_bSaveAndValidate)
    {
        //DDX_Password(pDX, IDC_EDIT_PASSWORD, m_strPassword, g_lpszDummyPassword);
        DDX_Password_SecuredString(pDX, IDC_EDIT_PASSWORD, m_strPassword, g_lpszDummyPassword);
    }

    if (!m_fPasswordSync)
    {
        //DDV_MinMaxChars(pDX, m_strPassword, 1, PWLEN);
        DDV_MinMaxChars_SecuredString(pDX, m_strPassword, 1, PWLEN);
    }
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CAnonymousDlg, CDialog)
    //{{AFX_MSG_MAP(CAnonymousDlg)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE_USERS, OnButtonBrowseUsers)
    ON_BN_CLICKED(IDC_BUTTON_CHECK_PASSWORD, OnButtonCheckPassword)
    ON_BN_CLICKED(IDC_CHECK_ENABLE_PW_SYNCHRONIZATION, OnCheckEnablePwSynchronization)
    ON_EN_CHANGE(IDC_EDIT_USERNAME, OnChangeEditUsername)
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_PASSWORD, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_DOMAIN_NAME, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_BASIC_DOMAIN, OnItemChanged)

END_MESSAGE_MAP()



void
CAnonymousDlg::SetControlStates()
/*++

Routine Description:

    Set the states of the dialog control depending on its current
    values.

Arguments:

    None

Return Value:

    None

--*/
{
    m_static_Password.EnableWindow(!m_fPasswordSync);
    m_edit_Password.EnableWindow(!m_fPasswordSync);
    m_button_CheckPassword.EnableWindow(!m_fPasswordSync);
}


//
// Message Handlers
// 
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


BOOL 
CAnonymousDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    SetControlStates();
    
    return TRUE;  
}


void
CAnonymousDlg::OnItemChanged()
/*++

Routine Description:

    All EN_CHANGE and BN_CLICKED messages map to this function

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



void 
CAnonymousDlg::OnButtonBrowseUsers()
/*++

Routine Description:

    User browse dialog pressed, bring up
    the user browser

Arguments:

    None

Return Value:

    None

--*/
{
    CString str;

    if (GetIUsrAccount(m_strServerName, this, str))
    {
        //
        // If the name is non-local (determined by having
        // a slash in the name, password sync is disabled,
        // and a password should be entered.
        //
        m_edit_UserName.SetWindowText(str);
        if (!(m_fPasswordSync = IsLocalAccount(str)))
        {
            m_edit_Password.SetWindowText(_T(""));
            m_edit_Password.SetFocus();
        }

        m_chk_PasswordSync.SetCheck(m_fPasswordSync);
        OnItemChanged();
    }
}


void 
CAnonymousDlg::OnButtonCheckPassword() 
/*++

Routine Description:

    Check password button has been pressed.

Arguments:

    None

Return Value:

    None

--*/
{
    if (!UpdateData(TRUE))
    {
        return;
    }

    CString csTempPassword;
    m_strPassword.CopyTo(csTempPassword);
    CError err(CComAuthInfo::VerifyUserPassword(m_strUserName, csTempPassword));
    if (!err.MessageBoxOnFailure(m_hWnd))
    {
        DoHelpMessageBox(m_hWnd,IDS_PASSWORD_OK, MB_APPLMODAL | MB_OK | MB_ICONINFORMATION, 0);
    }
}



void
CAnonymousDlg::OnCheckEnablePwSynchronization()
/*++

Routine Description:

    Handler for 'enable password synchronization' checkbox press

Arguments:

    None

Return Value:

    None

--*/
{
    m_fPasswordSyncChanged = TRUE;
    m_fPasswordSync = !m_fPasswordSync;
    OnItemChanged();
    SetControlStates();
    if (!m_fPasswordSync )
    {
        m_edit_Password.SetSel(0,-1);
        m_edit_Password.SetFocus();
    }
}




void 
CAnonymousDlg::OnChangeEditUsername() 
/*++

Routine description:

    Handler for 'username' edit box change messages

Arguments:

    None

Return Value:

    None

--*/
{
    m_fUserNameChanged = TRUE;
    OnItemChanged();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\app_pools.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        app_pools.cpp

   Abstract:
        IIS Application Pools nodes

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
        11/03/2000      sergeia     Initial creation

--*/
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "iisobj.h"
#include "shts.h"
#include "app_sheet.h"
#include "app_pool_sheet.h"
#include "tracker.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
#define new DEBUG_NEW

extern CPropertySheetTracker g_OpenPropertySheetTracker;

CAppPoolsContainer::CAppPoolsContainer(
      CIISMachine * pOwner,
      CIISService * pService
      )
    : CIISMBNode(pOwner, SZ_MBN_APP_POOLS),
      m_pWebService(pService)
{
   VERIFY(m_bstrDisplayName.LoadString(IDS_APP_POOLS));
}

CAppPoolsContainer::~CAppPoolsContainer()
{
}

/*virtual*/
HRESULT
CAppPoolsContainer::RefreshData()
{
    CError err;
    CComBSTR bstrPath;
    
    err = BuildMetaPath(bstrPath);
	err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,bstrPath);
    if (!IsLostInterface(err))
    {
        // reset error if an other error other than No interface
        err.Reset();
    }
    if (err.Succeeded())
    {
        return CIISMBNode::RefreshData();
    }
    DisplayError(err);
    return err;
}

HRESULT
CAppPoolsContainer::RefreshDataChildren(CString AppPoolToRefresh,BOOL bVerifyChildren)
{
    IConsoleNameSpace2 * pConsoleNameSpace = (IConsoleNameSpace2 *)GetConsoleNameSpace();
	HSCOPEITEM hChildItem = NULL;
	LONG_PTR cookie;
    BOOL bMyVerifyChildren = FALSE;

	HRESULT hr = pConsoleNameSpace->GetChildItem(m_hScopeItem, &hChildItem, &cookie);
    if (AppPoolToRefresh.IsEmpty())
    {
        // don't verify children when they ask for *.*
        bMyVerifyChildren = FALSE;
    }
    else
    {
        bMyVerifyChildren = TRUE;
    }
    if (bVerifyChildren)
    {
        bMyVerifyChildren = TRUE;
    }
	while(SUCCEEDED(hr) && hChildItem)
	{
		CAppPoolNode * pItem = (CAppPoolNode *)cookie;
        if (pItem)
        {
            if (pItem->IsExpanded())
            {
                if (AppPoolToRefresh.IsEmpty())
                {
                    pItem->RefreshData(TRUE,bMyVerifyChildren);
                    pItem->RefreshDisplay(FALSE);
                }
                else
                {
                    if (0 == AppPoolToRefresh.CompareNoCase(pItem->QueryDisplayName()))
                    {
                        pItem->RefreshData(TRUE,bMyVerifyChildren);
                        pItem->RefreshDisplay(FALSE);
                    }
                }
            }
        }
		hr = pConsoleNameSpace->GetNextItem(hChildItem, &hChildItem, &cookie);
	}

    return hr;
}

/* virtual */ 
HRESULT 
CAppPoolsContainer::EnumerateScopePane(HSCOPEITEM hParent)
{
	CPoolList list;
	CError err = EnumerateAppPools(&list);
	if (err.Succeeded())
	{
		POSITION pos = list.GetHeadPosition();
		while (pos)
		{
			CAppPoolNode * pool = list.GetNext(pos);
			pool->AddRef();
			err = pool->AddToScopePane(hParent);
			if (err.Failed())
			{
				pool->Release();
				break;
			}
		}
	}
	list.RemoveAll();
    DisplayError(err);
    return err;
}

/* virtual */
LPOLESTR 
CAppPoolsContainer::GetResultPaneColInfo(int nCol)
{
    if (nCol == 0)
    {
        return QueryDisplayName();
    }
    return OLESTR("");
}

HRESULT
CAppPoolsContainer::EnumerateAppPools(CPoolList * pList)
{
	ASSERT(pList != NULL);
    CString strPool;
	CComBSTR bstrPath;
	CError err;
    DWORD dwState;
	do
	{
		err = BuildMetaPath(bstrPath);
        err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,bstrPath);
		BREAK_ON_ERR_FAILURE(err)
		CMetaKey mk(QueryInterface(), bstrPath, METADATA_PERMISSION_READ);
		err = mk.QueryResult();
		BREAK_ON_ERR_FAILURE(err)
		CStringListEx list;
		err = mk.GetChildPaths(list);
		BREAK_ON_ERR_FAILURE(err)
		CString key_type;
		POSITION pos = list.GetHeadPosition();
		while (err.Succeeded() && pos != NULL)
		{
			strPool = list.GetNext(pos);
			err = mk.QueryValue(MD_KEY_TYPE, key_type, NULL, strPool);
			if (err == (HRESULT)MD_ERROR_DATA_NOT_FOUND)
			{
				err.Reset();
			}

            err = mk.QueryValue(MD_APPPOOL_STATE, dwState, NULL, strPool);
			if (err == (HRESULT)MD_ERROR_DATA_NOT_FOUND)
			{
                // if not found then it's state is off..
                dwState = MD_APPPOOL_STATE_STOPPED;
				err.Reset();
			}

            // Get the app pool state
			if (err.Succeeded() && (key_type.CompareNoCase(_T("IIsApplicationPool")) == 0))
			{
				CAppPoolNode * pool;
				if (NULL == (pool = new CAppPoolNode(m_pOwner, this, strPool, dwState)))
				{
					err = ERROR_NOT_ENOUGH_MEMORY;
					break;
				}
				pList->AddTail(pool);
			}
		}
    } while (FALSE);

	return err;
}

/* virtual */
void 
CAppPoolsContainer::InitializeChildHeaders(LPHEADERCTRL lpHeader)
/*++

Routine Description:
    Build result view for immediate descendant type

Arguments:
    LPHEADERCTRL lpHeader      : Header control

--*/
{
   CAppPoolNode::InitializeHeaders(lpHeader);
}

/* virtual */
HRESULT
CAppPoolsContainer::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle, 
    IUnknown * pUnk,
    DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Create the property pages for the given object

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  : Provider
    LONG_PTR handle                     : Handle.
    IUnknown * pUnk,
    DATA_OBJECT_TYPES type

Return Value:

    HRESULT
                                                
--*/
{
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());
	CError  err;

	if (S_FALSE == (HRESULT)(err = CIISMBNode::CreatePropertyPages(lpProvider, handle, pUnk, type)))
	{
		return S_OK;
	}
    if (ERROR_ALREADY_EXISTS == err.Win32Error())
    {
        return S_FALSE;
    }
	if (err.Succeeded())
	{
		CComBSTR path;
		err = BuildMetaPath(path);
		if (err.Succeeded())
		{
            err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,path);
            if (err.Succeeded())
            {
			    CAppPoolSheet * pSheet = new CAppPoolSheet(
				    QueryAuthInfo(), path, GetMainWindow(GetConsole()), (LPARAM)this,
                    (LPARAM)GetOwner()
				    );
  			    if (pSheet != NULL)
			    {
                    // cache handle for user in MMCPropertyChangeNotify
                    m_ppHandle = handle;

				    pSheet->SetModeless();
				    err = AddMMCPage(lpProvider, new CAppPoolRecycle(pSheet));
				    err = AddMMCPage(lpProvider, new CAppPoolPerf(pSheet));
				    err = AddMMCPage(lpProvider, new CAppPoolHealth(pSheet));
    //				err = AddMMCPage(lpProvider, new CAppPoolDebug(pSheet));
				    err = AddMMCPage(lpProvider, new CAppPoolIdent(pSheet));
    //				err = AddMMCPage(lpProvider, new CAppPoolCache(pSheet));
    //				err = AddMMCPage(lpProvider, new CPoolProcessOpt(pSheet));
			    }
            }
		}
	}
	err.MessageBoxOnFailure();
	return err;
}

/* virtual */
HRESULT
CAppPoolsContainer::BuildMetaPath(
    OUT CComBSTR & bstrPath
    ) const
/*++

Routine Description:

    Recursively build up the metabase path from the current node
    and its parents. We cannot use CIISMBNode method because AppPools
    is located under w3svc, but rendered after machine.

Arguments:

    CComBSTR & bstrPath     : Returns metabase path

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;
    ASSERT(m_pWebService != NULL);
    hr = m_pWebService->BuildMetaPath(bstrPath);

    if (SUCCEEDED(hr))
    {
        bstrPath.Append(_cszSeparator);
        bstrPath.Append(QueryNodeName());
        return hr;
    }

    //
    // No service node
    //
    ASSERT_MSG("No WebService pointer");
    return E_UNEXPECTED;
}

HRESULT
CAppPoolsContainer::QueryDefaultPoolId(CString& id)
//
// Returns pool id which is set on master node for web service
//
{
    CError err;
    CComBSTR path;
    CString service;

    BuildMetaPath(path);
    CMetabasePath::GetServicePath(path, service);
    CMetaKey mk(QueryAuthInfo(), service, METADATA_PERMISSION_READ);
    err = mk.QueryResult();
    if (err.Succeeded())
    {
        err = mk.QueryValue(MD_APP_APPPOOL_ID, id);
    }

    return err;
}

/* virtual */
HRESULT
CAppPoolsContainer::AddMenuItems(
    IN LPCONTEXTMENUCALLBACK lpContextMenuCallback,
    IN OUT long * pInsertionAllowed,
    IN DATA_OBJECT_TYPES type
    )
{
    ASSERT_READ_PTR(lpContextMenuCallback);

    //
    // Add base menu items
    //
    HRESULT hr = CIISObject::AddMenuItems(
        lpContextMenuCallback,
        pInsertionAllowed,
        type
        );

    if (SUCCEEDED(hr))
    {
        ASSERT(pInsertionAllowed != NULL);
        if (IsAdministrator())
        {
            if ((*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) != 0)
            {
                AddMenuSeparator(lpContextMenuCallback);
                AddMenuItemByCommand(lpContextMenuCallback, IDM_NEW_APP_POOL);

                if (IsConfigImportExportable())
                {
                    AddMenuItemByCommand(lpContextMenuCallback, IDM_NEW_APP_POOL_FROM_FILE);
                }
            }

            if ((*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK) != 0)
            {
                if (IsConfigImportExportable())
                {
                    AddMenuSeparator(lpContextMenuCallback);
                    AddMenuItemByCommand(lpContextMenuCallback, IDM_TASK_EXPORT_CONFIG_WIZARD);
                }
            }
        }
    }

    return hr;
}

HRESULT
CAppPoolsContainer::Command(
    long lCommandID,
    CSnapInObjectRootBase * pObj,
    DATA_OBJECT_TYPES type
    )
{
    HRESULT hr = S_OK;
    CString name;

    switch (lCommandID)
    {

    case IDM_NEW_APP_POOL:
        {
            CError err;
            CComBSTR bstrMetaPath;

            VERIFY(SUCCEEDED(BuildMetaPath(bstrMetaPath)));
            err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,bstrMetaPath);
            if (!IsLostInterface(err))
            {
                // reset error if an other error other than No interface
                err.Reset();
            }
            if (err.Succeeded())
            {
                if (    SUCCEEDED(hr = AddAppPool(pObj, type, this, name))
                    && !name.IsEmpty()
                    )
                {
                hr = InsertNewPool(name);
                }
            }
        }
        break;

    //
    // Pass on to base class
    //
    default:
        hr = CIISMBNode::Command(lCommandID, pObj, type);
    }

    return hr;
}

HRESULT
CAppPoolsContainer::InsertNewPool(CString& id)
{
    CError err;
    if (!IsExpanded())
    {
        SelectScopeItem();
        IConsoleNameSpace2 * pConsoleNameSpace
                       = (IConsoleNameSpace2 *)GetConsoleNameSpace();
        pConsoleNameSpace->Expand(QueryScopeItem());
		HSCOPEITEM hChildItem = NULL;
		LONG_PTR cookie;
		HRESULT hr = pConsoleNameSpace->GetChildItem(m_hScopeItem, &hChildItem, &cookie);
		while(SUCCEEDED(hr) && hChildItem)
		{
			CAppPoolNode * pItem = (CAppPoolNode *)cookie;
			ASSERT_PTR(pItem);
			if (0 == id.Compare(pItem->QueryDisplayName()))
			{
				pItem->SelectScopeItem();
                // set status to running when creating a new apppool
                pItem->ChangeState(MD_APPPOOL_COMMAND_START);
				break;
			}
			hr = pConsoleNameSpace->GetNextItem(hChildItem, &hChildItem, &cookie);
		}
    }
	else
	{
		// Now we should insert and select this new site
		CAppPoolNode * pPool = new CAppPoolNode(m_pOwner, this, id, 0);
		if (pPool != NULL)
		{
			err = pPool->RefreshData();
			if (err.Succeeded())
			{
				pPool->AddRef();
				err = pPool->AddToScopePaneSorted(QueryScopeItem(), FALSE);
				if (err.Succeeded())
				{
					VERIFY(SUCCEEDED(pPool->SelectScopeItem()));
                    // set status to running when creating a new apppool
                    pPool->ChangeState(MD_APPPOOL_COMMAND_START);
				}
				else
				{
					pPool->Release();
				}
			}
		}
		else
		{
			err = ERROR_NOT_ENOUGH_MEMORY;
		}
	}
    return err;
}

////////////////////////////////////////////////////////////////////////////////
// CAppPoolNode implementation
//
// App Pool Result View definition
//
/* static */ int 
CAppPoolNode::_rgnLabels[COL_TOTAL] =
{
    IDS_RESULT_SERVICE_DESCRIPTION,
    IDS_RESULT_SERVICE_STATE,
	IDS_RESULT_STATUS
};
    

/* static */ int 
CAppPoolNode::_rgnWidths[COL_TOTAL] =
{
    180,
    70,
	200
};

/* static */ CComBSTR CAppPoolNode::_bstrStarted;
/* static */ CComBSTR CAppPoolNode::_bstrStopped;
/* static */ CComBSTR CAppPoolNode::_bstrUnknown;
/* static */ CComBSTR CAppPoolNode::_bstrPending;
/* static */ BOOL     CAppPoolNode::_fStaticsLoaded = FALSE;

CAppPoolNode::CAppPoolNode(
      CIISMachine * pOwner,
      CAppPoolsContainer * pContainer,
      LPCTSTR name,
      DWORD dwState
      )
    : CIISMBNode(pOwner, name),
      m_pContainer(pContainer),
      m_dwWin32Error(0),
      m_dwState(dwState)
{
}

CAppPoolNode::~CAppPoolNode()
{
}

#if 0
// This is too expensive
BOOL
CAppPoolNode::IsDeletable() const
{
   // We could delete node if it is empty and it is not default app pool
   BOOL bRes = TRUE;

   CComBSTR path;
   CStringListEx strListOfApps;
   BuildMetaPath(path);
   CIISMBNode * that = (CIISMBNode *)this;
   CIISAppPool pool(that->QueryAuthInfo(), (LPCTSTR)path);
   HRESULT hr = pool.EnumerateApplications(strListOfApps);
   bRes = (SUCCEEDED(hr) && strListOfApps.GetCount() == 0);
   if (bRes)
   {
      CString buf;
      hr = m_pContainer->QueryDefaultPoolId(buf);
      bRes = buf.CompareNoCase(QueryNodeName()) != 0;
   }
   return bRes;
}
#endif

HRESULT
CAppPoolNode::DeleteNode(IResultData * pResult)
{
   CError err;

    // check if they have the property sheet open on it.
    if (IsMyPropertySheetOpen())
    {
        ::AfxMessageBox(IDS_CLOSE_PROPERTY_SHEET);
        return S_OK;
    }

    // this could be an orphaned property sheet
    // check if an orphaned property sheet is open on this item.
    CIISObject * pAlreadyOpenProp = NULL;
    if (TRUE == g_OpenPropertySheetTracker.FindAlreadyOpenPropertySheet(this,&pAlreadyOpenProp))
    {
        // Bring it to the foreground, and bail
        HWND hHwnd = 0;
        if (pAlreadyOpenProp)
        {
            if (hHwnd = pAlreadyOpenProp->IsMyPropertySheetOpen())
            {
                if (hHwnd && (hHwnd != (HWND) 1))
                {
                    // Perhapse we should cancel the already
                    // opened property sheet...just a thought
                    if (!SetForegroundWindow(hHwnd))
                    {
                        // wasn't able to bring this property sheet to
                        // the foreground, the propertysheet must not
                        // exist anymore.  let's just clean the hwnd
                        // so that the user will be able to open propertysheet
                        pAlreadyOpenProp->SetMyPropertySheetOpen(0);
                    }
                    else
                    {
                        ::AfxMessageBox(IDS_CLOSE_PROPERTY_SHEET);
                        return S_OK;
                    }
                }
            }
        }
    }

    CComBSTR path;
    BuildMetaPath(path);
    err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,path);
    if (!IsLostInterface(err))
    {
        // reset error if an other error other than No interface
        err.Reset();
    }
    if (err.Succeeded())
    {
        if (!NoYesMessageBox(IDS_CONFIRM_DELETE))
            return err;

        CIISAppPool pool(QueryAuthInfo(), (LPCTSTR)path);

        err = pool.Delete(QueryNodeName());

        if (err.Succeeded())
        {
            err = RemoveScopeItem();
        }
        if (err.Win32Error() == ERROR_NOT_EMPTY)
        {
	        CString msg;
	        msg.LoadString(IDS_ERR_NONEMPTY_APPPOOL);
	        AfxMessageBox(msg);
        }
        else
        {
	        err.MessageBoxOnFailure();
        }
    }
    else
    {
        err.MessageBoxOnFailure();
    }

   return err;
}

/* virtual */
HRESULT
CAppPoolNode::BuildMetaPath(CComBSTR & bstrPath) const
{
    HRESULT hr = S_OK;
    ASSERT(m_pContainer != NULL);
    hr = m_pContainer->BuildMetaPath(bstrPath);

    if (SUCCEEDED(hr))
    {
        bstrPath.Append(_cszSeparator);
        bstrPath.Append(QueryNodeName());
        return hr;
    }

    //
    // No service node
    //
    ASSERT_MSG("No pointer to container");
    return E_UNEXPECTED;
}

/* virtual */
LPOLESTR 
CAppPoolNode::GetResultPaneColInfo(
    IN int nCol
    )
/*++

Routine Description:

    Return result pane string for the given column number

Arguments:

    int nCol        : Column number

Return Value:

    String

--*/
{
    switch(nCol)
    {
    case COL_DESCRIPTION:
        return QueryDisplayName();

    case COL_STATE:
        switch(m_dwState)
        {
        case MD_APPPOOL_STATE_STARTED:
            return _bstrStarted;
        case MD_APPPOOL_STATE_STOPPED:
            return _bstrStopped;
        case MD_APPPOOL_STATE_STARTING:
        case MD_APPPOOL_STATE_STOPPING:
            return _bstrPending;
		default:
			return OLESTR("");
        }
	case COL_STATUS:
        {
            AFX_MANAGE_STATE(::AfxGetStaticModuleState());
            CError err(m_dwWin32Error);
            if (err.Succeeded())
            {
                return OLESTR("");
            }
       
            _bstrResult = err;
        }
        return _bstrResult;
    }
    ASSERT_MSG("Bad column number");
    return OLESTR("");
}

/* virtual */
int      
CAppPoolNode::QueryImage() const
{
	if (m_dwWin32Error != 0)
	{
		return iAppPoolErr;
	}
	else
	{
		if (m_dwState == MD_APPPOOL_STATE_STOPPED)
		{
			return iAppPoolStop;
		}
		else
		{
			return iAppPool;
		}
	}
}

/* virtual */
LPOLESTR 
CAppPoolNode::QueryDisplayName()
{
    if (m_strDisplayName.IsEmpty())
    {
		RefreshData();
        m_strDisplayName = QueryNodeName();
    }        
    return (LPTSTR)(LPCTSTR)m_strDisplayName;
}

/* virtual */
HRESULT
CAppPoolNode::RefreshData()
{
    CError err;
    CComBSTR bstrPath1;
    CMetaKey * pKey = NULL;

    do
    {
        err = BuildMetaPath(bstrPath1);
        if (err.Failed())
        {
            break;
        }

        BOOL fContinue = TRUE;
        while (fContinue)
        {
            fContinue = FALSE;
            if (NULL == (pKey = new CMetaKey(QueryInterface(), bstrPath1)))
            {
                TRACEEOLID("RefreshData: Out Of Memory");
                err = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            err = pKey->QueryResult();

            if (IsLostInterface(err))
            {
                SAFE_DELETE(pKey);
                fContinue = OnLostInterface(err);
            }
        }
        if (err.Failed())
        {
            break;
        }

        CAppPoolProps pool(pKey, _T(""));

        err = pool.LoadData();
        if (err.Failed())
        {
            break;
        }
        // Assign the data
		m_dwState = pool.m_dwState;
		m_strDisplayName = QueryNodeName();
		m_dwWin32Error = pool.m_dwWin32Error;
    }
    while(FALSE);
    SAFE_DELETE(pKey);

    return err;
}


HRESULT 
CAppPoolNode::RefreshData(BOOL bRefreshChildren,BOOL bMyVerifyChildren)
{
    CError err;

    // call regular refreshdata on this node...
    err = RefreshData();

    // -------------------------------------
    // Loop thru all of our children to make
    // sure they are all still jiving..
    // -------------------------------------
    if (bRefreshChildren)
    {
        CComBSTR bstrPath1;
        POSITION pos1 = NULL;
        CApplicationList MyMMCList;
        CApplicationNode * pItemFromMMC = NULL;

        // create a list of what is in mmc...
        MyMMCList.RemoveAll();

	    HSCOPEITEM hChild = NULL, hCurrent;
	    LONG_PTR cookie = 0;
    IConsoleNameSpace2 * pConsoleNameSpace = (IConsoleNameSpace2 *)GetConsoleNameSpace();
	    err = pConsoleNameSpace->GetChildItem(QueryScopeItem(), &hChild, &cookie);
	    while (err.Succeeded() && hChild != NULL)
	    {
		    CIISMBNode * pNode = (CIISMBNode *)cookie;
            if (pNode)
            {
		        if (IsEqualGUID(* (GUID *)pNode->GetNodeType(),cApplicationNode))
		        {
                    CApplicationNode * pNode2 = (CApplicationNode *) pNode;
                    if (pNode2)
                    {
                        // clean the displayname, it could have changed..
                        // and this could be the real reason for the refresh...
                        pNode2->QueryDisplayName(TRUE);
                        MyMMCList.AddTail(pNode2);
                    }
		        }
            }
		    hCurrent = hChild;
		    err = pConsoleNameSpace->GetNextItem(hCurrent, &hChild, &cookie);
	    }

        // Loop thru and see if we need to add anything
        CStringListEx strListOfApps;
        BuildMetaPath(bstrPath1);
        CIISAppPool pool(QueryAuthInfo(), (LPCTSTR)bstrPath1);
        err = pool.EnumerateApplications(strListOfApps);
        if (err.Succeeded() && strListOfApps.GetCount() > 0)
        {
            POSITION pos2 = NULL;
            DWORD iNumApp = 0;
            CString strAppInMetabase;
            CString strAppInMetabaseName;
            pos1 = strListOfApps.GetHeadPosition();
            while ( pos1 != NULL)
            {
                BOOL bExistsInUI = FALSE; 
                strAppInMetabase = strListOfApps.GetNext(pos1);

                iNumApp = CMetabasePath::GetInstanceNumber(strAppInMetabase);
                if (iNumApp > 0)
                {
                    CMetabasePath::CleanMetaPath(strAppInMetabase);
                    CMetabasePath::GetLastNodeName(strAppInMetabase, strAppInMetabaseName);

                    // Check if this item is in the list...
                    // Loop through our list
                    // and see if we need to add anything
                    pos2 = MyMMCList.GetHeadPosition();
	                while (pos2)
	                {
		                pItemFromMMC = MyMMCList.GetNext(pos2);
                        if (pItemFromMMC)
                        {
                            CComBSTR bstrPath2;
                            err = pItemFromMMC->BuildMetaPath(bstrPath2);
                            CString csAppID = bstrPath2;
                            CMetabasePath::CleanMetaPath(csAppID);

                            if (0 == csAppID.CompareNoCase(strAppInMetabase))
                            {
                                bExistsInUI = TRUE;
                                break;
                            }
                        }
                    }

                    if (!bExistsInUI)
                    {
                        TRACEEOL(strAppInMetabase << ", not exist but should, adding to UI...");
                        CApplicationNode * app_node = new CApplicationNode(GetOwner(), strAppInMetabase, strAppInMetabaseName);
                        if (app_node != NULL)
                        {
                            app_node->AddRef();
                            app_node->AddToScopePane(m_hScopeItem, TRUE, TRUE, FALSE);
                        }
                    }
                }
            }
        }

        // Loop through our list and find stuff we want to delete
        BuildMetaPath(bstrPath1);
        pos1 = MyMMCList.GetHeadPosition();
        BOOL bMarkedForDelete = FALSE;
	    while (pos1)
	    {
		    pItemFromMMC = MyMMCList.GetNext(pos1);
            bMarkedForDelete = FALSE;
            // see if it exists in the metabase,
            // if it doesn't then add it to the delete list...
            if (pItemFromMMC)
            {
                CComBSTR bstrPath3;
                pItemFromMMC->BuildMetaPath(bstrPath3);

                // check if path exists...
                CMetaKey mk(QueryInterface(), bstrPath3);
                if (!mk.Succeeded())
                {
                    // delete it
                    bMarkedForDelete = TRUE;
                }
                else
                {
                    // doesn't need to be removed...
                    // put perhase it does..
                    // check if this Application is actually being used
                    // by the site!
                    if (bMyVerifyChildren)
                    {
                        // Lookup that website
                        // and get it's App that it's using
                        // see if it's the same as this AppID (BuildMetaPath(bstrPath1);)
                        err = mk.QueryResult();
                        if (err.Succeeded())
                        {
                            CString csAppID = bstrPath1;
                            CString csAppIDName;
                            CMetabasePath::CleanMetaPath(csAppID);
                            CMetabasePath::GetLastNodeName(csAppID, csAppIDName);

                            CString id;
                            err = mk.QueryValue(MD_APP_APPPOOL_ID, id);
                            err = mk.QueryResult();
                            if (err.Succeeded())
                            {
                                if (0 != csAppIDName.CompareNoCase(id))
                                {
                                    // the web site, isn't actually using it..
                                    // delete it
                                    bMarkedForDelete = TRUE;
                                }
                            }
                        }
                    }
                }

                if (bMarkedForDelete)
                {
                    // delete it list...
                    TRACEEOL(bstrPath3 << ", not exist, removing from UI...");
                    // remove it from the UI
                    pItemFromMMC->RemoveScopeItem();
                    // delete the object
                    pItemFromMMC->Release();
                }
            }
        }
    }
    
    return err;
}

/* virtual */
int 
CAppPoolNode::CompareResultPaneItem(
    CIISObject * pObject, 
    int nCol
    )
/*++

Routine Description:

    Compare two CIISObjects on sort item criteria

Arguments:

    CIISObject * pObject : Object to compare against
    int nCol             : Column number to sort on

Return Value:

    0  if the two objects are identical
    <0 if this object is less than pObject
    >0 if this object is greater than pObject

--*/
{
    ASSERT_READ_PTR(pObject);

    if (nCol == 0)
    {
        return CompareScopeItem(pObject);
    }

    //
    // First criteria is object type
    //
    int n1 = QuerySortWeight();
    int n2 = pObject->QuerySortWeight();

    if (n1 != n2)
    {
        return n1 - n2;
    }

    //
    // Both are CAppPoolNode objects
    //
    CAppPoolNode * pPool = (CAppPoolNode *)pObject;

    switch(nCol)
    {
    case COL_DESCRIPTION:
    case COL_STATE:
    default:
        //
        // Lexical sort
        //
        return ::lstrcmpi(
            GetResultPaneColInfo(nCol), 
            pObject->GetResultPaneColInfo(nCol)
            );
    }
}

/* virtual */
void 
CAppPoolNode::InitializeChildHeaders(LPHEADERCTRL lpHeader)
/*++
Routine Description:
    Build result view for immediate descendant type

Arguments:
    LPHEADERCTRL lpHeader      : Header control

--*/
{
   CApplicationNode::InitializeHeaders(lpHeader);
}

/* static */
void
CAppPoolNode::InitializeHeaders(LPHEADERCTRL lpHeader)
/*++

Routine Description:
    Initialize the result headers

Arguments:
    LPHEADERCTRL lpHeader : Header control

--*/
{
    CIISObject::BuildResultView(lpHeader, COL_TOTAL, _rgnLabels, _rgnWidths);
    if (!_fStaticsLoaded)
    {
        _fStaticsLoaded =
            _bstrStarted.LoadString(IDS_STARTED)  &&
            _bstrStopped.LoadString(IDS_STOPPED)  &&
            _bstrUnknown.LoadString(IDS_UNKNOWN)  &&
            _bstrPending.LoadString(IDS_PENDING);
    }
}

/* virtual */
HRESULT 
CAppPoolNode::EnumerateScopePane(
    IN HSCOPEITEM hParent
    )
/*++

Routine Description:

    Enumerate scope child items.

Arguments:

    HSCOPEITEM hParent                      : Parent console handle

Return Value:

    HRESULT

--*/
{
    CError err;
    do
    {
        CComBSTR path;
        BuildMetaPath(path);
        err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,path);
	    BREAK_ON_ERR_FAILURE(err)

        CIISAppPool pool(QueryAuthInfo(), path);
        if (pool.Succeeded())
        {
            CStringListEx strListOfApps;

            err = pool.EnumerateApplications(strListOfApps);
            if (err.Succeeded() && strListOfApps.GetCount() > 0)
            {
                POSITION pos = strListOfApps.GetHeadPosition();
                while ( pos != NULL)
                {
                    CString app = strListOfApps.GetNext(pos);
                    DWORD i = CMetabasePath::GetInstanceNumber(app);
                    if (i > 0)
                    {
                        CString name;
                        CMetabasePath::CleanMetaPath(app);
                        CMetabasePath::GetLastNodeName(app, name);
                        CApplicationNode * app_node = new CApplicationNode(
                            GetOwner(), app, name);
                        if (app_node != NULL)
                        {
                            app_node->AddRef();
                            app_node->AddToScopePane(m_hScopeItem, TRUE, TRUE, FALSE);
                        }
                        else
                        {
                            err = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }
                }
            }
        }
    } while (FALSE);
    return err;
}

/* virtual */
HRESULT
CAppPoolNode::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle, 
    IUnknown * pUnk,
    DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Create the property pages for the given object

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  : Provider
    LONG_PTR handle                     : Handle.
    IUnknown * pUnk,
    DATA_OBJECT_TYPES type

Return Value:

    HRESULT
                                                
--*/
{
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());
	CError  err;

	if (S_FALSE == (HRESULT)(err = CIISMBNode::CreatePropertyPages(lpProvider, handle, pUnk, type)))
	{
		return S_OK;
	}
    if (ERROR_ALREADY_EXISTS == err.Win32Error())
    {
        return S_FALSE;
    }
	if (err.Succeeded())
	{
		CComBSTR path;
		err = BuildMetaPath(path);
		if (err.Succeeded())
		{
            err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,path);
            if (err.Succeeded())
            {
			    CAppPoolSheet * pSheet = new CAppPoolSheet(
				    QueryAuthInfo(), path, GetMainWindow(GetConsole()), (LPARAM)this,
                    (LPARAM) m_pContainer
				    );
    	   
			    if (pSheet != NULL)
			    {
                    // cache handle for user in MMCPropertyChangeNotify
                    m_ppHandle = handle;

				    pSheet->SetModeless();
				    err = AddMMCPage(lpProvider, new CAppPoolRecycle(pSheet));
				    err = AddMMCPage(lpProvider, new CAppPoolPerf(pSheet));
				    err = AddMMCPage(lpProvider, new CAppPoolHealth(pSheet));
    //				err = AddMMCPage(lpProvider, new CAppPoolDebug(pSheet));
				    err = AddMMCPage(lpProvider, new CAppPoolIdent(pSheet));
    //				err = AddMMCPage(lpProvider, new CAppPoolCache(pSheet));
    //				err = AddMMCPage(lpProvider, new CPoolProcessOpt(pSheet));
    			}
            }
		}
	}
	err.MessageBoxOnFailure();
	return err;
}

/* virtual */
HRESULT
CAppPoolNode::AddMenuItems(
    IN LPCONTEXTMENUCALLBACK lpContextMenuCallback,
    IN OUT long * pInsertionAllowed,
    IN DATA_OBJECT_TYPES type
    )
{
    ASSERT_READ_PTR(lpContextMenuCallback);

    //
    // Add base menu items
    //
    HRESULT hr = CIISObject::AddMenuItems(
        lpContextMenuCallback,
        pInsertionAllowed,
        type
        );

    ASSERT(pInsertionAllowed != NULL);
    if ((*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP) != 0)
	{
		AddMenuSeparator(lpContextMenuCallback);
		AddMenuItemByCommand(lpContextMenuCallback, IDM_START, IsStartable() ? 0 : MF_GRAYED);
		AddMenuItemByCommand(lpContextMenuCallback, IDM_STOP, IsStoppable() ? 0 : MF_GRAYED);
        AddMenuItemByCommand(lpContextMenuCallback, IDM_RECYCLE, IsRunning() ? 0 : MF_GRAYED);
    }
    if (SUCCEEDED(hr))
    {
        ASSERT(pInsertionAllowed != NULL);
        if ((*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) != 0)
        {
           AddMenuSeparator(lpContextMenuCallback);
           AddMenuItemByCommand(lpContextMenuCallback, IDM_NEW_APP_POOL);

           if (IsConfigImportExportable())
           {
               AddMenuItemByCommand(lpContextMenuCallback, IDM_NEW_APP_POOL_FROM_FILE);
           }
        }

        if ((*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK) != 0)
        {
            if (IsConfigImportExportable())
            {
                AddMenuSeparator(lpContextMenuCallback);
                AddMenuItemByCommand(lpContextMenuCallback, IDM_TASK_EXPORT_CONFIG_WIZARD);
            }
        }
    }

    return hr;
}

/* virtual */
HRESULT
CAppPoolNode::Command(
    IN long lCommandID,     
    IN CSnapInObjectRootBase * pObj,
    IN DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Handle command from context menu. 

Arguments:

    long lCommandID                 : Command ID
    CSnapInObjectRootBase * pObj    : Base object 
    DATA_OBJECT_TYPES type          : Data object type

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;
    CString name;
    DWORD command = 0;
    CError err;
    CComBSTR bstrMetaPath;
    BOOL bNeedMetabase = FALSE;
    BOOL bHaveMetabase = FALSE;

    switch (lCommandID)
    {
        case IDM_NEW_APP_POOL:
        case IDM_START:
        case IDM_STOP:
        case IDM_RECYCLE:
            bNeedMetabase = TRUE;
            break;
        default:
            bNeedMetabase = FALSE;
    }

    if (bNeedMetabase)
    {
        // WARNING:bstrMetaPath will be used by switch statement below
        VERIFY(SUCCEEDED(BuildMetaPath(bstrMetaPath)));
        err = CheckForMetabaseAccess(METADATA_PERMISSION_READ,this,TRUE,bstrMetaPath);
        if (!IsLostInterface(err))
        {
            // reset error if an other error other than No interface
            err.Reset();
        }
        if (err.Succeeded())
        {
            bHaveMetabase = TRUE;
        }
    }

    switch (lCommandID)
    {

    case IDM_NEW_APP_POOL:
        if (bHaveMetabase)
        {
            if (SUCCEEDED(hr = AddAppPool(pObj, type, m_pContainer, name)) && !name.IsEmpty())
            {
                hr = m_pContainer->InsertNewPool(name);
            }
        }
        break;

    case IDM_START:
        if (bHaveMetabase)
        {
            command = MD_APPPOOL_COMMAND_START;
        }
        break;

    case IDM_STOP:
        if (bHaveMetabase)
        {
            command = MD_APPPOOL_COMMAND_STOP;
        }
        break;

    case IDM_RECYCLE:
    {
        if (bHaveMetabase)
        {
            CIISAppPool pool(QueryAuthInfo(), (LPCTSTR)bstrMetaPath);
            err = pool.Recycle(QueryNodeName());
            hr = err;
        }
        break;
    }
    
    //
    // Pass on to base class
    //
    default:
        hr = CIISMBNode::Command(lCommandID, pObj, type);
    }

    if (command != 0)
    {
        hr = ChangeState(command);
    }

    return hr;
}

HRESULT 
CAppPoolNode::ChangeState(DWORD dwCommand)
/*++

Routine Description:
    Change the state of this instance (started/stopped/paused)

Arguments:
    DWORD dwCommand         : MD_SERVER_COMMAND_START, etc.

Return Value:
    HRESULT

--*/
{
    CError err;
    CComBSTR bstrPath;

    AFX_MANAGE_STATE(::AfxGetStaticModuleState());
    
    do
    {
        CWaitCursor wait;

        err = BuildMetaPath(bstrPath);

        CAppPoolProps prop(QueryAuthInfo(), bstrPath);

        err = prop.LoadData();
        BREAK_ON_ERR_FAILURE(err)

        err = prop.ChangeState(dwCommand);
        BREAK_ON_ERR_FAILURE(err)

        err = RefreshData();
        if (err.Succeeded())
        {
            err = RefreshDisplay();
        }
    }
    while(FALSE);

    err.MessageBoxOnFailure();

    return err;
}

////////////////////////////////////////////////////////////////////////

/* static */ int 
CApplicationNode::_rgnLabels[COL_TOTAL] =
{
    IDS_RESULT_SERVICE_DESCRIPTION,
    IDS_RESULT_PATH,
};
    

/* static */ int 
CApplicationNode::_rgnWidths[COL_TOTAL] =
{
    180,
    200,
};

/* static */
void
CApplicationNode::InitializeHeaders(LPHEADERCTRL lpHeader)
/*++

Routine Description:
    Initialize the result headers

Arguments:
    LPHEADERCTRL lpHeader : Header control

--*/
{
    CIISObject::BuildResultView(lpHeader, COL_TOTAL, _rgnLabels, _rgnWidths);
}

LPOLESTR 
CApplicationNode::QueryDisplayName()
/*++

Routine Description:

    Return primary display name of this site.
    
Arguments:

    None

Return Value:

    The display name

--*/
{
    return QueryDisplayName(FALSE);
}

LPOLESTR 
CApplicationNode::QueryDisplayName(BOOL bForceQuery)
{
    if (m_strDisplayName.IsEmpty() || bForceQuery)
    {
        CMetaKey mk(QueryInterface(), m_meta_path, METADATA_PERMISSION_READ);
        if (mk.Succeeded())
        {
            mk.QueryValue(MD_APP_FRIENDLY_NAME, m_strDisplayName);
            if (m_strDisplayName.IsEmpty())
            {
            m_strDisplayName = QueryNodeName();
            }
        }
    }
    return (LPTSTR)(LPCTSTR)m_strDisplayName;
}

HRESULT
CApplicationNode::BuildMetaPath(CComBSTR& path) const
{
    path = m_meta_path;
    return S_OK;
}

LPOLESTR 
CApplicationNode::GetResultPaneColInfo(
    IN int nCol
    )
/*++

Routine Description:

    Return result pane string for the given column number

Arguments:

    int nCol        : Column number

Return Value:

    String

--*/
{
    switch(nCol)
    {
    case COL_ALIAS:
        return QueryDisplayName();

    case COL_PATH:
        {
        CString buf;
        return (LPTSTR)(LPCTSTR)FriendlyAppRoot(m_meta_path, buf);
        }
    }

    ASSERT_MSG("Bad column number");

    return OLESTR("");
}

LPCTSTR
CApplicationNode::FriendlyAppRoot(
    LPCTSTR lpAppRoot, 
    CString & strFriendly
    )
/*++

Routine Description:

    Convert the metabase app root path to a friendly display name
    format.

Arguments:

    LPCTSTR lpAppRoot           : App root
    CString & strFriendly       : Output friendly app root format

Return Value:

    Reference to the output string

Notes:

    App root must have been cleaned from WAM format prior
    to calling this function (see first ASSERT below)

--*/
{
    if (lpAppRoot != NULL && *lpAppRoot != 0)
    {
        //
        // Make sure we cleaned up WAM format
        //
        ASSERT(*lpAppRoot != _T('/'));
        strFriendly.Empty();

        CInstanceProps prop(QueryAuthInfo(), lpAppRoot);
        HRESULT hr = prop.LoadData();

        if (SUCCEEDED(hr))
        {
            CString root, tail;
            strFriendly.Format(_T("<%s>"), prop.GetDisplayText(root));
            CMetabasePath::GetRootPath(lpAppRoot, root, &tail);
            if (!tail.IsEmpty())
            {
                //
                // Add rest of dir path
                //
                strFriendly += _T("/");
                strFriendly += tail;
            }

            //
            // Now change forward slashes in the path to backward slashes
            //
//            CvtPathToDosStyle(strFriendly);

            return strFriendly;
        }
    }    
    //
    // Bogus
    //    
    VERIFY(strFriendly.LoadString(IDS_APPROOT_UNKNOWN));

    return strFriendly;
}
//////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\app_sheet.h ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        app_sheet.h

   Abstract:
        Application property sheet relevant classes

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#ifndef _APP_SHEET_H
#define _APP_SHEET_H

#include <vector>
#include <list>
#include "inetprop.h"

#define CACHE_UNLIM_MAX     999999

typedef struct _Mapping
{
   CString ext;
   CString path;
   CString verbs;
   DWORD flags;

   _Mapping()
   {
   }
   _Mapping(const struct _Mapping& m)
   {
       ext = m.ext;
       path = m.path;
       verbs = m.verbs;
       flags = m.flags;
   }
   _Mapping(const CString& buf);
   LPCTSTR ToString(CString& buf) const;
} Mapping;

class CApplicationProps : public CMetaProperties
{
public:
	CApplicationProps(CComAuthInfo * pAuthInfo, LPCTSTR meta_path, BOOL fInherit = TRUE);
	CApplicationProps(CMetaInterface * pInterface, LPCTSTR meta_path, BOOL fInherit = TRUE);
	CApplicationProps(CMetaKey * pInterface, LPCTSTR meta_path, BOOL fInherit = TRUE);

	virtual HRESULT WriteDirtyProps();

	WORD MajorVersion()
	{
		return LOWORD(m_dwVersion);
	}
	WORD MinorVersion()
	{
		return HIWORD(m_dwVersion);
	}

protected:
	virtual void ParseFields();

	HRESULT LoadVersion();
    void LoadInitialMappings(CStringListEx& list);
    BOOL InitialDataChanged(CStringListEx& list);

public:
   CString m_ServerName;
   CString m_UserName;
   CStrPassword m_UserPassword;
   CString m_MetaPath;
   CString m_HelpPath;
   BOOL m_fIsLocal;
   BOOL m_fCompatMode;
   BOOL m_Dirty;

	MP_DWORD m_AppIsolated;                	//MD_APP_ISOLATED
	// CAspMain
	MP_BOOL m_EnableSession;              	//MD_ASP_ALLOWSESSIONSTATE
	MP_BOOL m_EnableBuffering;            	//MD_ASP_BUFFERINGON
	MP_BOOL m_EnableParents;              	//MD_ASP_ENABLEPARENTPATHS
	MP_DWORD m_SessionTimeout;             	//MD_ASP_SESSIONTIMEOUT
	MP_DWORD m_ScriptTimeout;              	//MD_ASP_SCRIPTTIMEOUT
	MP_CString m_Languages;        			//MD_ASP_SCRIPTLANGUAGE
    MP_DWORD m_AspServiceFlag;
	MP_CString m_AspSxsName;
	// CAppMappingPageBase
	MP_BOOL m_CacheISAPI;                 	//MD_CACHE_EXTENSIONS
	MP_CStringListEx m_strlMappings;		//MD_SCRIPT_MAPS
	BOOL m_fMappingsInherited;
	std::vector<CString> m_initData;

	MP_BOOL m_ServerDebug;                	//MD_ASP_ENABLESERVERDEBUG
	MP_BOOL m_ClientDebug;                	//MD_ASP_ENABLECLIENTDEBUG
	MP_BOOL m_SendAspError;               	//MD_ASP_SCRIPTERRORSSENTTOBROWSER
	MP_CString m_DefaultError;     			//MD_ASP_SCRIPTERRORMESSAGE

	BOOL m_NoCache;
	BOOL m_UnlimCache;
	BOOL m_LimCache;
    BOOL m_LimDiskCache;
	MP_DWORD m_AspScriptFileCacheSize;
	MP_DWORD m_AspMaxDiskTemplateCacheFiles;
    int m_LimCacheDiskSize;
    int m_LimCacheMemSize;
	MP_CString m_DiskCacheDir;     			//MD_ASP_DISKTEMPLATECACHEDIRECTORY
	MP_DWORD m_ScriptEngCacheMax;          	//MD_ASP_SCRIPTENGINECACHEMAX

	DWORD m_dwVersion;
//  CAppPropSheet * m_pSheet;
};


class CAppPropSheet : public CInetPropertySheet
{
	DECLARE_DYNAMIC(CAppPropSheet)

public:
	CAppPropSheet(
        CComAuthInfo * pAuthInfo,
        LPCTSTR lpszMetaPath,
        CWnd * pParentWnd  = NULL,
        LPARAM lParam = 0L,
        LPARAM lParamParent = 0L,
        UINT iSelectPage = 0
        );

   virtual ~CAppPropSheet();

public:
	// The following methods have predefined names to be compatible with
	// BEGIN_META_INST_READ and other macros.
	HRESULT QueryInstanceResult() const 
	{ 
		return m_pprops ? m_pprops->QueryResult() : S_OK;
	}
	CApplicationProps & GetInstanceProperties() { return *m_pprops; }

	virtual HRESULT LoadConfigurationParameters();
	virtual void FreeConfigurationParameters();

	//{{AFX_MSG(CAppPropSheet)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CApplicationProps * m_pprops;
};

class CAspMainPage : public CInetPropertyPage
{
	DECLARE_DYNCREATE(CAspMainPage)
public:
	CAspMainPage(CInetPropertySheet * pSheet = NULL);
	virtual ~CAspMainPage();

protected:
	enum {IDD = IDD_ASPMAIN};
    virtual BOOL OnInitDialog();
    afx_msg void OnItemChanged();
    afx_msg void OnSxs();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

protected:
	BOOL m_EnableSession;
	BOOL m_EnableBuffering;
	BOOL m_EnableParents;
	DWORD m_SessionTimeout;
	DWORD m_ScriptTimeout;
	CString m_Languages;
    DWORD m_AspServiceFlag;
    BOOL m_AspEnableSxs;
	CString m_AspSxsName;

	CEdit m_LanguagesCtrl;
    //{{AFX_VIRTUAL(CAppPoolGeneral)
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL
	virtual void SetControlsState();
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();
};

BOOL SortMappings(CListCtrl& list, int col, int order);

class CAppMappingPageBase : public CInetPropertyPage
{
public:
	CAppMappingPageBase(DWORD id, CInetPropertySheet * pSheet);
	virtual ~CAppMappingPageBase();

    enum 
    {
        COL_EXTENSION = 0,
        COL_PATH,
        COL_EXCLUSIONS
    };

protected:
    virtual OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);

    virtual BOOL OnInitDialog();
	afx_msg void OnAdd();
	afx_msg void OnEdit();
	afx_msg void OnRemove();
    afx_msg BOOL OnDblClickList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg BOOL OnItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg BOOL OnKeyDown(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg BOOL OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDlgItemChanged();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

protected:
	BOOL m_CacheISAPI;
	CListCtrl m_list;
	CStringListEx m_strlMappings;
    int m_sortCol;
    int m_sortOrder;

    //{{AFX_VIRTUAL(CAppMappingPageBase)
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();
	virtual void SetControlsState();

    void RemoveSelected(CListCtrl& lst);
};

class CAppMappingPage_iis5 : public CAppMappingPageBase
{
public:
	CAppMappingPage_iis5(CInetPropertySheet * pSheet = NULL)
        : CAppMappingPageBase(IDD, pSheet)
    {
    }
	virtual ~CAppMappingPage_iis5()
    {
    }

protected:
	enum {IDD = IDD_APPMAP_IIS5};

    DECLARE_MESSAGE_MAP()
};

class CAppMappingPage : public CAppMappingPageBase
{
public:
	CAppMappingPage(CInetPropertySheet * pSheet = NULL)
        : CAppMappingPageBase(IDD, pSheet)
    {
    }
	virtual ~CAppMappingPage()
    {
    }
protected:
	enum {IDD = IDD_APPMAP};
	CListCtrl m_list_exe;

	virtual void SetControlsState();
    void MoveItem(CListCtrl& lst, int from, int to);

    virtual BOOL OnInitDialog();
    virtual void DoDataExchange(CDataExchange * pDX);
    virtual OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	afx_msg void OnInsert();
	afx_msg void OnEditExe();
	afx_msg void OnRemoveExe();
	afx_msg void OnMoveUp();
	afx_msg void OnMoveDown();
    afx_msg BOOL OnDblClickListExe(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg BOOL OnItemChangedExe(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg BOOL OnKeyDownExe(NMHDR* pNMHDR, LRESULT* pResult);
    DECLARE_MESSAGE_MAP()
};

//////////////////////////////////////////////////////////

class CEditMapBase : public CDialog
{
public:
	CEditMapBase(UINT id, CWnd * pParent) : CDialog(id, pParent)
	{
        m_pMaps = NULL;
        // IDS_EXECUTABLE_DLL_MASK or IDS_EXECUTABLE_EXE_DLL_MASK
        m_IDS_BROWSE_BUTTON_MASK = IDS_EXECUTABLE_DLL_MASK;
	}

public:
	CString m_exec;
	CString m_exec_init;
	BOOL m_file_exists;
	BOOL m_new, m_exec_valid, m_star_maps;
	BOOL m_bIsLocal;
	DWORD m_flags;
	CListCtrl * m_pMaps;
    UINT_PTR m_IDS_BROWSE_BUTTON_MASK;

protected:
	virtual BOOL OnInitDialog();
	virtual void DoDataExchange(CDataExchange * pDX);
    BOOL SetControlsState();

protected:
	afx_msg void OnButtonBrowse();
	afx_msg void OnExecutableChanged();
    DECLARE_MESSAGE_MAP()
};

class CEditMap : public CEditMapBase
{
public:
	CEditMap(CWnd * pParent = NULL) : CEditMapBase(CEditMap::IDD, pParent)
	{
        m_star_maps = FALSE;
        m_IDS_BROWSE_BUTTON_MASK = IDS_EXECUTABLE_EXE_DLL_MASK;
	}

public:
	CString m_ext;
    int m_verbs_index;
	CString m_verbs;
	BOOL m_has_global_interceptor;
	BOOL m_script_engine;

protected:
	enum { IDD = IDD_EDITMAP };
	virtual BOOL OnInitDialog();
	virtual void DoDataExchange(CDataExchange * pDX);
    BOOL SetControlsState();

protected:
	afx_msg void OnExtChanged();
	afx_msg void OnVerbs();
	afx_msg void OnVerbsChanged();
    afx_msg void OnHelp();
	DECLARE_MESSAGE_MAP();
};

class CEditStarMap : public CEditMapBase
{
public:
	CEditStarMap(CWnd * pParent) : CEditMapBase(CEditStarMap::IDD, pParent)
	{
        m_star_maps = TRUE;
        m_IDS_BROWSE_BUTTON_MASK = IDS_EXECUTABLE_DLL_MASK;
	}
protected:
	enum { IDD = IDD_EDIT_STARMAP };
    afx_msg void OnHelp();
	DECLARE_MESSAGE_MAP();
};

class CAppCacheBase : public CInetPropertyPage
{
public:
	CAppCacheBase(DWORD id, CInetPropertySheet * pSheet);
	virtual ~CAppCacheBase();

protected:
    virtual BOOL OnInitDialog();
    afx_msg void OnItemChanged();
    DECLARE_MESSAGE_MAP()

protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    virtual HRESULT FetchLoadedValues()
    {
        return S_OK;
    }
    virtual HRESULT SaveInfo()
    {
        return S_OK;
    }
	virtual void SetControlsState();

protected:
    BOOL m_NoCache, m_UnlimCache, m_LimCache;
    CSpinButtonCtrl m_ScriptEngCacheMaxSpin;
	DWORD m_ScriptEngCacheMax;
};

class CAppCache : public CAppCacheBase
{
public:
	CAppCache(CInetPropertySheet * pSheet);
	virtual ~CAppCache();
    int BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam);

protected:
    virtual BOOL OnInitDialog();
	afx_msg void OnNoCache();
	afx_msg void OnUnlimitedCache();
	afx_msg void OnLimitedCache();
	afx_msg void OnUnlimitedDiskCache();
	afx_msg void OnLimitedDiskCache();
	afx_msg void OnBrowse();
//	afx_msg void OnItemChanged();
    DECLARE_MESSAGE_MAP()

protected:
    virtual void DoDataExchange(CDataExchange * pDX);
	virtual void SetControlsState();
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

protected:
	enum { IDD = IDD_CACHE_OPT };
    BOOL m_LimDiskCache;
    DWORD m_LimCacheDiskSize;
    DWORD m_LimCacheMemSize;
    CString m_DiskCacheDir;
    LPTSTR m_pPathTemp;
    CSpinButtonCtrl m_LimCacheMemSizeSpin;
    CSpinButtonCtrl m_LimCacheDiskSizeSpin;
};

class CAppCache_iis5 : public CAppCacheBase
{
public:
	CAppCache_iis5(CInetPropertySheet * pSheet);
	virtual ~CAppCache_iis5();

protected:
    virtual BOOL OnInitDialog();
	afx_msg void OnNoCache();
	afx_msg void OnUnlimitedCache();
	afx_msg void OnLimitedCache();
	afx_msg void OnItemChanged();
    DECLARE_MESSAGE_MAP()

protected:
    virtual void DoDataExchange(CDataExchange * pDX);
	virtual void SetControlsState();
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

protected:
	enum { IDD = IDD_CACHE_OPT_IIS5 };
    int m_AspScriptFileCacheSize;
    CSpinButtonCtrl m_AspScriptFileCacheSizeSpin;
};

class CAspDebug : public CInetPropertyPage
{
	DECLARE_DYNCREATE(CAspDebug)
public:
	CAspDebug(CInetPropertySheet * pSheet = NULL);
	virtual ~CAspDebug();

protected:
	enum {IDD = IDD_ASPDEBUG};
    virtual BOOL OnInitDialog();
    afx_msg void OnItemChanged();
    afx_msg void OnChangedError();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

protected:
    BOOL m_ServerDebug;
    BOOL m_ClientDebug;
    BOOL m_SendAspError;
    CString m_DefaultError;

    //{{AFX_VIRTUAL(CAspDebug)
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();
};

#endif //_APP_SHEET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\snapin\app_sheet.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        app_sheet.cpp

   Abstract:
        Application property sheet implementation

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#include "stdafx.h"
#include "common.h"
#include "resource.h"
#include "inetmgrapp.h"
#include "inetprop.h"
#include "shts.h"
#include "w3sht.h"
#include "app_sheet.h"
#include <algorithm>

// Defaults and ranges for properties
#define SESSION_TIMEOUT_MIN		1
#define SESSION_TIMEOUT_MAX		2000000000
#define SCRIPT_TIMEOUT_MIN		1
#define SCRIPT_TIMEOUT_MAX		2000000000
#define SCRIPT_ENG_MIN		    0
#define SCRIPT_ENG_MAX		    2000000000

#define WINHELP_NUMBER_BASE     0x20000

extern CInetmgrApp theApp;

HRESULT
AppConfigSheet(CIISMBNode * pNode,CIISMBNode * pNodeParent, LPCTSTR metapath, CWnd * pParent)
{
    if (pNode == NULL)
    {
        return E_POINTER;
    }
    CError err;
    do
    {
        CAppPropSheet * pSheet = new CAppPropSheet(
            pNode->QueryAuthInfo(),
            metapath,
            pParent,
            (LPARAM)pNode,
            (LPARAM)pNodeParent,
            NULL
            );

        CString caption;
        caption.LoadString(IDS_APPSHEET_TITLE);
        pSheet->SetTitle(caption);
        // Hide Apply button for modal dialog
        pSheet->m_psh.dwFlags |= PSH_NOAPPLYNOW;

        BOOL fCompatMode = FALSE;
        BOOL bShowCache = FALSE;
	    if (pSheet->QueryMajorVersion() >= 6)
		{
            CError err;
            CString svc, inst;
            CMetabasePath::GetServicePath(metapath, svc, NULL);
		    CMetaKey mk(pSheet->QueryAuthInfo(), svc, METADATA_PERMISSION_READ);
		    err = mk.QueryResult();
		    if (err.Succeeded())
		    {
			    err = mk.QueryValue(MD_GLOBAL_STANDARD_APP_MODE_ENABLED, fCompatMode);
		    }
		}
        else
        {
            fCompatMode = TRUE;
        }
        if (fCompatMode)
        {
            if (CMetabasePath::IsMasterInstance(metapath))
            {
                bShowCache = TRUE;
            }
            else
            {
		        CMetaKey mk(pSheet->QueryAuthInfo(), metapath, METADATA_PERMISSION_READ);
		        err = mk.QueryResult();
                DWORD isol = 0;
		        if (err.Succeeded())
		        {
			        err = mk.QueryValue(MD_APP_ISOLATED, isol);
		        }
                bShowCache = isol == eAppRunOutProcIsolated;
            }
        }
        else
        {
            bShowCache = CMetabasePath::IsMasterInstance(metapath);
        }

        CPropertyPage * pPage;
        if (pSheet->QueryMajorVersion() < 6)
        {
            pPage = new CAppMappingPage_iis5(pSheet);
        }
        else
        {
            pPage = new CAppMappingPage(pSheet);
        }
        if (pPage == NULL)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        pSheet->AddPage(pPage);

        pPage = new CAspMainPage(pSheet);
        if (pPage == NULL)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        pSheet->AddPage(pPage);

        pPage = new CAspDebug(pSheet);
        if (pPage == NULL)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        pSheet->AddPage(pPage);

        if (bShowCache)
        {
            if (pSheet->QueryMajorVersion() == 5 && pSheet->QueryMinorVersion() == 0)
            {
                pPage = new CAppCache_iis5(pSheet);
            }
            else
            {
                pPage = new CAppCache(pSheet);
            }
            if (pPage == NULL)
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            pSheet->AddPage(pPage);
        }

        CThemeContextActivator activator(theApp.GetFusionInitHandle());

        err  = pSheet->DoModal() == IDOK ? S_OK : S_FALSE;
//        pSheet->Release();
    } while (FALSE);
    return err;
}

_Mapping::_Mapping(const CString& buf)
{
	int len = buf.GetLength();
	int pos = buf.Find(_T(','));
	ASSERT(pos != -1);
	ext = buf.Left(pos);

	int pos1 = buf.Find(_T(','), ++pos);
	ASSERT(pos1 != -1);
	path = buf.Mid(pos, pos1 - pos);

	pos = pos1;
	pos1 = buf.Find(_T(','), ++pos);
	if (pos1 == -1)
	{
		flags = StrToInt(buf.Right(len - pos));
	}
	else
	{
		flags = StrToInt(buf.Mid(pos, pos1 - pos));
		verbs = buf.Right(len - pos1 - 1);
	}
}

LPCTSTR
_Mapping::ToString(CString& buf) const
{
	TCHAR num[12];
	buf = ext;
	buf += _T(",");
	buf += path;
	buf += _T(",");
	wsprintf(num, _T("%u"), flags);
	buf += num;
	if (!verbs.IsEmpty())
	{
		buf += _T(",");
		buf += verbs;
	}
    return buf;
}

void
CApplicationProps::LoadInitialMappings(CStringListEx& list)
{
	m_initData.assign(list.GetCount(), CString(_T("")));
	CString buf;
	POSITION p = list.GetHeadPosition();
	while (p != NULL)
	{
		buf = list.GetNext(p);
		m_initData.push_back(buf);
	}
}

inline bool eq_nocase(CString& str1, CString& str2)
{
    return str1.CompareNoCase(str2) == 0;
}

struct less_nocase : public std::less<CString>
{
    bool operator()(const CString& str1, const CString& str2) const
    {
        return StrCmpI(str1, str2) < 0;
    }
};

BOOL
CApplicationProps::InitialDataChanged(CStringListEx& list)
{
	std::vector<CString> newData;
	newData.assign(list.GetCount(), CString(_T("")));
	POSITION pos = list.GetHeadPosition();
	while (pos != NULL)
	{
		CString data = list.GetNext(pos);
		newData.push_back(data);
	}
	std::sort(m_initData.begin(), m_initData.end(), less_nocase());
	std::sort(newData.begin(), newData.end(), less_nocase());
	return !std::equal(newData.begin(), newData.end(), m_initData.begin(), eq_nocase);
}

CApplicationProps::CApplicationProps(
   CComAuthInfo * pAuthInfo, LPCTSTR meta_path, BOOL fInherit
   )
   : CMetaProperties(pAuthInfo, meta_path)
{
   m_fInherit = fInherit;
}

CApplicationProps::CApplicationProps(
   CMetaInterface * pInterface, LPCTSTR meta_path, BOOL fInherit
   )
   : CMetaProperties(pInterface, meta_path)
{
   m_fInherit = fInherit;
}

CApplicationProps::CApplicationProps(
   CMetaKey * pKey, LPCTSTR meta_path, BOOL fInherit
   )
   : CMetaProperties(pKey, meta_path)
{
   m_fInherit = fInherit;
}

#define CACHE_SIZE_UNDEFINED	0xfffffffe

void
CApplicationProps::ParseFields()
{
	HRESULT hr = S_OK;
	MP_DWORD asp_scriptfilecachesize = CACHE_SIZE_UNDEFINED;
	m_AspMaxDiskTemplateCacheFiles = 0;

	BEGIN_PARSE_META_RECORDS(m_dwNumEntries, m_pbMDData)
		HANDLE_META_RECORD(MD_APP_ISOLATED, m_AppIsolated)

		HANDLE_META_RECORD(MD_ASP_ALLOWSESSIONSTATE, m_EnableSession)
		HANDLE_META_RECORD(MD_ASP_BUFFERINGON, m_EnableBuffering)
		HANDLE_META_RECORD(MD_ASP_ENABLEPARENTPATHS, m_EnableParents)
		HANDLE_META_RECORD(MD_ASP_SESSIONTIMEOUT, m_SessionTimeout)
		HANDLE_META_RECORD(MD_ASP_SCRIPTTIMEOUT, m_ScriptTimeout)
		HANDLE_META_RECORD(MD_ASP_SCRIPTLANGUAGE, m_Languages)
		HANDLE_META_RECORD(MD_ASP_SERVICE_FLAGS, m_AspServiceFlag)
		HANDLE_META_RECORD(MD_ASP_SERVICE_SXS_NAME, m_AspSxsName)

		HANDLE_META_RECORD(MD_CACHE_EXTENSIONS, m_CacheISAPI)
		HANDLE_INHERITED_META_RECORD(MD_SCRIPT_MAPS, m_strlMappings, m_fMappingsInherited)

		HANDLE_META_RECORD(MD_ASP_ENABLESERVERDEBUG, m_ServerDebug)
		HANDLE_META_RECORD(MD_ASP_ENABLECLIENTDEBUG, m_ClientDebug)
		HANDLE_META_RECORD(MD_ASP_SCRIPTERRORSSENTTOBROWSER, m_SendAspError)
		HANDLE_META_RECORD(MD_ASP_SCRIPTERRORMESSAGE, m_DefaultError)

		HANDLE_META_RECORD(MD_ASP_SCRIPTENGINECACHEMAX, m_ScriptEngCacheMax)
		HANDLE_META_RECORD(MD_ASP_SCRIPTFILECACHESIZE, asp_scriptfilecachesize)
		HANDLE_META_RECORD(MD_ASP_DISKTEMPLATECACHEDIRECTORY, m_DiskCacheDir)
		HANDLE_META_RECORD(MD_ASP_MAXDISKTEMPLATECACHEFILES, m_AspMaxDiskTemplateCacheFiles)

	END_PARSE_META_RECORDS
	LoadVersion();
	LoadInitialMappings(MP_V(m_strlMappings));
	do
	{
		m_NoCache = m_UnlimCache = m_LimCache = FALSE;
		if (MajorVersion() == 5 && MinorVersion() == 0)
		{
			m_AspScriptFileCacheSize = asp_scriptfilecachesize == CACHE_SIZE_UNDEFINED ?
				0 : asp_scriptfilecachesize;
			if (m_AspScriptFileCacheSize == 0)
			{
				m_NoCache = TRUE;
			} 
			else if (m_AspScriptFileCacheSize == 0xFFFFFFFF)
			{
				m_UnlimCache = TRUE;
			}
			else
			{
				m_LimCache = TRUE;
			}
		}
		else
		{
			if (MP_V(m_DiskCacheDir).IsEmpty())
			{
				m_DiskCacheDir = _T("%windir%\\system32\\inetsrv\\ASP Compiled Templates");
			}

			m_AspScriptFileCacheSize = asp_scriptfilecachesize;
            m_LimCacheMemSize = 120;
            m_LimCacheDiskSize = 1000;
			if (m_AspMaxDiskTemplateCacheFiles == 0 
                && m_AspScriptFileCacheSize == 0)
			{
				m_NoCache = TRUE;
			}
			else if (m_AspScriptFileCacheSize == -1)
			{
				m_UnlimCache = TRUE;
			}
			else if (m_AspMaxDiskTemplateCacheFiles == -1)
			{
				m_LimCache = TRUE;
                m_LimDiskCache = FALSE;
                m_LimCacheMemSize = m_AspScriptFileCacheSize;
			}
            else
            {
                m_LimCache = TRUE;
                m_LimDiskCache = TRUE;
                m_LimCacheMemSize = m_AspScriptFileCacheSize;
                m_LimCacheDiskSize = m_AspMaxDiskTemplateCacheFiles;
            }
		}
	} while (FALSE);
}

HRESULT
CApplicationProps::WriteDirtyProps()
{
	CError err;
	BEGIN_META_WRITE()
		META_WRITE(MD_ASP_ALLOWSESSIONSTATE, m_EnableSession)
		META_WRITE(MD_ASP_BUFFERINGON, m_EnableBuffering)
		META_WRITE(MD_ASP_ENABLEPARENTPATHS, m_EnableParents)
		META_WRITE(MD_ASP_SESSIONTIMEOUT, m_SessionTimeout)
		META_WRITE(MD_ASP_SCRIPTTIMEOUT, m_ScriptTimeout)
		META_WRITE(MD_ASP_SCRIPTLANGUAGE, m_Languages)
		META_WRITE(MD_ASP_ENABLESERVERDEBUG, m_ServerDebug)
		META_WRITE(MD_ASP_ENABLECLIENTDEBUG, m_ClientDebug)
		META_WRITE(MD_ASP_SCRIPTERRORSSENTTOBROWSER, m_SendAspError)
		META_WRITE(MD_ASP_SCRIPTERRORMESSAGE, m_DefaultError)
		META_WRITE(MD_CACHE_EXTENSIONS, m_CacheISAPI)
		META_WRITE(MD_ASP_SCRIPTENGINECACHEMAX, m_ScriptEngCacheMax)
		if (MajorVersion() == 5 && MinorVersion() == 0)
		{
			if (m_NoCache)
			{
				m_AspScriptFileCacheSize = 0;
			}
			else if (m_UnlimCache)
			{
				m_AspScriptFileCacheSize = -1;
			}
			META_WRITE(MD_ASP_SCRIPTFILECACHESIZE, m_AspScriptFileCacheSize)
		}
		else
		{
			META_WRITE(MD_ASP_DISKTEMPLATECACHEDIRECTORY, m_DiskCacheDir)
			if (m_NoCache)
			{
				m_AspScriptFileCacheSize = 0;
				m_AspMaxDiskTemplateCacheFiles = 0;
			}
			else if (m_UnlimCache)
			{
				m_AspScriptFileCacheSize = -1;
			}
			else if (m_LimCache)
			{
		        m_AspScriptFileCacheSize = m_LimCacheMemSize;
                if (m_LimDiskCache)
                {
                    m_AspMaxDiskTemplateCacheFiles = m_LimCacheDiskSize;
                }
                else
                {
                    m_AspMaxDiskTemplateCacheFiles = -1;
                }
			}
            else
            {
                ASSERT(FALSE);
            }
			META_WRITE(MD_ASP_MAXDISKTEMPLATECACHEFILES, m_AspMaxDiskTemplateCacheFiles)
			META_WRITE(MD_ASP_SCRIPTFILECACHESIZE, m_AspScriptFileCacheSize)
		}
        if (MajorVersion() >= 6)
        {
		    META_WRITE(MD_ASP_SERVICE_FLAGS, m_AspServiceFlag)
		    META_WRITE(MD_ASP_SERVICE_SXS_NAME, m_AspSxsName)
        }
		// Process mappings
		if (MP_V(m_strlMappings).IsEmpty())
		{
			// User must be wants to inherit scriptmaps from the parent
			if (!m_fMappingsInherited)
			{
				FlagPropertyForDeletion(MD_SCRIPT_MAPS);
			}
		}
		else if (	MP_V(m_strlMappings).GetCount() != m_initData.size()
				||	InitialDataChanged(MP_V(m_strlMappings))
				)
		{
				META_WRITE(MD_SCRIPT_MAPS, m_strlMappings)
				m_fMappingsInherited = FALSE;
		}
	END_META_WRITE(err);
	m_Dirty = err.Succeeded();
	return err;
}

HRESULT
CApplicationProps::LoadVersion()
{
    CString info;
    CMetabasePath::GetServiceInfoPath(_T(""), info);
    CServerCapabilities sc(this, info);
    HRESULT hr = sc.LoadData();
    if (SUCCEEDED(hr))
    {
        DWORD dwVersion = sc.QueryMajorVersion();
        if (dwVersion)
        {
            m_dwVersion = dwVersion | (sc.QueryMinorVersion() << SIZE_IN_BITS(WORD));
        }
    }
	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CAppPropSheet, CInetPropertySheet)

CAppPropSheet::CAppPropSheet(
      CComAuthInfo * pAuthInfo,
      LPCTSTR lpszMetaPath,
      CWnd * pParentWnd,
      LPARAM lParam,
      LPARAM lParamParent,
      UINT iSelectPage
      )
      : CInetPropertySheet(
         pAuthInfo, lpszMetaPath, pParentWnd, lParam, lParamParent, iSelectPage),
      m_pprops(NULL)
{
}

CAppPropSheet::~CAppPropSheet()
{
   FreeConfigurationParameters();
}

HRESULT
CAppPropSheet::LoadConfigurationParameters()
{
   //
   // Load base properties
   //
   CError err;

   if (m_pprops == NULL)
   {
      //
      // First call -- load values
      //
      m_pprops = new CApplicationProps(QueryAuthInfo(), QueryMetaPath());
      if (!m_pprops)
      {
         TRACEEOLID("LoadConfigurationParameters: OOM");
         err = ERROR_NOT_ENOUGH_MEMORY;
         return err;
      }
      err = m_pprops->LoadData();
   }
   
   return err;
}

void
CAppPropSheet::FreeConfigurationParameters()
{
   CInetPropertySheet::FreeConfigurationParameters();
   delete m_pprops;
}

BEGIN_MESSAGE_MAP(CAppPropSheet, CInetPropertySheet)
    //{{AFX_MSG_MAP(CAppPoolSheet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CAspMainPage, CInetPropertyPage)

CAspMainPage::CAspMainPage(CInetPropertySheet * pSheet)
	: CInetPropertyPage(CAspMainPage::IDD, pSheet)
{
#if 0
	// hack to have new struct size with old MFC and new NT 5.0 headers
	ZeroMemory(&m_psp_ex, sizeof(PROPSHEETPAGE));
	memcpy(&m_psp_ex, &m_psp, m_psp.dwSize);
	m_psp_ex.dwSize = sizeof(PROPSHEETPAGE);
#endif
}

CAspMainPage::~CAspMainPage()
{
    m_AspEnableSxs = FALSE;
}

/* virtual */
HRESULT
CAspMainPage::FetchLoadedValues()
{
   CError err;

   BEGIN_META_INST_READ(CAppPropSheet)
      FETCH_INST_DATA_FROM_SHEET(m_EnableSession);
      FETCH_INST_DATA_FROM_SHEET(m_EnableBuffering);
      FETCH_INST_DATA_FROM_SHEET(m_EnableParents);
      FETCH_INST_DATA_FROM_