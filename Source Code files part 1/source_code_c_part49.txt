                                     );
    HRESULT ExportPair   ( /*[out]*/       CComBSTR& bstrPrivate, /*[out]*/       CComBSTR& bstrPublic );
    HRESULT ImportPrivate( /*[in] */ const CComBSTR& bstrPrivate                                       );
    HRESULT ImportPublic (                                        /*[in ]*/ const CComBSTR& bstrPublic );


    HRESULT SignData  ( /*[out]*/       CComBSTR& bstrSignature, /*[in]*/ BYTE* pbData, /*[in]*/ DWORD dwDataLen );
    HRESULT VerifyData( /*[in ]*/ const CComBSTR& bstrSignature, /*[in]*/ BYTE* pbData, /*[in]*/ DWORD dwDataLen );
};

/////////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___HCP___KEYSLIB_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\include\makefile.inc ===
$(O)\HelpServiceInterfaces_i.c : $(LOCALLIBPATH)\HelpServiceTypeLib_i.c
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\include\module.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    module.h

Abstract:
    This file contains the declaration of the CComModule extension for the service.

Revision History:
    Davide Massarenti   (Dmassare)  03/14/2000
        created

******************************************************************************/

#if !defined(__INCLUDED___PCH___MODULE_H___)
#define __INCLUDED___PCH___MODULE_H___

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <atlbase.h>

class CServiceModule : public CComModule
{
    HANDLE 				  	m_hEventShutdown;
    DWORD                   m_dwThreadID;
    HANDLE 				  	m_hMonitor;
    BOOL   				  	m_bActivity;
  
    LPCWSTR               	m_szServiceName;
	UINT                    m_iDisplayName;
	UINT                    m_iDescription;
    SERVICE_STATUS_HANDLE 	m_hServiceStatus;
    SERVICE_STATUS 		  	m_status;
	BOOL                  	m_bService;

public:
	CServiceModule();
	virtual ~CServiceModule();

	HRESULT RegisterServer  ( BOOL bRegTypeLib, BOOL bService, LPCWSTR szSvcHostGroup );
	HRESULT UnregisterServer(                                  LPCWSTR szSvcHostGroup );

	void Init( _ATL_OBJMAP_ENTRY* p, HINSTANCE h, LPCWSTR szServiceName, UINT iDisplayName, UINT iDescription, const GUID* plibid = NULL );

    BOOL	Start( BOOL bService );
    HRESULT Run  (               );

    BOOL IsInstalled(                        );
    BOOL Install    ( LPCWSTR szSvcHostGroup );
    BOOL Uninstall  ( LPCWSTR szSvcHostGroup );
    LONG Lock       (                        );
	LONG Unlock     (                        );

	void ServiceMain	 ( DWORD dwArgc, LPWSTR* lpszArgv );
    void Handler    	 ( DWORD dwOpcode                 );
    void SetServiceStatus( DWORD dwState                  );

#ifdef DEBUG
	static void ReadDebugSettings();
#endif

	void ForceShutdown();

//Implementation
private:
    void MonitorShutdown();
    BOOL StartMonitor   ();

	static void  WINAPI _ServiceMain( DWORD dwArgc, LPWSTR* lpszArgv );
    static void  WINAPI _Handler    ( DWORD dwOpcode                 );
	static DWORD WINAPI _Monitor    ( void* pv                       );
};

extern CServiceModule _Module;


#include <atlcom.h>

#include <ProjectConstants.h>

#include <locres.h>
#include <HCAppRes.h>

#include <MPC_logging.h>

#include <Debug.h>

extern MPC::NTEvent   g_NTEvents;
extern MPC::FileLog   g_ApplicationLog;

#endif // !defined(__INCLUDED___PCH___MODULE_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\include\mergedhhk.h ===
/******************************************************************************

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    MergedHHK.h

Abstract:
    This file contains the declaration of the classes used to parse and
    process HHK files.

Revision History:
    Davide Massarenti   (Dmassare)  12/18/99
        created

******************************************************************************/

#if !defined(__INCLUDED___HCP___MERGEDHHK_H___)
#define __INCLUDED___HCP___MERGEDHHK_H___

#include <TaxonomyDatabase.h>

#define HHK_BUF_SIZE (32 * 1024)

namespace HHK
{
    /*

    The Following HHK Exerpt serves as an example to keep at hand in order to understand
    the way the different objects interact.


    <LI> <OBJECT type="text/sitemap">
        <param name="Name" value=".bmp files">
        <param name="Name" value="Using Paint to create pictures">
        <param name="Local" value="app_paintbrush.htm">
        <param name="Name" value="To change the background of your desktop">
        <param name="Local" value="win_deskpr_changebackgrnd.htm">
        </OBJECT>

    */

    /*
    Entry represents just the basic HHK entries. Basic HHK entries are comprised of
    a couple of Param Name="Name" and Param Name="Local" lines. the first line contains
    in its value attribute the Title of the Entry, and the second the url. In the example
    the relevant lines are:

        <param name="Name" value="Using Paint to create pictures">
        <param name="Local" value="app_paintbrush.htm">

    In this case m_strTitle == "Using Paint to create pictures"
             and m_lstUrl == "app_paintbrush.htm"
    */
    class Entry
    {
    public:
        typedef std::list<MPC::string>    UrlList;
        typedef UrlList::iterator         UrlIter;
        typedef UrlList::const_iterator   UrlIterConst;

        MPC::string m_strTitle;
        UrlList     m_lstUrl;

        void MergeURLs( const Entry& entry );
    };

    /*
    A section, is everything that is between a line that starts with:

        <LI> <OBJECT type="text/sitemap"

    and the closing line which is:

        </OBJECT>

    A section may contain subsections. Finally a section may be in the form of multiple
    entries, or in the form of see also
    */
    class Section
    {
    public:
        typedef std::list<Entry>            EntryList;
        typedef EntryList::iterator         EntryIter;
        typedef EntryList::const_iterator   EntryIterConst;

        typedef std::list<Section*>         SectionList;
        typedef SectionList::iterator       SectionIter;
        typedef SectionList::const_iterator SectionIterConst;

        MPC::string m_strTitle;
        EntryList   m_lstEntries;

        MPC::string m_strSeeAlso;
        SectionList m_lstSeeAlso;

        Section();
        ~Section();

        void MergeURLs   ( const Entry&   entry );
        void MergeSeeAlso( const Section& sec   );

        void CleanEntries( EntryList& lstEntries );
    };

    /*
    A reader essentially Opens a stream on the CHM and reads the HHK file from within
    the CHM
    */
    class Reader
    {
    private:
        static BOOL s_fDBCSSystem;
        static LCID s_lcidSystem;

        ////////////////////////////////////////////////////////////

        CComPtr<IStream> m_stream;
        MPC::string      m_strStorage;
        CHAR             m_rgBuf[HHK_BUF_SIZE];
        LPSTR            m_szBuf_Pos;
        LPSTR            m_szBuf_End;

        MPC::string      m_strLine;
        LPCSTR           m_szLine_Pos;
        LPCSTR           m_szLine_End;
        int              m_iLevel;
        bool             m_fOpeningBraceSeen;

        inline bool IsEndOfBuffer() { return m_szBuf_Pos  >= m_szBuf_End;  }
        inline bool IsEndOfLine  () { return m_szLine_Pos >= m_szLine_End; }

        ////////////////////////////////////////////////////////////

    public:
        static LPCSTR StrChr       ( LPCSTR szString, CHAR   cSearch  );
        static LPCSTR StriStr      ( LPCSTR szString, LPCSTR szSearch );
        static int    StrColl      ( LPCSTR szLeft  , LPCSTR szRight  );
        static LPCSTR ComparePrefix( LPCSTR szString, LPCSTR szPrefix );

        Reader();
        ~Reader();

        HRESULT Init( LPCWSTR szFile );


        bool ReadNextBuffer  (                                               );
        bool GetLine         ( MPC::wstring* pstrString = NULL               );
        bool FirstNonSpace   (                             bool fWrap = true );
        bool FindCharacter   ( CHAR ch, bool fSkip = true, bool fWrap = true );
        bool FindDblQuote    (          bool fSkip = true, bool fWrap = true );
        bool FindOpeningBrace(          bool fSkip = true, bool fWrap = true );
        bool FindClosingBrace(          bool fSkip = true, bool fWrap = true );

        bool GetQuotedString( MPC::string& strString                      );
        bool GetValue       ( MPC::string& strName, MPC::string& strValue );
        bool GetType        ( MPC::string& strType                        );

        Section* Parse();
    };

    /*
    Writer has as task writing the output MERGED.HHK file
    */
    class Writer
    {
    private:
        CComPtr<MPC::FileStream> m_stream;
        CHAR                     m_rgBuf[HHK_BUF_SIZE];
        LPSTR                    m_szBuf_Pos;

        inline size_t Available() { return &m_rgBuf[HHK_BUF_SIZE] - m_szBuf_Pos; }

        ////////////////////////////////////////////////////////////

        HRESULT FlushBuffer();

    public:

        Writer();
        ~Writer();

        HRESULT Init ( LPCWSTR szFile );
        HRESULT Close(                );

        HRESULT OutputLine   ( LPCSTR   szLine );
        HRESULT OutputSection( Section* sec    );
    };

    ////////////////////////////////////////////////////////////

    class Merger
    {
    public:
        class Entity
        {
            Section* m_Section;

        protected:
            void SetSection( Section* sec );

        public:
            Entity();
            virtual ~Entity();

            virtual HRESULT Init() = 0;

            Section* GetSection();
            Section* Detach    ();

            virtual bool MoveNext() = 0;

            virtual long Size() const = 0;
        };

        class FileEntity : public Entity
        {
            MPC::wstring m_strFile;
            Reader       m_Input;

        public:
            FileEntity( LPCWSTR szFile );
            virtual ~FileEntity();

            virtual HRESULT Init();

            virtual bool MoveNext();
            virtual long Size() const;
        };

        class DbEntity : public Entity
        {
        public:
            struct match
            {
                long        ID_keyword;
                long        ID_topic;
                MPC::string strKeyword;
                MPC::string strTitle;
                MPC::string strURI;
            };

            class CompareMatches
            {
            public:
                bool operator()( /*[in]*/ const match *, /*[in]*/ const match * ) const;
            };

            typedef std::list<match>           MatchList;
            typedef MatchList::iterator        MatchIter;
            typedef MatchList::const_iterator  MatchIterConst;

            typedef std::map<match*,match*,CompareMatches> SortMap;
            typedef SortMap::iterator                      SortIter;
            typedef SortMap::const_iterator                SortIterConst;

            typedef std::map<long,match*>    TopicMap;
            typedef TopicMap::iterator       TopicIter;
            typedef TopicMap::const_iterator TopicIterConst;

            typedef std::map<long,MPC::string> KeywordMap;
            typedef KeywordMap::iterator       KeywordIter;
            typedef KeywordMap::const_iterator KeywordIterConst;

    private:
            Section::SectionList m_lst;
            Taxonomy::Updater&   m_updater;
            Taxonomy::WordSet    m_setCHM;

        public:
            DbEntity( /*[in]*/ Taxonomy::Updater& updater, /*[in]*/ Taxonomy::WordSet& setCHM );
            virtual ~DbEntity();

            virtual HRESULT Init();

            virtual bool MoveNext();
            virtual long Size() const;
        };

        class SortingFileEntity : public Entity
        {
            typedef std::vector<Section*>      SectionVec;
            typedef SectionVec::iterator       SectionIter;
            typedef SectionVec::const_iterator SectionIterConst;

            Section::SectionList m_lst;
            FileEntity           m_in;

        public:
            SortingFileEntity( LPCWSTR szFile );
            virtual ~SortingFileEntity();

            virtual HRESULT Init();

            virtual bool MoveNext();
            virtual long Size() const;
        };
        typedef std::list<Entity*>         EntityList;
        typedef EntityList::iterator       EntityIter;
        typedef EntityList::const_iterator EntityIterConst;

        EntityList m_lst;
        EntityList m_lstSelected;
        Section*   m_SectionSelected;
        Section*   m_SectionTemp;

    public:
        Merger();
        ~Merger();

        HRESULT AddFile( Entity* ent, bool fIgnoreMissing = true );

        bool     MoveNext();
        Section* GetSection();
        long     Size() const;

        HRESULT  PrepareMergedHhk   ( Writer& writer, Taxonomy::Updater& updater   , Taxonomy::WordSet& setCHM, MPC::WStringList& lst, LPCWSTR szOutputHHK );
        HRESULT  PrepareSortingOfHhk( Writer& writer, LPCWSTR            szInputHHK,                                                   LPCWSTR szOutputHHK );

        static Section* MergeSections( Section::SectionList& lst );
    };

    ////////////////////////////////////////////////////////////

};

/////////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___HCP___MERGEDHHK_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\include\newslib.h ===
/** Copyright (c) 2000 Microsoft Corporation
 ******************************************************************************
 **     Module Name:
 **
 **             Newslib.h
 **
 **     Abstract:
 **
 **             Declaration of News Headlines classes
 **
 **     Author:
 **
 **             Martha Arellano (t-alopez) 06-Dec-2000
 **
 **
 **     Revision History:
 **
 **
 ******************************************************************************
 **/

#if !defined(AFX_NEWSLIB_H__B87C3400_E0B9_48CD_A0A9_0223F4448759__INCLUDED_)
#define AFX_NEWSLIB_H__B87C3400_E0B9_48CD_A0A9_0223F4448759__INCLUDED_

////////////////////////////////////////////////////////////////////////////////

// NewsSet.xml path
#define HC_HCUPDATE_NEWSSETTINGS           HC_ROOT_HELPSVC_CONFIG L"\\NewsSet.xml"
// newsver.xml path
#define HC_HCUPDATE_NEWSVER                HC_ROOT_HELPSVC_CONFIG L"\\News\\newsver.xml"
// UpdateHeadlines.xml path
#define HC_HCUPDATE_UPDATE                 HC_ROOT_HELPSVC_CONFIG L"\\News\\UpdateHeadlines.xml"
// NewsHeadlines.xml path
#define HC_HCUPDATE_NEWSHEADLINES          HC_ROOT_HELPSVC_CONFIG L"\\News\\NewsHeadlines_"


// default URL for newsver.xml
#define NEWSSETTINGS_DEFAULT_URL           L"http://go.microsoft.com/fwlink/?LinkID=11"
//default URL for the icon for Update headlines
#define HC_HCUPDATE_UPDATEBLOCK_ICONURL	   L"http://go.microsoft.com/fwlink/?LinkId=627"	

// default Frequency
#define NEWSSETTINGS_DEFAULT_FREQUENCY     14


// Headlines RegKey Name
#define HEADLINES_REGKEY                   L"Headlines"

// Default expiration date for news items from HCUpdate
#define HCUPDATE_DEFAULT_TIMEOUT		10	

// Current number of OEM headlines
#define NUMBER_OF_OEM_HEADLINES				2

////////////////////////////////////////////////////////////////////////////////

namespace News
{
    /////////////////////////////////////////////////////////////////////////////
    //   NEWSVER
    //
    //  The NEWSVER class loads the newsver.xml file, with the information to update the news headlines
    //
    //  It defines the clases:
    //        Newsblock
    //        SKU
    //        Language
    //
    //  and the variables:
    //        URL
    //        Frequency
    //
    //        list of Languages
    //
    //
    //  Has the following functions:
    //                Download ( URL )
    //                Load( LCID, SKU )
    //
    //                get_NumbeOfNewsblocks
    //                get_NewsblockURL
    //                get_URL
    //                get_Frequency
    //
    class Newsver : public MPC::Config::TypeConstructor // hungarian: nw
    {
	public:
        //
        //  The Newsblock class stores the newsfile information from the newsver.xml file:
        //          URL
        //
        class Newsblock : public MPC::Config::TypeConstructor
        {
            DECLARE_CONFIG_MAP(Newsblock);

        public:
            MPC::wstring 	m_strURL;
            bool			m_fNewsblockHasHeadlines;

            ////////////////////

            Newsblock();

            ////////////////////////////////////////
            //
            // MPC::Config::TypeConstructor
            //
            DEFINE_CONFIG_DEFAULTTAG();
            DECLARE_CONFIG_METHODS();
            //
            ////////////////////////////////////////
        };

        typedef std::vector< Newsblock >        NewsblockVector;
        typedef NewsblockVector::iterator       NewsblockIter;
        typedef NewsblockVector::const_iterator NewsblockIterConst;

        ////////////////////////////////////////

        //
        //  The SKU class stores the SKU information from the newsver.xml file:
        //          SKU Version (Professional, Personal, ...)
        //
        //          vector of newsblocks
        //
        class SKU : public MPC::Config::TypeConstructor
        {
            DECLARE_CONFIG_MAP(SKU);

        public:
            MPC::wstring    m_strSKU;
            NewsblockVector m_vecNewsblocks;     //vector of newsblocks

            ////////////////////

            SKU();

            ////////////////////////////////////////
            //
            // MPC::Config::TypeConstructor
            //
            DEFINE_CONFIG_DEFAULTTAG();
            DECLARE_CONFIG_METHODS();
            //
            ////////////////////////////////////////
        };

        typedef std::list< SKU >        SKUList;
        typedef SKUList::iterator       SKUIter;
        typedef SKUList::const_iterator SKUIterConst;

        ////////////////////////////////////////

        //
        //  The Language class stores the Language information from the newsver.xml file:
        //          Language LCID
        //
        //          list of SKUs
        //
        class Language : public MPC::Config::TypeConstructor
        {
            DECLARE_CONFIG_MAP(Language);

        public:
            long    m_lLCID;
            SKUList m_lstSKUs;     //list of SKUs

            ////////////////////

            Language();

            ////////////////////////////////////////
            //
            // MPC::Config::TypeConstructor
            //
            DEFINE_CONFIG_DEFAULTTAG();
            DECLARE_CONFIG_METHODS();
            //
            ////////////////////////////////////////
        };

        typedef std::list< Language >        LanguageList;
        typedef LanguageList::iterator       LanguageIter;
        typedef LanguageList::const_iterator LanguageIterConst;


        ////////////////////////////////////////

	private:
        DECLARE_CONFIG_MAP(Newsver);

        MPC::wstring m_strURL;
        int          m_nFrequency;
        bool         m_fLoaded;
        bool         m_fDirty;
					 
        LanguageList m_lstLanguages;             //list of Languages
		SKU*         m_data;

    public:
        Newsver();

        ////////////////////////////////////////
        //
        // MPC::Config::TypeConstructor
        //
        DEFINE_CONFIG_DEFAULTTAG();
        DECLARE_CONFIG_METHODS();
        //
        ////////////////////////////////////////

        HRESULT Download( /*[in]*/ const MPC::wstring& strNewsverURL );

        HRESULT Load( /*[in]*/ long lLCID, /*[in]*/ const MPC::wstring& strSKU );
        bool OEMNewsblock( /*[in]*/ size_t nIndex );

        size_t  			get_NumberOfNewsblocks(                        );
        const MPC::wstring*	get_NewsblockURL      ( /*[in]*/ size_t nIndex );
        const MPC::wstring* get_URL               (                        );
        int                 get_Frequency         (                        );
    };

    /////////////////////////////////////////////////////////////////////////////
    //  Headlines
    //
    // The Headlines class manipulates the news headlines file (with 1 or more providers headlines)
    //
    //
    // It contains the clases:
    //       Headline
    //       Newsblock
    //
    // the variables:
    //       Timestamp   when was the file created from newsblocks
    //       Date        when was the file modified (and for the UI)
    //
    //       list of Newsblocks
    //
    //
    // and the methods:
    //       Clear()
    //       Load( Path )
    //       Save( Path )
    //       get_Stream ( Path )
    //       set_Timestamp()
    //       get_Timestamp
    //       get_Number_of_Newsblocks
    //       check_Number_of_Newsblocks
    //       Time_To_Update_Newsblock( BOOL )
    //
    //       Add_Provider( Name, URL, PostDate )
    //       Delete_Provider()
    //
    //       Copy_Newsblock( index, LangSKU, ProvID, Block )
    //       Add_First_Newsblock( index, LangSKU, BOOL )
    //
    class Headlines : public MPC::Config::TypeConstructor // hungarian nh
    {
    public:

        //
        // The Headline class stores the Headline information from the news headline:
        //            Icon (path)
        //            Title
        //            Link
        //            Description
        //            Expires
        //
        class Headline : public MPC::Config::TypeConstructor
        {
            DECLARE_CONFIG_MAP(Headline);

        public:
            MPC::wstring m_strIcon;
            MPC::wstring m_strTitle;
            MPC::wstring m_strLink;
            MPC::wstring m_strDescription;
            DATE         m_dtExpires;
            bool		 m_fUpdateHeadlines;

            ////////////////////

            Headline(                                             );
			Headline( /*[in]*/ const MPC::wstring& strIcon        ,
                      /*[in]*/ const MPC::wstring& strTitle       ,
                      /*[in]*/ const MPC::wstring& strLink        ,
                      /*[in]*/ const MPC::wstring& strDescription ,
                      /*[in]*/ DATE                dtExpires      ,
                      /*[in]*/ bool				   fUpdateHeadlines);

            ////////////////////////////////////////
            //
            // MPC::Config::TypeConstructor
            //
            DEFINE_CONFIG_DEFAULTTAG();
            DECLARE_CONFIG_METHODS();
            //
            ////////////////////////////////////////
        };

        typedef std::vector< Headline >        HeadlineVector;
        typedef HeadlineVector::iterator       HeadlineIter;
        typedef HeadlineVector::const_iterator HeadlineConst;

        ////////////////////////////////////////

        //
        //  The Newsblock class stores the Provider information from the news headline:
        //          Provider
        //          Link
        //          Icon
        //          Position
        //          Timestamp
        //          Frequency
        //
        //          vector of Headlines
        //
        class Newsblock : public MPC::Config::TypeConstructor
        {
            DECLARE_CONFIG_MAP(Newsblock);

		private:
			void GetFileName( MPC::wstring strURL, MPC::wstring& strFileName );
			
        public:
            MPC::wstring   m_strProvider;
            MPC::wstring   m_strLink;
            MPC::wstring   m_strIcon;
            MPC::wstring   m_strPosition;
            DATE           m_dtTimestamp;
            int            m_nFrequency;

            HeadlineVector m_vecHeadlines;                   //vector of headlines

            ////////////////////

            Newsblock();

            ////////////////////////////////////////
            //
            // MPC::Config::TypeConstructor
            //
            DEFINE_CONFIG_DEFAULTTAG();
            DECLARE_CONFIG_METHODS();
            //
            ////////////////////////////////////////

			bool TimeToUpdate();


			HRESULT Copy( /*[in]*/ const Headlines::Newsblock& block      ,
						  /*[in]*/ const MPC::wstring& 		   strLangSKU ,
						  /*[in]*/ int                 		   nProvID    );
        };

        typedef std::vector< Newsblock >        NewsblockVector;
        typedef NewsblockVector::iterator       NewsblockIter;
        typedef NewsblockVector::const_iterator NewsblockIterConst;

        ////////////////////////////////////////

	private:
        DECLARE_CONFIG_MAP(Headlines);

        DATE            m_dtTimestamp;
        DATE            m_dtDate;

        NewsblockVector m_vecNewsblocks;		// vector of newsblocks

    public:
        Headlines();

        ////////////////////////////////////////
        //
        // MPC::Config::TypeConstructor
        //
        DEFINE_CONFIG_DEFAULTTAG();
        DECLARE_CONFIG_METHODS();
        //
        ////////////////////////////////////////

        HRESULT Clear(                                      );
        HRESULT Load ( /*[in]*/ const MPC::wstring& strPath );
        HRESULT Save ( /*[in]*/ const MPC::wstring& strPath );

        HRESULT get_Stream( /*[in]*/ long lLCID, /*[in]*/ const MPC::wstring& strSKU, /*[in]*/ const MPC::wstring& strPath, /*[out]*/ IUnknown* *pVal );

        void   	   			  set_Timestamp         (							   );
		DATE   	   			  get_Timestamp         (							   ) { return m_dtTimestamp;          }
        size_t 	   			  get_NumberOfNewsblocks(							   ) { return m_vecNewsblocks.size(); }
        Headlines::Newsblock* get_Newsblock         ( /*[in]*/ size_t nBlockIndex );

        HRESULT AddNewsblock( /*[in]*/ const Headlines::Newsblock& block, /*[in]*/ const MPC::wstring& strLangSKU );
        HRESULT AddHomepageHeadlines( /*[in]*/ const Headlines::Newsblock& block );
        bool 	CheckIfImagesExist();
    };

    /////////////////////////////////////////////////////////////////////////////
    //  UpdateHeadlines
    //
    // The UpdateHeadlines class loads the UpdateHeadlines.xml file
    // that contains update headlines to insert in the news headlines
    //
    // It defines the classes:
    //         Headline
    //         SKU
    //         Language
    //
    // and the variables:
    //
    //         list of Languages
    //
    //         functions:
    //                 Load ( LCID, SKU )
    //                 Save ( )
    //                 Add ( LCID, SKU, Icon, Title, Link, #Days )
    //                 Get ( LCID, SKU, list of Headlines )
    //
    class UpdateHeadlines : public MPC::Config::TypeConstructor // hungarian: uh
    {
	public:
        //
        // The Headline class stores the Headline information from the news headline:
        //           Icon
        //           Title
        //           Link
        //           Expires
        //
        class Headline : public MPC::Config::TypeConstructor
        {
            DECLARE_CONFIG_MAP(Headline);

        public:
            MPC::wstring m_strIcon;
            MPC::wstring m_strTitle;
            MPC::wstring m_strLink;
            MPC::wstring m_strDescription;
            DATE         m_dtTimeOut;

            ////////////////////

            Headline(                                       );
            Headline( /*[in]*/ const MPC::wstring& strIcon  ,
                      /*[in]*/ const MPC::wstring& strTitle ,
                      /*[in]*/ const MPC::wstring& strLink  ,
                      /*[in]*/ const MPC::wstring& strDescription  ,
                      /*[in]*/ int                 nDays    );

            ////////////////////////////////////////
            //
            // MPC::Config::TypeConstructor
            //
            DEFINE_CONFIG_DEFAULTTAG();
            DECLARE_CONFIG_METHODS();
            //
            ////////////////////////////////////////
        };

        typedef std::vector< Headline >        HeadlineVector;
        typedef HeadlineVector::iterator       HeadlineIter;
        typedef HeadlineVector::const_iterator HeadlineConst;

        ////////////////////////////////////////

        //
        //  The SKU class stores the SKU information:
        //          SKU Version (Professional, Personal, ...)
        //
        //          vector of Newsfiles
        //
        class SKU : public MPC::Config::TypeConstructor
        {
            DECLARE_CONFIG_MAP(SKU);

        public:
            MPC::wstring   m_strSKU;
            HeadlineVector m_vecHeadlines;       //vector of news files

            ////////////////////

            SKU(                                     );
            SKU( /*[in]*/ const MPC::wstring& strSKU );

            ////////////////////////////////////////
            //
            // MPC::Config::TypeConstructor
            //
            DEFINE_CONFIG_DEFAULTTAG();
            DECLARE_CONFIG_METHODS();
            //
            ////////////////////////////////////////
        };

        typedef std::list< SKU >        SKUList;
        typedef SKUList::iterator       SKUIter;
        typedef SKUList::const_iterator SKUIterConst;

        ////////////////////////////////////////

        //
        //  The Language class stores the Language information:
        //          Language LCID
        //
        //          list of SKUs
        //
        class Language : public MPC::Config::TypeConstructor
        {
                DECLARE_CONFIG_MAP(Language);
        public:
                long    m_lLCID;
                SKUList m_lstSKUs;     //list of SKUs

                ////////////////////

                Language(                     );
                Language( /*[in]*/ long lLCID );

                ////////////////////////////////////////
                //
                // MPC::Config::TypeConstructor
                //
                DEFINE_CONFIG_DEFAULTTAG();
                DECLARE_CONFIG_METHODS();
                //
                ////////////////////////////////////////
        };

        typedef std::list< Language >        LanguageList;
        typedef LanguageList::iterator       LanguageIter;
        typedef LanguageList::const_iterator LanguageIterConst;

        ////////////////////////////////////////

	private:
        DECLARE_CONFIG_MAP(UpdateHeadlines);

        LanguageList m_lstLanguages; //list of Languages
		SKU*         m_data;
		bool         m_fLoaded;
		bool         m_fDirty;

		////////////////////

		HRESULT Locate( /*[in]*/ long lLCID, /*[in]*/ const MPC::wstring& strSKU, /*[in]*/ bool fCreate );

    public:
        UpdateHeadlines();

        ////////////////////////////////////////
        //
        // MPC::Config::TypeConstructor
        //
        DEFINE_CONFIG_DEFAULTTAG();
        DECLARE_CONFIG_METHODS();
        //
        ////////////////////////////////////////

        HRESULT Load( /*[in]*/ long                	 			lLCID        ,
                      /*[in]*/ const MPC::wstring& 	 			strSKU       );
  			 
        HRESULT Save(                                						 );	 
  			 
  			 
        HRESULT Add ( /*[in]*/ long                	 			lLCID        ,
                      /*[in]*/ const MPC::wstring& 	 			strSKU       ,
                      /*[in]*/ const MPC::wstring& 	 			strIcon      ,
                      /*[in]*/ const MPC::wstring& 	 			strTitle     ,
                      /*[in]*/ const MPC::wstring& 				strDescription ,
                      /*[in]*/ const MPC::wstring& 	 			strLink      ,
                      /*[in]*/ int       	          			nTimeOutDays ,
                      /*[in]*/ DATE							  	dtExpiryDate);
  													 			
        HRESULT AddHCUpdateHeadlines( /*[in]*/ long                	 			lLCID        ,
                      /*[in]*/ const MPC::wstring& 	 			strSKU       ,
                      /*[in]*/ News::Headlines& 				nhHeadlines);

        HRESULT DoesMoreThanOneHeadlineExist(	/*[in]*/ long					lLCID,
                                    /*[in]*/ const MPC::wstring& 	strSKU, 
                                    /*[out]*/ bool& 				fMoreThanOneHeadline,
                                    /*[out]*/ bool& 				fExactlyOneHeadline);	

    };

    ////////////////////////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////////////////////
    //   CNewslib
    //
    //  The CNewslib class stores the information in the cached newsset.xml file, that stores the user news settings:
    //  URL, Frequency (in days) and Timestamp (the time the news headlines were last updated).
    //
    //  Has the following methods:
    //        Load()
    //        Restore(LCID)
    //        Save()
    //        Time_To_Update_Newsver(BOOL)
    //        Update_Newsver
    //        Update_NewsHeadlines
    //        Update_Newsblocks
    //
    //        get_Headlines_Enabled (BOOL)
    //        get_News( LCID, SKU, IStream)
    //        get_Cached_News( LCID, SKU, IStream)
    //        get_Download_News( LCID, SKU, IStream)
    //        get_URL
    //        put_URL
    //        get_Frequency
    //        put_Frequency
    //
    //
    class Main : public MPC::Config::TypeConstructor
    {
        DECLARE_CONFIG_MAP(Main);

        MPC::wstring m_strURL;
        int          m_nFrequency;
        DATE         m_dtTimestamp;
        bool         m_fLoaded;
        bool         m_fDirty;

		long         m_lLCID;
		MPC::wstring m_strSKU;
		MPC::wstring m_strLangSKU;
		MPC::wstring m_strNewsHeadlinesPath;
		bool 		 m_fOnline;
		bool		 m_fConnectionStatusChecked;

		////////////////////

		HRESULT Init( /*[in]*/ long lLCID, /*[in]*/ BSTR bstrSKU );

    public:
        Main();

        ////////////////////////////////////////
        //
        // MPC::Config::TypeConstructor
        //
        DEFINE_CONFIG_DEFAULTTAG();
        DECLARE_CONFIG_METHODS();
        //
        ////////////////////////////////////////

        HRESULT Load   (                     );
        HRESULT Restore( /*[in]*/ long lLCID );
        HRESULT Save   (                     );

        bool IsTimeToUpdateNewsver();

        HRESULT Update_Newsver      ( /*[in/out]*/ Newsver& nwNewsver                                      );
        HRESULT Update_NewsHeadlines( /*[in/out]*/ Newsver& nwNewsver, /*[in/out]*/ Headlines& nhHeadlines );
        HRESULT Update_NewsBlocks   ( /*[in/out]*/ Newsver& nwNewsver, /*[in/out]*/ Headlines& nhHeadlines );

        HRESULT get_URL      ( /*[out]*/ BSTR *pVal   );
        HRESULT put_URL      ( /*[in ]*/ BSTR  newVal );
        HRESULT get_Frequency( /*[out]*/ int  *pVal   );
        HRESULT put_Frequency( /*[in ]*/ int   newVal );

        HRESULT get_Headlines_Enabled( /*[out]*/ VARIANT_BOOL *pVal );

        HRESULT get_News         ( /*[in]*/ long lLCID, /*[in]*/ BSTR bstrSKU, /*[out]*/ IUnknown* *pVal );
        HRESULT get_News_Cached  ( /*[in]*/ long lLCID, /*[in]*/ BSTR bstrSKU, /*[out]*/ IUnknown* *pVal );
        HRESULT get_News_Download( /*[in]*/ long lLCID, /*[in]*/ BSTR bstrSKU, /*[out]*/ IUnknown* *pVal );
        HRESULT AddHCUpdateNews		 (/*[in ]*/ const MPC::wstring&  strNewsHeadlinesPath );
        bool CheckConnectionStatus	 ();
    };

    ////////////////////////////////////////////////////////////////////////////////

    HRESULT LoadXMLFile       	 ( /*[in]*/ LPCWSTR szURL, /*[out]*/ CComPtr<IStream>& stream  );
    HRESULT LoadFileFromServer	 ( /*[in]*/ LPCWSTR szURL, /*[out]*/ CComPtr<IStream>& stream  );  
};

#endif // !defined(AFX_NEWSLIB_H__B87C3400_E0B9_48CD_A0A9_0223F4448759__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\include\safdid.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    SAFDID.h

Abstract:
    This file contains the definition of some constants used by
    the Help Center Application.

Revision History:
    Davide Massarenti   (Dmassare)  04/09/2000
        created

    Kalyani Narlanka    (kalyanin)
	    Additions for Remote Assistance
		Additions for Encryption
		Additions for Unsolicited RA

******************************************************************************/

#if !defined(__INCLUDED___PCH___SAFDID_H___)
#define __INCLUDED___PCH___SAFDID_H___

/////////////////////////////////////////////////////////////////////////

#define DISPID_SAF_BASE                                 0x08020000

#define DISPID_SAF_BASE_SR                              (DISPID_SAF_BASE + 0x0000) // ISAFReg
#define DISPID_SAF_BASE_C                               (DISPID_SAF_BASE + 0x0100) // ISAFChannel
#define DISPID_SAF_BASE_II                              (DISPID_SAF_BASE + 0x0200) // ISAFIncidentItem
#define DISPID_SAF_BASE_INC                             (DISPID_SAF_BASE + 0x0300) // ISAFIncident

#define DISPID_SAF_BASE_DC                              (DISPID_SAF_BASE + 0x0400) // ISAFDataCollection
#define DISPID_SAF_BASE_DCE                             (DISPID_SAF_BASE + 0x0500) // DSAFDataCollectionEvents
#define DISPID_SAF_BASE_DCR                             (DISPID_SAF_BASE + 0x0600) // ISAFDataCollectionReport

#define DISPID_SAF_BASE_CB                              (DISPID_SAF_BASE + 0x0700) // ISAFCabinet
#define DISPID_SAF_BASE_CBE                             (DISPID_SAF_BASE + 0x0800) // DSAFCabinetEvents

#define DISPID_SAF_BASE_ENC                             (DISPID_SAF_BASE + 0x0900) // ISAFEncrypt

#define DISPID_SAF_BASE_RDC                             (DISPID_SAF_BASE + 0x0A00) // ISAFRemoteDesktopConnection
#define DISPID_SAF_BASE_RCD                             (DISPID_SAF_BASE + 0x0B00) // ISAFRemoteConnectionData
#define DISPID_SAF_BASE_USER                            (DISPID_SAF_BASE + 0x0C00) // ISAFUser
#define DISPID_SAF_BASE_SESS                            (DISPID_SAF_BASE + 0x0D00) // ISAFSession

#define DISPID_SAF_BASE_CNOTI							(DISPID_SAF_BASE + 0x0E00) // ISAFChannelNotifyIncident

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

#define DISPID_SAF_SR__EOF                              (DISPID_SAF_BASE_SR + 0x0000)
#define DISPID_SAF_SR__VENDORID                         (DISPID_SAF_BASE_SR + 0x0001)
#define DISPID_SAF_SR__PRODUCTID                        (DISPID_SAF_BASE_SR + 0x0002)
#define DISPID_SAF_SR__VENDORNAME                       (DISPID_SAF_BASE_SR + 0x0003)
#define DISPID_SAF_SR__PRODUCTNAME                      (DISPID_SAF_BASE_SR + 0x0004)
#define DISPID_SAF_SR__PRODUCTDESCRIPTION               (DISPID_SAF_BASE_SR + 0x0005)
#define DISPID_SAF_SR__VENDORICON                       (DISPID_SAF_BASE_SR + 0x0006)
#define DISPID_SAF_SR__SUPPORTURL                       (DISPID_SAF_BASE_SR + 0x0007)

#define DISPID_SAF_SR__PUBLICKEY                        (DISPID_SAF_BASE_SR + 0x0008)
#define DISPID_SAF_SR__USERACCOUNT                      (DISPID_SAF_BASE_SR + 0x0009)

#define DISPID_SAF_SR__MOVEFIRST                    	(DISPID_SAF_BASE_SR + 0x0010)
#define DISPID_SAF_SR__MOVENEXT                     	(DISPID_SAF_BASE_SR + 0x0011)

/////////////////////////////////////////////////////////////////////////

#define DISPID_SAF_C__VENDORID                          (DISPID_SAF_BASE_C + 0x0000)
#define DISPID_SAF_C__PRODUCTID                         (DISPID_SAF_BASE_C + 0x0001)
#define DISPID_SAF_C__VENDORNAME                        (DISPID_SAF_BASE_C + 0x0002)
#define DISPID_SAF_C__PRODUCTNAME                       (DISPID_SAF_BASE_C + 0x0003)
#define DISPID_SAF_C__DESCRIPTION                       (DISPID_SAF_BASE_C + 0x0004)
#define DISPID_SAF_C__VENDORDIRECTORY                   (DISPID_SAF_BASE_C + 0x0005)
					                 					
#define DISPID_SAF_C__SECURITY                          (DISPID_SAF_BASE_C + 0x0010)
#define DISPID_SAF_C__NOTIFICATION						(DISPID_SAF_BASE_C + 0x0011)
					                 					
#define DISPID_SAF_C__INCIDENTS                         (DISPID_SAF_BASE_C + 0x0020)
#define DISPID_SAF_C__RECORDINCIDENT                    (DISPID_SAF_BASE_C + 0x0021)

/////////////////////////////////////////////////////////////////////////

#define DISPID_SAF_CNOTI_ADD							(DISPID_SAF_BASE_CNOTI + 0x0000)
#define DISPID_SAF_CNOTI_REMOVE							(DISPID_SAF_BASE_CNOTI + 0x0001)
#define DISPID_SAF_CNOTI_UPDATE							(DISPID_SAF_BASE_CNOTI + 0x0002)
#define DISPID_SAF_CNOTI_CHUPDATE						(DISPID_SAF_BASE_CNOTI + 0x0003)

/////////////////////////////////////////////////////////////////////////

#define DISPID_SAF_II__DISPLAYSTRING                    (DISPID_SAF_BASE_II  + 0x0000)
#define DISPID_SAF_II__URL                              (DISPID_SAF_BASE_II  + 0x0001)
#define DISPID_SAF_II__PROGRESS                         (DISPID_SAF_BASE_II  + 0x0002)
#define DISPID_SAF_II__XMLDATAFILE                      (DISPID_SAF_BASE_II  + 0x0003)
#define DISPID_SAF_II__CREATIONTIME                     (DISPID_SAF_BASE_II  + 0x0004)
#define DISPID_SAF_II__CHANGEDTIME                      (DISPID_SAF_BASE_II  + 0x0005)
#define DISPID_SAF_II__CLOSEDTIME                       (DISPID_SAF_BASE_II  + 0x0006)
#define DISPID_SAF_II__STATUS                           (DISPID_SAF_BASE_II  + 0x0007)
#define DISPID_SAF_II__XMLBLOB                          (DISPID_SAF_BASE_II  + 0x0008)
					                     				
#define DISPID_SAF_II__SECURITY                         (DISPID_SAF_BASE_II  + 0x0010)
#define DISPID_SAF_II__OWNER                            (DISPID_SAF_BASE_II  + 0x0011)
					                     				
#define DISPID_SAF_II__CLOSEINCIDENTITEM                (DISPID_SAF_BASE_II  + 0x0020)
#define DISPID_SAF_II__DELETEINCIDENTITEM               (DISPID_SAF_BASE_II  + 0x0021)

/////////////////////////////////////////////////////////////////////////

#define DISPID_SAF_INC__MISC                            (DISPID_SAF_BASE_INC + 0x0000)
#define DISPID_SAF_INC__SELFHELPTRACE                   (DISPID_SAF_BASE_INC + 0x0001)
#define DISPID_SAF_INC__MACHINEHISTORY                  (DISPID_SAF_BASE_INC + 0x0002)
#define DISPID_SAF_INC__MACHINESNAPSHOT                 (DISPID_SAF_BASE_INC + 0x0003)
#define DISPID_SAF_INC__PROBLEMDESCRIPTION              (DISPID_SAF_BASE_INC + 0x0004)
#define DISPID_SAF_INC__PRODUCTNAME                     (DISPID_SAF_BASE_INC + 0x0005)
#define DISPID_SAF_INC__PRODUCTID                       (DISPID_SAF_BASE_INC + 0x0006)
#define DISPID_SAF_INC__USERNAME                        (DISPID_SAF_BASE_INC + 0x0007)
#define DISPID_SAF_INC__UPLOADTYPE                      (DISPID_SAF_BASE_INC + 0x0008)
#define DISPID_SAF_INC__INCIDENTXSL                     (DISPID_SAF_BASE_INC + 0x0009)
// Salem Changes
#define DISPID_SAF_INC__RCREQUESTED                     (DISPID_SAF_BASE_INC + 0x000A)
#define DISPID_SAF_INC__RCENCRYPTED                     (DISPID_SAF_BASE_INC + 0x000B)
#define DISPID_SAF_INC__RCTICKET                        (DISPID_SAF_BASE_INC + 0x000C)
#define DISPID_SAF_INC__STARTPAGE                       (DISPID_SAF_BASE_INC + 0x000D)

#define DISPID_SAF_INC__LOADFROMSTREAM                  (DISPID_SAF_BASE_INC + 0x0010)
#define DISPID_SAF_INC__SAVETOSTREAM                    (DISPID_SAF_BASE_INC + 0x0011)
#define DISPID_SAF_INC__LOAD                            (DISPID_SAF_BASE_INC + 0x0012)
#define DISPID_SAF_INC__SAVE                            (DISPID_SAF_BASE_INC + 0x0013)
#define DISPID_SAF_INC__GETXMLASSTREAM                  (DISPID_SAF_BASE_INC + 0x0014)
#define DISPID_SAF_INC__GETXML                          (DISPID_SAF_BASE_INC + 0x0015)
#define DISPID_SAF_INC__LOADFROMXMLSTREAM				(DISPID_SAF_BASE_INC + 0x0016)
#define DISPID_SAF_INC__LOADFROMXMLFILE  				(DISPID_SAF_BASE_INC + 0x0017)
#define DISPID_SAF_INC__LOADFROMXMLSTRING				(DISPID_SAF_BASE_INC + 0x0018)
#define DISPID_SAF_INC__CLOSERAINCIDENT                 (DISPID_SAF_BASE_INC + 0x0019)


/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

#define DISPID_SAF_DC__STATUS                           (DISPID_SAF_BASE_DC   + 0x0000)
#define DISPID_SAF_DC__PERCENTDONE                      (DISPID_SAF_BASE_DC   + 0x0001)
#define DISPID_SAF_DC__ERRORCODE                        (DISPID_SAF_BASE_DC   + 0x0002)

#define DISPID_SAF_DC__MACHINEDATA_DATASPEC             (DISPID_SAF_BASE_DC   + 0x0003)
#define DISPID_SAF_DC__HISTORY_DATASPEC                 (DISPID_SAF_BASE_DC   + 0x0004)
#define DISPID_SAF_DC__HISTORY_MAXDELTAS                (DISPID_SAF_BASE_DC   + 0x0005)
#define DISPID_SAF_DC__HISTORY_MAXSUPPORTEDDELTAS       (DISPID_SAF_BASE_DC   + 0x0006)

#define DISPID_SAF_DC__ONSTATUSCHANGE                   (DISPID_SAF_BASE_DC   + 0x0010)
#define DISPID_SAF_DC__ONPROGRESS                       (DISPID_SAF_BASE_DC   + 0x0011)
#define DISPID_SAF_DC__ONCOMPLETE                       (DISPID_SAF_BASE_DC   + 0x0012)

#define DISPID_SAF_DC__REPORTS                          (DISPID_SAF_BASE_DC   + 0x0020)

#define DISPID_SAF_DC__COMPARE_SNAPSHOTS                (DISPID_SAF_BASE_DC   + 0x0030)
#define DISPID_SAF_DC__EXECUTESYNC                      (DISPID_SAF_BASE_DC   + 0x0031)
#define DISPID_SAF_DC__EXECUTEASYNC                     (DISPID_SAF_BASE_DC   + 0x0032)
#define DISPID_SAF_DC__ABORT                            (DISPID_SAF_BASE_DC   + 0x0033)

#define DISPID_SAF_DC__MACHINEDATA_GETSTREAM            (DISPID_SAF_BASE_DC   + 0x0034)
#define DISPID_SAF_DC__HISTORY_GETSTREAM                (DISPID_SAF_BASE_DC   + 0x0035)

////////////////////////////////////////

#define DISPID_SAF_DCE__ONSTATUSCHANGE                  (DISPID_SAF_BASE_DCE  + 0x0000)
#define DISPID_SAF_DCE__ONPROGRESS                      (DISPID_SAF_BASE_DCE  + 0x0001)
#define DISPID_SAF_DCE__ONCOMPLETE                      (DISPID_SAF_BASE_DCE  + 0x0002)

////////////////////////////////////////

#define DISPID_SAF_DCRC__COUNT                          (DISPID_SAF_BASE_DCRC + 0x0000)

////////////////////////////////////////

#define DISPID_SAF_DCR__NAMESPACE                       (DISPID_SAF_BASE_DCR + 0x0000)
#define DISPID_SAF_DCR__CLASS                           (DISPID_SAF_BASE_DCR + 0x0001)
#define DISPID_SAF_DCR__WQL                             (DISPID_SAF_BASE_DCR + 0x0002)
#define DISPID_SAF_DCR__ERRORCODE                       (DISPID_SAF_BASE_DCR + 0x0003)
#define DISPID_SAF_DCR__DESCRIPTION                     (DISPID_SAF_BASE_DCR + 0x0004)

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

#define DISPID_SAF_CB__IGNOREMISSINGFILES               (DISPID_SAF_BASE_CB  + 0x0000)
#define DISPID_SAF_CB__ONPROGRESSFILES                  (DISPID_SAF_BASE_CB  + 0x0001)
#define DISPID_SAF_CB__ONPROGRESSBYTES                  (DISPID_SAF_BASE_CB  + 0x0002)
#define DISPID_SAF_CB__ONCOMPLETE                       (DISPID_SAF_BASE_CB  + 0x0003)
#define DISPID_SAF_CB__STATUS                           (DISPID_SAF_BASE_CB  + 0x0004)
#define DISPID_SAF_CB__ERRORCODE                        (DISPID_SAF_BASE_CB  + 0x0005)

#define DISPID_SAF_CB__ADDFILE                          (DISPID_SAF_BASE_CB  + 0x0010)
#define DISPID_SAF_CB__COMPRESS                         (DISPID_SAF_BASE_CB  + 0x0011)
#define DISPID_SAF_CB__ABORT                            (DISPID_SAF_BASE_CB  + 0x0012)

////////////////////////////////////////

#define DISPID_SAF_CBE__ONPROGRESSFILES                 (DISPID_SAF_BASE_CBE + 0x0000)
#define DISPID_SAF_CBE__ONPROGRESSBYTES                 (DISPID_SAF_BASE_CBE + 0x0001)
#define DISPID_SAF_CBE__ONCOMPLETE                      (DISPID_SAF_BASE_CBE + 0x0002)

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

#define DISPID_SAF_ENC__ENCRYPTIONTYPE					(DISPID_SAF_BASE_ENC + 0x0000)

#define DISPID_SAF_ENC__ENCRYPTSTRING					(DISPID_SAF_BASE_ENC + 0x0010)
#define DISPID_SAF_ENC__DECRYPTSTRING					(DISPID_SAF_BASE_ENC + 0x0011)
#define DISPID_SAF_ENC__ENCRYPTFILE						(DISPID_SAF_BASE_ENC + 0x0012)
#define DISPID_SAF_ENC__DECRYPTFILE						(DISPID_SAF_BASE_ENC + 0x0013)
#define DISPID_SAF_ENC__ENCRYPTSTREAM					(DISPID_SAF_BASE_ENC + 0x0014)
#define DISPID_SAF_ENC__DECRYPTSTREAM					(DISPID_SAF_BASE_ENC + 0x0015)

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
 
#define DISPID_SAF_RDC__CONNECTREMOTEDESKTOP			(DISPID_SAF_BASE_RDC + 0x0000)

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////


#define DISPID_SAF_RCD__CONNECTIONPARMS                 (DISPID_SAF_BASE_RCD + 0x0000)
#define DISPID_SAF_RCD__SERVERNAME                      (DISPID_SAF_BASE_RCD + 0x0001)
          
#define DISPID_SAF_RCD__USERS                           (DISPID_SAF_BASE_RCD + 0x0011)
#define DISPID_SAF_RCD__SESSIONS                        (DISPID_SAF_BASE_RCD + 0x0012)
#define DISPID_SAF_RCD__INITUSERSESSIONSINFO            (DISPID_SAF_BASE_RCD + 0x0013)
#define DISPID_SAF_RCD__MODEMCONNECTED                  (DISPID_SAF_BASE_RCD + 0x0014)


/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

#define DISPID_SAF_USER__DOMAINNAME                     (DISPID_SAF_BASE_USER + 0x0010)
#define DISPID_SAF_USER__USERNAME                       (DISPID_SAF_BASE_USER + 0x0011)


/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

#define DISPID_SAF_SESS__SESSIONID                      (DISPID_SAF_BASE_SESS + 0x0010)
#define DISPID_SAF_SESS__SESSIONSTATE                   (DISPID_SAF_BASE_SESS + 0x0011)
#define DISPID_SAF_SESS__DOMAINNAME                     (DISPID_SAF_BASE_SESS + 0x0012)
#define DISPID_SAF_SESS__USERNAME                       (DISPID_SAF_BASE_SESS + 0x0013)

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___PCH___SAFDID_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\include\offlinecache.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    OfflineCache.h

Abstract:
    To speed up the start time of the Help Center, we cache in the registry the most
    common queries.

Revision History:
    Davide Massarenti   (Dmassare)  07/16/2000
        created

******************************************************************************/

#if !defined(__INCLUDED___HCP___OFFLINECACHE_H___)
#define __INCLUDED___HCP___OFFLINECACHE_H___

#include <QueryResult.h>
#include <ProjectConstants.h>

#include <TaxonomyDatabase.h>


namespace OfflineCache
{
    typedef enum
    {
        ET_INVALID             = 0,
        ET_NODE                   ,
        ET_SUBNODES               ,
        ET_SUBNODES_VISIBLE       ,
        ET_NODESANDTOPICS         ,
        ET_NODESANDTOPICS_VISIBLE ,
        ET_TOPICS                 ,
        ET_TOPICS_VISIBLE         ,
		//					      
		// Not cached...	      
		//					      
        ET_LOCATECONTEXT          ,
        ET_SEARCH                 ,
        ET_NODES_RECURSIVE        ,
        ET_TOPICS_RECURSIVE       ,
    } Entry_Type;


    class Query;
    class SetOfHelpTopics;
	class Handle;
    class Root;


    class Query
    {
        friend class SetOfHelpTopics;
        friend class Root;

        ////////////////////////////////////////

        MPC::wstring m_strID;
        int          m_iType;
        int          m_iSequence;
		bool         m_fNull;

        ////////////////////////////////////////

        friend HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/       Query& val );
        friend HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const Query& val );

        HRESULT InitFile( /*[in]*/ const MPC::wstring& strDir, /*[out]*/ MPC::wstring& strFile );

        HRESULT Store   ( /*[in]*/ const MPC::wstring& strDir, /*[in]*/ const CPCHQueryResultCollection*  pColl );
        HRESULT Retrieve( /*[in]*/ const MPC::wstring& strDir, /*[in]*/       CPCHQueryResultCollection* *pColl );
        HRESULT Remove  ( /*[in]*/ const MPC::wstring& strDir													);

    public:
        ////////////////////////////////////////

        Query();
    };


    class SetOfHelpTopics
    {
        friend class Root;

        typedef std::list<Query>          QueryList;
        typedef QueryList::iterator       QueryIter;
        typedef QueryList::const_iterator QueryIterConst;

        ////////////////////////////////////////

		Root*              m_parent;

		Taxonomy::Instance m_inst;
        QueryList    	   m_lstQueries;
        int          	   m_iLastSeq;

        ////////////////////////////////////////

        friend HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/       SetOfHelpTopics& val );
        friend HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const SetOfHelpTopics& val );


        HRESULT InitDir( /*[in]*/ MPC::wstring& strDir );


        HRESULT Find( /*[in/out]*/ LPCWSTR& szID, /*[in]*/ int iType, /*[out]*/ QueryIter& it );

		void ConnectToParent( /*[in]*/ Root* parent );

    public:
        SetOfHelpTopics();

        const Taxonomy::Instance& Instance() { return m_inst; }

		////////////////////

		bool    AreYouInterested( /*[in]*/ LPCWSTR szID, /*[in]*/ int iType                                                   );
        HRESULT Retrieve     	( /*[in]*/ LPCWSTR szID, /*[in]*/ int iType, /*[in]*/       CPCHQueryResultCollection* *pColl );
        HRESULT Store        	( /*[in]*/ LPCWSTR szID, /*[in]*/ int iType, /*[in]*/ const CPCHQueryResultCollection*  pColl );
        HRESULT RemoveQueries	(                                                                                             );
    };

	class Handle
	{
		friend class Root;

		Root*            m_main; // We have a lock on it.
		SetOfHelpTopics* m_sht;

		void Attach ( /*[in]*/ Root* main, /*[in]*/ SetOfHelpTopics* sht );
		void Release(                                                    );

	public:
		Handle();
		~Handle();

		operator SetOfHelpTopics*()   { return m_sht; }
		SetOfHelpTopics* operator->() { return m_sht; }
	};

    class Root : public CComObjectRootEx<MPC::CComSafeMultiThreadModel> // Just to have locking...
    {
		typedef CComObjectRootEx<MPC::CComSafeMultiThreadModel> super;

		friend class SetOfHelpTopics;

        typedef std::list<SetOfHelpTopics> SKUList;
        typedef SKUList::iterator          SKUIter;
        typedef SKUList::const_iterator    SKUIterConst;

		static const DWORD s_dwVersion = 0x02324351; // QC2 02

        ////////////////////////////////////////

        MPC::NamedMutex    m_nmSharedLock;
 
        bool         	   m_fReady;               // PERSISTED
        Taxonomy::Instance m_instMachine;          // PERSISTED
        SKUList            m_lstSKUs;              // PERSISTED

        bool         	   m_fMaster;              // VOLATILE
        bool         	   m_fLoaded;			   // VOLATILE
        bool         	   m_fDirty;			   // VOLATILE
		DWORD        	   m_dwDisableSave;		   // VOLATILE
		HANDLE       	   m_hChangeNotification;  // VOLATILE
	  
        ////////////////////////////////////////

        friend HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/       Root& val );
        friend HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const Root& val );


		HRESULT GetIndexFile( /*[out]*/ MPC::wstring& strIndex );
		HRESULT Load     	(                                  );
		HRESULT Save     	(                                  );
		HRESULT Clean    	(                                  );
        HRESULT SetDirty 	(                                  );


        HRESULT Find( /*[in]*/ const Taxonomy::HelpSet& ths, /*[out]*/ SKUIter& it );


    public:
        Root( /*[in]*/ bool fMaster = false );
        ~Root();

		////////////////////////////////////////////////////////////////////////////////

		static Root* s_GLOBAL;

		static HRESULT InitializeSystem( /*[in]*/ bool fMaster );
		static void    FinalizeSystem  (                       );

		////////////////////////////////////////////////////////////////////////////////

		void Lock  ();
		void Unlock();

		////////////////////

        bool     		          IsReady        ();
        const Taxonomy::Instance& MachineInstance() { return m_instMachine; }

		////////////////////

        HRESULT SetReady   	  ( /*[in]*/ bool                      fReady );
        HRESULT SetMachineInfo( /*[in]*/ const Taxonomy::Instance& inst   );

		////////////////////

		HRESULT DisableSave();
		HRESULT EnableSave ();

        HRESULT Import( /*[in]*/ const Taxonomy::Instance& inst );

        HRESULT Locate( /*[in]*/ const Taxonomy::HelpSet & ths, /*[out]*/ Handle& handle );
        HRESULT Remove( /*[in]*/ const Taxonomy::HelpSet & ths 						     );

        HRESULT Flush( /*[in]*/ bool fForce = false );


		////////////////////

		HRESULT FindMatch( /*[in]*/  LPCWSTR			szSKU      ,
						   /*[in]*/  LPCWSTR			szLanguage ,
						   /*[out]*/ Taxonomy::HelpSet& ths        );
    };
};

#endif // !defined(__INCLUDED___HCP___OFFLINECACHE_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\include\saflib.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    SAFlib.h

Abstract:
    This is declaration of SAF Channel objects

Revision History:
    Steve Shih  created  07/15/99

********************************************************************/

#if !defined(__INCLUDED___PCH___SAFLIB_H___)
#define __INCLUDED___PCH___SAFLIB_H___

#include <time.h>

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

#include <MPC_main.h>
#include <MPC_com.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_config.h>
#include <MPC_streams.h>

#include <AccountsLib.h>
#include <TaxonomyDatabase.h>

/////////////////////////////////////////////////////////////////////////////

class CSAFChannel;
class CSAFIncidentItem;
class CSAFReg;

class CIncidentStore;

typedef MPC::CComObjectParent<CSAFChannel> CSAFChannel_Object;

/////////////////////////////////////////////////////////////////////////////

#define MAX_REC_LEN 1024
#define MAX_ID      1024

class CSAFIncidentRecord
{
public:
    DWORD              m_dwRecIndex;

    CComBSTR           m_bstrVendorID;
    CComBSTR           m_bstrProductID;
    CComBSTR           m_bstrDisplay;
    CComBSTR           m_bstrURL;
    CComBSTR           m_bstrProgress;
    CComBSTR           m_bstrXMLDataFile;
    CComBSTR           m_bstrXMLBlob;
    DATE               m_dCreatedTime;
    DATE               m_dChangedTime;
    DATE               m_dClosedTime;
    IncidentStatusEnum m_iStatus;
    CComBSTR           m_bstrSecurity;
    CComBSTR           m_bstrOwner;

    CSAFIncidentRecord();

    friend HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/       CSAFIncidentRecord& increc );
    friend HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const CSAFIncidentRecord& increc );
};

class CSAFChannelRecord
{
public:
    typedef enum
    {
        SAFREG_SKU               ,
        SAFREG_Language          ,

        SAFREG_VendorID          ,
        SAFREG_ProductID         ,

        SAFREG_VendorName        ,
        SAFREG_ProductName       ,
        SAFREG_ProductDescription,

        SAFREG_VendorIcon        ,
        SAFREG_SupportUrl        ,

        SAFREG_PublicKey         ,
        SAFREG_UserAccount       ,

        SAFREG_Security          ,
        SAFREG_Notification      ,
    } SAFREG_Field;

    ////////////////////

    Taxonomy::HelpSet m_ths;

    CComBSTR          m_bstrVendorID;
    CComBSTR          m_bstrProductID;

    CComBSTR          m_bstrVendorName;
    CComBSTR          m_bstrProductName;
    CComBSTR          m_bstrDescription;

    CComBSTR          m_bstrIcon;
    CComBSTR          m_bstrURL;

    CComBSTR          m_bstrPublicKey;
    CComBSTR          m_bstrUserAccount;

    CComBSTR          m_bstrSecurity;
    CComBSTR          m_bstrNotification;

    ////////////////////

    CSAFChannelRecord();

    HRESULT GetField( /*[in]*/ SAFREG_Field field, /*[out]*/ BSTR *pVal   );
    HRESULT SetField( /*[in]*/ SAFREG_Field field, /*[in ]*/ BSTR  newVal );
};


////////////////////////////////////////////////////////////////////////////////

//
// Adding MPC::CComObjectRootParentBase to take care of the Parent Child relation between Channel and IncidentItem.
//
class ATL_NO_VTABLE CSAFChannel :
    public MPC::CComObjectRootParentBase,
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public IDispatchImpl<ISAFChannel, &IID_ISAFChannel, &LIBID_HelpServiceTypeLib>
{
public:
    typedef std::list< CSAFIncidentItem* > List;
    typedef List::iterator                 Iter;
    typedef List::const_iterator           IterConst;

private:
    CSAFChannelRecord               m_data;
    CComPtr<IPCHSecurityDescriptor> m_Security;
    List                            m_lstIncidentItems;


public:
DECLARE_NO_REGISTRY()
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSAFChannel)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISAFChannel)
END_COM_MAP()

    CSAFChannel();

    void FinalRelease();
    void Passivate   ();


    BSTR   GetVendorID        () { return m_data.m_bstrVendorID;     }
    BSTR   GetProductID       () { return m_data.m_bstrProductID;    }
    size_t GetSizeIncidentList() { return m_lstIncidentItems.size(); }


    static HRESULT OpenIncidentStore ( /*[out]*/ CIncidentStore*& pIStore );
    static HRESULT CloseIncidentStore( /*[out]*/ CIncidentStore*& pIStore );


    HRESULT Init( /*[in]*/ const CSAFChannelRecord& cr );

    HRESULT Import( /*[in]*/  const CSAFIncidentRecord&  increc ,
                    /*[out]*/ CSAFIncidentItem*         *pVal   );

    HRESULT Create( /*[in]*/  BSTR               bstrDesc        ,
                    /*[in]*/  BSTR               bstrURL         ,
                    /*[in]*/  BSTR               bstrProgress    ,
                    /*[in]*/  BSTR               bstrXMLDataFile ,
                    /*[in]*/  BSTR               bstrXMLBlob     ,
                    /*[out]*/ CSAFIncidentItem* *pVal            );

    IterConst Find( /*[in]*/ BSTR  bstrURL );
    IterConst Find( /*[in]*/ DWORD dwIndex );

    HRESULT RemoveIncidentFromList( /*[in]*/ CSAFIncidentItem* pVal );

    HRESULT Fire_NotificationEvent( /*[in]*/ int               iEventType              ,
                                    /*[in]*/ int               iCountIncidentInChannel ,
                                    /*[in]*/ ISAFChannel*      pC                      ,
                                    /*[in]*/ ISAFIncidentItem* pI                      ,
                                    /*[in]*/ DWORD             dwCode                  );

// ISAFChannel
public:
    STDMETHOD(get_VendorID       )( /*[out, retval]*/ BSTR                    *pVal   );
    STDMETHOD(get_ProductID      )( /*[out, retval]*/ BSTR                    *pVal   );
    STDMETHOD(get_VendorName     )( /*[out, retval]*/ BSTR                    *pVal   );
    STDMETHOD(get_ProductName    )( /*[out, retval]*/ BSTR                    *pVal   );
    STDMETHOD(get_Description    )( /*[out, retval]*/ BSTR                    *pVal   );
    STDMETHOD(get_VendorDirectory)( /*[out, retval]*/ BSTR                    *pVal   );

    STDMETHOD(get_Security       )( /*[out, retval]*/ IPCHSecurityDescriptor* *pVal   );
    STDMETHOD(put_Security       )( /*[in]         */ IPCHSecurityDescriptor*  newVal );

    STDMETHOD(get_Notification   )( /*[out, retval]*/ BSTR                    *pVal   );
    STDMETHOD(put_Notification   )( /*[in]         */ BSTR                     newVal );

    STDMETHOD(Incidents)( /*[in]*/ IncidentCollectionOptionEnum opt, /*[out, retval]*/ IPCHCollection* *ppC );

    STDMETHOD(RecordIncident)( /*[in]*/  BSTR               bstrDisplay  ,
                               /*[in]*/  BSTR               bstrURL      ,
                               /*[in]*/  VARIANT            vProgress    ,
                               /*[in]*/  VARIANT            vXMLDataFile ,
                               /*[in]*/  VARIANT            vXMLBlob     ,
                               /*[out]*/ ISAFIncidentItem* *pVal         );
};


///////////////////////////////////////////////////////////////////////////////////////////////////


//
// Use CComObjectRootChildEx() in place of CComObjectRootEx()
// public CComObjectRootEx<CComSingleThreadModel>,
//
// Also adding MPC::CComObjectRootParentBase to take care of the Parent Child relation between Channel and IncidentItem.
//

// This is a child of Incidents Object.
class ATL_NO_VTABLE CSAFIncidentItem :
    public MPC::CComObjectRootChildEx<MPC::CComSafeMultiThreadModel, CSAFChannel>,
    public IDispatchImpl<ISAFIncidentItem, &IID_ISAFIncidentItem, &LIBID_HelpServiceTypeLib>
{
    CSAFIncidentRecord m_increc;
    bool               m_fDirty;

public:
BEGIN_COM_MAP(CSAFIncidentItem)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISAFIncidentItem)
END_COM_MAP()

    CSAFIncidentItem();


    HRESULT Import( /*[in] */ const CSAFIncidentRecord& increc );
    HRESULT Export( /*[out]*/       CSAFIncidentRecord& increc );

    HRESULT Save();

    DWORD     GetRecIndex() { return m_increc.m_dwRecIndex; }
    CComBSTR& GetURL     () { return m_increc.m_bstrURL;    }

    bool MatchEnumOption( /*[in]*/ IncidentCollectionOptionEnum opt );

    HRESULT VerifyPermissions( /*[in]*/ bool fModify = false );

// ISAFIncidentItem
public:
    STDMETHOD(get_DisplayString)( /*[out, retval]*/ BSTR                    *pVal   );
    STDMETHOD(put_DisplayString)( /*[in]         */ BSTR                     newVal );
    STDMETHOD(get_URL          )( /*[out, retval]*/ BSTR                    *pVal   );
    STDMETHOD(put_URL          )( /*[in]         */ BSTR                     newVal );
    STDMETHOD(get_Progress     )( /*[out, retval]*/ BSTR                    *pVal   );
    STDMETHOD(put_Progress     )( /*[in]         */ BSTR                     newVal );
    STDMETHOD(get_XMLDataFile  )( /*[out, retval]*/ BSTR                    *pVal   );
    STDMETHOD(put_XMLDataFile  )( /*[in]         */ BSTR                     newVal );
    STDMETHOD(get_XMLBlob      )( /*[out, retval]*/ BSTR                    *pVal   );
    STDMETHOD(put_XMLBlob      )( /*[in]         */ BSTR                     newVal );
    STDMETHOD(get_CreationTime )( /*[out, retval]*/ DATE                    *pVal   );
    STDMETHOD(get_ClosedTime   )( /*[out, retval]*/ DATE                    *pVal   );
    STDMETHOD(get_ChangedTime  )( /*[out, retval]*/ DATE                    *pVal   );
    STDMETHOD(get_Status       )( /*[out, retval]*/ IncidentStatusEnum      *pVal   );

    STDMETHOD(get_Security     )( /*[out, retval]*/ IPCHSecurityDescriptor* *pVal   );
    STDMETHOD(put_Security     )( /*[in]         */ IPCHSecurityDescriptor*  newVal );
    STDMETHOD(get_Owner        )( /*[out, retval]*/ BSTR                    *pVal   );

    STDMETHOD(CloseIncidentItem )();
    STDMETHOD(DeleteIncidentItem)();
};

/////////////////////////////////////////////////////////////////////////////

//
// This is the read-only, flat version of CSAFReg.
//
class ATL_NO_VTABLE CSAFRegDummy :
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public IDispatchImpl<ISAFReg, &IID_ISAFReg, &LIBID_HelpServiceTypeLib>
{
    typedef std::list< CSAFChannelRecord > ChannelsList;
    typedef ChannelsList::iterator         ChannelsIter;
    typedef ChannelsList::const_iterator   ChannelsIterConst;

    ////////////////////////////////////////

    ChannelsList m_lstChannels;
    ChannelsIter m_itCurrent;  // Used by MoveFirst / MoveNext / get_EOF

    ////////////////////////////////////////

    HRESULT ReturnField( /*[in]*/ CSAFChannelRecord::SAFREG_Field field, /*[out]*/ BSTR *pVal );

    ////////////////////////////////////////

public:
BEGIN_COM_MAP(CSAFRegDummy)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISAFReg)
END_COM_MAP()

    CSAFRegDummy();

    HRESULT Append( /*[in]*/ const CSAFChannelRecord& cr );

    ////////////////////////////////////////////////////////////////////////////////

// ISAFReg
public:
    STDMETHOD(get_EOF               )( /*[out, retval]*/ VARIANT_BOOL *pVal );

    STDMETHOD(get_VendorID          )( /*[out, retval]*/ BSTR         *pVal );
    STDMETHOD(get_ProductID         )( /*[out, retval]*/ BSTR         *pVal );

    STDMETHOD(get_VendorName        )( /*[out, retval]*/ BSTR         *pVal );
    STDMETHOD(get_ProductName       )( /*[out, retval]*/ BSTR         *pVal );
    STDMETHOD(get_ProductDescription)( /*[out, retval]*/ BSTR         *pVal );

    STDMETHOD(get_VendorIcon        )( /*[out, retval]*/ BSTR         *pVal );
    STDMETHOD(get_SupportUrl        )( /*[out, retval]*/ BSTR         *pVal );

    STDMETHOD(get_PublicKey         )( /*[out, retval]*/ BSTR         *pVal );
    STDMETHOD(get_UserAccount       )( /*[out, retval]*/ BSTR         *pVal );

    STDMETHOD(MoveFirst)();
    STDMETHOD(MoveNext )();
};

/////////////////////////////////////////////////////////////////////////////
// CSAFReg
class CSAFReg :
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>, // Just for locking...
    public MPC::Config::TypeConstructor
{
    class Inner_UI : public MPC::Config::TypeConstructor
    {
        DECLARE_CONFIG_MAP(Inner_UI);

    public:
        Taxonomy::HelpSet m_ths;
        CComBSTR          m_bstrVendorName;
        CComBSTR          m_bstrProductName;
        CComBSTR          m_bstrDescription;
        CComBSTR          m_bstrIcon;
        CComBSTR          m_bstrURL;

        ////////////////////////////////////////
        //
        // MPC::Config::TypeConstructor
        //
        DEFINE_CONFIG_DEFAULTTAG();
        DECLARE_CONFIG_METHODS();
        //
        ////////////////////////////////////////
    };

    typedef std::list< Inner_UI >  UIList;
    typedef UIList::iterator       UIIter;
    typedef UIList::const_iterator UIIterConst;

    ////////////////////////////////////////

    class Inner_Product : public MPC::Config::TypeConstructor
    {
        DECLARE_CONFIG_MAP(Inner_Product);

    public:
        CComBSTR m_bstrProductID;
        UIList   m_lstUI;

        CComBSTR m_bstrSecurity;
        CComBSTR m_bstrNotification;

        ////////////////////////////////////////
        //
        // MPC::Config::TypeConstructor
        //
        DEFINE_CONFIG_DEFAULTTAG();
        DECLARE_CONFIG_METHODS();
        //
        ////////////////////////////////////////
    };

    typedef std::list< Inner_Product > ProdList;
    typedef ProdList::iterator         ProdIter;
    typedef ProdList::const_iterator   ProdIterConst;

    ////////////////////////////////////////

    class Inner_Vendor : public MPC::Config::TypeConstructor
    {
        DECLARE_CONFIG_MAP(Inner_Vendor);

    public:
        CComBSTR m_bstrVendorID;
        ProdList m_lstProducts;

        CComBSTR m_bstrPublicKey;
        CComBSTR m_bstrUserAccount;

        ////////////////////////////////////////
        //
        // MPC::Config::TypeConstructor
        //
        DEFINE_CONFIG_DEFAULTTAG();
        DECLARE_CONFIG_METHODS();
        //
        ////////////////////////////////////////
    };

    typedef std::list< Inner_Vendor >  VendorList;
    typedef VendorList::iterator       VendorIter;
    typedef VendorList::const_iterator VendorIterConst;

    ////////////////////////////////////////

    DECLARE_CONFIG_MAP(CSAFReg);

    MPC::wstring m_szSAFStore;
    VendorList   m_lstVendors;
    bool         m_fLoaded;
    bool         m_fDirty;

    ////////////////////////////////////////

    HRESULT EnsureInSync();

    HRESULT ParseFileField( /*[in]*/  MPC::XmlUtil& xml      ,
                            /*[in]*/  LPCWSTR       szTag    ,
                            /*[in]*/  CComBSTR&     bstrDest );

    HRESULT ParseFile( /*[in    ]*/ MPC::XmlUtil&      xml ,
                       /*[in/out]*/ CSAFChannelRecord& cr  );

    HRESULT MoveToChannel( /*[in ]*/ const       CSAFChannelRecord& cr ,
                           /*[in ]*/ bool        fCreate               ,
                           /*[out]*/ bool&       fFound                ,
                           /*[out]*/ VendorIter& itVendor              ,
                           /*[out]*/ ProdIter*   pitProduct = NULL     ,
                           /*[out]*/ UIIter*     pitUI      = NULL     );

    void PopulateRecord( /*[in]*/ CSAFChannelRecord& cr        ,
                         /*[in]*/ VendorIter         itVendor  ,
                         /*[in]*/ ProdIter           itProduct ,
                         /*[in]*/ UIIter             itUI      );

    ////////////////////////////////////////

public:
    CSAFReg();

    ////////////////////////////////////////
    //
    // MPC::Config::TypeConstructor
    //
    DEFINE_CONFIG_DEFAULTTAG();
    DECLARE_CONFIG_METHODS();
    //
    ////////////////////////////////////////

    HRESULT CreateReadOnlyCopy( /*[in]*/ const Taxonomy::HelpSet& ths, /*[out]*/ CSAFRegDummy* *pVal );

    HRESULT LookupAccountData( /*[in]*/ BSTR bstrVendorID, /*[out]*/ CPCHUserProcess::UserEntry& ue );

    ////////////////////////////////////////////////////////////////////////////////

    static CSAFReg* s_GLOBAL;

    static HRESULT InitializeSystem();
    static void    FinalizeSystem  ();

    ////////////////////////////////////////////////////////////////////////////////

    HRESULT RegisterSupportChannel( /*[in]*/ const CSAFChannelRecord& cr, /*[in]*/ MPC::XmlUtil& xml );
    HRESULT RemoveSupportChannel  ( /*[in]*/ const CSAFChannelRecord& cr, /*[in]*/ MPC::XmlUtil& xml );

    HRESULT UpdateField( /*[in    ]*/ const CSAFChannelRecord& cr, /*[in]*/ CSAFChannelRecord::SAFREG_Field field );
    HRESULT Synchronize( /*[in/out]*/       CSAFChannelRecord& cr, /*[out]*/ bool& fFound                         );

    HRESULT RemoveSKU( /*[in]*/ const Taxonomy::HelpSet& ths );
};

////////////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___PCH___SAFLIB_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\include\pchupdate.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    pchupdate.h

Abstract:
    This file contains the declaration of the CPCHUpdate class, that implements
    the IPCHUpdate interface.

Revision History:
    Davide Massarenti   (Dmassare)  00/00/2000
        created

******************************************************************************/

#ifndef __PCHUPDATE_H_
#define __PCHUPDATE_H_

#include <SvcResource.h>

#include <TaxonomyDatabase.h>

namespace HCUpdate
{
    class Engine;
    class VersionItem;

	////////////////////

    class ATL_NO_VTABLE VersionItem :
        public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
        public IDispatchImpl<IPCHVersionItem, &IID_IPCHVersionItem, &LIBID_HelpServiceTypeLib>
    {
        friend class Engine;

        Taxonomy::Package m_pkg;

        ////////////////////////////////////////

    public:
    BEGIN_COM_MAP(VersionItem)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IPCHVersionItem)
    END_COM_MAP()

        // IHCPHelpSessionItem
        STDMETHOD(get_SKU       )( /*[out, retval]*/ BSTR *pVal );
        STDMETHOD(get_Language  )( /*[out, retval]*/ BSTR *pVal );
        STDMETHOD(get_VendorID  )( /*[out, retval]*/ BSTR *pVal );
        STDMETHOD(get_VendorName)( /*[out, retval]*/ BSTR *pVal );
        STDMETHOD(get_ProductID )( /*[out, retval]*/ BSTR *pVal );
        STDMETHOD(get_Version   )( /*[out, retval]*/ BSTR *pVal );

        STDMETHOD(Uninstall)();
    };

    /////////////////////////////////////////////////////////////////////////////
    // Engine
    class ATL_NO_VTABLE Engine :
        public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
        public IDispatchImpl< IPCHUpdate, &IID_IPCHUpdate, &LIBID_HelpServiceTypeLib >,
        public CComCoClass  < Engine    , &CLSID_PCHUpdate                           >,
        public Taxonomy::InstallationEngine
    {
		friend class VersionItem;

        MPC::wstring          		 m_strWinDir;
	  
        Taxonomy::Logger      		 m_log;
        Taxonomy::Updater     		 m_updater;
        Taxonomy::Settings    		 m_ts;
        Taxonomy::InstalledInstance* m_sku;
        Taxonomy::Package*     		 m_pkg;

        bool                   		 m_fCreationMode;
        DWORD                  		 m_dwRefCount;
        JetBlue::SessionHandle 		 m_handle;
        JetBlue::Session*      		 m_sess;
        JetBlue::Database*     		 m_db;

        ////////////////////////////////////////////////////////////////////////////////

        typedef enum
        {
            ACTION_ADD,
            ACTION_DELETE
        } Action;

        static const LPCWSTR s_ActionText[];

        ////////////////////////////////////////////////////////////////////////////////

        static long CountNodes( /*[in]*/ IXMLDOMNodeList* poNodeList );

        ////////////////////////////////////////////////////////////////////////////////

        void    DeleteTempFile ( /*[in/out]*/ MPC::wstring& strFile );
        HRESULT PrepareTempFile( /*[in/out]*/ MPC::wstring& strFile );

        ////////////////////////////////////////////////////////////////////////////////

        HRESULT AppendVendorDir( LPCWSTR szURL, LPCWSTR szOwnerID, LPCWSTR szWinDir, LPWSTR szDest, int iMaxLen );

        HRESULT LookupAction  ( /*[in]*/ LPCWSTR szAction, /*[out]*/ Action& id                                        );
        HRESULT LookupBoolean ( /*[in]*/ LPCWSTR szString, /*[out]*/ bool&   fVal, /*[in]*/ bool fDefault = false      );
        HRESULT LookupNavModel( /*[in]*/ LPCWSTR szString, /*[out]*/ long&   lVal, /*[in]*/ long lDefault = QR_DEFAULT );

        HRESULT UpdateStopSign( /*[in]*/ Action idAction, /*[in]*/ const MPC::wstring& strContext , /*[in]*/ const MPC::wstring& strStopSign  );
        HRESULT UpdateStopWord( /*[in]*/ Action idAction,                                           /*[in]*/ const MPC::wstring& strStopWord  );
        HRESULT UpdateOperator( /*[in]*/ Action idAction, /*[in]*/ const MPC::wstring& strOperator, /*[in]*/ const MPC::wstring& strOperation );

        ////////////////////////////////////////////////////////////////////////////////

        bool IsMicrosoft() { return m_pkg->m_fMicrosoft; }

		bool IsAborted() { return (Taxonomy::InstalledInstanceStore::s_GLOBAL && Taxonomy::InstalledInstanceStore::s_GLOBAL->IsShutdown()); }

        ////////////////////////////////////////////////////////////////////////////////

        HRESULT GetNodeDepth( /*[in]*/ LPCWSTR szCategory, /*[out]*/ int& iDepth );

        HRESULT CheckNode( /*[in]*/ LPCWSTR szCategory, /*[out]*/ bool& fExist, /*[out]*/ bool& fCanCreate );

        HRESULT CheckTopic( /*[in]*/ long ID_node, /*[in]*/ LPCWSTR szURI, /*[in]*/ LPCWSTR szCategory );

        ////////////////////////////////////////////////////////////////////////////////

        HRESULT InsertNode( /*[in]*/ Action  idAction      ,
                            /*[in]*/ LPCWSTR szCategory    ,
                            /*[in]*/ LPCWSTR szEntry       ,
                            /*[in]*/ LPCWSTR szTitle       ,
                            /*[in]*/ LPCWSTR szDescription ,
                            /*[in]*/ LPCWSTR szURI         ,
                            /*[in]*/ LPCWSTR szIconURI     ,
                            /*[in]*/ bool    fVisible      ,
                            /*[in]*/ bool    fSubsite      ,
                            /*[in]*/ long    lNavModel     ,
                            /*[in]*/ long    lPos          );

        HRESULT InsertTaxonomy( /*[in]*/ MPC::XmlUtil& oXMLUtil ,
                                /*[in]*/ IXMLDOMNode*  poNode   );

        ////////////////////////////////////////////////////////////////////////////////

        HRESULT AcquireDatabase();
        void    ReleaseDatabase();

        HRESULT ProcessHHTFile( /*[in]*/ LPCWSTR       szHHTName ,
                                /*[in]*/ MPC::XmlUtil& oXMLUtil  );

        HRESULT ProcessRegisterContent( /*[in]*/ Action  idAction ,
                                        /*[in]*/ LPCWSTR szURI    );

        HRESULT ProcessInstallFile( /*[in]*/ Action  idAction      ,
                                    /*[in]*/ LPCWSTR szSource      ,
                                    /*[in]*/ LPCWSTR szDestination ,
                                    /*[in]*/ bool    fSys          ,
                                    /*[in]*/ bool    fSysHelp      );

        HRESULT ProcessSAFFile( /*[in]*/ Action        idAction  ,
                                /*[in]*/ LPCWSTR       szSAFName ,
                                /*[in]*/ MPC::XmlUtil& oXMLUtil  );

        ////////////////////////////////////////////////////////////////////////////////

    public:
    DECLARE_REGISTRY_RESOURCEID(IDR_HCUPDATE)
    DECLARE_NOT_AGGREGATABLE(Engine)

    BEGIN_COM_MAP(Engine)
        COM_INTERFACE_ENTRY(IPCHUpdate)
        COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

        Engine();

        HRESULT FinalConstruct();
        void    FinalRelease  ();

        ////////////////////////////////////////

        HRESULT StartLog (                                                                             ) { return m_log.StartLog (                          ); }
        HRESULT EndLog   (                                                                             ) { return m_log.EndLog   (                          ); }
        HRESULT WriteLogV( /*[in]*/ HRESULT hr, /*[in]*/ LPCWSTR szLogFormat, /*[in]*/ va_list arglist ) { return m_log.WriteLogV( hr, szLogFormat, arglist ); }
        HRESULT WriteLog ( /*[in]*/ HRESULT hr, /*[in]*/ LPCWSTR szLogFormat,          ...             );

        Taxonomy::Logger& GetLogger() { return m_log; }

        ////////////////////////////////////////

        HRESULT SetSkuInfo( /*[in]*/ LPCWSTR szSKU, /*[in]*/ long lLCID );

        HRESULT PopulateDatabase( /*[in]*/ LPCWSTR            szCabinet ,
                                  /*[in]*/ LPCWSTR            szHHTFile ,
                                  /*[in]*/ LPCWSTR            szLogFile ,
                                  /*[in]*/ LPCWSTR            szSKU     ,
                                  /*[in]*/ long               lLCID     ,
                                  /*[in]*/ JetBlue::Session*  sess      ,
                                  /*[in]*/ JetBlue::Database* db        );

        HRESULT InternalCreateIndex( /*[in]*/ VARIANT_BOOL bForce );

        HRESULT InternalUpdatePkg( /*[in]*/ LPCWSTR szPathname,                                  /*[in]*/ bool fImpersonate );
        HRESULT InternalRemovePkg( /*[in]*/ LPCWSTR szPathname, /*[in]*/ Taxonomy::Package* pkg, /*[in]*/ bool fImpersonate );

		HRESULT ForceSystemRestore();

        // IPCHUpdate
    public:
        STDMETHOD(get_VersionList)( /*[out, retval]*/ IPCHCollection* *ppC );

        STDMETHOD(LatestVersion)( /*[in         ]*/ BSTR     bstrVendorID  ,
                                  /*[in         ]*/ BSTR     bstrProductID ,
                                  /*[in,optional]*/ VARIANT  vSKU          ,
                                  /*[in,optional]*/ VARIANT  vLanguage     ,
                                  /*[out, retval]*/ BSTR    *pVal          );

        STDMETHOD(CreateIndex)( /*[in         ]*/ VARIANT_BOOL bForce    ,
                                /*[in,optional]*/ VARIANT      vSKU      ,
                                /*[in,optional]*/ VARIANT      vLanguage );

        STDMETHOD(UpdatePkg	   )( /*[in]*/ BSTR bstrPathname, /*[in]*/ VARIANT_BOOL bSilent                          		  );
        STDMETHOD(RemovePkg	   )( /*[in]*/ BSTR bstrPathname                                                         		  );
        STDMETHOD(RemovePkgByID)( /*[in]*/ BSTR bstrVendorID, /*[in]*/ BSTR bstrProductID, /*[in,optional]*/ VARIANT vVersion );

        // Taxonomy::InstallationEngine
        HRESULT ProcessPackage( /*[in]*/ Taxonomy::InstalledInstance& instance, /*[in]*/ Taxonomy::Package& pkg    );
		HRESULT RecreateIndex ( /*[in]*/ Taxonomy::InstalledInstance& instance, /*[in]*/ bool               fForce );
    };
};

#endif //__PCHUPDATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\include\scriptingframeworkdid.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    ScriptingFrameworkDID.h

Abstract:
    This file contains the definition of some constants used by
    the Help Center Application.

Revision History:
    Davide Massarenti   (Dmassare)  07/21/99
        created

    Kalyani Narlanka    (KalyaniN)  03/15/01
	    Moved Incident and Encryption Objects from HelpService to HelpCtr to improve Perf.

******************************************************************************/

#if !defined(__INCLUDED___PCH___SCRIPTINGFRAMEWORKDID_H___)
#define __INCLUDED___PCH___SCRIPTINGFRAMEWORKDID_H___

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

#define DISPID_PCH_BASE                                 	  0x08010000
	  
#define DISPID_PCH_BASE_COL                             	  (DISPID_PCH_BASE + 0x0000) // IPCHCollection
	  
#define DISPID_PCH_BASE_U                               	  (DISPID_PCH_BASE + 0x0100) // IPCHUtility
#define DISPID_PCH_BASE_US                              	  (DISPID_PCH_BASE + 0x0300) // IPCHUserSettings
	  
#define DISPID_PCH_BASE_QR                              	  (DISPID_PCH_BASE + 0x0400) // IPCHQueryResult
#define DISPID_PCH_BASE_TDB                             	  (DISPID_PCH_BASE + 0x0500) // IPCHTaxonomyDatabase
#define DISPID_PCH_BASE_SHT                             	  (DISPID_PCH_BASE + 0x0600) // IPCHSetOfHelpTopics
#define DISPID_PCH_BASE_SHTE                            	  (DISPID_PCH_BASE + 0x0680) // DPCHSetOfHelpTopicsEvents
	  
#define DISPID_PCH_BASE_S                               	  (DISPID_PCH_BASE + 0x0700) // IPCHSecurity
#define DISPID_PCH_BASE_SD                              	  (DISPID_PCH_BASE + 0x0800) // IPCHSecurityDescriptor
#define DISPID_PCH_BASE_ACL                             	  (DISPID_PCH_BASE + 0x0900) // IPCHAccessControlList
#define DISPID_PCH_BASE_ACE                             	  (DISPID_PCH_BASE + 0x0A00) // IPCHAccessControlEntry

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

#define DISPID_PCH_COL__COUNT                           	  (DISPID_PCH_BASE_COL  + 0x0000)

////////////////////////////////////////

#define DISPID_PCH_U__USERSETTINGS                     	   	  (DISPID_PCH_BASE_U    + 0x0000)
#define DISPID_PCH_U__CHANNELS                         	   	  (DISPID_PCH_BASE_U    + 0x0001)
#define DISPID_PCH_U__SECURITY                         	   	  (DISPID_PCH_BASE_U    + 0x0002)
#define DISPID_PCH_U__CONNECTIVITY                     	   	  (DISPID_PCH_BASE_U    + 0x0003)
#define DISPID_PCH_U__DATABASE                         	   	  (DISPID_PCH_BASE_U    + 0x0004)
   	  
#define DISPID_PCH_U__FORMATERROR                      	   	  (DISPID_PCH_BASE_U    + 0x0010)
   	  
#define DISPID_PCH_U__CREATEOBJECT_SEARCHENGINEMGR     	   	  (DISPID_PCH_BASE_U    + 0x0020)
#define DISPID_PCH_U__CREATEOBJECT_DATACOLLECTION      	   	  (DISPID_PCH_BASE_U    + 0x0021)
#define DISPID_PCH_U__CREATEOBJECT_CABINET             	   	  (DISPID_PCH_BASE_U    + 0x0022)
#define DISPID_PCH_U__CREATEOBJECT_ENCRYPTION         	   	  (DISPID_PCH_BASE_U    + 0x0023)
#define DISPID_PCH_U__CREATEOBJECT_CHANNEL             	   	  (DISPID_PCH_BASE_U    + 0x0024)
#define DISPID_PCH_U__CREATEOBJECT_REMOTEDESKTOPCONNECTION 	  (DISPID_PCH_BASE_U    + 0x0025)
#define DISPID_PCH_U__CREATEOBJECT_REMOTEDESKTOPSESSION	      (DISPID_PCH_BASE_U    + 0x0026)
#define DISPID_PCH_U__CONNECTTOEXPERT                         (DISPID_PCH_BASE_U    + 0x0027)
#define DISPID_PCH_U__SWITCHDESKTOPMODE                       (DISPID_PCH_BASE_U    + 0x0028)

////////////////////////////////////////	  
	  
#define DISPID_PCH_US__CURRENTSKU                       	  (DISPID_PCH_BASE_US   + 0x0000)
#define DISPID_PCH_US__MACHINESKU                       	  (DISPID_PCH_BASE_US   + 0x0001)
	  
#define DISPID_PCH_US__HELPLOCATION                     	  (DISPID_PCH_BASE_US   + 0x0008)
#define DISPID_PCH_US__DATABASEDIR                      	  (DISPID_PCH_BASE_US   + 0x0009)
#define DISPID_PCH_US__DATABASEFILE                     	  (DISPID_PCH_BASE_US   + 0x000A)
#define DISPID_PCH_US__INDEXFILE                        	  (DISPID_PCH_BASE_US   + 0x000B)
#define DISPID_PCH_US__INDEXDISPLAYNAME                   	  (DISPID_PCH_BASE_US   + 0x000C)
#define DISPID_PCH_US__LASTUPDATED                      	  (DISPID_PCH_BASE_US   + 0x000D)

#define DISPID_PCH_US__AREHEADLINESENABLED                 	  (DISPID_PCH_BASE_US   + 0x000E)
#define DISPID_PCH_US__NEWS                               	  (DISPID_PCH_BASE_US   + 0x000F)
	  
#define DISPID_PCH_US__SELECT                           	  (DISPID_PCH_BASE_US   + 0x0010)

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

#define DISPID_PCH_QR__CATEGORY                         	  (DISPID_PCH_BASE_QR   + 0x0000)
#define DISPID_PCH_QR__ENTRY                            	  (DISPID_PCH_BASE_QR   + 0x0001)
#define DISPID_PCH_QR__TOPIC_URL                        	  (DISPID_PCH_BASE_QR   + 0x0002)
#define DISPID_PCH_QR__ICON_URL                         	  (DISPID_PCH_BASE_QR   + 0x0003)
#define DISPID_PCH_QR__TITLE                            	  (DISPID_PCH_BASE_QR   + 0x0004)
#define DISPID_PCH_QR__DESCRIPTION                      	  (DISPID_PCH_BASE_QR   + 0x0005)
#define DISPID_PCH_QR__TYPE                             	  (DISPID_PCH_BASE_QR   + 0x0006)
#define DISPID_PCH_QR__POS                              	  (DISPID_PCH_BASE_QR   + 0x0007)
#define DISPID_PCH_QR__VISIBLE                          	  (DISPID_PCH_BASE_QR   + 0x0008)
#define DISPID_PCH_QR__SUBSITE                                (DISPID_PCH_BASE_QR   + 0x0009)
#define DISPID_PCH_QR__NAVIGATIONMODEL                        (DISPID_PCH_BASE_QR   + 0x000A)
#define DISPID_PCH_QR__PRIORITY                               (DISPID_PCH_BASE_QR   + 0x000B)

#define DISPID_PCH_QR__FULLPATH                   	          (DISPID_PCH_BASE_QR   + 0x0020)
	  
////////////////////////////////////////	  
	  
#define DISPID_PCH_TDB__INSTALLEDSKUS                   	  (DISPID_PCH_BASE_TDB  + 0x0000)
#define DISPID_PCH_TDB__HASWRITEPERMISSIONS             	  (DISPID_PCH_BASE_TDB  + 0x0001)
	  
#define DISPID_PCH_TDB__LOOKUPNODE                      	  (DISPID_PCH_BASE_TDB  + 0x0010)
#define DISPID_PCH_TDB__LOOKUPSUBNODES                  	  (DISPID_PCH_BASE_TDB  + 0x0011)
#define DISPID_PCH_TDB__LOOKUPTOPICS                    	  (DISPID_PCH_BASE_TDB  + 0x0012)
#define DISPID_PCH_TDB__LOOKUPNODESANDTOPICS               	  (DISPID_PCH_BASE_TDB  + 0x0013)
#define DISPID_PCH_TDB__LOCATECONTEXT                   	  (DISPID_PCH_BASE_TDB  + 0x0014)
#define DISPID_PCH_TDB__KEYWORDSEARCH                   	  (DISPID_PCH_BASE_TDB  + 0x0015)
	  
#define DISPID_PCH_TDB__GATHERNODES                     	  (DISPID_PCH_BASE_TDB  + 0x0018)
#define DISPID_PCH_TDB__GATHERTOPICS                    	  (DISPID_PCH_BASE_TDB  + 0x0019)
	  
#define DISPID_PCH_TDB__CONNECTTODISK                   	  (DISPID_PCH_BASE_TDB  + 0x0020)
#define DISPID_PCH_TDB__CONNECTTOSERVER                 	  (DISPID_PCH_BASE_TDB  + 0x0021)
#define DISPID_PCH_TDB__ABORT                           	  (DISPID_PCH_BASE_TDB  + 0x0022)
	  
////////////////////////////////////////	  
	  
#define DISPID_PCH_SHT__SKU                             	  (DISPID_PCH_BASE_SHT  + 0x0000)
#define DISPID_PCH_SHT__LANGUAGE                        	  (DISPID_PCH_BASE_SHT  + 0x0001)
#define DISPID_PCH_SHT__DISPLAYNAME                     	  (DISPID_PCH_BASE_SHT  + 0x0002)
#define DISPID_PCH_SHT__PRODUCTID                       	  (DISPID_PCH_BASE_SHT  + 0x0003)
#define DISPID_PCH_SHT__VERSION                         	  (DISPID_PCH_BASE_SHT  + 0x0004)
	  																				
#define DISPID_PCH_SHT__LOCATION                        	  (DISPID_PCH_BASE_SHT  + 0x0005)
#define DISPID_PCH_SHT__EXPORTED                        	  (DISPID_PCH_BASE_SHT  + 0x0006)
	  																				
#define DISPID_PCH_SHT__ONSTATUSCHANGE                  	  (DISPID_PCH_BASE_SHT  + 0x0007)
#define DISPID_PCH_SHT__STATUS                          	  (DISPID_PCH_BASE_SHT  + 0x0008)
#define DISPID_PCH_SHT__ERRORCODE                       	  (DISPID_PCH_BASE_SHT  + 0x0009)
	  																				
#define DISPID_PCH_SHT__ISMACHINEHELP                   	  (DISPID_PCH_BASE_SHT  + 0x000A)
#define DISPID_PCH_SHT__ISINSTALLED                     	  (DISPID_PCH_BASE_SHT  + 0x000B)
#define DISPID_PCH_SHT__CANINSTALL                      	  (DISPID_PCH_BASE_SHT  + 0x000C)
#define DISPID_PCH_SHT__CANUNINSTALL                    	  (DISPID_PCH_BASE_SHT  + 0x000D)
	  																				
#define DISPID_PCH_SHT__INSTALL                         	  (DISPID_PCH_BASE_SHT  + 0x0020)
#define DISPID_PCH_SHT__UNINSTALL                       	  (DISPID_PCH_BASE_SHT  + 0x0021)
#define DISPID_PCH_SHT__ABORT                           	  (DISPID_PCH_BASE_SHT  + 0x0022)
	  																				
////////////////////////////////////////	  										
	  																				
#define DISPID_PCH_SHTE__ONSTATUSCHANGE                 	  (DISPID_PCH_BASE_SHTE + 0x0000)

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

#define DISPID_PCH_S__CREATEOBJECT_SECURITYDESCRIPTOR   	  (DISPID_PCH_BASE_S   	+ 0x0000)
#define DISPID_PCH_S__CREATEOBJECT_ACCESSCONTROLLIST    	  (DISPID_PCH_BASE_S   	+ 0x0001)
#define DISPID_PCH_S__CREATEOBJECT_ACCESSCONTROLENTRY   	  (DISPID_PCH_BASE_S   	+ 0x0002)
	   
#define DISPID_PCH_S__GETUSERNAME  		           			  (DISPID_PCH_BASE_S   	+ 0x0008)
#define DISPID_PCH_S__GETUSERDOMAIN		           			  (DISPID_PCH_BASE_S   	+ 0x0009)
#define DISPID_PCH_S__GETUSERDISPLAYNAME           			  (DISPID_PCH_BASE_S   	+ 0x000A)
	   
#define DISPID_PCH_S__CHECKCREDENTIALS             			  (DISPID_PCH_BASE_S   	+ 0x0010)
#define DISPID_PCH_S__CHECKACCESSTOSD              			  (DISPID_PCH_BASE_S   	+ 0x0011)
#define DISPID_PCH_S__CHECKACCESSTOFILE             		  (DISPID_PCH_BASE_S   	+ 0x0012)
#define DISPID_PCH_S__CHECKACCESSTOREGISTRY             	  (DISPID_PCH_BASE_S   	+ 0x0013)
	   
#define DISPID_PCH_S__GETFILESD                         	  (DISPID_PCH_BASE_S   	+ 0x0018)
#define DISPID_PCH_S__SETFILESD                         	  (DISPID_PCH_BASE_S   	+ 0x0019)
#define DISPID_PCH_S__GETREGISTRYSD                     	  (DISPID_PCH_BASE_S   	+ 0x001A)
#define DISPID_PCH_S__SETREGISTRYSD                     	  (DISPID_PCH_BASE_S   	+ 0x001B)
	   
////////////////////////////////////////	   
	   
#define DISPID_PCH_SD__REVISION                         	  (DISPID_PCH_BASE_SD  	+ 0x0000)
#define DISPID_PCH_SD__CONTROL                          	  (DISPID_PCH_BASE_SD  	+ 0x0001)
#define DISPID_PCH_SD__OWNER                            	  (DISPID_PCH_BASE_SD  	+ 0x0002)
#define DISPID_PCH_SD__OWNERDEFAULTED                   	  (DISPID_PCH_BASE_SD  	+ 0x0003)
#define DISPID_PCH_SD__GROUP                            	  (DISPID_PCH_BASE_SD  	+ 0x0004)
#define DISPID_PCH_SD__GROUPDEFAULTED                   	  (DISPID_PCH_BASE_SD  	+ 0x0005)
#define DISPID_PCH_SD__DISCRETIONARYACL                 	  (DISPID_PCH_BASE_SD  	+ 0x0006)
#define DISPID_PCH_SD__DACLDEFAULTED                    	  (DISPID_PCH_BASE_SD  	+ 0x0007)
#define DISPID_PCH_SD__SYSTEMACL                        	  (DISPID_PCH_BASE_SD  	+ 0x0008)
#define DISPID_PCH_SD__SACLDEFAULTED                    	  (DISPID_PCH_BASE_SD  	+ 0x0009)
	   
#define DISPID_PCH_SD__CLONE                            	  (DISPID_PCH_BASE_SD  	+ 0x0010)
#define DISPID_PCH_SD__LOADXML                          	  (DISPID_PCH_BASE_SD  	+ 0x0011)
#define DISPID_PCH_SD__LOADXMLASSTRING                  	  (DISPID_PCH_BASE_SD  	+ 0x0012)
#define DISPID_PCH_SD__LOADXMLASSTREAM                  	  (DISPID_PCH_BASE_SD  	+ 0x0013)
#define DISPID_PCH_SD__SAVEXML                          	  (DISPID_PCH_BASE_SD  	+ 0x0014)
#define DISPID_PCH_SD__SAVEXMLASSTRING                  	  (DISPID_PCH_BASE_SD  	+ 0x0015)
#define DISPID_PCH_SD__SAVEXMLASSTREAM                  	  (DISPID_PCH_BASE_SD  	+ 0x0016)
	   
////////////////////////////////////////	   
	   
#define DISPID_PCH_ACL__COUNT                           	  (DISPID_PCH_BASE_ACL 	+ 0x0000)
#define DISPID_PCH_ACL__ACLREVISION                     	  (DISPID_PCH_BASE_ACL 	+ 0x0001)
	   
#define DISPID_PCH_ACL__ADDACE                          	  (DISPID_PCH_BASE_ACL 	+ 0x0010)
#define DISPID_PCH_ACL__REMOVEACE                       	  (DISPID_PCH_BASE_ACL 	+ 0x0011)
#define DISPID_PCH_ACL__CLONE                           	  (DISPID_PCH_BASE_ACL 	+ 0x0012)
#define DISPID_PCH_ACL__LOADXML                         	  (DISPID_PCH_BASE_ACL 	+ 0x0013)
#define DISPID_PCH_ACL__LOADXMLASSTRING                 	  (DISPID_PCH_BASE_ACL 	+ 0x0014)
#define DISPID_PCH_ACL__LOADXMLASSTREAM                 	  (DISPID_PCH_BASE_ACL 	+ 0x0015)
#define DISPID_PCH_ACL__SAVEXML                         	  (DISPID_PCH_BASE_ACL 	+ 0x0016)
#define DISPID_PCH_ACL__SAVEXMLASSTRING                 	  (DISPID_PCH_BASE_ACL 	+ 0x0017)
#define DISPID_PCH_ACL__SAVEXMLASSTREAM                 	  (DISPID_PCH_BASE_ACL 	+ 0x0018)
	   
////////////////////////////////////////	   
	   
#define DISPID_PCH_ACE__ACCESSMASK                      	  (DISPID_PCH_BASE_ACE 	+ 0x0000)
#define DISPID_PCH_ACE__ACETYPE                         	  (DISPID_PCH_BASE_ACE 	+ 0x0001)
#define DISPID_PCH_ACE__ACEFLAGS                        	  (DISPID_PCH_BASE_ACE 	+ 0x0002)
#define DISPID_PCH_ACE__FLAGS                           	  (DISPID_PCH_BASE_ACE 	+ 0x0003)
#define DISPID_PCH_ACE__OBJECTTYPE                      	  (DISPID_PCH_BASE_ACE 	+ 0x0004)
#define DISPID_PCH_ACE__INHERITEDOBJECTTYPE             	  (DISPID_PCH_BASE_ACE 	+ 0x0005)
#define DISPID_PCH_ACE__TRUSTEE                         	  (DISPID_PCH_BASE_ACE 	+ 0x0006)
	   
#define DISPID_PCH_ACE__ISEQUIVALENT                    	  (DISPID_PCH_BASE_ACE 	+ 0x0010)
#define DISPID_PCH_ACE__CLONE                           	  (DISPID_PCH_BASE_ACE 	+ 0x0011)
#define DISPID_PCH_ACE__LOADXML                         	  (DISPID_PCH_BASE_ACE 	+ 0x0012)
#define DISPID_PCH_ACE__LOADXMLASSTRING                 	  (DISPID_PCH_BASE_ACE 	+ 0x0013)
#define DISPID_PCH_ACE__LOADXMLASSTREAM                 	  (DISPID_PCH_BASE_ACE 	+ 0x0014)
#define DISPID_PCH_ACE__SAVEXML                         	  (DISPID_PCH_BASE_ACE 	+ 0x0015)
#define DISPID_PCH_ACE__SAVEXMLASSTRING                 	  (DISPID_PCH_BASE_ACE 	+ 0x0016)
#define DISPID_PCH_ACE__SAVEXMLASSTREAM                 	  (DISPID_PCH_BASE_ACE 	+ 0x0017)

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___PCH___SCRIPTINGFRAMEWORKDID_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\include\queryresult.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    QueryResult.h

Abstract:
    This file contains the declaration of the classes used to store
    results from queries to the database.

Revision History:
    Davide Massarenti   (Dmassare)  07/26/99
        created

******************************************************************************/

#if !defined(__INCLUDED___PCH___QUERYRESULT_H___)
#define __INCLUDED___PCH___QUERYRESULT_H___

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

#include <MPC_streams.h>

////////////////////////////////////////////////////////////////////////////////

typedef MPC::CComCollection< IPCHCollection, &LIBID_HelpServiceTypeLib, MPC::CComSafeMultiThreadModel> CPCHBaseCollection;

class ATL_NO_VTABLE CPCHCollection : // Hungarian: hcpc
    public CPCHBaseCollection
{
public:
BEGIN_COM_MAP(CPCHCollection)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHCollection)
END_COM_MAP()
};

/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHQueryResult : // Hungarian: hcpqr
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public IDispatchImpl< IPCHQueryResult, &IID_IPCHQueryResult, &LIBID_HelpServiceTypeLib >
{
public:
    struct Payload
    {
        CComBSTR m_bstrCategory;
        CComBSTR m_bstrEntry;
        CComBSTR m_bstrTopicURL;
        CComBSTR m_bstrIconURL;
        CComBSTR m_bstrTitle;
        CComBSTR m_bstrDescription;
        long     m_lType;
        long     m_lPos;
        bool     m_fVisible;
        bool     m_fSubsite;
        long     m_lNavModel;
        long     m_lPriority;

        Payload();
    };

private:
    Payload m_data;

public:
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPCHQueryResult)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHQueryResult)
END_COM_MAP()

    CPCHQueryResult();

    HRESULT Load( /*[in]*/ MPC::Serializer& streamIn  );
    HRESULT Save( /*[in]*/ MPC::Serializer& streamOut ) const;

    void Initialize( /*[in]*/ Payload& data );

    const Payload& GetData() { return m_data; }

public:
    //
    // IPCHQueryResult
    //
    STDMETHOD(get_Category       )( /*[out]*/ BSTR         *pVal );
    STDMETHOD(get_Entry          )( /*[out]*/ BSTR         *pVal );
    STDMETHOD(get_TopicURL       )( /*[out]*/ BSTR         *pVal );
    STDMETHOD(get_IconURL        )( /*[out]*/ BSTR         *pVal );
    STDMETHOD(get_Title          )( /*[out]*/ BSTR         *pVal );
    STDMETHOD(get_Description    )( /*[out]*/ BSTR         *pVal );
    STDMETHOD(get_Type           )( /*[out]*/ long         *pVal );
    STDMETHOD(get_Pos            )( /*[out]*/ long         *pVal );
    STDMETHOD(get_Visible        )( /*[out]*/ VARIANT_BOOL *pVal );
    STDMETHOD(get_Subsite        )( /*[out]*/ VARIANT_BOOL *pVal );
    STDMETHOD(get_NavigationModel)( /*[out]*/ QR_NAVMODEL  *pVal );
    STDMETHOD(get_Priority       )( /*[out]*/ long         *pVal );

    STDMETHOD(get_FullPath       )( /*[out]*/ BSTR         *pVal );
};

/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHQueryResultCollection :
    public CPCHBaseCollection,
    public IPersistStream
{
    typedef std::list< CPCHQueryResult* > List;
    typedef List::iterator                Iter;
    typedef List::const_iterator          IterConst;

    List m_results;

public:
BEGIN_COM_MAP(CPCHQueryResultCollection)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHCollection)
    COM_INTERFACE_ENTRY(IPersistStream)
END_COM_MAP()

    CPCHQueryResultCollection();
    ~CPCHQueryResultCollection();

    static HRESULT MakeLocalCopyIfPossible( /*[in]*/ IPCHCollection* pRemote, /*[out]*/ IPCHCollection* *pLocal );

    typedef enum
    {
        SORT_BYCONTENTTYPE,
        SORT_BYPRIORITY   ,
        SORT_BYURL        ,
        SORT_BYTITLE      ,
    } SortMode;

    ////////////////////////////////////////
    //
    // IPersist
    //
    STDMETHOD(GetClassID)( /*[out]*/ CLSID *pClassID );
    //
    // IPersistStream
    //
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)( /*[in]*/ IStream *pStm                            );
    STDMETHOD(Save)( /*[in]*/ IStream *pStm, /*[in]*/ BOOL fClearDirty );
    STDMETHOD(GetSizeMax)( /*[out]*/ ULARGE_INTEGER *pcbSize );
    //
    ////////////////////////////////////////

    int     Size (                                     ) const;
    void    Erase(                                     );
    HRESULT Load ( /*[in]*/ MPC::Serializer& streamIn  );
    HRESULT Save ( /*[in]*/ MPC::Serializer& streamOut ) const;

    HRESULT CreateItem(                     /*[out]*/ CPCHQueryResult* *item );
    HRESULT GetItem   ( /*[in]*/ long lPos, /*[out]*/ CPCHQueryResult* *item );

    HRESULT LoadFromCache( /*[in]*/ IStream* stream );
    HRESULT SaveToCache  ( /*[in]*/ IStream* stream ) const;

    HRESULT Sort( /*[in]*/ SortMode mode, /*[in]*/ int iLimit = -1 );
};

#endif // !defined(__INCLUDED___PCH___QUERYRESULT_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\include\searchenginelib.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    SearchEngineLib.h

Abstract:
    This file contains the declaration of the classes involved in
    the SearchEngine Application.

Revision History:
    Ghim-Sim Chua   (gschua)  04/10/2000
        created

******************************************************************************/

#if !defined(__INCLUDED___PCH___SEARCHENGINELIB_H___)
#define __INCLUDED___PCH___SEARCHENGINELIB_H___

#include <TaxonomyDatabase.h>

#include <MPC_security.h>

/////////////////////////////////////////////////////////////////////////////

namespace SearchEngine
{
    class ATL_NO_VTABLE Manager :
        public MPC::CComObjectRootParentBase,
        public MPC::ConnectionPointImpl< Manager, &DIID_DPCHSEMgrEvents, MPC::CComSafeMultiThreadModel >,
        public IDispatchImpl           < IPCHSEManager, &IID_IPCHSEManager, &LIBID_HelpServiceTypeLib  >,
        public MPC::Thread<Manager,IUnknown>
    {
        typedef std::list< IPCHSEWrapperItem* > WrapperItemList;
        typedef WrapperItemList::iterator       WrapperItemIter;
        typedef WrapperItemList::const_iterator WrapperItemIterConst;

		Taxonomy::HelpSet              m_ths;

        WrapperItemList                m_lstWrapperItem;
        bool                           m_fInitialized;
        MPC::FileLog                   m_fl;
        MPC::Impersonation             m_imp;

        CComBSTR                       m_bstrQueryString;
        long                           m_lNumResult;
        long                           m_lEnabledSE;
        long                           m_lCountComplete;
        HRESULT                        m_hrLastError;

        CComPtr<IPCHSEManagerInternal> m_Notifier;
        CComPtr<IDispatch>             m_Progress;
        CComPtr<IDispatch>             m_Complete;
        CComPtr<IDispatch>             m_WrapperComplete;

        ////////////////////////////////////////

        HRESULT Fire_OnProgress       ( /*[in]*/ long lDone, /*[in]*/ long lTotal, /*[in]*/ BSTR bstrSEWrapperName );
        HRESULT Fire_OnComplete       ( /*[in]*/ long lSucceeded                                                   );
        HRESULT Fire_OnWrapperComplete( /*[in]*/ IPCHSEWrapperItem* pIPCHSEWICompleted                             );

        HRESULT CreateAndAddWrapperToList( /*[in]*/ MPC::SmartLock<_ThreadModel>& lock      ,
										   /*[in]*/ BSTR                          bstrCLSID ,
										   /*[in]*/ BSTR                          bstrID    ,
										   /*[in]*/ BSTR                          bstrData  );

        void    AcquireLock( /*[in]*/ MPC::SmartLock<_ThreadModel>& lock );
        HRESULT Initialize ( /*[in]*/ MPC::SmartLock<_ThreadModel>& lock );

        HRESULT ExecQuery();

		void CloneListOfWrappers( /*[out]*/ WrapperItemList& lst );

    public:
    BEGIN_COM_MAP(Manager)
        COM_INTERFACE_ENTRY2(IDispatch, IPCHSEManager)
        COM_INTERFACE_ENTRY(IPCHSEManager)
        COM_INTERFACE_ENTRY(IConnectionPointContainer)
    END_COM_MAP()

        Manager();

		//
		// This is called by the CComObjectParent.Release method, to prepare for shutdown.
		//
        void Passivate();

        HRESULT IsNetworkAlive        (                                /*[out]*/ VARIANT_BOOL *pvbVar );
        HRESULT IsDestinationReachable( /*[in]*/ BSTR bstrDestination, /*[out]*/ VARIANT_BOOL *pvbVar );

    public:
        // IPCHSEManager
        STDMETHOD(get_QueryString       )( /*[out, retval]*/ BSTR       *pVal     );
        STDMETHOD(put_QueryString       )( /*[in]*/          BSTR        newVal   );
        STDMETHOD(get_NumResult         )( /*[out, retval]*/ long       *pVal     );
        STDMETHOD(put_NumResult         )( /*[in]*/          long        newVal   );
        STDMETHOD(put_onComplete        )( /*[in]*/          IDispatch*  function );
        STDMETHOD(put_onProgress        )( /*[in]*/          IDispatch*  function );
        STDMETHOD(put_onWrapperComplete )( /*[in]*/          IDispatch*  function );
        STDMETHOD(get_SKU               )( /*[out, retval]*/ BSTR       *pVal     );
        STDMETHOD(get_LCID              )( /*[out, retval]*/ long       *pVal     );

        STDMETHOD(AbortQuery        )(                                        );
        STDMETHOD(ExecuteAsynchQuery)(                                        );
        STDMETHOD(EnumEngine        )( /*[out, retval]*/ IPCHCollection* *ppC );

        ////////////////////////////////////////

        // Internal Initialization.
        HRESULT InitializeFromDatabase( /*[in]*/ const Taxonomy::HelpSet& ths );

        HRESULT NotifyWrapperComplete( /*[in]*/ long lSucceeded, /*[in]*/ IPCHSEWrapperItem* pIPCHSEWICompleted );
        HRESULT LogRecord( /*[in]*/ BSTR bstrRecord );
    };

    typedef MPC::CComObjectParent<Manager> Manager_Object;

    class ATL_NO_VTABLE ManagerInternal :
        public MPC::CComObjectRootChildEx<MPC::CComSafeMultiThreadModel, Manager>,
        public IDispatchImpl<IPCHSEManagerInternal, &IID_IPCHSEManagerInternal, &LIBID_HelpServiceTypeLib>
    {
    public:
    BEGIN_COM_MAP(ManagerInternal)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IPCHSEManagerInternal)
    END_COM_MAP()

        // IPCHSEManagerInternal
    public:
        STDMETHOD(WrapperComplete)( /*[in]*/ long lSucceeded, /*[in]*/ IPCHSEWrapperItem* pIPCHSEWICompleted );

        STDMETHOD(IsNetworkAlive        )(                                /*[out]*/ VARIANT_BOOL *pvbVar );
        STDMETHOD(IsDestinationReachable)( /*[in]*/ BSTR bstrDestination, /*[out]*/ VARIANT_BOOL *pvbVar );

        STDMETHOD(LogRecord)( /*[in]*/ BSTR bstrRecord );
    };

    ////////////////////////////////////////////////////////////////////////////////

    struct ResultItem_Data
    {
        CComBSTR m_bstrTitle;
        CComBSTR m_bstrURI;
        long     m_lContentType;
        CComBSTR m_bstrLocation;
        long     m_lHits;
        double   m_dRank;
        CComBSTR m_bstrImageURL;
        CComBSTR m_bstrVendor;
        CComBSTR m_bstrProduct;
        CComBSTR m_bstrComponent;
        CComBSTR m_bstrDescription;
        DATE     m_dateLastModified;

        ResultItem_Data();
    };

    class ATL_NO_VTABLE ResultItem :
        public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
        public IDispatchImpl<IPCHSEResultItem, &IID_IPCHSEResultItem, &LIBID_HelpServiceTypeLib>
    {
        ResultItem_Data m_data;

    public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(ResultItem)
        COM_INTERFACE_ENTRY(IPCHSEResultItem)
        COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

        ResultItem();

        ResultItem_Data& Data() { return m_data; }

    // IPCHSEResultItem
    public:
        STDMETHOD(get_Title      )( /*[out, retval]*/ BSTR   *pVal );
        STDMETHOD(get_URI        )( /*[out, retval]*/ BSTR   *pVal );
        STDMETHOD(get_ContentType)( /*[out, retval]*/ long   *pVal );
        STDMETHOD(get_Location   )( /*[out, retval]*/ BSTR   *pVal );
        STDMETHOD(get_Hits       )( /*[out, retval]*/ long   *pVal );
        STDMETHOD(get_Rank       )( /*[out, retval]*/ double *pVal );
        STDMETHOD(get_Description)( /*[out, retval]*/ BSTR   *pVal );
    };

    ////////////////////////////////////////////////////////////////////////////////

    struct ParamItem_Definition
    {
        ParamTypeEnum m_pteParamType;
        VARIANT_BOOL  m_bRequired;
        VARIANT_BOOL  m_bVisible;

        LPCWSTR		  m_szName;

        UINT		  m_iDisplayString;
		LPCWSTR       m_szDisplayString;

        LPCWSTR       m_szData;
    };

    struct ParamItem_Definition2 : public ParamItem_Definition
    {
        MPC::wstring m_strName;
		MPC::wstring m_strDisplayString;
		MPC::wstring m_strData;

		ParamItem_Definition2();
	};

    struct ParamItem_Data
    {
        ParamTypeEnum m_pteParamType;
        VARIANT_BOOL  m_bRequired;
        VARIANT_BOOL  m_bVisible;
        CComBSTR      m_bstrDisplayString;
        CComBSTR      m_bstrName;
        CComVariant   m_varData;

        ParamItem_Data();
    };

    class ATL_NO_VTABLE ParamItem :
        public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
        public IDispatchImpl<IPCHSEParamItem, &IID_IPCHSEParamItem, &LIBID_HelpServiceTypeLib>
    {
        ParamItem_Data m_data;

    public:
    BEGIN_COM_MAP(ParamItem)
        COM_INTERFACE_ENTRY(IPCHSEParamItem)
        COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

        ParamItem();

        ParamItem_Data& Data() { return m_data; }

    // IPCHSEParamItem
    public:
        STDMETHOD(get_Type    )( /*[out, retval]*/ ParamTypeEnum *pVal );
        STDMETHOD(get_Display )( /*[out, retval]*/ BSTR          *pVal );
        STDMETHOD(get_Name    )( /*[out, retval]*/ BSTR          *pVal );
        STDMETHOD(get_Required)( /*[out, retval]*/ VARIANT_BOOL  *pVal );
        STDMETHOD(get_Visible )( /*[out, retval]*/ VARIANT_BOOL  *pVal );
        STDMETHOD(get_Data    )( /*[out, retval]*/ VARIANT       *pVal );
    };

    ////////////////////////////////////////////////////////////////////////////////

    typedef std::map<MPC::wstring, CComVariant> ParamMap;
    typedef ParamMap::iterator                  ParamMapIter;

    class ATL_NO_VTABLE WrapperBase :
        public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
        public IDispatchImpl<IPCHSEWrapperItem    , &IID_IPCHSEWrapperItem    , &LIBID_HelpServiceTypeLib>,
        public IDispatchImpl<IPCHSEWrapperInternal, &IID_IPCHSEWrapperInternal, &LIBID_HelpServiceTypeLib>
    {
	protected:
        VARIANT_BOOL                   m_bEnabled;

        CComBSTR                       m_bstrID;
        CComBSTR                       m_bstrOwner;

        CComBSTR                       m_bstrName;
        CComBSTR                       m_bstrDescription;
        CComBSTR                       m_bstrHelpURL;
        CComBSTR                       m_bstrScope;

        CComBSTR                       m_bstrQueryString;
        long                           m_lNumResult;
        CComPtr<IPCHSEManagerInternal> m_pSEMgr;

        Taxonomy::HelpSet 	           m_ths;
		CComPtr<CPCHCollection>        m_pParamDef;
        ParamMap                       m_aParam;

        ////////////////////////////////////////

	public:
		WrapperBase();
		virtual ~WrapperBase();

		virtual HRESULT Clean();

		VARIANT* GetParamInternal( /*[in]*/ LPCWSTR szParamName );

		HRESULT  CreateParam( /*[in/out]*/ CPCHCollection* coll, /*[in]*/ const ParamItem_Definition* def );

		virtual HRESULT CreateListOfParams( /*[in]*/ CPCHCollection* coll );

		virtual HRESULT GetParamDefinition( /*[out]*/ const ParamItem_Definition*& lst, /*[out]*/ int& len );

    // IPCHSEWrapperItem
    public:
        STDMETHOD(get_Enabled    )( /*[out, retval]*/ VARIANT_BOOL *  pVal );
        STDMETHOD(put_Enabled    )( /*[in]*/          VARIANT_BOOL  newVal );
        STDMETHOD(get_Owner      )( /*[out, retval]*/ BSTR         *  pVal );
        STDMETHOD(get_Description)( /*[out, retval]*/ BSTR         *  pVal );
        STDMETHOD(get_Name       )( /*[out, retval]*/ BSTR         *  pVal );
        STDMETHOD(get_ID         )( /*[out, retval]*/ BSTR         *  pVal );
        STDMETHOD(get_HelpURL    )( /*[out, retval]*/ BSTR         *  pVal );
		STDMETHOD(get_SearchTerms)( /*[out, retval]*/ VARIANT      *  pVal );

        STDMETHOD(Param   )(                              /*[out,retval]*/ IPCHCollection* *ppC    );
        STDMETHOD(AddParam)( /*[in]*/ BSTR bstrParamName, /*[in]*/         VARIANT          newVal );
        STDMETHOD(GetParam)( /*[in]*/ BSTR bstrParamName, /*[out,retval]*/ VARIANT         *  pVal );
        STDMETHOD(DelParam)( /*[in]*/ BSTR bstrParamName                                           );

    // IPCHSEWrapperInternal
    public:
        STDMETHOD(get_QueryString)( /*[out, retval]*/ BSTR *  pVal );
        STDMETHOD(put_QueryString)( /*[in]*/          BSTR  newVal );
        STDMETHOD(get_NumResult  )( /*[out, retval]*/ long *  pVal );
        STDMETHOD(put_NumResult  )( /*[in]*/          long  newVal );

		STDMETHOD(SECallbackInterface)( /*[in]*/ IPCHSEManagerInternal* pMgr                                                     );
		STDMETHOD(Initialize         )( /*[in]*/ BSTR bstrID, /*[in]*/ BSTR bstrSKU, /*[in]*/ long lLCID, /*[in]*/ BSTR bstrData );
	};

    ////////////////////////////////////////////////////////////////////////////////

    extern HRESULT WrapperItem__Create_Keyword       ( /*[out]*/ CComPtr<IPCHSEWrapperInternal>& pVal );
    extern HRESULT WrapperItem__Create_FullTextSearch( /*[out]*/ CComPtr<IPCHSEWrapperInternal>& pVal );
};

////////////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___PCH___SEARCHENGINELIB_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\include\seconfig.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    seconfig.h

Abstract:
    This is the Search Engine Config .h file

Revision History:
    gschua          created     3/22/2000

********************************************************************/

#if !defined(__INCLUDED___PCH___SECONFIG_H___)
#define __INCLUDED___PCH___SECONFIG_H___

#include <MPC_config.h>

#include <TaxonomyDatabase.h>

namespace SearchEngine
{
    class Config :
        public MPC::Config::TypeConstructor,
        public MPC::NamedMutex
    {
    public:
        class Wrapper : public MPC::Config::TypeConstructor
        {
            DECLARE_CONFIG_MAP(Wrapper);

        public:
            Taxonomy::HelpSet m_ths;
            CComBSTR          m_bstrID;
            CComBSTR          m_bstrOwner;
            CComBSTR          m_bstrCLSID;
            CComBSTR          m_bstrData;

            ////////////////////////////////////////
            //
            // MPC::Config::TypeConstructor
            //
            DEFINE_CONFIG_DEFAULTTAG();
            DECLARE_CONFIG_METHODS();
            //
            ////////////////////////////////////////
        };

        typedef std::list< Wrapper >        WrapperList;
        typedef WrapperList::iterator       WrapperIter;
        typedef WrapperList::const_iterator WrapperIterConst;

        ////////////////////////////////////////

    private:
        DECLARE_CONFIG_MAP(Config);

        double      m_dVersion;
        bool        m_bLoaded;
        WrapperList m_lstWrapper;

        ////////////////////////////////////////
        //
        // MPC::Config::TypeConstructor
        //
        DEFINE_CONFIG_DEFAULTTAG();
        DECLARE_CONFIG_METHODS();
        //
        ////////////////////////////////////////

        HRESULT SyncConfiguration( /*[in]*/ bool fLoad );

        bool FindWrapper( /*[in]*/ const Taxonomy::HelpSet& ths, /*[in ]*/ LPCWSTR szID, /*[out]*/ WrapperIter& it );

     public:
        Config();
        ~Config();


        HRESULT RegisterWrapper  ( const Taxonomy::HelpSet& ths, LPCWSTR szID, LPCWSTR szOwner, LPCWSTR szCLSID, LPCWSTR szData );
        HRESULT UnRegisterWrapper( const Taxonomy::HelpSet& ths, LPCWSTR szID, LPCWSTR szOwner                                  );
        HRESULT ResetSKU         ( const Taxonomy::HelpSet& ths                                                                 );

        HRESULT GetWrappers( /*[out]*/ WrapperIter& itBegin, /*[out]*/ WrapperIter& itEnd );
    };
};

#endif // !defined(__INCLUDED___PCH___SECONFIG_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\include\svcresource.h ===
//******************************************************************************
// 
// Copyright (c) 2000 Microsoft Corporation
// 
// Module Name:
// 	   SvcResource.h
// 
// Abstract:
// 	   Resource file for Help Center Service.
// 
// Revision History:
// 	   Davide Massarenti   (Dmassare)  03/14/2000
// 		   created
// 
//******************************************************************************

#define IDR_HELPSVC                     100
#define IDR_HCUPDATE                    200
#define IDR_PCHDBSESSION                300
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\include\securitylib.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    SecurityLib.h

Abstract:
    This file contains the declaration of the classes responsible for managing
    security settings.

Revision History:
    Davide Massarenti   (Dmassare)  03/22/2000
        created

******************************************************************************/

#if !defined(__INCLUDED___PCH___SECURITYLIB_H___)
#define __INCLUDED___PCH___SECURITYLIB_H___

#include <MPC_security.h>

////////////////////////////////////////////////////////////////////////////////

class CPCHSecurityDescriptorDirect : public MPC::SecurityDescriptor
{
public:
    static HRESULT ConvertACEFromCOM( /*[in]*/ IPCHAccessControlEntry* pObj, /*[out]*/       PACL&  pACL );
    static HRESULT ConvertACEToCOM  ( /*[in]*/ IPCHAccessControlEntry* pObj, /*[in ]*/ const LPVOID pACE );

    static HRESULT ConvertACLFromCOM( /*[in]*/ IPCHAccessControlList* pObj, /*[out]*/       PACL& pACL );
    static HRESULT ConvertACLToCOM  ( /*[in]*/ IPCHAccessControlList* pObj, /*[in ]*/ const PACL  pACL );

public:
    HRESULT ConvertSDToCOM  ( /*[in]*/ IPCHSecurityDescriptor* pObj );
    HRESULT ConvertSDFromCOM( /*[in]*/ IPCHSecurityDescriptor* pObj );
};

////////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHAccessControlEntry : // Hungarian: pchace
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public IDispatchImpl< IPCHAccessControlEntry, &IID_IPCHAccessControlEntry, &LIBID_HelpServiceTypeLib >
{
    DWORD     m_dwAccessMask;
    DWORD     m_dwAceFlags;
    DWORD     m_dwAceType;
    DWORD     m_dwFlags;

    CComBSTR  m_bstrTrustee;
    CComBSTR  m_bstrObjectType;
    CComBSTR  m_bstrInheritedObjectType;


    HRESULT LoadPost( /*[in]*/ MPC::XmlUtil& xml );
    HRESULT SavePre ( /*[in]*/ MPC::XmlUtil& xml );

public:
BEGIN_COM_MAP(CPCHAccessControlEntry)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHAccessControlEntry)
END_COM_MAP()

    CPCHAccessControlEntry();
    virtual ~CPCHAccessControlEntry();

public:
    // IPCHAccessControlEntry
    STDMETHOD(get_AccessMask         )( /*[out, retval]*/ long *pVal   );
    STDMETHOD(put_AccessMask         )( /*[in         ]*/ long  newVal );
    STDMETHOD(get_AceType            )( /*[out, retval]*/ long *pVal   );
    STDMETHOD(put_AceType            )( /*[in         ]*/ long  newVal );
    STDMETHOD(get_AceFlags           )( /*[out, retval]*/ long *pVal   );
    STDMETHOD(put_AceFlags           )( /*[in         ]*/ long  newVal );
    STDMETHOD(get_Flags              )( /*[out, retval]*/ long *pVal   );
    STDMETHOD(put_Flags              )( /*[in         ]*/ long  newVal );
    STDMETHOD(get_Trustee            )( /*[out, retval]*/ BSTR *pVal   );
    STDMETHOD(put_Trustee            )( /*[in         ]*/ BSTR  newVal );
    STDMETHOD(get_ObjectType         )( /*[out, retval]*/ BSTR *pVal   );
    STDMETHOD(put_ObjectType         )( /*[in         ]*/ BSTR  newVal );
    STDMETHOD(get_InheritedObjectType)( /*[out, retval]*/ BSTR *pVal   );
    STDMETHOD(put_InheritedObjectType)( /*[in         ]*/ BSTR  newVal );


    STDMETHOD(IsEquivalent)( /*[in]*/ IPCHAccessControlEntry* pAce, /*[out, retval]*/ VARIANT_BOOL *pVal );

    STDMETHOD(Clone)( /*[out, retval]*/ IPCHAccessControlEntry* *pVal );

    STDMETHOD(LoadXML        )( /*[in]*/ IXMLDOMNode* xdnNode );
    STDMETHOD(LoadXMLAsString)( /*[in]*/ BSTR         bstrVal );
    STDMETHOD(LoadXMLAsStream)( /*[in]*/ IUnknown*    pStream );

    STDMETHOD(SaveXML        )( /*[in]*/ IXMLDOMNode* xdnRoot, /*[out, retval]*/ IXMLDOMNode* *pxdnNode );
    STDMETHOD(SaveXMLAsString)(                                /*[out, retval]*/ BSTR         *bstrVal  );
    STDMETHOD(SaveXMLAsStream)(                                /*[out, retval]*/ IUnknown*    *pStream  );
};

////////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHAccessControlList : // Hungarian: pchacl
    public MPC::CComCollection< IPCHAccessControlList, &LIBID_HelpServiceTypeLib, MPC::CComSafeMultiThreadModel>
{
    DWORD m_dwAclRevision;


    HRESULT LoadPost( /*[in]*/ MPC::XmlUtil& xml );
    HRESULT SavePre ( /*[in]*/ MPC::XmlUtil& xml );

public:
BEGIN_COM_MAP(CPCHAccessControlList)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHAccessControlList)
END_COM_MAP()

    CPCHAccessControlList();
    virtual ~CPCHAccessControlList();


    HRESULT CreateItem( /*[out]*/ CPCHAccessControlEntry* *entry );

public:
    // IPCHAccessControlList
    STDMETHOD(get_AclRevision)( /*[out, retval]*/ long *pVal   );
    STDMETHOD(put_AclRevision)( /*[in         ]*/ long  newVal );

    STDMETHOD(AddAce   )( /*[in]*/ IPCHAccessControlEntry* pAccessControlEntry );
    STDMETHOD(RemoveAce)( /*[in]*/ IPCHAccessControlEntry* pAccessControlEntry );

    STDMETHOD(Clone)( /*[out, retval]*/ IPCHAccessControlList* *pVal );

    STDMETHOD(LoadXML        )( /*[in]*/ IXMLDOMNode* xdnNode );
    STDMETHOD(LoadXMLAsString)( /*[in]*/ BSTR         bstrVal );
    STDMETHOD(LoadXMLAsStream)( /*[in]*/ IUnknown*    pStream );

    STDMETHOD(SaveXML        )( /*[in]*/ IXMLDOMNode* xdnRoot, /*[out, retval]*/ IXMLDOMNode* *pxdnNode );
    STDMETHOD(SaveXMLAsString)(                                /*[out, retval]*/ BSTR         *bstrVal  );
    STDMETHOD(SaveXMLAsStream)(                                /*[out, retval]*/ IUnknown*    *pStream  );
};

////////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHSecurityDescriptor : // Hungarian: pchsd
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public IDispatchImpl< IPCHSecurityDescriptor, &IID_IPCHSecurityDescriptor, &LIBID_HelpServiceTypeLib >
{
    DWORD                          m_dwRevision;
    DWORD                          m_dwControl;

    CComBSTR                       m_bstrOwner;
    bool                           m_fOwnerDefaulted;

    CComBSTR                       m_bstrGroup;
    bool                           m_fGroupDefaulted;

    CComPtr<IPCHAccessControlList> m_DACL;
    bool                           m_fDaclDefaulted;

    CComPtr<IPCHAccessControlList> m_SACL;
    bool                           m_fSaclDefaulted;


    HRESULT LoadPost( /*[in]*/ MPC::XmlUtil& xml );
    HRESULT SavePre ( /*[in]*/ MPC::XmlUtil& xml );


public:
BEGIN_COM_MAP(CPCHSecurityDescriptor)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHSecurityDescriptor)
END_COM_MAP()

    CPCHSecurityDescriptor();
    virtual ~CPCHSecurityDescriptor();


    static HRESULT GetForFile    ( /*[in]*/ LPCWSTR szFilename, /*[out, retval]*/ IPCHSecurityDescriptor* *psd );
    static HRESULT SetForFile    ( /*[in]*/ LPCWSTR szFilename, /*[in         ]*/ IPCHSecurityDescriptor*   sd );
    static HRESULT GetForRegistry( /*[in]*/ LPCWSTR szKey     , /*[out, retval]*/ IPCHSecurityDescriptor* *psd );
    static HRESULT SetForRegistry( /*[in]*/ LPCWSTR szKey     , /*[in         ]*/ IPCHSecurityDescriptor*   sd );

public:
    // IPCHSecurityDescriptor
    STDMETHOD(get_Revision          )( /*[out, retval]*/ long                   *pVal   );
    STDMETHOD(put_Revision          )( /*[in         ]*/ long                    newVal );
    STDMETHOD(get_Control           )( /*[out, retval]*/ long                   *pVal   );
    STDMETHOD(put_Control           )( /*[in         ]*/ long                    newVal );
    STDMETHOD(get_Owner             )( /*[out, retval]*/ BSTR                   *pVal   );
    STDMETHOD(put_Owner             )( /*[in         ]*/ BSTR                    newVal );
    STDMETHOD(get_OwnerDefaulted    )( /*[out, retval]*/ VARIANT_BOOL           *pVal   );
    STDMETHOD(put_OwnerDefaulted    )( /*[in         ]*/ VARIANT_BOOL            newVal );
    STDMETHOD(get_Group             )( /*[out, retval]*/ BSTR                   *pVal   );
    STDMETHOD(put_Group             )( /*[in         ]*/ BSTR                    newVal );
    STDMETHOD(get_GroupDefaulted    )( /*[out, retval]*/ VARIANT_BOOL           *pVal   );
    STDMETHOD(put_GroupDefaulted    )( /*[in         ]*/ VARIANT_BOOL            newVal );
    STDMETHOD(get_DiscretionaryAcl  )( /*[out, retval]*/ IPCHAccessControlList* *pVal   );
    STDMETHOD(put_DiscretionaryAcl  )( /*[in         ]*/ IPCHAccessControlList*  newVal );
    STDMETHOD(get_DaclDefaulted     )( /*[out, retval]*/ VARIANT_BOOL           *pVal   );
    STDMETHOD(put_DaclDefaulted     )( /*[in         ]*/ VARIANT_BOOL            newVal );
    STDMETHOD(get_SystemAcl         )( /*[out, retval]*/ IPCHAccessControlList* *pVal   );
    STDMETHOD(put_SystemAcl         )( /*[in         ]*/ IPCHAccessControlList*  newVal );
    STDMETHOD(get_SaclDefaulted     )( /*[out, retval]*/ VARIANT_BOOL           *pVal   );
    STDMETHOD(put_SaclDefaulted     )( /*[in         ]*/ VARIANT_BOOL            newVal );

    STDMETHOD(Clone)( /*[out, retval]*/ IPCHSecurityDescriptor* *pVal );

    STDMETHOD(LoadXML        )( /*[in]*/ IXMLDOMNode* xdnNode );
    STDMETHOD(LoadXMLAsString)( /*[in]*/ BSTR         bstrVal );
    STDMETHOD(LoadXMLAsStream)( /*[in]*/ IUnknown*    pStream );

    STDMETHOD(SaveXML        )( /*[in]*/ IXMLDOMNode* xdnRoot, /*[out, retval]*/ IXMLDOMNode* *pxdnNode );
    STDMETHOD(SaveXMLAsString)(                                /*[out, retval]*/ BSTR         *bstrVal  );
    STDMETHOD(SaveXMLAsStream)(                                /*[out, retval]*/ IUnknown*    *pStream  );
};

////////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHSecurity : // Hungarian: pchs
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public IDispatchImpl< IPCHSecurity, &IID_IPCHSecurity, &LIBID_HelpServiceTypeLib >
{
	HRESULT CheckAccess( /*[in]*/  VARIANT&                 vDesiredAccess ,
						 /*[in]*/  MPC::SecurityDescriptor& sd             ,
						 /*[out]*/ VARIANT_BOOL&            retVal         );

public:
BEGIN_COM_MAP(CPCHSecurity)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHSecurity)
END_COM_MAP()

	////////////////////////////////////////////////////////////////////////////////

	static CPCHSecurity* s_GLOBAL;

    static HRESULT InitializeSystem();
	static void    FinalizeSystem  ();
	
	////////////////////////////////////////////////////////////////////////////////

public:
    // IPCHSecurity
    STDMETHOD(CreateObject_SecurityDescriptor)( /*[out, retval]*/ IPCHSecurityDescriptor* *pSD  );
    STDMETHOD(CreateObject_AccessControlList )( /*[out, retval]*/ IPCHAccessControlList * *pACL );
    STDMETHOD(CreateObject_AccessControlEntry)( /*[out, retval]*/ IPCHAccessControlEntry* *pACE );

    STDMETHOD(GetUserName       )( /*[in]*/ BSTR bstrPrincipal, /*[out, retval]*/ BSTR *retVal );
    STDMETHOD(GetUserDomain     )( /*[in]*/ BSTR bstrPrincipal, /*[out, retval]*/ BSTR *retVal );
    STDMETHOD(GetUserDisplayName)( /*[in]*/ BSTR bstrPrincipal, /*[out, retval]*/ BSTR *retVal );

    STDMETHOD(CheckCredentials)( /*[in]*/ BSTR bstrCredentials, /*[out, retval]*/ VARIANT_BOOL *retVal );

    STDMETHOD(CheckAccessToSD      )( /*[in]*/ VARIANT vDesiredAccess, /*[in]*/ IPCHSecurityDescriptor* sd          , /*[out, retval]*/ VARIANT_BOOL *retVal );
    STDMETHOD(CheckAccessToFile    )( /*[in]*/ VARIANT vDesiredAccess, /*[in]*/ BSTR                    bstrFilename, /*[out, retval]*/ VARIANT_BOOL *retVal );
    STDMETHOD(CheckAccessToRegistry)( /*[in]*/ VARIANT vDesiredAccess, /*[in]*/ BSTR                    bstrKey     , /*[out, retval]*/ VARIANT_BOOL *retVal );


    STDMETHOD(GetFileSD)( /*[in]*/ BSTR bstrFilename, /*[out, retval]*/ IPCHSecurityDescriptor* *psd );
    STDMETHOD(SetFileSD)( /*[in]*/ BSTR bstrFilename, /*[in]         */ IPCHSecurityDescriptor*   sd );

    STDMETHOD(GetRegistrySD)( /*[in]*/ BSTR bstrKey, /*[out, retval]*/ IPCHSecurityDescriptor* *psd );
    STDMETHOD(SetRegistrySD)( /*[in]*/ BSTR bstrKey, /*[in]         */ IPCHSecurityDescriptor*   sd );
};

#endif // !defined(__INCLUDED___PCH___SECURITYLIB_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\include\service.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Service.h

Abstract:
    This file contains the declaration of the CPCHService class.

Revision History:
    Davide Massarenti   (Dmassare)  03/14/2000
        created

    Kalyani Narlanka    (kalyanin)  10/20/2000
        Additions for Unsolicited Remote Control

******************************************************************************/

#if !defined(__INCLUDED___PCH___SERVICE_H___)
#define __INCLUDED___PCH___SERVICE_H___

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

#include <ContentStoreMgr.h>

#include <TaxonomyDatabase.h>

//
// From SessMgr.idl
//
#include <sessmgr.h>

class ATL_NO_VTABLE CPCHService :
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public CComCoClass<CPCHService, &CLSID_PCHService>,
    public IDispatchImpl<IPCHService, &IID_IPCHService, &LIBID_HelpServiceTypeLib>
{
    bool m_fVerified;

public:
DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CPCHService)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPCHService)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHService)
END_COM_MAP()

    CPCHService();
    virtual ~CPCHService();

    // IPCHService
    STDMETHOD(get_RemoteSKUs)( /*[out, retval]*/ IPCHCollection* *pVal );
	STDMETHOD(get_RemoteModemConnected)( /*[out, retval]*/ VARIANT_BOOL *pVal );

    STDMETHOD(IsTrusted)( /*[in]*/ BSTR bstrURL, /*[out, retval]*/ VARIANT_BOOL *pfTrusted );

    STDMETHOD(Utility           )( /*[in]*/ BSTR bstrSKU, /*[in]*/ long lLCID, /*[out]*/ IPCHUtility*            *pVal );
    STDMETHOD(RemoteHelpContents)( /*[in]*/ BSTR bstrSKU, /*[in]*/ long lLCID, /*[out]*/ IPCHRemoteHelpContents* *pVal );

    STDMETHOD(RegisterHost       )(                           /*[in]*/ BSTR bstrID  ,                        /*[in ]*/ IUnknown*   pObj );
    STDMETHOD(CreateScriptWrapper)( /*[in]*/ REFCLSID rclsid, /*[in]*/ BSTR bstrCode, /*[in]*/ BSTR bstrURL, /*[out]*/ IUnknown* *ppObj );

    STDMETHOD(TriggerScheduledDataCollection)( /*[in]*/ VARIANT_BOOL fStart );
    STDMETHOD(PrepareForShutdown            )(                              );

    STDMETHOD(ForceSystemRestore)(                                            );
    STDMETHOD(UpgradeDetected	)(                                            );
    STDMETHOD(MUI_Install  	 	)( /*[in]*/ long LCID, /*[in]*/ BSTR bstrFile );
    STDMETHOD(MUI_Uninstall	 	)( /*[in]*/ long LCID                         );

    STDMETHOD(RemoteConnectionParms)( /*[in	]*/ BSTR 			 bstrUserName          ,
									  /*[in	]*/ BSTR 			 bstrDomainName        ,
									  /*[in	]*/ long 			 lSessionID            ,
									  /*[in	]*/ BSTR 			 bstrUserHelpBlob      ,
									  /*[out]*/ BSTR            *pbstrConnectionString );
    STDMETHOD(RemoteUserSessionInfo)( /*[out]*/ IPCHCollection* *pVal                  );
};

////////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHRemoteHelpContents :
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public IDispatchImpl<IPCHRemoteHelpContents, &IID_IPCHRemoteHelpContents, &LIBID_HelpServiceTypeLib>
{
    Taxonomy::Instance     m_data;
    Taxonomy::Settings     m_ts;
    MPC::wstring           m_strDir;
						   
    Taxonomy::Updater      m_updater;
    JetBlue::SessionHandle m_handle;
    JetBlue::Database*     m_db;


    HRESULT AttachToDatabase  ();
    void    DetachFromDatabase();

public:
BEGIN_COM_MAP(CPCHRemoteHelpContents)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHRemoteHelpContents)
END_COM_MAP()

    CPCHRemoteHelpContents();
    virtual ~CPCHRemoteHelpContents();

    HRESULT Init( /*[in]*/ const Taxonomy::Instance& data );

    // IPCHRemoteHelpContents
    STDMETHOD(get_SKU        )( /*[out, retval]*/ BSTR    *pVal );
    STDMETHOD(get_Language   )( /*[out, retval]*/ long    *pVal );
    STDMETHOD(get_ListOfFiles)( /*[out, retval]*/ VARIANT *pVal );

    STDMETHOD(GetDatabase)(                             /*[out, retval]*/ IUnknown* *pVal );
    STDMETHOD(GetFile    )( /*[in]*/ BSTR bstrFileName, /*[out, retval]*/ IUnknown* *pVal );
};

/////////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___PCH___SERVICE_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\include\semgrdid.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    SEDID.h

Abstract:
    This file contains the definition of some constants used by
    the SearchEngine Application.

Revision History:
    Ghim-Sim Chua   (gschua)  04/10/2000
        created

******************************************************************************/

#if !defined(__INCLUDED___PCH___SEMGRDID_H___)
#define __INCLUDED___PCH___SEMGRDID_H___

#define DISPID_SE_BASE                                  0x08040000

#define DISPID_SE_BASE_MGR                              (DISPID_SE_BASE + 0x0000) // IPCHSEManager
#define DISPID_SE_BASE_WRAPPER                          (DISPID_SE_BASE + 0x0100) // IPCHSEWrapperItem
#define DISPID_SE_BASE_RESULTITEM                       (DISPID_SE_BASE + 0x0200) // IPCHSEResultItem
#define DISPID_SE_BASE_PARAMITEM                        (DISPID_SE_BASE + 0x0300) // IPCHSEParamItem

#define DISPID_SE_BASE_MGRINNER                         (DISPID_SE_BASE + 0x0400) // IPCHSEManagerInternal
#define DISPID_SE_BASE_WRAPPERINNER                     (DISPID_SE_BASE + 0x0500) // IPCHSEWrapperInternal

#define DISPID_SE_BASE_EVENTS                           (DISPID_SE_BASE + 0x0600) // DPCHSEMgrEvents

////////////////////////////////////////////////////////////////////////////////

#define DISPID_SE_MGR__QUERYSTRING                      (DISPID_SE_BASE_MGR 	   	 + 0x0000)
#define DISPID_SE_MGR__NUMRESULT                        (DISPID_SE_BASE_MGR 	   	 + 0x0001)
#define DISPID_SE_MGR__ONCOMPLETE                       (DISPID_SE_BASE_MGR 	   	 + 0x0002)
#define DISPID_SE_MGR__ONPROGRESS                       (DISPID_SE_BASE_MGR 	   	 + 0x0003)
#define DISPID_SE_MGR__ONWRAPPERCOMPLETE                (DISPID_SE_BASE_MGR 	   	 + 0x0004)
#define DISPID_SE_MGR__SKU								(DISPID_SE_BASE_MGR 	   	 + 0x0005)
#define DISPID_SE_MGR__LCID				                (DISPID_SE_BASE_MGR 	   	 + 0x0006)
	   	 
#define DISPID_SE_MGR__ENUMENGINE                       (DISPID_SE_BASE_MGR 	   	 + 0x0010)
#define DISPID_SE_MGR__ABORTQUERY                       (DISPID_SE_BASE_MGR 	   	 + 0x0011)
#define DISPID_SE_MGR__EXECUTEASYNCHQUERY               (DISPID_SE_BASE_MGR 	   	 + 0x0012)
  
////////////////////////////////////////  
  
#define DISPID_SE_WRAPPER__ENABLED                      (DISPID_SE_BASE_WRAPPER    	 + 0x0000)
#define DISPID_SE_WRAPPER__OWNER                        (DISPID_SE_BASE_WRAPPER    	 + 0x0001)
#define DISPID_SE_WRAPPER__DESCRIPTION                  (DISPID_SE_BASE_WRAPPER    	 + 0x0002)
#define DISPID_SE_WRAPPER__NAME                         (DISPID_SE_BASE_WRAPPER    	 + 0x0003)
#define DISPID_SE_WRAPPER__ID                           (DISPID_SE_BASE_WRAPPER    	 + 0x0004)

#define DISPID_SE_WRAPPER__RESULT                       (DISPID_SE_BASE_WRAPPER    	 + 0x0010)
#define DISPID_SE_WRAPPER__PARAM                        (DISPID_SE_BASE_WRAPPER    	 + 0x0011)
#define DISPID_SE_WRAPPER__ADDPARAM                     (DISPID_SE_BASE_WRAPPER	   	 + 0x0012)
#define DISPID_SE_WRAPPER__GETPARAM                     (DISPID_SE_BASE_WRAPPER	   	 + 0x0013)
#define DISPID_SE_WRAPPER__DELPARAM                     (DISPID_SE_BASE_WRAPPER	   	 + 0x0014)
#define DISPID_SE_WRAPPER__SEARCHTERMS                  (DISPID_SE_BASE_WRAPPER	   	 + 0x0015)
#define DISPID_SE_WRAPPER__HELPURL                      (DISPID_SE_BASE_WRAPPER	   	 + 0x0016)

////////////////////////////////////////  
  
#define DISPID_SE_RESULTITEM__TITLE						(DISPID_SE_BASE_RESULTITEM 	 + 0x0000)
#define DISPID_SE_RESULTITEM__URI						(DISPID_SE_BASE_RESULTITEM 	 + 0x0001)
#define DISPID_SE_RESULTITEM__CONTENTTYPE				(DISPID_SE_BASE_RESULTITEM 	 + 0x0002)
#define DISPID_SE_RESULTITEM__LOCATION					(DISPID_SE_BASE_RESULTITEM 	 + 0x0003)
#define DISPID_SE_RESULTITEM__HITS						(DISPID_SE_BASE_RESULTITEM 	 + 0x0004)
#define DISPID_SE_RESULTITEM__RANK						(DISPID_SE_BASE_RESULTITEM 	 + 0x0005)
#define DISPID_SE_RESULTITEM__DESCRIPTION				(DISPID_SE_BASE_RESULTITEM 	 + 0x0006)
 
////////////////////////////////////////  
  
#define DISPID_SE_PARAMITEM__TYPE                       (DISPID_SE_BASE_PARAMITEM 	 + 0x0000)
#define DISPID_SE_PARAMITEM__TITLE                      (DISPID_SE_BASE_PARAMITEM 	 + 0x0001)
#define DISPID_SE_PARAMITEM__DISPLAY                    (DISPID_SE_BASE_PARAMITEM 	 + 0x0002)
#define DISPID_SE_PARAMITEM__REQUIRED                   (DISPID_SE_BASE_PARAMITEM 	 + 0x0003)
#define DISPID_SE_PARAMITEM__DATA						(DISPID_SE_BASE_PARAMITEM 	 + 0x0004)
#define DISPID_SE_PARAMITEM__VISIBLE                    (DISPID_SE_BASE_PARAMITEM 	 + 0x0005)

////////////////////////////////////////  
  
#define DISPID_SE_MGRINNER__WRAPPERCOMPLETE             (DISPID_SE_BASE_MGRINNER   	 + 0x0001)

#define DISPID_SE_MGRINNER__ISNETWORKALIVE              (DISPID_SE_BASE_MGRINNER   	 + 0x0010)
#define DISPID_SE_MGRINNER__ISDESTINATIONREACHABLE      (DISPID_SE_BASE_MGRINNER   	 + 0x0011)

#define DISPID_SE_MGRINNER__LOGRECORD                   (DISPID_SE_BASE_MGRINNER   	 + 0x0020)

////////////////////////////////////////

#define DISPID_SE_WRAPPERINNER__QUERYSTRING             (DISPID_SE_BASE_WRAPPERINNER + 0x0000)
#define DISPID_SE_WRAPPERINNER__NUMRESULT               (DISPID_SE_BASE_WRAPPERINNER + 0x0001)
								                   		
#define DISPID_SE_WRAPPERINNER__EXECASYNCQUERY          (DISPID_SE_BASE_WRAPPERINNER + 0x0010)
#define DISPID_SE_WRAPPERINNER__ABORTQUERY              (DISPID_SE_BASE_WRAPPERINNER + 0x0011)
#define DISPID_SE_WRAPPERINNER__SECALLBACKINTERFACE     (DISPID_SE_BASE_WRAPPERINNER + 0x0012)
#define DISPID_SE_WRAPPERINNER__INITIALIZE			    (DISPID_SE_BASE_WRAPPERINNER + 0x0013)

////////////////////////////////////////

#define DISPID_SE_EVENTS__ONPROGRESS     				(DISPID_SE_BASE_EVENTS 		 + 0x0000)
#define DISPID_SE_EVENTS__ONCOMPLETE     				(DISPID_SE_BASE_EVENTS 		 + 0x0001)
#define DISPID_SE_EVENTS__ONWRAPPERCOMPLETE     		(DISPID_SE_BASE_EVENTS 		 + 0x0002)

////////////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___PCH___SEMGRDID_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\include\svcutils.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    SvcUtils.h

Abstract:
    This file contains the declaration of various utility functions.

Revision History:
    Davide Massarenti   (Dmassare)  04/26/2000
        created

******************************************************************************/

#if !defined(__INCLUDED___PCH___SVCUTILS_H___)
#define __INCLUDED___PCH___SVCUTILS_H___

#include <MPC_streams.h>
#include <MPC_security.h>

namespace SVC
{
	HRESULT OpenStreamForRead ( /*[in]*/ LPCWSTR szFile, /*[out]*/ IStream* *pVal, /*[in]*/ bool fDeleteOnRelease = false );
	HRESULT OpenStreamForWrite( /*[in]*/ LPCWSTR szFile, /*[out]*/ IStream* *pVal, /*[in]*/ bool fDeleteOnRelease = false );

	HRESULT CopyFileWhileImpersonating         ( /*[in]*/ LPCWSTR szSrc , /*[in]*/ LPCWSTR szDst, /*[in]*/ MPC::Impersonation& imp, /*[in]*/ bool fImpersonateForSource = true );
	HRESULT CopyOrExtractFileWhileImpersonating( /*[in]*/ LPCWSTR szSrc , /*[in]*/ LPCWSTR szDst, /*[in]*/ MPC::Impersonation& imp                                             );

	HRESULT LocateDataArchive( /*[in]*/ LPCWSTR szDir, /*[out]*/ MPC::WStringList& lst );

	HRESULT RemoveAndRecreateDirectory( /*[in]*/ const MPC::wstring& strDir, /*[in]*/ LPCWSTR szExtra, /*[in]*/ bool fRemove, /*[in]*/ bool fRecreate );
	HRESULT RemoveAndRecreateDirectory( /*[in]*/ LPCWSTR              szDir, /*[in]*/ LPCWSTR szExtra, /*[in]*/ bool fRemove, /*[in]*/ bool fRecreate );

	HRESULT ChangeSD( /*[in]*/ MPC::SecurityDescriptor& sdd, /*[in]*/ MPC::wstring strPath, /*[in]*/ LPCWSTR szExtra = NULL );

	////////////////////////////////////////////////////////////////////////////////

	HRESULT SafeLoad     	 ( /*[in]*/ const MPC::wstring& strFile, /*[in]*/ CComPtr<MPC::FileStream>& stream, /*[in]*/ DWORD dwTimeout = 100, /*[in]*/ DWORD dwRetries = 2 );
	HRESULT SafeSave_Init	 ( /*[in]*/ const MPC::wstring& strFile, /*[in]*/ CComPtr<MPC::FileStream>& stream, /*[in]*/ DWORD dwTimeout = 100, /*[in]*/ DWORD dwRetries = 2 );
	HRESULT SafeSave_Finalize( /*[in]*/ const MPC::wstring& strFile, /*[in]*/ CComPtr<MPC::FileStream>& stream, /*[in]*/ DWORD dwTimeout = 100, /*[in]*/ DWORD dwRetries = 2 );
};

#endif // !defined(__INCLUDED___PCH___SVCUTILS_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\include\systemmonitor.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    SystemMonitor.h

Abstract:
    This file contains the declaration of the classes used to implement
    the Setup Finalizer class.

Revision History:
    Davide Massarenti   (Dmassare)  08/25/99
        created

******************************************************************************/

#if !defined(__INCLUDED___PCH___SYSTEMMONITOR_H___)
#define __INCLUDED___PCH___SYSTEMMONITOR_H___

#include <MPC_COM.h>
#include <MPC_config.h>

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

#include <TaxonomyDatabase.h>
#include <PCHUpdate.h>

/////////////////////////////////////////////////////////////////////////////

class CPCHSystemMonitor :
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public MPC::Thread<CPCHSystemMonitor,IUnknown>
{
	bool m_fLoadCache;
	bool m_fScanBatch;
	bool m_fDataCollection;

    //////////////////////////////////////////////////////////////////////

    HRESULT Run    ();
    HRESULT RunLoop();

    //////////////////////////////////////////////////////////////////////

public:
    CPCHSystemMonitor();
    virtual ~CPCHSystemMonitor();

	////////////////////////////////////////////////////////////////////////////////

	static CPCHSystemMonitor* s_GLOBAL;

    static HRESULT InitializeSystem();
	static void    FinalizeSystem  ();
	
	////////////////////////////////////////////////////////////////////////////////

	HRESULT EnsureStarted();
	void    Shutdown     ();

	HRESULT Startup();

	HRESULT LoadCache            (                      );
	HRESULT TriggerDataCollection( /*[in]*/ bool fStart );

	HRESULT TaskScheduler_Add   ( /*[in]*/ bool fAfterBoot );
	HRESULT TaskScheduler_Remove(                          );
};

#endif // !defined(__INCLUDED___PCH___SYSTEMMONITOR_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\include\taxonomydatabase.h ===
/******************************************************************************

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:
    TaxonomyDatabase.h

Abstract:
    Handles DB manipulation of taxonomy

Revision History:
    Anand Arvind (aarvind)  2000-03-29
        created

    Davide Massarenti (dmassare) 2000-04-08
        taking ownership

******************************************************************************/

#if !defined(__INCLUDED___HCP___TAXONOMYDATABASE_H___)
#define __INCLUDED___HCP___TAXONOMYDATABASE_H___

#include <MPC_COM.h>
#include <MPC_Utils.h>
#include <MPC_Config.h>
#include <MPC_Security.h>

#include <set>

#include <JetBlueLib.h>

#include <QueryResult.h>

namespace HHK
{
    class Merger;
    class Writer;
};

////////////////////////////////////////////////////////////////////////////////

namespace Taxonomy
{
    typedef std::set<MPC::wstring,MPC::NocaseLess> WordSet;
    typedef WordSet::iterator                      WordIter;
    typedef WordSet::const_iterator                WordIterConst;

    typedef std::set<long>                         MatchSet;
    typedef MatchSet::iterator                     MatchIter;
    typedef MatchSet::const_iterator               MatchIterConst;

    typedef std::map<long,long>                    WeightedMatchSet;
    typedef WeightedMatchSet::iterator             WeightedMatchIter;
    typedef WeightedMatchSet::const_iterator       WeightedMatchIterConst;

    ////////////////////////////////////////////////////////////////////////////////

    const WCHAR s_szSKU_32_PERSONAL       [] = L"Personal_32";
    const WCHAR s_szSKU_32_PROFESSIONAL   [] = L"Professional_32";
    const WCHAR s_szSKU_32_SERVER         [] = L"Server_32";
    const WCHAR s_szSKU_32_BLADE          [] = L"Blade_32";
    const WCHAR s_szSKU_32_ADVANCED_SERVER[] = L"AdvancedServer_32";
    const WCHAR s_szSKU_32_DATACENTER     [] = L"DataCenter_32";

    const WCHAR s_szSKU_64_PROFESSIONAL   [] = L"Professional_64";
    const WCHAR s_szSKU_64_ADVANCED_SERVER[] = L"AdvancedServer_64";
    const WCHAR s_szSKU_64_DATACENTER     [] = L"DataCenter_64";

    class HelpSet;
    class Settings;
    class Updater;
    class KeywordSearch;
    class Cache;

    ////////////////////

    struct Strings;
    struct InstanceBase;
    struct Instance;
    struct Package;
    struct ProcessedPackage;
    struct InstalledInstance;

    class Logger;
    class LockingHandle;
    class InstallationEngine;
    class InstalledInstanceStore;

    ////////////////////////////////////////////////////////////////////////////////

    class HelpSet
    {
    public:
        static MPC::wstring m_strSKU_Machine;
        static long         m_lLCID_Machine;

        MPC::wstring        m_strSKU;
        long                m_lLCID;

        ////////////////////

        static HRESULT SetMachineInfo( /*[in]*/ const InstanceBase& inst );

        static LPCWSTR GetMachineSKU     () { return m_strSKU_Machine.c_str(); }
        static long    GetMachineLanguage() { return m_lLCID_Machine         ; }

        static DWORD   GetMachineLCID      (                                                  );
        static DWORD   GetUserLCID         (                                                  );
        static void    GetLCIDDisplayString( /*[in]*/ long lLCID, /*[out]*/ MPC::wstring& str );

        ////////////////////////////////////////////////////////////////////////////////

        HelpSet( /*[in]*/ LPCWSTR szSKU = NULL, /*[in]*/ long lLCID = 0 );

        HelpSet           ( /*[in]*/ const HelpSet& ths );
        HelpSet& operator=( /*[in]*/ const HelpSet& ths );

        //////////////////////////////////////////////////////////////////////

        HRESULT Initialize( /*[in]*/ LPCWSTR szSKU, /*[in]*/ long    lLCID      );
        HRESULT Initialize( /*[in]*/ LPCWSTR szSKU, /*[in]*/ LPCWSTR szLanguage );

        LPCWSTR GetSKU     () const { return m_strSKU.c_str(); }
        long    GetLanguage() const { return m_lLCID         ; }

        //////////////////////////////////////////////////////////////////////

        bool IsMachineHelp() const;

        //////////////////////////////////////////////////////////////////////

        bool operator==( /*[in]*/ const HelpSet& sel ) const;
        bool operator< ( /*[in]*/ const HelpSet& sel ) const;

        friend HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/       HelpSet& val );
        friend HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const HelpSet& val );
    };

    class Settings : public HelpSet
    {
    public:
        Settings( /*[in]*/ LPCWSTR szSKU = NULL, /*[in]*/ long lLCID = 0 );
        Settings( /*[in]*/ const HelpSet& ths );

        //////////////////////////////////////////////////////////////////////

        static HRESULT SplitNodePath( /*[in]*/ LPCWSTR szNodeStr, /*[out]*/ MPC::WStringVector& vec );

        HRESULT BaseDir     ( /*[out]*/ MPC::wstring& strRES, /*[in]*/ bool fExpand = true                             ) const;
        HRESULT HelpFilesDir( /*[out]*/ MPC::wstring& strRES, /*[in]*/ bool fExpand = true, /*[in]*/ bool fMUI = false ) const;
        HRESULT DatabaseDir ( /*[out]*/ MPC::wstring& strRES                                                           ) const;
        HRESULT DatabaseFile( /*[out]*/ MPC::wstring& strRES                                                           ) const;
        HRESULT IndexFile   ( /*[out]*/ MPC::wstring& strRES, /*[in]*/ long lScoped = -1                               ) const;

        HRESULT GetDatabase( /*[out]*/ JetBlue::SessionHandle& handle, /*[out]*/ JetBlue::Database*& db, /*[in]*/ bool fReadOnly ) const;

        //////////////////////////////////////////////////////////////////////

        HRESULT LookupNode          ( /*[in]*/ LPCWSTR szNodeStr ,                             /*[in]*/ CPCHQueryResultCollection* pColl ) const;
        HRESULT LookupSubNodes      ( /*[in]*/ LPCWSTR szNodeStr , /*[in]*/ bool fVisibleOnly, /*[in]*/ CPCHQueryResultCollection* pColl ) const;
        HRESULT LookupNodesAndTopics( /*[in]*/ LPCWSTR szNodeStr , /*[in]*/ bool fVisibleOnly, /*[in]*/ CPCHQueryResultCollection* pColl ) const;
        HRESULT LookupTopics        ( /*[in]*/ LPCWSTR szNodeStr , /*[in]*/ bool fVisibleOnly, /*[in]*/ CPCHQueryResultCollection* pColl ) const;
        HRESULT LocateContext       ( /*[in]*/ LPCWSTR szURL     , /*[in]*/ LPCWSTR szSubSite, /*[in]*/ CPCHQueryResultCollection* pColl ) const;
        HRESULT KeywordSearch       ( /*[in]*/ LPCWSTR szQueryStr, /*[in]*/ LPCWSTR szSubSite, /*[in]*/ CPCHQueryResultCollection* pColl ,
                                                                                               /*[in]*/ MPC::WStringList*          lst   ) const;

        HRESULT GatherNodes         ( /*[in]*/ LPCWSTR szNodeStr , /*[in]*/ bool fVisibleOnly, /*[in]*/ CPCHQueryResultCollection* pColl ) const;
        HRESULT GatherTopics        ( /*[in]*/ LPCWSTR szNodeStr , /*[in]*/ bool fVisibleOnly, /*[in]*/ CPCHQueryResultCollection* pColl ) const;
    };


    ////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////

    struct QueryResultEntry
    {
        long                     m_ID_node;
        long                     m_ID_topic;
        long                     m_ID_parent;
        long                     m_ID_owner;
        long                     m_lOriginalPos;

        CPCHQueryResult::Payload m_data;

        ////////////////////

        QueryResultEntry();
    };

    class QueryResults
    {
        typedef std::vector<QueryResultEntry*> ResultVec;
        typedef ResultVec::iterator            ResultIter;
        typedef ResultVec::const_iterator      ResultIterConst;

        class Compare
        {
        public:
            bool operator()( /*[in]*/ const QueryResultEntry* left, /*[in]*/ const QueryResultEntry* right ) const;
        };

        Taxonomy::Updater& m_updater;
        ResultVec          m_vec;

        ////////////////////

        HRESULT AllocateNew( /*[in]*/ LPCWSTR szCategory, /*[out]*/ QueryResultEntry*& qre );

        HRESULT Sort();

    public:
        QueryResults( /*[in]*/ Taxonomy::Updater& updater );
        ~QueryResults();

        void Clean();

        HRESULT Append( /*[in]*/ Taxonomy::RS_Data_Taxonomy* rs, /*[in]*/ LPCWSTR szCategory );
        HRESULT Append( /*[in]*/ Taxonomy::RS_Data_Topics*   rs, /*[in]*/ LPCWSTR szCategory );

        HRESULT LookupNodes ( /*[in]*/ LPCWSTR szCategory, /*[in]*/ long ID_node, /*[in]*/ bool fVisibleOnly );
        HRESULT LookupTopics( /*[in]*/ LPCWSTR szCategory, /*[in]*/ long ID_node, /*[in]*/ bool fVisibleOnly );

        HRESULT MakeRoomForInsert( /*[in]*/ LPCWSTR szMode, /*[in]*/ LPCWSTR szID, /*[in]*/ long ID_node, /*[out]*/ long& lPosRet );

        HRESULT PopulateCollection( /*[in]*/ CPCHQueryResultCollection* pColl );
    };

    ////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////

    typedef enum
    {
        UPDATER_SET_STOPSIGNS             = 0,
        UPDATER_SET_STOPSIGNS_ATENDOFWORD    ,
        UPDATER_SET_STOPWORDS                ,
        UPDATER_SET_OPERATOR_NOT             ,
        UPDATER_SET_OPERATOR_AND             ,
        UPDATER_SET_OPERATOR_OR              ,
        UPDATER_SET_OPERATOR_MAX
    } Updater_Set;

    struct Updater_Stat
    {
        struct Entity
        {
            int m_iCreated;
            int m_iModified;
            int m_iDeleted;
            int m_iNoOp;

            Entity()
            {
                m_iCreated  = 0;
                m_iModified = 0;
                m_iDeleted  = 0;
                m_iNoOp     = 0;
            }

            void Created () { m_iCreated ++; }
            void Modified() { m_iModified++; }
            void Deleted () { m_iDeleted ++; }
            void NoOp    () { m_iNoOp    ++; }
        };

        ////////////////////

        Entity m_entContentOwners ;
        Entity m_entSynSets       ;
        Entity m_entHelpImage     ;
        Entity m_entIndexFiles    ;
        Entity m_entFullTextSearch;
        Entity m_entScope         ;
        Entity m_entTaxonomy      ;
        Entity m_entTopics        ;
        Entity m_entSynonyms      ;
        Entity m_entKeywords      ;
        Entity m_entMatches       ;
    };

    class Updater
    {
    public:
        struct WordSetDef
        {
            LPCWSTR szName;
            bool    fSplitAtDelimiter;

            LPCWSTR szDefault;
            LPCWSTR szAlwaysPresent;
        };

        struct WordSetStatus
        {
            Updater*          m_updater;
            const WordSetDef* m_def;

            WordSet           m_set;
            bool              m_fLoaded;
            bool              m_fModified;

            WordSetStatus();

            HRESULT Close(                                                           );
            HRESULT Init ( /*[in]*/ Updater* updater, /*[in]*/ const WordSetDef* def );

            HRESULT Load();
            HRESULT Save();

            HRESULT Add   ( /*[in]*/ LPCWSTR szValue );
            HRESULT Remove( /*[in]*/ LPCWSTR szValue );
        };

    private:
        Settings           m_ts;
        JetBlue::Database* m_db;
        Cache*             m_cache;
        bool               m_fUseCache;

        RS_DBParameters*   m_rsDBParameters;
        RS_ContentOwners*  m_rsContentOwners;
        RS_SynSets*        m_rsSynSets;
        RS_HelpImage*      m_rsHelpImage;
        RS_IndexFiles*     m_rsIndexFiles;
        RS_FullTextSearch* m_rsFullTextSearch;
        RS_Scope*          m_rsScope;
        RS_Taxonomy*       m_rsTaxonomy;
        RS_Topics*         m_rsTopics;
        RS_Synonyms*       m_rsSynonyms;
        RS_Keywords*       m_rsKeywords;
        RS_Matches*        m_rsMatches;

        long               m_ID_owner;
        bool               m_fOEM;

        MPC::wstring       m_strDBLocation;

        WordSetStatus      m_sets[UPDATER_SET_OPERATOR_MAX];
        JetBlue::Id2Node   m_nodes;
        JetBlue::Node2Id   m_nodes_reverse;

        Updater_Stat       m_stat;

        ////////////////////////////////////////

        HRESULT DeleteAllTopicsUnderANode      ( /*[in]*/ RS_Topics*   rs, /*[in]*/ long ID_node, /*[in]*/ bool fCheck );
        HRESULT DeleteAllSubNodes              ( /*[in]*/ RS_Taxonomy* rs, /*[in]*/ long ID_node, /*[in]*/ bool fCheck );
        HRESULT DeleteAllMatchesPointingToTopic( /*[in]*/ RS_Matches*  rs, /*[in]*/ long ID_topic                      );

        ////////////////////////////////////////

        bool NodeCache_FindNode( /*[in]*/ MPC::wstringUC& strPathUC, /*[out]*/ JetBlue::Id2NodeIter& itNode );
        bool NodeCache_FindId  ( /*[in]*/ long            ID_node  , /*[out]*/ JetBlue::Node2IdIter& itId   );

        void NodeCache_Add   ( /*[in]*/ MPC::wstringUC& strPathUC, /*[in]*/ long ID_node );
        void NodeCache_Remove(                                     /*[in]*/ long ID_node );
        void NodeCache_Clear (                                                           );

        ////////////////////////////////////////

    private: // Disable copy constructors...
        Updater           ( /*[in]*/ const Updater& );
        Updater& operator=( /*[in]*/ const Updater& );

    public:
        Updater();
        ~Updater();

        ////////////////////////////////////////

        HRESULT FlushWordSets(                                                                                           );
        HRESULT Close        (                                                                                           );
        HRESULT Init         ( /*[in]*/ const Settings& ts, /*[in]*/ JetBlue::Database* db, /*[in]*/ Cache* cache = NULL );

        void SetCacheFlag( /*[in]*/ bool fOn ) { m_fUseCache = fOn; }

        HRESULT GetWordSet       ( /*[in]*/ Updater_Set id, /*[out]*/ WordSet*           *pVal = NULL );
        HRESULT GetDBParameters  (                          /*[out]*/ RS_DBParameters*   *pVal = NULL );
        HRESULT GetContentOwners (                          /*[out]*/ RS_ContentOwners*  *pVal = NULL );
        HRESULT GetSynSets       (                          /*[out]*/ RS_SynSets*        *pVal = NULL );
        HRESULT GetHelpImage     (                          /*[out]*/ RS_HelpImage*      *pVal = NULL );
        HRESULT GetIndexFiles    (                          /*[out]*/ RS_IndexFiles*     *pVal = NULL );
        HRESULT GetFullTextSearch(                          /*[out]*/ RS_FullTextSearch* *pVal = NULL );
        HRESULT GetScope         (                          /*[out]*/ RS_Scope*          *pVal = NULL );
        HRESULT GetTaxonomy      (                          /*[out]*/ RS_Taxonomy*       *pVal = NULL );
        HRESULT GetTopics        (                          /*[out]*/ RS_Topics*         *pVal = NULL );
        HRESULT GetSynonyms      (                          /*[out]*/ RS_Synonyms*       *pVal = NULL );
        HRESULT GetKeywords      (                          /*[out]*/ RS_Keywords*       *pVal = NULL );
        HRESULT GetMatches       (                          /*[out]*/ RS_Matches*        *pVal = NULL );

        ////////////////////////////////////////

        long GetOwner() { return m_ID_owner; }
        bool IsOEM   () { return m_fOEM;     }

        const MPC::wstring& GetHelpLocation();

        Updater_Stat& Stat() { return m_stat; }

        ////////////////////////////////////////

        HRESULT ReadDBParameter ( /*[in]*/ LPCWSTR szName, /*[out]*/ MPC::wstring& strValue, /*[out]*/ bool *pfFound = NULL );
        HRESULT ReadDBParameter ( /*[in]*/ LPCWSTR szName, /*[out]*/ long&           lValue, /*[out]*/ bool *pfFound = NULL );
        HRESULT WriteDBParameter( /*[in]*/ LPCWSTR szName, /*[in ]*/ LPCWSTR        szValue );
        HRESULT WriteDBParameter( /*[in]*/ LPCWSTR szName, /*[in ]*/ long            lValue );


        HRESULT AddWordToSet     ( /*[in]*/ Updater_Set id, /*[in]*/ LPCWSTR szValue );
        HRESULT RemoveWordFromSet( /*[in]*/ Updater_Set id, /*[in]*/ LPCWSTR szValue );

        HRESULT ExpandURL  ( /*[in/out]*/ MPC::wstring& strURL );
        HRESULT CollapseURL( /*[in/out]*/ MPC::wstring& strURL );

        HRESULT ListAllTheHelpFiles( /*[out]*/ MPC::WStringList& lstFiles );

        HRESULT GetIndexInfo( /*[out]*/ MPC::wstring& strLocation, /*[out]*/ MPC::wstring& strDisplayName, /*[in]*/ LPCWSTR szScope );

        ////////////////////////////////////////

        HRESULT DeleteOwner(                                                                       );
        HRESULT LocateOwner(                           /*[in]*/ LPCWSTR szDN                       );
        HRESULT CreateOwner( /*[out]*/ long& ID_owner, /*[in]*/ LPCWSTR szDN, /*[in]*/ bool fIsOEM );

        ////////////////////////////////////////

        HRESULT DeleteSynSet(                            /*[in]*/ LPCWSTR szName );
        HRESULT LocateSynSet( /*[out]*/ long& ID_synset, /*[in]*/ LPCWSTR szName );
        HRESULT CreateSynSet( /*[out]*/ long& ID_synset, /*[in]*/ LPCWSTR szName );

        HRESULT DeleteSynonym( /*[in]*/ long ID_synset, /*[in]*/ LPCWSTR szName );
        HRESULT CreateSynonym( /*[in]*/ long ID_synset, /*[in]*/ LPCWSTR szName );

        HRESULT LocateSynonyms( /*[in]*/ LPCWSTR szName, /*[out]*/ MPC::WStringList& lst, /*[in]*/ bool fMatchOwner );

        ////////////////////////////////////////

        HRESULT AddFile   ( /*[in]*/ LPCWSTR szFile );
        HRESULT RemoveFile( /*[in]*/ LPCWSTR szFile );

        ////////////////////////////////////////

        HRESULT RemoveScope( /*[in ]*/ long  ID_Scope                                                                                                      );
        HRESULT LocateScope( /*[out]*/ long& ID_Scope, /*[out]*/ long& lOwner, /*[in]*/ LPCWSTR szID                                                       );
        HRESULT CreateScope( /*[out]*/ long& ID_Scope                        , /*[in]*/ LPCWSTR szID, /*[in]*/ LPCWSTR szName, /*[in]*/ LPCWSTR szCategory );

        ////////////////////////////////////////

        HRESULT AddIndexFile   ( /*[in]*/ long ID_Scope, /*[in]*/ LPCWSTR szStorage, /*[in]*/ LPCWSTR szFile );
        HRESULT RemoveIndexFile( /*[in]*/ long ID_Scope, /*[in]*/ LPCWSTR szStorage, /*[in]*/ LPCWSTR szFile );

        ////////////////////////////////////////

        HRESULT AddFullTextSearchQuery   ( /*[in]*/ long ID_Scope, /*[in]*/ LPCWSTR szCHM, /*[in]*/ LPCWSTR szCHQ );
        HRESULT RemoveFullTextSearchQuery( /*[in]*/ long ID_Scope, /*[in]*/ LPCWSTR szCHM                         );

        ////////////////////////////////////////

        HRESULT DeleteTaxonomyNode( /*[in ]*/ long  ID_node );

        HRESULT LocateTaxonomyNode( /*[out]*/ long& ID_node, /*[in]*/ LPCWSTR szTaxonomyPath ,
                                                             /*[in]*/ bool    fLookForFather );

        HRESULT CreateTaxonomyNode( /*[out]*/ long& ID_node, /*[in]*/ LPCWSTR szTaxonomyPath ,
                                                             /*[in]*/ LPCWSTR szTitle        ,
                                                             /*[in]*/ LPCWSTR szDescription  ,
                                                             /*[in]*/ LPCWSTR szURI          ,
                                                             /*[in]*/ LPCWSTR szIconURI      ,
                                                             /*[in]*/ bool    fVisible       ,
                                                             /*[in]*/ bool    fSubsite       ,
                                                             /*[in]*/ long    lNavModel      ,
                                                             /*[in]*/ long    lPos           );

        ////////////////////////////////////////

        HRESULT DeleteTopicEntry( /*[in ]*/ long    ID_topic      );

        HRESULT LocateTopicEntry( /*[out]*/ long&   ID_topic      ,
                                  /*[in ]*/ long    ID_node       ,
                                  /*[in ]*/ LPCWSTR szURI         ,
                                  /*[in ]*/ bool    fCheckOwner   );

        HRESULT CreateTopicEntry( /*[out]*/ long&   ID_topic      ,
                                  /*[in ]*/ long    ID_node       ,
                                  /*[in ]*/ LPCWSTR szTitle       ,
                                  /*[in ]*/ LPCWSTR szURI         ,
                                  /*[in ]*/ LPCWSTR szDescription ,
                                  /*[in ]*/ LPCWSTR szIconURI     ,
                                  /*[in ]*/ long    lType         ,
                                  /*[in ]*/ bool    fVisible      ,
                                  /*[in ]*/ long    lPos          );

        ////////////////////////////////////////

        HRESULT CreateMatch( /*[in]*/ LPCWSTR szKeyword, /*[in]*/ long ID_topic, /*[in]*/ long lPriority = 0, /*[in]*/ bool fHHK = true );

        ////////////////////////////////////////

        HRESULT MakeRoomForInsert( /*[in]*/ LPCWSTR szNodeStr, /*[in]*/ LPCWSTR szMode, /*[in]*/ LPCWSTR szID, /*[out]*/ long& lPos );

        HRESULT LocateSubNodes    ( /*[in]*/ long ID_node, /*[in]*/ bool fRecurse, /*[in]*/ bool fOnlyVisible, /*[out]*/ MatchSet& res );
        HRESULT LocateNodesFromURL( /*[in]*/ LPCWSTR szURL                                                   , /*[out]*/ MatchSet& res );


        HRESULT LookupNode          ( /*[in]*/ LPCWSTR szNodeStr ,                             /*[in]*/ CPCHQueryResultCollection* pColl );
        HRESULT LookupSubNodes      ( /*[in]*/ LPCWSTR szNodeStr , /*[in]*/ bool fVisibleOnly, /*[in]*/ CPCHQueryResultCollection* pColl );
        HRESULT LookupNodesAndTopics( /*[in]*/ LPCWSTR szNodeStr , /*[in]*/ bool fVisibleOnly, /*[in]*/ CPCHQueryResultCollection* pColl );
        HRESULT LookupTopics        ( /*[in]*/ LPCWSTR szNodeStr , /*[in]*/ bool fVisibleOnly, /*[in]*/ CPCHQueryResultCollection* pColl );
        HRESULT LocateContext       ( /*[in]*/ LPCWSTR szURL     , /*[in]*/ LPCWSTR szSubSite, /*[in]*/ CPCHQueryResultCollection* pColl );
        HRESULT KeywordSearch       ( /*[in]*/ LPCWSTR szQueryStr, /*[in]*/ LPCWSTR szSubSite, /*[in]*/ CPCHQueryResultCollection* pColl ,
                                                                                               /*[in]*/ MPC::WStringList*          lst   );

        HRESULT GatherNodes         ( /*[in]*/ LPCWSTR szNodeStr , /*[in]*/ bool fVisibleOnly, /*[in]*/ CPCHQueryResultCollection* pColl );
        HRESULT GatherTopics        ( /*[in]*/ LPCWSTR szNodeStr , /*[in]*/ bool fVisibleOnly, /*[in]*/ CPCHQueryResultCollection* pColl );
    };

    ////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////

    class KeywordSearch
    {
        typedef enum
        {
            TOKEN_INVALID     = -1,
            TOKEN_EMPTY           ,
            TOKEN_TEXT            ,
            TOKEN_PAREN_OPEN      ,
            TOKEN_PAREN_CLOSE     ,
            TOKEN_NOT             ,
            TOKEN_AND_IMPLICIT    ,
            TOKEN_AND             ,
            TOKEN_OR
        } TOKEN;

        struct Token
        {
            TOKEN            m_type;
            MPC::wstring     m_strToken;
            WeightedMatchSet m_results;

            Token*           m_left;  // Only for operators.
            Token*           m_right; //

            Token();
            ~Token();

            bool HasNOT();
            bool HasExplicitOperators();

            void AddHit( /*[in]*/ long ID, /*[in]*/ long priority );

            HRESULT ExecuteText(                                     /*[in]*/ LPCWSTR  szKeyword, /*[in]*/ RS_Keywords* rsKeywords, /*[in]*/ RS_Matches* rsMatches );
            HRESULT Execute    ( /*[in]*/ MatchSet& setAllTheTopics, /*[in]*/ Updater& updater  , /*[in]*/ RS_Keywords* rsKeywords, /*[in]*/ RS_Matches* rsMatches );

            void CollectKeywords( /*[in/out]*/ MPC::WStringList& lst ) const;

            HRESULT Stringify( /*[in]*/ MPC::wstring& strNewQuery );
        };

        ////////////////////////////////////////

        Updater&     m_updater;
        RS_Topics*   m_rsTopics;
        RS_Keywords* m_rsKeywords;
        RS_Matches*  m_rsMatches;

        WordSet*     m_setStopSignsWithoutContext;
        WordSet*     m_setStopSignsAtEnd;
        WordSet*     m_setStopWords;
        WordSet*     m_setOpNOT;
        WordSet*     m_setOpAND;
        WordSet*     m_setOpOR;

        ////////////////////////////////////////

        LPCWSTR SkipWhite( /*[in]*/ LPCWSTR szStr );

        bool IsNotString( /*[in]*/ LPCWSTR szSrc, /*[in]*/ WCHAR cQuote );
        bool IsQueryChar( /*[in]*/ WCHAR   c                            );

        void RemoveStopSignsWithoutContext( /*[in]*/ LPWSTR szText );
        void RemoveStopSignsAtEnd         ( /*[in]*/ LPWSTR szText );

        void CopyAndEliminateExtraWhiteSpace( /*[in]*/ LPCWSTR szSrc, /*[out]*/ LPWSTR szDst );

        TOKEN NextToken( /*[in/out]*/ LPCWSTR& szSrc, /*[out]*/ LPWSTR szToken );

        ////////////////////////////////////////

        HRESULT AllocateQuery  ( /*[in]    */ const MPC::wstring& strQuery, /*[out]*/ LPWSTR& szInput, /*[out]*/ LPWSTR& szOutput );
        HRESULT PreprocessQuery( /*[in/out]*/       MPC::wstring& strQuery                                                        );

        ////////////////////////////////////////

        HRESULT Parse( /*[in/out]*/ LPCWSTR& szInput, /*[in]*/ LPWSTR szTmpBuf, /*[in]*/ bool fSubExpr, /*[out]*/ Token*& res );

        HRESULT GenerateResults( /*[in]*/ Token* obj, /*[in]*/ CPCHQueryResultCollection* pColl, /*[in]*/ MPC::WStringUCSet& setURLs, /*[in]*/ Taxonomy::MatchSet* psetNodes );

    public:
        KeywordSearch( /*[in]*/ Updater& updater );
        ~KeywordSearch();

        HRESULT Execute( /*[in]*/ LPCWSTR szQuery, /*[in]*/ LPCWSTR szSubsite, /*[in]*/ CPCHQueryResultCollection* pColl, /*[in]*/ MPC::WStringList* lst );
    };

    ////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////

    class Cache : public CComObjectRootEx<MPC::CComSafeMultiThreadModel> // Just to have locking...
    {
    public:
        class NodeEntry;
        class QueryEntry;
        class SortEntries;
        class CachedHelpSet;

        ////////////////////
        class NodeEntry
        {
            friend class CachedHelpSet;

            ////////////////////

            RS_Data_Taxonomy m_rs_data;

            ////////////////////

            friend HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/       NodeEntry& val );
            friend HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const NodeEntry& val );

        public:
            NodeEntry();

            bool operator< ( /*[in]*/ NodeEntry const &en ) const;
            bool operator==( /*[in]*/ long             ID ) const;

            class MatchNode
            {
                long m_ID;

            public:
                MatchNode( /*[in]*/ long ID );

                bool operator()( /*[in]*/ NodeEntry const &en ) const;
            };
        };


        class QueryEntry
        {
            friend class CachedHelpSet;
            friend class SortEntries;

            ////////////////////

            MPC::wstring m_strID;
            int          m_iType;
            int          m_iSequence;
            bool         m_fNull;

            DWORD        m_dwSize;
            DATE         m_dLastUsed;
            bool         m_fRemoved;

            ////////////////////

            void    Touch();
            HRESULT GetFile( /*[out]*/ MPC::wstring& strFile );

            friend HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/       QueryEntry& val );
            friend HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const QueryEntry& val );

            ////////////////////

        public:
            QueryEntry();

            bool operator<( /*[in]*/ QueryEntry const &en ) const;


            HRESULT Store   ( /*[in]*/ MPC::StorageObject& disk, /*[in]*/ const CPCHQueryResultCollection* pColl );
            HRESULT Retrieve( /*[in]*/ MPC::StorageObject& disk, /*[in]*/       CPCHQueryResultCollection* pColl );
            HRESULT Release ( /*[in]*/ MPC::StorageObject& disk                                                  );
        };

        typedef std::set<NodeEntry>           NodeEntrySet;
        typedef NodeEntrySet::iterator        NodeEntryIter;
        typedef NodeEntrySet::const_iterator  NodeEntryIterConst;

        typedef std::set<QueryEntry>           QueryEntrySet;
        typedef QueryEntrySet::iterator        QueryEntryIter;
        typedef QueryEntrySet::const_iterator  QueryEntryIterConst;

        typedef std::vector<QueryEntry*>       SortedEntryVec;
        typedef SortedEntryVec::iterator       SortedEntryIter;
        typedef SortedEntryVec::const_iterator SortedEntryIterConst;

        class SortEntries
        {
        public:
            bool operator()( /*[in]*/ QueryEntry* const &left, /*[in]*/ QueryEntry* const &right ) const;
        };

        class CachedHelpSet
        {
            friend class Cache;

            Taxonomy::HelpSet  m_ths;
            MPC::wstring       m_strFile;
            MPC::StorageObject m_disk;

            bool               m_fLoaded;
            bool               m_fDirty;
            bool               m_fMarkedForLoad;
            DATE               m_dLastSaved;
            long               m_lTopNode;
            NodeEntrySet       m_setNodes;
            QueryEntrySet      m_setQueries;
            int                m_iLastSequence;

            void    Init        (                                  );
            void    Clean       (                                  );
            HRESULT Load        (                                  );
            HRESULT Save        (                                  );
            HRESULT EnsureInSync( /*[in]*/ bool fForceSave = false );

            ////////////////////

            HRESULT GenerateDefaultQueries( /*[in]*/ Taxonomy::Settings& ts      ,
                                            /*[in]*/ Taxonomy::Updater&  updater ,
                                            /*[in]*/ long                ID      ,
                                            /*[in]*/ long                lLevel  );

            HRESULT GenerateDefaultQueries( /*[in]*/ Taxonomy::Settings& ts      ,
                                            /*[in]*/ Taxonomy::Updater&  updater );

            bool LocateNode( /*[in]*/ long ID_parent, /*[in]*/ LPCWSTR szEntry, /*[out]*/ NodeEntryIter& it );

        public:
            CachedHelpSet();
            ~CachedHelpSet();

            // copy constructors...
            CachedHelpSet           ( /*[in]*/ const CachedHelpSet& chs );
            CachedHelpSet& operator=( /*[in]*/ const CachedHelpSet& chs );

            bool operator<( /*[in]*/ CachedHelpSet const &chs ) const;


            HRESULT PrePopulate  ( /*[in]*/ Cache* parent );
            HRESULT Erase        (                        );
            HRESULT PrepareToLoad(                        );
            HRESULT LoadIfMarked (                        );
            HRESULT MRU          (                        );

            HRESULT LocateNode( /*[in]*/ long ID_parent, /*[in]*/ LPCWSTR szEntry, /*[out]*/ RS_Data_Taxonomy& rs_data );

            HRESULT LocateSubNodes    ( /*[in]*/ long ID_node, /*[in]*/ bool fRecurse, /*[in]*/ bool fOnlyVisible, /*[out]*/ MatchSet& res );
            HRESULT LocateNodesFromURL( /*[in]*/ LPCWSTR szURL                                                   , /*[out]*/ MatchSet& res );

            HRESULT BuildNodePath( /*[in]*/ long ID, /*[out]*/ MPC::wstring& strPath , /*[in]*/ bool fParent );

            HRESULT LocateQuery( /*[in]*/ LPCWSTR szID, /*[in]*/ int iType, /*[out]*/ QueryEntry* &pEntry, /*[in]*/ bool fCreate );
        };

        typedef std::set<CachedHelpSet>  CacheSet;
        typedef CacheSet::iterator       CacheIter;
        typedef CacheSet::const_iterator CacheIterConst;

    private:

        ////////////////////

        CacheSet m_skus;

        HRESULT Locate( /*[in]*/ const Taxonomy::HelpSet& ths, /*[out]*/ CacheIter& it );

        void Shutdown();

        ////////////////////

    public:
        Cache();
        ~Cache();

        ////////////////////////////////////////////////////////////////////////////////

        static Cache* s_GLOBAL;

        static HRESULT InitializeSystem();
        static void    FinalizeSystem  ();

        ////////////////////////////////////////////////////////////////////////////////

        HRESULT PrePopulate  ( /*[in]*/ const Taxonomy::HelpSet& ths );
        HRESULT Erase        ( /*[in]*/ const Taxonomy::HelpSet& ths );
        HRESULT PrepareToLoad( /*[in]*/ const Taxonomy::HelpSet& ths );
        HRESULT LoadIfMarked ( /*[in]*/ const Taxonomy::HelpSet& ths );

        HRESULT LocateNode( /*[in]*/ const Taxonomy::HelpSet& ths, /*[in]*/ long ID_parent, /*[in]*/ LPCWSTR szEntry, /*[out]*/ RS_Data_Taxonomy& rs_data );

        HRESULT LocateSubNodes    ( /*[in]*/ const Taxonomy::HelpSet& ths, /*[in]*/ long ID_node, /*[in]*/ bool fRecurse, /*[in]*/ bool fOnlyVisible, /*[out]*/ MatchSet& res );
        HRESULT LocateNodesFromURL( /*[in]*/ const Taxonomy::HelpSet& ths, /*[in]*/ LPCWSTR szURL                                                   , /*[out]*/ MatchSet& res );

        HRESULT BuildNodePath( /*[in]*/ const Taxonomy::HelpSet& ths, /*[in]*/ long ID, /*[out]*/ MPC::wstring& strPath, /*[in]*/ bool fParent );

        HRESULT StoreQuery   ( /*[in]*/ const Taxonomy::HelpSet& ths, /*[in]*/ LPCWSTR szID, /*[in]*/ int iType, /*[in]*/ const CPCHQueryResultCollection* pColl );
        HRESULT RetrieveQuery( /*[in]*/ const Taxonomy::HelpSet& ths, /*[in]*/ LPCWSTR szID, /*[in]*/ int iType, /*[in]*/       CPCHQueryResultCollection* pColl );
    };

    ////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////

    struct Strings
    {
        static LPCWSTR const s_file_PackageDescription;

        static LPCWSTR const s_tag_root_PackageDescription;
        static LPCWSTR const s_tag_root_HHT;
        static LPCWSTR const s_tag_root_SAF;
    };

    class Logger
    {
        MPC::FileLog m_obj;
        DWORD        m_dwLogging;

    public:
        Logger();
        ~Logger();

        HRESULT StartLog ( /*[in]*/ LPCWSTR szLocation = NULL );
        HRESULT EndLog   (                                    );

        HRESULT WriteLogV( /*[in]*/ HRESULT hr, /*[in]*/ LPCWSTR szLogFormat, /*[in]*/ va_list arglist );
        HRESULT WriteLog ( /*[in]*/ HRESULT hr, /*[in]*/ LPCWSTR szLogFormat,          ...             );
    };

    struct InstanceBase // MACHINE-INDEPENDENT
    {
        Taxonomy::HelpSet m_ths;
        MPC::wstring      m_strDisplayName;
        MPC::wstring      m_strProductID;
        MPC::wstring      m_strVersion;

        bool              m_fDesktop;
        bool              m_fServer;
        bool              m_fEmbedded;

        ////////////////////

        InstanceBase();

        friend HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/       InstanceBase& val );
        friend HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const InstanceBase& val );

        bool Match( /*[in]*/ LPCWSTR szSKU, /*[in]*/ LPCWSTR szLanguage );
        bool Match( /*[in]*/ const Package& pkg                         );
    };

    struct Instance : public InstanceBase // MACHINE-DEPENDENT
    {
        bool              m_fSystem;
        bool              m_fMUI;
        bool              m_fExported;
        DATE              m_dLastUpdated;

        MPC::wstring      m_strSystem;
        MPC::wstring      m_strHelpFiles;
        MPC::wstring      m_strDatabaseDir;
        MPC::wstring      m_strDatabaseFile;
        MPC::wstring      m_strIndexFile;
        MPC::wstring      m_strIndexDisplayName;

        ////////////////////

        Instance();

        friend HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/       Instance& val );
        friend HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const Instance& val );

        HRESULT LoadFromStream( /*[in]*/ IStream* stream );
        HRESULT SaveToStream  ( /*[in]*/ IStream* stream ) const;

        HRESULT InitializeFromBase( /*[in]*/ const InstanceBase& base, /*[in]*/ bool fSystem, /*[in]*/ bool fMUI );

        ////////////////////

        void SetTimeStamp();

        HRESULT GetFileName( /*[out]*/ MPC::wstring& strFile                             );
        HRESULT Import     ( /*[in]*/  LPCWSTR        szFile, /*[in/out]*/ DWORD* pdwCRC );
        HRESULT Remove     (                                                             );
    };

    typedef std::list<Instance>          InstanceList;
    typedef InstanceList::iterator       InstanceIter;
    typedef InstanceList::const_iterator InstanceIterConst;

    ////////////////////

    struct Package
    {
        static const DWORD c_Cmp_SKU     = 0x0001;
        static const DWORD c_Cmp_ID      = 0x0002;
        static const DWORD c_Cmp_VERSION = 0x0004;

        MPC::wstring m_strFileName; // VOLATILE
        bool         m_fTemporary;  // VOLATILE Used for packages not yet authenticated.
        long         m_lSequence;
        DWORD        m_dwCRC;

        MPC::wstring m_strSKU;
        MPC::wstring m_strLanguage;
        MPC::wstring m_strVendorID;
        MPC::wstring m_strVendorName;
        MPC::wstring m_strProductID;
        MPC::wstring m_strVersion;

        bool         m_fMicrosoft;
        bool         m_fBuiltin;   // Used for packages installed as part of the setup.

        ////////////////////

        Package();
        ~Package();

        friend HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/       Package& val );
        friend HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const Package& val );

        int Compare( /*[in]*/ const Package& pkg, /*[in]*/ DWORD dwMode = -1 ) const;


        HRESULT GenerateFileName();


        HRESULT Import      ( /*[in]*/ Logger& log, /*[in]*/ LPCWSTR szFile, /*[in]*/ long lSequence, /*[in]*/ MPC::Impersonation* imp );
        HRESULT Authenticate( /*[in]*/ Logger& log                                                                                     );
        HRESULT Remove      ( /*[in]*/ Logger& log                                                                                     );

        HRESULT ExtractFile   ( /*[in]*/ Logger& log, /*[in]*/ LPCWSTR szFileDestination                , /*[in]*/ LPCWSTR szNameInCabinet );
        HRESULT ExtractXMLFile( /*[in]*/ Logger& log, /*[in]*/ MPC::XmlUtil& xml, /*[in]*/ LPCWSTR szTag, /*[in]*/ LPCWSTR szNameInCabinet );
        HRESULT ExtractPkgDesc( /*[in]*/ Logger& log, /*[in]*/ MPC::XmlUtil& xml                                                           );
    };

    typedef std::list<Package>          PackageList;
    typedef PackageList::iterator       PackageIter;
    typedef PackageList::const_iterator PackageIterConst;

    ////////////////////

    struct ProcessedPackage
    {
        long m_lSequence;
        bool m_fProcessed;
        bool m_fDisabled;

        ////////////////////

        ProcessedPackage();

        friend HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/       ProcessedPackage& val );
        friend HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const ProcessedPackage& val );
    };

    typedef std::list<ProcessedPackage>          ProcessedPackageList;
    typedef ProcessedPackageList::iterator       ProcessedPackageIter;
    typedef ProcessedPackageList::const_iterator ProcessedPackageIterConst;

    ////////////////////

    struct InstalledInstance
    {
        Instance             m_inst;
        ProcessedPackageList m_lst;
        bool                 m_fInvalidated;
        bool                 m_fRecreateCache;
        bool                 m_fCreateIndex;
        bool                 m_fCreateIndexForce;
        DWORD                m_dwCRC;

        DWORD                m_dwRef;          // VOLATILE

        ////////////////////

        InstalledInstance();

        friend HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/       InstalledInstance& val );
        friend HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const InstalledInstance& val );

        bool InUse() { return (m_dwRef != 0); }


        HRESULT InstallFiles  ( /*[in]*/ bool fAlsoHelpFiles, /*[in]*/ InstalledInstanceStore* store );
        HRESULT UninstallFiles( /*[in]*/ bool fAlsoHelpFiles                                         );
    };

    typedef std::list<InstalledInstance>          InstalledInstanceList;
    typedef InstalledInstanceList::iterator       InstalledInstanceIter;
    typedef InstalledInstanceList::const_iterator InstalledInstanceIterConst;

    ////////////////////

    class LockingHandle
    {
        friend class InstalledInstanceStore;

        InstalledInstanceStore* m_main; // We have a lock on it.
        Logger*                 m_logPrevious;

        void Attach( /*[in]*/ InstalledInstanceStore* main ,
                     /*[in]*/ Logger*                 log  );

    public:
        LockingHandle ();
        ~LockingHandle();

        void Release();
    };

    class InstallationEngine
    {
    public:
        bool m_fTaxonomyModified;
        bool m_fRecreateIndex;

        ////////////////////

        InstallationEngine()
        {
            ResetModificationFlags();
        }

        void ResetModificationFlags()
        {
            m_fTaxonomyModified = false;
            m_fRecreateIndex    = false;
        }

        virtual HRESULT ProcessPackage( /*[in]*/ InstalledInstance& instance, /*[in]*/ Package& pkg    ) = 0;
        virtual HRESULT RecreateIndex ( /*[in]*/ InstalledInstance& instance, /*[in]*/ bool     fForce ) = 0;
    };

    class InstalledInstanceStore : public CComObjectRootEx<MPC::CComSafeMultiThreadModel> // Just to get locking...
    {
        static const DWORD s_dwVersion = 0x03314351; // QC1 03

        friend class LockingHandle;

        InstanceList          m_lstInstances;
        PackageList           m_lstPackages;
        InstalledInstanceList m_lstSKUs;


        MPC::wstring          m_strStore;
        bool                  m_fLoaded;
        bool                  m_fDirty;
        Logger*               m_log;

        DWORD                 m_dwRecurse;

		bool                  m_fShutdown;

        ////////////////////////////////////////

        void    Clean           (                          );
        HRESULT Load            (                          );
        HRESULT LoadFromDisk    ( /*[in]*/ LPCWSTR  szFile );
        HRESULT LoadFromRegistry(                          );
        HRESULT LoadFromStream  ( /*[in]*/ IStream* stream );
        HRESULT Save            (                          );
        HRESULT SaveToDisk      ( /*[in]*/ LPCWSTR  szFile );
        HRESULT SaveToRegistry  (                          );
        HRESULT SaveToStream    ( /*[in]*/ IStream* stream );
        HRESULT EnsureInSync    (                          );

    public:
        InstalledInstanceStore();
        ~InstalledInstanceStore();

        ////////////////////////////////////////////////////////////////////////////////

        static InstalledInstanceStore* s_GLOBAL;

        static HRESULT InitializeSystem();
        static void    FinalizeSystem  ();

		void Shutdown();

		bool IsShutdown() { return m_fShutdown; }

        ////////////////////////////////////////////////////////////////////////////////

        HRESULT InUse_Lock  ( /*[in]*/ const Taxonomy::HelpSet& ths                                 );
        HRESULT InUse_Unlock( /*[in]*/ const Taxonomy::HelpSet& ths                                 );
        HRESULT GrabControl ( /*[in]*/       LockingHandle&     handle, /*[in]*/ Logger* log = NULL );

        ////////////////////////////////////////////////////////////////////////////////

        HRESULT Instance_GetList( /*[out]*/          InstanceIterConst& itBegin, /*[out]*/           InstanceIterConst& itEnd );
        HRESULT Package_GetList ( /*[out]*/           PackageIterConst& itBegin, /*[out]*/            PackageIterConst& itEnd );
        HRESULT SKU_GetList     ( /*[out]*/ InstalledInstanceIterConst& itBegin, /*[out]*/  InstalledInstanceIterConst& itEnd );


        HRESULT Instance_Find  (                          /*[in]*/ const Taxonomy::HelpSet& ths , /*[out]*/ bool& fFound, /*[out]*/ InstanceIter&          it );
        HRESULT Instance_Add   ( /*[in]*/ LPCWSTR szFile, /*[in]*/ const Instance&          data, /*[out]*/ bool& fFound, /*[out]*/ InstanceIter&          it );
        HRESULT Instance_Remove(                                                                                          /*[in ]*/ InstanceIter&          it );


        HRESULT Package_Find   (                          /*[in]*/ const Package&           pkg , /*[out]*/ bool& fFound, /*[out]*/ PackageIter&           it );
        HRESULT Package_Add    ( /*[in]*/ LPCWSTR szFile, /*[in]*/ MPC::Impersonation*      imp ,
                                                          /*[in]*/ const Taxonomy::HelpSet* ths , /*[in ]*/ bool  fInsertAtTop,
                                                                                                  /*[out]*/ bool& fFound, /*[out]*/ PackageIter&           it );
        HRESULT Package_Remove (                                                                                          /*[in ]*/ PackageIter&           it );


        HRESULT SKU_Find       (                          /*[in]*/ const Taxonomy::HelpSet& ths , /*[out]*/ bool& fFound, /*[out]*/ InstalledInstanceIter& it );
        HRESULT SKU_Add        (                          /*[in]*/ const Instance&          data, /*[out]*/ bool& fFound, /*[out]*/ InstalledInstanceIter& it );
        HRESULT SKU_Updated    (                                                                                          /*[in ]*/ InstalledInstanceIter& it );
        HRESULT SKU_Remove     (                                                                                          /*[in ]*/ InstalledInstanceIter& it );

        ////////////////////////////////////////////////////////////////////////////////

        HRESULT State_InvalidateSKU    ( /*[in]*/ const Taxonomy::HelpSet& ths      , /*[in]*/ bool fAlsoDatabase );
        HRESULT State_InvalidatePackage( /*[in]*/ long                     lSequence                              );

        ////////////////////////////////////////////////////////////////////////////////

        HRESULT MakeReady( /*[in]*/ InstallationEngine& engine, /*[in]*/ bool fNoOp, /*[in]*/ bool& fWorkToProcess );
    };
};

////////////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___HCP___TAXONOMYDATABASE_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\include\unsolicitedrc.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    UnsolicitedRC.h

Abstract:
    Declaration of the CSAFRemoteDesktopConnection class.

Revision History:
    KalyaniN  created  09/29/'00

********************************************************************/

#ifndef __SAF_UNSOLICITEDRC_H_
#define __SAF_UNSOLICITEDRC_H_

struct SSessionInfoItem
{
    CComBSTR               bstrDomain;
    CComBSTR               bstrUser;
    DWORD		           dwSessionID;
    SessionStateEnum       wtsConnectState;
};

/////////////////////////////////////////////////////////////////////////////
// CSAFRemoteDesktopConnection

class CSAFRemoteDesktopConnection :
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<ISAFRemoteDesktopConnection, &IID_ISAFRemoteDesktopConnection, &LIBID_HelpServiceTypeLib>
{
	void Cleanup();

public:
	CSAFRemoteDesktopConnection();
	~CSAFRemoteDesktopConnection();
	

BEGIN_COM_MAP(CSAFRemoteDesktopConnection)
	COM_INTERFACE_ENTRY(ISAFRemoteDesktopConnection)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CSAFRemoteDesktopConnection)

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);


// ISAFRemoteDesktopConnection
public:
	STDMETHOD(ConnectRemoteDesktop   )( /*[in]*/  BSTR bstrServerName,  /*[out, retval]*/ ISAFRemoteConnectionData  **ppRCD);	
};


/////////////////////////////////////////////////////////////////////////////
// CSAFRemoteConnectionData
class ATL_NO_VTABLE CSAFRemoteConnectionData : 
	public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
	public IDispatchImpl<ISAFRemoteConnectionData, &IID_ISAFRemoteConnectionData, &LIBID_HelpServiceTypeLib>
{
	long              m_NumSessions;
	SSessionInfoItem* m_SessionInfoTable;
	CComBSTR          m_bstrServerName;
    
	void Cleanup();

public:
DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CSAFRemoteConnectionData)

BEGIN_COM_MAP(CSAFRemoteConnectionData)
	COM_INTERFACE_ENTRY(ISAFRemoteConnectionData)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

	CSAFRemoteConnectionData();
	~CSAFRemoteConnectionData();

    HRESULT InitUserSessionsInfo(/*[in]*/ BSTR bstrServer );

	static HRESULT Populate( /*[in]*/ CPCHCollection* pColl );

// ISAFRemoteConnectionData
public:
	STDMETHOD(ConnectionParms)( /*[in		  ]*/ BSTR 	bstrServer           ,
							 	/*[in		  ]*/ BSTR 	bstrUser             ,
							 	/*[in		  ]*/ BSTR 	bstrDomain           ,
							 	/*[in		  ]*/ long 	lSessionID           ,
								/*[in         ]*/ BSTR  bstrUserHelpBlob     ,
							 	/*[out, retval]*/ BSTR *bstrConnectionString );
		
	STDMETHOD(Sessions)( /*[in, optional]*/ VARIANT vUser, /*[in, optional]*/ VARIANT  vDomain, /*[out, retval]*/ IPCHCollection* *ppC );
	STDMETHOD(Users   )(                                                                        /*[out, retval]*/ IPCHCollection* *ppC );
	STDMETHOD(ModemConnected)(  /*[in		  ]*/ BSTR 	bstrServer           ,
		                        /*[out, retval]*/ VARIANT_BOOL  *fModemConnected);

};


/////////////////////////////////////////////////////////////////////////////
// CSAFUser
class ATL_NO_VTABLE CSAFUser : 
	public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
	public IDispatchImpl<ISAFUser, &IID_ISAFUser, &LIBID_HelpServiceTypeLib>
{
	CComBSTR  m_bstrUserName;
	CComBSTR  m_bstrDomainName;

	void Cleanup();

public:
	CSAFUser();
	~CSAFUser();
	

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CSAFUser)

BEGIN_COM_MAP(CSAFUser)
	COM_INTERFACE_ENTRY(ISAFUser)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ISAFUser
public:
	STDMETHOD(get_UserName   )(/*[out, retval]*/ BSTR  *pbstrUserName  );
	STDMETHOD(get_DomainName )(/*[out, retval]*/ BSTR  *pbstrDomainName);
	STDMETHOD(put_UserName   )(/*[in         ]*/ BSTR   bstrUserName);
	STDMETHOD(put_DomainName )(/*[in         ]*/ BSTR   bstrDomainName);
};

/////////////////////////////////////////////////////////////////////////////
// CSAFSession
class ATL_NO_VTABLE CSAFSession : 
	public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
	public IDispatchImpl<ISAFSession, &IID_ISAFSession, &LIBID_HelpServiceTypeLib>
{
	CComBSTR               m_bstrUserName;
	CComBSTR               m_bstrDomainName;
	DWORD		           m_dwSessionID;
    SessionStateEnum       m_SessionConnectState;

	void Cleanup();

public:
	CSAFSession();
	~CSAFSession();
	

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CSAFSession)


BEGIN_COM_MAP(CSAFSession)
	COM_INTERFACE_ENTRY(ISAFSession)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ISAFSession
public:
	STDMETHOD(get_SessionID   )(/*[out, retval]*/ DWORD            *dwSessionID    );
	STDMETHOD(put_SessionID   )(/*[in         ]*/ DWORD             dwSessionID    );
	STDMETHOD(get_SessionState)(/*[out, retval]*/ SessionStateEnum *SessionState   );
	STDMETHOD(put_SessionState)(/*[in         ]*/ SessionStateEnum  SessionState   );
	STDMETHOD(get_UserName    )(/*[out, retval]*/ BSTR             *bstrUserName   );
	STDMETHOD(put_UserName    )(/*[in         ]*/ BSTR              bstrUserName   );
	STDMETHOD(get_DomainName  )(/*[out, retval]*/ BSTR             *bstrDomainName );
	STDMETHOD(put_DomainName  )(/*[in         ]*/ BSTR              bstrDomainName );
};

#endif //__SAF_UNSOLICITEDRC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\jetblue\comwrapper\column.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Column.cpp

Abstract:
    This file contains the implementation of the JetBlueCOM::Column class.

Revision History:
    Davide Massarenti   (Dmassare)  05/20/2000
        created

******************************************************************************/

#include <stdafx.h>

#ifndef NOJETBLUECOM

////////////////////////////////////////////////////////////////////////////////

JetBlueCOM::Column::Column()
{
    m_col = NULL; // JetBlue::Column* m_col;
}

JetBlueCOM::Column::~Column()
{
    Passivate();
}

////////////////////////////////////////

HRESULT JetBlueCOM::Column::Initialize( /*[in]*/ JetBlue::Column& col )
{
    m_col = &col;

    return S_OK;
}

void JetBlueCOM::Column::Passivate()
{
    MPC::SmartLock<_ThreadModel> lock( this );

    m_col = NULL;
}

////////////////////////////////////////

STDMETHODIMP JetBlueCOM::Column::get_Name( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_FUNC_ENTRY( "JetBlueCOM::Column::get_Name" );

	USES_CONVERSION;

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();

    __MPC_JET_CHECKHANDLE(hr,m_col,NULL);


    {
        const MPC::string& str = *m_col;

        hr = MPC::GetBSTR( A2W( str.c_str() ), pVal );
    }


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP JetBlueCOM::Column::get_Type( /*[out, retval]*/ long *pVal )
{
    __HCP_FUNC_ENTRY( "JetBlueCOM::Column::get_Type" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();

    __MPC_JET_CHECKHANDLE(hr,m_col,NULL);


    {
        const JET_COLUMNDEF& coldef = *m_col;

        *pVal = coldef.coltyp;
    }


    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP JetBlueCOM::Column::get_Bits( /*[out, retval]*/ long *pVal )
{
    __HCP_FUNC_ENTRY( "JetBlueCOM::Column::get_Bits" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();

    __MPC_JET_CHECKHANDLE(hr,m_col,NULL);


    {
        const JET_COLUMNDEF& coldef = *m_col;

        *pVal = coldef.grbit;
    }


    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP JetBlueCOM::Column::get_Value( /*[out, retval]*/ VARIANT *pVal )
{
    __HCP_FUNC_ENTRY( "JetBlueCOM::Column::get_Value" );

    HRESULT                      hr;
    CComVariant                  vValue;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pVal);
    __MPC_PARAMCHECK_END();

    __MPC_JET_CHECKHANDLE(hr,m_col,NULL);

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_col->Get( vValue ));

    hr = vValue.Detach( pVal );

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP JetBlueCOM::Column::put_Value( /*[in]*/ VARIANT newVal )
{
    __HCP_FUNC_ENTRY( "JetBlueCOM::Column::put_Value" );

    HRESULT                      hr;
    CComVariant                  vValue;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_JET_CHECKHANDLE(hr,m_col,NULL);

    __MPC_EXIT_IF_METHOD_FAILS(hr, vValue.Attach( &newVal ));

    hr = m_col->Put( vValue );

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\include\wmiparser.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    WMIParser.h

Abstract:
    This file contains the declaration of the classes that are part of
    the WMIParser library.

Revision History:
    Davide Massarenti   (Dmassare)  07/25/99
        created

******************************************************************************/

#if !defined(__INCLUDED___PCH___WMIPARSER_H___)
#define __INCLUDED___PCH___WMIPARSER_H___

/////////////////////////////////////////////////////////////////////////////

namespace WMIParser
{
    class InstanceName;
    class ValueReference;

    /////////////////////////////////////////////////////////////////////////////

    class InstanceNameItem // Hungarian: wmipini
    {
        friend InstanceName;

    private:
        MPC::wstring    m_szValue;
        ValueReference* m_wmipvrValue;

    public:
        InstanceNameItem();
        InstanceNameItem( /*[in]*/ const InstanceNameItem& wmipini );
        ~InstanceNameItem();

        InstanceNameItem& operator=( /*[in]*/ const InstanceNameItem& wmipini );

        bool operator==( /*[in]*/ InstanceNameItem const &wmipini ) const;
        bool operator< ( /*[in]*/ InstanceNameItem const &wmipini ) const;
    };

    class InstanceName // Hungarian: wmipin
    {
        friend class Instance;

    public:
        typedef std::map<MPC::wstringUC,InstanceNameItem> KeyMap;
        typedef KeyMap::iterator                          KeyIter;
        typedef KeyMap::const_iterator                    KeyIterConst;

    private:
        MPC::XmlUtil m_xmlNode;       // This instance in the Xml DOM.
        MPC::wstring m_szNamespace;   // Namespace of the instance in CIM.
        MPC::wstring m_szClass;       // Name of the class for this instance.

        KeyMap       m_mapKeyBinding; // Set of keys.


        HRESULT ParseNamespace(                                                                                              );
        HRESULT ParseKey      ( /*[in] */ IXMLDOMNode* pxdnNode, /*[out]*/ InstanceNameItem& wmipini, /*[out]*/ bool& fEmpty );
        HRESULT ParseKeys     (                                                                                              );


    public:
        InstanceName();
        ~InstanceName();

        bool operator==( /*[in]*/ InstanceName const &wmipin ) const;
        bool operator< ( /*[in]*/ InstanceName const &wmipin ) const;

        HRESULT put_Node( /*[in] */ IXMLDOMNode* pxdnNode, /*[out]*/ bool& fEmpty );


        HRESULT get_Namespace( /*[out]*/ MPC::wstring& szNamespace );
        HRESULT get_Class    ( /*[out]*/ MPC::wstring& szClass     );


        HRESULT get_KeyBinding( /*[out]*/ KeyIterConst& itBegin, /*[out]*/ KeyIterConst& itEnd );
    };


    class Value // Hungarian: wmipv
    {
    private:
        long         m_lData;   // Length of the data value.
        BYTE*        m_rgData;  // Data value.
        MPC::wstring m_szData;  // Data value.

    public:
        Value();
        virtual ~Value();

        bool operator==( /*[in]*/ Value const &wmipv ) const;

        HRESULT Parse( /*[in] */ IXMLDOMNode* pxdnNode, /*[in]*/ LPCWSTR szTag );

        HRESULT get_Data( /*[out]*/ long& lData, /*[out]*/ BYTE*&        rgData );
        HRESULT get_Data(                        /*[out]*/ MPC::wstring& szData );
    };

    class ValueReference // Hungarian: wmipvr
    {
    private:
        InstanceName m_wmipin;

    public:
        ValueReference();
        virtual ~ValueReference();

        bool operator==( /*[in]*/ ValueReference const &wmipvr ) const;
        bool operator< ( /*[in]*/ ValueReference const &wmipvr ) const;

        HRESULT Parse( /*[in] */ IXMLDOMNode* pxdnNode );

        HRESULT get_Data( /*[out]*/ InstanceName*& wmipin );
    };

    /////////////////////////////////////////////////////////////////////////////

    class Property // Hungarian: wmipp
    {
    protected:
        MPC::XmlUtil m_xmlNode; // This property in the Xml DOM.
        MPC::wstring m_szName;  // Name of the property.
        MPC::wstring m_szType;  // Type of the value for this property.

    public:
        Property();
        virtual ~Property();

        bool operator==( /*[in]*/ LPCWSTR             strName ) const;
        bool operator==( /*[in]*/ const MPC::wstring& szName  ) const;


        HRESULT put_Node( /*[in] */ IXMLDOMNode*  pxdnNode );
        HRESULT get_Node( /*[out]*/ IXMLDOMNode* *pxdnNode );


        HRESULT get_Name( /*[out]*/ MPC::wstring& szName );
        HRESULT get_Type( /*[out]*/ MPC::wstring& szType );
    };

    class Property_Scalar : public Property // Hungarian: wmipps
    {
    private:
        Value m_wmipvData;

    public:
        Property_Scalar();
        virtual ~Property_Scalar();

        bool operator==( /*[in]*/ Property_Scalar const &wmipps  ) const;


        HRESULT put_Node( /*[in] */ IXMLDOMNode* pxdnNode );


        HRESULT get_Data( /*[out]*/ MPC::wstring&       szData                         );
        HRESULT put_Data( /*[in] */ const MPC::wstring& szData, /*[out]*/ bool& fFound );
    };

    class Property_Array : public Property // Hungarian: wmippa
    {
    private:
        typedef std::list<Value>         ElemList;
        typedef ElemList::iterator       ElemIter;
        typedef ElemList::const_iterator ElemIterConst;

        ElemList m_lstElements;

    public:
        Property_Array();
        virtual ~Property_Array();

        bool operator==( /*[in]*/ Property_Array const &wmippa ) const;


        HRESULT put_Node( /*[in] */ IXMLDOMNode* pxdnNode );


        HRESULT get_Data( /*[in]*/ int iIndex, /*[out]*/ MPC::wstring&       szData                         );
        HRESULT put_Data( /*[in]*/ int iIndex, /*[in] */ const MPC::wstring& szData, /*[out]*/ bool& fFound );
    };

    class Property_Reference : public Property // Hungarian: wmippr
    {
    private:
        ValueReference m_wmipvrData;

    public:
        Property_Reference();
        virtual ~Property_Reference();

        bool operator==( /*[in]*/ Property_Reference const &wmippr ) const;


        HRESULT put_Node( /*[in] */ IXMLDOMNode* pxdnNode );


        HRESULT get_Data( /*[out]*/ ValueReference*& wmipvr );
    };

    /////////////////////////////////////////////////////////////////////////////

    class Instance // Hungarian: wmipi
    {
        friend class Instance_Less_ByClass;
        friend class Instance_Less_ByKey;

    public:
        typedef std::map<MPC::wstring,Property_Scalar>    PropMap;
        typedef PropMap::iterator                         PropIter;
        typedef PropMap::const_iterator                   PropIterConst;

        typedef std::map<MPC::wstring,Property_Array>     ArrayMap;
        typedef ArrayMap::iterator                        ArrayIter;
        typedef ArrayMap::const_iterator                  ArrayIterConst;

        typedef std::map<MPC::wstring,Property_Reference> ReferenceMap;
        typedef ReferenceMap::iterator                    ReferenceIter;
        typedef ReferenceMap::const_iterator              ReferenceIterConst;

    private:
        MPC::XmlUtil     m_xmlNode;                // This instance in the Xml DOM.

        Property_Scalar  m_wmippTimeStamp;         // Timestamp of this instance.
        bool             m_fTimeStamp;             //

        Property_Scalar  m_wmippChange;            // Change status of this instance.
        bool             m_fChange;                //

        InstanceName     m_wmipinIdentity;         // Set of keys.

        bool             m_fPropertiesParsed;      // Flags to indicate if properties are already parsed or not.
        PropMap          m_mapPropertiesScalar;    // Map of all the scalar properties of this instance.
        ArrayMap         m_mapPropertiesArray;     // Map of all the array properties of this instance.
        ReferenceMap     m_mapPropertiesReference; // Map of all the reference properties of this instance.


        HRESULT ParseIdentity           ( /*[in] */ IXMLDOMNode* pxdnNode, /*[out]*/ bool& fEmpty );
        HRESULT ParseProperties         (                                                         );
        HRESULT ParsePropertiesScalar   (                                                         );
        HRESULT ParsePropertiesArray    (                                                         );
        HRESULT ParsePropertiesReference(                                                         );


    public:
        Instance();
        ~Instance();


        bool operator==( /*[in]*/ Instance const &wmipi ) const;


        HRESULT put_Node( /*[in] */ IXMLDOMNode*  pxdnNode, /*[out]*/ bool& fEmpty );
        HRESULT get_Node( /*[out]*/ IXMLDOMNode* *pxdnNode                         );


        HRESULT get_Namespace( /*[out]*/ MPC::wstring&                 szNamespace );
        HRESULT get_Class    ( /*[out]*/ MPC::wstring&                 szClass     );

        HRESULT get_TimeStamp( /*[out]*/ Property_Scalar*& wmippTimeStamp, /*[out]*/ bool& fFound );
        HRESULT get_Change   ( /*[out]*/ Property_Scalar*& wmippChange                            );


        HRESULT get_Identity           ( /*[out]*/ InstanceName*&      wmipin                                       );
        HRESULT get_Properties         ( /*[out]*/ PropIterConst&      itBegin, /*[out]*/ PropIterConst&      itEnd );
        HRESULT get_PropertiesArray    ( /*[out]*/ ArrayIterConst&     itBegin, /*[out]*/ ArrayIterConst&     itEnd );
        HRESULT get_PropertiesReference( /*[out]*/ ReferenceIterConst& itBegin, /*[out]*/ ReferenceIterConst& itEnd );

        bool CompareByClass( /*[in]*/ Instance const &wmipi ) const;
        bool CompareByKey  ( /*[in]*/ Instance const &wmipi ) const;
    };

    class Instance_Less_ByClass
    {
     public:
        bool operator()( /*[in]*/ Instance* const &, /*[in]*/ Instance* const & ) const;
    };

    class Instance_Less_ByKey
    {
     public:
        bool operator()( /*[in]*/ Instance* const &, /*[in]*/ Instance* const & ) const;
    };

    /////////////////////////////////////////////////////////////////////////////

    class Snapshot // Hungarian: wmips
    {
    public:
        typedef std::list<Instance>      InstList;
        typedef InstList::iterator       InstIter;
        typedef InstList::const_iterator InstIterConst;

    private:
        MPC::XmlUtil         m_xmlNode;       // This snapshot in the Xml DOM.
        CComPtr<IXMLDOMNode> m_xdnInstances;  // Position of the parent of all instances.

        InstList             m_lstInstances;  // List of all the instances of this snapshot.


        HRESULT Parse();


    public:
        Snapshot();
        ~Snapshot();


        HRESULT put_Node            ( /*[in] */ IXMLDOMNode*  pxdnNode );
        HRESULT get_Node            ( /*[out]*/ IXMLDOMNode* *pxdnNode );
        HRESULT get_NodeForInstances( /*[out]*/ IXMLDOMNode* *pxdnNode );


        HRESULT get_Instances( /*[out]*/ InstIterConst& itBegin, /*[out]*/ InstIterConst& itEnd );


        HRESULT clone_Instance( /*[in]*/ Instance* pwmipiOld, /*[out]*/ Instance*& pwmipiNew );


        HRESULT New (                                                     );
        HRESULT Load( /*[in]*/ LPCWSTR szFile, /*[in]*/ LPCWSTR szRootTag );
        HRESULT Save( /*[in]*/ LPCWSTR szFile                             );
    };

    /////////////////////////////////////////////////////////////////////////////

    typedef std::map<Instance*,Instance*,Instance_Less_ByKey> ClusterByKeyMap;
    typedef ClusterByKeyMap::iterator                         ClusterByKeyIter;
    typedef ClusterByKeyMap::const_iterator                   ClusterByKeyIterConst;


    class Cluster
    {
        ClusterByKeyMap m_map;

    public:
        Cluster() {};

        HRESULT Add ( /*[in] */ Instance*         wmipiInst                                                               );
        HRESULT Find( /*[in] */ Instance*         wmipiInst, /*[out]*/ Instance*&        wmipiRes, /*[out]*/ bool& fFound );
        HRESULT Enum( /*[out]*/ ClusterByKeyIter& itBegin  , /*[out]*/ ClusterByKeyIter& itEnd                            );
    };

    typedef std::map<Instance*,Cluster,Instance_Less_ByClass> ClusterByClassMap;
    typedef ClusterByClassMap::iterator                       ClusterByClassIter;
    typedef ClusterByClassMap::const_iterator                 ClusterByClassIterConst;

    /////////////////////////////////////////////////////////////////////////////

    HRESULT DistributeOnCluster( /*[in]*/ ClusterByClassMap& cluster, /*[in]*/ Snapshot& wmips );

    HRESULT CompareSnapshots( /*[in]        */ BSTR          bstrFilenameT0   ,
                              /*[in]        */ BSTR          bstrFilenameT1   ,
                              /*[in]        */ BSTR          bstrFilenameDiff ,
                              /*[out,retval]*/ VARIANT_BOOL *pVal             );
};

#endif // !defined(__INCLUDED___PCH___WMIPARSER_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\include\utility.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Utility.h

Abstract:
    This file contains the declaration of the service-side class exposed as the "pchealth" object.

Revision History:
    Davide Massarenti   (dmassare) 03/20/2000
        created

    Kalyani Narlanka    (KalyaniN)  03/15/01
	    Moved Incident and Encryption Objects from HelpService to HelpCtr to improve Perf.

******************************************************************************/

#if !defined(__INCLUDED___PCH___UTILITY_H___)
#define __INCLUDED___PCH___UTILITY_H___

#include <MPC_COM.h>
#include <MPC_Security.h>

#include <Debug.h>

#include <SAFLib.h>
#include <TaxonomyDatabase.h>
#include <SystemMonitor.h>
#include <FileList.h>

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHUserSettings :
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public IDispatchImpl<IPCHUserSettings, &IID_IPCHUserSettings, &LIBID_HelpServiceTypeLib>
{
	bool               m_fAttached;
    Taxonomy::Settings m_ts;

	HRESULT get_SKU( /*[in]*/ bool fMachine, /*[out, retval]*/ IPCHSetOfHelpTopics* *pVal );

public:
BEGIN_COM_MAP(CPCHUserSettings)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHUserSettings)
END_COM_MAP()

    CPCHUserSettings();
    virtual ~CPCHUserSettings();

	void Passivate();

    HRESULT InitUserSettings( /*[out]*/ Taxonomy::HelpSet& ths );

    ////////////////////

    // IPCHUserSettings
    STDMETHOD(get_CurrentSKU)( /*[out, retval]*/ IPCHSetOfHelpTopics* *pVal );
    STDMETHOD(get_MachineSKU)( /*[out, retval]*/ IPCHSetOfHelpTopics* *pVal );
																 
    STDMETHOD(get_HelpLocation    )(  							   	   /*[out, retval]*/ BSTR *pVal );
    STDMETHOD(get_DatabaseDir     )(  							   	   /*[out, retval]*/ BSTR *pVal );
    STDMETHOD(get_DatabaseFile    )(  							   	   /*[out, retval]*/ BSTR *pVal );
    STDMETHOD(get_IndexFile       )( /*[in,optional]*/ VARIANT vScope, /*[out, retval]*/ BSTR *pVal );
    STDMETHOD(get_IndexDisplayName)( /*[in,optional]*/ VARIANT vScope, /*[out, retval]*/ BSTR *pVal );
    STDMETHOD(get_LastUpdated     )(  							   	   /*[out, retval]*/ DATE *pVal );

    STDMETHOD(get_AreHeadlinesEnabled)( /*[out, retval]*/ VARIANT_BOOL *pVal );
    STDMETHOD(get_News               )( /*[out, retval]*/ IUnknown*    *pVal );


    STDMETHOD(Select)( /*[in]*/ BSTR bstrSKU, /*[in]*/ long lLCID );
};

/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHSetOfHelpTopics :
    public MPC::Thread			   < CPCHSetOfHelpTopics, IPCHSetOfHelpTopics                                            >,
    public MPC::ConnectionPointImpl< CPCHSetOfHelpTopics, &DIID_DPCHSetOfHelpTopicsEvents, MPC::CComSafeMultiThreadModel >,
    public IDispatchImpl           < IPCHSetOfHelpTopics, &IID_IPCHSetOfHelpTopics, &LIBID_HelpServiceTypeLib            >,
	public IPersistStream
{
    Taxonomy::Settings           m_ts;
    Taxonomy::Instance           m_inst;

	////////////////////

    CComPtr<IDispatch>           m_sink_onStatusChange;
    SHT_STATUS                   m_shtStatus;
	HRESULT                      m_hrErrorCode;
    bool                         m_fReadyForCommands;
	  							 
	MPC::Impersonation           m_imp;
	  							 
    bool                         m_fInstalled;
	  							 
    bool                         m_fConnectedToDisk;
	MPC::wstring                 m_strDirectory;
    MPC::wstring                 m_strCAB;
    MPC::wstring                 m_strLocalCAB;
	  							 
    bool                         m_fConnectedToServer;
    MPC::wstring                 m_strServer;
    CComPtr<IPCHSetOfHelpTopics> m_sku;
    CComPtr<IPCHService>         m_svc;
	  							 
    bool                         m_fActAsCollection;
	CComPtr<CPCHCollection>      m_coll;


    //////////////////////////////////////////////////////////////////////

	HRESULT PrepareSettings    (                           );
    HRESULT Close              ( /*[in]*/ bool    fCleanup );
	void    CleanupWorkerThread( /*[in]*/ HRESULT hr       );

	HRESULT ImpersonateCaller();
	HRESULT EndImpersonation ();

	HRESULT GetListOfFilesFromDatabase( /*[in]*/ const MPC::wstring& strDB, /*[out]*/ MPC::WStringList& lst );

	HRESULT ProcessPackages();
	HRESULT CreateIndex    ();


    //////////////////////////////////////////////////////////////////////

    HRESULT RunInitFromDisk  ();
    HRESULT RunInitFromServer();

    HRESULT RunInstall       ();
    HRESULT RunUninstall     ();

    HRESULT put_Status( /*[in]*/ SHT_STATUS newVal, /*[in]*/ BSTR bstrFile );

    //////////////////////////////////////////////////////////////////////

    //
    // Event firing methods.
    //
    HRESULT Fire_onStatusChange( IPCHSetOfHelpTopics* obj, SHT_STATUS lStatus, long hrErrorCode, BSTR bstrFile );

    //////////////////////////////////////////////////////////////////////

    HRESULT PopulateFromDisk  ( /*[in]*/ CPCHSetOfHelpTopics* pParent, /*[in]*/ const MPC::wstring& strDirectory                    );
    HRESULT PopulateFromServer( /*[in]*/ CPCHSetOfHelpTopics* pParent, /*[in]*/ IPCHSetOfHelpTopics* sku, /*[in]*/ IPCHService* svc );

public:
BEGIN_COM_MAP(CPCHSetOfHelpTopics)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHSetOfHelpTopics)
    COM_INTERFACE_ENTRY(IPersistStream)
END_COM_MAP()

    CPCHSetOfHelpTopics();
    virtual ~CPCHSetOfHelpTopics();

    HRESULT Init          ( /*[in]*/ const Taxonomy::Instance& inst                       );
    HRESULT InitFromDisk  ( /*[in]*/ LPCWSTR szDirectory , /*[in]*/ CPCHCollection* pColl );
    HRESULT InitFromServer( /*[in]*/ LPCWSTR szServerName, /*[in]*/ CPCHCollection* pColl );

	static HRESULT VerifyWritePermissions();

    //////////////////////////////////////////////////////////////////////

	HRESULT RegisterPackage( /*[in]*/ const MPC::wstring& strFile, /*[in]*/ bool fBuiltin );

	HRESULT DirectInstall  ( /*[in]*/ Installer::Package&      pkg, /*[in]*/ bool fSetup, /*[in]*/ bool fSystem, /*[in]*/ bool fMUI );
	HRESULT DirectUninstall( /*[in]*/ const Taxonomy::HelpSet* ths = NULL                                                           );
	HRESULT ScanBatch      (                                                                                                        );

	static HRESULT RebuildSKU( /*[in]*/ const Taxonomy::HelpSet& ths );

    //////////////////////////////////////////////////////////////////////

    // IPCHSetOfHelpTopics
    STDMETHOD(get_SKU           )( /*[out, retval]*/ BSTR         *pVal     );
    STDMETHOD(get_Language      )( /*[out, retval]*/ long         *pVal     );
    STDMETHOD(get_DisplayName   )( /*[out, retval]*/ BSTR         *pVal     );
    STDMETHOD(get_ProductID     )( /*[out, retval]*/ BSTR         *pVal     );
    STDMETHOD(get_Version       )( /*[out, retval]*/ BSTR         *pVal     );

    STDMETHOD(get_Location      )( /*[out, retval]*/ BSTR         *pVal     );
    STDMETHOD(get_Exported      )( /*[out, retval]*/ VARIANT_BOOL *pVal     );
    STDMETHOD(put_Exported      )( /*[in         ]*/ VARIANT_BOOL  newVal   );

    STDMETHOD(put_onStatusChange)( /*[in         ]*/ IDispatch*    function );
    STDMETHOD(get_Status        )( /*[out, retval]*/ SHT_STATUS   *pVal     );
    STDMETHOD(get_ErrorCode     )( /*[out, retval]*/ long         *pVal     );

    STDMETHOD(get_IsMachineHelp )( /*[out, retval]*/ VARIANT_BOOL *pVal     );
    STDMETHOD(get_IsInstalled   )( /*[out, retval]*/ VARIANT_BOOL *pVal     );
    STDMETHOD(get_CanInstall    )( /*[out, retval]*/ VARIANT_BOOL *pVal     );
    STDMETHOD(get_CanUninstall  )( /*[out, retval]*/ VARIANT_BOOL *pVal     );

    STDMETHOD(Install  )();
    STDMETHOD(Uninstall)();
    STDMETHOD(Abort    )();

	////////////////////////////////////////
	//
	// IPersist
	//
    STDMETHOD(GetClassID)( /*[out]*/ CLSID *pClassID );
    //
	// IPersistStream
	//
	STDMETHOD(IsDirty)();
	STDMETHOD(Load)( /*[in]*/ IStream *pStm                            );
	STDMETHOD(Save)( /*[in]*/ IStream *pStm, /*[in]*/ BOOL fClearDirty );
	STDMETHOD(GetSizeMax)( /*[out]*/ ULARGE_INTEGER *pcbSize );
	//
	////////////////////////////////////////
};

typedef CComObject<CPCHSetOfHelpTopics> CPCHSetOfHelpTopics_Object;

/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHTaxonomyDatabase :
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public IDispatchImpl<IPCHTaxonomyDatabase, &IID_IPCHTaxonomyDatabase, &LIBID_HelpServiceTypeLib>
{
    Taxonomy::Settings           m_ts;
	CComPtr<IPCHSetOfHelpTopics> m_ActiveObject;

public:
BEGIN_COM_MAP(CPCHTaxonomyDatabase)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHTaxonomyDatabase)
END_COM_MAP()

    Taxonomy::Settings& GetTS() { return m_ts; }

    static HRESULT SelectInstalledSKUs( /*[in]*/ bool fOnlyExported, /*[out, retval]*/ IPCHCollection* *pVal );


    // IPCHTaxonomyDatabase
    STDMETHOD(get_InstalledSKUs      )( /*[out, retval]*/ IPCHCollection* *pVal );
    STDMETHOD(get_HasWritePermissions)( /*[out, retval]*/ VARIANT_BOOL    *pVal );

    STDMETHOD(LookupNode    	  )( /*[in]*/ BSTR bstrNode	,                                     /*[out, retval]*/ IPCHCollection* *ppC );
    STDMETHOD(LookupSubNodes	  )( /*[in]*/ BSTR bstrNode	, /*[in]*/ VARIANT_BOOL fVisibleOnly, /*[out, retval]*/ IPCHCollection* *ppC );
    STDMETHOD(LookupNodesAndTopics)( /*[in]*/ BSTR bstrNode	, /*[in]*/ VARIANT_BOOL fVisibleOnly, /*[out, retval]*/ IPCHCollection* *ppC );
    STDMETHOD(LookupTopics  	  )( /*[in]*/ BSTR bstrNode	, /*[in]*/ VARIANT_BOOL fVisibleOnly, /*[out, retval]*/ IPCHCollection* *ppC );
    STDMETHOD(LocateContext       )( /*[in]*/ BSTR bstrURL  , /*[in,optional]*/ VARIANT vSubSite, /*[out, retval]*/ IPCHCollection* *ppC );
    STDMETHOD(KeywordSearch 	  )( /*[in]*/ BSTR bstrQuery, /*[in,optional]*/ VARIANT vSubSite, /*[out, retval]*/ IPCHCollection* *ppC );
	  																																
    STDMETHOD(GatherNodes   	  )( /*[in]*/ BSTR bstrNode	, /*[in]*/ VARIANT_BOOL fVisibleOnly, /*[out, retval]*/ IPCHCollection* *ppC );
    STDMETHOD(GatherTopics  	  )( /*[in]*/ BSTR bstrNode	, /*[in]*/ VARIANT_BOOL fVisibleOnly, /*[out, retval]*/ IPCHCollection* *ppC );

    STDMETHOD(ConnectToDisk  )( /*[in]*/ BSTR bstrDirectory , /*[in]*/ IDispatch* notify, /*[out, retval]*/ IPCHCollection* *ppC );
    STDMETHOD(ConnectToServer)( /*[in]*/ BSTR bstrServerName, /*[in]*/ IDispatch* notify, /*[out, retval]*/ IPCHCollection* *ppC );
    STDMETHOD(Abort          )(                                                                                                  );
};

////////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHUtility :
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public IDispatchImpl<IPCHUtility, &IID_IPCHUtility, &LIBID_HelpServiceTypeLib>
{
    CComPtr<CPCHUserSettings> m_UserSettings;

    HRESULT InitUserSettings( /*[in]*/ Taxonomy::Settings& ts );

public:
BEGIN_COM_MAP(CPCHUtility)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHUtility)
END_COM_MAP()

    HRESULT FinalConstruct();

    // IPCHUtility
    STDMETHOD(get_UserSettings)( /*[out, retval]*/ IPCHUserSettings*     *pVal );
    STDMETHOD(get_Channels    )( /*[out, retval]*/ ISAFReg*              *pVal );
    STDMETHOD(get_Security    )( /*[out, retval]*/ IPCHSecurity*         *pVal );
    STDMETHOD(get_Database    )( /*[out, retval]*/ IPCHTaxonomyDatabase* *pVal );


    STDMETHOD(FormatError)( /*[in]*/ VARIANT vError, /*[out, retval]*/ BSTR *pVal );

    STDMETHOD(CreateObject_SearchEngineMgr)(                                                          /*[out, retval]*/ IPCHSEManager*      *ppSE );
    STDMETHOD(CreateObject_DataCollection )(                                                          /*[out, retval]*/ ISAFDataCollection* *ppDC );
    STDMETHOD(CreateObject_Cabinet        )(                                                          /*[out, retval]*/ ISAFCabinet*        *ppCB );
    STDMETHOD(CreateObject_Encryption     )(                                                          /*[out, retval]*/ ISAFEncrypt*        *ppEn );
    STDMETHOD(CreateObject_Channel        )( /*[in]*/ BSTR bstrVendorID, /*[in]*/ BSTR bstrProductID, /*[out, retval]*/ ISAFChannel*        *ppCh );

	STDMETHOD(CreateObject_RemoteDesktopConnection)( /*[out, retval]*/ ISAFRemoteDesktopConnection* *ppRDC               );
	STDMETHOD(CreateObject_RemoteDesktopSession   )( /*[in]         */ REMOTE_DESKTOP_SHARING_CLASS  sharingClass        ,
                                                     /*[in]         */ long 						 lTimeout            ,
                                                     /*[in]         */ BSTR 						 bstrConnectionParms ,
													 /*[in]         */ BSTR 						 bstrUserHelpBlob    ,
													 /*[out, retval]*/ ISAFRemoteDesktopSession*    *ppRCS               );


    STDMETHOD(ConnectToExpert)( /*[in]*/ BSTR bstrExpertConnectParm, /*[in]*/ LONG lTimeout, /*[out, retval]*/ LONG *lSafErrorCode );

	STDMETHOD(SwitchDesktopMode)( /*[in]*/ int nMode, /* [in]*/ int nRAType );
};

////////////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___PCH___UTILITY_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\jetblue\comwrapper\database.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Database.cpp

Abstract:
    This file contains the implementation of the JetBlueCOM::Database class.

Revision History:
    Davide Massarenti   (Dmassare)  05/20/2000
        created

******************************************************************************/

#include <stdafx.h>

#ifndef NOJETBLUECOM

////////////////////////////////////////////////////////////////////////////////

JetBlueCOM::Database::Database()
{
    m_db = NULL; // JetBlue::Database*                     m_db;
                 // BaseObjectWithChildren<Database,Table> m_Tables;
}

JetBlueCOM::Database::~Database()
{
    Passivate();
}

HRESULT JetBlueCOM::Database::Refresh()
{
    __HCP_FUNC_ENTRY( "JetBlueCOM::Database::Refresh" );

    HRESULT hr;
    int     iTbl = m_db->NumOfTables();
    int     i;

    m_Tables.Passivate();

    for(i=0; i<iTbl; i++)
    {
        CComPtr<Table>  child;
        JetBlue::Table* tbl = m_db->GetTbl( i );

        __MPC_EXIT_IF_METHOD_FAILS(hr, tbl->Open());

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_Tables.CreateChild( this, &child ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, child->Initialize( *tbl ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

HRESULT JetBlueCOM::Database::Initialize( /*[in]*/ JetBlue::Database& db )
{
    __HCP_FUNC_ENTRY( "JetBlueCOM::Database::Initialize" );

    HRESULT hr;


    m_db = &db;


    hr = Refresh();


    __HCP_FUNC_EXIT(hr);
}

void JetBlueCOM::Database::Passivate()
{
    MPC::SmartLock<_ThreadModel> lock( this );

    m_db = NULL;

    m_Tables.Passivate();
}

////////////////////////////////////////

STDMETHODIMP JetBlueCOM::Database::get_Name( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_FUNC_ENTRY( "JetBlueCOM::Database::get_Name" );

	USES_CONVERSION;

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();

    __MPC_JET_CHECKHANDLE(hr,m_db,NULL);


    {
        const MPC::string& str = *m_db;

        hr = MPC::GetBSTR( A2W(str.c_str()), pVal );
    }


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP JetBlueCOM::Database::get_Tables( /*[out, retval]*/ IPCHDBCollection* *pVal )
{
    __HCP_FUNC_ENTRY( "JetBlueCOM::Database::get_Tables" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();

    __MPC_JET_CHECKHANDLE(hr,m_db,NULL);

    hr = m_Tables.GetEnumerator( pVal );

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

STDMETHODIMP JetBlueCOM::Database::AttachTable( /*[in]*/           BSTR          bstrName ,
                                                /*[in, optional]*/ VARIANT       vXMLDef  ,
                                                /*[out,retval]  */ IPCHDBTable* *pVal     )
{
    __HCP_FUNC_ENTRY( "JetBlueCOM::Database::DeleteRecord" );

    USES_CONVERSION;

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    JET_TABLECREATE              tblcrt; ::ZeroMemory( &tblcrt, sizeof(tblcrt) );
    JetBlue::TableDefinition     tbldef;
    JetBlue::Table*              table;
    LPSTR                        szName;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrName);
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();

    __MPC_JET_CHECKHANDLE(hr,m_db,NULL);

    szName = W2A( bstrName );

    if(vXMLDef.vt == VT_BSTR && vXMLDef.bstrVal)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, tbldef.Load( vXMLDef.bstrVal ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, tbldef.Generate( tblcrt      ));

        tblcrt.szTableName = szName;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_db->GetTable( NULL, table, &tblcrt ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, Refresh());
    }
    else
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_db->GetTable( szName, table ));
    }


    {
        BaseObjectWithChildren<Database,Table>::ChildIterConst itBegin;
        BaseObjectWithChildren<Database,Table>::ChildIterConst itEnd;

        m_Tables.GetChildren( itBegin, itEnd );

        for(;itBegin != itEnd; itBegin++)
        {
            CComBSTR bstr;

            __MPC_EXIT_IF_METHOD_FAILS(hr, (*itBegin)->get_Name( &bstr ));

            if(bstr == bstrName) break;
        }

        if(itBegin == itEnd)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
        }
        else
        {
            __MPC_SET_ERROR_AND_EXIT(hr, (*itBegin)->QueryInterface( IID_IPCHDBTable, (void**)pVal ));
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    (void)tbldef.Release( tblcrt );

    __HCP_FUNC_EXIT(hr);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\include\trustedscripts.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    TrustedScripts.h

Abstract:
    This file contains the declaration of the CPCHService class.

Revision History:
    Davide Massarenti   (Dmassare)  03/14/2000
        created

******************************************************************************/

#if !defined(__INCLUDED___PCH___TRUSTEDSCRIPTS_H___)
#define __INCLUDED___PCH___TRUSTEDSCRIPTS_H___

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

////////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHDispatchWrapper :
    public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatch
{
    CComQIPtr<IDispatch> m_real;

public:
DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CPCHDispatchWrapper)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPCHDispatchWrapper)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

	static HRESULT CreateInstance( /*[in]*/ IUnknown* real, /*[out]*/ IUnknown* *punk )
	{
		__HCP_FUNC_ENTRY( "CPCHDispatchWrapper::CreateInstance" );

		HRESULT                          hr;
		CComObject<CPCHDispatchWrapper>* obj = NULL;

		__MPC_EXIT_IF_METHOD_FAILS(hr, obj->CreateInstance( &obj )); obj->AddRef();

		((CPCHDispatchWrapper*)obj)->m_real = real;

		__MPC_EXIT_IF_METHOD_FAILS(hr, obj->QueryInterface( IID_IUnknown, (void**)punk ));

		hr = S_OK;


		__HCP_FUNC_CLEANUP;

		if(obj) obj->Release();

		__HCP_FUNC_EXIT(hr);
	}

	////////////////////////////////////////

	//
	// IDispatch
	//
	STDMETHOD(GetTypeInfoCount)( UINT* pctinfo )
	{
		return m_real ? m_real->GetTypeInfoCount( pctinfo ) : E_FAIL;
	}
    
	STDMETHOD(GetTypeInfo)( UINT        itinfo  ,
							LCID        lcid    ,
							ITypeInfo* *pptinfo )
	{
		return m_real ? m_real->GetTypeInfo( itinfo, lcid, pptinfo ) : E_FAIL;
	}

    
	STDMETHOD(GetIDsOfNames)( REFIID    riid      ,
							  LPOLESTR* rgszNames ,
							  UINT      cNames    ,
							  LCID      lcid      ,
							  DISPID*   rgdispid  )
	{
		return m_real ? m_real->GetIDsOfNames( riid, rgszNames, cNames, lcid, rgdispid ) : E_FAIL;
	}
    
	STDMETHOD(Invoke)( DISPID      dispidMember ,
					   REFIID      riid         ,
					   LCID        lcid         ,
					   WORD        wFlags       ,
					   DISPPARAMS* pdispparams  ,
					   VARIANT*    pvarResult   ,
					   EXCEPINFO*  pexcepinfo   ,
					   UINT*       puArgErr     )
	{
		return m_real ? m_real->Invoke( dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr ) : E_FAIL;
	}
};

////////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHScriptWrapper_ClientSideRoot :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<IPCHActiveScriptSite, &IID_IPCHActiveScriptSite, &LIBID_HelpServiceTypeLib>,
    public IActiveScript,
    public IActiveScriptParse
{
    class NamedItem
	{
    public:
		CComBSTR m_bstrName;
		DWORD    m_dwFlags;

        bool operator==( /*[in]*/ LPCOLESTR szKey ) const;
    };

    typedef std::list< NamedItem >    NamedList;
    typedef NamedList::iterator       NamedIter;
    typedef NamedList::const_iterator NamedIterConst;

	////////////////////

    class TypeLibItem
	{
    public:
		GUID  m_guidTypeLib;
		DWORD m_dwMajor;
		DWORD m_dwMinor;
		DWORD m_dwFlags;

        bool operator==( /*[in]*/ REFGUID rguidTypeLib ) const;
    };

    typedef std::list< TypeLibItem > 	TypeLibList;
    typedef TypeLibList::iterator       TypeLibIter;
    typedef TypeLibList::const_iterator TypeLibIterConst;

	////////////////////

	const CLSID*                m_pWrappedCLSID;
    NamedList                   m_lstNamed;
    TypeLibList                 m_lstTypeLib;
	SCRIPTSTATE                 m_ss;
    CComPtr<IActiveScriptSite>  m_Browser;
    CComPtr<IPCHActiveScript>   m_Script;

	////////////////////////////////////////

public:
    CPCHScriptWrapper_ClientSideRoot();
    virtual ~CPCHScriptWrapper_ClientSideRoot();

	HRESULT FinalConstructInner( /*[in]*/ const CLSID* pWrappedCLSID );
	void FinalRelease();

	////////////////////////////////////////

    // IActiveScript
    STDMETHOD(SetScriptSite )( /*[in]*/ IActiveScriptSite* pass );
    STDMETHOD(GetScriptSite )( /*[in ]*/ REFIID  riid      ,
							   /*[out]*/ void*  *ppvObject );

    STDMETHOD(SetScriptState)( /*[in ]*/ SCRIPTSTATE   ss );
    STDMETHOD(GetScriptState)( /*[out]*/ SCRIPTSTATE *pss );

    STDMETHOD(Close)();

    STDMETHOD(AddNamedItem)( /*[in]*/ LPCOLESTR pstrName ,
							 /*[in]*/ DWORD     dwFlags  );

    STDMETHOD(AddTypeLib)( /*[in]*/ REFGUID rguidTypeLib ,
						   /*[in]*/ DWORD   dwMajor      ,
						   /*[in]*/ DWORD   dwMinor      ,
						   /*[in]*/ DWORD   dwFlags      );

    STDMETHOD(GetScriptDispatch)( /*[in ]*/ LPCOLESTR   pstrItemName ,
								  /*[out]*/ IDispatch* *ppdisp       );

    STDMETHOD(GetCurrentScriptThreadID)( /*[out]*/ SCRIPTTHREADID *pstidThread );

    STDMETHOD(GetScriptThreadID)( /*[in ]*/ DWORD           dwWin32ThreadId ,
								  /*[out]*/ SCRIPTTHREADID *pstidThread     );

    STDMETHOD(GetScriptThreadState)( /*[in ]*/ SCRIPTTHREADID     stidThread ,
									 /*[out]*/ SCRIPTTHREADSTATE *pstsState  );

    STDMETHOD(InterruptScriptThread)( /*[in]*/ SCRIPTTHREADID   stidThread ,
									  /*[in]*/ const EXCEPINFO* pexcepinfo ,
									  /*[in]*/ DWORD            dwFlags    );

    STDMETHOD(Clone)( /*[out]*/ IActiveScript* *ppscript );

    // IActiveScriptParse
    STDMETHOD(InitNew)();

    STDMETHOD(AddScriptlet)( /*[in ]*/ LPCOLESTR  pstrDefaultName       ,
							 /*[in ]*/ LPCOLESTR  pstrCode              ,
							 /*[in ]*/ LPCOLESTR  pstrItemName          ,
							 /*[in ]*/ LPCOLESTR  pstrSubItemName       ,
							 /*[in ]*/ LPCOLESTR  pstrEventName         ,
							 /*[in ]*/ LPCOLESTR  pstrDelimiter         ,
							 /*[in ]*/ DWORD_PTR  dwSourceContextCookie ,
							 /*[in ]*/ ULONG      ulStartingLineNumber  ,
							 /*[in ]*/ DWORD      dwFlags               ,
							 /*[out]*/ BSTR      *pbstrName             ,
							 /*[out]*/ EXCEPINFO *pexcepinfo            );

    STDMETHOD(ParseScriptText)( /*[in ]*/ LPCOLESTR  pstrCode              ,
								/*[in ]*/ LPCOLESTR  pstrItemName          ,
								/*[in ]*/ IUnknown*  punkContext           ,
								/*[in ]*/ LPCOLESTR  pstrDelimiter         ,
								/*[in ]*/ DWORD_PTR  dwSourceContextCookie ,
								/*[in ]*/ ULONG 	 ulStartingLineNumber  ,
								/*[in ]*/ DWORD 	 dwFlags               ,
								/*[out]*/ VARIANT   *pvarResult            ,
								/*[out]*/ EXCEPINFO *pexcepinfo            );

	////////////////////////////////////////

    // IPCHActiveScriptSite
	STDMETHOD(Remote_GetLCID)( /*[out]*/ BSTR *plcid );
        
    STDMETHOD(Remote_GetItemInfo)( /*[in ]*/ BSTR        bstrName     ,
								   /*[in ]*/ DWORD       dwReturnMask ,
								   /*[out]*/ IUnknown*  *ppiunkItem   ,
								   /*[out]*/ ITypeInfo* *ppti         );
        
    STDMETHOD(Remote_GetDocVersionString)( /*[out]*/ BSTR *pbstrVersion );
        
    STDMETHOD(Remote_OnScriptTerminate)( /*[in]*/ VARIANT*   pvarResult );
        	  
    STDMETHOD(Remote_OnStateChange)( /*[in]*/ SCRIPTSTATE ssScriptState );
        	  
    STDMETHOD(Remote_OnScriptError)( /*[in]*/ IUnknown* pscripterror );
        
    STDMETHOD(Remote_OnEnterScript)();
        	  
    STDMETHOD(Remote_OnLeaveScript)();
};

////////////////////////////////////////

template < const CLSID* pWrappedCLSID > class ATL_NO_VTABLE CPCHScriptWrapper_ClientSide :
    public CPCHScriptWrapper_ClientSideRoot,
    public CComCoClass< CPCHScriptWrapper_ClientSide, pWrappedCLSID >
{
public:
DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CPCHScriptWrapper_ClientSide)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPCHScriptWrapper_ClientSide)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHActiveScriptSite)
    COM_INTERFACE_ENTRY(IActiveScript)
    COM_INTERFACE_ENTRY(IActiveScriptParse)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return FinalConstructInner( pWrappedCLSID );
	}
};

////////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHScriptWrapper_ServerSide :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<IPCHActiveScript, &IID_IPCHActiveScript, &LIBID_HelpServiceTypeLib>,
    public IActiveScriptSite
{
    CComBSTR                      m_bstrURL;
    CComPtr<IPCHActiveScriptSite> m_Browser;
    CComPtr<IActiveScript>        m_Script;
    CComPtr<IActiveScriptParse>   m_ScriptParse;

public:
    class KeyValue
	{
    public:
		MPC::wstring m_strKey;
		MPC::wstring m_strValue;

        bool operator==( /*[in]*/ LPCOLESTR szKey ) const;
    };

    typedef std::list< KeyValue >      HeaderList;
    typedef HeaderList::iterator       HeaderIter;
    typedef HeaderList::const_iterator HeaderIterConst;

	////////////////////////////////////////

BEGIN_COM_MAP(CPCHScriptWrapper_ServerSide)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHActiveScript)
    COM_INTERFACE_ENTRY(IActiveScriptSite)
END_COM_MAP()

    CPCHScriptWrapper_ServerSide();
    virtual ~CPCHScriptWrapper_ServerSide();

	HRESULT FinalConstructInner( /*[in]*/ const CLSID* pWrappedCLSID, /*[in]*/ BSTR bstrURL );
	void FinalRelease();

    // IPCHActiveScript
	STDMETHOD(Remote_SetScriptSite)( /*[in]*/ IPCHActiveScriptSite* pass );

    STDMETHOD(Remote_SetScriptState)( /*[in] */ SCRIPTSTATE   ss      );
    STDMETHOD(Remote_GetScriptState)( /*[out]*/ SCRIPTSTATE *pssState );

    STDMETHOD(Remote_Close)();

    STDMETHOD(Remote_AddNamedItem)( /*[in]*/ BSTR  bstrName ,                                                
									/*[in]*/ DWORD dwFlags  );

    STDMETHOD(Remote_AddTypeLib)( /*[in]*/ BSTR  bstrTypeLib ,
								  /*[in]*/ DWORD dwMajor     ,
								  /*[in]*/ DWORD dwMinor     ,
								  /*[in]*/ DWORD dwFlags     );

    STDMETHOD(Remote_GetScriptDispatch)( /*[in ]*/ BSTR        bstrItemName ,
										 /*[out]*/ IDispatch* *ppdisp       );

    STDMETHOD(Remote_GetCurrentScriptThreadID)( /*[out]*/ SCRIPTTHREADID *pstidThread );

    STDMETHOD(Remote_GetScriptThreadID)( /*[in ]*/ DWORD           dwWin32ThreadId ,
										 /*[out]*/ SCRIPTTHREADID *pstidThread     );

    STDMETHOD(Remote_GetScriptThreadState)( /*[in ]*/ SCRIPTTHREADID     stidThread ,
											/*[out]*/ SCRIPTTHREADSTATE *pstsState  );

    STDMETHOD(Remote_InterruptScriptThread)( /*[in]*/ SCRIPTTHREADID stidThread ,
											 /*[in]*/ DWORD          dwFlags    );

    STDMETHOD(Remote_InitNew)();

    STDMETHOD(Remote_AddScriptlet)( /*[in ]*/ BSTR		 bstrDefaultName       ,
									/*[in ]*/ BSTR		 bstrCode              ,
									/*[in ]*/ BSTR		 bstrItemName          ,
									/*[in ]*/ BSTR		 bstrSubItemName       ,
									/*[in ]*/ BSTR		 bstrEventName         ,
									/*[in ]*/ BSTR		 bstrDelimiter         ,
									/*[in ]*/ DWORD_PTR      dwSourceContextCookie ,
									/*[in ]*/ ULONG      ulStartingLineNumber  ,
									/*[in ]*/ DWORD      dwFlags               ,
									/*[out]*/ BSTR      *pbstrName             );

    STDMETHOD(Remote_ParseScriptText)( /*[in ]*/ BSTR  	   	bstrCode              ,
									   /*[in ]*/ BSTR  	   	bstrItemName          ,
                                	   /*[in ]*/ IUnknown* 	punkContext           ,
                                	   /*[in ]*/ BSTR      	bstrDelimiter         ,
                                	   /*[in ]*/ DWORD_PTR 	dwSourceContextCookie ,
                                	   /*[in ]*/ ULONG 	   	ulStartingLineNumber  ,
                                	   /*[in ]*/ DWORD 	   	dwFlags               ,
                                	   /*[out]*/ VARIANT*   pvarResult            );

	////////////////////////////////////////

    // IPCHActiveScriptSite
	STDMETHOD(GetLCID)( /*[out]*/ LCID *plcid );
        
    STDMETHOD(GetItemInfo)( /*[in]*/ LPCOLESTR pstrName, /*[in]*/ DWORD dwReturnMask, /*[out]*/ IUnknown* *ppiunkItem, /*[out]*/ ITypeInfo* *ppti );
        
    STDMETHOD(GetDocVersionString)( /*[out]*/ BSTR *pbstrVersion );
        
    STDMETHOD(OnScriptTerminate)( /*[in]*/ const VARIANT* pvarResult, /*[in]*/ const EXCEPINFO* pexcepinfo );
        	  
    STDMETHOD(OnStateChange)( /*[in]*/ SCRIPTSTATE ssScriptState );
        	  
    STDMETHOD(OnScriptError)( /*[in]*/ IActiveScriptError *pscripterror );
        
    STDMETHOD(OnEnterScript)( void );
        	  
    STDMETHOD(OnLeaveScript)( void );

	static HRESULT ProcessBody( /*[in]*/ BSTR bstrCode, /*[out]*/ CComBSTR& bstrRealCode, /*[out]*/ HeaderList& lst );
};

class CPCHScriptWrapper_Launcher :
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public MPC::Thread< CPCHScriptWrapper_Launcher, IUnknown, COINIT_APARTMENTTHREADED >
{
    MPC::CComPtrThreadNeutral<IUnknown> m_engine;
	const CLSID*                        m_pCLSID;
	CComBSTR                            m_bstrURL;
	HRESULT                             m_hr;

    //////////////////////////////////////////////////////////////////////

    HRESULT Run();
	HRESULT CreateEngine();

public:

	CPCHScriptWrapper_Launcher();
	~CPCHScriptWrapper_Launcher();

	HRESULT CreateScriptWrapper( /*[in ]*/ REFCLSID   rclsid   ,
								 /*[in ]*/ BSTR       bstrCode ,
								 /*[in ]*/ BSTR       bstrURL  ,
								 /*[out]*/ IUnknown* *ppObj    );
};

#endif // !defined(__INCLUDED___PCH___TRUSTEDSCRIPTS_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\jetblue\comwrapper\index.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Index.cpp

Abstract:
    This file contains the implementation of the JetBlueCOM::Index class.

Revision History:
    Davide Massarenti   (Dmassare)  05/20/2000
        created

******************************************************************************/

#include <stdafx.h>

#ifndef NOJETBLUECOM

////////////////////////////////////////////////////////////////////////////////

JetBlueCOM::Index::Index()
{
    m_idx = NULL; // JetBlue::Index*                      m_idx;
                  // BaseObjectWithChildren<Index,Column> m_Columns;
}

JetBlueCOM::Index::~Index()
{
    Passivate();
}

////////////////////////////////////////

HRESULT JetBlueCOM::Index::Initialize( /*[in]*/ JetBlue::Index& idx )
{
    __HCP_FUNC_ENTRY( "JetBlueCOM::Index::Initialize" );

    HRESULT hr;
    int     iCol = idx.NumOfColumns();
    int     i;

    m_idx = &idx;

    for(i=0; i<iCol; i++)
    {
        CComPtr<Column> child;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_Columns.CreateChild( this, &child ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, child->Initialize( idx.GetCol( i ) ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void JetBlueCOM::Index::Passivate()
{
    MPC::SmartLock<_ThreadModel> lock( this );

    m_idx = NULL;

    m_Columns.Passivate();
}

////////////////////////////////////////

STDMETHODIMP JetBlueCOM::Index::get_Name( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_FUNC_ENTRY( "JetBlueCOM::Index::get_Name" );

	USES_CONVERSION;

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();

    __MPC_JET_CHECKHANDLE(hr,m_idx,NULL);


    {
        const MPC::string& str = *m_idx;

        hr = MPC::GetBSTR( A2W(str.c_str()), pVal );
    }


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP JetBlueCOM::Index::get_Columns( /*[out, retval]*/ IPCHDBCollection* *pVal )
{
    __HCP_FUNC_ENTRY( "JetBlueCOM::Index::get_Columns" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();

    __MPC_JET_CHECKHANDLE(hr,m_idx,NULL);

    hr = m_Columns.GetEnumerator( pVal );

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\jetblue\comwrapper\session.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Session.cpp

Abstract:
    This file contains the implementation of the JetBlueCOM::Session class.

Revision History:
    Davide Massarenti   (Dmassare)  05/20/2000
        created

******************************************************************************/

#include <stdafx.h>

#ifndef NOJETBLUECOM

////////////////////////////////////////////////////////////////////////////////

JetBlueCOM::Session::Session()
{
    // JetBlue::SessionHandle                   m_sess;
    // BaseObjectWithChildren<Session,Database> m_DBs;
}

JetBlueCOM::Session::~Session()
{
    Passivate();
}

HRESULT JetBlueCOM::Session::Refresh()
{
    __HCP_FUNC_ENTRY( "JetBlueCOM::Session::Refresh" );

    HRESULT hr;
    int     iDb = m_sess->NumOfDatabases();
    int     i;

    m_DBs.Passivate();

    for(i=0; i<iDb; i++)
    {
        CComPtr<Database>  child;
        JetBlue::Database* db = m_sess->GetDB( i );

        __MPC_EXIT_IF_METHOD_FAILS(hr, db->Open( /*fReadOnly*/false, /*fCreate*/false, /*fRepair*/false ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_DBs.CreateChild( this, &child ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, child->Initialize( *db ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

HRESULT JetBlueCOM::Session::FinalConstruct()
{
    __HCP_FUNC_ENTRY( "JetBlueCOM::Session::FinalConstruct" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, JetBlue::SessionPool::s_GLOBAL->GetSession( m_sess ));


    hr = Refresh();


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void JetBlueCOM::Session::Passivate()
{
    MPC::SmartLock<_ThreadModel> lock( this );

    m_DBs .Passivate();
    m_sess.Release  ();
}

////////////////////////////////////////

STDMETHODIMP JetBlueCOM::Session::get_Databases( /*[out, retval]*/ IPCHDBCollection* *pVal )
{
    __HCP_FUNC_ENTRY( "JetBlueCOM::Session::get_Databases" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();

    hr = m_DBs.GetEnumerator( pVal );

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

STDMETHODIMP JetBlueCOM::Session::AttachDatabase( /*[in]*/           BSTR             bstrName ,
                                                  /*[in, optional]*/ VARIANT          vCreate  ,
                                                  /*[out,retval]*/   IPCHDBDatabase* *pVal     )
{
    __HCP_FUNC_ENTRY( "JetBlueCOM::Session::AttachDatabase" );

    USES_CONVERSION;

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    JetBlue::Database*           db;
    LPSTR                        szName;
    bool                         fCreate;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrName);
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


    szName  = W2A( bstrName );
    fCreate = (vCreate.vt == VT_BOOL && vCreate.boolVal == VARIANT_TRUE);


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_sess->GetDatabase( szName, db, /*fReadOnly*/false, /*fCreate*/fCreate, /*fRepair*/false ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, Refresh());

    {
        BaseObjectWithChildren<Session,Database>::ChildIterConst itBegin;
        BaseObjectWithChildren<Session,Database>::ChildIterConst itEnd;

        m_DBs.GetChildren( itBegin, itEnd );

        for(;itBegin != itEnd; itBegin++)
        {
            CComBSTR bstr;

            __MPC_EXIT_IF_METHOD_FAILS(hr, (*itBegin)->get_Name( &bstr ));

            if(bstr == bstrName) break;
        }

        if(itBegin == itEnd)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
        }
        else
        {
            __MPC_SET_ERROR_AND_EXIT(hr, (*itBegin)->QueryInterface( IID_IPCHDBDatabase, (void**)pVal ));
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

STDMETHODIMP JetBlueCOM::Session::BeginTransaction()
{
    __HCP_FUNC_ENTRY( "JetBlueCOM::Session::BeginTransaction" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

    hr = m_sess->BeginTransaction();

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP JetBlueCOM::Session::CommitTransaction()
{
    __HCP_FUNC_ENTRY( "JetBlueCOM::Session::CommitTransaction" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

    hr = m_sess->CommitTransaction();

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP JetBlueCOM::Session::RollbackTransaction()
{
    __HCP_FUNC_ENTRY( "JetBlueCOM::Session::RollbackTransaction" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

    hr = m_sess->RollbackTransaction();

    __HCP_FUNC_EXIT(hr);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\jetblue\comwrapper\stdafx.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    StdAfx.h

Abstract:
    Precompiled header.

Revision History:
    Davide Massarenti   (Dmassare)  03/16/2000
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__412B7974_2F00_11D3_9A30_00C04F72D6C5__INCLUDED_)
#define AFX_STDAFX_H__412B7974_2F00_11D3_9A30_00C04F72D6C5__INCLUDED_

#include <module.h>

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>


//
// For debug trace
//
#include <HCP_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_COM.h>


#include <JetBlueLib.h>


//
// Localized strings functions.
//
#include <locres.h>

//
// Localized strings IDs.
//
#include <HCAppRes.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__412B7974_2F00_11D3_9A30_00C04F72D6C5__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\jetblue\comwrapper\table.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Table.cpp

Abstract:
    This file contains the implementation of the JetBlueCOM::Table class.

Revision History:
    Davide Massarenti   (Dmassare)  05/20/2000
        created

******************************************************************************/

#include <stdafx.h>

#ifndef NOJETBLUECOM

////////////////////////////////////////////////////////////////////////////////

JetBlueCOM::Table::Table()
{
    m_tbl = NULL; // JetBlue::Table*                      m_tbl;
                  // BaseObjectWithChildren<Table,Column> m_Columns;
                  // BaseObjectWithChildren<Table,Index > m_Indexes;
}

JetBlueCOM::Table::~Table()
{
    Passivate();
}

////////////////////////////////////////

HRESULT JetBlueCOM::Table::Initialize( /*[in]*/ JetBlue::Table& tbl )
{
    __HCP_FUNC_ENTRY( "JetBlueCOM::Table::Initialize" );

    HRESULT hr;
    int     iCol = tbl.NumOfColumns();
    int     iIdx = tbl.NumOfIndexes();
    int     i;

    m_tbl = &tbl;

    for(i=0; i<iCol; i++)
    {
        CComPtr<Column> child;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_Columns.CreateChild( this, &child ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, child->Initialize( tbl.GetCol( i ) ));
    }

    for(i=0; i<iIdx; i++)
    {
        CComPtr<Index> child;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_Indexes.CreateChild( this, &child ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, child->Initialize( tbl.GetIdx( i ) ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void JetBlueCOM::Table::Passivate()
{
    MPC::SmartLock<_ThreadModel> lock( this );

    m_tbl = NULL;

    m_Columns.Passivate();
    m_Indexes.Passivate();
}

////////////////////////////////////////

STDMETHODIMP JetBlueCOM::Table::get_Name( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_FUNC_ENTRY( "JetBlueCOM::Table::get_Name" );

	USES_CONVERSION;

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();

    __MPC_JET_CHECKHANDLE(hr,m_tbl,NULL);


    {
        const MPC::string& str = *m_tbl;

        hr = MPC::GetBSTR( A2W(str.c_str()), pVal );
    }


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP JetBlueCOM::Table::get_Columns( /*[out, retval]*/ IPCHDBCollection* *pVal )
{
    __HCP_FUNC_ENTRY( "JetBlueCOM::Table::get_Columns" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();

    __MPC_JET_CHECKHANDLE(hr,m_tbl,NULL);

    hr = m_Columns.GetEnumerator( pVal );

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP JetBlueCOM::Table::get_Indexes( /*[out, retval]*/ IPCHDBCollection* *pVal )
{
    __HCP_FUNC_ENTRY( "JetBlueCOM::Table::get_Indexes" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();

    __MPC_JET_CHECKHANDLE(hr,m_tbl,NULL);

    hr = m_Indexes.GetEnumerator( pVal );

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

STDMETHODIMP JetBlueCOM::Table::SelectIndex( /*[in]*/ BSTR bstrIndex ,
                                             /*[in]*/ long grbit     )
{
    __HCP_FUNC_ENTRY( "JetBlueCOM::Table::SelectIndex" );

    USES_CONVERSION;

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_JET_CHECKHANDLE(hr,m_tbl,NULL);

    hr = m_tbl->SelectIndex( (bstrIndex && bstrIndex[0]) ? W2A(bstrIndex) : NULL, grbit );

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP JetBlueCOM::Table::SetIndexRange( /*[in]*/ long grbit )
{
    __HCP_FUNC_ENTRY( "JetBlueCOM::Table::SetIndexRange" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_JET_CHECKHANDLE(hr,m_tbl,NULL);

    hr = m_tbl->SetIndexRange( grbit );

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP JetBlueCOM::Table::PrepareInsert()
{
    __HCP_FUNC_ENTRY( "JetBlueCOM::Table::PrepareInsert" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_JET_CHECKHANDLE(hr,m_tbl,NULL);

    hr = m_tbl->PrepareInsert();

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP JetBlueCOM::Table::PrepareUpdate()
{
    __HCP_FUNC_ENTRY( "JetBlueCOM::Table::PrepareUpdate" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_JET_CHECKHANDLE(hr,m_tbl,NULL);

    hr = m_tbl->PrepareUpdate();

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP JetBlueCOM::Table::Move( /*[in]*/          long          grbit   ,
                                      /*[in]*/          long          cRow    ,
                                      /*[out, retval]*/ VARIANT_BOOL *pfValid )
{
    __HCP_FUNC_ENTRY( "JetBlueCOM::Table::Move" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    bool                         fFound;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pfValid,VARIANT_FALSE);
    __MPC_PARAMCHECK_END();

    __MPC_JET_CHECKHANDLE(hr,m_tbl,NULL);


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_tbl->Move( grbit, cRow, &fFound ));

    *pfValid = fFound ? VARIANT_TRUE : VARIANT_FALSE;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP JetBlueCOM::Table::Seek( /*[in]*/          long          grbit   ,
                                      /*[in]*/          VARIANT       vKey    ,
                                      /*[out, retval]*/ VARIANT_BOOL *pfValid )
{
    __HCP_FUNC_ENTRY( "JetBlueCOM::Table::Seek" );

    HRESULT                      hr;
    CComVariant*                 pvKeys = NULL;
    MPC::SmartLock<_ThreadModel> lock( this );
    bool                         fFound;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pfValid,VARIANT_FALSE);
    __MPC_PARAMCHECK_END();

    __MPC_JET_CHECKHANDLE(hr,m_tbl,NULL);


    if(vKey.vt == VT_SAFEARRAY)
    {
        long lLBound;
        long lUBound;
        long lSize;

        //
        // Verify that the SafeArray is the proper shape.
        //
        if(::SafeArrayGetDim( vKey.parray ) != 1)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, E_INVALIDARG);
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, ::SafeArrayGetLBound( vKey.parray, 1, &lLBound ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, ::SafeArrayGetUBound( vKey.parray, 1, &lUBound ));

        lSize = lUBound - lLBound + 1;
        __MPC_EXIT_IF_ALLOC_FAILS(hr, pvKeys, new CComVariant[lSize]);

        for(long i=lLBound; i<=lUBound; i++)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, ::SafeArrayGetElement( vKey.parray, &i, &pvKeys[i-lLBound] ));
        }

        hr = m_tbl->Seek( grbit, pvKeys, lSize, &fFound );
    }
    else
    {
        hr = m_tbl->Seek( grbit, &vKey, 1, &fFound );
    }

    *pfValid = fFound ? VARIANT_TRUE : VARIANT_FALSE;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(pvKeys) delete [] pvKeys;

    __HCP_FUNC_EXIT(hr);
}


STDMETHODIMP JetBlueCOM::Table::UpdateRecord()
{
    __HCP_FUNC_ENTRY( "JetBlueCOM::Table::SelectIndex" );

    USES_CONVERSION;

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_JET_CHECKHANDLE(hr,m_tbl,NULL);

    hr = m_tbl->UpdateRecord( /*fMove*/true );

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP JetBlueCOM::Table::DeleteRecord()
{
    __HCP_FUNC_ENTRY( "JetBlueCOM::Table::DeleteRecord" );

    USES_CONVERSION;

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_JET_CHECKHANDLE(hr,m_tbl,NULL);

    hr = m_tbl->DeleteRecord();

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\jetblue\lowlevel\column.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Column.cpp

Abstract:
    This file contains the implementation of the JetBlue::Column class.

Revision History:
    Davide Massarenti   (Dmassare)  05/17/2000
        created

******************************************************************************/

#include <stdafx.h>

////////////////////////////////////////////////////////////////////////////////

JetBlue::Column::Column()
{
    m_sesid   = JET_sesidNil;    // JET_SESID     m_sesid;
    m_tableid = JET_tableidNil;  // JET_TABLEID   m_tableid;
                                 // MPC::string   m_strName;
                                 // JET_COLUMNDEF m_coldef;

    ::ZeroMemory( &m_coldef, sizeof(m_coldef) ); m_coldef.cbStruct = sizeof(m_coldef);
}

JetBlue::Column::~Column()
{
}

////////////////////////////////////////

HRESULT JetBlue::Column::Get( /*[out]*/ CComVariant& vValue )
{
    __HCP_FUNC_ENTRY( "JetBlue::Column::Get" );

    HRESULT       hr;
    JET_ERR       err;
    JET_RETINFO   ret;
    void*         pvData;
    unsigned long cbData;
    unsigned long cbActual;
    BYTE          rgBuf[2048+2];
    BYTE*         pBufLarge = NULL;


    vValue.Clear();


    switch(m_coldef.coltyp)
    {
    case JET_coltypBit         : pvData = &rgBuf[0]     ; cbData = sizeof( rgBuf[0]      )    ; break;
    case JET_coltypUnsignedByte: pvData = &vValue.bVal  ; cbData = sizeof( vValue.bVal   )    ; break;
    case JET_coltypShort       : pvData = &vValue.iVal  ; cbData = sizeof( vValue.iVal   )    ; break;
    case JET_coltypLong        : pvData = &vValue.lVal  ; cbData = sizeof( vValue.lVal   )    ; break;
    case JET_coltypCurrency    : pvData = &vValue.cyVal ; cbData = sizeof( vValue.cyVal  )    ; break;
    case JET_coltypIEEESingle  : pvData = &vValue.fltVal; cbData = sizeof( vValue.fltVal )    ; break;
    case JET_coltypIEEEDouble  : pvData = &vValue.dblVal; cbData = sizeof( vValue.dblVal )    ; break;
    case JET_coltypDateTime    : pvData = &vValue.date  ; cbData = sizeof( vValue.date   )    ; break;
    /////////////////////////////////////////////////////////////////////////////////////////////
    case JET_coltypText        :
    case JET_coltypLongText    : pvData =  rgBuf        ; cbData = sizeof( rgBuf         ) - 2; break;

    default:
        __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }

	__MPC_JET__MTSAFE(m_sesid, err, ::JetRetrieveColumn( m_sesid, m_tableid, m_coldef.columnid, pvData, cbData, &cbActual, JET_bitRetrieveCopy, NULL ));

    //
    // No value, bail out.
    //
    if(err == JET_wrnColumnNull)
    {
        vValue.vt = VT_NULL;

        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }

	__MPC_EXIT_IF_JET_FAILS(hr, err);

    if(cbActual > cbData)
    {
        __MPC_EXIT_IF_ALLOC_FAILS(hr, pBufLarge, new BYTE[cbActual+2]);

        pvData = pBufLarge;
        cbData = cbActual;

        __MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetRetrieveColumn( m_sesid, m_tableid, m_coldef.columnid, pvData, cbData, &cbActual, JET_bitRetrieveCopy, NULL ));
    }

    switch(m_coldef.coltyp)
    {
    case JET_coltypBit         : vValue.vt = VT_BOOL; vValue.boolVal = rgBuf[0] ? VARIANT_TRUE : VARIANT_FALSE; break;
    case JET_coltypUnsignedByte: vValue.vt = VT_UI1;                                                            break;
    case JET_coltypShort       : vValue.vt = VT_I2;                                                             break;
    case JET_coltypLong        : vValue.vt = VT_I4;                                                             break;
    case JET_coltypCurrency    : vValue.vt = VT_CY;                                                             break;
    case JET_coltypIEEESingle  : vValue.vt = VT_R4;                                                             break;
    case JET_coltypIEEEDouble  : vValue.vt = VT_R8;                                                             break;
    case JET_coltypDateTime    : vValue.vt = VT_DATE;                                                           break;

    case JET_coltypText    :
    case JET_coltypLongText:
        // Put the trailing zeros, just in case...
        ((BYTE*)pvData + cbActual)[0] = 0;
        ((BYTE*)pvData + cbActual)[1] = 0;

        if(m_coldef.cp == 1200) vValue = (LPWSTR)pvData;
        else                    vValue = (LPSTR )pvData;
        break;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(pBufLarge) delete [] pBufLarge;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::Column::Get( /*[out]*/ MPC::CComHGLOBAL& hgValue )
{
    __HCP_FUNC_ENTRY( "JetBlue::Column::Get" );

    HRESULT       hr;
    void*         pvData;
    unsigned long cbData;
    unsigned long cbActual;
    BYTE          rgBuf[256];
    BYTE*         pBufLarge = NULL;


    switch(m_coldef.coltyp)
    {
    case JET_coltypBinary    : break;
    case JET_coltypLongBinary: break;

    default: __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }

    pvData = rgBuf;
    cbData = sizeof(rgBuf);

    __MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetRetrieveColumn( m_sesid, m_tableid, m_coldef.columnid, pvData, cbData, &cbActual, JET_bitRetrieveCopy, NULL ));
    if(cbActual > cbData)
    {
        __MPC_EXIT_IF_ALLOC_FAILS(hr, pBufLarge, new BYTE[cbActual]);

        pvData = pBufLarge;
        cbData = cbActual;

        __MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetRetrieveColumn( m_sesid, m_tableid, m_coldef.columnid, pvData, cbData, &cbActual, JET_bitRetrieveCopy, NULL ));
    }

	__MPC_EXIT_IF_METHOD_FAILS(hr, hgValue.New( GMEM_FIXED, cbActual ));

	::CopyMemory( hgValue.Get(), pvData, cbActual );


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(pBufLarge) delete [] pBufLarge;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::Column::Get( /*[out]*/ MPC::wstring& strValue )
{
    __HCP_FUNC_ENTRY( "JetBlue::Column::Get" );

    HRESULT     hr;
    CComVariant vValue;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Get( vValue ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, vValue.ChangeType( VT_BSTR ));

    strValue = SAFEBSTR( vValue.bstrVal );
    hr       = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::Column::Get( /*[out]*/ MPC::string& strValue )
{
    __HCP_FUNC_ENTRY( "JetBlue::Column::Get" );

    USES_CONVERSION;

    HRESULT     hr;
    CComVariant vValue;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Get( vValue ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, vValue.ChangeType( VT_BSTR ));

    strValue = W2A( SAFEBSTR( vValue.bstrVal ) );
    hr       = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::Column::Get( /*[out]*/ long& lValue )
{
    __HCP_FUNC_ENTRY( "JetBlue::Column::Get" );

    HRESULT     hr;
    CComVariant vValue;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Get( vValue ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, vValue.ChangeType( VT_I4 ));

    lValue = vValue.lVal;
    hr     = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::Column::Get( /*[out]*/ short& sValue )
{
    __HCP_FUNC_ENTRY( "JetBlue::Column::Get" );

    HRESULT     hr;
    CComVariant vValue;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Get( vValue ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, vValue.ChangeType( VT_I2 ));

    sValue = vValue.iVal;
    hr     = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::Column::Get( /*[out]*/ BYTE& bValue )
{
    __HCP_FUNC_ENTRY( "JetBlue::Column::Get" );

    HRESULT     hr;
    CComVariant vValue;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Get( vValue ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, vValue.ChangeType( VT_UI1 ));

    bValue = vValue.bVal;
    hr     = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

HRESULT JetBlue::Column::Put( /*[in]*/ const VARIANT& vValue  ,
                              /*[in]*/ int            iIdxPos )
{
    __HCP_FUNC_ENTRY( "JetBlue::Column::Put" );

    USES_CONVERSION;

    HRESULT        hr;
    const void*    pvData;
    unsigned long  cbData;
    BYTE           fBool;
    VARTYPE        vt;
    CComVariant    vTmp;
    const VARIANT* pvPtr;
    JET_GRBIT      grbit = 0;


    if(vValue.vt == VT_NULL)
    {
        pvData = NULL;
        cbData = 0;
    }
    else
    {
        switch(m_coldef.coltyp)
        {
        case JET_coltypBit         : vt = VT_BOOL;                                 break;
        case JET_coltypUnsignedByte: vt = VT_UI1 ;                                 break;
        case JET_coltypShort       : vt = VT_I2  ;                                 break;
        case JET_coltypLong        : vt = VT_I4  ;                                 break;
        case JET_coltypCurrency    : vt = VT_CY  ;                                 break;
        case JET_coltypIEEESingle  : vt = VT_R4  ;                                 break;
        case JET_coltypIEEEDouble  : vt = VT_R8  ;                                 break;
        case JET_coltypDateTime    : vt = VT_DATE;                                 break;
        case JET_coltypText        : vt = VT_BSTR;                                 break;
        case JET_coltypLongText    : vt = VT_BSTR;                                 break;
        default                    : __MPC_EXIT_IF_METHOD_FAILS(hr, E_INVALIDARG); break;
        }

        if(vt != vValue.vt)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, vTmp.ChangeType( vt, &vValue ));

            pvPtr = &vTmp;
        }
        else
        {
            pvPtr = &vValue;
        }

		if(vt == VT_BOOL)
		{
			fBool = pvPtr->boolVal == VARIANT_FALSE ? 0 : 1;
		}

        switch(m_coldef.coltyp)
        {
        case JET_coltypBit         : pvData =               &fBool             ; cbData = sizeof( fBool          )    ; break;
        case JET_coltypUnsignedByte: pvData =               &pvPtr->bVal       ; cbData = sizeof( pvPtr->bVal    )    ; break;
        case JET_coltypShort       : pvData =               &pvPtr->iVal       ; cbData = sizeof( pvPtr->iVal    )    ; break;
        case JET_coltypLong        : pvData =               &pvPtr->lVal       ; cbData = sizeof( pvPtr->lVal    )    ; break;
        case JET_coltypCurrency    : pvData =               &pvPtr->cyVal      ; cbData = sizeof( pvPtr->cyVal   )    ; break;
        case JET_coltypIEEESingle  : pvData =               &pvPtr->fltVal     ; cbData = sizeof( pvPtr->fltVal  )    ; break;
        case JET_coltypIEEEDouble  : pvData =               &pvPtr->dblVal     ; cbData = sizeof( pvPtr->dblVal  )    ; break;
        case JET_coltypDateTime    : pvData =               &pvPtr->date       ; cbData = sizeof( pvPtr->date    )    ; break;
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        case JET_coltypText    :
        case JET_coltypLongText:
            if(m_coldef.cp == 1200) { pvData =      SAFEBSTR( pvPtr->bstrVal )  ; cbData = wcslen( (LPWSTR)pvData ) * 2; }
            else                    { pvData = W2A( SAFEBSTR( pvPtr->bstrVal ) ); cbData = strlen( (LPSTR )pvData )    ; }
            break;
        }

        if(cbData == 0) grbit = JET_bitSetZeroLength;
    }

	{
		JET_ERR err;

		if(iIdxPos == -1)
		{
			__MPC_JET__MTSAFE(m_sesid, err, ::JetSetColumn( m_sesid, m_tableid, m_coldef.columnid, pvData, cbData, grbit, NULL ));

			//
			// Special case: Jet returns a warning, we want to return an error.
			//
			if(err == JET_wrnColumnMaxTruncated)
			{
				__MPC_SET_ERROR_AND_EXIT(hr, HRESULT_BASE_JET | (err & 0xFFFF));
			}
		}
		else
		{
			__MPC_JET__MTSAFE(m_sesid, err, ::JetMakeKey( m_sesid, m_tableid, pvData, cbData, iIdxPos > 0 ? 0 : JET_bitNewKey ));
		}

		__MPC_EXIT_IF_JET_FAILS(hr, err);
	}
	
    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::Column::Put( /*[out]*/ const MPC::CComHGLOBAL& hgValue )
{
    __HCP_FUNC_ENTRY( "JetBlue::Column::Put" );

    HRESULT       hr;
    LPVOID        pvData;
    unsigned long cbData;
    unsigned long cbActual;
    BYTE          rgBuf[256];
    BYTE*         pBufLarge = NULL;


	pvData = hgValue.Lock();
	cbData = hgValue.Size();


    switch(m_coldef.coltyp)
    {
    case JET_coltypBinary    : break;
    case JET_coltypLongBinary: break;

    default: __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }

    __MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetSetColumn( m_sesid, m_tableid, m_coldef.columnid, pvData, cbData, 0, NULL ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

	hgValue.Unlock();

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::Column::Put( /*[out]*/ const MPC::wstring& strValue )
{
    return Put( strValue.c_str() );
}

HRESULT JetBlue::Column::Put( /*[out]*/ const MPC::string& strValue )
{
    return Put( strValue.c_str() );
}

HRESULT JetBlue::Column::Put( /*[out]*/ LPCWSTR szValue )
{
    return Put( CComVariant( szValue ) );
}

HRESULT JetBlue::Column::Put( /*[out]*/ long lValue )
{
    return Put( CComVariant( lValue ) );
}

HRESULT JetBlue::Column::Put( /*[out]*/ LPCSTR szValue )
{
    return Put( CComVariant( szValue ) );
}

HRESULT JetBlue::Column::Put( /*[out]*/ short sValue )
{
    return Put( CComVariant( sValue ) );
}

HRESULT JetBlue::Column::Put( /*[out]*/ BYTE bValue )
{
    return Put( CComVariant( bValue ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\jetblue\lowlevel\config.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Config.cpp

Abstract:
    This file contains the implementation of the JetBlue::*Definition classes.

Revision History:
    Davide Massarenti   (Dmassare)  05/17/2000
        created

******************************************************************************/

#include <stdafx.h>

/////////////////////////////////////////////////////////////////////////////

CFG_BEGIN_FIELDS_MAP(JetBlue::ColumnDefinition)
    CFG_ATTRIBUTE( L"TYPE"    , DWORD , m_dwColTyp   ),
    CFG_ATTRIBUTE( L"GRBITS"  , DWORD , m_dwGRBits   ),
    CFG_ATTRIBUTE( L"CODEPAGE", DWORD , m_dwCodePage ),
    CFG_ATTRIBUTE( L"MAX"     , DWORD , m_dwMax      ),
	CFG_VALUE    (              string, m_strName    ),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(JetBlue::ColumnDefinition)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(JetBlue::ColumnDefinition,L"COLUMN")

DEFINE_CONFIG_METHODS__NOCHILD(JetBlue::ColumnDefinition)

////////////////////

CFG_BEGIN_FIELDS_MAP(JetBlue::IndexDefinition)
    CFG_ATTRIBUTE( L"NAME"    , string, m_strName   ),
    CFG_ATTRIBUTE( L"GRBITS"  , DWORD , m_dwGRBits  ),
    CFG_ATTRIBUTE( L"DENSITY" , DWORD , m_dwDensity ),
	CFG_VALUE    (              string, m_strCols   ),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(JetBlue::IndexDefinition)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(JetBlue::IndexDefinition,L"INDEX")

DEFINE_CONFIG_METHODS__NOCHILD(JetBlue::IndexDefinition)

////////////////////

CFG_BEGIN_FIELDS_MAP(JetBlue::TableDefinition)
    CFG_ATTRIBUTE( L"NAME"   , string, m_strName   ),
    CFG_ATTRIBUTE( L"PAGES"  , DWORD , m_dwPages   ),
    CFG_ATTRIBUTE( L"DENSITY", DWORD , m_dwDensity ),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(JetBlue::TableDefinition)
    CFG_CHILD(JetBlue::ColumnDefinition)
    CFG_CHILD(JetBlue::IndexDefinition)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(JetBlue::TableDefinition,L"TABLE")


DEFINE_CONFIG_METHODS_CREATEINSTANCE_SECTION(JetBlue::TableDefinition,tag,defSubType)
    if(tag == _cfg_table_tags[0])
    {
        defSubType = &(*(m_lstColumns.insert( m_lstColumns.end() )));
        return S_OK;
    }
    else if(tag == _cfg_table_tags[1])
    {
        defSubType = &(*(m_lstIndexes.insert( m_lstIndexes.end() )));
        return S_OK;
    }
DEFINE_CONFIG_METHODS_SAVENODE_SECTION(JetBlue::TableDefinition,xdn)
    if(SUCCEEDED(hr = MPC::Config::SaveList( m_lstColumns, xdn )))
    {
        hr = MPC::Config::SaveList( m_lstIndexes, xdn );
    }
DEFINE_CONFIG_METHODS_END(JetBlue::TableDefinition)

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

JetBlue::ColumnDefinition::ColumnDefinition()
{
                                       // MPC::string m_strName;
    m_dwColTyp   = JET_coltypLongText; // DWORD       m_dwColTyp;
    m_dwGRBits   = 0;                  // DWORD       m_dwGRBits;
    m_dwCodePage = 1200;               // DWORD       m_dwCodePage;
    m_dwMax      = 0;                  // DWORD       m_dwMax;
                                       // CComVariant m_vDefault;
}

HRESULT JetBlue::ColumnDefinition::Parse( /*[in] */ Column& col )
{
    __HCP_FUNC_ENTRY( "JetBlue::ColumnDefinition::Parse" );

    HRESULT hr;

    m_strName    = col.m_strName;
    m_dwColTyp   = col.m_coldef.coltyp;
    m_dwCodePage = col.m_coldef.cp;
    m_dwMax      = col.m_coldef.cbMax;
    m_dwGRBits   = col.m_coldef.grbit;

    hr = S_OK;


    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::ColumnDefinition::Generate( /*[out]*/ JET_COLUMNCREATE& col )
{
    __HCP_FUNC_ENTRY( "JetBlue::ColumnDefinition::Generate" );

    HRESULT hr;

    ::ZeroMemory( &col, sizeof(col) );

    col.cbStruct     = sizeof(JET_COLUMNCREATE);
    col.szColumnName = _strdup( m_strName.c_str() );
    col.coltyp       = m_dwColTyp;
    col.cbMax        = m_dwMax;
    col.grbit        = m_dwGRBits;
    col.pvDefault    = NULL;
    col.cbDefault    = 0;
    col.cp           = m_dwCodePage;
    col.columnid     = 0;
    col.err          = JET_errSuccess;

    if(col.szColumnName == NULL)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_OUTOFMEMORY);
    }


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::ColumnDefinition::Release( /*[in]*/ JET_COLUMNCREATE& col )
{
    __HCP_FUNC_ENTRY( "JetBlue::ColumnDefinition::Release" );

    HRESULT hr;

    if(col.szColumnName)
    {
        free( col.szColumnName );

        col.szColumnName = NULL;
    }

    hr = S_OK;

    __HCP_FUNC_EXIT(hr);
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

JetBlue::IndexDefinition::IndexDefinition()
{
                       // MPC::string m_strName;
                       // MPC::string m_strCols;
    m_dwGRBits  = 0;   // DWORD       m_dwGRBits;
    m_dwDensity = 100; // DWORD       m_dwDensity;
}

HRESULT JetBlue::IndexDefinition::Parse( /*[in] */ Index& idx )
{
    __HCP_FUNC_ENTRY( "JetBlue::IndexDefinition::Parse" );

    HRESULT hr;
    int     iElem;
    int     i;

    m_strName    = idx.m_strName;
    m_strCols.erase();
    m_dwGRBits  = idx.m_grbitIndex;
    m_dwDensity = 100; // ??

    iElem = idx.NumOfColumns();

    for(i=0; i<iElem; i++)
    {
        Column& col = idx.GetCol( i );

        if(i) m_strCols += ' ';

        m_strCols += (col.m_coldef.grbit & JET_bitKeyDescending) ? "-" : "+";

        m_strCols += col.m_strName;
    }

    hr = S_OK;


    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::IndexDefinition::Generate( /*[out]*/ JET_INDEXCREATE& idx )
{
    __HCP_FUNC_ENTRY( "JetBlue::IndexDefinition::Generate" );

    HRESULT                  hr;
    Index                    obj;
    std::vector<MPC::string> vec;
    int                      iElem;
    int                      i;


    ::ZeroMemory( &idx, sizeof(idx) );

    idx.cbStruct            = sizeof(JET_INDEXCREATE);
    idx.szIndexName         = _strdup( m_strName.c_str() );
    idx.szKey               = NULL;
    idx.cbKey               = 0;
    idx.grbit               = m_dwGRBits;
    idx.ulDensity           = m_dwDensity;

    idx.pidxunicode         = NULL;

    idx.cbVarSegMac         = 0;
    idx.rgconditionalcolumn = NULL;
    idx.cConditionalColumn  = 0;
    idx.err                 = JET_errSuccess;


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SplitAtDelimiter( vec, m_strCols.c_str(), " ", true, true ));

    iElem = vec.size();

    obj.m_vecColumns.resize( iElem );

    for(i=0; i<iElem; i++)
    {
        Column&   col   = obj.m_vecColumns[i];
        LPCSTR    szCol = vec[i].c_str();
        JET_GRBIT grbit = JET_bitKeyAscending;

        switch(szCol[0])
        {
        case '-': grbit = JET_bitKeyDescending;
        case '+': szCol++;
        }

        col.m_strName      = szCol;
        col.m_coldef.grbit = grbit;
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, obj.GenerateKey( idx.szKey, idx.cbKey ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::IndexDefinition::Release( /*[in]*/ JET_INDEXCREATE& idx )
{
    __HCP_FUNC_ENTRY( "JetBlue::IndexDefinition::Release" );

    HRESULT hr;

    if(idx.szIndexName)
    {
        free( idx.szIndexName );

        idx.szIndexName = NULL;
    }

    if(idx.szKey)
    {
        delete [] idx.szKey;

        idx.szKey = NULL;
        idx.cbKey = 0;
    }

    hr = S_OK;


    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

JetBlue::TableDefinition::TableDefinition()
{
                      // MPC::string  m_strName;
    m_dwPages   = 10; // DWORD        m_dwPages;
    m_dwDensity = 80; // DWORD        m_dwDensity;
                      // ColumnList   m_lstColumns;
                      // IndexList    m_lstIndexes;
}

////////////////////////////////////////

HRESULT JetBlue::TableDefinition::Load( /*[in]*/ LPCWSTR szFile )
{
    __HCP_FUNC_ENTRY( "JetBlue::TableDefinition::Load" );

    HRESULT hr;


    m_strName.erase();
    m_dwPages   = 10;
    m_dwDensity = 80;
    m_lstColumns.clear();
    m_lstIndexes.clear();

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::Config::LoadFile( this, szFile ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT JetBlue::TableDefinition::Save( /*[in]*/ LPCWSTR szFile )
{
    __HCP_FUNC_ENTRY( "JetBlue::TableDefinition::Save" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::Config::SaveFile( this, szFile ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////

HRESULT JetBlue::TableDefinition::Parse( /*[in] */ Table& tbl )
{
    __HCP_FUNC_ENTRY( "JetBlue::TableDefinition::Parse" );

    HRESULT hr;
    int     i;
    int     iNum;

    m_strName   = tbl.m_strName;
    m_dwPages   = 0;  // ??
    m_dwDensity = 80; // ??
    m_lstColumns.clear();
    m_lstIndexes.clear();

    for(iNum=tbl.NumOfColumns(),i=0; i<iNum; i++)
    {
        ColDefIter it = m_lstColumns.insert( m_lstColumns.end() );

        __MPC_EXIT_IF_METHOD_FAILS(hr, it->Parse( tbl.GetCol( i ) ));
    }

    for(iNum=tbl.NumOfIndexes(),i=0; i<iNum; i++)
    {
        IdxDefIter it = m_lstIndexes.insert( m_lstIndexes.end() );

        __MPC_EXIT_IF_METHOD_FAILS(hr, it->Parse( tbl.GetIdx( i ) ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::TableDefinition::Generate( /*[out]*/ JET_TABLECREATE& tbl )
{
    __HCP_FUNC_ENTRY( "JetBlue::TableDefinition::Generate" );

    HRESULT    hr;
    ColDefIter itCol;
    IdxDefIter itIdx;
    int        i;


    ::ZeroMemory( &tbl, sizeof(tbl) );

    tbl.cbStruct            = sizeof(JET_TABLECREATE);
    tbl.szTableName         = _strdup( m_strName.c_str() );
    tbl.szTemplateTableName = NULL;
    tbl.ulPages             = m_dwPages;
    tbl.ulDensity           = m_dwDensity;
    tbl.cColumns            = m_lstColumns.size();
    tbl.rgcolumncreate      = new JET_COLUMNCREATE[tbl.cColumns];
    tbl.cIndexes            = m_lstIndexes.size();
    tbl.rgindexcreate       = new JET_INDEXCREATE[tbl.cIndexes];
    tbl.grbit               = 0;
    tbl.tableid             = JET_tableidNil;
    tbl.cCreated            = 0;

    if(tbl.rgcolumncreate) ::ZeroMemory( tbl.rgcolumncreate, sizeof(JET_COLUMNCREATE) * tbl.cColumns );
    if(tbl.rgindexcreate ) ::ZeroMemory( tbl.rgindexcreate , sizeof(JET_INDEXCREATE ) * tbl.cIndexes );

    if(tbl.szTableName    == NULL ||
       tbl.rgcolumncreate == NULL ||
       tbl.rgindexcreate  == NULL  )
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_OUTOFMEMORY);
    }


    for(i=0, itCol = m_lstColumns.begin(); itCol != m_lstColumns.end(); itCol++, i++)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, itCol->Generate( tbl.rgcolumncreate[ i ] ));
    }

    for(i=0, itIdx = m_lstIndexes.begin(); itIdx != m_lstIndexes.end(); itIdx++, i++)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, itIdx->Generate( tbl.rgindexcreate[ i ] ));
    }


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::TableDefinition::Release( /*[in]*/ JET_TABLECREATE& tbl )
{
    __HCP_FUNC_ENTRY( "JetBlue::TableDefinition::Release" );

    HRESULT    hr;
    ColDefIter itCol;
    IdxDefIter itIdx;
    int        i;


    if(tbl.szTableName)
    {
        free( tbl.szTableName );

        tbl.szTableName = NULL;
    }

    if(tbl.rgcolumncreate)
    {
        for(i=0, itCol = m_lstColumns.begin(); itCol != m_lstColumns.end(); itCol++, i++)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, itCol->Release( tbl.rgcolumncreate[ i ] ));
        }

        delete [] tbl.rgcolumncreate; tbl.rgcolumncreate = NULL;
    }

    if(tbl.rgindexcreate)
    {
        for(i=0, itIdx = m_lstIndexes.begin(); itIdx != m_lstIndexes.end(); itIdx++, i++)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, itIdx->Release( tbl.rgindexcreate[ i ] ));
        }

        delete [] tbl.rgindexcreate; tbl.rgindexcreate = NULL;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\jetblue\lowlevel\database.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Database.cpp

Abstract:
    This file contains the implementation of the JetBlue::Database class.

Revision History:
    Davide Massarenti   (Dmassare)  05/17/2000
        created

******************************************************************************/

#include <stdafx.h>
#include <strsafe.h>

////////////////////////////////////////////////////////////////////////////////

JetBlue::Database::Database( /*[in]*/ Session*  parent ,
                             /*[in]*/ JET_SESID sesid  ,
                             /*[in]*/ LPCSTR    szName )
{
    m_parent  = parent;      // Session*    m_parent;
    m_sesid   = sesid;       // JET_SESID   m_sesid;
    m_dbid    = JET_dbidNil; // JET_DBID    m_dbid;
    m_strName = szName;      // MPC::string m_strName;
                             // TableMap    m_mapTables;
}

JetBlue::Database::~Database()
{
    (void)Close( true );
}

////////////////////////////////////////

HRESULT JetBlue::Database::Refresh()
{
    __HCP_FUNC_ENTRY( "JetBlue::Database::Refresh" );

    HRESULT        hr;
    JET_OBJECTLIST info; ::ZeroMemory( &info, sizeof(info) ); info.cbStruct = sizeof(info); info.tableid = JET_tableidNil;
    Table*         tblNew = NULL;


    m_mapTables.clear();


    if(m_dbid != JET_dbidNil)
    {
        ////////////////////////////////////////////////////////////////////////////////
        //
        // Read table definition.
        //
        // JET_OBJECTLIST
        // {
        //     unsigned long   cbStruct;
        //     JET_TABLEID     tableid;
        //     unsigned long   cRecord;
        //     JET_COLUMNID    columnidcontainername;
        //     JET_COLUMNID    columnidobjectname;
        //     JET_COLUMNID    columnidobjtyp;
        //     JET_COLUMNID    columniddtCreate;   //  XXX -- to be deleted
        //     JET_COLUMNID    columniddtUpdate;   //  XXX -- to be deleted
        //     JET_COLUMNID    columnidgrbit;
        //     JET_COLUMNID    columnidflags;
        //     JET_COLUMNID    columnidcRecord;    /* Level 2 info */
        //     JET_COLUMNID    columnidcPage;      /* Level 2 info */
        // };
        //
        // JET_RETRIEVECOLUMN
        // {
        //     JET_COLUMNID        columnid;
        //     void                *pvData;
        //     unsigned long       cbData;
        //     unsigned long       cbActual;
        //     JET_GRBIT           grbit;
        //     unsigned long       ibLongValue;
        //     unsigned long       itagSequence;
        //     JET_COLUMNID        columnidNextTagged;
        //     JET_ERR             err;
        // };
        JET_RETRIEVECOLUMN rc     [1               ]; ::ZeroMemory( &rc, sizeof(rc) );
        char               tblName[JET_cbNameMost+1];
        int                i;


        __MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetGetObjectInfo( m_sesid, m_dbid, JET_objtypTable, NULL, NULL, &info, sizeof(info), JET_ObjInfoList ));

        __MPC_JET_INIT_RETRIEVE_COL( rc, 0, info.columnidobjectname, tblName, JET_cbNameMost );


        for(i=0; i<info.cRecord; i++)
        {
            ::ZeroMemory( tblName, sizeof(tblName) );

            __MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetMove           ( m_sesid, info.tableid, (i == 0 ? JET_MoveFirst : JET_MoveNext), 0 ));
            __MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetRetrieveColumns( m_sesid, info.tableid, rc, ARRAYSIZE(rc)                          ));

            __MPC_EXIT_IF_ALLOC_FAILS(hr, tblNew, new Table( m_sesid, m_dbid, tblName ));

            m_mapTables[tblName] = tblNew; tblNew = NULL;
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(info.tableid != JET_tableidNil)
    {
        __MPC_JET__MTSAFE_NORESULT(m_sesid, ::JetCloseTable( m_sesid, info.tableid ));
    }

    if(tblNew) delete tblNew;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::Database::Open( /*[in]*/ bool fReadOnly ,
                                 /*[in]*/ bool fCreate   ,
								 /*[in]*/ bool fRepair   )
{
    __HCP_FUNC_ENTRY( "JetBlue::Database::Open" );

    HRESULT   hr;
    JET_ERR   err;
	JET_GRBIT grbit   = fReadOnly ? JET_bitDbReadOnly : 0;
	bool      fLocked = false;


	//
	// In case we cannot lock the database, we try to release it and relock it.
	//
	if(m_parent->LockDatabase( m_strName, fReadOnly ) == false)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, Close());

		__MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->ReleaseDatabase( m_strName ));

		if(m_parent->LockDatabase( m_strName, fReadOnly ) == false)
		{
			__MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_BUSY);
		}
	}
	fLocked = true;

 
    if(m_dbid == JET_dbidNil)
    {
        err = ::JetAttachDatabase( m_sesid, m_strName.c_str(), grbit );
        if(err < JET_errSuccess)
        {
            if(err == JET_errDatabaseCorrupted && fRepair)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, Repair());

                err = ::JetAttachDatabase( m_sesid, m_strName.c_str(), grbit );
            }

            if(err == JET_errDatabaseCorrupted || fCreate == false)
            {
                __MPC_EXIT_IF_JET_FAILS(hr, err);
            }

            __MPC_EXIT_IF_JET_FAILS(hr, ::JetCreateDatabase( m_sesid, m_strName.c_str(), NULL, &m_dbid, 0 ));
        }
        else
        {
            __MPC_EXIT_IF_JET_FAILS(hr, ::JetOpenDatabase( m_sesid, m_strName.c_str(), NULL, &m_dbid, 0 ));
        }


        __MPC_EXIT_IF_METHOD_FAILS(hr, Refresh());
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

	if(FAILED(hr) && fLocked)
	{
        m_parent->UnlockDatabase( m_strName );
	}

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::Database::Close( /*[in]*/ bool fForce, /*[in]*/ bool fAll )
{
    __HCP_FUNC_ENTRY( "JetBlue::Database::Close" );

    HRESULT   hr;
    JET_ERR   err;
    TableIter it;


    for(it = m_mapTables.begin(); it != m_mapTables.end(); it++)
    {
        Table* tbl = it->second;

        if(tbl)
        {
            HRESULT hr2 = tbl->Close( fForce ); if(!fForce) __MPC_EXIT_IF_METHOD_FAILS(hr, hr2);

            delete tbl;
        }
    }
    m_mapTables.clear();


    if(fAll && m_dbid != JET_dbidNil)
    {
        err = ::JetCloseDatabase( m_sesid, m_dbid, 0 ); if(!fForce) __MPC_EXIT_IF_JET_FAILS(hr, err);

        m_dbid = JET_dbidNil;

        m_parent->UnlockDatabase( m_strName );
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::Database::Delete( /*[in]*/ bool fForce )
{
    __HCP_FUNC_ENTRY( "JetBlue::Database::Delete" );

    USES_CONVERSION;

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Close( fForce ));

    if(m_strName.length() > 0)
    {
        MPC::FileSystemObject fso( A2W( m_strName.c_str() ) );

        __MPC_EXIT_IF_METHOD_FAILS(hr, fso.Delete( fForce ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

HRESULT JetBlue::Database::GetTable( /*[in] */ LPCSTR           szName ,
                                     /*[out]*/ Table*&          tbl    ,
                                     /*[in] */ JET_TABLECREATE* pDef   )
{
    __HCP_FUNC_ENTRY( "JetBlue::Database::GetTable" );

    HRESULT   hr;
    HRESULT   hr2;
    Table*    tblNew = NULL;
    TableIter it;


    __MPC_JET_CHECKHANDLE(hr,m_sesid,JET_sesidNil );


    if(pDef) szName = pDef->szTableName;


    it = m_mapTables.find( szName );
    if(it == m_mapTables.end())
    {
        __MPC_EXIT_IF_ALLOC_FAILS(hr, tblNew, new Table( m_sesid, m_dbid, szName ));

        m_mapTables[szName] = tblNew;

        tbl = tblNew; tblNew = NULL;
    }
    else
    {
        tbl = it->second;
    }

    if(FAILED(hr2 = tbl->Open()))
    {
        if(pDef == NULL || hr2 != JetERRToHRESULT( JET_errObjectNotFound ))
        {
            __MPC_SET_ERROR_AND_EXIT(hr, hr2);
        }

        if(pDef == (JET_TABLECREATE*)-1)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, tbl->Create());
        }
        else
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, tbl->Create( pDef ));
        }
    }

    hr  = S_OK;


    __HCP_FUNC_CLEANUP;

    if(tblNew) delete tblNew;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::Database::Compact()
{
    __HCP_FUNC_ENTRY( "JetBlue::Database::Compact" );

    HRESULT    hr;
    JET_DBUTIL util;
    CHAR       rgTempDB[MAX_PATH];

    ::ZeroMemory( &util, sizeof(util) );

    util.cbStruct   =        sizeof(util);
    util.sesid      =        m_sesid;
    util.op         =        opDBUTILDBDefragment;
    util.szDatabase = (LPSTR)m_strName.c_str();
    util.szTable    =        rgTempDB;

    StringCbPrintfA( rgTempDB, sizeof(rgTempDB), "%s.temp", util.szDatabase );
    (void)::DeleteFileA( rgTempDB );


    __MPC_EXIT_IF_METHOD_FAILS(hr, Close());


    __MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetDBUtilities( &util ));


    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::MoveFileExA( rgTempDB, util.szDatabase, MOVEFILE_REPLACE_EXISTING ));

    hr  = S_OK;


    __HCP_FUNC_CLEANUP;

    (void)::DeleteFileA( rgTempDB );

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::Database::Repair()
{
    __HCP_FUNC_ENTRY( "JetBlue::Database::Repair" );

    HRESULT    hr;
    JET_DBUTIL util;

    ::ZeroMemory( &util, sizeof(util) );

    util.cbStruct   =        sizeof(util);
    util.sesid      =        m_sesid;
    util.op         =        opDBUTILEDBRepair;
    util.szDatabase = (LPSTR)m_strName.c_str();


    __MPC_EXIT_IF_METHOD_FAILS(hr, Close());


    __MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetDBUtilities( &util ));


    hr  = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

JetBlue::Table* JetBlue::Database::GetTbl( /*[in]*/ int iPos )
{
    for(TableIter it = m_mapTables.begin(); it != m_mapTables.end(); it++)
    {
        if(iPos-- == 0) return it->second;
    }

    return NULL;
}

JetBlue::Table* JetBlue::Database::GetTbl( LPCSTR szTbl )
{
    TableIter it = m_mapTables.find( szTbl );

    return (it == m_mapTables.end()) ? NULL : it->second;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\jetblue\lowlevel\index.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Index.cpp

Abstract:
    This file contains the implementation of the JetBlue::Index class.

Revision History:
    Davide Massarenti   (Dmassare)  05/19/2000
        created

******************************************************************************/

#include <stdafx.h>

////////////////////////////////////////////////////////////////////////////////

JetBlue::Index::Index()
{
    m_sesid      = JET_sesidNil;   // JET_SESID    m_sesid;
    m_tableid    = JET_tableidNil; // JET_TABLEID  m_tableid;
                                   // MPC::string  m_strName;
    m_grbitIndex = 0;              // JET_GRBIT    m_grbitIndex;
    m_cKey       = 0;              // LONG         m_cKey;
    m_cEntry     = 0;              // LONG         m_cEntry;
    m_cPage      = 0;              // LONG         m_cPage;
                                   // ColumnVector m_vecColumns;
                                   // Column       m_fake;
}

JetBlue::Index::~Index()
{
}

////////////////////////////////////////

HRESULT JetBlue::Index::GenerateKey( /*[out]*/ LPSTR&         szKey ,
                                     /*[out]*/ unsigned long& cKey  )
{
    __HCP_FUNC_ENTRY( "JetBlue::Index::Get" );

    HRESULT hr;
    LPSTR   szPtr;
    int     iLen = m_vecColumns.size();
    int     iPos;


    szKey = NULL;
    cKey  = 1;


    for(iPos=0; iPos<iLen; iPos++)
    {
        cKey += (unsigned long) m_vecColumns[iPos].m_strName.length() + 2;
    }

    __MPC_EXIT_IF_ALLOC_FAILS(hr, szKey, new CHAR[cKey]);

    for(szPtr=szKey,iPos=0; iPos<iLen; iPos++)
    {
        Column& col = m_vecColumns[iPos];

        *szPtr++ = (col.m_coldef.grbit & JET_bitKeyDescending) ? '-' : '+';

        strcpy( szPtr, col.m_strName.c_str() ); szPtr += col.m_strName.length() + 1;
    }
    *szPtr = 0;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

int JetBlue::Index::GetColPosition( LPCSTR szCol )
{
    int iLen = m_vecColumns.size();
    int iPos;

    for(iPos=0; iPos<iLen; iPos++)
    {
        Column& col = m_vecColumns[iPos];

        if(col.m_strName.compare( SAFEASTR( szCol ) ) == 0) return iPos;
    }

    return -1;
}

JetBlue::Column& JetBlue::Index::GetCol( LPCSTR szCol )
{
    return GetCol( GetColPosition( szCol ) );
}

JetBlue::Column& JetBlue::Index::GetCol( /*[in]*/ int iPos )
{
    if(0 <= iPos && iPos < m_vecColumns.size()) return m_vecColumns[iPos];

    return m_fake;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\jetblue\lowlevel\record.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Record.cpp

Abstract:
    This file contains the implementation of the JetBlue::Record class.

Revision History:
    Davide Massarenti   (Dmassare)  05/21/2000
        created

******************************************************************************/

#include <stdafx.h>

////////////////////////////////////////////////////////////////////////////////

#define GET_IDX_NAME(rs,name) SchemaDefinition::rs::IdxDef[ SchemaDefinition::rs::Idx__##name ].szIndexName

namespace SchemaDefinition
{
    namespace DbParameters
    {
        static const int Idx__ByName = 0;

        static const JET_INDEXCREATE IdxDef[] =
        {
            __MPC_JET_INDEXCREATE("ByName","+Name\0",JET_bitIndexUnique|JET_bitIndexPrimary,80),
        };

        static const JET_COLUMNCREATE ColDef[] =
        {
            __MPC_JET_COLUMNCREATE_UNICODE("Name" ,JET_coltypText    ,128,JET_bitColumnNotNULL),
            __MPC_JET_COLUMNCREATE_UNICODE("Value",JET_coltypLongText,0  ,0                   ),
        };

        static const JET_TABLECREATE TblDef = __MPC_JET_TABLECREATE("DbParameters",10,80,ColDef,IdxDef);
    };

    namespace ContentOwners
    {
        static const int Idx__ByVendorID = 0;
        static const int Idx__Owner      = 1;

        static const JET_INDEXCREATE IdxDef[] =
        {
            __MPC_JET_INDEXCREATE("ByVendorID","+DN\0"      ,JET_bitIndexUnique|JET_bitIndexPrimary,80),
            __MPC_JET_INDEXCREATE("Owner"     ,"+ID_owner\0",JET_bitIndexUnique                    ,80),
        };

        static const JET_COLUMNCREATE ColDef[] =
        {
            __MPC_JET_COLUMNCREATE_UNICODE("DN"      ,JET_coltypText,250,JET_bitColumnNotNULL                           ),
            __MPC_JET_COLUMNCREATE        ("ID_owner",JET_coltypLong,0  ,JET_bitColumnNotNULL|JET_bitColumnAutoincrement),
            __MPC_JET_COLUMNCREATE_UNICODE("IsOEM"   ,JET_coltypBit ,0  ,JET_bitColumnNotNULL                           ),
        };

        static const JET_TABLECREATE TblDef = __MPC_JET_TABLECREATE("ContentOwners",10,80,ColDef,IdxDef);
    };

    namespace SynSets
    {
        static const int Idx__ByPair = 0;

        static const JET_INDEXCREATE IdxDef[] =
        {
            __MPC_JET_INDEXCREATE("ByPair","+Name\0+ID_owner\0",JET_bitIndexUnique|JET_bitIndexPrimary,80),
        };

        static const JET_COLUMNCREATE ColDef[] =
        {
            __MPC_JET_COLUMNCREATE_UNICODE("Name"     ,JET_coltypText,250,JET_bitColumnNotNULL                           ),
            __MPC_JET_COLUMNCREATE        ("ID_owner" ,JET_coltypLong,0  ,JET_bitColumnNotNULL                           ),
            __MPC_JET_COLUMNCREATE        ("ID_synset",JET_coltypLong,0  ,JET_bitColumnNotNULL|JET_bitColumnAutoincrement),
        };

        static const JET_TABLECREATE TblDef = __MPC_JET_TABLECREATE("SynSets",10,80,ColDef,IdxDef);
    };

    namespace HelpImage
    {
        static const int Idx__ByFile = 0;

        static const JET_INDEXCREATE IdxDef[] =
        {
            __MPC_JET_INDEXCREATE("ByFile","+File\0",JET_bitIndexUnique|JET_bitIndexPrimary,80),
        };

        static const JET_COLUMNCREATE ColDef[] =
        {
            __MPC_JET_COLUMNCREATE        ("ID_owner",JET_coltypLong,0  ,JET_bitColumnNotNULL),
            __MPC_JET_COLUMNCREATE_UNICODE("File"    ,JET_coltypText,250,JET_bitColumnNotNULL),
        };

        static const JET_TABLECREATE TblDef = __MPC_JET_TABLECREATE("HelpImage",10,80,ColDef,IdxDef);
    };

    namespace Scope
    {
        static const int Idx__ByID        = 0;
        static const int Idx__ByScope     = 1;
        static const int Idx__OwnedScopes = 2;

        static const JET_INDEXCREATE IdxDef[] =
        {
            __MPC_JET_INDEXCREATE("ByID"       ,"+ID\0"      ,JET_bitIndexUnique|JET_bitIndexPrimary,80),
            __MPC_JET_INDEXCREATE("ByScope"    ,"+ID_scope\0",JET_bitIndexUnique                    ,80),
            __MPC_JET_INDEXCREATE("OwnedScopes","+ID_owner\0",0                                     ,80),
        };

        static const JET_COLUMNCREATE ColDef[] =
        {
            __MPC_JET_COLUMNCREATE        ("ID_owner",JET_coltypLong    ,0  ,JET_bitColumnNotNULL                           ),
            __MPC_JET_COLUMNCREATE        ("ID_scope",JET_coltypLong    ,0  ,JET_bitColumnNotNULL|JET_bitColumnAutoincrement),
            __MPC_JET_COLUMNCREATE_UNICODE("ID"      ,JET_coltypText    ,250,JET_bitColumnNotNULL                           ),
            __MPC_JET_COLUMNCREATE_UNICODE("Name"    ,JET_coltypText    ,250,JET_bitColumnNotNULL                           ),
            __MPC_JET_COLUMNCREATE_UNICODE("Category",JET_coltypLongText,0  ,0                                              ),
        };

        static const JET_TABLECREATE TblDef = __MPC_JET_TABLECREATE("Scope",10,80,ColDef,IdxDef);
    };

    namespace IndexFiles
    {
        static const int Idx__ByScope = 0;

        static const JET_INDEXCREATE IdxDef[] =
        {
            __MPC_JET_INDEXCREATE("ByScope","+ID_scope\0",0,80),
        };

        static const JET_COLUMNCREATE ColDef[] =
        {
            __MPC_JET_COLUMNCREATE        ("ID_owner",JET_coltypLong    ,0,JET_bitColumnNotNULL),
            __MPC_JET_COLUMNCREATE        ("ID_scope",JET_coltypLong    ,0,JET_bitColumnNotNULL),
            __MPC_JET_COLUMNCREATE_UNICODE("Storage" ,JET_coltypLongText,0,0                   ),
            __MPC_JET_COLUMNCREATE_UNICODE("File"    ,JET_coltypLongText,0,0                   ),
        };

        static const JET_TABLECREATE TblDef = __MPC_JET_TABLECREATE("IndexFiles",10,80,ColDef,IdxDef);
    };

    namespace FullTextSearch
    {
        static const int Idx__ByScope = 0;

        static const JET_INDEXCREATE IdxDef[] =
        {
            __MPC_JET_INDEXCREATE("ByScope","+ID_scope\0",0,80),
        };

        static const JET_COLUMNCREATE ColDef[] =
        {
            __MPC_JET_COLUMNCREATE        ("ID_owner",JET_coltypLong    ,0,JET_bitColumnNotNULL),
            __MPC_JET_COLUMNCREATE        ("ID_scope",JET_coltypLong    ,0,JET_bitColumnNotNULL),
            __MPC_JET_COLUMNCREATE_UNICODE("CHM"     ,JET_coltypLongText,0,0                   ),
            __MPC_JET_COLUMNCREATE_UNICODE("CHQ"     ,JET_coltypLongText,0,0                   ),
        };

        static const JET_TABLECREATE TblDef = __MPC_JET_TABLECREATE("FullTextSearch",10,80,ColDef,IdxDef);
    };

    namespace Taxonomy
    {
        static const int Idx__SubNode  = 0;
        static const int Idx__Children = 1;
        static const int Idx__Node     = 2;

        static const JET_INDEXCREATE IdxDef[] =
        {
            __MPC_JET_INDEXCREATE("SubNode" ,"+ID_parent\0+Entry\0",JET_bitIndexUnique|JET_bitIndexPrimary,80),
            __MPC_JET_INDEXCREATE("Children","+ID_parent\0"        ,0                                     ,80),
            __MPC_JET_INDEXCREATE("Node"    ,"+ID_node\0"          ,JET_bitIndexUnique                    ,80),
        };

        static const JET_COLUMNCREATE ColDef[] =
        {
            __MPC_JET_COLUMNCREATE        ("ID_node"        ,JET_coltypLong    ,0  ,JET_bitColumnNotNULL|JET_bitColumnAutoincrement),
            __MPC_JET_COLUMNCREATE        ("Pos"            ,JET_coltypLong    ,0  ,JET_bitColumnNotNULL                           ),
            __MPC_JET_COLUMNCREATE        ("ID_parent"      ,JET_coltypLong    ,0  ,0                                              ),
            __MPC_JET_COLUMNCREATE        ("ID_owner"       ,JET_coltypLong    ,0  ,JET_bitColumnNotNULL                           ),
            __MPC_JET_COLUMNCREATE_UNICODE("Entry"          ,JET_coltypText    ,250,JET_bitColumnNotNULL                           ),
            __MPC_JET_COLUMNCREATE_UNICODE("Title"          ,JET_coltypLongText,0  ,0                                              ),
            __MPC_JET_COLUMNCREATE_UNICODE("Description"    ,JET_coltypLongText,0  ,0                                              ),
            __MPC_JET_COLUMNCREATE_UNICODE("DescriptionURI" ,JET_coltypLongText,0  ,0                                              ),
            __MPC_JET_COLUMNCREATE_UNICODE("IconURI"        ,JET_coltypLongText,0  ,0                                              ),
            __MPC_JET_COLUMNCREATE        ("Visible"        ,JET_coltypBit     ,0  ,JET_bitColumnNotNULL                           ),
            __MPC_JET_COLUMNCREATE        ("Subsite"        ,JET_coltypBit     ,0  ,JET_bitColumnNotNULL                           ),
            __MPC_JET_COLUMNCREATE        ("NavModel"       ,JET_coltypLong    ,0  ,JET_bitColumnNotNULL                           ),
        };

        static const JET_TABLECREATE TblDef = __MPC_JET_TABLECREATE("Taxonomy",10,80,ColDef,IdxDef);
    };

    namespace Topics
    {
        static const int Idx__SingleTopic     = 0;
        static const int Idx__TopicsUnderNode = 1;
        static const int Idx__ByURI           = 2;

        static const JET_INDEXCREATE IdxDef[] =
        {
            __MPC_JET_INDEXCREATE("SingleTopic"    ,"+ID_topic\0",JET_bitIndexPrimary|JET_bitIndexUnique,80),
            __MPC_JET_INDEXCREATE("TopicsUnderNode","+ID_node\0" ,0                                     ,80),
            __MPC_JET_INDEXCREATE("ByURI"          ,"+URI\0"     ,0                                     ,80),
        };

        static const JET_COLUMNCREATE ColDef[] =
        {
            __MPC_JET_COLUMNCREATE        ("ID_topic"   ,JET_coltypLong    ,0  ,JET_bitColumnNotNULL|JET_bitColumnAutoincrement),
            __MPC_JET_COLUMNCREATE        ("ID_node"    ,JET_coltypLong    ,0  ,JET_bitColumnNotNULL                           ),
            __MPC_JET_COLUMNCREATE        ("ID_owner"   ,JET_coltypLong    ,0  ,JET_bitColumnNotNULL                           ),
            __MPC_JET_COLUMNCREATE        ("Pos"        ,JET_coltypLong    ,0  ,JET_bitColumnNotNULL                           ),
            __MPC_JET_COLUMNCREATE_UNICODE("Title"      ,JET_coltypLongText,0  ,0                                              ),
            __MPC_JET_COLUMNCREATE_UNICODE("URI"        ,JET_coltypLongText,0  ,0                                              ),
            __MPC_JET_COLUMNCREATE_UNICODE("Description",JET_coltypLongText,0  ,0                                              ),
            __MPC_JET_COLUMNCREATE_UNICODE("IconURI"    ,JET_coltypLongText,0  ,0                                              ),
            __MPC_JET_COLUMNCREATE        ("Type"       ,JET_coltypLong    ,0  ,JET_bitColumnNotNULL                           ),
            __MPC_JET_COLUMNCREATE        ("Visible"    ,JET_coltypBit     ,0  ,JET_bitColumnNotNULL                           ),
        };

        static const JET_TABLECREATE TblDef = __MPC_JET_TABLECREATE("Topics",10,80,ColDef,IdxDef);
    };

    namespace Synonyms
    {
        static const int Idx__ByPair = 0;
        static const int Idx__ByName = 1;

        static const JET_INDEXCREATE IdxDef[] =
        {
            __MPC_JET_INDEXCREATE("ByPair","+Keyword\0+ID_synset\0",JET_bitIndexUnique|JET_bitIndexPrimary,80),
            __MPC_JET_INDEXCREATE("ByName","+Keyword\0"            ,0                                     ,80),
        };

        static const JET_COLUMNCREATE ColDef[] =
        {
            __MPC_JET_COLUMNCREATE_UNICODE("Keyword"  ,JET_coltypText,250,JET_bitColumnNotNULL),
            __MPC_JET_COLUMNCREATE        ("ID_synset",JET_coltypLong,0  ,JET_bitColumnNotNULL),
            __MPC_JET_COLUMNCREATE        ("ID_owner" ,JET_coltypLong,0  ,JET_bitColumnNotNULL),
        };

        static const JET_TABLECREATE TblDef = __MPC_JET_TABLECREATE("Synonyms",10,80,ColDef,IdxDef);
    };

    namespace Keywords
    {
        static const int Idx__ByName = 0;

        static const JET_INDEXCREATE IdxDef[] =
        {
            __MPC_JET_INDEXCREATE("ByName","+Keyword\0",JET_bitIndexUnique|JET_bitIndexPrimary,80),
        };

        static const JET_COLUMNCREATE ColDef[] =
        {
            __MPC_JET_COLUMNCREATE_UNICODE("Keyword"   ,JET_coltypText,250,JET_bitColumnNotNULL                           ),
            __MPC_JET_COLUMNCREATE        ("ID_keyword",JET_coltypLong,0  ,JET_bitColumnNotNULL|JET_bitColumnAutoincrement),
        };

        static const JET_TABLECREATE TblDef = __MPC_JET_TABLECREATE("Keywords",10,80,ColDef,IdxDef);
    };

    namespace Matches
    {
        static const int Idx__Pair      = 0;
        static const int Idx__ByKeyword = 1;
        static const int Idx__ByTopic   = 2;

        static const JET_INDEXCREATE IdxDef[] =
        {
            __MPC_JET_INDEXCREATE("Pair"     ,"+ID_keyword\0+ID_topic\0",JET_bitIndexUnique|JET_bitIndexPrimary,80),
            __MPC_JET_INDEXCREATE("ByKeyword","+ID_keyword\0"           ,0                                     ,80),
            __MPC_JET_INDEXCREATE("ByTopic"  ,"+ID_topic\0"             ,0                                     ,80),
        };

        static const JET_COLUMNCREATE ColDef[] =
        {
            __MPC_JET_COLUMNCREATE("ID_topic"  ,JET_coltypLong,0,JET_bitColumnNotNULL),
            __MPC_JET_COLUMNCREATE("ID_keyword",JET_coltypLong,0,JET_bitColumnNotNULL),
            __MPC_JET_COLUMNCREATE("Priority"  ,JET_coltypLong,0,JET_bitColumnNotNULL),
            __MPC_JET_COLUMNCREATE("HHK"       ,JET_coltypBit ,0,JET_bitColumnNotNULL),
        };

        static const JET_TABLECREATE TblDef = __MPC_JET_TABLECREATE("Matches",10,80,ColDef,IdxDef);
    };
};

////////////////////////////////////////////////////////////////////////////////

const JET_TABLECREATE* Taxonomy::g_Tables[] =
{
    &SchemaDefinition::DbParameters  ::TblDef,
    &SchemaDefinition::ContentOwners ::TblDef,
    &SchemaDefinition::SynSets       ::TblDef,
    &SchemaDefinition::HelpImage     ::TblDef,
    &SchemaDefinition::Scope         ::TblDef,
    &SchemaDefinition::IndexFiles    ::TblDef,
    &SchemaDefinition::FullTextSearch::TblDef,
    &SchemaDefinition::Taxonomy      ::TblDef,
    &SchemaDefinition::Topics        ::TblDef,
    &SchemaDefinition::Synonyms      ::TblDef,
    &SchemaDefinition::Keywords      ::TblDef,
    &SchemaDefinition::Matches       ::TblDef,
};

const int Taxonomy::g_NumOfTables = ARRAYSIZE(Taxonomy::g_Tables);

////////////////////////////////////////

static HRESULT Local_CreateTable( /*[in]*/  JetBlue::Database*&    db    ,
                                  /*[out]*/ JetBlue::Table*&       table ,
                                  /*[in]*/  const JET_TABLECREATE* def   )
{
    __HCP_FUNC_ENTRY( "Local_CreateTable" );

    HRESULT         hr;
    JET_TABLECREATE tblDef;

    ::CopyMemory( &tblDef, def, sizeof(tblDef) );

    tblDef.rgcolumncreate = NULL;
    tblDef.cColumns       = 0;
    tblDef.rgindexcreate  = NULL;
    tblDef.cIndexes       = 0;

    if(def->cColumns)
    {
        __MPC_EXIT_IF_ALLOC_FAILS(hr, tblDef.rgcolumncreate, new JET_COLUMNCREATE[def->cColumns]);

        tblDef.cColumns = def->cColumns;

        ::CopyMemory( tblDef.rgcolumncreate, def->rgcolumncreate, sizeof(*tblDef.rgcolumncreate) * def->cColumns );
    }

    if(def->cIndexes)
    {
        __MPC_EXIT_IF_ALLOC_FAILS(hr, tblDef.rgindexcreate, new JET_INDEXCREATE[def->cIndexes]);

        tblDef.cIndexes = def->cIndexes;

        ::CopyMemory( tblDef.rgindexcreate, def->rgindexcreate, sizeof(*tblDef.rgindexcreate) * def->cIndexes );
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, db->GetTable( NULL, table, &tblDef ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(tblDef.rgcolumncreate) delete [] tblDef.rgcolumncreate;
    if(tblDef.rgindexcreate ) delete [] tblDef.rgindexcreate;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::CreateSchema( /*[in]*/ JetBlue::Database* db )
{
    __HCP_FUNC_ENTRY( "Taxonomy::CreateSchema" );

    HRESULT         hr;
    JetBlue::Table* table;

    ////////////////////////////////////////////////////////////////////////////////

    for(int i=0; i<Taxonomy::g_NumOfTables; i++)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, Local_CreateTable( db, table, g_Tables[i] ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

JetBlue::RecordBindingBase::RecordBindingBase( /*[in]*/ const RecordBindingBase& rs            ,
                                               /*[in]*/ void*                    pvBaseOfClass )
{
    m_fInitialized  = false;              // bool                    m_fInitialized;
    m_tbl           = NULL;               // Table*                  m_tbl;
    m_cur           = new Cursor();       // Cursor*                 m_cur;
    m_pvBaseOfClass = pvBaseOfClass;      // void*                   m_pvBaseOfClass;
    m_dwNumOfFields = rs.m_dwNumOfFields; // int                     m_dwNumOfFields;
    m_FieldsDef     = rs.m_FieldsDef;     // const RecordBindingDef* m_FieldsDef;
    m_rgFieldsPos   = NULL;               // int*                    m_rgFieldsPos;
    m_vtFieldsType  = NULL;               // VARTYPE*                m_vtFieldsType;

    if(m_cur && rs.m_tbl)
    {
        if(SUCCEEDED(rs.m_tbl->DupCursor( *m_cur )))
        {
            Table& tbl = *m_cur;

            m_tbl = &tbl;
        }
    }
}

JetBlue::RecordBindingBase::RecordBindingBase( /*[in]*/ Table*                  tbl           ,
                                               /*[in]*/ void*                   pvBaseOfClass ,
                                               /*[in]*/ const RecordBindingDef* FieldsDef     )
{
    m_fInitialized  = false;          // bool                    m_fInitialized;
    m_tbl           = tbl;            // Table*                  m_tbl;
    m_cur           = NULL;           // Cursor*                 m_cur;
    m_pvBaseOfClass = pvBaseOfClass;  // void*                   m_pvBaseOfClass;
    m_dwNumOfFields = 0;              // int                     m_dwNumOfFields;
    m_FieldsDef     = FieldsDef;      // const RecordBindingDef* m_FieldsDef;
    m_rgFieldsPos   = NULL;           // int*                    m_rgFieldsPos;
    m_vtFieldsType  = NULL;           // VARTYPE*                m_vtFieldsType;

    while(FieldsDef->szColName != NULL || FieldsDef->szColPos != -1)
    {
        void* data = (void*)((BYTE*)m_pvBaseOfClass + FieldsDef->offsetData);

        //
        // Clean all the non-automatic fields.
        //
        switch(FieldsDef->mtType)
        {
        case MPC::Config::MT_bool        : *(bool        *)data = false        ; break;
        case MPC::Config::MT_BOOL        : *(BOOL        *)data = FALSE        ; break;
        case MPC::Config::MT_VARIANT_BOOL: *(VARIANT_BOOL*)data = VARIANT_FALSE; break;
        case MPC::Config::MT_int         : *(int         *)data = 0            ; break;
        case MPC::Config::MT_long        : *(long        *)data = 0            ; break;
        case MPC::Config::MT_DWORD       : *(DWORD       *)data = 0            ; break;
        case MPC::Config::MT_float       : *(float       *)data = 0            ; break;
        case MPC::Config::MT_double      : *(double      *)data = 0            ; break;
        case MPC::Config::MT_DATE        : *(DATE        *)data = 0            ; break;
//      case MPC::Config::MT_BSTR        : ((CComBSTR    *)data)->Empty()      ; break;
//      case MPC::Config::MT_string      : ((MPC::string *)data)->erase()      ; break;
//      case MPC::Config::MT_wstring     : ((MPC::wstring*)data)->erase()      ; break;
        }

        if(FieldsDef->offsetNullFlag != -1)
        {
            *(bool*)((BYTE*)m_pvBaseOfClass + FieldsDef->offsetNullFlag) = false;
        }


        FieldsDef++;
        m_dwNumOfFields++;
    }
}

JetBlue::RecordBindingBase::~RecordBindingBase()
{
    Cleanup();
}

HRESULT JetBlue::RecordBindingBase::Initialize()
{
    __HCP_FUNC_ENTRY( "JetBlue::RecordBindingBase::Initialize" );

    HRESULT hr;


    if(m_fInitialized == false)
    {
        __MPC_JET_CHECKHANDLE(hr,m_tbl,NULL);

        __MPC_EXIT_IF_ALLOC_FAILS(hr, m_rgFieldsPos , new int    [m_dwNumOfFields]);
        __MPC_EXIT_IF_ALLOC_FAILS(hr, m_vtFieldsType, new VARTYPE[m_dwNumOfFields]);

        for(int i=0; i<m_dwNumOfFields; i++)
        {
            const RecordBindingDef coldef = m_FieldsDef[i];
            VARTYPE                vt;
            int                    iColPos;

            switch(coldef.mtType)
            {
            case MPC::Config::MT_bool        : vt = VT_BOOL; break;
            case MPC::Config::MT_BOOL        : vt = VT_BOOL; break;
            case MPC::Config::MT_VARIANT_BOOL: vt = VT_BOOL; break;
            case MPC::Config::MT_int         : vt = VT_I4  ; break;
            case MPC::Config::MT_long        : vt = VT_I4  ; break;
            case MPC::Config::MT_DWORD       : vt = VT_I4  ; break;
            case MPC::Config::MT_float       : vt = VT_R4  ; break;
            case MPC::Config::MT_double      : vt = VT_R8  ; break;
            case MPC::Config::MT_DATE        : vt = VT_DATE; break;
            case MPC::Config::MT_BSTR        : vt = VT_BSTR; break;
            case MPC::Config::MT_string      : vt = VT_BSTR; break;
            case MPC::Config::MT_wstring     : vt = VT_BSTR; break;
            default                          : __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
            }


            if(coldef.szColName)
            {
                int iPos = m_tbl->GetColPosition( coldef.szColName );

                if(iPos == -1)
                {
                    __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
                }

                iColPos = iPos;
            }
            else
            {
                iColPos = coldef.szColPos;
            }


            m_rgFieldsPos [i] = iColPos;
            m_vtFieldsType[i] = vt;
        }

        m_fInitialized = true;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void JetBlue::RecordBindingBase::Cleanup()
{
    if(m_rgFieldsPos)
    {
        delete [] m_rgFieldsPos; m_rgFieldsPos = NULL;
    }

    if(m_vtFieldsType)
    {
        delete [] m_vtFieldsType; m_vtFieldsType = NULL;
    }

    if(m_cur)
    {
        delete m_cur; m_cur = NULL;
    }

    m_fInitialized = false;
}

////////////////////

HRESULT JetBlue::RecordBindingBase::ReadData()
{
    __HCP_FUNC_ENTRY( "JetBlue::RecordBindingBase::ReadData" );

    USES_CONVERSION;

    HRESULT hr;


    for(int i=0; i<m_dwNumOfFields; i++)
    {
        const RecordBindingDef coldef  = m_FieldsDef[i];
        void*                  data    = (void*)((BYTE*)m_pvBaseOfClass + coldef.offsetData);
        bool*                  pfIsValid;
        CComVariant            value;


        __MPC_EXIT_IF_METHOD_FAILS(hr, m_tbl->GetCol( m_rgFieldsPos[i] ).Get( value ));


        if(coldef.offsetNullFlag == -1)
        {
            pfIsValid = NULL;
        }
        else
        {
            pfIsValid = (bool*)((BYTE*)m_pvBaseOfClass + coldef.offsetNullFlag);
        }

        if(value.vt == VT_NULL)
        {
            if(pfIsValid == NULL)
            {
                __MPC_SET_ERROR_AND_EXIT(hr, JetBlue::JetERRToHRESULT(JET_errNullInvalid));
            }

            *pfIsValid = false;

            switch(coldef.mtType)
            {
            case MPC::Config::MT_bool        : *(bool        *)data = false        ; break;
            case MPC::Config::MT_BOOL        : *(BOOL        *)data = FALSE        ; break;
            case MPC::Config::MT_VARIANT_BOOL: *(VARIANT_BOOL*)data = VARIANT_FALSE; break;
            case MPC::Config::MT_int         : *(int         *)data = 0            ; break;
            case MPC::Config::MT_long        : *(long        *)data = 0            ; break;
            case MPC::Config::MT_DWORD       : *(DWORD       *)data = 0            ; break;
            case MPC::Config::MT_float       : *(float       *)data = 0            ; break;
            case MPC::Config::MT_double      : *(double      *)data = 0            ; break;
            case MPC::Config::MT_DATE        : *(DATE        *)data = 0            ; break;
            case MPC::Config::MT_BSTR        : ((CComBSTR    *)data)->Empty()      ; break;
            case MPC::Config::MT_string      : ((MPC::string *)data)->erase()      ; break;
            case MPC::Config::MT_wstring     : ((MPC::wstring*)data)->erase()      ; break;
            }
        }
        else
        {
            if(pfIsValid)
            {
                *pfIsValid = true;
            }

            __MPC_EXIT_IF_METHOD_FAILS(hr, value.ChangeType( m_vtFieldsType[i] ));

            switch(coldef.mtType)
            {
            case MPC::Config::MT_bool        : *(bool        *)data =                (value.boolVal == VARIANT_TRUE) ? true : false; break;
            case MPC::Config::MT_BOOL        : *(BOOL        *)data =                (value.boolVal == VARIANT_TRUE) ? TRUE : FALSE; break;
            case MPC::Config::MT_VARIANT_BOOL: *(VARIANT_BOOL*)data =                 value.boolVal                                ; break;
            case MPC::Config::MT_int         : *(int         *)data =                 value.lVal                                   ; break;
            case MPC::Config::MT_long        : *(long        *)data =                 value.lVal                                   ; break;
            case MPC::Config::MT_DWORD       : *(DWORD       *)data =                 value.lVal                                   ; break;
            case MPC::Config::MT_float       : *(float       *)data =                 value.fltVal                                 ; break;
            case MPC::Config::MT_double      : *(double      *)data =                 value.dblVal                                 ; break;
            case MPC::Config::MT_DATE        : *(DATE        *)data =                 value.date                                   ; break;
            case MPC::Config::MT_BSTR        : *(CComBSTR    *)data =                 value.bstrVal                                ; break;
            case MPC::Config::MT_string      : *(MPC::string *)data =  OLE2A(SAFEBSTR(value.bstrVal))                              ; break;
            case MPC::Config::MT_wstring     : *(MPC::wstring*)data =        SAFEBSTR(value.bstrVal)                               ; break;
            }
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::RecordBindingBase::WriteData()
{
    __HCP_FUNC_ENTRY( "JetBlue::RecordBindingBase::WriteData" );

    HRESULT hr;


    for(int i=0; i<m_dwNumOfFields; i++)
    {
        const RecordBindingDef coldef  = m_FieldsDef[i];
        void*                  data    = (void*)((BYTE*)m_pvBaseOfClass + coldef.offsetData    );
        bool*                  pfIsValid;
        CComVariant            value;


        if(coldef.offsetNullFlag == -1)
        {
            pfIsValid = NULL;
        }
        else
        {
            pfIsValid = (bool*)((BYTE*)m_pvBaseOfClass + coldef.offsetNullFlag);
        }


        if(pfIsValid && *pfIsValid == false)
        {
            value.vt = VT_NULL;
        }
        else
        {
            switch(coldef.mtType)
            {
            case MPC::Config::MT_bool        : value.vt = VT_BOOL; value.boolVal = *(bool        *)data ? VARIANT_TRUE : VARIANT_FALSE; break;
            case MPC::Config::MT_BOOL        : value.vt = VT_BOOL; value.boolVal = *(BOOL        *)data ? VARIANT_TRUE : VARIANT_FALSE; break;
            case MPC::Config::MT_VARIANT_BOOL: value.vt = VT_BOOL; value.boolVal = *(VARIANT_BOOL*)data                               ; break;
            case MPC::Config::MT_int         : value.vt = VT_I4  ; value.lVal    = *(int         *)data                               ; break;
            case MPC::Config::MT_long        : value.vt = VT_I4  ; value.lVal    = *(long        *)data                               ; break;
            case MPC::Config::MT_DWORD       : value.vt = VT_I4  ; value.lVal    = *(DWORD       *)data                               ; break;
            case MPC::Config::MT_float       : value.vt = VT_R4  ; value.fltVal  = *(float       *)data                               ; break;
            case MPC::Config::MT_double      : value.vt = VT_R8  ; value.dblVal  = *(double      *)data                               ; break;
            case MPC::Config::MT_DATE        : value.vt = VT_DATE; value.date    = *(DATE        *)data                               ; break;
            case MPC::Config::MT_BSTR        :                     value         = *(CComBSTR    *)data                               ; break;
            case MPC::Config::MT_string      :                     value         = ((MPC::string *)data)->c_str()                     ; break;
            case MPC::Config::MT_wstring     :                     value         = ((MPC::wstring*)data)->c_str()                     ; break;
            }
        }

        {
            Column&              col = m_tbl->GetCol( m_rgFieldsPos[i] );
            const JET_COLUMNDEF& def = col;

            //
            // Don't write Autoincrement columns...
            //
            if(def.grbit & JET_bitColumnAutoincrement) continue;

            __MPC_EXIT_IF_METHOD_FAILS(hr, col.Put( value ));
        }

    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////

HRESULT JetBlue::RecordBindingBase::SelectIndex( /*[in]*/ LPCSTR    szIndex ,
                                                 /*[in]*/ JET_GRBIT grbit   )
{
    __HCP_FUNC_ENTRY( "JetBlue::RecordBindingBase::SelectIndex" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Initialize());

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_tbl->SelectIndex( szIndex, grbit ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::RecordBindingBase::SetIndexRange( /*[in]*/ JET_GRBIT grbit )
{
    __HCP_FUNC_ENTRY( "JetBlue::RecordBindingBase::SetIndexRange" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Initialize());

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_tbl->SetIndexRange( grbit ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::RecordBindingBase::Move( /*[in]*/ JET_GRBIT  grbit   ,
                                          /*[in]*/ long       cRow    ,
                                          /*[in]*/ bool      *pfFound )
{
    __HCP_FUNC_ENTRY( "JetBlue::RecordBindingBase::Move" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Initialize());

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_tbl->Move( grbit, cRow, pfFound ));

    if(pfFound == NULL || *pfFound)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, ReadData());
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::RecordBindingBase::Seek( /*[in]*/ JET_GRBIT  grbit   ,
                                          /*[in]*/ VARIANT*   rgKeys  ,
                                          /*[in]*/ int        dwLen   ,
                                          /*[in]*/ bool      *pfFound )
{
    __HCP_FUNC_ENTRY( "JetBlue::RecordBindingBase::Seek" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Initialize());

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_tbl->Seek( grbit, rgKeys, dwLen, pfFound ));

    if(pfFound == NULL || *pfFound)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, ReadData());
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////

HRESULT JetBlue::RecordBindingBase::Insert()
{
    __HCP_FUNC_ENTRY( "JetBlue::RecordBindingBase::Insert" );

    HRESULT hr;
	bool    fPrepared = false;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Initialize());

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_tbl->PrepareInsert()); fPrepared = true;

    __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData());

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_tbl->UpdateRecord( /*fMove*/true )); fPrepared = false;

    __MPC_EXIT_IF_METHOD_FAILS(hr, ReadData());

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

	if(FAILED(hr) && fPrepared) (void)m_tbl->CancelChange();

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::RecordBindingBase::Update()
{
    __HCP_FUNC_ENTRY( "JetBlue::RecordBindingBase::Update" );

    HRESULT hr;
	bool    fPrepared = false;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Initialize());

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_tbl->PrepareUpdate()); fPrepared = true;

    __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData());

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_tbl->UpdateRecord( /*fMove*/false )); fPrepared = false;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

	if(FAILED(hr) && fPrepared) (void)m_tbl->CancelChange();

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::RecordBindingBase::Delete()
{
    __HCP_FUNC_ENTRY( "JetBlue::RecordBindingBase::Delete" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Initialize());

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_tbl->DeleteRecord());

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

JET_BEGIN_RECORDBINDING(Taxonomy::RS_DBParameters)
    JET_FIELD_BYNAME_NOTNULL("Name" ,wstring,m_strName                 ),
    JET_FIELD_BYNAME        ("Value",wstring,m_strValue,m_fValid__Value),
JET_END_RECORDBINDING(Taxonomy::RS_DBParameters)

HRESULT Taxonomy::RS_DBParameters::Seek_ByName( /*[in]*/ LPCWSTR szName, /*[in]*/ bool *pfFound )
{
    HRESULT     hr;
    CComVariant v( szName );

    if(FAILED(hr = SelectIndex( GET_IDX_NAME( DbParameters, ByName ), JET_bitNoMove ))) return hr;

    return Seek( JET_bitSeekEQ, &v, 1, pfFound );
}

////////////////////

JET_BEGIN_RECORDBINDING(Taxonomy::RS_ContentOwners)
    JET_FIELD_BYNAME_NOTNULL("DN"      ,wstring,m_strDN   ),
    JET_FIELD_BYNAME_NOTNULL("ID_owner",long   ,m_ID_owner),
    JET_FIELD_BYNAME_NOTNULL("IsOEM"   ,bool   ,m_fIsOEM  ),
JET_END_RECORDBINDING(Taxonomy::RS_ContentOwners)

HRESULT Taxonomy::RS_ContentOwners::Seek_ByVendorID( /*[in]*/ LPCWSTR szDN, /*[in]*/ bool *pfFound )
{
    HRESULT     hr;
    CComVariant v( szDN );

    if(FAILED(hr = SelectIndex( GET_IDX_NAME( ContentOwners, ByVendorID ), JET_bitNoMove ))) return hr;

    return Seek( JET_bitSeekEQ, &v, 1, pfFound );
}

////////////////////

JET_BEGIN_RECORDBINDING(Taxonomy::RS_SynSets)
    JET_FIELD_BYNAME_NOTNULL("Name"     ,wstring,m_strName  ),
    JET_FIELD_BYNAME_NOTNULL("ID_owner" ,long   ,m_ID_owner ),
    JET_FIELD_BYNAME_NOTNULL("ID_synset",long   ,m_ID_synset),
JET_END_RECORDBINDING(Taxonomy::RS_SynSets)

HRESULT Taxonomy::RS_SynSets::Seek_ByPair( /*[in]*/ LPCWSTR szName, /*[in]*/ long ID_synset, /*[in]*/ bool *pfFound )
{
    HRESULT     hr;
    CComVariant v[] = { szName, ID_synset };

    if(FAILED(hr = SelectIndex( GET_IDX_NAME( SynSets, ByPair ), JET_bitNoMove ))) return hr;

    return Seek( JET_bitSeekEQ, v, 2, pfFound );
}

////////////////////

JET_BEGIN_RECORDBINDING(Taxonomy::RS_HelpImage)
    JET_FIELD_BYNAME_NOTNULL("ID_owner",long   ,m_ID_owner),
    JET_FIELD_BYNAME_NOTNULL("File"    ,wstring,m_strFile ),
JET_END_RECORDBINDING(Taxonomy::RS_HelpImage)

HRESULT Taxonomy::RS_HelpImage::Seek_ByFile( /*[in]*/ LPCWSTR szFile, /*[in]*/ bool *pfFound )
{
    HRESULT     hr;
    CComVariant v( szFile );

    if(FAILED(hr = SelectIndex( GET_IDX_NAME( HelpImage, ByFile ), JET_bitNoMove ))) return hr;

    return Seek( JET_bitSeekEQ, &v, 1, pfFound );
}

////////////////////

JET_BEGIN_RECORDBINDING(Taxonomy::RS_Scope)
    JET_FIELD_BYNAME_NOTNULL("ID_owner",long   ,m_ID_owner                      ),
    JET_FIELD_BYNAME_NOTNULL("ID_scope",long   ,m_ID_scope                      ),
    JET_FIELD_BYNAME_NOTNULL("ID"      ,wstring,m_strID                         ),
    JET_FIELD_BYNAME_NOTNULL("Name"    ,wstring,m_strName                       ),
    JET_FIELD_BYNAME        ("Category",wstring,m_strCategory,m_fValid__Category),
JET_END_RECORDBINDING(Taxonomy::RS_Scope)

HRESULT Taxonomy::RS_Scope::Seek_ByID( /*[in]*/ LPCWSTR szID, /*[in]*/ bool *pfFound )
{
    HRESULT     hr;
    CComVariant v( szID );

    if(FAILED(hr = SelectIndex( GET_IDX_NAME( Scope, ByID ), JET_bitNoMove ))) return hr;

    return Seek( JET_bitSeekEQ, &v, 1, pfFound );
}

HRESULT Taxonomy::RS_Scope::Seek_ByScope( /*[in]*/ long ID_scope, /*[in]*/ bool *pfFound )
{
    HRESULT     hr;
    CComVariant v( ID_scope );

    if(FAILED(hr = SelectIndex( GET_IDX_NAME( Scope, ByScope ), JET_bitNoMove ))) return hr;

    return Seek( JET_bitSeekEQ | JET_bitSetIndexRange, &v, 1, pfFound );
}

HRESULT Taxonomy::RS_Scope::Seek_OwnedScopes( /*[in]*/ long ID_owner, /*[in]*/ bool *pfFound )
{
    HRESULT     hr;
    CComVariant v( ID_owner );

    if(FAILED(hr = SelectIndex( GET_IDX_NAME( Scope, OwnedScopes ), JET_bitNoMove ))) return hr;

    return Seek( JET_bitSeekEQ | JET_bitSetIndexRange, &v, 1, pfFound );
}

////////////////////

JET_BEGIN_RECORDBINDING(Taxonomy::RS_IndexFiles)
    JET_FIELD_BYNAME_NOTNULL("ID_owner",long   ,m_ID_owner                    ),
    JET_FIELD_BYNAME_NOTNULL("ID_scope",long   ,m_ID_scope                    ),
    JET_FIELD_BYNAME        ("Storage" ,wstring,m_strStorage,m_fValid__Storage),
    JET_FIELD_BYNAME        ("File"    ,wstring,m_strFile   ,m_fValid__File   ),
JET_END_RECORDBINDING(Taxonomy::RS_IndexFiles)

HRESULT Taxonomy::RS_IndexFiles::Seek_ByScope( /*[in]*/ long ID_scope, /*[in]*/ bool *pfFound )
{
    HRESULT     hr;
    CComVariant v( ID_scope );

    if(FAILED(hr = SelectIndex( GET_IDX_NAME( IndexFiles, ByScope ), JET_bitNoMove ))) return hr;

    return Seek( JET_bitSeekEQ | JET_bitSetIndexRange, &v, 1, pfFound );
}

////////////////////

JET_BEGIN_RECORDBINDING(Taxonomy::RS_FullTextSearch)
    JET_FIELD_BYNAME_NOTNULL("ID_owner",long   ,m_ID_owner              ),
    JET_FIELD_BYNAME_NOTNULL("ID_scope",long   ,m_ID_scope              ),
    JET_FIELD_BYNAME        ("CHM"     ,wstring,m_strCHM  ,m_fValid__CHM),
    JET_FIELD_BYNAME        ("CHQ"     ,wstring,m_strCHQ  ,m_fValid__CHQ),
JET_END_RECORDBINDING(Taxonomy::RS_FullTextSearch)

HRESULT Taxonomy::RS_FullTextSearch::Seek_ByScope( /*[in]*/ long ID_scope, /*[in]*/ bool *pfFound )
{
    HRESULT     hr;
    CComVariant v( ID_scope );

    if(FAILED(hr = SelectIndex( GET_IDX_NAME( FullTextSearch, ByScope ), JET_bitNoMove ))) return hr;

    return Seek( JET_bitSeekEQ | JET_bitSetIndexRange, &v, 1, pfFound );
}

////////////////////

HRESULT Taxonomy::operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/ RS_Data_Taxonomy& val )
{
    __HCP_FUNC_ENTRY( "Taxonomy::RS_Data_Taxonomy::operator>>" );

    HRESULT hr;

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_ID_node          );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_lPos             );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_ID_parent        );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_ID_owner         );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_strEntry         );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_strTitle         );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_strDescription   );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_strDescriptionURI);
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_strIconURI       );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_fVisible         );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_fSubsite         );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_lNavModel        );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Taxonomy::operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const RS_Data_Taxonomy& val )
{
    __HCP_FUNC_ENTRY( "Taxonomy::RS_Data_Taxonomy::operator<<" );

    HRESULT hr;

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_ID_node          );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_lPos             );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_ID_parent        );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_ID_owner         );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_strEntry         );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_strTitle         );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_strDescription   );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_strDescriptionURI);
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_strIconURI       );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_fVisible         );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_fSubsite         );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_lNavModel        );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

JET_BEGIN_RECORDBINDING(Taxonomy::RS_Taxonomy)
    JET_FIELD_BYNAME_NOTNULL("ID_node"        ,long   ,m_ID_node         						   ),
    JET_FIELD_BYNAME_NOTNULL("Pos"            ,long   ,m_lPos            						   ),
    JET_FIELD_BYNAME        ("ID_parent"      ,long   ,m_ID_parent        ,m_fValid__ID_parent     ),
    JET_FIELD_BYNAME_NOTNULL("ID_owner"       ,long   ,m_ID_owner        						   ),
    JET_FIELD_BYNAME_NOTNULL("Entry"          ,wstring,m_strEntry                                  ),
    JET_FIELD_BYNAME        ("Title"          ,wstring,m_strTitle         ,m_fValid__Title         ),
    JET_FIELD_BYNAME        ("Description"    ,wstring,m_strDescription   ,m_fValid__Description   ),
    JET_FIELD_BYNAME        ("DescriptionURI" ,wstring,m_strDescriptionURI,m_fValid__DescriptionURI),
    JET_FIELD_BYNAME        ("IconURI"        ,wstring,m_strIconURI       ,m_fValid__IconURI       ),
    JET_FIELD_BYNAME_NOTNULL("Visible"        ,bool   ,m_fVisible                                  ),
    JET_FIELD_BYNAME_NOTNULL("Subsite"        ,bool   ,m_fSubsite                                  ),
    JET_FIELD_BYNAME_NOTNULL("NavModel"       ,long   ,m_lNavModel                                 ),
JET_END_RECORDBINDING(Taxonomy::RS_Taxonomy)

HRESULT Taxonomy::RS_Taxonomy::Seek_SubNode( /*[in]*/ long ID_parent, /*[in]*/ LPCWSTR szEntry, /*[in]*/ bool *pfFound )
{
    HRESULT     hr;
    CComVariant v[] = { ID_parent, szEntry };

    if(FAILED(hr = SelectIndex( GET_IDX_NAME( Taxonomy, SubNode ), JET_bitNoMove ))) return hr;

    if(ID_parent == -1) v[0].vt = VT_NULL;

    return Seek( JET_bitSeekEQ, v, 2, pfFound );
}

HRESULT Taxonomy::RS_Taxonomy::Seek_Children( /*[in]*/ long ID_parent, /*[in]*/ bool *pfFound )
{
    HRESULT     hr;
    CComVariant v( ID_parent );

    if(FAILED(hr = SelectIndex( GET_IDX_NAME( Taxonomy, Children ), JET_bitNoMove ))) return hr;

    if(ID_parent == -1) v.vt = VT_NULL;

    return Seek( JET_bitSeekEQ | JET_bitSetIndexRange, &v, 1, pfFound );
}

HRESULT Taxonomy::RS_Taxonomy::Seek_Node( /*[in]*/ long ID_node, /*[in]*/ bool *pfFound )
{
    HRESULT     hr;
    CComVariant v( ID_node );

    if(FAILED(hr = SelectIndex( GET_IDX_NAME( Taxonomy, Node ), JET_bitNoMove ))) return hr;

    return Seek( JET_bitSeekEQ, &v, 1, pfFound );
}

////////////////////

JET_BEGIN_RECORDBINDING(Taxonomy::RS_Topics)
    JET_FIELD_BYNAME_NOTNULL("ID_topic"   ,long   ,m_ID_topic                            ),
    JET_FIELD_BYNAME_NOTNULL("ID_node"    ,long   ,m_ID_node                             ),
    JET_FIELD_BYNAME_NOTNULL("ID_owner"   ,long   ,m_ID_owner                            ),
    JET_FIELD_BYNAME_NOTNULL("Pos"        ,long   ,m_lPos                                ),
    JET_FIELD_BYNAME        ("Title"      ,wstring,m_strTitle      ,m_fValid__Title      ),
    JET_FIELD_BYNAME        ("URI"        ,wstring,m_strURI        ,m_fValid__URI        ),
    JET_FIELD_BYNAME        ("Description",wstring,m_strDescription,m_fValid__Description),
    JET_FIELD_BYNAME        ("IconURI"    ,wstring,m_strIconURI    ,m_fValid__IconURI    ),
    JET_FIELD_BYNAME_NOTNULL("Type"       ,long   ,m_lType                               ),
    JET_FIELD_BYNAME_NOTNULL("Visible"    ,bool   ,m_fVisible                            ),
JET_END_RECORDBINDING(Taxonomy::RS_Topics)

HRESULT Taxonomy::RS_Topics::Seek_SingleTopic( /*[in]*/ long ID_topic, /*[in]*/ bool *pfFound )
{
    HRESULT     hr;
    CComVariant v( ID_topic );

    if(FAILED(hr = SelectIndex( GET_IDX_NAME( Topics, SingleTopic ), JET_bitNoMove ))) return hr;

    return Seek( JET_bitSeekEQ, &v, 1, pfFound );
}

HRESULT Taxonomy::RS_Topics::Seek_TopicsUnderNode( /*[in]*/ long ID_node, /*[in]*/ bool *pfFound )
{
    HRESULT     hr;
    CComVariant v( ID_node );

    if(FAILED(hr = SelectIndex( GET_IDX_NAME( Topics, TopicsUnderNode ), JET_bitNoMove ))) return hr;

    return Seek( JET_bitSeekEQ | JET_bitSetIndexRange, &v, 1, pfFound );
}

HRESULT Taxonomy::RS_Topics::Seek_ByURI( /*[in]*/ LPCWSTR szURI, /*[in]*/ bool *pfFound )
{
    HRESULT     hr;
    CComVariant v( szURI );

    if(FAILED(hr = SelectIndex( GET_IDX_NAME( Topics, ByURI ), JET_bitNoMove ))) return hr;

    return Seek( JET_bitSeekEQ | JET_bitSetIndexRange, &v, 1, pfFound );
}

////////////////////

JET_BEGIN_RECORDBINDING(Taxonomy::RS_Synonyms)
    JET_FIELD_BYNAME_NOTNULL("Keyword"  ,wstring,m_strKeyword),
    JET_FIELD_BYNAME_NOTNULL("ID_synset",long   ,m_ID_synset ),
    JET_FIELD_BYNAME_NOTNULL("ID_owner" ,long   ,m_ID_owner  ),
JET_END_RECORDBINDING(Taxonomy::RS_Synonyms)

HRESULT Taxonomy::RS_Synonyms::Seek_ByPair( /*[in]*/ LPCWSTR szKeyword, /*[in]*/ long ID_synset, /*[in]*/ bool *pfFound )
{
    HRESULT     hr;
    CComVariant v[] = { szKeyword, ID_synset };

    if(FAILED(hr = SelectIndex( GET_IDX_NAME( Synonyms, ByPair ), JET_bitNoMove ))) return hr;

    return Seek( JET_bitSeekEQ, v, 2, pfFound );
}

HRESULT Taxonomy::RS_Synonyms::Seek_ByName( /*[in]*/ LPCWSTR szKeyword, /*[in]*/ bool *pfFound )
{
    HRESULT     hr;
    CComVariant v( szKeyword );

    if(FAILED(hr = SelectIndex( GET_IDX_NAME( Synonyms, ByName ), JET_bitNoMove ))) return hr;

    return Seek( JET_bitSeekEQ | JET_bitSetIndexRange, &v, 1, pfFound );
}

////////////////////

JET_BEGIN_RECORDBINDING(Taxonomy::RS_Keywords)
    JET_FIELD_BYNAME_NOTNULL("Keyword"   ,wstring,m_strKeyword),
    JET_FIELD_BYNAME_NOTNULL("ID_keyword",long   ,m_ID_keyword),
JET_END_RECORDBINDING(Taxonomy::RS_Keywords)

HRESULT Taxonomy::RS_Keywords::Seek_ByName( /*[in]*/ LPCWSTR szKeyword, /*[in]*/ bool *pfFound )
{
    HRESULT     hr;
    CComVariant v( szKeyword );

    if(FAILED(hr = SelectIndex( GET_IDX_NAME( Keywords, ByName ), JET_bitNoMove ))) return hr;

    return Seek( JET_bitSeekEQ, &v, 1, pfFound );
}

////////////////////

JET_BEGIN_RECORDBINDING(Taxonomy::RS_Matches)
    JET_FIELD_BYNAME_NOTNULL("ID_topic"  ,long,m_ID_topic  ),
    JET_FIELD_BYNAME_NOTNULL("ID_keyword",long,m_ID_keyword),
    JET_FIELD_BYNAME_NOTNULL("Priority"  ,long,m_lPriority ),
    JET_FIELD_BYNAME_NOTNULL("HHK"       ,bool,m_fHHK      ),
JET_END_RECORDBINDING(Taxonomy::RS_Matches)

HRESULT Taxonomy::RS_Matches::Seek_Pair( /*[in]*/ long ID_keyword, /*[in]*/ long ID_topic, /*[in]*/ bool *pfFound )
{
    HRESULT     hr;
    CComVariant v[2] = { ID_keyword, ID_topic };

    if(FAILED(hr = SelectIndex( GET_IDX_NAME( Matches, Pair ), JET_bitNoMove ))) return hr;

    return Seek( JET_bitSeekEQ, v, 2, pfFound );
}

HRESULT Taxonomy::RS_Matches::Seek_ByKeyword( /*[in]*/ long ID_keyword, /*[in]*/ bool *pfFound )
{
    HRESULT     hr;
    CComVariant v( ID_keyword );

    if(FAILED(hr = SelectIndex( GET_IDX_NAME( Matches, ByKeyword ), JET_bitNoMove ))) return hr;

    return Seek( JET_bitSeekEQ | JET_bitSetIndexRange, &v, 1, pfFound );
}

HRESULT Taxonomy::RS_Matches::Seek_ByTopic( /*[in]*/ long ID_topic, /*[in]*/ bool *pfFound )
{
    HRESULT     hr;
    CComVariant v( ID_topic );

    if(FAILED(hr = SelectIndex( GET_IDX_NAME( Matches, ByTopic ), JET_bitNoMove ))) return hr;

    return Seek( JET_bitSeekEQ | JET_bitSetIndexRange, &v, 1, pfFound );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\jetblue\lowlevel\stdafx.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    StdAfx.h

Abstract:
    Precompiled header.

Revision History:
    Davide Massarenti   (Dmassare)  03/16/2000
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__412B7974_2F00_11D3_9A30_00C04F72D6C5__INCLUDED_)
#define AFX_STDAFX_H__412B7974_2F00_11D3_9A30_00C04F72D6C5__INCLUDED_

#include <module.h>

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>


//
// For debug trace
//
#include <HCP_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_COM.h>
#include <MPC_config.h>


#include <JetBlueLib.h>


//
// Localized strings functions.
//
#include <locres.h>

//
// Localized strings IDs.
//
#include <HCAppRes.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__412B7974_2F00_11D3_9A30_00C04F72D6C5__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\jetblue\lowlevel\session.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Session.cpp

Abstract:
    This file contains the implementation of the JetBlue::Session* classes.

Revision History:
    Davide Massarenti   (Dmassare)  05/17/2000
        created

******************************************************************************/

#include <stdafx.h>

////////////////////////////////////////////////////////////////////////////////

JetBlue::Session::Session( /*[in]*/ SessionPool* parent ,
                           /*[in]*/ JET_INSTANCE inst   )
{
    m_parent 			   = parent;       // SessionPool* m_parent;
    m_inst   			   = inst;         // JET_INSTANCE m_inst;
    m_sesid  			   = JET_sesidNil; // JET_SESID    m_sesid;
             							   // DbMap        m_mapDBs;
	m_dwTransactionNesting = 0;            // DWORD        m_dwTransactionNesting;
	m_fAborted             = false;        // bool         m_fAborted;
}

JetBlue::Session::~Session()
{
    (void)Close( true );
}

////////////////////////////////////////

bool 	JetBlue::Session::LockDatabase   ( /*[in]*/ const MPC::string& strDB, /*[in]*/ bool fReadOnly ) { return m_parent->LockDatabase   ( this, strDB, fReadOnly ); }
void 	JetBlue::Session::UnlockDatabase ( /*[in]*/ const MPC::string& strDB                          ) {        m_parent->UnlockDatabase ( this, strDB            ); }
HRESULT JetBlue::Session::ReleaseDatabase( /*[in]*/ const MPC::string& strDB                          ) { return m_parent->ReleaseDatabase(       strDB.c_str()    ); }

////////////////////////////////////////

HRESULT JetBlue::Session::Init()
{
    __HCP_FUNC_ENTRY( "JetBlue::Session::Init" );

    HRESULT hr;


    if(m_sesid == JET_sesidNil)
    {
        __MPC_EXIT_IF_JET_FAILS(hr, ::JetBeginSession( m_inst, &m_sesid, NULL, NULL ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::Session::Close( /*[in]*/ bool fForce )
{
    __HCP_FUNC_ENTRY( "JetBlue::Session::Close" );

    HRESULT hr;
    DbIter  it;


    for(it = m_mapDBs.begin(); it != m_mapDBs.end(); it++)
    {
        Database* db = it->second;

        if(db)
        {
            HRESULT hr2 = db->Close( fForce ); if(!fForce) __MPC_EXIT_IF_METHOD_FAILS(hr, hr2);

            delete db;
        }
    }
    m_mapDBs.clear();


    if(m_sesid != JET_sesidNil)
    {
        JET_ERR err = ::JetEndSession( m_sesid, 0 ); if(!fForce) __MPC_EXIT_IF_JET_FAILS(hr, err);

        m_sesid = JET_sesidNil;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void JetBlue::Session::Release()
{
	if(m_fAborted)
	{
		DbIter it;

		for(it = m_mapDBs.begin(); it != m_mapDBs.end(); it++)
		{
			Database* db = it->second;
					
			if(db)
			{
				db->Close( /*fForce*/true, /*fAll*/false );
			}
		}

		__MPC_JET__MTSAFE_NORESULT(m_sesid, ::JetRollback( m_sesid, JET_bitRollbackAll ));

		m_fAborted = false;
	}
}

////////////////////////////////////////

HRESULT JetBlue::Session::GetDatabase( /*[in] */ LPCSTR     szName    ,
                                       /*[out]*/ Database*& db        ,
                                       /*[in]*/  bool       fReadOnly ,
                                       /*[in]*/  bool       fCreate   ,
                                       /*[in]*/  bool       fRepair   )
{
    __HCP_FUNC_ENTRY( "JetBlue::Session::GetDatabase" );

    HRESULT   hr;
    Database* dbNew = NULL;
    DbIter    it;


    db = NULL;


    it = m_mapDBs.find( szName );
    if(it == m_mapDBs.end())
    {
        __MPC_EXIT_IF_ALLOC_FAILS(hr, dbNew, new Database( this, m_sesid, szName ));

        m_mapDBs[szName] = dbNew;

        db = dbNew; dbNew = NULL;
    }
    else
    {
        db = it->second;
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, db->Open( fReadOnly, fCreate, fRepair ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(dbNew) delete dbNew;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

HRESULT JetBlue::Session::BeginTransaction()
{
    __HCP_FUNC_ENTRY( "JetBlue::Session::BeginTransaction" );

    HRESULT hr;

    __MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetBeginTransaction( m_sesid ));

	m_dwTransactionNesting++;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::Session::CommitTransaction()
{
    __HCP_FUNC_ENTRY( "JetBlue::Session::CommitTransaction" );

    HRESULT hr;

	if(m_dwTransactionNesting > 0)
	{
		__MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetCommitTransaction( m_sesid, JET_bitCommitLazyFlush ));

		m_dwTransactionNesting--;
	}


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::Session::RollbackTransaction()
{
    __HCP_FUNC_ENTRY( "JetBlue::Session::RollbackTransaction" );

    HRESULT hr;

	if(m_dwTransactionNesting > 0)
	{
		m_fAborted = true;

		__MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetRollback( m_sesid, 0 ));

		m_dwTransactionNesting--;
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

JetBlue::Database* JetBlue::Session::GetDB( /*[in]*/ int iPos )
{
    for(DbIter it = m_mapDBs.begin(); it != m_mapDBs.end(); it++)
    {
        if(iPos-- == 0) return it->second;
    }

    return NULL;
}

JetBlue::Database* JetBlue::Session::GetDB( LPCSTR szDB )
{
    DbIter it = m_mapDBs.find( szDB );

    return (it == m_mapDBs.end()) ? NULL : it->second;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

JetBlue::TransactionHandle::TransactionHandle()
{
    m_sess = NULL; // Session* m_sess;
}

JetBlue::TransactionHandle::~TransactionHandle()
{
    (void)Rollback();
}

HRESULT JetBlue::TransactionHandle::Begin( /*[in]*/ Session* sess )
{
	__HCP_FUNC_ENTRY( "JetBlue::TransactionHandle::Begin" );

	HRESULT hr;

	__MPC_EXIT_IF_METHOD_FAILS(hr, Rollback());

	if(sess)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, sess->BeginTransaction());

		m_sess = sess;
	}

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::TransactionHandle::Commit()
{
	__HCP_FUNC_ENTRY( "JetBlue::TransactionHandle::Commit" );

	HRESULT hr;

	if(m_sess)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, m_sess->CommitTransaction());

		m_sess = NULL;
	}

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::TransactionHandle::Rollback()
{
	__HCP_FUNC_ENTRY( "JetBlue::TransactionHandle::Rollback" );

	HRESULT hr;

	if(m_sess)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, m_sess->RollbackTransaction());

		m_sess = NULL;
	}

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

JetBlue::SessionHandle::SessionHandle()
{
    m_pool = NULL; // SessionPool* m_pool;
    m_sess = NULL; // Session*     m_sess;
}

JetBlue::SessionHandle::~SessionHandle()
{
    Release();
}

////////////////////////////////////////

void JetBlue::SessionHandle::Release()
{
    if(m_pool)
    {
        m_pool->ReleaseSession( m_sess );

        m_pool = NULL;
    }

    m_sess = NULL;
}

void JetBlue::SessionHandle::Init( /*[in]*/ SessionPool* pool ,
                                   /*[in]*/ Session*     sess )
{
    Release();

    m_pool = pool; // SessionPool* m_pool;
    m_sess = sess; // Session*     m_sess;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

JetBlue::SessionPool::SessionPool()
{
    m_fInitialized = false;           // bool         m_fInitialized;
    m_inst         = JET_instanceNil; // JET_INSTANCE m_inst;
                                      // SessionList  m_lstSessions;
                                      // DbInUseList  m_lstDbInUse;
    m_iAllocated   = 0;               // int          m_iAllocated;
    m_iInUse       = 0;               // int          m_iInUse;

    (void)MPC::_MPC_Module.RegisterCallback( this, (void (JetBlue::SessionPool::*)())Shutdown );
}

JetBlue::SessionPool::~SessionPool()
{
    MPC::_MPC_Module.UnregisterCallback( this );

	Shutdown();
}

////////////////////

JetBlue::SessionPool* JetBlue::SessionPool::s_GLOBAL( NULL );

HRESULT JetBlue::SessionPool::InitializeSystem()
{
	if(s_GLOBAL == NULL)
	{
		s_GLOBAL = new JetBlue::SessionPool;
	}

	return s_GLOBAL ? S_OK : E_OUTOFMEMORY;
}

void JetBlue::SessionPool::FinalizeSystem()
{
	if(s_GLOBAL)
	{
		delete s_GLOBAL; s_GLOBAL = NULL;
	}
}

////////////////////

void JetBlue::SessionPool::Shutdown()
{
    (void)Close( true );
}
	
////////////////////////////////////////

void JetBlue::SessionPool::ReleaseSession( /*[in]*/ Session* sess )
{
    MPC::SmartLock<_ThreadModel> lock( this );
    SessionIter                  it;


    for(it = m_lstSessions.begin(); it != m_lstSessions.end(); it++)
    {
        if(it->m_sess == sess)
        {
			sess->Release();

            it->m_fInUse = false; m_iInUse--;

			if(m_iAllocated - m_iInUse > l_MaxFreePoolSize)
            {
                m_lstSessions.erase( it ); m_iAllocated--;
            }

            break;
        }
    }
}

bool JetBlue::SessionPool::LockDatabase( /*[in]*/ Session* sess, /*[in]*/ const MPC::string& strDB, /*[in]*/ bool fReadOnly )
{
    MPC::SmartLock<_ThreadModel> lock( this );
    DbInUseIter                  it;
	bool 						 fLockedForRead  = false;
	bool 						 fLockedForWrite = false;


	for(it = m_lstDbInUse.begin(); it != m_lstDbInUse.end(); it++)
	{
		DatabaseInUse& db = *it;

		if(db.m_strDB == strDB)
		{
			if(db.m_fReadOnly) fLockedForRead  = true;
			else               fLockedForWrite = true;
		}
	}

	if(fLockedForRead && !fReadOnly) return false;      // Someone has the database opened in read-only mode...
	if(fLockedForWrite             ) fReadOnly = false; // The database is already opened for writing, so do the same.

    for(it = m_lstDbInUse.begin(); it != m_lstDbInUse.end(); it++)
    {
        DatabaseInUse& db = *it;

        if(db.m_sess  == sess  &&
           db.m_strDB == strDB  )
        {
            return true; // Already locked.
        }
    }

    //
    // Create new entry.
    //
    it = m_lstDbInUse.insert( m_lstDbInUse.end() );

    it->m_sess  	= sess;
    it->m_strDB 	= strDB;
	it->m_fReadOnly = fReadOnly;

	return true;
}

void JetBlue::SessionPool::UnlockDatabase( /*[in]*/ Session* sess, /*[in]*/ const MPC::string& strDB )
{
    MPC::SmartLock<_ThreadModel> lock( this );
    DbInUseIter                  it     = m_lstDbInUse.begin();
	bool                         fInUse = false;
	bool                         fSeen  = false;
	
    while(it != m_lstDbInUse.end())
    {
		DbInUseIter    it2 =  it++; // Copy iterator and move to the next one. This protects us from node removal.
        DatabaseInUse& db  = *it2;

        if(db.m_strDB == strDB)
        {
			fSeen = true;

			if(db.m_sess == sess)
			{
				m_lstDbInUse.erase( it2 );
			}
			else
			{
				fInUse = true;
			}
		}
    }

	//
	// Last session to release the database, detach from it.
	//
	if(fSeen && !fInUse)
	{
		(void)::JetDetachDatabase( sess->GetSESID(), strDB.c_str() );
	}
}

HRESULT JetBlue::SessionPool::ReleaseDatabase( /*[in]*/ LPCSTR szDB )
{
    __HCP_FUNC_ENTRY( "JetBlue::SessionPool::ReleaseDatabase" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock ( this );
    MPC::string                  strDB( szDB );
    DbInUseIter                  it;


    for(it = m_lstDbInUse.begin(); it != m_lstDbInUse.end();)
    {
        DatabaseInUse& db = *it;

        if(db.m_strDB == strDB)
        {
            SessionIter it2;

            for(it2 = m_lstSessions.begin(); it2 != m_lstSessions.end(); it2++)
            {
                if(it2->m_sess == db.m_sess) break;
            }

            if(it2 != m_lstSessions.end())
            {
                if(it2->m_fInUse)
                {
                    __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_BUSY);
                }

                m_lstSessions.erase( it2 ); m_iAllocated--;

                //
                // The list of databases in use has been changed by the delete operator.
                //
                it = m_lstDbInUse.begin(); continue;
            }
        }

        it++;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

HRESULT JetBlue::SessionPool::Init( /*[in]*/ LPCWSTR szLogs )
{
    __HCP_FUNC_ENTRY( "JetBlue::SessionPool::Init" );

    USES_CONVERSION;

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

    if(m_fInitialized == false)
    {
		static const JET_SETSYSPARAM sConfig_Normal[] =
		{
			//unsigned long paramid 	 , ULONG_PTR lParam, const char *sz, JET_ERR err
#ifdef DEBUG	 
			{ JET_paramAssertAction 	 , JET_AssertMsgBox, NULL          , JET_errSuccess },
#endif	   
			{ JET_paramSystemPath   	 , 0               , (LPSTR)-1     , JET_errSuccess },
			{ JET_paramTempPath     	 , 0               , (LPSTR)-1     , JET_errSuccess },
			{ JET_paramLogFilePath  	 , 0               , (LPSTR)-1     , JET_errSuccess },
			{ JET_paramBaseName     	 , 0               , "edb"         , JET_errSuccess },
			{ JET_paramEventSource  	 , 0               , "HelpSvc.exe" , JET_errSuccess },
			{ JET_paramNoInformationEvent, 1               , NULL          , JET_errSuccess },
			{ JET_paramGlobalMinVerPages , 1               , NULL          , JET_errSuccess },
			{ JET_paramMaxVerPages       , 1024            , NULL          , JET_errSuccess },
			{ JET_paramCacheSizeMax 	 , 1024            , NULL          , JET_errSuccess },
////		{ JET_paramLogFileSize  	 , 128             , NULL          , JET_errSuccess },
////		{ JET_paramCircularLog  	 , 1               , NULL          , JET_errSuccess },
			
			{ -1                                                                            }
		};

		static const JET_SETSYSPARAM sConfig_LargeSet[] =
		{
			//unsigned long paramid 	 , ULONG_PTR lParam, const char *sz, JET_ERR err
#ifdef DEBUG	 
			{ JET_paramAssertAction 	 , JET_AssertMsgBox, NULL          , JET_errSuccess },
#endif	   
			{ JET_paramSystemPath   	 , 0               , (LPSTR)-1     , JET_errSuccess },
			{ JET_paramTempPath     	 , 0               , (LPSTR)-1     , JET_errSuccess },
			{ JET_paramLogFilePath  	 , 0               , (LPSTR)-1     , JET_errSuccess },
			{ JET_paramBaseName     	 , 0               , "edb"         , JET_errSuccess },
			{ JET_paramEventSource  	 , 0               , "HelpSvc.exe" , JET_errSuccess },
			{ JET_paramNoInformationEvent, 1               , NULL          , JET_errSuccess },
			{ JET_paramGlobalMinVerPages , 64              , NULL          , JET_errSuccess },
			{ JET_paramMaxVerPages       , 2048            , NULL          , JET_errSuccess },
			{ JET_paramCacheSizeMax 	 , 4096            , NULL          , JET_errSuccess },
////		{ JET_paramLogFileSize  	 , 1024            , NULL          , JET_errSuccess },
////		{ JET_paramCircularLog  	 , 0               , NULL          , JET_errSuccess },

			{ -1                                                                            }
		};

		////////////////////

        MPC::wstring 		   strDir;
        LPCSTR       		   szDirAnsi;
		const JET_SETSYSPARAM* pParam;
		JET_ERR                err;


		if(szLogs == NULL)
		{
			szLogs = HC_ROOT_HELPSVC_CONFIG L"\\CheckPoint\\";
			pParam = sConfig_Normal;
		}
		else
		{
			pParam = sConfig_LargeSet;
		}


		MPC::SubstituteEnvVariables( strDir = szLogs ); szDirAnsi = W2A( strDir.c_str() );

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MakeDir( strDir ));

		::JetSetSystemParameter( &m_inst, 0, JET_paramRecovery, 0, "off" );

        while(pParam->paramid != -1)
        {
			JET_SETSYSPARAM param = *pParam++;
			JET_ERR         err;

            if(param.sz == (LPSTR)-1)
            {
                param.sz = szDirAnsi;
            }

			err = ::JetSetSystemParameter( &m_inst, 0, param.paramid, param.lParam, param.sz );
			if(err == JET_errInvalidParameter) continue; // Ignore version problems.

			__MPC_EXIT_IF_JET_FAILS(hr, err);
		}


		err = ::JetInit( &m_inst );

		//
		// If it's a log problem, delete the log files and retry.
		//
		if(err >= JET_errSoftRecoveryOnSnapshot &&
		   err <= JET_errInvalidLoggedOperation  )
		{
			MPC::FileSystemObject fso( strDir.c_str() );

			__MPC_EXIT_IF_METHOD_FAILS(hr, fso.DeleteChildren( true, false ));

			err = ::JetInit( &m_inst );
		}

		__MPC_EXIT_IF_JET_FAILS(hr, err);

        m_fInitialized = true;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::SessionPool::Close( /*[in]*/ bool fForce )
{
    __HCP_FUNC_ENTRY( "JetBlue::SessionPool::Close" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


    while(m_lstSessions.size() > 0)
    {
        SessionState& ss = m_lstSessions.front();

		if(ss.m_sess)
		{
			HRESULT hr2 = ss.m_sess->Close( fForce ); if(!fForce) __MPC_EXIT_IF_JET_FAILS(hr, hr2);
		}

        m_lstSessions.pop_front();
    }


    if(m_fInitialized)
    {
        JET_ERR err = ::JetTerm2( m_inst, JET_bitTermComplete ); if(!fForce) __MPC_EXIT_IF_JET_FAILS(hr, err);

        m_inst         = JET_instanceNil;
        m_fInitialized = false;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT JetBlue::SessionPool::GetSession( /*[out]*/ SessionHandle& handle    ,
                                          /*[in]*/  DWORD          dwTimeout )
{
    __HCP_FUNC_ENTRY( "JetBlue::SessionPool::GetSession" );

    HRESULT                      hr;
    SessionIter                  it;
    Session*                     sess = NULL;
    MPC::SmartLock<_ThreadModel> lock( this );

    handle.Release();

    __MPC_EXIT_IF_METHOD_FAILS(hr, Init());


    while(1)
    {
        if(m_iAllocated > m_iInUse)
        {
            //
            // Look for free session.
            //
            for(it = m_lstSessions.begin(); it != m_lstSessions.end(); it++)
            {
                if(it->m_fInUse == false)
                {
                    it->m_fInUse = true; m_iInUse++;

                    handle.Init( this, it->m_sess );

                    __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
                }
            }
        }

        //
        // No free session, but still below maximum number of sessions, so let's create a new one.
        //
        if(m_iAllocated < l_MaxPoolSize)
        {
            __MPC_EXIT_IF_ALLOC_FAILS(hr, sess, new Session( this, m_inst ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, sess->Init());

            it = m_lstSessions.insert(  m_lstSessions.end() ); m_iAllocated++;

            it->m_sess   = sess; sess = NULL;
            it->m_fInUse = true; m_iInUse++;

            handle.Init( this, it->m_sess );

            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }

        //
        // Out of resources, wait for other threads to release them...
        //
        if(dwTimeout == 0)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, ERROR_NO_SYSTEM_RESOURCES);
        }

        lock = NULL;

        ::Sleep( 100 );
        if(dwTimeout < 100) dwTimeout  =   0;
        else                dwTimeout -= 100;

        lock = this;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(sess) delete sess;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\jetblue\lowlevel\table.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Table.cpp

Abstract:
    This file contains the implementation of the JetBlue::Table class.

Revision History:
    Davide Massarenti   (Dmassare)  05/17/2000
        created

******************************************************************************/

#include <stdafx.h>

////////////////////////////////////////////////////////////////////////////////

static HRESULT AdjustReturnCode( HRESULT hr, bool *pfFound )
{
    if(pfFound)
    {
        if(hr == JetBlue::JetERRToHRESULT(JET_errNoCurrentRecord) ||
           hr == JetBlue::JetERRToHRESULT(JET_errRecordNotFound )  )
        {
            hr       = S_OK;
            *pfFound = false;
        }
        else
        {
            *pfFound = (SUCCEEDED(hr)) ? true : false;
        }
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////

JetBlue::Table::Table()
{
    m_sesid   = JET_sesidNil;   // JET_SESID    m_sesid;
    m_dbid    = JET_dbidNil;    // JET_DBID     m_dbid;
    m_tableid = JET_tableidNil; // JET_TABLEID  m_tableid;
                                // MPC::string  m_strName;
                                // ColumnVector m_vecColumns;
                                // IndexVector  m_vecIndexes;
    m_idxSelected = NULL;       // Index*       m_idxSelected;
                                // Column       m_fakeCol;
                                // Index        m_fakeIdx;
}

JetBlue::Table::Table( /*[in]*/ JET_SESID sesid  ,
                       /*[in]*/ JET_DBID  dbid   ,
                       /*[in]*/ LPCSTR    szName )
{
    m_sesid   = sesid;          // JET_SESID    m_sesid;
    m_dbid    = dbid;           // JET_DBID     m_dbid;
    m_tableid = JET_tableidNil; // JET_TABLEID  m_tableid;
    m_strName = szName;         // MPC::string  m_strName;
                                // ColumnVector m_vecColumns;
                                // IndexVector  m_vecIndexes;
    m_idxSelected = NULL;       // Index*       m_idxSelected;
                                // Column       m_fakeCol;
                                // Index        m_fakeIdx;
}

JetBlue::Table::~Table()
{
    (void)Close( true );
}

////////////////////////////////////////

HRESULT JetBlue::Table::Duplicate( /*[in]*/ Table& tbl )
{
    __HCP_FUNC_ENTRY( "JetBlue::Table::Duplicate" );

    HRESULT hr;
    int     iColMax = tbl.m_vecColumns.size();
    int     iIdxMax = tbl.m_vecIndexes.size();
    int     iCol;
    int     iIdx;


    m_sesid   = tbl.m_sesid;        // JET_SESID    m_sesid;
    m_dbid    = tbl.m_dbid;         // JET_DBID     m_dbid;
    m_tableid = JET_tableidNil;     // JET_TABLEID  m_tableid;
    m_strName.erase();              // MPC::string  m_strName;
    m_vecColumns.resize( iColMax ); // ColumnVector m_vecColumns;
    m_vecIndexes.resize( iIdxMax ); // IndexVector  m_vecIndexes;
                                    // Column       m_fakeCol;
                                    // Index        m_fakeIdx;


    __MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetDupCursor( m_sesid, tbl.m_tableid, &m_tableid, 0 ));


    //
    // Copy the columns and indexes, updating the tableid.
    //
    for(iCol=0; iCol<iColMax; iCol++)
    {
        Column& colSrc = tbl.m_vecColumns[iCol];
        Column& colDst =     m_vecColumns[iCol];

        colDst.m_sesid   =        m_sesid;   // JET_SESID     m_sesid;
        colDst.m_tableid =        m_tableid; // JET_TABLEID   m_tableid;
        colDst.m_strName = colSrc.m_strName; // MPC::string   m_strName;
        colDst.m_coldef  = colSrc.m_coldef;  // JET_COLUMNDEF m_coldef;
    }

    for(iIdx=0; iIdx<iIdxMax; iIdx++)
    {
        Index& idxSrc = tbl.m_vecIndexes[iIdx];
        Index& idxDst =     m_vecIndexes[iIdx];

        idxDst.m_sesid      =        m_sesid;       // JET_SESID     m_sesid;
        idxDst.m_tableid    =        m_tableid;     // JET_TABLEID   m_tableid;
        idxDst.m_strName    = idxSrc.m_strName;     // MPC::string   m_strName;
        idxDst.m_grbitIndex = idxSrc.m_grbitIndex;  // JET_GRBIT     m_grbitIndex;
        idxDst.m_cKey       = idxSrc.m_cKey;        // LONG          m_cKey;
        idxDst.m_cEntry     = idxSrc.m_cEntry;      // LONG          m_cEntry;
        idxDst.m_cPage      = idxSrc.m_cPage;       // LONG          m_cPage;
                                                    // ColumnVector  m_vecColumns;
                                                    // Column        m_fake;


        iColMax = idxSrc.m_vecColumns.size();
        idxDst.m_vecColumns.resize( iColMax );


        for(iCol=0; iCol<iColMax; iCol++)
        {
            Column& colSrc = idxSrc.m_vecColumns[iCol];
            Column& colDst = idxDst.m_vecColumns[iCol];

            colDst.m_sesid   =        m_sesid;   // JET_SESID     m_sesid;
            colDst.m_tableid =        m_tableid; // JET_TABLEID   m_tableid;
			colDst.m_strName = colSrc.m_strName; // MPC::string   m_strName;
            colDst.m_coldef  = colSrc.m_coldef;  // JET_COLUMNDEF m_coldef;
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


HRESULT JetBlue::Table::Refresh()
{
    __HCP_FUNC_ENTRY( "JetBlue::Table::Refresh" );

    HRESULT        hr;
    JET_COLUMNLIST infoCols; ::ZeroMemory( &infoCols, sizeof(infoCols) ); infoCols.cbStruct = sizeof(infoCols); infoCols.tableid  = JET_tableidNil;
    JET_INDEXLIST  infoIdxs; ::ZeroMemory( &infoIdxs, sizeof(infoIdxs) ); infoIdxs.cbStruct = sizeof(infoIdxs); infoIdxs.tableid  = JET_tableidNil;


    m_vecColumns.clear();


    if(m_tableid != JET_tableidNil)
    {
        ////////////////////////////////////////////////////////////////////////////////
        //
        // Read column definition.
        //
        // JET_COLUMNLIST
        // {
        //     unsigned long    cbStruct;
        //     JET_TABLEID      tableid;
        //     unsigned long    cRecord;
        //     JET_COLUMNID columnidPresentationOrder;
        //     JET_COLUMNID columnidcolumnname;
        //     JET_COLUMNID columnidcolumnid;
        //     JET_COLUMNID columnidcoltyp;
        //     JET_COLUMNID columnidCountry;
        //     JET_COLUMNID columnidLangid;
        //     JET_COLUMNID columnidCp;
        //     JET_COLUMNID columnidCollate;
        //     JET_COLUMNID columnidcbMax;
        //     JET_COLUMNID columnidgrbit;
        //     JET_COLUMNID columnidDefault;
        //     JET_COLUMNID columnidBaseTableName;
        //     JET_COLUMNID columnidBaseColumnName;
        //     JET_COLUMNID columnidDefinitionName;
        // }
        //
        // JET_COLUMNDEF
        // {
        //     unsigned long   cbStruct;
        //     JET_COLUMNID    columnid;
        //     JET_COLTYP      coltyp;
        //     unsigned short  wCountry;
        //     unsigned short  langid;
        //     unsigned short  cp;
        //     unsigned short  wCollate;       /* Must be 0 */
        //     unsigned long   cbMax;
        //     JET_GRBIT       grbit;
        // };
        //
        // JET_RETRIEVECOLUMN
        // {
        //     JET_COLUMNID        columnid;
        //     void                *pvData;
        //     unsigned long       cbData;
        //     unsigned long       cbActual;
        //     JET_GRBIT           grbit;
        //     unsigned long       ibLongValue;
        //     unsigned long       itagSequence;
        //     JET_COLUMNID        columnidNextTagged;
        //     JET_ERR             err;
        // };
        {
            JET_RETRIEVECOLUMN rc     [9               ]; ::ZeroMemory( &rc, sizeof(rc) );
            char               colName[JET_cbNameMost+1];
            JET_COLUMNDEF      colDef;
            int                i;


#ifdef USE_WHISTLER_VERSION
            __MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetGetTableColumnInfo( m_sesid, m_tableid, NULL, &infoCols, sizeof(infoCols), JET_ColInfoListSortColumnid ));
#else
            __MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetGetTableColumnInfo( m_sesid, m_tableid, NULL, &infoCols, sizeof(infoCols), JET_ColInfoList ));
#endif


            __MPC_JET_INIT_RETRIEVE_COL( rc, 0, infoCols.columnidcolumnname,  colName        ,    JET_cbNameMost          );
            __MPC_JET_INIT_RETRIEVE_COL( rc, 1, infoCols.columnidcolumnid  , &colDef.columnid,    sizeof(colDef.columnid) );
            __MPC_JET_INIT_RETRIEVE_COL( rc, 2, infoCols.columnidcoltyp    , &colDef.coltyp  ,    sizeof(colDef.coltyp  ) );
            __MPC_JET_INIT_RETRIEVE_COL( rc, 3, infoCols.columnidCountry   , &colDef.wCountry,    sizeof(colDef.wCountry) );
            __MPC_JET_INIT_RETRIEVE_COL( rc, 4, infoCols.columnidLangid    , &colDef.langid  ,    sizeof(colDef.langid  ) );
            __MPC_JET_INIT_RETRIEVE_COL( rc, 5, infoCols.columnidCp        , &colDef.cp      ,    sizeof(colDef.cp      ) );
            __MPC_JET_INIT_RETRIEVE_COL( rc, 6, infoCols.columnidCollate   , &colDef.wCollate,    sizeof(colDef.wCollate) );
            __MPC_JET_INIT_RETRIEVE_COL( rc, 7, infoCols.columnidcbMax     , &colDef.cbMax   ,    sizeof(colDef.cbMax   ) );
            __MPC_JET_INIT_RETRIEVE_COL( rc, 8, infoCols.columnidgrbit     , &colDef.grbit   ,    sizeof(colDef.grbit   ) );


            m_vecColumns.resize( infoCols.cRecord );
            for(i=0; i<infoCols.cRecord; i++)
            {
                Column& col = m_vecColumns[i];

                 ::ZeroMemory(  colName, sizeof(colName) );
                 ::ZeroMemory( &colDef , sizeof(colDef ) );

                __MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetMove           ( m_sesid, infoCols.tableid, (i == 0 ? JET_MoveFirst : JET_MoveNext), 0 ));
                __MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetRetrieveColumns( m_sesid, infoCols.tableid, rc, ARRAYSIZE(rc)                          ));

                col.m_sesid    = m_sesid;
                col.m_tableid  = m_tableid;
                col.m_strName  = colName;

                col.m_coldef.columnid = colDef.columnid;
                col.m_coldef.coltyp   = colDef.coltyp;
                col.m_coldef.wCountry = colDef.wCountry;
                col.m_coldef.langid   = colDef.langid;
                col.m_coldef.cp       = colDef.cp;
                col.m_coldef.wCollate = colDef.wCollate;
                col.m_coldef.cbMax    = colDef.cbMax;
                col.m_coldef.grbit    = colDef.grbit;
            }
        }

        ////////////////////////////////////////////////////////////////////////////////
        //
        // Read index definition.
        //
        // JET_INDEXLIST
        // {
        //     unsigned long cbStruct;
        //     JET_TABLEID   tableid;
        //     unsigned long cRecord;
        //     JET_COLUMNID  columnidindexname;   # JET_coltypText  # LPSTR          INDEX
        //     JET_COLUMNID  columnidgrbitIndex;  # JET_coltypLong  # JET_GRBIT      INDEX
        //     JET_COLUMNID  columnidcKey;        # JET_coltypLong  # LONG           INDEX
        //     JET_COLUMNID  columnidcEntry;      # JET_coltypLong  # LONG           INDEX
        //     JET_COLUMNID  columnidcPage;       # JET_coltypLong  # LONG           INDEX
        //     JET_COLUMNID  columnidcColumn;     # JET_coltypLong  # LONG           INDEX
        //     JET_COLUMNID  columnidiColumn;     # JET_coltypLong  # ULONG          COLUMN
        //     JET_COLUMNID  columnidcolumnid;    # JET_coltypLong  # JET_COLUMNID   COLUMN
        //     JET_COLUMNID  columnidcoltyp;      # JET_coltypLong  # JET_COLTYP     COLUMN
        //     JET_COLUMNID  columnidCountry;     # JET_coltypShort # WORD           INDEX
        //     JET_COLUMNID  columnidLangid;      # JET_coltypShort # LANGID         INDEX
        //     JET_COLUMNID  columnidCp;          # JET_coltypShort # USHORT         COLUMN
        //     JET_COLUMNID  columnidCollate;     # JET_coltypShort # WORD           INDEX
        //     JET_COLUMNID  columnidgrbitColumn; # JET_coltypLong  # JET_GRBIT      COLUMN
        //     JET_COLUMNID  columnidcolumnname;  # JET_coltypText  # LPSTR          COLUMN
        //     JET_COLUMNID  columnidLCMapFlags;  # JET_coltypLong  # DWORD          INDEX
        // };
        {
            JET_RETRIEVECOLUMN rc     [14              ]; ::ZeroMemory( &rc, sizeof(rc) );
            char               idxName[JET_cbNameMost+1];
            char               colName[JET_cbNameMost+1];
            Index*             idx = NULL;
            Column*            col;
            JET_COLUMNDEF      colDef;
            JET_GRBIT          grbit;
            LONG               cKey;
            LONG               cEntry;
            LONG               cPage;
            LONG               cColumn;
            int                iIdx = 0;
            int                iCol = 0;
            int                i;

            __MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetGetTableIndexInfo( m_sesid, m_tableid, NULL, &infoIdxs, sizeof(infoIdxs), JET_IdxInfoList ));

            __MPC_JET_INIT_RETRIEVE_COL( rc,  0, infoIdxs.columnidindexname  ,  idxName        , JET_cbNameMost          );
            __MPC_JET_INIT_RETRIEVE_COL( rc,  1, infoIdxs.columnidgrbitIndex , &grbit          , sizeof(grbit          ) );
            __MPC_JET_INIT_RETRIEVE_COL( rc,  2, infoIdxs.columnidcKey       , &cKey           , sizeof(cKey           ) );
            __MPC_JET_INIT_RETRIEVE_COL( rc,  3, infoIdxs.columnidcEntry     , &cEntry         , sizeof(cEntry         ) );
            __MPC_JET_INIT_RETRIEVE_COL( rc,  4, infoIdxs.columnidcPage      , &cPage          , sizeof(cPage          ) );
            __MPC_JET_INIT_RETRIEVE_COL( rc,  5, infoIdxs.columnidcColumn    , &cColumn        , sizeof(cColumn        ) );

            __MPC_JET_INIT_RETRIEVE_COL( rc,  6, infoIdxs.columnidcolumnname ,  colName        , JET_cbNameMost          );
            __MPC_JET_INIT_RETRIEVE_COL( rc,  7, infoIdxs.columnidcolumnid   , &colDef.columnid, sizeof(colDef.columnid) );
            __MPC_JET_INIT_RETRIEVE_COL( rc,  8, infoIdxs.columnidcoltyp     , &colDef.coltyp  , sizeof(colDef.coltyp  ) );
            __MPC_JET_INIT_RETRIEVE_COL( rc,  9, infoIdxs.columnidCountry    , &colDef.wCountry, sizeof(colDef.wCountry) );
            __MPC_JET_INIT_RETRIEVE_COL( rc, 10, infoIdxs.columnidLangid     , &colDef.langid  , sizeof(colDef.langid  ) );
            __MPC_JET_INIT_RETRIEVE_COL( rc, 11, infoIdxs.columnidCp         , &colDef.cp      , sizeof(colDef.cp      ) );
            __MPC_JET_INIT_RETRIEVE_COL( rc, 12, infoIdxs.columnidCollate    , &colDef.wCollate, sizeof(colDef.wCollate) );
            __MPC_JET_INIT_RETRIEVE_COL( rc, 13, infoIdxs.columnidgrbitColumn, &colDef.grbit   , sizeof(colDef.grbit   ) );


            m_vecIndexes.resize( infoIdxs.cRecord );
            for(i=0; i<infoIdxs.cRecord; i++)
            {
                 ::ZeroMemory( idxName, sizeof(idxName) );
                 ::ZeroMemory( colName, sizeof(colName) );

                __MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetMove           ( m_sesid, infoIdxs.tableid, (i == 0 ? JET_MoveFirst : JET_MoveNext), 0 ));
                __MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetRetrieveColumns( m_sesid, infoIdxs.tableid, rc, ARRAYSIZE(rc)                          ));

                if(idx == NULL || idx->m_strName != idxName)
                {
                    iCol = 0;
                    idx  = &m_vecIndexes[iIdx++];

                    idx->m_sesid      = m_sesid;
                    idx->m_tableid    = m_tableid;
                    idx->m_strName    = idxName;
                    idx->m_grbitIndex = grbit;
                    idx->m_cKey       = cKey;
                    idx->m_cEntry     = cEntry;
                    idx->m_cPage      = cPage;

                    idx->m_vecColumns.resize( cColumn );
                }

                col = &idx->m_vecColumns[iCol++];

                col->m_sesid   = m_sesid;
                col->m_tableid = m_tableid;
                col->m_strName = colName;

                col->m_coldef.columnid = colDef.columnid;
                col->m_coldef.coltyp   = colDef.coltyp;
                col->m_coldef.wCountry = colDef.wCountry;
                col->m_coldef.langid   = colDef.langid;
                col->m_coldef.cp       = colDef.cp;
                col->m_coldef.wCollate = colDef.wCollate;
                col->m_coldef.cbMax    = colDef.cbMax;
                col->m_coldef.grbit    = colDef.grbit;
            }
            m_vecIndexes.resize( iIdx ); // Trim down the size to the real one.
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(infoCols.tableid != JET_tableidNil)
    {
        __MPC_JET__MTSAFE_NORESULT(m_sesid, ::JetCloseTable( m_sesid, infoCols.tableid ));
    }

    if(infoIdxs.tableid != JET_tableidNil)
    {
        __MPC_JET__MTSAFE_NORESULT(m_sesid, ::JetCloseTable( m_sesid, infoIdxs.tableid ));
    }

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::Table::Close( /*[in]*/ bool fForce )
{
    __HCP_FUNC_ENTRY( "JetBlue::Table::Close" );

    HRESULT hr;


    if(m_tableid != JET_tableidNil)
    {
        JET_ERR err = ::JetCloseTable( m_sesid, m_tableid ); if(!fForce) __MPC_EXIT_IF_JET_FAILS(hr, err);

        m_tableid = JET_tableidNil;
    }

    m_idxSelected = NULL;
    m_vecColumns.clear();

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

HRESULT JetBlue::Table::Attach( /*[in]*/ JET_TABLEID tableid )
{
    __HCP_FUNC_ENTRY( "JetBlue::Table::Attach" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Close());

    m_tableid = tableid;

    __MPC_EXIT_IF_METHOD_FAILS(hr, Refresh());

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::Table::Open()
{
    __HCP_FUNC_ENTRY( "JetBlue::Table::Open" );

    HRESULT hr;


    if(m_tableid == JET_tableidNil)
    {
        __MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetOpenTable( m_sesid, m_dbid, m_strName.c_str(), NULL, 0, JET_bitTableUpdatable, &m_tableid ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, Refresh());
    }


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::Table::Create()
{
    __HCP_FUNC_ENTRY( "JetBlue::Table::Create" );

    HRESULT hr;


    if(m_tableid == JET_tableidNil)
    {
        __MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetCreateTable( m_sesid, m_dbid, m_strName.c_str(), 10, 80, &m_tableid ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, Refresh());
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::Table::Create( /*[in]*/ JET_TABLECREATE* pDef )
{
    __HCP_FUNC_ENTRY( "JetBlue::Table::Create" );

    HRESULT         hr;
    JET_TABLECREATE tbldef = *pDef;

    __MPC_EXIT_IF_METHOD_FAILS(hr, Close());

    tbldef.szTableName = (LPSTR)m_strName.c_str();

    __MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetCreateTableColumnIndex( m_sesid, m_dbid, &tbldef ));

    m_tableid = tbldef.tableid;

    __MPC_EXIT_IF_METHOD_FAILS(hr, Refresh());

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::Table::Delete( /*[in]*/ bool fForce )
{
    __HCP_FUNC_ENTRY( "JetBlue::Table::Delete" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Close( fForce ));

    if(m_strName.length() > 0)
    {
        __MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetDeleteTable( m_sesid, m_dbid, m_strName.c_str() ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

HRESULT JetBlue::Table::DupCursor( /*[in/out]*/ Cursor& cur )
{
    __HCP_FUNC_ENTRY( "JetBlue::Table::DupCursor" );

    HRESULT hr;

    __MPC_JET_CHECKHANDLE(hr,m_sesid  ,JET_sesidNil  );
    __MPC_JET_CHECKHANDLE(hr,m_tableid,JET_tableidNil);

    __MPC_EXIT_IF_METHOD_FAILS(hr, cur->Duplicate( *this ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::Table::SelectIndex( /*[in]*/ LPCSTR    szIndex ,
                                     /*[in]*/ JET_GRBIT grbit   )
{
    __HCP_FUNC_ENTRY( "JetBlue::Table::SelectIndex" );

    HRESULT hr;
    int     iPos;
    Index*  idxSelected;

    __MPC_JET_CHECKHANDLE(hr,m_sesid  ,JET_sesidNil  );
    __MPC_JET_CHECKHANDLE(hr,m_tableid,JET_tableidNil);


    iPos = GetIdxPosition( szIndex );
    if(iPos == -1)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, JetBlue::JetERRToHRESULT(JET_errIndexNotFound));
    }
    idxSelected = &(m_vecIndexes[iPos]);

    if(grbit == JET_bitNoMove)
    {
        if(m_idxSelected == idxSelected)
        {
            //
            // No need to reselect it.
            //
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }

        //
        // There was no index selected, so there's no current record...
        //
        grbit = JET_bitMoveFirst;
    }

    __MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetSetCurrentIndex2( m_sesid, m_tableid, szIndex, grbit ));


    m_idxSelected = idxSelected;
    hr            = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::Table::SetIndexRange( /*[in]*/ JET_GRBIT grbit )
{
    __HCP_FUNC_ENTRY( "JetBlue::Table::SetIndexRange" );

    HRESULT hr;


    __MPC_JET_CHECKHANDLE(hr,m_sesid      ,JET_sesidNil  );
    __MPC_JET_CHECKHANDLE(hr,m_tableid    ,JET_tableidNil);
    __MPC_JET_CHECKHANDLE(hr,m_idxSelected,NULL          );

    __MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetSetIndexRange( m_sesid, m_tableid, grbit ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


HRESULT JetBlue::Table::PrepareInsert()
{
    __HCP_FUNC_ENTRY( "JetBlue::Table::PrepareInsert" );

    HRESULT hr;


    __MPC_JET_CHECKHANDLE(hr,m_sesid  ,JET_sesidNil  );
    __MPC_JET_CHECKHANDLE(hr,m_tableid,JET_tableidNil);

    __MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetPrepareUpdate( m_sesid, m_tableid, JET_prepInsert ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::Table::PrepareUpdate()
{
    __HCP_FUNC_ENTRY( "JetBlue::Table::PrepareUpdate" );

    HRESULT hr;


    __MPC_JET_CHECKHANDLE(hr,m_sesid  ,JET_sesidNil  );
    __MPC_JET_CHECKHANDLE(hr,m_tableid,JET_tableidNil);

    __MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetPrepareUpdate( m_sesid, m_tableid, JET_prepReplace ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::Table::CancelChange()
{
    __HCP_FUNC_ENTRY( "JetBlue::Table::CancelChange" );

    HRESULT hr;


    __MPC_JET_CHECKHANDLE(hr,m_sesid  ,JET_sesidNil  );
    __MPC_JET_CHECKHANDLE(hr,m_tableid,JET_tableidNil);

    __MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetPrepareUpdate( m_sesid, m_tableid, JET_prepCancel ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::Table::Move( /*[in]*/ JET_GRBIT  grbit   ,
                              /*[in]*/ long       cRow    ,
                              /*[in]*/ bool      *pfFound )
{
    __HCP_FUNC_ENTRY( "JetBlue::Table::Move" );

    HRESULT hr;


    __MPC_JET_CHECKHANDLE(hr,m_sesid  ,JET_sesidNil  );
    __MPC_JET_CHECKHANDLE(hr,m_tableid,JET_tableidNil);

    __MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetMove( m_sesid, m_tableid, cRow, grbit ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    hr = AdjustReturnCode( hr, pfFound );

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::Table::Seek( /*[in]*/ JET_GRBIT  grbit   ,
                              /*[in]*/ VARIANT*   rgKeys  ,
                              /*[in]*/ int        iLen    ,
                              /*[in]*/ bool      *pfFound )
{
    __HCP_FUNC_ENTRY( "JetBlue::Table::Seek" );

    HRESULT hr;
    int     iPos;


    __MPC_JET_CHECKHANDLE(hr,m_sesid      ,JET_sesidNil  );
    __MPC_JET_CHECKHANDLE(hr,m_tableid    ,JET_tableidNil);
    __MPC_JET_CHECKHANDLE(hr,m_idxSelected,NULL          );

    if(iLen != m_idxSelected->NumOfColumns())
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }

    for(iPos=0; iPos<iLen; iPos++)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_idxSelected->GetCol( iPos ).Put( rgKeys[iPos], iPos ));
    }

    __MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetSeek( m_sesid, m_tableid, grbit ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    hr = AdjustReturnCode( hr, pfFound );

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::Table::Get( /*[in]*/  int           iArg ,
                             /*[out]*/ CComVariant* rgArg )
{
    __HCP_FUNC_ENTRY( "JetBlue::Table::Get" );

    HRESULT    hr;
    ColumnIter it;

    __MPC_JET_CHECKHANDLE(hr,m_sesid  ,JET_sesidNil  );
    __MPC_JET_CHECKHANDLE(hr,m_tableid,JET_tableidNil);

    for(it = m_vecColumns.begin(); it != m_vecColumns.end() && iArg > 0; it++, iArg--, rgArg++)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, it->Get( *rgArg ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::Table::Put( /*[in]*/ int                 iArg ,
                             /*[in]*/ const CComVariant* rgArg )
{
    __HCP_FUNC_ENTRY( "JetBlue::Table::Put" );

    HRESULT    hr;
    ColumnIter it;

    __MPC_JET_CHECKHANDLE(hr,m_sesid  ,JET_sesidNil  );
    __MPC_JET_CHECKHANDLE(hr,m_tableid,JET_tableidNil);

    for(it = m_vecColumns.begin(); it != m_vecColumns.end() && iArg > 0; it++, iArg--, rgArg++)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, it->Put( *rgArg ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::Table::UpdateRecord( /*[in]*/ bool fMove )
{
    __HCP_FUNC_ENTRY( "JetBlue::Table::UpdateRecord" );

    HRESULT hr;


    __MPC_JET_CHECKHANDLE(hr,m_sesid  ,JET_sesidNil  );
    __MPC_JET_CHECKHANDLE(hr,m_tableid,JET_tableidNil);

    if(fMove)
    {
        BYTE          rgBookmark[JET_cbBookmarkMost];
        unsigned long cbActual;

        __MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetUpdate      ( m_sesid, m_tableid, rgBookmark, sizeof(rgBookmark), &cbActual ));
        __MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetGotoBookmark( m_sesid, m_tableid, rgBookmark                    ,  cbActual ));
    }
    else
    {
        __MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetUpdate( m_sesid, m_tableid, NULL, 0, NULL ));
    }


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT JetBlue::Table::DeleteRecord()
{
    __HCP_FUNC_ENTRY( "JetBlue::Table::DeleteRecord" );

    HRESULT hr;


    __MPC_JET_CHECKHANDLE(hr,m_sesid  ,JET_sesidNil  );
    __MPC_JET_CHECKHANDLE(hr,m_tableid,JET_tableidNil);

    __MPC_EXIT_IF_JET_FAILS__MTSAFE(m_sesid, hr, ::JetDelete( m_sesid, m_tableid ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

int JetBlue::Table::GetColPosition( /*[in]*/ LPCSTR szCol )
{
    int iLen = m_vecColumns.size();
    int iPos;

    for(iPos=0; iPos<iLen; iPos++)
    {
        Column& col = m_vecColumns[iPos];

        if(col.m_strName.compare( SAFEASTR( szCol ) ) == 0) return iPos;
    }

    return -1;
}

JetBlue::Column& JetBlue::Table::GetCol( /*[in]*/ LPCSTR szCol )
{
    return GetCol( GetColPosition( szCol ) );
}

JetBlue::Column& JetBlue::Table::GetCol( /*[in]*/ int iPos )
{
    if(0 <= iPos && iPos < m_vecColumns.size()) return m_vecColumns[iPos];

    return m_fakeCol;
}

////////////////////////////////////////

int JetBlue::Table::GetIdxPosition( /*[in]*/ LPCSTR szIdx )
{
    int iLen = m_vecIndexes.size();
    int iPos;

    for(iPos=0; iPos<iLen; iPos++)
    {
        Index& idx = m_vecIndexes[iPos];

        if(idx.m_strName.compare( SAFEASTR( szIdx ) ) == 0) return iPos;
    }

    return -1;
}

JetBlue::Index& JetBlue::Table::GetIdx( /*[in]*/ LPCSTR szIdx )
{
    return GetIdx( GetIdxPosition( szIdx ) );
}

JetBlue::Index& JetBlue::Table::GetIdx( /*[in]*/ int iPos )
{
    if(0 <= iPos && iPos < m_vecIndexes.size()) return m_vecIndexes[iPos];

    return m_fakeIdx;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\jetblue\unittest\main.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    main.cpp

Abstract:
    This file contains the unit test for the low-level JetBlue objects.

Revision History:
    Davide Massarenti   (Dmassare)  05/18/2000
        created

******************************************************************************/

#include "StdAfx.h"

#define LOG__MPC_EXIT_IF_METHOD_FAILS(hr, cmd)                                             \
{                                                                                          \
    printf( "Executing %s\n", #cmd );                                                      \
    if(FAILED(hr=cmd))                                                                     \
    {                                                                                      \
        printf( "Error: %08x\n", hr ); __MPC_TRACE_HRESULT(hr); __MPC_FUNC_LEAVE;          \
    }                                                                                      \
}

class BindTest1 : public JetBlue::RecordBindingBase
{
    JET_DECLARE_BINDING(BindTest1);
public:

    long        m_iVal1 ; bool m_fVal1;
    MPC::string m_szVal2; bool m_fVal2;
};

JET_BEGIN_RECORDBINDING(BindTest1)
    JET_FIELD_BYNAME("Col1",long  ,m_iVal1 ,m_fVal1),
    JET_FIELD_BYNAME("Col2",string,m_szVal2,m_fVal2),
JET_END_RECORDBINDING(BindTest1)

////////////////////////////////////////////////////////////////////////////////

static const JET_COLUMNCREATE s_ColDef[] =
{
    __MPC_JET_COLUMNCREATE        ("Col1",JET_coltypLong    ,0,JET_bitColumnNotNULL),
    __MPC_JET_COLUMNCREATE_ANSI   ("Col2",JET_coltypLongText,0,0),
    __MPC_JET_COLUMNCREATE_UNICODE("Col3",JET_coltypLongText,0,0),
};


static const char s_szIndex1[] = "+Col1\0";
static const char s_szIndex2[] = "+Col1\0-Col2\0";

static const JET_INDEXCREATE s_IdxDef[] =
{
    __MPC_JET_INDEXCREATE("Idx1",s_szIndex1,0,100),
    __MPC_JET_INDEXCREATE("Idx2",s_szIndex2,0,100)
};

static const JET_TABLECREATE s_TblDef = __MPC_JET_TABLECREATE(NULL,10,80,s_ColDef,s_IdxDef);

////////////////////////////////////////////////////////////////////////////////

static HRESULT GetSession( /*[in/out]*/ JetBlue::SessionHandle& handle )
{
    __HCP_FUNC_ENTRY( "GetSession" );

    HRESULT hr;

    LOG__MPC_EXIT_IF_METHOD_FAILS(hr, JetBlue::SessionPool::s_GLOBAL->GetSession( handle ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

static HRESULT CreateDatabase( /*[in]*/  JetBlue::SessionHandle& handle ,
                               /*[out]*/ JetBlue::Database*&     db     ,
                               /*[in]*/  LPCSTR                  szName )
{
    __HCP_FUNC_ENTRY( "CreateDatabase" );

    HRESULT hr;

    LOG__MPC_EXIT_IF_METHOD_FAILS(hr, handle->GetDatabase( szName, db, true ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

static HRESULT CreateTable( /*[in]*/  JetBlue::Database*&  db     ,
                            /*[out]*/ JetBlue::Table*&     table  ,
                            /*[in]*/  LPCSTR               szName )
{
    __HCP_FUNC_ENTRY( "CreateTable" );

    HRESULT          hr;
    JET_COLUMNCREATE colDef[ARRAYSIZE(s_ColDef)]; ::CopyMemory(  colDef,  s_ColDef, sizeof(colDef) );
    JET_INDEXCREATE  idxDef[ARRAYSIZE(s_IdxDef)]; ::CopyMemory(  idxDef,  s_IdxDef, sizeof(idxDef) );
    JET_TABLECREATE  tblDef;                      ::CopyMemory( &tblDef, &s_TblDef, sizeof(tblDef) );

    tblDef.szTableName    = (LPSTR)szName;
    tblDef.rgcolumncreate =        colDef;
    tblDef.rgindexcreate  =        idxDef;

    LOG__MPC_EXIT_IF_METHOD_FAILS(hr, db->GetTable( NULL, table, &tblDef ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

static HRESULT RestoreTableFromFile( /*[in]*/ LPCSTR          szFile ,
                                     /*[in]*/ JetBlue::Table* table  )
{
    __HCP_FUNC_ENTRY( "RestoreTableFromFile" );

    HRESULT       hr;
    std::ifstream ifile( szFile, ios::nocreate | ios::in );
    char          rgBuf       [2048+1];
    WCHAR         rgBufUNICODE[2048+1];
    LPCWSTR*      argv = NULL;
    int           argc = 0;
    int           i;

    if(ifile.fail())
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
    }

    while(!ifile.eof())
    {
        MPC::CommandLine_Free( argc, argv );

        ifile.getline( rgBuf, sizeof(rgBuf) );

        ::MultiByteToWideChar( CP_ACP, 0, rgBuf, -1, rgBufUNICODE, MAXSTRLEN(rgBufUNICODE) );

        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CommandLine_Parse( argc, argv, rgBufUNICODE, true ));
        if(argc == 0) continue;

        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, table->PrepareInsert());

        for(i=0; i<argc; i++)
        {
            if(wcscmp( argv[i], L"<NULL>"))
            {
                LOG__MPC_EXIT_IF_METHOD_FAILS(hr, table->GetCol( i ).Put( argv[i] ));
            }
        }

        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, table->UpdateRecord( /*fMove*/false ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    MPC::CommandLine_Free( argc, argv );

    __HCP_FUNC_EXIT(hr);
}

static HRESULT SaveTableToFile( /*[in]*/ LPCSTR          szFile              ,
                                /*[in]*/ JetBlue::Table* table               ,
                                /*[in]*/ bool            fMoveToFirst = true )
{
    __HCP_FUNC_ENTRY( "SaveTableToFile" );

    HRESULT       hr;
    JET_ERR       err;
    std::ofstream ofile( szFile );
    WCHAR         rgBufEscaped[  2048+1];
    char          rgBufANSI   [2*2048+1];
    int           iCols = table->NumOfColumns();
    CComVariant*  rgArg = NULL;
    int           i;

    if(ofile.fail())
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
    }

    __MPC_EXIT_IF_ALLOC_FAILS(hr, rgArg, new CComVariant[iCols]);

    hr = fMoveToFirst ? table->Move( 0, JET_MoveFirst ) : S_OK;
    while(SUCCEEDED(hr))
    {
        for(i=0; i<iCols; i++) rgArg[i].Clear();

        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, table->Get( iCols, rgArg ));

        for(i=0; i<iCols; i++)
        {
            CComVariant& v = rgArg[i];
            LPCWSTR      szSrc;
            LPWSTR       szDst;
            bool         fQuotes = false;

            rgBufEscaped[0] = 0;

            if(SUCCEEDED(v.ChangeType( VT_BSTR )))
            {
                LPCWSTR szSrc = SAFEBSTR( v.bstrVal );
                LPWSTR  szDst = rgBufEscaped;
                WCHAR   c;

                if(szSrc[0] == 0) fQuotes = true;

                while((c = *szSrc++))
                {
                    switch(c)
                    {
                    case '\'':
                    case '"' :
                    case '\\': *szDst++ = '\\';
                    case ' ' : fQuotes = true;
                    }

                    *szDst++ = c;
                }
                *szDst = 0;
            }
            else if(v.vt == VT_NULL)
            {
                wcscpy( rgBufEscaped, L"<NULL>" );
            }

            ::WideCharToMultiByte( CP_ACP, 0, rgBufEscaped, -1, rgBufANSI, MAXSTRLEN(rgBufANSI), NULL, NULL );

            if(i      ) ofile << " ";
            if(fQuotes) ofile << "\"";
                        ofile << rgBufANSI;
            if(fQuotes) ofile << "\"";
        }
        std::endl( ofile );

        hr = table->Move( 0, JET_MoveNext );
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

static HRESULT WriteData( /*[in]*/ JetBlue::Table* table )
{
    __HCP_FUNC_ENTRY( "WriteData" );

    HRESULT hr;

    //
    // Individual put.
    //
    {
        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, table->PrepareInsert());

        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, table->GetCol( 0 ).Put( MPC::wstring( L"124" ) ));
        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, table->GetCol( 1 ).Put( long        ( 678    ) ));
        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, table->GetCol( 2 ).Put( CComVariant ( "ads"  ) ));

        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, table->UpdateRecord( /*fMove*/false ));
    }

    //
    // Batch put.
    //
    {
        CComVariant rgArg[] = { "124", 678, "ads" };

        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, table->PrepareInsert());

        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, table->Put( ARRAYSIZE(rgArg), rgArg ));

        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, table->UpdateRecord( /*fMove*/false ));
    }

    //
    // Binding mode.
    //
    {
        BindTest1 rb( table );

        rb.m_fVal1 = false; rb.m_iVal1 = 30;
        rb.m_fVal2 = true;

        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, rb.Insert());

        rb.m_fVal1 = false; rb.m_iVal1  = 30;
        rb.m_fVal2 = false; rb.m_szVal2 = "Prova di stringa";

        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, rb.Insert());
    }


    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

static HRESULT ReadData( /*[in]*/ JetBlue::Table* table )
{
    __HCP_FUNC_ENTRY( "ReadData" );

    HRESULT hr;

    //
    // Individual get.
    //
    {
        long          lCol1;
        MPC::wstring szCol2;
        MPC::wstring szCol3;

        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, table->Move( 0, JET_MoveFirst ));

        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, table->GetCol(      0 ).Get(  lCol1 ));
        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, table->GetCol(      1 ).Get( szCol2 ));
        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, table->GetCol( "Col2" ).Get( szCol3 ));
    }

    //
    // Batch get.
    //
    {
        CComVariant rgArg[3];

        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, table->Move( 0, JET_MoveNext ));

        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, table->Get( ARRAYSIZE(rgArg), rgArg ));
    }

    //
    // Binding mode.
    //
    {
        BindTest1 rb( table );

        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, rb.Move( 0, JET_MoveFirst ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

static HRESULT DeleteTable( /*[in]*/ JetBlue::Table* table )
{
    __HCP_FUNC_ENTRY( "DeleteTable" );

    HRESULT hr;

    LOG__MPC_EXIT_IF_METHOD_FAILS(hr, table->Delete( true ));

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

static HRESULT DeleteDatabase( /*[in]*/ JetBlue::Database* db )
{
    __HCP_FUNC_ENTRY( "DeleteDatabase" );

    HRESULT hr;

    LOG__MPC_EXIT_IF_METHOD_FAILS(hr, db->Delete( true ));

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

static HRESULT RunTests( int argc, WCHAR **argv )
{
    __HCP_FUNC_ENTRY( "RunTests" );

    HRESULT hr;

    LOG__MPC_EXIT_IF_METHOD_FAILS(hr, JetBlue::SessionPool::s_GLOBAL->Init());

    {
        JetBlue::SessionHandle handle;
        JetBlue::Database*     db;
        JetBlue::Table*        table;
        JetBlue::Table*        table2;


        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, GetSession( handle ));

        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, CreateDatabase( handle, db, "files\\test.edb" ));

        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, handle->BeginTransaction());

        ////////////////////////////////////////////////////////////////////////////////

        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, CreateTable( db, table, "table1" ));

        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( table ));
        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, ReadData ( table ));

        {
            JetBlue::TableDefinition tbldef;

            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, tbldef.Parse( *table ));
            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, tbldef.Save( L"files\\table1.xml" ));
        }

        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, SaveTableToFile( "files\\runtime.txt", table ));

        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, DeleteTable( table ));

        ////////////////////////////////////////

        {
            JetBlue::TableDefinition tbldef;
            JET_TABLECREATE          tblcrt;

            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, tbldef.Load( L"files\\table1.xml" ));
            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, tbldef.Generate( tblcrt ));

            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, db->GetTable( NULL, table2, &tblcrt ));

            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, tbldef.Release( tblcrt ));
        }

        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, RestoreTableFromFile( "files\\input.txt" , table2 ));
        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, SaveTableToFile     ( "files\\output.txt", table2 ));

        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, table2->SelectIndex( "Idx1"                                    ));
        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, table2->Seek       ( JET_bitSeekEQ | JET_bitSetIndexRange, 12L ));
        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, SaveTableToFile    ( "files\\filter.txt", table2, false        ));

        {
            CComVariant rgKeys[2] = { 12, "asd" };

            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, table2->SelectIndex( "Idx2"                                          ));
            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, table2->Seek       ( JET_bitSeekEQ | JET_bitSetIndexRange, rgKeys, 2 ));
            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, SaveTableToFile    ( "files\\filter2.txt", table2, false             ));
        }

        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, table2->SelectIndex ( "Idx1"                                    ));
        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, table2->Seek        ( JET_bitSeekEQ | JET_bitSetIndexRange, 12L ));
        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, table2->DeleteRecord(                                           ));
        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, table2->Seek        ( JET_bitSeekEQ | JET_bitSetIndexRange, 12L ));
        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, SaveTableToFile     ( "files\\filter3.txt", table2, false       ));

        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, DeleteTable( table2 ));

        ////////////////////////////////////////////////////////////////////////////////

        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, handle->CommitTransaction());

        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, DeleteDatabase( db ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    (void)JetBlue::SessionPool::s_GLOBAL->Close( true );

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

static HRESULT InitAll()
{
    __HCP_FUNC_ENTRY( "InitAll" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, JetBlue::SessionPool            ::InitializeSystem(                 ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::InitializeSystem(                 ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::Cache                 ::InitializeSystem(                 ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, OfflineCache::Root              ::InitializeSystem( /*fMaster*/true ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, HCUpdate::Config::Root          ::InitializeSystem(                 ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHContentStore                ::InitializeSystem( /*fMaster*/true ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHUserProcess                 ::InitializeSystem(                 ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHSecurity                    ::InitializeSystem(                 ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHSystemMonitor               ::InitializeSystem(                 ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, CSAFReg                         ::InitializeSystem(                 ));


    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

static HRESULT CleanAll()
{
    CSAFReg                         ::FinalizeSystem();
    CPCHSystemMonitor               ::FinalizeSystem();
    CPCHSecurity                    ::FinalizeSystem();

    CPCHUserProcess                 ::FinalizeSystem();
    CPCHContentStore                ::FinalizeSystem();

    HCUpdate::Config::Root          ::FinalizeSystem();
    OfflineCache::Root              ::FinalizeSystem();
    Taxonomy::Cache                 ::FinalizeSystem();
    Taxonomy::InstalledInstanceStore::FinalizeSystem();
    JetBlue::SessionPool            ::FinalizeSystem();
}

////////////////////////////////////////////////////////////////////////////////

int __cdecl wmain( int argc, WCHAR **argv, WCHAR **envp)
{
    HRESULT  hr;

    if(SUCCEEDED(hr = ::CoInitializeEx( NULL, COINIT_MULTITHREADED )) &&
	   SUCCEEDED(hr = InitAll         (                            ))  )
    {
        hr = RunTests( argc, argv );

		CleanAll();

        ::CoUninitialize();
    }

    return FAILED(hr) ? 10 : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\keyssupport\client\stdafx.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    StdAfx.h

Abstract:
    Precompiled header.

Revision History:
    Davide Massarenti   (Dmassare)  04/07/2000
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__35881994_CD02_11D2_9370_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__35881994_CD02_11D2_9370_00C04F72DAF7__INCLUDED_

#include <module.h>

#include <stdio.h>
#include <stdlib.h>
#include <float.h>

#include <HCP_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_COM.h>
#include <MPC_streams.h>
#include <MPC_logging.h>

#include <KeysLib.h>

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__35881994_CD02_11D2_9370_00C04F72DAF7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\keyssupport\client\main.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    main.cpp

Abstract:
    This file contains the client program for dealing with script signature.

Revision History:
    Davide Massarenti   (Dmassare)  04/11/2000
        created

******************************************************************************/

#include "stdafx.h"
#include <iostream>

#include <string>
#include <list>

//////////////////////////////////////////////////////////////////////

static void Usage( int     argc   ,
                   LPCWSTR argv[] )
{
    wprintf( L"Usage: %s <command> <parameters>\n\n", argv[0]                 );
    wprintf( L"Available commands:\n\n"                                       );
    wprintf( L"  CREATE <private key file> <public key file>\n"               );
    wprintf( L"  SIGN   <private key file> <file to sign> <signature file>\n" );
    wprintf( L"  VERIFY <public key file> <signed file>  <signature file>\n"  );
}

////////////////////////////////////////////////////////////////////////////////

static HRESULT LoadFile( /*[in ]*/ LPCWSTR  szFile ,
                         /*[out]*/ HGLOBAL& hg     )
{
    __HCP_FUNC_ENTRY( "LoadFile" );

    HRESULT                  hr;
    CComPtr<IStream>         streamMem;
    CComPtr<MPC::FileStream> streamFile;


    //
    // Create a stream for a file.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &streamFile ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamFile->InitForRead( szFile  ));


    //
    // Create a memory stream.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CreateStreamOnHGlobal( NULL, FALSE, &streamMem ));

    //
    // Load the contents in memory.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::BaseStream::TransferData( streamFile, streamMem ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, ::GetHGlobalFromStream( streamMem, &hg ));
    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

static HRESULT SaveFile( /*[in]*/ LPCWSTR szFile ,
                         /*[in]*/ HGLOBAL hg     )
{
    __HCP_FUNC_ENTRY( "SaveFile" );

    HRESULT                  hr;
    CComPtr<IStream>         streamMem;
    CComPtr<MPC::FileStream> streamFile;


    //
    // Create a stream for a file.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &streamFile ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamFile->InitForWrite( szFile ));


    //
    // Create a memory stream.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CreateStreamOnHGlobal( hg, FALSE, &streamMem ));

    //
    // Load the contents in memory.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::BaseStream::TransferData( streamMem, streamFile ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

static HRESULT LoadFileAsString( /*[in ]*/ LPCWSTR   szFile   ,
                                 /*[out]*/ CComBSTR& bstrData )
{
    __HCP_FUNC_ENTRY( "LoadFileAsString" );

    HRESULT hr;
    HGLOBAL hg = NULL;
    DWORD   dwLen;
    LPWSTR  str;


    __MPC_EXIT_IF_METHOD_FAILS(hr, LoadFile( szFile, hg ));

    dwLen = ::GlobalSize( hg );

    bstrData.Attach( ::SysAllocStringLen( NULL, dwLen ) );

    ::MultiByteToWideChar( CP_ACP, 0, (LPCSTR)::GlobalLock( hg ), dwLen, bstrData, (dwLen+1)*sizeof(WCHAR) ); bstrData[dwLen] = 0;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(hg) ::GlobalFree( hg );

    __HCP_FUNC_EXIT(hr);
}

static HRESULT SaveFileAsString( /*[in]*/ LPCWSTR         szFile   ,
                                 /*[in]*/ const CComBSTR& bstrData )
{
    __HCP_FUNC_ENTRY( "SaveFileAsString" );

    USES_CONVERSION;

    HRESULT hr;
    DWORD   dwLen = ::SysStringLen( bstrData );
    HGLOBAL hg    = NULL;


    __MPC_EXIT_IF_CALL_RETURNS_NULL(hr, (hg = ::GlobalAlloc( GMEM_FIXED, dwLen )));

    ::CopyMemory( hg, W2A(bstrData), dwLen );

    __MPC_EXIT_IF_METHOD_FAILS(hr, SaveFile( szFile, hg ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(hg) ::GlobalFree( hg );

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

static HRESULT Create( /*[in]*/ LPCWSTR szPrivateFile ,
                       /*[in]*/ LPCWSTR szPublicFile  )
{
    __HCP_FUNC_ENTRY( "Create" );

    HRESULT       hr;
    CPCHCryptKeys key;
    CComBSTR      bstrPrivate;
    CComBSTR      bstrPublic;


    __MPC_EXIT_IF_METHOD_FAILS(hr, key.CreatePair());

    __MPC_EXIT_IF_METHOD_FAILS(hr, key.ExportPair( bstrPrivate, bstrPublic ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, SaveFileAsString( szPrivateFile, bstrPrivate ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, SaveFileAsString( szPublicFile , bstrPublic  ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

static HRESULT Sign( /*[in]*/ LPCWSTR szPrivateFile   ,
                     /*[in]*/ LPCWSTR szDataFile      ,
                     /*[in]*/ LPCWSTR szSignatureFile )
{
    __HCP_FUNC_ENTRY( "Sign" );

    HRESULT       hr;
    CPCHCryptKeys key;
    CComBSTR      bstrPrivate;
    CComBSTR      bstrSignature;
    HGLOBAL       hg = NULL;


    __MPC_EXIT_IF_METHOD_FAILS(hr, LoadFileAsString( szPrivateFile, bstrPrivate ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, LoadFile        ( szDataFile   , hg          ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, key.ImportPrivate( bstrPrivate ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, key.SignData( bstrSignature, (BYTE*)::GlobalLock( hg ), ::GlobalSize( hg ) ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, SaveFileAsString( szSignatureFile, bstrSignature ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(hg) ::GlobalFree( hg );

    __HCP_FUNC_EXIT(hr);
}

static HRESULT Verify( /*[in]*/ LPCWSTR szPublicFile    ,
                       /*[in]*/ LPCWSTR szDataFile      ,
                       /*[in]*/ LPCWSTR szSignatureFile )
{
    __HCP_FUNC_ENTRY( "Sign" );

    HRESULT       hr;
    CPCHCryptKeys key;
    CComBSTR      bstrPublic;
    CComBSTR      bstrSignature;
    HGLOBAL       hg = NULL;


    __MPC_EXIT_IF_METHOD_FAILS(hr, LoadFileAsString( szPublicFile   , bstrPublic    ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, LoadFileAsString( szSignatureFile, bstrSignature ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, LoadFile        ( szDataFile     , hg            ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, key.ImportPublic( bstrPublic ));


    hr = key.VerifyData( bstrSignature, (BYTE*)::GlobalLock( hg ), ::GlobalSize( hg ) );
    if(FAILED(hr))
    {
        wprintf( L"Verification failure: 0x%08x\n", hr );
    }
    else
    {
        wprintf( L"Verification successful: 0x%08x\n", hr );
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(hg) ::GlobalFree( hg );

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

static HRESULT ProcessArguments( int     argc   ,
                                 LPCWSTR argv[] )
{
    __HCP_FUNC_ENTRY( "ProcessArguments" );

    HRESULT hr;


    if(argc < 2) { Usage( argc, argv ); __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL); }

    if(!_wcsicmp( argv[1], L"CREATE" ))
    {
        if(argc < 4) { Usage( argc, argv ); __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL); }

        __MPC_EXIT_IF_METHOD_FAILS(hr, Create( argv[2], argv[3] ));
    }

    if(!_wcsicmp( argv[1], L"SIGN" ))
    {
        if(argc < 5) { Usage( argc, argv ); __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL); }

        __MPC_EXIT_IF_METHOD_FAILS(hr, Sign( argv[2], argv[3], argv[4] ));
    }

    if(!_wcsicmp( argv[1], L"VERIFY" ))
    {
        if(argc < 5) { Usage( argc, argv ); __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL); }

        __MPC_EXIT_IF_METHOD_FAILS(hr, Verify( argv[2], argv[3], argv[4] ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

int __cdecl wmain( int     argc   ,
                   LPCWSTR argv[] )
{
    HRESULT hr;

    //DebugBreak();

    //
    // We need to be a single-threaded application, because we are hosting script engines and
    // script engines don't like to be called from different threads...
    //
    if(SUCCEEDED(hr = ::CoInitializeEx( NULL, COINIT_APARTMENTTHREADED )))
    {
        if(SUCCEEDED(hr = ::CoInitializeSecurity( NULL                     ,
                                                  -1                       , // We don't care which authentication service we use.
                                                  NULL                     ,
                                                  NULL                     ,
                                                  RPC_C_AUTHN_LEVEL_CONNECT, // We want to identify the callers.
                                                  RPC_C_IMP_LEVEL_DELEGATE , // We want to be able to forward the caller's identity.
                                                  NULL                     ,
                                                  EOAC_DYNAMIC_CLOAKING    , // Let's use the thread token for outbound calls.
                                                  NULL                     )))
        {
            __MPC_TRACE_INIT();

            //
            // Process arguments.
            //
            hr = ProcessArguments( argc, argv );

            __MPC_TRACE_TERM();
        }

        ::CoUninitialize();
    }

    return FAILED(hr) ? 10 : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\jetblue\unittest\stdafx.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    stdafx.h

Abstract:
    include file for standard system include files,
    or project specific include files that are used frequently,
    but are changed infrequently


Revision History:
    Davide Massarenti   (Dmassare)  07/21/99
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_

#include <module.h>

//////

#include <HCP_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_COM.h>

#include <JetBlueLib.h>

#include <fstream>
#include <iostream>
#include <ios.h>

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\keyssupport\lib\stdafx.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    StdAfx.h

Abstract:
    Precompiled header.

Revision History:
    Davide Massarenti   (Dmassare)  04/07/2000
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__35881994_CD02_11D2_9370_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__35881994_CD02_11D2_9370_00C04F72DAF7__INCLUDED_

#include <module.h>

#include <stdio.h>
#include <stdlib.h>
#include <float.h>

#include <HCP_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_COM.h>
#include <MPC_logging.h>

#include <KeysLib.h>
#include <wintrust.h>
#include <wincrypt.h>
#include <softpub.h>

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__35881994_CD02_11D2_9370_00C04F72DAF7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\keyssupport\lib\keyslib.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    KeysLib.cpp

Abstract:
    This file contains the implementation of the CPCHCryptKeys class,
    that is uses to sign and verify trusted scripts.

Revision History:
    Davide Massarenti   (Dmassare)  04/11/2000
        created

******************************************************************************/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////

CPCHCryptKeys::CPCHCryptKeys()
{
    __HCP_FUNC_ENTRY( "CPCHCryptKeys::CPCHCryptKeys" );

    m_hCryptProv = NULL;  //  HCRYPTPROV m_hCryptProv;
    m_hKey       = NULL;  //  HCRYPTKEY  m_hKey;
}

CPCHCryptKeys::~CPCHCryptKeys()
{
    __HCP_FUNC_ENTRY( "CPCHCryptKeys::~CPCHCryptKeys" );

    Close();
}

HRESULT CPCHCryptKeys::Close()
{
    __HCP_FUNC_ENTRY( "CPCHCryptKeys::Close" );

    if(m_hKey)
    {
        ::CryptDestroyKey( m_hKey ); m_hKey = NULL;
    }

    if(m_hCryptProv)
    {
        ::CryptReleaseContext( m_hCryptProv, 0 ); m_hCryptProv = NULL;
    }

    __HCP_FUNC_EXIT(S_OK);
}

HRESULT CPCHCryptKeys::Init()
{
    __HCP_FUNC_ENTRY( "CPCHCryptKeys::Init" );

    HRESULT hr;

    Close();

    if(!::CryptAcquireContext( &m_hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_SILENT ))
    {
        DWORD dwRes = ::GetLastError();

        if(dwRes != NTE_BAD_KEYSET)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRes);
        }

        //
        // Key set doesn't exist, let's create one.
        //
        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CryptAcquireContext( &m_hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET | CRYPT_SILENT ));
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    if(FAILED(hr)) Close();

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHCryptKeys::CreatePair()
{
    __HCP_FUNC_ENTRY( "CPCHCryptKeys::CreatePair" );

    HRESULT hr;

    __MPC_EXIT_IF_METHOD_FAILS(hr, Init());

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CryptGenKey( m_hCryptProv, AT_SIGNATURE, CRYPT_EXPORTABLE, &m_hKey ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHCryptKeys::ExportPair( /*[out]*/ CComBSTR& bstrPrivate ,
                                   /*[out]*/ CComBSTR& bstrPublic  )
{
    __HCP_FUNC_ENTRY( "CPCHCryptKeys::ExportPair" );

    HRESULT hr;
    DWORD   dwSize;
    HGLOBAL hg = NULL;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(m_hKey);
    __MPC_PARAMCHECK_END();


    ////////////////////////////////////////
    //
    // Export private/public pair.
    //
    dwSize = 0;
    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CryptExportKey( m_hKey, NULL, PRIVATEKEYBLOB, 0, NULL, &dwSize ));

    __MPC_EXIT_IF_CALL_RETURNS_NULL(hr, (hg = ::GlobalAlloc( GMEM_FIXED, dwSize )));

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CryptExportKey( m_hKey, NULL, PRIVATEKEYBLOB, 0, (BYTE*)hg, &dwSize ));

    //
    // Convert from blob to string.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertHGlobalToHex( hg, bstrPrivate ));

    ::GlobalFree( hg ); hg = NULL;

    ////////////////////////////////////////
    //
    // Export public pair.
    //
    dwSize = 0;
    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CryptExportKey( m_hKey, NULL, PUBLICKEYBLOB, 0, NULL, &dwSize ));

    __MPC_EXIT_IF_CALL_RETURNS_NULL(hr, (hg = ::GlobalAlloc( GMEM_FIXED, dwSize )));

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CryptExportKey( m_hKey, NULL, PUBLICKEYBLOB, 0, (BYTE*)hg, &dwSize ));

    //
    // Convert from blob to string.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertHGlobalToHex( hg, bstrPublic ));

    ////////////////////////////////////////

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(hg) ::GlobalFree( hg );

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHCryptKeys::ImportPrivate( /*[in] */ const CComBSTR& bstrPrivate )
{
    __HCP_FUNC_ENTRY( "CPCHCryptKeys::ImportPrivate" );

    HRESULT hr;
    HGLOBAL hg = NULL;



    __MPC_EXIT_IF_METHOD_FAILS(hr, Init());


    //
    // Convert from string to blob.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertHexToHGlobal( bstrPrivate, hg ));

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CryptImportKey( m_hCryptProv, (BYTE*)hg, ::GlobalSize( hg ), NULL, CRYPT_EXPORTABLE, &m_hKey ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(hg) ::GlobalFree( hg );

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHCryptKeys::ImportPublic( /*[in ]*/ const CComBSTR& bstrPublic )
{
    __HCP_FUNC_ENTRY( "CPCHCryptKeys::ImportPublic" );

    HRESULT hr;
    HGLOBAL hg = NULL;



    __MPC_EXIT_IF_METHOD_FAILS(hr, Init());


    //
    // Convert from string to blob.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertHexToHGlobal( bstrPublic, hg ));

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CryptImportKey( m_hCryptProv, (BYTE*)hg, ::GlobalSize( hg ), NULL, 0, &m_hKey ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(hg) ::GlobalFree( hg );

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHCryptKeys::SignData( /*[out]*/ CComBSTR& bstrSignature ,
                                 /*[in ]*/ BYTE*     pbData        ,
                                 /*[in ]*/ DWORD     dwDataLen     )
{
    __HCP_FUNC_ENTRY( "CPCHCryptKeys::SignData" );

    HRESULT    hr;
    DWORD      dwSize = 0;
    HGLOBAL    hg     = NULL;
    HCRYPTHASH hHash  = NULL;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(m_hKey);
        __MPC_PARAMCHECK_NOTNULL(pbData);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CryptCreateHash( m_hCryptProv, CALG_MD5, 0, 0, &hHash ));

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CryptHashData( hHash, pbData, dwDataLen, 0 ));

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CryptSignHash( hHash, AT_SIGNATURE, NULL, 0, NULL, &dwSize ));

    __MPC_EXIT_IF_CALL_RETURNS_NULL(hr, (hg = ::GlobalAlloc( GMEM_FIXED, dwSize )));

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CryptSignHash( hHash, AT_SIGNATURE, NULL, 0, (BYTE*)hg, &dwSize ));

    //
    // Convert from blob to string.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertHGlobalToHex( hg, bstrSignature ));

    ////////////////////////////////////////

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(hg) ::GlobalFree( hg );

    if(hHash) ::CryptDestroyHash( hHash );

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHCryptKeys::VerifyData( /*[in]*/ const CComBSTR& bstrSignature,
                                   /*[in]*/ BYTE*           pbData       ,
                                   /*[in]*/ DWORD           dwDataLen    )
{
    __HCP_FUNC_ENTRY( "CPCHCryptKeys::VerifyData" );

    HRESULT    hr;
    HGLOBAL    hg    = NULL;
    HCRYPTHASH hHash = NULL;


    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(m_hKey);
        __MPC_PARAMCHECK_NOTNULL(pbData);
    __MPC_PARAMCHECK_END();


    //
    // Convert from string to blob.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertHexToHGlobal( bstrSignature, hg ));


    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CryptCreateHash( m_hCryptProv, CALG_MD5, 0, 0, &hHash ));

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CryptHashData( hHash, pbData, dwDataLen, 0 ));

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CryptVerifySignature( hHash, (BYTE*)hg, ::GlobalSize( hg ), m_hKey, NULL, 0 ));

    ////////////////////////////////////////

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(hg) ::GlobalFree( hg );

    if(hHash) ::CryptDestroyHash( hHash );

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\news\lib\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__3D71D225_C4D9_431C_A0A3_A97293C67DC5__INCLUDED_)
#define AFX_STDAFX_H__3D71D225_C4D9_431C_A0A3_A97293C67DC5__INCLUDED_

#include <module.h>

#include <MPC_main.h>
#include <MPC_com.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_config.h>
#include <MPC_streams.h>
#include <MPC_security.h>
#include <HCP_trace.h>

#include <HelpServiceTypeLib.h>

#include <NewsLib.h>

#include <AccountsLib.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__3D71D225_C4D9_431C_A0A3_A97293C67DC5__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\news\lib\newsheadlines.cpp ===
/** Copyright (c) 2000 Microsoft Corporation
 ******************************************************************************
 **     Module Name:
 **
 **             NewsHeadlines.cpp
 **
 **     Astract:
 **
 **             Implementation of CNewsHeadlines
 **
 **     Author:
 **
 **             Martha Arellano (t-alopez) 03-Oct-2000
 **
 **
 **     Revision History:
 **
 **             Martha Arellano (t-alopez) 05-Oct-2000      Added timestamp, frequency and link
 **                                                         to xml file format
 **
 **                                                         Added get_Provider_Frequency() to interface
 **
 **                                        06-Oct-2000      Added Delete_Provider(nBlockIndex) to interface
 **
 **                                                         Added get_Provider_URL(nBlockIndex) to interface
 **
 **                                        11-Oct-2000      Added date in newsver and timestamp in provider
 **
 **                                        15-Nov-2000      Added Provider Icon, Position and Headline Expires attr
 **
 **                                        07-Dec-2000      Added Get_UpdateHeadlines to get_Stream()
 **
 ******************************************************************************
 **/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////
// CONFIG MAP
/////////////////////////////////////////////////////////////////////////////
/*
  <NEWSHEADLINES TIMESTAMP="10/3/2000" DATE="10/4/2000">
    <NEWSBLOCK PROVIDER="Windows Family" LINK="http://www.microsoft.com/family" ICON="logo.gif"
              POSITION="horizontal" FREQUENCY=5 TIMESTAMP="10/4/2000" >
        <HEADLINE ICON="" TITLE="Visit the Windows Family home page for current headlines"
                  LINK="http://www.microsoft.com/windows" DESCRIPTION="Some description (if necessary)" />
    </NEWSBLOCK>
  </NEWSHEADLINES>
*/

CFG_BEGIN_FIELDS_MAP(News::Headlines::Headline)
    CFG_ATTRIBUTE( L"ICON"          	, wstring, 	m_strIcon        	),
    CFG_ATTRIBUTE( L"TITLE"         	, wstring, 	m_strTitle       	),
    CFG_ATTRIBUTE( L"LINK"          	, wstring, 	m_strLink        	),
    CFG_ATTRIBUTE( L"DESCRIPTION"   	, wstring, 	m_strDescription	),
    CFG_ATTRIBUTE( L"EXPIRES"       	, DATE_CIM,	m_dtExpires      	),
    CFG_ATTRIBUTE( L"UPDATEHEADLINES"   , bool   ,	m_fUpdateHeadlines  ),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(News::Headlines::Headline)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(News::Headlines::Headline, L"HEADLINE")

DEFINE_CONFIG_METHODS__NOCHILD(News::Headlines::Headline)

////////////////////

CFG_BEGIN_FIELDS_MAP(News::Headlines::Newsblock)
    CFG_ATTRIBUTE( L"PROVIDER" , wstring , m_strProvider ),
    CFG_ATTRIBUTE( L"LINK"     , wstring , m_strLink     ),
    CFG_ATTRIBUTE( L"ICON"     , wstring , m_strIcon     ),
    CFG_ATTRIBUTE( L"POSITION" , wstring , m_strPosition ),
    CFG_ATTRIBUTE( L"TIMESTAMP", DATE_CIM, m_dtTimestamp ),
    CFG_ATTRIBUTE( L"FREQUENCY", int     , m_nFrequency  ),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(News::Headlines::Newsblock)
    CFG_CHILD(News::Headlines::Headline)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(News::Headlines::Newsblock,L"NEWSBLOCK")


DEFINE_CONFIG_METHODS_CREATEINSTANCE_SECTION(News::Headlines::Newsblock,tag,defSubType)
    if(tag == _cfg_table_tags[0])
    {
        defSubType = &(*(m_vecHeadlines.insert( m_vecHeadlines.end() )));
        return S_OK;
    }
DEFINE_CONFIG_METHODS_SAVENODE_SECTION(News::Headlines::Newsblock,xdn)
    hr = MPC::Config::SaveList( m_vecHeadlines, xdn );
DEFINE_CONFIG_METHODS_END(News::Headlines::Newsblock)

////////////////////

CFG_BEGIN_FIELDS_MAP(News::Headlines)
    CFG_ATTRIBUTE( L"TIMESTAMP"  , DATE_CIM, m_dtTimestamp ),
    CFG_ATTRIBUTE( L"DATE"       , DATE_CIM, m_dtDate      ),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(News::Headlines)
    CFG_CHILD(News::Headlines::Newsblock)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(News::Headlines,L"NEWSHEADLINES")


DEFINE_CONFIG_METHODS_CREATEINSTANCE_SECTION(News::Headlines,tag,defSubType)
    if(tag == _cfg_table_tags[0])
    {
        defSubType = &(*(m_vecNewsblocks.insert( m_vecNewsblocks.end() )));
        return S_OK;
    }
DEFINE_CONFIG_METHODS_SAVENODE_SECTION(News::Headlines,xdn)
    hr = MPC::Config::SaveList( m_vecNewsblocks, xdn );
DEFINE_CONFIG_METHODS_END(News::Headlines)

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//
// Convert a date from CIM format to number of milliseconds since January 1, 1970.
//
static HRESULT local_ConvertDate( /*[in]*/ MPC::XmlUtil& xml      ,
								  /*[in]*/ LPCWSTR       szTag    ,
								  /*[in]*/ LPCWSTR       szAttrib ,
								  /*[in]*/ IXMLDOMNode*  pxdnNode )
{
	__HCP_FUNC_ENTRY( "local_ConvertDate" );

	HRESULT 	 hr;
	bool    	 fFound;
	MPC::wstring strValue;
	DATE         dDate;
	DATE         dDateBase;
	CComVariant  v;


	__MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( szTag, szAttrib, strValue, fFound, pxdnNode ));
	if(fFound)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertStringToDate( strValue, dDate, /*fGMT*/false, /*fCIM*/true, 0 ));

		{
			SYSTEMTIME st;

			st.wYear         = (WORD)1970;
			st.wMonth        = (WORD)1;
			st.wDay          = (WORD)1;
			st.wHour         = (WORD)0;
			st.wMinute       = (WORD)0;
			st.wSecond       = (WORD)0;
			st.wMilliseconds = (WORD)0;

			::SystemTimeToVariantTime( &st, &dDateBase );
		}

		v = (dDate - dDateBase) * 86400.0 * 1000.0; __MPC_EXIT_IF_METHOD_FAILS(hr, v.ChangeType( VT_BSTR ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, xml.ModifyAttribute( szTag, szAttrib, v.bstrVal, fFound, pxdnNode ));
	}

	hr = S_OK;



	__HCP_FUNC_CLEANUP;
	
	__HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

News::Headlines::Headline::Headline()
{
                     				// MPC::wstring m_strIcon;
                     				// MPC::wstring m_strTitle;
                     				// MPC::wstring m_strLink;
                     				// MPC::wstring m_strDescription;
    m_dtExpires = 0; 				// DATE         m_dtExpires;
    m_fUpdateHeadlines = false;		// bool			m_fUpdateHeadlines;
}

News::Headlines::Headline::Headline( /*[in]*/ const MPC::wstring& strIcon        ,
                                     /*[in]*/ const MPC::wstring& strTitle       ,
                                     /*[in]*/ const MPC::wstring& strLink        ,
                                     /*[in]*/ const MPC::wstring& strDescription ,
                                     /*[in]*/ DATE                dtExpires      , 
                                     /*[in]*/ bool                fUpdateHeadlines)
{
    m_strIcon        	= strIcon;        	// MPC::wstring m_strIcon;
    m_strTitle       	= strTitle;       	// MPC::wstring m_strTitle;
    m_strLink       	= strLink;        	// MPC::wstring m_strLink;
    m_strDescription 	= strDescription; 	// MPC::wstring m_strDescription;
    m_dtExpires      	= dtExpires;      	// DATE         m_dtExpires;
    m_fUpdateHeadlines 	= fUpdateHeadlines;	// bool			m_fUpdateHeadlines;
}

////////////////////

News::Headlines::Newsblock::Newsblock()
{
                       // MPC::wstring m_strProvider;
                       // MPC::wstring m_strLink;
                       // MPC::wstring m_strIcon;
                       // MPC::wstring m_strPosition;
    m_dtTimestamp = 0; // DATE         m_dtTimestamp;
    m_nFrequency  = 0; // int          m_nFrequency;
                       //
                       // HeadlineList m_vecHeadlines;
}

//
// Routine Description:
//
//     Determines if its time to update or not, the newsblock
//
// Arguments:
//
//     nBlockIndex         Newsblock index
//
// Return Value:
//
//     returns TRUE if its time to update the newsblock
//
//
bool News::Headlines::Newsblock::TimeToUpdate()
{
    if(m_nFrequency)
    {
        DATE dtNow = MPC::GetLocalTime() - m_nFrequency;

        // then we check if its time to download newsver.xml
        if(dtNow >= m_dtTimestamp) return true;
    }

    return false;
}

HRESULT News::Headlines::Newsblock::Copy( /*[in]*/ const Newsblock&    block      ,
                                          /*[in]*/ const MPC::wstring& strLangSKU ,
                                          /*[in]*/ int                 nProvID    )
{
    __HCP_FUNC_ENTRY( "News::Headlines::Newsblock::Copy" );

    HRESULT hr;

    //
    // copy the member variables
    *this = block;

    //
    // set the time we are modifying the Newsblock
    m_dtTimestamp = MPC::GetLocalTime();

    // check when we have incomplete information and we won't download the icon
    // when there is no Icon
    // when there is no Provider's name
    // when the Icon URL is missing a '/'
    if(!m_strIcon    .empty() &&
       !m_strProvider.empty()  )
    {
    	MPC::wstring	szEnd;
    	GetFileName( m_strIcon, szEnd);
    	
        if(!szEnd.empty())
        {
            MPC::wstring strPath = HC_HELPSET_ROOT HC_HELPSET_SUB_SYSTEM L"\\News\\";
            MPC::wstring strOthers;
            MPC::wstring strImgPath;
            WCHAR        wzProvID[64];
            bool         fUseIcon = false;

            __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SubstituteEnvVariables( strPath ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MakeDir               ( strPath ));

            // add Lang and SKU
            strOthers  = strLangSKU + L'_';
            strOthers += _itow( nProvID, wzProvID, 10 ); // add Provider's ID
            strOthers += L'_';
            strOthers += szEnd; // add the icon's name

            // form the path to this image file
            strImgPath  = strPath;
            strImgPath += strOthers;

            // we check if we have that file already
            if(MPC::FileSystemObject::IsFile( strImgPath.c_str() ))
            {
                fUseIcon = true;
            }
            else
            {
                CComPtr<IStream> streamIn;

                // then, we download the new image
                if(SUCCEEDED(News::LoadFileFromServer( m_strIcon.c_str(), streamIn )))
                {
                    CComPtr<MPC::FileStream> streamImg;

                    if(SUCCEEDED(MPC::CreateInstance    ( &streamImg         )) &&
                       SUCCEEDED(streamImg->InitForWrite( strImgPath.c_str() ))  )
                    {
                        if(SUCCEEDED(MPC::BaseStream::TransferData( streamIn, streamImg )))
                        {
                            fUseIcon = true;
                        }
                    }
                }
            }

            if(fUseIcon)
            {
                m_strIcon  = L"hcp://system/news/";
                m_strIcon += strOthers;
            }
            else
            {
                m_strIcon    .erase();
                m_strPosition.erase();
            }
        }
    }


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void News::Headlines::Newsblock::GetFileName( MPC::wstring strURL, MPC::wstring& strFileName )
{
	MPC::wstring::size_type		pos;

	if(!strURL.empty())
	{
	    if((pos = strURL.find_last_of( '/' )) == strURL.length() - 1)
    	{
    		strURL.resize( strURL.length() - 1 );
    		pos = strURL.find_last_of( '/' );
    	}

		if(pos != MPC::wstring::npos)
		{	
			strFileName.assign( strURL, pos, strURL.length() - pos );
			// Go thro the string and delete all invalid characters
			pos = 0; 
			while(!strFileName.empty() && pos < strFileName.length())
			{
				if((strFileName[pos] == '\\') || (strFileName[pos] == '/') || (strFileName[pos] == ':') || 
					(strFileName[pos] == '*') || (strFileName[pos] == '?') || (strFileName[pos] == '"') ||
					(strFileName[pos] == '<') || (strFileName[pos] == '>') || (strFileName[pos] == '|'))
				{
					strFileName.erase( pos, 1 );
				}
				else
				{
					pos++;
				}
			}
		}
	}
}


////////////////////////////////////////////////////////////////////////////////

News::Headlines::Headlines()
{
    m_dtTimestamp = 0; // DATE          m_dtTimestamp;
    m_dtDate      = 0; // DATE          m_dtDate;
                       //
                       // NewsblockList m_vecNewsblocks;
}

//
// Routine Description:
//
//     Clears the News::Headlines Class' variables and lists, so it can be loaded againg
//
// Arguments:
//
//     None
//
//
HRESULT News::Headlines::Clear()
{
    __HCP_FUNC_ENTRY( "News::Headlines::Clear" );

    HRESULT hr;

    m_dtTimestamp = 0;
    m_dtDate      = 0;

    m_vecNewsblocks.clear();

    hr = S_OK;


    __HCP_FUNC_EXIT(hr);
}

//
// Routine Description:
//
//     Loads the specified file and validates it (from the local disk or from the server)
//
// Arguments:
//
//     strPath     the path for the news headlines file (or newsblock)
//
//
HRESULT News::Headlines::Load( /*[in]*/ const MPC::wstring& strPath )
{
    __HCP_FUNC_ENTRY( "News::Headlines::Load" );

    HRESULT          hr;
    CComPtr<IStream> stream;


    // we load the file
    __MPC_EXIT_IF_METHOD_FAILS(hr, News::LoadXMLFile( strPath.c_str(), stream ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::Config::LoadStream( this, stream ));

    //validate file
    //
    if(m_vecNewsblocks.size() == 0)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_INVALID_DATA);
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

//
// Routine Description:
//
//     The newsheadlines file is saved in the local user disk
//
//     the timestamp is updated
//
// Arguments:
//
//     strPath          the path and name of the newsheadlines file
//
//
HRESULT  News::Headlines::Save( /*[in]*/ const MPC::wstring& strPath )
{
    __HCP_FUNC_ENTRY( "News::Headlines::Save" );

    HRESULT hr;

    // the date is updated every time it is saved
    m_dtDate = MPC::GetLocalTime();

    // we save the file
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::Config::SaveFile( this, strPath.c_str() ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


//
// Routine Description:
//
//     Reloads the newsheadlines file and then returns it as a stream
//
//     We check the Expires attribute in each headline, if it has expired then its deleted
//     if a provider loses all its headlines, then the provider (newsblock) is deleted too
//
//     If all Newsblocks are deleted, we return ERROR_INVALID_DATA, to display the offline message
//
//     We save the changes in the News Headlines file
//
// Arguments:
//
//     strPath         path for the newsheadlines file
//
// Return Value:
//
//     pVal                IStream with the newsheadlines xml content
//
//
HRESULT News::Headlines::	get_Stream( /*[in ]*/ long                 lLCID   ,
                                     /*[in ]*/ const MPC::wstring&  strSKU  ,                                 
                                     /*[in ]*/ const MPC::wstring&  strPath ,
                                     /*[out]*/ IUnknown*           *pVal    )
{
    __HCP_FUNC_ENTRY( "News::Headlines::get_Stream" );

    HRESULT          hr;
    MPC::XmlUtil     xml;
    UpdateHeadlines  uhUpdate;
    CComPtr<IStream> stream;
    bool             fModified = false;
    DATE             dtNow     = MPC::GetLocalTime();
    NewsblockIter    itNewsblock;


    // we clear the object
    Clear();

    // we load the News Headlines file
    __MPC_EXIT_IF_METHOD_FAILS(hr, News::LoadXMLFile( strPath.c_str(), stream ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::Config::LoadStream( this, stream ));

    // ****** delete expired headlines

    // for each newsblock
    itNewsblock = m_vecNewsblocks.begin();
    while(itNewsblock != m_vecNewsblocks.end())
    {
        Newsblock&   nb         = *itNewsblock;
        HeadlineIter itHeadline = nb.m_vecHeadlines.begin();

        while(itHeadline != nb.m_vecHeadlines.end())
        {
            // check each headline if it has expired
            if(itHeadline->m_dtExpires < dtNow)
            {
                // if expired, deleted
                nb.m_vecHeadlines.erase( itHeadline );

                fModified = true;
            }
            else
            {
                // we go to the next headline
                itHeadline++;
            }
        }

        // if the Newsblock has no headlines valid
        if(itNewsblock->m_vecHeadlines.empty())
        {
            // we delete it
            m_vecNewsblocks.erase( itNewsblock );
        }
        else
        {
            // we go to the next Newsblock
            itNewsblock++;
        }
    }

    if(fModified)
    {
        // if we deleted headlines or newsblocks we save the News Headlines file
        __MPC_EXIT_IF_METHOD_FAILS(hr, Save( strPath ));
    }

    // if there aren't Newsblocks left, we return an error
    if(m_vecNewsblocks.empty())
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_INVALID_DATA);
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::Config::SaveXmlUtil( this, xml ));

 	__MPC_EXIT_IF_METHOD_FAILS(hr, local_ConvertDate( xml, NULL, L"TIMESTAMP", NULL ));
 	__MPC_EXIT_IF_METHOD_FAILS(hr, local_ConvertDate( xml, NULL, L"DATE"     , NULL ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.SaveAsStream( pVal ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

//
// Routine Description:
//
//     Checks to see if there atleast a single Newsblock which has an icon
//
// Arguments:
//
//     None
//
// Return Value:
//
//     true or false
//
bool News::Headlines::CheckIfImagesExist()
{
    // Note that this function does NOT check to see if a headline has an icon. This is because headline icons are not
    // being processed (even though the ICON attribute exists in the HEADLINE tag). 
    
	NewsblockIter    itNewsblock;

    itNewsblock = m_vecNewsblocks.begin();
    while(itNewsblock != m_vecNewsblocks.end())
    {
    	if(!itNewsblock->m_strIcon.empty())
    	{
    		return true;
    	}
    	else
    	{
    		itNewsblock++;
    	}
    }
    return false;
}


//
// Routine Description:
//
//     Sets the News Headlines timestamp to the current time
//     This method should be called when all the newsblocks are retrieved
//
// Arguments:
//
//     None
//
// Return Value:
//
//     None
//
//
void News::Headlines::set_Timestamp()
{
    m_dtTimestamp = MPC::GetLocalTime();
}


News::Headlines::Newsblock* News::Headlines::get_Newsblock( /*[in]*/ size_t nBlockIndex )
{
    if(nBlockIndex >= m_vecNewsblocks.size()) return NULL;

    return &(m_vecNewsblocks[ nBlockIndex ]);
}

////////////////////////////////////////
//
// Routine Description:
//
//     From the provided newsblock this method gets the first two headlines
//     and adds it to the first newsblock
//
// Arguments:
//
//     None
//
// Return Value:
//
//     None
//
//

HRESULT News::Headlines::AddHomepageHeadlines( /*[in]*/ const Headlines::Newsblock& block )
{
    __HCP_FUNC_ENTRY( "News::Headlines::AddHomepageHeadlines" );

    HRESULT       	hr;
    size_t			nIndex = 0;
    NewsblockIter 	itNewsblock;
    HeadlineIter	itHeadline;

	// Add 2 headlines to the first newsblock
	itNewsblock = m_vecNewsblocks.begin();
	while ( itNewsblock && ( ++nIndex <= NUMBER_OF_OEM_HEADLINES ) )
	{
		// If a headline already exists delete it before adding a new one
		if ( nIndex < itNewsblock->m_vecHeadlines.size() )
		{
			itHeadline = itNewsblock->m_vecHeadlines.begin();
			std::advance( itHeadline, nIndex );
			// Delete the existing headline before adding it
			itNewsblock->m_vecHeadlines.erase( itHeadline );
			// Add the headline
			itNewsblock->m_vecHeadlines.insert( itHeadline, block.m_vecHeadlines[nIndex - 1] );
		}
		else
		{
			// Insert the headline to the end of the list
			itNewsblock->m_vecHeadlines.insert( itNewsblock->m_vecHeadlines.end(), block.m_vecHeadlines[nIndex - 1] );
		}
	}

    hr = S_OK;


   return S_OK;
}

////////////////////////////////////////

HRESULT News::Headlines::AddNewsblock( /*[in]*/ const Headlines::Newsblock& block      ,
                                       /*[in]*/ const MPC::wstring&         strLangSKU )
{
    __HCP_FUNC_ENTRY( "News::Headlines::AddNewsblock" );

    HRESULT       hr;
    NewsblockIter itNewsblock;


    itNewsblock = m_vecNewsblocks.insert( m_vecNewsblocks.end() );

    __MPC_EXIT_IF_METHOD_FAILS(hr, itNewsblock->Copy( block, strLangSKU, m_vecNewsblocks.size()-1 ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\news\lib\newsver.cpp ===
/** Copyright (c) 2000 Microsoft Corporation
 ******************************************************************************
 **     Module Name:
 **
 **             Newsver.cpp
 **
 **     Abstract:
 **
 **             Implementation of Newsver class
 **
 **     Author:
 **
 **             Martha Arellano (t-alopez) 03-Oct-2000
 **
 **
 **     Revision History:
 **
 **             Martha Arellano (t-alopez) 05-Oct-2000      Changed Newsver.xml format
 **
 **                                        11-Oct-2000      Added URL and get_URL property
 **
 **                                        12-Oct-2000      Added Download method
 **
 **
 ******************************************************************************
 **/

#include "stdafx.h"

//////////////////////////////////////////////////////////////////////
// CONFIG MAP
//////////////////////////////////////////////////////////////////////

/*<?xml version="1.0" ?>
<NEWSVER URL="www" FREQUENCY="20">
    <LANGUAGE LCID="1033">
        <SKU VERSION="Personal">
            <NEWSBLOCK URL="http://windows.microsoft.com" />
        </SKU>
    </LANGUAGE>
</NEWSVER>
*/


CFG_BEGIN_FIELDS_MAP(News::Newsver::Newsblock)
    CFG_ATTRIBUTE( L"URL", wstring, m_strURL ),
    CFG_ATTRIBUTE( L"OEM", bool, m_fNewsblockHasHeadlines ),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(News::Newsver::Newsblock)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(News::Newsver::Newsblock, L"NEWSBLOCK")

DEFINE_CONFIG_METHODS__NOCHILD(News::Newsver::Newsblock)

////////////////////

CFG_BEGIN_FIELDS_MAP(News::Newsver::SKU)
    CFG_ATTRIBUTE( L"VERSION", wstring, m_strSKU),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(News::Newsver::SKU)
    CFG_CHILD(News::Newsver::Newsblock)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(News::Newsver::SKU, L"SKU")


DEFINE_CONFIG_METHODS_CREATEINSTANCE_SECTION(News::Newsver::SKU,tag,defSubType)
    if(tag == _cfg_table_tags[0])
    {
        defSubType = &(*(m_vecNewsblocks.insert( m_vecNewsblocks.end() )));
        return S_OK;
    }
DEFINE_CONFIG_METHODS_SAVENODE_SECTION(News::Newsver::SKU,xdn)
    hr = MPC::Config::SaveList( m_vecNewsblocks, xdn );
DEFINE_CONFIG_METHODS_END(News::Newsver::SKU)

////////////////////

CFG_BEGIN_FIELDS_MAP(News::Newsver::Language)
    CFG_ATTRIBUTE( L"LCID", long, m_lLCID ),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(News::Newsver::Language)
    CFG_CHILD(News::Newsver::SKU)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(News::Newsver::Language,L"LANGUAGE")

DEFINE_CONFIG_METHODS_CREATEINSTANCE_SECTION(News::Newsver::Language,tag,defSubType)
    if(tag == _cfg_table_tags[0])
    {
        defSubType = &(*(m_lstSKUs.insert( m_lstSKUs.end() )));
        return S_OK;
    }
DEFINE_CONFIG_METHODS_SAVENODE_SECTION(News::Newsver::Language,xdn)
    hr = MPC::Config::SaveList( m_lstSKUs, xdn );
DEFINE_CONFIG_METHODS_END(News::Newsver::Language)

////////////////////

CFG_BEGIN_FIELDS_MAP(News::Newsver)
    CFG_ATTRIBUTE( L"URL",       wstring, m_strURL     ),
    CFG_ATTRIBUTE( L"FREQUENCY", int    , m_nFrequency ),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(News::Newsver)
    CFG_CHILD(News::Newsver::Language)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(News::Newsver,L"NEWSVER")


DEFINE_CONFIG_METHODS_CREATEINSTANCE_SECTION(News::Newsver,tag,defSubType)
    if(tag == _cfg_table_tags[0])
    {
        defSubType = &(*(m_lstLanguages.insert( m_lstLanguages.end() )));
        return S_OK;
    }
DEFINE_CONFIG_METHODS_SAVENODE_SECTION(News::Newsver,xdn)
    hr = MPC::Config::SaveList( m_lstLanguages, xdn );
DEFINE_CONFIG_METHODS_END(News::Newsver)

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

News::Newsver::Newsblock::Newsblock()
{
    // MPC::wstring m_strURL;
}

News::Newsver::SKU::SKU()
{
    // MPC::wstring    m_strSKU;
    // NewsblockVector m_vecNewsblocks;
}

News::Newsver::Language::Language()
{
    m_lLCID = 0; // long    m_lLCID;
                 // SKUList m_lstSKUs;

}

News::Newsver::Newsver()
{
        			      // MPC::wstring m_strURL;
    m_nFrequency = 0;     // int          m_nFrequency;
	m_fLoaded    = false; // bool         m_fLoaded;
	m_fDirty     = false; // bool         m_fDirty;
						  // 			  
        				  // LanguageList m_lstLanguages;
}

/////////////////////////////////////////////////////////////////////////////

//
// Routine Description:
//
//	   Downloads the newsver.xml file and saves it in HC_HCUPDATE_NEWSVER
//
// Arguments:
//
//	   strNewsverURL       the URL for newsver.xml
//
HRESULT News::Newsver::Download( /*[in]*/ const MPC::wstring& strNewsverURL )
{
    __HCP_FUNC_ENTRY( "News::Newsver::Download" );

    HRESULT          hr;
	CComPtr<IStream> stream;
    MPC::wstring     strPath;


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SubstituteEnvVariables( strPath = HC_HCUPDATE_NEWSVER ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MakeDir               ( strPath                       ));


	__MPC_EXIT_IF_METHOD_FAILS(hr, News::LoadXMLFile( strNewsverURL.c_str(), stream ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::Config::LoadStream( this, stream ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::Config::SaveFile( this, strPath.c_str() ));

    hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}




//
// Routine Description:
//
//	   Loads the cached newsver.xml file and looks for the newsblocks for the specified LCID and SKUVersion
//
//	   if the newsblocks are found, m_fReady is TRUE
//
// Arguments:
//
//	   lLCID            the Language to look for
//
//	   strSKU			the SKU to look for
//
//
HRESULT News::Newsver::Load( /*[in]*/ long lLCID, /*[in]*/ const MPC::wstring& strSKU )
{
    __HCP_FUNC_ENTRY( "News::Newsver::Load" );

    HRESULT      hr;
    MPC::wstring strPath = HC_HCUPDATE_NEWSVER; MPC::SubstituteEnvVariables( strPath );


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::Config::LoadFile( this, strPath.c_str() ));

    /////////////// looks for LCID and SKU

	m_data = NULL;
    for(LanguageIter it = m_lstLanguages.begin(); it != m_lstLanguages.end(); it++)
    {
        if(it->m_lLCID == lLCID)
        {
			for(SKUIter it2 = it->m_lstSKUs.begin(); it2 != it->m_lstSKUs.end(); it2++)
            {
                if(!MPC::StrICmp( it2->m_strSKU, strSKU ))
                {
					m_data = &(*it2);
					break;
                }
            }
			break;
        }
    }

	if(m_data == NULL)
	{
		__MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_INVALID_DATA);
	}

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

//
// Routine Description:
//
//	   Returns true if the newsblock has the HEADLINES attribute set to true else returns false
//
bool News::Newsver::OEMNewsblock( /*[in]*/ size_t nIndex )
{
    if(m_data == NULL || nIndex >= m_data->m_vecNewsblocks.size() )
    {
		return false;
    }

	return (m_data->m_vecNewsblocks[nIndex].m_fNewsblockHasHeadlines);
}

////////////////////////////////////////////////////////////////////////////////

size_t News::Newsver::get_NumberOfNewsblocks()
{
	return m_data ? m_data->m_vecNewsblocks.size() : 0;
}

const MPC::wstring* News::Newsver::get_NewsblockURL( /*[in]*/ size_t nIndex )
{
    if(m_data == NULL || nIndex >= m_data->m_vecNewsblocks.size() )
    {
		return NULL;
    }

	return &(m_data->m_vecNewsblocks[nIndex].m_strURL);
}

const MPC::wstring* News::Newsver::get_URL()
{
	return m_strURL.size() ? &m_strURL : NULL;
}

int News::Newsver::get_Frequency()
{
	return m_nFrequency;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\news\lib\newslib.cpp ===
/** Copyright (c) 2000 Microsoft Corporation
 ******************************************************************************
 **     Module Name:
 **
 **             Newslib.cpp
 **
 **     Abstract:
 **
 **             Implementation of CNewslib ( get_News )
 **
 **     Author:
 **
 **             Martha Arellano (t-alopez) 03-Oct-2000
 **
 **
 **     Revision History:
 **
 **             Martha Arellano (t-alopez) 05-Oct-2000      Changed goto statements
 **                                                         Load creates newsset.xml if missing
 **                                                         Added Time_To_Update()
 **
 **                                        06-Oct-2000      Added Update_NewsBlocks()
 **
 **                                        13-Oct-2000      Added Update_Newsver()
 **
 **                                        25-Oct-2000      Added get_Headlines_Enabled() to interface
 **
 ******************************************************************************
 **/

#include "stdafx.h"
#include <strsafe.h>


/////////////////////////////////////////////////////////////////////////////
// CNews
/////////////////////////////////////////////////////////////////////////////
/*  <?xml version="1.0" ?>
    <NEWSSETTINGS xmlns="x-schema:NewsSetSchema.xml"
        URL="http://windows.microsoft.com/redir.dll?"
        FREQUENCY="weekly"
        TIMESTAMP="1988-04-07T18:39:09" /> */
//////////////////////////////////////////////////////////////

CFG_BEGIN_FIELDS_MAP(News::Main)
    CFG_ATTRIBUTE( L"URL",       wstring , m_strURL      ),
    CFG_ATTRIBUTE( L"FREQUENCY", int     , m_nFrequency  ),
    CFG_ATTRIBUTE( L"TIMESTAMP", DATE_CIM, m_dtTimestamp ),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(News::Main)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(News::Main,L"NEWSSETTINGS")


DEFINE_CONFIG_METHODS__NOCHILD(News::Main)

///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////

News::Main::Main()
{
                           		   // MPC::wstring m_strURL;
    m_nFrequency  = -1;     		   // int          m_nFrequency;
    m_dtTimestamp = 0;     		   // DATE         m_dtTimestamp;
    m_fLoaded     = false; 		   // bool         m_fLoaded;
    m_fDirty      = false; 		   // bool         m_fDirty;
                           		   // 
                           		   // long         m_lLCID;
                           		   // MPC::wstring m_strSKU;
                           		   // MPC::wstring m_strLangSKU;
                           		   // MPC::wstring m_strNewsHeadlinesPath;
    m_fOnline     = VARIANT_FALSE; // VARIANT_BOOL m_fOnline;
    m_fConnectionStatusChecked = VARIANT_FALSE; // VARIANT_BOOL m_fConnectionStatusChecked;
}

/////////////////////////////////////////////////////////////////////////////

//
// Routine Description:
//
//	   The cached news settings file is loaded and validated from the path in HC_HCUPDATE_NEWSSETTINGS
//
//	   If the file is valid, the flag m_fLoaded will be set to true
//
// Arguments:
//
//
HRESULT News::Main::Load()
{
    __HCP_FUNC_ENTRY( "News::Main::Load" );

    HRESULT hr;


	if(m_fLoaded == false)
	{
		MPC::wstring 	 strPath( HC_HCUPDATE_NEWSSETTINGS ); MPC::SubstituteEnvVariables( strPath );
		CComPtr<IStream> stream;

		__MPC_EXIT_IF_METHOD_FAILS(hr, News::LoadXMLFile( strPath.c_str(), stream ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::Config::LoadStream( this, stream ));

		//
		// validate the news settings
		//
		if(m_strURL.empty()      ||
		   m_nFrequency     <  0 ||
		   m_dtTimestamp    == 0  )
		{
			__MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_INVALID_DATA);
		}

		m_fLoaded = true;
		m_fDirty  = false;
    }

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	if(FAILED(hr))
	{
		hr = Restore( m_lLCID );
	}

	__HCP_FUNC_EXIT(hr);
}




//
// Routine Description:
//
//	   Restores the default values to the News Settings class and saves it
//	   the flag m_fReady will be set to TRUE
//
// Arguments:
//
//
HRESULT News::Main::Restore( /*[in]*/ long lLCID )
{
    __HCP_FUNC_ENTRY( "News::Main::Restore" );

    HRESULT hr;
    WCHAR   rgLCID[64];

    // set the default values

    m_strURL  = NEWSSETTINGS_DEFAULT_URL;		//redir.dll
	//m_strURL += _itow( lLCID, rgLCID, 10 ); // add LCID parameter to the URL

    m_nFrequency  = NEWSSETTINGS_DEFAULT_FREQUENCY;
    m_dtTimestamp = MPC::GetLocalTime() - NEWSSETTINGS_DEFAULT_FREQUENCY; // we set the timestamp, so that it will try to update news headlines file

	m_fLoaded = true;
	m_fDirty  = true;

    // we save NewsSet.xml
    __MPC_EXIT_IF_METHOD_FAILS(hr, Save());

    hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}


//
// Routine Description:
//
//	   This saves the cached NewsSettings file in the local user disk in the path of HC_HCUPDATE_NEWSSETTINGS
//
// Arguments:
//
//	   None
//
//
HRESULT News::Main::Save()
{
    __HCP_FUNC_ENTRY( "News::Main::Save" );

    HRESULT hr;

	if(m_fDirty)
	{
		MPC::wstring strPath( HC_HCUPDATE_NEWSSETTINGS ); MPC::SubstituteEnvVariables( strPath );

		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::Config::SaveFile( this, strPath.c_str() ));

		m_fDirty = false;
	}

    hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

HRESULT News::Main::get_URL( /*[out]*/ BSTR *pVal )
{
    __HCP_FUNC_ENTRY( "News::Main::get_URL" );

    HRESULT hr;

	(void)Load();     //check to see if it has been loaded

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_strURL.c_str(), pVal ));

    hr = S_OK;

    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT News::Main::put_URL( /*[in]*/ BSTR newVal )
{
    __HCP_FUNC_ENTRY( "News::Main::put_URL" );

    HRESULT hr;

	(void)Load();

    m_strURL = SAFEBSTR( newVal );

    hr = S_OK;

    __MPC_FUNC_EXIT(hr);
}


HRESULT News::Main::get_Frequency( /*[out]*/ int *pVal )
{
    __HCP_FUNC_ENTRY( "News::Main::get_Frequency" );

    HRESULT hr;

	(void)Load(); //check to see if it has been loaded

    if(pVal) *pVal = m_nFrequency;

    hr = S_OK;

    __MPC_FUNC_EXIT(hr);
}

HRESULT News::Main::put_Frequency( /*[in]*/ int newVal )
{
    __HCP_FUNC_ENTRY( "News::Main::put_Frequency" );

    HRESULT hr;

	(void)Load();     //check to see if it has been loaded

    m_nFrequency  = newVal;
	m_dtTimestamp = MPC::GetLocalTime() - m_nFrequency; // also set timestamp, so that it will try to update news headlines file

    hr = S_OK;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////

//
// Routine Description:
//
//	   Determines if its time to update newsver or not
//
//	   we assume the newsset has been loaded (m_fReady = TRUE)
//
// Arguments:
//
//	   None
//
// Return Value:
//
//	   fGet - returns TRUE if its time to update the news
//
//
bool News::Main::IsTimeToUpdateNewsver()
{
    __HCP_FUNC_ENTRY( "News::Main::IsTimeToUpdateNewsver" );

	DATE dtNow;

	(void)Load();

	dtNow = MPC::GetLocalTime() - m_nFrequency;

    // then we check if its time to download newsver.xml
    return ((dtNow >= m_dtTimestamp) && m_nFrequency >= 0);
}

////////////////////

//
// Routine Description:
//
//	   This routine will go to the process of Updating the Newsver file
//	   - download newsver.xml from m_strURL
//	   - save it
//	   - update the News Settings cached file
//
// Arguments:
//
//	   None
//
//
HRESULT News::Main::Update_Newsver( /*[in]*/ Newsver& nwNewsver )
{
    __HCP_FUNC_ENTRY( "News::Main::Update_Newsver" );

    HRESULT hr;

	// If the connection status has already been checked then dont do it again else check the connection status
	if( !m_fConnectionStatusChecked )
	{
		m_fOnline =	CheckConnectionStatus( );
	}

	if ( !m_fOnline )
	{
		// If not connected to the network then return ERROR_INTERNET_DISCONNECTED
		__MPC_SET_WIN32_ERROR_AND_EXIT ( hr, ERROR_INTERNET_DISCONNECTED );
	}
	
	(void)Load();

    // download newsver and save it
    __MPC_EXIT_IF_METHOD_FAILS( hr, nwNewsver.Download( m_strURL ));

    // check if URL from Newsver has changed and is valid
	{
        const MPC::wstring* pstr = nwNewsver.get_URL();

		if(pstr && pstr->size())
		{
			m_strURL = *pstr;
		}
	}

    // check if frequency from Newsver has changed and is valid
	{
		int nFrequency = nwNewsver.get_Frequency();

		if(nFrequency >= 0)
		{
			m_nFrequency = nFrequency;
		}
	}

    // change timestamp of newsset.xml
    m_dtTimestamp = MPC::GetLocalTime();
	m_fDirty      = true;

    // save News Settings cached file
    __MPC_EXIT_IF_METHOD_FAILS( hr, Save());


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}


//
// Routine Description:
//
//	   This routine will go to the process of Update the NewsHeadlines in the local user disk:
//	   - download the newsblocks
//	   - integrate the newsblocks and save them as newsheadlines.xml
//
// Arguments:
//
//	   None
//
//
HRESULT News::Main::Update_NewsHeadlines( /*[in]*/ Newsver&   nwNewsver   ,
										  /*[in]*/ Headlines& nhHeadlines )
{
    __HCP_FUNC_ENTRY( "News::Main::Update_NewsHeadlines" );

    HRESULT hr;
	bool fOEMBlockAdded = false;
    size_t  nNumBlocks = nwNewsver.get_NumberOfNewsblocks();


	// If the connection status has already been checked then dont do it again else check the connection status
	if( !m_fConnectionStatusChecked )
	{
		m_fOnline =	CheckConnectionStatus( );
	}

	if ( !m_fOnline )
	{
		// If not connected to the network then return ERROR_INTERNET_DISCONNECTED
		__MPC_SET_WIN32_ERROR_AND_EXIT ( hr, ERROR_INTERNET_DISCONNECTED );
	}

    // clear the News Headlines cached file
    __MPC_EXIT_IF_METHOD_FAILS(hr, nhHeadlines.Clear());


    // for each newsblock
    for(size_t i=0; i<nNumBlocks; i++)
    {
		const MPC::wstring* pstr = nwNewsver.get_NewsblockURL( i );

		if(pstr)
		{
			Headlines nh;

			// load the newsblock
			if(SUCCEEDED(nh.Load( *pstr )))
			{
				const Headlines::Newsblock* block = nh.get_Newsblock( 0 );

				if(block)
				{
					// Code to check if an OEM block containing headlines exists
					if (!fOEMBlockAdded && nwNewsver.OEMNewsblock( i ) == true)
					{
						// This newsblock contains headlines - extract the first two headlines and add them to the first newsblock
						fOEMBlockAdded = true;
						nhHeadlines.AddHomepageHeadlines( *block );
					}
					
					// we are adding another newsblock
					if(SUCCEEDED(nhHeadlines.AddNewsblock( *block, m_strLangSKU )))
					{
						;
					}
				}
			}
		}
	}

    if(nhHeadlines.get_NumberOfNewsblocks()) // if the news headlines cached file has at least one newsblock
    {
        // change the timestamp of the NewsHeadlines
        nhHeadlines.set_Timestamp();

        // save the new newsheadlines cached file in the user's local disk
        __MPC_EXIT_IF_METHOD_FAILS( hr, nhHeadlines.Save( m_strNewsHeadlinesPath ));
    }


    hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

//
// Routine Description:
//
//	   This routine will update the newsblocks needed
//	   - determine newsblocks to download
//	   - download the newsblocks
//	   - save changes to newsheadlines.xml
//	   - update news settings
//
// Arguments:
//
//	   None
//
//
HRESULT News::Main::Update_NewsBlocks( /*[in]*/ Newsver&   nwNewsver   ,
									   /*[in]*/ Headlines& nhHeadlines )
{
    __HCP_FUNC_ENTRY( "News::Main::Update_NewsBlocks" );

    HRESULT 	 hr;
    size_t  	 nNumBlocks     = nhHeadlines.get_NumberOfNewsblocks();
	size_t  	 nNumBlockCount = 0;
    MPC::wstring strURLtemp;


	// If the connection status has already been checked then dont do it again else check the connection status
	if( !m_fConnectionStatusChecked )
	{
		m_fOnline =	CheckConnectionStatus( );
	}

	if ( !m_fOnline )
	{
		// If not connected to the network then return ERROR_INTERNET_DISCONNECTED
		__MPC_SET_WIN32_ERROR_AND_EXIT ( hr, ERROR_INTERNET_DISCONNECTED );
	}

    // for each newsfile
    for(size_t i=0; i<nNumBlocks; i++)
    {
		Headlines::Newsblock* nb      = nhHeadlines.get_Newsblock   ( i );
		const MPC::wstring*   pstrURL = nwNewsver  .get_NewsblockURL( i );

        // check if its time to update that newsblock (provider)
		if(pstrURL && nb && nb->TimeToUpdate())
		{
			Headlines nh;

			// load the newsblock
			if(SUCCEEDED(nh.Load( *pstrURL )))
			{
				Headlines::Newsblock* nbNew = nh.get_Newsblock( 0 );

				// we are modifying another newsblock
				if(nbNew && SUCCEEDED(nb->Copy( *nbNew, m_strLangSKU, i )))
				{
					;
				}
			}
        }
    }

	// save the new newsheadlines cached file in the user's local disk
	__MPC_EXIT_IF_METHOD_FAILS( hr, nhHeadlines.Save( m_strNewsHeadlinesPath ));

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////


HRESULT News::Main::Init( /*[in]*/ long lLCID, /*[in]*/ BSTR bstrSKU )
{
    __HCP_FUNC_ENTRY( "News::Main::Init" );

	HRESULT hr;
    WCHAR   rgLangSKU[256];
	LPCWSTR szEnd;
	size_t  len;

	SANITIZEWSTR( bstrSKU );
	szEnd = wcschr( bstrSKU, '_' );
	len   = szEnd ? szEnd - bstrSKU : wcslen( bstrSKU );

    m_lLCID      = lLCID;
    m_strSKU.assign( bstrSKU, len );	StringCchPrintfW( rgLangSKU, ARRAYSIZE(rgLangSKU), L"%d_%s", lLCID, m_strSKU.c_str() );
	m_strLangSKU = rgLangSKU;

	m_strNewsHeadlinesPath  = HC_HCUPDATE_NEWSHEADLINES;
	m_strNewsHeadlinesPath += m_strLangSKU;
	m_strNewsHeadlinesPath += L".xml"; MPC::SubstituteEnvVariables( m_strNewsHeadlinesPath );

	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MakeDir( m_strNewsHeadlinesPath ));

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

//
// Routine Description:
//
//	   Function that determines and downloads the latest news headlines if needed,
//	   or returns the cached news headlines from the user's local disk
//
// Arguments:
//
//	   lLCIDreq		the Language ID of the News to get
//
//	   bstrSKU		the SKU of the News to get
//
// Return Value:
//
//	   pVal        IStream loaded with the newsheadlines to display
//
//
HRESULT News::Main::get_News( /*[in]*/ long lLCID, /*[in]*/ BSTR bstrSKU, /*[out]*/ IUnknown* *pVal )
{
    __HCP_FUNC_ENTRY( "News::Main::get_News" );

    HRESULT   hr;
    Newsver   nwNewsver;
    Headlines nhHeadlines;
	MPC::wstring strPath = HC_HELPSET_ROOT HC_HELPSET_SUB_SYSTEM L"\\News\\"; 

	__MPC_EXIT_IF_METHOD_FAILS(hr, Init( lLCID, bstrSKU ));
	
    // 1.0 Load cached News Settings file
	__MPC_EXIT_IF_METHOD_FAILS(hr, Load());

    // Is time to update newsver?
	if(IsTimeToUpdateNewsver() || FAILED(nwNewsver.Load( m_lLCID, m_strSKU )))
    {
		// try to update newsver
		if(SUCCEEDED(Update_Newsver( nwNewsver )))
		{
			// try load cached newsver
			if(SUCCEEDED(nwNewsver.Load( m_lLCID, m_strSKU )))
			{
				// 2.0 try to update the News Headlines file
				Update_NewsHeadlines( nwNewsver, nhHeadlines );
			}
		}
	}    
    else    // not time to update NewsHeadlines
    {
        size_t nNumBlocksNewsver = nwNewsver.get_NumberOfNewsblocks();

        // we try to load cached NewsHeadlines file and we check the number of newsblocks
        if(SUCCEEDED(nhHeadlines.Load( m_strNewsHeadlinesPath )) && nhHeadlines.get_NumberOfNewsblocks() == nNumBlocksNewsver)
        {
            DATE dtHeadlines = nhHeadlines.get_Timestamp();

            // check if the cached NewsHeadlines is Outdated
            if(dtHeadlines && (dtHeadlines < m_dtTimestamp))
            {
				// 2.0 try to update the News Headlines file
				Update_NewsHeadlines( nwNewsver, nhHeadlines );
            }
            else
            {
                size_t nNumBlocks = nhHeadlines.get_NumberOfNewsblocks();

                // check to see if its time to update at least 1 newsblock
				for(size_t i=0; i<nNumBlocks; i++)
				{
					Headlines::Newsblock* nb = nhHeadlines.get_Newsblock( i );

                    // check if its time to update that newsblock (provider)
					if(nb && nb->TimeToUpdate())
					{
						// 3.0 update newsblocks
						Update_NewsBlocks( nwNewsver, nhHeadlines );
						break;
					}
                }
            }
        }
        else    // cached News Headlines not valid
        {
			// 2.0 try to update the News Headlines file
			__MPC_EXIT_IF_METHOD_FAILS(hr, Update_NewsHeadlines( nwNewsver, nhHeadlines ));
        }
    }

	// Reload the NewsHeadlines file contains images and if the System\News folder has been deleted - fix for bug 522860
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SubstituteEnvVariables( strPath ));

    if(!MPC::FileSystemObject::IsDirectory( strPath.c_str() ))
    {
    	if(nhHeadlines.CheckIfImagesExist())
    	{
    		__MPC_EXIT_IF_METHOD_FAILS(hr, Update_NewsHeadlines( nwNewsver, nhHeadlines ));
    	}
    }

	// Add news items from HCUpdate 
	__MPC_EXIT_IF_METHOD_FAILS(hr, AddHCUpdateNews(m_strNewsHeadlinesPath));

    // 4.0 Return cached NewsHeadlines file
    __MPC_EXIT_IF_METHOD_FAILS(hr, nhHeadlines.get_Stream( m_lLCID, m_strSKU, m_strNewsHeadlinesPath, pVal ));


    hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}


//
// Routine Description:
//
//	   Function that adds news items from HCUpdate
//
// Arguments:
//
//
// Return Value:
//
//
HRESULT News::Main::AddHCUpdateNews(/*[in ]*/ const MPC::wstring&  strNewsHeadlinesPath )
{	
	Headlines 					nhHeadlines;
	HRESULT						hr;
	UpdateHeadlines  			uhUpdate;
	bool						fMoreThanOneHeadline = false;
	bool						fExactlyOneHeadline = false;
	bool						fCreateRecentUpdatesBlock = false;
	CComPtr<IStream>			stream;
	CComBSTR					bstrUpdateBlockName;

	__HCP_FUNC_ENTRY( "News::Main::AddHCUpdateNews" );

	// Load the localized name of the update block
	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::LocalizeString( IDS_NEWS_UPDATEBLOCK_NAME, bstrUpdateBlockName )); 

	// Check to see if more than one news headlines exist ffrom HCUpdate - if it does then
	// we need to create the "Recent Updates" newsblock if it doesnt already exist
	__MPC_EXIT_IF_METHOD_FAILS(hr, uhUpdate.DoesMoreThanOneHeadlineExist( m_lLCID, m_strSKU, fMoreThanOneHeadline, fExactlyOneHeadline ));
	if (fMoreThanOneHeadline | fExactlyOneHeadline)
	{
		if (FAILED(hr = LoadXMLFile( strNewsHeadlinesPath.c_str(), stream )))
		{
			Headlines::Newsblock block;
			
			// News headlines file does not exist - create one to add news items from HCUpdate
			// Add the first news block for headlines
			nhHeadlines.AddNewsblock( block, m_strLangSKU );

			// Also create the Recent Updates newblock for update headlines
			if (fMoreThanOneHeadline)
			{
				fCreateRecentUpdatesBlock = true;
			}
			else
			{
				// change the timestamp of the NewsHeadlines
				nhHeadlines.set_Timestamp();

				// save the new newsheadlines cached file in the user's local disk
				__MPC_EXIT_IF_METHOD_FAILS(hr, nhHeadlines.Save( strNewsHeadlinesPath ));
			}
		}
		else
		{
			if (fMoreThanOneHeadline)
			{
				// News Headlines file does exist - check to see if the "Recent Updates" newsblock exists
				Headlines::Newsblock* ptrNewsblock;
				size_t nLength;

				__MPC_EXIT_IF_METHOD_FAILS(hr, nhHeadlines.Load( strNewsHeadlinesPath ));
				nLength = nhHeadlines.get_NumberOfNewsblocks();
				
				for (ptrNewsblock = nhHeadlines.get_Newsblock( nLength - 1 ); ptrNewsblock;)
				{
					if (!MPC::StrICmp( ptrNewsblock->m_strProvider, bstrUpdateBlockName ))
					{
						// Found it - just get out
						break;
					}

					if (nLength == 0)
					{
						// Did not find it - so create it				
						fCreateRecentUpdatesBlock = true;
						break;
					}
					ptrNewsblock = nhHeadlines.get_Newsblock( --nLength );
				}
			}
			else
			{
				__MPC_EXIT_IF_METHOD_FAILS(hr, nhHeadlines.Load( strNewsHeadlinesPath ));
			}
		}
		
		if (fCreateRecentUpdatesBlock)
		{
			Headlines::Newsblock 	block;

			// Add the "Recent Updates" news block for news to be displayed on the More... page
			block.m_strProvider = SAFEBSTR(bstrUpdateBlockName);
			block.m_strIcon = HC_HCUPDATE_UPDATEBLOCK_ICONURL;
			nhHeadlines.AddNewsblock( block, m_strLangSKU );

	        // change the timestamp of the NewsHeadlines
	        nhHeadlines.set_Timestamp();

	        // save the new newsheadlines cached file in the user's local disk
	        __MPC_EXIT_IF_METHOD_FAILS(hr, nhHeadlines.Save( strNewsHeadlinesPath ));
		}

		// So we now have the newsblock "Recent Updates" added to the news headlines file
		// Now add headlines items from Updates headlines file
		__MPC_EXIT_IF_METHOD_FAILS(hr, uhUpdate.AddHCUpdateHeadlines( m_lLCID, m_strSKU, nhHeadlines ));	
		// save the new newsheadlines cached file in the user's local disk
		__MPC_EXIT_IF_METHOD_FAILS(hr, nhHeadlines.Save( strNewsHeadlinesPath ));
	}


    hr = S_OK;

	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);

}


//
// Routine Description:
//
//	   Function that returns the cached news headlines from the user's local disk
//
// Arguments:
//
//	   nLCIDreq    the Language ID of the News to get
//
//	   bstrSKUreq  the SKU of the News to get
//
// Return Value:
//
//	   pVal        IStream loaded with the newsheadlines to display
//
//
HRESULT News::Main::get_News_Cached( /*[in]*/ long lLCID, /*[in]*/ BSTR bstrSKU, /*[out]*/ IUnknown* *pVal )
{
    __HCP_FUNC_ENTRY( "News::Main::get_Cached_News" );

    HRESULT   hr;
    Headlines nhHeadlines;


	__MPC_EXIT_IF_METHOD_FAILS(hr, Init( lLCID, bstrSKU ));


    // Return cached NewsHeadlines file
    __MPC_EXIT_IF_METHOD_FAILS(hr, nhHeadlines.get_Stream( m_lLCID, m_strSKU, m_strNewsHeadlinesPath, pVal ));


    hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}




//
// Routine Description:
//
//	   Function that downloads the newsver.xml file and then
//	   downloads the news headlines and returns them
//
// Arguments:
//
//	   nLCIDreq    the Language ID of the News to get
//
//	   bstrSKUreq  the SKU of the News to get
//
// Return Value:
//
//	   pVal        IStream loaded with the newsheadlines to display
//
//
HRESULT News::Main::get_News_Download( /*[in]*/ long lLCID, /*[in]*/ BSTR bstrSKU, /*[out]*/ IUnknown* *pVal )
{
    __HCP_FUNC_ENTRY( "News::Main::get_Download_News" );

    HRESULT   hr;
    Newsver   nwNewsver;
    Headlines nhHeadlines;


	__MPC_EXIT_IF_METHOD_FAILS(hr, Init( lLCID, bstrSKU ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, Load());

    // update newsver
    __MPC_EXIT_IF_METHOD_FAILS(hr, Update_Newsver( nwNewsver ));

    // load cached newsver
    __MPC_EXIT_IF_METHOD_FAILS(hr, nwNewsver.Load( m_lLCID, m_strSKU ));

    // update the News Headlines file
    __MPC_EXIT_IF_METHOD_FAILS(hr, Update_NewsHeadlines( nwNewsver, nhHeadlines ));

    // return the NewsHeadlines
    __MPC_EXIT_IF_METHOD_FAILS(hr, nhHeadlines.get_Stream( m_lLCID, m_strSKU, m_strNewsHeadlinesPath, pVal ));

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}




//
// Routine Description:
//
//	   Function that checks the registry to see if the headlines area is enabled or not
//
//		 registry key in:
//
//		   HKEY_LOCAL_MACHINE      HC_REGISTRY_HELPSVC     Headlines
//
// Arguments:
//
//	   None
//
// Return Value:
//
//	   pVal        VARIANT_TRUE or VARIANT_FALSE
//
//
HRESULT News::Main::get_Headlines_Enabled( /*[out]*/ VARIANT_BOOL *pVal)
{
    __HCP_FUNC_ENTRY( "News::Main::get_Headlines_Enabled" );

    HRESULT hr;
    DWORD   dwValue;
    bool    fFound;


    // Get the RegKey Value
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::RegKey_Value_Read( dwValue, fFound, HC_REGISTRY_HELPSVC, HEADLINES_REGKEY ));

    // If the Key was found and is disabled
    if(fFound && !dwValue)
	{
        *pVal = VARIANT_FALSE; // the Headlines are not enabled
	}
    else
	{
        *pVal = VARIANT_TRUE; // the Headlines are enabled
	}

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT News::LoadXMLFile( /*[in]*/ LPCWSTR szURL, /*[out]*/ CComPtr<IStream>& stream )
{
	__HCP_FUNC_ENTRY( "News::LoadXMLFile" );

	HRESULT                  hr;
	CComPtr<IXMLDOMDocument> xml;
    VARIANT_BOOL             fSuccess;
 

	if(wcsstr( szURL, L"://" )) // Remote file
	{
		CPCHUserProcess::UserEntry ue;
		CComPtr<IPCHSlaveProcess>  sp;
		CComPtr<IUnknown>          unk;


		__MPC_EXIT_IF_METHOD_FAILS(hr, ue.InitializeForImpersonation());
		__MPC_EXIT_IF_METHOD_FAILS(hr, CPCHUserProcess::s_GLOBAL->Connect( ue, &sp  ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, sp->CreateInstance( CLSID_DOMDocument, NULL, &unk ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, unk.QueryInterface( &xml ));
	}
	else
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, xml.CoCreateInstance( CLSID_DOMDocument ));
	}


	//
	// Set synchronous operation.
	//
	__MPC_EXIT_IF_METHOD_FAILS(hr, xml->put_async( VARIANT_FALSE ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, xml->load( CComVariant( szURL ), &fSuccess ));
    if(fSuccess == VARIANT_FALSE)
    {
		__MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_INVALID_DATA);
	}

	__MPC_EXIT_IF_METHOD_FAILS(hr, xml->QueryInterface( &stream ));

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

HRESULT News::LoadFileFromServer( /*[in]*/ LPCWSTR szURL, /*[out]*/ CComPtr<IStream>& stream )
{
	__HCP_FUNC_ENTRY( "News::LoadFileFromServer" );

	HRESULT                    hr;
	CPCHUserProcess::UserEntry ue;
	CComPtr<IPCHSlaveProcess>  sp;
	CComPtr<IUnknown>          unk;
 

	__MPC_EXIT_IF_METHOD_FAILS(hr, ue.InitializeForImpersonation());
    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHUserProcess::s_GLOBAL->Connect( ue, &sp  ));


	__MPC_EXIT_IF_METHOD_FAILS(hr, sp->OpenBlockingStream( CComBSTR( szURL ), &unk ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, unk.QueryInterface( &stream ));

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

bool News::Main::CheckConnectionStatus( )
{
	__HCP_FUNC_ENTRY("News::SetConnectionStatus");

	HRESULT                    	hr;
	CPCHUserProcess::UserEntry	ue;
	CComPtr<IPCHSlaveProcess>  	sp;
	CComPtr<IUnknown>          	unk;
	VARIANT_BOOL				varResult;
 
	if (!m_fConnectionStatusChecked)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, ue.InitializeForImpersonation());
	    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHUserProcess::s_GLOBAL->Connect( ue, &sp  ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, sp->IsNetworkAlive( &varResult ));
		varResult == VARIANT_TRUE?m_fOnline = true:m_fOnline = false;

		m_fConnectionStatusChecked = true;
	}

	hr = S_OK;

    __HCP_FUNC_CLEANUP;
    if (FAILED (hr))
    {
    	m_fOnline = false;
    }

	return m_fOnline;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\othertools\reformathhk\main.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    main.cpp

Abstract:
    This file contains the implementation of ReformatHHK utility, used to load
	and sort HHK files.

Revision History:
    Davide Massarenti   (Dmassare)  06/09/2000
        created

******************************************************************************/

#include "stdafx.h"

//////////////////////////////////////////////////////////////////////

HRESULT ProcessHHK( LPCWSTR szFileIn, LPCWSTR szFileOut )
{
    __HCP_FUNC_ENTRY( "ProcessHHK" );

    HRESULT     hr;
    HHK::Merger merger;
    HHK::Writer writer;

	__MPC_EXIT_IF_METHOD_FAILS(hr, merger.PrepareSortingOfHhk( writer, szFileIn, szFileOut ));

    while(merger.MoveNext())
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, writer.OutputSection( merger.GetSection() ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void ExtractHhkName( MPC::wstring& szFullName,
					 LPCWSTR       szFileName )
{
	LPCWSTR szEnd;
	LPCWSTR szEnd2;

	if((szEnd  = wcsrchr( szFileName, '\\' )) &&
	   (szEnd2 = wcsrchr( szEnd     , '.'  ))  )
	{
		MPC::wstring szTmp;

		szTmp  = L"ms-its:";
		szTmp += szFileName;
		szTmp += L"::/";
		szTmp += MPC::wstring( szEnd+1, szEnd2 );
		szTmp += L".hhk";
		
		szFullName = szTmp;
	}
	else
	{
		szFullName = szFileName;
	}
}

HRESULT ExpandAndProcessHHK( LPCWSTR szFileIn, LPCWSTR szFileOut )
{
    __HCP_FUNC_ENTRY( "ExpandAndProcessHHK" );

	HRESULT      hr;
	MPC::wstring szFileName;


	if(MPC::MSITS::IsCHM( szFileIn ) == false && StrStrIW( szFileIn, L".hhk" ) == NULL)
    {
		ExtractHhkName( szFileName, szFileIn );
	}
	else
	{
		szFileName = szFileIn;
	}

	wprintf( L"Processing '%s'...\n", szFileName.c_str() );

	hr = ProcessHHK( szFileName.c_str(), szFileOut );


    __HCP_FUNC_EXIT(hr);
}


/////////////////////////////////////////////////////////////////////////////
//
int __cdecl wmain( int     argc   ,
				   LPCWSTR argv[] )
{
	HRESULT      hr;
	MPC::wstring szFileIn;
	MPC::wstring szFileOut;

	if(argc != 3)
	{
		wprintf( L"Usage: %s <file to process> <output>\n", argv[0] );
		exit( 1 );
	}


    if(FAILED(hr = ::CoInitializeEx( NULL, COINIT_MULTITHREADED )))
    {
		wprintf( L"No COM!!\n" );
		exit(2);
    }

	MPC::SubstituteEnvVariables( szFileIn  = argv[1] );
	MPC::SubstituteEnvVariables( szFileOut = argv[2] );

	if(FAILED(hr = ExpandAndProcessHHK( szFileIn.c_str(), szFileOut.c_str() )))
	{
		wprintf( L"Failed to process %s: %08x\n", argv[1], hr );
		exit(3);
	}

    ::CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\othertools\reformathhk\stdafx.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    StdAfx.h

Abstract:
    Precompiled header.

Revision History:
    Davide Massarenti   (Dmassare)  03/16/2000
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__6877C875_4E31_4E1C_8AC2_024A50599D66__INCLUDED_)
#define AFX_STDAFX_H__6877C875_4E31_4E1C_8AC2_024A50599D66__INCLUDED_


#include <module.h>


#include <stdio.h>
#include <stdlib.h>
#include <float.h>

#include <HCP_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_COM.h>
#include <MPC_logging.h>

#include <MergedHhk.h>


#endif // !defined(AFX_STDAFX_H__6877C875_4E31_4E1C_8AC2_024A50599D66__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\news\lib\updateheadlines.cpp ===
/** Copyright (c) 2000 Microsoft Corporation
 ******************************************************************************
 **     Module Name:
 **
 **             UpdateHeadlines.cpp
 **
 **     Abstract:
 **
 **             Implementation of CUpdateHeadlines
 **
 **     Author:
 **
 **             Martha Arellano (t-alopez) 06-Dec-2000
 **
 **
 **
 ******************************************************************************
 **/

#include "stdafx.h"

//////////////////////////////////////////////////////////////////////
// CONFIG MAP
//////////////////////////////////////////////////////////////////////

/*<?xml version="1.0" ?>
<UPDATEHEADLINES>
    <LANGUAGE LCID="1033">
        <SKU VERSION="Personal">
            <HEADLINE ICON="" TITLE="" LINK="" EXPIRES=""/>
        </SKU>
    </LANGUAGE>
</UPDATEHEADLINES>
*/


CFG_BEGIN_FIELDS_MAP(News::UpdateHeadlines::Headline)
    CFG_ATTRIBUTE( L"ICON"   		, wstring, m_strIcon   			),
    CFG_ATTRIBUTE( L"TITLE"  		, wstring, m_strTitle  			),
    CFG_ATTRIBUTE( L"LINK"   		, wstring, m_strLink   			),
    CFG_ATTRIBUTE( L"DESCRIPTION"   , wstring, m_strDescription		),
    CFG_ATTRIBUTE( L"TIMEOUT"		, DATE_CIM, m_dtTimeOut		 	),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(News::UpdateHeadlines::Headline)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(News::UpdateHeadlines::Headline, L"HEADLINE")

DEFINE_CONFIG_METHODS__NOCHILD(News::UpdateHeadlines::Headline)

////////////////////

CFG_BEGIN_FIELDS_MAP(News::UpdateHeadlines::SKU)
    CFG_ATTRIBUTE( L"VERSION", wstring, m_strSKU ),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(News::UpdateHeadlines::SKU)
    CFG_CHILD(News::UpdateHeadlines::Headline)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(News::UpdateHeadlines::SKU, L"SKU")


DEFINE_CONFIG_METHODS_CREATEINSTANCE_SECTION(News::UpdateHeadlines::SKU,tag,defSubType)
    if(tag == _cfg_table_tags[0])
    {
        defSubType = &(*(m_vecHeadlines.insert( m_vecHeadlines.end() )));
        return S_OK;
    }
DEFINE_CONFIG_METHODS_SAVENODE_SECTION(News::UpdateHeadlines::SKU,xdn)
    hr = MPC::Config::SaveList( m_vecHeadlines, xdn );
DEFINE_CONFIG_METHODS_END(News::UpdateHeadlines::SKU)

////////////////////

CFG_BEGIN_FIELDS_MAP(News::UpdateHeadlines::Language)
    CFG_ATTRIBUTE( L"LCID", long, m_lLCID ),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(News::UpdateHeadlines::Language)
    CFG_CHILD(News::UpdateHeadlines::SKU)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(News::UpdateHeadlines::Language,L"LANGUAGE")

DEFINE_CONFIG_METHODS_CREATEINSTANCE_SECTION(News::UpdateHeadlines::Language,tag,defSubType)
    if(tag == _cfg_table_tags[0])
    {
        defSubType = &(*(m_lstSKUs.insert( m_lstSKUs.end() )));
        return S_OK;
    }
DEFINE_CONFIG_METHODS_SAVENODE_SECTION(News::UpdateHeadlines::Language,xdn)
    hr = MPC::Config::SaveList( m_lstSKUs, xdn );
DEFINE_CONFIG_METHODS_END(News::UpdateHeadlines::Language)

////////////////////

CFG_BEGIN_FIELDS_MAP(News::UpdateHeadlines)
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(News::UpdateHeadlines)
    CFG_CHILD(News::UpdateHeadlines::Language)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(News::UpdateHeadlines,L"UPDATEHEADLINES")


DEFINE_CONFIG_METHODS_CREATEINSTANCE_SECTION(News::UpdateHeadlines,tag,defSubType)
    if(tag == _cfg_table_tags[0])
    {
        defSubType = &(*(m_lstLanguages.insert( m_lstLanguages.end() )));
        return S_OK;
    }
DEFINE_CONFIG_METHODS_SAVENODE_SECTION(News::UpdateHeadlines,xdn)
    hr = MPC::Config::SaveList( m_lstLanguages, xdn );
DEFINE_CONFIG_METHODS_END(News::UpdateHeadlines)

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

News::UpdateHeadlines::Headline::Headline()
{
                     // MPC::wstring m_strIcon;
                     // MPC::wstring m_strTitle;
                     // MPC::wstring m_strLink;
    m_dtTimeOut = 0; // DATE         m_dtTimeOut;
}

News::UpdateHeadlines::Headline::Headline( /*[in]*/ const MPC::wstring& strIcon  ,
                                           /*[in]*/ const MPC::wstring& strTitle ,
                                           /*[in]*/ const MPC::wstring& strLink  ,
                                           /*[in]*/ const MPC::wstring& strDescription  ,
                                           /*[in]*/ int                 nTimeOutDays    )
{
    m_strIcon   		= strIcon;                     	// MPC::wstring m_strIcon;
    m_strTitle  		= strTitle;                    	// MPC::wstring m_strTitle;
    m_strLink   		= strLink;                   	// MPC::wstring m_strLink;
    m_strDescription 	= strDescription;				// MPC::wstring m_strDescription;
    m_dtTimeOut 		= MPC::GetLocalTime() + nTimeOutDays; 	// DATE         m_dtTimeOut;
}

////////////////////

News::UpdateHeadlines::SKU::SKU()
{
    // MPC::wstring   m_strSKU;
    // HeadlineVector m_vecHeadlines;
}

News::UpdateHeadlines::SKU::SKU( /*[in]*/ const MPC::wstring& strSKU )
{
    m_strSKU = strSKU; // MPC::wstring   m_strSKU;
                       // HeadlineVector m_vecHeadlines;
}

////////////////////

News::UpdateHeadlines::Language::Language()
{
    m_lLCID = 0; // long    m_lLCID;
                 // SKUList m_lstSKUs;
}

News::UpdateHeadlines::Language::Language( long lLCID )
{
    m_lLCID = lLCID; // long    m_lLCID;
                     // SKUList m_lstSKUs;
}

/////////////////////////////////////////////////////////////////////////////

News::UpdateHeadlines::UpdateHeadlines()
{
                       // LanguageList m_lstLanguages;
    m_data    = NULL;  // SKU*         m_data;
    m_fLoaded = false; // bool         m_fLoaded;
    m_fDirty  = false; // bool         m_fDirty;
}


HRESULT News::UpdateHeadlines::Locate( /*[in]*/ long                lLCID   ,
                                       /*[in]*/ const MPC::wstring& strSKU  ,
                                       /*[in]*/ bool                fCreate )
{
    __HCP_FUNC_ENTRY( "News::UpdateHeadlines::Locate" );

    HRESULT      hr;
    LanguageIter itLanguage;
    SKUIter      itSKU;


    m_data = NULL;


    if(m_fLoaded == false)
    {
        CComPtr<IStream> stream;
        MPC::wstring     strPath( HC_HCUPDATE_UPDATE ); MPC::SubstituteEnvVariables( strPath );

        // we load the file 
        if(SUCCEEDED(News::LoadXMLFile( strPath.c_str(), stream )))
        {
            if(SUCCEEDED(MPC::Config::LoadStream( this, stream )))
            {
                ;
            }
        }

        m_fLoaded = true;
        m_fDirty  = false;
    }


    itLanguage = m_lstLanguages.begin();
    while(1)
    {
        if(itLanguage == m_lstLanguages.end())
        {
            if(fCreate == false)
            {
                __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_INVALID_DATA);
            }

            itLanguage = m_lstLanguages.insert( itLanguage, Language( lLCID ) );
            m_fDirty   = true;
        }

        if(itLanguage->m_lLCID == lLCID)
        {
            itSKU = itLanguage->m_lstSKUs.begin();
            while(1)
            {
                if(itSKU == itLanguage->m_lstSKUs.end())
                {
                    if(fCreate == false)
                    {
                        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_INVALID_DATA);
                    }

                    itSKU    = itLanguage->m_lstSKUs.insert( itSKU, SKU( strSKU ) );
                    m_fDirty = true;
                }

                //
                // Check if its bstrMySKUVersion
                if(!MPC::StrICmp( itSKU->m_strSKU, strSKU ))
                {
                    m_data = &(*itSKU);
                    __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
                }

                itSKU++;
            }
        }

        itLanguage++;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

//
// Routine Description:
//
//     Loads the UpdateHeadlines.xml file and looks for the specified LCID and SKUVersion
//
//     if the file doesn't exist, or there isn't the LCID and SKU,
//     those elements are added to the file
//
//     the iterators will point to the specified LCID and SKU
//
// Arguments:
//
//     nMyLCID             the CLanguage to look for
//
//     strMySKUVersion     the CSKU to look for
//
//
HRESULT News::UpdateHeadlines::Load( /*[in]*/ long                lLCID  ,
                                     /*[in]*/ const MPC::wstring& strSKU )
{
    __HCP_FUNC_ENTRY( "News::UpdateHeadlines::Load" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Locate( lLCID, strSKU, /*fCreate*/true ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}




//
// Routine Description:
//
//     This saves the UpdateHeadlines file in the path of HC_HCUPDATE_UPDATE
//
// Arguments:
//
//     None
//
//
HRESULT News::UpdateHeadlines::Save()
{
    __HCP_FUNC_ENTRY( "News::UpdateHeadlines::Save" );

    HRESULT hr;


    if(m_fDirty)
    {
        MPC::wstring strPath( HC_HCUPDATE_UPDATE ); MPC::SubstituteEnvVariables( strPath );

        // check to see if the dirs exist
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MakeDir( strPath ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::Config::SaveFile( this, strPath.c_str() ));

        m_fDirty = false;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}




//
// Routine Description:
//
//     Will add a new Headline for the specified LCID and SKU
//     If the UpdateHeadlines file doesn't exist, it will be created and saved
//
//     - additional validation is made
//
// Arguments:
//
//     nMyLCID             the Language
//     strMySKUVersion     the SKU
//     strMyIcon           the Icon for the Headline
//     strMyTitle          the Title for the Headline
//     strMyLink           the Link for the Headline
//     nTimeOutDays               the number of days, to set the frequency
//
//
//
HRESULT News::UpdateHeadlines::Add ( /*[in]*/ long                lLCID    ,
                                     /*[in]*/ const MPC::wstring& strSKU   ,
                                     /*[in]*/ const MPC::wstring& strIcon  ,
                                     /*[in]*/ const MPC::wstring& strTitle ,
                                     /*[in]*/ const MPC::wstring& strLink  ,
                                     /*[in]*/ const MPC::wstring& strDescription ,
                                     /*[in]*/ int                 nTimeOutDays    	,
                                     /*[in]*/ DATE				  dtExpiryDate)
{
    __HCP_FUNC_ENTRY( "News::UpdateHeadlines::Add" );

    HRESULT      hr;
    HeadlineIter it;


	// Before doing anything make sure that the headlines hasnt expired
	// Note: this is the calendar expiration date i.e. if the calendar expiry date is 1/1/01 and
	// if the user tries to install this headlines on 1/1/02 then it fails
	if (dtExpiryDate && (MPC::GetLocalTime() > dtExpiryDate))
	{
		__MPC_SET_ERROR_AND_EXIT(hr, S_OK);
	}

	// Set the default expiration date if it is 0
	if (nTimeOutDays == 0)
	{
		nTimeOutDays = HCUPDATE_DEFAULT_TIMEOUT;
	}
	
    // Load UpdateHeadlines
    __MPC_EXIT_IF_METHOD_FAILS(hr, Load( lLCID, strSKU ));


    // check that this Headline is unique:
    //
    for(it = m_data->m_vecHeadlines.begin(); it != m_data->m_vecHeadlines.end(); it++)
    {
        // if it has the same title
        if(MPC::StrICmp( it->m_strTitle, strTitle ) == 0)
        {
            // modify existing headline
            it->m_strIcon  			= strIcon;
            it->m_strLink   		= strLink;
            it->m_strDescription 	= strDescription;
            it->m_dtTimeOut 		= MPC::GetLocalTime() + nTimeOutDays;
            m_fDirty        		= true;
            break;
        }

        // if it has the same link
        if(it->m_strLink == strLink)
        {
            // modify existing headline
            it->m_strIcon   		= strIcon;
            it->m_strTitle  		= strTitle;
            it->m_strDescription 	= strDescription;
            it->m_dtTimeOut 		= MPC::GetLocalTime() + nTimeOutDays;
            m_fDirty        		= true;
            break;
        }
    }

    // if we didn't found and modified a headline
    if(it == m_data->m_vecHeadlines.end())
    {
        m_data->m_vecHeadlines.insert(m_data->m_vecHeadlines.begin(), Headline( strIcon, strTitle, strLink, strDescription, nTimeOutDays ) );
        m_fDirty = true;
    }

    // Save UpdateHeadlines.xml file
    __MPC_EXIT_IF_METHOD_FAILS(hr, Save());


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


//
// Routine Description:
//
//     Gets all the UpdateHeadlines for the specified LCID and SKU
//     Deletes the expired UpdateHeadlines
//     and inserts the rest in the list of Headlines
//
// Arguments:
//
//     nMyLCID             the Language
//     strMySKUVersion     the SKU
//
//
HRESULT News::UpdateHeadlines::AddHCUpdateHeadlines( /*[in]*/ long  lLCID        ,
                                    /*[in]*/ const MPC::wstring&    strSKU       ,
                                    /*[in]*/ News::Headlines& 		nhHeadlines )
{
    __HCP_FUNC_ENTRY( "News::UpdateHeadlines::Get" );

    HRESULT      						hr;
    HeadlineIter 						itUpdateHeadlines;
    Headlines::HeadlineIter				itHeadlines;
    Headlines::Newsblock*				ptrNewsblock;
	size_t 								nLength;


    // Load UpdateHeadlines
    __MPC_EXIT_IF_METHOD_FAILS( hr, Load( lLCID, strSKU ) );

	// Add the first headline from the UpdateHeadlines.xml to the first Newsblock
	itUpdateHeadlines = m_data->m_vecHeadlines.begin();
	ptrNewsblock = nhHeadlines.get_Newsblock(0);
	itHeadlines = ptrNewsblock->m_vecHeadlines.begin();
	// Check to see if there are any headlines - if the vector is empty then just add this headline
	if ( itHeadlines == ptrNewsblock->m_vecHeadlines.end() )
	{	
		ptrNewsblock->m_vecHeadlines.insert( ptrNewsblock->m_vecHeadlines.end(), News::Headlines::Headline( itUpdateHeadlines->m_strIcon, itUpdateHeadlines->m_strTitle, itUpdateHeadlines->m_strLink, MPC::wstring(), itUpdateHeadlines->m_dtTimeOut, true ));   			
	}
	else
	{
		// There are other headlines in the file 
	   	while ( 1 )
	   	{
	   		if ( itHeadlines->m_fUpdateHeadlines == true )
	   		{
	   			// An update headline already exists - replace it 
	   			ptrNewsblock->m_vecHeadlines.erase( itHeadlines );
	   			ptrNewsblock->m_vecHeadlines.insert( itHeadlines, News::Headlines::Headline( itUpdateHeadlines->m_strIcon, itUpdateHeadlines->m_strTitle, itUpdateHeadlines->m_strLink, MPC::wstring(), itUpdateHeadlines->m_dtTimeOut, true ));
	   			break;
	   		}

	   		if ( ++itHeadlines == ptrNewsblock->m_vecHeadlines.end() )
	   		{
	   			// No previous update existed - add this to the end of the vector
	   			ptrNewsblock->m_vecHeadlines.insert( ptrNewsblock->m_vecHeadlines.end(), News::Headlines::Headline( itUpdateHeadlines->m_strIcon, itUpdateHeadlines->m_strTitle, itUpdateHeadlines->m_strLink, MPC::wstring(), itUpdateHeadlines->m_dtTimeOut, true ));   			
	   			break;
	   		}
	   	}
	}


	// Now add the remaining headlines to the Newsblock whose provider is called "Recent Updates". 
	if ( ++itUpdateHeadlines != m_data->m_vecHeadlines.end() )
	{
		nLength = nhHeadlines.get_NumberOfNewsblocks();

		// The first headline has been added to the homepage so dont add it again
		for ( ptrNewsblock = nhHeadlines.get_Newsblock(nLength - 1); ptrNewsblock; )
		{
		    CComBSTR    bstrUpdateBlockName;
			// Load the localized name of the update block
        	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::LocalizeString( IDS_NEWS_UPDATEBLOCK_NAME, bstrUpdateBlockName )); 

			if(!MPC::StrICmp( ptrNewsblock->m_strProvider, bstrUpdateBlockName ))
			{
				// Found the "Recent Updates" newsblock - add the rest of the headlines here
				// Before adding delete the current set of headlines
				ptrNewsblock->m_vecHeadlines.clear();
				for ( ; itUpdateHeadlines != m_data->m_vecHeadlines.end(); ++itUpdateHeadlines )
				{
					ptrNewsblock->m_vecHeadlines.insert(ptrNewsblock->m_vecHeadlines.end(), News::Headlines::Headline( itUpdateHeadlines->m_strIcon, itUpdateHeadlines->m_strTitle, itUpdateHeadlines->m_strLink, itUpdateHeadlines->m_strDescription, itUpdateHeadlines->m_dtTimeOut, true ));
				}

				break;
			}		
			ptrNewsblock = nhHeadlines.get_Newsblock(--nLength);
		}
	}
	
	__MPC_EXIT_IF_METHOD_FAILS(hr, Save());

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

//
// Routine Description:
//
//     	Checks to see if there is more than headlines item - returns true if there are
//		Also, deletes expired headlines
//
// Arguments:
//
//     nMyLCID             the Language
//     strMySKUVersion     the SKU
//
//
HRESULT News::UpdateHeadlines::DoesMoreThanOneHeadlineExist(	/*[in]*/ long		lLCID,
                                    			/*[in]*/ const MPC::wstring& strSKU, 
                                    			/*[out]*/ bool& fMoreThanOneHeadline,
                                    			/*[out]*/ bool& fExactlyOneHeadline)
{
    __HCP_FUNC_ENTRY( "News::UpdateHeadlines::DoesNewsItemsExist" );

	HRESULT			hr;
	HeadlineIter	it;
	DATE         	dNow = MPC::GetLocalTime();

    fMoreThanOneHeadline = false;
    fExactlyOneHeadline = false;
    	
    // Load UpdateHeadlines
    __MPC_EXIT_IF_METHOD_FAILS(hr, Load( lLCID, strSKU ));

    for(it = m_data->m_vecHeadlines.begin(); it != m_data->m_vecHeadlines.end(); it++)
    {
        // if the headline has expired
        if(it->m_dtTimeOut < dNow)
        {
            m_data->m_vecHeadlines.erase( it );
            m_fDirty = true;
        }
    }

    if(m_data->m_vecHeadlines.size() > 1)
    {
    	fMoreThanOneHeadline = true;
    	fExactlyOneHeadline = false;
    }

    if(m_data->m_vecHeadlines.size() == 1)
    {
    	fMoreThanOneHeadline = false;
    	fExactlyOneHeadline = true;
    }

	hr = S_OK;

	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\othertools\signutil\stdafx.h ===
#include <module.h>
#include <windows.h>
#include <winbase.h>
#include <wintrust.h>
#include <wincrypt.h>
#include <sipbase.h>
#include <softpub.h>

// Trace Stuff
#include <HCP_trace.h>
#include <MPC_main.h>
#include <MPC_utils.h> // Several utility things, also includes Mpc_common.
#include <MPC_xml.h>
#include <MPC_com.h>

#define MAX_NAME 1024
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\othertools\signcode\sign.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    sign.cpp

Abstract:

Revision History:
    Vijay Baliga   (VBaliga)  08/10/2000
        created

******************************************************************************/

#include <module.h>
#include <MPC_main.h>
#include <MPC_utils.h>
#include <MPC_streams.h>
#include <KeysLib.h>
#include <HCP_trace.h>
#include <TrustedScripts.h>

HRESULT WINAPI
GetSignature(
    CComBSTR    bstrPrivateKey,
    CComBSTR    bstrCode
)
{
    __HCP_FUNC_ENTRY( "GetSignature" );

    HRESULT         hr;
    CPCHCryptKeys   key;
    CComBSTR        bstrSignature;

    if (NULL != NULL)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, key.ImportPrivate(bstrPrivateKey));

    __MPC_EXIT_IF_METHOD_FAILS
    (
        hr,
        key.SignData
        (
            bstrSignature,
            (BYTE*) (BSTR(bstrCode)),
            SysStringByteLen(bstrCode)
        )
    );

    hr = S_OK;

    wprintf(L"%s", bstrSignature);

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

static HRESULT LoadFile( /*[in ]*/ LPCWSTR  szFile ,
                         /*[out]*/ HGLOBAL& hg     )
{
    __HCP_FUNC_ENTRY( "LoadFile" );

    HRESULT                  hr;
    CComPtr<IStream>         streamMem;
    CComPtr<MPC::FileStream> streamFile;


    //
    // Create a stream for a file.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &streamFile ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamFile->InitForRead( szFile  ));


    //
    // Create a memory stream.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CreateStreamOnHGlobal( NULL, FALSE, &streamMem ));

    //
    // Load the contents in memory.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::BaseStream::TransferData( streamFile, streamMem ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, ::GetHGlobalFromStream( streamMem, &hg ));
    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

static HRESULT LoadFileAsString( /*[in ]*/ LPCWSTR   szFile   ,
                                 /*[out]*/ CComBSTR& bstrData )
{
    __HCP_FUNC_ENTRY( "LoadFileAsString" );

    HRESULT hr;
    HGLOBAL hg = NULL;
    DWORD   dwLen;
    LPWSTR  str;


    __MPC_EXIT_IF_METHOD_FAILS(hr, LoadFile( szFile, hg ));

    dwLen = ::GlobalSize( hg );

    bstrData.Attach( ::SysAllocStringLen( NULL, dwLen ) );

    ::MultiByteToWideChar( CP_ACP, 0, (LPCSTR)::GlobalLock( hg ), dwLen, bstrData, (dwLen+1)*sizeof(WCHAR) ); bstrData[dwLen] = 0;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(hg) ::GlobalFree( hg );

    __HCP_FUNC_EXIT(hr);
}

int __cdecl wmain(
    int     argc,
    LPCWSTR argv[]
)
{
	HRESULT      hr;
	MPC::wstring szFileKey;
	MPC::wstring szFileCode;
    CComBSTR     bstrPrivateKey;
    CComBSTR     bstrCode;

	if (argc != 3)
	{
		wprintf(L"Usage: %s <private key file> <code file>\n", argv[0]);
		exit(1);
	}


    if (FAILED(hr = ::CoInitializeEx(NULL, COINIT_MULTITHREADED)))
    {
		wprintf(L"No COM!!\n");
		exit(2);
    }

	MPC::SubstituteEnvVariables(szFileKey  = argv[1]);
	MPC::SubstituteEnvVariables(szFileCode = argv[2]);

	LoadFileAsString(szFileKey.c_str(), bstrPrivateKey);
	LoadFileAsString(szFileCode.c_str(), bstrCode);

	if(FAILED(hr = GetSignature(bstrPrivateKey, bstrCode)))
	{
		wprintf(L"Failed to process %s: %08x\n", argv[1], hr);
		exit(3);
	}

    ::CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\othertools\verifyhhk\stdafx.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    StdAfx.h

Abstract:
    Precompiled header.

Revision History:
    Davide Massarenti   (Dmassare)  03/16/2000
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__6877C875_4E31_4E1C_8AC2_024A50599D66__INCLUDED_)
#define AFX_STDAFX_H__6877C875_4E31_4E1C_8AC2_024A50599D66__INCLUDED_


#include <module.h>


#include <stdio.h>
#include <stdlib.h>
#include <float.h>

#include <HCP_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_COM.h>
#include <MPC_logging.h>

#include <MergedHhk.h>


#endif // !defined(AFX_STDAFX_H__6877C875_4E31_4E1C_8AC2_024A50599D66__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\othertools\signutil\regoem.cpp ===
#include "stdafx.h"

static void GetDNInfo( PCCERT_CONTEXT pCC               ,
                       LPCSTR         field             ,
                       LPCWSTR        fieldName         ,
                       MPC::wstring&  szBuf             ,
                       MPC::wstring*  szPlainName = NULL)
{
    WCHAR szTmp[MAX_NAME];

    if(szBuf.length()) szBuf += L",";

    szBuf += fieldName;

    ::CertGetNameStringW( pCC,
                          CERT_NAME_ATTR_TYPE,
                          0,
                          (void*)field,
                          szTmp,
                          MAXSTRLEN(szTmp) );

    if(szPlainName) *szPlainName = szTmp;

    szBuf += szTmp;
}


HRESULT GetInfoFromCert(LPWSTR wszCABName, MPC::wstring &wszDN, MPC::wstring &wszOwner)
{
    __HCP_FUNC_ENTRY( "GetInfoFromCert" );

    HRESULT         hr;
    DWORD           dwEncoding;
    DWORD           dwContentType;
    DWORD           dwFormatType;
    HCERTSTORE      hCertStore = NULL;
    PCCERT_CONTEXT  pCC        = NULL;
    DWORD           dwNameBytes = MAX_NAME;

    // Start querying the cert object
    if(!::CryptQueryObject( CERT_QUERY_OBJECT_FILE,                     // dwObjectType
                            wszCABName,			                        // pvObject
                            CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED, // dwExpectedContentTypeFlags
                            CERT_QUERY_FORMAT_FLAG_ALL,                 // dwExpectedFormatTypeFlags
                            0,                                          // dwFlags
                            &dwEncoding,                                // pdwMsgAndCertEncodingType
                            &dwContentType,                             // pdwContentType
                            &dwFormatType,                              // pdwFormatType
                            &hCertStore,                                // phCertStore
                            NULL,                                       // phMsg
                            NULL))                                      // ppvContext
    {
        printf("Error - unable to perform CryptQueryObject.\n"); __MPC_FUNC_LEAVE;
    }

    // get the first cert
    pCC = ::CertEnumCertificatesInStore( hCertStore, NULL );
    if(!pCC)
    {
        printf("Error - unable to perform CertEnumCertificatesInStore.\n"); __MPC_FUNC_LEAVE;
    }


    {
        wszDN.erase();

        GetDNInfo( pCC, szOID_COMMON_NAME           , L"CN=", wszDN, &wszOwner	    );
        GetDNInfo( pCC, szOID_LOCALITY_NAME         , L"L=" , wszDN                 );
        GetDNInfo( pCC, szOID_STATE_OR_PROVINCE_NAME, L"S=" , wszDN                 );
        GetDNInfo( pCC, szOID_COUNTRY_NAME          , L"C=" , wszDN                 );
    }

    if(wszDN.size() == 0 || wszOwner.size() == 0)
    {
        printf("Error - unable to obtain DN or name in certificate.\n"); __MPC_FUNC_LEAVE;
    }

    //
    // Escape unsafe character in the CertID.
    //
    {
        LPWSTR szCertID = (LPWSTR)wszDN.c_str();

        while(szCertID[0])
        {
            switch(szCertID[0])
            {
            case L'\\':
            case L'/':
            case L':':
            case L'*':
            case L'?':
            case L'"':
            case L'<':
            case L'>':
            case L'|':
                szCertID[0] = L'_';
            }

            szCertID++;
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(pCC       ) ::CertFreeCertificateContext( pCC           );
    if(hCertStore) ::CertCloseStore            ( hCertStore, 0 );

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

int __cdecl wmain( int argc, WCHAR **argv, WCHAR **envp)
{
    HRESULT  hr;
	MPC::wstring wszDN;
	MPC::wstring wszOwnerName;
	FILE *fPD;
	FILE *fLT;
	USES_CONVERSION;

	if(argc != 3)
	{
		printf("\nUsage : regoem <cab filename> <regcab filename>\n");
		return 0;
	}

	hr = GetInfoFromCert(argv[1], wszDN, wszOwnerName);

	//
	// Create package_description.xml file
	//
	fPD = fopen("package_description.xml", "w");
	if (!fPD)
	{
		printf("Unable to create package_description.xml\n");
		return 0;
	}
	fprintf(fPD, "<?xml version=\"1.0\" ?>\n<HELPCENTERPACKAGE>\n\t<VERSION VALUE=\"0.0.0.0\" />");
	fprintf(fPD, "\n\t<PRODUCT ID=\"%s\" />", W2A(wszOwnerName.c_str()));
	fprintf(fPD, "\n\t<SKU VALUE=\"ALL\"/>");
	fprintf(fPD, "\n\t<LANGUAGE VALUE=\"ALL\"/>");
	fprintf(fPD, "\n\t<NODEOWNERS>\n\t\t<OWNER DN=\"%s\"/>\n\t</NODEOWNERS>\n</HELPCENTERPACKAGE>", W2A(wszDN.c_str()));
	fclose(fPD);

	//
	// Create list.txt file
	//
	fLT = fopen("list.txt", "w");
	if (!fLT)
	{
		printf("Unable to create list.txt\n");
		return 0;
	}
	fprintf(fLT, "%s,OEM registration CAB for %s,http://www.microsoft.com\n", W2A(argv[2]), W2A(wszOwnerName.c_str()));
	fclose(fLT);

    return FAILED(hr) ? 10 : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\channels\lib\channel.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Channel.cpp

Abstract:
    This is implementation of IChannel object

Revision History:
    Steve Shih        created  07/15/99

    Davide Massarenti rewrote  12/05/2000

********************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

CSAFChannelRecord::CSAFChannelRecord()
{
}

HRESULT CSAFChannelRecord::GetField( /*[in]*/ SAFREG_Field field, /*[out]*/ BSTR *pVal   )
{
    LPCWSTR szText;
    WCHAR   rgLCID[64];

    switch(field)
    {
    case SAFREG_SKU               : szText =                m_ths.GetSKU     ();               break;
    case SAFREG_Language          : szText = rgLCID; _ltow( m_ths.GetLanguage(), rgLCID, 10 ); break;

    case SAFREG_VendorID          : szText = m_bstrVendorID;                                   break;
    case SAFREG_ProductID         : szText = m_bstrProductID;                                  break;

    case SAFREG_VendorName        : szText = m_bstrVendorName;                                 break;
    case SAFREG_ProductName       : szText = m_bstrProductName;                                break;
    case SAFREG_ProductDescription: szText = m_bstrDescription;                                break;

    case SAFREG_VendorIcon        : szText = m_bstrIcon;                                       break;
    case SAFREG_SupportUrl        : szText = m_bstrURL;                                        break;
                                                                                               break;
    case SAFREG_PublicKey         : szText = m_bstrPublicKey;                                  break;
    case SAFREG_UserAccount       : szText = m_bstrUserAccount;                                break;

    case SAFREG_Security          : szText = m_bstrSecurity;                                   break;
    case SAFREG_Notification      : szText = m_bstrNotification;                               break;

    default: return E_INVALIDARG;
    }

    return MPC::GetBSTR( szText, pVal );
}

HRESULT CSAFChannelRecord::SetField( /*[in]*/ SAFREG_Field field, /*[in]*/ BSTR newVal )
{
    CComBSTR* pbstr = NULL;

    SANITIZEWSTR( newVal );

    switch(field)
    {
    case SAFREG_SKU               : m_ths.m_strSKU =        newVal  	  ; break;
    case SAFREG_Language          : m_ths.m_lLCID  = _wtol( newVal )	  ; break;
																		  
    case SAFREG_VendorID          : pbstr = (CComBSTR*)&m_bstrVendorID    ; break;
    case SAFREG_ProductID         : pbstr = (CComBSTR*)&m_bstrProductID   ; break;
																		  
    case SAFREG_VendorName        : pbstr = (CComBSTR*)&m_bstrVendorName  ; break;
    case SAFREG_ProductName       : pbstr = (CComBSTR*)&m_bstrProductName ; break;
    case SAFREG_ProductDescription: pbstr = (CComBSTR*)&m_bstrDescription ; break;
																		  
    case SAFREG_VendorIcon        : pbstr = (CComBSTR*)&m_bstrIcon        ; break;
    case SAFREG_SupportUrl        : pbstr = (CComBSTR*)&m_bstrURL         ; break;
																		  
    case SAFREG_PublicKey         : pbstr = (CComBSTR*)&m_bstrPublicKey   ; break;
    case SAFREG_UserAccount       : pbstr = (CComBSTR*)&m_bstrUserAccount ; break;
																		  
    case SAFREG_Security          : pbstr = (CComBSTR*)&m_bstrSecurity    ; break;
    case SAFREG_Notification      : pbstr = (CComBSTR*)&m_bstrNotification; break;

    default: return E_INVALIDARG;
    }

    return pbstr ? MPC::PutBSTR( *pbstr, newVal ) : S_OK;
}

////////////////////////////////////////////////////////////////////////////////

CSAFChannel::CSAFChannel()
{
    __HCP_FUNC_ENTRY( "CSAFChannel::CSAFChannel" );

    // CSAFChannelRecord               m_data;
    // CComPtr<IPCHSecurityDescriptor> m_Security;
    // List                            m_lstIncidentItems;
}

void CSAFChannel::FinalRelease()
{
    __HCP_FUNC_ENTRY( "CSAFChannel::FinalRelease" );

    Passivate();
}

void CSAFChannel::Passivate()
{
    __HCP_FUNC_ENTRY( "CSAFChannel::Passivate" );

    m_Security.Release();

    MPC::ReleaseAll( m_lstIncidentItems );
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CSAFChannel::OpenIncidentStore( /*[out]*/ CIncidentStore*& pIStore )
{
    __HCP_FUNC_ENTRY( "CSAFChannel::OpenIncidentStore" );

    HRESULT hr;


    __MPC_EXIT_IF_ALLOC_FAILS(hr, pIStore, new CIncidentStore());

    __MPC_EXIT_IF_METHOD_FAILS(hr, pIStore->Load());

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CSAFChannel::CloseIncidentStore( /*[out]*/ CIncidentStore*& pIStore )
{
    __HCP_FUNC_ENTRY( "CSAFChannel::CloseIncidentStore" );

    HRESULT hr;


    if(pIStore)
    {
        (void)pIStore->Save();

        delete pIStore; pIStore = NULL;
    }

    hr = S_OK;


    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CSAFChannel::Init( /*[in]*/ const CSAFChannelRecord& cr )
{
    __HCP_FUNC_ENTRY( "CSAFChannel::Init" );

    HRESULT         hr;
    CIncidentStore* pIStore = NULL;


    m_data = cr;

    __MPC_EXIT_IF_METHOD_FAILS(hr, OpenIncidentStore( pIStore ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pIStore->OpenChannel( this ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    (void)CloseIncidentStore( pIStore );

    __HCP_FUNC_EXIT(hr);
}

HRESULT CSAFChannel::Import( /*[in]*/  const CSAFIncidentRecord&  increc ,
                             /*[out]*/ CSAFIncidentItem*         *ppItem )
{
    __HCP_FUNC_ENTRY( "CSAFChannel::Import" );

    HRESULT                       hr;
    CComObject<CSAFIncidentItem>* pItem = NULL;


    __MPC_EXIT_IF_METHOD_FAILS(hr, CreateChild( this, &pItem ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pItem->Import( increc ));

    if(ppItem)
    {
        (*ppItem = pItem)->AddRef();
    }

    m_lstIncidentItems.push_back( pItem ); pItem = NULL;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    MPC::Release( pItem );

    __HCP_FUNC_EXIT(hr);
}

HRESULT CSAFChannel::Create( /*[in]*/  BSTR               bstrDesc        ,
                             /*[in]*/  BSTR               bstrURL         ,
                             /*[in]*/  BSTR               bstrProgress    ,
                             /*[in]*/  BSTR               bstrXMLDataFile ,
                             /*[in]*/  BSTR               bstrXMLBlob     ,
                             /*[out]*/ CSAFIncidentItem* *pVal            )
{
    __HCP_FUNC_ENTRY( "CSAFChannel::Create" );

    HRESULT         hr;
    CIncidentStore* pIStore = NULL;
    CComBSTR        bstrOwner;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, OpenIncidentStore( pIStore ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetCallerPrincipal( /*fImpersonate*/true, bstrOwner ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pIStore->AddRec( this, bstrOwner, bstrDesc, bstrURL, bstrProgress, bstrXMLDataFile, bstrXMLBlob, pVal ));

    // Fire an event to the Notification Object (onIncidentAdded)
    __MPC_EXIT_IF_METHOD_FAILS(hr, Fire_NotificationEvent( EVENT_INCIDENTADDED, GetSizeIncidentList(), this, *pVal, 0 ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    (void)CloseIncidentStore( pIStore );

    __HCP_FUNC_EXIT(hr);
}

CSAFChannel::IterConst CSAFChannel::Find( /*[in]*/ BSTR bstrURL )
{
    IterConst it;

    //
    // Release all the items.
    //
    for(it = m_lstIncidentItems.begin(); it != m_lstIncidentItems.end(); it++)
    {
        if((*it)->GetURL() == bstrURL) break;
    }

    return it;
}

CSAFChannel::IterConst CSAFChannel::Find( /*[in]*/ DWORD dwIndex )
{
    IterConst it;

    //
    // Release all the items.
    //
    for(it = m_lstIncidentItems.begin(); it != m_lstIncidentItems.end(); it++)
    {
        if((*it)->GetRecIndex() == dwIndex) break;
    }

    return it;
}

/////////////////////////////////////////////////////////////////////////////
// Custom interfaces

STDMETHODIMP CSAFChannel::get_VendorID( /*[out, retval]*/ BSTR *pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return m_data.GetField( CSAFChannelRecord::SAFREG_VendorID, pVal );
}

STDMETHODIMP CSAFChannel::get_ProductID( /*[out, retval]*/ BSTR *pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return m_data.GetField( CSAFChannelRecord::SAFREG_ProductID, pVal );
}

STDMETHODIMP CSAFChannel::get_VendorName( /*[out, retval]*/ BSTR *pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return m_data.GetField( CSAFChannelRecord::SAFREG_VendorName, pVal );
}

STDMETHODIMP CSAFChannel::get_ProductName( /*[out, retval]*/ BSTR *pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return m_data.GetField( CSAFChannelRecord::SAFREG_ProductName, pVal );
}

STDMETHODIMP CSAFChannel::get_Description( /*[out, retval]*/ BSTR *pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return m_data.GetField( CSAFChannelRecord::SAFREG_ProductDescription, pVal );
}

STDMETHODIMP CSAFChannel::get_VendorDirectory( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_FUNC_ENTRY( "CSAFChannel::get_VendorDirectory" );

    HRESULT                      	hr;
    MPC::SmartLock<_ThreadModel> 	lock( this );
    MPC::wstring                 	strRoot;
    Taxonomy::LockingHandle         handle;
    Taxonomy::InstalledInstanceIter it;
    bool                            fFound;


    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();

	if(m_data.m_bstrVendorID.Length() == 0)
	{
		__MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
	}


	__MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->GrabControl( handle                   ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->SKU_Find   ( m_data.m_ths, fFound, it ));
    if(!fFound)
	{
		__MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
	}

	strRoot  = it->m_inst.m_strSystem; 
	strRoot += HC_HELPSET_SUB_VENDORS L"\\"; MPC::SubstituteEnvVariables( strRoot );
	strRoot += m_data.m_bstrVendorID;

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( strRoot.c_str(), pVal ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CSAFChannel::get_Security( /*[out, retval]*/ IPCHSecurityDescriptor* *pVal )
{
    __HCP_FUNC_ENTRY( "CSAFChannel::get_Security" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


    if(m_data.m_bstrSecurity.Length())
    {
        if(m_Security == NULL)
        {
            CPCHSecurityDescriptorDirect sdd;

            __MPC_EXIT_IF_METHOD_FAILS(hr, sdd.ConvertFromString( m_data.m_bstrSecurity ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHSecurity::s_GLOBAL->CreateObject_SecurityDescriptor( &m_Security ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, sdd.ConvertSDToCOM( m_Security ));
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_Security.CopyTo( pVal ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CSAFChannel::put_Security( /*[in]*/ IPCHSecurityDescriptor* newVal )
{
    __HCP_FUNC_ENTRY( "CSAFChannel::put_Security" );

    HRESULT hr;


    m_data.m_bstrSecurity.Empty  ();
    m_Security           .Release();

    if(newVal)
    {
        CPCHSecurityDescriptorDirect sdd;

        __MPC_EXIT_IF_METHOD_FAILS(hr, sdd.ConvertSDFromCOM( newVal ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, sdd.ConvertToString( &m_data.m_bstrSecurity ));
    }

    //
    // Update the SAF store...
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, CSAFReg::s_GLOBAL->UpdateField( m_data, CSAFChannelRecord::SAFREG_Security ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CSAFChannel::get_Notification( /*[out, retval]*/ BSTR *pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return m_data.GetField( CSAFChannelRecord::SAFREG_Notification, pVal );
}

STDMETHODIMP CSAFChannel::put_Notification( /*[in]*/ BSTR newVal )
{
    __HCP_FUNC_ENTRY( "CSAFChannel::get_Notification" );

    HRESULT                      hr;
    CLSID                        clsID;
    MPC::SmartLock<_ThreadModel> lock( this );


    // Lets see if the CLSID is valid, if not return error
    if(FAILED(hr = ::CLSIDFromString( newVal, &clsID )))
    {
        DebugLog(L"Not a valid GUID!\r\n");
        __MPC_FUNC_LEAVE;
    }

    // Set the CSAFChannel object member
    m_data.m_bstrNotification = newVal;

    // Place the Notification GUID into the XML SAFReg
    __MPC_EXIT_IF_METHOD_FAILS(hr, CSAFReg::s_GLOBAL->UpdateField( m_data, CSAFChannelRecord::SAFREG_Notification ));

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CSAFChannel::Incidents( /*[in]*/          IncidentCollectionOptionEnum  opt ,
                                     /*[out, retval]*/ IPCHCollection*              *ppC )
{
    __HCP_FUNC_ENTRY( "CSAFChannel::get_Incidents" );

    HRESULT                      hr;
    IterConst                    it;
    CComPtr<CPCHCollection>      pColl;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(ppC,NULL);
    __MPC_PARAMCHECK_END();


    //  Check the value of "opt" if other than 0,1,2 flag an error
    switch(opt)
    {
    case pchAllIncidents   : break;
    case pchOpenIncidents  : break;
    case pchClosedIncidents: break;
    default                : __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);// Not a valid Option. Set the error.
    }

    //
    // Create the Enumerator and fill it with items.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pColl ));

    for(it = m_lstIncidentItems.begin(); it != m_lstIncidentItems.end(); it++)
    {
        CSAFIncidentItem* item = *it;

        if(item->MatchEnumOption( opt ))
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, pColl->AddItem( item ));
        }
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, pColl.QueryInterface( ppC ));

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

//  The following method needs to be in the IncidentItem ideally.
// First take it out from here.

STDMETHODIMP CSAFChannel::RecordIncident( /*[in]*/  BSTR               bstrDisplay  ,
                                          /*[in]*/  BSTR               bstrURL      ,
                                          /*[in]*/  VARIANT            vProgress    ,
                                          /*[in]*/  VARIANT            vXMLDataFile ,
                                          /*[in]*/  VARIANT            vXMLBlob     ,
                                          /*[out]*/ ISAFIncidentItem* *pVal         )
{
    __HCP_FUNC_ENTRY( "CSAFChannel::RecordIncident" );

    HRESULT                      hr;
    CComPtr<CSAFIncidentItem>    pItem;
    MPC::SmartLock<_ThreadModel> lock( this );
    BSTR                         bstrProgress    = (vProgress.vt    == VT_BSTR ? vProgress   .bstrVal : NULL);
    BSTR                         bstrXMLDataFile = (vXMLDataFile.vt == VT_BSTR ? vXMLDataFile.bstrVal : NULL);
    BSTR                         bstrXMLBlob     = (vXMLBlob.vt     == VT_BSTR ? vXMLBlob    .bstrVal : NULL);


    __MPC_EXIT_IF_METHOD_FAILS(hr, Create( bstrDisplay, bstrURL, bstrProgress, bstrXMLDataFile, bstrXMLBlob, &pItem ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pItem.QueryInterface( pVal ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CSAFChannel::RemoveIncidentFromList( /*[in]*/ CSAFIncidentItem* pVal )
{
    __HCP_FUNC_ENTRY( "CSAFChannel::RemoveIncidentFromList" );

    HRESULT                      hr;
    IterConst                    it;
    MPC::SmartLock<_ThreadModel> lock( this );


    // Fire an event to the Notification Object (onIncidentAdded)
    __MPC_EXIT_IF_METHOD_FAILS(hr, Fire_NotificationEvent( EVENT_INCIDENTREMOVED, GetSizeIncidentList(), this, pVal, 0 ));


    it = Find( pVal->GetRecIndex() );
    if(it != m_lstIncidentItems.end())
    {
        (*it)->Release();

        m_lstIncidentItems.erase( it );
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

/*
    Function CSAFChannel::Fire_Notification

    Description
    This function is used to fire a notification event on the registered notification object.
    If there is no notification object, this will do nothing.

    Parameters:

    Depending on the type of Event you want to fire, different parameters must be filled out.
    The following table shows which are the valid parameters for the call.  If a parameter
    is not valid, it MUST be set to NULL.

        iEventType  - EVENT_INCIDENTADDED

                        Valid parameters:
                        - iCountIncidentInChannel
                        - pC
                        - pI

                    - EVENT_INCIDENTREMOVED

                        Valid parameters:
                        - iCountIncidentInChannel
                        - pC
                        - pI

                    - EVENT_INCIDENTUPDATED

                        Valid parameters:
                        - iCountIncidentInChannel
                        - pC
                        - pI

                    - EVENT_CHANNELUPDATED

                        Valid parameters:
                        - iCountIncidentInChannel
                        - pC
                        - dwCode


  */

HRESULT CSAFChannel::Fire_NotificationEvent( int               iEventType              ,
                                             int               iCountIncidentInChannel ,
                                             ISAFChannel*      pC                      ,
                                             ISAFIncidentItem* pI                      ,
                                             DWORD             dwCode                  )
{
    __HCP_FUNC_ENTRY( "CSAFChannel::Fire_NotificationEvent" );

    HRESULT                hr;
    PWTS_SESSION_INFO      pSessionInfo    = NULL;
    DWORD                  dwSessions      = 0;
    DWORD                  dwValidSessions = 0;
    DWORD                  dwRetSize       = 0;

    WINSTATIONINFORMATIONW WSInfo;

    CComBSTR               bstrCaller;

    PSID                   pSID            = NULL;
    LPCWSTR                szDomain        = NULL;
    LPCWSTR                szLogin         = NULL;

    CLSID                  clsID;
    ULONG                  ulRet;



    // Check to see if we have a registered Notification Object
    if(!m_data.m_bstrNotification || FAILED(::CLSIDFromString( m_data.m_bstrNotification, &clsID )))
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    //
    // First lets get the callers Domain and Name by impersonating the caller and grabbing them
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetCallerPrincipal( true, bstrCaller ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SecurityDescriptor::ConvertPrincipalToSID( bstrCaller, pSID ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SecurityDescriptor::ConvertSIDToPrincipal( pSID, &szLogin, &szDomain ));



    // Enumerate all sessions on this machine
    // -------------------------------------------
    // Use WTSEnumerateSessions
    // Then find active ones
    // Then make the calls to ISAFChannelNotifyIncident

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::WTSEnumerateSessions( WTS_CURRENT_SERVER_HANDLE, 0, 1, &pSessionInfo, &dwSessions ))

    // Find the active ones and mark them only if they are the correct user
    for(DWORD i = 0; i < dwSessions; i++)
    {
        if(pSessionInfo[i].State == WTSActive) // Got an active session
        {
            CComPtr<IPCHSlaveProcess>          sp;
            CComPtr<IUnknown>                  unk;
            CComPtr<ISAFChannelNotifyIncident> chNot;


            // Now mark it if the Username and Domain match that of the user
            // we are calling for.
            memset( &WSInfo, 0, sizeof(WSInfo) );

            __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::WinStationQueryInformationW( SERVERNAME_CURRENT        ,
                                                                                pSessionInfo[i].SessionId ,
                                                                                WinStationInformation     ,
                                                                                &WSInfo                   ,
                                                                                sizeof(WSInfo)            ,
                                                                                &dwRetSize                ));

            // Now we can fish the userid and domain out of the WSInfo.Domain and WSInfo.UserName


            // Now we are ready to compare the domain and username
            if((wcscmp( WSInfo.Domain  , szDomain ) == 0) &&
               (wcscmp( WSInfo.UserName, szLogin  ) == 0)  )
            {
                WINSTATIONUSERTOKEN WsUserToken;

                // We found the correct sessions, make the calls to ISAFChannelNotifyIncident
                WsUserToken.ProcessId = LongToHandle( GetCurrentProcessId() );
                WsUserToken.ThreadId  = LongToHandle( GetCurrentThreadId () );

                // Grab token from SessionID
                __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::WinStationQueryInformationW( WTS_CURRENT_SERVER_HANDLE ,
                                                                                    pSessionInfo[i].SessionId ,
                                                                                    WinStationUserToken       ,
                                                                                    &WsUserToken              ,
                                                                                    sizeof(WsUserToken)       ,
                                                                                    &ulRet                    ));

                // Create the notification object in the session (using the hToken
                {
                    CPCHUserProcess::UserEntry ue;

                    __MPC_EXIT_IF_METHOD_FAILS(hr, ue.InitializeForImpersonation( WsUserToken.UserToken ));

                    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHUserProcess::s_GLOBAL->Connect( ue, &sp  ));
                }

                //
                // Discard all the failures from the remote objects.
                //
                ////////////////////////////////////////////////////////////////////////////////

                // Use the Slave Process to Create the object which CLSID clsID.
                if(FAILED(hr = sp->CreateInstance( clsID, NULL, &unk )))
                {
                    continue;
                }

                // Grab a pointer to the correct interface
                if(FAILED(hr = unk.QueryInterface( &chNot )))
                {
                    continue;
                }

                // Depending on the type of notification, call the correct event callback
                switch(iEventType)
                {
                case EVENT_INCIDENTADDED  : hr = chNot->onIncidentAdded  ( pC, pI    , iCountIncidentInChannel ); break;
                case EVENT_INCIDENTREMOVED: hr = chNot->onIncidentRemoved( pC, pI    , iCountIncidentInChannel ); break;
                case EVENT_INCIDENTUPDATED: hr = chNot->onIncidentUpdated( pC, pI    , iCountIncidentInChannel ); break;
                case EVENT_CHANNELUPDATED : hr = chNot->onChannelUpdated ( pC, dwCode, iCountIncidentInChannel ); break;
                }
                if(FAILED(hr))
                {
                    continue;
                }
            }
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    MPC::SecurityDescriptor::ReleaseMemory( (void *&)pSID     );
    MPC::SecurityDescriptor::ReleaseMemory( (void *&)szLogin  );
    MPC::SecurityDescriptor::ReleaseMemory( (void *&)szDomain );

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\othertools\verifyhhk\main.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    main.cpp

Abstract:
    This file contains the implementation of ReformatHHK utility, used to load
	and sort HHK files.

Revision History:
    Davide Massarenti   (Dmassare)  06/09/2000
        created

******************************************************************************/

#include "stdafx.h"

//////////////////////////////////////////////////////////////////////

HRESULT ProcessHHK( LPCWSTR szFile )
{
    __HCP_FUNC_ENTRY( "ProcessHHK" );

	USES_CONVERSION;

    HRESULT                 hr;
    HHK::Merger::FileEntity ent( szFile );
	MPC::string             szTitle;

	__MPC_EXIT_IF_METHOD_FAILS(hr, ent.Init());

	while(ent.MoveNext() == true)
	{
        HHK::Section*           sec = ent.GetSection();
		HHK::Section::EntryIter it;

        if(szTitle.size() && HHK::Reader::StrColl( sec->m_szTitle.c_str(), szTitle.c_str() ) < 0)
        {
			wprintf( L"Keyword out of order: '%s' after '%s'\n", A2W( sec->m_szTitle.c_str() ), A2W( szTitle.c_str() ) );
        }

        if(szTitle.size() && HHK::Reader::StrColl( sec->m_szTitle.c_str(), szTitle.c_str() ) == 0)
        {
			wprintf( L"Duplicate Keyword: '%s'\n", A2W( sec->m_szTitle.c_str() ) );
        }

        szTitle = sec->m_szTitle.c_str();


		for(it = sec->m_lstEntries.begin(); it != sec->m_lstEntries.end(); it++)
		{
			HHK::Entry& entry = *it;

			if(entry.m_szTitle.size() == 0)
			{
				wprintf( L"Keyword with an empty title: '%s'\n", A2W( sec->m_szTitle.c_str() ) );
			}

			if(entry.m_lstUrl.size() == 0)
			{
				wprintf( L"Keyword with a title but not URL: '%s' => '%s' \n", A2W( sec->m_szTitle.c_str() ), A2W( entry.m_szTitle.c_str() ) );
			}
		}
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void ExtractHhkName( MPC::wstring& szFullName,
					 LPCWSTR       szFileName )
{
	LPCWSTR szEnd;
	LPCWSTR szEnd2;

	if((szEnd  = wcsrchr( szFileName, '\\' )) &&
	   (szEnd2 = wcsrchr( szEnd     , '.'  ))  )
	{
		MPC::wstring szTmp;

		szTmp  = L"ms-its:";
		szTmp += szFileName;
		szTmp += L"::/";
		szTmp += MPC::wstring( szEnd+1, szEnd2 );
		szTmp += L".hhk";
		
		szFullName = szTmp;
	}
	else
	{
		szFullName = szFileName;
	}
}

HRESULT ExpandAndProcessHHK( LPCWSTR szFile )
{
    __HCP_FUNC_ENTRY( "ExpandAndProcessHHK" );

	HRESULT      hr;
	MPC::wstring szFileName;


	if(MPC::MSITS::IsCHM( szFile ) == false && StrStrIW( szFile, L".hhk" ) == NULL)
    {
		ExtractHhkName( szFileName, szFile );
	}
	else
	{
		szFileName = szFile;
	}

	wprintf( L"Processing '%s'...\n", szFileName.c_str() );

	hr = ProcessHHK( szFileName.c_str() );


    __HCP_FUNC_EXIT(hr);
}


/////////////////////////////////////////////////////////////////////////////
//
int __cdecl wmain( int     argc   ,
				   LPCWSTR argv[] )
{
	HRESULT      hr;
	MPC::wstring szFile;

	if(argc < 2)
	{
		wprintf( L"Usage: %s <file to analyze>\n", argv[0] );
		exit( 1 );
	}


    if(FAILED(hr = ::CoInitializeEx( NULL, COINIT_MULTITHREADED )))
    {
		wprintf( L"No COM!!\n" );
		exit(2);
    }

	MPC::SubstituteEnvVariables( szFile = argv[1] );

	{
		MPC::FileSystemObject fso( szFile.c_str() );

		if(fso.IsDirectory())
		{
			MPC::FileSystemObject::List lst;
			MPC::FileSystemObject::Iter it;


			if(FAILED(hr = fso.EnumerateFiles( lst )))
			{
				wprintf( L"Failed to read directory %s: %08x\n", szFile.c_str(), hr );
				exit(2);
			}

			for(it=lst.begin(); it!=lst.end(); it++)
			{
				MPC::wstring szSubFile;

				(*it)->get_Path( szSubFile );

				if(StrStrIW( szSubFile.c_str(), L".chm" ))
				{
					(void)ExpandAndProcessHHK( szSubFile.c_str() );
				}
			}
		}
		else
		{
			if(FAILED(hr = ExpandAndProcessHHK( szFile.c_str() )))
			{
				wprintf( L"Failed to process %s: %08x\n", argv[1], hr );
				exit(3);
			}
		}
	}

    ::CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\channels\lib\incidentstore.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    IncidentStore.cpp

Abstract:
    File for Implementation of CIncidentStore

Revision History:
    Steve Shih        created  07/19/99

    Davide Massarenti rewrote  12/05/2000

********************************************************************/
#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/       IncidentStatusEnum& val ) { return stream.read ( &val, sizeof(val) ); }
HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const IncidentStatusEnum& val ) { return stream.write( &val, sizeof(val) ); }

////////////////////////////////////////////////////////////////////////////////

static const WCHAR c_szEventObject[] =  L"PCH_INCIDENTSTORE";
static const WCHAR c_szStorePath  [] =  HC_HELPSVC_STORE_INCIDENTITEMS;


static const DWORD l_dwVersion = 0x0100AF05; // SAF 01

////////////////////////////////////////////////////////////////////////////////

CSAFIncidentRecord::CSAFIncidentRecord()
{
    m_dwRecIndex   = -1;                 // DWORD              m_dwRecIndex;
                                         //
                                         // CComBSTR           m_bstrVendorID;
                                         // CComBSTR           m_bstrProductID;
                                         // CComBSTR           m_bstrDisplay;
                                         // CComBSTR           m_bstrURL;
                                         // CComBSTR           m_bstrProgress;
                                         // CComBSTR           m_bstrXMLDataFile;
	                                     // CComBSTR           m_bstrXMLBlob;
    m_dCreatedTime = 0;                  // DATE               m_dCreatedTime;
    m_dChangedTime = 0;                  // DATE               m_dChangedTime;
    m_dClosedTime  = 0;                  // DATE               m_dClosedTime;
    m_iStatus      = pchIncidentInvalid; // IncidentStatusEnum m_iStatus;
                                         //
                                         // CComBSTR           m_bstrSecurity;
	                                     // CComBSTR           m_bstrOwner;
}

HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/ CSAFIncidentRecord& increc )
{
    __HCP_FUNC_ENTRY( "CSAFIncidentRecord::operator>>" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> increc.m_dwRecIndex     );

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> increc.m_bstrVendorID   );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> increc.m_bstrProductID  );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> increc.m_bstrDisplay    );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> increc.m_bstrURL        );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> increc.m_bstrProgress   );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> increc.m_bstrXMLDataFile);
	__MPC_EXIT_IF_METHOD_FAILS(hr, stream >> increc.m_bstrXMLBlob    );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> increc.m_dCreatedTime   );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> increc.m_dChangedTime   );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> increc.m_dClosedTime    );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> increc.m_iStatus        );

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> increc.m_bstrSecurity   );
	__MPC_EXIT_IF_METHOD_FAILS(hr, stream >> increc.m_bstrOwner      );

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const CSAFIncidentRecord& increc )
{
    __HCP_FUNC_ENTRY( "CSAFIncidentRecord::operator<<" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << increc.m_dwRecIndex     );

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << increc.m_bstrVendorID   );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << increc.m_bstrProductID  );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << increc.m_bstrDisplay    );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << increc.m_bstrURL        );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << increc.m_bstrProgress   );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << increc.m_bstrXMLDataFile);
	__MPC_EXIT_IF_METHOD_FAILS(hr, stream << increc.m_bstrXMLBlob    );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << increc.m_dCreatedTime   );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << increc.m_dChangedTime   );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << increc.m_dClosedTime    );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << increc.m_iStatus        );

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << increc.m_bstrSecurity   );
	__MPC_EXIT_IF_METHOD_FAILS(hr, stream << increc.m_bstrOwner      );

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

CIncidentStore::CIncidentStore() : MPC::NamedMutex( c_szEventObject )
{
    m_fLoaded     = false; // bool  m_fLoaded;
    m_fDirty      = false; // bool  m_fDirty;
    m_dwNextIndex = 0;     // DWORD m_dwNextIndex;
                           // List  m_lstIncidents;
	m_strNotificationGuid = ""; // String m_strNotificationGuid;
}


CIncidentStore::~CIncidentStore()
{
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CIncidentStore::Load()
{
    __HCP_FUNC_ENTRY( "CIncidentStore::Load" );

    HRESULT hr;
    HANDLE  hFile = INVALID_HANDLE_VALUE;


    if(m_fLoaded == false)
    {
        MPC::wstring szFile = c_szStorePath; MPC::SubstituteEnvVariables( szFile );


        m_dwNextIndex = 0;


        //
        // Get the named mutex, so that only one instance at a time can access the store.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, Acquire());

        //
        // Open the store.
        //
        hFile = ::CreateFileW( szFile.c_str()        ,
                               GENERIC_READ          ,
                               0                     ,
                               NULL                  ,
                               OPEN_EXISTING         ,
                               FILE_ATTRIBUTE_NORMAL ,
                               NULL                  );
        if(hFile == INVALID_HANDLE_VALUE)
        {
            DWORD dwRes = ::GetLastError();

            if(dwRes != ERROR_FILE_NOT_FOUND)
            {
                __MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRes);
            }
        }
        else
        {
            MPC::Serializer& stream = MPC::Serializer_File( hFile );
            DWORD            dwVer;


            if(SUCCEEDED(stream >> dwVer) && dwVer == l_dwVersion)
            {
                if(SUCCEEDED(stream >> m_dwNextIndex))
                {
					//if (SUCCEEDED( stream >> m_strNotificationGuid))
					//{
						while(1)
						{
							Iter it = m_lstIncidents.insert( m_lstIncidents.end() );
							
							if(FAILED(stream >> *it))
							{
								m_lstIncidents.erase( it );
								break;
							}
						}
					//}
                }
            }
        }
    }

    m_fLoaded = true;
    m_fDirty  = false;
    hr        = S_OK;


    __HCP_FUNC_CLEANUP;

    if(hFile != INVALID_HANDLE_VALUE) ::CloseHandle( hFile );

    __HCP_FUNC_EXIT(hr);
}

HRESULT CIncidentStore::Save()
{
    __HCP_FUNC_ENTRY( "CIncidentStore::Save" );

    HRESULT hr;
    HANDLE  hFile = INVALID_HANDLE_VALUE;


    if(m_fLoaded && m_fDirty)
    {
        MPC::wstring szFile = c_szStorePath; MPC::SubstituteEnvVariables( szFile );


        //
        // Open the store.
        //
        __MPC_EXIT_IF_INVALID_HANDLE(hr, hFile, ::CreateFileW( szFile.c_str()        ,
                                                               GENERIC_WRITE         ,
                                                               0                     ,
                                                               NULL                  ,
                                                               CREATE_ALWAYS         ,
                                                               FILE_ATTRIBUTE_NORMAL ,
                                                               NULL                  ));

        {
            MPC::Serializer& stream = MPC::Serializer_File( hFile );
            Iter             it;

            __MPC_EXIT_IF_METHOD_FAILS(hr, stream << l_dwVersion  );
            __MPC_EXIT_IF_METHOD_FAILS(hr, stream << m_dwNextIndex);

			// Persist the string version of the notification GUID
			//__MPC_EXIT_IF_METHOD_FAILS(hr, stream << m_strNotificationGuid);


            for(it = m_lstIncidents.begin(); it != m_lstIncidents.end(); it++)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, stream << *it);
            }
        }

        m_fDirty = false;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(hFile != INVALID_HANDLE_VALUE) ::CloseHandle( hFile );

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CIncidentStore::OpenChannel( CSAFChannel* pChan )
{
    __HCP_FUNC_ENTRY( "CIncidentStore::OpenChannel" );

    HRESULT   hr;
    LPCWSTR   szVendorID  = pChan->GetVendorID ();
    LPCWSTR   szProductID = pChan->GetProductID();
    IterConst it;

	SANITIZEWSTR( szVendorID  );
	SANITIZEWSTR( szProductID );

    __MPC_EXIT_IF_METHOD_FAILS(hr, Load());


    for(it = m_lstIncidents.begin(); it != m_lstIncidents.end(); it++)
    {
        if(MPC::StrICmp( it->m_bstrVendorID , szVendorID  ) == 0 &&
           MPC::StrICmp( it->m_bstrProductID, szProductID ) == 0  )
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, pChan->Import( *it, NULL ));
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CIncidentStore::AddRec( CSAFChannel*       pChan          ,
                                BSTR               bstrOwner      ,
                                BSTR               bstrDesc       ,
                                BSTR               bstrURL        ,
                                BSTR               bstrProgress   ,
                                BSTR               bstrXMLDataFile,
								BSTR               bstrXMLBlob,
                                CSAFIncidentItem* *ppItem         )
{
    __HCP_FUNC_ENTRY( "CIncidentStore::Init" );

    HRESULT hr;
    Iter    it;
		 

    __MPC_EXIT_IF_METHOD_FAILS(hr, Load());

    it                    = m_lstIncidents.insert( m_lstIncidents.end() );
    it->m_dwRecIndex      = m_dwNextIndex++;

    it->m_bstrVendorID    = pChan->GetVendorID ();
    it->m_bstrProductID   = pChan->GetProductID();
    it->m_bstrDisplay     = bstrDesc;
    it->m_bstrURL         = bstrURL;
    it->m_bstrProgress    = bstrProgress;
    it->m_bstrXMLDataFile = bstrXMLDataFile;
	it->m_bstrXMLBlob     = bstrXMLBlob;
    it->m_dCreatedTime    = MPC::GetLocalTime();
    it->m_dChangedTime    = it->m_dCreatedTime;
    it->m_dClosedTime     = 0;
    it->m_iStatus         = pchIncidentOpen;
	it->m_bstrOwner       = bstrOwner;
    m_fDirty              = true;

    //
    // Create the IncidentItem.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, pChan->Import( *it, ppItem ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;
   
    __HCP_FUNC_EXIT(hr);
}

HRESULT CIncidentStore::DeleteRec( CSAFIncidentItem* pItem )
{
    __HCP_FUNC_ENTRY( "CIncidentStore::DeleteRec" );

    HRESULT hr;
    DWORD   dwIndex = pItem->GetRecIndex();
    Iter    it;


    for(it = m_lstIncidents.begin(); it != m_lstIncidents.end(); it++)
    {
        if(it->m_dwRecIndex == dwIndex)
        {
            m_lstIncidents.erase( it );

            m_fDirty = true; break;
        }
    }

    hr = S_OK;


    __HCP_FUNC_EXIT(hr);
}

HRESULT CIncidentStore::UpdateRec( CSAFIncidentItem* pItem )
{
    __HCP_FUNC_ENTRY( "CIncidentStore::UpdateRec" );

    HRESULT hr;
    DWORD   dwIndex = pItem->GetRecIndex();
    Iter    it;


    for(it = m_lstIncidents.begin(); it != m_lstIncidents.end(); it++)
    {
        if(it->m_dwRecIndex == dwIndex)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, pItem->Export( *it ));

            m_fDirty = true; break;
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\channels\lib\incidentitem.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    IncidentItem.cpp

Abstract:
    File for Implementation of CSAFIncidentItem

Revision History:
    Steve Shih        created  07/15/99

    Davide Massarenti rewrote  12/05/2000

********************************************************************/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////
// CSAFIncidentItem

CSAFIncidentItem::CSAFIncidentItem()
{
    __HCP_FUNC_ENTRY( "CSAFIncidentItem::CSAFIncidentItem" );

	                   // CSAFIncidentRecord m_increc;
    m_fDirty  = false; // bool               m_fDirty;
}

HRESULT CSAFIncidentItem::Import( /*[in] */ const CSAFIncidentRecord& increc )
{
    __HCP_FUNC_ENTRY( "CSAFIncidentItem::Import" );


	m_increc = increc;


    __HCP_FUNC_EXIT(S_OK);
}

HRESULT CSAFIncidentItem::Export( /*[in] */ CSAFIncidentRecord& increc )
{
    __HCP_FUNC_ENTRY( "CSAFIncidentItem::Export" );

    CSAFChannel *pChan;


    Child_GetParent( &pChan );

	increc                 = m_increc;
    increc.m_bstrVendorID  = pChan->GetVendorID ();
    increc.m_bstrProductID = pChan->GetProductID();

    pChan->Release();


    __HCP_FUNC_EXIT(S_OK);
}

bool CSAFIncidentItem::MatchEnumOption( /*[in]*/ IncidentCollectionOptionEnum opt )
{
	bool  fRes     = false;
	DWORD dwGroups = 0;

	switch(opt)
	{
	case pchAllIncidents   : case pchAllIncidentsAllUsers 	: fRes =  true                                    ; break;
	case pchOpenIncidents  : case pchOpenIncidentsAllUsers	: fRes = (m_increc.m_iStatus == pchIncidentOpen  ); break;
	case pchClosedIncidents: case pchClosedIncidentsAllUsers: fRes = (m_increc.m_iStatus == pchIncidentClosed); break;
	}

	switch(opt)
	{
	//
	// For these options, administrators will see other users' incidents.
	//
	case pchAllIncidentsAllUsers   :
	case pchOpenIncidentsAllUsers  :
	case pchClosedIncidentsAllUsers:
		dwGroups = MPC::IDENTITY_SYSTEM | MPC::IDENTITY_ADMIN | MPC::IDENTITY_ADMINS;
		break;
	}

	if(fRes && FAILED(MPC::CheckCallerAgainstPrincipal( /*fImpersonate*/true, m_increc.m_bstrOwner, dwGroups )))
	{
		fRes = false;
	}

	return fRes;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CSAFIncidentItem::VerifyPermissions( /*[in]*/ bool fModify )
{
	__HCP_FUNC_ENTRY( "CSAFIncidentItem::VerifyPermissions" );

	HRESULT hr;


	if(m_increc.m_bstrSecurity.Length())
	{
		MPC::AccessCheck ac;
		BOOL 			 fGranted;
		DWORD			 dwGranted;


		__MPC_EXIT_IF_METHOD_FAILS(hr, ac.GetTokenFromImpersonation());


		__MPC_EXIT_IF_METHOD_FAILS(hr, ac.Verify( fModify ? ACCESS_WRITE : ACCESS_READ, fGranted, dwGranted, m_increc.m_bstrSecurity ));

		if(fGranted == FALSE)
		{
			__MPC_EXIT_IF_METHOD_FAILS(hr, E_ACCESSDENIED);
		}
	}

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CSAFIncidentItem::get_DisplayString( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CSAFIncidentItem::get_DisplayString",hr,pVal);


	__MPC_EXIT_IF_METHOD_FAILS(hr, VerifyPermissions( FALSE ));


	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_increc.m_bstrDisplay, pVal ));


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CSAFIncidentItem::put_DisplayString( /*[in]*/ BSTR newVal )
{
    __HCP_BEGIN_PROPERTY_PUT("CSAFIncidentItem::put_DisplayString",hr);


	__MPC_EXIT_IF_METHOD_FAILS(hr, VerifyPermissions( TRUE ));


    m_increc.m_bstrDisplay = newVal;
    m_fDirty               = true;

	__MPC_EXIT_IF_METHOD_FAILS(hr, Save());


    __HCP_END_PROPERTY(hr);
}


STDMETHODIMP CSAFIncidentItem::get_URL( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CSAFIncidentItem::get_URL",hr,pVal);


	__MPC_EXIT_IF_METHOD_FAILS(hr, VerifyPermissions( FALSE ));


	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_increc.m_bstrURL, pVal ));


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CSAFIncidentItem::put_URL( /*[in]*/ BSTR newVal )
{
    __HCP_BEGIN_PROPERTY_PUT("CSAFIncidentItem::put_URL",hr);


	__MPC_EXIT_IF_METHOD_FAILS(hr, VerifyPermissions( TRUE ));


    m_increc.m_bstrURL = newVal;
    m_fDirty           = true;

	__MPC_EXIT_IF_METHOD_FAILS(hr, Save());


    __HCP_END_PROPERTY(hr);
}


STDMETHODIMP CSAFIncidentItem::get_Progress( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CSAFIncidentItem::get_Progress",hr,pVal);


	__MPC_EXIT_IF_METHOD_FAILS(hr, VerifyPermissions( FALSE ));


	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_increc.m_bstrProgress, pVal ));


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CSAFIncidentItem::put_Progress( /*[in]*/ BSTR newVal )
{
    __HCP_BEGIN_PROPERTY_PUT("CSAFIncidentItem::put_Progress",hr);


	__MPC_EXIT_IF_METHOD_FAILS(hr, VerifyPermissions( FALSE ));


    m_increc.m_bstrProgress = newVal;
    m_fDirty                = true;

	__MPC_EXIT_IF_METHOD_FAILS(hr, Save());


    __HCP_END_PROPERTY(hr);
}


STDMETHODIMP CSAFIncidentItem::get_XMLDataFile( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CSAFIncidentItem::get_XMLDataFile",hr,pVal);


	__MPC_EXIT_IF_METHOD_FAILS(hr, VerifyPermissions( FALSE ));


	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_increc.m_bstrXMLDataFile, pVal ));


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CSAFIncidentItem::put_XMLDataFile( /*[in]*/ BSTR newVal )
{
    __HCP_BEGIN_PROPERTY_PUT("CSAFIncidentItem::put_XMLDataFile",hr);


	__MPC_EXIT_IF_METHOD_FAILS(hr, VerifyPermissions( TRUE ));


    m_increc.m_bstrXMLDataFile = newVal;
    m_fDirty                   = true;

    __MPC_EXIT_IF_METHOD_FAILS(hr, Save());


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CSAFIncidentItem::get_XMLBlob( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CSAFIncidentItem::get_XMLBlob",hr,pVal);


	__MPC_EXIT_IF_METHOD_FAILS(hr, VerifyPermissions( FALSE ));


	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_increc.m_bstrXMLBlob, pVal ));


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CSAFIncidentItem::put_XMLBlob( /*[in]*/ BSTR newVal )
{
    __HCP_BEGIN_PROPERTY_PUT("CSAFIncidentItem::put_XMLBlob",hr);

	__MPC_EXIT_IF_METHOD_FAILS(hr, VerifyPermissions( TRUE ));


    m_increc.m_bstrXMLBlob = newVal;
    m_fDirty                   = true;

    __MPC_EXIT_IF_METHOD_FAILS(hr, Save());


    __HCP_END_PROPERTY(hr);
}


STDMETHODIMP CSAFIncidentItem::get_CreationTime( /*[out, retval]*/ DATE *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CSAFIncidentItem::get_CreationTime",hr,pVal,0);


	__MPC_EXIT_IF_METHOD_FAILS(hr, VerifyPermissions( FALSE ));


    *pVal = m_increc.m_dCreatedTime;


    __HCP_END_PROPERTY(hr);
}


STDMETHODIMP CSAFIncidentItem::get_ChangedTime( /*[out, retval]*/ DATE *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CSAFIncidentItem::get_ChangedTime",hr,pVal,0);


	__MPC_EXIT_IF_METHOD_FAILS(hr, VerifyPermissions( FALSE ));


    *pVal = m_increc.m_dChangedTime;


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CSAFIncidentItem::get_ClosedTime( /*[out, retval]*/ DATE *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CSAFIncidentItem::get_ClosedTime",hr,pVal,0);


	__MPC_EXIT_IF_METHOD_FAILS(hr, VerifyPermissions( FALSE ));


    *pVal = m_increc.m_dClosedTime;


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CSAFIncidentItem::get_Status( /*[out, retval]*/ IncidentStatusEnum *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CSAFIncidentItem::get_Status",hr,pVal,pchIncidentInvalid);


	__MPC_EXIT_IF_METHOD_FAILS(hr, VerifyPermissions( TRUE ));


	*pVal = m_increc.m_iStatus;


    __HCP_END_PROPERTY(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CSAFIncidentItem::Save()
{
    __HCP_FUNC_ENTRY( "CSAFIncidentItem::Save" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    CIncidentStore*              pIStore = NULL;

	CSAFChannel *				 pChan = NULL;

	int					         ilstSize = 0x0;

    m_increc.m_dChangedTime = MPC::GetLocalTime();


    __MPC_EXIT_IF_METHOD_FAILS(hr, CSAFChannel::OpenIncidentStore( pIStore ));

	if(m_increc.m_iStatus == pchIncidentInvalid)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, pIStore->DeleteRec( this ));
	}
	else
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, pIStore->UpdateRec( this ));
	}

	// Grab the CSAFChannel (parent) of this CSAFIncidentItem
    Child_GetParent( &pChan );

	// Grab the size of the incident list to fire the event
	ilstSize = pChan->GetSizeIncidentList();

	// Fire the event EVENT_INCIDENTUPDATED
	__MPC_EXIT_IF_METHOD_FAILS(hr, pChan->Fire_NotificationEvent(EVENT_INCIDENTUPDATED,
								  ilstSize,
								  pChan,
								  this,
								  0));

    m_fDirty = false;
    hr       = S_OK;

    __HCP_FUNC_CLEANUP;

    CSAFChannel::CloseIncidentStore( pIStore );

	if(pChan) pChan->Release();	

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CSAFIncidentItem::get_Security( /*[out, retval]*/ IPCHSecurityDescriptor* *pVal )
{
	__HCP_FUNC_ENTRY( "CSAFIncidentItem::get_Security" );

	HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
	__MPC_PARAMCHECK_END();


	__MPC_EXIT_IF_METHOD_FAILS(hr, VerifyPermissions( FALSE ));


	if(m_increc.m_bstrSecurity.Length())
	{
		CPCHSecurityDescriptorDirect sdd;

		__MPC_EXIT_IF_METHOD_FAILS(hr, sdd.ConvertFromString( m_increc.m_bstrSecurity ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, CPCHSecurity::s_GLOBAL->CreateObject_SecurityDescriptor( pVal ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, sdd.ConvertSDToCOM( *pVal ));
	}

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CSAFIncidentItem::put_Security( /*[in]*/ IPCHSecurityDescriptor* newVal )
{
    __HCP_BEGIN_PROPERTY_PUT("CSAFChannel::put_Security",hr);


	__MPC_EXIT_IF_METHOD_FAILS(hr, VerifyPermissions( TRUE ));


	m_increc.m_bstrSecurity.Empty();

	if(newVal)
	{
		CPCHSecurityDescriptorDirect sdd;

		__MPC_EXIT_IF_METHOD_FAILS(hr, sdd.ConvertSDFromCOM( newVal ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, sdd.ConvertToString( &m_increc.m_bstrSecurity ));
	}

	__MPC_EXIT_IF_METHOD_FAILS(hr, Save());


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CSAFIncidentItem::get_Owner( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CSAFIncidentItem::get_Owner",hr,pVal);


	__MPC_EXIT_IF_METHOD_FAILS(hr, VerifyPermissions( FALSE ));


	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_increc.m_bstrOwner, pVal ));


    __HCP_END_PROPERTY(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CSAFIncidentItem::CloseIncidentItem()
{
    __HCP_FUNC_ENTRY( "CSAFIncidentItem::CloseIncidentItem" );

	HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


	__MPC_EXIT_IF_METHOD_FAILS(hr, VerifyPermissions( TRUE ));


	m_increc.m_dClosedTime = MPC::GetLocalTime();
    m_increc.m_iStatus     = pchIncidentClosed;

	__MPC_EXIT_IF_METHOD_FAILS(hr, Save());

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CSAFIncidentItem::DeleteIncidentItem()
{
    __HCP_FUNC_ENTRY( "CSAFIncidentItem::DeleteIncidentItem" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    CSAFChannel*                 pChan = NULL;


	__MPC_EXIT_IF_METHOD_FAILS(hr, VerifyPermissions( TRUE ));


    Child_GetParent( &pChan );

	if(pChan)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, pChan->RemoveIncidentFromList( this ));
	}


	if(m_increc.m_iStatus != pchIncidentInvalid)
	{
		m_increc.m_dClosedTime = MPC::GetLocalTime();
		m_increc.m_iStatus     = pchIncidentInvalid;

		__MPC_EXIT_IF_METHOD_FAILS(hr, Save());
	}

	hr = S_OK;


    __HCP_FUNC_CLEANUP;

	if(pChan) pChan->Release();

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\channels\test\notifyincident\atl.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\channels\lib\incidentstore.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    IncidentStore.h

Abstract:
    This is the header file for IncidentStore

Revision History:
    Steve Shih        created  07/14/99

    Davide Massarenti rewrote  12/05/2000

********************************************************************/

#ifndef __INCSTORE_H_
#define __INCSTORE_H_

#include "time.h"

#include "SAFLib.h"

class CIncidentStore : public MPC::NamedMutex
{
    typedef std::list< CSAFIncidentRecord > List;
    typedef List::iterator                  Iter;
    typedef List::const_iterator            IterConst;
	typedef MPC::wstring					String;

    bool  m_fLoaded;
    bool  m_fDirty;
    DWORD m_dwNextIndex;
    List  m_lstIncidents;

	CComBSTR  m_strNotificationGuid;


public:
    CIncidentStore();
    virtual ~CIncidentStore();


    HRESULT Load();
    HRESULT Save();


    HRESULT OpenChannel( CSAFChannel* pChan                                                                                                                                           );
    HRESULT AddRec     ( CSAFChannel* pChan, BSTR bstrOwner, BSTR bstrDesc, BSTR bstrURL, BSTR bstrProgress, BSTR bstrXMLDataFile, BSTR XMLDataBlob, CSAFIncidentItem* *ppItem );
    HRESULT DeleteRec  (                                                                                                                             CSAFIncidentItem*   pItem );
    HRESULT UpdateRec  (                                                                                                                             CSAFIncidentItem*   pItem );

};

#endif // __INCSTORE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\channels\lib\stdafx.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    StdAfx.h

Abstract:
    This file generates the Precompiled headers.

Revision History:
    Davide Massarenti   (Dmassare)  00/00/2000
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__3E4C2A94_3891_11D3_85AE_00C04F610557__INCLUDED_)
#define AFX_STDAFX_H__3E4C2A94_3891_11D3_85AE_00C04F610557__INCLUDED_


#define EVENT_INCIDENTADDED		0x1
#define EVENT_INCIDENTREMOVED	0x2
#define EVENT_INCIDENTUPDATED	0x3
#define EVENT_CHANNELUPDATED	0x4

#include <module.h>

#include <HCP_trace.h>

#include <SAFLib.h>
#include <locres.h>

#include <AccountsLib.h>

#include <SecurityLib.h>

#include <Utility.h>

#include <winsta.h>
#include <wtsapi32.h>

#include "IncidentStore.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__3E4C2A94_3891_11D3_85AE_00C04F610557__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\channels\lib\safreg.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    SAFReg.cpp

Abstract:
    File for Implementation of CSAFReg

Revision History:
    Steve Shih        created  07/15/99

    Davide Massarenti rewrote  05/12/2000

********************************************************************/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////
// CSAFReg

const WCHAR c_SAFStore         [] = HC_HELPSVC_STORE_CHANNELS;

const WCHAR c_szXML_ProductID  [] = L"ProductID";
const WCHAR c_szXML_ProductName[] = L"ProductName";
const WCHAR c_szXML_Description[] = L"ProductDescription";
const WCHAR c_szXML_EntryURL   [] = L"EntryURL";
const WCHAR c_szXML_IconPath   [] = L"VendorIcon";
const WCHAR c_szXML_PublicKey  [] = L"PublicKey";

/*
    <?xml version="1.0" encoding="utf-8" ?>
    <SAFConfig>
        <ProductID>Word</ProductID>
        <ProductName>Microsoft Word</ProductName>
        <ProductDescription>Word Processor</ProductDescription>
        <EntryURL>http://www.microsoft.com/office/word</EntryURL>
        <VendorIcon>http://steveshi-2/helpportal/images/go_to_4.gif</VendorIcon>
    </SAFConfig>
*/

/////////////////////////////////////////////////////////////////////////////

CFG_BEGIN_FIELDS_MAP(CSAFReg::Inner_UI)
    CFG_ATTRIBUTE( L"SKU"     	 , wstring, m_ths.m_strSKU    ),
    CFG_ATTRIBUTE( L"LANGUAGE"	 , long   , m_ths.m_lLCID     ),

    CFG_ATTRIBUTE( L"VENDORNAME" , BSTR   , m_bstrVendorName  ),
    CFG_ATTRIBUTE( L"PRODUCTNAME", BSTR   , m_bstrProductName ),
    CFG_ATTRIBUTE( L"ICON"    	 , BSTR   , m_bstrIcon        ),
    CFG_ATTRIBUTE( L"URL"     	 , BSTR   , m_bstrURL         ),
    CFG_VALUE    (            	   BSTR   , m_bstrDescription ),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(CSAFReg::Inner_UI)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(CSAFReg::Inner_UI,L"UI")

DEFINE_CONFIG_METHODS__NOCHILD(CSAFReg::Inner_UI)

////////////////////

CFG_BEGIN_FIELDS_MAP(CSAFReg::Inner_Product)
    CFG_ATTRIBUTE( L"ID"          , BSTR, m_bstrProductID    ),

    CFG_ATTRIBUTE( L"SECURITY"    , BSTR, m_bstrSecurity     ),
    CFG_ATTRIBUTE( L"NOTIFICATION", BSTR, m_bstrNotification ),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(CSAFReg::Inner_Product)
    CFG_CHILD(CSAFReg::Inner_UI)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(CSAFReg::Inner_Product,L"PRODUCT")

DEFINE_CONFIG_METHODS_CREATEINSTANCE_SECTION(CSAFReg::Inner_Product,tag,defSubType)
    if(tag == _cfg_table_tags[0])
    {
        defSubType = &(*(m_lstUI.insert( m_lstUI.end() )));
        return S_OK;
    }
DEFINE_CONFIG_METHODS_SAVENODE_SECTION(CSAFReg::Inner_Product,xdn)
    hr = MPC::Config::SaveList( m_lstUI, xdn );
DEFINE_CONFIG_METHODS_END(CSAFReg::Inner_Product)

////////////////////

CFG_BEGIN_FIELDS_MAP(CSAFReg::Inner_Vendor)
    CFG_ATTRIBUTE( L"ID"         , BSTR, m_bstrVendorID    ),

    CFG_ATTRIBUTE( L"PUBLICKEY"  , BSTR, m_bstrPublicKey   ),
    CFG_ATTRIBUTE( L"USERACCOUNT", BSTR, m_bstrUserAccount ),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(CSAFReg::Inner_Vendor)
    CFG_CHILD(CSAFReg::Inner_Product)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(CSAFReg::Inner_Vendor,L"VENDOR")


DEFINE_CONFIG_METHODS_CREATEINSTANCE_SECTION(CSAFReg::Inner_Vendor,tag,defSubType)
    if(tag == _cfg_table_tags[0])
    {
        defSubType = &(*(m_lstProducts.insert( m_lstProducts.end() )));
        return S_OK;
    }
DEFINE_CONFIG_METHODS_SAVENODE_SECTION(CSAFReg::Inner_Vendor,xdn)
    hr = MPC::Config::SaveList( m_lstProducts, xdn );
DEFINE_CONFIG_METHODS_END(CSAFReg::Inner_Vendor)

////////////////////

CFG_BEGIN_FIELDS_MAP(CSAFReg)
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(CSAFReg)
    CFG_CHILD(CSAFReg::Inner_Vendor)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(CSAFReg,L"SAFREG")


DEFINE_CONFIG_METHODS_CREATEINSTANCE_SECTION(CSAFReg,tag,defSubType)
    if(tag == _cfg_table_tags[0])
    {
        defSubType = &(*(m_lstVendors.insert( m_lstVendors.end() )));
        return S_OK;
    }
DEFINE_CONFIG_METHODS_SAVENODE_SECTION(CSAFReg,xdn)
    hr = MPC::Config::SaveList( m_lstVendors, xdn );
DEFINE_CONFIG_METHODS_END(CSAFReg)

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

CSAFRegDummy::CSAFRegDummy()
{
                                       // ChannelsList m_lstChannels;
    m_itCurrent = m_lstChannels.end(); // ChannelsIter m_itCurrent;
}

HRESULT CSAFRegDummy::Append( /*[in]*/ const CSAFChannelRecord& cr )
{
    m_lstChannels.push_back( cr );
    m_itCurrent = m_lstChannels.begin();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CSAFRegDummy::ReturnField( /*[in]*/  CSAFChannelRecord::SAFREG_Field  field ,
                                   /*[out]*/ BSTR                            *pVal  )
{
    __HCP_BEGIN_PROPERTY_PUT("CSAFRegDummy::ReturnField",hr);

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


    if(m_itCurrent != m_lstChannels.end())
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_itCurrent->GetField( field, pVal ));
    }

    __HCP_END_PROPERTY(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CSAFRegDummy::MoveFirst()
{
    __HCP_FUNC_ENTRY( "CSAFRegDummy::MoveFirst" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


    m_itCurrent = m_lstChannels.begin();

    hr = S_OK;


    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CSAFRegDummy::MoveNext()
{
    __HCP_FUNC_ENTRY( "CSAFRegDummy::MoveNext" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


    if(m_itCurrent != m_lstChannels.end()) m_itCurrent++;

    hr = S_OK;


    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CSAFRegDummy::get_EOF( VARIANT_BOOL *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CSAFRegDummy::get_EOF",hr,pVal,VARIANT_TRUE);

    *pVal = (m_itCurrent != m_lstChannels.end()) ? VARIANT_FALSE : VARIANT_TRUE;

    __HCP_END_PROPERTY(hr);
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CSAFRegDummy::get_VendorID          ( BSTR *pVal ) { return ReturnField( CSAFChannelRecord::SAFREG_VendorID          , pVal ); }
STDMETHODIMP CSAFRegDummy::get_ProductID         ( BSTR *pVal ) { return ReturnField( CSAFChannelRecord::SAFREG_ProductID         , pVal ); }

STDMETHODIMP CSAFRegDummy::get_VendorName        ( BSTR *pVal ) { return ReturnField( CSAFChannelRecord::SAFREG_VendorName        , pVal ); }
STDMETHODIMP CSAFRegDummy::get_ProductName       ( BSTR *pVal ) { return ReturnField( CSAFChannelRecord::SAFREG_ProductName       , pVal ); }
STDMETHODIMP CSAFRegDummy::get_ProductDescription( BSTR *pVal ) { return ReturnField( CSAFChannelRecord::SAFREG_ProductDescription, pVal ); }

STDMETHODIMP CSAFRegDummy::get_VendorIcon        ( BSTR *pVal ) { return ReturnField( CSAFChannelRecord::SAFREG_VendorIcon        , pVal ); }
STDMETHODIMP CSAFRegDummy::get_SupportUrl        ( BSTR *pVal ) { return ReturnField( CSAFChannelRecord::SAFREG_SupportUrl        , pVal ); }

STDMETHODIMP CSAFRegDummy::get_PublicKey         ( BSTR *pVal ) { return ReturnField( CSAFChannelRecord::SAFREG_PublicKey         , pVal ); }
STDMETHODIMP CSAFRegDummy::get_UserAccount       ( BSTR *pVal ) { return ReturnField( CSAFChannelRecord::SAFREG_UserAccount       , pVal ); }

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

CSAFReg::CSAFReg()
{
    m_szSAFStore = c_SAFStore; MPC::SubstituteEnvVariables( m_szSAFStore ); // MPC::wstring m_szSAFStore;
                                                                            // VendorList   m_lstVendors;
    m_fLoaded    = false;                                                   // bool         m_fLoaded;
    m_fDirty     = false;                                                   // bool         m_fDirty;
}

////////////////////

CSAFReg* CSAFReg::s_GLOBAL( NULL );

HRESULT CSAFReg::InitializeSystem()
{
    if(s_GLOBAL) return S_OK;

	CSAFReg::s_GLOBAL = new CSAFReg;

    return CSAFReg::s_GLOBAL ? S_OK : E_OUTOFMEMORY;
}

void CSAFReg::FinalizeSystem()
{
    if(s_GLOBAL)
    {
        delete s_GLOBAL; s_GLOBAL = NULL;
    }
}

////////////////////

HRESULT CSAFReg::EnsureInSync()
{
    __HCP_FUNC_ENTRY( "CSAFReg::EnsureInSync" );

    HRESULT hr;


    if(m_fLoaded == false)
    {
        m_lstVendors.clear();

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::Config::LoadFile( this, m_szSAFStore.c_str() ));

        m_fLoaded = true;
        m_fDirty  = false;
    }

    if(m_fDirty)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::Config::SaveFile( this, m_szSAFStore.c_str() ));

        m_fDirty = true;
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CSAFReg::ParseFileField( /*[in]*/  MPC::XmlUtil& xml      ,
                                 /*[in]*/  LPCWSTR       szTag    ,
                                 /*[in]*/  CComBSTR&     bstrDest )
{
    __HCP_FUNC_ENTRY( "CSAFReg::ParseFileField" );

    HRESULT     hr;
    CComVariant vValue;
    bool        fFound;


    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetValue( szTag, vValue, fFound ));
    if(fFound)
    {
        if(SUCCEEDED(vValue.ChangeType( VT_BSTR )))
        {
            bstrDest = vValue.bstrVal;
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CSAFReg::ParseFile( /*[in    ]*/ MPC::XmlUtil&      xml ,
                            /*[in/out]*/ CSAFChannelRecord& cr  )
{
    __HCP_FUNC_ENTRY( "CSAFReg::ParseFile" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, ParseFileField( xml, c_szXML_ProductID  , cr.m_bstrProductID   ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, ParseFileField( xml, c_szXML_ProductName, cr.m_bstrProductName ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, ParseFileField( xml, c_szXML_Description, cr.m_bstrDescription ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, ParseFileField( xml, c_szXML_EntryURL   , cr.m_bstrURL         ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, ParseFileField( xml, c_szXML_IconPath   , cr.m_bstrIcon        ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, ParseFileField( xml, c_szXML_PublicKey  , cr.m_bstrPublicKey   ));

    //
    // Backward compatibility, when ProductName was not available.
    //
    if(cr.m_bstrProductName.Length() == 0) cr.m_bstrProductName = cr.m_bstrProductID;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CSAFReg::MoveToChannel( /*[in ]*/ const       CSAFChannelRecord& cr ,
                                /*[in ]*/ bool        fCreate               ,
                                /*[out]*/ bool&       fFound                ,
                                /*[out]*/ VendorIter& itVendor              ,
                                /*[out]*/ ProdIter*   pitProduct            ,
                                /*[out]*/ UIIter*     pitUI                 )
{
    __HCP_FUNC_ENTRY( "CSAFReg::MoveToChannel" );

    HRESULT hr;


    fFound = false;

    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());

    for(itVendor = m_lstVendors.begin(); itVendor != m_lstVendors.end(); itVendor++)
    {
        if(!MPC::StrICmp( itVendor->m_bstrVendorID, cr.m_bstrVendorID )) break;
    }
    if(itVendor == m_lstVendors.end())
    {
        if(!fCreate)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }

        itVendor = m_lstVendors.insert( m_lstVendors.end() ); m_fDirty = true;

        itVendor->m_bstrVendorID = cr.m_bstrVendorID;
    }

    if(pitProduct)
    {
        Inner_Vendor& v = *itVendor;
        ProdIter      itProduct;

        for(itProduct = v.m_lstProducts.begin(); itProduct != v.m_lstProducts.end(); itProduct++)
        {
            if(!MPC::StrICmp( itProduct->m_bstrProductID, cr.m_bstrProductID )) break;
        }
        if(itProduct == v.m_lstProducts.end())
        {
            if(!fCreate)
            {
                __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
            }

            itProduct = v.m_lstProducts.insert( v.m_lstProducts.end() ); m_fDirty = true;

            itProduct->m_bstrProductID = cr.m_bstrProductID;
        }
        *pitProduct = itProduct;

        if(pitUI)
        {
            Inner_Product& p = *itProduct;
            UIIter         itUI;

            for(itUI = p.m_lstUI.begin(); itUI != p.m_lstUI.end(); itUI++)
            {
                if(itUI->m_ths == cr.m_ths) break;
            }
            if(itUI == p.m_lstUI.end())
            {
                if(!fCreate)
                {
                    __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
                }

                itUI = p.m_lstUI.insert( p.m_lstUI.end() ); m_fDirty = true;

                itUI->m_ths = cr.m_ths;
            }
            *pitUI = itUI;
        }
    }

    fFound = true;

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void CSAFReg::PopulateRecord( /*[in]*/ CSAFChannelRecord& cr        ,
							  /*[in]*/ VendorIter         itVendor  ,
							  /*[in]*/ ProdIter           itProduct ,
							  /*[in]*/ UIIter             itUI      )
{
    cr.m_ths.m_strSKU     = itUI     ->m_ths.m_strSKU    ; // SAFREG_SKU
    cr.m_ths.m_lLCID      = itUI     ->m_ths.m_lLCID     ; // SAFREG_Language
                                                           //
    cr.m_bstrVendorID     = itVendor ->m_bstrVendorID    ; // SAFREG_VendorID
    cr.m_bstrProductID    = itProduct->m_bstrProductID   ; // SAFREG_ProductID
                                                           //
    cr.m_bstrVendorName   = itUI     ->m_bstrVendorName  ; // SAFREG_VendorName
    cr.m_bstrProductName  = itUI     ->m_bstrProductName ; // SAFREG_ProductName
    cr.m_bstrDescription  = itUI     ->m_bstrDescription ; // SAFREG_ProductDescription
                                                           //
    cr.m_bstrIcon         = itUI     ->m_bstrIcon        ; // SAFREG_VendorIcon
    cr.m_bstrURL          = itUI     ->m_bstrURL         ; // SAFREG_SupportUrl
                                                           //
    cr.m_bstrPublicKey    = itVendor ->m_bstrPublicKey   ; // SAFREG_PublicKey
    cr.m_bstrUserAccount  = itVendor ->m_bstrUserAccount ; // SAFREG_UserAccount
                                                           //
    cr.m_bstrSecurity     = itProduct->m_bstrSecurity    ; // SAFREG_Security
    cr.m_bstrNotification = itProduct->m_bstrNotification; // SAFREG_Notification
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CSAFReg::RegisterSupportChannel( /*[in]*/ const CSAFChannelRecord& cr  ,
                                         /*[in]*/ MPC::XmlUtil&            xml )
{
    __HCP_BEGIN_PROPERTY_PUT("CSAFReg::RegisterSupportChannel",hr);

    CSAFChannelRecord cr2 = cr;
    bool       		  fFound;
    VendorIter 		  itVendor;
    ProdIter   		  itProduct;
    UIIter     		  itUI;


    __MPC_EXIT_IF_METHOD_FAILS(hr, ParseFile( xml, cr2 ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MoveToChannel( cr2, /*fCreate*/true, fFound, itVendor, &itProduct, &itUI ));
    if(!fFound)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
    }


	//
	// Update fields.
	//
    itUI    ->m_bstrVendorName  = cr2.m_bstrVendorName ;
    itUI    ->m_bstrProductName = cr2.m_bstrProductName;
    itUI    ->m_bstrDescription = cr2.m_bstrDescription;
													   
    itUI    ->m_bstrIcon        = cr2.m_bstrIcon       ;
    itUI    ->m_bstrURL         = cr2.m_bstrURL        ;
													   
    itVendor->m_bstrPublicKey   = cr2.m_bstrPublicKey  ;


    //
    // Always create a user account associated with the vendor.
    //
    if(itVendor->m_bstrUserAccount.Length() == 0)
    {
        GUID         guidPassword;
        MPC::wstring szComment;
        DWORD        dwCRC;


        __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateGuid( &guidPassword )); // This generates a random password.

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::LocalizeString( IDS_HELPSVC_USERCOMMENT, szComment ));


        //
        // The user account is created using this template:
        //
        //  SUPPORT_<CRC1>
        //
        // where <CRC1> is an 8 digit hash of the whole vendor id.
        //
        //
		{
			BSTR bstr = itVendor->m_bstrVendorID;

			MPC::InitCRC   ( dwCRC                                           );
			MPC::ComputeCRC( dwCRC, (UCHAR*)bstr, ::SysStringByteLen( bstr ) );
		}

        //
        // The CRC method doesn't guarantee the user account is unique, so you have to try creating
        // the user and if it fails, move to a different one. Anyway, it's highly unlikely
        //
        {
            WCHAR        rgUserName[64]; swprintf( rgUserName, L"SUPPORT_%08x", (int)dwCRC );
			CComBSTR     bstrPWD( guidPassword );
            CPCHAccounts acc;


			for(int pass=0; pass<2; pass++)
			{
				hr = acc.CreateUser( rgUserName, bstrPWD, itVendor->m_bstrVendorID, szComment.c_str() );
				if(SUCCEEDED(hr)) break;

                if(hr != HRESULT_FROM_WIN32(NERR_UserExists)) __MPC_SET_ERROR_AND_EXIT(hr, hr);

				__MPC_EXIT_IF_METHOD_FAILS(hr, acc.DeleteUser( rgUserName ));
            }

            itVendor->m_bstrUserAccount = rgUserName;

            //
            // The account is created disabled.
            //
			__MPC_EXIT_IF_METHOD_FAILS(hr, acc.ChangeUserStatus( rgUserName, /*fEnable*/false ));
        }
    }

    m_fDirty = true;
    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());


    __HCP_END_PROPERTY(hr);
}

HRESULT CSAFReg::RemoveSupportChannel( /*[in]*/ const CSAFChannelRecord& cr  ,
									   /*[in]*/ MPC::XmlUtil&            xml )
{
    __HCP_BEGIN_PROPERTY_PUT("CSAFReg::RemoveSupportChannel",hr);

    CSAFChannelRecord cr2 = cr;
    bool       		  fFound;
    VendorIter 		  itVendor;
    ProdIter   		  itProduct;
    UIIter     		  itUI;


    __MPC_EXIT_IF_METHOD_FAILS(hr, ParseFile( xml, cr2 ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MoveToChannel( cr2, /*fCreate*/false, fFound, itVendor, &itProduct, &itUI ));
    if(fFound)
    {
        itProduct->m_lstUI.erase( itUI );
		if(itProduct->m_lstUI.size() == 0)
		{
			itVendor->m_lstProducts.erase( itProduct );
			if(itVendor->m_lstProducts.size() == 0)
			{
				if(itVendor->m_bstrUserAccount.Length())
				{
					//
					// Delete the user account associated with the vendor.
					//
					CPCHAccounts               acc;
					CPCHUserProcess::UserEntry ue;

					__MPC_EXIT_IF_METHOD_FAILS(hr, ue.InitializeForVendorAccount( itVendor->m_bstrUserAccount,
																				  itVendor->m_bstrVendorID   ,
																				  itVendor->m_bstrPublicKey  ));

					(void)CPCHUserProcess::s_GLOBAL->Remove    ( ue                          );
					(void)acc                       .DeleteUser( itVendor->m_bstrUserAccount );
				}

				m_lstVendors.erase( itVendor );
			}
		}

		m_fDirty = true;
		__MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());
    }


    __HCP_END_PROPERTY(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CSAFReg::CreateReadOnlyCopy( /*[in ]*/ const Taxonomy::HelpSet&  ths  ,
									 /*[out]*/ CSAFRegDummy*            *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CSAFReg::CreateReadOnlyCopy",hr,pVal);

    MPC::AccessCheck      ac;
    CComPtr<CSAFRegDummy> obj;
	CSAFChannelRecord     cr;
    VendorIter            itVendor;
    ProdIter              itProduct;
    UIIter                itUI;


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &obj ));

    //
    // Walk through all the products, only copy those passing the read/write access check.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, ac.GetTokenFromImpersonation());


    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());

    for(itVendor = m_lstVendors.begin(); itVendor != m_lstVendors.end(); itVendor++)
    {
        Inner_Vendor& v = *itVendor;

        for(itProduct = v.m_lstProducts.begin(); itProduct != v.m_lstProducts.end(); itProduct++)
        {
            Inner_Product& p = *itProduct;

            for(itUI = p.m_lstUI.begin(); itUI != p.m_lstUI.end(); itUI++)
            {
				if(itUI->m_ths == ths)
				{
					bool fAdd = false;

					if(itProduct->m_bstrSecurity.Length() == 0)
					{
						fAdd = true;
					}
					else
					{
						BOOL  fGranted;
						DWORD dwGranted;
						
						if(SUCCEEDED(ac.Verify( ACCESS_READ, fGranted, dwGranted, itProduct->m_bstrSecurity )) && fGranted)
						{
							fAdd = true;
						}
					}

					if(fAdd)
					{
						PopulateRecord( cr, itVendor, itProduct, itUI );

						__MPC_EXIT_IF_METHOD_FAILS(hr, obj->Append( cr ));
					}
				}
			}
		}
    }

    *pVal = obj.Detach();


    __HCP_END_PROPERTY(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CSAFReg::LookupAccountData( /*[in ]*/ BSTR                        bstrVendorID ,
                                    /*[out]*/ CPCHUserProcess::UserEntry& ue           )
{
    __HCP_BEGIN_PROPERTY_PUT("CSAFReg::LookupAccountData",hr);

    CSAFChannelRecord cr;
    bool              fFound;
    VendorIter        itVendor;


    //
    // Look just for Vendor.
    //
    cr.m_bstrVendorID = bstrVendorID;
    __MPC_EXIT_IF_METHOD_FAILS(hr, MoveToChannel( cr, /*fCreate*/false, fFound, itVendor ));
    if(!fFound)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, ue.InitializeForVendorAccount( itVendor->m_bstrUserAccount, itVendor->m_bstrVendorID, itVendor->m_bstrPublicKey ));


    __HCP_END_PROPERTY(hr);
}

HRESULT CSAFReg::UpdateField( /*[in]*/ const CSAFChannelRecord&        cr    ,
							  /*[in]*/ CSAFChannelRecord::SAFREG_Field field )
{
    __HCP_BEGIN_PROPERTY_PUT("CSAFReg::UpdateField",hr);

    bool       fFound;
    VendorIter itVendor;
    ProdIter   itProduct;
    UIIter     itUI;


    __MPC_EXIT_IF_METHOD_FAILS(hr, MoveToChannel( cr, /*fCreate*/false, fFound, itVendor, &itProduct, &itUI ));
    if(!fFound)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
    }


    switch(field)
    {
    case CSAFChannelRecord::SAFREG_SKU               : itUI     ->m_ths.m_strSKU     = cr.m_ths.m_strSKU    ; break;
    case CSAFChannelRecord::SAFREG_Language          : itUI     ->m_ths.m_lLCID      = cr.m_ths.m_lLCID     ; break;

    case CSAFChannelRecord::SAFREG_VendorID          : itVendor ->m_bstrVendorID     = cr.m_bstrVendorID    ; break;
    case CSAFChannelRecord::SAFREG_ProductID         : itProduct->m_bstrProductID    = cr.m_bstrProductID   ; break;

    case CSAFChannelRecord::SAFREG_VendorName        : itUI     ->m_bstrVendorName   = cr.m_bstrVendorName  ; break;
    case CSAFChannelRecord::SAFREG_ProductName       : itUI     ->m_bstrProductName  = cr.m_bstrProductName ; break;
    case CSAFChannelRecord::SAFREG_ProductDescription: itUI     ->m_bstrDescription  = cr.m_bstrDescription ; break;

    case CSAFChannelRecord::SAFREG_VendorIcon        : itUI     ->m_bstrIcon         = cr.m_bstrIcon        ; break;
    case CSAFChannelRecord::SAFREG_SupportUrl        : itUI     ->m_bstrURL          = cr.m_bstrURL         ; break;

    case CSAFChannelRecord::SAFREG_PublicKey         : itVendor ->m_bstrPublicKey    = cr.m_bstrPublicKey   ; break;
    case CSAFChannelRecord::SAFREG_UserAccount       : itVendor ->m_bstrUserAccount  = cr.m_bstrUserAccount ; break;

    case CSAFChannelRecord::SAFREG_Security          : itProduct->m_bstrSecurity     = cr.m_bstrSecurity    ; break;
    case CSAFChannelRecord::SAFREG_Notification      : itProduct->m_bstrNotification = cr.m_bstrNotification; break;

    default: __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }

    m_fDirty = true;
    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());


    __HCP_END_PROPERTY(hr);
}

HRESULT CSAFReg::Synchronize( /*[in/out]*/ CSAFChannelRecord& cr     ,
							  /*[out   ]*/ bool&              fFound )
{
    __HCP_BEGIN_PROPERTY_PUT("CSAFReg::Synchronize",hr);

    VendorIter itVendor;
    ProdIter   itProduct;
    UIIter     itUI;


    __MPC_EXIT_IF_METHOD_FAILS(hr, MoveToChannel( cr, /*fCreate*/false, fFound, itVendor, &itProduct, &itUI ));
    if(fFound)
    {
		PopulateRecord( cr, itVendor, itProduct, itUI );
    }


    __HCP_END_PROPERTY(hr);
}

HRESULT CSAFReg::RemoveSKU( /*[in]*/ const Taxonomy::HelpSet& ths )
{
    __HCP_BEGIN_PROPERTY_PUT("CSAFReg::RemoveSKU",hr);

    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());

    for(VendorIter itVendor = m_lstVendors.begin(); itVendor != m_lstVendors.end(); itVendor++)
    {
		Inner_Vendor& v = *itVendor;

        for(ProdIter itProduct = v.m_lstProducts.begin(); itProduct != v.m_lstProducts.end(); itProduct++)
        {
			Inner_Product& p = *itProduct;

            for(UIIter itUI = p.m_lstUI.begin(); itUI != p.m_lstUI.end(); itUI++)
            {
                if(itUI->m_ths == ths)
				{
					p.m_lstUI.erase( itUI );
					break;
				}
			}
		}
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());

    __HCP_END_PROPERTY(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\channels\test\saftest.cpp ===
#include "stdafx.h"
#include <stdio.h>
#include <objbase.h>
#include "wchar.h"

#include "HelpServiceTypeLib.h"
#include "HelpServiceTypeLib_i.c"

#include "register.h"

CComModule _Module;

/**************************************************
    usage: saftest.exe -[A|D] config-file-name
****************************************************/
int __cdecl wmain(int argc, WCHAR* argv[])
{
    HRESULT hr;
    if (argc <2 || argv[1][1] == L'A' && argc < 3 || argv[1][1] != L'A' && argc < 2)
    {
        wprintf(L"\nUsage: -[A config-file-name|R [config-file-name]|C http-test-string]\n\n");
        return 0;
    }

    if (argv[1][1] == L'A')
    {
        wprintf(L"\n... Add support channel config file: %s...\n\n", argv[2]);
        hr = RegisterSupportChannel(
            L"VendorID:12345",
            L"Vendor Test Company",
            argv[2]);
    }
    else if (argv[1][1] == L'R')
    {
        wprintf(L"\n... Delete support config file: %s...\n\n", argv[2]);
        hr = RemoveSupportChannel(
            L"VendorID:12345",
            L"Vendor Test Company",
            argv[2]);
    }
/*
    else if (argv[1][1] == L'C')
    {
        wprintf(L"\n... Check if %s is a legal support channel...\n\n", argv[2]);
        BOOL bRes = FALSE;
        GetSupportChannelMap();
        bRes = IsSupportChannel(argv[2]);
        wprintf(L"%s, it %s a support channel.\n\n", 
                    bRes ? L"Yes" : L"No", 
                    bRes ? L"is" :  L"is not");

        CloseSupportChannelMap();
    }
*/
    if (FAILED(hr))
        printf("Test Failed\n");
    else
        printf("Test Succeed\n");

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\channels\test\notifyincident\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by NotifyIncident.rc
//
#define IDS_PROJNAME                    100
#define IDR_SAFCHANNELNOTIFYINCIDENT    101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\channels\test\notifyincident\safchannelnotifyincident.cpp ===
// SAFChannelNotifyIncident.cpp : Implementation of CSAFChannelNotifyIncident
#include "stdafx.h"
#include "NotifyIncident.h"
#include "SAFChannelNotifyIncident.h"

/////////////////////////////////////////////////////////////////////////////
// CSAFChannelNotifyIncident


STDMETHODIMP CSAFChannelNotifyIncident::onIncidentAdded(ISAFChannel *ch, ISAFIncidentItem *inc, long n)
{
	MessageBox(NULL, "onIncidentAdded", "onIncidentAdded", MB_OK);

	return S_OK;
}

STDMETHODIMP CSAFChannelNotifyIncident::onIncidentRemoved(ISAFChannel *ch, ISAFIncidentItem *inc, long n)
{
	MessageBox(NULL, "onIncidentRemoved", "onIncidentRemoved", MB_OK);

	return S_OK;
}

STDMETHODIMP CSAFChannelNotifyIncident::onIncidentUpdated(ISAFChannel *ch, ISAFIncidentItem *inc, long n)
{
	MessageBox(NULL, "onIncidentUpdated", "onIncidentUpdated", MB_OK);

	return S_OK;
}

STDMETHODIMP CSAFChannelNotifyIncident::onChannelUpdated(ISAFChannel *ch, long dwCode, long n)
{
	MessageBox(NULL, "onChannelUpdated", "onChannelUpdated", MB_OK);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\channels\test\notifyincident\notifyincident.cpp ===
// NotifyIncident.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f NotifyIncidentps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "NotifyIncident.h"

#include "NotifyIncident_i.c"
#include "SAFChannelNotifyIncident.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SAFChannelNotifyIncident, CSAFChannelNotifyIncident)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_NOTIFYINCIDENTLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\channels\test\notifyincident\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A11C58CE_2EB4_42F8_8A60_4126B639341D__INCLUDED_)
#define AFX_STDAFX_H__A11C58CE_2EB4_42F8_8A60_4126B639341D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A11C58CE_2EB4_42F8_8A60_4126B639341D__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\channels\test\notifyincident\safchannelnotifyincident.h ===
// SAFChannelNotifyIncident.h : Declaration of the CSAFChannelNotifyIncident

#ifndef __SAFCHANNELNOTIFYINCIDENT_H_
#define __SAFCHANNELNOTIFYINCIDENT_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CSAFChannelNotifyIncident
class ATL_NO_VTABLE CSAFChannelNotifyIncident : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSAFChannelNotifyIncident, &CLSID_SAFChannelNotifyIncident>,
	public IDispatchImpl<ISAFChannelNotifyIncident, &IID_ISAFChannelNotifyIncident, &LIBID_NOTIFYINCIDENTLib>
{
public:
	CSAFChannelNotifyIncident()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_SAFCHANNELNOTIFYINCIDENT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSAFChannelNotifyIncident)
	COM_INTERFACE_ENTRY(ISAFChannelNotifyIncident)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ISAFChannelNotifyIncident
public:
	STDMETHOD(onChannelUpdated)(ISAFChannel * ch, long dwCode, long n);
	STDMETHOD(onIncidentUpdated)(ISAFChannel * ch, ISAFIncidentItem * inc, long n);
	STDMETHOD(onIncidentRemoved)(ISAFChannel * ch, ISAFIncidentItem * inc, long n);
	STDMETHOD(onIncidentAdded)(ISAFChannel * ch, ISAFIncidentItem * inc, long n);
};

#endif //__SAFCHANNELNOTIFYINCIDENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\contentstore\lib\stdafx.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    stdafx.h

Abstract:
    include file for standard system include files,
    or project specific include files that are used frequently,
    but are changed infrequently


Revision History:
    Davide Massarenti   (Dmassare)  03/20/2000
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__0DAA8F96_0286_11D3_9397_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__0DAA8F96_0286_11D3_9397_00C04F72DAF7__INCLUDED_

#include <module.h>

#include <HCP_trace.h>

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__0DAA8F96_0286_11D3_9397_00C04F72DAF7__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\contentstore\unittest\csmutest.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    csmutest.cpp

Abstract:
    Content Store manager unit test

Revision History:
    DerekM  created  07/14/99

********************************************************************/

#include <atlbase.h>

extern CComModule _Module;

#include <mbstring.h>

#include <ContentStoreMgr.h>

#include <stdio.h>

// **************************************************************************
inline LPVOID MyAlloc(DWORD cb)
{ 
    return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cb); 
}

// **************************************************************************
inline LPVOID MyReAlloc(LPVOID pv, DWORD cb)
{ 
    return HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, pv, cb); 
}
    
// **************************************************************************
inline BOOL MyFree(LPVOID pv)
{ 
    return HeapFree(GetProcessHeap(), 0, pv); 
}




// **************************************************************************
void ShowUsage(void)
{
    printf("Usage:\n");
    printf("wcsutest <command> <command parameters>\n");
    printf("\n\nCommands:\n");
    printf("  ADD: adds URLs to the store\n");
    printf("  Usage:\n");
    printf("    wcsutest ADD <Vendor ID> <Vendor Name> <URL>\n");
    printf("\n  REMOVE: removes URLs from the store\n");
    printf("  Usage:\n");
    printf("    wcsutest REMOVE <Vendor ID> <Vendor Name> [URL]\n");
    printf("    Note that 'URL' is optional.  If it is not present, all URLs for the specified\n");
    printf("     for the specified vendor will be deleted.\n");
    printf("\n  ADDFILE: adds URLs listed in the specified file to the store\n");
    printf("  Usage:\n");
    printf("    wcsutest ADD <Vendor ID> <Vendor Name> <URL File>\n");
    printf("\n  REMOVEFILE: removes URLs listed in the specfied file from the store\n");
    printf("  Usage:\n");
    printf("    wcsutest REMOVE <Vendor ID> <Vendor Name> [URL File]\n");
    printf("    Note that 'URL File' is optional.  If it is not present, all URLs for the specified\n");
    printf("     for the specified vendor will be deleted.\n");
    printf("\n  CHECKTRUST: checks if a URL is in the store\n");
    printf("  Usage:\n");
    printf("    wcsutest CHECKTRUST <URL>\n");
    printf("\n");
}

// **************************************************************************

int __cdecl wmain(int argc, WCHAR **argv, WCHAR **envp)
{
    HRESULT 		 hr;
    LPCWSTR   		 wszURL        = L"";
	LPCWSTR   		 wszVendorID   = L"";
	LPCWSTR   		 wszVendorName = L"";
	CPCHContentStore cs( true );


	switch(argc)
	{
	case 5: wszVendorName = argv[4];
	case 4: wszVendorID   = argv[3];
	case 3: wszURL        = argv[2]; break;
		
	default:
        ShowUsage();
        exit( 10 );
	}


	if(SUCCEEDED(hr = cs.Acquire()))
	{
		if(!_wcsicmp( argv[1], L"ADD")) // we're adding URLs
		{
			if(argc != 5)
			{
				ShowUsage();
				exit(10);
			}

			if(FAILED(hr = cs.Add( wszURL, wszVendorID, wszVendorName )))
			{
				wprintf( L"Unable to register URLs: 0x%08x\n", hr );
			}
			else
			{
				wprintf( L"Successfully added URLs\n" );
			}
		}
		else if(!_wcsicmp( argv[1], L"REMOVE" )) // we're deleteing URLs
		{
			if(argc != 5)
			{
				ShowUsage();
				exit(10);
			}

			if(FAILED(hr = cs.Remove( wszURL, wszVendorID, wszVendorName )))
			{
				wprintf( L"Unable to remove URLs: 0x%08x\n", hr );
			}
			else
			{
				wprintf( L"Successfully removed URL:s\n" );
			}
		}
		else if (!_wcsicmp( argv[1], L"CHECKTRUST")) // we're validating a URL
		{
			bool fTrusted;

			if(argc != 3)
			{
				ShowUsage();
				exit(10);
			}

			if(FAILED(hr = cs.IsTrusted( wszURL, fTrusted )))
			{
				wprintf( L"Unable to check if URL is trusted: 0x%08x\n", hr );
			}
			else
			{
				if(fTrusted)
				{
					wprintf( L"%s is trusted!\n", wszURL );
				}
				else
				{
					wprintf( L"%s is NOT trusted!\n", wszURL );
				}
			}
		}
		else // nothing valid
		{
			ShowUsage();
			exit(10);
		}

		if(SUCCEEDED(hr)) cs.Release( true );
    }

    return SUCCEEDED(hr) ? 0 : 5;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\encryptionobject\lib\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__84BD2123_7B5D_483F_9C80_35B974A003C5__INCLUDED_)
#define AFX_STDAFX_H__84BD2123_7B5D_483F_9C80_35B974A003C5__INCLUDED_

#include <module.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#include <MPC_utils.h>
#include <MPC_COM.h>
#include <MPC_streams.h>

#include <SvcUtils.h>

#include "msscript.h"

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

//
// From HelpCenterTypeLib.idl
//
#include <HelpCenterTypeLib.h>



#include <Encrypt.h>

#endif // !defined(AFX_STDAFX_H__84BD2123_7B5D_483F_9C80_35B974A003C5__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\contentstore\lib\contentstore.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    ContentStore.cpp

Abstract:
    This file contains the implementation of the Content Store.

Revision History:
    Davide Massarenti   (Dmassare)  12/14/99
        created

******************************************************************************/

#include "StdAfx.h"

#include <ContentStoreMgr.h>

static const WCHAR s_MutexName1[] = L"Global\\PCH_CONTENTSTORE";
static const WCHAR s_MutexName2[] = L"Global\\PCH_CONTENTSTORE_DATA";

/////////////////////////////////////////////////////////////////////////////

static const DWORD l_dwVersion    = 0x01005343; // 'CS 01'
static const WCHAR l_szDatabase[] = HC_HELPSVC_STORE_TRUSTEDCONTENTS;

/////////////////////////////////////////////////////////////////////////////

bool CPCHContentStore::Entry::operator<( /*[in]*/ const Entry& en ) const
{
    MPC::NocaseLess strLess;

    return strLess( szURL, en.szURL );
}

int CPCHContentStore::Entry::compare( /*[in]*/ LPCWSTR wszSearch ) const
{
    return MPC::StrICmp( szURL, wszSearch );
}

/////////////////////////////////////////////////////////////////////////////

CPCHContentStore::CPCHContentStore( /*[in]*/ bool fMaster ) : MPC::NamedMutexWithState( s_MutexName1, sizeof(SharedState) )
{
    m_dwLastRevision = 0;       //  DWORD                     m_dwLastRevision;
                                //  EntryVec                  m_vecData;
    m_mapData        = NULL;    //  MPC::NamedMutexWithState* m_mapData;
    m_fDirty         = false;   //  bool                      m_fDirty;
    m_fSorted        = false;   //  bool                      m_fSorted;
    m_fMaster        = fMaster; //  bool                      m_fMaster;
}

CPCHContentStore::~CPCHContentStore()
{
    while(IsOwned()) Release();

    Cleanup();
}

////////////////////

CPCHContentStore* CPCHContentStore::s_GLOBAL( NULL );

HRESULT CPCHContentStore::InitializeSystem( /*[in]*/ bool fMaster )
{
	if(s_GLOBAL == NULL)
	{
		s_GLOBAL = new CPCHContentStore( fMaster );
	}

	return s_GLOBAL ? S_OK : E_OUTOFMEMORY;
}

void CPCHContentStore::FinalizeSystem()
{
	if(s_GLOBAL)
	{
		delete s_GLOBAL; s_GLOBAL = NULL;
	}
}

////////////////////

void CPCHContentStore::Sort()
{
    std::sort< EntryIter >( m_vecData.begin(), m_vecData.end() );
}

void CPCHContentStore::Cleanup()
{
	Map_Release();

    m_vecData.clear();

    m_fDirty  = false;
    m_fSorted = false;
}

////////////////////////////////////////////////////////////////////////////////

void CPCHContentStore::Map_Release()
{
	if(m_mapData)
	{
		delete m_mapData;

		m_mapData = NULL;
	}
}

HRESULT CPCHContentStore::Map_Generate()
{
    __HCP_FUNC_ENTRY( "CPCHContentStore::Map_Generate" );

    HRESULT                hr;
	MPC::Serializer_Memory stream;
	DWORD                  dwSize;


	Map_Release();


	//
	// Save the data to a memory stream.
	//
	__MPC_EXIT_IF_METHOD_FAILS(hr, SaveDirect( stream ));


	//
	// Allocate a new shared object large enough to get the serialized data.
	//
	dwSize = stream.GetSize();

	__MPC_EXIT_IF_ALLOC_FAILS(hr, m_mapData, new MPC::NamedMutexWithState( s_MutexName2, dwSize ));


	//
	// Copy the data to the shared object.
	//
	__MPC_EXIT_IF_METHOD_FAILS(hr, m_mapData->Acquire());

	::CopyMemory( m_mapData->GetData(), stream.GetData(), dwSize );

	__MPC_EXIT_IF_METHOD_FAILS(hr, m_mapData->Release());

	//
	// Update the length information on the main mutex.
	//
    State()->dwSize = dwSize;
    State()->dwRevision++;

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT CPCHContentStore::Map_Read()
{
    __HCP_FUNC_ENTRY( "CPCHContentStore::Map_Read" );

    HRESULT                hr;
	MPC::Serializer_Memory stream;
	DWORD                  dwSize = State()->dwSize;


	Map_Release();


	//
	// Allocate a new shared object large enough to get the serialized data.
	//
	__MPC_EXIT_IF_ALLOC_FAILS(hr, m_mapData, new MPC::NamedMutexWithState( s_MutexName2, dwSize ));


	//
	// Copy the data from the shared object.
	//
	__MPC_EXIT_IF_METHOD_FAILS(hr, m_mapData->Acquire());

	__MPC_EXIT_IF_METHOD_FAILS(hr, stream.SetSize(                       dwSize ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, stream.write  ( m_mapData->GetData(), dwSize ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, m_mapData->Release());


	//
	// Load the data from a memory stream.
	//
	__MPC_EXIT_IF_METHOD_FAILS(hr, LoadDirect( stream ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

	(void)Map_Release();

    __MPC_FUNC_EXIT(hr);
}


////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHContentStore::LoadDirect( /*[in]*/ MPC::Serializer& stream )
{
    __HCP_FUNC_ENTRY( "CPCHContentStore::LoadDirect" );

    HRESULT hr;
	DWORD   dwVer;


	m_vecData.clear();


	if(FAILED(stream >> dwVer) || dwVer != l_dwVersion) __MPC_SET_ERROR_AND_EXIT(hr, S_OK);

	while(1)
	{
		EntryIter it = m_vecData.insert( m_vecData.end() ); // This line creates a new entry!!

		if(FAILED(hr = stream >> it->szURL       ) ||
		   FAILED(hr = stream >> it->szOwnerID   ) ||
		   FAILED(hr = stream >> it->szOwnerName )  )
		{
			m_vecData.erase( it );
			break;
		}
	}

	Sort(); // Just to be sure...

    m_dwLastRevision = State()->dwRevision; // Get the shared state.
    m_fDirty         = false;
    hr               = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT CPCHContentStore::SaveDirect( /*[in]*/ MPC::Serializer& stream )
{
    __HCP_FUNC_ENTRY( "CPCHContentStore::SaveDirect" );

    HRESULT hr;


	__MPC_EXIT_IF_METHOD_FAILS(hr, stream << l_dwVersion);

	for(EntryIter it = m_vecData.begin(); it != m_vecData.end(); it++)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, stream << it->szURL      );
		__MPC_EXIT_IF_METHOD_FAILS(hr, stream << it->szOwnerID  );
		__MPC_EXIT_IF_METHOD_FAILS(hr, stream << it->szOwnerName);
	}

    m_dwLastRevision = ++State()->dwRevision; // Touch the shared state.
    m_fDirty         = false;
    hr               = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHContentStore::Load()
{
    __HCP_FUNC_ENTRY( "CPCHContentStore::Load" );

    HRESULT hr;
    HANDLE  hFile = INVALID_HANDLE_VALUE;

	if(m_fMaster)
	{
		MPC::wstring szFile( l_szDatabase ); MPC::SubstituteEnvVariables( szFile );

		//
		// Open file and read it.
		//
		hFile = ::CreateFileW( szFile.c_str(), GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
		if(hFile == INVALID_HANDLE_VALUE)
		{
			DWORD dwRes = ::GetLastError();

            if(dwRes != ERROR_FILE_NOT_FOUND)
            {
                __MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRes);
            }
		}
		else
		{
			MPC::Serializer_File      streamReal( hFile      );
			MPC::Serializer_Buffering streamBuf ( streamReal );

			__MPC_EXIT_IF_METHOD_FAILS(hr, LoadDirect( streamBuf ));
		}

		__MPC_EXIT_IF_METHOD_FAILS(hr, Map_Generate());
	}
	else
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, Map_Read());
	}

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    if(hFile != INVALID_HANDLE_VALUE) ::CloseHandle( hFile );

    __MPC_FUNC_EXIT(hr);
}

HRESULT CPCHContentStore::Save()
{
    __HCP_FUNC_ENTRY( "CPCHContentStore::Save" );

    HRESULT hr;
    HANDLE  hFile = INVALID_HANDLE_VALUE;

	if(m_fMaster)
	{
		MPC::wstring szFile( l_szDatabase ); MPC::SubstituteEnvVariables( szFile );

		//
		// Open file and read it.
		//
		__MPC_EXIT_IF_INVALID_HANDLE(hr, hFile, ::CreateFileW( szFile.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL ));

		{
			MPC::Serializer_File      streamReal( hFile      );
			MPC::Serializer_Buffering streamBuf ( streamReal );

			__MPC_EXIT_IF_METHOD_FAILS(hr, SaveDirect( streamBuf ));

			__MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf.Flush());
		}

		__MPC_EXIT_IF_METHOD_FAILS(hr, Map_Generate());
	}
	else
	{
		;
	}

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    if(hFile != INVALID_HANDLE_VALUE) ::CloseHandle( hFile );

    __MPC_FUNC_EXIT(hr);
}

HRESULT CPCHContentStore::Acquire()
{
    __HCP_FUNC_ENTRY( "CPCHContentStore::Acquire" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, NamedMutexWithState::Acquire());

    if(State()->dwRevision == 0)
    {
        State()->dwRevision++; // Shared state should not be zero...
    }

    if(m_dwLastRevision != State()->dwRevision)
    {
        Cleanup();
        Load   ();
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT CPCHContentStore::Release( /*[in]*/ bool fSave )
{
    __HCP_FUNC_ENTRY( "CPCHContentStore::Release" );

    HRESULT hr;
    HRESULT hr2;


    if(fSave)
    {
        if(m_fDirty)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, Save());
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    hr2 = NamedMutexWithState::Release();

    if(SUCCEEDED(hr)) hr = hr2;

    __MPC_FUNC_EXIT(hr);
}

CPCHContentStore::SharedState* CPCHContentStore::State()
{
    return (SharedState*)GetData();
}

HRESULT CPCHContentStore::Find( /*[in]*/ LPCWSTR wszURL, /*[in]*/ LPCWSTR wszVendorID, /*[out]*/ EntryIter& it )
{
    HRESULT      hr = E_PCH_URI_DOES_NOT_EXIST;
    CompareEntry cmp;


    it = std::lower_bound( m_vecData.begin(), m_vecData.end(), wszURL, cmp );
    if(it != m_vecData.end() && it->compare( wszURL ) == 0)
    {
        if(wszVendorID && MPC::StrICmp( it->szOwnerID, wszVendorID ) != 0)
        {
            hr = E_PCH_PROVIDERID_DO_NOT_MATCH;
        }
        else
        {
            hr = S_OK;
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CPCHContentStore::Add( /*[in]*/ LPCWSTR wszURL, /*[in]*/ LPCWSTR wszVendorID, /*[in]*/ LPCWSTR wszVendorName )
{
    HRESULT   hr;
    EntryIter it;


    hr = Find( wszURL, wszVendorID, it );
    if(SUCCEEDED(hr))
    {
        hr = E_PCH_URI_EXISTS;
    }
    else if(hr == E_PCH_URI_DOES_NOT_EXIST)
    {
        it = m_vecData.insert( m_vecData.end() ); // This line creates a new entry!!

        it->szURL       = wszURL;
        it->szOwnerID   = wszVendorID;
        it->szOwnerName = wszVendorName;
        m_fDirty        = true;
        hr              = S_OK;

        Sort();
    }

    return hr;
}

HRESULT CPCHContentStore::Remove( /*[in]*/ LPCWSTR wszURL, /*[in]*/ LPCWSTR wszVendorID, /*[in]*/ LPCWSTR wszVendorName )
{
    HRESULT   hr;
    EntryIter it;


    hr = Find( wszURL, wszVendorID, it );
    if(SUCCEEDED(hr))
    {
        m_vecData.erase( it );

        m_fDirty = true;
        hr       = S_OK;
    }

    return hr;
}


bool CPCHContentStore::CompareEntry::operator()( /*[in]*/ const CPCHContentStore::Entry& entry, /*[in]*/ const LPCWSTR wszURL ) const
{
    return entry.compare( wszURL ) < 0;
}

HRESULT CPCHContentStore::IsTrusted( /*[in]*/ LPCWSTR wszURL, /*[out]*/ bool& fTrusted, /*[out]*/ MPC::wstring *pszVendorID, /*[in]*/ bool fUseStore )
{
	static const WCHAR s_szURL_System          [] = L"hcp://system/";
	static const WCHAR s_szURL_System_Untrusted[] = L"hcp://system/untrusted/";

    HRESULT      hr = S_OK;
    CompareEntry cmp;


	SANITIZEWSTR( wszURL );
    fTrusted = false;

	if(pszVendorID) pszVendorID->erase();


	if(!_wcsnicmp( wszURL, s_szURL_System_Untrusted, MAXSTRLEN( s_szURL_System_Untrusted ) ))
	{
		fTrusted = false;
	}
    else if(!_wcsnicmp( wszURL, s_szURL_System, MAXSTRLEN( s_szURL_System) ))
	{
		fTrusted = true;
	}
	else if(fUseStore && SUCCEEDED(hr = Acquire()))
    {
        MPC::wstring            szUrlTmp( wszURL );
        MPC::wstring::size_type pos;
        EntryIter               it;

        while(1)
        {
            //
            // Match?
            //
            if(SUCCEEDED(Find( szUrlTmp.c_str(), NULL, it )))
            {
				if(pszVendorID) *pszVendorID = it->szOwnerID.c_str();

                fTrusted = true;
                break;
            }


            //
            // No match, look for final slash.
            //
            if((pos = szUrlTmp.find_last_of( '/' )) == szUrlTmp.npos) break;

            //
            // Truncate the string AFTER the slash.
            //
            // This is to cover the case where "<scheme>://<path>/" is a trusted URL.
            //
            szUrlTmp.resize( pos+1 );

            //
            // Match?
            //
            if(SUCCEEDED(Find( szUrlTmp.c_str(), NULL, it )))
            {
				if(pszVendorID) *pszVendorID = it->szOwnerID.c_str();

                fTrusted = true;
                break;
            }

            //
            // No match with the trailing slash, let's remove it and loop.
            //
            szUrlTmp.resize( pos );
        }

        hr = Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\remotedesktopmanager\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ISAFrdm.rc
//
#define IDS_PROJNAME                    100
#define IDR_SAFREMOTEDESKTOPMANAGER     101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\remotedesktopmanager\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( ISAFrdm )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( ISAFrdm ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\encryptionobject\unittest\eoutest.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    ioutest.cpp

Abstract:
    incident object unit test

Revision History:
    DerekM  created  07/14/99

********************************************************************/

#include <module.h>
 
#include <mpc_utils.h>
#include <mpc_com.h>
#include <MPC_streams.h>

#include <stdio.h>

#include "HelpServiceTypeLib.h"
#include "HelpServiceTypeLib_i.c"

#include "HelpCenterTypeLib.h"
#include "HelpCenterTypeLib_i.c"

// #include "hsi.h"

#include <fci.h>

#include <initguid.h>
#include <msscript.h>

#include <encrypt.h>

#include <SvcUtils.h>


// **************************************************************************
int __cdecl wmain(int argc, WCHAR **argv, WCHAR **envp)
{   

	__MPC_FUNC_ENTRY( COMMONID, "Encryption Testing" );
    
    CComObject<CSAFEncrypt>     *pEO = NULL;
    CComBSTR                    bstrToBeEncrypted;
    CComBSTR                    bstrPassword;
	CComBSTR                    bstrEncryptedString;
	CComBSTR                    bstrDecryptedString;
	IUnknown                    *punkPlainStm;
	IUnknown                    *punkEncryptedStream;
	IUnknown                    *punkDecryptedStream;
	CComPtr<IStream>            streamPlain;         
	CComPtr<IStream>            streamEncrypted;            	  
	CComPtr<IStream>            streamDecrypted; 
	CComPtr<IStream>            streamEncryptedOutput;
	CComPtr<IStream>            streamDecryptedOutput;

	unsigned int                uiLen;

    HRESULT hr = NOERROR;

    hr = CoInitialize(NULL);
    if (FAILED(hr))
        return hr;

    hr = CComObject<CSAFEncrypt>::CreateInstance(&pEO);
    if (FAILED(hr))
        goto done;

	bstrToBeEncrypted          = L"Encrypt this string";
	bstrPassword               = L"Password";

	bstrToBeEncrypted          = L"Will you encrypt this string please?";
	bstrPassword               = L"Pwd";


	// Tests for the String Encryption.

    hr = pEO->EncryptString(bstrPassword, bstrToBeEncrypted, &bstrEncryptedString);
    if (FAILED(hr))
        goto done;

	// Get the length of the encrypted String.
	uiLen = bstrEncryptedString.Length();

	hr = pEO->DecryptString( bstrPassword, bstrEncryptedString, &bstrDecryptedString);
    if (FAILED(hr))
        goto done;

	uiLen = bstrDecryptedString.Length();

	// Tests for the File Encryption

    hr = pEO->EncryptFile(bstrPassword, L"D:\\enc.xml", L"D:\\enc1.xml");
    if (FAILED(hr))
        goto done;

	hr = pEO->DecryptFile(bstrPassword, L"D:\\enc1.xml", L"D:\\enc2.xml");
    if (FAILED(hr))
        goto done;

	// Tests for Stream Encryption
	__MPC_EXIT_IF_METHOD_FAILS(hr, SVC::OpenStreamForRead( L"D:\\test.enc" , &streamPlain ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, pEO->EncryptStream(bstrPassword, streamPlain, &punkEncryptedStream));

	__MPC_EXIT_IF_METHOD_FAILS(hr, punkEncryptedStream->QueryInterface( IID_IStream, (void**)&streamEncrypted ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, SVC::OpenStreamForWrite( L"D:\\test1.enc", &streamEncryptedOutput ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::BaseStream::TransferData( streamEncrypted, streamEncryptedOutput ));


	// Tests for Stream Decryption
	__MPC_EXIT_IF_METHOD_FAILS(hr, SVC::OpenStreamForRead( L"D:\\test2.enc" , &streamEncryptedOutput ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, pEO->DecryptStream(bstrPassword, streamEncryptedOutput, &punkDecryptedStream));
    
    __MPC_EXIT_IF_METHOD_FAILS(hr, punkDecryptedStream->QueryInterface( IID_IStream, (void**)&streamDecrypted ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, SVC::OpenStreamForWrite( L"D:\\test3.enc", &streamDecryptedOutput ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::BaseStream::TransferData( streamDecrypted, streamDecryptedOutput ));

done:

	__MPC_FUNC_CLEANUP;

	if (pEO != NULL)
        pEO->Release();
    CoUninitialize();

	// Free HGlobal

    __MPC_FUNC_EXIT(hr);
   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\remotedesktopmanager\safrdm.cpp ===
// ISAFrdm.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f ISAFrdmps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "SAFrdm.h"

#include "SAFrdm_i.c"
#include "SAFRemoteDesktopManager.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SAFRemoteDesktopManager, CSAFRemoteDesktopManager)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_ISAFRDMLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\encryptionobject\lib\encrypt.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    incident.cpp

Abstract:
    Encryption object

Revision History:
    KalyaninN  created  06/28/'00

********************************************************************/

// SAFEncrypt.cpp : Implementation of CSAFEncrypt

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////
// CSAFEncrypt

#include <HCP_trace.h>

/////////////////////////////////////////////////////////////////////////////
//  construction / destruction

// **************************************************************************
CSAFEncrypt::CSAFEncrypt()
{
    m_EncryptionType = 1;
}

// **************************************************************************
CSAFEncrypt::~CSAFEncrypt()
{
    Cleanup();
}

// **************************************************************************
void CSAFEncrypt::Cleanup(void)
{
    
}

/////////////////////////////////////////////////////////////////////////////
//  CSAFEncrypt properties


STDMETHODIMP CSAFEncrypt::get_EncryptionType(long *pVal)
{
    __HCP_BEGIN_PROPERTY_GET2("CSAFEncrypt::get_EncryptionType",hr,pVal,m_EncryptionType);

    __HCP_END_PROPERTY(hr);

}

STDMETHODIMP CSAFEncrypt::put_EncryptionType(long pVal)
{
    __HCP_BEGIN_PROPERTY_PUT("CSAFEncrypt::put_EncryptionType",hr);

	if(pVal < 0)
	{
        __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }

    m_EncryptionType = pVal;

    __HCP_END_PROPERTY(hr);
}

/////////////////////////////////////////////////////////////////////////////
//  CSAFEncrypt Methods

STDMETHODIMP CSAFEncrypt::EncryptString(BSTR bstrEncryptionKey, BSTR bstrInputString, BSTR *bstrEncryptedString)
{
	__HCP_FUNC_ENTRY( "CSAFEncrypt::EncryptString" );

    HRESULT                       hr;
								  
    CComPtr<IStream>              streamPlain;
    CComPtr<IStream>              streamEnc;
    CComPtr<MPC::EncryptedStream> stream;
    MPC::Serializer_IStream       streamSerializerPlain;
								  
    CComBSTR                      bstrEncString;
    HGLOBAL                       hg;

    STATSTG                       stg; ::ZeroMemory( &stg, sizeof(stg) );
    DWORD                         dwLen;

    // Validate the input and output parameters.

    __MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_POINTER_AND_SET(bstrEncryptedString, NULL);
    __MPC_PARAMCHECK_END();

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamSerializerPlain << CComBSTR(bstrInputString));

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamSerializerPlain.Reset());

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamSerializerPlain.GetStream( &streamPlain ));
		
    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CreateStreamOnHGlobal( NULL, TRUE, &streamEnc));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &stream ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream->Init( streamEnc, bstrEncryptionKey ));

    // Use the STATSTG on the encrypted stream to get the size of the stream.

	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::BaseStream::TransferData( streamPlain, stream));

	//Get HGlobal from EncryptedStream 'stream'.
    __MPC_EXIT_IF_METHOD_FAILS(hr, ::GetHGlobalFromStream( streamEnc, &hg ));

    // Get the size of the encrypted stream.
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamEnc->Stat( &stg, STATFLAG_NONAME ));


    //
    // Sorry, we don't handle streams longer than 4GB!!
    //
    if(stg.cbSize.u.HighPart)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_OUTOFMEMORY);
    }

    dwLen = stg.cbSize.u.LowPart;

    // ConvertHGlobaltoHex to finally get a string.
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertHGlobalToHex( hg, bstrEncString, FALSE, &dwLen ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( bstrEncString, bstrEncryptedString));

    hr = S_OK;

    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

STDMETHODIMP CSAFEncrypt::DecryptString(BSTR bstrEncryptionKey, BSTR bstrInputString, BSTR *bstrDecryptedString)
{
    __HCP_FUNC_ENTRY( "CSAFEncrypt::DecryptString" );

    HRESULT                       hr;

    CComPtr<MPC::EncryptedStream> stream;
    CComPtr<IStream>              streamPlain;
    CComPtr<IStream>              streamEncrypted;
								  
    CComBSTR                      bstrDecryptString;
    HGLOBAL                       hg        =  NULL;
    LARGE_INTEGER                 liFilePos = { 0, 0 };

    __MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_POINTER_AND_SET(bstrDecryptedString, NULL);
    __MPC_PARAMCHECK_END();

    // Convert Hex to HGlobal -  i.e. Copy the encrypted string to global.
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertHexToHGlobal( bstrInputString, hg ));

    // CreateStreamOnHGlobal - i.e. create a  encrypted stream.
    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CreateStreamOnHGlobal( hg, FALSE, &streamEncrypted ));

    // You have the input as stream, now decrypt it .
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &stream ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream->Init( streamEncrypted, bstrEncryptionKey ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CreateStreamOnHGlobal( NULL, TRUE, &streamPlain ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::BaseStream::TransferData( stream, streamPlain ));

    // Rewind the Stream.
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamPlain->Seek( liFilePos, STREAM_SEEK_SET, NULL ));

    // Now the decrypted plain stream is available. Get the string from it.
    {
		// Initialize the serializer with the plain stream.
        MPC::Serializer_IStream streamSerializerPlain( streamPlain );

		__MPC_EXIT_IF_METHOD_FAILS(hr, streamSerializerPlain >> bstrDecryptString);

		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( bstrDecryptString, bstrDecryptedString));
    }

    hr = S_OK;

    __MPC_FUNC_CLEANUP;

    if(hg) ::GlobalFree( hg );

    __MPC_FUNC_EXIT(hr);
}

STDMETHODIMP CSAFEncrypt::EncryptFile(BSTR bstrEncryptionKey, BSTR bstrInputFile,   BSTR bstrEncryptedFile)
{
    __HCP_FUNC_ENTRY( "CSAFEncrypt::EncryptFile" );

    HRESULT                       hr;
    CComPtr<MPC::EncryptedStream> stream;
    CComPtr<IStream>              streamPlain;
    CComPtr<IStream>              streamEncrypted;
								  
    MPC::wstring                  szTempFile;
    MPC::NocaseCompare            cmpStrings;
								  
    bool                          fTempFile = false;

    // Check to see if one of the input files is null. If it is fail!

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrInputFile);
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrEncryptedFile);
    __MPC_PARAMCHECK_END();

    // Check to see if both files are same.

    if(cmpStrings(bstrInputFile, bstrEncryptedFile))
    {
		// Get temp Folder Location.
		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetTemporaryFileName( szTempFile ));

		// Copy the input file contents to the temporary file.
		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CopyFile(bstrInputFile, szTempFile.c_str()));

		// Copy the Temporary File Name over the Input File Name;
		bstrInputFile = (BSTR)szTempFile.c_str();
		fTempFile     = true;
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::OpenStreamForRead( bstrInputFile , &streamPlain ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::OpenStreamForWrite( bstrEncryptedFile, &streamEncrypted ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &stream ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream->Init( streamEncrypted, bstrEncryptionKey ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::BaseStream::TransferData( streamPlain, stream ));

    hr = S_OK;

    __MPC_FUNC_CLEANUP;

    if(fTempFile) ::DeleteFileW( bstrInputFile );
	
    __MPC_FUNC_EXIT(hr);
}


STDMETHODIMP CSAFEncrypt::DecryptFile(BSTR bstrEncryptionKey, BSTR bstrInputFile,  BSTR bstrDecryptedFile  )
{
    __HCP_FUNC_ENTRY( "CSAFEncrypt::DecryptFile" );

    HRESULT                       hr;
    CComPtr<MPC::EncryptedStream> stream;
    CComPtr<IStream>              streamPlain;
    CComPtr<IStream>              streamEncrypted;
								  
    MPC::NocaseCompare            cmpStrings;
    MPC::wstring                  szTempFile;
								  
    bool                          fTempFile = false;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrInputFile);
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrDecryptedFile);
    __MPC_PARAMCHECK_END();

    // Check to see if both files are same.

    if(cmpStrings(bstrInputFile, bstrDecryptedFile))
    {
		// Get temp Folder Location.
		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetTemporaryFileName( szTempFile ));

		// Copy the input file contents to the temporary file.
		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CopyFile(bstrInputFile, szTempFile.c_str()));

		// Copy the Temporary File Name over the Input File Name;
		bstrInputFile = (BSTR)szTempFile.c_str();

		fTempFile = true;
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::OpenStreamForRead( bstrInputFile , &streamEncrypted  ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::OpenStreamForWrite( bstrDecryptedFile, &streamPlain ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &stream ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream->Init( streamEncrypted, bstrEncryptionKey ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::BaseStream::TransferData( stream, streamPlain));

    hr = S_OK;

    __MPC_FUNC_CLEANUP;

    if(fTempFile) ::DeleteFileW( bstrInputFile );

    __MPC_FUNC_EXIT(hr);
}

STDMETHODIMP CSAFEncrypt::EncryptStream(BSTR bstrEncryptionKey, IUnknown *punkInStm, IUnknown **ppunkOutStm)
{
	__HCP_FUNC_ENTRY( "CSAFEncrypt::EncryptStream" );

    HRESULT                       hr;
    CComPtr<MPC::EncryptedStream> stream;
    CComPtr<IStream>              streamPlain;
    CComPtr<IStream>              streamEncrypted;
    LARGE_INTEGER                 liFilePos = { 0, 0 };

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(punkInStm);
        __MPC_PARAMCHECK_POINTER_AND_SET(ppunkOutStm, NULL);
    __MPC_PARAMCHECK_END();

    __MPC_EXIT_IF_METHOD_FAILS(hr, punkInStm->QueryInterface( IID_IStream, (void**)&streamPlain ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CreateStreamOnHGlobal( NULL, TRUE, &streamEncrypted ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &stream ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream->Init( streamEncrypted, bstrEncryptionKey ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::BaseStream::TransferData( streamPlain, stream ));

    // Rewind the Stream.
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamEncrypted->Seek( liFilePos, STREAM_SEEK_SET, NULL ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamEncrypted->QueryInterface( IID_IUnknown, (LPVOID *)ppunkOutStm ));

    hr = S_OK;

    __MPC_FUNC_CLEANUP;
	
    __MPC_FUNC_EXIT(hr);
}

STDMETHODIMP CSAFEncrypt::DecryptStream(BSTR bstrEncryptionKey, IUnknown *punkInStm, IUnknown **ppunkOutStm)
{
	__HCP_FUNC_ENTRY( "CSAFEncrypt::DecryptStream" );

    HRESULT                       hr;

    CComPtr<MPC::EncryptedStream> stream;
    CComPtr<IStream>              streamPlain;
    CComPtr<IStream>              streamEncrypted;
								  
    LARGE_INTEGER                 liFilePos = { 0, 0 };

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(punkInStm);
        __MPC_PARAMCHECK_POINTER_AND_SET(ppunkOutStm, NULL);
    __MPC_PARAMCHECK_END();

    __MPC_EXIT_IF_METHOD_FAILS(hr, punkInStm->QueryInterface( IID_IStream, (void**)&streamEncrypted ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &stream ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream->Init( streamEncrypted, bstrEncryptionKey ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CreateStreamOnHGlobal( NULL, TRUE, &streamPlain ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::BaseStream::TransferData( stream, streamPlain));

    // Rewind the Stream.
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamPlain->Seek( liFilePos, STREAM_SEEK_SET, NULL ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamPlain->QueryInterface( IID_IUnknown, (LPVOID *)ppunkOutStm ));

    hr = S_OK;

    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\incidentobject\lib\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__C5610F51_3F0C_11D3_80CE_00C04F688C0B__INCLUDED_)
#define AFX_STDAFX_H__C5610F51_3F0C_11D3_80CE_00C04F688C0B__INCLUDED_

#include <module.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#include <MPC_xml.h>
#include <MPC_utils.h>
#include <MPC_COM.h>
#include <MPC_streams.h>

#include "msscript.h"

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

//
// From HelpCenterTypeLib.idl
//
#include <HelpCenterTypeLib.h>

#include <Incident.h>


#endif // !defined(AFX_STDAFX_H__C5610F51_3F0C_11D3_80CE_00C04F688C0B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\remotedesktopmanager\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\remotedesktopmanager\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__06D175BE_6169_4143_AC02_5B284EA0BC8A__INCLUDED_)
#define AFX_STDAFX_H__06D175BE_6169_4143_AC02_5B284EA0BC8A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include "SAFrdmMsgs.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__06D175BE_6169_4143_AC02_5B284EA0BC8A__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\incidentobject\unittest\hsi.h ===
#ifndef HSI
#define HSI

#include <stdlib.h>

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

//
// From HelpCenterTypeLib.idl
//
#include <HelpCenterTypeLib.h>

class ATL_NO_VTABLE CHSItem :
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public IDispatchImpl<IPCHHelpSessionItem, &IID_IPCHHelpSessionItem, &LIBID_HelpServiceTypeLib>
{
public:
BEGIN_COM_MAP(CHSItem)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHHelpSessionItem)
END_COM_MAP()

	CComBSTR m_bstrURL;
	CComBSTR m_bstrTitle;
	DATE     m_dtLV;
	DATE     m_dtDur;
	long     m_cHits;

    HRESULT Init(BSTR bstrURL, BSTR bstrTitle, DATE dtLV, DATE dtDur, long cHits)
    {
        m_bstrURL   = bstrURL;
        m_bstrTitle = bstrTitle;
        m_dtLV      = dtLV;
        m_dtDur     = dtDur;
        m_cHits     = cHits;
        return NOERROR;
    }

	// IPCHHelpSessionItem
    STDMETHOD(get_SKU        )( /*[out, retval]*/ BSTR *pVal )
    {
        return E_NOTIMPL;
    }
    STDMETHOD(get_Language        )( /*[out, retval]*/ long *pVal )
    {
        return E_NOTIMPL;
    }

    STDMETHOD(get_URL        )( /*[out, retval]*/ BSTR *pVal )
    {
        if ((*pVal = SysAllocString(m_bstrURL.m_str)) == NULL)
            return E_OUTOFMEMORY;

        return NOERROR;
    }

    STDMETHOD(get_Title      )( /*[out, retval]*/ BSTR *pVal )
    {
        if ((*pVal = SysAllocString(m_bstrTitle.m_str)) == NULL)
            return E_OUTOFMEMORY;

        return NOERROR;
    }

    STDMETHOD(get_LastVisited)( /*[out, retval]*/ DATE *pVal )
    {
        *pVal = m_dtLV;
        return NOERROR;
    }

    STDMETHOD(get_Duration   )( /*[out, retval]*/ DATE *pVal )
    {
        *pVal = m_dtDur;
        return NOERROR;
    }

    STDMETHOD(get_NumOfHits  )( /*[out, retval]*/ long *pVal )
    {
        *pVal = m_cHits;
        return NOERROR;
    }

    STDMETHOD(get_Property)( /*[in]*/ BSTR bstrName, /*[out, retval]*/ VARIANT *  pVal )
	{
        return E_NOTIMPL;
    }

    STDMETHOD(put_Property)( /*[in]*/ BSTR bstrName, /*[in]*/ VARIANT  newVal )
	{
        return E_NOTIMPL;
    }

    STDMETHOD(get_ContextName)( /*[out, retval]*/ BSTR *pVal )
	{
        return E_NOTIMPL;
    }

    STDMETHOD(get_ContextInfo)( /*[out, retval]*/ BSTR *pVal )
	{
        return E_NOTIMPL;
    }

    STDMETHOD(get_ContextURL)( /*[out, retval]*/ BSTR *pVal )
	{
        return E_NOTIMPL;
    }

	STDMETHOD(CheckProperty)( /*[in]*/ BSTR bstrName, /*[out, retval]*/ VARIANT_BOOL *pVal )
	{
        return E_NOTIMPL;
    }
};


class ATL_NO_VTABLE CHSC :
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public IDispatchImpl<IPCHCollection, &IID_IPCHCollection, &LIBID_HelpServiceTypeLib>
{
public:
BEGIN_COM_MAP(CHSC)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHCollection)
END_COM_MAP()

    STDMETHOD(get__NewEnum)(IUnknown **pVal) { return E_NOTIMPL; }
    STDMETHOD(get_Item    )(long vIndex, VARIANT *pEntry)
    {
        CComObject<CHSItem> *phsi = NULL;
        SYSTEMTIME          st;
        CComBSTR            bstrURL, bstrTitle;
        HRESULT             hr = NOERROR;
        WCHAR               wsz[14];
        DATE                dtLast, dtDur;

        _itow(vIndex, wsz, 10);

        bstrURL = L"URL";
        bstrURL.Append(wsz);
        bstrTitle = L"Title";
        bstrTitle.Append(wsz);
        
        GetSystemTime(&st);
        SystemTimeToVariantTime(&st, &dtLast);
        Sleep(516);
        GetSystemTime(&st);
        SystemTimeToVariantTime(&st, &dtDur);
        dtDur = dtDur - dtLast;

        hr = CComObject<CHSItem>::CreateInstance(&phsi);
        if (FAILED(hr))
            goto done;

        hr = phsi->Init(bstrURL, bstrTitle, dtLast, dtDur, vIndex);
        if (FAILED(hr))
            goto done;

        V_VT(pEntry) = VT_DISPATCH;
        V_DISPATCH(pEntry) = phsi;
        phsi = NULL;

    done:
        if (phsi != NULL)
            phsi->Release();
        return hr;
    }

    STDMETHOD(get_Count)(long *pVal) { *pVal = 3; return NOERROR; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\incidentobject\lib\incident.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    incident.cpp

Abstract:
    Incident object

Revision History:
    DerekM  created  07/21/99

    Kalyani Narlanka    (KalyaniN)  03/15/01
	      Moved Incident Object from HelpService to HelpCtr to improve Perf.
		  Impersonation code removed while loading an incident XML file as this no longer
		  lives in a service.

********************************************************************/

#include "stdafx.h"
#include "msxml.h"

#include <HCP_trace.h>


const DWORD c_dwidDone  = 0;
const DWORD c_dwidMisc  = 1;
const DWORD c_dwidSnap  = 2;
const DWORD c_dwidHist  = 3;
const DWORD c_dwidTrace = 4;
const DWORD c_dwidType  = 5;
const DWORD c_dwidUser  = 6;
const DWORD c_dwidProb  = 7;
const DWORD c_dwidID    = 8;
const DWORD c_dwidName  = 9;
const DWORD c_dwidXSL   = 10;
const DWORD c_dwidRCReq = 11;
const DWORD c_dwidRCEnc = 12;
const DWORD c_dwidRCTkt = 13;
const DWORD c_dwidStartPg = 14;

#define TEXT_TAG_UPLOADINFO           L"UPLOADINFO"
#define TEXT_TAG_UPLOADDATA           L"UPLOADDATA"
#define TEXT_TAG_SNAPSHOT             L"//SNAPSHOT"
#define TEXT_TAG_HISTORY              L"//HISTORY"
#define TEXT_TAG_HELPSESSION          L"//HELPSESSIONCOLLECTION"
#define TEXT_ATTR_INC_TYPE            L"TYPE"
#define TEXT_UT_BUG                   L"Bug"
#define TEXT_TRUE                     L"1"
#define TEXT_FALSE                    L"0"

static CComBSTR l_bstrXmlSkeleton( L"<?xml version=\"1.0\" encoding=\"Unicode\" ?><ROOTNODE ATTRIB=\"VALUE\"><CHILDNODE/></ROOTNODE>" );

/////////////////////////////////////////////////////////////////////////////
//  utility functions

static HRESULT WriteData( IStream* pstmDest, DWORD dw )
{
    __HCP_FUNC_ENTRY( "WriteData(DWORD)" );

    HRESULT hr;
    DWORD   cbWritten;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pstmDest);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, pstmDest->Write( &dw, sizeof(dw), &cbWritten ));
    _ASSERT(cbWritten == sizeof(dw));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

// **************************************************************************

static HRESULT WriteData( IStream* pstmDest, LPCWSTR wszSrc, BOOL fWriteSize = FALSE )
{
    __HCP_FUNC_ENTRY( "WriteData(WCHAR)" );

    HRESULT hr;
    DWORD   cbWritten;
    DWORD   cbToWrite;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pstmDest);
        // __MPC_PARAMCHECK_NOTNULL(wszSrc);
    __MPC_PARAMCHECK_END();


    SANITIZEWSTR(wszSrc);
    cbToWrite = wcslen(wszSrc) * sizeof(WCHAR);

    if(fWriteSize)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pstmDest, cbToWrite ));
    }

    if(cbToWrite)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, pstmDest->Write( wszSrc, cbToWrite, &cbWritten ));

        _ASSERT(cbWritten == cbToWrite);
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

// **************************************************************************

static HRESULT WriteXMLAttribute( IStream* pStm, LPCWSTR wszName, LPCWSTR wszValue, IXMLDOMDocument* pDoc )
{
    __HCP_FUNC_ENTRY( "WriteXMLAttribute" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pStm);
        __MPC_PARAMCHECK_NOTNULL(wszName);
        __MPC_PARAMCHECK_NOTNULL(pDoc);
    __MPC_PARAMCHECK_END();


    if(wszValue)
    {
        CComPtr<IXMLDOMAttribute> pAttrib;
        CComBSTR                  bstrXML;

        __MPC_EXIT_IF_METHOD_FAILS(hr, pDoc->createAttribute ( CComBSTR   ( wszName  ), &pAttrib ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, pAttrib->put_nodeValue( CComVariant( wszValue )           ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, pAttrib->get_xml( &bstrXML ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, bstrXML ));
    }
    else
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, wszName  ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, L"=\"\"" ));
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, L" " ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

// **************************************************************************

static HRESULT WriteData( IStream* pstmDest, SHelpSessionItem &hsi, IXMLDOMDocument* pDoc = NULL )
{
    __HCP_FUNC_ENTRY( "WriteData(SHelpSessionItem)" );

    HRESULT hr;
    DWORD   cbWritten;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pstmDest);
    __MPC_PARAMCHECK_END();


    // write out the URL
    if(pDoc)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData        ( pstmDest, L"<HELPSESSIONITEM "      ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteXMLAttribute( pstmDest, L"URL", hsi.bstrURL, pDoc ));
    }
    else
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pstmDest, hsi.bstrURL, TRUE ));
    }

    // write out the title
    if(pDoc)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteXMLAttribute( pstmDest, L"TITLE", hsi.bstrTitle, pDoc ));
    }
    else
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pstmDest, hsi.bstrTitle, TRUE ));
    }

    // write out the last visited date
    if(pDoc)
    {
		MPC::wstring strDate;

		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertDateToString( hsi.dtLastVisited, strDate, /*fGMT*/false, /*fCIM*/false, -1 )); // Always use US locale.

        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteXMLAttribute( pstmDest, L"LASTVISITED", strDate.c_str(), pDoc ));
    }
    else
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, pstmDest->Write( &(hsi.dtLastVisited), sizeof(hsi.dtLastVisited), &cbWritten ));

        _ASSERT(cbWritten == sizeof(hsi.dtLastVisited));
    }

    // write out the last visited date
    if(pDoc)
    {
		MPC::wstring strDate;

		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertDateToString( hsi.dtDuration, strDate, /*fGMT*/false, /*fCIM*/false, -1 )); // Always use US locale.

        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteXMLAttribute( pstmDest, L"DURATION", strDate.c_str(), pDoc ));
    }
    else
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, pstmDest->Write( &(hsi.dtDuration), sizeof(hsi.dtDuration), &cbWritten ));

        _ASSERT(cbWritten == sizeof(hsi.dtDuration));
    }

    // write out the # of hits
    if(pDoc)
    {
        CComVariant var;

        var = hsi.cHits;

        __MPC_EXIT_IF_METHOD_FAILS(hr, var.ChangeType( VT_BSTR ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteXMLAttribute( pstmDest, L"HITS", V_BSTR(&var), pDoc ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pstmDest, L"/>" ));
    }
    else
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, pstmDest->Write( &(hsi.cHits), sizeof(hsi.cHits), &cbWritten ));

        _ASSERT(cbWritten == sizeof(hsi.cHits));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

// **************************************************************************

// **************************************************************************
// **************************************************************************
// **************************************************************************

static HRESULT ReadData( IStream* pstmSrc, DWORD *pdw )
{
    __HCP_FUNC_ENTRY( "ReadData(DWORD)" );

    HRESULT hr;
    DWORD   cbRead;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pstmSrc);
        __MPC_PARAMCHECK_NOTNULL(pdw);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, pstmSrc->Read( pdw, sizeof(DWORD), &cbRead ));
    _ASSERT(cbRead == sizeof(DWORD));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

// **************************************************************************

static HRESULT ReadData( IStream* pstmSrc, BSTR *pbstr )
{
    __HCP_FUNC_ENTRY( "ReadData(BSTR)" );

    HRESULT  hr;
    DWORD    cbRead;
    DWORD    cbToRead;
    CComBSTR bstr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pstmSrc);
        __MPC_PARAMCHECK_POINTER_AND_SET(pbstr,NULL);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, ReadData( pstmSrc, &cbToRead ));

    // return S_FALSE to indicate we didn't successfully didn't read anything
    if(cbToRead == 0)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE);
    }

    bstr.Attach( ::SysAllocStringByteLen(NULL, cbToRead) );
    if(bstr.m_str == NULL)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_OUTOFMEMORY);
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, pstmSrc->Read( bstr, cbToRead, &cbRead ));

    *pbstr = bstr.Detach();
    hr     = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

// **************************************************************************

static HRESULT ReadData( IStream* pstmSrc, LPVOID *ppv, DWORD *pcb)
{
    __HCP_FUNC_ENTRY( "ReadData(LPVOID)" );

    HRESULT  hr;
    BYTE*    pv = NULL;
    DWORD    cb;
    DWORD    cbRead;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pstmSrc);
        __MPC_PARAMCHECK_POINTER_AND_SET(ppv,NULL);
        __MPC_PARAMCHECK_POINTER_AND_SET(pcb,0);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, ReadData( pstmSrc, &cb ));

    *pcb = cb;

    // return S_FALSE to indicate we didn't successfully didn't read anything
    if(cb == 0)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE);
    }

    __MPC_EXIT_IF_ALLOC_FAILS(hr, pv, new BYTE[ cb ]);

    __MPC_EXIT_IF_METHOD_FAILS(hr, pstmSrc->Read( pv, cb, &cbRead ));

    _ASSERT(cb == cbRead);

    *ppv = pv; pv = NULL;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(pv) delete [] pv;

    __HCP_FUNC_EXIT(hr);
}

// **************************************************************************

static HRESULT ReadData( IStream* pstmSrc, SHelpSessionItem &hsi )
{
    __HCP_FUNC_ENTRY( "ReadData(SHelpSessionItem)" );

    HRESULT  hr;
    DWORD    cbRead;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pstmSrc);
    __MPC_PARAMCHECK_END();


    // read the URL
    __MPC_EXIT_IF_METHOD_FAILS(hr, ReadData(pstmSrc, &hsi.bstrURL ));

    // read the Title
    __MPC_EXIT_IF_METHOD_FAILS(hr, ReadData(pstmSrc, &hsi.bstrTitle ));

    // read the last visited date
    __MPC_EXIT_IF_METHOD_FAILS(hr, pstmSrc->Read( &(hsi.dtLastVisited), sizeof(hsi.dtLastVisited), &cbRead ));
    _ASSERT(cbRead == sizeof(hsi.dtLastVisited));

    // read the duration
    __MPC_EXIT_IF_METHOD_FAILS(hr, pstmSrc->Read( &(hsi.dtDuration), sizeof(hsi.dtDuration), &cbRead ));
    _ASSERT(cbRead == sizeof(hsi.dtDuration));

    // read the # of hits
    __MPC_EXIT_IF_METHOD_FAILS(hr, pstmSrc->Read( &(hsi.cHits), sizeof(hsi.cHits), &cbRead ));
    _ASSERT(cbRead == sizeof(hsi.cHits));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

// **************************************************************************

static HRESULT SetStream( /*[in/out]*/ CComBSTR& bstrXML, /*[in]*/ IUnknown *punkStm )
{
    __HCP_FUNC_ENTRY( "SetStream" );

    HRESULT                   hr;
    CComPtr<IXMLDOMDocument>  xddDoc;
    CComPtr<IXMLDOMElement>   xdeRoot;
    CComVariant               vStream = punkStm;
    VARIANT_BOOL              fSuccess;


    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateInstance( CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument, (void**)&xddDoc ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, xddDoc->load( vStream, &fSuccess ));
    if(fSuccess != VARIANT_TRUE)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, xddDoc->get_documentElement( &xdeRoot ));

	bstrXML.Empty(); __MPC_EXIT_IF_METHOD_FAILS(hr, xdeRoot->get_xml( &bstrXML ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
//  construction / destruction

// **************************************************************************
CSAFIncident::CSAFIncident()
{
    m_rghsi = NULL;
    m_chsi  = 0;
    m_eut   = eutEscalated;

    // By default RCRequested is False and RCTicketEncrypted is False.
    m_fRCRequested = VARIANT_FALSE;
    m_fRCTicketEncrypted = VARIANT_FALSE;
	                        // MPC::Impersonation              m_imp;
}

// **************************************************************************
CSAFIncident::~CSAFIncident()
{
    Cleanup();
}

// **************************************************************************
void CSAFIncident::Cleanup()
{
    m_pDict       .Release();
    m_bstrUser    .Empty  ();
    m_bstrID      .Empty  ();
    m_bstrName    .Empty  ();
    m_bstrProb    .Empty  ();
    m_bstrSnapshot.Empty  ();
    m_bstrHistory .Empty  ();
    m_bstrXSL     .Empty  ();
    m_bstrRCTicket.Empty  ();
    m_bstrStartPg .Empty  ();

    delete [] m_rghsi; m_rghsi = NULL;

    m_chsi = 0;
    m_eut  = eutEscalated;
}

////////////////////

/////////////////////////////////////////////////////////////////////////////
//  CSAFIncident properties

// **************************************************************************
STDMETHODIMP CSAFIncident::get_IncidentXSL(BSTR *pbstrUser)
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::GetBSTR( m_bstrXSL, pbstrUser );
}

// **************************************************************************
STDMETHODIMP CSAFIncident::put_IncidentXSL(BSTR bstrUser)
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::PutBSTR( m_bstrXSL, bstrUser );
}

// **************************************************************************
STDMETHODIMP CSAFIncident::get_UserName(BSTR *pbstrUser)
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::GetBSTR( m_bstrUser, pbstrUser );
}

// **************************************************************************
STDMETHODIMP CSAFIncident::put_UserName(BSTR bstrUser)
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::PutBSTR( m_bstrUser, bstrUser );
}

// **************************************************************************
STDMETHODIMP CSAFIncident::get_ProductID(BSTR *pbstrID)
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::GetBSTR( m_bstrID, pbstrID );
}

// **************************************************************************
STDMETHODIMP CSAFIncident::put_ProductID(BSTR bstrID)
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::PutBSTR( m_bstrID, bstrID );
}

// **************************************************************************
STDMETHODIMP CSAFIncident::get_ProductName(BSTR *pbstrName)
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::GetBSTR( m_bstrName, pbstrName );
}

// **************************************************************************
STDMETHODIMP CSAFIncident::put_ProductName(BSTR bstrName)
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::PutBSTR( m_bstrName, bstrName );
}

// **************************************************************************
STDMETHODIMP CSAFIncident::get_ProblemDescription(BSTR *pbstrProb)
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::GetBSTR( m_bstrProb, pbstrProb );
}

// **************************************************************************
STDMETHODIMP CSAFIncident::put_ProblemDescription(BSTR bstrProb)
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::PutBSTR( m_bstrProb, bstrProb );
}

// **************************************************************************
STDMETHODIMP CSAFIncident::put_MachineSnapshot(IUnknown *punkStm)
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return SetStream( m_bstrSnapshot, punkStm );
}


// **************************************************************************
STDMETHODIMP CSAFIncident::put_MachineHistory(IUnknown *punkStm)
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return SetStream( m_bstrHistory, punkStm );
}

// **************************************************************************
STDMETHODIMP CSAFIncident::put_SelfHelpTrace( IUnknown* punkStm )
{
    __HCP_FUNC_ENTRY("CSAFIncident::put_SelfHelpTrace");

    HRESULT                      hr;
    CComPtr<IPCHCollection>      pClct;
    int                          i;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(punkStm);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, punkStm->QueryInterface( IID_IPCHCollection, (LPVOID *)&pClct ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pClct->get_Count( &m_chsi ));

    delete [] m_rghsi; __MPC_EXIT_IF_ALLOC_FAILS(hr, m_rghsi, new SHelpSessionItem[m_chsi]);

    for(i = 0; i < m_chsi; i++)
    {
        SHelpSessionItem&            rghsi = m_rghsi[i];
        CComPtr<IPCHHelpSessionItem> pItem;
        CComVariant                  var;

        __MPC_EXIT_IF_METHOD_FAILS(hr, pClct->get_Item( i+1, &var ));
        _ASSERT(V_VT(&var) == VT_DISPATCH || V_VT(&var) == VT_UNKNOWN);

        __MPC_EXIT_IF_METHOD_FAILS(hr, V_UNKNOWN(&var)->QueryInterface( IID_IPCHHelpSessionItem, (LPVOID *)&pItem ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, pItem->get_URL        ( &rghsi.bstrURL       ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, pItem->get_Title      ( &rghsi.bstrTitle     ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, pItem->get_LastVisited( &rghsi.dtLastVisited ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, pItem->get_Duration   ( &rghsi.dtDuration    ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, pItem->get_NumOfHits  ( &rghsi.cHits         ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

// **************************************************************************
HRESULT CSAFIncident::InitDictionary()
{
    if(m_pDict) return S_OK;

	return ::CoCreateInstance( CLSID_Dictionary, NULL, CLSCTX_INPROC_SERVER, IID_IDictionary, (LPVOID *)&m_pDict );
}

STDMETHODIMP CSAFIncident::get_Misc( IDispatch* *ppdispDict )
{
    __HCP_BEGIN_PROPERTY_GET("SAFIncident::get_Misc",hr,ppdispDict);


	__MPC_EXIT_IF_METHOD_FAILS(hr, InitDictionary());

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_pDict.QueryInterface( ppdispDict ));


    __HCP_END_PROPERTY(hr);
}

// **************************************************************************
STDMETHODIMP CSAFIncident::put_UploadType( EUploadType eut )
{
    __HCP_BEGIN_PROPERTY_PUT("SAFIncident::put_UploadType",hr);


    // As the valid upload types are 0,1,2 if the value of UploadType is
    // outside this range we should not set it and also flag an error.
    switch(eut)
    {
        case eutBug:
        case eutEscalated:
        case eutNonEscalated:
            m_eut = eut;
            break;

        default:
            __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }


    __HCP_END_PROPERTY(hr);
}

// **************************************************************************
STDMETHODIMP CSAFIncident::get_UploadType( EUploadType *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CSAFIncident::get_UploadType",hr,pVal,m_eut);

    __HCP_END_PROPERTY(hr);
}


// RC Additions
// **************************************************************************

STDMETHODIMP CSAFIncident::get_RCRequested(VARIANT_BOOL *pVal)
{
    __HCP_BEGIN_PROPERTY_GET2("CSAFIncident::get_RCRequested",hr,pVal,m_fRCRequested);

    __HCP_END_PROPERTY(hr);
}

// **************************************************************************

STDMETHODIMP CSAFIncident::put_RCRequested(VARIANT_BOOL Val)
{

    __HCP_BEGIN_PROPERTY_PUT("CSAFIncident::put_RCRequested",hr);

    m_fRCRequested = Val;

    __HCP_END_PROPERTY(hr);
}

// **************************************************************************

STDMETHODIMP CSAFIncident::get_RCTicketEncrypted( VARIANT_BOOL *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CSAFIncident::get_RCTicketEncrypted",hr,pVal,m_fRCTicketEncrypted);

    __HCP_END_PROPERTY(hr);
}

// **************************************************************************

STDMETHODIMP CSAFIncident::put_RCTicketEncrypted( VARIANT_BOOL newVal )
{
    __HCP_BEGIN_PROPERTY_PUT("CSAFIncident::put_RCTicketEncrypted",hr);

    m_fRCTicketEncrypted = newVal;

    __HCP_END_PROPERTY(hr);
}

// **************************************************************************

STDMETHODIMP CSAFIncident::get_RCTicket( BSTR *pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::GetBSTR( m_bstrRCTicket, pVal, true );
}

// **************************************************************************

STDMETHODIMP CSAFIncident::put_RCTicket( BSTR bstrVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::PutBSTR( m_bstrRCTicket, bstrVal, true );
}

// **************************************************************************

STDMETHODIMP CSAFIncident::get_StartPage( BSTR *pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::GetBSTR( m_bstrStartPg, pVal );
}

// **************************************************************************
STDMETHODIMP CSAFIncident::put_StartPage( BSTR newVal)
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::PutBSTR( m_bstrStartPg, newVal );
}


/////////////////////////////////////////////////////////////////////////////
//  CSAFIncident methods

STDMETHODIMP CSAFIncident::GetXML( BSTR bstrFileName )
{
    __HCP_FUNC_ENTRY("CSAFIncident::GetXML");

    HRESULT                      hr;
    CComPtr<MPC::FileStream>     pfs;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrFileName);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pfs ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pfs->InitForWrite( bstrFileName ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, DoXML( pfs ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

// **************************************************************************

STDMETHODIMP CSAFIncident::GetXMLAsStream( IUnknown* *ppunkStm )
{
    __HCP_FUNC_ENTRY("CSAFIncident::GetXMLAsStream");

    HRESULT                      hr;
    CComPtr<MPC::FileStream>     pfs;
    MPC::wstring                 szTempFile;
    LARGE_INTEGER                liFilePos = { 0, 0 };
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(ppunkStm,NULL);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pfs ));

    //
    // create a temporary file to hold the stream.  We want to use a file cuz
    // otherwise, we're going to be using boatloads of memory for all the CIM
    // stuff...
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetTemporaryFileName( szTempFile ));

    // Adding GENERIC_READ
    __MPC_EXIT_IF_METHOD_FAILS(hr, pfs->InitForReadWrite( szTempFile.c_str() ));

    // Call release on delete similar to close on delete.
    __MPC_EXIT_IF_METHOD_FAILS(hr, pfs->DeleteOnRelease());

    __MPC_EXIT_IF_METHOD_FAILS(hr, DoXML( pfs ));

    // Rewind the stream pointer.
    __MPC_EXIT_IF_METHOD_FAILS(hr, pfs->Seek( liFilePos, STREAM_SEEK_SET, NULL ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pfs->QueryInterface( IID_IUnknown, (LPVOID *)ppunkStm ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

// **************************************************************************

HRESULT CSAFIncident::DoXML( IStream* pStm )
{
    __HCP_FUNC_ENTRY("CSAFIncident::DoXML");

    HRESULT                   hr;
    CComPtr<IXMLDOMDocument>  pDoc;
    ULARGE_INTEGER            uli = { 0, 0 };
    VARIANT_BOOL              varf;
    DWORD                     cbWritten;
    WCHAR                     wch = 0xfeff;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pStm);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateInstance( CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument, (LPVOID *)&pDoc ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pDoc->loadXML( l_bstrXmlSkeleton, &varf ));

    if(FAILED(hr = pStm->SetSize( uli )) && hr != E_NOTIMPL)
    {
        __MPC_FUNC_LEAVE;
    }

    // need to write out the character that marks the file as unicode
    __MPC_EXIT_IF_METHOD_FAILS(hr, pStm->Write( &wch, sizeof(wch), &cbWritten ));
    _ASSERT(cbWritten == sizeof(wch));

    // write out the header crap
    __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, L"<?xml version=\"1.0\" encoding=\"Unicode\" ?>" ));

    // write out the XSL node if we have any
    if(m_bstrXSL.Length() > 0)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, m_bstrXSL.m_str ));
    }

    // write out the root node
    __MPC_EXIT_IF_METHOD_FAILS(hr,  WriteData( pStm, L"<UPLOADINFO" ));

    switch(m_eut)
    {
    case eutBug         : __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, L" TYPE=\"Bug\">"          )); break;
    case eutEscalated   : __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, L" TYPE=\"Escalated\">"    )); break;
    case eutNonEscalated: __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, L" TYPE=\"NonEscalated\">" )); break;
    default             : __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, L"<UPLOADDATA " ));

    if(m_bstrUser.Length() > 0)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteXMLAttribute( pStm, L"USERNAME", m_bstrUser.m_str, pDoc ));
    }

    if(m_bstrID.Length() > 0)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteXMLAttribute( pStm, L"PRODUCTID", m_bstrID.m_str, pDoc ));
    }

    if(m_bstrName.Length() > 0)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteXMLAttribute( pStm, L"PRODUCTNAME", m_bstrName.m_str, pDoc ));
    }

    if(m_bstrProb.Length() > 0)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteXMLAttribute( pStm, L"PROBLEMDESCRIPTION", m_bstrProb.m_str, pDoc ));
    }

    if(m_bstrRCTicket.Length() > 0)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteXMLAttribute( pStm, L"RCTICKET", m_bstrRCTicket.m_str, pDoc ));
    }

#if 0 // This is no longer used.
    if(m_fRCRequested == VARIANT_TRUE)
    {
         __MPC_EXIT_IF_METHOD_FAILS(hr, WriteXMLAttribute( pStm, L"RCREQUESTED", TEXT_TRUE, pDoc ));
    }
    else
    {
         __MPC_EXIT_IF_METHOD_FAILS(hr, WriteXMLAttribute( pStm, L"RCREQUESTED", TEXT_FALSE, pDoc ));
    }
#endif

    if(m_fRCTicketEncrypted == VARIANT_TRUE)
    {
         __MPC_EXIT_IF_METHOD_FAILS(hr, WriteXMLAttribute( pStm, L"RCTICKETENCRYPTED", TEXT_TRUE, pDoc ));
    }
    else
    {
         __MPC_EXIT_IF_METHOD_FAILS(hr, WriteXMLAttribute( pStm, L"RCTICKETENCRYPTED", TEXT_FALSE, pDoc ));
    }

    if(m_bstrStartPg.Length() > 0)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteXMLAttribute( pStm, L"STARTPAGE", m_bstrStartPg.m_str, pDoc ));
    }


    // write out the contents of the dictionary object here...
    if(m_pDict)
    {
        CComPtr<IUnknown>     punkEnum;
        CComPtr<IEnumVARIANT> pEnum;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_pDict->_NewEnum( &punkEnum ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, punkEnum.QueryInterface( &pEnum ));

        for(;;)
        {
            CComVariant varKey;
            CComVariant varValue;
            ULONG       cFetched;

            __MPC_EXIT_IF_METHOD_FAILS(hr, pEnum->Next( 1, &varKey, &cFetched ));

            // we're done enuming
            if(hr == S_FALSE || cFetched != 1) break;

            __MPC_EXIT_IF_METHOD_FAILS(hr, m_pDict->get_Item( &varKey, &varValue ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, varKey  .ChangeType( VT_BSTR ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, varValue.ChangeType( VT_BSTR ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, WriteXMLAttribute( pStm, V_BSTR(&varKey), V_BSTR(&varValue), pDoc ));
        }
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, L"/>" ));

    // write out the CIM data streams
    if(m_bstrSnapshot.Length() > 0)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, m_bstrSnapshot ));
    }

    // write out the CIM data streams
    if(m_bstrHistory.Length() > 0)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, m_bstrHistory ));
    }

    // write out the trace stuff
    if(m_rghsi && m_chsi > 0)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, L"<HELPSESSIONCOLLECTION>" ));

        for(int i = 0; i < m_chsi; i++)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, m_rghsi[i], pDoc ));
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, L"</HELPSESSIONCOLLECTION>" ));
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, L"</UPLOADINFO>" ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

// **************************************************************************

STDMETHODIMP CSAFIncident::Save( BSTR bstrFileName )
{
    __HCP_FUNC_ENTRY( "CSAFIncident::Save" );

    HRESULT                      hr;
    CComPtr<MPC::FileStream>     pfs;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrFileName);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pfs ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pfs->InitForWrite( bstrFileName ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, DoSave( pfs ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CSAFIncident::SaveToStream( IUnknown* *ppunkStm )
{
    __HCP_FUNC_ENTRY("CSAFIncident::SaveToStream");

    HRESULT                      hr;
    CComPtr<MPC::FileStream>     pfs;
    TCHAR                        szTempPath[MAX_PATH];
    TCHAR                        szTempFile[MAX_PATH];
    LARGE_INTEGER                liFilePos = { 0, 0 };
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(ppunkStm,NULL);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pfs ));

    // create a temporary file to hold the stream.  We want to use a file cuz
    //  otherwise, we're going to be using boatloads of memory for all the CIM
    //  stuff...
    __MPC_EXIT_IF_CALL_RETURNS_ZERO(hr, ::GetTempPath    ( MAX_PATH, szTempPath                           ));
    __MPC_EXIT_IF_CALL_RETURNS_ZERO(hr, ::GetTempFileName(           szTempPath, _T("PCH"), 0, szTempFile ));

    // To fix Bug 115618 open the file with read and write attributes.
    // hr = pfs->InitForReadWrite(bstrFileName, hFile);
    __MPC_EXIT_IF_METHOD_FAILS(hr, pfs->InitForReadWrite( CComBSTR( szTempFile ) ));

    // Mark the file for deletion
    __MPC_EXIT_IF_METHOD_FAILS(hr, pfs->DeleteOnRelease());

    __MPC_EXIT_IF_METHOD_FAILS(hr, DoSave( pfs ));

    // Rewind the stream after writing to it.
    __MPC_EXIT_IF_METHOD_FAILS(hr, pfs->Seek( liFilePos, STREAM_SEEK_SET, NULL ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pfs->QueryInterface( IID_IUnknown, (LPVOID *)ppunkStm ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CSAFIncident::DoSave( IStream* pStm )
{
    __HCP_FUNC_ENTRY("CSAFIncident::DoSave");

    HRESULT        hr;
    ULARGE_INTEGER uli = { 0, 0 };

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pStm);
    __MPC_PARAMCHECK_END();


    if(FAILED(hr = pStm->SetSize( uli )) && hr != E_NOTIMPL)
    {
        __MPC_FUNC_LEAVE;
    }

    // write out upload type
    __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, c_dwidType   ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, (DWORD)m_eut ));


    // write out username
    if(m_bstrUser.Length() > 0)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, c_dwidUser             ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, m_bstrUser.m_str, TRUE ));
    }


    // write out product ID
    if(m_bstrID.Length() > 0)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, c_dwidID             ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, m_bstrID.m_str, TRUE ));
    }


    // write out product name
    if(m_bstrName.Length() > 0)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, c_dwidName             ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, m_bstrName.m_str, TRUE ));
    }


    // write out problem description
    if(m_bstrProb.Length() > 0)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, c_dwidProb             ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, m_bstrProb.m_str, TRUE ));
    }


    // write out XSL stream
    if(m_bstrXSL.Length() > 0)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, c_dwidXSL              ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, m_bstrXSL.m_str, TRUE  ));
    }

    // write out RC Ticket
    if(m_bstrRCTicket.Length() > 0)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, c_dwidRCTkt            ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, m_bstrRCTicket.m_str, TRUE  ));
    }

    // write out RCRequested Flag
    if(m_fRCRequested == VARIANT_TRUE)
    {
       __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, c_dwidRCReq            ));
       __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, TEXT_TRUE, TRUE         ));
    }
    else
    {
       __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, c_dwidRCReq            ));
       __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, TEXT_FALSE, TRUE        ));
    }

    // write out RCTicketEncrypted Flag
    if(m_fRCTicketEncrypted == VARIANT_TRUE)
    {
       __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, c_dwidRCEnc            ));
       __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, TEXT_TRUE, TRUE         ));
    }
    else
    {
       __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, c_dwidRCEnc            ));
       __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, TEXT_FALSE, TRUE        ));
    }

    // write out Start Page
    if(m_bstrStartPg.Length() > 0)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, c_dwidStartPg          ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, m_bstrStartPg.m_str, TRUE  ));
    }

    // write out snapshot stream
    if(m_bstrSnapshot.Length() > 0)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, c_dwidSnap           ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, m_bstrSnapshot, TRUE ));
    }


    // write out history stream
    if(m_bstrHistory.Length() > 0)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, c_dwidHist          ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, m_bstrHistory, TRUE ));
    }

    // write out the trace list
    if(m_rghsi && m_chsi > 0)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, c_dwidTrace ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, m_chsi      ));

        for(int i = 0; i < m_chsi; i++)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, m_rghsi[i] ));
        }
    }

    // write out the property list
    if(m_pDict)
    {
        CComPtr<IUnknown>     punkEnum;
        CComPtr<IEnumVARIANT> pEnum;

        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, c_dwidMisc ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_pDict->_NewEnum( &punkEnum ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, punkEnum.QueryInterface( &pEnum ));

        for(;;)
        {
            CComVariant varKey;
            CComVariant varValue;
            ULONG       cFetched;
            DWORD       cb;

            __MPC_EXIT_IF_METHOD_FAILS(hr, pEnum->Next( 1, &varKey, &cFetched ));

            // we're done enuming
            if(hr == S_FALSE || cFetched != 1) break;

            __MPC_EXIT_IF_METHOD_FAILS(hr,  m_pDict->get_Item( &varKey, &varValue ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, varKey  .ChangeType( VT_BSTR ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, varValue.ChangeType( VT_BSTR ));

            if(::SysStringLen( V_BSTR(&varValue) ) > 0)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, V_BSTR(&varKey  ), TRUE ));
                __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, V_BSTR(&varValue), TRUE ));
            }
        }

        //
        // Emit end of dictionary (DWORD == 0).
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, (DWORD)0 ));
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, WriteData( pStm, c_dwidDone ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

// **************************************************************************

STDMETHODIMP CSAFIncident::Load( BSTR bstrFileName )
{
    __HCP_FUNC_ENTRY("CSAFIncident::Load");

    HRESULT                      hr;
    CComPtr<MPC::FileStream>     pfs;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrFileName);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pfs ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pfs->InitForRead( bstrFileName ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, LoadFromStream( pfs ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CSAFIncident::LoadFromStream( IUnknown* punkStm )
{
    __HCP_FUNC_ENTRY("CSAFIncident::LoadFromStream");

    HRESULT                      hr;
    CComPtr<IStream>             pStm;
    DWORD                        i;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(punkStm);
    __MPC_PARAMCHECK_END();


    Cleanup();


    __MPC_EXIT_IF_METHOD_FAILS(hr, punkStm->QueryInterface( IID_IStream, (LPVOID *)&pStm ));

    for(;;)
    {
        CComVariant varName;
        CComVariant varVal;
        DWORD       dwid;
        CComBSTR    bstrRCReq;
        CComBSTR    bstrRCEnc;

        // figure out which dwid we're processing
        __MPC_EXIT_IF_METHOD_FAILS(hr, ReadData( pStm, &dwid ));
        if(dwid == c_dwidDone) break;

        switch(dwid)
        {
        case c_dwidUser: m_bstrUser    .Empty(); __MPC_EXIT_IF_METHOD_FAILS(hr, ReadData( pStm, &m_bstrUser     )); break;
        case c_dwidProb: m_bstrProb    .Empty(); __MPC_EXIT_IF_METHOD_FAILS(hr, ReadData( pStm, &m_bstrProb     )); break;
        case c_dwidID  : m_bstrID      .Empty(); __MPC_EXIT_IF_METHOD_FAILS(hr, ReadData( pStm, &m_bstrID       )); break;
        case c_dwidName: m_bstrName    .Empty(); __MPC_EXIT_IF_METHOD_FAILS(hr, ReadData( pStm, &m_bstrName     )); break;
        case c_dwidXSL:  m_bstrXSL     .Empty(); __MPC_EXIT_IF_METHOD_FAILS(hr, ReadData( pStm, &m_bstrXSL      )); break;
        case c_dwidRCTkt:  m_bstrRCTicket.Empty(); __MPC_EXIT_IF_METHOD_FAILS(hr, ReadData( pStm, &m_bstrRCTicket)); break;
        case c_dwidStartPg:m_bstrStartPg .Empty(); __MPC_EXIT_IF_METHOD_FAILS(hr, ReadData( pStm, &m_bstrStartPg)); break;

        case c_dwidRCReq:
            m_fRCRequested=VARIANT_FALSE;
            __MPC_EXIT_IF_METHOD_FAILS(hr, ReadData( pStm, &bstrRCReq ));
            if(MPC::StrICmp( bstrRCReq, TEXT_TRUE ) == 0)
            {
                m_fRCRequested = VARIANT_TRUE;
            }
            break;

        case c_dwidRCEnc:
            m_fRCTicketEncrypted=VARIANT_FALSE;
            __MPC_EXIT_IF_METHOD_FAILS(hr, ReadData( pStm, &bstrRCEnc ));
            if(MPC::StrICmp( bstrRCEnc, TEXT_TRUE ) == 0)
            {
                m_fRCTicketEncrypted = VARIANT_TRUE;
            }
            break;

        case c_dwidSnap: m_bstrSnapshot.Empty(); __MPC_EXIT_IF_METHOD_FAILS(hr, ReadData( pStm, &m_bstrSnapshot )); break;
        case c_dwidHist: m_bstrHistory .Empty(); __MPC_EXIT_IF_METHOD_FAILS(hr, ReadData( pStm, &m_bstrHistory  )); break;


        case c_dwidType: __MPC_EXIT_IF_METHOD_FAILS(hr, ReadData( pStm, (DWORD *)&m_eut )); break;

        case c_dwidTrace:
            __MPC_EXIT_IF_METHOD_FAILS(hr, ReadData(pStm, (DWORD *)&m_chsi ));

            delete [] m_rghsi; __MPC_EXIT_IF_ALLOC_FAILS(hr, m_rghsi, new SHelpSessionItem[m_chsi]);

            for(i = 0; i < m_chsi; i++)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, ReadData( pStm, m_rghsi[i] ));
            }
            break;

        case c_dwidMisc:
			__MPC_EXIT_IF_METHOD_FAILS(hr, InitDictionary());

            for(;;)
            {
                CComBSTR bstrVal;

                __MPC_EXIT_IF_METHOD_FAILS(hr, ReadData( pStm, &bstrVal ));
                if(hr == S_FALSE) break;

                varName = bstrVal; bstrVal.Empty();

                __MPC_EXIT_IF_METHOD_FAILS(hr, ReadData( pStm, &bstrVal ));

                if(hr == S_FALSE) varVal = "";
                else              varVal = bstrVal;

                __MPC_EXIT_IF_METHOD_FAILS(hr, m_pDict->put_Item( &varName, &varVal ));
            }
            break;

        default:
            __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
        }
    }


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

// **************************************************************************

//
// Given a XML Stream, this method initializes the Incident Object with its contents.
//
HRESULT CSAFIncident::LoadFromXMLObject( /*[in]*/ MPC::XmlUtil& xmldocIncident )
{
    __HCP_FUNC_ENTRY( "CSAFIncident::LoadFromXMLObject" );

    HRESULT hr;


    Cleanup();


    //
    // Initialize the XSL value.
    //

    //
    // Initialize the Upload Type. ------------------------------------------------------------------------------
    //
    {
        CComBSTR bstrValue;
		bool     fFound;

        __MPC_EXIT_IF_METHOD_FAILS(hr, xmldocIncident.GetAttribute( NULL, TEXT_ATTR_INC_TYPE, bstrValue, fFound, NULL ));
        if(fFound == false)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_BAD_FORMAT);
        }

        if(bstrValue == L"Bug")
        {
            m_eut = eutBug;
        }
        else if(bstrValue == L"Escalated")
        {
            m_eut = eutEscalated;
        }
        else if(bstrValue == L"NonEscalated")
        {
            m_eut = eutNonEscalated;
        }
        else
        {
            __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
        }
    }

    //
    // Get the Upload Data Attributes--------------------------------------------------------------------------------
    //
    {
        CComPtr<IXMLDOMNode> xdnNode;

        __MPC_EXIT_IF_METHOD_FAILS(hr, xmldocIncident.GetNode( TEXT_TAG_UPLOADDATA, &xdnNode ));
        if(xdnNode)
        {
            CComPtr<IXMLDOMNamedNodeMap> xdnnmAttributes;
            long                         nAttribLen;


            __MPC_EXIT_IF_METHOD_FAILS(hr, xdnNode        ->get_attributes( &xdnnmAttributes ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, xdnnmAttributes->get_length    ( &nAttribLen      ));

            // Add the miscellaneous properties to the Dictionary object a property of the Incident object.
			__MPC_EXIT_IF_METHOD_FAILS(hr, InitDictionary());

            for(long i=0; i<nAttribLen; i++)
            {
                CComPtr<IXMLDOMNode> xdnAttribItem;
                CComBSTR             bstrAttribName;
                CComVariant          vAttribValue;


                // Get the attribute Name and Value.
                __MPC_EXIT_IF_METHOD_FAILS(hr, xdnnmAttributes->get_item( i, &xdnAttribItem ));

                __MPC_EXIT_IF_METHOD_FAILS(hr, xdnAttribItem->get_nodeName ( &bstrAttribName ));
                __MPC_EXIT_IF_METHOD_FAILS(hr, xdnAttribItem->get_nodeValue( &vAttribValue   ));

                if(vAttribValue.vt == VT_BSTR)
                {
                    // Initialize the well known attributes.
                    if(bstrAttribName == L"PRODUCTID")
                    {
                        // Initialize the Product ID varaible.
                        m_bstrID = vAttribValue.bstrVal;
                        continue;
                    }

                    if(bstrAttribName == L"PRODUCTNAME")
                    {
                        // Initialize the Product Name varaible.
                        m_bstrName = vAttribValue.bstrVal;
                        continue;

                    }

                    if(bstrAttribName == L"PROBLEMDESCRIPTION")
                    {
                        // Initialize the Problem Description varaible.
                        m_bstrProb = vAttribValue.bstrVal;
                        continue;
                    }

                    if(bstrAttribName == L"USERNAME")
                    {
                        // Initialize the UserName varaible.
                        m_bstrUser = vAttribValue.bstrVal;
                        continue;
                    }

                    if(bstrAttribName == L"RCTICKET")
                    {
                        // Initialize the RCTICKET varaible.
                        m_bstrRCTicket = vAttribValue.bstrVal;
                        continue;
                    }

                    if(bstrAttribName == L"RCREQUESTED")
                    {
                        // Initialize the RCREQUESTED varaible.
                        if(MPC::StrICmp( vAttribValue.bstrVal, TEXT_TRUE ) == 0)
                        {
                            m_fRCRequested = VARIANT_TRUE;
                        }
                        continue;
                    }

                    if(bstrAttribName == L"RCTICKETENCRYPTED")
                    {
                        // Initialize the  RCTICKETENCRYPTED varaible.
                        m_fRCTicketEncrypted = (MPC::StrICmp( vAttribValue.bstrVal, TEXT_TRUE ) == 0) ? VARIANT_TRUE : VARIANT_FALSE;
                        continue;
                    }

                    if(bstrAttribName == L"STARTPAGE")
                    {
                        // Initialize the Start Page varaible.
                        m_bstrStartPg = vAttribValue.bstrVal;
                        continue;
                    }
                }

                // This is a miscellaneous property.
                // Initialize the Dictionary Object Property varaible.
				{
					CComVariant v( bstrAttribName );

					__MPC_EXIT_IF_METHOD_FAILS(hr, m_pDict->put_Item( &v, &vAttribValue ));
				}
            }
        }
    }

    //
    // Get the SnapShot Data--------------------------------------------------------------------------------------------------
    //
    {
        CComPtr<IXMLDOMNode> xdnNode;

        if(SUCCEEDED(hr = xmldocIncident.GetNode( TEXT_TAG_SNAPSHOT, &xdnNode )) && xdnNode)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, xdnNode->get_xml( &m_bstrSnapshot ));
        }
    }

    //
    // Get the History Data---------------------------------------------------------------------------------------------------
    //
    {
        CComPtr<IXMLDOMNode> xdnNode;

        if(SUCCEEDED(hr = xmldocIncident.GetNode( TEXT_TAG_HISTORY, &xdnNode )) && xdnNode)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, xdnNode->get_xml( &m_bstrHistory ));
        }
    }

    //
    // Get the trace stuff HELPSESSIONCOLLECTION-------------------------------------------------------------------------------
    //
    {
        CComPtr<IXMLDOMNode> xdnNode;

        if(SUCCEEDED(hr = xmldocIncident.GetNode( TEXT_TAG_HELPSESSION, &xdnNode )) && xdnNode)
        {
            // __MPC_EXIT_IF_METHOD_FAILS(hr, xdnNodeHistory->get_xml(&m_bstrHistory));
        }
    }

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CSAFIncident::LoadFromXMLStream( /*[in]*/ IUnknown* punkStm )
{
    __HCP_FUNC_ENTRY("CSAFIncident::LoadFromXMLStream");

    HRESULT      hr;
    MPC::XmlUtil xmldocIncident;
    bool         fLoaded;
    bool         fFound;


    __MPC_EXIT_IF_METHOD_FAILS(hr, xmldocIncident.LoadAsStream( punkStm, TEXT_TAG_UPLOADINFO, fLoaded, &fFound ));
    if(fLoaded == false ||
       fFound  == false  )
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_OPEN_FAILED);
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, LoadFromXMLObject( xmldocIncident ));


    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

// **************************************************************************

// Given a XML File this method initializes the Incident Object with its contents.

STDMETHODIMP CSAFIncident::LoadFromXMLFile( BSTR bstrFileName )
{
    __HCP_FUNC_ENTRY("CSAFIncident::LoadFromXMLFile");

    HRESULT      hr;
    MPC::XmlUtil xmldocIncident;
    bool         fLoaded;
    bool         fFound;


    __MPC_EXIT_IF_METHOD_FAILS(hr, xmldocIncident.Load( bstrFileName, TEXT_TAG_UPLOADINFO, fLoaded, &fFound ));
	
    if(fLoaded == false ||
       fFound  == false  )
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_OPEN_FAILED);
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, LoadFromXMLObject( xmldocIncident ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

// **************************************************************************

// Given a XML String this method initializes the Incident Object with its contents.

STDMETHODIMP CSAFIncident::LoadFromXMLString( BSTR bstrXMLBlob )
{
    __HCP_FUNC_ENTRY("CSAFIncident::LoadFromXMLString");

    HRESULT      hr;
    MPC::XmlUtil xmldocIncident;
    bool         fLoaded;
    bool         fFound;


    __MPC_EXIT_IF_METHOD_FAILS(hr, xmldocIncident.LoadAsString( bstrXMLBlob, TEXT_TAG_UPLOADINFO, fLoaded, &fFound ));
    if(fLoaded == false ||
       fFound  == false  )
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_OPEN_FAILED);
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, LoadFromXMLObject( xmldocIncident ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

// *************************************************************************

// If this object contains a valid SALEM session id, then we should close that session.
STDMETHODIMP CSAFIncident::CloseRemoteAssistanceIncident()
{
    __HCP_FUNC_ENTRY("CSAFIncident::CloseRemoteAssistanceIncident");

    HRESULT     hr;
    REMOTE_DESKTOP_SHARING_CLASS  sharingClass  = VIEWDESKTOP_PERMISSION_NOT_REQUIRE;
    
    CComBSTR pRcTicket;
    CComBSTR pNull;
    CComPtr<ISAFRemoteDesktopSession> pSession;
    CComPtr<IClassFactory> fact;
    CComQIPtr<IPCHUtility> disp;
 
    __MPC_EXIT_IF_METHOD_FAILS(hr, get_RCTicket(&pRcTicket));
    
    if (pRcTicket.Length() == 0)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }

    //
    // This is handled in a special way.
    //
    // We QI the PCHSVC broker and then forward the call to it.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoGetClassObject( CLSID_PCHService, CLSCTX_ALL, NULL, IID_IClassFactory, (void**)&fact ));
 
    if((disp = fact))
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, disp->CreateObject_RemoteDesktopSession( sharingClass, 0, (BSTR)pRcTicket, (BSTR)pNull, &pSession));
    }
    else
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_NOINTERFACE);
    }
 
	__MPC_EXIT_IF_METHOD_FAILS(hr, pSession->CloseRemoteDesktopSession());

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\incidentobject\unittest\ioutest.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    ioutest.cpp

Abstract:
    incident object unit test

Revision History:
    DerekM  created  07/14/99

********************************************************************/

#include <module.h>
 
#include <MPC_utils.h>
#include <MPC_com.h>
#include <MPC_streams.h>

#include <stdio.h>

#include "HelpServiceTypeLib.h"
#include "HelpServiceTypeLib_i.c"

#include "HelpCenterTypeLib.h"
#include "HelpCenterTypeLib_i.c"

#include "hsi.h"

#include <initguid.h>
#include <msscript.h>

#include <incident.h>


// **************************************************************************
int __cdecl wmain(int argc, WCHAR **argv, WCHAR **envp)
{   
    CComObject<MPC::FileStream> *pfsHist = NULL;
    CComObject<MPC::FileStream> *pfsSnap = NULL;
    CComObject<CHSC>            *phsc = NULL;
    IDictionary                 *pDict = NULL;
    CComObject<CSAFIncident>    *pIO = NULL;
    IDispatch                   *pdisp = NULL;
    CComBSTR                    bstrFile;
    CComBSTR                    bstr;
    CComBSTR                    bstrVal, bstrKey;
    VARIANT                     varVal, varKey;


    VARIANT_BOOL                fRCReq = VARIANT_TRUE;
	VARIANT_BOOL                fRCReqRet;

	CComBSTR                    bstrRCTicket, bstrRCTicket1;
	CComBSTR                    bstrStartPage, bstrStartPage1;

	CComBSTR                    bstrXMLBlob;


    HRESULT hr = NOERROR;

    if (argc < 2)
    {
        printf("Usage: ioutest <save | load | getxml>\n\n");
        return E_FAIL;
    }

    hr = CoInitialize(NULL);
    if (FAILED(hr))
        return hr;

    hr = CComObject<CSAFIncident>::CreateInstance(&pIO);
    if (FAILED(hr))
        goto done;

    hr = CComObject<MPC::FileStream>::CreateInstance(&pfsHist);
    if (FAILED(hr))
        goto done;

    hr = CComObject<MPC::FileStream>::CreateInstance(&pfsSnap);
    if (FAILED(hr))
        goto done;

    pfsHist->AddRef();
    pfsSnap->AddRef();

	bstrFile = L"d:\\incident.xml";

	hr = pIO->LoadFromXMLFile(bstrFile);

	bstrXMLBlob = L"<?xml version=\"1.0\" encoding=\"Unicode\"?><UPLOADINFO TYPE=\"Bug\"><UPLOADDATA USERNAME=\"Rajesh\" PROBLEMDESCRIPTION=\"Test Description\" RCTICKET=\"1,nsoytest1,HelpAssistant,90!4SbO7NTfN4v,1,TSRDP0,ht^5GmLrR2SKwI,0\" RCREQUESTED=\"1\" RCENCRYPTED=\"1\" SALEMID=\"1,nsoytest1,HelpAssistant,90!4SbO7NTfN4v,1,TSRDP0,ht^5GmLrR2SKwI,0\"/></UPLOADINFO>";

	hr = pIO->LoadFromXMLString(bstrXMLBlob);

	/*

	// Get the dictionary stuff
    hr = pIO->get_Misc(&pdisp);
    if (FAILED(hr))
        goto done;

    hr = pdisp->QueryInterface(IID_IDictionary, (LPVOID *)&pDict);
    if (FAILED(hr))
        goto done;

   // Read the contents of the dictionary object here...

    if(pDict)
    {
		VARIANT                varKey;
        VARIANT                varValue;

		VariantInit(&varKey);
		VariantInit(&varValue);

		V_VT(&varKey) = VT_BSTR;
		V_BSTR(&varKey) = L"USERNAME";
        hr = pDict->get_Item( &varKey, &varValue );

		V_VT(&varKey) = VT_BSTR;
		V_BSTR(&varKey) = L"PROBLEMDESCRIPTION";
        hr = pDict->get_Item( &varKey, &varValue );

		V_VT(&varKey) = VT_BSTR;
		V_BSTR(&varKey) = L"SALEMID";
        hr = pDict->get_Item( &varKey, &varValue );
        
    }
	*/

	
    // add machine history stream
    bstrFile = L"d:\\hist.xml";
    hr = pfsHist->InitForRead( bstrFile );
    if (FAILED(hr))
        goto done;

    hr = pIO->put_MachineHistory(pfsHist);
    if (FAILED(hr))
        goto done;

    // add machine snapshot stream
    bstrFile = L"d:\\snap.xml";
    hr = pfsSnap->InitForRead( bstrFile );
    if (FAILED(hr))
        goto done;

    hr = pIO->put_MachineSnapshot(pfsSnap);
    if (FAILED(hr))
        goto done;

    // add problem description
    bstr = L"It doesn't work at all";
    hr = pIO->put_ProblemDescription(bstr);
    if (FAILED(hr))
        goto done;

    // add product name
    bstr = L"NonFunctionality 1.0";
    hr = pIO->put_ProductName(bstr);
    if (FAILED(hr))
        goto done;

    // add product id
    bstr = L"NF10";
    hr = pIO->put_ProductID(bstr);
    if (FAILED(hr))
        goto done;

    // add username
    bstr = L"Jim Bob Robberts";
    hr = pIO->put_UserName(bstr);
    if (FAILED(hr))
        goto done;

    // add upload type
    hr = pIO->put_UploadType(eutBug);
    if (FAILED(hr))
        goto done;

	// add the dictionary stuff
    hr = pIO->get_Misc(&pdisp);
    if (FAILED(hr))
        goto done;

    hr = pdisp->QueryInterface(IID_IDictionary, (LPVOID *)&pDict);
    if (FAILED(hr))
        goto done;

    VariantInit(&varKey);
    VariantInit(&varVal);
    V_VT(&varKey) = VT_BSTR;
    V_VT(&varVal) = VT_BSTR;

    bstrKey = L"Title";
    bstrVal = L"Exploding windows";
    V_BSTR(&varKey) = bstrKey.m_str;
    V_BSTR(&varVal) = bstrVal.m_str;
    hr = pDict->put_Item(&varKey, &varVal);
    if (FAILED(hr))
        goto done;

    bstrKey = L"Severity";
    bstrVal = L"Really Bad";
    V_BSTR(&varKey) = bstrKey.m_str;
    V_BSTR(&varVal) = bstrVal.m_str;
    hr = pDict->put_Item(&varKey, &varVal);
    if (FAILED(hr))
        goto done;

    bstrKey = L"Area";
    bstrVal = L"Windows";
    V_BSTR(&varKey) = bstrKey.m_str;
    V_BSTR(&varVal) = bstrVal.m_str;
    hr = pDict->put_Item(&varKey, &varVal);
    if (FAILED(hr))
        goto done;

    bstrKey = L"ExpectedResults";
    bstrVal = L"It just works!";
    V_BSTR(&varKey) = bstrKey.m_str;
    V_BSTR(&varVal) = bstrVal.m_str;
    hr = pDict->put_Item(&varKey, &varVal);
    if (FAILED(hr))
        goto done;

    bstrKey = L"ReproSteps";
    bstrVal = L"Turn on computer.  Watch it explode.";
    V_BSTR(&varKey) = bstrKey.m_str;
    V_BSTR(&varVal) = bstrVal.m_str;
    hr = pDict->put_Item(&varKey, &varVal);
    if (FAILED(hr))
        goto done;

    // add the trace stuff
    hr = CComObject<CHSC>::CreateInstance(&phsc);
    if (FAILED(hr))
        goto done;

    //hr = pIO->put_SelfHelpTrace(phsc);
    //if (FAILED(hr))
        //goto done;

	// Add the new RC properties.

	// add RCRequested
    hr = pIO->put_RCRequested(fRCReq);
    if (FAILED(hr))
        goto done;

	hr = pIO->get_RCRequested(&fRCReqRet);
    if (FAILED(hr))
        goto done;

	// add RCTicketEncrypted
    hr = pIO->put_RCTicketEncrypted(fRCReq);
    if (FAILED(hr))
        goto done;

	hr = pIO->get_RCTicketEncrypted(&fRCReqRet);
    if (FAILED(hr))
        goto done;

	
	bstrRCTicket = L"This is the RCTicket";

	// Add RCTicket
    hr = pIO->put_RCTicket(bstrRCTicket);
    if (FAILED(hr))
        goto done;

	hr = pIO->get_RCTicket(&bstrRCTicket1);
    if (FAILED(hr))
        goto done;

	// add startpage
    bstrStartPage = L"http://startpage.htm";

    hr = pIO->put_StartPage(bstrStartPage);
    if (FAILED(hr))
        goto done;

	hr = pIO->get_StartPage(&bstrStartPage1);
    if (FAILED(hr))
        goto done;


    // dump the output
    switch(argv[1][0])
    {
        case 'L':
        case 'l': 
            bstrFile = "d:\\out.sav";
            hr = pIO->Load(bstrFile);
            if (FAILED(hr))
                goto done;

            bstrFile = "d:\\out.xml";
            hr = pIO->GetXML(bstrFile);
            if (FAILED(hr))
                goto done;
            
            break;

        case 'S':
        case 's':
            bstrFile = "d:\\out.sav";
            hr = pIO->Save(bstrFile);
            if (FAILED(hr))
                goto done;
            
            break;


        case 'G':
        case 'g':
            bstrFile = "d:\\out.xml";
            hr = pIO->GetXML(bstrFile);
            if (FAILED(hr))
                goto done;
            
            break;

        default:
            printf("Usage: ioutest <save | load | getxml>\n\n");
            hr = E_INVALIDARG;
            break;
    }

    
done:
    if (pfsHist != NULL)
        pfsHist->Release();
    if (pfsSnap != NULL)
        pfsSnap->Release();
    if (pDict != NULL)
        pDict->Release();
    if (pdisp != NULL)
        pdisp->Release();
    if (pIO != NULL)
        pIO->Release();
    CoUninitialize();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\remotedesktopmanager\safremotedesktopmanager.h ===
// SAFRemoteDesktopManager.h : Declaration of the CSAFRemoteDesktopManager

#ifndef __SAFREMOTEDESKTOPMANAGER_H_
#define __SAFREMOTEDESKTOPMANAGER_H_

#include "resource.h"       // main symbols

#define BUF_SZ 512

/////////////////////////////////////////////////////////////////////////////
// CSAFRemoteDesktopManager
class ATL_NO_VTABLE CSAFRemoteDesktopManager : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSAFRemoteDesktopManager, &CLSID_SAFRemoteDesktopManager>,
	public IDispatchImpl<ISAFRemoteDesktopManager, &IID_ISAFRemoteDesktopManager, &LIBID_ISAFRDMLib>
{
public:
	CSAFRemoteDesktopManager()
	{
		WCHAR	*lpBuf=NULL;
		DWORD	dwCnt;
		WCHAR	buf1[BUF_SZ];

		m_bstrSupportEngineer = L""; 

		dwCnt = GetEnvironmentVariable(L"PCHUSERBLOB", buf1, BUF_SZ);
		if (!dwCnt)
			m_bstruserSupportBlob = L""; 
		else if (dwCnt <= BUF_SZ)
			m_bstruserSupportBlob = buf1;
		else
		{
			lpBuf = (WCHAR *)LocalAlloc(LPTR, dwCnt * sizeof(WCHAR));
			GetEnvironmentVariable(L"PCHUSERBLOB", lpBuf, dwCnt);
			m_bstruserSupportBlob = lpBuf;
			LocalFree(lpBuf);
			lpBuf = NULL;
		}

		dwCnt = GetEnvironmentVariable(L"PCHEXPERTBLOB", buf1, BUF_SZ);
		if (!dwCnt)
			m_bstrexpertSupportBlob = L""; 
		else if (dwCnt <= BUF_SZ)
			m_bstrexpertSupportBlob = buf1;
		else
		{
			lpBuf = (WCHAR *)LocalAlloc(LPTR, dwCnt * sizeof(WCHAR));
			GetEnvironmentVariable(L"PCHEXPERTBLOB", lpBuf, dwCnt);
			m_bstrexpertSupportBlob = lpBuf;
			LocalFree(lpBuf);
			lpBuf = NULL;
		}
		
		dwCnt = GetEnvironmentVariable(L"PCHCONNECTPARMS", buf1, BUF_SZ);
		if (!dwCnt)
			m_bstrRCTicket = L""; 
		else if (dwCnt <= BUF_SZ)
			m_bstrRCTicket = buf1;
		else
		{
			lpBuf = (WCHAR *)LocalAlloc(LPTR, dwCnt * sizeof(WCHAR));
			GetEnvironmentVariable(L"PCHCONNECTPARMS", lpBuf, dwCnt);
			m_bstrRCTicket = lpBuf;
			LocalFree(lpBuf);
			lpBuf = NULL;
		}

		dwCnt = GetEnvironmentVariable(L"PCHSESSIONENUM", buf1, BUF_SZ);
		if (!dwCnt)
			m_bstrSessionEnum = L""; 
		else if (dwCnt <= BUF_SZ)
			m_bstrSessionEnum = buf1;
		else
		{
			lpBuf = (WCHAR *)LocalAlloc(LPTR, dwCnt * sizeof(WCHAR));
			GetEnvironmentVariable(L"PCHSESSIONENUM", lpBuf, dwCnt);
			m_bstrSessionEnum = lpBuf;
			LocalFree(lpBuf);
			lpBuf = NULL;
		}

		dwCnt = GetEnvironmentVariable(L"PCHEVENTNAME", buf1, BUF_SZ);
		if (!dwCnt)
			m_bstrEventName = L""; 
		else if (dwCnt <= BUF_SZ)
			m_bstrEventName = buf1;
		else
		{
			lpBuf = (WCHAR *)LocalAlloc(LPTR, dwCnt * sizeof(WCHAR));
			GetEnvironmentVariable(L"PCHEVENTNAME", lpBuf, dwCnt);
			m_bstrEventName = lpBuf;
			LocalFree(lpBuf);
			lpBuf = NULL;
		}

		dwCnt = GetEnvironmentVariable(L"PCHMutexName", buf1, BUF_SZ);
		if (!dwCnt)
			m_bstrMutexName = L""; 
		else if (dwCnt <= BUF_SZ)
			m_bstrMutexName = buf1;
		else
		{
			lpBuf = (WCHAR *)LocalAlloc(LPTR, dwCnt * sizeof(WCHAR));
			GetEnvironmentVariable(L"PCHMutexName", lpBuf, dwCnt);
			m_bstrMutexName = lpBuf;
			LocalFree(lpBuf);
			lpBuf = NULL;
		}

		m_boolConnectionValid = TRUE;
		m_boolDesktopUnknown = FALSE;
		m_boolAcceptReserved = FALSE;
	}

	~CSAFRemoteDesktopManager()
	{
		m_bstrRCTicket.Empty();
		m_bstrSupportEngineer.Empty();
		m_bstruserSupportBlob.Empty();
		m_bstrexpertSupportBlob.Empty();
		m_bstrSessionEnum.Empty();
		m_bstrEventName.Empty();
		m_bstrMutexName.Empty();
	}

DECLARE_REGISTRY_RESOURCEID(IDR_SAFREMOTEDESKTOPMANAGER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSAFRemoteDesktopManager)
	COM_INTERFACE_ENTRY(ISAFRemoteDesktopManager)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ISAFRemoteDesktopManager
public:
	STDMETHOD(get_userHelpBlob)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_expertHelpBlob)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_SupportEngineer)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_DesktopUnknown)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(get_RCTicket)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(Aborted)(/*[in]*/ BSTR Val);
	STDMETHOD(Rejected)();
	STDMETHOD(Accepted)();
	STDMETHOD(ReserveAcceptedLock)();
	STDMETHOD(SwitchDesktopMode)(/*[in]*/ int Mode, /*[in]*/ int nRAType);
private:
	CComBSTR m_bstrMutexName;
	CComBSTR m_bstrEventName;
	CComBSTR m_bstrSessionEnum;
	CComBSTR m_bstrSupportEngineer;
	CComBSTR m_bstruserSupportBlob;
	CComBSTR m_bstrexpertSupportBlob;
	CComBSTR m_bstrRCTicket;
	BOOL m_boolConnectionValid;
	BOOL m_boolDesktopUnknown;
	BOOL m_boolAcceptReserved;
//	HRESULT SignalResolver(BOOL yn);
};

#endif //__SAFREMOTEDESKTOPMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\remotedesktopmanager\safremotedesktopmanager.cpp ===
// SAFRemoteDesktopManager.cpp : Implementation of CSAFRemoteDesktopManager
#include "stdafx.h"
#include "SAFrdm.h"
#include "SAFRemoteDesktopManager.h"

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>
#include "helpservicetypelib_i.c"

#include <MPC_COM.h>
#include <MPC_utils.h>
#include <MPC_trace.h>

#define MODULE_NAME	L"SAFrdm"

/////////////////////////////////////////////////////////////////////////////
// CSAFRemoteDesktopManager


STDMETHODIMP CSAFRemoteDesktopManager::ReserveAcceptedLock()
{
	HRESULT hr=E_FAIL;
	DWORD dwR;
    HANDLE  hMutex = NULL, hEvent = NULL;

	/*
	 *  Signal the session resolver
	 */
	if (!m_bstrEventName.Length() || !m_bstrMutexName.Length() )
	{
		// if we got here, the environment is missing our event name
		// so mention it with our ret val...
		hr = E_INVALIDARG;
		goto done;
	}


	/*
	 * Open the handles we got from the resolver, and yank it
	 */
	hMutex = OpenMutex(SYNCHRONIZE, FALSE, m_bstrMutexName);
	hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, m_bstrEventName);

	if (!hEvent || !hMutex)
	{
        // only close the mutex here!
	    if (hMutex)
		    CloseHandle(hMutex);

        hr = E_HANDLE;
		goto done;
	}

	/*
	 *	Now see if this is the first session to click "yes"
	 *	If so, we can have the Mutex.
	 */
	dwR = WaitForSingleObject(hMutex, 0);
	if (dwR == WAIT_OBJECT_0)
	{
		SetEvent(hEvent);
		hr = S_OK;
		m_boolAcceptReserved = TRUE;
	}
	else if (dwR == WAIT_ABANDONED)
	{
		hr = E_OUTOFMEMORY;
	}
	else if (dwR == WAIT_TIMEOUT)
	{
		hr = E_OUTOFMEMORY;
	}
	else if (dwR == WAIT_FAILED)
	{
		// If we didn't get the mutex, then close the handle
		hr = E_ACCESSDENIED;
	}
	else
	{
		hr = E_UNEXPECTED;
	}

done:
	// close the event handle, but NOT the mutex handle
	if (hEvent)
		CloseHandle(hEvent);
        if (hMutex)
		CloseHandle(hMutex);
	return hr;
}

STDMETHODIMP CSAFRemoteDesktopManager::Accepted()
{
	HRESULT hr = E_FAIL;

	if (!m_boolAcceptReserved)
	{
		hr = E_UNEXPECTED;
		goto done;
	}

	/*
	 *  Signal the session resolver
	 */
	if (!m_bstrEventName.Length())
	{
		// if we got here, the environment is missing our event name
		// so mention it with our ret val...
		hr = E_INVALIDARG;
		goto done;
	}

	/*
	 * Open the handle we got from the resolver, and yank it
	 */
	HANDLE hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, m_bstrEventName);

	if (hEvent)
	{
		/* this is the call to the resolver that tells it we are now ready to begin RA */
		SetEvent(hEvent);
		hr = S_OK;
		CloseHandle(hEvent);
	}
	else
		hr = E_HANDLE;
done:
	return hr;
}

STDMETHODIMP CSAFRemoteDesktopManager::Rejected()
{
	return S_OK;
}

STDMETHODIMP CSAFRemoteDesktopManager::Aborted(BSTR reason)
{
	/*
	 *  Write out an NT Event with the "reason" in it.
	 */
	HANDLE	hEvent = RegisterEventSource(NULL, MODULE_NAME);
	LPCWSTR	ArgsArray[1]={reason};

	if (hEvent)
	{
		ReportEvent(hEvent, EVENTLOG_INFORMATION_TYPE, 
			0,
			SAFRDM_I_ABORT,
			NULL,
			1,
			0,
			ArgsArray,
			NULL);

		DeregisterEventSource(hEvent);
	}

	return S_OK;
}

STDMETHODIMP CSAFRemoteDesktopManager::SwitchDesktopMode(/*[in]*/ int nMode, /*[in]*/ int nRAType)
{

	__MPC_FUNC_ENTRY(COMMONID, "CSAFRemoteDesktopManager::SwitchDesktopMode" );


	HRESULT                          hr=E_FAIL;
	CComPtr<IClassFactory> fact;
	CComQIPtr<IPCHUtility> disp;


	//
	// This is handled in a special way.
	//
	// Instead of using the implementation inside HelpCtr, we QI the PCHSVC broker and then forward the call to it.
	//

   	__MPC_EXIT_IF_METHOD_FAILS(hr, ::CoGetClassObject( CLSID_PCHService, CLSCTX_ALL, NULL, IID_IClassFactory, (void**)&fact ));
	
	if((disp = fact))
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, disp->SwitchDesktopMode (nMode, nRAType));

	}
	else
	{
		__MPC_SET_ERROR_AND_EXIT(hr, E_NOINTERFACE);
	}

	hr = S_OK;

	__MPC_FUNC_CLEANUP;
	
    __MPC_FUNC_EXIT(hr);
	
}

STDMETHODIMP CSAFRemoteDesktopManager::get_RCTicket(BSTR *pVal)
{
 
	if (!pVal)
		return E_INVALIDARG;

	*pVal = m_bstrRCTicket.Copy();
 
	return S_OK;
}

STDMETHODIMP CSAFRemoteDesktopManager::get_DesktopUnknown(BOOL *pVal)
{
	if (!pVal)
		return E_INVALIDARG;

	*pVal = m_boolDesktopUnknown;

	return S_OK;
}

STDMETHODIMP CSAFRemoteDesktopManager::get_SupportEngineer(BSTR *pVal)
{
	if (!pVal)
		return E_INVALIDARG;

	*pVal = m_bstrSupportEngineer.Copy();

	return S_OK;
}


STDMETHODIMP CSAFRemoteDesktopManager::get_userHelpBlob(BSTR *pVal)
{
	if (!pVal)
		return E_INVALIDARG;

	*pVal = m_bstruserSupportBlob.Copy();

	return S_OK;
}

STDMETHODIMP CSAFRemoteDesktopManager::get_expertHelpBlob(BSTR *pVal)
{
	if (!pVal)
		return E_INVALIDARG;

	*pVal = m_bstrexpertSupportBlob.Copy();

	return S_OK;
}

#if 0
HRESULT CSAFRemoteDesktopManager::SignalResolver(BOOL yn)
{
	HRESULT hr = E_FAIL;

	if (yn)
	{
		if (!m_bstrEventName.Length())
		{
			// if we got here, the environment is missing our event name
			// so mention it with our ret val...
			hr = E_HANDLE;
			goto done;
		}

		/*
		 * Open the handle we got from the resolver, and yank it
		 */
		HANDLE hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, m_bstrEventName);

		if (hEvent)
		{
			if (!m_boolResolverSignaled)
			{
				/* This is the call to tell the resolver that we WANT to start RA */
				DWORD dwResult = SignalObjectAndWait(hEvent, hEvent, 60000, FALSE);
				if (dwResult == WAIT_OBJECT_0)
					hr = S_OK;
				else
					/* If the resolver does not respond within 60 seconds, then another
					 * session got in just ahead of you...
					 */
					hr = E_ACCESSDENIED;
			}
			else
			{
				/* this is the call to the resolver that tells it we are now ready to begin RA */
				SetEvent(hEvent);
				hr = S_OK;
			}
			CloseHandle(hEvent);
		}
	}
	else
	{
		/*
		 * Do nothing, as the script will kill the HelpCtr window
		 */
		hr = S_OK;
	}

done:
	// tell the ~dtor we don't need it to signal the resolver
	m_boolResolverSignaled = TRUE;
	return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\unsolicitedrc\lib\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__30D1B1B5_A051_4060_BCFB_82B33E161130__INCLUDED_)
#define AFX_STDAFX_H__30D1B1B5_A051_4060_BCFB_82B33E161130__INCLUDED_

#include <module.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#include <MPC_utils.h>
#include <MPC_COM.h>
#include <MPC_streams.h>
#include <MPC_trace.h>
#include <HCP_trace.h>
#include <wtsapi32.h>
#include <winsta.h>

#include <Utility.h>

#include <SvcUtils.h>

#include "msscript.h"

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

//
// From HelpCenterTypeLib.idl
//
#include <HelpCenterTypeLib.h>

#include <UnsolicitedRC.h>

#endif // !defined(AFX_STDAFX_H__30D1B1B5_A051_4060_BCFB_82B33E161130__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\unsolicitedrc\lib\remoteconnectiondata.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    RemoteConnectionData.cpp

Abstract:
    SAFRemoteConnectionData Object

Revision History:
    KalyaninN  created  09/29/'00

********************************************************************/

// RemoteConnectionData.cpp : Implementation of CSAFRemoteConnectionData

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////
// CSAFRemoteConnectionData

/////////////////////////////////////////////////////////////////////////////
//  construction / destruction

// **************************************************************************
CSAFRemoteConnectionData::CSAFRemoteConnectionData()
{
    m_NumSessions      = 0;    // long              m_NumSessions;
    m_SessionInfoTable = NULL; // SSessionInfoItem* m_SessionInfoTable;
                               // CComBSTR          m_bstrServerName;
}

// **************************************************************************
CSAFRemoteConnectionData::~CSAFRemoteConnectionData()
{
    Cleanup();
}

// **************************************************************************

// **************************************************************************
void CSAFRemoteConnectionData::Cleanup()
{
    delete [] m_SessionInfoTable; m_SessionInfoTable = NULL;
}

HRESULT CSAFRemoteConnectionData::InitUserSessionsInfo( /*[in]*/ BSTR bstrServerName )
{
    __HCP_FUNC_ENTRY( "CSAFRemoteConnectionData::InitUserSessionsInfo" );

    HRESULT                 hr;
    MPC::Impersonation      imp;
    CComPtr<IPCHService>    svc;
    COSERVERINFO            si; ::ZeroMemory( &si, sizeof( si ) );
    MULTI_QI                qi; ::ZeroMemory( &qi, sizeof( qi ) );
    CComPtr<IPCHCollection> pColl;
    CComQIPtr<ISAFSession>  pSession;
    SSessionInfoItem*       ptr;
    int                     i;


    m_bstrServerName = bstrServerName;


    __MPC_EXIT_IF_METHOD_FAILS(hr, imp.Initialize ());
    __MPC_EXIT_IF_METHOD_FAILS(hr, imp.Impersonate());

    // Connect to the Server represented by bstrServerName.
    si.pwszName = (LPWSTR)m_bstrServerName;
    qi.pIID     = &IID_IPCHService;

    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateInstanceEx( CLSID_PCHService, NULL, CLSCTX_REMOTE_SERVER, &si, 1, &qi ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, qi.hr);
    svc.Attach( (IPCHService*)qi.pItf );

    __MPC_EXIT_IF_METHOD_FAILS(hr, svc->RemoteUserSessionInfo( &pColl ));


    //Transfer the contents of the collection to the internal member structure.
    __MPC_EXIT_IF_METHOD_FAILS(hr, pColl->get_Count( &m_NumSessions));

    // Allocate Memory for the Session Info Table.
    __MPC_EXIT_IF_ALLOC_FAILS(hr, m_SessionInfoTable, new SSessionInfoItem[m_NumSessions]);

    for(i=0, ptr=m_SessionInfoTable; i<(int)m_NumSessions; i++, ptr++)
    {
        CComVariant cvVarSession;

        //
        // Get the item
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, pColl->get_Item( i+1, &cvVarSession ));
        if(cvVarSession.vt != VT_DISPATCH) continue;

        pSession = cvVarSession.pdispVal;

        //
        // Read the data from the Session Item Object.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, pSession->get_SessionID   ( &(ptr->dwSessionID    ) ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, pSession->get_SessionState( &(ptr->wtsConnectState) ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, pSession->get_UserName    ( &(ptr->bstrUser       ) ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, pSession->get_DomainName  ( &(ptr->bstrDomain     ) ));
    }

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CSAFRemoteConnectionData::Populate( /*[in]*/ CPCHCollection* pColl )
{
    __HCP_FUNC_ENTRY( "CSAFRemoteConnectionData::Populate" );

    static const DWORD c_dwTSSessionID = 65536; // This is the session that TS uses to Listen.

    HRESULT                hr;
    SessionStateEnum       wtsConnectState;
    WINSTATIONINFORMATIONW WSInfo;
    PWTS_SESSION_INFOW     pSessionInfo       = NULL;
    PWTS_SESSION_INFOW     ptr;
    DWORD                  dwSessions;
    DWORD                  dwPos;
	BOOL                   fSucc;
	BOOL                   fIsHelpAssistant;
	
    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pColl);
    __MPC_PARAMCHECK_END();



    //
    // Start with WTSEnumerateSessions,
    // get all sessions whether active or not,
    // get sessions for all logonIDs,
    // then use WinStationQueryInformation to get the logged on users username, domainname
    //
    if(!::WTSEnumerateSessionsW( WTS_CURRENT_SERVER_HANDLE, /*dwReserved*/0, /*dwVersion*/1, &pSessionInfo, &dwSessions ) || !pSessionInfo)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ::GetLastError());
    }

    for(dwPos=0, ptr=pSessionInfo; dwPos < dwSessions; dwPos++, ptr++)
    {
        DWORD dwCurrentSessionID = ptr->SessionId;
        DWORD dwRetSize;

        ::ZeroMemory( &WSInfo, sizeof(WSInfo) );

        // Do not include the session that TS uses to listen, with SessionID 65536 and SessionState pchListen
        if(dwCurrentSessionID == c_dwTSSessionID) continue;

        // Do not include the disconnected sessions.
        if(ptr->State == WTSDisconnected) continue;

		// Do not include the idle sessions.  Fix for bug 363824.
        if(ptr->State == WTSIdle) continue;

		// Exclude the Help Assistant account. This can get included only when there are two instances of Unsolicited RA. 
		// When the first instance, shadows the session and the second instance enumerates the sessions, "Help Assistant Session"
		// is included in the second.

		fIsHelpAssistant = WinStationIsHelpAssistantSession(SERVERNAME_CURRENT, dwCurrentSessionID);

		if(fIsHelpAssistant)
			continue;

        fSucc = WinStationQueryInformationW( SERVERNAME_CURRENT, dwCurrentSessionID, WinStationInformation, &WSInfo, sizeof(WSInfo), &dwRetSize );

		if(!fSucc)
			continue;

		// Bug 454497 - Do not include blank user names.
		if((StrCmpI(WSInfo.UserName, L"") == 0))
			continue;

		// Fill up the SessionInfoTable with details.
		switch(ptr->State)
		{
		case WTSActive      : wtsConnectState = pchActive;       break;
		case WTSConnected   : wtsConnectState = pchConnected;    break;
		case WTSConnectQuery: wtsConnectState = pchConnectQuery; break;
		case WTSShadow      : wtsConnectState = pchShadow;       break;
		case WTSListen      : wtsConnectState = pchListen;       break;
		case WTSReset       : wtsConnectState = pchReset;        break;
		case WTSDown        : wtsConnectState = pchDown;         break;
		case WTSInit        : wtsConnectState = pchInit;         break;
		default             : wtsConnectState = pchStateInvalid; break;
		}
		
        {
            CComPtr<CSAFSession> pItem;

            __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pItem ));

			pItem->put_SessionID   ( dwCurrentSessionID );
			pItem->put_UserName    ( WSInfo.UserName    );
			pItem->put_DomainName  ( WSInfo.Domain      );
			pItem->put_SessionState( wtsConnectState    );
			
            __MPC_EXIT_IF_METHOD_FAILS(hr, pColl->AddItem( pItem ));
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    /* free the memory we asked for */
    if(pSessionInfo) ::WTSFreeMemory( pSessionInfo );

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
// CSAFRemoteConnectionData  Methods

STDMETHODIMP CSAFRemoteConnectionData::Users( /*[out,retval]*/ IPCHCollection* *ppUsers )
{
    __HCP_FUNC_ENTRY( "CSAFRemoteConnectionData::Users" );

    HRESULT                 hr;
    CComPtr<CPCHCollection> pColl;
    BSTR                    bstrPrevUser   = NULL;
    BSTR                    bstrPrevDomain = NULL;
    SSessionInfoItem*       ptr;
    int                     i;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(ppUsers,NULL);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pColl ));

    // Each user can be logged to multiple sessions,
    // so there will be repeated usernames with different session IDs
    // in the Session Table. While returning the users in the collection,
    // remove the duplicate username entries.
    for(i=0, ptr = m_SessionInfoTable; i<(int)m_NumSessions; i++, ptr++)
    {
        BSTR bstrUser   = ptr->bstrUser;
        BSTR bstrDomain = ptr->bstrDomain;

        /*if(MPC::StrICmp( ptr->bstrUser  , bstrPrevUser   ) != 0 &&
           MPC::StrICmp( ptr->bstrDomain, bstrPrevDomain ) != 0  )
		*/
		if(MPC::StrICmp( ptr->bstrDomain, bstrPrevDomain )== 0)
		{
			if(MPC::StrICmp( ptr->bstrUser, bstrPrevUser )== 0)
			{
				// Do Not Include this session.
			}
			else
			{
				CComPtr<CSAFUser> pItem;

				__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pItem ));

				__MPC_EXIT_IF_METHOD_FAILS(hr, pItem->put_UserName  ( bstrUser   ));
				__MPC_EXIT_IF_METHOD_FAILS(hr, pItem->put_DomainName( bstrDomain ));

				__MPC_EXIT_IF_METHOD_FAILS(hr, pColl->AddItem( pItem ));

				bstrPrevUser   = bstrUser;
				bstrPrevDomain = bstrDomain;
			}

		}
		else
        {
            CComPtr<CSAFUser> pItem;

            __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pItem ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, pItem->put_UserName  ( bstrUser   ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, pItem->put_DomainName( bstrDomain ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, pColl->AddItem( pItem ));

            bstrPrevUser   = bstrUser;
            bstrPrevDomain = bstrDomain;
        }
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, pColl.QueryInterface( ppUsers ));


    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CSAFRemoteConnectionData::Sessions( /*[in,optional]*/ VARIANT          vUser      ,
                                                 /*[in,optional]*/ VARIANT          vDomain    ,
                                                 /*[out,retval ]*/ IPCHCollection* *ppSessions )
{
    __HCP_FUNC_ENTRY( "CSAFRemoteConnectionData::Sessions" );

    HRESULT                 hr;
    CComPtr<CPCHCollection> pColl;
    SSessionInfoItem*       ptr;
    int                     i;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(ppSessions,NULL);
    __MPC_PARAMCHECK_END();

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pColl ));

    for(i=0, ptr = m_SessionInfoTable; i<(int)m_NumSessions; i++, ptr++)
    {
        if((vUser  .vt != VT_BSTR || MPC::StrICmp( vUser  .bstrVal, ptr->bstrUser   ) != 0) &&
           (vDomain.vt != VT_BSTR || MPC::StrICmp( vDomain.bstrVal, ptr->bstrDomain ) != 0)  )
        {
            CComPtr<CSAFSession> pItem;

            __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pItem ));

            pItem->put_UserName    ( ptr->bstrUser        );
            pItem->put_DomainName  ( ptr->bstrDomain      );
            pItem->put_SessionID   ( ptr->dwSessionID     );
            pItem->put_SessionState( ptr->wtsConnectState );

            __MPC_EXIT_IF_METHOD_FAILS(hr, pColl->AddItem( pItem ));
        }
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, pColl.QueryInterface( ppSessions ));


    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CSAFRemoteConnectionData::ConnectionParms( /*[in ]*/ BSTR  bstrServerName       ,
                                                        /*[in ]*/ BSTR  bstrUserName         ,
                                                        /*[in ]*/ BSTR  bstrDomainName       ,
                                                        /*[in ]*/ long  lSessionID           ,
														/*[in ]*/ BSTR  bstrUserHelpBlob     ,
                                                        /*[out]*/ BSTR *bstrConnectionString )
{
    __HCP_FUNC_ENTRY( "CSAFRemoteConnectionData::ConnectionParms" );

    HRESULT              hr;
    MPC::Impersonation   imp;
    CComPtr<IPCHService> svc;
    COSERVERINFO         si; ::ZeroMemory( &si, sizeof( si ) );
    MULTI_QI             qi; ::ZeroMemory( &qi, sizeof( qi ) );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(bstrConnectionString,NULL);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, imp.Initialize ());
    __MPC_EXIT_IF_METHOD_FAILS(hr, imp.Impersonate());

    // Connect to the Server represented by bstrServerName.
    si.pwszName = (LPWSTR)bstrServerName;
    qi.pIID     = &IID_IPCHService;

    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateInstanceEx( CLSID_PCHService, NULL, CLSCTX_REMOTE_SERVER, &si, 1, &qi ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, qi.hr);
    svc.Attach( (IPCHService*)qi.pItf );

    // Invoke the method on the IPCHService that invokes the Salem API on the Remote Server.
    __MPC_EXIT_IF_METHOD_FAILS(hr, svc->RemoteConnectionParms( bstrUserName, bstrDomainName, lSessionID, bstrUserHelpBlob, bstrConnectionString ));


    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

// Bug 456403

STDMETHODIMP CSAFRemoteConnectionData::ModemConnected( /*[in ]*/ BSTR  bstrServerName       ,
													   /*[out]*/ VARIANT_BOOL *fModemConnected )
{

	__HCP_FUNC_ENTRY( "CSAFRemoteConnectionData::ModemConnected" );

	HRESULT              hr;
    MPC::Impersonation   imp;
    CComPtr<IPCHService> svc;
    COSERVERINFO         si; ::ZeroMemory( &si, sizeof( si ) );
    MULTI_QI             qi; ::ZeroMemory( &qi, sizeof( qi ) );

	CComPtr<IDispatch>   pDisp;
	DISPID               dispid;
	LPWSTR               szMember = L"RemoteModemConnected";

	VARIANT              varResult;
	DISPPARAMS           dispparamsNoArgs = {NULL, NULL, 0, 0};

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(fModemConnected,VARIANT_FALSE);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, imp.Initialize ());
    __MPC_EXIT_IF_METHOD_FAILS(hr, imp.Impersonate());

    // Connect to the Server represented by bstrServerName.
    si.pwszName = (LPWSTR)bstrServerName;
    qi.pIID     = &IID_IPCHService;

    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateInstanceEx( CLSID_PCHService, NULL, CLSCTX_REMOTE_SERVER, &si, 1, &qi ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, qi.hr);
    svc.Attach( (IPCHService*)qi.pItf );


	// Invoke the method on the server(IPCHService interface) that detects for a Modem.
	// Since the original version of RemoteConnectionData object does not have this method,
	// we need to check if the object supports this method or not before calling this
	// method on the server end i.e. check the IPCHService interface by calling the invoke method.

	// This can be done via IDispatch.

    // Get the IDispatch pointer of the IPCHService interface
	__MPC_EXIT_IF_METHOD_FAILS(hr, svc->QueryInterface(IID_IDispatch, (void **)&pDisp));

	
 	// pDisp is an IDispatch pointer to the IPCHService interface
	// Get the ID of the ModemConnected property.
    
	__MPC_EXIT_IF_METHOD_FAILS(hr, pDisp->GetIDsOfNames(IID_NULL, &szMember, 1,LOCALE_USER_DEFAULT, &dispid));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pDisp->Invoke( dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET,
                                                  &dispparamsNoArgs, &varResult, NULL, NULL));

	// Assign the value from varResult to fModemConnected
	*fModemConnected = varResult.boolVal;

	hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\unsolicitedrc\lib\session.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Session.cpp

Abstract:
    SAFSession Object

Revision History:
    KalyaninN  created  09/29/'00

********************************************************************/

// User.cpp : Implementation of CSAFSession

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////
// CSAFSession

#include <HCP_trace.h>

/////////////////////////////////////////////////////////////////////////////
//  construction / destruction

// **************************************************************************
CSAFSession::CSAFSession()
{

	// CComBSTR               m_bstrUserName;
	// CComBSTR               m_bstrDomainName;
	// DWORD		          m_dwSessionID;
    // SessionStateEnum       m_SessionConnectState;

}

// **************************************************************************
CSAFSession::~CSAFSession()
{
    Cleanup();
}

// **************************************************************************
void CSAFSession::Cleanup(void)
{
}

/////////////////////////////////////////////////////////////////////////////
// CSAFSession  Properties


STDMETHODIMP CSAFSession::get_SessionID(DWORD  *dwSessionID)
{
    if (dwSessionID == NULL)
        return E_INVALIDARG;

    *dwSessionID = m_dwSessionID;
	return S_OK;
}

STDMETHODIMP CSAFSession::put_SessionID(DWORD   dwSessionID)
{
	m_dwSessionID = dwSessionID;
	return S_OK;
}

STDMETHODIMP CSAFSession::get_SessionState(SessionStateEnum  *pSessionState)
{
	__HCP_BEGIN_PROPERTY_GET2("CSAFSession::get_SessionState",hr,pSessionState,pchStateInvalid);

	*pSessionState = m_SessionConnectState;

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CSAFSession::put_SessionState(SessionStateEnum  SessionState)
{
	__HCP_BEGIN_PROPERTY_PUT("CSAFSession::put_SessionState",hr);

	switch(SessionState)
    {

	      case pchActive:
          case pchConnected:
          case pchConnectQuery:
          case pchShadow:
          case pchDisconnected:
          case pchIdle:
          case pchListen:
          case pchReset:
          case pchDown:
          case pchInit:
             m_SessionConnectState = SessionState;
             break;

          default:
            __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CSAFSession::get_UserName(BSTR  *pbstrUserName)
{
	MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::GetBSTR( m_bstrUserName, pbstrUserName );
}

STDMETHODIMP CSAFSession::put_UserName(BSTR  bstrUserName)
{
	__HCP_BEGIN_PROPERTY_PUT("CSAFSession::put_UserName",hr);

	m_bstrUserName = bstrUserName ;
   
    __HCP_END_PROPERTY(hr);

}

STDMETHODIMP CSAFSession::get_DomainName(BSTR  *pbstrDomainName)
{
	MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::GetBSTR( m_bstrDomainName, pbstrDomainName );
}

STDMETHODIMP CSAFSession::put_DomainName(BSTR  bstrDomainName)
{
	__HCP_BEGIN_PROPERTY_PUT("CSAFSession::put_DomainName",hr);

	m_bstrDomainName = bstrDomainName;
   
    __HCP_END_PROPERTY(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\unsolicitedrc\lib\user.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    User.cpp

Abstract:
    SAFUser Object

Revision History:
    KalyaninN  created  09/29/'00

********************************************************************/

// User.cpp : Implementation of CSAFUser

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////
// CSAFUser

#include <HCP_trace.h>

/////////////////////////////////////////////////////////////////////////////
//  construction / destruction

// **************************************************************************
CSAFUser::CSAFUser()
{

}

// **************************************************************************
CSAFUser::~CSAFUser()
{
    Cleanup();
}

// **************************************************************************
void CSAFUser::Cleanup(void)
{
    
}

/////////////////////////////////////////////////////////////////////////////
// CSAFUser  Properties

STDMETHODIMP CSAFUser::get_UserName(BSTR  *pbstrUserName)
{
	MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::GetBSTR( m_bstrUserName, pbstrUserName );
}

// **************************************************************************

STDMETHODIMP CSAFUser::get_DomainName(BSTR  *pbstrDomainName)
{
	MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::GetBSTR( m_bstrDomainName, pbstrDomainName );
}

// **************************************************************************

STDMETHODIMP CSAFUser::put_UserName(BSTR  bstrUserName)
{
	MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::PutBSTR( m_bstrUserName, bstrUserName );
}

// **************************************************************************

STDMETHODIMP CSAFUser::put_DomainName(BSTR  bstrDomainName)
{
	MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::PutBSTR( m_bstrDomainName, bstrDomainName );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\unsolicitedrc\lib\unsolicitedrc.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    UnsolicitedRC.cpp

Abstract:
    SAFRemoteDesktopConnection Object

Revision History:
    Kalyani Narlanka   (kalyanin)   09/29/'00
        Created

********************************************************************/

// SAFRemoteDesktopConnection.cpp : Implementation of CSAFRemoteDesktopConnection

#include "stdafx.h"


/////////////////////////////////////////////////////////////////////////////
// CSAFRemoteDesktopConnection

/////////////////////////////////////////////////////////////////////////////
//  construction / destruction

// **************************************************************************
CSAFRemoteDesktopConnection::CSAFRemoteDesktopConnection()
{

}

// **************************************************************************
CSAFRemoteDesktopConnection::~CSAFRemoteDesktopConnection()
{
    Cleanup();
}

// **************************************************************************
void CSAFRemoteDesktopConnection::Cleanup(void)
{

}

static HRESULT Error(UINT nID, const REFIID riid, HRESULT hRes)
{

    __MPC_FUNC_ENTRY( COMMONID, "CSAFRemoteDesktopConnection::ConnectRemoteDesktop" );

    CComPtr<ICreateErrorInfo> pCrErrInfo  =  0;
    CComPtr<IErrorInfo>       pErrorInfo;
    HRESULT                   hr;
    CComBSTR                  bstrDescription;


    //Step1 initialize the error

    __MPC_EXIT_IF_METHOD_FAILS(hr, CreateErrorInfo(&pCrErrInfo));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pCrErrInfo->SetGUID(riid));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::LocalizeString( IDS_NOPOLICY, bstrDescription, /*fMUI*/true ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pCrErrInfo->SetDescription(bstrDescription));

    //Step2 throw the error

    __MPC_EXIT_IF_METHOD_FAILS(hr, pCrErrInfo->QueryInterface(IID_IErrorInfo, (void**)&pErrorInfo));

    __MPC_EXIT_IF_METHOD_FAILS(hr, SetErrorInfo(0, pErrorInfo));

    hr = hRes;

    __MPC_FUNC_CLEANUP;

    if(pCrErrInfo)
    {
        pCrErrInfo.Release();
    }
    if(pErrorInfo)
    {
        pErrorInfo.Release();
    }

    __MPC_FUNC_EXIT(hr);

}


/////////////////////////////////////////////////////////////////////////////
//  CSAFRemoteDesktopConnection properties


/////////////////////////////////////////////////////////////////////////////
//  CSAFRemoteDesktopConnection Methods

STDMETHODIMP CSAFRemoteDesktopConnection::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] =
    {
        &IID_ISAFRemoteDesktopConnection
    };
    for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}




STDMETHODIMP CSAFRemoteDesktopConnection::ConnectRemoteDesktop( /*[in]*/ BSTR bstrServerName, /*[out]*/ ISAFRemoteConnectionData* *ppRCD )
{
    __MPC_FUNC_ENTRY( COMMONID, "CSAFRemoteDesktopConnection::ConnectRemoteDesktop" );

    HRESULT                           hr;
    CComPtr<CSAFRemoteConnectionData> pRCD;
    DWORD                             dwSessions;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(ppRCD,NULL);
    __MPC_PARAMCHECK_END();

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pRCD ));

    // Invoke the GetUserSessionInfo to populate the Users and Sessions information.

    hr = pRCD->InitUserSessionsInfo( bstrServerName );

    if(hr == HRESULT_FROM_WIN32( ERROR_ACCESS_DISABLED_BY_POLICY ))
    {
        // Populate the error description.
        // This Error() method sets up the IErrorInfo interface to provide error information to the client.
        // To call the Error method, the object must implement the ISupportErrorInfo interface.

        __MPC_EXIT_IF_METHOD_FAILS(hr, Error(IDS_NOPOLICY,IID_ISAFRemoteDesktopConnection,hr));

    }
    else
    {
        if(FAILED(hr))
        {
            // return the hr
            __MPC_EXIT_IF_METHOD_FAILS(hr, hr);
        }

    }

    // Return the RemoteConnectionData Interface to the caller
    __MPC_EXIT_IF_METHOD_FAILS(hr, pRCD.QueryInterface( ppRCD ));

    hr = S_OK;

    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\wmi\stdafx.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    stdafx.h

Abstract:
    include file for standard system include files,
    or project specific include files that are used frequently,
    but are changed infrequently


Revision History:
    Davide Massarenti   (Dmassare)  07/21/99
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__0DAA8F96_0286_11D3_9397_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__0DAA8F96_0286_11D3_9397_00C04F72DAF7__INCLUDED_

#include <module.h>

#include <HCP_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>

#include <WMIParser.h>

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__0DAA8F96_0286_11D3_9397_00C04F72DAF7__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\wmi\wmiparser_cluster.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    WMIParser_Cluster.cpp

Abstract:
    This file contains the implementation of the WMIParser::Cluster class,
    which is used to cluster together instances based on Class or Key.

Revision History:
    Davide Massarenti   (Dmassare)  07/25/99
        created

******************************************************************************/

#include "stdafx.h"

HRESULT WMIParser::Cluster::Add( /*[in]*/ Instance* wmipiInst )
{
    __HCP_FUNC_ENTRY( "WMIParser::Cluster::Add" );

    HRESULT hr;

    m_map[wmipiInst] = wmipiInst;
    hr               = S_OK;


    __HCP_FUNC_EXIT(hr);
}

HRESULT WMIParser::Cluster::Find( /*[in] */ Instance*  wmipiInst ,
								  /*[out]*/ Instance*& wmipiRes  ,
								  /*[out]*/ bool&      fFound    )
{
    __HCP_FUNC_ENTRY( "WMIParser::Cluster::Find" );

    HRESULT          hr;
    ClusterByKeyIter itCluster;


    itCluster = m_map.find( wmipiInst );
    if(itCluster != m_map.end())
    {
        wmipiRes = (*itCluster).second;
        fFound   = true;
    }
    else
    {
        wmipiRes = NULL;
        fFound   = false;
    }

    hr = S_OK;


    __HCP_FUNC_EXIT(hr);
}

HRESULT WMIParser::Cluster::Enum( /*[out]*/ ClusterByKeyIter& itBegin ,
								  /*[out]*/ ClusterByKeyIter& itEnd   )
{
    __HCP_FUNC_ENTRY( "WMIParser::Cluster::Enum" );

    HRESULT hr;


    itBegin = m_map.begin();
    itEnd   = m_map.end  ();
    hr      = S_OK;


    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT WMIParser::DistributeOnCluster( /*[in]*/ ClusterByClassMap& cluster ,
										/*[in]*/ Snapshot&          wmips   )
{
    __HCP_FUNC_ENTRY( "WMIParser::DistributeOnCluster" );

    HRESULT                 hr;
    Snapshot::InstIterConst itBegin;
    Snapshot::InstIterConst itEnd;
	Instance*               pwmipiInst;


    //
    // Create clusters based on CLASSPATH/CLASSNAME.
    //
	__MPC_EXIT_IF_METHOD_FAILS(hr, wmips.get_Instances( itBegin, itEnd ));
	while(itBegin != itEnd)
	{

		//
		// First of all, find the cluster by Path/Class.
		//
		Cluster& subcluster = cluster[ pwmipiInst = const_cast<Instance*>(&*itBegin) ];

		//
		// Then, add the instance in the cluster by Key.
		//
		__MPC_EXIT_IF_METHOD_FAILS(hr, subcluster.Add( pwmipiInst ));

		itBegin++;
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

#define TAG_CIM        L"CIM"
#define VALUE_REMOVED  L"Delete"
#define VALUE_MODIFIED L"Update"
#define VALUE_ADDED    L"New"

HRESULT WMIParser::CompareSnapshots( /*[in]        */ BSTR          bstrFilenameT0   ,
									 /*[in]        */ BSTR          bstrFilenameT1   ,
									 /*[in]        */ BSTR          bstrFilenameDiff ,
									 /*[out,retval]*/ VARIANT_BOOL *pVal             )
{
    __HCP_FUNC_ENTRY( "WMIParser::CompareMachineInfo" );

    HRESULT                            hr;
    WMIParser::ClusterByClassMap       clusterOld;
    WMIParser::ClusterByClassMap       clusterNew;
    WMIParser::ClusterByClassIter      itClusterOld;
    WMIParser::ClusterByClassIter      itClusterNew;
    WMIParser::Snapshot                wmipsOld;
    WMIParser::Snapshot                wmipsNew;
    WMIParser::Snapshot                wmipsDiff;
    WMIParser::Snapshot::InstIterConst itBegin;
    WMIParser::Snapshot::InstIterConst itEnd;
    WMIParser::ClusterByKeyIter        itSubBegin;
    WMIParser::ClusterByKeyIter        itSubEnd;
    WMIParser::Instance*               pwmipiInst;
    WMIParser::Instance*               pwmipiInst2;
    WMIParser::Property_Scalar*        pwmippChange;
    bool                               fDifferent = false;
    bool                               fFound;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_POINTER_AND_SET(pVal,VARIANT_FALSE);
	__MPC_PARAMCHECK_END();


    //
    // Load old and new snapshots and prepare the delta one.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, wmipsOld.Load( SAFEBSTR( bstrFilenameT0 ), TAG_CIM ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, wmipsNew.Load( SAFEBSTR( bstrFilenameT1 ), TAG_CIM ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, wmipsDiff.New(                                     ));


    //
    // Create clusters based on CLASSPATH/CLASSNAME.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, WMIParser::DistributeOnCluster( clusterOld, wmipsOld ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, WMIParser::DistributeOnCluster( clusterNew, wmipsNew ));


    //
    // Compute delta of Old vs New.
    //
    {
        for(itClusterOld = clusterOld.begin(); itClusterOld != clusterOld.end(); itClusterOld++)
        {
            pwmipiInst = (*itClusterOld).first; // Get the key of the cluster.

            itClusterNew = clusterNew.find( pwmipiInst );
            if(itClusterNew == clusterNew.end())
            {
                //
                // The cluster doesn't exist in the new snapshot, so it's a deleted cluster ...
                //

                //
                // Copy all the instances in the diff files, marking them as "Removed".
                //
                WMIParser::Cluster& subclusterOld = (*itClusterOld).second;

                __MPC_EXIT_IF_METHOD_FAILS(hr, subclusterOld.Enum( itSubBegin, itSubEnd ));
                while(itSubBegin != itSubEnd)
                {
                    __MPC_EXIT_IF_METHOD_FAILS(hr, wmipsDiff.clone_Instance( (*itSubBegin).first, pwmipiInst ));

                    //
                    // Update the "Change" property.
                    //
                    __MPC_EXIT_IF_METHOD_FAILS(hr, pwmipiInst->get_Change( pwmippChange          ));
					__MPC_EXIT_IF_METHOD_FAILS(hr, pwmippChange->put_Data( VALUE_REMOVED, fFound ));


                    fDifferent = true;

                    itSubBegin++;
                }
            }
            else
            {
                WMIParser::Cluster& subclusterOld = (*itClusterOld).second;
                WMIParser::Cluster& subclusterNew = (*itClusterNew).second;

                __MPC_EXIT_IF_METHOD_FAILS(hr, subclusterOld.Enum( itSubBegin, itSubEnd ));
                while(itSubBegin != itSubEnd)
                {
                    pwmipiInst = (*itSubBegin).first;

                    __MPC_EXIT_IF_METHOD_FAILS(hr, subclusterNew.Find( pwmipiInst, pwmipiInst2, fFound ));
                    if(fFound == false)
                    {
                        //
                        // Found a deleted instance ...
                        //

                        //
                        // Copy it in the diff files, marking it as "Removed".
                        //
                        __MPC_EXIT_IF_METHOD_FAILS(hr, wmipsDiff.clone_Instance( (*itSubBegin).first, pwmipiInst ));

                        //
                        // Update the "Change" property.
                        //
                        __MPC_EXIT_IF_METHOD_FAILS(hr, pwmipiInst->get_Change( pwmippChange          ));
						__MPC_EXIT_IF_METHOD_FAILS(hr, pwmippChange->put_Data( VALUE_REMOVED, fFound ));


                        fDifferent = true;
                    }
                    else
                    {
                        if(*pwmipiInst == *pwmipiInst2)
                        {
                            //
                            // They are the same...
                            //
                        }
                        else
                        {
                            //
                            // Found a changed instance ...
                            //

                            //
                            // Copy it in the diff files, marking it as "Modified".
                            //
                            __MPC_EXIT_IF_METHOD_FAILS(hr, wmipsDiff.clone_Instance( (*itSubBegin).first, pwmipiInst ));

                            //
                            // Update the "Change" property.
                            //
                            __MPC_EXIT_IF_METHOD_FAILS(hr, pwmipiInst->get_Change( pwmippChange           ));
							__MPC_EXIT_IF_METHOD_FAILS(hr, pwmippChange->put_Data( VALUE_MODIFIED, fFound ));


                            fDifferent = true;
                        }
                    }

                    itSubBegin++;
                }
            }
        }
    }


    //
    // Compute delta of New vs Old.
    //
    {
        for(itClusterNew = clusterNew.begin(); itClusterNew != clusterNew.end(); itClusterNew++)
        {
            pwmipiInst = (*itClusterNew).first; // Get the key of the cluster.

            itClusterOld = clusterOld.find( pwmipiInst );
            if(itClusterOld == clusterOld.end())
            {
                //
                // The cluster doesn't exist in the old snapshot, so it's an added cluster ...
                //

                //
                // Copy all the instances in the diff files, marking them as "Added".
                //
                WMIParser::Cluster& subclusterNew = (*itClusterNew).second;

                __MPC_EXIT_IF_METHOD_FAILS(hr, subclusterNew.Enum( itSubBegin, itSubEnd ));
                while(itSubBegin != itSubEnd)
                {
                    __MPC_EXIT_IF_METHOD_FAILS(hr, wmipsDiff.clone_Instance( (*itSubBegin).first, pwmipiInst ));

                    //
                    // Update the "Change" property.
                    //
                    __MPC_EXIT_IF_METHOD_FAILS(hr, pwmipiInst->get_Change( pwmippChange        ));
					__MPC_EXIT_IF_METHOD_FAILS(hr, pwmippChange->put_Data( VALUE_ADDED, fFound ));


                    fDifferent = true;

                    itSubBegin++;
                }
            }
            else
            {
                WMIParser::Cluster& subclusterNew = (*itClusterNew).second;
                WMIParser::Cluster& subclusterOld = (*itClusterOld).second;

                __MPC_EXIT_IF_METHOD_FAILS(hr, subclusterNew.Enum( itSubBegin, itSubEnd ));
                while(itSubBegin != itSubEnd)
                {
                    pwmipiInst = (*itSubBegin).first;

                    __MPC_EXIT_IF_METHOD_FAILS(hr, subclusterOld.Find( pwmipiInst, pwmipiInst2, fFound ));
                    if(fFound == false)
                    {
                        //
                        // Found an added instance ...
                        //

                        //
                        // Copy it in the diff files, marking it as "Added".
                        //
                        __MPC_EXIT_IF_METHOD_FAILS(hr, wmipsDiff.clone_Instance( (*itSubBegin).first, pwmipiInst ));

                        //
                        // Update the "Change" property.
                        //
                        __MPC_EXIT_IF_METHOD_FAILS(hr, pwmipiInst->get_Change( pwmippChange        ));
						__MPC_EXIT_IF_METHOD_FAILS(hr, pwmippChange->put_Data( VALUE_ADDED, fFound ));


                        fDifferent = true;
                    }
                    else
                    {
                        //
                        // Already checked for changes in two instances...
                        //
                    }

                    itSubBegin++;
                }
            }
        }
    }


    //
    // Only save the delta if actually there are differences.
    //
    if(fDifferent)
    {
        //
        // Save the delta.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, wmipsDiff.Save( SAFEBSTR( bstrFilenameDiff ) ));

        *pVal = VARIANT_TRUE;
    }
    else
    {
        *pVal = VARIANT_FALSE;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\wmi\wmiparser_instance.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    WMIParser_Instance.cpp

Abstract:
    This file contains the implementation of the WMIParser::Instance class,
    which is used to hold the data of an instance inside a CIM schema.

Revision History:
    Davide Massarenti   (Dmassare)  07/25/99
        created

******************************************************************************/

#include "stdafx.h"


#define XQL_PROPERTY            L"INSTANCE/PROPERTY"
#define XQL_PROPERTY_ARRAY      L"INSTANCE/PROPERTY.ARRAY"
#define XQL_PROPERTY_REFERENCE  L"INSTANCE/PROPERTY.REFERENCE"

#define TAG_INSTANCE            L"INSTANCE"
#define TAG_PROPERTY            L"PROPERTY"

#define TAG_VALUE               L"VALUE"
#define ATTRIB_NAME             L"NAME"
#define ATTRIB_TYPE             L"TYPE"

#define PROPERTY_TIMESTAMP      L"TimeStamp"
#define PROPERTY_CHANGE         L"Change"
#define PROPERTY_CHANGE_TYPE    L"string"


WMIParser::Instance::Instance()
{
    __HCP_FUNC_ENTRY( "WMIParser::Instance::Instance" );


                                 // MPC::XmlUtil     m_xmlNode;
                                 //
                                 // Property_Scalar  m_wmippTimeStamp;
    m_fTimeStamp        = false; // bool             m_fTimeStamp;
                                 //
                                 // Property_Scalar  m_wmippChange;
    m_fChange           = false; // bool             m_fChange;
                                 //
                                 // InstanceName     m_wmipinIdentity;
                                 //
    m_fPropertiesParsed = false; // bool             m_fPropertiesParsed;
                                 // PropMap          m_mapPropertiesScalar;
                                 // ArrayMap         m_mapPropertiesArray;
                                 // ReferenceMap     m_mapPropertiesReference;
}

WMIParser::Instance::~Instance()
{
    __HCP_FUNC_ENTRY( "WMIParser::Instance::~Instance" );
}

bool WMIParser::Instance::operator==( /*[in]*/ Instance const &wmipi ) const
{
    __HCP_FUNC_ENTRY( "WMIParser::Instance::operator==" );

    bool fRes = false;


    //
    // We don't parse the properties until the last moment...
    //
    if(      m_fPropertiesParsed == false) (void)const_cast<Instance*>( this )->ParseProperties();
    if(wmipi.m_fPropertiesParsed == false) (void)const_cast<Instance*>(&wmipi)->ParseProperties();


    if(m_mapPropertiesScalar    == wmipi.m_mapPropertiesScalar    &&
       m_mapPropertiesArray     == wmipi.m_mapPropertiesArray     &&
       m_mapPropertiesReference == wmipi.m_mapPropertiesReference  )
	{
		fRes = true;
    }


    __HCP_FUNC_EXIT(fRes);
}


////////////////////////////////////////////////

HRESULT WMIParser::Instance::ParseIdentity( /*[in] */ IXMLDOMNode* pxdnNode ,
                                            /*[out]*/ bool&        fEmpty   )
{
    __HCP_FUNC_ENTRY( "WMIParser::Instance::ParseIdentity" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_wmipinIdentity.put_Node( pxdnNode, fEmpty ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT WMIParser::Instance::ParseProperties()
{
    __HCP_FUNC_ENTRY( "WMIParser::Instance::ParseProperties" );

    HRESULT hr;


    if(m_fPropertiesParsed == false)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, ParsePropertiesScalar   ());
        __MPC_EXIT_IF_METHOD_FAILS(hr, ParsePropertiesArray    ());
        __MPC_EXIT_IF_METHOD_FAILS(hr, ParsePropertiesReference());

        m_fPropertiesParsed = true;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT WMIParser::Instance::ParsePropertiesScalar()
{
    __HCP_FUNC_ENTRY( "WMIParser::Instance::ParsePropertiesScalar" );

    HRESULT                  hr;
    CComPtr<IXMLDOMNodeList> xdnlList;
    CComPtr<IXMLDOMNode>     xdnNode;


    //
    // Get all the elements of type "PROPERTY".
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlNode.GetNodes( XQL_PROPERTY, &xdnlList ));

    for(;SUCCEEDED(hr = xdnlList->nextNode( &xdnNode )) && xdnNode != NULL; xdnNode = NULL)
    {
        Property     wmipp;
        MPC::wstring szName;

        //
        // Get the name of the property.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, wmipp.put_Node( xdnNode ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, wmipp.get_Name( szName  ));

		////////////////////////////////////////////////////////////

        //
        // Filter out "Timestamp" and "Change" properties!
        //
        if(wmipp == PROPERTY_TIMESTAMP && m_fTimeStamp == false)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_wmippTimeStamp.put_Node( xdnNode ));

            m_fTimeStamp = true;
            continue;
        }

        if(wmipp == PROPERTY_CHANGE && m_fChange == false)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_wmippChange.put_Node( xdnNode ));

            m_fChange = true;
            continue;
        }

		////////////////////////////////////////////////////////////

        //
        // Parse the whole property.
        //
        {
            Property_Scalar& wmipps = m_mapPropertiesScalar[ szName ];

            __MPC_EXIT_IF_METHOD_FAILS(hr, wmipps.put_Node( xdnNode ));
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT WMIParser::Instance::ParsePropertiesArray()
{
    __HCP_FUNC_ENTRY( "WMIParser::Instance::ParsePropertiesArray" );

    HRESULT                  hr;
    CComPtr<IXMLDOMNodeList> xdnlList;
    CComPtr<IXMLDOMNode>     xdnNode;

    //
    // Get all the elements of type "PROPERTY.ARRAY".
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlNode.GetNodes( XQL_PROPERTY_ARRAY, &xdnlList ));

    for(;SUCCEEDED(hr = xdnlList->nextNode( &xdnNode )) && xdnNode != NULL; xdnNode = NULL)
    {
        Property     wmipp;
        MPC::wstring szName;

        //
        // Get the name of the property.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, wmipp.put_Node( xdnNode ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, wmipp.get_Name( szName  ));

        //
        // Parse the whole property.
        //
        {
            Property_Array& wmippa = m_mapPropertiesArray[ szName ];

            __MPC_EXIT_IF_METHOD_FAILS(hr, wmippa.put_Node( xdnNode ));
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT WMIParser::Instance::ParsePropertiesReference()
{
    __HCP_FUNC_ENTRY( "WMIParser::Instance::ParsePropertiesReference" );

    HRESULT                  hr;
    CComPtr<IXMLDOMNodeList> xdnlList;
    CComPtr<IXMLDOMNode>     xdnNode;

    //
    // Get all the elements of type "PROPERTY.REFERENCE".
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlNode.GetNodes( XQL_PROPERTY_REFERENCE, &xdnlList ));

    for(;SUCCEEDED(hr = xdnlList->nextNode( &xdnNode )) && xdnNode != NULL; xdnNode = NULL)
    {
        Property     wmipp;
        MPC::wstring szName;

        //
        // Get the name of the property.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, wmipp.put_Node( xdnNode ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, wmipp.get_Name( szName  ));

        //
        // Parse the whole property.
        //
        {
            Property_Reference& wmippr = m_mapPropertiesReference[ szName ];

            __MPC_EXIT_IF_METHOD_FAILS(hr, wmippr.put_Node( xdnNode ));
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


////////////////////////////////////////////////

HRESULT WMIParser::Instance::put_Node( /*[in] */ IXMLDOMNode* pxdnNode ,
                                       /*[out]*/ bool&        fEmpty   )
{
    __HCP_FUNC_ENTRY( "WMIParser::Instance::put_Node" );

    HRESULT hr;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_NOTNULL(pxdnNode);
	__MPC_PARAMCHECK_END();


    m_xmlNode = pxdnNode;
    fEmpty    = true;


    //
    // Analize the node...
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, ParseIdentity( pxdnNode, fEmpty ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT WMIParser::Instance::get_Node( /*[out]*/ IXMLDOMNode* *pxdnNode )
{
    __HCP_FUNC_ENTRY( "WMIParser::Instance::get_Node" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlNode.GetRoot( pxdnNode ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////

HRESULT WMIParser::Instance::get_Namespace( /*[out]*/ MPC::wstring& szNamespace )
{
    __HCP_FUNC_ENTRY( "WMIParser::Instance::get_Namespace" );

    HRESULT hr;


    hr = m_wmipinIdentity.get_Namespace( szNamespace );


    __HCP_FUNC_EXIT(hr);
}

HRESULT WMIParser::Instance::get_Class( /*[out]*/ MPC::wstring& szClass )
{
    __HCP_FUNC_ENTRY( "WMIParser::Instance::get_Class" );

    HRESULT hr;


    hr = m_wmipinIdentity.get_Class( szClass );


    __HCP_FUNC_EXIT(hr);
}

HRESULT WMIParser::Instance::get_TimeStamp( /*[out]*/ Property_Scalar*& wmippTimeStamp ,
                                            /*[out]*/ bool&             fFound         )
{
    __HCP_FUNC_ENTRY( "WMIParser::Instance::get_TimeStamp" );

    HRESULT hr;


    //
    // We don't parse the properties until the last moment...
    //
    if(m_fPropertiesParsed == false)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, ParseProperties());
	}


    fFound         = m_fTimeStamp;
    wmippTimeStamp = m_fTimeStamp ? &m_wmippTimeStamp : NULL;
    hr             = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT WMIParser::Instance::get_Change( /*[out]*/ Property_Scalar*& wmippChange )
{
    __HCP_FUNC_ENTRY( "WMIParser::Instance::get_Change" );

    HRESULT hr;


    //
    // We don't parse the properties until the last moment...
    //
    if(m_fPropertiesParsed == false) (void)ParseProperties();


    //
    // If the "CHANGE" property is not present, create a fake one.
    //
    if(m_fChange == false)
    {
        CComPtr<IXMLDOMNode> xdnNodeInstance;
        CComPtr<IXMLDOMNode> xdnNodeProperty;
        CComPtr<IXMLDOMNode> xdnNodeValue;
        bool                 fFound;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlNode.GetNode( TAG_INSTANCE, &xdnNodeInstance ));
        if(xdnNodeInstance)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlNode.CreateNode  ( TAG_PROPERTY,                                    &xdnNodeProperty, xdnNodeInstance ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlNode.PutAttribute( NULL, ATTRIB_NAME, PROPERTY_CHANGE     , fFound,  xdnNodeProperty                  ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlNode.PutAttribute( NULL, ATTRIB_TYPE, PROPERTY_CHANGE_TYPE, fFound,  xdnNodeProperty                  ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlNode.CreateNode  ( TAG_VALUE, &xdnNodeValue                       ,  xdnNodeProperty                  ));


            __MPC_EXIT_IF_METHOD_FAILS(hr, m_wmippChange.put_Node( xdnNodeProperty ));
			m_fChange = true;
        }
		else
		{
			__MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_BAD_FORMAT);
		}
    }

    wmippChange = m_fChange ? &m_wmippChange : NULL;
    hr          = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


HRESULT WMIParser::Instance::get_Identity( /*[out]*/ InstanceName*& wmipin )
{
    __HCP_FUNC_ENTRY( "WMIParser::Instance::get_Identity" );

    HRESULT hr;


    wmipin = &m_wmipinIdentity;
    hr     = S_OK;


    __HCP_FUNC_EXIT(hr);
}

HRESULT WMIParser::Instance::get_Properties( /*[out]*/ PropIterConst& itBegin ,
                                             /*[out]*/ PropIterConst& itEnd   )
{
    __HCP_FUNC_ENTRY( "WMIParser::Instance::get_Properties" );

    HRESULT hr;


    //
    // We don't parse the properties until the last moment...
    //
    if(m_fPropertiesParsed == false) (void)ParseProperties();


    itBegin = m_mapPropertiesScalar.begin();
    itEnd   = m_mapPropertiesScalar.end  ();
    hr      = S_OK;


    __HCP_FUNC_EXIT(hr);
}

HRESULT WMIParser::Instance::get_PropertiesArray( /*[out]*/ ArrayIterConst& itBegin ,
                                                  /*[out]*/ ArrayIterConst& itEnd   )
{
    __HCP_FUNC_ENTRY( "WMIParser::Instance::get_PropertiesArray" );

    HRESULT hr;


    //
    // We don't parse the properties until the last moment...
    //
    if(m_fPropertiesParsed == false) (void)ParseProperties();


    itBegin = m_mapPropertiesArray.begin();
    itEnd   = m_mapPropertiesArray.end  ();
    hr      = S_OK;


    __HCP_FUNC_EXIT(hr);
}

HRESULT WMIParser::Instance::get_PropertiesReference( /*[out]*/ ReferenceIterConst& itBegin ,
                                                      /*[out]*/ ReferenceIterConst& itEnd   )
{
    __HCP_FUNC_ENTRY( "WMIParser::Instance::get_PropertiesReference" );

    HRESULT hr;


    //
    // We don't parse the properties until the last moment...
    //
    if(m_fPropertiesParsed == false) (void)ParseProperties();


    itBegin = m_mapPropertiesReference.begin();
    itEnd   = m_mapPropertiesReference.end  ();
    hr      = S_OK;


    __HCP_FUNC_EXIT(hr);
}

bool WMIParser::Instance::CompareByClass( /*[in]*/ Instance const &wmipi ) const
{
    MPC::NocaseLess     strLess;
    MPC::NocaseCompare  strCmp;
    const MPC::wstring& leftNamespace  =       m_wmipinIdentity.m_szNamespace;
    const MPC::wstring& leftClass      =       m_wmipinIdentity.m_szClass;
    const MPC::wstring& rightNamespace = wmipi.m_wmipinIdentity.m_szNamespace;
    const MPC::wstring& rightClass     = wmipi.m_wmipinIdentity.m_szClass;
    bool                fRes;


    if(strCmp( leftNamespace, rightNamespace ) == true)
    {
        fRes = strLess( leftClass, rightClass );
    }
    else
    {
        fRes = strLess( leftNamespace, rightNamespace );
    }


    return fRes;
}

bool WMIParser::Instance::CompareByKey( /*[in]*/ Instance const &wmipi ) const
{
    bool fRes = false;


    if(m_wmipinIdentity < wmipi.m_wmipinIdentity) fRes = true;


    return fRes;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

bool WMIParser::Instance_Less_ByClass::operator()( /*[in]*/ Instance* const & left  ,
                                                   /*[in]*/ Instance* const & right ) const
{
    return left->CompareByClass( *right );
}

bool WMIParser::Instance_Less_ByKey::operator()( /*[in]*/ Instance* const & left  ,
                                                 /*[in]*/ Instance* const & right ) const
{
    return left->CompareByKey( *right );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\wmi\wmiparser_instancename.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    WMIParser_InstanceName.cpp

Abstract:
    This file contains the implementation of the WMIParser::InstanceName class,
    which is used to hold the data of an name for an instance inside a CIM schema.

Revision History:
    Davide Massarenti   (Dmassare)  10/03/99
        created

******************************************************************************/

#include "stdafx.h"


#define ATTRIB_CLASSNAME            L"CLASSNAME"
#define ATTRIB_NAME                 L"NAME"

#define TAG_KEYVALUE                L"KEYVALUE"
#define TAG_VALUE_REFERENCE         L"VALUE.REFERENCE"

#define TAG_KEYBINDING              L"KEYBINDING"
#define TAG_KEYBINDING_NAME_DEFAULT L"<DEFAULT>"


const LPCWSTR l_Namespace   [] = { L"INSTANCEPATH/NAMESPACEPATH/LOCALNAMESPACEPATH/NAMESPACE", L"LOCALINSTANCEPATH/LOCALNAMESPACEPATH/NAMESPACE" };
const LPCWSTR l_InstanceName[] = { L"INSTANCEPATH/INSTANCENAME"                              , L"LOCALINSTANCEPATH/INSTANCENAME"                 };

WMIParser::InstanceName::InstanceName()
{
    __HCP_FUNC_ENTRY( "WMIParser::InstanceName::InstanceName" );

    // MPC::wstring     m_szNamespace;
    // MPC::wstring     m_szClass;
    //
    // KeyMap           m_mapKeyBinding;
}

WMIParser::InstanceName::~InstanceName()
{
    __HCP_FUNC_ENTRY( "WMIParser::InstanceName::~InstanceName" );
}

bool WMIParser::InstanceName::operator==( /*[in]*/ InstanceName const &wmipin ) const
{
    MPC::NocaseCompare strCmp;
    bool               fRes = false;

    if(strCmp( m_szNamespace, wmipin.m_szNamespace ) == true &&
       strCmp( m_szClass    , wmipin.m_szClass     ) == true  )
    {
        fRes = (m_mapKeyBinding == wmipin.m_mapKeyBinding);
    }

    return fRes;
}

bool WMIParser::InstanceName::operator< ( /*[in]*/ InstanceName const &wmipin ) const
{
    MPC::NocaseLess     strLess;
    MPC::NocaseCompare  strCmp;
    const MPC::wstring& leftNamespace  =        m_szNamespace;
    const MPC::wstring& leftClass      =        m_szClass;
    const MPC::wstring& rightNamespace = wmipin.m_szNamespace;
    const MPC::wstring& rightClass     = wmipin.m_szClass;
    bool                fRes;


    if(strCmp( leftNamespace, rightNamespace ) == true)
    {
        if(strCmp( leftClass, rightClass ) == true)
        {
            fRes = (m_mapKeyBinding < wmipin.m_mapKeyBinding);
        }
        else
        {
            fRes = strLess( leftClass, rightClass );
        }
    }
    else
    {
        fRes = strLess( leftNamespace, rightNamespace );
    }


    return fRes;
}


////////////////////////////////////////////////

HRESULT WMIParser::InstanceName::ParseNamespace()
{
    __HCP_FUNC_ENTRY( "WMIParser::InstanceName::ParseNamespace" );

    HRESULT                  hr;
    CComPtr<IXMLDOMNodeList> xdnlList;
    CComPtr<IXMLDOMNode>     xdnNode;
    int                      iPass;
    bool                     fBuilt = false;


    for(iPass=0; iPass<ARRAYSIZE(l_Namespace); iPass++,xdnlList=NULL,xdnNode=NULL)
    {
        //
        // Get all the elements of type "NAMESPACE".
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlNode.GetNodes( l_Namespace[iPass], &xdnlList ));

        for(;SUCCEEDED(hr = xdnlList->nextNode( &xdnNode )) && xdnNode != NULL; xdnNode = NULL)
        {
            MPC::wstring szNamespace;
            bool         fFound;

            __MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlNode.GetAttribute( NULL, ATTRIB_NAME, szNamespace, fFound, xdnNode ));
            if(fFound)
            {
                if(fBuilt == false)
                {
                    fBuilt = true;
                }
                else
                {
                    m_szNamespace += L'/';
                }

                m_szNamespace += szNamespace;
            }
        }

        if(fBuilt) break;
    }

    if(fBuilt == false)
    {
        //
        // Initialize the namespace to a meaningful default.
        //
        m_szNamespace = L"<UNKNOWN>";
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT WMIParser::InstanceName::ParseKey( /*[in] */ IXMLDOMNode*      pxdnNode ,
                                           /*[out]*/ InstanceNameItem& wmipini  ,
                                           /*[out]*/ bool&             fFound   )
{
    __HCP_FUNC_ENTRY( "WMIParser::InstanceName::ParseKey" );

    _ASSERT(pxdnNode != NULL);

    HRESULT              hr;
    MPC::XmlUtil         xmlNodeSub( pxdnNode );
    CComPtr<IXMLDOMNode> xdnNode;
    CComVariant          vValue;
    bool                 fFoundValue;


    fFound = false;


    //
    // Try to parse KEYVALUE element.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, xmlNodeSub.GetValue( TAG_KEYVALUE, vValue, fFoundValue ));
    if(fFoundValue)
    {
        if(SUCCEEDED(vValue.ChangeType( VT_BSTR )))
        {
            wmipini.m_szValue = OLE2W( vValue.bstrVal );
            fFound            = true;
        }
    }

    //
    // Try to parse VALUE.REFERENCE element.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, xmlNodeSub.GetNode( TAG_VALUE_REFERENCE, &xdnNode ));
    if(xdnNode)
    {
        __MPC_EXIT_IF_ALLOC_FAILS(hr, wmipini.m_wmipvrValue, new ValueReference());

        __MPC_EXIT_IF_METHOD_FAILS(hr, wmipini.m_wmipvrValue->Parse( xdnNode ));

        fFound = true;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT WMIParser::InstanceName::ParseKeys()
{
    __HCP_FUNC_ENTRY( "WMIParser::InstanceName::ParseNamespace" );

    HRESULT                  hr;
    CComPtr<IXMLDOMNodeList> xdnlList;
    CComPtr<IXMLDOMNode>     xdnNode;
    CComPtr<IXMLDOMNode>     xdnNodeSub;
    int                      iPass;
    MPC::wstring             szKey;
    bool                     fFound;


    m_szClass = L"";

    for(iPass=0; iPass<ARRAYSIZE(l_InstanceName); iPass++,xdnlList=NULL,xdnNode=NULL)
    {
        //
        // Look for an element of type "INSTANCENAME".
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlNode.GetNode( l_InstanceName[iPass], &xdnNode ));
        if(xdnNode)
        {
            MPC::XmlUtil xmlNodeSub( xdnNode );


            //
            // Get the attribute named "CLASSNAME".
            //
            __MPC_EXIT_IF_METHOD_FAILS(hr, xmlNodeSub.GetAttribute( NULL, ATTRIB_CLASSNAME, m_szClass, fFound ));

            //
            // Get all the elements of type "KEYBINDING".
            //
            __MPC_EXIT_IF_METHOD_FAILS(hr, xmlNodeSub.GetNodes( TAG_KEYBINDING, &xdnlList ));
            for(;SUCCEEDED(hr = xdnlList->nextNode( &xdnNodeSub )) && xdnNodeSub != NULL; xdnNodeSub = NULL)
            {
                InstanceNameItem wmipini;

                __MPC_EXIT_IF_METHOD_FAILS(hr, xmlNodeSub.GetAttribute( NULL, ATTRIB_NAME , szKey , fFound, xdnNodeSub )); if(fFound == false) continue;

                __MPC_EXIT_IF_METHOD_FAILS(hr, ParseKey( xdnNodeSub, wmipini, fFound ));
                if(fFound)
                {
                    m_mapKeyBinding[ szKey.c_str() ] = wmipini;
                }
            }

            //
            // Also look for KEYVALUE or VALUE.REFERENCE alone.
            //
            {
                InstanceNameItem wmipini;

                __MPC_EXIT_IF_METHOD_FAILS(hr, ParseKey( xdnNode, wmipini, fFound ));
                if(fFound)
                {
                    m_mapKeyBinding[ TAG_KEYBINDING_NAME_DEFAULT ] = wmipini;
                }
            }
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////

HRESULT WMIParser::InstanceName::put_Node( /*[in] */ IXMLDOMNode* pxdnNode ,
                                           /*[out]*/ bool&        fEmpty   )
{
    __HCP_FUNC_ENTRY( "WMIParser::InstanceName::put_Node" );

    HRESULT hr;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_NOTNULL(pxdnNode);
	__MPC_PARAMCHECK_END();

    m_xmlNode = pxdnNode;
    fEmpty    = true;


    //
    // Analize the node...
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, ParseNamespace());
    __MPC_EXIT_IF_METHOD_FAILS(hr, ParseKeys     ());


    //
    // If any of these fields is empty, probably the InstanceName is malformed, so it's best to skip it...
    //
    if(m_szNamespace.length() != 0 &&
       m_szClass    .length() != 0  )
    {
        fEmpty = false;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////

HRESULT WMIParser::InstanceName::get_Namespace( /*[out]*/ MPC::wstring& szNamespace )
{
    __HCP_FUNC_ENTRY( "WMIParser::InstanceName::get_Namespace" );

    HRESULT hr;


    szNamespace = m_szNamespace;
    hr          = S_OK;


    __HCP_FUNC_EXIT(hr);
}

HRESULT WMIParser::InstanceName::get_Class( /*[out]*/ MPC::wstring& szClass )
{
    __HCP_FUNC_ENTRY( "WMIParser::InstanceName::get_Class" );

    HRESULT hr;


    szClass = m_szClass;
    hr      = S_OK;


    __HCP_FUNC_EXIT(hr);
}


HRESULT WMIParser::InstanceName::get_KeyBinding( /*[out]*/ KeyIterConst& itBegin ,
                                                 /*[out]*/ KeyIterConst& itEnd   )
{
    __HCP_FUNC_ENTRY( "WMIParser::InstanceName::get_KeyBinding" );

    HRESULT hr;


    itBegin = m_mapKeyBinding.begin();
    itEnd   = m_mapKeyBinding.end  ();
    hr      = S_OK;


    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\wmi\wmiparser_property.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    WMIParser_Property.cpp

Abstract:
    This file contains the implementation of the WMIParser::Property class,
    which is used to hold the data of an property inside a CIM schema.

Revision History:
    Davide Massarenti   (Dmassare)  07/25/99
        created

******************************************************************************/

#include "stdafx.h"


#define ATTRIBUTE_NAME L"NAME"
#define ATTRIBUTE_TYPE L"TYPE"


WMIParser::Property::Property()
{
    __HCP_FUNC_ENTRY( "WMIParser::Property::Property" );

    // MPC::XmlUtil m_xmlNode;
    // MPC::wstring m_szName;
    // MPC::wstring m_szType;
}

WMIParser::Property::~Property()
{
    __HCP_FUNC_ENTRY( "WMIParser::Property::~Property" );
}

////////////////////////////////////////////////

bool WMIParser::Property::operator==( /*[in]*/ LPCWSTR strName ) const
{
    __HCP_FUNC_ENTRY( "WMIParser::Property::operator==" );

    MPC::NocaseCompare cmp;
    bool               fRes;


    fRes = cmp( m_szName, strName);


    __HCP_FUNC_EXIT(fRes);
}

bool WMIParser::Property::operator==( /*[in]*/ const MPC::wstring& szName  ) const
{
    __HCP_FUNC_ENTRY( "WMIParser::Property::operator==" );

    bool fRes;


	fRes = (*this == szName.c_str());


    __HCP_FUNC_EXIT(fRes);
}


////////////////////////////////////////////////

HRESULT WMIParser::Property::put_Node( /*[in]*/ IXMLDOMNode* pxdnNode )
{
    __HCP_FUNC_ENTRY( "WMIParser::Property::put_Node" );

    HRESULT hr;
	bool    fFound;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_NOTNULL(pxdnNode);
	__MPC_PARAMCHECK_END();


    m_xmlNode = pxdnNode;


    //
    // Analize the node...
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlNode.GetAttribute( NULL, ATTRIBUTE_NAME, m_szName , fFound ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlNode.GetAttribute( NULL, ATTRIBUTE_TYPE, m_szType , fFound ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT WMIParser::Property::get_Node( /*[out]*/ IXMLDOMNode* *pxdnNode )
{
    __HCP_FUNC_ENTRY( "WMIParser::Property::get_Node" );

    HRESULT hr;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_POINTER_AND_SET(pxdnNode,NULL);
	__MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlNode.GetRoot( pxdnNode ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////

HRESULT WMIParser::Property::get_Name( /*[out]*/ MPC::wstring& szName )
{
    __HCP_FUNC_ENTRY( "WMIParser::Property::get_Name" );

    HRESULT hr;


    szName = m_szName;
    hr     = S_OK;


    __HCP_FUNC_EXIT(hr);
}

HRESULT WMIParser::Property::get_Type( /*[out]*/ MPC::wstring& szType )
{
    __HCP_FUNC_ENTRY( "WMIParser::Property::get_Type" );

    HRESULT hr;


    szType = m_szType;
    hr     = S_OK;


    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\wmi\wmiparser_property_reference.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    WMIParser_Property_Reference.cpp

Abstract:
    This file contains the implementation of the WMIParser::Property_Reference class,
    which is used to hold the data of an property inside a CIM schema.

Revision History:
    Davide Massarenti   (Dmassare)  07/25/99
        created

******************************************************************************/

#include "stdafx.h"


#define TAG_VALUE_REFERENCE L"VALUE.REFERENCE"


WMIParser::Property_Reference::Property_Reference()
{
    __HCP_FUNC_ENTRY( "WMIParser::Property_Reference::Property_Reference" );

	// ValueReference m_wmipvrData;
}

WMIParser::Property_Reference::~Property_Reference()
{
    __HCP_FUNC_ENTRY( "WMIParser::Property_Reference::~Property_Reference" );
}

////////////////////////////////////////////////


bool WMIParser::Property_Reference::operator==( /*[in]*/ Property_Reference const &wmipps ) const
{
    __HCP_FUNC_ENTRY( "WMIParser::Property_Reference::operator==" );

    bool fRes;


	fRes = (*(static_cast<Property const *>(this)) == wmipps.m_szName);
	if(fRes)
	{
		fRes = (this->m_wmipvrData == wmipps.m_wmipvrData);
	}


    __HCP_FUNC_EXIT(fRes);
}

////////////////////////////////////////////////

HRESULT WMIParser::Property_Reference::put_Node( /*[in]*/ IXMLDOMNode* pxdnNode )
{
    __HCP_FUNC_ENTRY( "WMIParser::Property_Reference::put_Node" );

    HRESULT              hr;
    MPC::XmlUtil         xmlNode( pxdnNode );
    CComPtr<IXMLDOMNode> xdnNode;


    __MPC_EXIT_IF_METHOD_FAILS(hr, (static_cast<Property*>(this))->put_Node( pxdnNode ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, xmlNode.GetNode( TAG_VALUE_REFERENCE, &xdnNode ));
	if(xdnNode)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, m_wmipvrData.Parse( xdnNode ));
    }


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////

HRESULT WMIParser::Property_Reference::get_Data( /*[out]*/ ValueReference*& wmipvr )
{
    __HCP_FUNC_ENTRY( "WMIParser::Property_Reference::get_Data" );

    HRESULT hr;


	wmipvr = &m_wmipvrData;
	hr     = S_OK;


    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\wmi\wmiparser_instancenameitem.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    WMIParser_InstanceNameItem.cpp

Abstract:
    This file contains the implementation of the WMIParser::InstanceNameItem class,
    which is used to hold the data of a key inside a CIM schema.

Revision History:
    Davide Massarenti   (Dmassare)  10/03/99
        created

******************************************************************************/

#include "stdafx.h"


WMIParser::InstanceNameItem::InstanceNameItem()
{
    __HCP_FUNC_ENTRY( "WMIParser::InstanceNameItem::InstanceNameItem" );

						  // MPC::wstring    m_szValue;
	m_wmipvrValue = NULL; // ValueReference* m_wmipvrValue;
}

WMIParser::InstanceNameItem::InstanceNameItem( /*[in]*/ const InstanceNameItem& wmipini )
{
    __HCP_FUNC_ENTRY( "WMIParser::InstanceNameItem::InstanceNameItem" );

	m_szValue     = wmipini.m_szValue;     // MPC::wstring    m_szValue;
	m_wmipvrValue = wmipini.m_wmipvrValue; // ValueReference* m_wmipvrValue;

	//
	// The copy constructor actually transfers ownership of the ValueReference object!!!
	//
	InstanceNameItem* wmipini2 = const_cast<InstanceNameItem*>(&wmipini);
	wmipini2->m_wmipvrValue = NULL;
}

WMIParser::InstanceNameItem::~InstanceNameItem()
{
    __HCP_FUNC_ENTRY( "WMIParser::InstanceNameItem::~InstanceNameItem" );

	delete m_wmipvrValue; m_wmipvrValue = NULL;
}

WMIParser::InstanceNameItem& WMIParser::InstanceNameItem::operator=( /*[in]*/ const InstanceNameItem& wmipini )
{
    __HCP_FUNC_ENTRY( "WMIParser::InstanceNameItem::InstanceNameItem" );

	if(m_wmipvrValue)
	{
		delete m_wmipvrValue;
	}

	m_szValue     = wmipini.m_szValue;     // MPC::wstring    m_szValue;
	m_wmipvrValue = wmipini.m_wmipvrValue; // ValueReference* m_wmipvrValue;

	//
	// The assignment actually transfers ownership of the ValueReference object!!!
	//
	InstanceNameItem* wmipini2 = const_cast<InstanceNameItem*>(&wmipini);
	wmipini2->m_wmipvrValue = NULL;

	return *this;
}


bool WMIParser::InstanceNameItem::operator==( /*[in]*/ InstanceNameItem const &wmipini ) const
{
    __HCP_FUNC_ENTRY( "WMIParser::InstanceNameItem::operator==" );

    MPC::NocaseCompare cmp;
    bool               fRes = false;


    if(cmp( m_szValue, wmipini.m_szValue ) == true)
	{
		bool leftBinary  = (        m_wmipvrValue != NULL);
		bool rightBinary = (wmipini.m_wmipvrValue != NULL);


		// If the two values are of the same kind of data, then they are comparable.
		if(leftBinary == rightBinary)
		{
			if(leftBinary)
			{
				fRes = ((*m_wmipvrValue) == (*wmipini.m_wmipvrValue));
			}
			else
			{
				fRes = true;
			}
		}
	}

    __HCP_FUNC_EXIT(fRes);
}

bool WMIParser::InstanceNameItem::operator<( /*[in]*/ InstanceNameItem const &wmipini ) const
{
    __HCP_FUNC_ENTRY( "WMIParser::InstanceNameItem::operator<" );

    MPC::NocaseLess less;
    bool            fRes = false;


    if(less( m_szValue, wmipini.m_szValue ) == true)
	{
		fRes = true;
	}
	else if(less( wmipini.m_szValue, m_szValue ) == false) // It means that the two szValue are the same...
	{
		bool leftBinary  = (        m_wmipvrValue != NULL);
		bool rightBinary = (wmipini.m_wmipvrValue != NULL);


		if(leftBinary != rightBinary)
		{
			// Different kind of data, assume that NULL is less NOT NULL

			fRes = rightBinary;
		}
		else
		{
			if(leftBinary)
			{
				fRes = (*m_wmipvrValue) < (*wmipini.m_wmipvrValue);
			}
		}
	}

    __HCP_FUNC_EXIT(fRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\wmi\wmiparser_property_array.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    WMIParser_Property_Array.cpp

Abstract:
    This file contains the implementation of the WMIParser::Property_Array class,
    which is used to hold the data of an property inside a CIM schema.

Revision History:
    Davide Massarenti   (Dmassare)  07/25/99
        created

******************************************************************************/

#include "stdafx.h"


#define TAG_VALUE L"VALUE.ARRAY/VALUE"


WMIParser::Property_Array::Property_Array()
{
    __HCP_FUNC_ENTRY( "WMIParser::Property_Array::Property_Array" );

	// ElemList m_lstElements;
}

WMIParser::Property_Array::~Property_Array()
{
    __HCP_FUNC_ENTRY( "WMIParser::Property_Array::~Property_Array" );
}

////////////////////////////////////////////////


bool WMIParser::Property_Array::operator==( /*[in]*/ Property_Array const &wmippa ) const
{
    __HCP_FUNC_ENTRY( "WMIParser::Property_Array::operator==" );

    bool fRes = (*(static_cast<Property const *>(this)) == wmippa.m_szName);

	if(fRes)
	{
		fRes = (m_lstElements == wmippa.m_lstElements);
    }


    __HCP_FUNC_EXIT(fRes);
}

////////////////////////////////////////////////

HRESULT WMIParser::Property_Array::put_Node( /*[in]*/ IXMLDOMNode* pxdnNode )
{
    __HCP_FUNC_ENTRY( "WMIParser::Property_Array::put_Node" );

    HRESULT                  hr;
    CComPtr<IXMLDOMNodeList> xdnlList;
    CComPtr<IXMLDOMNode>     xdnNode;


    __MPC_EXIT_IF_METHOD_FAILS(hr, (static_cast<Property*>(this))->put_Node( pxdnNode ));

    //
    // Get all the elements of type "VALUE".
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlNode.GetNodes( TAG_VALUE, &xdnlList ));

    for(;SUCCEEDED(hr = xdnlList->nextNode( &xdnNode )) && xdnNode != NULL; xdnNode = NULL)
    {
		ElemIter wmipvNew = m_lstElements.insert( m_lstElements.end() );

        __MPC_EXIT_IF_METHOD_FAILS(hr, wmipvNew->Parse( xdnNode, NULL ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////


HRESULT WMIParser::Property_Array::get_Data( /*[in]*/  int           iIndex ,
											 /*[out]*/ MPC::wstring& szData )
{
    __HCP_FUNC_ENTRY( "WMIParser::Property_Array::get_Data" );

    HRESULT hr;

    hr = E_NOTIMPL;

    __HCP_FUNC_EXIT(hr);
}


HRESULT WMIParser::Property_Array::put_Data( /*[in]*/  int                 iIndex , 
											 /*[in]*/  const MPC::wstring& szData ,
											 /*[out]*/ bool&               fFound )
{
    __HCP_FUNC_ENTRY( "WMIParser::Property_Array::put_Data" );

    HRESULT hr;

    hr = E_NOTIMPL;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\wmi\wmiparser_property_scalar.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    WMIParser_Property_Scalar.cpp

Abstract:
    This file contains the implementation of the WMIParser::Property_Scalar class,
    which is used to hold the data of an property inside a CIM schema.

Revision History:
    Davide Massarenti   (Dmassare)  07/25/99
        created

******************************************************************************/

#include "stdafx.h"


#define TAG_VALUE L"VALUE"


WMIParser::Property_Scalar::Property_Scalar()
{
    __HCP_FUNC_ENTRY( "WMIParser::Property_Scalar::Property_Scalar" );

	// Value m_wmipvData;
}

WMIParser::Property_Scalar::~Property_Scalar()
{
    __HCP_FUNC_ENTRY( "WMIParser::Property_Scalar::~Property_Scalar" );
}

////////////////////////////////////////////////


bool WMIParser::Property_Scalar::operator==( /*[in]*/ Property_Scalar const &wmipps ) const
{
    __HCP_FUNC_ENTRY( "WMIParser::Property_Scalar::operator==" );

    bool fRes;


	fRes = (*(static_cast<Property const *>(this)) == wmipps.m_szName);
	if(fRes)
	{
		fRes = (this->m_wmipvData == wmipps.m_wmipvData);
	}


    __HCP_FUNC_EXIT(fRes);
}

////////////////////////////////////////////////

HRESULT WMIParser::Property_Scalar::put_Node( /*[in]*/ IXMLDOMNode* pxdnNode )
{
    __HCP_FUNC_ENTRY( "WMIParser::Property_Scalar::put_Node" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, (static_cast<Property*>(this))->put_Node( pxdnNode ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, m_wmipvData.Parse( pxdnNode, TAG_VALUE ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////

HRESULT WMIParser::Property_Scalar::get_Data( /*[out]*/ MPC::wstring& szData )
{
    __HCP_FUNC_ENTRY( "WMIParser::Property_Scalar::get_Data" );

    HRESULT hr;


	hr = m_wmipvData.get_Data( szData );


    __HCP_FUNC_EXIT(hr);
}


HRESULT WMIParser::Property_Scalar::put_Data( /*[in]*/  const MPC::wstring& szData ,
											  /*[out]*/ bool&               fFound )
{
    __HCP_FUNC_ENTRY( "WMIParser::Property_Scalar::put_Data" );

    HRESULT     hr;
    CComVariant vValue( szData.c_str() );


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlNode.PutValue( TAG_VALUE, vValue, fFound ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\wmi\wmiparser_value.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    WMIParser_Value.cpp

Abstract:
    This file contains the implementation of the WMIParser::Value class,
    which is used to hold the data of an value inside a CIM schema.

Revision History:
    Davide Massarenti   (Dmassare)  07/01/99
        created

******************************************************************************/

#include "stdafx.h"

WMIParser::Value::Value()
{
    __HCP_FUNC_ENTRY( "WMIParser::Value::Value" );


    m_lData   = 0;    // long         m_lData;
    m_rgData  = NULL; // BYTE*        m_rgData;
                      // MPC::wstring m_szData;
}

WMIParser::Value::~Value()
{
    __HCP_FUNC_ENTRY( "WMIParser::Value::~Value" );


    if(m_rgData)
    {
        delete [] m_rgData;

        m_rgData = NULL;
    }
}

////////////////////////////////////////////////


bool WMIParser::Value::operator==( /*[in]*/ Value const &wmipv ) const
{
    __HCP_FUNC_ENTRY( "WMIParser::Value::operator==" );

    bool               fRes = true;
    MPC::NocaseCompare cmp;
	bool               leftBinary  = (      m_rgData != NULL);
	bool               rightBinary = (wmipv.m_rgData != NULL);


	if(leftBinary != rightBinary)
	{
		fRes = false; // Different kind of data, not comparable.
	}
	else
	{
		if(leftBinary)
		{
			// Binary Data, do byte-to-byte comparison.
			if(          m_lData != wmipv.m_lData            ) fRes = false;
			if(::memcmp( m_rgData , wmipv.m_rgData, m_lData )) fRes = false;
		}
		else
		{
			// Text Data, do string comparison.
			if(m_szData != wmipv.m_szData) fRes = false;
		}
	}

    __HCP_FUNC_EXIT(fRes);
}

////////////////////////////////////////////////

HRESULT WMIParser::Value::Parse( /*[in] */ IXMLDOMNode* pxdnNode ,
								 /*[in]*/  LPCWSTR      szTag    )
{
    __HCP_FUNC_ENTRY( "WMIParser::Value::Parse" );

    HRESULT      hr;
    MPC::XmlUtil xmlNode( pxdnNode );
    CComVariant  vValue;
    bool         fFound;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_NOTNULL(pxdnNode);
	__MPC_PARAMCHECK_END();


    //
    // Analize the node...
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, xmlNode.GetValue( szTag, vValue, fFound ));
    if(fFound)
	{
		if(vValue.vt == VT_BSTR)
		{
			m_szData = OLE2W( vValue.bstrVal );
		}
		else if(SUCCEEDED(vValue.ChangeType( VT_ARRAY | VT_UI1 )))
		{
			long  lLBound;
			long  lUBound;
			BYTE* rgData;

			__MPC_EXIT_IF_METHOD_FAILS(hr, SafeArrayGetLBound( vValue.parray, 1, &lLBound ));
			__MPC_EXIT_IF_METHOD_FAILS(hr, SafeArrayGetUBound( vValue.parray, 1, &lUBound ));

			m_lData = lUBound - lLBound + 1;
			__MPC_EXIT_IF_ALLOC_FAILS(hr, m_rgData, new BYTE[m_lData]);

			__MPC_EXIT_IF_METHOD_FAILS(hr, SafeArrayAccessData( vValue.parray, (void **)&rgData ));

			CopyMemory( m_rgData, rgData, m_lData );

			__MPC_EXIT_IF_METHOD_FAILS(hr, SafeArrayUnaccessData( vValue.parray ));
		}
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////

HRESULT WMIParser::Value::get_Data( /*[out]*/ long&  lData  ,
									/*[out]*/ BYTE*& rgData )
{
    __HCP_FUNC_ENTRY( "WMIParser::Value::get_Data" );

    HRESULT hr;


    lData  = m_lData;
    rgData = m_rgData;
    hr     = S_OK;


    __HCP_FUNC_EXIT(hr);
}

HRESULT WMIParser::Value::get_Data( /*[out]*/ MPC::wstring& szData )
{
    __HCP_FUNC_ENTRY( "WMIParser::Value::get_Data" );

    HRESULT hr;


    szData = m_szData;
    hr     = S_OK;


    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\wmi\wmiparser_snapshot.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    WMIParser_Snapshot.cpp

Abstract:
    This file contains the implementation of the WMIParser::Snapshot class,
    which is used to hold the data of an snapshot inside a CIM schema.

Revision History:
    Davide Massarenti   (Dmassare)  07/25/99
        created

******************************************************************************/

#include "stdafx.h"


#define TAG_DECLARATION L"DECLARATION"
#define TAG_DECLGROUP   L"DECLGROUP.WITHPATH"


//const LPCWSTR l_Instances[] = { L"DECLARATION/DECLGROUP/VALUE.OBJECT"                      ,
//								  L"DECLARATION/DECLGROUP.WITHNAME/VALUE.NAMEDOBJECT"        ,
//								  L"DECLARATION/DECLGROUP.WITHPATH/VALUE.OBJECTWITHPATH"     ,
//								  L"DECLARATION/DECLGROUP.WITHPATH/VALUE.OBJECTWITHLOCALPATH" };

static const WCHAR   l_InstancesRoot[] = L"DECLARATION/DECLGROUP.WITHPATH";

static const LPCWSTR l_Instances[] = { L"DECLARATION/DECLGROUP.WITHPATH/VALUE.OBJECTWITHPATH"     ,
									   L"DECLARATION/DECLGROUP.WITHPATH/VALUE.OBJECTWITHLOCALPATH" };

static CComBSTR l_EmptyCIM( L"<?xml version=\"1.0\" encoding=\"unicode\"?><CIM CIMVERSION=\"2.0\" DTDVERSION=\"2.0\"><DECLARATION><DECLGROUP.WITHPATH></DECLGROUP.WITHPATH></DECLARATION></CIM>" );


WMIParser::Snapshot::Snapshot()
{
    __HCP_FUNC_ENTRY( "WMIParser::Snapshot::Snapshot" );

    // MPC_XmlUtil m_xmlNode;
    //
    // InstList    m_lstInstances;
}

WMIParser::Snapshot::~Snapshot()
{
    __HCP_FUNC_ENTRY( "WMIParser::Snapshot::~Snapshot" );
}

HRESULT WMIParser::Snapshot::Parse()
{
    __HCP_FUNC_ENTRY( "WMIParser::Snapshot::Parse" );

    HRESULT                  hr;
    CComPtr<IXMLDOMNodeList> xdnlList;
    CComPtr<IXMLDOMNode>     xdnNode;
    bool                     fEmpty;
	int                      iPass;


    m_lstInstances.clear();


	for(iPass=0; iPass<sizeof(l_Instances)/sizeof(*l_Instances); iPass++,xdnlList=NULL,xdnNode=NULL)
	{
		//
		// Get all the elements of type "INSTANCE".
		//
		__MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlNode.GetNodes( l_Instances[iPass], &xdnlList ));

		for(;SUCCEEDED(hr = xdnlList->nextNode( &xdnNode )) && xdnNode != NULL; xdnNode = NULL)
		{
			InstIter wmipiNew = m_lstInstances.insert( m_lstInstances.end() );

			__MPC_EXIT_IF_METHOD_FAILS(hr, wmipiNew->put_Node( xdnNode, fEmpty ));
			if(fEmpty == true)
			{
				//
				// The instance appears to be empty, so don't use it.
				//
				m_lstInstances.erase( wmipiNew );
			}
		}
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////

HRESULT WMIParser::Snapshot::put_Node( /*[in]*/ IXMLDOMNode* pxdnNode )
{
    __HCP_FUNC_ENTRY( "WMIParser::Snapshot::put_Node" );

    _ASSERT(pxdnNode != NULL);

    HRESULT hr;


    m_xmlNode = pxdnNode;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Parse());

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT WMIParser::Snapshot::get_Node( /*[out]*/ IXMLDOMNode* *pxdnNode )
{
    __HCP_FUNC_ENTRY( "WMIParser::Snapshot::get_Node" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlNode.GetRoot( pxdnNode ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT WMIParser::Snapshot::get_NodeForInstances( /*[out]*/ IXMLDOMNode* *pxdnNode )
{
    __HCP_FUNC_ENTRY( "WMIParser::Snapshot::get_NodeForInstances" );

    HRESULT hr;


	if(m_xdnInstances == NULL)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlNode.GetNode( l_InstancesRoot, &m_xdnInstances ));
		if(m_xdnInstances == NULL)
		{
			__MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
		}
	}

	__MPC_EXIT_IF_METHOD_FAILS(hr, m_xdnInstances->QueryInterface( IID_IXMLDOMNode, (void **)pxdnNode ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////

HRESULT WMIParser::Snapshot::get_Instances( /*[out]*/ InstIterConst& itBegin ,
											/*[out]*/ InstIterConst& itEnd   )
{
    __HCP_FUNC_ENTRY( "WMIParser::Snapshot::get_Instances" );

    HRESULT hr;


    itBegin = m_lstInstances.begin();
    itEnd   = m_lstInstances.end  ();
    hr      = S_OK;


    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////

HRESULT WMIParser::Snapshot::clone_Instance( /*[in] */ Instance*  pwmipiOld ,
											 /*[out]*/ Instance*& pwmipiNew )
{
    __HCP_FUNC_ENTRY( "WMIParser::Snapshot::clone" );

    HRESULT              hr;
    CComPtr<IXMLDOMNode> xdnNode;
    CComPtr<IXMLDOMNode> xdnNodeCloned;
    CComPtr<IXMLDOMNode> xdnNodeParent;
    CComPtr<IXMLDOMNode> xdnNodeReplaced;


	pwmipiNew = NULL;


    //
    // Get the XML node of old instance.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, pwmipiOld->get_Node( &xdnNode ));

    //
    // Make a copy of it.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, xdnNode->cloneNode( VARIANT_TRUE, &xdnNodeCloned ));


    //
    // Get the root of our document.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, get_NodeForInstances( &xdnNodeParent ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, xdnNodeParent->appendChild( xdnNodeCloned, &xdnNodeReplaced ));


    //
    // Create a new INSTANCE object, attach it to the XML node and insert it in the list of instances.
    //
	{
		InstIter wmipiNew = m_lstInstances.insert( m_lstInstances.end() );
		bool     fEmpty;

		__MPC_EXIT_IF_METHOD_FAILS(hr, wmipiNew->put_Node( xdnNodeReplaced, fEmpty ));

		pwmipiNew = &(*wmipiNew);
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////
////////////////////////////////////////////////
////////////////////////////////////////////////

HRESULT WMIParser::Snapshot::New()
{
    __HCP_FUNC_ENTRY( "WMIParser::Snapshot::New" );

    HRESULT                  hr;
    CComPtr<IXMLDOMDocument> xddDoc;
	VARIANT_BOOL             fLoaded;


    //
    // Create the DOM object.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateInstance( CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument, (void**)&xddDoc ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, xddDoc->loadXML( l_EmptyCIM, &fLoaded ));
	if(fLoaded == VARIANT_FALSE)
	{
        __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
	}
	else
	{
		MPC::XmlUtil 		 xml( xddDoc );
		CComPtr<IXMLDOMNode> xdnRoot;

		__MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetRoot( &xdnRoot ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlNode.New( xdnRoot, TRUE ));
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT WMIParser::Snapshot::Load( /*[in]*/ LPCWSTR szFile    ,
								   /*[in]*/ LPCWSTR szRootTag )
{
    __HCP_FUNC_ENTRY( "WMIParser::Snapshot::Load" );

    HRESULT hr;
    bool    fLoaded;


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlNode.Load( szFile, szRootTag, fLoaded ));
    if(fLoaded == false)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, Parse());

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT WMIParser::Snapshot::Save( /*[in]*/ LPCWSTR szFile )
{
    __HCP_FUNC_ENTRY( "WMIParser::Snapshot::Save" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlNode.Save( szFile ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\saf\wmi\wmiparser_valuereference.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    WMIParser_ValueReference.cpp

Abstract:
    This file contains the implementation of the WMIParser::ValueReference class,
    which is used to hold the data of an value reference inside a CIM schema.

Revision History:
    Davide Massarenti   (Dmassare)  07/01/99
        created

******************************************************************************/

#include "stdafx.h"

WMIParser::ValueReference::ValueReference()
{
    __HCP_FUNC_ENTRY( "WMIParser::ValueReference::ValueReference" );

	// InstanceName wmipin;
}

WMIParser::ValueReference::~ValueReference()
{
    __HCP_FUNC_ENTRY( "WMIParser::ValueReference::~ValueReference" );
}

////////////////////////////////////////////////


bool WMIParser::ValueReference::operator==( /*[in]*/ ValueReference const &wmipvr ) const
{
    __HCP_FUNC_ENTRY( "WMIParser::ValueReference::operator==" );

    bool fRes = (m_wmipin == wmipvr.m_wmipin);

    __HCP_FUNC_EXIT(fRes);
}

bool WMIParser::ValueReference::operator<( /*[in]*/ ValueReference const &wmipvr ) const
{
    __HCP_FUNC_ENTRY( "WMIParser::ValueReference::operator<" );

    bool fRes = (m_wmipin < wmipvr.m_wmipin);

    __HCP_FUNC_EXIT(fRes);
}

////////////////////////////////////////////////

HRESULT WMIParser::ValueReference::Parse( /*[in] */ IXMLDOMNode* pxdnNode )
{
    __HCP_FUNC_ENTRY( "WMIParser::ValueReference::Parse" );

    HRESULT hr;
	bool    fEmpty;


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_wmipin.put_Node( pxdnNode, fEmpty ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////

HRESULT WMIParser::ValueReference::get_Data( /*[out]*/ InstanceName*& wmipin )
{
    __HCP_FUNC_ENTRY( "WMIParser::ValueReference::get_Data" );

    HRESULT hr;


	wmipin = &m_wmipin;
    hr     = S_OK;


    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\scriptingframework\cabinet.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Cabinet.cpp

Abstract:
    This file contains the implementation of the CSAFCabinet class,
    which implements the data collection functionality.

Revision History:
    Davide Massarenti   (Dmassare)  08/25/99
        created

******************************************************************************/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////

#define CHECK_MODIFY()  __MPC_EXIT_IF_METHOD_FAILS(hr, CanModifyProperties())

/////////////////////////////////////////////////////////////////////////////

CSAFCabinet::CSAFCabinet()
{
    __HCP_FUNC_ENTRY( "CSAFCabinet::CSAFCabinet" );

                               // MPC::Impersonation m_imp;
                               // 					 
                               // MPC::Cabinet       m_cab;
                               //					 
    m_hResult  = 0;            // HRESULT            m_hResult;
    m_cbStatus = CB_NOTACTIVE; // CB_STATUS          m_cbStatus;
                               //
                               // CComPtr<IDispatch> m_sink_onProgressFiles;
                               // CComPtr<IDispatch> m_sink_onProgressBytes;
                               // CComPtr<IDispatch> m_sink_onComplete;


    (void)m_cab.put_IgnoreMissingFiles( TRUE             );
    (void)m_cab.put_UserData          ( this             );
    (void)m_cab.put_onProgress_Files  ( fnCallback_Files );
    (void)m_cab.put_onProgress_Bytes  ( fnCallback_Bytes );
}

void CSAFCabinet::FinalRelease()
{
    __HCP_FUNC_ENTRY( "CSAFCabinet::FinalRelease" );

    (void)Abort();

    Thread_Wait();
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT CSAFCabinet::Run()
{
    __HCP_FUNC_ENTRY( "CSAFCabinet::Run" );

    HRESULT                      hr;
    BOOL                         res;
    MPC::SmartLock<_ThreadModel> lock( this );


    ::SetThreadPriority( ::GetCurrentThread(), THREAD_PRIORITY_LOWEST );

	__MPC_TRY_BEGIN();

    put_Status( CB_COMPRESSING );


	__MPC_EXIT_IF_METHOD_FAILS(hr, m_imp.Impersonate());
	lock = NULL;
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_cab.Compress());
	lock = this;
	__MPC_EXIT_IF_METHOD_FAILS(hr, m_imp.RevertToSelf());


    put_Status( CB_COMPLETED );
    hr = S_OK;

    __HCP_FUNC_CLEANUP;

	__MPC_TRY_CATCHALL(hr);

	lock = this;

    m_hResult  = hr;
    if(FAILED(hr))
    {
        put_Status( CB_FAILED );
    }

    //
    // Release the lock on current object, otherwise a deadlock could occur.
    //
    lock = NULL;

    Fire_onComplete( this, hr );

    Thread_Abort(); // To tell the MPC:Thread object to close the worker thread...

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

////////////////
//            //
// Properties //
//            //
////////////////

STDMETHODIMP CSAFCabinet::put_IgnoreMissingFiles( /*[in]*/ VARIANT_BOOL fIgnoreMissingFiles )
{
    __HCP_BEGIN_PROPERTY_PUT("CSAFCabinet::put_IgnoreMissingFiles",hr);

    CHECK_MODIFY();


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_cab.put_IgnoreMissingFiles( fIgnoreMissingFiles == VARIANT_TRUE ));


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CSAFCabinet::put_onProgressFiles( /*[in]*/ IDispatch* function )
{
    __HCP_BEGIN_PROPERTY_PUT("CSAFCabinet::put_onProgressFiles",hr);

    CHECK_MODIFY();

    m_sink_onProgressFiles = function;


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CSAFCabinet::put_onProgressBytes( /*[in]*/ IDispatch* function )
{
    __HCP_BEGIN_PROPERTY_PUT("CSAFCabinet::put_onProgressBytes",hr);

    CHECK_MODIFY();

    m_sink_onProgressBytes = function;


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CSAFCabinet::put_onComplete( /*[in]*/ IDispatch* function )
{
    __HCP_BEGIN_PROPERTY_PUT("CSAFCabinet::put_onComplete",hr);

    CHECK_MODIFY();

    m_sink_onComplete = function;


    __HCP_END_PROPERTY(hr);
}


HRESULT CSAFCabinet::put_Status( /*[in]*/ CB_STATUS pVal ) // Inner method
{
    __HCP_FUNC_ENTRY( "CSAFCabinet::put_Status" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


    m_cbStatus = pVal;
    hr         = S_OK;


    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CSAFCabinet::get_Status( /*[out]*/ CB_STATUS *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CSAFCabinet::get_Status",hr,pVal,m_cbStatus);

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CSAFCabinet::get_ErrorCode( /*[out]*/ long *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CSAFCabinet::get_ErrorCode",hr,pVal,m_hResult);

    __HCP_END_PROPERTY(hr);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CSAFCabinet::AddFile( /*[in]*/ BSTR    bstrFilePath ,
                                   /*[in]*/ VARIANT vFileName    )
{
    __HCP_FUNC_ENTRY( "CSAFCabinet::AddFile" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
	LPCWSTR                      szFileName = (vFileName.vt == VT_BSTR ? SAFEBSTR( vFileName.bstrVal ) : L"");

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrFilePath);
	__MPC_PARAMCHECK_END();

    CHECK_MODIFY();


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_cab.AddFile( bstrFilePath, szFileName ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CSAFCabinet::Compress( /*[in]*/ BSTR bstrCabinetFile )
{
    __HCP_FUNC_ENTRY( "CSAFCabinet::Compress" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrCabinetFile);
	__MPC_PARAMCHECK_END();

    CHECK_MODIFY();


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_cab.put_CabinetFile( bstrCabinetFile ));


    //
    // Release the lock on current object, otherwise a deadlock could occur.
    //
    lock = NULL;

	__MPC_EXIT_IF_METHOD_FAILS(hr, m_imp.Initialize());

    __MPC_EXIT_IF_METHOD_FAILS(hr, Thread_Start( this, Run, NULL ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CSAFCabinet::Abort()
{
    __HCP_FUNC_ENTRY( "CSAFCabinet::Abort" );

    Thread_Abort(); // To tell the MPC:Thread object to close the worker thread...

    __HCP_FUNC_EXIT(S_OK);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//////////////////////
//                  //
// Callback Methods //
//                  //
//////////////////////

HRESULT CSAFCabinet::fnCallback_Files( MPC::Cabinet* cabinet, LPCWSTR szFile, ULONG lDone, ULONG lTotal, LPVOID user )
{
    CSAFCabinet* pThis = (CSAFCabinet*)user;
    HRESULT      hr;

    if(pThis->Thread_IsAborted())
    {
        hr = E_FAIL;
    }
    else
    {
        hr = pThis->Fire_onProgressFiles( pThis, CComBSTR( szFile ), lDone, lTotal );
    }

    return hr;
}

HRESULT CSAFCabinet::fnCallback_Bytes( MPC::Cabinet* cabinet, ULONG lDone, ULONG lTotal, LPVOID user )
{
    CSAFCabinet* pThis = (CSAFCabinet*)user;
    HRESULT      hr;

    if(pThis->Thread_IsAborted())
    {
        hr = E_FAIL;
    }
    else
    {
        hr = pThis->Fire_onProgressBytes( pThis, lDone, lTotal );
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//////////////////////////
//                      //
// Event Firing Methods //
//                      //
//////////////////////////

HRESULT CSAFCabinet::Fire_onProgressFiles( ISAFCabinet* hcpcb, BSTR bstrFile, long lDone, long lTotal )
{
    CComVariant pvars[4];

    pvars[3] = hcpcb;
    pvars[2] = bstrFile;
    pvars[1] = lDone;
    pvars[0] = lTotal;

    return FireAsync_Generic( DISPID_SAF_CBE__ONPROGRESSFILES, pvars, ARRAYSIZE( pvars ), m_sink_onProgressFiles );
}

HRESULT CSAFCabinet::Fire_onProgressBytes( ISAFCabinet* hcpcb, long lDone, long lTotal )
{
    CComVariant pvars[3];

    pvars[2] = hcpcb;
    pvars[1] = lDone;
    pvars[0] = lTotal;

    return FireAsync_Generic( DISPID_SAF_CBE__ONPROGRESSBYTES, pvars, ARRAYSIZE( pvars ), m_sink_onProgressBytes );
}

HRESULT CSAFCabinet::Fire_onComplete( ISAFCabinet* hcpcb, HRESULT hrRes )
{
    CComVariant pvars[2];

    pvars[1] = hcpcb;
    pvars[0] = hrRes;

    return FireAsync_Generic( DISPID_SAF_CBE__ONCOMPLETE, pvars, ARRAYSIZE( pvars ), m_sink_onComplete );
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////
//                 //
// Utility Methods //
//                 //
/////////////////////

HRESULT CSAFCabinet::CanModifyProperties()
{
    __HCP_FUNC_ENTRY( "CSAFCabinet::CanModifyProperties" );

    HRESULT hr = E_ACCESSDENIED;


    if(m_cbStatus != CB_COMPRESSING)
    {
        hr = S_OK;
    }


    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\scriptingframework\queryresult.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    HPCQueryResult.cpp

Abstract:
    This file contains the implementation of the CHPCQueryResult class,
    the descriptor of all the query results.

Revision History:
    Davide Massarenti   (Dmassare)  07/26/99
        created

******************************************************************************/

#include "stdafx.h"




CPCHQueryResult::Payload::Payload()
{
                              // CComBSTR m_bstrCategory;
                              // CComBSTR m_bstrEntry;
                              // CComBSTR m_bstrTopicURL;
                              // CComBSTR m_bstrIconURL;
                              // CComBSTR m_bstrTitle;
                              // CComBSTR m_bstrDescription;
    m_lType     = 0;          // long     m_lType;
    m_lPos      = 0;          // long     m_lPos;
    m_fVisible  = true;       // bool     m_fVisible;
    m_fSubsite  = true;       // bool     m_fSubsite;
    m_lNavModel = QR_DEFAULT; // long     m_lNavModel;
    m_lPriority = 0;          // long     m_lPriority;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////


CPCHQueryResult::CPCHQueryResult()
{
    // Payload m_data;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CPCHQueryResult::Load( /*[in]*/ MPC::Serializer& streamIn )
{
    __HCP_FUNC_ENTRY( "CPCHQueryResult::Load" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_data.m_bstrCategory   );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_data.m_bstrEntry      );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_data.m_bstrTopicURL   );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_data.m_bstrIconURL    );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_data.m_bstrTitle      );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_data.m_bstrDescription);
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_data.m_lType          );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_data.m_lPos           );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_data.m_fVisible       );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_data.m_fSubsite       );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_data.m_lNavModel      );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_data.m_lPriority      );


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHQueryResult::Save( /*[in]*/ MPC::Serializer& streamOut ) const
{
    __HCP_FUNC_ENTRY( "CPCHQueryResult::Save" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_data.m_bstrCategory   );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_data.m_bstrEntry      );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_data.m_bstrTopicURL   );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_data.m_bstrIconURL    );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_data.m_bstrTitle      );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_data.m_bstrDescription);
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_data.m_lType          );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_data.m_lPos           );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_data.m_fVisible       );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_data.m_fSubsite       );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_data.m_lNavModel      );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_data.m_lPriority      );


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void CPCHQueryResult::Initialize( /*[in]*/ Payload& data )
{
    m_data = data;
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHQueryResult::get_Category( /*[out]*/ BSTR *pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::GetBSTR( m_data.m_bstrCategory, pVal );
}

STDMETHODIMP CPCHQueryResult::get_Entry( /*[out]*/ BSTR *pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::GetBSTR( m_data.m_bstrEntry, pVal );
}

STDMETHODIMP CPCHQueryResult::get_TopicURL( /*[out]*/ BSTR *pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::GetBSTR( m_data.m_bstrTopicURL, pVal );
}

STDMETHODIMP CPCHQueryResult::get_IconURL( /*[out]*/ BSTR *pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::GetBSTR( m_data.m_bstrIconURL, pVal );
}

STDMETHODIMP CPCHQueryResult::get_Title( /*[out]*/ BSTR *pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::GetBSTR( m_data.m_bstrTitle, pVal );
}

STDMETHODIMP CPCHQueryResult::get_Description( /*[out]*/ BSTR *pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::GetBSTR( m_data.m_bstrDescription, pVal );
}

STDMETHODIMP CPCHQueryResult::get_Type( /*[out]*/ long *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CPCHQueryResult::get_Type",hr,pVal,m_data.m_lType);

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHQueryResult::get_Pos( /*[out]*/ long *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CPCHQueryResult::get_Pos",hr,pVal,m_data.m_lPos);

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHQueryResult::get_Visible( /*[out]*/ VARIANT_BOOL *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CPCHQueryResult::get_Visible",hr,pVal,(m_data.m_fVisible ? VARIANT_TRUE : VARIANT_FALSE));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHQueryResult::get_Subsite( /*[out]*/ VARIANT_BOOL *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CPCHQueryResult::get_Subsite",hr,pVal,(m_data.m_fSubsite ? VARIANT_TRUE : VARIANT_FALSE));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHQueryResult::get_NavigationModel( /*[out]*/ QR_NAVMODEL *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CPCHQueryResult::get_NavigationModel",hr,pVal,(QR_NAVMODEL)m_data.m_lNavModel);

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHQueryResult::get_Priority( /*[out]*/ long *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CPCHQueryResult::get_Priority",hr,pVal,m_data.m_lPriority);

    __HCP_END_PROPERTY(hr);
}


STDMETHODIMP CPCHQueryResult::get_FullPath( /*[out]*/ BSTR *pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );
    MPC::wstring                 strFullPath; strFullPath.reserve( 512 );

    if(STRINGISPRESENT(m_data.m_bstrCategory))
    {
        strFullPath += m_data.m_bstrCategory;

        if(STRINGISPRESENT(m_data.m_bstrEntry))
        {
            strFullPath += L"/";
            strFullPath += m_data.m_bstrEntry;
        }
    }
    else if(STRINGISPRESENT(m_data.m_bstrEntry))
    {
        strFullPath += m_data.m_bstrEntry;
    }

    return MPC::GetBSTR( strFullPath.c_str(), pVal );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\scriptingframework\queryresultcollection.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    QueryResultCollection.cpp

Abstract:
    This file contains the implementation of the CPCHQueryResultCollection class,
    which is used to store results of queries.

Revision History:
    Davide Massarenti   (Dmassare)  07/26/99
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

static const DWORD l_dwVersion = 0x02425251; // QRC 02

////////////////////////////////////////////////////////////////////////////////

struct ElementHolder
{
    CPCHQueryResult* obj;
    long             pos;
};

class ElementSorter
{
    CPCHQueryResultCollection::SortMode m_mode;

public:
    ElementSorter( /*[in]*/ CPCHQueryResultCollection::SortMode mode ) : m_mode(mode) {}

    bool operator()( ElementHolder& left, ElementHolder& right )
    {
        const CPCHQueryResult::Payload& leftData  = left .obj->GetData();
        const CPCHQueryResult::Payload& rightData = right.obj->GetData();
        int                             iCmp      = 0;

		//
		// Priority is sorted from highest to lowest, so negate iCmp;
		//
        switch(m_mode)
        {
        case CPCHQueryResultCollection::SORT_BYCONTENTTYPE: iCmp = 			   ( leftData.m_lType     	- rightData.m_lType    	   ); break;
        case CPCHQueryResultCollection::SORT_BYPRIORITY   : iCmp = 			  -( leftData.m_lPriority 	- rightData.m_lPriority	   ); break;
        case CPCHQueryResultCollection::SORT_BYURL        : iCmp = MPC::StrICmp( leftData.m_bstrTopicURL, rightData.m_bstrTopicURL ); break;
        case CPCHQueryResultCollection::SORT_BYTITLE      : iCmp = MPC::StrICmp( leftData.m_bstrTitle   , rightData.m_bstrTitle    ); break;
        }

        if(iCmp < 0) return true;
        if(iCmp > 0) return false;

        return (left.pos < right.pos);
    }
};

////////////////////////////////////////////////////////////////////////////////

CPCHQueryResultCollection::CPCHQueryResultCollection()
{
    // List m_results;
}

CPCHQueryResultCollection::~CPCHQueryResultCollection()
{
    Erase();
}

////////////////////////////////////////

HRESULT CPCHQueryResultCollection::MakeLocalCopyIfPossible( /*[in]*/  IPCHCollection*  pRemote ,
                                                            /*[out]*/ IPCHCollection* *pLocal  )
{
    __HCP_FUNC_ENTRY( "CPCHQueryResultCollection::MakeLocalCopyIfPossible" );

    HRESULT                            hr;
    CComPtr<CPCHQueryResultCollection> pColl;
    CComPtr<IPersistStream>            persistRemote;
    CComPtr<IPersistStream>            persistLocal;
    CComPtr<IStream>                   stream;
    MPC::Serializer_IStream            ser;


    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pRemote);
        __MPC_PARAMCHECK_POINTER_AND_SET(pLocal,NULL);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pColl ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, pRemote->QueryInterface( IID_IPersistStream, (void**)&persistRemote ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pColl  ->QueryInterface( IID_IPersistStream, (void**)&persistLocal  ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, ser.GetStream          (                             &stream        ));

    //
    // Convert from stream to live object.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, persistRemote->Save( stream, FALSE ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, ser.Reset          (               )); // Rewind stream.
    __MPC_EXIT_IF_METHOD_FAILS(hr, persistLocal ->Load( stream        ));

    *pLocal = pColl.Detach();

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    //
    // In case of failure, use the remote copy...
    //
    if(FAILED(hr) && pRemote && pLocal)
    {
        (*pLocal = pRemote)->AddRef();
    }

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

STDMETHODIMP CPCHQueryResultCollection::GetClassID( /*[out]*/ CLSID *pClassID )
{
    return E_NOTIMPL;
}

STDMETHODIMP CPCHQueryResultCollection::IsDirty()
{
    return S_FALSE;
}

STDMETHODIMP CPCHQueryResultCollection::Load( /*[in]*/ IStream *pStm )
{
    MPC::Serializer_IStream   stream ( pStm   );
    MPC::Serializer_Buffering stream2( stream );

    return pStm ? Load( stream2 ) : E_POINTER;
}

STDMETHODIMP CPCHQueryResultCollection::Save( /*[in]*/ IStream *pStm, /*[in]*/ BOOL fClearDirty )
{
    HRESULT                   hr;
    MPC::Serializer_IStream   stream ( pStm   );
    MPC::Serializer_Buffering stream2( stream );


    if(pStm)
    {
        if(SUCCEEDED(hr = Save( stream2 ))) hr = stream2.Flush();
    }
    else
    {
        hr = E_POINTER;
    }


    return hr;
}

STDMETHODIMP CPCHQueryResultCollection::GetSizeMax( /*[out]*/ ULARGE_INTEGER *pcbSize )
{
    return E_NOTIMPL;
}

////////////////////////////////////////

int CPCHQueryResultCollection::Size() const
{
    return m_results.size();
}

void CPCHQueryResultCollection::Erase()
{
    CPCHBaseCollection::Erase();

    MPC::ReleaseAll( m_results );
}

HRESULT CPCHQueryResultCollection::Load( /*[in]*/ MPC::Serializer& streamIn )
{
    __HCP_FUNC_ENTRY( "CPCHQueryResultCollection::Load" );

    HRESULT                  hr;
    CComPtr<CPCHQueryResult> item;
    DWORD                    dwVer;
    int                      iCount;


    Erase();


    if(FAILED(streamIn >> dwVer ) || dwVer != l_dwVersion) __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    if(FAILED(streamIn >> iCount)                        ) __MPC_SET_ERROR_AND_EXIT(hr, S_OK);

    for(int i=0; i<iCount; i++)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, CreateItem( &item ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, item->Load( streamIn ));

        item.Release();
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHQueryResultCollection::Save( /*[in]*/ MPC::Serializer& streamOut ) const
{
    __HCP_FUNC_ENTRY( "CPCHQueryResultCollection::Save" );

    HRESULT hr;
    Iter    it;
    DWORD   dwVer  = l_dwVersion;
    int     iCount = m_results.size();


    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << dwVer  );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << iCount );

    for(it = m_results.begin(); it != m_results.end(); it++)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, (*it)->Save( streamOut ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHQueryResultCollection::CreateItem( /*[out]*/ CPCHQueryResult* *item )
{
    __HCP_FUNC_ENTRY( "CPCHQueryResultCollection::CreateItem" );

    HRESULT                  hr;
    CComPtr<CPCHQueryResult> hpcqr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(item,NULL);
    __MPC_PARAMCHECK_END();


    //
    // Create a new item and link it to the system.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &hpcqr )); (*item = hpcqr)->AddRef();
    __MPC_EXIT_IF_METHOD_FAILS(hr, AddItem( hpcqr ));

    m_results.push_back( hpcqr.Detach() );


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHQueryResultCollection::GetItem( /*[in]*/ long lPos, /*[out]*/ CPCHQueryResult* *item )
{
    __HCP_FUNC_ENTRY( "CPCHQueryResultCollection::GetItem" );

    HRESULT hr;
    Iter    it;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(item,NULL);
    __MPC_PARAMCHECK_END();

    it = m_results.begin();
    while(1)
    {
        if(it == m_results.end())
        {
            __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
        }

        if(lPos-- == 0) break;

        it++;
    }

    (*item = *it)->AddRef();

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CPCHQueryResultCollection::LoadFromCache( /*[in]*/ IStream* stream )
{
    __HCP_FUNC_ENTRY( "CPCHQueryResultCollection::LoadFromCache" );

    HRESULT                   hr;
    MPC::Serializer_IStream   streamReal( stream     );
    MPC::Serializer_Buffering streamBuf ( streamReal );


    Erase();


    __MPC_EXIT_IF_METHOD_FAILS(hr, Load( streamBuf ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHQueryResultCollection::SaveToCache( /*[in]*/ IStream* stream ) const
{
    __HCP_FUNC_ENTRY( "CPCHQueryResultCollection::SaveToCache" );

    HRESULT                   hr;
    MPC::Serializer_IStream   streamReal( stream     );
    MPC::Serializer_Buffering streamBuf ( streamReal );


    __MPC_EXIT_IF_METHOD_FAILS(hr, Save( streamBuf ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf.Flush());


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHQueryResultCollection::Sort( /*[in]*/ SortMode mode, /*[in]*/ int iLimit )
{
    __HCP_FUNC_ENTRY( "CPCHQueryResultCollection::Sort" );

    HRESULT        hr;
	ElementHolder* ptr;
    ElementHolder* rgBuf = NULL;
    int            iSize = m_results.size();
	int            i;

    if(iSize > 1)
    {
		ElementSorter  sorted( mode );
		Iter           it;

        __MPC_EXIT_IF_ALLOC_FAILS(hr, rgBuf, new ElementHolder[iSize]);

        for(i=0, ptr=rgBuf, it=m_results.begin(); i<iSize && it!=m_results.end(); i++, ptr++, it++)
        {
            CPCHQueryResult* obj = *it;

            ptr->obj = obj; obj->AddRef();
            ptr->pos = i;
        }

		std::sort( rgBuf, ptr, sorted );

		if(iLimit < 0 || iLimit > iSize) iLimit = iSize;

		Erase();
        for(i=0, ptr=rgBuf; i<iLimit; i++, ptr++)
        {
			__MPC_EXIT_IF_METHOD_FAILS(hr, AddItem( ptr->obj ));

			m_results.push_back( ptr->obj ); ptr->obj = NULL;
		}
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(rgBuf)
    {
        for(i=0, ptr=rgBuf; i<iSize; i++, ptr++)
        {
            if(ptr->obj) ptr->obj->Release();
        }

        delete [] rgBuf;
    }

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\scriptingframework\setofhelptopics.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    SetOfHelpTopics.cpp

Abstract:
    This file contains the implementation of the CPCHSetOfHelpTopics class,
    that models the set of help file for a particular SKU/Language pair.

Revision History:
    Davide Massarenti   (Dmassare)  07/01/2000
        created

******************************************************************************/

#include "stdafx.h"

#include <MergedHhk.h>
#include <algorithm>

static const WCHAR c_SetupImage    [] = L"PCHDT_";
static const WCHAR c_CabExtension  [] = L".cab";
static const WCHAR c_ListPrefix    [] = L"[SourceDisksFiles]";
static const WCHAR c_ListPrefixX86 [] = L"[SourceDisksFiles.x86]";
static const WCHAR c_ListPrefixIA64[] = L"[SourceDisksFiles.";

////////////////////////////////////////////////////////////////////////////////

static HRESULT Local_ParseLayoutInf( /*[in ]*/ LPCWSTR               szFile  ,
									 /*[out]*/ MPC::WStringUCLookup* mapAll  ,
									 /*[out]*/ MPC::WStringUCLookup* mapX86  ,
									 /*[out]*/ MPC::WStringUCLookup* mapIA64 )
{
    __HCP_FUNC_ENTRY( "Local_ParseLayoutInf" );

    HRESULT     		  hr;
    HHK::Reader*		  reader = NULL;
    MPC::wstring		  strLine;
	MPC::WStringUCLookup* mapActive = NULL;

    __MPC_EXIT_IF_ALLOC_FAILS(hr, reader, new HHK::Reader);

    __MPC_EXIT_IF_METHOD_FAILS(hr, reader->Init( szFile ));

    while(reader->GetLine( &strLine ))
    {
		LPCWSTR szPtr = strLine.c_str();

		if(szPtr[0] == '[')
		{
			if     (!_wcsnicmp( szPtr, c_ListPrefix    , MAXSTRLEN( c_ListPrefix     ) )) mapActive = mapAll;
			else if(!_wcsnicmp( szPtr, c_ListPrefixX86 , MAXSTRLEN( c_ListPrefixX86  ) )) mapActive = mapX86;
			else if(!_wcsnicmp( szPtr, c_ListPrefixIA64, MAXSTRLEN( c_ListPrefixIA64 ) )) mapActive = mapIA64;
			else                                                                          mapActive = NULL;
		}

		if(mapActive)
		{
			std::vector<MPC::wstring> vec1;

			//
			// <Source filename> = <diskid>,<subdir>,<size>,<checksum>,<spare>,<spare>,<bootmedia>,<targetdir>,<upgradedisp>,<cleandisp>,<targetname>
			//
			__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SplitAtDelimiter( vec1, szPtr, L" \t", false, true ));

			if(vec1.size() >= 3)
			{
				std::vector<MPC::wstring> vec2;
				LPCWSTR                   szCDName = vec1[0].c_str();

				__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SplitAtDelimiter( vec2, vec1[2].c_str(), L",", false, false ));

				if(vec2.size() >= 11)
				{
					(*mapActive)[vec2[10]] = szCDName;
				}
				else
				{
					(*mapActive)[szCDName] = szCDName;
				}
			}
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    delete reader;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

#define FAIL_IF_RUNNING()                                                     \
{                                                                             \
    if(Thread_IsRunning())                                                    \
    {                                                                         \
        switch(m_shtStatus)                                                   \
        {                                                                     \
        case SHT_QUERIED    :                                                 \
        case SHT_INSTALLED  :                                                 \
        case SHT_UNINSTALLED:                                                 \
        case SHT_ABORTED    :                                                 \
        case SHT_FAILED     :                                                 \
            break;                                                            \
                                                                              \
        default:                                                              \
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_BUSY);                   \
        }                                                                     \
    }                                                                         \
}

#define EXIT_IF_ABORTED()                                                     \
{                                                                             \
    if(Thread_IsAborted())                                                    \
    {                                                                         \
        (void)put_Status( SHT_ABORTING, NULL );                               \
        __MPC_SET_ERROR_AND_EXIT(hr, E_ABORT);                                \
    }                                                                         \
}

#define CHANGE_STATE(x,y)                                                     \
{                                                                             \
    EXIT_IF_ABORTED();                                                        \
    __MPC_EXIT_IF_METHOD_FAILS(hr, put_Status( x, y ));                       \
}

#define CHECK_WRITE_PERMISSIONS()  __MPC_EXIT_IF_METHOD_FAILS(hr, VerifyWritePermissions());

////////////////////////////////////////////////////////////////////////////////

CPCHSetOfHelpTopics::CPCHSetOfHelpTopics()
{
                                          // Taxonomy::Settings           m_ts;
                                          // Taxonomy::Instance           m_inst;
                                          // CComPtr<IDispatch>           m_sink_onStatusChange;
    m_shtStatus          = SHT_NOTACTIVE; // SHT_STATUS                   m_shtStatus;
    m_hrErrorCode        = S_OK;          // HRESULT                      m_hrErrorCode;
    m_fReadyForCommands  = false;         // bool                         m_fReadyForCommands;
                                          //
                                          // MPC::Impersonation           m_imp;
                                          //
    m_fInstalled         = false;         // bool                         m_fInstalled;
                                          //
    m_fConnectedToDisk   = false;         // bool                         m_fConnectedToDisk;
                                          // MPC::wstring                 m_strDirectory;
                                          // MPC::wstring                 m_strCAB;
                                          // MPC::wstring                 m_strLocalCAB;
                                          //
    m_fConnectedToServer = false;         // bool                         m_fConnectedToServer;
                                          // MPC::wstring                 m_strServer;
                                          // CComPtr<IPCHSetOfHelpTopics> m_sku;
                                          // CComPtr<IPCHService>         m_svc;
                                          //
    m_fActAsCollection   = false;         // bool                         m_fActAsCollection;
                                          // CComPtr<CPCHCollection>      m_coll;
}

CPCHSetOfHelpTopics::~CPCHSetOfHelpTopics()
{
    (void)Close( true );
}

HRESULT CPCHSetOfHelpTopics::Close( /*[in]*/ bool fCleanup )
{
    __HCP_FUNC_ENTRY( "CPCHSetOfHelpTopics::Close" );

    HRESULT hr;


    //
    // Do the final cleanup.
    //
    if(fCleanup)
    {
        Thread_Wait();

        (void)MPC::RemoveTemporaryFile( m_strLocalCAB );

        m_fConnectedToDisk   = false; // bool                              m_fConnectedToDisk;
        m_strDirectory       = L"";   // MPC::wstring                      m_strDirectory;
        m_strCAB             = L"";   // MPC::wstring                      m_strCAB;
                                      // MPC::wstring                      m_strLocalCAB;

        m_fConnectedToServer = false; // bool                              m_fConnectedToServer;
        m_strServer           = L"";  // MPC::wstring                      m_strServer;
        m_sku.Release();              // CComPtr<IPCHSetOfHelpTopics>      m_sku;
        m_svc.Release();              // CComPtr<IPCHService>              m_svc;
    }

    hr = S_OK;


    __HCP_FUNC_EXIT(hr);
}

void CPCHSetOfHelpTopics::CleanupWorkerThread( /*[in]*/ HRESULT hr )
{
    (void)EndImpersonation();

    (void)Close( false );

    if(FAILED(hr))
    {
        m_hrErrorCode = hr;

        (void)put_Status( (hr == E_ABORT) ? SHT_ABORTED : SHT_FAILED, NULL );
    }

    (void)Thread_Abort();
}

HRESULT CPCHSetOfHelpTopics::PrepareSettings()
{
    __HCP_FUNC_ENTRY( "CPCHSetOfHelpTopics::PrepareSettings" );

    HRESULT hr;

    m_ts                = m_inst.m_ths;
    m_fReadyForCommands = true;
    hr                  = S_OK;


    __HCP_FUNC_EXIT(hr);
}

////////////////////

HRESULT CPCHSetOfHelpTopics::ImpersonateCaller()
{
    return m_imp.Impersonate();
}

HRESULT CPCHSetOfHelpTopics::EndImpersonation()
{
    return m_imp.RevertToSelf();
}

////////////////////

HRESULT CPCHSetOfHelpTopics::GetListOfFilesFromDatabase( /*[in]*/  const MPC::wstring& strDB ,
                                                         /*[out]*/ MPC::WStringList&   lst   )
{
    __HCP_FUNC_ENTRY( "CPCHSetOfHelpTopics::GetListOfFilesFromDatabase" );

    USES_CONVERSION;

    HRESULT                hr;
    LPCSTR                 szDB = W2A( strDB.c_str() );
    JetBlue::SessionHandle sess;
    JetBlue::Database*     db;
    Taxonomy::Updater      updater;


    __MPC_EXIT_IF_METHOD_FAILS(hr, JetBlue::SessionPool::s_GLOBAL->GetSession( sess ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, sess->GetDatabase( szDB, db, /*fCreate*/false, /*fRepair*/false, /*fReadOnly*/true ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, updater.Init( m_ts, db ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, updater.ListAllTheHelpFiles( lst ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    (void)updater.Close();

    sess.Release();

    JetBlue::SessionPool::s_GLOBAL->ReleaseDatabase( szDB );

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHSetOfHelpTopics::PopulateFromDisk( /*[in]*/ CPCHSetOfHelpTopics* pParent      ,
                                               /*[in]*/ const MPC::wstring&  strDirectory )
{
    __HCP_FUNC_ENTRY( "CPCHSetOfHelpTopics::PopulateFromDisk" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pParent);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, Close( true ));

    m_imp = pParent->m_imp;

    ////////////////////////////////////////

    m_fConnectedToDisk = true;
    m_strDirectory     = strDirectory;

    ////////////////////////////////////////

    //
    // Find SKUs, recursively enumerating folders.
    //
    {
        MPC::wstring             strLayout( m_strDirectory ); strLayout += L"\\layout.inf";
        MPC::WStringUCLookup     mapLayout;
        MPC::WStringUCLookupIter itLayout;
        LPCWSTR                  szCAB_first = NULL;
        LPCWSTR                  szCAB_srv   = NULL;

        EXIT_IF_ABORTED();


        __MPC_EXIT_IF_METHOD_FAILS(hr, ImpersonateCaller   (                                           ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, Local_ParseLayoutInf( strLayout.c_str(), &mapLayout, NULL, NULL ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, EndImpersonation    (                                           ));

        for(itLayout = mapLayout.begin(); itLayout != mapLayout.end(); itLayout++)
        {
            LPCWSTR szName = itLayout->first.c_str();

            if(!wcsncmp( szName, c_SetupImage, MAXSTRLEN(c_SetupImage) ))
            {
                LPCWSTR szFile = itLayout->second.c_str();

                if(!szCAB_first) szCAB_first = szFile;

                //
                // Special case for Server: it also contains the AdvancedServer stuff.
                //
                if(!wcscmp( szName, L"PCHDT_S3.CAB" )) szCAB_srv  = szFile;
                if(!wcscmp( szName, L"PCHDT_S6.CAB" )) szCAB_srv  = szFile;
            }
        }

        if(!szCAB_first)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
        }

        m_strCAB = m_strDirectory; m_strCAB += L"\\"; m_strCAB += (szCAB_srv ? szCAB_srv : szCAB_first);
    }

    //
    // Make a local copy of the data archive, using the user credentials.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetTemporaryFileName               (                   m_strLocalCAB                ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::CopyOrExtractFileWhileImpersonating( m_strCAB.c_str(), m_strLocalCAB.c_str(), m_imp ));

    EXIT_IF_ABORTED();


    //
    // Extract the database to a temporary file.
    //
    {
        Installer::Package pkg;

        __MPC_EXIT_IF_METHOD_FAILS(hr, pkg.Init( m_strLocalCAB.c_str() ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, pkg.Load(                       ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_inst.InitializeFromBase( pkg.GetData(), /*fSystem*/false, /*fMUI*/false ));
    }

    EXIT_IF_ABORTED();

    ////////////////////////////////////////////////////////////////////////////////

    __MPC_EXIT_IF_METHOD_FAILS(hr, PrepareSettings());

    m_shtStatus = SHT_QUERIED;
    hr          = S_OK;


    __HCP_FUNC_CLEANUP;

    CleanupWorkerThread( hr );

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHSetOfHelpTopics::PopulateFromServer( /*[in]*/ CPCHSetOfHelpTopics* pParent, /*[in]*/ IPCHSetOfHelpTopics* sku, /*[in]*/ IPCHService* svc )
{
    __HCP_FUNC_ENTRY( "CPCHSetOfHelpTopics::PopulateFromServer" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    CComBSTR                     bstrDB_SKU;
    long                            lDB_LCID;
    CComBSTR                     bstrDB_DisplayName;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pParent);
        __MPC_PARAMCHECK_NOTNULL(sku);
        __MPC_PARAMCHECK_NOTNULL(svc);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, Close( true ));

    m_imp = pParent->m_imp;

    ////////////////////////////////////////

    m_fConnectedToServer = true;
    m_strServer          = pParent->m_strServer;
    m_sku                = sku;
    m_svc                = svc;

    ////////////////////////////////////////////////////////////////////////////////

    __MPC_EXIT_IF_METHOD_FAILS(hr, sku->get_SKU        ( &bstrDB_SKU         ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, sku->get_Language   ( &   lDB_LCID        ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, sku->get_DisplayName( &bstrDB_DisplayName ));

    m_inst.m_ths.m_strSKU   = SAFEBSTR( bstrDB_SKU         );
    m_inst.m_ths.m_lLCID    =              lDB_LCID         ;
    m_inst.m_strDisplayName = SAFEBSTR( bstrDB_DisplayName );

    ////////////////////////////////////////////////////////////////////////////////

    __MPC_EXIT_IF_METHOD_FAILS(hr, PrepareSettings());

    m_shtStatus = SHT_QUERIED;
    hr          = S_OK;


    __HCP_FUNC_CLEANUP;

    CleanupWorkerThread( hr );

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHSetOfHelpTopics::VerifyWritePermissions()
{
    return MPC::CheckCallerAgainstPrincipal( /*fImpersonate*/true, NULL, MPC::IDENTITY_SYSTEM     |
                                                                         MPC::IDENTITY_ADMIN      |
                                                                         MPC::IDENTITY_ADMINS     |
                                                                         MPC::IDENTITY_POWERUSERS );
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHSetOfHelpTopics::RunInitFromDisk()
{
    __HCP_FUNC_ENTRY( "CPCHSetOfHelpTopics::RunInitFromDisk" );

    HRESULT          hr;
    MPC::WStringList lst;

    //
    // There's a possible race condition between the call to ConnectToDisk and the firing of the QUERIED event,
    // in case the directory doesn't exist at all: QUERIED is fired before the method returns a pointer to the object...
    //
    ::SetThreadPriority( ::GetCurrentThread(), THREAD_PRIORITY_LOWEST ); ::Sleep( 10 );

    __MPC_TRY_BEGIN();

    CHANGE_STATE( SHT_QUERYING, NULL );

    ////////////////////////////////////////////////////////////////////////////////

    lst.push_back( m_strDirectory );

    while(lst.size())
    {
        MPC::wstring strDir = lst.front(); lst.pop_front();

        //
        // Look for subfolders.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, ImpersonateCaller());
        {
            MPC::FileSystemObject            fso( strDir.c_str() );
            MPC::FileSystemObject::List      fso_lst;
            MPC::FileSystemObject::IterConst fso_it;


            if(SUCCEEDED(fso.Scan            (         )) &&
               SUCCEEDED(fso.EnumerateFolders( fso_lst ))  )
            {
                for(fso_it=fso_lst.begin(); fso_it != fso_lst.end(); fso_it++)
                {
                    MPC::wstring strSubFolder;

                    if(SUCCEEDED((*fso_it)->get_Path( strSubFolder )))
                    {
                        lst.push_back( strSubFolder );
                    }

                    EXIT_IF_ABORTED();
                }
            }
        }
        __MPC_EXIT_IF_METHOD_FAILS(hr, EndImpersonation());

        EXIT_IF_ABORTED();

        {
            CComPtr<CPCHSetOfHelpTopics> obj;

            //
            // Create an object to analyze the directory.
            //
            __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &obj ));

            {
                CPCHSetOfHelpTopics* pObj = obj; // Working around ATL template problem...

                if(SUCCEEDED(pObj->PopulateFromDisk( this, strDir )))
                {
                    __MPC_EXIT_IF_METHOD_FAILS(hr, m_coll->AddItem( pObj ));

                    CHANGE_STATE( SHT_QUERYING, NULL );
                }
            }
        }
    }

    EXIT_IF_ABORTED();


    ////////////////////////////////////////////////////////////////////////////////

    CHANGE_STATE( SHT_QUERIED, NULL );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __MPC_TRY_CATCHALL(hr);

    CleanupWorkerThread( hr );

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHSetOfHelpTopics::RunInitFromServer()
{
    __HCP_FUNC_ENTRY( "CPCHSetOfHelpTopics::RunInitFromServer" );

    HRESULT                 hr;
    IPCHService*            svc;
    COSERVERINFO            si; ::ZeroMemory( &si, sizeof( si ) );
    MULTI_QI                qi; ::ZeroMemory( &qi, sizeof( qi ) );
    CComPtr<IPCHCollection> serverSKUs;


    //
    // There's a possible race condition between the call to ConnectToServer and the firing of the QUERIED event,
    // in case the server doesn't exist at all: QUERIED is fired before the method returns a pointer to the object...
    //
    ::SetThreadPriority( ::GetCurrentThread(), THREAD_PRIORITY_LOWEST ); ::Sleep( 10 );

    __MPC_TRY_BEGIN();

    CHANGE_STATE( SHT_QUERYING, NULL );

    ////////////////////////////////////////

    __MPC_EXIT_IF_METHOD_FAILS(hr, ImpersonateCaller());

    si.pwszName = (LPWSTR)m_strServer.c_str();
    qi.pIID     = &IID_IPCHService;
    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateInstanceEx( CLSID_PCHService, NULL, CLSCTX_REMOTE_SERVER, &si, 1, &qi ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, qi.hr);

    __MPC_EXIT_IF_METHOD_FAILS(hr, EndImpersonation());

    ////////////////////////////////////////

    svc = (IPCHService*)qi.pItf;
    __MPC_EXIT_IF_METHOD_FAILS(hr, svc->get_RemoteSKUs( &serverSKUs ));

    //
    // Copy the items in the remote collection.
    //
    {
        long lCount;
        long lPos;

        __MPC_EXIT_IF_METHOD_FAILS(hr, serverSKUs->get_Count( &lCount ));
        for(lPos=1; lPos<=lCount; lPos++)
        {
            CComVariant                  v;
            CComPtr<IPCHSetOfHelpTopics> sku;
            CComPtr<CPCHSetOfHelpTopics> obj;

            __MPC_EXIT_IF_METHOD_FAILS(hr, serverSKUs->get_Item( lPos, &v ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, v.ChangeType( VT_DISPATCH ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, v.pdispVal->QueryInterface( IID_IPCHSetOfHelpTopics, (LPVOID*)&sku ));

            //
            // Make a proxy of the remote SKU.
            //
            __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &obj ));

            {
                CPCHSetOfHelpTopics* pObj = obj; // Working around ATL template problem...

                __MPC_EXIT_IF_METHOD_FAILS(hr, pObj->PopulateFromServer( this, sku, svc ));

                __MPC_EXIT_IF_METHOD_FAILS(hr, m_coll->AddItem( pObj ));

                CHANGE_STATE( SHT_QUERYING, NULL );
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////////

    CHANGE_STATE( SHT_QUERIED, NULL );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __MPC_TRY_CATCHALL(hr);

    MPC::Release( qi.pItf );

    CleanupWorkerThread( hr );

    __HCP_FUNC_EXIT(hr);
}

////////////////////

HRESULT CPCHSetOfHelpTopics::RunInstall()
{
    __HCP_FUNC_ENTRY( "CPCHSetOfHelpTopics::RunInstall" );

    HRESULT            hr;
    Installer::Package pkg;


    __MPC_TRY_BEGIN();

    CHANGE_STATE( SHT_COPYING_DB, NULL );

    ////////////////////////////////////////////////////////////////////////////////
    //
    // Phase Zero: get the database.
    //
    if(m_fConnectedToServer)
    {
        CComPtr<IPCHRemoteHelpContents> rhc;

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetTemporaryFileName( m_strLocalCAB ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_svc->RemoteHelpContents( CComBSTR( m_inst.m_ths.GetSKU() ), m_inst.m_ths.GetLanguage(), &rhc ));
        if(rhc == NULL) __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);

        //
        // Get the data archive.
        //
        {
            CComPtr<IUnknown>  unkSrc;
            CComQIPtr<IStream> streamSrc;
            CComPtr<IStream>   streamDst;

            __MPC_EXIT_IF_METHOD_FAILS(hr, rhc->GetDatabase( &unkSrc )); streamSrc = unkSrc;

            __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::OpenStreamForWrite( m_strLocalCAB.c_str(), &streamDst ));

            EXIT_IF_ABORTED();

            __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::BaseStream::TransferData( streamSrc, streamDst ));

            EXIT_IF_ABORTED();
        }

        EXIT_IF_ABORTED();
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, pkg.Init( m_strLocalCAB.c_str() ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pkg.Load(                       ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, DirectInstall( pkg, /*fSetup*/false, /*fSystem*/false, /*fMUI*/false ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __MPC_TRY_CATCHALL(hr);

    CleanupWorkerThread( hr );

    //
    // In case of failure, remote everything...
    //
    if(FAILED(hr))
    {
        (void)DirectUninstall();
    }

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHSetOfHelpTopics::RunUninstall()
{
    __HCP_FUNC_ENTRY( "CPCHSetOfHelpTopics::RunUninstall" );

    HRESULT hr;


    __MPC_TRY_BEGIN();

    CHANGE_STATE( SHT_UNINSTALLING, NULL );

    __MPC_EXIT_IF_METHOD_FAILS(hr, DirectUninstall());

    CHANGE_STATE( SHT_UNINSTALLED, NULL );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __MPC_TRY_CATCHALL(hr);

    CleanupWorkerThread( hr );

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

HRESULT CPCHSetOfHelpTopics::Fire_onStatusChange( IPCHSetOfHelpTopics* obj, SHT_STATUS lStatus, long hrErrorCode, BSTR bstrFile )
{
    CComPtr<IDispatch> func;
    CComVariant        pvars[4];

    //
    // Only lock this!
    //
    {
        MPC::SmartLock<_ThreadModel> lock( this );

        func = m_sink_onStatusChange;
    }

    pvars[3] = obj;
    pvars[2] = lStatus;
    pvars[1] = hrErrorCode;
    pvars[0] = bstrFile;

    return FireAsync_Generic( DISPID_PCH_SHTE__ONSTATUSCHANGE, pvars, ARRAYSIZE( pvars ), func );
}

HRESULT CPCHSetOfHelpTopics::put_Status( /*[in]*/ SHT_STATUS newVal, /*[in]*/ BSTR bstrFile )
{
    __HCP_FUNC_ENTRY( "CPCHSetOfHelpTopics::put_Status" );

    HRESULT                      hr;
    long                         hrErrorCode;
    MPC::SmartLock<_ThreadModel> lock( this );

    m_shtStatus = newVal;
    hrErrorCode = m_hrErrorCode;

    lock = NULL; // Unlock before firing events.
    __MPC_EXIT_IF_METHOD_FAILS(hr, Fire_onStatusChange( this, newVal, hrErrorCode, bstrFile ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////

HRESULT CPCHSetOfHelpTopics::Init( /*[in]*/ const Taxonomy::Instance& inst )
{
    __HCP_FUNC_ENTRY( "CPCHSetOfHelpTopics::Init" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


    __MPC_EXIT_IF_METHOD_FAILS(hr, Close( true ));

    ////////////////////////////////////////

    m_fInstalled = true;
    m_inst       = inst;
    m_shtStatus  = SHT_INSTALLED;

    __MPC_EXIT_IF_METHOD_FAILS(hr, PrepareSettings());

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    CleanupWorkerThread( hr );

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHSetOfHelpTopics::InitFromDisk( /*[in]*/ LPCWSTR szDirectory, /*[in]*/ CPCHCollection* pColl )
{
    __HCP_FUNC_ENTRY( "CPCHSetOfHelpTopics::InitFromDisk" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( NULL );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(szDirectory);
        __MPC_PARAMCHECK_NOTNULL(pColl);
    __MPC_PARAMCHECK_END();


    Thread_Wait(); lock = this;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Close( true ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_imp.Initialize());

    ////////////////////////////////////////

    m_fActAsCollection = true;
    m_coll             = pColl;
    m_strDirectory     = szDirectory;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Thread_Start( this, RunInitFromDisk, NULL ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHSetOfHelpTopics::InitFromServer( /*[in]*/ LPCWSTR szServerName, /*[in]*/ CPCHCollection* pColl )
{
    __HCP_FUNC_ENTRY( "CPCHSetOfHelpTopics::InitFromServer" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( NULL );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(szServerName);
        __MPC_PARAMCHECK_NOTNULL(pColl);
    __MPC_PARAMCHECK_END();


    Thread_Wait(); lock = this;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Close( true ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_imp.Initialize());

    ////////////////////////////////////////

    m_fActAsCollection = true;
    m_coll             = pColl;
    m_strServer        = szServerName;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Thread_Start( this, RunInitFromServer, NULL ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHSetOfHelpTopics::get_SKU( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHSetOfHelpTopics::get_SKU",hr,pVal);

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_inst.m_ths.m_strSKU.c_str(), pVal ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHSetOfHelpTopics::get_Language( /*[out, retval]*/ long *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CPCHSetOfHelpTopics::get_Language",hr,pVal,m_inst.m_ths.GetLanguage());

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHSetOfHelpTopics::get_DisplayName( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHSetOfHelpTopics::get_DisplayName",hr,pVal);

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_inst.m_strDisplayName.c_str(), pVal ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHSetOfHelpTopics::get_ProductID( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHSetOfHelpTopics::get_ProductID",hr,pVal);

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_inst.m_strProductID.c_str(), pVal ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHSetOfHelpTopics::get_Version( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHSetOfHelpTopics::get_Version",hr,pVal);

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_inst.m_strVersion.c_str(), pVal ));

    __HCP_END_PROPERTY(hr);
}

////////////////////////////////////////

STDMETHODIMP CPCHSetOfHelpTopics::get_Location( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHSetOfHelpTopics::get_Location",hr,pVal);

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_inst.m_strHelpFiles.c_str(), pVal ));

    __HCP_END_PROPERTY(hr);
}

////////////////////////////////////////

STDMETHODIMP CPCHSetOfHelpTopics::get_Exported( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CPCHSetOfHelpTopics::get_Exported",hr,pVal,m_inst.m_fExported);

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHSetOfHelpTopics::put_Exported( /*[in]*/ VARIANT_BOOL newVal )
{
    __HCP_BEGIN_PROPERTY_PUT("CPCHSetOfHelpTopics::put_Exported",hr);

    CHECK_WRITE_PERMISSIONS();
    FAIL_IF_RUNNING();


    m_inst.m_fExported = (newVal == VARIANT_TRUE);

    if(m_fInstalled)
    {
        Taxonomy::LockingHandle         handle;
        Taxonomy::InstalledInstanceIter it;
        bool                            fFound;

        __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->GrabControl( handle                   ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->SKU_Find   ( m_inst.m_ths, fFound, it ));

        if(fFound)
        {
            it->m_inst.m_fExported = m_inst.m_fExported;

            __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->SKU_Updated( it ));
        }
    }

    __HCP_END_PROPERTY(hr);
}

////////////////////////////////////////

STDMETHODIMP CPCHSetOfHelpTopics::put_onStatusChange( /*[in]*/ IDispatch* function )
{
    __HCP_BEGIN_PROPERTY_PUT("CPCHSetOfHelpTopics::put_onStatusChange",hr);

    m_sink_onStatusChange = function;

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHSetOfHelpTopics::get_Status( /*[out, retval]*/ SHT_STATUS *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CPCHSetOfHelpTopics::get_Status",hr,pVal,m_shtStatus);

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHSetOfHelpTopics::get_ErrorCode( /*[out, retval]*/ long *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CPCHSetOfHelpTopics::get_ErrorCode",hr,pVal,m_hrErrorCode);

    __HCP_END_PROPERTY(hr);
}

////////////////////////////////////////

STDMETHODIMP CPCHSetOfHelpTopics::get_IsMachineHelp( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CPCHSetOfHelpTopics::get_IsMachineHelp",hr,pVal,VARIANT_FALSE);

    if(m_fReadyForCommands)
    {
        if(m_ts.IsMachineHelp())
        {
            *pVal = VARIANT_TRUE;
        }
    }

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHSetOfHelpTopics::get_IsInstalled( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CPCHSetOfHelpTopics::get_IsInstalled",hr,pVal,VARIANT_FALSE);

    if(m_fReadyForCommands)
    {
        Taxonomy::LockingHandle         handle;
        Taxonomy::InstalledInstanceIter it;
        bool                            fFound;

        __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->GrabControl( handle                   ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->SKU_Find   ( m_inst.m_ths, fFound, it ));
        if(fFound)
        {
            *pVal = VARIANT_TRUE;
        }
    }

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHSetOfHelpTopics::get_CanInstall( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CPCHSetOfHelpTopics::get_CanInstall",hr,pVal,VARIANT_FALSE);

    if(m_fReadyForCommands && SUCCEEDED(VerifyWritePermissions()))
    {
        Taxonomy::LockingHandle         handle;
        Taxonomy::InstalledInstanceIter it;
        bool                            fFound;

        __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->GrabControl( handle                   ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->SKU_Find   ( m_inst.m_ths, fFound, it ));

        //
        // You can install a SKU only if it's not already installed...
        //
        if(fFound == false)
        {
            *pVal = VARIANT_TRUE;
        }
    }

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHSetOfHelpTopics::get_CanUninstall( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CPCHSetOfHelpTopics::get_CanUninstall",hr,pVal,VARIANT_FALSE);

    if(m_fReadyForCommands && SUCCEEDED(VerifyWritePermissions()))
    {
        //
        // You can only uninstall a SKU that is installed.
        //
        if(m_fInstalled)
        {
			Taxonomy::LockingHandle         handle;
			Taxonomy::InstalledInstanceIter it;
			bool                            fFound;

			__MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->GrabControl( handle           ));
			__MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->SKU_Find   ( m_ts, fFound, it ));

			//
			// You cannot uninstall a SKU in use.
			//
			if(fFound && it->m_inst.m_fSystem == false && it->m_inst.m_fMUI == false && it->InUse() == false)
			{
				*pVal = VARIANT_TRUE;
			}
        }
    }

    __HCP_END_PROPERTY(hr);
}

////////////////////////////////////////

STDMETHODIMP CPCHSetOfHelpTopics::Install()
{
    __HCP_FUNC_ENTRY( "CPCHSetOfHelpTopics::Install" );

    HRESULT                      hr;
    VARIANT_BOOL                 fRes;
    MPC::SmartLock<_ThreadModel> lock( this );

    FAIL_IF_RUNNING();
    CHECK_WRITE_PERMISSIONS();


    __MPC_EXIT_IF_METHOD_FAILS(hr, get_CanInstall( &fRes ));
    if(fRes == VARIANT_FALSE)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_ALREADY_EXISTS);
    }

    ////////////////////

    __MPC_EXIT_IF_METHOD_FAILS(hr, Thread_Start( this, RunInstall, NULL ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHSetOfHelpTopics::Uninstall()
{
    __HCP_FUNC_ENTRY( "CPCHSetOfHelpTopics::Uninstall" );

    HRESULT                      hr;
    VARIANT_BOOL                 fRes;
    MPC::SmartLock<_ThreadModel> lock( this );

    FAIL_IF_RUNNING();
    CHECK_WRITE_PERMISSIONS();


    __MPC_EXIT_IF_METHOD_FAILS(hr, get_CanUninstall( &fRes ));
    if(fRes == VARIANT_FALSE)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_ACCESSDENIED);
    }

    ////////////////////

    __MPC_EXIT_IF_METHOD_FAILS(hr, Thread_Start( this, RunUninstall, NULL ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHSetOfHelpTopics::Abort()
{
    __HCP_FUNC_ENTRY( "CPCHSetOfHelpTopics::Abort" );

    HRESULT hr;

    Thread_Abort();

    if(m_fActAsCollection)
    {
        MPC::SmartLock<_ThreadModel> lock( this );
        long                         lCount;
        long                         lPos;


        __MPC_EXIT_IF_METHOD_FAILS(hr, m_coll->get_Count( &lCount ));
        for(lPos=1; lPos<=lCount; lPos++)
        {
            CComVariant                  v;
            CComPtr<IPCHSetOfHelpTopics> sku;

            __MPC_EXIT_IF_METHOD_FAILS(hr, m_coll->get_Item( lPos, &v ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, v.ChangeType( VT_DISPATCH ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, v.pdispVal->QueryInterface( IID_IPCHSetOfHelpTopics, (LPVOID*)&sku ));

            (void)sku->Abort();
        }
    }


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(S_OK);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHSetOfHelpTopics::GetClassID( /*[out]*/ CLSID *pClassID )
{
    return E_NOTIMPL;
}

STDMETHODIMP CPCHSetOfHelpTopics::IsDirty()
{
    return S_FALSE;
}

STDMETHODIMP CPCHSetOfHelpTopics::Load( /*[in]*/ IStream *pStm )
{
    return m_inst.LoadFromStream( pStm );
}

STDMETHODIMP CPCHSetOfHelpTopics::Save( /*[in]*/ IStream *pStm, /*[in]*/ BOOL fClearDirty )
{
    return m_inst.SaveToStream( pStm );
}

STDMETHODIMP CPCHSetOfHelpTopics::GetSizeMax( /*[out]*/ ULARGE_INTEGER *pcbSize )
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHSetOfHelpTopics::CreateIndex()
{
    __HCP_FUNC_ENTRY( "CPCHSetOfHelpTopics::CreateIndex" );

    HRESULT                       hr;
    CComObject<HCUpdate::Engine>* hc = NULL;


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &hc ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, hc->SetSkuInfo( m_ts.GetSKU(), m_ts.GetLanguage() ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, hc->InternalCreateIndex( VARIANT_FALSE ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(hc) hc->Release();

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHSetOfHelpTopics::RegisterPackage( /*[in]*/ const MPC::wstring& strFile  ,
                                              /*[in]*/ bool                fBuiltin )
{
    Taxonomy::PackageIter it;
    bool                  fFound;

    return Taxonomy::InstalledInstanceStore::s_GLOBAL->Package_Add( strFile.c_str(), NULL, fBuiltin ? &m_ts : NULL, /*fInsertAtTop*/false, fFound, it );
}


HRESULT CPCHSetOfHelpTopics::DirectInstall( /*[in]*/ Installer::Package& pkg     ,
                                            /*[in]*/ bool                fSetup  ,
                                            /*[in]*/ bool                fSystem ,
                                            /*[in]*/ bool                fMUI    )
{
    __HCP_FUNC_ENTRY( "CPCHSetOfHelpTopics::DirectInstall" );

    HRESULT                         hr;
    Taxonomy::LockingHandle         handle;
    Taxonomy::InstanceBase&         base = pkg.GetData();
    Taxonomy::InstanceIter          itInstance;
    Taxonomy::InstalledInstanceIter itSKU;
    bool                            fFound;


    if(fSetup) fSystem = true;


    ////////////////////////////////////////////////////////////////////////////////
    //
    // Phase One: get the database.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->GrabControl( handle ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_inst.InitializeFromBase( pkg.GetData(), fSystem, fMUI ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, PrepareSettings());

    //
    // Loop through the installed instances and remove any duplicates or, if during setup, any SYSTEM or MUI instances.
    //
    while(1)
    {
        Taxonomy::InstanceIterConst itBegin;
        Taxonomy::InstanceIterConst itEnd;

        __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->Instance_GetList( itBegin, itEnd ));
        for(;itBegin != itEnd; itBegin++)
        {
            const Taxonomy::Instance& inst = *itBegin;

            if(            inst.m_ths == m_inst.m_ths      || // Duplicate
               (fSetup && (inst.m_fSystem || inst.m_fMUI))  ) // System and MUI (setup-only)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->Instance_Find( inst.m_ths, fFound, itInstance ));
                if(fFound)
                {
                    __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->Instance_Remove( itInstance ));

                    //
                    // Uninstalling an instance could change the system settings, reapply them.
                    //
                    __MPC_EXIT_IF_METHOD_FAILS(hr, m_inst.InitializeFromBase( pkg.GetData(), fSystem, fMUI ));
                    __MPC_EXIT_IF_METHOD_FAILS(hr, PrepareSettings());
                    break;
                }
            }
        }
        if(itBegin == itEnd) break;
    }


    ////////////////////////////////////////////////////////////////////////////////
    //
    // Phase Two: clean up previous situation, set up permissions.
    //
    if(fSetup)
    {
        CPCHSecurityDescriptorDirect sdd;
        MPC::wstring                 strGroupName;


        //
        // Remove old data from our directories.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::RemoveAndRecreateDirectory( HC_ROOT_HELPSVC_CONFIG                      , NULL, /*fRemove*/true, /*fRecreate*/true ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::RemoveAndRecreateDirectory( HC_ROOT_HELPSVC_DATACOLL                    , NULL, /*fRemove*/true, /*fRecreate*/true ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::RemoveAndRecreateDirectory( HC_ROOT_HELPSVC_LOGS                        , NULL, /*fRemove*/true, /*fRecreate*/true ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::RemoveAndRecreateDirectory( HC_ROOT_HELPSVC_TEMP                        , NULL, /*fRemove*/true, /*fRecreate*/true ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::RemoveAndRecreateDirectory( HC_ROOT_HELPSVC_OFFLINECACHE                , NULL, /*fRemove*/true, /*fRecreate*/true ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::RemoveAndRecreateDirectory( HC_HELPSET_ROOT HC_HELPSET_SUB_INSTALLEDSKUS, NULL, /*fRemove*/true, /*fRecreate*/true ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::RemoveAndRecreateDirectory( HC_ROOT_HELPSVC_BATCH   , NULL, /*fRemove*/false, /*fRecreate*/true ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::RemoveAndRecreateDirectory( HC_ROOT_HELPSVC_PKGSTORE, NULL, /*fRemove*/false, /*fRecreate*/true ));

        //
        // Change the ACL for system directories.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::LocalizeString( IDS_HELPSVC_GROUPNAME, strGroupName ));


        __MPC_EXIT_IF_METHOD_FAILS(hr, sdd.Initialize());

        __MPC_EXIT_IF_METHOD_FAILS(hr, sdd.SetGroup( strGroupName.c_str() ));


        //
        // Config, Database and Datacoll directories:
        //
        //   LOCAL SYSTEM, Admin, Admins : any access.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, sdd.Add( (PSID)&sdd.s_SystemSid                     ,
                                                ACCESS_ALLOWED_ACE_TYPE                    ,
                                                OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE ,
                                                FILE_ALL_ACCESS                            ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, sdd.Add( (PSID)&sdd.s_Alias_AdminsSid               ,
                                                ACCESS_ALLOWED_ACE_TYPE                    ,
                                                OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE ,
                                                FILE_ALL_ACCESS                            ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::ChangeSD( sdd, HC_ROOT_HELPSVC_CONFIG   ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::ChangeSD( sdd, HC_ROOT_HELPSVC_DATACOLL ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::ChangeSD( sdd, HC_ROOT_HELPSVC_PKGSTORE ));

        //
        // Binaries, System, Batch, Temp
        //
        //   LOCAL SYSTEM, Admin, Admins : any access.
        //   Everyone                    : read and execute.
        //
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, sdd.Add( (PSID)&sdd.s_EveryoneSid                   ,
                                                ACCESS_ALLOWED_ACE_TYPE                    ,
                                                OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE ,
                                                FILE_GENERIC_READ | FILE_GENERIC_EXECUTE   ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::ChangeSD( sdd, HC_ROOT_HELPSVC_BATCH                        ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::ChangeSD( sdd, HC_ROOT_HELPSVC_BINARIES                     ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::ChangeSD( sdd, HC_ROOT_HELPSVC_LOGS                         ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::ChangeSD( sdd, HC_ROOT_HELPSVC_OFFLINECACHE                 ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::ChangeSD( sdd, HC_ROOT_HELPSVC_TEMP                         ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::ChangeSD( sdd, HC_HELPSET_ROOT HC_HELPSET_SUB_INSTALLEDSKUS ));

        {
            static const Installer::PURPOSE c_allowed[] =
            {
                Installer::PURPOSE_OTHER  ,
                Installer::PURPOSE_INVALID,
            };

            __MPC_EXIT_IF_METHOD_FAILS(hr, pkg.Install( c_allowed, NULL ));
        }
    }


    ////////////////////////////////////////////////////////////////////////////////
    //
    // Phase Three: register instance.
    //

    //
    // Install instance.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->Instance_Add( pkg.GetFile(), m_inst, fFound, itInstance ));

    //
    // Add the SKU to the list of installed ones.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->SKU_Add( m_inst, fFound, itSKU ));


    ////////////////////////////////////////////////////////////////////////////////
    //
    // Phase Four: copy the Help files.
    //
    if(m_fConnectedToDisk)
    {
        MPC::WStringUCLookup  mapLayout;
        MPC::WStringUCLookup  mapLayoutX86;
        MPC::WStringUCLookup  mapLayoutIA64;
        MPC::WStringList      lst;
        MPC::WStringIterConst it;
        MPC::wstring          strDir_HelpFiles( m_inst.m_strHelpFiles    ); MPC::SubstituteEnvVariables( strDir_HelpFiles );
        MPC::wstring          strFile_Database( m_inst.m_strDatabaseFile ); MPC::SubstituteEnvVariables( strFile_Database );
		bool                  fX86 = (wcsstr( m_inst.m_ths.GetSKU(), L"_32" ) != NULL);

        //
        // Parse the layout.inf file, to create the map of CD files.
        //
        {
            MPC::wstring strLayout( m_strDirectory ); strLayout += L"\\layout.inf";

            __MPC_EXIT_IF_METHOD_FAILS(hr, ImpersonateCaller   (                                                              ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, Local_ParseLayoutInf( strLayout.c_str(), &mapLayout, &mapLayoutX86, &mapLayoutIA64 ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, EndImpersonation    (                                                              ));
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, GetListOfFilesFromDatabase( strFile_Database, lst ));

        for(it = lst.begin(); it != lst.end(); it++)
        {
            const MPC::wstring&           strHelpFile = *it;
			MPC::WStringUCLookupIterConst it2;

			it2 = mapLayout.find( strHelpFile );
			if(it2 == mapLayout.end())
			{
				if(fX86)
				{
					it2 = mapLayoutX86.find( strHelpFile ); if(it2 == mapLayoutX86.end()) continue;
				}
				else
				{
					it2 = mapLayoutIA64.find( strHelpFile ); if(it2 == mapLayoutIA64.end()) continue;
				}
			}

            if(it2->second.empty() == false)
            {
                MPC::wstring strSrcFile;
                MPC::wstring strDstFile;

                strSrcFile = m_strDirectory  ; strSrcFile += L"\\"; strSrcFile += it2->second;
                strDstFile = strDir_HelpFiles; strDstFile += L"\\"; strDstFile += strHelpFile;

                CHANGE_STATE( SHT_COPYING_FILES, CComBSTR( strHelpFile.c_str() ) );

                __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MakeDir( strDstFile ));

                if(FAILED(hr = SVC::CopyOrExtractFileWhileImpersonating( strSrcFile.c_str(), strDstFile.c_str(), m_imp )))
                {
                    if(hr != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)) __MPC_FUNC_LEAVE;

                    continue;
                }

                EXIT_IF_ABORTED();
            }
        }
    }

    if(m_fConnectedToServer)
    {
        CComPtr<IPCHRemoteHelpContents> rhc;
        CComVariant                     v;
        MPC::WStringList                lst;
        MPC::WStringIterConst           it;


        __MPC_EXIT_IF_METHOD_FAILS(hr, m_svc->RemoteHelpContents( CComBSTR( m_inst.m_ths.GetSKU() ), m_inst.m_ths.GetLanguage(), &rhc ));
        if(rhc == NULL) __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);

        __MPC_EXIT_IF_METHOD_FAILS(hr, rhc->get_ListOfFiles       ( &v      ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertSafeArrayToList(  v, lst ));

        for(it = lst.begin(); it != lst.end(); it++)
        {
            CComPtr<IUnknown>  unkSrc;
            CComBSTR           bstrSrcFile( it->c_str() );
            MPC::wstring       strDstFile;

            strDstFile  = m_inst.m_strHelpFiles; MPC::SubstituteEnvVariables( strDstFile );
            strDstFile += L"\\";
            strDstFile += it->c_str();

            __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MakeDir( strDstFile ));

            if(SUCCEEDED(hr = rhc->GetFile( bstrSrcFile, &unkSrc )))
            {
                CComQIPtr<IStream> streamSrc = unkSrc; // TransferData checks for NULL.
                CComPtr<IStream>   streamDst;

                CHANGE_STATE( SHT_COPYING_FILES, bstrSrcFile );

                __MPC_EXIT_IF_METHOD_FAILS(hr, SVC::OpenStreamForWrite( strDstFile.c_str(), &streamDst ));

                __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::BaseStream::TransferData( streamSrc, streamDst ));
            }
            else
            {
                if(hr != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)) __MPC_FUNC_LEAVE;
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////////

    CHANGE_STATE( SHT_INSTALLING, NULL );

    __MPC_EXIT_IF_METHOD_FAILS(hr, ScanBatch());

    ////////////////////////////////////////////////////////////////////////////////

    CHANGE_STATE( SHT_INSTALLED, NULL );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


HRESULT CPCHSetOfHelpTopics::DirectUninstall( /*[in]*/ const Taxonomy::HelpSet* ths )
{
    __HCP_FUNC_ENTRY( "CPCHSetOfHelpTopics::DirectUninstall" );

    HRESULT                 hr;
    Taxonomy::LockingHandle handle;
    Taxonomy::InstanceIter  itInstance;
    bool                    fFound;

    if(ths) m_ts = *ths;

    __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->GrabControl( handle ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->Instance_Find( m_ts, fFound, itInstance ));
    if(fFound)
    {
        //
        // System SKU cannot be uninstalled!!
        //
        if(itInstance->m_fSystem)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_ACCESS_DENIED);
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->Instance_Remove( itInstance ));
    }


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHSetOfHelpTopics::ScanBatch()
{
    __HCP_FUNC_ENTRY( "CPCHSetOfHelpTopics::ScanBatch" );

    HRESULT                       hr;
    MPC::wstring                  strBatchPath( HC_ROOT_HELPSVC_BATCH ); MPC::SubstituteEnvVariables( strBatchPath );
    MPC::FileSystemObject         fso( strBatchPath.c_str() );
    CComObject<HCUpdate::Engine>* hc    = NULL;
    Taxonomy::LockingHandle       handle;


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &hc ));

    {
        Taxonomy::Logger& log         = hc->GetLogger();
        bool              fLogStarted = false;

        __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->GrabControl( handle, &log ));

        if(SUCCEEDED(fso.Scan()))
        {
            MPC::FileSystemObject::List           fso_lst;
            MPC::FileSystemObject::IterConst      fso_it;
            std::vector<MPC::wstringUC>           vec;
            std::vector<MPC::wstringUC>::iterator it;

            //
            // Delete any subdirectory.
            //
            __MPC_EXIT_IF_METHOD_FAILS(hr, fso.EnumerateFolders( fso_lst ));
            for(fso_it=fso_lst.begin(); fso_it != fso_lst.end(); fso_it++)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, (*fso_it)->Delete( true, false ));
            }
            fso_lst.clear();

            //
            // For each file, process it if it's a cabinet and then delete!
            //
            __MPC_EXIT_IF_METHOD_FAILS(hr, fso.EnumerateFiles( fso_lst ));
            for(fso_it=fso_lst.begin(); fso_it != fso_lst.end(); fso_it++)
            {
                MPC::FileSystemObject* fsoFile = *fso_it;
                MPC::wstring           strPath;
                LPCWSTR                szExt;

                __MPC_EXIT_IF_METHOD_FAILS(hr, fsoFile->get_Path( strPath ));

                if((szExt = wcsrchr( strPath.c_str(), '.' )) && !_wcsicmp( szExt, c_CabExtension ))
                {
                    vec.push_back( strPath );
                }
            }
            std::sort( vec.begin(), vec.end() );

            for(it=vec.begin(); it<vec.end(); it++)
            {
                MPC::wstring&         strPath = *it;
                Taxonomy::PackageIter it2;
                bool                  fFound;

                if(!fLogStarted)
                {
                    (void)hc->StartLog();
                    fLogStarted = true;
                }

                hr = Taxonomy::InstalledInstanceStore::s_GLOBAL->Package_Add( strPath.c_str(), NULL, NULL, /*fInsertAtTop*/false, fFound, it2 );
                if(FAILED(hr))
                {
                    ; // Ignore any failure....
                }
            }

            //
            // Remove files.
            //
            for(fso_it=fso_lst.begin(); fso_it != fso_lst.end(); fso_it++)
            {
                MPC::FileSystemObject* fsoFile = *fso_it;

                __MPC_EXIT_IF_METHOD_FAILS(hr, (*fso_it)->Delete( true, false ));
            }
            fso_lst.clear();
        }

        handle.Release();

        hr = hc->InternalUpdatePkg( NULL, /*fImpersonate*/false );
        if(FAILED(hr))
        {
            ; // Ignore any failure....
        }

        if(fLogStarted)
        {
            (void)hc->EndLog();
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(hc) hc->Release();

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHSetOfHelpTopics::RebuildSKU( /*[in]*/ const Taxonomy::HelpSet& ths )
{
    __HCP_FUNC_ENTRY( "CPCHSetOfHelpTopics::RebuildSKU" );

    HRESULT                       hr;
    CComObject<HCUpdate::Engine>* hc = NULL;


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &hc ));

    {
        Taxonomy::LockingHandle handle;
        bool                    fUseLogger = SUCCEEDED(hc->StartLog()); // It could be already in use.

        __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->GrabControl( handle, fUseLogger ? &(hc->GetLogger()) : NULL ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->State_InvalidateSKU( ths, /*fAlsoDatabase*/true ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, hc->InternalUpdatePkg( NULL, /*fImpersonate*/false ));

        if(fUseLogger) (void)hc->EndLog();
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(hc) hc->Release();

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\scriptingframework\stdafx.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    stdafx.h

Abstract:
    include file for standard system include files,
    or project specific include files that are used frequently,
    but are changed infrequently


Revision History:
    Davide Massarenti   (Dmassare)  07/21/99
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_

#include <module.h>

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

//////

#include <HCP_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_COM.h>
#include <MPC_streams.h>

#include <Debug.h>

#include <SvcResource.h>
#include <SvcUtils.h>

//////

#include <Utility.h>

#include <FileList.h>

//////

#include <Service.h>
#include <SystemMonitor.h>

#include <DataCollection.h>

#include <QueryResult.h>
#include <SearchEngineLib.h>

#include <SAFLib.h>

#include <Incident.h>

#include <Cabinet.h>

#include <OfflineCache.h>
#include <TaxonomyDatabase.h>
#include <PCHUpdate.h>

#include <SecurityLib.h>

#include <NewsLib.h>

#include <Encrypt.h>

#include <UnsolicitedRC.h>


/////////////////////////////////////////////////////////////////////////////

#define BUFFER_SIZE_TMP      (64)
#define BUFFER_SIZE_FILECOPY (512)

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\scriptingframework\usersettings.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    UserSettings.cpp

Abstract:
    This file contains the implementation of the CPCHUserSettings class,
    that contains the user's settings on the service side.

Revision History:
    Davide Massarenti   (Dmassare)  04/15/2000
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

CPCHUserSettings::CPCHUserSettings()
{
	m_fAttached = false; // bool               m_fAttached;
    					 // Taxonomy::Settings m_ts;
}

CPCHUserSettings::~CPCHUserSettings()
{
	Passivate();
}

void CPCHUserSettings::Passivate()
{
	if(m_fAttached)
	{
		(void)Taxonomy::InstalledInstanceStore::s_GLOBAL->InUse_Unlock( m_ts );

		m_fAttached = false;
	}
}

HRESULT CPCHUserSettings::InitUserSettings( /*[out]*/ Taxonomy::HelpSet& ths )
{
    MPC::SmartLock<_ThreadModel> lock( this );

	ths = m_ts;

	return S_OK;
}
////////////////////////////////////////

HRESULT CPCHUserSettings::get_SKU( /*[in]*/ bool fMachine, /*[out, retval]*/ IPCHSetOfHelpTopics* *pVal )
{
	__HCP_FUNC_ENTRY( "CPCHUserSettings::get_SKU" );

	HRESULT                      	hr;
    MPC::SmartLock<_ThreadModel> 	lock( this );
    Taxonomy::LockingHandle      	handle;
    Taxonomy::InstalledInstanceIter it;
	bool                            fFound;
 
    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();



	__MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->GrabControl( handle                                            ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->SKU_Find   ( fMachine ? Taxonomy::HelpSet() : m_ts, fFound, it ));
	if(fFound)
	{
		CComPtr<CPCHSetOfHelpTopics> pObj;

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pObj ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, pObj->Init( it->m_inst ));

		*pVal = pObj.Detach();
	}
	else
	{
		if(fMachine)
		{
			__MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
		}

		__MPC_EXIT_IF_METHOD_FAILS(hr, get_SKU( true, pVal ));
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHUserSettings::get_CurrentSKU( /*[out, retval]*/ IPCHSetOfHelpTopics* *pVal )
{
	return get_SKU( false, pVal );
}

STDMETHODIMP CPCHUserSettings::get_MachineSKU( /*[out, retval]*/ IPCHSetOfHelpTopics* *pVal )
{
	return get_SKU( true, pVal );
}

////////////////////

STDMETHODIMP CPCHUserSettings::get_HelpLocation( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHUserSettings::get_HelpLocation",hr,pVal);

    Taxonomy::LockingHandle         handle;
    Taxonomy::InstalledInstanceIter it;
	bool                   			fFound;


	__MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->GrabControl( handle           ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->SKU_Find   ( m_ts, fFound, it ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( fFound ? it->m_inst.m_strHelpFiles.c_str() : HC_HELPSVC_HELPFILES_DEFAULT, pVal ));


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHUserSettings::get_DatabaseDir( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHUserSettings::get_IndexFile",hr,pVal);

    MPC::wstring strRES;


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_ts.DatabaseDir( strRES ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( strRES.c_str(), pVal ));


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHUserSettings::get_DatabaseFile( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHUserSettings::get_IndexFile",hr,pVal);

    MPC::wstring strRES;


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_ts.DatabaseFile( strRES ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( strRES.c_str(), pVal ));


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHUserSettings::get_IndexFile( /*[in,optional]*/ VARIANT vScope, /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHUserSettings::get_IndexFile",hr,pVal);

	MPC::wstring strLocation;
	MPC::wstring strDisplayName;

	if(vScope.vt == VT_BSTR)
	{
		JetBlue::SessionHandle handle;
		JetBlue::Database*     db;
		Taxonomy::Updater      updater;

		__MPC_EXIT_IF_METHOD_FAILS(hr, m_ts.GetDatabase( handle, db, /*fReadOnly*/true ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, updater.Init( m_ts, db ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, updater.GetIndexInfo( strLocation, strDisplayName, vScope.bstrVal ));
	}
	else
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, m_ts.IndexFile( strLocation ));
	}

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( strLocation.c_str(), pVal ));


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHUserSettings::get_IndexDisplayName( /*[in,optional]*/ VARIANT vScope, /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHUserSettings::get_IndexDisplayName",hr,pVal);

	MPC::wstring strLocation;
	MPC::wstring strDisplayName;

	if(vScope.vt == VT_BSTR)
	{
		JetBlue::SessionHandle handle;
		JetBlue::Database*     db;
		Taxonomy::Updater      updater;

		__MPC_EXIT_IF_METHOD_FAILS(hr, m_ts.GetDatabase( handle, db, /*fReadOnly*/true ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, updater.Init( m_ts, db ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, updater.GetIndexInfo( strLocation, strDisplayName, vScope.bstrVal ));
	}

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( strDisplayName.c_str(), pVal ));


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHUserSettings::get_LastUpdated( /*[out, retval]*/ DATE *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHUserSettings::get_LastUpdated",hr,pVal);

    Taxonomy::LockingHandle			handle;
    Taxonomy::InstalledInstanceIter it;
	bool                            fFound;


	__MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->GrabControl( handle           ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->SKU_Find   ( m_ts, fFound, it ));

	if(fFound) *pVal = it->m_inst.m_dLastUpdated;


    __HCP_END_PROPERTY(hr);
}

////////////////////////////////////////

STDMETHODIMP CPCHUserSettings::get_AreHeadlinesEnabled( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2__NOLOCK("CPCHUserSettings::get_AreHeadlinesEnabled",hr,pVal,VARIANT_FALSE);

	News::Main m;

	__MPC_EXIT_IF_METHOD_FAILS(hr, m.get_Headlines_Enabled( pVal ));

    __HCP_END_PROPERTY(hr);
}

//
// Don't lock during this method, it takes a long time to execute. 
//
STDMETHODIMP CPCHUserSettings::get_News( /*[out, retval]*/ IUnknown* *pVal )
{
    __HCP_BEGIN_PROPERTY_GET__NOLOCK("CPCHUserSettings::get_News",hr,pVal);

	News::Main m;

	__MPC_EXIT_IF_METHOD_FAILS(hr, m.get_News( m_ts.GetLanguage(), CComBSTR( m_ts.GetSKU() ), pVal ));

    __HCP_END_PROPERTY(hr);
}

////////////////////////////////////////

STDMETHODIMP CPCHUserSettings::Select( /*[in]*/ BSTR bstrSKU, /*[in]*/ long lLCID )
{
    __HCP_FUNC_ENTRY( "CPCHUserSettings::Select" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


	Passivate();

	{
		Taxonomy::HelpSet      			ths;
		Taxonomy::LockingHandle			handle;
		Taxonomy::InstalledInstanceIter it;
		bool                            fFound;


		__MPC_EXIT_IF_METHOD_FAILS(hr, ths.Initialize( bstrSKU, lLCID ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->GrabControl( handle          ));
		__MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->SKU_Find   ( ths, fFound, it ));
		if(fFound == false)
		{
			__MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
		}

		m_ts = it->m_inst.m_ths;
	}

	//
	// Mark the SKU as in-use and signal the SystemMonitor to load the cache.
	//
	m_fAttached = true;
	__MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->InUse_Lock	( m_ts ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::Cache                 ::s_GLOBAL->PrepareToLoad( m_ts ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, CPCHSystemMonitor               ::s_GLOBAL->LoadCache    (      ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\scriptingframework\systemmonitor.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    SystemMonitor.cpp

Abstract:
    This file contains the implementation of the CPCHSystemMonitor class,
    which implements the data collection functionality.

Revision History:
    Davide Massarenti   (Dmassare)  08/25/99
        created

******************************************************************************/

#include "stdafx.h"

#include <initguid.h>
#include <mstask.h> // for task scheduler apis
#include <msterr.h>

/////////////////////////////////////////////////////////////////////////////

static const ULONG INITIAL_RESCHEDULE_TIME         =      10 * 60; // (10 minutes)
static const ULONG DATACOLLECTION_RESCHEDULE_TIME  =  6 * 60 * 60; // (6 hours)
static const ULONG DATACOLLECTION_IDLE_TIME        =            5; // (5 minutes)
static const ULONG SECONDS_IN_A_DAY                = 24 * 60 * 60;
static const ULONG SECONDS_IN_A_MINUTE             =           60;
static const ULONG MINUTES_IN_A_DAY                = 24 * 60;


/////////////////////////////////////////////////////////////////////////////

static HRESULT Exec( LPCWSTR szExec )
{
    MPC::wstring strCmdLine( szExec ); MPC::SubstituteEnvVariables( strCmdLine );

    return MPC::ExecuteCommand( strCmdLine );
}

/////////////////////////////////////////////////////////////////////////////

CPCHSystemMonitor::CPCHSystemMonitor()
{
    __HCP_FUNC_ENTRY( "CPCHSystemMonitor::CPCHSystemMonitor" );

    m_fLoadCache      = false; // bool m_fLoadCache;
    m_fScanBatch      = true;  // bool m_fScanBatch;
    m_fDataCollection = false; // bool m_fDataCollection;

    (void)MPC::_MPC_Module.RegisterCallback( this, (void (CPCHSystemMonitor::*)())Shutdown );
}

CPCHSystemMonitor::~CPCHSystemMonitor()
{
    MPC::_MPC_Module.UnregisterCallback( this );

    Shutdown();
}

////////////////////

CPCHSystemMonitor* CPCHSystemMonitor::s_GLOBAL( NULL );

HRESULT CPCHSystemMonitor::InitializeSystem()
{
    if(s_GLOBAL == NULL)
    {
        s_GLOBAL = new CPCHSystemMonitor;
    }

    return s_GLOBAL ? S_OK : E_OUTOFMEMORY;
}

void CPCHSystemMonitor::FinalizeSystem()
{
    if(s_GLOBAL)
    {
        delete s_GLOBAL; s_GLOBAL = NULL;
    }
}

////////////////////

void CPCHSystemMonitor::Shutdown()
{
    Thread_Wait();
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT CPCHSystemMonitor::EnsureStarted()
{
    __HCP_FUNC_ENTRY( "CPCHSystemMonitor::EnsureStarted" );

    HRESULT hr;


    if(Thread_IsRunning() == false &&
       Thread_IsAborted() == false  )
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, Thread_Start( this, Run, NULL ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHSystemMonitor::Run()
{
    __HCP_FUNC_ENTRY( "CPCHSystemMonitor::Run" );

    const DWORD s_dwNotify = FILE_NOTIFY_CHANGE_FILE_NAME  |
                             FILE_NOTIFY_CHANGE_DIR_NAME   |
                             FILE_NOTIFY_CHANGE_ATTRIBUTES |
                             FILE_NOTIFY_CHANGE_SIZE       |
                             FILE_NOTIFY_CHANGE_CREATION;

    HRESULT                      hr;
    MPC::wstring                 strBatch( HC_ROOT_HELPSVC_BATCH ); MPC::SubstituteEnvVariables( strBatch );
    HANDLE                       hBatchNotification = INVALID_HANDLE_VALUE;
    DWORD                        dwTimeout          = INFINITE;
    MPC::SmartLock<_ThreadModel> lock( this );


    ::SetThreadPriority( ::GetCurrentThread(), THREAD_PRIORITY_LOWEST ); ::Sleep( 0 ); // Yield processor...

////
//// Don't touch task scheduler, it brings in too many things...
////
////    //
////    // Move forward the scheduled data collection by at least 10 minutes.
////    // Task scheduler is available only on normal boots.
////    //
////    if(::GetSystemMetrics( SM_CLEANBOOT ) == 0)
////    {
////        __MPC_EXIT_IF_METHOD_FAILS(hr, TaskScheduler_Add( true ));
////    }


    hBatchNotification = ::FindFirstChangeNotificationW( strBatch.c_str(), TRUE, s_dwNotify );


    while(Thread_IsAborted() == false)
    {
        DWORD dwRes;


        lock = NULL;
        __MPC_EXIT_IF_METHOD_FAILS(hr, RunLoop());
        lock = this;

        //
        // Done, for now...
        //
        lock = NULL;
        dwRes = Thread_WaitForEvents( hBatchNotification == INVALID_HANDLE_VALUE ? NULL : hBatchNotification, dwTimeout );
        lock = this;

        switch(dwRes)
        {
        case WAIT_OBJECT_0   :
        case WAIT_ABANDONED_0:
            break;

        case WAIT_OBJECT_0    + 1:
        case WAIT_ABANDONED_0 + 1:
            ::FindNextChangeNotification( hBatchNotification );

            dwTimeout = 1*1000; // Don't scan immediately, wait some time.
            break;

        case WAIT_TIMEOUT:
            dwTimeout    = INFINITE;
            m_fScanBatch = true;
            break;


        case WAIT_FAILED:
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ::GetLastError());
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(hBatchNotification != INVALID_HANDLE_VALUE)
	{
		::FindCloseChangeNotification( hBatchNotification );
	}

    Thread_Abort  (); // To tell the MPC:Thread object to close the worker thread...
    Thread_Release(); // To tell the MPC:Thread object to clean up...

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHSystemMonitor::RunLoop()
{
    __HCP_FUNC_ENTRY( "CPCHSystemMonitor::RunLoop" );

    HRESULT hr;

    ////////////////////////////////////////////////////////////////////////////////

    //
    // Batch processing for the other update packages.
    //
    if(m_fScanBatch)
    {
        CComPtr<CPCHSetOfHelpTopics> sht;

        m_fScanBatch = false;

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &sht ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, sht->ScanBatch());
    }

    ////////////////////////////////////////////////////////////////////////////////

    //
    // Load the cache for active SKUs.
    //
    if(m_fLoadCache)
    {
        Taxonomy::LockingHandle              handle;
        Taxonomy::InstalledInstanceIterConst itBegin;
        Taxonomy::InstalledInstanceIterConst itEnd;
        Taxonomy::InstalledInstanceIterConst it;


        m_fLoadCache = false;


        //
        // Get the list of SKU installed on the machine.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->GrabControl( handle         ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->SKU_GetList( itBegin, itEnd ));


        //
        // Enumerate all of the SKUs, creating the index.
        //
        for(it = itBegin; it != itEnd; it++)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::Cache::s_GLOBAL->LoadIfMarked( it->m_inst.m_ths ));
        }
    }

    if(m_fDataCollection)
    {
        CComPtr<CSAFDataCollection> pdc;

        m_fDataCollection = false;

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pdc ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, pdc->ExecScheduledCollection());

        __MPC_EXIT_IF_METHOD_FAILS(hr, TaskScheduler_Add( false ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHSystemMonitor::LoadCache()
{
    __HCP_FUNC_ENTRY( "CPCHSystemMonitor::LoadCache" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureStarted());

    m_fLoadCache = true;
    Thread_Signal();

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHSystemMonitor::TriggerDataCollection( /*[in]*/ bool fStart )
{
    __HCP_FUNC_ENTRY( "CPCHSystemMonitor::TriggerDataCollection" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

	if(fStart)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, EnsureStarted());

		m_fDataCollection = true;
		Thread_Signal();
	}
	else
	{
		m_fDataCollection = false;
		Thread_Signal();
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CPCHSystemMonitor::TaskScheduler_Add( /*[in]*/ bool fAfterBoot )
{
    MPC::wstring strDate;

	if(SUCCEEDED(MPC::ConvertDateToString( MPC::GetLocalTime(), strDate, /*fGMT*/false, /*fCIM*/true, 0 )))
	{
		static const WCHAR s_szRoot          [] = HC_REGISTRY_PCHSVC;
		static const WCHAR s_szDataCollection[] = L"DataCollection";

		(void)MPC::RegKey_Value_Write( strDate, s_szRoot, s_szDataCollection );
	}

	return S_OK;
}

HRESULT CPCHSystemMonitor::TaskScheduler_Remove()
{
	return S_OK;
}

////HRESULT CPCHSystemMonitor::TaskScheduler_Add( /*[in]*/ bool fAfterBoot )
////{
////	__HCP_FUNC_ENTRY( "CPCHSystemMonitor::TaskScheduler_Add" );
////
////	HRESULT                     hr;
////	CComPtr<ITaskScheduler>     pTaskScheduler;
////	CComPtr<ITask>              pTask;
////	CComPtr<IUnknown>           pTaskUnknown;
////	CComPtr<IScheduledWorkItem> pScheduledWorkItem;
////	bool                        fTaskExists = false;
////
////	WCHAR                       rgFileName[MAX_PATH];
////	CComBSTR                    bstrTaskName;
////	CComBSTR                    bstrComments;
////
////	ULONG                       ulTime = fAfterBoot ? INITIAL_RESCHEDULE_TIME : DATACOLLECTION_RESCHEDULE_TIME;
////	WORD                        wIdle  = DATACOLLECTION_IDLE_TIME;
////
////	////////////////////////////////////////
////
////	//
////	// Get our complete filename -- needed to create a task in the task scheduler.
////	//
////	__MPC_EXIT_IF_CALL_RETURNS_ZERO(hr, ::GetModuleFileNameW( NULL, rgFileName, MAX_PATH ));
////
////
////	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::LocalizeString( IDS_HELPSVC_TASKNAME   , bstrTaskName ));
////	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::LocalizeString( IDS_HELPSVC_TASKCOMMENT, bstrComments ));
////
////	//
////	// First create the task scheduler.
////	//
////	__MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateInstance( CLSID_CTaskScheduler, NULL, CLSCTX_INPROC_SERVER, IID_ITaskScheduler, (void**)&pTaskScheduler ));
////
////
////	//
////	// See if the task already exists in the task scheduler
////	//
////	if(SUCCEEDED(pTaskScheduler->Activate( bstrTaskName, IID_ITask, &pTaskUnknown )))
////	{
////		fTaskExists = true;
////
////		__MPC_EXIT_IF_METHOD_FAILS(hr, pTaskUnknown->QueryInterface( IID_ITask, (void **)&pTask ));
////	}
////	else
////	{
////		//
////		// Create a new task and set its app name and parameters.
////		//
////		if(FAILED(hr = pTaskScheduler->NewWorkItem( bstrTaskName, CLSID_CTask, IID_ITask, (IUnknown**)&pTask )))
////		{
////			if(hr != ERROR_FILE_EXISTS)
////			{
////				__MPC_TRACE_HRESULT(hr);
////				__MPC_FUNC_LEAVE;
////			}
////		}
////	}
////
////	__MPC_EXIT_IF_METHOD_FAILS(hr, pTask->QueryInterface( IID_IScheduledWorkItem, (void **)&pScheduledWorkItem ));
////
////	//
////	// Run under SYSTEM.
////	//
////	__MPC_EXIT_IF_METHOD_FAILS(hr, pScheduledWorkItem->SetAccountInformation( L"", NULL ));
////
////	__MPC_EXIT_IF_METHOD_FAILS(hr, pTask->SetApplicationName( CComBSTR( rgFileName  ) ));
////	__MPC_EXIT_IF_METHOD_FAILS(hr, pTask->SetParameters     ( CComBSTR( L"-collect" ) ));
////
////	// Set the comment, so we know how this job go there.
////	__MPC_EXIT_IF_METHOD_FAILS(hr, pScheduledWorkItem->SetComment( bstrComments ));
////	__MPC_EXIT_IF_METHOD_FAILS(hr, pScheduledWorkItem->SetFlags  ( 0            ));
////
////
////
////
////	// Now, fill in the trigger as necessary.
////	{
////		CComPtr<ITaskTrigger> pTaskTrigger;
////		SYSTEMTIME            stNow;
////		DOUBLE                dblNextScheduledTime;
////		TASK_TRIGGER          ttTaskTrig;
////
////
////		::ZeroMemory( &ttTaskTrig, sizeof(ttTaskTrig) );
////		ttTaskTrig.cbTriggerSize = sizeof(ttTaskTrig);
////
////
////		if(fTaskExists)
////		{
////			__MPC_EXIT_IF_METHOD_FAILS(hr, pScheduledWorkItem->GetTrigger( 0, &pTaskTrigger ));
////			__MPC_EXIT_IF_METHOD_FAILS(hr, pTaskTrigger      ->GetTrigger( &ttTaskTrig      ));
////		}
////		else
////		{
////			WORD wTrigNumber;
////
////			__MPC_EXIT_IF_METHOD_FAILS(hr, pScheduledWorkItem->CreateTrigger( &wTrigNumber, &pTaskTrigger ));
////		}
////
////
////		//
////		// Calculate the exact time of next activation.
////		//
////		::GetLocalTime           ( &stNow                        );
////		::SystemTimeToVariantTime( &stNow, &dblNextScheduledTime );
////
////		dblNextScheduledTime += (double)ulTime / SECONDS_IN_A_DAY;
////		::VariantTimeToSystemTime( dblNextScheduledTime, &stNow );
////
////
////		ttTaskTrig.wBeginYear              = stNow.wYear;
////		ttTaskTrig.wBeginMonth             = stNow.wMonth;
////		ttTaskTrig.wBeginDay               = stNow.wDay;
////		ttTaskTrig.wStartHour              = stNow.wHour;
////		ttTaskTrig.wStartMinute            = stNow.wMinute;
////
////		ttTaskTrig.MinutesDuration         = MINUTES_IN_A_DAY;
////		ttTaskTrig.MinutesInterval         = ulTime / SECONDS_IN_A_MINUTE;
////		ttTaskTrig.TriggerType             = TASK_TIME_TRIGGER_DAILY;
////
////		ttTaskTrig.Type.Daily.DaysInterval = 1;
////
////		if(wIdle)
////		{
////			__MPC_EXIT_IF_METHOD_FAILS(hr, pScheduledWorkItem->SetIdleWait( wIdle, 0x7FFF                ));
////			__MPC_EXIT_IF_METHOD_FAILS(hr, pScheduledWorkItem->SetFlags   ( TASK_FLAG_START_ONLY_IF_IDLE ));
////		}
////
////		// Add this trigger to the task.
////		__MPC_EXIT_IF_METHOD_FAILS(hr, pTaskTrigger->SetTrigger( &ttTaskTrig ));
////	}
////
////	//
////	// Make the changes permanent.
////	//
////	{
////		CComPtr<IPersistFile> pIPF;
////
////		__MPC_EXIT_IF_METHOD_FAILS(hr, pTask->QueryInterface( IID_IPersistFile, (void **)&pIPF ));
////
////		__MPC_EXIT_IF_METHOD_FAILS(hr, pIPF->Save( NULL, FALSE ));
////	}
////
////
////	hr = S_OK;
////
////
////	__HCP_FUNC_CLEANUP;
////
////	__HCP_FUNC_EXIT(hr);
////}
////
////HRESULT CPCHSystemMonitor::TaskScheduler_Remove()
////{
////	__HCP_FUNC_ENTRY( "CPCHSystemMonitor::TaskScheduler_Remove" );
////
////	HRESULT                 hr;
////	CComPtr<ITaskScheduler> pTaskScheduler;
////	CComBSTR                bstrTaskName;
////
////
////	////////////////////////////////////////
////
////	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::LocalizeString( IDS_HELPSVC_TASKNAME, bstrTaskName ));
////
////	//
////	// First create the task scheduler.
////	//
////	__MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateInstance( CLSID_CTaskScheduler, NULL, CLSCTX_INPROC_SERVER, IID_ITaskScheduler, (void**)&pTaskScheduler ));
////
////
////	if(FAILED(hr = pTaskScheduler->Delete( bstrTaskName )))
////	{
////		if(hr != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
////		{
////			__MPC_TRACE_HRESULT(hr);
////			__MPC_FUNC_LEAVE;
////		}
////	}
////
////
////	hr = S_OK;
////
////
////	__HCP_FUNC_CLEANUP;
////
////	__HCP_FUNC_EXIT(hr);
////}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHSystemMonitor::Startup()
{
    __HCP_FUNC_ENTRY( "CPCHSystemMonitor::Startup" );

    HRESULT hr;


    //
    // This forces the Content Store to be loaded.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHContentStore::s_GLOBAL->Acquire());
    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHContentStore::s_GLOBAL->Release());

    ////////////////////////////////////////////////////////////////////////////////

	//
	// Force the loading of the cache.
	//
    {
        Taxonomy::LockingHandle handle;

        __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->GrabControl( handle ));
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureStarted());

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\scriptingframework\taxonomydatabase.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    TaxonomyDatabase.cpp

Abstract:
    This file contains the implementation of the class CPCHTaxonomyDatabase.

Revision History:
    Davide Massarenti   (dmassare) 05/21/2000
        created

******************************************************************************/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////

#define LOCAL_FUNC_PROLOGUE(func,hr,coll,val)                         \
                                                                      \
    __HCP_FUNC_ENTRY( func );                                         \
                                                                      \
    HRESULT                            hr;                            \
    CComPtr<CPCHQueryResultCollection> coll;                          \
                                                                      \
    __MPC_PARAMCHECK_BEGIN(hr)                                        \
        __MPC_PARAMCHECK_POINTER_AND_SET(val,NULL);                   \
    __MPC_PARAMCHECK_END();                                           \
                                                                      \
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &coll ));	  
																	  
																	  
#define LOCAL_FUNC_EPILOGUE(hr,coll,val)                              \
                                                                      \
    __MPC_EXIT_IF_METHOD_FAILS(hr, coll.QueryInterface( val ));       \
                                                                      \
    hr = S_OK;                                                        \
                                                                      \
    __HCP_FUNC_CLEANUP;                                               \
                                                                      \
    __HCP_FUNC_EXIT(hr)

/////////////////////////////////////////////////////////////////////////////

HRESULT CPCHTaxonomyDatabase::SelectInstalledSKUs( /*[in]*/ bool fOnlyExported, /*[out, retval]*/ IPCHCollection* *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHTaxonomyDatabase::get_InstalledSKUs" );

    HRESULT                    			 hr;
    CComPtr<CPCHCollection>    			 pColl;
    CPCHSetOfHelpTopics_Object*			 pObj  = NULL;
	Taxonomy::LockingHandle  			 handle;
	Taxonomy::InstalledInstanceIterConst itBegin;
	Taxonomy::InstalledInstanceIterConst itEnd;
	Taxonomy::InstalledInstanceIterConst it;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


    //
    // Get the list of SKU installed on the machine.
    //
	__MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->GrabControl( handle         ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::InstalledInstanceStore::s_GLOBAL->SKU_GetList( itBegin, itEnd ));


    //
    // Create a new collection.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pColl ));
    for(it = itBegin; it != itEnd; it++)
    {
        const Taxonomy::Instance& data = it->m_inst;

        if(fOnlyExported && !data.m_fExported) continue;


        __MPC_EXIT_IF_METHOD_FAILS(hr, pObj->CreateInstance( &pObj )); pObj->AddRef();

        __MPC_EXIT_IF_METHOD_FAILS(hr, pObj->Init( data ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, pColl->AddItem( pObj ));

        pObj->Release(); pObj = NULL;
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, pColl.QueryInterface( pVal ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

	MPC::Release( pObj );

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHTaxonomyDatabase::get_InstalledSKUs( /*[out, retval]*/ IPCHCollection* *pVal )
{
    return SelectInstalledSKUs( false, pVal );
}

STDMETHODIMP CPCHTaxonomyDatabase::get_HasWritePermissions( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CPCHTaxonomyDatabase::get_HasWritePermissions",hr,pVal,VARIANT_FALSE);

	if(SUCCEEDED(CPCHSetOfHelpTopics::VerifyWritePermissions()))
	{
		*pVal = VARIANT_TRUE;
	}

    __HCP_END_PROPERTY(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHTaxonomyDatabase::LookupNode( /*[in]*/ BSTR bstrNode, /*[out, retval]*/ IPCHCollection* *ppC )
{
    LOCAL_FUNC_PROLOGUE( "CPCHTaxonomyDatabase::LookupNode", hr, pColl, ppC );

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_ts.LookupNode( bstrNode, pColl ));

    LOCAL_FUNC_EPILOGUE( hr, pColl, ppC );
}

STDMETHODIMP CPCHTaxonomyDatabase::LookupSubNodes( /*[in]*/          BSTR              bstrNode     ,
                                                   /*[in]*/          VARIANT_BOOL      fVisibleOnly ,
                                                   /*[out, retval]*/ IPCHCollection*  *ppC          )
{
    LOCAL_FUNC_PROLOGUE( "CPCHTaxonomyDatabase::LookupSubNodes", hr, pColl, ppC );

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_ts.LookupSubNodes( bstrNode, fVisibleOnly == VARIANT_TRUE, pColl ));

    LOCAL_FUNC_EPILOGUE( hr, pColl, ppC );
}

STDMETHODIMP CPCHTaxonomyDatabase::LookupNodesAndTopics( /*[in]*/          BSTR              bstrNode     ,
														 /*[in]*/          VARIANT_BOOL      fVisibleOnly ,
														 /*[out, retval]*/ IPCHCollection*  *ppC          )
{
    LOCAL_FUNC_PROLOGUE( "CPCHTaxonomyDatabase::LookupTopics", hr, pColl, ppC );

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_ts.LookupNodesAndTopics( bstrNode, fVisibleOnly == VARIANT_TRUE, pColl ));

    LOCAL_FUNC_EPILOGUE( hr, pColl, ppC );
}

STDMETHODIMP CPCHTaxonomyDatabase::LookupTopics( /*[in]*/          BSTR              bstrNode     ,
                                                 /*[in]*/          VARIANT_BOOL      fVisibleOnly ,
                                                 /*[out, retval]*/ IPCHCollection*  *ppC          )
{
    LOCAL_FUNC_PROLOGUE( "CPCHTaxonomyDatabase::LookupTopics", hr, pColl, ppC );

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_ts.LookupTopics( bstrNode, fVisibleOnly == VARIANT_TRUE, pColl ));

    LOCAL_FUNC_EPILOGUE( hr, pColl, ppC );
}

STDMETHODIMP CPCHTaxonomyDatabase::LocateContext( /*[in]*/          BSTR             bstrURL   ,
												  /*[in,optional]*/ VARIANT          vSubSite  ,
                                                  /*[out, retval]*/ IPCHCollection* *ppC       )
{
    LOCAL_FUNC_PROLOGUE( "CPCHTaxonomyDatabase::KeywordSearch", hr, pColl, ppC );

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_ts.LocateContext( bstrURL, vSubSite.vt == VT_BSTR ? vSubSite.bstrVal : NULL, pColl ));

    LOCAL_FUNC_EPILOGUE( hr, pColl, ppC );
}

STDMETHODIMP CPCHTaxonomyDatabase::KeywordSearch( /*[in]*/          BSTR             bstrQuery ,
												  /*[in,optional]*/ VARIANT          vSubSite  ,
                                                  /*[out, retval]*/ IPCHCollection* *ppC       )
{
    LOCAL_FUNC_PROLOGUE( "CPCHTaxonomyDatabase::KeywordSearch", hr, pColl, ppC );

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_ts.KeywordSearch( bstrQuery, vSubSite.vt == VT_BSTR ? vSubSite.bstrVal : NULL, pColl, NULL ));

    LOCAL_FUNC_EPILOGUE( hr, pColl, ppC );
}


STDMETHODIMP CPCHTaxonomyDatabase::GatherNodes( /*[in]*/          BSTR              bstrNode     ,
												/*[in]*/          VARIANT_BOOL      fVisibleOnly ,
												/*[out, retval]*/ IPCHCollection*  *ppC          )
{
    LOCAL_FUNC_PROLOGUE( "CPCHTaxonomyDatabase::GatherNodes", hr, pColl, ppC );

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_ts.GatherNodes( bstrNode, fVisibleOnly == VARIANT_TRUE, pColl ));

    LOCAL_FUNC_EPILOGUE( hr, pColl, ppC );
}

STDMETHODIMP CPCHTaxonomyDatabase::GatherTopics( /*[in]*/          BSTR              bstrNode     ,
                                                 /*[in]*/          VARIANT_BOOL      fVisibleOnly ,
                                                 /*[out, retval]*/ IPCHCollection*  *ppC          )
{
    LOCAL_FUNC_PROLOGUE( "CPCHTaxonomyDatabase::GatherTopics", hr, pColl, ppC );

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_ts.GatherTopics( bstrNode, fVisibleOnly == VARIANT_TRUE, pColl ));

    LOCAL_FUNC_EPILOGUE( hr, pColl, ppC );
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHTaxonomyDatabase::ConnectToDisk( /*[in]*/          BSTR             bstrDirectory,
                                                  /*[in]*/          IDispatch*       notify       ,
												  /*[out, retval]*/ IPCHCollection* *pVal         )
{
    __HCP_FUNC_ENTRY( "CPCHTaxonomyDatabase::ConnectToDisk" );

    HRESULT                      hr;
    CComPtr<CPCHCollection>      pColl;
    CComPtr<CPCHSetOfHelpTopics> pObj;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrDirectory);
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


	(void)Abort();


    //
    // Kickstart the asynchronous query to the server.
    //
	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pColl ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pObj  ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, pObj->put_onStatusChange( notify               ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, pObj->InitFromDisk      ( bstrDirectory, pColl ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pColl.QueryInterface( pVal ));

	m_ActiveObject = pObj;
    hr             = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHTaxonomyDatabase::ConnectToServer( /*[in]*/          BSTR             bstrServerName,
                                                    /*[in]*/          IDispatch*       notify        ,
                                                    /*[out, retval]*/ IPCHCollection* *pVal          )
{
    __HCP_FUNC_ENTRY( "CPCHTaxonomyDatabase::ConnectToServer" );

    HRESULT                      hr;
    CComPtr<CPCHCollection>      pColl;
    CComPtr<CPCHSetOfHelpTopics> pObj;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrServerName);
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


	(void)Abort();


    //
    // Kickstart the asynchronous query to the disk.
    //
	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pColl ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pObj  ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, pObj->put_onStatusChange( notify                ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, pObj->InitFromServer    ( bstrServerName, pColl ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pColl.QueryInterface( pVal ));

	m_ActiveObject = pObj;
    hr             = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHTaxonomyDatabase::Abort()
{
    __HCP_FUNC_ENTRY( "CPCHTaxonomyDatabase::Abort" );

	HRESULT hr;


	if(m_ActiveObject)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, m_ActiveObject->Abort());

		m_ActiveObject.Release();
	}

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\scriptingframework\utility.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Utility.cpp

Abstract:
    This file contains the implementation of the class exposed as the "window.external" object.

Revision History:
    Ghim-Sim Chua       (gschua)   07/23/99
        created
    Davide Massarenti   (dmassare) 07/25/99
        modified

    Kalyani Narlanka    (KalyaniN)  03/15/01
        Moved Incident and Encryption Objects from HelpService to HelpCtr to improve Perf.

******************************************************************************/

#include "stdafx.h"

#include "rdshost_i.c"

/////////////////////////////////////////////////////////////////////////////

HRESULT CPCHUtility::FinalConstruct()
{
    __HCP_FUNC_ENTRY( "CPCHUtility::FinalConstruct" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &m_UserSettings ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHUtility::InitUserSettings( /*[in]*/ Taxonomy::Settings& ts )
{
    return m_UserSettings ? m_UserSettings->InitUserSettings( ts ) : E_FAIL;
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHUtility::get_UserSettings( /*[out, retval]*/ IPCHUserSettings* *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHUtility::get_UserSettings",hr,pVal);


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_UserSettings.QueryInterface( pVal ));


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHUtility::get_Channels( /*[out, retval]*/ ISAFReg* *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHUtility::get_Channels",hr,pVal);

    CComPtr<CSAFRegDummy> obj;
    Taxonomy::Settings    ts;


    __MPC_EXIT_IF_METHOD_FAILS(hr, InitUserSettings( ts ));


    //
    // Get the channels registry, but make a read-only copy.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, CSAFReg::s_GLOBAL->CreateReadOnlyCopy( ts, &obj ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, obj.QueryInterface( pVal ));


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHUtility::get_Security( /*[out, retval]*/ IPCHSecurity* *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHUtility::get_Security",hr,pVal);


    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHSecurity::s_GLOBAL->QueryInterface( IID_IPCHSecurity, (void**)pVal ));


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHUtility::get_Database( /*[out, retval]*/ IPCHTaxonomyDatabase* *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHUtility::get_Database" );

    HRESULT                       hr;
    CComPtr<CPCHTaxonomyDatabase> pObj;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


    //
    // Create a new collection and fill it from the database.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pObj ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, InitUserSettings( pObj->GetTS() ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pObj.QueryInterface( pVal ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHUtility::FormatError( /*[in]*/ VARIANT vError, /*[out, retval]*/ BSTR *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHUtility::CreateObject_DataCollection" );

    HRESULT hr;
    HRESULT hrIn;
    LPWSTR lpMsgBuf = NULL;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


    if(vError.vt == VT_ERROR)
    {
        hrIn = vError.scode;
    }
    else if(vError.vt == VT_I4)
    {
        hrIn = vError.lVal;
    }
    else
    {
        CComVariant v;

        __MPC_EXIT_IF_METHOD_FAILS(hr, v.ChangeType( VT_I4, &vError ));

        hrIn = v.lVal;
    }

    if(HRESULT_FACILITY(hrIn) == FACILITY_WIN32)
    {
        if(::FormatMessageW( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                             FORMAT_MESSAGE_FROM_SYSTEM     |
                             FORMAT_MESSAGE_IGNORE_INSERTS,
                             NULL,
                             hrIn,
                             MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                             (LPWSTR)&lpMsgBuf,
                             0,
                             NULL ))
        {
            __MPC_EXIT_IF_ALLOC_FAILS(hr,*pVal,::SysAllocString( lpMsgBuf ));

            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }
    }

    //
    // Unknown error....
    //
    {
        WCHAR rgFmt[128];
        WCHAR rgBuf[512];

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::LocalizeString( IDS_HELPSVC_UNKNOWNERROR, rgFmt, MAXSTRLEN(rgFmt), /*fMUI*/true ));

        _snwprintf( rgBuf, MAXSTRLEN(rgBuf), rgFmt, hrIn );

        __MPC_EXIT_IF_ALLOC_FAILS(hr,*pVal,::SysAllocString( rgBuf ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(lpMsgBuf) ::LocalFree( lpMsgBuf );

    __HCP_FUNC_EXIT(hr);
}


STDMETHODIMP CPCHUtility::CreateObject_SearchEngineMgr( /*[out , retval]*/ IPCHSEManager* *ppSE )
{
    __HCP_FUNC_ENTRY( "CPCHUtility::CreateObject_SearchEngineMgr" );

    HRESULT                       hr;
    SearchEngine::Manager_Object* semgr = NULL;
    Taxonomy::Settings            ts;


    //
    // Create a new data collection.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, semgr->CreateInstance( &semgr )); semgr->AddRef();

    __MPC_EXIT_IF_METHOD_FAILS(hr, InitUserSettings             ( ts ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, semgr->InitializeFromDatabase( ts ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, semgr->QueryInterface( IID_IPCHSEManager, (void**)ppSE ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    MPC::Release( semgr );

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHUtility::CreateObject_DataCollection( /*[out, retval]*/ ISAFDataCollection* *ppDC )
{
    __HCP_FUNC_ENTRY( "CPCHUtility::CreateObject_DataCollection" );

    HRESULT                     hr;
    CComPtr<CSAFDataCollection> pchdc;


    //
    // Create a new data collection.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pchdc ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pchdc.QueryInterface( ppDC ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHUtility::CreateObject_Cabinet( /*[out , retval]*/ ISAFCabinet* *ppCB )
{
    __HCP_FUNC_ENTRY( "CPCHUtility::CreateObject_Cabinet" );

    HRESULT              hr;
    CComPtr<CSAFCabinet> cabinet;


    //
    // Create a new data collection.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &cabinet ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, cabinet.QueryInterface( ppCB ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHUtility::CreateObject_Encryption( /*[out, retval]*/ ISAFEncrypt* *ppEn )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHUtility::CreateObject_Encryption",hr,ppEn);

    CComPtr<CSAFEncrypt> pEn;

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pEn ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pEn.QueryInterface( ppEn ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHUtility::CreateObject_Channel( /*[in]         */ BSTR          bstrVendorID  ,
                                                /*[in]         */ BSTR          bstrProductID ,
                                                /*[out, retval]*/ ISAFChannel* *ppCh          )
{
    __HCP_FUNC_ENTRY( "CPCHUtility::CreateObject_Channel" );

    HRESULT             hr;
    CSAFChannel_Object* safchan = NULL;
    Taxonomy::Settings  ts;
    CSAFChannelRecord   cr;
    bool                fFound;


    __MPC_EXIT_IF_METHOD_FAILS(hr, InitUserSettings( ts ));

    cr.m_ths           = ts;
    cr.m_bstrVendorID  = bstrVendorID;
    cr.m_bstrProductID = bstrProductID;

    __MPC_EXIT_IF_METHOD_FAILS(hr, CSAFReg::s_GLOBAL->Synchronize( cr, fFound ));
    if(!fFound)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
    }

    //
    // Locate a channel.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, safchan->CreateInstance( &safchan )); safchan->AddRef();

    __MPC_EXIT_IF_METHOD_FAILS(hr, safchan->Init( cr ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, safchan->QueryInterface( IID_ISAFChannel, (void**)ppCh ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    MPC::Release( safchan );

    __HCP_FUNC_EXIT(hr);
}


STDMETHODIMP CPCHUtility::CreateObject_RemoteDesktopConnection( /*[out, retval]*/ ISAFRemoteDesktopConnection* *ppRDC )
{
    __HCP_FUNC_ENTRY( "CPCHUtility::CreateObject_RemoteDesktopConnection" );

    HRESULT                              hr;
    CComPtr<CSAFRemoteDesktopConnection> rdc;

    //
    // Create a new RemoteDesktopConnection Object..
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &rdc ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, rdc.QueryInterface( ppRDC ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHUtility::CreateObject_RemoteDesktopSession( /*[in]         */ REMOTE_DESKTOP_SHARING_CLASS  sharingClass        ,
                                                             /*[in]         */ long                          lTimeout            ,
                                                             /*[in]         */ BSTR                          bstrConnectionParms ,
                                                             /*[in]         */ BSTR                          bstrUserHelpBlob    ,
                                                             /*[out, retval]*/ ISAFRemoteDesktopSession*    *ppRCS               )
{
    return E_NOTIMPL; // Implementation moved to the PCHSVC broker...
}

STDMETHODIMP CPCHUtility::ConnectToExpert(/* [in]          */ BSTR bstrExpertConnectParm,
                                          /* [in]          */ LONG lTimeout,
                                          /* [retval][out] */ LONG *lSafErrorCode)

{
    return E_NOTIMPL; // Implementation moved to the PCHSVC broker...

}

STDMETHODIMP CPCHUtility::SwitchDesktopMode(/* [in]*/ int nMode,
                                            /* [in]*/ int nRAType)

{
    return E_NOTIMPL; // Implementation moved to the PCHSVC broker...

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\fts_lib\fs.cpp ===
// Copyright (C) 1997 Microsoft Corporation. All rights reserved.
#include "stdafx.h"
#include "titleinfo.h"
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

////////////////////////////////////////////////////////////////////////////////

static const WCHAR txtwUncompressed[] =  L"uncompressed";

typedef struct tagITSControlData
{
    UINT  cdwFollowing;         // Must be 6 or 13
    DWORD cdwITFS_Control;      // Must be 5
    DWORD dwMagicITS;           // Must be MAGIC_ITSFS_CONTROL (see below)
    DWORD dwVersionITS;         // Must be 1
    DWORD cbDirectoryBlock;     // Size in bytes of directory blocks (Default is 8192)
    DWORD cMinCacheEntries;     // Least upper bound on the number of directory blocks
                                // which we'll cache in memory. (Default is 20)
    DWORD fFlags;               // Control bit flags (see below).
                                // Default value is fDefaultIsCompression.
    UINT  cdwControlData;       // Must be 6
    DWORD dwLZXMagic;           // Must be LZX_MAGIC (see below)
    DWORD dwVersion;            // Must be 2
    DWORD dwMulResetBlock;      // Number of blocks between compression resets.  (Default: 4)
    DWORD dwMulWindowSize;      // Maximum number of blocks kept in data history (Default: 4)
    DWORD dwMulSecondPartition; // Granularity in blocks of sliding history(Default: 2)
    DWORD dwOptions;            // Option flags (Default: fOptimizeCodeStreams)
} ITCD;

////////////////////////////////////////////////////////////////////////////////

CFileSystem::CFileSystem()
{
    m_pITStorage    = NULL;
    m_pStorage      = NULL;
    m_szPathName[0] = 0;
}

CFileSystem::~CFileSystem()
{
    ReleaseObjPtr( m_pStorage   );
    ReleaseObjPtr( m_pITStorage );
}

HRESULT CFileSystem::Init()
{
    if(m_pITStorage) return S_OK;

    return ::CoCreateInstance( CLSID_ITStorage, NULL, CLSCTX_INPROC_SERVER, IID_ITStorage, (VOID**)&m_pITStorage );
}

HRESULT CFileSystem::Create( LPCSTR szPathName )
{
    USES_CONVERSION;

    HRESULT hr;
    ITCD    itcd;

    if(!m_pITStorage || m_pStorage) return E_FAIL;

    itcd.cdwFollowing          = 13;
    itcd.cdwITFS_Control       = 5;
    itcd.dwMagicITS            = MAGIC_ITSFS_CONTROL;
    itcd.dwVersionITS          = 1;
    itcd.cbDirectoryBlock      = 4096;     // default = 8192
    itcd.cMinCacheEntries      = 10;       // default = 20
    itcd.fFlags                = 1;        // 0 == Uncompressed, 1 == Compressed.
    itcd.cdwControlData        = 6;
    itcd.dwLZXMagic            = LZX_MAGIC;
    itcd.dwVersion             = 2;
    itcd.dwMulResetBlock       = 2;    // Default = 4
    itcd.dwMulWindowSize       = 2;    // Default = 4
    itcd.dwMulSecondPartition  = 1;    // Default = 2
    itcd.dwOptions             = 0;    // Default = fOptimizeCodeStreams

    m_pITStorage->SetControlData( PITS_Control_Data(&itcd) );

    hr = m_pITStorage->StgCreateDocfile( A2W(szPathName), STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT, 0, &m_pStorage );
    if(FAILED(hr)) return hr;

    StringCchCopyA( (LPSTR)m_szPathName, ARRAYSIZE(m_szPathName), szPathName );

    return S_OK;
}

// NOTE: The below function is required for the ITIR full-text indexer to
//     initialize.  I'm working to find out why this is and what impact
//     the below has on the file system.
//
HRESULT CFileSystem::CreateUncompressed( LPCSTR szPathName )
{
    USES_CONVERSION;

    HRESULT hr;
    ITCD    itcd;

    if(!m_pITStorage || m_pStorage) return E_FAIL;

    itcd.cdwFollowing      = 6;
    itcd.cdwITFS_Control   = 5;
    itcd.dwMagicITS        = MAGIC_ITSFS_CONTROL;
    itcd.dwVersionITS      = 1;
    itcd.cbDirectoryBlock  = 8192;     // default = 8192
    itcd.cMinCacheEntries  = 20;        // default = 20
    itcd.fFlags            = 0;        // 0 == Uncompressed, 1 == Compressed.

    m_pITStorage->SetControlData( PITS_Control_Data(&itcd) );

    hr = m_pITStorage->StgCreateDocfile( A2W(szPathName), STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT, 0, &m_pStorage);
    if(FAILED(hr)) return hr;

    StringCchCopyA( (LPSTR) m_szPathName, ARRAYSIZE(m_szPathName), szPathName );

    return S_OK;
}

HRESULT CFileSystem::Open( LPCWSTR wszPathName, DWORD dwAccess )
{
    HRESULT hr = S_OK;

    if(!m_pITStorage || m_pStorage) return E_FAIL;

    // force access modes
    if((dwAccess & STGM_WRITE    ) ||
       (dwAccess & STGM_READWRITE)  )
    {
        dwAccess &= ~STGM_WRITE;
        dwAccess |= STGM_READWRITE | STGM_SHARE_EXCLUSIVE;
   }
   else
   {
       dwAccess |= STGM_SHARE_DENY_WRITE;
   }

   hr = m_pITStorage->StgOpenStorage( wszPathName, NULL, dwAccess, NULL, 0, &m_pStorage );
   if(FAILED(hr)) return hr;

   // this will break the deletesub function, but we don't need it here
   //
   m_szPathName[0] = 0;

   return hr;
}

HRESULT CFileSystem::Compact( LPCSTR szPathName )
{
    USES_CONVERSION;

    m_pITStorage->Compact( A2W(szPathName), COMPACT_DATA_AND_PATH );

    return S_OK;
}

HRESULT CFileSystem::Close()
{
   ReleaseObjPtr( m_pStorage );

   return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Here are a set of "sub" file I/O calls.
//
//
CSubFileSystem::CSubFileSystem( CFileSystem* pFS )
{
    m_pFS           = pFS;
    m_pStorage      = NULL;
    m_pStream       = NULL;
    m_szPathName[0] = 0;
}

CSubFileSystem::~CSubFileSystem()
{
	ReleaseStorage();

    ReleaseObjPtr( m_pStream );
}

void CSubFileSystem::ReleaseStorage()
{
    if(m_pStorage && (m_pStorage != m_pFS->m_pStorage))
    {
		m_pStorage->Release(); m_pStorage = NULL;
    }
}

HRESULT CSubFileSystem::CreateSub( LPCSTR szPathName )
{
    USES_CONVERSION;

    HRESULT hr;
    LPCSTR  szFilePortion;

    if(m_pStorage || m_pStream) return E_FAIL;

    if((szFilePortion = FindFilePortion( szPathName )) && szFilePortion > szPathName)
    {
        CHAR    szPath[MAX_PATH];
        LPCWSTR wszStorage;

        StringCchCopyA( szPath, ARRAYSIZE(szPath), szPathName ); szPath[(szFilePortion - 1) - szPathName] = '\0';

        wszStorage = A2W( szPath );

        hr = m_pFS->m_pStorage->OpenStorage( wszStorage, NULL, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, NULL, 0, &m_pStorage );
        if(FAILED(hr) || !m_pStorage) // storage didn't exist, so create it
        {
            hr = m_pFS->m_pStorage->CreateStorage( wszStorage, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &m_pStorage );
            if(FAILED(hr)) return hr;
        }
	}
	else // no folder, so store the file in the root
	{
		m_pStorage    = m_pFS->m_pStorage;
		szFilePortion = szPathName;
	}

	hr = m_pStorage->CreateStream( A2W(szFilePortion), STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &m_pStream );
	if(FAILED(hr))
	{
		ReleaseStorage();

		return hr;
	}

	// Needed for delete.
	StringCchCopyA( m_szPathName, ARRAYSIZE(m_szPathName), szFilePortion );

	return S_OK;
}

HRESULT CSubFileSystem::CreateUncompressedSub( LPCSTR szPathName )
{
	USES_CONVERSION;

    HRESULT       hr;
    LPCSTR        szFilePortion;
    IStorageITEx* pIStorageEx;

    if(m_pStorage || m_pStream) return E_FAIL;

    if((szFilePortion = FindFilePortion( szPathName )) && szFilePortion > szPathName)
    {
        CHAR    szPath[MAX_PATH];
        LPCWSTR wszStorage;

        StringCchCopyA( szPath, ARRAYSIZE(szPath), szPathName ); szPath[(szFilePortion - 1) - szPathName] = '\0';

        wszStorage = A2W(szPath);

        hr = m_pFS->m_pStorage->OpenStorage( wszStorage, NULL, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, NULL, 0, &m_pStorage );
        if(FAILED(hr) || !m_pStorage) // storage didn't exist, so create it
        {
			hr = m_pFS->m_pStorage->CreateStorage( wszStorage, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &m_pStorage );
			if(FAILED(hr))
			{
				return hr;
			}
		}
	}
	else // no folder, so store the file in the root
	{
		m_pStorage = m_pFS->m_pStorage;
		szFilePortion = szPathName;
	}

	if(FAILED(hr = m_pStorage->QueryInterface( IID_IStorageITEx, (void**)&pIStorageEx )))
	{
		return hr; // The QI call above should work!
	}

	hr = pIStorageEx->CreateStreamITEx( A2W(szFilePortion), txtwUncompressed, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, (IStreamITEx**)&m_pStream );
	ReleaseObjPtr( pIStorageEx );

	if(FAILED(hr))
	{
		ReleaseStorage();

		return hr;
	}

	// Needed for delete.
	StringCchCopyA( m_szPathName, ARRAYSIZE(m_szPathName), szFilePortion );
	
	return S_OK;
}

HRESULT CSubFileSystem::CreateSystemFile( LPCSTR szPathName )
{
	USES_CONVERSION;

	HRESULT hr;
	
	m_pStorage = m_pFS->m_pStorage;

	hr = m_pStorage->CreateStream( A2W(szPathName), STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &m_pStream );
	if(FAILED(hr)) return hr;

	// Needed for delete.
	StringCchCopyA( m_szPathName, ARRAYSIZE(m_szPathName), szPathName );

	return S_OK;
}

HRESULT CSubFileSystem::CreateUncompressedSystemFile( LPCSTR szPathName )
{
	USES_CONVERSION;

	HRESULT       hr;
	IStorageITEx* pIStorageEx;

	m_pStorage = m_pFS->m_pStorage;

	if(FAILED(hr = m_pStorage->QueryInterface(IID_IStorageITEx, (void**)&pIStorageEx )))
	{
		return hr; // The QI call above should work!
	}

	hr = pIStorageEx->CreateStreamITEx( A2W(szPathName), txtwUncompressed, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, (IStreamITEx**)&m_pStream );
	ReleaseObjPtr( pIStorageEx );

	if(FAILED(hr)) return hr;

	// Needed for delete.
	StringCchCopyA( m_szPathName, ARRAYSIZE(m_szPathName), szPathName );
	
	return S_OK;
}

HRESULT CSubFileSystem::OpenSub( LPCSTR szPathName, DWORD dwAccess )
{
	USES_CONVERSION;

	HRESULT hr;
	PCSTR   szFilePortion;

	if(m_pStorage || m_pStream) return E_FAIL;
	
	// force access modes
	if((dwAccess & STGM_WRITE    ) ||
	   (dwAccess & STGM_READWRITE)  )
	{
		dwAccess &= ~STGM_WRITE;
		dwAccess |= STGM_READWRITE | STGM_SHARE_EXCLUSIVE;
	}
	else
	{
		dwAccess |= STGM_SHARE_DENY_WRITE;
	}

	if((szFilePortion = FindFilePortion(szPathName)) && szFilePortion > szPathName + 2) // +2 to support / && ./
	{
		CHAR szPath[MAX_PATH];

		StringCchCopyA( szPath, ARRAYSIZE(szPath), szPathName ); szPath[(szFilePortion - 1) - szPathName] = '\0';

		hr = m_pFS->m_pStorage->OpenStorage( A2W(szPath), NULL, dwAccess, NULL, 0, &m_pStorage);
		if(FAILED(hr)) return hr;
	}
	else // no folder, so store the file in the root
	{
		m_pStorage    = m_pFS->m_pStorage;
		szFilePortion = szPathName;
	}

	hr = m_pStorage->OpenStream( A2W(szFilePortion), NULL, dwAccess, 0, &m_pStream);
	if(FAILED(hr))
	{
		ReleaseStorage();

		return hr;
	}

	// Needed for delete.
	StringCchCopyA( m_szPathName, ARRAYSIZE(m_szPathName), szFilePortion );

	return S_OK;
}

ULONG CSubFileSystem::WriteSub( const void* pData, int cb )
{
	HRESULT hr;
	ULONG   cbWritten;

	if(!m_pStorage || !m_pStream) return (ULONG)-1;


	hr = m_pStream->Write( pData, cb, &cbWritten );
	if(FAILED(hr) || (cbWritten != (ULONG)cb))
	{
		return (ULONG)-1;
	}

	// REVIEW: 30-May-1997  [ralphw] Why are we returning this? We fail if
	// we don't write cb bytes.
	return cbWritten;
}

/*
 * iOrigin:
 *    0 = Seek from beginning.
 *    1 = Seek from current.
 *    2 = Seek from end.
 */
ULONG CSubFileSystem::SeekSub( int cb, int iOrigin )
{
	HRESULT        hr;
	LARGE_INTEGER  liCount = { 0, 0 };
	ULARGE_INTEGER liNewPos;

   if(!m_pStorage || !m_pStream) return (ULONG)-1;

   liCount.LowPart = cb;

   if(FAILED(hr =  m_pStream->Seek( liCount, iOrigin, &liNewPos )))
   {
      return (ULONG)-1;
   }

   return liNewPos.LowPart;
}

//
// Pre-allocate the size of the stream.
//

HRESULT CSubFileSystem::SetSize( unsigned uSize )
{
	HRESULT        hr;
	ULARGE_INTEGER liSize = {0,0};

	if(!m_pStorage || !m_pStream) return E_FAIL;

	liSize.LowPart = uSize;

	return m_pStream->SetSize( liSize );
}

//
// Delete substorage.
//
HRESULT CSubFileSystem::DeleteSub()
{
	USES_CONVERSION;

	HRESULT hr = S_OK;

    if(m_pStorage)
    {
		// Release the stream.
		ReleaseObjPtr( m_pStream );

        // Now delete the storage.
		hr = m_pStorage->DestroyElement( A2W(m_szPathName) );

		// Get back to the constructor state.
		ReleaseStorage();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\fts_lib\fs.h ===
// Copyright  1997-1997  Microsoft Corporation.  All Rights Reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _FS_H_
#define _FS_H_

#include <unknwn.h>
#include "msitstg.h"
#include <strsafe.h>

#ifdef ReleaseObjPtr
#undef ReleaseObjPtr
#endif
#define ReleaseObjPtr(pObj) \
{                           \
  if( pObj )                \
  {                         \
    pObj->Release();        \
    pObj= NULL;             \
  }                         \
}

//
// Sub-File System
//
class CSubFileSystem
{
public:
	CSubFileSystem( class CFileSystem* pfs );
	~CSubFileSystem();

	HRESULT CreateSub            		( LPCSTR szPathName                                                       );
	HRESULT CreateUncompressedSub		( LPCSTR szPathName                                                       );
	HRESULT OpenSub              		( LPCSTR szPathName, DWORD dwAccess = (STGM_READ | STGM_SHARE_DENY_WRITE) );
	HRESULT CreateSystemFile     		( LPCSTR szPathName                                                       );
	HRESULT CreateUncompressedSystemFile( LPCSTR szPathName                                                       );

	ULONG   WriteSub ( const void* pData, int cb );
	ULONG   SeekSub  ( int cb, int iOrigin );
	HRESULT SetSize  ( unsigned uSize );
	HRESULT DeleteSub() ;

	inline HRESULT ReadSub( void* pData, ULONG cb, ULONG *pcbRead )
	{
		return m_pStream->Read(pData, cb, pcbRead);
	}

	inline ULONG GetUncompressedSize()
	{
		return SeekSub(0,2);
	}

	inline HRESULT Stat( STATSTG* pstatstg, DWORD grfStatFalg )
	{
		return m_pStream->Stat( pstatstg, grfStatFalg );
	}

	inline HRESULT CopyTo( IStream* pstm, ULARGE_INTEGER cb, ULARGE_INTEGER* pcbRead, ULARGE_INTEGER* pcbWritten )
	{
		return m_pStream->CopyTo( pstm, cb, pcbRead, pcbWritten );
	}

	inline IStream* GetStream()
	{
		return m_pStream;
	}

	inline IStorage* GetITStorageDocObj() const
    {
		return m_pStorage;
	}

private:
	void ReleaseStorage();

	class CFileSystem* m_pFS;
	IStorage*          m_pStorage;
	IStream*           m_pStream;
	char               m_szPathName[MAX_PATH]; // Needed for delete.
};

//
// File System
//
class CFileSystem
{
	friend class CSubFileSystem;

public:
	CFileSystem();
	~CFileSystem();

	HRESULT Init();
	HRESULT Create            ( LPCSTR   szPathName                                                       );
	HRESULT CreateUncompressed( LPCSTR   szPathName                                                       );
	HRESULT Open              ( LPCWSTR wszPathName, DWORD dwAccess = (STGM_READ | STGM_SHARE_DENY_WRITE) );
	HRESULT Compact           ( LPCSTR   szFileName                                                       );
	HRESULT Close();

	inline HRESULT GetPathName( LPSTR szPathName, int cch ) { StringCchCopyA( szPathName, cch, m_szPathName ); return S_OK; }

	inline IITStorage* GetITStorageObj   () const { return m_pITStorage; }
	inline IStorage*   GetITStorageDocObj() const { return m_pStorage;   }

private:
	IITStorage* m_pITStorage;
	IStorage*   m_pStorage;
	char        m_szPathName[MAX_PATH];
};

#endif // _FS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\fts_lib\itdb.h ===
// ITDB.H:	ITDatabase interface declaration

#ifndef __ITDB_H__
#define __ITDB_H__

// {8fa0d5a2-dedf-11d0-9a61-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(IID_IITDatabase, 
0x8fa0d5a2, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#ifdef ITPROXY

// {66673452-8C23-11d0-A84E-00AA006C7D01}
DEFINE_GUID(CLSID_IITDatabase, 
0x66673452, 0x8c23, 0x11d0, 0xa8, 0x4e, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

#else

// {4662daa9-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITDatabaseLocal, 
0x4662daa9, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#endif	// ITPROXY


// Guaranteed to be an invalid value for dwObjInstance params in IITDatabase
// methods.
#define	IITDB_OBJINST_NULL	((DWORD) 0xFFFFFFFF)


DECLARE_INTERFACE_(IITDatabase, IUnknown)
{
	STDMETHOD(Open)(LPCWSTR lpszHost, LPCWSTR lpszMoniker, DWORD dwFlags) PURE;
	STDMETHOD(Close)(void) PURE;

	// Creates an unnamed object that can be referenced in the future
	// by *pdwObjInstance.  Note that the value in *pdwObjInstance will be
	// persisted by the database when it is asked to save via
	// IPersistStorage::Save.
	STDMETHOD(CreateObject)(REFCLSID rclsid, DWORD *pdwObjInstance) PURE;

	// Retrieves a specified IUnknown-based interface on the object identified
	// by dwObjInstance.
	STDMETHOD(GetObject)(DWORD dwObjInstance, REFIID riid, LPVOID *ppvObj) PURE;

	// To obtain a pointer to a named object's persistence the object's full
	// name (including any object-specific type prefix) should be passed in
	// lpswszObject.  If *lpwszObject is NULL, then the database's own storage
	// will be returned.  If lpwszObject is NULL, then dwObjInstance will be
	// used to identify the object and locate its persistence.  On exit,
	// *ppvPersistence will be either an IStorage* or an IStream*, depending
	// on what the caller specified with the fStream param.  The caller should
	// assume that only read operations can be performed on *ppvPersistence.
	// If the specified object's persistence doesn't exist, or if it exists
	// but is of the wrong type, then STG_E_FILENOTFOUND will be returned. 
	STDMETHOD(GetObjectPersistence)(LPCWSTR lpwszObject, DWORD dwObjInstance,
									LPVOID *ppvPersistence, BOOL fStream) PURE;
};

typedef IITDatabase* LPITDB;

#endif		// __ITDB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\fts_lib\index.h ===
// Copyright  1996-1997  Microsoft Corporation.  All Rights Reserved.

#ifndef _CDLG_H_
#include "cdlg.h"
#endif

class CTopicList : public CDlg
{
public:       // Constructors

  CTopicList( CHtmlHelpControl* phhCtrl, CWTable* ptblTitles, HFONT hfont, CWTable *ptblLocations = NULL )
                  : CDlg(phhCtrl, IDDLG_RELATED_TOPICS)
  {
    m_ptblTitles = ptblTitles;
    m_hfont = hfont;
    m_ptblLocations = ptblLocations;
    m_cResultCount = m_ptblTitles->CountStrings();
    SetUnicode(TRUE);
  }

  CTopicList( HWND hwndParent, CWTable* ptblTitles, HFONT hfont, CWTable *ptblLocations = NULL )
                  : CDlg(hwndParent, IDDLG_RELATED_TOPICS)
  {
    m_ptblTitles = ptblTitles;
    m_hfont = hfont;
    m_ptblLocations = ptblLocations;
    m_cResultCount = m_ptblTitles->CountStrings();
    SetUnicode(TRUE);
  }

  // Methods
  LRESULT ListViewMsg(HWND hwnd, NM_LISTVIEW* pnmhdr);
  BOOL OnBeginOrEnd(void);
  LRESULT OnDlgMsg(UINT msg, WPARAM wParam, LPARAM lParam);
  void AddItems();
  void OnDblClick() {
  PostMessage(m_hWnd, WM_COMMAND, MAKELONG(IDOK, BN_CLICKED), 0); }

  // Data Members
  CWTable*        m_ptblTitles;
  CWTable*        m_ptblLocations;
  HFONT           m_hfont;
  HWND            m_hwndListView;
  int             m_pos;   // position in ptblTitles
  int             m_cResultCount;
  SITE_ENTRY_URL* m_pUrl;
  SITEMAP_ENTRY*  m_pSiteMapChosen;

  enum { IDD = IDDLG_RELATED_TOPICS };
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\fts_lib\itcc.h ===
/************************************************************************
 *
 * ITCC.H
 *
 * Copyright (c) Microsoft Corporation 1993 - 1997
 * All rights reserved.
 *
 *************************************************************************
 *
 * Module intent:
 *
 * This module contains the API (Application Programming Interface)
 * for creating and updating ITIR objects and storages
 *
 *************************************************************************
 *
 * Current owner: JohnRush
 *
 ************************************************************************/

#ifndef _ITCC_H // {
#define _ITCC_H

#include "itpropl.h"
#include "itdb.h"

// Document property macros
#define STDPROP_UID         1
#define STDPROP_TITLE       2
#define STDPROP_USERDATA    3
#define STDPROP_KEY         4

#define STDPROP_SORTKEY		100
#define STDPROP_DISPLAYKEY	101
#define STDPROP_SORTORDINAL 102

#define STDPROP_INDEX_TEXT    200
#define STDPROP_INDEX_VFLD    201
#define STDPROP_INDEX_DTYPE   202
#define STDPROP_INDEX_LENGTH  203
#define STDPROP_INDEX_BREAK   204

#define STDPROP_INDEX_TERM              210
#define STDPROP_INDEX_TERM_RAW_LENGTH   211

#define STDPROP_USERPROP_BASE   0x00010000
#define STDPROP_USERPROP_MAX    0x7FFFFFFF

// Property destinations for word wheels
#define SZ_WWDEST_GLOBAL    L"GLOBAL"
#define SZ_WWDEST_KEY       L"KEY"
#define SZ_WWDEST_OCC       L"OCC"


// {4662daa2-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITCmdInt,
0x4662daa2, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4662daa3-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITSvMgr,
0x4662daa3, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4CF34C30-9BF9-11d0-8764-00A0C913F764}
DEFINE_GUID(IID_IITCmdInt,
0x4cf34c30, 0x9bf9, 0x11d0, 0x87, 0x64, 0x0, 0xa0, 0xc9, 0x13, 0xf7, 0x64);

// {4E7DA031-9C11-11d0-8764-00A0C913F764}
DEFINE_GUID(IID_IITSvMgr,
0x4e7da031, 0x9c11, 0x11d0, 0x87, 0x64, 0x0, 0xa0, 0xc9, 0x13, 0xf7, 0x64);

// {4662daa5-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITWordWheelUpdate,
0x4662daa5, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);
    
// {8fa0d5a5-dedf-11d0-9a61-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(IID_IITBuildCollect,
0x8fa0d5a5, 0xdedf, 0x11d0, 0x9a, 0x61, 0x0, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4662daa4-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITGroupUpdate,
0x4662daa4, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {8fa0d5aa-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(CLSID_IITIndexBuild,
0x8fa0d5aa, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {8fa0d5ab-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(CLSID_IITWWFilterBuild,
0x8fa0d5ab, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

struct VARARG
{
    DWORD   dwArgc;
    void    *Argv[20];
};

// Document class
class CSvDoc
{
public:
    virtual HRESULT WINAPI ResetDocTemplate (void) PURE;

    virtual HRESULT WINAPI AddObjectEntry(LPCWSTR lpObjName, IITPropList *pPL) PURE;
    virtual HRESULT WINAPI AddObjectEntry
        (LPCWSTR lpObjName, LPCWSTR szPropDest, IITPropList *pPL) PURE;
};

// Service manager class
DECLARE_INTERFACE_(IITSvMgr, IUnknown)
{
    STDMETHOD(Initiate)(IStorage *pistgStorage, IStream *piistmLog) PURE;
	STDMETHOD(Dispose)(void) PURE;
	STDMETHOD(Build)(void) PURE;
	STDMETHOD(SetPropDest)
        (LPCWSTR szObjectName, LPCWSTR szDestination, IITPropList *pPL) PURE;
	STDMETHOD(CreateBuildObject)(LPCWSTR pwstrObjectName, REFCLSID refclsid) PURE;
    STDMETHOD(GetBuildObject)
        (LPCWSTR pwstrObjectName, REFIID refiid, void **pInterface) PURE;

	STDMETHOD(CreateDocTemplate)(CSvDoc **ppDoc) PURE;
	STDMETHOD(FreeDocTemplate)(CSvDoc *pDoc) PURE;
	STDMETHOD(AddDocument)(CSvDoc *pDoc) PURE;

	STDMETHOD(HashString)(IN LPCWSTR lpwstr, OUT DWORD *pdwHash) PURE;
};

// Command Interpreter Interface
DECLARE_INTERFACE_(IITCmdInt, IUnknown)
{
	STDMETHOD(Initiate)(IITSvMgr *piitsv) PURE;
	STDMETHOD(Dispose)(void) PURE;
	STDMETHOD(LoadFromStream)(IStream *pMVPStream, IStream *pLogStream) PURE;
};

typedef struct tagHelperInfo
{
    UINT    CodePage;
    LCID    lcid;
    DWORD   argc1;
    DWORD   *argv1;
    DWORD   argc2;
    LPWSTR  *argv2;
} HelperInfo, *PHelperInfo;

// This structure is sent to IITBuildCollect::SetBuildStats
typedef struct tagIITBOCI
{
    DWORD dwSize;   // Must be set to size of this structure
    DWORD dwMaxUID; // The highest uid authored for this title
} ITBuildObjectControlInfo;

DECLARE_INTERFACE_(IITBuildCollect, IUnknown)
{
    STDMETHOD(SetConfigInfo)(IITDatabase *piitdb, VARARG vaParams) PURE;
	STDMETHOD(InitHelperInstance)(DWORD dwHelperObjInstance,
        IITDatabase *pITDatabase, DWORD dwCodePage,
        LCID lcid, VARARG vaDword, VARARG vaString) PURE;
	STDMETHOD(SetEntry)(LPCWSTR szDest, IITPropList *pPropList) PURE;
	STDMETHOD(Close)(void) PURE;
    STDMETHOD(GetTypeString)(LPWSTR wstrType, DWORD *pLength) PURE;
    STDMETHOD(SetBuildStats)(ITBuildObjectControlInfo &itboci) PURE;
};


#endif // _ITCC_H }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\fts_lib\hhtypes.h ===
// hhtypes.h

#ifndef _HHTYPES_H
#define _HHTYPES_H

#include <wininet.h>

typedef DWORD INODE;

#define PAGE_SIZE  4096
#define NUM_IN_LOCATE_GROUP 4  // 100
#define MAX_URL INTERNET_MAX_URL_LENGTH

// CHM_SIGNATURE is the master CHM signature value
// (or internal CHM file format version if you will)
//
// hhw: all code that needs to set the file format version
// of the CMH should use this number to "stamp" a value in the CHM
// it is okay to stamp the CHM in several place just as long as
// we all stamp the same number
//
// hhctrl: all code that is specific to an CHM file format
// version should check at runtime this value against your
// specific stamp in the CHM and make sure that it is an
// exact match otherwise don't bother reading the CHM and just
// do not perform the requested feature (dislay an warning if you wish)
//
// Note: currently when the user tries to load the title via the TOC
// if CHM_SIGNATURE is not an exact match then we display an appropriate
// message and prevent the title from loading.  However, this doe not prevent
// the title from loading via another mechanism (such as F1 lookup jumps) unless
// that feature is coded to check this stamp (F1 lookups currently do).
//

#define FS_SIGNATURE     'M' << 24 | 'S' << 16 | 'F' << 7 | 'T'
#define CHM_SIGNATURE    0x0001

// TOC Node Flags
#define TOC_HAS_CHILDREN   0x00000001
#define TOC_NEW_NODE       0x00000002
#define TOC_FOLDER         0x00000004
#define TOC_TOPIC_NODE     0x00000008
#define TOC_NOLOCATION     0x00000010
#define TOC_IVT_ROOT       0x00000020
#define TOC_SS_LEAF        0x00000040
#define TOC_MERGED_REF     0x00000080
#define TOC_HAS_UNTYPED    0x00000100

// Topic Table entry flags.
#define F_TOPIC_FRAGMENT   0x0001
#define F_TOPIC_HASIPOS    0x0002    // Used at COMPILE time only! Has no meaning at runtime.
#define F_TOPIC_MULTI_REF  0x0004    // Used at COMPILE time only! Has no meaning at runtime.

//
// flags used in the flag word of the url tree chunklets.
//

#define F_URLC_LEAF     0x01
#define F_URLC_LEAF_HTM    0x02
#define F_URLC_HAS_KIDS    0x04
#define F_URLC_IS_FRAGMENT 0x08
#define F_URLC_IS_TOC_ITEM 0x10
#define F_URLC_IGNORE_URL  0x20
#define F_URLC_FILE_PROCESSED 0x40
#define F_URLC_KEEPER      0x80

//
// Compiled sitemap goo.
//
typedef struct _tagSMI
{
   DWORD    dwOffsImageList;
   DWORD    dwCntImages;
   DWORD    dwfFolderImages;
   COLORREF clrBackground;
   COLORREF clrForeground;
   DWORD    dwOffsFont;
   DWORD    m_tvStyles;
   DWORD    m_exStyles;
   DWORD    dwOffsBackBitmap;
   DWORD    dwOffsFrameName;
   DWORD    dwOffsWindowName;
} SMI, *PSMI;

// Warning: If you add members to IDXHEADER they must be added before the dwOffsMergedTitle DWORD array and you
//          MUST adjust the padding of the struct. Note that the structure is padded out to one page.

typedef struct _tagIdxHeader
{
   DWORD  dwSignature;
   DWORD  dwTimeStamp;
   DWORD  dwReqVersion;
   DWORD  cTopics;
   DWORD  dwFlags;
   SMI    smi;                 // (S)ite (M)ap (I)nfo.
   DWORD  dwCntIT;             // Count of unique infotypes.
   DWORD  dwITWidth;           // The width in DWORDS of each infotype bit field.
   DWORD  dwCntMergedTitles;
   DWORD* dwOffsMergedTitles;                                    // Array of DWORDS which utilizes the padded area of this
   BYTE   pad[PAGE_SIZE - (sizeof(SMI) + (sizeof(DWORD) * 9))];  // struct. It must be the last defined item in the structure.
} IDXHEADER, *PIDXHEADER;

typedef struct _tagTOCIDX_HEADER
{
   DWORD    dwOffsRootNode;   // Offset to the root node of the TOC.
   DWORD    dwOffsGrpTbl;        // Offset to the beginning of the group table.
   DWORD    dwGrpCnt;             // Count of groups.
   DWORD    dwOffsTopicArray;    // Offset to beginning of topic array used to facilitate FTS and F1 lookup filtration based on runtime defined subsets.
} TOCIDX_HDR, *PTOCIDX_HDR;

typedef struct TOC_FolderNode
{
   WORD  wFontIdx;      // Index into a font table used to specify a particular facename, style and weight.
   WORD    wGrpIdx;     // Index into Group table. Facilitates runtime TOC subsetting.
   DWORD   dwFlags;     // Flag bits used to assign attributes to the node.
   DWORD   dwOffsTopic;    // Offset into the 0 to n linear topic array. if folder just offset to title
   DWORD   dwOffsParent;   // Offset to parent node.
   DWORD   dwOffsNext;     // Next sibling offset, needed only for non-leaves.
   DWORD   dwOffsChild;    // Child offset.
   DWORD   dwIT_Idx;       // !!<WARNING>!! This must remain the last member of this struct. Infotype index. Needed only on folders for TOC filtering.
} TOC_FOLDERNODE, *PTOC_FOLDERNODE;       // 28 bytes.


typedef struct TOC_LeafNode
{
   WORD  wFontIdx;      // Index into a font table used to specify a particular facename, style and weight.
   WORD    wGrpIdx;     // Index into Group table. Facilitates runtime TOC subsetting.
   DWORD   dwFlags;     // Flag bits used to assign attributes to the node.
   DWORD   dwOffsTopic;    // Offset into the 0 to n linear topic array. if folder just offset to title
   DWORD   dwOffsParent;   // Offset to parent node.
   DWORD   dwOffsNext;     // Next sibling offset.
} TOC_LEAFNODE, *PTOC_LEAFNODE;     // 20 bytes.


typedef struct _tag_TOC_Topic
{
   DWORD dwOffsTOC_Node;   // This is the "sync to information"
   DWORD dwOffsTitle;      // Offset to the title string.
   DWORD dwOffsURL;        // Offset to URL data for the topic.
   WORD  wFlags;           // 16 flags should be enough.
   WORD  wIT_Idx;          // InfoType index. !!<WARNING>!! This MUST be the last member of this struct!
} TOC_TOPIC, *PTOC_TOPIC;     // Size == 16 bytes.


typedef struct _tag_url_entry
{
   DWORD dwHash;        // Hashed URL value.
   DWORD dwTopicNumber;    // Index into topic array table, needed for sync.
   DWORD dwOffsURL;        // Offset into URL string data. Secondary URLs will be specified via DWORD that
                       // preceedes the primary URL which will indicate an offset to the secondary URL
                       // in the URL_STRINGS subfile. If the preceeding DOWRD in the URL_STRINGS
                       // subfile is NULL, no secondary URL exists.
} CURL, *PCURL;

// URL String data storage (URL_STRINGS):
//
// This will be the repository for all URL string data for a given title. In addition, this subfile will also
// contain references to secondary URLs.

typedef struct _tag_url_strings
{
   DWORD dwOffsSecondaryURL;  // Offset to the secondary URL. If NULL, no secondary URL exists.
   DWORD dwOffsFrameName;   // Offset to the optional frame name URL is to be displayed in. If NULL, Defualt frame is used.
   union
   {
      int   iPosURL;     // used at compile time only!
      char  szURL[4];       // Primary URL. NULL terminated string.
   };
} URLSTR, *PURLSTR;

// An array of these lives right after the topic array in the GRPINF subfile. the dwOffsGrpTable
// will get you to the array of these.
//
// DANGER Will Robinson --> Note that this struct is 16 bytes in size. Since out page size
//                   is divisable by 16 there is no code needed to assure that these
//                   don't cross page boundrys. If you change the size of this struct
//                   then you'll need to take care of page alignement problems.
//
typedef struct _GroupTable
{
   DWORD iNode;            // offset into node tree.
   DWORD dwID;          // Group identifier.
   DWORD dwOffsTopicArray; // Index into topic array. Indicates first topic of the group.
   DWORD dwTopicCount;     // Count of topics in the array.
} GRPTBL, *PGRPTBL;


////////////////////////////////////////////////////////////////////////////
//
// Version structure
//
// This structure is not in a file system subfile; rather, it is
// appended to the file system file, to make it easy to find
//

// this structure is used to detect the presence of version
// information and never changes
//
typedef struct tagIVTVERSIONSIGNATURE
{
   DWORD dwSignature;      // contains "IVTV"
   DWORD dwIvtVersion;  // contains IVT_SIGNATURE
   DWORD dwSize;        // contains sizeof(IVTVERSION)
} IVTVERSIONSIGNATURE;

// this should never change unless IVTVERSIONSIGNATURE changes
//
#define IVT_VERSION_SIGNATURE 'I' + 256*('V' + 256*('T' + 256*'V'))

// this structure contains more information about the version,
// and can be version dependant (based on the size given above)
//
typedef struct tagIVTVERSION
{
   DWORD dwTimeStamp;      // when IVT was build
   DWORD dwVersion;     // contains authored version
   DWORD dwRevision;    //    ditto
   DWORD dwBuild;       //    ditto
   DWORD dwSubBuild;    //    ditto
   DWORD dwLangId;      // language identifier
   IVTVERSIONSIGNATURE sig;
} IVTVERSION;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\fts_lib\itgroup.h ===
// ITGROUP.H:  IITGroup interface declaration

#ifndef __ITGROUP_H__
#define __ITGROUP_H__

//#include <comdef.h>

// {B1A6CA91-A479-11d0-9741-00AA006117EB}
DEFINE_GUID(IID_IITGroup, 
0xb1a6ca91, 0xa479, 0x11d0, 0x97, 0x41, 0x0, 0xaa, 0x0, 0x61, 0x17, 0xeb);

// {98258914-B6AB-11d0-9D92-00A0C90F55A5}
DEFINE_GUID(IID_IITGroupArray, 
0x98258914, 0xb6ab, 0x11d0, 0x9d, 0x92, 0x0, 0xa0, 0xc9, 0xf, 0x55, 0xa5);

#ifdef ITPROXY

// {B1A6CA92-A479-11d0-9741-00AA006117EB}
DEFINE_GUID(CLSID_IITGroup, 
0xb1a6ca92, 0xa479, 0x11d0, 0x97, 0x41, 0x0, 0xaa, 0x0, 0x61, 0x17, 0xeb);

// {98258915-B6AB-11d0-9D92-00A0C90F55A5}
DEFINE_GUID(CLSID_IITGroupArray, 
0x98258915, 0xb6ab, 0x11d0, 0x9d, 0x92, 0x0, 0xa0, 0xc9, 0xf, 0x55, 0xa5);

#else

// {4662daab-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITGroupLocal, 
0x4662daab, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4662daac-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITGroupArrayLocal, 
0x4662daac, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#endif	// ITPROXY

// Forward declarations
interface IITDatabase;

DECLARE_INTERFACE_(IITGroup, IUnknown)
{

	STDMETHOD(Initiate)(DWORD lcGrpItem) PURE;
	STDMETHOD(CreateFromBitVector)(LPBYTE lpBits, DWORD dwSize, DWORD dwItems) PURE;
	STDMETHOD(CreateFromBuffer)(HANDLE h) PURE;
    STDMETHOD(Open)(IITDatabase* lpITDB, LPCWSTR lpszMoniker) PURE;
    STDMETHOD(Free)(void) PURE;
	STDMETHOD(CopyOutBitVector)(IITGroup* pIITGroup) PURE;
    STDMETHOD(AddItem)(DWORD dwGrpItem) PURE;
    STDMETHOD(RemoveItem)(DWORD dwGrpItem) PURE;
	STDMETHOD(FindTopicNum)(DWORD dwCount, LPDWORD lpdwOutputTopicNum) PURE;
	STDMETHOD(FindOffset)(DWORD dwTopicNum, LPDWORD lpdwOutputOffset) PURE;
    STDMETHOD(GetSize)(LPDWORD dwGrpSize) PURE;
	STDMETHOD(Trim)(void) PURE;
	STDMETHOD(And)(IITGroup* pIITGroup) PURE;
	STDMETHOD(And)(IITGroup* pIITGroupIn, IITGroup* pIITGroupOut) PURE;
	STDMETHOD(Or)(IITGroup* pIITGroup) PURE;
	STDMETHOD(Or)(IITGroup* pIITGroupIn, IITGroup* pIITGroupOut) PURE;
	STDMETHOD(Not)(void) PURE;
	STDMETHOD(Not)(IITGroup* pIITGroupOut) PURE;
	STDMETHOD(IsBitSet)(DWORD dwTopicNum) PURE;
	STDMETHOD(CountBitsOn)(LPDWORD lpdwTotalNumBitsOn) PURE;
	STDMETHOD(Clear)(void) PURE;
    STDMETHOD_(LPVOID, GetLocalImageOfGroup)(void) PURE;
    STDMETHOD(PutRemoteImageOfGroup)(LPVOID lpGroupIn) PURE;

};

typedef IITGroup* LPITGROUP;

#define ITGP_MAX_GROUPARRAY_ENTRIES 32   // maximum number of groups allowed in a collection
#define ITGP_ALL_ENTRIES (-1L)
#define ITGP_OPERATOR_OR   0
#define ITGP_OPERATOR_AND  1

DECLARE_INTERFACE_(IITGroupArray, IITGroup)
{
	// composite group interface
	STDMETHOD(InitEntry)(IITDatabase *piitDB, LPCWSTR lpwszName, LONG& lEntryNum) PURE;
	STDMETHOD(InitEntry)(IITGroup *piitGroup, LONG& lEntryNum) PURE;
	STDMETHOD(SetEntry)(LONG lEntryNum) PURE;
	STDMETHOD(ClearEntry)(LONG lEntryNum) PURE;
	STDMETHOD(SetDefaultOp)(LONG cDefaultOp) PURE;
	STDMETHOD(ToString)(LPWSTR *ppwBuffer) PURE;
};

typedef IITGroupArray* LPIITGroupArray;
#endif // __ITGROUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\fts_lib\iterror.h ===
#ifndef __ITERROR_H__
#define __ITERROR_H__


#ifdef __cplusplus
extern "C" {
#endif


// define the old error types in terms of HRESULTs
typedef HRESULT* PHRESULT;

#define ERR     HRESULT
#define ERRB    HRESULT
#define LPERRB  HRESULT*
#define RC      HRESULT


#define	SetErrCode(a,b)	SetErr(a, b)
#define	SetErrReturn(a)	SetErr(0, a)


HRESULT PASCAL SetErr (HRESULT* phr, HRESULT ErrCode);


/*************************************************************************
 *
 *                  CALLBACK FUNCTIONS PROTOTYPES
 *
 * User callback functions are needed in case:
 *  - The application needs to support interrupt
 *  - The application needs to display error messages its way
 *  - The application needs to know the status of the process
 *************************************************************************/
typedef ERR (FAR PASCAL *ERR_FUNC) (DWORD dwFlag, LPVOID pUserData, LPVOID pMessage);

/*************************************************************************
 * Call back structure
 *  Contains information about all callback functions
 *************************************************************************/ 

#define ERRFLAG_INTERRUPT      0x01 // The processes should be cancelled
#define ERRFLAG_STATUS         0x02 // High-level status messages
#define ERRFLAG_STATUS_VERBOSE 0x04 // Low-level status messages
#define ERRFLAG_ERROR          0x08 // Warning & Error messages
#define ERRFLAG_STRING         0x10 // Debug string messages

typedef struct fCallBack_msg
{
    ERR_FUNC MessageFunc;
    LPVOID pUserData;
    DWORD  dwFlags;
} FCALLBACK_MSG, FAR * PFCALLBACK_MSG;


// ***********************************************************************
// This structure should be filled out and passed back in the case of
// an error.
// ***********************************************************************
typedef WORD HCE;   // User errors
typedef WORD EP;    // Error Phase
typedef struct
{
    LPCSTR  pchFile;
    LONG    iLine;
    DWORD   iTopic;
    DWORD   fCustom; // If true then var1 is LPCSTR to custom error message
    DWORD   var1, var2, var3;   // Error parameters

    EP      ep;                 // Error Phase
    HCE     errCode;
} ERRC, FAR *PERRC;

#define CALLBACKKEY 0x524A4A44

typedef struct
{
    DWORD dwReserved;
    DWORD dwKey;
    FCALLBACK_MSG Callback;
} CUSTOMSTRUCT, FAR *PCUSTOMSTRUCT;

// Error Phase values
#define epNoFile       0
#define epLine         1
#define epTopic        2
#define epOffset       3
#define epMVBtopic	   4
#define epAliasLine	   5
#define epByteOffset   6


//
// The InfoTech error codes
//
#define E_NOTEXIST          _HRESULT_TYPEDEF_(0x80001000L)
#define E_DUPLICATE         _HRESULT_TYPEDEF_(0x80001001L)
#define E_BADVERSION        _HRESULT_TYPEDEF_(0x80001002L)
#define E_BADFILE           _HRESULT_TYPEDEF_(0x80001003L)
#define E_BADFORMAT         _HRESULT_TYPEDEF_(0x80001004L)
#define E_NOPERMISSION      _HRESULT_TYPEDEF_(0x80001005L)
#define E_ASSERT            _HRESULT_TYPEDEF_(0x80001006L)
#define E_INTERRUPT         _HRESULT_TYPEDEF_(0x80001007L)
#define E_NOTSUPPORTED      _HRESULT_TYPEDEF_(0x80001008L)
#define E_OUTOFRANGE        _HRESULT_TYPEDEF_(0x80001009L)                  
#define E_GROUPIDTOOBIG     _HRESULT_TYPEDEF_(0x8000100AL)
#define E_TOOMANYTITLES     _HRESULT_TYPEDEF_(0x8000100BL)
#define E_NOMERGEDDATA      _HRESULT_TYPEDEF_(0x8000100CL)
#define E_NOTFOUND          _HRESULT_TYPEDEF_(0x8000100DL)
#define E_CANTFINDDLL       _HRESULT_TYPEDEF_(0x8000100EL)
#define E_NOHANDLE          _HRESULT_TYPEDEF_(0x8000100FL) 
#define E_GETLASTERROR      _HRESULT_TYPEDEF_(0x80001010L)
#define E_BADPARAM			_HRESULT_TYPEDEF_(0x80001011L)
#define E_INVALIDSTATE		_HRESULT_TYPEDEF_(0x80001012L)
#define E_NOTOPEN           _HRESULT_TYPEDEF_(0x80001013L)
#define E_ALREADYOPEN       _HRESULT_TYPEDEF_(0x80001013L)
#define E_UNKNOWN_TRANSPORT _HRESULT_TYPEDEF_(0x80001016L)
#define E_UNSUPPORTED_TRANSPORT _HRESULT_TYPEDEF_(0x80001017L)
#define E_BADFILTERSIZE     _HRESULT_TYPEDEF_(0x80001018L)
#define E_TOOMANYOBJECTS    _HRESULT_TYPEDEF_(0x80001019L)
#define E_NAMETOOLONG       _HRESULT_TYPEDEF_(0x80001020L)

#define E_FILECREATE        _HRESULT_TYPEDEF_(0x80001030L) 
#define E_FILECLOSE         _HRESULT_TYPEDEF_(0x80001031L)
#define E_FILEREAD          _HRESULT_TYPEDEF_(0x80001032L)
#define E_FILESEEK          _HRESULT_TYPEDEF_(0x80001033L)
#define E_FILEWRITE         _HRESULT_TYPEDEF_(0x80001034L)
#define E_FILEDELETE        _HRESULT_TYPEDEF_(0x80001035L)
#define E_FILEINVALID       _HRESULT_TYPEDEF_(0x80001036L)
#define E_FILENOTFOUND      _HRESULT_TYPEDEF_(0x80001037L)
#define E_DISKFULL          _HRESULT_TYPEDEF_(0x80001038L)

#define E_TOOMANYTOPICS     _HRESULT_TYPEDEF_(0x80001050L)
#define E_TOOMANYDUPS       _HRESULT_TYPEDEF_(0x80001051L)
#define E_TREETOOBIG        _HRESULT_TYPEDEF_(0x80001052L)
#define E_BADBREAKER        _HRESULT_TYPEDEF_(0x80001053L)
#define E_BADVALUE          _HRESULT_TYPEDEF_(0x80001054L)
#define E_ALL_WILD          _HRESULT_TYPEDEF_(0x80001055L)
#define E_TOODEEP           _HRESULT_TYPEDEF_(0x80001056L)
#define E_EXPECTEDTERM      _HRESULT_TYPEDEF_(0x80001057L)
#define E_MISSLPAREN        _HRESULT_TYPEDEF_(0x80001058L)
#define E_MISSRPAREN        _HRESULT_TYPEDEF_(0x80001059L)
#define E_MISSQUOTE         _HRESULT_TYPEDEF_(0x8000105AL)
#define E_NULLQUERY         _HRESULT_TYPEDEF_(0x8000105BL)
#define E_STOPWORD          _HRESULT_TYPEDEF_(0x8000105CL)
#define E_BADRANGEOP        _HRESULT_TYPEDEF_(0x8000105DL)
#define E_UNMATCHEDTYPE     _HRESULT_TYPEDEF_(0x8000105EL)
#define E_WORDTOOLONG       _HRESULT_TYPEDEF_(0x8000105FL)
#define E_BADINDEXFLAGS     _HRESULT_TYPEDEF_(0x80001060L)
#define E_WILD_IN_DTYPE		_HRESULT_TYPEDEF_(0x80001061L)   
#define E_NOSTEMMER			_HRESULT_TYPEDEF_(0x80001062L)

// Property list and result set errors
#define E_MISSINGPROP		_HRESULT_TYPEDEF_(0x80001080L)
#define E_PROPLISTNOTEMPTY  _HRESULT_TYPEDEF_(0x80001081L)
#define E_PROPLISTEMPTY     _HRESULT_TYPEDEF_(0x80001082L)
#define E_ALREADYINIT       _HRESULT_TYPEDEF_(0x80001083L)
#define E_NOTINIT           _HRESULT_TYPEDEF_(0x80001084L)
#define E_RESULTSETEMPTY	_HRESULT_TYPEDEF_(0x80001085L)
#define E_TOOMANYCOLUMNS	_HRESULT_TYPEDEF_(0x80001086L)
#define E_NOKEYPROP			_HRESULT_TYPEDEF_(0x80001087L)

#ifdef __cplusplus
}
#endif

#endif  // __ITERROR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\fts_lib\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__23C95C1F_F8B1_4A62_8F99_CAD1F1AB7339__INCLUDED_)
#define AFX_STDAFX_H__23C95C1F_F8B1_4A62_8F99_CAD1F1AB7339__INCLUDED_

#include <module.h>

#include <MPC_main.h>
#include <MPC_utils.h>
#include <MPC_config.h>

#include <SvcResource.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__23C95C1F_F8B1_4A62_8F99_CAD1F1AB7339__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\fts_lib\itrs.h ===
// ITRS.H:	ITResultSet interface declaration

#ifndef __ITRS_H__
#define __ITRS_H__


// {3BB91D41-998B-11d0-A850-00AA006C7D01}
DEFINE_GUID(IID_IITResultSet, 
0x3bb91d41, 0x998b, 0x11d0, 0xa8, 0x50, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

// {4662daa7-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITResultSet, 
0x4662daa7, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// maximum number of columns in a row set
#define MAX_COLUMNS  256

// Column priorities
typedef enum
{
    PRIORITY_LOW = 0,
    PRIORITY_NORMAL = 1,
    PRIORITY_HIGH = 2,

} PRIORITY;


// Forward declarations
class CProperty;

typedef struct tagROWSTATUS
{
    LONG lRowFirst;
    LONG cRows;
    LONG cProperties;
    LONG cRowsTotal;

} ROWSTATUS, *LPROWSTATUS;


typedef struct tagCOLUMNSTATUS
{
    LONG cPropCount;
    LONG cPropsLoaded;

} COLUMNSTATUS, *LPCOLUMNSTATUS;


// Used by IITResultSet::SetColumnHeap.
typedef SCODE (__stdcall *PFNCOLHEAPFREE)(LPVOID);


DECLARE_INTERFACE_(IITResultSet, IUnknown)
{
    // Initialization
    STDMETHOD(SetColumnPriority)(LONG lColumnIndex, PRIORITY ColumnPriority) PURE;
	STDMETHOD(SetColumnHeap)(LONG lColumnIndex, LPVOID lpvHeap,
										PFNCOLHEAPFREE pfnColHeapFree) PURE;
    STDMETHOD(SetKeyProp)(PROPID PropID) PURE;
    STDMETHOD(Add)(LPVOID lpvHdr) PURE;
    STDMETHOD(Add)(PROPID PropID, LPVOID lpvDefaultData, DWORD cbData, PRIORITY Priority) PURE;
    STDMETHOD(Add)(PROPID PropID, LPCWSTR lpszwDefault, PRIORITY Priority) PURE;
    STDMETHOD(Add)(PROPID PropID, DWORD dwDefaultData, PRIORITY Priority) PURE;

    // Build result set
	STDMETHOD(Append)(LPVOID lpvHdr, LPVOID lpvData) PURE;
	STDMETHOD(Set)(LONG lRowIndex, LPVOID lpvHdr, LPVOID lpvData) PURE;
    STDMETHOD(Set)(LONG lRowIndex, LONG lColumnIndex, DWORD dwData) PURE;
    STDMETHOD(Set)(LONG lRowIndex, LONG lColumnIndex, LPCWSTR lpwStr) PURE;
    STDMETHOD(Set)(LONG lRowIndex, LONG lColumnIndex, LPVOID lpvData, DWORD cbData) PURE;
	STDMETHOD(Copy)(IITResultSet* pRSCopy) PURE;
	STDMETHOD(AppendRows)(IITResultSet* pResSrc, LONG lRowSrcFirst, LONG cSrcRows, 
									LONG& lRowFirstDest) PURE;


    // Obtain info about result set
    STDMETHOD(Get)(LONG lRowIndex, LONG lColumnIndex, CProperty& Prop) PURE;
    STDMETHOD(GetKeyProp)(PROPID& KeyPropID) PURE;
    STDMETHOD(GetColumnPriority)(LONG lColumnIndex, PRIORITY& ColumnPriority) PURE;
    STDMETHOD(GetRowCount)(LONG& lNumberOfRows) PURE;
	STDMETHOD(GetColumnCount)(LONG& lNumberOfColumns) PURE;
	STDMETHOD(GetColumn)(LONG lColumnIndex, PROPID& PropID) PURE;
    STDMETHOD(GetColumn)(LONG lColumnIndex, PROPID& PropID, DWORD& dwType, LPVOID& lpvDefaultValue,
		                 DWORD& cbSize, PRIORITY& ColumnPriority) PURE;

	STDMETHOD(GetColumnFromPropID)(PROPID PropID, LONG& lColumnIndex) PURE;

    // Clear result set
    STDMETHOD(Clear)() PURE;
    STDMETHOD(ClearRows)() PURE;
    STDMETHOD(Free)() PURE;

    // Asynchronous support
    STDMETHOD(IsCompleted)() PURE;      // returns S_OK or S_FALSE
    STDMETHOD(Cancel)() PURE;
    STDMETHOD(Pause)(BOOL fPause) PURE;

    STDMETHOD(GetRowStatus)(LONG lRowFirst, LONG cRows, LPROWSTATUS lpRowStatus) PURE;
    STDMETHOD(GetColumnStatus)(LPCOLUMNSTATUS lpColStatus) PURE;
};

typedef IITResultSet* LPITRS;


#endif		// __ITRS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\fts_lib\itpropl.h ===
// ITPROPL.H:	ITPropertyList interface declaration

#ifndef __ITPROPL_H__
#define __ITPROPL_H__

#include <ocidl.h>

// {1F403BB1-9997-11d0-A850-00AA006C7D01}
DEFINE_GUID(IID_IITPropList, 
0x1f403bb1, 0x9997, 0x11d0, 0xa8, 0x50, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

// {4662daae-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITPropList, 
0x4662daae, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

typedef DWORD PROPID;

// Operations you can do on a property
#define PROP_ADD    0x00000000
#define PROP_DELETE 0x00000001
#define PROP_UPDATE 0x00000002

// Type of data
#define TYPE_VALUE   0x00000000
#define TYPE_POINTER 0x00000001
#define TYPE_STRING  0x00000002

// Class definition of CProperty
class CProperty
{
public:
    PROPID dwPropID;        // property ID
    DWORD cbData;           // Amount of data
    DWORD dwType;           // What type this is
    union
    {
        LPCWSTR lpszwData;  // String
        LPVOID lpvData;     // Any kind of data
        DWORD  dwValue;     // Numerical data
    };
	BOOL fPersist;          // TRUE to persist this property

};

typedef CProperty* LPPROP;


// Interface def. for IITPropList
DECLARE_INTERFACE_(IITPropList, IPersistStreamInit)
{

    // dwOperation = operation (add, delete, update, etc.) to perform on property list
	STDMETHOD(Set)(PROPID PropID, DWORD dwData, DWORD dwOperation) PURE;
	STDMETHOD(Set)(PROPID PropID, LPVOID lpvData, DWORD cbData, DWORD dwOperation) PURE;
    STDMETHOD(Set)(PROPID PropID, LPCWSTR lpszwString, DWORD dwOperation) PURE;
    STDMETHOD(Add)(CProperty& Prop) PURE;

    STDMETHOD(Get)(PROPID PropID, CProperty& Property) PURE;
    STDMETHOD(Clear)() PURE;

    // set persistence state on property
    STDMETHOD(SetPersist)(PROPID PropID, BOOL fPersist) PURE;   // single property
    STDMETHOD(SetPersist)(BOOL fPersist) PURE;          // all properties in list

    // for enumerating properties
    STDMETHOD(GetFirst)(CProperty& Property) PURE;
    STDMETHOD(GetNext)(CProperty& Property) PURE;
    STDMETHOD(GetPropCount)(LONG &cProp) PURE;

	// persist header and data separately
	STDMETHOD(SaveHeader)(LPVOID lpvData, DWORD dwHdrSize) PURE;
	STDMETHOD(SaveData)(LPVOID lpvHeader, DWORD dwHdrSize, LPVOID lpvData, DWORD dwBufSize) PURE;
	STDMETHOD(GetHeaderSize)(DWORD& dwHdrSize) PURE;
	STDMETHOD(GetDataSize)(LPVOID lpvHeader, DWORD dwHdrSize, DWORD& dwDataSize) PURE;
	STDMETHOD(SaveDataToStream)(LPVOID lpvHeader, DWORD dwHdrSize, IStream* pStream) PURE;

    // persist to a memory buffer
    STDMETHOD(LoadFromMem)(LPVOID lpvData, DWORD dwBufSize) PURE;
    STDMETHOD(SaveToMem)(LPVOID lpvData, DWORD dwBufSize) PURE;

};

typedef IITPropList* LPITPROPLIST;

#endif		// __ITPROPL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\fts_lib\itww.h ===
// ITWW.H:	IITWordWheel interface declaration

#ifndef __ITWW_H__
#define __ITWW_H__

// {8fa0d5a4-dedf-11d0-9a61-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(IID_IITWordWheel, 
0x8fa0d5a4, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#ifdef ITPROXY

// {D73725C2-8C12-11d0-A84E-00AA006C7D01}
DEFINE_GUID(CLSID_IITWordWheel, 
0xd73725c2, 0x8c12, 0x11d0, 0xa8, 0x4e, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

#else

// {4662daa8-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITWordWheelLocal, 
0x4662daa8, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#endif	// ITPROXY

// Word-wheel open flags
#define ITWW_OPEN_CONNECT	0x00000000    // connect to server on open (the default)
#define ITWW_OPEN_NOCONNECT	0x00000001    // don't connect to server on open

// Constants for IITWordWheel::Lookup.
#define ITWW_CBKEY_MAX		1024		// Max size of keys allowed in Word Wheels.

// Forward declarations
interface IITDatabase;
interface IITResultSet;
interface IITGroup;
interface IITPropList;
interface IITQuery;

DECLARE_INTERFACE_(IITWordWheel, IUnknown)
{

	STDMETHOD(Open)(IITDatabase* lpITDB, LPCWSTR lpszMoniker, DWORD dwFlags=0) PURE;
	STDMETHOD(Close)(void) PURE;

	// Returns the code page ID and locale ID that the word wheel was built and
	// sorted with.
	STDMETHOD(GetLocaleInfo)(DWORD *pdwCodePageID, LCID *plcid) PURE;

	// Returns in *pdwObjInstance the ID of the external sort instance being used by
	// this word wheel.  The instance ID can be passed to IITDatabase::GetObject to
	// to obtain an interface pointer on the instantiated instance.  If the word
	// wheel doesn't use external sorting, then IITDB_OBJINST_NULL.
	STDMETHOD(GetSorterInstance)(DWORD *pdwObjInstance) PURE;

	STDMETHOD(Count)(LONG *pcEntries) PURE;

	// To be safe, the length of lpvKeyBuf should always be at least ITWW_CBKEY_MAX. 
	STDMETHOD(Lookup)(LONG lEntry, LPVOID lpvKeyBuf, DWORD cbKeyBuf) PURE;
	STDMETHOD(Lookup)(LONG lEntry, IITResultSet* lpITResult, LONG cEntries) PURE;
	STDMETHOD(Lookup)(LPCVOID lpcvPrefix, BOOL fExactMatch, LONG *plEntry) PURE;

	STDMETHOD(SetGroup)(IITGroup* piitGroup) PURE;
	STDMETHOD(GetGroup)(IITGroup** ppiitGroup) PURE;

	STDMETHOD(GetDataCount)(LONG lEntry, DWORD *pdwCount) PURE;
	STDMETHOD(GetData)(LONG lEntry, IITResultSet* lpITResult) PURE;
	STDMETHOD(GetDataColumns)(IITResultSet* pRS) PURE;
};

typedef IITWordWheel* LPITWORDWHEEL;

#endif		// __ITWW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\fts_lib\subfile.cpp ===
// Copyright (C) 1997 Microsoft Corporation. All rights reserved.

#include "stdafx.h"
#include "titleinfo.h"
#include <strsafe.h>

static CPagesList listSubfiles;

//////////////////////////////////////////////
//
//  CPagesList
//
//////////////////////////////////////////////

CPagesList::~CPagesList()
{
    CPages* p;

    while (p = m_pFirst)
    {
        m_pFirst = p->m_pNext;
        delete p;
    }
}

CPages* CPagesList::GetPages( HASH hash )
{
    CPages * p;

    for (p = m_pFirst; p; p = p->m_pNext)
        if ( hash == p->m_hash )
            return p;

    p = new CPages( hash );
	if(p)
	{
		p->m_pNext = m_pFirst;
		m_pFirst = p;
	}

    return p;
}

////////////////////////////////////////
//
//  CPages
//
////////////////////////////////////////

CPages::CPages( HASH hash )
{
    m_pNext = 0;
    m_hash = hash;
    Flush();
}

void* CPages::Find(const CTitleInfo * pTitle, HASH hashPathname, DWORD dwPage)
{
  int i;
   
   for( i = 0; i < CACHE_PAGE_COUNT; i++ )
   {
      // test if lowest LRU
      if( m_pages[i].dwLRU < m_pages[m_dwLRUPage].dwLRU ) {
        m_dwLRUPage = i;
      }

      if( m_pages[i].dwLRU &&
          m_pages[i].hashPathname == hashPathname &&
          m_pages[i].dwPage == dwPage &&
          m_pages[i].pTitle == pTitle )
      {
         m_pages[i].dwLRU = ++m_dwLRUCount;  // update LRU
         return m_pages[i].rgb;
      }
   }

   return NULL;
}

void* CPages::Alloc(CTitleInfo * pTitle, HASH hashPathname, DWORD dwPage)
{
    // if we reached the max LRU number then flush the cache and start over
    if( m_dwLRUCount == ((DWORD) -1) )
      Flush();
    
    m_pages[m_dwLRUPage].dwLRU = ++m_dwLRUCount;
    m_pages[m_dwLRUPage].hashPathname = hashPathname;
    m_pages[m_dwLRUPage].dwPage = dwPage;
    m_pages[m_dwLRUPage].pTitle = pTitle;

    return m_pages[m_dwLRUPage].rgb;
}

void CPages::Flush(void)
{
    int i;

    for( i = 0; i < CACHE_PAGE_COUNT; i++ ) 
        m_pages[i].dwLRU = 0;
    m_dwLRUPage = 0;
    m_dwLRUCount = 0;
}

void CPages::Flush( CTitleInfo* pTitle )
{
    if( !pTitle )
      return;

    int i;

    for( i = 0; i < CACHE_PAGE_COUNT; i++ )
      if( m_pages[i].pTitle == pTitle )
        m_pages[i].dwLRU = 0;
}


//////////////////////////////////////////////
//
//  CPagedSubfile
//
//////////////////////////////////////////////

CPagedSubfile::CPagedSubfile()
{
   m_pCSubFileSystem = 0;          // type CSubFileSystem from fs.h/fs.cpp
   m_pTitle = 0;
   m_pPages = 0;
   m_cbSize = 0xFFFFFFFF;
}

CPagedSubfile::~CPagedSubfile()
{
   if ( m_pCSubFileSystem )
      delete m_pCSubFileSystem;

   // flush all of its owned pages since
   // the same pTitle value may be re-used and thus
   // the cache is invalid
   m_pPages->Flush( m_pTitle );
}

HRESULT CPagedSubfile::Open(CTitleInfo * pTitle, LPCSTR lpsz)
{
   if (m_pCSubFileSystem || m_pTitle || m_pPages || !pTitle->m_pCFileSystem )
      return E_FAIL;

   m_pTitle = pTitle;

   // hash the filename
   m_hashPathname = HashFromSz( lpsz );

#ifdef _DEBUG
   char sz[1024];
   StringCbPrintfA( sz, sizeof(sz), "Hash:%d File:%s\n", m_hashPathname, lpsz );
   OutputDebugString( sz );
#endif

#if defined( HH_FAST_CACHE )
   // keep CACHE_PAGE_COUNT small (2-3) and hash the title and the filename
   char szHash[MAX_PATH*2];
   StringCchCopyA( szHash, ARRAYSIZE(szHash), pTitle->GetInfo2()->GetShortName() );
   StringCchCatA( szHash, ARRAYSIZE(szHash), "::" );
   StringCchCatA( szHash, ARRAYSIZE(szHash), lpsz );
   m_hash = HashFromSz( szHash );
#elif defined ( HH_EFFICIENT_CACHE )
   // keep CACHE_PAGE_COUNT moderately low (3-5) and hash just the filename
   m_hash = HashFromSz( lpsz );
#else // HH_SHARED_CACHE
   // keep CACHE_PAGE_COUNT high (30+) and have only one shared cache group
   m_hash = HashFromSz( "HTMLHelpSharedCache" );
#endif

   if (!(m_pPages = listSubfiles.GetPages(m_hash)))
       return E_FAIL;

   m_pCSubFileSystem = new CSubFileSystem(pTitle->m_pCFileSystem); if(!m_pCSubFileSystem) return E_FAIL;

   if(FAILED(m_pCSubFileSystem->OpenSub(lpsz)))
   {
       delete m_pCSubFileSystem;
       m_pCSubFileSystem = NULL;
       return E_FAIL;
   }
   m_cbSize = m_pCSubFileSystem->GetUncompressedSize();

   return S_OK;
}

void* CPagedSubfile::Offset(DWORD dwOffs)
{
   DWORD dwPage;
   void* pv;

   if (dwOffs >= m_cbSize)
       return NULL;

   dwPage = dwOffs / PAGE_SIZE;

   dwOffs -= (dwPage * PAGE_SIZE);

   if (pv = Page(dwPage))
      return (BYTE*)pv + dwOffs;
   else
      return NULL;
}

void* CPagedSubfile::Page(DWORD dwPage)
{
    void* pv;

    if (pv = m_pPages->Find(m_pTitle, m_hashPathname, dwPage))
        return pv;

    if (!(pv = m_pPages->Alloc(m_pTitle, m_hashPathname, dwPage)))
        return NULL;

    DWORD li = dwPage * PAGE_SIZE;

    if ( m_pCSubFileSystem->SeekSub(li,0) != li )
       return NULL;

    // init the page in case we don't read it all...
    //
#ifdef _DEBUG
    memset(pv,0xFF,PAGE_SIZE);
#endif

    ULONG cb;
    if (FAILED(m_pCSubFileSystem->ReadSub(pv, PAGE_SIZE, &cb)))
        return NULL;

   return pv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\fts_lib\itquery.h ===
// ITQUERY.H:	IITIndex and IITQuery interface declarations

#ifndef __ITQUERY_H__
#define __ITQUERY_H__

#include "iterror.h"

// {8fa0d5a3-dedf-11d0-9a61-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(IID_IITIndex, 
0x8fa0d5a3, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#ifdef ITPROXY

// {A38D3483-8C49-11d0-A84E-00AA006C7D01}
DEFINE_GUID(CLSID_IITIndex, 
0xa38d3483, 0x8c49, 0x11d0, 0xa8, 0x4e, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

#else

// {4662daad-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITIndexLocal, 
0x4662daad, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#endif	// ITPROXY

// {8fa0d5ac-dedf-11d0-9a61-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(IID_IITQuery, 
0x8fa0d5ac, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4662daa6-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITQuery, 
0x4662daa6, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// Defines
#define IMPLICIT_AND            0x0000
#define IMPLICIT_OR             0x0001
#define COMPOUNDWORD_PHRASE     0x0010 // use PHRASE opr for compound words
#define QUERYRESULT_RANK        0x0100 // Ranked the result. If not highest hit 1st (topics in UID order)
#define QUERYRESULT_UIDSORT     0x0200 // Result topics are 1st in 1st out
#define QUERYRESULT_SKIPOCCINFO 0x8000 // Topic list only, no occurrence info

#define STEMMED_SEARCH	        0x00010000
#define RESULTSET_ASYNC			0x00020000
#define QUERY_GETTERMS			0x00080000	// Return with each set of occurrence
											// data a pointer to the term string
											// that the data is associated with.

// Standard properties
#define STDPROP_SEARCHBASE  500
#define STDPROP_FIELD			STDPROP_SEARCHBASE
#define STDPROP_LENGTH			(STDPROP_SEARCHBASE + 1)
#define STDPROP_COUNT			(STDPROP_SEARCHBASE + 2)
#define STDPROP_OFFSET			(STDPROP_SEARCHBASE + 3)
#define STDPROP_TERM_UNICODE_ST	(STDPROP_SEARCHBASE + 4)

// Don't know signature of callbacks yet
typedef void (*LPFNCBBREAK)(void);    
typedef void (*LPFNRESULTCB)(void);


// Forward declarations
interface IITResultSet;
interface IITQuery;
interface IITDatabase;
interface IITGroup;

DECLARE_INTERFACE_(IITIndex, IUnknown)
{

	STDMETHOD(Open)(IITDatabase* pITDB, LPCWSTR lpszIndexMoniker, BOOL fInsideDB) PURE;
	STDMETHOD(Close)(void) PURE;

	STDMETHOD(GetLocaleInfo)(DWORD *pdwCodePageID, LCID *plcid) PURE;
	STDMETHOD(GetWordBreakerInstance)(DWORD *pdwObjInstance) PURE;

	STDMETHOD(CreateQueryInstance)(IITQuery** ppITQuery) PURE;
	STDMETHOD(Search)(IITQuery* pITQuery, IITResultSet* pITResult) PURE;
	STDMETHOD(Search)(IITQuery* pITQuery, IITGroup* pITGroup) PURE;
};

typedef IITIndex* PITINDEX;


DECLARE_INTERFACE_(IITQuery, IUnknown)
{
	STDMETHOD(SetResultCallback)(FCALLBACK_MSG *pfcbkmsg) PURE;
	STDMETHOD(SetCommand)(LPCWSTR lpszCommand) PURE;
	STDMETHOD(SetOptions)(DWORD dwFlags) PURE;
	STDMETHOD(SetProximity)(WORD wNear) PURE;
	STDMETHOD(SetGroup)(IITGroup* pITGroup) PURE;
	STDMETHOD(SetResultCount)(LONG cRows) PURE;

	STDMETHOD(GetResultCallback)(FCALLBACK_MSG *pfcbkmsg) PURE;
	STDMETHOD(GetCommand)(LPCWSTR& lpszCommand) PURE;
	STDMETHOD(GetOptions)(DWORD& dwFlags) PURE;
	STDMETHOD(GetProximity)(WORD& wNear) PURE;
	STDMETHOD(GetGroup)(IITGroup** ppiitGroup) PURE;
	STDMETHOD(GetResultCount)(LONG& cRows) PURE;

	STDMETHOD(ReInit)() PURE;

};

typedef IITQuery* PITQUERY;


#endif		// __ITQUERY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\fts_lib\subfile.h ===
// Copyright (C) 1997 Microsoft Corporation. All rights reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __SUBFILE_H__
#define __SUBFILE_H__

#include "hhtypes.h"

// we have three possible caching schemes:

// HH_FAST_CACHE - fast but its a hog!
//
// We store a small number of pages (2-3) for each unique
// title and subfile combination.  This results is quite of bit
// of memory being used per collection but oh boy is it fast!
//
//#define HH_FAST_CACHE

// HH_EFFICIENT_CACHE - slow but it saves memory!
//
// We store a small number of moderate pages (2-3) for each unique
// subfile regardless of the title it came from.  This results in an
// efficient use of memory since like subfiles, such as #TOCIDX, share
// the same group of cache pages instead of having their own uniqe group
// per title.  However, this method slows things down since multiple reads
// from the same named subfile accross several titles results in many
// cache misses.
//
//#define HH_EFFICIENT_CACHE

// HH_SHARED_CACHE - nice balance of speed and size!
//
// We store a large number of pages (16+) for the entire collection.
// This result is a fixed quantity of cache pages regardless of number
// and type of subfiles we have.  It utilizes memory well since we can
// access multiple subfiles of the same name accross several titles
// effectively yielding a larger pool of cache pages.
//
// [paulti] - We want to use this method exclusively.  Please see me
//            if you want to change this for any reason.
//
#define HH_SHARED_CACHE

#if defined ( HH_FAST_CACHE )
#define CACHE_PAGE_COUNT 3
#elif defined ( HH_EFFICIENT_CACHE )
#define CACHE_PAGE_COUNT 5
#else // HH_SHARED_CACHE
#define CACHE_PAGE_COUNT 32
#endif

class CSubFileSystem;
class CTitleInfo;

typedef struct page {
    CTitleInfo* pTitle;
    DWORD     dwPage;
    HASH      hashPathname;
    DWORD     dwLRU;
    BYTE      rgb[PAGE_SIZE];
} PAGE;

//////////////////////////////////////////////
//
//  CPagesList
//
//////////////////////////////////////////////

class CPagesList
{
    friend class CPagedSubfile;
    friend class CPages;

public:
    CPagesList() { m_pFirst = 0; }
    ~CPagesList();

private:
    CPages* m_pFirst;
    CPages* GetPages( HASH );

};

////////////////////////////////////////
//
//  CPages
//
////////////////////////////////////////

class CPages
{
public:
    void  Flush( CTitleInfo* pTitle );

private:
    CPages( HASH );

    void* Find( const CTitleInfo *, HASH, DWORD );
    void* Alloc( CTitleInfo *, HASH, DWORD );
    void  Flush( void );

    CPages* m_pNext;
    HASH           m_hash;
    DWORD          m_dwLRUPage;
    DWORD          m_dwLRUCount;
    PAGE           m_pages[CACHE_PAGE_COUNT];

    friend class CPagedSubfile;
    friend class CPagesList;
};

//////////////////////////////////////////////
//
//  CPagedSubfile
//
//////////////////////////////////////////////

class CPagedSubfile
{
public:
   CPagedSubfile();
   ~CPagedSubfile();

   HRESULT Open(CTitleInfo *, LPCSTR);

   void* Offset(DWORD dwOffs);
   void* Page(DWORD iPage);

private:
   CSubFileSystem* m_pCSubFileSystem;
   CTitleInfo*       m_pTitle;
   HASH            m_hashPathname;
   HASH            m_hash;
   DWORD           m_cbSize;
   CPages*  m_pPages;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\fts_lib\msitstg.h ===
// MSITStg.h -- Interface declaration for IMSITStorage

#ifndef __MSITSTG_H__

#define __MSITSTG_H__

// Class ID for the ITSS File System:

DEFINE_GUID(CLSID_ITStorage, 
0x5d02926a, 0x212e, 0x11d0, 0x9d, 0xf9, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Inteface ID for the IITStorage interface:

DEFINE_GUID(IID_ITStorage, 
0x88cc31de, 0x27ab, 0x11d0, 0x9d, 0xf9, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the IITStorageEx interface:

DEFINE_GUID(IID_ITStorageEx, 
0xe74097b0, 0x292d, 0x11d1, 0xb6, 0x7e, 0x0, 0x0, 0xf8, 0x1, 0x49, 0xf6);

// Class ID for the FSStorage wrapper for the Win32 file system:

// {D54EEE56-AAAB-11d0-9E1D-00A0C922E6EC}
DEFINE_GUID(CLSID_IFSStorage, 
0xd54eee56, 0xaaab, 0x11d0, 0x9e, 0x1d, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the IFSStorage interface:

// {8BB2438A-A70C-11d0-9E1C-00A0C922E6EC}
DEFINE_GUID(IID_IFSStorage, 
0x8bb2438a, 0xa70c, 0x11d0, 0x9e, 0x1c, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the extended IStream interface

DEFINE_GUID(IID_IStreamITEx, 
0xeb19b681, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the extended IStorage interface

DEFINE_GUID(IID_IStorageITEx, 
0xeb19b680, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface IDs for the Data Space Manager used within an ITStorage object:

DEFINE_GUID(IID_IDataSpaceManager, 
0x7c01fd0f, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_IDataSpace, 
0x7c01fd0e, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_ITransformServices, 
0xa55895fc, 0x89e1, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_IKeyInstance, 
0x96af35ce, 0x88ec, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface IDs for the plug-in data transforms:

DEFINE_GUID(IID_ITransformFactory, 
0x7c01fd0c, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_ITransformInstance, 
0xeb19b67e, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the File Finder interface (used with URLs):

DEFINE_GUID(IID_IITFileFinder, 
0x77231260, 0x19c0, 0x11d1, 0xb6, 0x6e, 0x0, 0x0, 0xf8, 0x1, 0x49, 0xf6);

/*

The IITStorage interface parallels the API's defined for creating and
opening Docfiles. So if you have code that currently uses Docfiles for 
your storage mechanism, you can easily convert over to using ITS files 
instead. 

ITS files use a different on-disk structure to optimize them for very 
fast stream access and very low overhead. ITS files can manage thousands 
or millions of streams with very good access performance and very small 
directory space requirements. This makes ITS files ideal for CD-Roms and
for data collections that you'll download across the Internet. 

To make the conversion to ITS files you'll need to call CoCreateInstance 
with the class-id CLSID_ITStorage and the interface-id IID_ITStorage. You'll 
get back an interface pointer, say pItStg. Then you'll need to adjust the
places where your code creates or opens Docfiles. Instead of StgCreateDocfile
you'll call pItStg->StgCreateDocfile, and instead of StgOpenStorage, you'll
call pItStg->StgOpenStorage. In both cases you'll get back an IStorage 
interface pointer, say pIStg, which you can use just as you did before.

That's it. In general the rest of your code shouldn't have to change. There 
are some functional difference between ITS files and Docfiles -- ITS files
don't support STGM_TRANSACTED, for example. So if you have to have transacted 
file operations, you can't use ITS files -- at least for now. However in
almost all other respects ITS files interfaces can directly replace Docfile
interfaces.

Converting your data is also easy. Just open one of  your Docfiles using
StgOpenStorage, create a new ITS file via pItStg->StgCreateDocfile, and then
use the CopyTo interface to copy your data objects and their storage heirarchy
over to the ITS file:
    
    pStgDocfile->CopyTo(0, NULL, NULL, pStgITS);

In some cases you may want to exercise some control over the internal parameters
kept in an ITS file. You do this by calling SetControlData to give the IITStorage
interface a block of ITS control data. Then each subsequent call to StgCreateDocfile
will use that control data. The ITS control data determines, among other things,
the tradeoff between efficient random access to the stream data and minimizing the
size of an ITS file.  

The actual structure and interpretation of ITS control data is documented below.
(See the ITSFS_Control_Data data type). You can get default control data via the
DefaultControlData fuction. Note that DefaultControlData allocates the control
structure using IMalloc::Alloc as provided by CoGetMalloc and expects that your code will
deallocate the structure using the IMalloc::Free.

 */

// IID_IStreamITEx interface declaration:

DECLARE_INTERFACE_(IStreamITEx, IStream)
{
    // IStreamITEx methods
    
    STDMETHOD(SetDataSpaceName)(const WCHAR   * pwcsDataSpaceName) PURE;
    STDMETHOD(GetDataSpaceName)(       WCHAR **ppwcsDataSpaceName) PURE;

    STDMETHOD(Flush)() = 0;
};

// IID_IStorageITEx interface declaration:

DECLARE_INTERFACE_(IStorageITEx, IStorage)
{
    // IStorageITEx methods:

    STDMETHOD(GetCheckSum)(ULARGE_INTEGER *puli) PURE;
    STDMETHOD(CreateStreamITEx)(const WCHAR * pwcsName, const WCHAR *pwcsDataSpaceName, 
                            DWORD grfMode, DWORD reserved1, DWORD reserved2, 
                            IStreamITEx ** ppstm
                           ) PURE;
    STDMETHOD(OpenStreamITEx)(const WCHAR * pwcsName, void * reserved1, DWORD grfMode, 
                          DWORD reserved2, IStreamITEx ** ppstm) PURE;
};

// IStorageITEx::CreateStream lets you specify the data space in which a stream
// is to be created. Currently two dataspaces are supported:
//
//    L"Uncompressed" -- This dataspace applies no compression.
//    L"MSCompressed" -- This dataspace applies a default compression transform.


#pragma warning( disable : 4200)

// ITS_Control_Data is the generic structure of control data passed to the 
// IITStorage::SetControlData method or returned by the IITStorage::DefaultControlData
// method.

typedef struct _ITS_Control_Data
{
    UINT cdwControlData;     // Number of DWords to follow.
    UINT adwControlData[0];  // Actually this will be adwControlData[cdwControlData]

} ITS_Control_Data, *PITS_Control_Data;  


// ITSFS_Control_Data is the actual prefix structure of control data for IITStorage. 

typedef struct _ITSFS_Control_Data
{
    UINT cdwFollowing;     // Must be 6 or 13

    DWORD cdwITFS_Control; // Must be 5
    DWORD dwMagic;         // Must be MAGIC_ITSFS_CONTROL (see below)
    DWORD dwVersion;       // Must be 1
    DWORD cbDirectoryBlock;// Size in bytes of directory blocks (Default is 8192)
    DWORD cMinCacheEntries;// Least upper bound on the number of directory blocks
	                       // which we'll cache in memory. (Default is 20)
    DWORD fFlags;          // Control bit flags (see below). 
	                       // Default value is fDefaultIsCompression.

} ITSFS_Control_Data, *PITSFS_Control_Data;

// Signature value for ITSFS_Control_Data

const DWORD MAGIC_ITSFS_CONTROL    = 'I' | ('T' << 8) | ('S' << 16) | ('C' << 24);

// Bit flag definitions for ITSFS_Control_Data::fFlags

const DWORD fDefaultIsCompression  = 0x00000001;
const DWORD fDefaultIsUncompressed = 0x00000000;

// Note all other fFlags bits positions are reserved for future releases and should be 
// set to zero.

// When ITSFS_Control_Data::cdwFollowing is > 6, we assume that LZX_Control_Data follows
// immediately after. (See the XformControlData type below) LZX_Control_Data defines
// parameters which control the default compressed data space. 
//
// If ITSFS_Control_Data::cdwFollowing is 6, we use default values for the LZX
// control data.

typedef struct _LZX_Control_Data
{
    UINT  cdwControlData; // Must be 6

    DWORD dwLZXMagic;     // Must be LZX_MAGIC (see below)
    DWORD dwVersion;      // Must be 2
    DWORD dwMulResetBlock;// Number of blocks between compression resets.  (Default: 4)
    DWORD dwMulWindowSize;// Maximum number of blocks kept in data history (Default: 4)
    DWORD dwMulSecondPartition; // Granularity in blocks of sliding history(Default: 2)
    DWORD dwOptions;  // Option flags (Default: fOptimizeCodeStreams)

} LZX_Control_Data, *PLZX_Control_Data;

// Note: The block size for LZX compression is 32768 bytes.

const DWORD LZX_MAGIC           = 'L' | ('Z' << 8 ) | ('X' << 16) | ('C' << 24);

// Values for LZX_Control_Data::dwOptions

const DWORD fOptimizeCodeStreams = 0x00000001;

// Note that all other flag bit positions are reserved for future releases and should be
// set to zero.


// The second parameter for the IITStorage::Compact method below is an enueration
// which defines the level of compaction to do.

typedef enum ECompactionLev {COMPACT_DATA=0, COMPACT_DATA_AND_PATH} ;

DECLARE_INTERFACE_(IITStorage, IUnknown)
{
    // IITStorage methods

    STDMETHOD(StgCreateDocfile)(const WCHAR * pwcsName, DWORD grfMode, 
                                DWORD reserved, IStorage ** ppstgOpen
                               ) PURE;

    STDMETHOD(StgCreateDocfileOnILockBytes)(ILockBytes * plkbyt, DWORD grfMode,
                                            DWORD reserved, IStorage ** ppstgOpen
                                           ) PURE;

    STDMETHOD(StgIsStorageFile)(const WCHAR * pwcsName) PURE;

    STDMETHOD(StgIsStorageILockBytes)(ILockBytes * plkbyt) PURE;

    STDMETHOD(StgOpenStorage)(const WCHAR * pwcsName, IStorage * pstgPriority, 
                              DWORD grfMode, SNB snbExclude, DWORD reserved, 
                              IStorage ** ppstgOpen
                             ) PURE;

    STDMETHOD(StgOpenStorageOnILockBytes)
                  (ILockBytes * plkbyt, IStorage * pStgPriority, DWORD grfMode, 
                   SNB snbExclude, DWORD reserved, IStorage ** ppstgOpen
                  ) PURE;

    STDMETHOD(StgSetTimes)(WCHAR const * lpszName,  FILETIME const * pctime, 
                           FILETIME const * patime, FILETIME const * pmtime
                          ) PURE;

    STDMETHOD(SetControlData)(PITS_Control_Data pControlData) PURE;

    STDMETHOD(DefaultControlData)(PITS_Control_Data *ppControlData) PURE;
		
    STDMETHOD(Compact)(const WCHAR * pwcsName, ECompactionLev iLev) PURE;
};

DECLARE_INTERFACE_(IITStorageEx, IITStorage)
{
    STDMETHOD(StgCreateDocfileForLocale)
        (const WCHAR * pwcsName, DWORD grfMode, DWORD reserved, LCID lcid, 
         IStorage ** ppstgOpen
        ) PURE;

    STDMETHOD(StgCreateDocfileForLocaleOnILockBytes)
        (ILockBytes * plkbyt, DWORD grfMode, DWORD reserved, LCID lcid, 
         IStorage ** ppstgOpen
        ) PURE;

    STDMETHOD(QueryFileStampAndLocale)(const WCHAR *pwcsName, DWORD *pFileStamp, 
                                                              DWORD *pFileLocale) PURE;
    
    STDMETHOD(QueryLockByteStampAndLocale)(ILockBytes * plkbyt, DWORD *pFileStamp, 
                                                                DWORD *pFileLocale) PURE;
};

typedef IITStorage *PIITStorage;

DECLARE_INTERFACE_(IFSStorage, IUnknown)
{
    // IUnknown methods

    STDMETHOD(QueryInterface)  (THIS_ REFIID, VOID **) PURE;
    STDMETHOD_(ULONG, AddRef)  (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // IFSStorage methods

    STDMETHOD(FSCreateStorage)(const WCHAR * pwcsName, DWORD grfMode, IStorage **ppstgOpen) PURE;

    STDMETHOD(FSOpenStorage)(const WCHAR * pwcsName, DWORD grfMode, IStorage **ppstgOpen) PURE;

    STDMETHOD(FSCreateStream)(const WCHAR *pwcsName, DWORD grfMode, IStream **ppStrm) PURE;
    STDMETHOD(FSCreateTemporaryStream)(IStream **ppStrm) PURE;
    STDMETHOD(FSOpenStream  )(const WCHAR *pwcsName, DWORD grfMode, IStream **ppStrm) PURE;
    STDMETHOD(FSCreateLockBytes)(const WCHAR *pwcsName, DWORD grfMode, ILockBytes **ppLkb) PURE;
    STDMETHOD(FSCreateTemporaryLockBytes)(ILockBytes **ppLkb) PURE;
    STDMETHOD(FSOpenLockBytes  )(const WCHAR *pwcsName, DWORD grfMode, ILockBytes **ppLkb) PURE;

    STDMETHOD(FSStgSetTimes)(WCHAR const * lpszName,  FILETIME const * pctime, 
                             FILETIME const * patime, FILETIME const * pmtime
                            ) PURE;
};

typedef IFSStorage *PIFSStorage;

/*
**   Data Spaces -- What they are.

Within an ITS file we store information in one or more data spaces. A data space
is a container which holds the bits which represent a collection of streams. Each
data space has a name and an associated collection of transforms.

Those transforms take the raw data which you write to an ITS stream and map it into
a representation stream. When you read from an ITS stream they do the reverse mapping
to reconstruct your original data from the representation. 

When you first create an ITS file, it contains one data space named "Default_Space"
which applies the LZX data compression transform. By default all of the streams you
create will have their data representations stored in the default data space.

If LZX compression meets your needs, and you're not concerned about data enciphering,
you can skip over the following discussion. If, on the other hand, you want to 
create additional data spaces or transforms, read on.

To create a data space, you must first get a pointer to the IDataSpaceManager interface.
Just do a QueryInterface for IID_DataSpaceManager from any storage created by the 
IITStorage interface. Then you can call the CreateDataSpace function to define a new
data space. 

When you're defining a collection of data spaces, be sure that their names are distinct.
Defining two data spaces with the same name is an error. Data space names follow the
rules for stream names. That is, they must be less than 260 characters long, and may
not contain the characters '/'. '\', '|', ':', or any character less than 0x0020.

Data spaces are kept in a separate name space. So you don't have to worry about
colliding with a stream name or a storage name. As noted above, we have defined one
special data space ("Default_Space") where all data resides if you take no action.

You can redefine that default space simply by creating a new data space with the
name "Default_Space". This is the one case where a name collision is allowed. If 
you do redefine the default data space, any data in the old space will automatically
be transformed appropriately and moved into the new default data space.  

**   Importing Items

If you have defined additional data spaces, the next step is to define which streams
and storages you want to move into the new data spaces. You do that by means of the 
IDataSpace::Import function. For example suppose you've defined the dataspace 
*pMyDataSpace and you want to import the stream "Alpha" contained in the storage 
*pThatStorage:

    pMyDataSpace->Import(pThatStorage, "Alpha");

Similarly if you want to import the storage "HTML_Pages" from pThisStorage:

    pMyDataSpace->Import(pThisStorage, "HTML_Pages");

That will recursively import the "HTML_Pages" storage and all of the streams and 
storages contained within it. It also conditions those storages so that anything
you create within them will be automatically imported into pMyDataSpace. Note that
subsequent Import operations may alter that conditioning.

If you later decide that you want to move "Alpha" back into the default data
space:

    hr = pDataSpaceManager->OpenDataSpace(L"Default_Space", &pDefaultDataSpace);

    pDefaultDataSpace->Import(pThatStorage, "Alpha");

**  Data Space Transform Sets 

When you define a data space, you must specify a set of transforms to apply to 
the items you import into the space. A transform is an interface that converts
data to some other representation. For example the LZX transform converts your 
imported data into a more compact, compressed representation. Other transforms
might implement word or phrase based dictionary compression, or they might encipher 
your data, or they might just convert from one data format to another. You could, 
for example, construct a transform to store HTML data as a Rich Text stream.

When you define a data space with more than one transform, they are applied in 
order. For example let's suppose that your transform set consists of these three:

  1. A Dictionary compression transform

  2. The LXZ transform

  3. An data encryption transform

Whenever you write data into this space, it will first be compressed using the
dictionary compression methods, then LZX compression will be applied, and finally
your information will be encrypted. When you read data the process is reversed so
that the encryption transform supplies data to the LZX transform which in turn 
provides data for the dictionary compression transform.

You define the transform set via a vector of class ids (paclsidXform). Each class id
defines a location where an implementation of IID_Transform can be found. In addition
you'll supply corresponding control data for each transform (papxfcd). The number of 
transforms is defined by the cXforms parameter.

Note that it is legal to define a space with zero transforms. This is useful when
you've got items which are already compressed and which won't benefit from an
additional layer of compression overhead.

The control data for a transform defines how it will operate in a particular
data space. For example the control data for the LZX transform defines how
aggressively it will pursue compression, and it controls the tradeoff between
random access performance and the level of compression.

The actual structure and content of the control data is documented above.
(See the LZX_Control_Data data type.)

**  Transform Factories -- How they are organized; What they do

Transforms have two functional capabilities. They can return default
control data (DefaultControlData), and they can create
transform instances (CreateTransformInstance). When the ITSS code calls your 
CreateTransformInstance function, it will supply a storage medium (pXFSpan_Base)
where transformed data is to be stored along with the control data for the
instance and several other useful pieces of information. 

The CreateTransformInstance function has several parameters that you can use 
when you need to access global and/or instance data streams. They also support
the construction of encryption transforms. You can ignore those parameters if your
transform doesn't do encryption, uses only a single pass over the data, and doesn't
rely on any data beyond the data in the stream being transformed.

  -- The rclsidXForm and pwszDataSpace parameters, respectively, tell you the Class ID
  by which your code was located, and the name of the data space in which your instance
  will be working. These values are used with the ITransformServices interface.

  -- The pXformServices parameter points to an instance of the ITranformServices interface. 
  That interface gives you access to a couple of storages where you can keep global and
  instance data for your transform. It also gives you a way to contruct a temporary
  stream that is automatically deleted when you release it. That's very handy when 
  you get a seek operation into the middle of the transformed data followed by a write 
  operation.

  If you're implementing a multipass strategy, you can get access to those storages
  from code outside the transform by doing a QueryInterface from any ITS storage for 
  the interface IID_ITransformServices. You identify the storage in question by the
  transform's class id and possibly the name of the data space instance. 

  The per-transform-instance storage is also a convenient place to put the navigation
  data necessary to support fast seek operations.

  -- The pKeyManager parameter is an interface pointer used with encryption transforms.
  It supplies the read and write keys to use with your encryption transform. Those keys
  are set by the SetKeys interface of the ITransformServices interface. This allows you
  to separate your user interface code where people will enter passwords from the 
  transform implementations. This can be useful when you want the same keys to be used 
  for several different data spaces.  

**  Transform Instances -- How they are organized; What they do

A Transform Instance is an object which simulates a data medium which can be 
suballocated. Suballocated items are managed as data spans (ITransformedSpan).
You must supply a function to create a data span (CreateTransformedSpan), and
a function to open a data span (OpenTransformedSpan). Both of those functions 
return an ITransformedSpan interface when they succeed. In addition you must
supply the function SpaceSize to return the size of the entire untransformed
data image. That is, SpaceSize returns the highest limit offset (offset + size)
of any data span created within the instance. 

A span is identified by an ImageSpan structure which defines an offset and a size 
for the span. Both values are defined in untransformed space. For the Create function
this is an output parameter, while it is an input parameter for the Open function.
Note the interaction between the ImageSpan and the WriteAt member function of the
ITransformedSpan interface.

**  Transformed Data Spans -- How they are organized; What they do

A transformed Data Span (ITransformedSpan) has two member functions -- ReadAt and 
WriteAt. Those functions are very similar to the ReadAt and WriteAt functions of
the ILockBytes interface. The difference is that WriteAt includes an extra output
parameter (pImageSpan) for recording the current span parameters. The ReadAt function
doesn't include that parameter because read operations can never change the span's
size or move it to a different offset.

**  Implementation Strategies

This section describes a few scenarios that you may encounter as you construct a 
transform along with strategies for those situations. This is an open ended list 
which will expand as we gain more experience with transforms.

Many compression and encryption transforms are designed around sequential I/O. That is,
they expect to get the raw data from a sequence of write opeations with no intervening
seek operations. In many cases such transforms also write out the transformed data to 
the base stream in ascending order. Similarly they expect read requests to come to them
with no intervening seek operations. 

The key issue for those transforms is how do you implement random access and interleaved
read, write, and seek operations. 

Leaving aside write operations for the moment, let's consider a random sequence of reads
interleaved with seek operations. One solution might be to construct a table to map from
raw data offsets to transformed data offsets. You can store such a table in the instance
storage for the current data space. 

One complication is that many compression transforms use the raw data as a dictionary. 
That is, you can only start reading from the beginning of the transformed data. You can
deal with those transforms telling them to reset themselves periodically. That gives
you a collection of starting points spread fairly evenly throught the transformed 
data. When you do this you'll need to supply a control data parameter to control the
frequency of those reset points so that your clients can make an appropriate tradeoff
between compression efficiency and random access performance.

Now what about adding random write operations to the mix? The short answer here is that
you can't do this in the middle of transformed data. One strategy would be to reconstruct
the entire raw data into a temporary stream and do all your I/O to that stream until
release time. Then at release time you can transform the revised data sequentially.

A variation on that strategy is to keep track of which reset spans are modified and 
write the modified versions of those transformed spans to the end of the base stream.
This leaves a certain amount of dead space in your transformed data, but it allows
you to defer the sequential reconstruction work to a more convenient time. The down 
side  is that it requires you to manage yet more navigation data in the instance 
storage for the data space.

 */

interface IDataSpaceManager;
interface IDataSpace;
interface ITransformServices;
interface IKeyInstance;
interface ITransformFactory;
interface ITransformInstance;

typedef struct _XformControlData
{
    UINT  cdwControlData;    // Size of this structure in DWords
    UINT  adwControlData[0]; // Actually this will be UINT adwData[cdwData];

} XformControlData, *PXformControlData;

/*
// {7C01FD0F-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_IDataSpaceManager, 
0x7c01fd0f, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IDataSpaceManager : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE CreateDataSpace
        (const WCHAR *pwszDataSpace, UINT cXforms,
         const CLSID *paclsidXform, PXformControlData paxfcd,
         IDataSpace *pITDataSpace
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE OpenDataSpace
        (const WCHAR *pwszDataSpace, 
         IDataSpace *pITDataSpace
        ) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE DiscardDataSpace
        (const WCHAR *pwszDataSpace) = 0;

    virtual HRESULT STDMETHODCALLTYPE EnumDataSpaces
        (IEnumSTATSTG ** ppenum) = 0;
};


/*
// {7C01FD0E-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_IDataSpace, 
0x7c01fd0e, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IDataSpace : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE GetTransformInfo
        (PUINT pcXforms, PUINT pcdwXformControlData, 
         CLSID *paclsid, PXformControlData pxfcd
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Import
        (IStorage *pStg, const WCHAR * pwszElementName) = 0;

    virtual HRESULT STDMETHODCALLTYPE ImportSpace(IStorage **ppStg) = 0;
};

/*
// {7C01FD0C-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_ITransformFactory, 
0x7c01fd0c, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface ITransformFactory : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE DefaultControlData
        (XformControlData **ppXFCD) = 0;

    virtual HRESULT STDMETHODCALLTYPE CreateTransformInstance
        (ITransformInstance *pXFormMedium,        // Container data span for transformed data
		 ULARGE_INTEGER      cbUntransformedSize, // Untransformed size of data
         PXformControlData   pXFCD,               // Control data for this instance
         const CLSID        *rclsidXForm,         // Transform Class ID
         const WCHAR        *pwszDataSpaceName,   // Data space name for this instance
         ITransformServices *pXformServices,      // Utility routines
         IKeyInstance       *pKeyManager,         // Interface to get enciphering keys
         ITransformInstance **ppTransformInstance // Out: Instance transform interface
        ) = 0;
};

typedef struct _ImageSpan
{
	ULARGE_INTEGER	uliHandle;
	ULARGE_INTEGER  uliSize;

} ImageSpan;

/*
// {EB19B67E-9360-11d0-9E16-00A0C922E6EC}
DEFINE_GUID(IID_ITransformInstance, 
0xeb19b67e, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface ITransformInstance : public IUnknown
{
public:

	virtual HRESULT STDMETHODCALLTYPE ReadAt 
	                    (ULARGE_INTEGER ulOffset, void *pv, ULONG cb, ULONG *pcbRead,
						 ImageSpan *pSpan
                        ) = 0;

	virtual HRESULT STDMETHODCALLTYPE WriteAt
	                    (ULARGE_INTEGER ulOffset, const void *pv, ULONG cb, ULONG *pcbWritten, 
						 ImageSpan *pSpan
                        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Flush() = 0;

	virtual HRESULT STDMETHODCALLTYPE SpaceSize(ULARGE_INTEGER *puliSize) = 0;

	// Note: SpaceSize returns the high water mark for the space. That is, the largest
	//       limit value (uliOffset + uliSize) for any transformed lockbytes created within
	//       the base (*pXLKB).
};

/*
// {A55895FC-89E1-11d0-9E14-00A0C922E6EC}
DEFINE_GUID(IID_ITransformServices, 
0xa55895fc, 0x89e1, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface ITransformServices : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE PerTransformStorage
        (REFCLSID rclsidXForm, IStorage **ppStg) = 0;

    virtual HRESULT STDMETHODCALLTYPE PerTransformInstanceStorage
        (REFCLSID rclsidXForm, const WCHAR *pwszDataSpace, IStorage **ppStg) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetKeys
        (REFCLSID rclsidXForm, const WCHAR *pwszDataSpace, 
         PBYTE pbReadKey,  UINT cbReadKey, 
         PBYTE pbWriteKey, UINT cbWriteKey
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE CreateTemporaryStream(IStream **ppStrm) = 0;
};

/*
// {96AF35CE-88EC-11d0-9E14-00A0C922E6EC}
DEFINE_GUID(IID_IKeyInstance, 
0x96af35ce, 0x88ec, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IKeyInstance : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE GetKeys
        (PBYTE *pbReadKey,  PUINT pcbReadKey,
         PBYTE *pbWriteKey, PUINT pcbWriteKey
        ) = 0;
};

/* 

  Streams stored in an ITS file may be accessed through URLs with
  the form:

      its: <File Path> :: <Stream Path>

  where <File Path> may be either a Win32 file path or a URL, and
  <Stream Path> is the path to a stream stored in the ITS file. 
  Each <Stream Path> must begin with '/'. 

  This means that you can copy a Win32 directory tree of HTML files
  and associated files into an ITS file and get to them through ITS
  URLs. If all the URL references within those HTML files are 
  relative, they will be resolved within the containing ITS file.

  The <File Path> portion of the URL may either be a complete path
  to the ITS file, or it may be just the file name. In the later case
  you may need to install auxillary information in the registry to
  help the ITSS code locate the file. Here are the rules:

  1. If you don't supply a complete path, ITSS looks in the current
     working directory for the file. 

  2. If the file isn't found in step 1. ITSS looks for a registry
     value in the ITSS_MAP section of HKEY_LOCAL_MACHINE. The value
     name must match the file name, and the value will be a string
     giving the complete file path to be used.

  3. If the file isn't found in steps 1 and 2, ITSS isolates the file's 
     extension (beginning with the last '.' character) and looks
     for a corresponding class id value in the ITSS_FINDER section 
     of HKEY_LOCAL_MACHINE. The name for the value will match the
     extension, and the value will be the class id for an object
     which implements the IID_IITFileFinder interface.

  4. If the file isn't found in steps 1 through 3, the URL reference
     fails.

 */

#define ITSS_MAP     "Software\\Microsoft\\Windows\\ITStorage\\Maps"
#define ITSS_FINDER  "Software\\Microsoft\\Windows\\ITStorage\\Finders"

interface IITFileFinder : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE FindThisFile(const WCHAR *pFileName, WCHAR **ppFullPath,
                                                   BOOL *pfRecordPathInRegistry
                                                  ) = 0;

// The FindThisFile method maps a file name into a complete file path. The file name
// is defined by *pFileName, and a pointer to the complete path is returned in 
// *ppFullPath. The returned path will be a string allocated in the IMalloc heap.
// The *pfRecordPathInRegistry result should be TRUE when we should record this mapping
// in the ITSS_MAP registry section and FALSE otherwise.

    
};


#endif // __MSITSTG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\fts_lib\titleinfo.h ===
#ifndef _titleinfo_h_
#define _titleinfo_h_

#include "windows.h"
#include "stdio.h"
#include "fs.h"
#include "util.h"
#include "subfile.h"

class CTitleInfo
{
public:
   CTitleInfo();
   ~CTitleInfo();

   HRESULT GetTopicName(DWORD dwTopic, WCHAR* pwszTitle, int cch, UINT cp);
   HRESULT GetTopicURL(DWORD dwTopic, CHAR* pwszURL, int cch);
   HRESULT GetLocationName(WCHAR *pwszLocationName, int cch, UINT cp);
   BOOL OpenTitle(WCHAR *pwcTitlePath);
private:
   CTitleInformation *m_pTitleInfo;
   char m_szTitlePath[_MAX_PATH];
   const CHAR* GetString(DWORD dwOffset);
   HRESULT GetString( DWORD dwOffset, CHAR* psz, int cb);
   HRESULT GetString( DWORD dwOffset, WCHAR* pwsz, int cch, UINT cp );
   HRESULT GetTopicData(DWORD dwTopic, TOC_TOPIC * pTopicData);
   BOOL m_bOpen;
   CPagedSubfile* m_pTopics;
   CPagedSubfile* m_pStrTbl;
   CPagedSubfile* m_pUrlTbl;
   CPagedSubfile* m_pUrlStrings;

public:
   CFileSystem* m_pCFileSystem;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\fts_lib\util.h ===
#ifndef _util_h_
#define _util_h_

#include <windows.h>

#include <fs.h>

typedef unsigned long HASH;

PCSTR FindFilePortion(PCSTR pszFile);
void reportOleError(HRESULT hr);
PSTR StrChr(PCSTR pszString, char ch);
PSTR StrRChr(PCSTR pszString, char ch);
HASH WINAPI HashFromSz(PCSTR pszKey);


// WARNING: Never, ever change the order of these enums or you break
// backwards compatibility

typedef enum {
    TAG_DEFAULT_TOC,        // needed if no window definitions
    TAG_DEFAULT_INDEX,      // needed if no window definitions
    TAG_DEFAULT_HTML,       // needed if no window definitions
    TAG_DEFAULT_CAPTION,    // needed if no window definitions
    TAG_SYSTEM_FLAGS,
    TAG_DEFAULT_WINDOW,
    TAG_SHORT_NAME,    // short name of title (ex. root filename)
    TAG_HASH_BINARY_INDEX,
    TAG_INFO_TYPES,
    TAG_COMPILER_VERSION,   // specifies the version of the compiler used
    TAG_TIME,               // the time the file was compiled
    TAG_HASH_BINARY_TOC,    // binary TOC
    TAG_INFOTYPE_COUNT,     // Total number if infotypes found in .chm
    TAG_IDXHEADER,          // Much of this is duplicate, used to live in it's own subile.
    TAG_EXT_TABS,           // extensible tabs
    TAG_INFO_TYPE_CHECKSUM,
    TAG_DEFAULT_FONT,       // font to use in all CHM-supplied UI
    TAG_NEVER_PROMPT_ON_MERGE, // never prompt during index merge
} SYSTEM_TAG_TYPE;

typedef struct {
    WORD tag;
    WORD cbTag;
} SYSTEM_TAG;

class CTitleInformation
{
public:
    CTitleInformation( CFileSystem* pFileSystem );
    ~CTitleInformation();
    HRESULT Initialize();

    inline PCSTR          GetShortName() {return m_pszShortName; }
    inline PCSTR          GetDefaultCaption() {return m_pszDefCaption; }
private:
    CFileSystem*    m_pFileSystem;   // title file system handle
    PCSTR           m_pszShortName;  // short title name
    PCSTR           m_pszDefCaption;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\manager\resultitem.cpp ===
// PCHSEResultItem.cpp : Implementation of SearchEngine::ResultItem
#include "stdafx.h"


SearchEngine::ResultItem_Data::ResultItem_Data()
{
                            // CComBSTR m_bstrTitle;
                            // CComBSTR m_bstrURI;
    m_lContentType     = 0; // long     m_lContentType;
                            // CComBSTR m_bstrLocation;
    m_lHits            = 0; // long     m_lHits;
    m_dRank            = 0; // double   m_dRank;
                            // CComBSTR m_bstrImageURL;
                            // CComBSTR m_bstrVendor;
                            // CComBSTR m_bstrProduct;
                            // CComBSTR m_bstrComponent;
                            // CComBSTR m_bstrDescription;
    m_dateLastModified = 0; // DATE     m_dateLastModified;
}

/////////////////////////////////////////////////////////////////////////////
// SearchEngine::ResultItem

SearchEngine::ResultItem::ResultItem()
{
	// ResultItem_Data m_data;
}

STDMETHODIMP SearchEngine::ResultItem::get_Title( BSTR *pVal )
{
	__HCP_BEGIN_PROPERTY_GET("SearchEngine::ResultItem::get_Title",hr,pVal);

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_data.m_bstrTitle, pVal ));

	__HCP_END_PROPERTY(hr);
}

STDMETHODIMP SearchEngine::ResultItem::get_URI( BSTR *pVal )
{
	__HCP_BEGIN_PROPERTY_GET("SearchEngine::ResultItem::get_URI",hr,pVal);

	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_data.m_bstrURI, pVal ));

	__HCP_END_PROPERTY(hr);
}

STDMETHODIMP SearchEngine::ResultItem::get_ContentType( long *pVal )
{
	__HCP_BEGIN_PROPERTY_GET2("SearchEngine::ResultItem::get_ContentType",hr,pVal,m_data.m_lContentType);

	__HCP_END_PROPERTY(hr);
}

STDMETHODIMP SearchEngine::ResultItem::get_Location( BSTR *pVal )
{
	__HCP_BEGIN_PROPERTY_GET("SearchEngine::ResultItem::get_Location",hr,pVal);

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_data.m_bstrLocation, pVal ));

	__HCP_END_PROPERTY(hr);
}

STDMETHODIMP SearchEngine::ResultItem::get_Hits( long *pVal )
{
	__HCP_BEGIN_PROPERTY_GET2("SearchEngine::ResultItem::get_Hits",hr,pVal,m_data.m_lHits);

	__HCP_END_PROPERTY(hr);
}

STDMETHODIMP SearchEngine::ResultItem::get_Rank( double *pVal )
{
	__HCP_BEGIN_PROPERTY_GET2("SearchEngine::ResultItem::get_Rank",hr,pVal,m_data.m_dRank);

	__HCP_END_PROPERTY(hr);
}

STDMETHODIMP SearchEngine::ResultItem::get_Description( BSTR *pVal )
{
	__HCP_BEGIN_PROPERTY_GET("SearchEngine::ResultItem::get_Description",hr,pVal);

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_data.m_bstrDescription, pVal ));

	__HCP_END_PROPERTY(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\manager\paramitem.cpp ===
// PCHSEParamItem.cpp : Implementation of SearchEngine::ParamItem
#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

SearchEngine::ParamItem_Definition2::ParamItem_Definition2()
{
    m_pteParamType    = PARAM_BSTR;    // ParamTypeEnum m_pteParamType;
    m_bRequired       = VARIANT_FALSE; // VARIANT_BOOL  m_bRequired;
    m_bVisible        = VARIANT_TRUE;  // VARIANT_BOOL  m_bVisible;
                                       //
    m_szName          = NULL;          // LPCWSTR       m_szName;
                                       //
    m_iDisplayString  = 0;             // UINT          m_iDisplayString;
    m_szDisplayString = NULL;          // LPCWSTR       m_szDisplayString;
                                       //
    m_szData          = NULL;          // LPCWSTR       m_szData;
}

////////////////////////////////////////////////////////////////////////////////

SearchEngine::ParamItem_Data::ParamItem_Data()
{
    m_pteParamType = PARAM_BSTR;    // ParamTypeEnum m_pteParamType;
    m_bRequired    = VARIANT_FALSE; // VARIANT_BOOL  m_bRequired;
    m_bVisible     = VARIANT_TRUE;  // VARIANT_BOOL  m_bVisible;
                                    // CComBSTR      m_bstrDisplayString;
                                    // CComBSTR      m_bstrName;
                                    // CComVariant   m_varData;
}

/////////////////////////////////////////////////////////////////////////////
// SearchEngine::ParamItem

SearchEngine::ParamItem::ParamItem()
{
    // ParamItem_Data m_data;
}

STDMETHODIMP SearchEngine::ParamItem::get_Type( ParamTypeEnum *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("SearchEngine::ParamItem::get_Type",hr,pVal,m_data.m_pteParamType);

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP SearchEngine::ParamItem::get_Display( BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("SearchEngine::ParamItem::get_Display",hr,pVal);

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_data.m_bstrDisplayString, pVal ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP SearchEngine::ParamItem::get_Data( VARIANT *pVal )
{
    __HCP_BEGIN_PROPERTY_GET0("SearchEngine::ParamItem::get_Data",hr,pVal);

    __MPC_EXIT_IF_METHOD_FAILS(hr, ::VariantCopy( pVal, &m_data.m_varData ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP SearchEngine::ParamItem::get_Name( BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("SearchEngine::ParamItem::get_Name",hr,pVal);

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_data.m_bstrName, pVal ));

    __HCP_END_PROPERTY(hr);

}

STDMETHODIMP SearchEngine::ParamItem::get_Required( VARIANT_BOOL *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("SearchEngine::ParamItem::get_Required",hr,pVal,m_data.m_bRequired);

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP SearchEngine::ParamItem::get_Visible( VARIANT_BOOL *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("SearchEngine::ParamItem::get_Visible",hr,pVal,m_data.m_bVisible);

    __HCP_END_PROPERTY(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\manager\manager.cpp ===
/******************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:
    Manager.cpp

Abstract:
    Implementation of SearchEngine::Manager

Revision History:
    Ghim-Sim Chua   (gschua)  06/01/2000
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

static const WCHAR c_rgSEARCHENGINE_KEYWORD       [] = L"BUILTIN_KEYWORD";
static const WCHAR c_rgSEARCHENGINE_FULLTEXTSEARCH[] = L"BUILTIN_FULLTEXTSEARCH";

////////////////////////////////////////////////////////////////////////////////

void SearchEngine::Manager::CloneListOfWrappers( /*[out]*/ WrapperItemList& lst )
{
    WrapperItemIter it;

    for(it = m_lstWrapperItem.begin(); it != m_lstWrapperItem.end(); it++)
    {
		IPCHSEWrapperItem* obj = *it;

        lst.push_back( obj ); obj->AddRef();
    }
}

SearchEngine::Manager::Manager()
{
                              // Taxonomy::HelpSet              m_ths;
                              //
                              // WrapperItemList                m_lstWrapperItem;
    m_fInitialized   = false; // bool                           m_fInitialized;
                              // MPC::FileLog                   m_fl;
                              // MPC::Impersonation             m_imp;
                              //
                              // CComBSTR                       m_bstrQueryString;
    m_lNumResult     = 50;    // long                           m_lNumResult;
    m_lEnabledSE     = 0;     // long                           m_lEnabledSE;
    m_lCountComplete = 0;     // long                           m_lCountComplete;
    m_hrLastError    = S_OK;  // HRESULT                        m_hrLastError;
                              //
                              // CComPtr<IPCHSEManagerInternal> m_Notifier;
                              // CComPtr<IDispatch>             m_Progress;
                              // CComPtr<IDispatch>             m_Complete;
                              // CComPtr<IDispatch>             m_WrapperComplete;
}

void SearchEngine::Manager::Passivate()
{
    Thread_Wait();

    MPC::ReleaseAll( m_lstWrapperItem );

    m_Notifier.Release();

    m_fInitialized = false;
}

HRESULT SearchEngine::Manager::IsNetworkAlive( /*[out]*/ VARIANT_BOOL *pvbVar )
{
    __HCP_FUNC_ENTRY( "SearchEngine::Manager::IsNetworkAlive" );

    HRESULT                    hr;
    CPCHUserProcess::UserEntry ue;
    CComPtr<IPCHSlaveProcess>  sp;


    __MPC_EXIT_IF_METHOD_FAILS(hr, ue.InitializeForImpersonation( (HANDLE)m_imp ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHUserProcess::s_GLOBAL->Connect( ue, &sp ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, sp->IsNetworkAlive( pvbVar ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT SearchEngine::Manager::IsDestinationReachable( /*[in ]*/ BSTR bstrDestination, /*[out]*/ VARIANT_BOOL *pvbVar )
{
    __HCP_FUNC_ENTRY( "SearchEngine::Manager::IsDestinationReachable" );

    HRESULT                    hr;
    CPCHUserProcess::UserEntry ue;
    CComPtr<IPCHSlaveProcess>  sp;


    __MPC_EXIT_IF_METHOD_FAILS(hr, ue.InitializeForImpersonation( (HANDLE)m_imp ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHUserProcess::s_GLOBAL->Connect( ue, &sp ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, sp->IsDestinationReachable( bstrDestination, pvbVar ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT SearchEngine::Manager::InitializeFromDatabase( /*[in]*/ const Taxonomy::HelpSet& ths )
{
    __HCP_FUNC_ENTRY( "SearchEngine::Manager::InitializeFromDatabase" );

    HRESULT hr;

	m_ths = ths;

    hr = S_OK;


    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT SearchEngine::Manager::CreateAndAddWrapperToList( /*[in]*/ MPC::SmartLock<_ThreadModel>& lock      ,
                                                          /*[in]*/ BSTR                          bstrCLSID ,
                                                          /*[in]*/ BSTR                          bstrID    ,
                                                          /*[in]*/ BSTR                          bstrData  )
{
    __HCP_FUNC_ENTRY( "SearchEngine::Manager::CreateAndAddWrapperToList" );

    HRESULT                        hr;
    GUID                           guidCLSID;
    CComPtr<IPCHSEWrapperInternal> pWrapperInternal;
    CComPtr<IPCHSEWrapperItem>     pWrapperItem;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrCLSID);
    __MPC_PARAMCHECK_END();


    //
    // Translate it into actual CLSID and IID
    //
    if(!MPC::StrICmp( bstrCLSID, c_rgSEARCHENGINE_KEYWORD ))
    {
        guidCLSID = CLSID_KeywordSearchWrapper;
    }
    else if(!MPC::StrICmp( bstrCLSID, c_rgSEARCHENGINE_FULLTEXTSEARCH ))
    {
        guidCLSID = CLSID_FullTextSearchWrapper;
    }
    else
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, ::CLSIDFromString( bstrCLSID, &guidCLSID ));
    }


    if(IsEqualGUID( CLSID_KeywordSearchWrapper, guidCLSID ))
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, WrapperItem__Create_Keyword( pWrapperInternal ));
    }
    else if(IsEqualGUID( CLSID_FullTextSearchWrapper, guidCLSID ))
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, WrapperItem__Create_FullTextSearch( pWrapperInternal ));
    }
    else
    {
        CPCHUserProcess::UserEntry ue;
        CComPtr<IPCHSlaveProcess>  sp;
        CComPtr<IUnknown>          unk;

        //
        // Get the help host to create the object for us
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, ue.InitializeForImpersonation( (HANDLE)m_imp ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHUserProcess::s_GLOBAL->Connect( ue, &sp  ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, sp->CreateInstance( guidCLSID, NULL, &unk ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, unk.QueryInterface( &pWrapperInternal ));
    }

	__MPC_EXIT_IF_METHOD_FAILS(hr, pWrapperInternal.QueryInterface( &pWrapperItem ));

    //
    // Initialize the engine via the internal interface.
    //
    // Before calling into the wrapper, let's release the lock, to avoid deadlocks if the wrapper calls back ...
    //
    {
        CComBSTR ts_SKU      = m_ths.GetSKU     ();
        long     ts_Language = m_ths.GetLanguage();

        lock = NULL;
        hr   = pWrapperInternal->Initialize( bstrID, ts_SKU, ts_Language, bstrData );
        lock = this;

        __MPC_EXIT_IF_METHOD_FAILS(hr, hr);
    }

    //
    // Add it to the wrapper list
    //
    m_lstWrapperItem.insert( m_lstWrapperItem.end(), pWrapperItem.Detach() );

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT SearchEngine::Manager::Initialize( /*[in]*/ MPC::SmartLock<_ThreadModel>& lock )
{
    __HCP_FUNC_ENTRY( "SearchEngine::Manager::Initialize" );

    HRESULT                                    hr;
    CComObject<SearchEngine::ManagerInternal>* pNotifier = NULL;

    if(!m_fInitialized)
    {
        CComPtr<IPCHSEWrapperInternal> pObj;


        __MPC_EXIT_IF_METHOD_FAILS(hr, m_imp.Initialize( MAXIMUM_ALLOWED ));


        // Attempt to open the log for writing
        {
            MPC::wstring szFile( HC_SEMGR_LOGNAME ); MPC::SubstituteEnvVariables( szFile );

            __MPC_EXIT_IF_METHOD_FAILS(hr, m_fl.SetLocation( szFile.c_str() ));
        }

        ////////////////////////////////////////

        //
        // Create the notifier object (required to avoid loop in the reference counting.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, CreateChild( this, &pNotifier )); m_Notifier = pNotifier;


        //
        // Create the BUILT-IN wrappers.
        //
        {
            (void)CreateAndAddWrapperToList( lock, CComBSTR( c_rgSEARCHENGINE_KEYWORD        ), NULL, NULL );
            (void)CreateAndAddWrapperToList( lock, CComBSTR( c_rgSEARCHENGINE_FULLTEXTSEARCH ), NULL, NULL );
        }

        //
        // Load the configuration
        //
        {
            Config              seConfig;
            Config::WrapperIter itBegin;
            Config::WrapperIter itEnd;

            __MPC_EXIT_IF_METHOD_FAILS(hr, seConfig.GetWrappers( itBegin, itEnd ));

            //
            // Loop thru all and initialize each search engine.
            //
            for(; itBegin != itEnd; itBegin++)
            {
				if(itBegin->m_ths == m_ths)
				{
					//
					// Initialize the wrapper.
					// Check to see if one of the search wrappers failed to initialize.
					// If failed ignore this wrapper and proceed.
					//
					if(FAILED(hr = CreateAndAddWrapperToList( lock, itBegin->m_bstrCLSID, itBegin->m_bstrID, itBegin->m_bstrData )))
					{
						// Log the error
						m_fl.LogRecord( L"Could not create wrapper. ID: %s, CLSID: %s, Error: 0x%x", SAFEBSTR(itBegin->m_bstrID), SAFEBSTR(itBegin->m_bstrCLSID), hr );
					}
				}
            }
        }

        m_fInitialized = true;
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    // If something failed, delete everything
    if(FAILED(hr))
    {
        MPC::ReleaseAll( m_lstWrapperItem );
    }

    MPC::Release( pNotifier );

    __MPC_FUNC_EXIT(hr);
}

HRESULT SearchEngine::Manager::LogRecord( /*[in]*/ BSTR bstrRecord )
{
    __HCP_FUNC_ENTRY( "SearchEngine::Manager::LogRecord" );

    HRESULT hr = S_OK;

    m_fl.LogRecord( L"%s", SAFEBSTR(bstrRecord) );

    __MPC_FUNC_EXIT(hr);
}

HRESULT SearchEngine::Manager::NotifyWrapperComplete( /*[in]*/ long lSucceeded, /*[in]*/ IPCHSEWrapperItem* pIPCHSEWICompleted )
{
    __HCP_FUNC_ENTRY( "SearchEngine::Manager::NotifyWrapperComplete" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

    //
    // Register last error number
    //
    if(FAILED(lSucceeded))
    {
        m_hrLastError = lSucceeded;
    }

    //
    // Add completed search engine
    //
    m_lCountComplete++;

    //
    // Notify that one wrapper has completed
    //
    lock = NULL;
    __MPC_EXIT_IF_METHOD_FAILS(hr, Fire_OnWrapperComplete( pIPCHSEWICompleted ));
    lock = this;

    //
    // Check if all search engines have completed
    //
    if(m_lCountComplete == m_lEnabledSE)
    {
        HRESULT hr2 = m_hrLastError;


        //
        // Notify the client that all search engines have completed
        //
        lock = NULL;
        __MPC_EXIT_IF_METHOD_FAILS(hr, Fire_OnComplete( hr2 ));
        lock = this;

        //
        // reset everything
        //
        m_lCountComplete = 0;
        m_lEnabledSE     = 0;
        m_hrLastError    = S_OK;
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    if(FAILED(hr))
    {
        CComBSTR bstrName;
        CComBSTR bstrID;

        lock = NULL;

        pIPCHSEWICompleted->get_Name( &bstrName );
        pIPCHSEWICompleted->get_ID  ( &bstrID   );

        m_fl.LogRecord( L"WrapperComplete error. Wrapper name: %s. ID: %s, Error: 0x%x", SAFEBSTR(bstrName), SAFEBSTR(bstrID), hr);
    }

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT SearchEngine::Manager::Fire_OnWrapperComplete( /*[in]*/ IPCHSEWrapperItem* pIPCHSEWICompleted )
{
    CComVariant pvars[1];

    pvars[0] = pIPCHSEWICompleted;

    return FireAsync_Generic( DISPID_SE_EVENTS__ONWRAPPERCOMPLETE, pvars, ARRAYSIZE( pvars ), m_WrapperComplete );
}

HRESULT SearchEngine::Manager::Fire_OnComplete( /*[in]*/ long lSucceeded )
{
    CComVariant pvars[1];

    pvars[0] = lSucceeded;

    return FireAsync_Generic( DISPID_SE_EVENTS__ONCOMPLETE, pvars, ARRAYSIZE( pvars ), m_Complete );
}

HRESULT SearchEngine::Manager::Fire_OnProgress( /*[in]*/ long lDone, /*[in]*/ long lTotal, /*[in]*/ BSTR bstrSEWrapperName )
{
    CComVariant pvars[3];

    pvars[2] = lDone;
    pvars[1] = lTotal;
    pvars[0] = bstrSEWrapperName;

    return FireAsync_Generic( DISPID_SE_EVENTS__ONPROGRESS, pvars, ARRAYSIZE( pvars ), m_Progress );
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP SearchEngine::Manager::get_QueryString( BSTR *pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::GetBSTR( m_bstrQueryString, pVal );
}

STDMETHODIMP SearchEngine::Manager::put_QueryString( BSTR newVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::PutBSTR( m_bstrQueryString, newVal, false );
}

STDMETHODIMP SearchEngine::Manager::get_NumResult(long *pVal)
{
    __HCP_BEGIN_PROPERTY_GET2("SearchEngine::Manager::get_NumResult",hr,pVal,m_lNumResult);

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP SearchEngine::Manager::put_NumResult(long newVal)
{
    __HCP_BEGIN_PROPERTY_PUT("SearchEngine::Manager::put_NumResult",hr);

    m_lNumResult = newVal;

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP SearchEngine::Manager::put_onComplete(IDispatch* function)
{
    MPC::SmartLock<_ThreadModel> lock( this );

    m_Complete = function;

    return S_OK;
}

STDMETHODIMP SearchEngine::Manager::put_onWrapperComplete(IDispatch* function)
{
    MPC::SmartLock<_ThreadModel> lock( this );

    m_WrapperComplete = function;

    return S_OK;
}

STDMETHODIMP SearchEngine::Manager::put_onProgress(IDispatch* function)
{
    MPC::SmartLock<_ThreadModel> lock( this );

    m_Progress = function;

    return S_OK;
}

STDMETHODIMP SearchEngine::Manager::get_SKU( BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("SearchEngine::Manager::get_SKU",hr,pVal);

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_ths.GetSKU(), pVal ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP SearchEngine::Manager::get_LCID( long *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("SearchEngine::Manager::get_LCID",hr,pVal,m_ths.GetLanguage());

    __HCP_END_PROPERTY(hr);
}

////////////////////////////////////////

STDMETHODIMP SearchEngine::Manager::EnumEngine( /*[out,retval]*/ IPCHCollection* *ppC )
{
    __HCP_FUNC_ENTRY( "SearchEngine::Manager::EnumEngine" );

    HRESULT                      hr;
    CComPtr<CPCHCollection>      pColl;
    WrapperItemIter              it;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(ppC,NULL);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, Initialize( lock ));


    //
    // Create the Enumerator
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pColl ));

    //
    // Loop through the list
    //
	for(it = m_lstWrapperItem.begin(); it != m_lstWrapperItem.end(); it++)
    {
        //
        // Add the item to the collection
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, pColl->AddItem( *it ));
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, pColl.QueryInterface( ppC ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

STDMETHODIMP SearchEngine::Manager::ExecuteAsynchQuery()
{
    __HCP_FUNC_ENTRY( "SearchEngine::Wrap::ExecAsyncQuery" );

    HRESULT hr;

    //
    // Create a thread to execute the query
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, Thread_Start( this, ExecQuery, NULL ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT SearchEngine::Manager::ExecQuery()
{
    __HCP_FUNC_ENTRY( "SearchEngine::Manager::ExecQuery" );

    HRESULT                        hr;
    WrapperItemList                lst;
    WrapperItemIter                it;
    CComPtr<IPCHSEManagerInternal> pNotifier;
    CComBSTR                       bstrQueryString;
    long                           lNumResult;
    long                           lEnabledSE = 0;


    //
    // Make a copy of what we need, only locking the manager during this time.
    //
    {
        MPC::SmartLock<_ThreadModel> lock( this );

        //
        // Check if there is already a query being executed
        //
        if(m_lEnabledSE > 0)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_NOT_READY);
        }


        __MPC_EXIT_IF_METHOD_FAILS(hr, Initialize( lock ));

        CloneListOfWrappers( lst );

        pNotifier       = m_Notifier;
        bstrQueryString = m_bstrQueryString;
        lNumResult      = m_lNumResult;
    }

    for(it = lst.begin(); it != lst.end(); it++)
    {
        IPCHSEWrapperItem* obj = *it;
        VARIANT_BOOL       bEnabled;

        //
        // Check if the search engine is enabled
        //
        if(SUCCEEDED(obj->get_Enabled( &bEnabled )) && bEnabled == VARIANT_TRUE)
        {
            CComPtr<IPCHSEWrapperInternal> pSEInternal;

            if(SUCCEEDED(obj        ->QueryInterface     ( IID_IPCHSEWrapperInternal, (void **)&pSEInternal )) && // Get the Internal Wrapper Interface
               SUCCEEDED(pSEInternal->put_QueryString    ( bstrQueryString                                  )) && // Insert the query string
               SUCCEEDED(pSEInternal->put_NumResult      ( lNumResult                                       )) && // Insert the Number of results expected
               SUCCEEDED(pSEInternal->SECallbackInterface( pNotifier                                        )) && // Insert the Internal manager interface
               SUCCEEDED(pSEInternal->ExecAsyncQuery     (                                                  ))  ) // Execute the query and increment the count
            {
                lEnabledSE++;
            }
        }
    }

    {
        MPC::SmartLock<_ThreadModel> lock( this );

        m_lEnabledSE = lEnabledSE;
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    MPC::ReleaseAll( lst );

    Thread_Abort();

    __MPC_FUNC_EXIT(hr);
}

STDMETHODIMP SearchEngine::Manager::AbortQuery()
{
    __HCP_FUNC_ENTRY( "SearchEngine::Manager::AbortQuery" );

    HRESULT         hr;
    WrapperItemList lst;
    WrapperItemIter it;


    //
    // Copy list under lock.
    //
    {
        MPC::SmartLock<_ThreadModel> lock( this );

        CloneListOfWrappers( lst );
    }

    //
    // Loop through the list
    //
    for(it = lst.begin(); it != lst.end(); it++)
    {
        CComPtr<IPCHSEWrapperInternal> pSEInternal;

        //
        // Get the Internal Wrapper Interface
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, (*it)->QueryInterface( IID_IPCHSEWrapperInternal, (void **)&pSEInternal ));

        //
        // Abort the query
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, pSEInternal->AbortQuery());
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    MPC::ReleaseAll( lst );

    //
    // reset everything
    //
    {
        MPC::SmartLock<_ThreadModel> lock( this );

        m_lCountComplete = 0;
        m_lEnabledSE     = 0;
        m_hrLastError    = S_OK;
    }

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP SearchEngine::ManagerInternal::WrapperComplete( /*[in]*/ long lSucceeded, /*[in]*/ IPCHSEWrapperItem* pIPCHSEWICompleted )
{
    CComPtr<SearchEngine::Manager> pMgr;

    Child_GetParent( &pMgr );

    return pMgr ? pMgr->NotifyWrapperComplete( lSucceeded, pIPCHSEWICompleted ) : E_POINTER;
}

STDMETHODIMP SearchEngine::ManagerInternal::IsNetworkAlive( /*[out]*/ VARIANT_BOOL *pvbVar )
{
    CComPtr<SearchEngine::Manager> pMgr;

    Child_GetParent( &pMgr );

    return pMgr ? pMgr->IsNetworkAlive( pvbVar ) : E_POINTER;
}

STDMETHODIMP SearchEngine::ManagerInternal::IsDestinationReachable( /*[in ]*/ BSTR bstrDestination, /*[out]*/ VARIANT_BOOL *pvbVar )
{
    CComPtr<SearchEngine::Manager> pMgr;

    Child_GetParent( &pMgr );

    return pMgr ? pMgr->IsDestinationReachable( bstrDestination, pvbVar ) : E_POINTER;
}

STDMETHODIMP SearchEngine::ManagerInternal::LogRecord( /*[in]*/ BSTR bstrRecord )
{
    CComPtr<SearchEngine::Manager> pMgr;

    Child_GetParent( &pMgr );

    return pMgr ? pMgr->LogRecord( bstrRecord ) : E_POINTER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\fts_lib\util.cpp ===
#include "stdafx.h"
#include "util.h"
#include <strsafe.h>

PCSTR FindFilePortion(PCSTR pszFile)
{
        PCSTR psz = StrRChr(pszFile, '\\');
        if (psz)
                pszFile = psz + 1;
        psz = StrRChr(pszFile, '/');
        if (psz)
                return psz + 1;
        psz = StrRChr(pszFile, ':');
        return (psz ? psz + 1 : pszFile);
}

void reportOleError(HRESULT hr)
{
#ifdef _DEBUG
    char szTemp[100];

        StringCchPrintfA(szTemp, ARRAYSIZE(szTemp), "Ole error hresult %d\n",hr);
    MessageBox(NULL,szTemp,"Error",MB_OK);
#endif
}


PSTR StrChr(PCSTR pszString, char ch)
{
    while (*pszString) {
        while (IsDBCSLeadByte(*pszString))
        	pszString = CharNextA(pszString);
        if (*pszString == ch)
            return (PSTR) pszString;
        else if (!*pszString)
            return NULL;
        pszString++;
    }
    return NULL;
}

PSTR StrRChr(PCSTR pszString, char ch)
{
    PSTR psz = StrChr(pszString, ch);
    PSTR pszLast;

    if (!psz)
        return NULL;
    do {
        pszLast = psz;
        psz = StrChr(pszLast + 1, ch);
    } while (psz);

    return pszLast;
}

/***************************************************************************

    FUNCTION:   HashFromSz

    PURPOSE:    Convert a string into a hash representation

    PARAMETERS:
        pszKey

    RETURNS:    Hash number

    COMMENTS:
        Shamelessly stolen from the WinHelp code, since after 6 years
        of use by up to 1 million help authors, there were no reports
        of collisions.

    MODIFICATION DATES:
        10-Aug-1996 [ralphw] Stolen from WinHelp, removed special-case
        hash characters

***************************************************************************/

// This constant defines the alphabet size for our hash function.



static const HASH MAX_CHARS = 43;

HASH WINAPI HashFromSz(PCSTR pszKey)
{
    HASH  hash = 0;

    int cch = strlen(pszKey);

    for (int ich = 0; ich < cch; ++ich) {

        // treat '/' and '\' as the same

        if (pszKey[ich] == '/')
            hash = (hash * MAX_CHARS) + ('\\' - '0');
        else if (pszKey[ich] <= 'Z')
            hash = (hash * MAX_CHARS) + (pszKey[ich] - '0');
        else
            hash = (hash * MAX_CHARS) + (pszKey[ich] - '0' - ('a' - 'A'));
    }

    /*
     * Since the value 0 is reserved as a nil value, if any context
     * string actually hashes to this value, we just move it.
     */

    return (hash == 0 ? 0 + 1 : hash);
}


CTitleInformation::CTitleInformation( CFileSystem* pFileSystem )
{
    m_pFileSystem = pFileSystem;
    m_pszDefCaption = NULL;
    m_pszShortName = NULL;

    Initialize();
}

CTitleInformation::~CTitleInformation()
{
   if(m_pszDefCaption)
      free((void *)m_pszDefCaption);

   if(m_pszShortName)
      free((void *)m_pszShortName);
}

HRESULT CTitleInformation::Initialize()
{
    if( !m_pFileSystem )
        return S_FALSE;

    // open the title information file (#SYSTEM)
    CSubFileSystem* pSubFileSystem = new CSubFileSystem(m_pFileSystem); if(!pSubFileSystem) return E_FAIL;
    HRESULT hr = pSubFileSystem->OpenSub("#SYSTEM");
    if( FAILED(hr))
        return S_FALSE;

    // check the version of the title information file (#SYSTEM)

    DWORD dwVersion;
    DWORD cbRead;
    hr = pSubFileSystem->ReadSub(&dwVersion, sizeof(dwVersion), &cbRead);
    if( FAILED(hr) || cbRead != sizeof(dwVersion) ) 
    {
        delete pSubFileSystem;
        return STG_E_READFAULT;
    }
 
    // read in each and every item (skip those tags we don't care about)

    SYSTEM_TAG tag;
    for(;;) {

        // get the tag type

        hr = pSubFileSystem->ReadSub(&tag, sizeof(SYSTEM_TAG), &cbRead);
        if( FAILED(hr) || cbRead != sizeof(SYSTEM_TAG))
            break;

        // handle each tag according to it's type

        switch( tag.tag ) {

            // where all of our simple settings are stored

        case TAG_SHORT_NAME:
            m_pszShortName = (PCSTR) malloc(tag.cbTag);
            hr = pSubFileSystem->ReadSub((void*) m_pszShortName, tag.cbTag, &cbRead);
            break;

        case TAG_DEFAULT_CAPTION:
            m_pszDefCaption = (PCSTR) malloc(tag.cbTag);
            hr = pSubFileSystem->ReadSub((void*) m_pszDefCaption, tag.cbTag, &cbRead);
            break;

           // skip those we don't care about or don't know about
        default:
            hr = pSubFileSystem->SeekSub( tag.cbTag, SEEK_CUR );
            break;

    }

    if( FAILED(hr) ) {
        delete pSubFileSystem;
        return STG_E_READFAULT;
    }
  }

  delete pSubFileSystem;
  return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\fts_lib\titleinfo.cpp ===
// TitleInfo.cpp : implementation file
//
//
// includes
//
#include "stdafx.h"
#include "titleinfo.h"
#include <locale.h>
#include <strsafe.h>

// constants
//
const char txtTopicsFile[]	 = "#TOPICS";
const char txtUrlTblFile[]	 = "#URLTBL";
const char txtUrlStrFile[]	 = "#URLSTR";
const char txtStringsFile[]  = "#STRINGS";
const char txtMkStore[] = "ms-its:";
const char txtSepBack[]  = "::/";
const char txtDoubleColonSep[] = "::";

/////////////////////////////////////////////////////////////////////////////
// CTitleInfo Class
//
// This class provides the ability to retrieve topic titles and topic URLs
// from topic numbers from a CHM file (HTML Help title). 
//

/////////////////////////////////////////////////////////////////////////////
// CTitleInfo class constructor
//
CTitleInfo::CTitleInfo()
{
   // init members
   //
   m_bOpen           = FALSE;
   m_szTitlePath[0]  = NULL;
   m_pUrlStrings     = NULL;
   m_pTopics         = NULL;
   m_pStrTbl         = NULL;
   m_pUrlTbl         = NULL;
   m_pTitleInfo		 = NULL;
   m_pCFileSystem	 = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CTitleInfo class destructor
//
CTitleInfo::~CTitleInfo()
{
   // make sure the title was opened
   //
   if (!m_bOpen)
      return;

   // close the subfiles
   //
   if (m_pUrlTbl)
      delete m_pUrlTbl;

   if(m_pTopics)
      delete m_pTopics;

   if(m_pStrTbl)
      delete m_pStrTbl;

   if(m_pUrlStrings)
      delete m_pUrlStrings;

   if(m_pTitleInfo)
      delete m_pTitleInfo;

   // delete the mail filesystem
   //
   if(m_pCFileSystem)
      delete m_pCFileSystem;

   // deinit the members
   //
   m_pUrlStrings  = NULL;
   m_pTopics      = NULL;
   m_pStrTbl      = NULL;
   m_pUrlTbl      = NULL;

   // no longer open
   //
   m_bOpen = FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CTitleInfo: OpenTitle method
//
// This funciton opens a help title
// 
// Note: This method must be called before any other methods
//
// pwcTitlePath      Path the help title (chm file)
//
BOOL CTitleInfo::OpenTitle(WCHAR *pwcTitlePath)
{
   HRESULT hr;

   // make sure we're not already open
   //
   if (m_bOpen)
      return TRUE;

   WCHAR wcFullPath[_MAX_PATH];
   WCHAR *pwcFilePart = NULL;

   // get the full path to title
   //
   if(!GetFullPathNameW(pwcTitlePath, sizeof(wcFullPath)/sizeof(WCHAR), wcFullPath, &pwcFilePart))
      return FALSE;

   // create filesystem object
   //
   if (m_pCFileSystem) delete m_pCFileSystem;
   m_pCFileSystem = new CFileSystem();
   
   if(!m_pCFileSystem)
	  return FALSE;

   hr = m_pCFileSystem->Init();

   if(FAILED(hr))
   {
	   delete m_pCFileSystem;
	   m_pCFileSystem = NULL;
	   return FALSE;
   }

   // open the CHM file
   //
   hr = m_pCFileSystem->Open(wcFullPath);
   
   if (FAILED(hr))
   {
	   delete m_pCFileSystem;
	   m_pCFileSystem = NULL;
	   return FALSE;
   }

   if (m_pTitleInfo) delete m_pTitleInfo;
   m_pTitleInfo = new CTitleInformation(m_pCFileSystem);

   if(!m_pTitleInfo)
   {
	   delete m_pCFileSystem;
	   m_pCFileSystem = NULL;
	   return FALSE;
   }

   // save the full path to the CHM (used when constructing URLs)
   //
   WideCharToMultiByte(CP_ACP, 0, wcFullPath, -1, m_szTitlePath,  sizeof(m_szTitlePath), 0, 0);

   // success!
   //
   m_bOpen = TRUE;

   return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CTitleInfo: GetLocationName
//
// This function retrieves the location name of the CHM.  This string is the
// friendly name for the CHM that appears in result lists.
// 
// pwszLocationName  Destination buffer for location name
// cch               Size of pwszLocationName
//
HRESULT CTitleInfo::GetLocationName(WCHAR *pwszLocationName, int cch, UINT cp)
{
   if(!pwszLocationName || !cch)
      return E_INVALIDARG;

  if(m_pTitleInfo)
  {
    const CHAR* psz = NULL;
    psz = m_pTitleInfo->GetDefaultCaption();
    
    if( !psz || !*psz )
      psz = m_pTitleInfo->GetShortName();
    
    if( psz && *psz )
    {
      MultiByteToWideChar(cp, 0, psz, -1, pwszLocationName, cch);
      pwszLocationName[cch-1] = 0;
      return S_OK;
    }
  }

  return E_FAIL;
}

/////////////////////////////////////////////////////////////////////////////
// CTitleInfo: GetTopicName
//
// This function retrieves a topic title from a topic number
// 
// dwTopic        Topic Number
// pwszTitle      Destination buffer for topic title
// cch            Size of pwszTitle
//
HRESULT CTitleInfo::GetTopicName(DWORD dwTopic, WCHAR* pwszTitle, int cch, UINT cp)
{
   TOC_TOPIC topic;
   HRESULT hr;
   
   if (SUCCEEDED(hr = GetTopicData(dwTopic, &topic)))
      return GetString(topic.dwOffsTitle, pwszTitle, cch, cp);
   else
      return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CTitleInfo: GetTopicURL
//
// This function retrieves a topic URL from a topic number
// 
// dwTopic        Topic Number
// pwszURL        Destination buffer for URL
// cch            Size of pwcURL
//
HRESULT CTitleInfo::GetTopicURL(DWORD dwTopic, CHAR* pwszURL, int cch)
{
    TOC_TOPIC topic;
    HRESULT hr;
    CHAR* psz;

    if (m_bOpen == FALSE)
      return E_FAIL;

    if (!m_pUrlTbl)
    {
        m_pUrlTbl = new CPagedSubfile; if(!m_pUrlTbl) return E_FAIL;
        if (FAILED(hr = m_pUrlTbl->Open(this, txtUrlTblFile)))
        {
            delete m_pUrlTbl;
            m_pUrlTbl = NULL;
            return hr;
        }
    }
    if (!m_pUrlStrings)
    {
        m_pUrlStrings = new CPagedSubfile; if(!m_pUrlStrings) return E_FAIL;
        if (FAILED(hr = m_pUrlStrings->Open(this, txtUrlStrFile)))
        {
            delete m_pUrlStrings;
            m_pUrlStrings = NULL;
            return hr;
        }
    }
    if ( (hr = GetTopicData(dwTopic, &topic)) == S_OK )
    {
        PCURL pUrlTbl;
        if ( (pUrlTbl = (PCURL)m_pUrlTbl->Offset(topic.dwOffsURL)) )
        {
            PURLSTR purl = (PURLSTR) m_pUrlStrings->Offset(pUrlTbl->dwOffsURL);
            if (purl)
            {
                // If not an interfile jump, the create the full URL
                //
                if (! StrChr(purl->szURL, ':'))
                {
                    psz = purl->szURL;
                    if ((int) (strlen(psz) + strlen(txtMkStore) + strlen(m_szTitlePath) + 7) > cch)
                       return E_OUTOFMEMORY;
                    StringCchCopyA(pwszURL, cch, txtMkStore);
                    pwszURL[cch-1] = 0;
                    StringCchCatA(pwszURL, cch, m_szTitlePath);

                    if (*psz != '/')
                        StringCchCatA(pwszURL, cch, txtSepBack);
                    else
                        StringCchCatA(pwszURL, cch, txtDoubleColonSep);
                    StringCchCatA(pwszURL, cch, psz);
                }
                else
                   return E_FAIL;  // inter-chm jump, not supported by this function
            }
        }
    }
    return hr;
}



/////////////////////////////////////////////////////////////////////////////
// CTitleInfo: GetTopicData
//
// This funciton retrieves data from the topics sub-file
// 
HRESULT CTitleInfo::GetTopicData(DWORD dwTopic, TOC_TOPIC * pTopicData)
{
   HRESULT hr;
   BYTE * pb;
   
   if (m_bOpen == FALSE)
      return E_FAIL;

   if (!m_pTopics)
   {
	  m_pTopics = new CPagedSubfile; if(!m_pTopics) return E_FAIL;
	  if (FAILED(hr = m_pTopics->Open(this, txtTopicsFile)))
	  {
		  delete m_pTopics;
		  m_pTopics = NULL;
		  return hr;
	  }
   }
   pb = (BYTE*)m_pTopics->Offset(dwTopic * sizeof(TOC_TOPIC));
   if (pb)
   {
      memcpy(pTopicData, pb, sizeof(TOC_TOPIC));
      return S_OK;
   }
   else
      return E_FAIL;
}

/////////////////////////////////////////////////////////////////////////////
// CTitleInfo: GetString
//
// This funciton retrieves data from the strings sub-file
// 
HRESULT CTitleInfo::GetString( DWORD dwOffset, WCHAR* pwsz, int cch, UINT cp )
{
   const CHAR* pStr = GetString( dwOffset );
   
   if( pStr ) {
      MultiByteToWideChar(cp, 0, pStr, -1, pwsz, cch );
      return S_OK;
   }
   else
      return E_FAIL;
}

/////////////////////////////////////////////////////////////////////////////
// CTitleInfo: GetString
//
// This funciton retrieves data from the strings sub-file
// 
const CHAR* CTitleInfo::GetString( DWORD dwOffset )
{
  HRESULT hr;
  const CHAR* pStr;

  if( !m_bOpen )
     return NULL;

  if( !m_pStrTbl )
  {
	  m_pStrTbl = new CPagedSubfile; if(!m_pStrTbl) return NULL;

	  if( FAILED(hr = m_pStrTbl->Open(this,txtStringsFile)) )
	  {
		  delete m_pStrTbl; m_pStrTbl = NULL;

		  return NULL;
	  }
  }

  pStr = (const CHAR*) m_pStrTbl->Offset( dwOffset );

  return pStr;
}

/////////////////////////////////////////////////////////////////////////////
// CTitleInfo: GetString
//
// This funciton retrieves data from the strings sub-file
// 
HRESULT CTitleInfo::GetString( DWORD dwOffset, CHAR* psz, int cb )
{
  const CHAR* pStr = GetString( dwOffset );

  if( pStr )
  {
    StringCbCopyA( psz, cb, pStr );
    psz[cb-1] = 0;
    return S_OK;
  }
  else
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\manager\seconfig.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    SAFReg.cpp

Abstract:
    File for Implementation of CSAFReg

Revision History:

    gschua          created     3/22/2000

********************************************************************/

#include "stdafx.h"

static const WCHAR g_rgMutexName     [] = L"PCH_SEARCHENGINECONFIG";
static const WCHAR g_rgConfigFilename[] = HC_HCUPDATE_STORE_SE;

/////////////////////////////////////////////////////////////////////

CFG_BEGIN_FIELDS_MAP(SearchEngine::Config::Wrapper)
    CFG_ATTRIBUTE( L"SKU"     , wstring, m_ths.m_strSKU ),
    CFG_ATTRIBUTE( L"LANGUAGE", long   , m_ths.m_lLCID  ),

    CFG_ATTRIBUTE( L"ID"   	  , BSTR   , m_bstrID       ),
    CFG_ATTRIBUTE( L"OWNER"	  , BSTR   , m_bstrOwner    ),
    CFG_ATTRIBUTE( L"CLSID"	  , BSTR   , m_bstrCLSID    ),
    CFG_ATTRIBUTE( L"DATA" 	  , BSTR   , m_bstrData     ),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(SearchEngine::Config::Wrapper)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(SearchEngine::Config::Wrapper,L"WRAPPER")

DEFINE_CONFIG_METHODS__NOCHILD(SearchEngine::Config::Wrapper)

/////////////////////////////////////////////////////////////////////

CFG_BEGIN_FIELDS_MAP(SearchEngine::Config)
    CFG_ATTRIBUTE( L"VERSION", double, m_dVersion ),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(SearchEngine::Config)
    CFG_CHILD(SearchEngine::Config::Wrapper)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(SearchEngine::Config, L"SEARCHENGINES")

DEFINE_CONFIG_METHODS_CREATEINSTANCE_SECTION(SearchEngine::Config,tag,defSubType)
    if(tag == _cfg_table_tags[0])
    {
        defSubType = &(*(m_lstWrapper.insert( m_lstWrapper.end() )));
        return S_OK;
    }
DEFINE_CONFIG_METHODS_SAVENODE_SECTION(SearchEngine::Config,xdn)
    hr = MPC::Config::SaveList( m_lstWrapper, xdn );
DEFINE_CONFIG_METHODS_END(SearchEngine::Config)

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

SearchEngine::Config::Config() : MPC::NamedMutex( g_rgMutexName )
{
    m_bLoaded  = false; // double      m_dVersion;
    m_dVersion = 1;     // bool        m_bLoaded;
    					// WrapperList m_lstWrapper;

    MPC::NamedMutex::Acquire();
}

SearchEngine::Config::~Config()
{
    MPC::NamedMutex::Release();
}

////////////////////////////////////////////////////////////////////////////////

HRESULT SearchEngine::Config::SyncConfiguration( /*[in]*/ bool fLoad )
{
	__HCP_FUNC_ENTRY( "SearchEngine::Config::SyncConfiguration" );

    HRESULT      hr;
    MPC::wstring strConfig( g_rgConfigFilename ); MPC::SubstituteEnvVariables( strConfig );


	if(fLoad)
	{
		if(m_bLoaded == false)
		{
			__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::Config::LoadFile( this, strConfig.c_str() ));
			m_bLoaded = true;
		}
    }
	else
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::Config::SaveFile( this, strConfig.c_str() ));
		m_bLoaded = true;
	}

    hr = S_OK;

    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

bool SearchEngine::Config::FindWrapper( /*[in]*/ const Taxonomy::HelpSet& ths, /*[in]*/ LPCWSTR szID, /*[out]*/ WrapperIter& it )
{
	for(it = m_lstWrapper.begin(); it!= m_lstWrapper.end(); it++)
	{
        if(it->m_ths == ths && it->m_bstrID == szID) return true;
    }

	return false;
}

////////////////////

HRESULT SearchEngine::Config::RegisterWrapper( /*[in]*/ const Taxonomy::HelpSet& ths     , 
											  /*[in]*/ LPCWSTR                  szID    ,
                                              /*[in]*/ LPCWSTR                  szOwner ,
											  /*[in]*/ LPCWSTR                  szCLSID ,
											  /*[in]*/ LPCWSTR                  szData  )
{
	__HCP_FUNC_ENTRY( "SearchEngine::Config::RegisterWrapper" );

    HRESULT     hr;
	WrapperIter it;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_STRING_NOT_EMPTY(szID);
		__MPC_PARAMCHECK_STRING_NOT_EMPTY(szOwner);
		__MPC_PARAMCHECK_STRING_NOT_EMPTY(szCLSID);
	__MPC_PARAMCHECK_END();


    //
    // Make sure its loaded
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, SyncConfiguration( /*fLoad*/true ));

    //
    // Look for existing wrapper
    //
	if(FindWrapper( ths, szID, it ) == false)
	{
        //
        // Not found, so create a new Wrapper
        //
        it = m_lstWrapper.insert( m_lstWrapper.end() );
    }

    //
    // Stuff the values into the wrapper
    //
    it->m_ths       = ths;
    it->m_bstrID    = szID;
    it->m_bstrOwner = szOwner;
    it->m_bstrCLSID = szCLSID;
    it->m_bstrData  = szData;

	__MPC_EXIT_IF_METHOD_FAILS(hr, SyncConfiguration( /*fLoad*/false ));

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

HRESULT SearchEngine::Config::UnRegisterWrapper( /*[in]*/ const Taxonomy::HelpSet& ths     , 
												/*[in]*/ LPCWSTR                  szID    ,
                                                /*[in]*/ LPCWSTR                  szOwner )
{
	__HCP_FUNC_ENTRY( "SearchEngine::Config::UnRegisterWrapper" );

    HRESULT     hr;
	WrapperIter it;
	
	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_STRING_NOT_EMPTY(szID);
		__MPC_PARAMCHECK_STRING_NOT_EMPTY(szOwner);
	__MPC_PARAMCHECK_END();


    //
    // Make sure its loaded
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, SyncConfiguration( /*fLoad*/true ));

    //
    // Look for existing wrapper
    //
	if(FindWrapper( ths, szID, it ))
	{
        //
        // Check if it is the correct owner
        //
        if(MPC::StrICmp( it->m_bstrOwner, szOwner ) != 0)
        {
            __MPC_SET_ERROR_AND_EXIT( hr, ERROR_ACCESS_DENIED );
        }

        //
        // If so, delete it
        //
        m_lstWrapper.erase( it );
    }

	__MPC_EXIT_IF_METHOD_FAILS(hr, SyncConfiguration( /*fLoad*/false ));

    hr = S_OK;

    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT SearchEngine::Config::ResetSKU( /*[in]*/ const Taxonomy::HelpSet& ths )
{
	__HCP_FUNC_ENTRY( "SearchEngine::Config::ResetSKU" );

    HRESULT     hr;
	WrapperIter it;
	

    //
    // Make sure its loaded
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, SyncConfiguration( /*fLoad*/true ));

    //
    // Look for existing wrappers belonging to the same SKU.
    //
	for(it = m_lstWrapper.begin(); it!= m_lstWrapper.end(); )
	{
		WrapperIter it2 = it++;

		if(it2->m_ths == ths)
		{
			m_lstWrapper.erase( it2 );
		}
	}

	__MPC_EXIT_IF_METHOD_FAILS(hr, SyncConfiguration( /*fLoad*/false ));

    hr = S_OK;

    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT SearchEngine::Config::GetWrappers( /*[out]*/ WrapperIter& itBegin, /*[out]*/ WrapperIter& itEnd )
{
	__HCP_FUNC_ENTRY( "SearchEngine::Config::GetWrappers" );

	HRESULT hr;

    __MPC_EXIT_IF_METHOD_FAILS(hr, SyncConfiguration( /*fLoad*/true ));

	itBegin = m_lstWrapper.begin();
	itEnd   = m_lstWrapper.end  ();
	hr      = S_OK;

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\manager\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__23C95C1F_F8B1_4A62_8F99_CAD1F1AB7339__INCLUDED_)
#define AFX_STDAFX_H__23C95C1F_F8B1_4A62_8F99_CAD1F1AB7339__INCLUDED_

#include <module.h>

#include <HCP_trace.h>
#include <MPC_main.h>
#include <MPC_utils.h>
#include <MPC_config.h>
#include <MPC_streams.h>
#include <MPC_COM.h>
#include <SvcResource.h>

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>
#include <seconfig.h>
#include <SearchEngineLib.h>
#include <AccountsLib.h>
#include <Utility.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__23C95C1F_F8B1_4A62_8F99_CAD1F1AB7339__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\manager\wrapperbase.cpp ===
/******************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:
    WrapperBase.cpp

Abstract:
    Implementation of SearchEngine::WrapperBase

Revision History:
    Davide Massarenti   (dmassare)  04/28/2001
        created

******************************************************************************/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////

namespace SearchEngine
{
    struct WrapperConfig : public MPC::Config::TypeConstructor
    {
        DECLARE_CONFIG_MAP(WrapperConfig);

        CComBSTR m_bstrName;
        CComBSTR m_bstrDescription;
        CComBSTR m_bstrHelpURL;
        CComBSTR m_bstrScope;

        ////////////////////////////////////////

        ////////////////////////////////////////
        //
        // MPC::Config::TypeConstructor
        //
        DEFINE_CONFIG_DEFAULTTAG();
        DECLARE_CONFIG_METHODS  ();
        //
        ////////////////////////////////////////
    };
};


CFG_BEGIN_FIELDS_MAP(SearchEngine::WrapperConfig)
    CFG_ELEMENT( L"NAME"       , BSTR, m_bstrName        ),
    CFG_ELEMENT( L"DESCRIPTION", BSTR, m_bstrDescription ),
    CFG_ELEMENT( L"SCOPE"      , BSTR, m_bstrScope       ),
    CFG_ELEMENT( L"HELP_URL"   , BSTR, m_bstrHelpURL     ),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(SearchEngine::WrapperConfig)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(SearchEngine::WrapperConfig, L"CONFIG_DATA")

DEFINE_CONFIG_METHODS__NOCHILD(SearchEngine::WrapperConfig)

/////////////////////////////////////////////////////////////////////

SearchEngine::WrapperBase::WrapperBase()
{
    m_bEnabled   = VARIANT_TRUE; // VARIANT_BOOL                   m_bEnabled;
                                 //
                                 // CComBSTR                       m_bstrID;
                                 // CComBSTR                       m_bstrOwner;
                                 //
                                 // CComBSTR                       m_bstrName;
                                 // CComBSTR                       m_bstrDescription;
                                 // CComBSTR                       m_bstrHelpURL;
                                 // CComBSTR                       m_bstrScope;
                                 //
                                 // CComBSTR                       m_bstrQueryString;
    m_lNumResult = 100;          // long                           m_lNumResult;
                                 // CComPtr<IPCHSEManagerInternal> m_pSEMgr;
                                 //
                                 // Taxonomy::HelpSet              m_ths;
                                 // CComPtr<CPCHCollection>        m_pParamDef;
                                 // ParamMap                       m_aParam;
}

SearchEngine::WrapperBase::~WrapperBase()
{
    Clean();
}

HRESULT SearchEngine::WrapperBase::Clean()
{
    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP SearchEngine::WrapperBase::get_Enabled( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("SearchEngine::WrapperBase::get_Enabled",hr,pVal,m_bEnabled);

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP SearchEngine::WrapperBase::put_Enabled( /*[in]*/ VARIANT_BOOL newVal )
{
    __HCP_BEGIN_PROPERTY_PUT("SearchEngine::WrapperBase::put_Enabled",hr);

    m_bEnabled = newVal;

    __HCP_END_PROPERTY(hr);
}


STDMETHODIMP SearchEngine::WrapperBase::get_Owner( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("SearchEngine::WrapperBase::get_Owner",hr,pVal);

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_bstrOwner, pVal ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP SearchEngine::WrapperBase::get_Description( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("SearchEngine::WrapperBase::get_Description",hr,pVal);

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_bstrDescription, pVal ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP SearchEngine::WrapperBase::get_Name( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("SearchEngine::WrapperBase::get_Name",hr,pVal);

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_bstrName, pVal ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP SearchEngine::WrapperBase::get_ID( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("SearchEngine::WrapperBase::get_ID",hr,pVal);

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_bstrID, pVal ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP SearchEngine::WrapperBase::get_HelpURL( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("SearchEngine::WrapperBase::get_HelpURL",hr,pVal);

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_bstrHelpURL, pVal ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP SearchEngine::WrapperBase::get_SearchTerms( /*[out, retval]*/ VARIANT *pVal )
{
    return S_OK;
}

////////////////////

VARIANT* SearchEngine::WrapperBase::GetParamInternal( /*[in]*/ LPCWSTR szParamName )
{
    ParamMapIter it;

    it = m_aParam.find( szParamName );

    return (it == m_aParam.end()) ? NULL : &it->second;
}

HRESULT SearchEngine::WrapperBase::CreateParam( /*[in/out]*/ CPCHCollection* coll, /*[in]*/ const ParamItem_Definition* def )
{
    __HCP_FUNC_ENTRY( "SearchEngine::WrapperBase::CreateParam" );

    HRESULT            hr;
    CComPtr<ParamItem> obj;

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &obj ));

    {
        ParamItem_Data& data = obj->Data();

        data.m_pteParamType = def->m_pteParamType;
        data.m_bRequired    = def->m_bRequired;
        data.m_bVisible     = def->m_bVisible;

        data.m_bstrName     = def->m_szName;

        if(def->m_iDisplayString)
        {
            (void)MPC::LocalizeString( def->m_iDisplayString, data.m_bstrDisplayString, /*fMUI*/true );
        }
        else if(def->m_szDisplayString)
        {
            data.m_bstrDisplayString = def->m_szDisplayString;
        }

        if(def->m_szData)
        {
            VARTYPE vt;

            switch(data.m_pteParamType)
            {
            case PARAM_UI1 : vt = VT_UI1  ; break;
            case PARAM_I2  : vt = VT_I2   ; break;
            case PARAM_I4  : vt = VT_I4   ; break;
            case PARAM_R4  : vt = VT_R4   ; break;
            case PARAM_R8  : vt = VT_R8   ; break;
            case PARAM_BOOL: vt = VT_BOOL ; break;
            case PARAM_DATE: vt = VT_DATE ; break;
            case PARAM_BSTR: vt = VT_BSTR ; break;
            case PARAM_I1  : vt = VT_I1   ; break;
            case PARAM_UI2 : vt = VT_UI2  ; break;
            case PARAM_UI4 : vt = VT_UI4  ; break;
            case PARAM_INT : vt = VT_INT  ; break;
            case PARAM_UINT: vt = VT_UINT ; break;
            case PARAM_LIST: vt = VT_BSTR ; break;
            default        : vt = VT_EMPTY; break;
            }

            if(vt != VT_EMPTY)
            {
                data.m_varData = def->m_szData;

                if(FAILED(data.m_varData.ChangeType( vt )) || data.m_varData.vt != vt)
                {
                    data.m_varData.Clear();
                }
            }
        }

        if(data.m_pteParamType != PARAM_LIST)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, AddParam( data.m_bstrName, data.m_varData ));
        }
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, coll->AddItem( obj ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT SearchEngine::WrapperBase::CreateListOfParams( /*[in]*/ CPCHCollection* coll )
{
    __HCP_FUNC_ENTRY( "SearchEngine::WrapperBase::CreateListOfParams" );

    HRESULT                     hr;
    const ParamItem_Definition* lst = NULL;
    int                         len = 0;


    __MPC_EXIT_IF_METHOD_FAILS(hr, GetParamDefinition( lst, len ));
    while(len-- > 0)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, CreateParam( coll, lst++ ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT SearchEngine::WrapperBase::GetParamDefinition( /*[out]*/ const ParamItem_Definition*& lst, /*[out]*/ int& len )
{
    lst = NULL;
    len = 0;

    return S_OK;
}

STDMETHODIMP SearchEngine::WrapperBase::Param( /*[out,retval]*/ IPCHCollection* *ppC )
{
    __HCP_BEGIN_PROPERTY_GET("SearchEngine::WrapperBase::Param",hr,ppC);


    if(!m_pParamDef)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &m_pParamDef ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, CreateListOfParams (  m_pParamDef ));
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_pParamDef.QueryInterface( ppC ));


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP SearchEngine::WrapperBase::AddParam( /*[in]*/ BSTR bstrParamName, /*[in]*/ VARIANT newVal )
{
    __HCP_BEGIN_PROPERTY_PUT("SearchEngine::WrapperBase::AddParam",hr);

    std::pair<ParamMapIter, bool> item;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrParamName);
    __MPC_PARAMCHECK_END();

    item = m_aParam.insert( ParamMap::value_type( bstrParamName, CComVariant() ) ); item.first->second = newVal;

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP SearchEngine::WrapperBase::GetParam( /*[in]*/ BSTR bstrParamName, /*[out,retval]*/ VARIANT *pVal )
{
    __HCP_BEGIN_PROPERTY_PUT("SearchEngine::WrapperBase::AddParam",hr);

    VARIANT* v;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrParamName);
        __MPC_PARAMCHECK_NOTNULL(pVal);
    __MPC_PARAMCHECK_END();

    v = GetParamInternal( bstrParamName );
    if(!v)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_INVALID_PARAMETER);
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, ::VariantCopy( pVal, v ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP SearchEngine::WrapperBase::DelParam( /*[in]*/ BSTR bstrParamName )
{
    __HCP_BEGIN_PROPERTY_PUT("SearchEngine::WrapperBase::AddParam",hr);

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrParamName);
    __MPC_PARAMCHECK_END();

    m_aParam.erase( bstrParamName );

    __HCP_END_PROPERTY(hr);
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP SearchEngine::WrapperBase::get_QueryString( /*[out, retval]*/ BSTR *pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::GetBSTR( m_bstrQueryString, pVal );
}

STDMETHODIMP SearchEngine::WrapperBase::put_QueryString( /*[in]*/ BSTR newVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return MPC::PutBSTR( m_bstrQueryString, newVal, false );
}

STDMETHODIMP SearchEngine::WrapperBase::get_NumResult(/*[out, retval]*/ long *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("SearchEngine::WrapperBase::get_NumResult",hr,pVal,m_lNumResult);

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP SearchEngine::WrapperBase::put_NumResult( /*[in]*/ long  newVal )
{
    __HCP_BEGIN_PROPERTY_PUT("SearchEngine::WrapperBase::put_NumResult",hr);

    m_lNumResult = newVal;

    __HCP_END_PROPERTY(hr);
}

////////////////////

STDMETHODIMP SearchEngine::WrapperBase::Initialize( /*[in]*/ BSTR bstrID, /*[in]*/ BSTR bstrSKU, /*[in]*/ long lLCID, /*[in]*/ BSTR bstrData )
{
    if(STRINGISPRESENT(bstrID)) m_bstrID = bstrID;

    if(bstrData)
    {
        SearchEngine::WrapperConfig cfg;
        MPC::XmlUtil                xml;
        bool                        fLoaded;
        bool                        fFound;


        if(SUCCEEDED(xml.LoadAsString( bstrData, NULL, fLoaded )) && fLoaded)
        {
            if(SUCCEEDED(MPC::Config::LoadXmlUtil( &cfg, xml )))
            {
                if(cfg.m_bstrName       ) m_bstrName        = cfg.m_bstrName       ;
                if(cfg.m_bstrDescription) m_bstrDescription = cfg.m_bstrDescription;
                if(cfg.m_bstrHelpURL    ) m_bstrHelpURL     = cfg.m_bstrHelpURL    ;
                if(cfg.m_bstrScope      ) m_bstrScope       = cfg.m_bstrScope      ;
            }
        }
    }

    return m_ths.Initialize( bstrSKU, lLCID );
}

STDMETHODIMP SearchEngine::WrapperBase::SECallbackInterface( /*[in]*/ IPCHSEManagerInternal* pMgr )
{
    __HCP_BEGIN_PROPERTY_PUT("SearchEngine::WrapperBase::SECallbackInterface",hr);

    m_pSEMgr = pMgr;

    __HCP_END_PROPERTY(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\netsearchwrapper\netsearchconfig.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    NetSearchConfig.h

Abstract:
	Implements the class CSearchResultList that contains methods for traversing the elements
	of XML file that contains the results returned by a search engine. A sample results XML file 
	if shown here - 

	<ResultList xmlns="x-schema:ResultListSchema1.xdr">
		<ResultItem 
			Title="What if I've upgraded from Windows 95 to Windows 98?" 
			URI="http://gsadevnet/support/windows/InProductHelp98/lic_keep_old_copy.asp" 
			ContentType="7" 
			Rank="96" 
			Description="Online version of our in-product help." 
			DateLastModified="08/04/1999 19:48:10" />
	</ResultList>

Revision History:
    a-prakac	created		10/24/200

********************************************************************/

#if !defined(__INCLUDED___PCH___SELIB_NETSEARCHCONFIG_H___)
#define __INCLUDED___PCH___SELIB_NETSEARCHCONFIG_H___

#include <SearchEngineLib.h>
#include <MPC_config.h>

class CSearchResultList :
	public MPC::Config::TypeConstructor,
	public MPC::NamedMutex
{
	class CSearchItem :
		public MPC::Config::TypeConstructor
	{
		DECLARE_CONFIG_MAP(CSearchItem);

		public:
			MPC::wstring m_strSearchItem;

		////////////////////////////////////////
		//
		// MPC::Config::TypeConstructor
		//
		DEFINE_CONFIG_DEFAULTTAG();
		DECLARE_CONFIG_METHODS();
		//
		////////////////////////////////////////
	};
	
	class CResultItem :
		public MPC::Config::TypeConstructor
	{
		DECLARE_CONFIG_MAP(CResultItem);

	public:
		SearchEngine::ResultItem_Data m_data;

		////////////////////////////////////////
		//
		// MPC::Config::TypeConstructor
		//
		DEFINE_CONFIG_DEFAULTTAG();
		DECLARE_CONFIG_METHODS();
		//
		////////////////////////////////////////
	};

	
	typedef std::list< CResultItem >	ResultList;
	typedef ResultList::iterator		ResultIter;
	typedef ResultList::const_iterator	ResultIterConst;

	typedef std::list< CSearchItem >	SearchList;
	typedef SearchList::iterator		SearchIter;
	typedef SearchList::const_iterator	SearchIterConst;

    ////////////////////////////////////////

	DECLARE_CONFIG_MAP(CSearchResultList);

	ResultIter m_itCurrentResult;
    ResultList m_lstResult;
	SearchList m_lstSearchItem;
	CComBSTR   m_bstrPrevQuery;
	
	////////////////////////////////////////
	//
	// MPC::Config::TypeConstructor
	//
	DEFINE_CONFIG_DEFAULTTAG();
	DECLARE_CONFIG_METHODS	();
	//
	////////////////////////////////////////
public:
	CSearchResultList ();
	~CSearchResultList();

	HRESULT 	MoveFirst				( );
	HRESULT 	MoveNext				( );
	HRESULT		ClearResults			( );
	bool		IsCursorValid			( );
	HRESULT 	SetResultItemIterator	( /*[in]*/long lIndex );
	HRESULT 	LoadResults				( /*[in]*/IStream* pStream );
	HRESULT 	InitializeResultObject	( /*[out]*/SearchEngine::ResultItem* pRIObj );
	HRESULT 	GetSearchTerms			( /*[in, out]*/ MPC::WStringList& strList );
	CComBSTR&	PrevQuery				();
	////////////////////////////////////////
};


#endif // !defined(__INCLUDED___PCH___SELIB_NETSEARCHCONFIG_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\netsearchwrapper\netsw.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    NetSW.h

Abstract:
    Implements the class CNetSW that contains methods for executing
    the search query and returning the results back to the UI. Also
    contains methods for dynamic update of parameter list and dynamic
    generation of parameters.

Revision History:
    a-prakac          created     10/24/2000

********************************************************************/

#if !defined(__INCLUDED___PCH___SELIB_NETSE_H___)
#define __INCLUDED___PCH___SELIB_NETSE_H___

/////////////////////////////////////////////////////////////////////////////
// CNetSW

namespace SearchEngine
{
	class ATL_NO_VTABLE WrapperNetSearch :
		public WrapperBase, 
		public MPC::Thread<WrapperNetSearch,IUnknown>,
		public CComCoClass<WrapperNetSearch, &CLSID_NetSearchWrapper>
	{
		CParamList        m_ParamList;
		CSearchResultList m_resConfig;
		CRemoteConfig     m_objRemoteConfig;
		MPC::XmlUtil      m_xmlQuery;
		CComBSTR          m_bstrLCID;
		CComBSTR          m_bstrSKU;
		bool              m_bOfflineError;
		CComBSTR		  m_bstrPrevQuery;
	
		////////////////////
	
		// non-exported functions
		HRESULT ExecQuery      (                                                            );
		HRESULT AppendParameter( /*[in]*/ BSTR bstrParam, /*[in]*/ MPC::URL& urlQueryString );
	
	
	public:
	DECLARE_NO_REGISTRY()
	
	BEGIN_COM_MAP(WrapperNetSearch)
		COM_INTERFACE_ENTRY2(IDispatch,IPCHSEWrapperItem)
		COM_INTERFACE_ENTRY(IPCHSEWrapperItem)
		COM_INTERFACE_ENTRY(IPCHSEWrapperInternal)
	END_COM_MAP()
	
		WrapperNetSearch();
		~WrapperNetSearch();

	    virtual HRESULT CreateListOfParams( /*[in]*/ CPCHCollection* coll );

	// IPCHSEWrapperItem
	public:
		STDMETHOD(Result)( /*[in]*/ long lStart, /*[in]*/ long lEnd, /*[out, retval]*/ IPCHCollection* *ppC );
		STDMETHOD(get_SearchTerms)( /*[out, retval]*/ VARIANT *pvTerms );
	
	// IPCHSEWrapperInternal
	public:
		STDMETHOD(ExecAsyncQuery)(                                                                                          );
		STDMETHOD(AbortQuery    )(                                                                                          );
		STDMETHOD(Initialize    )( /*[in]*/ BSTR bstrID, /*[in]*/ BSTR bstrSKU, /*[in]*/ long lLCID, /*[in]*/ BSTR bstrData );
	};
};


#endif // !defined(__INCLUDED___PCH___SELIB_NETSW_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\netsearchwrapper\paramconfig.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    ParamConfig.cpp

Abstract:
    Implements the class CParamList that contains methods for traversing the elements
    of XML file that contains the parameters required by the search engine. A sample parameter list
    (also known as config file) XML file if shown here -

    <?xml version="1.0" encoding="UTF-8"?>
    <CONFIG_DATA

        SERVER_URL              =   "http://gsadevnet/GSASearch/search.asmx/Search"
        REMOTECONFIG_SERVER_URL =   "http://gsadevnet/GSASearch/search.asmx/"
        UPDATE_FREQUENCY        =   "3">

        <PARAM_ITEM NAME="ProdID" TYPE="CONFIG_DATA">

            <DESCRIPTION>Choose one of the following products:</DESCRIPTION>
            <PARAM_VALUE VALUE="enable">
                <DISPLAYSTRING>Accessibility</DISPLAYSTRING>
            </PARAM_VALUE>

            <PARAM_VALUE VALUE="drx" DEFAULT="true">
                <DISPLAYSTRING>DirectX (Home User)</DISPLAYSTRING>
            </PARAM_VALUE>

        </PARAM_ITEM>

    </CONFIG_DATA>

Revision History:
    a-prakac    created     12/05/2000

********************************************************************/


#include "stdafx.h"

static const WCHAR g_wszMutexName[] = L"PCH_PARAMCONFIG";

/////////////////////////////////////////////////////////////////////

CFG_BEGIN_FIELDS_MAP(CParamList::CParamValue)
    CFG_ATTRIBUTE( L"VALUE"        , BSTR, m_bstrValue         ),
    CFG_ELEMENT  ( L"DISPLAYSTRING", BSTR, m_bstrDisplayString ),
    CFG_ATTRIBUTE( L"DEFAULT"      , bool, m_bDefault          ),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(CParamList::CParamValue)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(CParamList::CParamValue, L"PARAM_VALUE")

DEFINE_CONFIG_METHODS__NOCHILD(CParamList::CParamValue)

/////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////

CFG_BEGIN_FIELDS_MAP(CParamList::CParamItem)
    CFG_ATTRIBUTE( L"NAME"       , BSTR, m_bstrName        ),
    CFG_ATTRIBUTE( L"TYPE"       , BSTR, m_bstrType        ),
    CFG_ELEMENT  ( L"DESCRIPTION", BSTR, m_bstrDescription ),
    CFG_ATTRIBUTE( L"REQUIRED"   , bool, m_bRequired       ),
    CFG_ATTRIBUTE( L"VISIBLE"    , bool, m_bVisible        ),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(CParamList::CParamItem)
    CFG_CHILD(CParamList::CParamValue)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(CParamList::CParamItem, L"PARAM_ITEM")

DEFINE_CONFIG_METHODS_CREATEINSTANCE_SECTION(CParamList::CParamItem,tag,defSubType)
    if(tag == _cfg_table_tags[0])
    {
        defSubType = &(*(m_lstParamValue.insert( m_lstParamValue.end() )));
        return S_OK;
    }
DEFINE_CONFIG_METHODS_SAVENODE_SECTION(CParamList::CParamItem,xdn)
    hr = MPC::Config::SaveList( m_lstParamValue, xdn );
DEFINE_CONFIG_METHODS_END(CParamList::CParamItem)

/////////////////////////////////////////////////////////////////////

CFG_BEGIN_FIELDS_MAP(CParamList)
    CFG_ATTRIBUTE          ( L"SERVER_URL"              , BSTR, m_bstrServerURL                                          ),
    CFG_ELEMENT            ( L"SEARCHENGINE_NAME"       , BSTR, m_bstrSearchEngineName                                   ),
    CFG_ELEMENT            ( L"SEARCHENGINE_DESCRIPTION", BSTR, m_bstrSearchEngineDescription                            ),
    CFG_ELEMENT            ( L"SEARCHENGINE_OWNER"      , BSTR, m_bstrSearchEngineOwner                                  ),
    CFG_ATTRIBUTE          ( L"UPDATE_FREQUENCY"        , long, m_lUpdateFrequency                                       ),
    CFG_ATTRIBUTE__TRISTATE( L"REMOTECONFIG_SERVER_URL" , BSTR, m_bstrRemoteConfigServerURL  , m_bRemoteServerUrlPresent ),
    CFG_ATTRIBUTE__TRISTATE( L"ERROR_INFO"              , BSTR, m_bstrErrorInfo              , m_bError                  ),
    CFG_ATTRIBUTE__TRISTATE( L"STANDARD_SEARCH"         , bool, m_bStandardSearch            , m_bSearchTypePresent      ),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(CParamList)
    CFG_CHILD(CParamList::CParamItem)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(CParamList, L"CONFIG_DATA")

DEFINE_CONFIG_METHODS_CREATEINSTANCE_SECTION(CParamList,tag,defSubType)
    if(tag == _cfg_table_tags[0])
    {
        defSubType = &(*(m_lstParamItem.insert( m_lstParamItem.end() )));
        return S_OK;
    }
DEFINE_CONFIG_METHODS_SAVENODE_SECTION(CParamList,xdn)
    hr = MPC::Config::SaveList( m_lstParamItem, xdn );
DEFINE_CONFIG_METHODS_END(CParamList)

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

bool CParamList::CParamItem::FindDefaultValue( /*[out]*/ ParamValueIter& it )
{
	for(it = m_lstParamValue.begin(); it != m_lstParamValue.end(); it++)
	{
		if(it->m_bDefault == true) return true;
	}

	return false;
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

// Commenting out MPC:: is a workaround for a compiler bug.
CParamList::CParamList() : /*MPC::*/NamedMutex( g_wszMutexName )
{
    // Initialize the Update Frequency to -1 so that in case the server hasnt provided an update frequency
    // then the default frequency can be used instead
    m_lUpdateFrequency = -1;
    m_bStandardSearch = true;
}

CParamList::~CParamList()
{
}

bool CParamList::IsStandardSearch()
{
    return (m_bSearchTypePresent ? m_bStandardSearch : true);
}

/************

Method - CParamList::Load(BSTR bstrConfigFilePath)

Description - This method loads the XML file (whose location is given bstrConfigFilePath)
into a list and sets the iterator of the list to the first element in the list. It then loads the XML file
into a DOM tree and retrieves a collection of nodes with tag name PARAM_ITEM.

************/

HRESULT CParamList::Load( /*[in]*/ BSTR bstrLCID, /*[in]*/ BSTR bstrID, /*[in]*/ BSTR bstrXMLConfigData )
{
    __HCP_FUNC_ENTRY( "CParamList::Load" );

    HRESULT              hr;
    bool                 fLoaded;
    bool                 fFound;
    MPC::XmlUtil         xmlConfigData;
    CComPtr<IStream>     pStream;
    MPC::wstring         strFileName;
    CComPtr<IXMLDOMNode> ptrDOMNode;
    CComBSTR             bstrXML;


    //
    // First try to load the file from the user setting path - if that fails then load the ConfigData
    // The file, if present, is located in user settings directory and is named bstrID_bstrLCID.xml
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetUserWritablePath( strFileName, HC_ROOT_HELPCTR ));
    m_bstrConfigFilePath.Append( strFileName.c_str() );
    m_bstrConfigFilePath.Append( L"\\"               );
    m_bstrConfigFilePath.Append( bstrID              );
    m_bstrConfigFilePath.Append( L"_"                );
    m_bstrConfigFilePath.Append( bstrLCID            );
    m_bstrConfigFilePath.Append( L".xml"             );

    __MPC_EXIT_IF_METHOD_FAILS(hr, xmlConfigData.Load( m_bstrConfigFilePath, NSW_TAG_CONFIGDATA, fLoaded, &fFound ));
    if(!fFound)
    {
        // The file could not be loaded for some reason - try loading the package_description.xml data
        __MPC_EXIT_IF_METHOD_FAILS(hr, xmlConfigData.LoadAsString( bstrXMLConfigData, NSW_TAG_DATA, fLoaded, &fFound ));
        if(!fFound)
        {
            // Even if this cant be loaded then exit
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }

        // Now load the CONFIG_DATA section
        __MPC_EXIT_IF_METHOD_FAILS(hr, xmlConfigData.GetNode( NSW_TAG_CONFIGDATA, &ptrDOMNode ) );
        __MPC_EXIT_IF_METHOD_FAILS(hr, ptrDOMNode->get_xml( &bstrXML ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, xmlConfigData.LoadAsString( bstrXML, NSW_TAG_CONFIGDATA, fLoaded, &fFound ));
        if(!fFound)
        {
            // Cant be loaded - exit
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }

    }

    // At this point the XML data has been loaded
    __MPC_EXIT_IF_METHOD_FAILS(hr, xmlConfigData.SaveAsStream( (IUnknown**)&pStream ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::Config::LoadStream   ( this,        pStream ));

	//
	// For each parameter, copy the XML blob.
	//
	{
		CComPtr<IXMLDOMNodeList> xdnl;
		CComPtr<IXMLDOMNode>     xdn;

		__MPC_EXIT_IF_METHOD_FAILS(hr, xmlConfigData.GetNodes( NSW_TAG_PARAMITEM, &xdnl ));
		if(xdnl)
		{
			for(ParamItemIter it = m_lstParamItem.begin(); it != m_lstParamItem.end() && SUCCEEDED(xdnl->nextNode( &xdn )) && xdn; it++, xdn.Release())
			{
				__MPC_EXIT_IF_METHOD_FAILS(hr, xdn->get_xml( &it->m_bstrXML ));
			}
		}
	}

    __MPC_EXIT_IF_METHOD_FAILS(hr, MoveFirst());

    hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

/************

Method - CParamList::IsCursorValid(), MoveFirst(), MoveNext()

Description - These methods are used to traverse the list that contains the various XML elements of the
loaded file.

************/

HRESULT CParamList::ClearResults()
{
    __HCP_FUNC_ENTRY( "CParamList::ClearResult" );

    m_lstParamItem.clear();

    return S_OK;
}

bool CParamList::IsCursorValid()
{
    return (m_itCurrentParam != m_lstParamItem.end());
}

HRESULT CParamList::MoveFirst()
{
    m_itCurrentParam = m_lstParamItem.begin();

    return S_OK;
}

HRESULT CParamList::MoveNext()
{
    if(IsCursorValid())
    {
        m_itCurrentParam++;
    }

    return S_OK;
}

/************

Method - CParamList::get_Name, get_ServerUrl, get_ConfigFilePath, get_Type

Description - Properties for getting the corresponding items.

************/

HRESULT CParamList::get_Name( /*[out]*/ CComBSTR& bstrName )
{
    if(IsCursorValid()) bstrName = m_itCurrentParam->m_bstrName;

    return S_OK;
}

HRESULT CParamList::get_ServerUrl( /*[out]*/ CComBSTR& bstrServerURL )
{
    bstrServerURL = m_bstrServerURL;

    return S_OK;
}

HRESULT CParamList::get_RemoteServerUrl( /*[out]*/ CComBSTR& bstrRemoteServerURL )
{
    bstrRemoteServerURL = m_bstrRemoteConfigServerURL;

    return S_OK;
}

bool CParamList::RemoteConfig()
{
    return m_bRemoteServerUrlPresent;
}

HRESULT CParamList::get_UpdateFrequency( /*[out]*/ long& lUpdateFrequency )
{
    lUpdateFrequency = m_lUpdateFrequency;
    return S_OK;
}

HRESULT CParamList::get_SearchEngineName(/*[out]*/ CComBSTR& bstrSEName )
{
    bstrSEName = m_bstrSearchEngineName;

    return S_OK;
}

HRESULT CParamList::get_SearchEngineDescription( /*[out]*/CComBSTR& bstrSEDescription )
{
    bstrSEDescription = m_bstrSearchEngineDescription;

    return S_OK;
}

HRESULT CParamList::get_SearchEngineOwner( /*[out]*/ CComBSTR& bstrSEOwner )
{
    bstrSEOwner = m_bstrSearchEngineOwner;

    return S_OK;
}

HRESULT CParamList::get_ConfigFilePath( /*[out]*/CComBSTR& bstrFilePath )
{
    bstrFilePath = m_bstrConfigFilePath;

    return S_OK;
}

HRESULT CParamList::get_Type( /*[in]*/ BSTR bstrType, /*[out]*/ ParamTypeEnum& enmParamType)
{
    if     (MPC::StrICmp( bstrType, L"PARAM_UI1"  ) == 0) enmParamType = PARAM_UI1;
    else if(MPC::StrICmp( bstrType, L"PARAM_I2"   ) == 0) enmParamType = PARAM_I2;
    else if(MPC::StrICmp( bstrType, L"PARAM_I4"	  ) == 0) enmParamType = PARAM_I4;
    else if(MPC::StrICmp( bstrType, L"PARAM_R4"	  ) == 0) enmParamType = PARAM_R4;
    else if(MPC::StrICmp( bstrType, L"PARAM_R8"	  ) == 0) enmParamType = PARAM_R8;
    else if(MPC::StrICmp( bstrType, L"PARAM_BOOL" ) == 0) enmParamType = PARAM_BOOL;
    else if(MPC::StrICmp( bstrType, L"PARAM_DATE" ) == 0) enmParamType = PARAM_DATE;
    else if(MPC::StrICmp( bstrType, L"PARAM_BSTR" ) == 0) enmParamType = PARAM_BSTR;
    else if(MPC::StrICmp( bstrType, L"PARAM_I1"   ) == 0) enmParamType = PARAM_I1;
    else if(MPC::StrICmp( bstrType, L"PARAM_UI2"  ) == 0) enmParamType = PARAM_UI2;
    else if(MPC::StrICmp( bstrType, L"PARAM_UI4"  ) == 0) enmParamType = PARAM_UI4;
    else if(MPC::StrICmp( bstrType, L"PARAM_INT"  ) == 0) enmParamType = PARAM_INT;
    else if(MPC::StrICmp( bstrType, L"PARAM_UINT" ) == 0) enmParamType = PARAM_UINT;
    else if(MPC::StrICmp( bstrType, L"PARAM_LIST" ) == 0) enmParamType = PARAM_LIST;

    return S_OK;
}

/************

Method - CParamList::InitializeParamObject( SearchEngine::ParamItem_Definition2& def )

Description - This method is called to initialize a parameter item object. Initializes
with the current parameter item.

************/
HRESULT CParamList::InitializeParamObject( /*[out]*/ SearchEngine::ParamItem_Definition2& def )
{
    __HCP_FUNC_ENTRY( "CParamList::InitializeParamObject" );

    HRESULT hr;

	if(IsCursorValid())
	{
		CParamItem& item     = *m_itCurrentParam;
		BSTR        bstrData = NULL;

		__MPC_EXIT_IF_METHOD_FAILS(hr, get_Type( item.m_bstrType, def.m_pteParamType ));

		if(def.m_pteParamType == PARAM_LIST)
		{
			bstrData = item.m_bstrXML;
		}
		else
		{
			ParamValueIter itValue;

			if(m_itCurrentParam->FindDefaultValue( itValue ))
			{
				bstrData = itValue->m_bstrValue;
			}
		}

		if(item.m_bstrName       .Length()) { def.m_strName          = item.m_bstrName       ; def.m_szName          = def.m_strName         .c_str(); }
		if(item.m_bstrDescription.Length()) { def.m_strDisplayString = item.m_bstrDescription; def.m_szDisplayString = def.m_strDisplayString.c_str(); }
		if(STRINGISPRESENT(bstrData)      ) { def.m_strData          =        bstrData       ; def.m_szData          = def.m_strData         .c_str(); }

		def.m_bRequired = item.m_bRequired;
		def.m_bVisible  = item.m_bVisible;
	}

    hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

/************

Method - CParamList::GetDefaultValue (CComBSTR bstrParamName, MPC::wstring& wszValue)

Description - This method is called to get the default value for a parameter.

************/
HRESULT CParamList::GetDefaultValue( /*[in]*/ BSTR bstrParamName, /*[in,out]*/ MPC::wstring& strValue )
{
    __HCP_FUNC_ENTRY("CParamList::GetDefaultValue");

    HRESULT hr;

    __MPC_EXIT_IF_METHOD_FAILS(hr, MoveFirst());
    while(IsCursorValid())
    {
        if(MPC::StrCmp( m_itCurrentParam->m_bstrName, bstrParamName ) == 0)
        {
			ParamValueIter itValue;

			if(m_itCurrentParam->FindDefaultValue( itValue ))
			{
				strValue = SAFEBSTR(itValue->m_bstrValue);
            }

            break;
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, MoveNext());
    }

    hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\netsearchwrapper\netsearchconfig.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    NetSearchConfig.cpp

Abstract:
    Implements the class CSearchResultList that contains methods for traversing the elements
    of XML file that contains the results returned by a search engine. A sample results XML file
    if shown here -

    <ResultList xmlns="x-schema:ResultListSchema1.xdr">
        <ResultItem
            Title="What if I've upgraded from Windows 95 to Windows 98?"
            URI="http://gsadevnet/support/windows/InProductHelp98/lic_keep_old_copy.asp"
            ContentType="7"
            Rank="96"
            Description="Online version of our in-product help."
            DateLastModified="08/04/1999 19:48:10" />
    </ResultList>

Revision History:
    a-prakac    created     10/24/200

********************************************************************/

#include "stdafx.h"

static const WCHAR g_wszMutexName     [] = L"PCH_SEARCHRESULTSCONFIG";

/////////////////////////////////////////////////////////////////////

CFG_BEGIN_FIELDS_MAP(CSearchResultList::CSearchItem)
	CFG_VALUE( wstring,	m_strSearchItem	),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(CSearchResultList::CSearchItem)
CFG_END_CHILD_MAP()

//DEFINE_CFG_OBJECT(CSearchResultList::CSearchItem,L"SearchItem")
DEFINE_CFG_OBJECT(CSearchResultList::CSearchItem,L"SearchTerm")

DEFINE_CONFIG_METHODS__NOCHILD(CSearchResultList::CSearchItem)

/////////////////////////////////////////////////////////////////////

CFG_BEGIN_FIELDS_MAP(CSearchResultList::CResultItem)
    CFG_ATTRIBUTE( L"Title"           , BSTR  , m_data.m_bstrTitle         ),
    CFG_ATTRIBUTE( L"URI"             , BSTR  , m_data.m_bstrURI           ),
    CFG_ATTRIBUTE( L"ContentType"     , long  , m_data.m_lContentType      ),
    CFG_ATTRIBUTE( L"Rank"            , double, m_data.m_dRank             ),
    CFG_ATTRIBUTE( L"Description"     , BSTR  , m_data.m_bstrDescription   ),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(CSearchResultList::CResultItem)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(CSearchResultList::CResultItem,L"ResultItem")

DEFINE_CONFIG_METHODS__NOCHILD(CSearchResultList::CResultItem)

/////////////////////////////////////////////////////////////////////

CFG_BEGIN_FIELDS_MAP(CSearchResultList)
    CFG_ELEMENT(L"PrevQuery", BSTR, m_bstrPrevQuery),      
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(CSearchResultList)
    CFG_CHILD(CSearchResultList::CSearchItem)
    CFG_CHILD(CSearchResultList::CResultItem)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(CSearchResultList, L"ResultList")

DEFINE_CONFIG_METHODS_CREATEINSTANCE_SECTION(CSearchResultList,tag,defSubType)
    if(tag == _cfg_table_tags[0])
    {
        defSubType = &(*(m_lstSearchItem.insert( m_lstSearchItem.end() )));
        return S_OK;
    }

    if(tag == _cfg_table_tags[1])
    {
        defSubType = &(*(m_lstResult.insert( m_lstResult.end() )));
        return S_OK;
    }
DEFINE_CONFIG_METHODS_SAVENODE_SECTION(CSearchResultList,xdn)
	hr = MPC::Config::SaveList( m_lstSearchItem, xdn );
    hr = MPC::Config::SaveList( m_lstResult, xdn );
DEFINE_CONFIG_METHODS_END(CSearchResultList)

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

// Commenting out MPC:: is a workaround for a compiler bug.
CSearchResultList::CSearchResultList() : /*MPC::*/NamedMutex( g_wszMutexName )
{
}

CSearchResultList::~CSearchResultList()
{
}

/************

Method - CSearchResultList::LoadResults(IStream* pStream)

Description - This method loads the XML file (passed thro the IStream pointer) into a list and sets
the iterator of the list to the first element in the list.

************/

HRESULT CSearchResultList::LoadResults( /*[in]*/IStream* pStream )
{
    __HCP_FUNC_ENTRY( "CSearchResultList::LoadConfiguration" );

    HRESULT hr;

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::Config::LoadStream( this, pStream ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MoveFirst());

    hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

HRESULT CSearchResultList::ClearResults()
{
    __HCP_FUNC_ENTRY( "CSearchResultList::ClearResult" );

    m_lstResult.clear();

    return S_OK;
}

/************

Method - CSearchResultList::IsCursorValid(), MoveFirst(), MoveNext()

Description - These methods are used to traverse the list that contains the various XML elements of the
loaded file.

************/

bool CSearchResultList::IsCursorValid()
{
    return (m_itCurrentResult != m_lstResult.end());
}

HRESULT CSearchResultList::MoveFirst()
{
    m_itCurrentResult = m_lstResult.begin();

    return S_OK;
}

HRESULT CSearchResultList::MoveNext()
{
    if(IsCursorValid())
    {
        m_itCurrentResult++;
    }

    return S_OK;
}

/************

Method - CSearchResultList::InitializeResultObject(SearchEngine::ResultItem *pRIObj)

Description - This method is called by CNetSW::Results() to initialize a result item object. Initializes
with the current result item.

************/

HRESULT CSearchResultList::InitializeResultObject( /*[out]*/ SearchEngine::ResultItem* pRIObj )
{
    if(IsCursorValid()) pRIObj->Data() = m_itCurrentResult->m_data;

    return S_OK;
}

/************

Method - CSearchResultList::SetResultItemIterator(long lIndex)

Description - This method returns sets the iterator to the index passed in. This method is called from
CNetSW::Results() when retrieving results from lStart to lEnd. If index passed in is invalid then returns E_FAIL.

************/

HRESULT CSearchResultList::SetResultItemIterator( /*[in]*/long lIndex )
{
    if((lIndex < 0) || (lIndex > m_lstResult.size())) return E_FAIL;

	MoveFirst();

    std::advance( m_itCurrentResult, (int)lIndex );

    return S_OK;
}

/************

Method - CSearchResultList::GetSearchTerms(MPC::WStringList& strList)

Description - This method returns a list of all the search terms
************/

HRESULT CSearchResultList::GetSearchTerms( /*[in, out]*/ MPC::WStringList& strList )
{
	SearchIter   it;       		

	it = m_lstSearchItem.begin();
		
	while(it != m_lstSearchItem.end())
	{
		strList.insert( strList.end(), it->m_strSearchItem );
		it++;
	}
	
	return S_OK;
}

/************

Method - CSearchResultList::get_PrevQuery()

Description - This method returns the value of the attribute PREV_QUERY - currently this is used
only the PSS search engine to send back the processed query. Used for "Search within results".
************/

CComBSTR& CSearchResultList::PrevQuery()
{
    return m_bstrPrevQuery;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\netsearchwrapper\netsw.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    NetSW.cpp

Abstract:
    Implements the class SearchEngine::WrapperNetSearch that contains methods for executing
    the search query and returning the results back to the UI. Also
    contains methods for dynamic update of parameter list and dynamic
    generation of parameters.

Revision History:
    a-prakac          created     10/24/2000

********************************************************************/


#include    "stdafx.h"
#include    <Utility.h>

/////////////////////////////////////////////////////////////////////////////
// SearchEngine::WrapperNetSearch : IPCHSEWrapperItem

SearchEngine::WrapperNetSearch::WrapperNetSearch()
{
                             // CParamList        m_ParamList;
                             // CSearchResultList m_resConfig;
                             // MPC::XmlUtil      m_xmlQuery;
                             // CComBSTR          m_bstrLCID;
                             // CComBSTR          m_bstrSKU;
    m_bOfflineError = false; // bool              m_bOfflineError;
                             // CComBSTR          m_bstrPrevQuery;
}

SearchEngine::WrapperNetSearch::~WrapperNetSearch()
{
	AbortQuery();

	Thread_Wait();
}

/************

Method - SearchEngine::WrapperNetSearch::Result( long lStart, long lEnd, IPCHCollection** ppC )

Description - This method returns items from lStart to lEnd. If there are else then (lEnd - lStart)
items then only those many are returned. If an error had occured during results retrieval then the
error info is returned as a result item (CONTENTTYPE_ERROR).

************/

STDMETHODIMP SearchEngine::WrapperNetSearch::Result( /*[in]*/ long lStart, /*[in]*/ long lEnd, /*[out, retval]*/ IPCHCollection** ppC )
{
    __HCP_FUNC_ENTRY( "SearchEngine::WrapperNetSearch::Result" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    CComPtr<CPCHCollection>      pColl;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(ppC, NULL);
    __MPC_PARAMCHECK_END();


    //
    // Create the collection object and fill it with result items
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pColl ));

    if(m_bEnabled)
    {
        long lIndex = lStart;

        // Check for retrieval errors
        if(m_bOfflineError)
        {
            CComPtr<SearchEngine::ResultItem> pRIObj;

            //
            // Create the result item, initialize it, and add it to the collection
            //
            __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pRIObj ));

            {
                ResultItem_Data& data = pRIObj->Data();

                data.m_lContentType    = CONTENTTYPE_ERROR_OFFLINE;
            }

            __MPC_EXIT_IF_METHOD_FAILS(hr, pColl->AddItem( pRIObj ));
        }
        else
        {
            //
            // Return only m_lNumResult number of results
            //
            if(lEnd > m_lNumResult) lEnd = m_lNumResult;

            //
            // The results have already been loaded in m_resConfig - populate the pRIObj using this.
            // SetResultItemIterator returns E_FAIL if lIndex is out of range
            //
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_resConfig.SetResultItemIterator( lIndex ));

            while((lIndex++ < lEnd) && (m_resConfig.IsCursorValid()))
            {
                CComPtr<SearchEngine::ResultItem> pRIObj;

                //
                // Create the result item, initialize it, and add it to the collection
                //
                __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pRIObj ));

                __MPC_EXIT_IF_METHOD_FAILS(hr, m_resConfig.InitializeResultObject( pRIObj ));

                __MPC_EXIT_IF_METHOD_FAILS(hr, pColl->AddItem( pRIObj ));

                m_resConfig.MoveNext();
            }
        }
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, pColl.QueryInterface( ppC ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


/////////////////////////////////////////////////////////////////////////////
// SearchEngine::WrapperNetSearch : IPCHSEWrapperInternal

STDMETHODIMP SearchEngine::WrapperNetSearch::AbortQuery()
{
	m_xmlQuery       .Abort();
	m_objRemoteConfig.Abort();

    Thread_Abort();

    return S_OK;
}

/************

Method - SearchEngine::WrapperNetSearch::ExecQuery()

Description - This method calls the search engine (webservice) URL to execute the user typed query and
retrieve the results. The parameters required for the query for read from the parameter list file - except
for the "QueryString" parameter which is hardcoded. The retrieved results are loaded using CSearchResultList
and checked for errors.

************/

HRESULT SearchEngine::WrapperNetSearch::ExecQuery()
{
    __HCP_FUNC_ENTRY( "SearchEngine::WrapperNetSearch::ExecQuery" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    MPC::wstring                 wszQuery;
    MPC::URL                     urlQuery;
    CComBSTR                     bstrParam;
    bool                         fLoaded;
    bool                         fFound;
    WCHAR                        wszNumResult[20];

    try
    {
        if(m_bEnabled)
        {
            m_bOfflineError = false;

            //
            // Check to see if the network is alive
            //
            {
                VARIANT_BOOL vtNetwork;

                if(FAILED(m_pSEMgr->IsNetworkAlive( &vtNetwork )) || vtNetwork == VARIANT_FALSE)
                {
                    // If the user is not online then set the error and exit
                    m_bOfflineError = true;

                    __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
                }

				if(Thread_IsAborted()) __MPC_SET_ERROR_AND_EXIT(hr, E_ABORT);
            }


            //
            // If Remote Configuration (dynamic update of parameters) is required then create another thread
            // to fetch the updated list of parameters
            //
            if(m_ParamList.RemoteConfig())
            {
                CComBSTR bstrRemoteServerUrl;
                CComBSTR bstrConfigFilePath;
                long     lUpdateFrequency;

                //
                // Get the remote server url, config file path and get the updated config file
                //
                m_ParamList.get_RemoteServerUrl( bstrRemoteServerUrl );
                m_ParamList.get_ConfigFilePath ( bstrConfigFilePath  );
                m_ParamList.get_UpdateFrequency( lUpdateFrequency    );

				if(Thread_IsAborted()) __MPC_SET_ERROR_AND_EXIT(hr, E_ABORT);

                __MPC_EXIT_IF_METHOD_FAILS(hr, m_objRemoteConfig.RetrieveList( bstrRemoteServerUrl, m_bstrLCID, m_bstrSKU, bstrConfigFilePath, lUpdateFrequency ) );
            }


            //
            // Clear the contents of the results of the old query before proceeding
            //
            m_resConfig.ClearResults();

            //
            // Get the parameters to form the query string - note that MPC::URL checks to see if the URL is in right format
            //
            {
                CComBSTR bstrQuery;

                __MPC_EXIT_IF_METHOD_FAILS(hr, m_ParamList.get_ServerUrl( bstrQuery ));
                __MPC_EXIT_IF_METHOD_FAILS(hr, urlQuery.put_URL         ( bstrQuery ));
            }

            //
            // Read the configuration XML file to get the parameter names
            //

            // Add the other 'hardcoded' parameters
            _ltow(m_lNumResult, wszNumResult, 10);


            // If not a standard search then add the PrevQuery parameter
            if(!m_ParamList.IsStandardSearch())
            {
                // If this is a search within results then change the value of QueryString and retain PrevQuery value
                CComVariant vValue;
                if((SUCCEEDED(GetParam( NSW_PARAM_SUBQUERY, &vValue ))) && (vValue.vt == VT_BOOL) && (vValue.boolVal == VARIANT_TRUE))
                {
                    if((SUCCEEDED(GetParam( NSW_PARAM_CURRENTQUERY, &vValue ))) && (vValue.vt == VT_BSTR))
                    {
                        m_bstrQueryString = SAFEBSTR(vValue.bstrVal);
                    }
                }
                else
                {
                    // If not a subquery then discard the contents of the old PrevQuery
                    m_bstrPrevQuery.Empty();
                }

                __MPC_EXIT_IF_METHOD_FAILS(hr, urlQuery.AppendQueryParameter( NSW_PARAM_PREVQUERY, SAFEBSTR(m_bstrPrevQuery) ));
            }

            __MPC_EXIT_IF_METHOD_FAILS(hr, urlQuery.AppendQueryParameter( NSW_PARAM_QUERYSTRING, m_bstrQueryString ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, urlQuery.AppendQueryParameter( NSW_PARAM_LCID       , m_bstrLCID        ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, urlQuery.AppendQueryParameter( NSW_PARAM_SKU        , m_bstrSKU         ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, urlQuery.AppendQueryParameter( NSW_PARAM_MAXRESULTS , wszNumResult      ));


            m_ParamList.MoveFirst();
            while(m_ParamList.IsCursorValid())
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, m_ParamList.get_Name( bstrParam ));

                __MPC_EXIT_IF_METHOD_FAILS(hr, AppendParameter( bstrParam, urlQuery ));

                m_ParamList.MoveNext();
            }

            __MPC_EXIT_IF_METHOD_FAILS(hr, urlQuery.get_URL( wszQuery ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlQuery.SetTimeout( NSW_TIMEOUT_QUERY ));

			if(Thread_IsAborted()) __MPC_SET_ERROR_AND_EXIT(hr, E_ABORT);

            __MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlQuery.Load( wszQuery.c_str(), NULL, fLoaded, &fFound ));
            if(fLoaded)
            {
                CComPtr<IXMLDOMNode> xdn;
                CComBSTR             bstrName;

                // Check to see if the root node is "ResultList" or "string"
                __MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlQuery.GetRoot( &xdn      ));
                __MPC_EXIT_IF_METHOD_FAILS(hr, xdn->get_nodeName ( &bstrName ));

                // If it is a webservice, then the root node returned is "string". In this case, get the value of
                // this node
                if(MPC::StrCmp( bstrName, NSW_TAG_STRING ) == 0)
                {
                    CComVariant vVar;

                    __MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlQuery.GetValue( NULL, vVar, fFound, NULL ));

                    __MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlQuery.LoadAsString( vVar.bstrVal, NSW_TAG_RESULTLIST, fLoaded, &fFound ));
                    if(!fLoaded)
                    {
                        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
                    }
                }

                // If not the results were retrieved succesfully - load it
                {
                    CComPtr<IStream> stream;

                    __MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlQuery.SaveAsStream( (IUnknown**)&stream ));

                    __MPC_EXIT_IF_METHOD_FAILS(hr, m_resConfig.LoadResults( stream ));

                    m_bstrPrevQuery = m_resConfig.PrevQuery();
                }
            }
        }
    }
    catch(...)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    hr = m_pSEMgr->WrapperComplete( hr, this );

    Thread_Abort();

    __HCP_FUNC_EXIT(hr);
}

/************

Method - SearchEngine::WrapperNetSearch::AppendQueryParameter(CComBSTR bstrParam, MPC::URL& urlQueryString )

Description - Small routine that gets the parameter value for the parameter passed in (NULL if it
could not be retrieved) and then calls the MPC::URL's AppendQueryParameter to append the parameter
and its value to the URL.

************/

HRESULT SearchEngine::WrapperNetSearch::AppendParameter (/*[in]*/ BSTR bstrParam, /*[in, out]*/ MPC::URL& urlQueryString )
{
    __HCP_FUNC_ENTRY( "SearchEngine::WrapperNetSearch::AppendParameter " );

    HRESULT      hr;
    CComVariant  vValue;
    MPC::wstring wszParamValue;


    // GetParam fetches the value if the user has changed it - else get the default value
    if(SUCCEEDED(GetParam( bstrParam, &vValue )))
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, ::VariantChangeType( &vValue, &vValue, VARIANT_ALPHABOOL, VT_BSTR ));

        wszParamValue = SAFEBSTR( vValue.bstrVal );
    }
    else
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_ParamList.GetDefaultValue( bstrParam, wszParamValue ));
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, urlQueryString.AppendQueryParameter( bstrParam, wszParamValue.c_str() ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

/************

Method - SearchEngine::WrapperNetSearch::ExecAsyncQuery()

Description - This method is called by the Search Engine Manager to execute the query. Here a seperate thread
is spun off to execute the query and retrieve the results. After this, it checks to if the remote configuration
is enabled (dynamic update of parameter list) and if it then another thread is spun off to retrieve the updated list.

************/

STDMETHODIMP SearchEngine::WrapperNetSearch::ExecAsyncQuery()
{
    __HCP_FUNC_ENTRY( "SearchEngine::WrapperNetSearch::ExecAsyncQuery" );

    HRESULT hr;


    //
    // Create a thread to execute the query and fetch the results
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, Thread_Start( this, ExecQuery, NULL ) );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

/************

Method - SearchEngine::WrapperNetSearch::Initialize( BSTR bstrID, BSTR bstrSKU, long lLCID, BSTR bstrData )

Description - This method is called by the Search Engine Manager to initialize the wrapper. ID is the id of
this instance of the NetSearch Wrapper, SKU is ignored, and bstrData is data provided during the registration
process. Data is an XML file that should contain the location of the config file path, the name and description
of the Search Engine, the owner and finally the LCID. This method loads this data and also loads the config file.

************/

STDMETHODIMP SearchEngine::WrapperNetSearch::Initialize( /*[in]*/ BSTR bstrID, /*[in]*/ BSTR bstrSKU, /*[in]*/ long lLCID, /*[in]*/ BSTR bstrData )
{
    __HCP_FUNC_ENTRY( "SearchEngine::WrapperNetSearch::Initialize" );

    HRESULT  hr;
    WCHAR    wstrLCID[20];
    CComBSTR bstrConfigFilePath;

    // Initialize the ID, LCID, and SKU member variables
    m_bstrID = bstrID;

    _ltow(lLCID, wstrLCID, 10);
    m_bstrLCID = wstrLCID;

    m_bstrSKU = bstrSKU;

    // Load the rest of the configuration data
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_ParamList.Load( m_bstrLCID, bstrID, bstrData ));

    m_ParamList.get_SearchEngineName       ( m_bstrName        );
    m_ParamList.get_SearchEngineOwner      ( m_bstrOwner       );
    m_ParamList.get_SearchEngineDescription( m_bstrDescription );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP SearchEngine::WrapperNetSearch::get_SearchTerms( /*[out, retval]*/ VARIANT *pvTerms )
{
    __HCP_FUNC_ENTRY( "SearchEngine::WrapperNetSearch::get_SearchTerms" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    MPC::WStringList             strList;


    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pvTerms);
    __MPC_PARAMCHECK_END();


    // Get all the search terms
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_resConfig.GetSearchTerms( strList ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertListToSafeArray( strList, *pvTerms, VT_BSTR ));

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT SearchEngine::WrapperNetSearch::CreateListOfParams( /*[in]*/ CPCHCollection* coll )
{
    __HCP_FUNC_ENTRY( "SearchEngine::WrapperNetSearch::CreateListOfParams" );

    HRESULT hr;

    m_ParamList.MoveFirst();
    while(m_ParamList.IsCursorValid())
    {
        ParamItem_Definition2 def;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_ParamList.InitializeParamObject( def ) );

        __MPC_EXIT_IF_METHOD_FAILS(hr, CreateParam( coll, &def ));

        m_ParamList.MoveNext();
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\netsearchwrapper\paramconfig.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    ParamConfig.h

Abstract:
    Implements the class CParamList that contains methods for traversing the elements
    of XML file that contains the parameters required by the search engine. A sample parameter list
    (also known as config file) XML file if shown here -

    <?xml version="1.0" encoding="UTF-8"?>
    <PARAM_LIST

        SERVER_URL              =   "http://gsadevnet/GSASearch/search.asmx/Search"
        REMOTECONFIG_SERVER_URL =   "http://gsadevnet/GSASearch/search.asmx/"
        UPDATE_FREQUENCY        =   "3">

        <PARAM_ITEM NAME="ProdID" TYPE="PARAM_LIST">

            <DESCRIPTION>Choose one of the following products:</DESCRIPTION>
            <PARAM_VALUE VALUE="enable">
                <DISPLAYSTRING>Accessibility</DISPLAYSTRING>
            </PARAM_VALUE>

            <PARAM_VALUE VALUE="drx" DEFAULT="true">
                <DISPLAYSTRING>DirectX (Home User)</DISPLAYSTRING>
            </PARAM_VALUE>

        </PARAM_ITEM>

    </PARAM_LIST>

Revision History:
    a-prakac    created     12/05/2000

********************************************************************/

#if !defined(__INCLUDED___PCH___SELIB_PARAMCONFIG_H___)
#define __INCLUDED___PCH___SELIB_PARAMCONFIG_H___

#include <SearchEngineLib.h>
#include <MPC_config.h>

class CParamList :
    public MPC::Config::TypeConstructor,
    public MPC::NamedMutex
{
    class CParamValue : public MPC::Config::TypeConstructor
    {
        DECLARE_CONFIG_MAP(CParamValue);

    public:
        //
        // m_bstrValue          -   The value to be passed to the wrapper when
        //                          this item is selected (used in case of PARAM_LIST)
        // m_bstrDisplayString  -   The display string that needs to be displayed
        //                          on UI (used in case of PARAM_LIST)
        // m _bDefault          -   Bool value that denotes if this is the default value to shown
        //                          in the case PARAM_LIST. This value will show up first in the drop down list.
        //
        CComBSTR    m_bstrValue;
        CComBSTR    m_bstrDisplayString;
        bool        m_bDefault;

        ////////////////////////////////////////
        //
        // MPC::Config::TypeConstructor
        //
        DEFINE_CONFIG_DEFAULTTAG();
        DECLARE_CONFIG_METHODS();
        //
        ////////////////////////////////////////
    };

    typedef std::list< CParamValue >    ParamValue;
    typedef ParamValue::iterator        ParamValueIter;
    typedef ParamValue::const_iterator  ParamValueIterConst;


    class CParamItem : public MPC::Config::TypeConstructor
    {
        DECLARE_CONFIG_MAP(CParamItem);

    public:
        //
        // m_bstrName           -   Name of the parameter - for ex, "ProdID"
        // m_bstrType           -   Type of the parameter - for ex, "PARAM_LIST"
        // m_bstrDescription    -   Description that is to be shown on UI - for ex, "Please select a product"
        // m_bRequired          -   Whether this parameter is required or not
        // m_bVisible           -   Whether this parameter is visible or not
        //
        CComBSTR    m_bstrName;
        CComBSTR    m_bstrType;
        CComBSTR    m_bstrDescription;
        bool        m_bRequired;
        bool        m_bVisible;

        ParamValue  m_lstParamValue;


        CComBSTR    m_bstrXML;

        ////////////////////////////////////////
        //
        // MPC::Config::TypeConstructor
        //
        DEFINE_CONFIG_DEFAULTTAG();
        DECLARE_CONFIG_METHODS();
        //
        ////////////////////////////////////////

        bool FindDefaultValue( /*[out]*/ ParamValueIter& it );
    };

    typedef std::list< CParamItem >     ParamItem;
    typedef ParamItem::iterator         ParamItemIter;
    typedef ParamItem::const_iterator   ParamItemIterConst;


    ////////////////////////////////////////

    DECLARE_CONFIG_MAP(CParamList);

    //
    // Attributes of the PARAM_LIST tag in the schema
    //
    // m_bstrServerURL              -   This is the server url used for querying
    // m_lUpdateFrequency           -   This is the frequency (in number of days) that the NetSearch wrapper
    //                                  should make an attempt to download the latest copy of the config file
    // m_bstrErrorInfo              -   Error info passed by the server if unable to send the
    //                                  updated version
    // m_bError                     -   Bool value that denotes if an error occured or not
    // m_bRemoteServerUrlPresent    -   This is the URL of the server that sends the updated parameter list
    // m_bstrRemoteConfigServerURL  -   Bool value that dentoes whether the above remote server URL is
    //                                  present or not
    //
    CComBSTR      m_bstrServerURL;
    long          m_lUpdateFrequency;
    CComBSTR      m_bstrErrorInfo;
    bool          m_bError;
    bool          m_bRemoteServerUrlPresent;
    CComBSTR      m_bstrRemoteConfigServerURL;
    CComBSTR      m_bstrSearchEngineName;
    CComBSTR      m_bstrSearchEngineDescription;
    CComBSTR      m_bstrSearchEngineOwner;
    bool		  m_bStandardSearch;
    bool		  m_bSearchTypePresent;

    //
    // Private variables that do not map to attributes/elements in the schema
    //
    CComBSTR      m_bstrConfigFilePath;


    ParamItem     m_lstParamItem;
    ParamItemIter m_itCurrentParam;

    ////////////////////////////////////////
    //
    // MPC::Config::TypeConstructor
    //
    DEFINE_CONFIG_DEFAULTTAG();
    DECLARE_CONFIG_METHODS  ();
    //
    ////////////////////////////////////////

private:
    HRESULT get_Type( /*[in]*/ BSTR bstrType, /*[out]*/ ParamTypeEnum& enmParamType );

public:
    CParamList  ();
    ~CParamList ();

    HRESULT MoveNext     ();
    HRESULT MoveFirst    ();
    HRESULT ClearResults ();
    bool    IsCursorValid();
    bool    RemoteConfig ();

    HRESULT Load( /*[in]*/ BSTR bstrLCID, /*[in]*/ BSTR bstrID, /*[in]*/ BSTR bstrXMLConfigData );


    HRESULT get_Name                   ( /*[out]*/ CComBSTR& bstrName            );
    HRESULT get_ConfigFilePath         ( /*[out]*/ CComBSTR& bstrPath            );
    HRESULT get_SearchEngineName       ( /*[out]*/ CComBSTR& bstrSEName          );
    HRESULT get_SearchEngineDescription( /*[out]*/ CComBSTR& bstrSEDescription   );
    HRESULT get_SearchEngineOwner      ( /*[out]*/ CComBSTR& bstrSEOwner         );
    HRESULT get_ServerUrl              ( /*[out]*/ CComBSTR& bstrServerUrl       );
    HRESULT get_UpdateFrequency        ( /*[out]*/ long&     lUpdateFrequency    );
    HRESULT get_RemoteServerUrl        ( /*[out]*/ CComBSTR& bstrRemoteServerURL );


    HRESULT InitializeParamObject(                              /*[out]*/    SearchEngine::ParamItem_Definition2& def      );
    HRESULT GetDefaultValue      ( /*[in]*/ BSTR bstrParamName, /*[in,out]*/ MPC::wstring&                        strValue );
    bool	IsStandardSearch	 ();

    ////////////////////////////////////////
};

#endif // !defined(__INCLUDED___PCH___SELIB_PARAMCONFIG_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\netsearchwrapper\remoteconfig.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    RemoteConfig.h

Abstract:
	Implements the class CRemoteConfig that contains methods for retrieving the updated 
	config file (parameter list file).

Revision History:
    a-prakac	created		10/24/2000

********************************************************************/

#if !defined(__INCLUDED___PCH___SELIB_REMOTECONFIG_H___)
#define __INCLUDED___PCH___SELIB_REMOTECONFIG_H___


class CRemoteConfig
{
    MPC::XmlUtil m_xmlUpdatedList;

	HRESULT CheckIfUpdateReqd( /*[in]*/ const MPC::wstring& strFilePath, /*[in]*/ long lUpdateFrequency, /*[out]*/ bool& fUpdateRequired );

public:
	HRESULT RetrieveList( /*[in]*/ BSTR bstrQuery, /*[in]*/ BSTR bstrLCID, /*[in]*/ BSTR bstrSKU, /*[in]*/ BSTR bstrFilePath, /*[in]*/ long lFrequency );

	HRESULT Abort();
};

#endif // !defined(__INCLUDED___PCH___SELIB_REMOTECONFIG_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\netsearchwrapper\remoteconfig.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    RemoteConfig.h

Abstract:
    Implements the class CRemoteConfig that contains methods for retrieving the updated
    config file (parameter list file).

Revision History:
    a-prakac    created     10/24/2000

********************************************************************/

#include    "stdafx.h"

#include <SvcUtils.h>

/************

Method - CRemoteConfig::RetrieveList(CComBSTR bstrQuery, CComBSTR bstrFilePath)

Description - This method retrieves the latest copy of the product list from a webservice.
It also checks to see if an update is required in the first place. The old product list is
replaced back in case of errors.

************/

HRESULT CRemoteConfig::RetrieveList( /*[in]*/ BSTR bstrQuery    ,
                                     /*[in]*/ BSTR bstrLCID     ,
                                     /*[in]*/ BSTR bstrSKU      ,
                                     /*[in]*/ BSTR bstrFilePath ,
                                     /*[in]*/ long lFrequency   )
{
    __HCP_FUNC_ENTRY( "CRemoteConfig::RetrieveList" );

    HRESULT              hr;
    CComPtr<IXMLDOMNode> ptrDOMNode;
    CComBSTR             bstrTemp;
    MPC::wstring         strQuery;
    bool                 fLoaded;
    bool                 fFound;


    SANITIZEWSTR(bstrQuery);
    SANITIZEWSTR(bstrLCID);
    SANITIZEWSTR(bstrSKU);
    SANITIZEWSTR(bstrFilePath);



    //
    // Check if an update is required and if so, call the webservice
    //
    {
        bool fUpdateRequired;
        long lUpdateFrequency;

        //
        // If a valid Update Frequency (non negative) has been passed in then use it - else use the default update frequency (7)
        //
        lUpdateFrequency = (lFrequency > 0) ? lFrequency : UPDATE_FREQUENCY;


        __MPC_EXIT_IF_METHOD_FAILS(hr, CheckIfUpdateReqd( bstrFilePath, lUpdateFrequency, fUpdateRequired ) );
        if(!fUpdateRequired)
        {
            __MPC_SET_ERROR_AND_EXIT( hr, S_OK );
        }
    }

    //
    // Add the 'hardcoded' parameters before calling the URL
    //
    {
        MPC::URL urlQuery;

        __MPC_EXIT_IF_METHOD_FAILS(hr, urlQuery.put_URL             ( bstrQuery                ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, urlQuery.AppendQueryParameter( NSW_PARAM_LCID, bstrLCID ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, urlQuery.AppendQueryParameter( NSW_PARAM_SKU , bstrSKU  ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, urlQuery.get_URL             ( strQuery                 ));
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlUpdatedList.SetTimeout( NSW_TIMEOUT_REMOTECONFIG ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlUpdatedList.Load( strQuery.c_str(), NULL, fLoaded, &fFound ));

    // Check if the file was loaded
    if(fLoaded)
    {
        // Check to see if the root node is "CONFIG_DATA" or "string"
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlUpdatedList.GetRoot( &ptrDOMNode ) );
        __MPC_EXIT_IF_METHOD_FAILS(hr, ptrDOMNode->get_nodeName( &bstrTemp   ) );
        ptrDOMNode = NULL;

        // If it is a webservice, then the root node returned is "string". In this case, get the value of
        // this node
        if(MPC::StrCmp( bstrTemp, NSW_TAG_STRING) == 0)
        {
            CComVariant vVar;

            __MPC_EXIT_IF_METHOD_FAILS( hr, m_xmlUpdatedList.GetValue    ( NULL, vVar        ,                               fFound ));
            __MPC_EXIT_IF_METHOD_FAILS( hr, m_xmlUpdatedList.LoadAsString(       vVar.bstrVal, NSW_TAG_CONFIGDATA, fLoaded, &fFound ));
            if(!fLoaded)
            {
                __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
            }
        }

        // If a successful download occured then stamp the file with the current time value and save
		__MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlUpdatedList.PutAttribute( NULL, NSW_TAG_LASTUPDATED, MPC::GetSystemTime(), fFound ));

		{
			MPC::wstring             strFile( bstrFilePath );
			CComPtr<MPC::FileStream> streamDst;
			CComPtr<IStream>         streamSrc;

			__MPC_EXIT_IF_METHOD_FAILS(hr, SVC::SafeSave_Init( strFile, streamDst ));

			__MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlUpdatedList.SaveAsStream( (IUnknown**)&streamSrc ));

			__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::BaseStream::TransferData( streamSrc, streamDst ));

			__MPC_EXIT_IF_METHOD_FAILS(hr, SVC::SafeSave_Finalize( strFile, streamDst ));
		}
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CRemoteConfig::Abort()
{
	return m_xmlUpdatedList.Abort();
}

/************

Method - CRemoteConfig::CheckIfUpdateReqd(MPC::wstring wszFilePath, long lUpdateFrequency)

Description - This method is called by RetrieveList to see if an update is really required. This method
returns E_FAIL if an update is not required otherwise it returns S_OK. It checks to see if the
UPDATE_FREQEUNCY amount of time has elapsed since the last time the file was updated.

************/

HRESULT CRemoteConfig::CheckIfUpdateReqd( /*[in]*/ const MPC::wstring& strFilePath, /*[in]*/ long lUpdateFrequency, /*[out]*/ bool& fUpdateRequired )
{
    __HCP_FUNC_ENTRY( "CRemoteConfig::CheckIfUpdateReqd" );

    HRESULT hr;


    //Default behaviour is update required
    fUpdateRequired = true;


    if(MPC::FileSystemObject::IsFile( strFilePath.c_str() ))
    {
        bool fLoaded;
        bool fFound;

        //
        // Get the attribute LASTUPDATED from the product list file - if not found then exit and download the config file again
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_xmlUpdatedList.Load( strFilePath.c_str(), NSW_TAG_CONFIGDATA, fLoaded, &fFound ));
        if(fLoaded)
        {
            long lLastUpdateTime;

            __MPC_EXIT_IF_METHOD_FAILS( hr, m_xmlUpdatedList.GetAttribute( NULL, NSW_TAG_LASTUPDATED, lLastUpdateTime, fFound ));
            if(fFound)
            {
                long lCurrentTime = MPC::GetSystemTime();

                //
                // If current time - last updated time is less than the update frequency then return E_FAIL - no update takes place in this case
                //
                if((lCurrentTime - lLastUpdateTime) < lUpdateFrequency)
                {
                    fUpdateRequired = false;
                }
            }
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\netsearchwrapper\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__2D61FC60_76C0_4B2F_94C7_8C23B1A6CB9E__INCLUDED_)
#define AFX_STDAFX_H__2D61FC60_76C0_4B2F_94C7_8C23B1A6CB9E__INCLUDED_

#include <module.h>

#include <MPC_main.h>
#include <MPC_utils.h>
#include <MPC_COM.h>
#include <MPC_xml.h>

#include <SvcResource.h>

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

#include <SearchEngineLib.h>

#include "NetSearchConfig.h"
#include "ParamConfig.h"
#include "RemoteConfig.h"

#include "NetSW.h"

#include <msxml2.h>

// Constants for the NetSearchWrapper
#define NSW_TIMEOUT_REMOTECONFIG (15 * 1000)
#define NSW_TIMEOUT_QUERY        (30 * 1000)

#define	CONTENTTYPE_ERROR_OFFLINE (-2)
#define	UPDATE_FREQUENCY	7

// Hardcoded parameters for the query string
#define NSW_PARAM_QUERYSTRING		L"QueryString"
#define NSW_PARAM_LCID				L"LCID"
#define	NSW_PARAM_SKU				L"SKU"
#define	NSW_PARAM_MAXRESULTS		L"MaxResults"
#define NSW_PARAM_PREVQUERY			L"PrevQuery"

#define NSW_PARAM_SUBQUERY			L"SubQuery"
#define NSW_PARAM_CURRENTQUERY		L"CurrentQuery"

// XML tags

#define	NSW_TAG_STRING				L"string"

// Result list schema tags
#define NSW_TAG_RESULTLIST			L"ResultList"
#define NSW_TAG_RESULTITEM			L"ResultItem"
#define NSW_TAG_ERRORINFO			L"ErrorInfo"

//Configuration data schema tags
#define NSW_TAG_DATA				L"DATA"
#define NSW_TAG_CONFIGDATA			L"CONFIG_DATA"
#define NSW_TAG_PARAMITEM			L"PARAM_ITEM"

// Remote configuration data schema tag
#define NSW_TAG_LASTUPDATED			L"LASTUPDATED"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__2D61FC60_76C0_4B2F_94C7_8C23B1A6CB9E__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\testwrapper\testresource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by testwrapper.rc
//
#define IDS_PROJNAME                    100
#define IDR_TESTSE                      101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\testwrapper\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__8214E9A8_9013_4BDE_B443_0FEC93ED1B48__INCLUDED_)
#define AFX_STDAFX_H__8214E9A8_9013_4BDE_B443_0FEC93ED1B48__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <MPC_main.h>
#include <MPC_utils.h>
#include <MPC_COM.h>
#include <MPC_logging.h>

#include <SvcResource.h>

#include "testresource.h"
#include "testwrapper.h"

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

#include <seconfig.h>
#include <SearchEngineLib.h>

#include "TestSE.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8214E9A8_9013_4BDE_B443_0FEC93ED1B48__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\testwrapper\testse.h ===
// TestSE.h : Declaration of the CTestSE

#ifndef __TESTSE_H_
#define __TESTSE_H_

#include <SvcResource.h>

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

#include "testwrapper.h"

/////////////////////////////////////////////////////////////////////////////
// CTestSE
class ATL_NO_VTABLE CTestSE :
    public MPC::Thread<CTestSE,ITestSE>,
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public CComCoClass<CTestSE, &CLSID_TestSE>,
    public IDispatchImpl<IPCHSEWrapperItem, &IID_IPCHSEWrapperItem, &LIBID_HelpServiceTypeLib>,
    public IDispatchImpl<IPCHSEWrapperInternal, &IID_IPCHSEWrapperInternal, &LIBID_HelpServiceTypeLib>
{
	DECLARE_WRAPPER_VARIABLES;
public:
    CTestSE();

DECLARE_REGISTRY_RESOURCEID(IDR_TESTSE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTestSE)
    COM_INTERFACE_ENTRY2(IDispatch,IPCHSEWrapperItem)
    COM_INTERFACE_ENTRY(IPCHSEWrapperItem)
    COM_INTERFACE_ENTRY(IPCHSEWrapperInternal)
END_COM_MAP()

// ITestSE
public:

	DECLARE_WRAPPER_PARAM_FUNCTIONS_BEGIN;

		DECLARE_WRAPPER_PARAM(	PARAM_UINT,							// Type
								CComBSTR("NumResults"),				// Name
								CComBSTR("NumResults"),				// Description
								VARIANT_FALSE,						// Required
								CComVariant(CComBSTR("")),			// Data
								VARIANT_TRUE);						// Visible

		DECLARE_WRAPPER_PARAM(	PARAM_UINT,							// Type
								CComBSTR("QueryDelayMillisec"),		// Name
								CComBSTR("QueryDelayMillisec"),		// Description
								VARIANT_FALSE,						// Required
								CComVariant(CComBSTR("")),			// Data
								VARIANT_TRUE);						// Visible

		DECLARE_WRAPPER_PARAM_FUNCTIONS_END;

	DECLARE_WRAPPER_EXPORT_INTERFACE;
	DECLARE_WRAPPER_NON_EXPORT_INTERFACE;

// non-exported functions
    HRESULT ExecQuery();
};

#endif //__TESTSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\testwrapper\testwrapper.cpp ===
// testwrapper.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f testwrapperps.mk in the project directory.

#include "stdafx.h"
#include <initguid.h>

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_TestSE, CTestSE)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_TESTWRAPPERLib);
        DisableThreadLibraryCalls(hInstance);
		MPC::_MPC_Module.Init();
    }
    else if (dwReason == DLL_PROCESS_DETACH)
	{
        _Module.Term();
		MPC::_MPC_Module.Term();
	}
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\testwrapper\testwrapper.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Thu Mar 30 11:49:45 2000
 */
/* Compiler settings for C:\whistler\admin\pchealth\HelpCtr\Service\testwrapper\testwrapper.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __testwrapper_h__
#define __testwrapper_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ITestSE_FWD_DEFINED__
#define __ITestSE_FWD_DEFINED__
typedef interface ITestSE ITestSE;
#endif 	/* __ITestSE_FWD_DEFINED__ */


#ifndef __TestSE_FWD_DEFINED__
#define __TestSE_FWD_DEFINED__

#ifdef __cplusplus
typedef class TestSE TestSE;
#else
typedef struct TestSE TestSE;
#endif /* __cplusplus */

#endif 	/* __TestSE_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __ITestSE_INTERFACE_DEFINED__
#define __ITestSE_INTERFACE_DEFINED__

/* interface ITestSE */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ITestSE;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6CB4F115-6D30-4925-AED6-FF3363CF1894")
    ITestSE : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ITestSEVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITestSE __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITestSE __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITestSE __RPC_FAR * This);
        
        END_INTERFACE
    } ITestSEVtbl;

    interface ITestSE
    {
        CONST_VTBL struct ITestSEVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITestSE_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITestSE_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITestSE_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITestSE_INTERFACE_DEFINED__ */



#ifndef __TESTWRAPPERLib_LIBRARY_DEFINED__
#define __TESTWRAPPERLib_LIBRARY_DEFINED__

/* library TESTWRAPPERLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_TESTWRAPPERLib;

EXTERN_C const CLSID CLSID_TestSE;

#ifdef __cplusplus

class DECLSPEC_UUID("FE6581C0-1773-47FD-894C-4CD9CD2275B3")
TestSE;
#endif
#endif /* __TESTWRAPPERLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\testwrapper\testse.cpp ===
// TestSE.cpp : Implementation of CTestSE
#include "stdafx.h"

#include "HelpServiceTypeLib_i.c"
#include "testwrapper_i.c"

#include <Utility.h>

#define		SETESTID	0x2000

/////////////////////////////////////////////////////////////////////////////
// CTestSE : IPCHSEWrapperItem

CTestSE::CTestSE()
{
	m_bEnabled      = VARIANT_TRUE;
	m_lNumResult    = 0;
	m_pSEMgr        = NULL;

	//
	// These strings will have to be changed to be read dynamically from
	// the initialization data
	//
    m_bstrOwner			= L"Microsoft";
    m_bstrName			= L"Test Search Wrapper";
    m_bstrDescription	= L"Test Wrapper";
    m_bstrHelpURL		= "";
	m_bstrID			= "16AF1738-E7BB-43c6-8B67-A07E21690029";

	AddParam(CComBSTR("NumResults"), CComVariant(20));
	AddParam(CComBSTR("QueryDelayMillisec"), CComVariant(500));

}


CPCHSEParamItem* CreateParamObject(ParamTypeEnum pte, BSTR bstrName, VARIANT_BOOL bReq)
{
    __HCP_FUNC_ENTRY( "CreateParamObject" );

	HRESULT                  hr;
    CComPtr<CPCHSEParamItem> pPIObj;

    //
    // Create the item to be inserted into the list
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pPIObj ));

    //
    // Stuff the data
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, pPIObj->put_Type		( pte		));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pPIObj->put_Name		( bstrName	));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pPIObj->put_Display  ( bstrName	));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pPIObj->put_Required ( bReq		));

    __MPC_FUNC_CLEANUP;

	return pPIObj.Detach();
}

STDMETHODIMP CTestSE::Result( /*[in]*/ long lStart, /*[in]*/ long lEnd, /*[out, retval]*/ IPCHCollection* *ppC )
{
	HRESULT	                     hr = S_OK;
    MPC::SmartLock<_ThreadModel> lock( this );
    CComPtr<CPCHCollection>      pColl;
	int                          i;
    VARIANT						 vValue;
	unsigned int				 iResults = 0;

	if(ppC == NULL) return E_POINTER;

    //
    // Create the Enumerator and fill it with jobs.
    //
    if(FAILED(hr= MPC::CreateInstance( &pColl )))
    {
        goto end;
    }

	if (m_bEnabled)
	{
		//
		// Get the number of parameters
		//
		if (FAILED(GetParam(CComBSTR("NumResults"), &vValue)))
		{
			iResults = 10;
		}
		else
		{
			iResults = vValue.uintVal;
		}

		//
		// Create 10 items and fill it with data
		//
		for (i = 0; i < iResults; i++)
		{
			CComPtr<CPCHSEResultItem> pRIObj;
			WCHAR					  wszIter[10];
			CComBSTR				  bstrString;

			//
			// Create the item to be inserted into the list
			//
			if (FAILED(hr=MPC::CreateInstance( &pRIObj )))
			{
				break;
			}

			//
			// Print out the iteration
			//
			swprintf(wszIter, L"%d", i);

			//
			// Stuff in the data
			//
			bstrString = L"Title ";
			bstrString.Append(wszIter);
			pRIObj->put_Title(bstrString);

			bstrString = L"URI ";
			bstrString.Append(wszIter);
			pRIObj->put_URI(bstrString);

			pRIObj->put_Rank		( (double)i/10 );
			pRIObj->put_Hits		(         i    );
			pRIObj->put_Location	(CComBSTR("Test"));
			pRIObj->put_ContentType (         i    );

			//
			// Add to enumerator
			//
			if (FAILED(hr = pColl->AddItem(pRIObj)))
			{
				goto end;
			}
		}
	}

    if (FAILED(hr=pColl.QueryInterface( ppC )))
    {
        goto end;
    }

end:
	return hr;
}

STDMETHODIMP CTestSE::get_SearchTerms( /*[out, retval]*/ VARIANT *pvTerms )
{
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTestSE : IPCHSEWrapperInternal

STDMETHODIMP CTestSE::AbortQuery()
{
	Thread_Abort();
	return S_OK;
}

HRESULT CTestSE::ExecQuery()
{
    __MPC_FUNC_ENTRY( SETESTID, "CTestSE::ExecQuery" );
	HRESULT								hr = S_OK;
    VARIANT								vValue;
	unsigned int						iDelay;
	CComPtr<IPCHSEManagerInternal> pSEMgr = m_pSEMgr;

	if (m_bEnabled)
	{
		//
		// Get the number of parameters
		//
		if (FAILED(GetParam(CComBSTR("QueryDelayMillisec"), &vValue)))
		{
			iDelay = 1000;
		}
		else
		{
			iDelay = vValue.uintVal;
		}

		Sleep(iDelay);

		//
		// Call the SearchManager's OnComplete
		//
		if (Thread_IsAborted() == false)
		{
			__MPC_EXIT_IF_METHOD_FAILS(hr, pSEMgr->WrapperComplete( 0, this ));
		}
	}

    __MPC_FUNC_CLEANUP;

	Thread_Abort();

    __MPC_FUNC_EXIT(hr);
}

STDMETHODIMP CTestSE::ExecAsyncQuery()
{
    __MPC_FUNC_ENTRY( SETESTID, "CTestSE::ExecAsyncQuery" );
	HRESULT									hr = S_OK;

	//
	// Create a thread to execute the query
	//
    __MPC_EXIT_IF_METHOD_FAILS(hr, Thread_Start( this, ExecQuery, NULL ));

    __MPC_FUNC_CLEANUP;
    __MPC_FUNC_EXIT(hr);
}

STDMETHODIMP CTestSE::Initialize( /*[in]*/ BSTR bstrID, /*[in]*/ BSTR bstrSKU, /*[in]*/ long lLCID, /*[in]*/ BSTR bstrData )
{
	//
	// Add your routine here to initialize your wrapper
	//
	return S_OK;
}

STDMETHODIMP CTestSE::SECallbackInterface( /*[in]*/ IPCHSEManagerInternal* pMgr )
{
    __MPC_FUNC_ENTRY( SETESTID, "CTestSE::SECallbackInterface" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

    m_pSEMgr = pMgr;
    hr       = S_OK;

    __MPC_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\wrapper_fts\ftsobj.cpp ===
#include "stdafx.h"
#include "ftsobj.h"
#include "fs.h"

//
// The high 10 bits will be used as an CHM ID.
// Conversion from DWORD to CHM_ID and Topic Number.
//
#define CHM_ID(exp)     (0x000003ff & (exp >> 22))
#define TOPIC_NUM(exp)  (0x003fffff & exp)

// Single-Width to Double-Width Mapping Array
//
static const unsigned char mtable[][2]={
   {129,66},{129,117},{129,118},{129,65},{129,69},{131,146},{131,64},
   {131,66},{131,68},{131,70},{131,72},{131,131},{131,133},{131,135},
   {131,98},{129,91},{131,65},{131,67},{131,69},{131,71},{131,73},
   {131,74},{131,76},{131,78},{131,80},{131,82},{131,84},{131,86},
   {131,88},{131,90},{131,92},{131,94},{131,96},{131,99},{131,101},
   {131,103},{131,105},{131,106},{131,107},{131,108},{131,109},
   {131,110},{131,113},{131,116},{131,119},{131,122},{131,125},
   {131,126},{131,128},{131,129},{131,130},{131,132},{131,134},
   {131,136},{131,137},{131,138},{131,139},{131,140},{131,141},
   {131,143},{131,147},{129,74},{129,75} };

// note, cannot put in .text since the pointers themselves are uninitialized
static const char* pJOperatorList[] =   {"","????","???","????","??????","?m?d?`?q","?n?q","?`?m?c","?m?n?s",""};
static const char* pEnglishOperator[] = {"","and "  ,"or " ,"not "  ,"near "   ,"NEAR "   ,"OR " ,"AND "  ,"NOT "  ,""};

UINT WINAPI CodePageFromLCID(LCID lcid)
{
    char wchLocale[10];
    UINT cp;

    if (GetLocaleInfoA(lcid, LOCALE_IDEFAULTANSICODEPAGE, wchLocale, sizeof wchLocale))
    {
        cp = strtoul(wchLocale, NULL, 10);
        if (cp)
            return cp;
    }
    return GetACP();
}

// Compare operator to query.  This is similar to a stricmp.
//
BOOL compareOperator(char *pszQuery, char *pszTerm)
{
    if(!*pszQuery || !*pszTerm)
        return FALSE;

    while(*pszQuery && *pszTerm)
    {
        if(*pszQuery != *pszTerm)
            return FALSE;

        ++pszQuery;
        ++pszTerm;
    }

    if(*pszTerm)
        return FALSE;

    return TRUE;
}

// This function computes if pszQuery is a FTS operator in full-width alphanumeric.
//
// return value
//
//      0 = not operator
//      n = index into pEnglishOperator array of translated English operator
//
int IsJOperator(char *pszQuery)
{
    if((PRIMARYLANGID(GetSystemDefaultLangID())) != LANG_JAPANESE)
        return FALSE;

    if(!pszQuery)
        return 0;

    int i = 1;
    char *pTerm = (char*)pJOperatorList[i];

    while(*pTerm)
    {
        if(compareOperator(pszQuery,pTerm))
            return i;

        pTerm = (char*)pJOperatorList[++i];
    }

    return 0;
}

// Han2Zen
//
// This function converts half-width katakana character to their
// full-width equivalents while taking into account the nigori
// and maru marks.
//
DWORD Han2Zen(unsigned char *lpInBuffer, unsigned char *lpOutBuffer, UINT codepage )
{
   // Note: The basic algorithm (including the mapping table) used here to
   // convert half-width Katakana characters to full-width Katakana appears
   // in the book "Understanding Japanese Information Systems" by
   // O'Reily & Associates.

    while(*lpInBuffer)
    {
        if(*lpInBuffer >= 161 && *lpInBuffer <= 223)
        {
            // We have a half-width Katakana character. Now compute the equivalent
            // full-width character via the mapping table.
            //
            *lpOutBuffer     = mtable[*lpInBuffer-161][0];
            *(lpOutBuffer+1) = mtable[*lpInBuffer-161][1];

            lpInBuffer++;

            // check if the second character is nigori mark.
            //
            if(*lpInBuffer == 222)
            {
                // see if we have a half-width katakana that can be modified by nigori.
                //
                if((*(lpInBuffer-1) >= 182 && *(lpInBuffer-1) <= 196) ||
                   (*(lpInBuffer-1) >= 202 && *(lpInBuffer-1) <= 206) || (*(lpInBuffer-1) == 179))
                {
                    // transform kana into kana with maru
                    //
                    if((*(lpOutBuffer+1) >= 74   && *(lpOutBuffer+1) <= 103) ||
                     (*(lpOutBuffer+1) >= 110 && *(lpOutBuffer+1) <= 122))
                    {
                         (*(lpOutBuffer+1))++;
                         ++lpInBuffer;
                    }
                    else if(*lpOutBuffer == 131 && *(lpOutBuffer+1) == 69)
                    {
                        *(lpOutBuffer+1) = 148;
                        ++lpInBuffer;
                    }
                }
            }
            else if(*lpInBuffer==223) // check if following character is maru mark
            {
                // see if we have a half-width katakana that can be modified by maru.
                //
                if((*(lpInBuffer-1) >= 202 && *(lpInBuffer-1) <= 206))
                {
                    // transform kana into kana with nigori
                    //
                    if(*(lpOutBuffer+1) >= 110 && *(lpOutBuffer+1) <= 122)
                    {
                        *(lpOutBuffer+1)+=2;
                        ++lpInBuffer;
                    }
                }
            }

            lpOutBuffer+=2;
        }
        else
        {
            if(IsDBCSLeadByteEx(codepage, *lpInBuffer))
            {
                *lpOutBuffer++ = *lpInBuffer++;
                if(*lpInBuffer)
                    *lpOutBuffer++ = *lpInBuffer++;
            }
            else
                *lpOutBuffer++ = *lpInBuffer++;
        }
    }

    *lpOutBuffer = 0;
    return TRUE;
}

LPWSTR PreProcessQuery(LPCWSTR pwcQuery, UINT codepage)
{
    WCHAR* pszUnicodeBuffer = NULL;
    char*  pszTempQuery1    = NULL;
    char*  pszTempQuery2          ;
    char*  pszTempQuery3    = NULL;
    char*  pszTempQuery4    = NULL;
    char*  pszTempQuery5          ;
    char*  pszTempQuery6    = NULL;
    char*  pszTempQuery7          ;
    char*  pszDest;
    char*  pszTemp;
    int    cUnmappedChars = 0;
    int    cbUnicodeSize;
    int    cb;
    DWORD  dwTempLen;
    DWORD  dwTranslatedLen;


    if(!pwcQuery) goto end;

    // compute max length for ANSI/DBCS conversion buffer
    //
    dwTempLen = ((wcslen(pwcQuery)*2)+4);

    // allocate buffer for ANSI/DBCS version of query string
    //
    pszTempQuery1 = new char[dwTempLen]; if(!pszTempQuery1) goto end;

    // Convert our Unicode query to ANSI/DBCS
    if(!WideCharToMultiByte(codepage, 0, pwcQuery, -1, pszTempQuery1, dwTempLen, "%", NULL)) goto end;


    // Count the number of unmappable characters
    //
    pszTempQuery5 = pszTempQuery1;
    while(*pszTempQuery5)
    {
        if(*pszTempQuery5 == '%') ++cUnmappedChars;

        if(IsDBCSLeadByteEx(codepage, *pszTempQuery5))
        {
            pszTempQuery5++;

            if(*pszTempQuery5) pszTempQuery5++;
        }
        else
        {
            ++pszTempQuery5;
        }
    }

    // allocate a new buffer large enough for unmapped character place holders plus original query
    //
    dwTranslatedLen = strlen(pszTempQuery1) + (cUnmappedChars * 4) + 16;

    pszTempQuery6 = new char[dwTranslatedLen]; if(!pszTempQuery6) goto end;
    pszTempQuery7 = pszTempQuery6;


    pszTempQuery5 = pszTempQuery1;

    // construct the new query string (inserting unmappable character place holders)
    //
    while(*pszTempQuery5)
    {
        if(*pszTempQuery5 == '%')
        {
            ++pszTempQuery5;
            *pszTempQuery7++='D';
            *pszTempQuery7++='X';
            *pszTempQuery7++='O';
            continue;
        }

        if(IsDBCSLeadByteEx(codepage, *pszTempQuery5))
        {
            *pszTempQuery7++ = *pszTempQuery5++;
            if(*pszTempQuery5)
                *pszTempQuery7++ = *pszTempQuery5++;
        }
        else
            *pszTempQuery7++ = *pszTempQuery5++;
    }

    *pszTempQuery7 = 0;

    pszTempQuery2 = pszTempQuery6;

    // If we are running a Japanese title then we nomalize Katakana characters
    // by converting half-width Katakana characters to full-width Katakana.
    // This allows the user to receive hits for both the full and half-width
    // versions of the character regardless of which version they type in the
    // query string.
    //
    if(codepage == 932)
    {
        cb = strlen(pszTempQuery2)+1;

        // allocate new buffer for converted query
        //
        pszTempQuery3 = new char[cb*2]; if(!pszTempQuery3) goto end;

        // convert half-width katakana to full-width
        //
        Han2Zen((unsigned char *)pszTempQuery2,(unsigned char *)pszTempQuery3, codepage);

        pszTempQuery2 = pszTempQuery3;
    }
    // done half-width normalization

    // For Japanese queries, convert all double-byte quotes into single byte quotes
    //
    if(codepage == 932)
    {
        pszTemp = pszTempQuery2;
        while(*pszTemp)
        {
            if(*pszTemp == '' && (*(pszTemp+1) == 'h' || *(pszTemp+1) == 'g' || *(pszTemp+1) == 'J') )
            {
                *pszTemp = ' ';
                *(pszTemp+1) = '\"'; //"
            }
            pszTemp = ::CharNextA(pszTemp);
        }
    }
    // done convert quotes

    // This section converts contigious blocks of DBCS characters into phrases (enclosed in double quotes).
    // Converting DBCS words into phrases is required with the character based DBCS indexer we use.
    //
    cb = strlen(pszTempQuery2);

    // allocate new buffer for processed query
    //
    pszTempQuery4  = new char[cb*8]; if(!pszTempQuery4) goto end;

    pszTemp = pszTempQuery2;
    pszDest = pszTempQuery4;

    while(*pszTemp)
    {
        // check for quoted string - if found, copy it
        if(*pszTemp == '"')
        {
            *pszDest++=*pszTemp++;
            while(*pszTemp && *pszTemp != '"')
            {
                if(IsDBCSLeadByteEx(codepage, *pszTemp))
                {
                    *pszDest++=*pszTemp++;
                    *pszDest++=*pszTemp++;
                }
                else
                    *pszDest++=*pszTemp++;
            }
            if(*pszTemp == '"')
                    *pszDest++=*pszTemp++;
            continue;
        }

        // Convert Japanese operators to English operators
        //
        if(IsDBCSLeadByteEx(codepage, *pszTemp))
        {
            int i;

            // check for full-width operator, if found, convert to ANSI
            if((i = IsJOperator(pszTemp)))
            {
                StringCchCopyA(pszDest, (cb*8) - (pszDest - pszTempQuery4), pEnglishOperator[i]);
                pszDest+=strlen(pEnglishOperator[i]);
                pszTemp+=strlen(pJOperatorList[i]);
                continue;
            }

            *pszDest++=' ';
            *pszDest++='"';
            while(*pszTemp && *pszTemp !='"' && IsDBCSLeadByteEx(codepage, *pszTemp))
            {
                *pszDest++=*pszTemp++;
                *pszDest++=*pszTemp++;
            }
            *pszDest++='"';
            *pszDest++=' ';
            continue;
        }

        *pszDest++=*pszTemp++;
    }
    *pszDest = 0;

    // compute size of Unicode buffer;

    cbUnicodeSize = ((MultiByteToWideChar(codepage, 0, pszTempQuery4, -1, NULL, 0) + 2) *2);

    pszUnicodeBuffer = new WCHAR[cbUnicodeSize]; if(!pszUnicodeBuffer) goto end;

    if(!MultiByteToWideChar(codepage, 0, pszTempQuery4, -1, pszUnicodeBuffer, cbUnicodeSize))
    {
        delete [] pszUnicodeBuffer; pszUnicodeBuffer = NULL;
        goto end;
    }

end:

    delete [] pszTempQuery1;
    delete [] pszTempQuery3;
    delete [] pszTempQuery4;
    delete [] pszTempQuery6;

    return pszUnicodeBuffer;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

CFTSObject::CFTSObject()
{
                             // Config                m_cfg;
                             //
    m_fInitialized  = false; // bool                  m_fInitialized;
                             // MPC::wstring          m_strCHQPath;
                             //
                             // LCID                  m_lcidLang;
                             // FILETIME              m_ftVersionInfo;
                             // DWORD                 m_dwTopicCount;
                             // WORD                  m_wIndex;
                             //
    m_fOutDated     = false; // bool                  m_fOutDated;
    m_cmeCHMInfo    = NULL;  // CHM_MAP_ENTRY*        m_cmeCHMInfo;
    m_wCHMInfoCount = 0;     // WORD                  m_wCHMInfoCount;
                             //
                             // CComPtr<IITIndex>     m_pIndex;
                             // CComPtr<IITQuery>     m_pQuery;
                             // CComPtr<IITResultSet> m_pITResultSet;
                             // CComPtr<IITDatabase>  m_pITDB;

}

CFTSObject::~CFTSObject()
{
    if(m_pITResultSet) m_pITResultSet->Clear();
    if(m_pIndex      ) m_pIndex      ->Close();
    if(m_pITDB       ) m_pITDB       ->Close();

    delete [] m_cmeCHMInfo;
}

////////////////////

void CFTSObject::BuildChmPath( /*[in/out]*/ MPC::wstring& strPath, /*[in]*/ LPCSTR szChmName )
{
	WCHAR rgBuf[MAX_PATH];

	::MultiByteToWideChar( CP_ACP, 0, szChmName, -1, rgBuf, MAXSTRLEN(rgBuf) );

	strPath  = m_strCHQPath;
	strPath += rgBuf;
	strPath += L".chm";
}

HRESULT CFTSObject::Initialize()
{
    __HCP_FUNC_ENTRY( "CFTSObject::Initialize" );

    USES_CONVERSION;

    HRESULT hr;
    LPCWSTR szFile;
    HANDLE  hFile = INVALID_HANDLE_VALUE;


    if(m_fInitialized == false)
    {
        /*DWORD   dwFileStamp;
        DWORD   dwRead;*/

        //
        // Check if it is a CHQ
        //
        if(m_cfg.m_fCombined)
        {
            LPCWSTR szStart = m_cfg.m_strCHQFilename.c_str();
            LPCWSTR szEnd   = wcsrchr( szStart, '\\' );

            m_strCHQPath.assign( szStart, szEnd ? ((szEnd+1) - szStart) : m_cfg.m_strCHQFilename.size() );

            __MPC_EXIT_IF_METHOD_FAILS(hr, LoadCombinedIndex());

            szFile = m_cfg.m_strCHQFilename.c_str();
        }
        else
        {
            szFile = m_cfg.m_strCHMFilename.c_str();
        }

        hFile = CreateFileW( szFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );
        if(hFile == INVALID_HANDLE_VALUE)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
        }

        /*::SetFilePointer( hFile, 4*sizeof(UINT), NULL, FILE_BEGIN );

        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::ReadFile( hFile, (void*) &dwFileStamp, sizeof( dwFileStamp ), &dwRead, NULL ));
        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::ReadFile( hFile, (void*) &m_lcidLang , sizeof( m_lcidLang  ), &dwRead, NULL ));*/

        ::CloseHandle( hFile ); hFile = INVALID_HANDLE_VALUE;

        //
        // Get IITIndex pointer
        //
		__MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateInstance( CLSID_IITIndexLocal, NULL, CLSCTX_INPROC_SERVER, IID_IITIndex, (VOID**)&m_pIndex ));

        //
        // Get IITDatabase pointer
        //
		__MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateInstance( CLSID_IITDatabaseLocal, NULL, CLSCTX_INPROC_SERVER, IID_IITDatabase, (VOID**)&m_pITDB ));

        //
        // Open the storage system
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_pITDB->Open( NULL, szFile, NULL));

        //
        // open the index.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_pIndex->Open( m_pITDB, L"ftiMain", TRUE ));

        //
        // Create query instance
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_pIndex->CreateQueryInstance( &m_pQuery ));

        //
        // Create Result Set object
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateInstance( CLSID_IITResultSet, NULL, CLSCTX_INPROC_SERVER, IID_IITResultSet, (VOID**)&m_pITResultSet ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_pITResultSet->ClearRows());

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_pITResultSet->Add( STDPROP_UID            , (DWORD)0   , PRIORITY_NORMAL ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_pITResultSet->Add( STDPROP_TERM_UNICODE_ST, (DWORD)NULL, PRIORITY_NORMAL ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_pITResultSet->Add( STDPROP_COUNT          , (DWORD)NULL, PRIORITY_NORMAL ));

        m_fInitialized = true;
    }

    hr = S_OK;

    __MPC_FUNC_CLEANUP;

    if(hFile != INVALID_HANDLE_VALUE)
    {
        ::CloseHandle( hFile );
    }

    __MPC_FUNC_EXIT(hr);
}

HRESULT CFTSObject::LoadCombinedIndex()
{
    __HCP_FUNC_ENTRY( "CFTSObject::LoadCombinedIndex" );

    USES_CONVERSION;

    HRESULT         hr;
	MPC::wstring    strCHMPathName;
    CFileSystem*    pDatabase = NULL;
    CSubFileSystem* pTitleMap = NULL;
    ULONG           cbRead    = 0;
    HANDLE          hFile     = INVALID_HANDLE_VALUE;


    //
    // Open the CHQ
    //
    __MPC_EXIT_IF_ALLOC_FAILS(hr, pDatabase, new CFileSystem);

    __MPC_EXIT_IF_METHOD_FAILS(hr, pDatabase->Init(                                        ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pDatabase->Open( (LPWSTR)m_cfg.m_strCHQFilename.c_str() ));

    //
    // Open the TitleMap that contains all the CHM indexes
    //
    __MPC_EXIT_IF_ALLOC_FAILS(hr, pTitleMap, new CSubFileSystem( pDatabase ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pTitleMap->OpenSub( "$TitleMap" ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pTitleMap->ReadSub( &m_wCHMInfoCount, sizeof(m_wCHMInfoCount), &cbRead ));

    //
    // Allocate the CHM MAP
    //
	delete [] m_cmeCHMInfo;
    __MPC_EXIT_IF_ALLOC_FAILS(hr, m_cmeCHMInfo, new CHM_MAP_ENTRY[m_wCHMInfoCount]);

    //
    // Read in all the CHM Maps
    //
    for(int iCount = 0; iCount < (int)m_wCHMInfoCount; iCount++)
    {
        /*DWORD dwFileStamp = 0;
        LCID  FileLocale  = 0;
        DWORD dwRead      = 0;*/


        if(hFile != INVALID_HANDLE_VALUE)
        {
            ::CloseHandle( hFile ); hFile = INVALID_HANDLE_VALUE;
        }

        //
        // Read in the CHM Map Entry
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, pTitleMap->ReadSub( &m_cmeCHMInfo[iCount], sizeof(CHM_MAP_ENTRY), &cbRead ));

        //
        // Open the CHM in the same folder as the CHQ folder
        //
		BuildChmPath( strCHMPathName, m_cmeCHMInfo[iCount].szChmName );


        hFile = ::CreateFileW( strCHMPathName.c_str(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );

        //
        // If cannot open the file, just resume to the next one
        //
        if(hFile == INVALID_HANDLE_VALUE) continue;


        //
        // Read in the timestamp and locale
        //
        /*::SetFilePointer( hFile, 4*sizeof(UINT), NULL, FILE_BEGIN );

        if(::ReadFile( hFile, (void*) &dwFileStamp, sizeof( dwFileStamp ), &dwRead, NULL ) == FALSE) continue;
        if(::ReadFile( hFile, (void*) &FileLocale , sizeof( FileLocale  ), &dwRead, NULL ) == FALSE) continue;*/

        ::CloseHandle( hFile ); hFile = INVALID_HANDLE_VALUE;

        //
        // Check if CHQ index has different version of index than CHM or different language
        //
        /*if ((m_cmeCHMInfo[iCount].versioninfo.dwLowDateTime  != dwFileStamp) ||
            (m_cmeCHMInfo[iCount].versioninfo.dwHighDateTime != dwFileStamp) ||
            (m_cmeCHMInfo[iCount].language                   != FileLocale))
        {
            //
            // If it is outdated, mark it
            //
            m_fOutDated = TRUE;
            m_cmeCHMInfo[iCount].dwOutDated = 1;
        }
        else
        {
            //
            // Otherwise it is good
            //
            m_cmeCHMInfo[iCount].dwOutDated = 0;
        }*/
    }

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

    if(hFile != INVALID_HANDLE_VALUE)
    {
        ::CloseHandle( hFile );
    }

    delete pTitleMap;
    delete pDatabase;

	__HCP_FUNC_EXIT(hr);
}

HRESULT CFTSObject::ResetQuery( LPCWSTR wszQuery )
{
    __HCP_FUNC_ENTRY( "CFTSObject::ResetQuery" );

    HRESULT hr;


	__MPC_EXIT_IF_METHOD_FAILS(hr, Initialize());

    //
    // Setup result set
    // we want topic numbers back
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_pITResultSet->ClearRows());

    //
    // Set up query parameters
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_pQuery->ReInit());

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_pQuery->SetResultCount( m_cfg.m_dwMaxResult     ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_pQuery->SetProximity  ( m_cfg.m_wQueryProximity ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_pQuery->SetCommand    ( wszQuery                ));

    hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

HRESULT CFTSObject::ProcessResult( /*[in/out]*/ SEARCH_RESULT_SET& results, /*[in/out]*/ MPC::WStringSet& words, UINT cp)
{
    __HCP_FUNC_ENTRY( "CFTSObject::ProcessResult" );

    HRESULT        hr;
    CProperty      Prop;
	CProperty	   HLProp;
	MPC::wstring   strCHMPathName;
    SEARCH_RESULT* pPrevResult = NULL;
    CTitleInfo*    pTitleInfo  = NULL;
    DWORD          dwPrevCHMID = 0xffffffff;
    DWORD          dwPrevValue = 0xffffffff;
    long           lRowCount = 0;
    long           lLoop;


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_pITResultSet->GetRowCount( lRowCount ));
    
    //
    // loop through all the results
    //
    for(lLoop = 0; lLoop < lRowCount; lLoop++)
    {
        WCHAR rgTitle   [1024];
        WCHAR rgLocation[1024];
        char  rgURL     [1024];

		HLProp.dwType = TYPE_STRING;
        if(FAILED(m_pITResultSet->Get( lLoop, 0, Prop ))) continue;
        if(FAILED(m_pITResultSet->Get( lLoop, 1, HLProp ))) continue;

		//
		// Add to highlight word list
		//
		words.insert( HLProp.lpszwData + 1 );

        //
        // Check if it is a duplicate
        //
        if(Prop.dwValue == dwPrevValue)
        {
            // increment the previous rank
            if(pPrevResult) pPrevResult->dwRank++;

            continue;
        }
        dwPrevValue = Prop.dwValue;

        //
        // If it is a CHQ result
        //
        if(m_cfg.m_fCombined)
        {
            //
            // If TitleInfo not already opened before
            //
            if((dwPrevCHMID != CHM_ID(Prop.dwValue)) || !pTitleInfo)
            {
                //
                // save the previous CHMID
                //
                dwPrevCHMID = CHM_ID(Prop.dwValue);

                //
                // Hunt for the correct CHMID
                //
                for(int iCHMInfo = 0; iCHMInfo < m_wCHMInfoCount; iCHMInfo++)
                {
                    //
                    // Check if the CHM index matches
                    //
                    if(m_cmeCHMInfo[iCHMInfo].iIndex == dwPrevCHMID)
                    {
						delete pTitleInfo; pTitleInfo = NULL;

                        //
                        // Check if outdated
                        //
                        //if(m_cmeCHMInfo[iCHMInfo].dwOutDated == 0)
                        {
							//
							// Create a new one
							//
							__MPC_EXIT_IF_ALLOC_FAILS(hr, pTitleInfo, new CTitleInfo);


							//
							// Create the chm pathname
							//
							BuildChmPath( strCHMPathName, m_cmeCHMInfo[iCHMInfo].szChmName );

							//
							// Open the CHM file
							//
							if(!pTitleInfo->OpenTitle( (LPWSTR)strCHMPathName.c_str() ))
							{
								delete pTitleInfo; pTitleInfo = NULL;
							}
						}

                        break;
                    }
                }
            }
        }
        else
        {
            //
            // Open the chm
            //
            if(!pTitleInfo)
            {
                //
                // Create a new one
                //
                __MPC_EXIT_IF_ALLOC_FAILS(hr, pTitleInfo, new CTitleInfo);

                if(!pTitleInfo->OpenTitle( (LPWSTR)m_cfg.m_strCHMFilename.c_str() ))
                {
					delete pTitleInfo; pTitleInfo = NULL;
                }
            }
        }

        if(pTitleInfo)
        {
			SEARCH_RESULT res;

            //
            // Get the topic title
            //
            if(SUCCEEDED(pTitleInfo->GetTopicName( TOPIC_NUM(Prop.dwValue), rgTitle, MAXSTRLEN(rgTitle), cp )))
            {
                res.bstrTopicName = rgTitle;
            }

            //
            // Get the topic location
            //
            if(SUCCEEDED(pTitleInfo->GetLocationName( rgLocation, MAXSTRLEN(rgLocation), cp )))
            {
                res.bstrLocation = rgLocation;
            }

            //
            // Get the topic URL
            //
            if(SUCCEEDED(pTitleInfo->GetTopicURL( TOPIC_NUM(Prop.dwValue), rgURL, MAXSTRLEN(rgURL) )))
            {
                res.bstrTopicURL = rgURL;
            }

			if(res.bstrTopicURL.Length() > 0)
			{
				std::pair<SEARCH_RESULT_SET_ITER,bool> ins = results.insert( res );

				ins.first->dwRank++;

				pPrevResult = &(*ins.first);
			}
        }
    }

    __MPC_FUNC_CLEANUP;

	delete pTitleInfo;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CFTSObject::Query( /*[in]*/ LPCWSTR wszQuery, /*[in]*/ bool bTitle, /*[in]*/ bool bStemming, /*[in/out]*/ SEARCH_RESULT_SET& results, /*[in/out]*/ MPC::WStringSet& words, UINT cp )
{
    __HCP_FUNC_ENTRY( "CFTSObject::Query" );

    HRESULT      hr;
    MPC::wstring strFormatQuery;
    LPWSTR       wszProcessedQuery = NULL;
    static bool  fSkipFirstTime = false;

    __MPC_PARAMCHECK_BEGIN(hr);
    	__MPC_PARAMCHECK_POINTER(wszQuery);
    __MPC_PARAMCHECK_END();

    //
    // Add field identifier to query (VFLD 0 = full content, VFLD 1 = title only)
    //
    if(bTitle) strFormatQuery = L"(VFLD 1 ";
    else       strFormatQuery = L"(VFLD 0 ";

    strFormatQuery += wszQuery;
    strFormatQuery += L")";

    //
    // Process query
    //
    wszProcessedQuery = PreProcessQuery( strFormatQuery.c_str(), CodePageFromLCID(m_lcidLang) );

    //
    // Execute the search on the CHQ
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, Initialize());

    __MPC_EXIT_IF_METHOD_FAILS(hr, ResetQuery( wszProcessedQuery ));
    if(bStemming)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_pQuery->SetOptions( IMPLICIT_AND | QUERY_GETTERMS | STEMMED_SEARCH ));
    }
    else
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_pQuery->SetOptions( IMPLICIT_AND | QUERY_GETTERMS ));
    }

    if(fSkipFirstTime)
    {
        hr = m_pIndex->Search( m_pQuery, m_pITResultSet );
        if(hr == E_NOSTEMMER && bStemming)
        {
            //
            // If won't allow stemmed search, take it out and requery
            //
            __MPC_EXIT_IF_METHOD_FAILS(hr, ResetQuery( wszProcessedQuery ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, m_pQuery->SetOptions( IMPLICIT_AND | QUERY_GETTERMS ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, m_pIndex->Search( m_pQuery, m_pITResultSet ));
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, ProcessResult( results, words, cp ));
    }

    //
    // Check if we have any outdated chms
    //
    //if(m_fOutDated)
    {
        //
        // search the chm that is outdated
        //
        for(int iCount = 0; iCount < (int)m_wCHMInfoCount; iCount++)
        {
            //
            // If the CHM is outdated
            //
            //if(m_cmeCHMInfo[iCount].dwOutDated == 1)
            {
                CFTSObject cftsoCHM;

                //
                // Initialize the sub-object.
                //
				BuildChmPath( cftsoCHM.m_cfg.m_strCHMFilename, m_cmeCHMInfo[iCount].szChmName );

                cftsoCHM.m_cfg.m_dwMaxResult     = m_cfg.m_dwMaxResult    ;
				cftsoCHM.m_cfg.m_wQueryProximity = m_cfg.m_wQueryProximity;
				cftsoCHM.m_lcidLang              = m_lcidLang;

				fSkipFirstTime = true;

                //
                // Execute query
                //
                (void)cftsoCHM.Query( wszQuery, bTitle, bStemming, results, words, cp );
            }
        }
    }

    hr = S_OK;


	__HCP_FUNC_CLEANUP;

	delete [] wszProcessedQuery;

	__HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\wrapper_fts\ftsobj.h ===
#ifndef __ftsobj_H_
#define __ftsobj_H_

#include "stdafx.h"
#include "msitstg.h"
#include <initguid.h>
#include "itrs.h"
#include "itdb.h"
#include "iterror.h"
#include "itgroup.h"
#include "itpropl.h"
#include "itquery.h"
#include "itcc.h"
#include "titleinfo.h"

////////////////////////////////////////////////////////////////////////////////
//
// DON'T TOUCH, FROM HHCTRL SOURCE CODE!!!!!
//
typedef struct CHM_MapEntry
{
    char                szChmName[50];
    WORD                iIndex;
    FILETIME            versioninfo;
    LCID                language;
    DWORD               dwOutDated;
} CHM_MAP_ENTRY;
//
// DON'T TOUCH, FROM HHCTRL SOURCE CODE!!!!!
//
////////////////////////////////////////////////////////////////////////////////

struct SEARCH_RESULT
{
    MPC::wstring strChmName;
    CComBSTR 	 bstrTopicName;
    CComBSTR 	 bstrLocation;
    CComBSTR 	 bstrTopicURL;
    DWORD        dwRank;

    SEARCH_RESULT()
    {
        dwRank = 0;
    }

    bool operator< ( /*[in]*/ SEARCH_RESULT const &res ) const
    {
        return MPC::StrICmp( bstrTopicURL, res.bstrTopicURL ) < 0;
    }
};

typedef std::set< SEARCH_RESULT >         SEARCH_RESULT_SET;
typedef SEARCH_RESULT_SET::iterator       SEARCH_RESULT_SET_ITER;
typedef SEARCH_RESULT_SET::const_iterator SEARCH_RESULT_SET_ITERCONST;


class SEARCH_RESULT_SORTER
{
public:
    bool operator()( SEARCH_RESULT* left, SEARCH_RESULT* right )
    {
		//
		// Rank is sorted from highest to lowest, so negate iCmp;
		//
        int iCmp = -(left->dwRank - right->dwRank);

        if(iCmp < 0) return true;
        if(iCmp > 0) return false;
		
		return MPC::StrICmp( left->bstrTopicName, right->bstrTopicName ) <= 0;
	}
};

typedef std::set< SEARCH_RESULT*, SEARCH_RESULT_SORTER > SEARCH_RESULT_SORTSET;
typedef SEARCH_RESULT_SORTSET::iterator       			 SEARCH_RESULT_SORTSET_ITER;
typedef SEARCH_RESULT_SORTSET::const_iterator 			 SEARCH_RESULT_SORTSET_ITERCONST;

////////////////////////////////////////////////////////////////////////////////

class CFTSObject
{
public:
    struct Config
    {
        MPC::wstring m_strCHMFilename;
        MPC::wstring m_strCHQFilename;
        bool         m_fCombined;
        DWORD        m_dwMaxResult;
        WORD         m_wQueryProximity;

        Config()
        {
            m_fCombined         = false;
            m_dwMaxResult       = 500;
            m_wQueryProximity   = 8;
        }
    };

private:
    Config                m_cfg;

    bool                  m_fInitialized;
    MPC::wstring          m_strCHQPath;

    LCID                  m_lcidLang;
    FILETIME              m_ftVersionInfo;
    DWORD                 m_dwTopicCount;
    WORD                  m_wIndex;

    bool                  m_fOutDated;
    CHM_MAP_ENTRY*        m_cmeCHMInfo;
    WORD                  m_wCHMInfoCount;

    CComPtr<IITIndex>     m_pIndex;
    CComPtr<IITQuery>     m_pQuery;
    CComPtr<IITResultSet> m_pITResultSet;
    CComPtr<IITDatabase>  m_pITDB;

    ////////////////////

	void BuildChmPath( /*[in/out]*/ MPC::wstring& strPath, /*[in]*/ LPCSTR szChmName );

    HRESULT Initialize       (                                         );
    HRESULT LoadCombinedIndex(                                         );
    HRESULT ResetQuery       ( /*[in]*/     LPCWSTR            szQuery );
    HRESULT ProcessResult    ( /*[in/out]*/ SEARCH_RESULT_SET& results, /*[in/out]*/ MPC::WStringSet& words, UINT cp );

public:
    CFTSObject();
    ~CFTSObject();

    Config& GetConfig() { return m_cfg; }

    HRESULT Query( /*[in]*/ LPCWSTR wszQuery, /*[in]*/ bool bTitle, /*[in]*/ bool bStemming, /*[in/out]*/ SEARCH_RESULT_SET& results, /*[in/out]*/ MPC::WStringSet& words, UINT cp );
};

typedef std::list< CFTSObject >            SEARCH_OBJECT_LIST;
typedef SEARCH_OBJECT_LIST::iterator       SEARCH_OBJECT_LIST_ITER;
typedef SEARCH_OBJECT_LIST::const_iterator SEARCH_OBJECT_LIST_ITERCONST;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\wrapper_fts\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__23C95C1F_F8B1_4A62_8F99_CAD1F1AB7339__INCLUDED_)
#define AFX_STDAFX_H__23C95C1F_F8B1_4A62_8F99_CAD1F1AB7339__INCLUDED_

#include <module.h>

#include <MPC_main.h>
#include <MPC_utils.h>
#include <MPC_config.h>

#include <SvcResource.h>

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

#include <seconfig.h>
#include <SearchEngineLib.h>

#include <SearchEngineLib.h>
#include <TaxonomyDatabase.h>

#include "FTSWrap.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__23C95C1F_F8B1_4A62_8F99_CAD1F1AB7339__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\wrapper_fts\ftswrap.h ===
/******************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:
    FTSWrap.h

Abstract:
    Declaration of SearchEngine::WrapperFTS

Revision History:
    Ghim-Sim Chua   (gschua)  06/01/2000
        created

******************************************************************************/

#ifndef __PCHSEWRAP_H_
#define __PCHSEWRAP_H_

#include <SearchEngineLib.h>

#include "ftsobj.h"

namespace SearchEngine
{
    /////////////////////////////////////////////////////////////////////////////

    class ATL_NO_VTABLE WrapperFTS : public WrapperBase, public MPC::Thread<WrapperFTS,IUnknown>
    {
        SEARCH_OBJECT_LIST    m_objects;
        SEARCH_RESULT_SET     m_results;
        SEARCH_RESULT_SORTSET m_resultsSorted;
        CComVariant           m_vKeywords;

        ////////////////////////////////////////

        void ReleaseAll          ();
        void ReleaseSearchResults();

        HRESULT ExecQuery();

        HRESULT Initialize();

    public:
    BEGIN_COM_MAP(WrapperFTS)
        COM_INTERFACE_ENTRY2(IDispatch,IPCHSEWrapperItem)
        COM_INTERFACE_ENTRY(IPCHSEWrapperItem)
        COM_INTERFACE_ENTRY(IPCHSEWrapperInternal)
    END_COM_MAP()

        WrapperFTS();
        virtual ~WrapperFTS();

        virtual HRESULT GetParamDefinition( /*[out]*/ const ParamItem_Definition*& lst, /*[out]*/ int& len );

    // IPCHSEWrapperItem
    public:
        STDMETHOD(get_SearchTerms)( /*[out, retval]*/ VARIANT *pVal );

        STDMETHOD(Result)( /*[in]*/ long lStart, /*[in]*/ long lEnd, /*[out, retval]*/ IPCHCollection* *ppC );

    // IPCHSEWrapperInternal
    public:
        STDMETHOD(ExecAsyncQuery)();
        STDMETHOD(AbortQuery    )();
    };
};

#endif //__PCHSEWRAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\wrapper_fts\ftswrap.cpp ===
/******************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:
    FTSWrap.cpp

Abstract:
    Implementation of SearchEngine::WrapperFTS

Revision History:
    Ghim-Sim Chua   (gschua)  06/01/2000
        created

******************************************************************************/

#include "stdafx.h"

#include "msitstg.h"
#include "itrs.h"
#include "itdb.h"
#include "iterror.h"
#include "itgroup.h"
#include "itpropl.h"
#include "itquery.h"
#include "itcc.h"
#include "ftsobj.h"
#include "fs.h"

////////////////////////////////////////////////////////////////////////////////

static bool local_ExpandURL( /*[in ]*/ Taxonomy::Updater&  updater  ,
                             /*[in ]*/ const MPC::wstring& strSrc   ,
                             /*[in ]*/ LPCWSTR             szPrefix ,
                             /*[out]*/ MPC::wstring&       strDst   )
{
    strDst  = szPrefix;
    strDst += strSrc;

    if(SUCCEEDED(updater.ExpandURL( strDst )))
    {
        if(MPC::FileSystemObject::IsFile( strDst.c_str() )) return true;
    }

    return false;
}

static void local_GenerateFullURL( /*[in ]*/ Taxonomy::Updater&  updater ,
                                   /*[in ]*/ const MPC::wstring& strSrc  ,
                                   /*[out]*/ MPC::wstring&       strDst  )
{
    if(strSrc.size())
    {
        if(local_ExpandURL( updater, strSrc, L"%HELP_LOCATION%\\", strDst )) return;
        if(local_ExpandURL( updater, strSrc, L"%WINDIR%\\Help\\" , strDst )) return;
    }

    strDst = L"";
}

////////////////////////////////////////////////////////////////////////////////


SearchEngine::WrapperFTS::WrapperFTS()
{
    // SEARCH_OBJECT_LIST    m_objects;
    // SEARCH_RESULT_SET     m_results;
    // SEARCH_RESULT_SORTSET m_resultsSorted;

    MPC::LocalizeString( IDS_HELPSVC_SEMGR_OWNER   , m_bstrOwner      , /*fMUI*/true );
    MPC::LocalizeString( IDS_HELPSVC_SEMGR_FTS_NAME, m_bstrName       , /*fMUI*/true );
    MPC::LocalizeString( IDS_HELPSVC_SEMGR_FTS_DESC, m_bstrDescription, /*fMUI*/true );

    m_bstrHelpURL = L"hcp://system/blurbs/ftshelp.htm";
    m_bstrID      = L"9A22481C-1795-46f3-8CCA-7D78E9E54112";
}

SearchEngine::WrapperFTS::~WrapperFTS()
{
    Thread_Wait();

    ReleaseAll();
}

HRESULT SearchEngine::WrapperFTS::GetParamDefinition( /*[out]*/ const ParamItem_Definition*& lst, /*[out]*/ int& len )
{
    static const ParamItem_Definition c_lst[] =
    {
        { PARAM_BOOL, VARIANT_FALSE, VARIANT_TRUE , L"TITLEONLY", IDS_HELPSVC_TITLE_ONLY, NULL, L"false" },
        { PARAM_BOOL, VARIANT_FALSE, VARIANT_TRUE , L"STEMMING" , IDS_HELPSVC_STEMMING  , NULL, L"false" },
        { PARAM_BOOL, VARIANT_FALSE, VARIANT_FALSE, L"UI_BULLET", 0                     , NULL, L"false" },
    };

    lst =           c_lst;
    len = ARRAYSIZE(c_lst);

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////

void SearchEngine::WrapperFTS::ReleaseAll()
{
    ReleaseSearchResults();

    m_objects.clear();
}

void SearchEngine::WrapperFTS::ReleaseSearchResults()
{
    m_results      .clear();
    m_resultsSorted.clear();
}

////////////////////////////////////////////////////////////////////////////////

HRESULT SearchEngine::WrapperFTS::ExecQuery()
{
    __HCP_FUNC_ENTRY( "SearchEngine::WrapperFTS::ExecQuery" );

    HRESULT          hr;
    long             lCount;
    long             lIndex = 0;
    MPC::WStringSet  wordsSet;
    MPC::WStringList wordsList;
    
    if(m_bEnabled)
    {
        CComBSTR bstrName;
        VARIANT* v;
        bool     bTitle;
        bool     bStemming;

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::LocalizeString( IDS_HELPSVC_SEMGR_FTS_NAME, bstrName, /*fMUI*/true ));

        if(m_bstrQueryString.Length() == 0)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_INVALID_DATA);
        }

      
        __MPC_EXIT_IF_METHOD_FAILS(hr, Initialize());
        

        //
        // Check if search in titles only
        //
        v = GetParamInternal( L"TITLEONLY" );
        bTitle = (v && v->vt == VT_BOOL && v->boolVal) ? true : false;

        //
        // Check if stemming is turned on
        //
        v = GetParamInternal( L"STEMMING" );
        bStemming = (v && v->vt == VT_BOOL && v->boolVal) ? true : false;

		//
		// Compute the code page each query, as the user may have changed the language using MUI between queries
		//
		UINT	cp = CP_ACP;
		WCHAR wchLocale[10];
		if (GetLocaleInfo(m_ths.GetLanguage(), LOCALE_IDEFAULTANSICODEPAGE, wchLocale, ARRAYSIZE(wchLocale)))
		   cp = wcstoul(wchLocale, NULL, 10);
		else
		   cp = CP_ACP;
        
		//
        // Execute the queries
        //
        for(SEARCH_OBJECT_LIST_ITER it = m_objects.begin(); (it != m_objects.end()) && (!Thread_IsAborted()); it++)
        {
            (void)it->Query( m_bstrQueryString, bTitle, bStemming, m_results, wordsSet, cp );
        }

		if(Thread_IsAborted()) __MPC_SET_ERROR_AND_EXIT(hr, E_ABORT);


        for(SEARCH_RESULT_SET_ITER it2 = m_results.begin(); (it2 != m_results.end()) && (!Thread_IsAborted()); it2++)
        {
            m_resultsSorted.insert( &(*it2) );
        }

		if(Thread_IsAborted()) __MPC_SET_ERROR_AND_EXIT(hr, E_ABORT);

        //
        // Copy the Highlight words from set to list
        //
        for(MPC::WStringSetIter itString = wordsSet.begin(); (itString != wordsSet.end()) && (!Thread_IsAborted()); itString++)
        {
            wordsList.push_back( *itString );
        }

		if(Thread_IsAborted()) __MPC_SET_ERROR_AND_EXIT(hr, E_ABORT);

        //
        // Store Highlight words in safe array
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertListToSafeArray( wordsList, m_vKeywords, VT_VARIANT ));
    }

    hr = S_OK;

    __MPC_FUNC_CLEANUP;

    Thread_Abort();

    //
    // Call the SearchManager's OnComplete
    //
    (void)m_pSEMgr->WrapperComplete( hr, this );

    __MPC_FUNC_EXIT(hr);
}

STDMETHODIMP SearchEngine::WrapperFTS::get_SearchTerms( /*[out, retval]*/ VARIANT *pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return ::VariantCopy( pVal, &m_vKeywords );
}

HRESULT SearchEngine::WrapperFTS::Initialize()
{
    __HCP_FUNC_ENTRY( "SearchEngine::WrapperFTS::Initialize" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    Taxonomy::Settings           ts( m_ths );
    JetBlue::SessionHandle       handle;
    JetBlue::Database*           db;
    Taxonomy::Updater            updater;
    Taxonomy::RS_FullTextSearch* rsFTS;
    Taxonomy::RS_Scope*          rsSCOPE;
    long                         ID_scope = -1;
    bool                         fFound;


    //
    // Clean previous search results.
    //
    //ReleaseSearchResults();
    ReleaseAll();


    __MPC_EXIT_IF_METHOD_FAILS(hr, ts     .GetDatabase      ( handle,  db, /*fReadOnly*/true ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, updater.Init             ( ts    ,  db                    ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, updater.GetFullTextSearch(         &rsFTS                 ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, updater.GetScope         (         &rsSCOPE               ));

    ////////////////////////////////////////

    if(m_bstrScope)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, rsSCOPE->Seek_ByID( m_bstrScope, &fFound ));
        if(fFound)
        {
            ID_scope = rsSCOPE->m_ID_scope;
        }
    }

    if(ID_scope == -1)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, rsSCOPE->Seek_ByID( L"<SYSTEM>", &fFound ));
        if(fFound)
        {
            ID_scope = rsSCOPE->m_ID_scope;
        }
    }

    ////////////////////////////////////////

    //
    // Create the search objects.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, rsFTS->Move( 0, JET_MoveFirst, &fFound ));
    while(fFound)
    {
        if(rsFTS->m_ID_scope == ID_scope)
        {
            CFTSObject&         obj = *(m_objects.insert( m_objects.end() ));
            CFTSObject::Config& cfg = obj.GetConfig();

            local_GenerateFullURL( updater, rsFTS->m_strCHM, cfg.m_strCHMFilename );
            local_GenerateFullURL( updater, rsFTS->m_strCHQ, cfg.m_strCHQFilename );

            if(cfg.m_strCHQFilename.size())
            {
                cfg.m_fCombined = true;
            }
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, rsFTS->Move( 0, JET_MoveNext, &fFound ));
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP SearchEngine::WrapperFTS::Result( /*[in]*/ long lStart, /*[in]*/ long lEnd, /*[out,retval]*/ IPCHCollection* *ppC )
{
    __HCP_FUNC_ENTRY( "SearchEngine::WrapperFTS::Result" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    CComPtr<CPCHCollection>      pColl;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(ppC,NULL);
    __MPC_PARAMCHECK_END();

    //
    // Create the Enumerator and fill it with jobs.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pColl ));

    if(m_bEnabled)
    {
        long lCount = 0;

        for(SEARCH_RESULT_SORTSET_ITER it = m_resultsSorted.begin(); (lCount < m_lNumResult) && (it != m_resultsSorted.end()); it++, lCount++)
        {
            //
            // if there is a URL
            //
            if(lCount >= lStart &&
               lCount <  lEnd    )
            {
                CComPtr<ResultItem> pRIObj;

                //
                // Create the item to be inserted into the list
                //
                __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pRIObj ));

                {
                    ResultItem_Data& data = pRIObj->Data();
                    SEARCH_RESULT*   res  = *it;

                    data.m_bstrTitle    = res->bstrTopicName;
                    data.m_bstrLocation = res->bstrLocation;
                    
                    data.m_bstrURI      = res->bstrTopicURL;
                }

                //
                // Add to enumerator
                //
                __MPC_EXIT_IF_METHOD_FAILS(hr, pColl->AddItem( pRIObj ));
            }
        }
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, pColl.QueryInterface( ppC ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP SearchEngine::WrapperFTS::AbortQuery()
{
    //
    // Abort any threads still running
    //
    Thread_Abort();

    return S_OK;
}


STDMETHODIMP SearchEngine::WrapperFTS::ExecAsyncQuery()
{
    __HCP_FUNC_ENTRY( "SearchEngine::WrapperFTS::ExecAsyncQuery" );

    HRESULT hr;

    //
    // Create a thread to execute the query
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, Thread_Start( this, ExecQuery, NULL ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT SearchEngine::WrapperItem__Create_FullTextSearch( /*[out]*/ CComPtr<IPCHSEWrapperInternal>& pVal )
{
    __HCP_FUNC_ENTRY( "CPCHSEWrapperItem__Create_FullTextSearch" );

    HRESULT                           hr;
    CComPtr<SearchEngine::WrapperFTS> pFTS;


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pFTS ));

    pVal = pFTS;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\wrapper_keyword\pchsewrap.h ===
/******************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:
    PCHSEWrap.h

Abstract:
    Declaration of SearchEngine::WrapperKeyword

Revision History:
    Davide Massarenti   (dmassare)  06/01/2001
        created

******************************************************************************/

#ifndef __PCHSEWRAP_H_
#define __PCHSEWRAP_H_

#include <SearchEngineLib.h>


namespace SearchEngine
{
    class ATL_NO_VTABLE WrapperKeyword : public WrapperBase, public MPC::Thread<WrapperKeyword,IUnknown>
    {
        CPCHQueryResultCollection* m_Results;
        CComVariant                m_vKeywords;

        ////////////////////////////////////////

        HRESULT ExecQuery();

    public:
    BEGIN_COM_MAP(WrapperKeyword)
        COM_INTERFACE_ENTRY2(IDispatch,IPCHSEWrapperItem)
        COM_INTERFACE_ENTRY(IPCHSEWrapperItem)
        COM_INTERFACE_ENTRY(IPCHSEWrapperInternal)
    END_COM_MAP()

        WrapperKeyword();
        virtual ~WrapperKeyword();

        virtual HRESULT GetParamDefinition( /*[out]*/ const ParamItem_Definition*& lst, /*[out]*/ int& len );

    // IPCHSEWrapperItem
    public:
        STDMETHOD(get_SearchTerms)( /*[out, retval]*/ VARIANT *pVal );

        STDMETHOD(Result)( /*[in]*/ long lStart, /*[in]*/ long lEnd, /*[out, retval]*/ IPCHCollection* *ppC );

    // IPCHSEWrapperInternal
    public:
        STDMETHOD(ExecAsyncQuery)();
        STDMETHOD(AbortQuery    )();
    };
};

#endif //__PCHSEWRAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\wrapper_keyword\pchsewrap.cpp ===
/******************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:
    PCHSEWrap.cpp

Abstract:
    Implementation of SearchEngine::WrapperKeyword

Revision History:
    Davide Massarenti   (dmassare)  06/01/2001
        created

******************************************************************************/

#include "stdafx.h"

SearchEngine::WrapperKeyword::WrapperKeyword()
{
    m_Results = NULL; // CPCHQueryResultCollection* m_Results;
                      // CComVariant                m_vKeywords;

    MPC::LocalizeString( IDS_HELPSVC_SEMGR_OWNER  , m_bstrOwner      , /*fMUI*/true );
    MPC::LocalizeString( IDS_HELPSVC_SEMGR_KW_NAME, m_bstrName       , /*fMUI*/true );
    MPC::LocalizeString( IDS_HELPSVC_SEMGR_KW_DESC, m_bstrDescription, /*fMUI*/true );

    m_bstrHelpURL = L"hcp://system/blurbs/keywordhelp.htm";
    m_bstrID      = L"9488F2E9-47AF-46da-AE4A-86372DEBD56C";
}

SearchEngine::WrapperKeyword::~WrapperKeyword()
{
    Thread_Wait();

    MPC::Release( m_Results );
}

HRESULT SearchEngine::WrapperKeyword::GetParamDefinition( /*[out]*/ const ParamItem_Definition*& lst, /*[out]*/ int& len )
{
    static const ParamItem_Definition c_lst[] =
    {
        { PARAM_BSTR, VARIANT_FALSE, VARIANT_FALSE, L"SUBSITE"  , 0, L"Name of subsite to search", NULL    },
        { PARAM_BOOL, VARIANT_FALSE, VARIANT_FALSE, L"UI_BULLET", 0, L"UI_BULLET"                , L"true" },
    };

    lst =           c_lst;
    len = ARRAYSIZE(c_lst);

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP SearchEngine::WrapperKeyword::Result( /*[in]*/ long lStart, /*[in]*/ long lEnd, /*[out,retval]*/ IPCHCollection* *ppC )
{
    __HCP_FUNC_ENTRY( "SearchEngine::WrapperKeyword::Result" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    CComPtr<CPCHCollection>      pColl;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(ppC,NULL);
    __MPC_PARAMCHECK_END();

    //
    // Create the Enumerator and fill it with jobs.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pColl ));

    //
    // If there are results
    //
    if(m_Results && m_bEnabled)
    {
        long lSize = m_Results->Size();
        long lPos;

        //
        // Loop thru all results to generate Enumerator
        //
        for(lPos=0; lPos<lSize; lPos++)
        {
            //
            // Check if they are between start and end
            //
            if(lPos >= lStart && lPos < lEnd)
            {
                CComPtr<CPCHQueryResult> obj;

                if(SUCCEEDED(m_Results->GetItem( lPos, &obj )) && obj)
                {
                    CComPtr<SearchEngine::ResultItem> pRIObj;

                    //
                    // Create the item to be inserted into the list
                    //
                    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pRIObj ));

                    {
                        ResultItem_Data&                dataDst = pRIObj->Data();
                        const CPCHQueryResult::Payload& dataSrc = obj->GetData();

                        dataDst.m_bstrTitle       = dataSrc.m_bstrTitle;
                        dataDst.m_bstrURI         = dataSrc.m_bstrTopicURL;
                        dataDst.m_bstrDescription = dataSrc.m_bstrDescription;
                        dataDst.m_lContentType    = dataSrc.m_lType;
                        dataDst.m_dRank           = -1.0;
                    }

                    //
                    // Add to enumerator
                    //
                    __MPC_EXIT_IF_METHOD_FAILS(hr, pColl->AddItem( pRIObj ));
                }
            }
        }
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, pColl.QueryInterface( ppC ));

    hr = S_OK;

    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

STDMETHODIMP SearchEngine::WrapperKeyword::get_SearchTerms( /*[out, retval]*/ VARIANT *pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return ::VariantCopy( pVal, &m_vKeywords );
}


/////////////////////////////////////////////////////////////////////////////
// SearchEngine::WrapperKeyword : IPCHSEWrapperInternal

STDMETHODIMP SearchEngine::WrapperKeyword::AbortQuery()
{
    //
    // Abort any threads still running
    //
    Thread_Abort();

    return S_OK;
}

STDMETHODIMP SearchEngine::WrapperKeyword::ExecAsyncQuery()
{
    __HCP_FUNC_ENTRY( "SearchEngine::WrapperKeyword::ExecAsyncQuery" );

    HRESULT hr;

    //
    // Create a thread to execute the query
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, Thread_Start( this, ExecQuery, NULL ));

    hr = S_OK;

    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT SearchEngine::WrapperKeyword::ExecQuery()
{
    __HCP_FUNC_ENTRY( "SearchEngine::WrapperKeyword::ExecQuery" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

    if(m_bEnabled)
    {
        CComBSTR         bstrSubSite;
        MPC::WStringList lst;

        if(m_bstrQueryString.Length() == 0)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_INVALID_DATA);
        }

        //
        // If previous results exist, release it
        //
        MPC::Release( m_Results );

        //
        // Create a new collection
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &m_Results ));

        //
        // Check if search in subsite
        //
        {
            VARIANT* v = GetParamInternal( L"SUBSITE" );

            if(v && v->vt == VT_BSTR) bstrSubSite = v->bstrVal;
        }

        //
        // Execute the query
        //
        {
            Taxonomy::Settings ts( m_ths );

            __MPC_EXIT_IF_METHOD_FAILS(hr, ts.KeywordSearch( m_bstrQueryString, bstrSubSite, m_Results, &lst ));
        }

        //
        // Sort, first by Priority, then by Content Type.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_Results->Sort( CPCHQueryResultCollection::SORT_BYPRIORITY   , m_lNumResult ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_Results->Sort( CPCHQueryResultCollection::SORT_BYCONTENTTYPE               ));

        //
        // Get the list of keywords.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertListToSafeArray( lst, m_vKeywords, VT_VARIANT ));
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    Thread_Abort();

    //
    // Call the SearchManager's OnComplete
    //
    (void)m_pSEMgr->WrapperComplete( hr, this );

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT SearchEngine::WrapperItem__Create_Keyword( /*[out]*/ CComPtr<IPCHSEWrapperInternal>& pVal )
{
    __HCP_FUNC_ENTRY( "SearchEngine::WrapperKeywordperItem__Create_Keyword" );

    HRESULT                               hr;
    CComPtr<SearchEngine::WrapperKeyword> pKW;


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pKW ));

    pVal = pKW;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\searchenginelib\wrapper_keyword\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__23C95C1F_F8B1_4A62_8F99_CAD1F1AB7339__INCLUDED_)
#define AFX_STDAFX_H__23C95C1F_F8B1_4A62_8F99_CAD1F1AB7339__INCLUDED_

#include <module.h>

#include <MPC_main.h>
#include <MPC_utils.h>
#include <MPC_config.h>
#include <SvcResource.h>

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>
#include <seconfig.h>
#include <SearchEngineLib.h>
#include <TaxonomyDatabase.h>
#include <Utility.h>
#include "PCHSEWrap.h"
#include <QueryResult.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__23C95C1F_F8B1_4A62_8F99_CAD1F1AB7339__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\security\accesscontrolentry.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    AccessControlEntry.cpp

Abstract:
    This file contains the implementation of the CPCHAccessControlEntry class,
	which is used to represent an access control entry.

Revision History:
    Davide Massarenti   (Dmassare)  03/22/2000
        created

******************************************************************************/

#include "StdAfx.h"

////////////////////////////////////////////////////////////////////////////////
//
//  AccessControlEntry [@AccessMask
//                      @AceFlags
//                      @AceType
//                      @Flags]
//
//      Trustee
//      ObjectType
//      InheritedOjectType
//
////////////////////////////////////////////////////////////////////////////////

static const CComBSTR s_TAG_ACE            	   ( L"AccessControlEntry" 	);
static const CComBSTR s_ATTR_ACE_AccessMask	   ( L"AccessMask"         	);
static const CComBSTR s_ATTR_ACE_AceFlags  	   ( L"AceFlags"           	);
static const CComBSTR s_ATTR_ACE_AceType   	   ( L"AceType"	           	);
static const CComBSTR s_ATTR_ACE_Flags     	   ( L"Flags"	           	);

static const CComBSTR s_TAG_Trustee            ( L"Trustee"             );
static const CComBSTR s_TAG_ObjectType         ( L"ObjectType"          );
static const CComBSTR s_TAG_InheritedObjectType( L"InheritedObjectType" );

////////////////////////////////////////////////////////////////////////////////

CPCHAccessControlEntry::CPCHAccessControlEntry()
{
    m_dwAccessMask = 0;	// DWORD     m_dwAccessMask;
    m_dwAceFlags   = 0;	// DWORD     m_dwAceFlags;
    m_dwAceType    = 0;	// DWORD     m_dwAceType;
    m_dwFlags      = 0;	// DWORD     m_dwFlags;
						// 
    					// CComBSTR  m_bstrTrustee;
    					// CComBSTR  m_bstrObjectType;
    					// CComBSTR  m_bstrInheritedObjectType;
}

CPCHAccessControlEntry::~CPCHAccessControlEntry()
{
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHAccessControlEntry::get_AccessMask( /*[out, retval]*/ long *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHAccessControlEntry::get_AccessMask",hr,pVal);

	*pVal = m_dwAccessMask;

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHAccessControlEntry::put_AccessMask( /*[in]*/ long newVal )
{
    __HCP_BEGIN_PROPERTY_PUT("CPCHAccessControlEntry::put_AccessMask",hr);

	m_dwAccessMask = newVal;

    __HCP_END_PROPERTY(hr);
}

////////////////////

STDMETHODIMP CPCHAccessControlEntry::get_AceType( /*[out, retval]*/ long *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHAccessControlEntry::get_AceType",hr,pVal);

	*pVal = m_dwAceType;

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHAccessControlEntry::put_AceType( /*[in]*/ long newVal )
{
    __HCP_BEGIN_PROPERTY_PUT("CPCHAccessControlEntry::put_AceType",hr);

	m_dwAceType = newVal;

    __HCP_END_PROPERTY(hr);
}

////////////////////

STDMETHODIMP CPCHAccessControlEntry::get_AceFlags( /*[out, retval]*/ long *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHAccessControlEntry::get_AceFlags",hr,pVal);

	*pVal = m_dwAceFlags;

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHAccessControlEntry::put_AceFlags( /*[in]*/ long newVal )
{
    __HCP_BEGIN_PROPERTY_PUT("CPCHAccessControlEntry::put_AceFlags",hr);

	m_dwAceFlags = newVal;

    __HCP_END_PROPERTY(hr);
}

////////////////////

STDMETHODIMP CPCHAccessControlEntry::get_Flags( /*[out, retval]*/ long *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHAccessControlEntry::get_Flags",hr,pVal);

	*pVal = m_dwFlags;

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHAccessControlEntry::put_Flags( /*[in]*/ long newVal )
{
    __HCP_BEGIN_PROPERTY_PUT("CPCHAccessControlEntry::put_Flags",hr);

	m_dwFlags = newVal;

    __HCP_END_PROPERTY(hr);
}

////////////////////

STDMETHODIMP CPCHAccessControlEntry::get_Trustee( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHAccessControlEntry::get_Trustee",hr,pVal);

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_bstrTrustee, pVal ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHAccessControlEntry::put_Trustee( /*[in]*/ BSTR newVal )
{
    __HCP_BEGIN_PROPERTY_PUT("CPCHAccessControlEntry::put_Trustee",hr);

	if(newVal)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, CPCHSecurityDescriptorDirect::VerifyPrincipal( newVal ));
	}

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::PutBSTR( m_bstrTrustee, newVal, false ));

    __HCP_END_PROPERTY(hr);
}

////////////////////

STDMETHODIMP CPCHAccessControlEntry::get_ObjectType( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHAccessControlEntry::get_ObjectType",hr,pVal);

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_bstrObjectType, pVal ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHAccessControlEntry::put_ObjectType( /*[in]*/ BSTR newVal )
{
    __HCP_BEGIN_PROPERTY_PUT("CPCHAccessControlEntry::put_ObjectType",hr);

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::PutBSTR( m_bstrObjectType, newVal ));

    __HCP_END_PROPERTY(hr);
}

////////////////////

STDMETHODIMP CPCHAccessControlEntry::get_InheritedObjectType( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHAccessControlEntry::get_InheritedObjectType",hr,pVal);

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_bstrInheritedObjectType, pVal ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHAccessControlEntry::put_InheritedObjectType( /*[in]*/ BSTR newVal )
{
    __HCP_BEGIN_PROPERTY_PUT("CPCHAccessControlEntry::put_InheritedObjectType",hr);

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::PutBSTR( m_bstrInheritedObjectType, newVal ));

    __HCP_END_PROPERTY(hr);
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHAccessControlEntry::IsEquivalent( /*[in         ]*/ IPCHAccessControlEntry*  pAce ,
												   /*[out, retval]*/ VARIANT_BOOL            *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHAccessControlEntry::IsEquivalent" );

	HRESULT  hr;
    long 	 lAccessMask;
    long 	 lAceFlags;
    long 	 lAceType;
    long 	 lFlags;
    CComBSTR bstrTrustee;
    CComBSTR bstrObjectType;
    CComBSTR bstrInheritedObjectType;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_NOTNULL(pAce);
		__MPC_PARAMCHECK_POINTER_AND_SET(pVal,VARIANT_FALSE);
	__MPC_PARAMCHECK_END();


	__MPC_EXIT_IF_METHOD_FAILS(hr, pAce->get_AccessMask( &lAccessMask ));
	if(m_dwAccessMask != lAccessMask)
	{
		__MPC_SET_ERROR_AND_EXIT(hr, S_OK);
	}

	__MPC_EXIT_IF_METHOD_FAILS(hr, pAce->get_AceFlags( &lAceFlags ));
	if(m_dwAceFlags != lAceFlags)
	{
		__MPC_SET_ERROR_AND_EXIT(hr, S_OK);
	}

	__MPC_EXIT_IF_METHOD_FAILS(hr, pAce->get_AceType( &lAceType ));
	if(m_dwAceType != lAceType)
	{
		__MPC_SET_ERROR_AND_EXIT(hr, S_OK);
	}

	__MPC_EXIT_IF_METHOD_FAILS(hr, pAce->get_Flags( &lFlags ));
	if(m_dwFlags != lFlags)
	{
		__MPC_SET_ERROR_AND_EXIT(hr, S_OK);
	}

	__MPC_EXIT_IF_METHOD_FAILS(hr, pAce->get_Trustee( &bstrTrustee ));
	if(MPC::StrICmp( m_bstrTrustee, bstrTrustee ))
	{
		__MPC_SET_ERROR_AND_EXIT(hr, S_OK);
	}

	__MPC_EXIT_IF_METHOD_FAILS(hr, pAce->get_ObjectType( &bstrObjectType ));
	if(MPC::StrICmp( m_bstrObjectType, bstrObjectType ))
	{
		__MPC_SET_ERROR_AND_EXIT(hr, S_OK);
	}

	__MPC_EXIT_IF_METHOD_FAILS(hr, pAce->get_InheritedObjectType( &bstrInheritedObjectType ));
	if(MPC::StrICmp( m_bstrInheritedObjectType, bstrInheritedObjectType ))
	{
		__MPC_SET_ERROR_AND_EXIT(hr, S_OK);
	}

    *pVal = VARIANT_TRUE;
    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHAccessControlEntry::Clone( /*[out, retval]*/ IPCHAccessControlEntry* *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHAccessControlEntry::Clone" );

    HRESULT                         hr;
    MPC::SmartLock<_ThreadModel>    lock( this );
    CComPtr<CPCHAccessControlEntry> pNew;
    CPCHAccessControlEntry*         pPtr;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
	__MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pNew ));

	pPtr = pNew;

    pPtr->m_dwAccessMask            = m_dwAccessMask;
    pPtr->m_dwAceFlags              = m_dwAceFlags;
    pPtr->m_dwAceType               = m_dwAceType;
    pPtr->m_dwFlags                 = m_dwFlags;
			                       	                        
    pPtr->m_bstrTrustee             = m_bstrTrustee;
    pPtr->m_bstrObjectType          = m_bstrObjectType;
    pPtr->m_bstrInheritedObjectType = m_bstrInheritedObjectType;

    __MPC_EXIT_IF_METHOD_FAILS(hr, pNew.QueryInterface( pVal ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHAccessControlEntry::LoadPost( /*[in]*/ MPC::XmlUtil& xml )
{
    __HCP_FUNC_ENTRY( "CPCHAccessControlEntry::LoadPost" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
	CComPtr<IXMLDOMNode>         xdnNode;
	CComBSTR                     bstrValue;                 
	LONG                         lValue;
	bool                         fFound;


	//
	// Make sure we have something to parse....
	//
	__MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetRoot( &xdnNode )); xdnNode.Release();


	//
	// Clean up before loading.
	//
    m_dwAccessMask = 0;
    m_dwAceFlags   = 0;
    m_dwAceType    = 0;
    m_dwFlags      = 0;

    m_bstrTrustee            .Empty();
    m_bstrObjectType         .Empty();
    m_bstrInheritedObjectType.Empty();
	

	//
	// Read attributes.
	//
	__MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( NULL, s_ATTR_ACE_AccessMask, lValue, fFound )); if(fFound) m_dwAccessMask = lValue;
	__MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( NULL, s_ATTR_ACE_AceFlags  , lValue, fFound )); if(fFound) m_dwAceFlags   = lValue;
	__MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( NULL, s_ATTR_ACE_AceType   , lValue, fFound )); if(fFound) m_dwAceType    = lValue;
	__MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( NULL, s_ATTR_ACE_Flags     , lValue, fFound )); if(fFound) m_dwFlags      = lValue;

	//
	// Read values.
	//
	__MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetValue( s_TAG_Trustee            , bstrValue, fFound )); if(fFound) m_bstrTrustee            .Attach( bstrValue.Detach() ); 
	__MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetValue( s_TAG_ObjectType         , bstrValue, fFound )); if(fFound) m_bstrObjectType         .Attach( bstrValue.Detach() ); 
	__MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetValue( s_TAG_InheritedObjectType, bstrValue, fFound )); if(fFound) m_bstrInheritedObjectType.Attach( bstrValue.Detach() ); 


	if(m_bstrTrustee.Length())
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, CPCHSecurityDescriptorDirect::VerifyPrincipal( m_bstrTrustee ));
	}


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHAccessControlEntry::LoadXML( /*[in]*/ IXMLDOMNode* xdnNode )
{
    __HCP_FUNC_ENTRY( "CPCHAccessControlEntry::LoadXML" );

	HRESULT      hr;
	MPC::XmlUtil xml( xdnNode );

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_NOTNULL(xdnNode);
	__MPC_PARAMCHECK_END();


	__MPC_EXIT_IF_METHOD_FAILS(hr, LoadPost( xml ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHAccessControlEntry::LoadXMLAsString( /*[in]*/ BSTR bstrVal )
{
    __HCP_FUNC_ENTRY( "CPCHAccessControlEntry::LoadXMLAsString" );

	HRESULT      hr;
	MPC::XmlUtil xml;
	bool         fLoaded;
	bool         fFound;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrVal);
	__MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.LoadAsString( bstrVal, s_TAG_ACE, fLoaded, &fFound ));
	if(fLoaded == false || fFound == false)
	{
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_BAD_FORMAT);
    }


	__MPC_EXIT_IF_METHOD_FAILS(hr, LoadPost( xml ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHAccessControlEntry::LoadXMLAsStream( /*[in]*/ IUnknown* pStream )
{
    __HCP_FUNC_ENTRY( "CPCHAccessControlEntry::LoadXMLAsStream" );

	HRESULT      hr;
	MPC::XmlUtil xml;
	bool         fLoaded;
	bool         fFound;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_NOTNULL(pStream);
	__MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.LoadAsStream( pStream, s_TAG_ACE, fLoaded, &fFound ));
	if(fLoaded == false || fFound == false)
	{
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_BAD_FORMAT);
    }


	__MPC_EXIT_IF_METHOD_FAILS(hr, LoadPost( xml ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHAccessControlEntry::SavePre( /*[in]*/ MPC::XmlUtil& xml )
{
    __HCP_FUNC_ENTRY( "CPCHAccessControlEntry::SavePre" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
	CComPtr<IXMLDOMNode>         xdnNode;
	bool                         fFound;


	__MPC_EXIT_IF_METHOD_FAILS(hr, xml.CreateNode( s_TAG_ACE, &xdnNode ));

	//
	// Write attributes.
	//
	__MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, s_ATTR_ACE_AccessMask, m_dwAccessMask, fFound, xdnNode ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, s_ATTR_ACE_AceFlags  , m_dwAceFlags  , fFound, xdnNode ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, s_ATTR_ACE_AceType   , m_dwAceType   , fFound, xdnNode ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, s_ATTR_ACE_Flags     , m_dwFlags     , fFound, xdnNode ));


	//
	// Write values.
	//
	if(m_bstrTrustee            ) __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutValue( s_TAG_Trustee            , m_bstrTrustee            , fFound, xdnNode ));
	if(m_bstrObjectType         ) __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutValue( s_TAG_ObjectType         , m_bstrObjectType         , fFound, xdnNode ));
	if(m_bstrInheritedObjectType) __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutValue( s_TAG_InheritedObjectType, m_bstrInheritedObjectType, fFound, xdnNode ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHAccessControlEntry::SaveXML( /*[in         ]*/ IXMLDOMNode*  xdnRoot  ,
											  /*[out, retval]*/ IXMLDOMNode* *pxdnNode )
{
    __HCP_FUNC_ENTRY( "CPCHAccessControlEntry::SaveXML" );

    HRESULT      hr;
	MPC::XmlUtil xml( xdnRoot );

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_NOTNULL(xdnRoot);
		__MPC_PARAMCHECK_POINTER_AND_SET(pxdnNode,NULL);
	__MPC_PARAMCHECK_END();


	__MPC_EXIT_IF_METHOD_FAILS(hr, SavePre( xml ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHAccessControlEntry::SaveXMLAsString( /*[out, retval]*/ BSTR *bstrVal )
{
    __HCP_FUNC_ENTRY( "CPCHAccessControlEntry::SaveXMLAsString" );

    HRESULT      hr;
	MPC::XmlUtil xml;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_POINTER_AND_SET(bstrVal,NULL);
	__MPC_PARAMCHECK_END();


	__MPC_EXIT_IF_METHOD_FAILS(hr, SavePre( xml ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, xml.SaveAsString( bstrVal ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHAccessControlEntry::SaveXMLAsStream( /*[out, retval]*/ IUnknown* *pStream )
{
    __HCP_FUNC_ENTRY( "CPCHAccessControlEntry::SaveXMLAsStream" );

    HRESULT      hr;
	MPC::XmlUtil xml;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_POINTER_AND_SET(pStream,NULL);
	__MPC_PARAMCHECK_END();


	__MPC_EXIT_IF_METHOD_FAILS(hr, SavePre( xml ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, xml.SaveAsStream( pStream ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\security\accesscontrollist.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    AccessControlList.cpp

Abstract:
    This file contains the implementation of the CPCHAccessControlList class,
    which is used to represent a security descriptor.

Revision History:
    Davide Massarenti   (Dmassare)  03/22/2000
        created

******************************************************************************/

#include "StdAfx.h"

////////////////////////////////////////////////////////////////////////////////
//
//  AccessControlList [@AclRevision]
//
//     Entries
//
////////////////////////////////////////////////////////////////////////////////

static const CComBSTR s_TAG_ACL             ( L"AccessControlList"  );
static const CComBSTR s_ATTR_ACL_AclRevision( L"AclRevision"        );

static const CComBSTR s_TAG_Entries     	( L"Entries"            );
static const CComBSTR s_TAG_ACE         	( L"AccessControlEntry" );

////////////////////////////////////////////////////////////////////////////////

CPCHAccessControlList::CPCHAccessControlList()
{
    m_dwAclRevision = 0; //  DWORD m_dwAclRevision;
}

CPCHAccessControlList::~CPCHAccessControlList()
{
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHAccessControlList::get_AclRevision( /*[out, retval]*/ long *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHAccessControlList::get_AclRevision",hr,pVal);

    *pVal = m_dwAclRevision;

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHAccessControlList::put_AclRevision( /*[in]*/ long newVal )
{
    __HCP_BEGIN_PROPERTY_PUT("CPCHAccessControlList::put_AclRevision",hr);

    m_dwAclRevision = newVal;

    __HCP_END_PROPERTY(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHAccessControlList::CreateItem( /*[out]*/ CPCHAccessControlEntry* *entry )
{
    __HCP_FUNC_ENTRY( "CPCHAccessControlList::CreateItem" );

    HRESULT                         hr;
    MPC::SmartLock<_ThreadModel>    lock( this );
	CComPtr<CPCHAccessControlEntry> pACE;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_POINTER_AND_SET(entry,NULL);
	__MPC_PARAMCHECK_END();


	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pACE ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, AddItem( pACE ));

	*entry = pACE.Detach();

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHAccessControlList::AddAce( /*[in]*/ IPCHAccessControlEntry* pAccessControlEntry )
{
    __HCP_FUNC_ENTRY( "CPCHAccessControlList::AddAce" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
	CollectionIter               it;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_NOTNULL(pAccessControlEntry);
	__MPC_PARAMCHECK_END();


	//
	// Verify that there's no duplicate ACE. 
	//
	for(it = m_coll.begin(); it != m_coll.end(); it++)
	{
		VARIANT_BOOL fSame;

		if(it->pdispVal)
		{
			CComPtr<IPCHAccessControlEntry> ace;

			__MPC_EXIT_IF_METHOD_FAILS(hr, it->pdispVal->QueryInterface( IID_IPCHAccessControlEntry, (void**)&ace ));

			__MPC_EXIT_IF_METHOD_FAILS(hr, ace->IsEquivalent( pAccessControlEntry, &fSame ));
			if(fSame == VARIANT_TRUE)
			{
				__MPC_SET_ERROR_AND_EXIT(hr, S_FALSE); // Duplicate, don't add.
			}
		}
	}

	__MPC_EXIT_IF_METHOD_FAILS(hr, AddItem( pAccessControlEntry ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHAccessControlList::RemoveAce( /*[in]*/ IPCHAccessControlEntry* pAccessControlEntry )
{
    __HCP_FUNC_ENTRY( "CPCHAccessControlList::RemoveAce" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
	CollectionIter               it;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_NOTNULL(pAccessControlEntry);
	__MPC_PARAMCHECK_END();



	//
	// Find and remove the entry. 
	//
	for(it = m_coll.begin(); it != m_coll.end(); it++)
	{
		VARIANT_BOOL fSame;

		if(it->pdispVal)
		{
			CComPtr<IPCHAccessControlEntry> ace;

			__MPC_EXIT_IF_METHOD_FAILS(hr, it->pdispVal->QueryInterface( IID_IPCHAccessControlEntry, (void**)&ace ));

			__MPC_EXIT_IF_METHOD_FAILS(hr, ace->IsEquivalent( pAccessControlEntry, &fSame ));
			if(fSame == VARIANT_TRUE)
			{
				m_coll.erase( it );
				__MPC_SET_ERROR_AND_EXIT(hr, S_OK); // Found, exit.
			}
		}
	}

    hr = S_FALSE; // Entry not found.


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHAccessControlList::Clone( /*[out, retval]*/ IPCHAccessControlList* *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHAccessControlList::Clone" );

    HRESULT                        hr;
    MPC::SmartLock<_ThreadModel>   lock( this );
    CComPtr<CPCHAccessControlList> pNew;
    CPCHAccessControlList*         pPtr;
	CollectionIter                 it;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
	__MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pNew ));

	pPtr = pNew;

    pPtr->m_dwAclRevision = m_dwAclRevision;

	for(it = m_coll.begin(); it != m_coll.end(); it++)
	{
		if(it->pdispVal)
		{
			CComPtr<IPCHAccessControlEntry> aceSrc;
			CComPtr<IPCHAccessControlEntry> aceDst;

			__MPC_EXIT_IF_METHOD_FAILS(hr, it->pdispVal->QueryInterface( IID_IPCHAccessControlEntry, (void**)&aceSrc ));

			__MPC_EXIT_IF_METHOD_FAILS(hr, aceSrc->Clone( &aceDst ));
			__MPC_EXIT_IF_METHOD_FAILS(hr, pPtr->AddItem(  aceDst ));
		}
	}


    __MPC_EXIT_IF_METHOD_FAILS(hr, pNew.QueryInterface( pVal ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHAccessControlList::LoadPost( /*[in]*/ MPC::XmlUtil& xml )
{
    __HCP_FUNC_ENTRY( "CPCHAccessControlList::LoadPost" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
	CComPtr<IXMLDOMNode>         xdnNode;
	CComBSTR                     bstrValue;                 
	LONG                         lValue;
	bool                         fFound;


	//
	// Make sure we have something to parse....
	//
	__MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetRoot( &xdnNode )); xdnNode.Release();


	//
	// Clean up before loading.
	//
    m_dwAclRevision = 0;

	Erase();


	//
	// Read attributes.
	//
	__MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( NULL, s_ATTR_ACL_AclRevision, lValue, fFound )); if(fFound) m_dwAclRevision =  lValue;

	//
	// Read ACES.
	//
	__MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetNode( s_TAG_Entries, &xdnNode ));
	if(xdnNode)
	{
		MPC::XmlUtil             subxml( xdnNode );
		CComPtr<IXMLDOMNodeList> xdnlList;
		CComPtr<IXMLDOMNode>     xdnSubNode;

		//
		// Enumerate all the ACE elements.
		//
		__MPC_EXIT_IF_METHOD_FAILS(hr, subxml.GetNodes( s_TAG_ACE, &xdnlList ));
		for(;SUCCEEDED(hr = xdnlList->nextNode( &xdnSubNode )) && xdnSubNode != NULL; xdnSubNode = NULL)
		{
			CComPtr<CPCHAccessControlEntry> ace;

			__MPC_EXIT_IF_METHOD_FAILS(hr, CreateItem( &ace ));

			__MPC_EXIT_IF_METHOD_FAILS(hr, ace->LoadXML( xdnSubNode ));
		}
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHAccessControlList::LoadXML( /*[in]*/ IXMLDOMNode* xdnNode )
{
    __HCP_FUNC_ENTRY( "CPCHAccessControlList::LoadXML" );

	HRESULT      hr;
	MPC::XmlUtil xml( xdnNode );

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_NOTNULL(xdnNode);
	__MPC_PARAMCHECK_END();


	__MPC_EXIT_IF_METHOD_FAILS(hr, LoadPost( xml ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHAccessControlList::LoadXMLAsString( /*[in]*/ BSTR bstrVal )
{
    __HCP_FUNC_ENTRY( "CPCHAccessControlList::LoadXMLAsString" );

	HRESULT      hr;
	MPC::XmlUtil xml;
	bool         fLoaded;
	bool         fFound;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_NOTNULL(bstrVal);
	__MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.LoadAsString( bstrVal, s_TAG_ACL, fLoaded, &fFound ));
	if(fLoaded == false || fFound == false)
	{
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_BAD_FORMAT);
    }


	__MPC_EXIT_IF_METHOD_FAILS(hr, LoadPost( xml ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHAccessControlList::LoadXMLAsStream( /*[in]*/ IUnknown* pStream )
{
    __HCP_FUNC_ENTRY( "CPCHAccessControlList::LoadXMLAsStream" );

	HRESULT      hr;
	MPC::XmlUtil xml;
	bool         fLoaded;
	bool         fFound;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_NOTNULL(pStream);
	__MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.LoadAsStream( pStream, s_TAG_ACL, fLoaded, &fFound ));
	if(fLoaded == false || fFound == false)
	{
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_BAD_FORMAT);
    }


	__MPC_EXIT_IF_METHOD_FAILS(hr, LoadPost( xml ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHAccessControlList::SavePre( /*[in]*/ MPC::XmlUtil& xml )
{
    __HCP_FUNC_ENTRY( "CPCHAccessControlList::SavePre" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
	CComPtr<IXMLDOMNode>         xdnNode;
	bool                         fFound;


	__MPC_EXIT_IF_METHOD_FAILS(hr, xml.CreateNode( s_TAG_ACL, &xdnNode ));

	//
	// Write attributes.
	//
	__MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, s_ATTR_ACL_AclRevision, m_dwAclRevision, fFound, xdnNode	));

	//
	// Write ACES.
	//
	if(m_coll.size())
	{
		CComPtr<IXMLDOMNode> xdnSubNode;
		CComPtr<IXMLDOMNode> xdnSubSubNode;
		CollectionIter       it;


		__MPC_EXIT_IF_METHOD_FAILS(hr, xml.CreateNode( s_TAG_Entries, &xdnSubNode, xdnNode ));

		for(it = m_coll.begin(); it != m_coll.end(); it++)
		{
			if(it->pdispVal)
			{
				CComPtr<IPCHAccessControlEntry> ace;

				__MPC_EXIT_IF_METHOD_FAILS(hr, it->pdispVal->QueryInterface( IID_IPCHAccessControlEntry, (void**)&ace ));

				__MPC_EXIT_IF_METHOD_FAILS(hr, ace->SaveXML( xdnSubNode, &xdnSubSubNode ));
			}
		}
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHAccessControlList::SaveXML( /*[in         ]*/ IXMLDOMNode*  xdnRoot  ,
											 /*[out, retval]*/ IXMLDOMNode* *pxdnNode )
{
    __HCP_FUNC_ENTRY( "CPCHAccessControlList::SaveXML" );

    HRESULT      hr;
	MPC::XmlUtil xml( xdnRoot );

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_NOTNULL(xdnRoot);
		__MPC_PARAMCHECK_POINTER_AND_SET(pxdnNode,NULL);
	__MPC_PARAMCHECK_END();


	__MPC_EXIT_IF_METHOD_FAILS(hr, SavePre( xml ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHAccessControlList::SaveXMLAsString( /*[out, retval]*/ BSTR *bstrVal )
{
    __HCP_FUNC_ENTRY( "CPCHAccessControlList::SaveXMLAsString" );

    HRESULT      hr;
	MPC::XmlUtil xml;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_POINTER_AND_SET(bstrVal,NULL);
	__MPC_PARAMCHECK_END();


	__MPC_EXIT_IF_METHOD_FAILS(hr, SavePre( xml ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, xml.SaveAsString( bstrVal ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHAccessControlList::SaveXMLAsStream( /*[out, retval]*/ IUnknown* *pStream )
{
    __HCP_FUNC_ENTRY( "CPCHAccessControlList::SaveXMLAsStream" );

    HRESULT      hr;
	MPC::XmlUtil xml;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_POINTER_AND_SET(pStream,NULL);
	__MPC_PARAMCHECK_END();


	__MPC_EXIT_IF_METHOD_FAILS(hr, SavePre( xml ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, xml.SaveAsStream( pStream ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\security\stdafx.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    stdafx.h

Abstract:
    include file for standard system include files,
    or project specific include files that are used frequently,
    but are changed infrequently


Revision History:
    Davide Massarenti   (Dmassare)  07/21/99
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_

#include <module.h>

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

//////

#include <HCP_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_COM.h>

#include <Debug.h>

//////

#include <ProjectConstants.h>

//////

#include <SecurityLib.h>

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\security\securitydescriptor.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    SecurityDescriptor.cpp

Abstract:
    This file contains the implementation of the CPCHSecurityDescriptor class,
    which is used to represent a security descriptor.

Revision History:
    Davide Massarenti   (Dmassare)  03/22/2000
        created

******************************************************************************/

#include "StdAfx.h"

////////////////////////////////////////////////////////////////////////////////
//
//  SecurityDescriptor [@Revision
//                      @Control
//                      @OwnerDefaulted
//                      @GroupDefaulted
//                      @DaclDefaulted
//                      @SaclDefaulted]
//
//     Owner
//     Group
//     DiscretionaryAcl
//     SystemAcl
//
////////////////////////////////////////////////////////////////////////////////

static const CComBSTR s_TAG_SD                ( L"SecurityDescriptor"                 );
static const CComBSTR s_ATTR_SD_Revision      ( L"Revision"                           );
static const CComBSTR s_ATTR_SD_Control       ( L"Control"                            );
static const CComBSTR s_ATTR_SD_OwnerDefaulted( L"OwnerDefaulted"                     );
static const CComBSTR s_ATTR_SD_GroupDefaulted( L"GroupDefaulted"                     );
static const CComBSTR s_ATTR_SD_DaclDefaulted ( L"DaclDefaulted"                      );
static const CComBSTR s_ATTR_SD_SaclDefaulted ( L"SaclDefaulted"                      );

static const CComBSTR s_TAG_Owner             ( L"Owner"                              );
static const CComBSTR s_TAG_Group             ( L"Group"                              );
static const CComBSTR s_TAG_DiscretionaryAcl  ( L"DiscretionaryAcl"                   );
static const CComBSTR s_TAG_SystemAcl         ( L"SystemAcl"                          );

static const CComBSTR s_XQL_DiscretionaryAcl  ( L"DiscretionaryAcl/AccessControlList" );
static const CComBSTR s_XQL_SystemAcl         ( L"SystemAcl/AccessControlList"        );

////////////////////////////////////////////////////////////////////////////////

static const MPC::StringToBitField s_arrCredentialMap[] =
{
    { L"SYSTEM"        , MPC::IDENTITY_SYSTEM    , MPC::IDENTITY_SYSTEM    , -1 },
    { L"LOCALSYSTEM"   , MPC::IDENTITY_SYSTEM    , MPC::IDENTITY_SYSTEM    , -1 },
    { L"ADMINISTRATOR" , MPC::IDENTITY_ADMIN     , MPC::IDENTITY_ADMIN     , -1 },
    { L"ADMINISTRATORS", MPC::IDENTITY_ADMINS    , MPC::IDENTITY_ADMINS    , -1 },
    { L"POWERUSERS"    , MPC::IDENTITY_POWERUSERS, MPC::IDENTITY_POWERUSERS, -1 },
    { L"USERS"         , MPC::IDENTITY_USERS     , MPC::IDENTITY_USERS     , -1 },
    { L"GUESTS"        , MPC::IDENTITY_GUESTS    , MPC::IDENTITY_GUESTS    , -1 },
    { NULL                                                                      }
};

static const MPC::StringToBitField s_arrAccessMap[] =
{
    { L"DELETE"                	 , DELETE                  , DELETE                	 , -1 },
    { L"READ_CONTROL"          	 , READ_CONTROL            , READ_CONTROL          	 , -1 },
    { L"WRITE_DAC"             	 , WRITE_DAC               , WRITE_DAC             	 , -1 },
    { L"WRITE_OWNER"           	 , WRITE_OWNER             , WRITE_OWNER           	 , -1 },
    { L"SYNCHRONIZE"           	 , SYNCHRONIZE             , SYNCHRONIZE           	 , -1 },

    { L"STANDARD_RIGHTS_REQUIRED", STANDARD_RIGHTS_REQUIRED, STANDARD_RIGHTS_REQUIRED, -1 },
    { L"STANDARD_RIGHTS_READ"    , STANDARD_RIGHTS_READ    , STANDARD_RIGHTS_READ    , -1 },
    { L"STANDARD_RIGHTS_WRITE"   , STANDARD_RIGHTS_WRITE   , STANDARD_RIGHTS_WRITE   , -1 },
    { L"STANDARD_RIGHTS_EXECUTE" , STANDARD_RIGHTS_EXECUTE , STANDARD_RIGHTS_EXECUTE , -1 },
    { L"STANDARD_RIGHTS_ALL"     , STANDARD_RIGHTS_ALL     , STANDARD_RIGHTS_ALL     , -1 },

    { L"ACCESS_SYSTEM_SECURITY"	 , ACCESS_SYSTEM_SECURITY  , ACCESS_SYSTEM_SECURITY	 , -1 },
    { L"ACCESS_READ"           	 , ACCESS_READ             , ACCESS_READ           	 , -1 },
    { L"ACCESS_WRITE"          	 , ACCESS_WRITE            , ACCESS_WRITE          	 , -1 },
    { L"ACCESS_CREATE"         	 , ACCESS_CREATE           , ACCESS_CREATE         	 , -1 },
    { L"ACCESS_EXEC"           	 , ACCESS_EXEC             , ACCESS_EXEC           	 , -1 },
    { L"ACCESS_DELETE"         	 , ACCESS_DELETE           , ACCESS_DELETE         	 , -1 },
    { L"ACCESS_ATRIB"          	 , ACCESS_ATRIB            , ACCESS_ATRIB          	 , -1 },
    { L"ACCESS_PERM"           	 , ACCESS_PERM             , ACCESS_PERM           	 , -1 },

    { L"GENERIC_READ"          	 , GENERIC_READ            , GENERIC_READ          	 , -1 },
    { L"GENERIC_WRITE"         	 , GENERIC_WRITE           , GENERIC_WRITE         	 , -1 },
    { L"GENERIC_EXECUTE"       	 , GENERIC_EXECUTE         , GENERIC_EXECUTE       	 , -1 },
    { L"GENERIC_ALL"           	 , GENERIC_ALL             , GENERIC_ALL           	 , -1 },
  	  
    { L"KEY_QUERY_VALUE"       	 , KEY_QUERY_VALUE         , KEY_QUERY_VALUE       	 , -1 },
    { L"KEY_SET_VALUE"         	 , KEY_SET_VALUE           , KEY_SET_VALUE         	 , -1 },
    { L"KEY_CREATE_SUB_KEY"    	 , KEY_CREATE_SUB_KEY      , KEY_CREATE_SUB_KEY    	 , -1 },
    { L"KEY_ENUMERATE_SUB_KEYS"	 , KEY_ENUMERATE_SUB_KEYS  , KEY_ENUMERATE_SUB_KEYS	 , -1 },
    { L"KEY_NOTIFY"            	 , KEY_NOTIFY              , KEY_NOTIFY            	 , -1 },
    { L"KEY_CREATE_LINK"       	 , KEY_CREATE_LINK         , KEY_CREATE_LINK       	 , -1 },
    { L"KEY_WOW64_RES"         	 , KEY_WOW64_RES           , KEY_WOW64_RES         	 , -1 },
  	  
    { L"KEY_READ"              	 , KEY_READ                , KEY_READ              	 , -1 },
    { L"KEY_WRITE"             	 , KEY_WRITE               , KEY_WRITE             	 , -1 },
    { L"KEY_EXECUTE"           	 , KEY_EXECUTE             , KEY_EXECUTE           	 , -1 },
    { L"KEY_ALL_ACCESS"        	 , KEY_ALL_ACCESS          , KEY_ALL_ACCESS        	 , -1 },
  	  
    { NULL                                                                                }
};

////////////////////////////////////////////////////////////////////////////////

CPCHSecurityDescriptor::CPCHSecurityDescriptor()
{
    m_dwRevision      = 0;     //  DWORD                          m_dwRevision;
    m_dwControl       = 0;     //  DWORD                          m_dwControl;
                               //
                               //  CComBSTR                       m_bstrOwner;
    m_fOwnerDefaulted = false; //  bool                           m_fOwnerDefaulted;
                               //
                               //  CComBSTR                       m_bstrGroup;
    m_fGroupDefaulted = false; //  bool                           m_fGroupDefaulted;
                               //
                               //  CComPtr<IPCHAccessControlList> m_DACL;
    m_fDaclDefaulted  = false; //  bool                           m_fDaclDefaulted;
                               //
                               //  CComPtr<IPCHAccessControlList> m_SACL;
    m_fSaclDefaulted  = false; //  bool                           m_fSaclDefaulted;
}

CPCHSecurityDescriptor::~CPCHSecurityDescriptor()
{
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHSecurityDescriptor::GetForFile( /*[in         ]*/ LPCWSTR                  szFilename ,
                                            /*[out, retval]*/ IPCHSecurityDescriptor* *psdObj     )
{
    __HCP_FUNC_ENTRY( "CPCHSecurityDescriptor::GetForFile" );

    HRESULT                         hr;
    CPCHSecurityDescriptorDirect    sdd;
    CComPtr<CPCHSecurityDescriptor> obj;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(psdObj,NULL);
    __MPC_PARAMCHECK_END();


    //
    // Get the security descriptor for the file.
    //
	if(FAILED(sdd.GetForFile( szFilename, sdd.s_SecInfo_ALL )))
	{
		//
		// If we fail to load the SACL, retry without...
		//
		__MPC_EXIT_IF_METHOD_FAILS(hr, sdd.GetForFile( szFilename, sdd.s_SecInfo_MOST ));
	}


    //
    // Convert it to COM.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &obj ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, sdd.ConvertSDToCOM( obj ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, obj.QueryInterface( psdObj ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


HRESULT CPCHSecurityDescriptor::SetForFile( /*[in]*/ LPCWSTR                 szFilename ,
                                            /*[in]*/ IPCHSecurityDescriptor* sdObj      )
{
    __HCP_FUNC_ENTRY( "CPCHSecurityDescriptor::SetForFile" );

    HRESULT                      hr;
    CPCHSecurityDescriptorDirect sdd;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(sdObj);
    __MPC_PARAMCHECK_END();


    //
    // Convert security descriptor from COM.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, sdd.ConvertSDFromCOM( sdObj ));


    //
    // Set the security descriptor for the file.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, sdd.SetForFile( szFilename, sdd.GetSACL() ? sdd.s_SecInfo_ALL : sdd.s_SecInfo_MOST ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHSecurityDescriptor::GetForRegistry( /*[in         ]*/ LPCWSTR                  szKey  ,
                                                /*[out, retval]*/ IPCHSecurityDescriptor* *psdObj )
{
    __HCP_FUNC_ENTRY( "CPCHSecurityDescriptor::GetForRegistry" );

    HRESULT                         hr;
    CPCHSecurityDescriptorDirect    sdd;
    CComPtr<CPCHSecurityDescriptor> obj;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(psdObj,NULL);
    __MPC_PARAMCHECK_END();


    //
    // Get the SD from the key.
    //
	if(FAILED(sdd.GetForRegistry( szKey, sdd.s_SecInfo_ALL )))
	{
		//
		// If we fail to load the SACL, retry without...
		//
		__MPC_EXIT_IF_METHOD_FAILS(hr, sdd.GetForRegistry( szKey, sdd.s_SecInfo_MOST ));
	}


    //
    // Convert it to COM.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &obj ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, sdd.ConvertSDToCOM( obj ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, obj.QueryInterface( psdObj ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHSecurityDescriptor::SetForRegistry( /*[in]*/ LPCWSTR                 szKey ,
                                                /*[in]*/ IPCHSecurityDescriptor* sdObj )
{
    __HCP_FUNC_ENTRY( "CPCHSecurityDescriptor::SetForRegistry" );

    HRESULT                      hr;
    CPCHSecurityDescriptorDirect sdd;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(sdObj);
    __MPC_PARAMCHECK_END();


    //
    // Convert security descriptor from COM.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, sdd.ConvertSDFromCOM( sdObj ));


    //
    // Set the security descriptor for the registry key.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, sdd.SetForRegistry( szKey, sdd.GetSACL() ? sdd.s_SecInfo_ALL : sdd.s_SecInfo_MOST ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHSecurityDescriptor::get_Revision( /*[out, retval]*/ long *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHSecurityDescriptor::get_Revision",hr,pVal);

    *pVal = m_dwRevision;

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHSecurityDescriptor::put_Revision( /*[in]*/ long newVal )
{
    __HCP_BEGIN_PROPERTY_PUT("CPCHSecurityDescriptor::put_Revision",hr);

    m_dwRevision = newVal;

    __HCP_END_PROPERTY(hr);
}

////////////////////

STDMETHODIMP CPCHSecurityDescriptor::get_Control( /*[out, retval]*/ long *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHSecurityDescriptor::get_Control",hr,pVal);

    *pVal = m_dwControl;

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHSecurityDescriptor::put_Control( /*[in]*/ long newVal )
{
    __HCP_BEGIN_PROPERTY_PUT("CPCHSecurityDescriptor::put_Control",hr);

    m_dwControl = newVal;

    __HCP_END_PROPERTY(hr);
}

////////////////////

STDMETHODIMP CPCHSecurityDescriptor::get_Owner( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHSecurityDescriptor::get_Owner",hr,pVal);

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_bstrOwner, pVal ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHSecurityDescriptor::put_Owner( /*[in]*/ BSTR newVal )
{
    __HCP_BEGIN_PROPERTY_PUT("CPCHSecurityDescriptor::put_Owner",hr);

    if(newVal)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHSecurityDescriptorDirect::VerifyPrincipal( newVal ));
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::PutBSTR( m_bstrOwner, newVal ));

    __HCP_END_PROPERTY(hr);
}

////////////////////

STDMETHODIMP CPCHSecurityDescriptor::get_OwnerDefaulted( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHSecurityDescriptor::get_OwnerDefaulted",hr,pVal);

    *pVal = m_fOwnerDefaulted ? VARIANT_TRUE : VARIANT_FALSE;

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHSecurityDescriptor::put_OwnerDefaulted( /*[in]*/ VARIANT_BOOL newVal )
{
    __HCP_BEGIN_PROPERTY_PUT("CPCHSecurityDescriptor::put_OwnerDefaulted",hr);

    m_fOwnerDefaulted = (newVal == VARIANT_TRUE);

    __HCP_END_PROPERTY(hr);
}

////////////////////

STDMETHODIMP CPCHSecurityDescriptor::get_Group( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHSecurityDescriptor::get_Group",hr,pVal);

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_bstrGroup, pVal ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHSecurityDescriptor::put_Group( /*[in]*/ BSTR newVal )
{
    __HCP_BEGIN_PROPERTY_PUT("CPCHSecurityDescriptor::put_Group",hr);

    if(newVal)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHSecurityDescriptorDirect::VerifyPrincipal( newVal ));
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::PutBSTR( m_bstrGroup, newVal ));

    __HCP_END_PROPERTY(hr);
}

////////////////////

STDMETHODIMP CPCHSecurityDescriptor::get_GroupDefaulted( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHSecurityDescriptor::get_GroupDefaulted",hr,pVal);

    *pVal = m_fGroupDefaulted ? VARIANT_TRUE : VARIANT_FALSE;

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHSecurityDescriptor::put_GroupDefaulted( /*[in]*/ VARIANT_BOOL newVal )
{
    __HCP_BEGIN_PROPERTY_PUT("CPCHSecurityDescriptor::put_GroupDefaulted",hr);

    m_fGroupDefaulted = (newVal == VARIANT_TRUE);

    __HCP_END_PROPERTY(hr);
}

////////////////////

STDMETHODIMP CPCHSecurityDescriptor::get_DiscretionaryAcl( /*[out, retval]*/ IPCHAccessControlList* *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHSecurityDescriptor::get_DiscretionaryAcl",hr,pVal);

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_DACL.CopyTo( pVal ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHSecurityDescriptor::put_DiscretionaryAcl( /*[in]*/ IPCHAccessControlList* newVal )
{
    __HCP_BEGIN_PROPERTY_PUT("CPCHSecurityDescriptor::put_DiscretionaryAcl",hr);

    m_DACL = newVal;

    __HCP_END_PROPERTY(hr);
}

////////////////////

STDMETHODIMP CPCHSecurityDescriptor::get_DaclDefaulted( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHSecurityDescriptor::get_DaclDefaulted",hr,pVal);

    *pVal = m_fDaclDefaulted ? VARIANT_TRUE : VARIANT_FALSE;

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHSecurityDescriptor::put_DaclDefaulted( /*[in]*/ VARIANT_BOOL newVal )
{
    __HCP_BEGIN_PROPERTY_PUT("CPCHSecurityDescriptor::put_DaclDefaulted",hr);

    m_fDaclDefaulted = (newVal == VARIANT_TRUE);

    __HCP_END_PROPERTY(hr);
}

////////////////////

STDMETHODIMP CPCHSecurityDescriptor::get_SystemAcl( /*[out, retval]*/ IPCHAccessControlList* *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHSecurityDescriptor::get_SystemAcl",hr,pVal);

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_SACL.CopyTo( pVal ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHSecurityDescriptor::put_SystemAcl( /*[in]*/ IPCHAccessControlList* newVal )
{
    __HCP_BEGIN_PROPERTY_PUT("CPCHSecurityDescriptor::put_SystemAcl",hr);

    m_SACL = newVal;

    __HCP_END_PROPERTY(hr);
}

////////////////////

STDMETHODIMP CPCHSecurityDescriptor::get_SaclDefaulted( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHSecurityDescriptor::get_SaclDefaulted",hr,pVal);

    *pVal = m_fSaclDefaulted ? VARIANT_TRUE : VARIANT_FALSE;

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHSecurityDescriptor::put_SaclDefaulted( /*[in]*/ VARIANT_BOOL newVal )
{
    __HCP_BEGIN_PROPERTY_PUT("CPCHSecurityDescriptor::put_SaclDefaulted",hr);

    m_fSaclDefaulted = (newVal == VARIANT_TRUE);

    __HCP_END_PROPERTY(hr);
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHSecurityDescriptor::Clone( /*[out, retval]*/ IPCHSecurityDescriptor* *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHSecurityDescriptor::Clone" );

    HRESULT                         hr;
    MPC::SmartLock<_ThreadModel>    lock( this );
    CComPtr<CPCHSecurityDescriptor> pNew;
    CPCHSecurityDescriptor*         pPtr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pNew ));

    pPtr = pNew;

    pPtr->m_dwRevision      = m_dwRevision;
    pPtr->m_dwControl       = m_dwControl;

    pPtr->m_bstrOwner       = m_bstrOwner;
    pPtr->m_fOwnerDefaulted = m_fOwnerDefaulted;

    pPtr->m_bstrGroup       = m_bstrGroup;
    pPtr->m_fGroupDefaulted = m_fGroupDefaulted;

    pPtr->m_fDaclDefaulted  = m_fDaclDefaulted;
    pPtr->m_fSaclDefaulted  = m_fSaclDefaulted;

    if(m_DACL) __MPC_EXIT_IF_METHOD_FAILS(hr, m_DACL->Clone( &pPtr->m_DACL ));
    if(m_SACL) __MPC_EXIT_IF_METHOD_FAILS(hr, m_SACL->Clone( &pPtr->m_SACL ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, pNew.QueryInterface( pVal ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHSecurityDescriptor::LoadPost( /*[in]*/ MPC::XmlUtil& xml )
{
    __HCP_FUNC_ENTRY( "CPCHSecurityDescriptor::LoadPost" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    CComPtr<IXMLDOMNode>         xdnNode;
    CComBSTR                     bstrValue;
    LONG                         lValue;
    bool                         fFound;


    //
    // Make sure we have something to parse....
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetRoot( &xdnNode )); xdnNode.Release();


    //
    // Clean up before loading.
    //
    m_dwRevision = 0;
    m_dwControl  = 0;

    m_bstrOwner.Empty();
    m_fOwnerDefaulted = false;

    m_bstrGroup.Empty();
    m_fGroupDefaulted = false;

    m_DACL.Release();
    m_fDaclDefaulted = false;

    m_SACL.Release();
    m_fSaclDefaulted = false;


    //
    // Read attributes.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( NULL, s_ATTR_SD_Revision      , lValue, fFound )); if(fFound) m_dwRevision      =  lValue;
    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( NULL, s_ATTR_SD_Control       , lValue, fFound )); if(fFound) m_dwControl       =  lValue;
    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( NULL, s_ATTR_SD_OwnerDefaulted, lValue, fFound )); if(fFound) m_fOwnerDefaulted = (lValue != 0);
    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( NULL, s_ATTR_SD_GroupDefaulted, lValue, fFound )); if(fFound) m_fGroupDefaulted = (lValue != 0);
    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( NULL, s_ATTR_SD_DaclDefaulted , lValue, fFound )); if(fFound) m_fDaclDefaulted  = (lValue != 0);
    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( NULL, s_ATTR_SD_SaclDefaulted , lValue, fFound )); if(fFound) m_fSaclDefaulted  = (lValue != 0);

    //
    // Read values.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetValue( s_TAG_Owner, bstrValue, fFound )); if(fFound) m_bstrOwner.Attach( bstrValue.Detach() );
    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetValue( s_TAG_Group, bstrValue, fFound )); if(fFound) m_bstrGroup.Attach( bstrValue.Detach() );

    //
    // Read ACLS.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetNode( s_XQL_DiscretionaryAcl, &xdnNode ));
    if(xdnNode)
    {
        CComPtr<CPCHAccessControlList> acl;

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &acl ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, acl->LoadXML( xdnNode ));

        m_DACL = acl; xdnNode.Release();
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetNode( s_XQL_SystemAcl, &xdnNode ));
    if(xdnNode)
    {
        CComPtr<CPCHAccessControlList> acl;

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &acl ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, acl->LoadXML( xdnNode ));

        m_SACL = acl;
    }


    if(m_bstrOwner.Length())
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHSecurityDescriptorDirect::VerifyPrincipal( m_bstrOwner ));
    }

    if(m_bstrGroup.Length())
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHSecurityDescriptorDirect::VerifyPrincipal( m_bstrGroup ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHSecurityDescriptor::LoadXML( /*[in]*/ IXMLDOMNode* xdnNode )
{
    __HCP_FUNC_ENTRY( "CPCHSecurityDescriptor::LoadXML" );

    HRESULT      hr;
    MPC::XmlUtil xml( xdnNode );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(xdnNode);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, LoadPost( xml ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHSecurityDescriptor::LoadXMLAsString( /*[in]*/ BSTR bstrVal )
{
    __HCP_FUNC_ENTRY( "CPCHSecurityDescriptor::LoadXMLAsString" );

    HRESULT      hr;
    MPC::XmlUtil xml;
    bool         fLoaded;
    bool         fFound;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrVal);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.LoadAsString( bstrVal, s_TAG_SD, fLoaded, &fFound ));
    if(fLoaded == false || fFound == false)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_BAD_FORMAT);
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, LoadPost( xml ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHSecurityDescriptor::LoadXMLAsStream( /*[in]*/ IUnknown* pStream )
{
    __HCP_FUNC_ENTRY( "CPCHSecurityDescriptor::LoadXMLAsStream" );

    HRESULT      hr;
    MPC::XmlUtil xml;
    bool         fLoaded;
    bool         fFound;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pStream);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.LoadAsStream( pStream, s_TAG_SD, fLoaded, &fFound ));
    if(fLoaded == false || fFound == false)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_BAD_FORMAT);
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, LoadPost( xml ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHSecurityDescriptor::SavePre( /*[in]*/ MPC::XmlUtil& xml )
{
    __HCP_FUNC_ENTRY( "CPCHSecurityDescriptor::SavePre" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    CComPtr<IXMLDOMNode>         xdnNode;
    bool                         fFound;


    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.CreateNode( s_TAG_SD, &xdnNode ));

    //
    // Write attributes.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, s_ATTR_SD_Revision      , m_dwRevision     , fFound, xdnNode ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, s_ATTR_SD_Control       , m_dwControl      , fFound, xdnNode ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, s_ATTR_SD_OwnerDefaulted, m_fOwnerDefaulted, fFound, xdnNode ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, s_ATTR_SD_GroupDefaulted, m_fGroupDefaulted, fFound, xdnNode ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, s_ATTR_SD_DaclDefaulted , m_fDaclDefaulted , fFound, xdnNode ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, s_ATTR_SD_SaclDefaulted , m_fSaclDefaulted , fFound, xdnNode ));


    //
    // Write values.
    //
    if(m_bstrOwner) __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutValue( s_TAG_Owner, m_bstrOwner, fFound, xdnNode ));
    if(m_bstrGroup) __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutValue( s_TAG_Group, m_bstrGroup, fFound, xdnNode ));

    //
    // Write ACLS.
    //
    if(m_DACL)
    {
        CComPtr<IXMLDOMNode> xdnSubNode;
        CComPtr<IXMLDOMNode> xdnSubSubNode;

        __MPC_EXIT_IF_METHOD_FAILS(hr, xml.CreateNode( s_TAG_DiscretionaryAcl, &xdnSubNode, xdnNode ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_DACL->SaveXML( xdnSubNode, &xdnSubSubNode ));
    }

    if(m_SACL)
    {
        CComPtr<IXMLDOMNode> xdnSubNode;
        CComPtr<IXMLDOMNode> xdnSubSubNode;

        __MPC_EXIT_IF_METHOD_FAILS(hr, xml.CreateNode( s_TAG_SystemAcl, &xdnSubNode, xdnNode ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_SACL->SaveXML( xdnSubNode, &xdnSubSubNode ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHSecurityDescriptor::SaveXML( /*[in         ]*/ IXMLDOMNode*  xdnRoot  ,
                                              /*[out, retval]*/ IXMLDOMNode* *pxdnNode )
{
    __HCP_FUNC_ENTRY( "CPCHSecurityDescriptor::SaveXML" );

    HRESULT      hr;
    MPC::XmlUtil xml( xdnRoot );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(xdnRoot);
        __MPC_PARAMCHECK_POINTER_AND_SET(pxdnNode,NULL);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, SavePre( xml ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHSecurityDescriptor::SaveXMLAsString( /*[out, retval]*/ BSTR *bstrVal )
{
    __HCP_FUNC_ENTRY( "CPCHSecurityDescriptor::SaveXMLAsString" );

    HRESULT      hr;
    MPC::XmlUtil xml;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(bstrVal,NULL);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, SavePre( xml ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.SaveAsString( bstrVal ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHSecurityDescriptor::SaveXMLAsStream( /*[out, retval]*/ IUnknown* *pStream )
{
    __HCP_FUNC_ENTRY( "CPCHSecurityDescriptor::SaveXMLAsStream" );

    HRESULT      hr;
    MPC::XmlUtil xml;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pStream,NULL);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, SavePre( xml ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.SaveAsStream( pStream ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

CPCHSecurity* CPCHSecurity::s_GLOBAL( NULL );

HRESULT CPCHSecurity::InitializeSystem()
{
	if(s_GLOBAL) return S_OK;

	return MPC::CreateInstanceCached( &CPCHSecurity::s_GLOBAL );
}

void CPCHSecurity::FinalizeSystem()
{
	if(s_GLOBAL)
	{
		s_GLOBAL->Release(); s_GLOBAL = NULL;
	}
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHSecurity::CreateObject_SecurityDescriptor( /*[out, retval]*/ IPCHSecurityDescriptor* *pSD  )
{
    __HCP_FUNC_ENTRY( "CPCHSecurity::CreateObject_SecurityDescriptor" );

    HRESULT                         hr;
    CComPtr<CPCHSecurityDescriptor> obj;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pSD,NULL);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &obj ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, obj.QueryInterface( pSD ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHSecurity::CreateObject_AccessControlList( /*[out, retval]*/ IPCHAccessControlList* *pACL )
{
    __HCP_FUNC_ENTRY( "CPCHSecurity::CreateObject_AccessControlList" );

    HRESULT                        hr;
    CComPtr<CPCHAccessControlList> obj;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pACL,NULL);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &obj ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, obj.QueryInterface( pACL ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHSecurity::CreateObject_AccessControlEntry( /*[out, retval]*/ IPCHAccessControlEntry* *pACE )
{
    __HCP_FUNC_ENTRY( "CPCHSecurity::CreateObject_AccessControlEntry" );

    HRESULT                         hr;
    CComPtr<CPCHAccessControlEntry> obj;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pACE,NULL);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &obj ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, obj.QueryInterface( pACE ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////

STDMETHODIMP CPCHSecurity::GetUserName( /*[in]         */ BSTR  bstrPrincipal ,
										/*[out, retval]*/ BSTR *retVal        )
{
    __HCP_FUNC_ENTRY( "CPCHSecurity::GetUserName" );

    HRESULT      hr;
	MPC::wstring strName;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrPrincipal);
        __MPC_PARAMCHECK_POINTER_AND_SET(retVal,NULL);
    __MPC_PARAMCHECK_END();


	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SecurityDescriptor::GetAccountName( bstrPrincipal, strName ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( strName.c_str(), retVal ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHSecurity::GetUserDomain( /*[in]         */ BSTR  bstrPrincipal ,
										  /*[out, retval]*/ BSTR *retVal        )
{
    __HCP_FUNC_ENTRY( "CPCHSecurity::GetUserDomain" );

    HRESULT      hr;
	MPC::wstring strName;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrPrincipal);
        __MPC_PARAMCHECK_POINTER_AND_SET(retVal,NULL);
    __MPC_PARAMCHECK_END();


	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SecurityDescriptor::GetAccountDomain( bstrPrincipal, strName ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( strName.c_str(), retVal ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHSecurity::GetUserDisplayName( /*[in]         */ BSTR  bstrPrincipal ,
											   /*[out, retval]*/ BSTR *retVal        )
{
    __HCP_FUNC_ENTRY( "CPCHSecurity::GetUserDisplayName" );

    HRESULT      hr;
	MPC::wstring strName;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrPrincipal);
        __MPC_PARAMCHECK_POINTER_AND_SET(retVal,NULL);
    __MPC_PARAMCHECK_END();


	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SecurityDescriptor::GetAccountDisplayName( bstrPrincipal, strName ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( strName.c_str(), retVal ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////

STDMETHODIMP CPCHSecurity::CheckCredentials( /*[in]         */ BSTR          bstrCredentials ,
                                             /*[out, retval]*/ VARIANT_BOOL *retVal          )
{
    __HCP_FUNC_ENTRY( "CPCHSecurity::CheckCredentials" );

    HRESULT  hr;
    CComBSTR bstrUser;
    DWORD    dwAllowedIdentity;
    DWORD    dwDesiredIdentity;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrCredentials);
        __MPC_PARAMCHECK_POINTER_AND_SET(retVal,VARIANT_FALSE);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertStringToBitField( bstrCredentials, dwDesiredIdentity, s_arrCredentialMap ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetCallerPrincipal( /*fImpersonate*/true, bstrUser, &dwAllowedIdentity ));

    *retVal = (dwAllowedIdentity & dwDesiredIdentity) ? VARIANT_TRUE : VARIANT_FALSE;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////

HRESULT CPCHSecurity::CheckAccess( /*[in]*/  VARIANT&                 vDesiredAccess ,
                                   /*[in]*/  MPC::SecurityDescriptor& sd             ,
                                   /*[out]*/ VARIANT_BOOL&            retVal         )
{
    __HCP_FUNC_ENTRY( "CPCHSecurity::CheckAccessToSD" );

    HRESULT          hr;
    MPC::AccessCheck ac;
	DWORD            dwDesired;
    DWORD            dwGranted;
    BOOL             fGranted;


    if(vDesiredAccess.vt == VT_I4)
    {
        dwDesired = vDesiredAccess.lVal;
    }
    else if(vDesiredAccess.vt == VT_BSTR)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertStringToBitField( vDesiredAccess.bstrVal, dwDesired, s_arrAccessMap ));
    }
    else
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, ac.GetTokenFromImpersonation());
    __MPC_EXIT_IF_METHOD_FAILS(hr, ac.Verify( dwDesired, fGranted, dwGranted, sd ));

    if(fGranted) retVal = VARIANT_TRUE;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHSecurity::CheckAccessToSD( /*[in]*/          VARIANT                  vDesiredAccess,
                                            /*[in]*/          IPCHSecurityDescriptor*  sd            ,
                                            /*[out, retval]*/ VARIANT_BOOL            *retVal        )
{
    __HCP_FUNC_ENTRY( "CPCHSecurity::CheckAccessToSD" );

    HRESULT                      hr;
    CPCHSecurityDescriptorDirect sdd;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(sd);
        __MPC_PARAMCHECK_POINTER_AND_SET(retVal,VARIANT_FALSE);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, sdd.ConvertSDFromCOM( sd ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, CheckAccess( vDesiredAccess, sdd, *retVal ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHSecurity::CheckAccessToFile( /*[in]*/ 			VARIANT       vDesiredAccess ,
											  /*[in]*/ 			BSTR          bstrFilename   ,
											  /*[out, retval]*/ VARIANT_BOOL *retVal         )
{
    __HCP_FUNC_ENTRY( "CPCHSecurity::CheckAccessToFile" );

    HRESULT                      hr;
    CPCHSecurityDescriptorDirect sdd;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrFilename);
        __MPC_PARAMCHECK_POINTER_AND_SET(retVal,VARIANT_FALSE);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, sdd.GetForFile( bstrFilename, sdd.s_SecInfo_MOST ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, CheckAccess( vDesiredAccess, sdd, *retVal ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHSecurity::CheckAccessToRegistry( /*[in]*/ 			VARIANT       vDesiredAccess ,
												  /*[in]*/ 			BSTR          bstrKey        ,
												  /*[out, retval]*/ VARIANT_BOOL *retVal         )
{
    __HCP_FUNC_ENTRY( "CPCHSecurity::CheckAccessToRegistry" );

    HRESULT                      hr;
    CPCHSecurityDescriptorDirect sdd;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrKey);
        __MPC_PARAMCHECK_POINTER_AND_SET(retVal,VARIANT_FALSE);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, sdd.GetForRegistry( bstrKey, sdd.s_SecInfo_MOST ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, CheckAccess( vDesiredAccess, sdd, *retVal ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////

STDMETHODIMP CPCHSecurity::GetFileSD( /*[in         ]*/ BSTR                     bstrFilename ,
                                      /*[out, retval]*/ IPCHSecurityDescriptor* *psd          )
{
    __HCP_FUNC_ENTRY( "CPCHSecurity::GetFileSD" );

    HRESULT            hr;
	MPC::Impersonation imp;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrFilename);
        __MPC_PARAMCHECK_POINTER_AND_SET(psd,NULL);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, imp.Initialize ());
	__MPC_EXIT_IF_METHOD_FAILS(hr, imp.Impersonate());

    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHSecurityDescriptor::GetForFile( bstrFilename, psd ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHSecurity::SetFileSD( /*[in]*/ BSTR                    bstrFilename ,
                                      /*[in]*/ IPCHSecurityDescriptor* sd           )
{
    __HCP_FUNC_ENTRY( "CPCHSecurity::SetFileSD" );

    HRESULT            hr;
	MPC::Impersonation imp;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrFilename);
        __MPC_PARAMCHECK_NOTNULL(sd);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, imp.Initialize ());
	__MPC_EXIT_IF_METHOD_FAILS(hr, imp.Impersonate());

    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHSecurityDescriptor::SetForFile( bstrFilename, sd ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


STDMETHODIMP CPCHSecurity::GetRegistrySD( /*[in         ]*/ BSTR                     bstrKey ,
                                          /*[out, retval]*/ IPCHSecurityDescriptor* *psd     )
{
    __HCP_FUNC_ENTRY( "CPCHSecurity::GetRegistrySD" );

    HRESULT            hr;
	MPC::Impersonation imp;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrKey);
        __MPC_PARAMCHECK_POINTER_AND_SET(psd,NULL);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, imp.Initialize ());
	__MPC_EXIT_IF_METHOD_FAILS(hr, imp.Impersonate());

    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHSecurityDescriptor::GetForRegistry( bstrKey, psd ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHSecurity::SetRegistrySD( /*[in]*/ BSTR                    bstrKey ,
                                          /*[in]*/ IPCHSecurityDescriptor* sd      )
{
    __HCP_FUNC_ENTRY( "CPCHSecurity::SetRegistrySD" );

    HRESULT            hr;
	MPC::Impersonation imp;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrKey);
        __MPC_PARAMCHECK_NOTNULL(sd);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, imp.Initialize ());
	__MPC_EXIT_IF_METHOD_FAILS(hr, imp.Impersonate());

    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHSecurityDescriptor::SetForRegistry( bstrKey, sd ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\security\lowlevel.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    LowLevel.cpp

Abstract:
    This file contains the implementation of the CPCHSecurityDescriptor class,
    which is used to represent a security descriptor.

Revision History:
    Davide Massarenti   (Dmassare)  03/24/2000
        created

******************************************************************************/

#include "StdAfx.h"

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHSecurityDescriptorDirect::ConvertACEFromCOM( /*[in ]*/ IPCHAccessControlEntry* objACE ,
                                                         /*[out]*/ PACL&                   pACL   )
{
    __HCP_FUNC_ENTRY( "CPCHSecurityDescriptorDirect::ConvertACEFromCOM" );

    HRESULT   hr;
    GUID      guidObjectType;
    GUID      guidInheritedObjectType;
    ////////////////////////////////////////
    long      lAccessMask;
    long      lAceFlags;
    long      lAceType;
    long      lFlags;
    CComBSTR  bstrTrustee;
    CComBSTR  bstrObjectType;
    CComBSTR  bstrInheritedObjectType;
    PSID      pPrincipalSid = NULL;


    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(objACE);
    __MPC_PARAMCHECK_END();


    //
    // Read data.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, objACE->get_AccessMask         ( &lAccessMask             ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, objACE->get_AceType            ( &lAceFlags               ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, objACE->get_AceFlags           ( &lAceType                ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, objACE->get_Flags              ( &lFlags                  ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, objACE->get_Trustee            ( &bstrTrustee             ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, objACE->get_ObjectType         ( &bstrObjectType          ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, objACE->get_InheritedObjectType( &bstrInheritedObjectType ));


    if(bstrObjectType.Length())
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, ::CLSIDFromString( bstrObjectType, &guidObjectType ));
    }

    if(bstrInheritedObjectType.Length())
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, ::CLSIDFromString( bstrInheritedObjectType, &guidInheritedObjectType ));
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, ConvertPrincipalToSID( SAFEBSTR(bstrTrustee), pPrincipalSid ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, AddACEToACL( pACL,
                                                pPrincipalSid      ,
                                                (DWORD)lAceType    ,
                                                (DWORD)lAceFlags   ,
                                                (DWORD)lAccessMask ,
                                                bstrObjectType          ? &guidObjectType          : NULL ,
                                                bstrInheritedObjectType ? &guidInheritedObjectType : NULL ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    ReleaseMemory( (void*&)pPrincipalSid );

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHSecurityDescriptorDirect::ConvertACEToCOM( /*[in]*/ IPCHAccessControlEntry* objACE ,
                                                       /*[in]*/ const LPVOID            pACE   )
{
    __HCP_FUNC_ENTRY( "CPCHSecurityDescriptorDirect::ConvertACEToCOM" );

    HRESULT     hr;
    PSID        pSID                    =              NULL;
    LPCWSTR     szPrincipal             =              NULL;
    GUID*       guidObjectType          =              NULL;
    GUID*       guidInheritedObjectType =              NULL;
    PACE_HEADER aceHeader               = (PACE_HEADER)pACE;
    ////////////////////////////////////////
    long        lAccessMask = 0;
    long        lAceFlags   = 0;
    long        lAceType    = 0;
    long        lFlags      = 0;
    CComBSTR    bstrTrustee;
    CComBSTR    bstrObjectType;
    CComBSTR    bstrInheritedObjectType;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(objACE);
        __MPC_PARAMCHECK_NOTNULL(pACE);
    __MPC_PARAMCHECK_END();


    lAceType  = aceHeader->AceType;
    lAceFlags = aceHeader->AceFlags;


    //
    // Extract data from the ACE.
    //
    switch(lAceType)
    {
    case ACCESS_ALLOWED_ACE_TYPE:
        {
            PACCESS_ALLOWED_ACE pRealACE = (PACCESS_ALLOWED_ACE)pACE;

            lAccessMask =        pRealACE->Mask;
            pSID        = (PSID)&pRealACE->SidStart;
        }
        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        {
            PACCESS_ALLOWED_OBJECT_ACE pRealACE = (PACCESS_ALLOWED_OBJECT_ACE)pACE;

            lAccessMask             =        pRealACE->Mask;
            lFlags                  =        pRealACE->Flags;
            guidObjectType          =       &pRealACE->ObjectType;
            guidInheritedObjectType =       &pRealACE->InheritedObjectType;
            pSID                    = (PSID)&pRealACE->SidStart;
        }
        break;

    case ACCESS_DENIED_ACE_TYPE:
        {
            PACCESS_DENIED_ACE pRealACE = (PACCESS_DENIED_ACE)pACE;

            lAccessMask =        pRealACE->Mask;
            pSID        = (PSID)&pRealACE->SidStart;
        }
        break;

    case ACCESS_DENIED_OBJECT_ACE_TYPE:
        {
            PACCESS_DENIED_OBJECT_ACE pRealACE = (PACCESS_DENIED_OBJECT_ACE)pACE;

            lAccessMask             =        pRealACE->Mask;
            lFlags                  =        pRealACE->Flags;
            guidObjectType          =       &pRealACE->ObjectType;
            guidInheritedObjectType =       &pRealACE->InheritedObjectType;
            pSID                    = (PSID)&pRealACE->SidStart;
        }
        break;

    case SYSTEM_AUDIT_ACE_TYPE:
        {
            PSYSTEM_AUDIT_ACE pRealACE = (PSYSTEM_AUDIT_ACE)pACE;

            lAccessMask =        pRealACE->Mask;
            pSID        = (PSID)&pRealACE->SidStart;
        }
        break;

    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
        {
            PSYSTEM_AUDIT_OBJECT_ACE pRealACE = (PSYSTEM_AUDIT_OBJECT_ACE)pACE;

            lAccessMask             =        pRealACE->Mask;
            lFlags                  =        pRealACE->Flags;
            guidObjectType          =       &pRealACE->ObjectType;
            guidInheritedObjectType =       &pRealACE->InheritedObjectType;
            pSID                    = (PSID)&pRealACE->SidStart;
        }
        break;

    default:
        __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }



    //
    // Convert GUIDs and SIDs to strings.
    //
    if(pSID)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, ConvertSIDToPrincipal( pSID, &szPrincipal ));

        bstrTrustee = szPrincipal;
    }

    if(guidObjectType)
    {
        LPOLESTR szGuid;

        __MPC_EXIT_IF_METHOD_FAILS(hr, ::StringFromCLSID( *guidObjectType, &szGuid ));

        bstrObjectType = szGuid;

        ::CoTaskMemFree( szGuid );
    }

    if(guidInheritedObjectType)
    {
        LPOLESTR szGuid;

        __MPC_EXIT_IF_METHOD_FAILS(hr, ::StringFromCLSID( *guidInheritedObjectType, &szGuid ));

        bstrInheritedObjectType = szGuid;

        ::CoTaskMemFree( szGuid );
    }


    //
    // Write data.
    //
                                         __MPC_EXIT_IF_METHOD_FAILS(hr, objACE->put_AccessMask         ( lAccessMask             ));
                                         __MPC_EXIT_IF_METHOD_FAILS(hr, objACE->put_AceType            ( lAceFlags               ));
                                         __MPC_EXIT_IF_METHOD_FAILS(hr, objACE->put_AceFlags           ( lAceType                ));
                                         __MPC_EXIT_IF_METHOD_FAILS(hr, objACE->put_Flags              ( lFlags                  ));
    if(bstrTrustee            .Length()) __MPC_EXIT_IF_METHOD_FAILS(hr, objACE->put_Trustee            ( bstrTrustee             ));
    if(bstrObjectType         .Length()) __MPC_EXIT_IF_METHOD_FAILS(hr, objACE->put_ObjectType         ( bstrObjectType          ));
    if(bstrInheritedObjectType.Length()) __MPC_EXIT_IF_METHOD_FAILS(hr, objACE->put_InheritedObjectType( bstrInheritedObjectType ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    ReleaseMemory( (void*&)szPrincipal );

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHSecurityDescriptorDirect::ConvertACLFromCOM( /*[in ]*/ IPCHAccessControlList* objACL ,
                                                         /*[out]*/ PACL&                  pACL   )
{
    __HCP_FUNC_ENTRY( "CPCHSecurityDescriptorDirect::ConvertACLFromCOM" );

    HRESULT hr;
    long    lCount;
    long    lPos;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(objACL);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, objACL->get_Count( &lCount ));

    for(lPos=1; lPos<=lCount; lPos++)
    {
        CComVariant vItem;

        __MPC_EXIT_IF_METHOD_FAILS(hr, objACL->get_Item( lPos, &vItem ));
        if(vItem.vt == VT_DISPATCH)
        {
            CComQIPtr<IPCHAccessControlEntry> objACE( vItem.pdispVal );

            if(objACE)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, ConvertACEFromCOM( objACE, pACL ));
            }
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHSecurityDescriptorDirect::ConvertACLToCOM( /*[in]*/ IPCHAccessControlList* objACL ,
                                                       /*[in]*/ const PACL             pACL   )
{
    __HCP_FUNC_ENTRY( "CPCHSecurityDescriptorDirect::ConvertACLToCOM" );

    HRESULT              hr;
    ACL_SIZE_INFORMATION aclSizeInfo;


    if(pACL)
    {
        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::GetAclInformation( pACL, (LPVOID)&aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation ));

        for(DWORD i = 0; i < aclSizeInfo.AceCount; i++)
        {
			CComPtr<CPCHAccessControlEntry> objACE;
            LPVOID                          pACE;

            __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::GetAce( pACL, i, (LPVOID*)&pACE ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &objACE ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, ConvertACEToCOM( objACE, pACE ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, objACL->AddAce( objACE ));
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHSecurityDescriptorDirect::ConvertSDToCOM( IPCHSecurityDescriptor* pObj )
{
    __HCP_FUNC_ENTRY( "CPCHSecurityDescriptorDirect::ConvertToCOM" );

    HRESULT                        hr;
    DWORD                          dwRevision;
    SECURITY_DESCRIPTOR_CONTROL    sdc;
    LPCWSTR                        szOwner = NULL;
    LPCWSTR                        szGroup = NULL;
    ////////////////////////////////////////
    long                           lRevision;
    long                           lControl;
    CComBSTR                       bstrOwner;
    VARIANT_BOOL                   fOwnerDefaulted;
    CComBSTR                       bstrGroup;
    VARIANT_BOOL                   fGroupDefaulted;
    CComPtr<CPCHAccessControlList> DACL;
    VARIANT_BOOL                   fDaclDefaulted;
    CComPtr<CPCHAccessControlList> SACL;
    VARIANT_BOOL                   fSaclDefaulted;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pObj);
    __MPC_PARAMCHECK_END();


    //
    // Convert data.
    //
    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::GetSecurityDescriptorControl( m_pSD, &sdc, &dwRevision ));
    lRevision = dwRevision;
    lControl  = sdc;

    ////////////////////

    if(m_pOwner)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, ConvertSIDToPrincipal( m_pOwner, &szOwner ));

        bstrOwner = szOwner;
    }
    fOwnerDefaulted = m_bOwnerDefaulted ? VARIANT_TRUE : VARIANT_FALSE;

    if(m_pGroup)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, ConvertSIDToPrincipal( m_pGroup, &szGroup ));

        bstrGroup = szGroup;
    }
    fGroupDefaulted = m_bGroupDefaulted ? VARIANT_TRUE : VARIANT_FALSE;

    if(m_pDACL)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &DACL ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, ConvertACLToCOM( DACL, m_pDACL ));
    }
    fDaclDefaulted = m_bDaclDefaulted ? VARIANT_TRUE : VARIANT_FALSE;

    if(m_pSACL)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &SACL ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, ConvertACLToCOM( SACL, m_pSACL ));
    }
    fSaclDefaulted = m_bSaclDefaulted ? VARIANT_TRUE : VARIANT_FALSE;

    ////////////////////////////////////////////////////////////////////////////////

    //
    // Write data.
    //
                           __MPC_EXIT_IF_METHOD_FAILS(hr, pObj->put_Revision        ( lRevision       ));
                           __MPC_EXIT_IF_METHOD_FAILS(hr, pObj->put_Control         ( lControl        ));
    if(bstrOwner.Length()) __MPC_EXIT_IF_METHOD_FAILS(hr, pObj->put_Owner           ( bstrOwner       ));
                           __MPC_EXIT_IF_METHOD_FAILS(hr, pObj->put_OwnerDefaulted  ( fOwnerDefaulted ));
    if(bstrGroup.Length()) __MPC_EXIT_IF_METHOD_FAILS(hr, pObj->put_Group           ( bstrGroup       ));
                           __MPC_EXIT_IF_METHOD_FAILS(hr, pObj->put_GroupDefaulted  ( fGroupDefaulted ));
    if(DACL)               __MPC_EXIT_IF_METHOD_FAILS(hr, pObj->put_DiscretionaryAcl( DACL            ));
                           __MPC_EXIT_IF_METHOD_FAILS(hr, pObj->put_DaclDefaulted   ( fDaclDefaulted  ));
    if(SACL)               __MPC_EXIT_IF_METHOD_FAILS(hr, pObj->put_SystemAcl       ( SACL            ));
                           __MPC_EXIT_IF_METHOD_FAILS(hr, pObj->put_SaclDefaulted   ( fSaclDefaulted  ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    ReleaseMemory( (void*&)szOwner );
    ReleaseMemory( (void*&)szGroup );

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHSecurityDescriptorDirect::ConvertSDFromCOM( IPCHSecurityDescriptor* pObj )
{
    __HCP_FUNC_ENTRY( "CPCHSecurityDescriptorDirect::ConvertSDFromCOM" );

    HRESULT                        hr;
    PSID                           pOwnerSid = NULL;
    PSID                           pGroupSid = NULL;
    ////////////////////////////////////////
    long                           lRevision;
    long                           lControl;
    CComBSTR                       bstrOwner;
    VARIANT_BOOL                   fOwnerDefaulted;
    CComBSTR                       bstrGroup;
    VARIANT_BOOL                   fGroupDefaulted;
    CComPtr<IPCHAccessControlList> DACL;
    VARIANT_BOOL                   fDaclDefaulted;
    CComPtr<IPCHAccessControlList> SACL;
    VARIANT_BOOL                   fSaclDefaulted;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pObj);
    __MPC_PARAMCHECK_END();


    //
    // Read data.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, pObj->get_Revision        ( &lRevision       ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pObj->get_Control         ( &lControl        ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pObj->get_Owner           ( &bstrOwner       ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pObj->get_OwnerDefaulted  ( &fOwnerDefaulted ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pObj->get_Group           ( &bstrGroup       ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pObj->get_GroupDefaulted  ( &fGroupDefaulted ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pObj->get_DiscretionaryAcl( &DACL            ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pObj->get_DaclDefaulted   ( &fDaclDefaulted  ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pObj->get_SystemAcl       ( &SACL            ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pObj->get_SaclDefaulted   ( &fSaclDefaulted  ));


    //
    // Convert data.
    //
    if(bstrOwner.Length())
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, ConvertPrincipalToSID( bstrOwner, pOwnerSid ));
    }

    if(bstrGroup.Length())
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, ConvertPrincipalToSID( bstrGroup, pGroupSid ));
    }


    //
    // Write data to security descriptor.
    //
    CleanUp();

    __MPC_EXIT_IF_METHOD_FAILS(hr, AllocateMemory( (void*&)m_pSD, sizeof(SECURITY_DESCRIPTOR) ));

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::InitializeSecurityDescriptor( m_pSD, (DWORD)lRevision ));

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::SetSecurityDescriptorControl( m_pSD, s_sdcMask, s_sdcMask & lControl ));

    ////////////////////

    __MPC_EXIT_IF_METHOD_FAILS(hr, SetOwner( pOwnerSid, fOwnerDefaulted == VARIANT_TRUE ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, SetGroup( pGroupSid, fGroupDefaulted == VARIANT_TRUE ));

    ////////////////////

    if(DACL)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, ConvertACLFromCOM( DACL, m_pDACL ));
    }
    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::SetSecurityDescriptorDacl( m_pSD, m_pDACL ? TRUE : FALSE, m_pDACL, fDaclDefaulted == VARIANT_TRUE ));

    if(SACL)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, ConvertACLFromCOM( SACL, m_pSACL ));
    }
    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::SetSecurityDescriptorSacl( m_pSD, m_pSACL ? TRUE : FALSE, m_pSACL, fSaclDefaulted == VARIANT_TRUE ));

    ////////////////////////////////////////////////////////////////////////////////

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    ReleaseMemory( (void*&)pOwnerSid );
    ReleaseMemory( (void*&)pGroupSid );

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\security\unittest\stdafx.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    stdafx.h

Abstract:
    include file for standard system include files,
    or project specific include files that are used frequently,
    but are changed infrequently


Revision History:
    Davide Massarenti   (Dmassare)  07/21/99
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_

#include <module.h>

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

//////

#include <HCP_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_COM.h>
#include <MPC_streams.h>

#include <Debug.h>

//////

#include <ProjectConstants.h>

//////

#include <SecurityLib.h>

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\security\unittest\main.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    main.cpp

Abstract:
    This file contains the unit test for the Security objects.

Revision History:
    Davide Massarenti   (Dmassare)  03/22/2000
        created

******************************************************************************/

#include "StdAfx.h"

#include <initguid.h>

#include "HelpServiceTypeLib.h"
#include "HelpServiceTypeLib_i.c"

////////////////////////////////////////////////////////////////////////////////

static HRESULT OpenStreamForRead( /*[in]*/  LPCWSTR   szFile ,
                                  /*[out]*/ IStream* *pVal   )
{
    __HCP_FUNC_ENTRY( "OpenStreamForRead" );

    HRESULT                  hr;
    CComPtr<MPC::FileStream> stream;
    MPC::wstring             szFileFull;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(szFile);
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


    MPC::SubstituteEnvVariables( szFileFull = szFile );


    //
    // Create a stream for a file.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &stream ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream->InitForRead( szFileFull.c_str() ));


    //
    // Return the stream to the caller.
    //
    *pVal = stream.Detach();
    hr    = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

static HRESULT OpenStreamForWrite( /*[in]*/  LPCWSTR   szFile ,
                                   /*[out]*/ IStream* *pVal   )
{
    __HCP_FUNC_ENTRY( "OpenStreamForWrite" );

    HRESULT                  hr;
    CComPtr<MPC::FileStream> stream;
    MPC::wstring             szFileFull;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(szFile);
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


    MPC::SubstituteEnvVariables( szFileFull = szFile );


    //
    // Create a stream for a file.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &stream ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream->InitForWrite( szFileFull.c_str() ));


    //
    // Return the stream to the caller.
    //
    *pVal = stream.Detach();
    hr    = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

static HRESULT Creation1()
{
    __HCP_FUNC_ENTRY( "Creation1" );

    HRESULT                         hr;
    CComPtr<CPCHSecurityDescriptor> pNew;


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pNew ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr)
}

static HRESULT Creation2()
{
    __HCP_FUNC_ENTRY( "Creation2" );

    HRESULT                        hr;
    CComPtr<CPCHAccessControlList> pNew;


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pNew ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr)
}

static HRESULT Creation3()
{
    __HCP_FUNC_ENTRY( "Creation3" );

    HRESULT                         hr;
    CComPtr<CPCHAccessControlEntry> pNew;


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pNew ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr)
}

////////////////////////////////////////////////////////////////////////////////

static HRESULT LoadAndSave()
{
    __HCP_FUNC_ENTRY( "LoadAndSave" );

    HRESULT                         hr;
    CComPtr<CPCHSecurityDescriptor> pNew;
    CComPtr<IStream>                pStream;
    CComBSTR                        bstrVal;


    __MPC_EXIT_IF_METHOD_FAILS(hr, OpenStreamForRead( L"%TEMP%\\test1.xml", &pStream ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pNew ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pNew->LoadXMLAsStream( pStream ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pNew->SaveXMLAsString( &bstrVal ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr)
}

////////////////////////////////////////////////////////////////////////////////

static HRESULT FileToCOM()
{
    __HCP_FUNC_ENTRY( "FileToCOM" );

    HRESULT                         hr;
    CPCHSecurityDescriptorDirect    sd;
    CComPtr<CPCHSecurityDescriptor> pNew;
    MPC::wstring                   	szFileFull( L"%TEMP%\\sdtest.xml" ); MPC::SubstituteEnvVariables( szFileFull );
    HANDLE                         	hFile = INVALID_HANDLE_VALUE;
    CComPtr<IStream>               	pStreamIn;
    CComPtr<IStream>               	pStreamOut;


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pNew ));


    __MPC_EXIT_IF_INVALID_HANDLE(hr, hFile, ::CreateFileW( szFileFull.c_str(), GENERIC_ALL, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, sd.AttachObject( hFile ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, sd.ConvertSDToCOM( pNew ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pNew->SaveXMLAsStream(            (IUnknown**)&pStreamIn  ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, OpenStreamForWrite   ( L"%TEMP%\\sddump.xml", &pStreamOut ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::BaseStream::TransferData( pStreamIn, pStreamOut ));



    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(hFile != INVALID_HANDLE_VALUE) ::CloseHandle( hFile );

    __HCP_FUNC_EXIT(hr)
}

////////////////////////////////////////////////////////////////////////////////

static HRESULT COMToFile()
{
    __HCP_FUNC_ENTRY( "COMToFile" );

    HRESULT                      hr;
    CPCHSecurityDescriptorDirect sd;
    MPC::wstring                 szFileFull( L"%TEMP%\\sdtest2.xml" ); MPC::SubstituteEnvVariables( szFileFull );
    HANDLE                       hFile = INVALID_HANDLE_VALUE;


	{
		CComPtr<CPCHSecurityDescriptor> pNew;
		CComPtr<IStream>               	pStream;

		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pNew ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, OpenStreamForRead    ( L"%TEMP%\\sddump_pre.xml", &pStream ));
		__MPC_EXIT_IF_METHOD_FAILS(hr, pNew->LoadXMLAsStream(            (IUnknown*)      pStream ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, sd.ConvertSDFromCOM( pNew ));

		__MPC_EXIT_IF_INVALID_HANDLE(hr, hFile, ::CreateFileW( szFileFull.c_str(), GENERIC_ALL, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL ));
	}

    {
        CComPtr<CPCHSecurityDescriptor> pNew;
        CComPtr<IStream>               	pStreamIn;
        CComPtr<IStream>               	pStreamOut;

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pNew ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, sd.ConvertSDToCOM( pNew ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, pNew->SaveXMLAsStream(                 (IUnknown**)&pStreamIn  ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, OpenStreamForWrite   ( L"%TEMP%\\sddump_post.xml", &pStreamOut ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::BaseStream::TransferData( pStreamIn, pStreamOut ));
    }

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::SetKernelObjectSecurity( hFile, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION, sd.GetSD() ));



    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(hFile != INVALID_HANDLE_VALUE) ::CloseHandle( hFile );

    __HCP_FUNC_EXIT(hr)
}

////////////////////////////////////////////////////////////////////////////////

static HRESULT RunTests( int argc, WCHAR **argv )
{
    __HCP_FUNC_ENTRY( "RunTests" );

    HRESULT hr;

    __MPC_EXIT_IF_METHOD_FAILS(hr, Creation1());
    __MPC_EXIT_IF_METHOD_FAILS(hr, Creation2());
    __MPC_EXIT_IF_METHOD_FAILS(hr, Creation3());

    __MPC_EXIT_IF_METHOD_FAILS(hr, LoadAndSave());

    __MPC_EXIT_IF_METHOD_FAILS(hr, FileToCOM());
    __MPC_EXIT_IF_METHOD_FAILS(hr, COMToFile());

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

int __cdecl wmain( int argc, WCHAR **argv, WCHAR **envp)
{
    HRESULT  hr;

    if(SUCCEEDED(hr = ::CoInitializeEx( NULL, COINIT_MULTITHREADED )))
    {
        hr = RunTests( argc, argv );

        ::CoUninitialize();
    }

    return FAILED(hr) ? 10 : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\setupsupport\client\main.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    main.cpp

Abstract:
    This file contains the Unit Test for Cabinet functions.

Revision History:
    Davide Massarenti   (Dmassare)  09/03/99
        created

******************************************************************************/

#include "stdafx.h"


#include <initguid.h>

#include "msscript.h"

#include "HelpServiceTypeLib.h"
#include "HelpServiceTypeLib_i.c"

#include "HelpCenterTypeLib.h"
#include "HelpCenterTypeLib_i.c"

////////////////////////////////////////////////////////////////////////////////

#define LOG__MPC_EXIT_IF_METHOD_FAILS(hr, cmd)                                             \
{                                                                                          \
    if(FAILED(hr=cmd))                                                                     \
    {                                                                                      \
        l_FileLog.LogRecord( "!!ERROR: %08x %s %d\n", hr, #cmd, __LINE__ );                \
      __MPC_TRACE_HRESULT(hr); __MPC_FUNC_LEAVE;                                           \
    }                                                                                      \
}

////////////////////////////////////////////////////////////////////////////////

static const DWORD   c_dwVersion = 0x07494250; // PBI 07


static const WCHAR   c_szNTTREE_BASE         [] = L"HelpAndSupportServices";
static const WCHAR   c_szNTTREE_INDEX        [] = L"index.dat";
static const WCHAR   c_szNTTREE_TMP          [] = L"%TEMP%";

static const WCHAR   c_szPackageDescription  [] = L"package_description.xml";

static const WCHAR   c_szHHT_rootTag         [] = L"METADATA";

static const WCHAR   c_szHHT_manual_STOPSIGN [] = L"STOPSIGN_ENTRIES";
static const WCHAR   c_szHHT_manual_STOPWORD [] = L"STOPWORD_ENTRIES";
static const WCHAR   c_szHHT_manual_OPERATOR [] = L"OPERATOR_ENTRIES";

static const WCHAR   c_szHHT_synset_SYNTABLE [] = L"SYNTABLE";

static const WCHAR   c_szHHT_loc_SCOPE       [] = L"SCOPE_DEFINITION";
static const WCHAR   c_szHHT_loc_TAXONOMY    [] = L"TAXONOMY_ENTRIES";

static const WCHAR   c_szHHT_noloc_FTS       [] = L"FTS";
static const WCHAR   c_szHHT_noloc_INDEX     [] = L"INDEX";
static const WCHAR   c_szHHT_noloc_HELPIMAGE [] = L"HELPIMAGE";


static const WCHAR   c_szHHT_conv_SCOPE      [] = L"SCOPE_DEFINITION/SCOPE";
static LPCWSTR const c_rgHHT_conv_SCOPE      [] = { L"DISPLAYNAME" };

static const WCHAR   c_szHHT_conv_TAXONOMY   [] = L"TAXONOMY_ENTRIES/TAXONOMY_ENTRY";
static LPCWSTR const c_rgHHT_conv_TAXONOMY   [] = { L"TITLE", L"DESCRIPTION" };

////////////////////////////////////////

static MPC::FileLog l_FileLog;
static LPCWSTR      l_szRoot       = NULL;
static LPCWSTR      l_szLog        = NULL;
static LPCWSTR      l_szDBLog      = NULL;
static int          l_lMaxElements = 1000;

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

struct SetupImageEntry;
struct FileEntry;
struct TaxonomyEntry;
struct PackageEntry;
struct PostBuildEntry;

////////////////////////////////////////////////////////////////////////////////

struct SetupImageEntry
{
    MPC::wstring m_strSKU;
    MPC::wstring m_strLocalization;
    MPC::wstring m_strPurpose;
    MPC::wstring m_strSourceFile;
    MPC::wstring m_strTemporaryName;
    MPC::wstring m_strDestinationName;
    MPC::wstring m_strDestinationDir;

    MPC::wstring m_strTemporaryFullPath;
    DATE         m_lastModified;
    bool         m_fUpdated;

    SetupImageEntry()
    {
        m_lastModified = 0;
        m_fUpdated     = false;
    }


    friend HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/       SetupImageEntry& val );
    friend HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const SetupImageEntry& val );


    HRESULT Import( /*[in]*/ PostBuildEntry& pbe, /*[in]*/ const MPC::wstring& strRoot );
    HRESULT Export( /*[in]*/ PostBuildEntry& pbe, /*[in]*/ const MPC::wstring& strRoot );

    void FixRoot( /*[in]*/ const MPC::wstring& strRootOld, /*[in]*/ const MPC::wstring& strRoot );
};

////////////////////////////////////////////////////////////////////////////////

struct FileEntry
{
    MPC::wstring m_strName;
    MPC::wstring m_strFullPath;
    DATE         m_lastModified_HIGH;
    DATE         m_lastModified_LOW;
    long         m_lChunks;
    bool         m_fUpdated;

    FileEntry()
    {
        m_lastModified_HIGH = 0;
        m_lastModified_LOW  = 0;
        m_lChunks           = 0;
        m_fUpdated          = false;
    }


    friend HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/       FileEntry& val );
    friend HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const FileEntry& val );


    void GenerateChunkName( /*[in]*/ long lChunk, /*[out]*/ MPC::wstring& strFile ) const;

    void GetDate( /*[out]*/ DATE& date_HIGH, /*[out]*/ DATE& date_LOW  ) const;

    void SetDate    ( /*[in]*/ bool fLookForChunks = false );
    bool WasModified() const;

    void FixRoot( /*[in]*/ const MPC::wstring& strRootOld, /*[in]*/ const MPC::wstring& strRoot );

    bool IsNewer( /*[in]*/ const FileEntry& fe   );
    bool IsNewer( /*[in]*/ DATE             date );
};

typedef std::list< FileEntry >   FileList;
typedef FileList::iterator       FileIter;
typedef FileList::const_iterator FileIterConst;

////////////////////////////////////////////////////////////////////////////////

struct TaxonomyEntry
{
    FileEntry m_fe;
    FileEntry m_feMANUAL;
    FileEntry m_feSYNSET;
    FileEntry m_feLOC;
    FileEntry m_feNOLOC;
    bool      m_fUpdated;

    FileEntry m_fe_New;

    TaxonomyEntry()
    {
        m_fUpdated = false;
    }


    friend HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/       TaxonomyEntry& val );
    friend HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const TaxonomyEntry& val );


    HRESULT Import( /*[in]*/ PackageEntry& pe, /*[in]*/ PostBuildEntry& pbe, /*[in]*/ const MPC::wstring& strRoot );
    HRESULT Export( /*[in]*/ PackageEntry& pe, /*[in]*/ PostBuildEntry& pbe, /*[in]*/ const MPC::wstring& strRoot );

    void FixRoot( /*[in]*/ const MPC::wstring& strRootOld, /*[in]*/ const MPC::wstring& strRoot );
};

typedef std::list< TaxonomyEntry >   TaxonomyList;
typedef TaxonomyList::iterator       TaxonomyIter;
typedef TaxonomyList::const_iterator TaxonomyIterConst;

////////////////////////////////////////////////////////////////////////////////

struct PackageEntry
{
    MPC::wstring m_strDir;
    MPC::wstring m_strPackageDescription;
    FileList     m_flSAF;
    FileList     m_flINSTALL;
    TaxonomyList m_flHHT;

    MPC::wstring m_strNew_Cabinet;
    MPC::wstring m_strNew_Database;

    MPC::wstring m_DB_strSKU;
    long         m_DB_lLCID;
    MPC::wstring m_DB_strDisplayName;


    friend HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/       PackageEntry& val );
    friend HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const PackageEntry& val );

    HRESULT OpenPackageDescription( /*[in/out]*/ MPC::XmlUtil& xml );

    HRESULT Import( /*[in]*/ PostBuildEntry& pbe, /*[in]*/ const MPC::wstring& strRoot );
    HRESULT Export( /*[in]*/ PostBuildEntry& pbe, /*[in]*/ const MPC::wstring& strRoot );

    HRESULT ProcessHHTFile( /*[in]*/ LPCWSTR szHHTFile, /*[in]*/ JetBlue::SessionHandle* handle, /*[in]*/ JetBlue::Database* db );
    HRESULT CreateDatabase( /*[in]*/ const MPC::wstring& strTmp );

    void FixRoot( /*[in]*/ const MPC::wstring& strRootOld, /*[in]*/ const MPC::wstring& strRoot );
};

////////////////////////////////////////////////////////////////////////////////

enum PostBuildType
{
    POSTBUILDTYPE_NORMAL = 0,
    POSTBUILDTYPE_SAF       ,
    POSTBUILDTYPE_HHT       ,
};

struct PostBuildEntry
{
    PostBuildType   m_pbt;
    SetupImageEntry m_entry;
    PackageEntry    m_package;


    friend HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/       PostBuildEntry& val );
    friend HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const PostBuildEntry& val );

    void FixRoot( /*[in]*/ const MPC::wstring& strRootOld, /*[in]*/ const MPC::wstring& strRoot );
};

typedef std::list< PostBuildEntry >   PostBuildList;
typedef PostBuildList::iterator       PostBuildIter;
typedef PostBuildList::const_iterator PostBuildIterConst;

////////////////////////////////////////////////////////////////////////////////

struct SkuInformation
{
    MPC::wstring m_strName;
    MPC::wstring m_strCabinet;
    MPC::wstring m_strProdFilt;
    bool         m_fDesktop;
    bool         m_fServer;
    bool         m_fEmbedded;

	SkuInformation()
	{
		m_fDesktop  = false;
		m_fServer   = false;
		m_fEmbedded = false;
	}

    friend HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/       SkuInformation& val );
    friend HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const SkuInformation& val );
};

typedef std::list< SkuInformation >        SkuInformationList;
typedef SkuInformationList::iterator       SkuInformationIter;
typedef SkuInformationList::const_iterator SkuInformationIterConst;

////////////////////////////////////////////////////////////////////////////////

static void GetRootDirectory( /*[out]*/ MPC::wstring& strRoot )
{
    strRoot = l_szRoot ? l_szRoot : c_szNTTREE_TMP; MPC::SubstituteEnvVariables( strRoot );
}

static void GetLogFile( /*[out]*/ MPC::wstring& strLog )
{
    GetRootDirectory( strLog );

    strLog += L"\\";
    strLog += l_szLog ? l_szLog : L"hss.log";
}

static void GetDBLogFile( /*[out]*/ MPC::wstring& strDBLog )
{
    GetRootDirectory( strDBLog );

    strDBLog += L"\\";
    strDBLog += l_szDBLog ? l_szDBLog : L"createdb.log";
}

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

static HRESULT ExtractFile( /*[in]*/ LPCWSTR szCabinet, /*[in]*/ LPCWSTR szDst, /*[in]*/ LPCWSTR szFile )
{
    __HCP_FUNC_ENTRY( "ExtractFile" );

    HRESULT hr;

    l_FileLog.LogRecord( L"Extracting '%s' from '%s'", szFile, szCabinet );

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::DecompressFromCabinet( szCabinet, szDst, szFile ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

static void RemoveDirectory( /*[in]*/ const MPC::wstring& strDir )
{
    MPC::FileSystemObject fso( strDir.c_str() );

    (void)fso.DeleteChildren( true, false );
}

////////////////////

static HRESULT MoveDataIsland( /*[in ]*/ MPC::XmlUtil& xmlIN  ,
                               /*[out]*/ MPC::XmlUtil& xmlOUT ,
                               /*[in ]*/ LPCWSTR       szTAG  )
{
    __HCP_FUNC_ENTRY( "MoveDataIsland" );

    HRESULT                  hr;
    CComPtr<IXMLDOMNodeList> xdnl;
    CComPtr<IXMLDOMNode>     xdn;
    CComPtr<IXMLDOMNode>     xdnRoot;


    __MPC_EXIT_IF_METHOD_FAILS(hr, xmlOUT.GetRoot( &xdnRoot ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, xmlIN.GetNodes( szTAG, &xdnl ));
    for(;SUCCEEDED(hr = xdnl->nextNode( &xdn )) && xdn != NULL; xdn.Release())
    {
        CComPtr<IXMLDOMNode> xdnReplaced;

        __MPC_EXIT_IF_METHOD_FAILS(hr, xdnRoot->appendChild( xdn, &xdnReplaced ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

static HRESULT ConvertAttributesToElements( /*[in]*/ MPC::XmlUtil&  xml      ,
                                            /*[in]*/ LPCWSTR        szTAG    ,
                                            /*[in]*/ LPCWSTR const* rgATTRIB ,
                                            /*[in]*/ int            iATTRIB  )
{
    __HCP_FUNC_ENTRY( "ConvertAttributesToElements" );

    HRESULT                  hr;
    CComPtr<IXMLDOMNodeList> xdnl;
    CComPtr<IXMLDOMNode>     xdn;


    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetNodes( szTAG, &xdnl ));
    for(;SUCCEEDED(hr = xdnl->nextNode( &xdn )) && xdn != NULL; xdn.Release())
    {
        for(int i=0; i<iATTRIB; i++)
        {
            LPCWSTR                   szATTRIB = rgATTRIB[i];
            CComPtr<IXMLDOMAttribute> xdna;
            bool                      fFound;

            //
            // Move the value from the attribute to the element.
            //
            if(SUCCEEDED(xml.GetAttribute( NULL, szATTRIB, &xdna, fFound, xdn )) && xdna)
            {
                CComVariant          vValue;
                CComPtr<IXMLDOMNode> xdnSUB;

                __MPC_EXIT_IF_METHOD_FAILS(hr, xdna->get_value( &vValue ));

                __MPC_EXIT_IF_METHOD_FAILS(hr, xml.CreateNode( szATTRIB, &xdnSUB, xdn ));

                __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutValue( NULL, vValue, fFound, xdnSUB ));

                __MPC_EXIT_IF_METHOD_FAILS(hr, xml.RemoveAttribute( NULL, szATTRIB, xdn ));
            }
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

static HRESULT ConvertElementsToAttributes( /*[in]*/ MPC::XmlUtil&  xml      ,
                                            /*[in]*/ LPCWSTR        szTAG    ,
                                            /*[in]*/ LPCWSTR const* rgATTRIB ,
                                            /*[in]*/ int            iATTRIB  )
{
    __HCP_FUNC_ENTRY( "ConvertElementsToAttributes" );

    HRESULT                  hr;
    CComPtr<IXMLDOMNodeList> xdnl;
    CComPtr<IXMLDOMNode>     xdn;


    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetNodes( szTAG, &xdnl ));
    for(;SUCCEEDED(hr = xdnl->nextNode( &xdn )) && xdn != NULL; xdn.Release())
    {
        for(int i=0; i<iATTRIB; i++)
        {
            LPCWSTR              szATTRIB = rgATTRIB[i];
            CComPtr<IXMLDOMNode> xdnSUB;

            //
            // Move the value from the attribute to the element.
            //
            if(SUCCEEDED(xdn->selectSingleNode( CComBSTR( szATTRIB ), &xdnSUB )) && xdnSUB)
            {
                CComVariant vValue;
                bool        fFound;

                __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetValue( NULL, vValue, fFound, xdnSUB ));
                if(fFound)
                {
                    CComPtr<IXMLDOMAttribute> xdna;

                    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, szATTRIB, &xdna, fFound, xdn ));
                    if(xdna)
                    {
                        __MPC_EXIT_IF_METHOD_FAILS(hr, xdna->put_value( vValue ));
                    }
                }

                __MPC_EXIT_IF_METHOD_FAILS(hr, xml.RemoveNode( NULL, xdnSUB ));
            }
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

static HRESULT SpreadToFiles( /*[in]*/ MPC::XmlUtil& xmlSrc ,
                              /*[in]*/ FileEntry&    fe     ,
                              /*[in]*/ long          lLimit )
{
    __HCP_FUNC_ENTRY( "SpreadToFiles" );

    HRESULT      hr;
    MPC::XmlUtil xmlDst;
    MPC::wstring strFile;
    long         lCount  = 0;
    bool         fCreate = true;

    fe.m_lChunks = 0;

    while(1)
    {
        CComPtr<IXMLDOMNode>     xdnRootSrc;
        CComPtr<IXMLDOMNode>     xdnRootDst;
        CComPtr<IXMLDOMNode>     xdnSrc;
        CComPtr<IXMLDOMNode>     xdnDst;
        CComPtr<IXMLDOMNodeList> xdnl;
        CComPtr<IXMLDOMNode>     xdn;
        long                     lLength;


        __MPC_EXIT_IF_METHOD_FAILS(hr, xmlSrc.GetRoot( &xdnRootSrc ));
        if(fCreate)
        {
            fCreate = false;

            __MPC_EXIT_IF_METHOD_FAILS(hr, xmlDst.New( xdnRootSrc, /*fDeep*/false ));
        }
        __MPC_EXIT_IF_METHOD_FAILS(hr, xmlDst.GetRoot( &xdnRootDst ));


        __MPC_EXIT_IF_METHOD_FAILS(hr, xdnRootSrc->get_firstChild( &xdnSrc ));
        if(xdnSrc)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, xdnSrc->get_childNodes( &xdnl    ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, xdnl  ->get_length    ( &lLength ));

            if(lLength < lLimit)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, xdnRootDst->appendChild( xdnSrc, &xdn ));

                lCount += lLength;
            }
            else
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, xdnSrc    ->cloneNode  ( VARIANT_FALSE, &xdn          ));
                __MPC_EXIT_IF_METHOD_FAILS(hr, xdnRootDst->appendChild(                 xdn, &xdnDst )); xdn.Release();

                for(lCount = 0; lCount < lLimit && SUCCEEDED(hr = xdnl->nextNode( &xdn )) && xdn != NULL; xdn.Release(), lCount++)
                {
                    CComPtr<IXMLDOMNode> xdn2;

                    __MPC_EXIT_IF_METHOD_FAILS(hr, xdnDst->appendChild( xdn, &xdn2 ));
                }
            }
        }

        if(xdnSrc == NULL || lCount >= lLimit)
        {
            fe.GenerateChunkName( fe.m_lChunks++, strFile );

            __MPC_EXIT_IF_METHOD_FAILS(hr, xmlDst.Save( strFile.c_str() ));

            lCount  = 0;
            fCreate = true;
        }

        if(!xdnSrc) break;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

static HRESULT CollateFromFiles( /*[in]*/ MPC::XmlUtil& xmlDst ,
                                 /*[in]*/ LPCWSTR       szRoot ,
                                 /*[in]*/ FileEntry&    fe     )
{
    __HCP_FUNC_ENTRY( "CollateFromFiles" );

    HRESULT      hr;
    MPC::XmlUtil xmlSrc;
    MPC::wstring strFile;
    bool         fCreated = false;
    bool         fLoaded;
    bool         fFound;


    for(long l=0; l<fe.m_lChunks; l++)
    {
        fe.GenerateChunkName( l, strFile );


        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, (fCreated ? xmlSrc : xmlDst).Load( strFile.c_str(), szRoot, fLoaded, &fFound ));
        if(fLoaded == false ||
           fFound  == false  )
        {
            l_FileLog.LogRecord( L"Not a valid HHT: '%s'", strFile.c_str() );
            __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
        }

        if(fCreated)
        {
            CComPtr<IXMLDOMNode>     xdnRootSrc;
            CComPtr<IXMLDOMNode>     xdnRootDst;
            CComPtr<IXMLDOMNode>     xdnSrc;
            CComPtr<IXMLDOMNode>     xdnDst;
            CComPtr<IXMLDOMNodeList> xdnl;
            CComPtr<IXMLDOMNode>     xdn;
            CComBSTR                 bstrTag;


            __MPC_EXIT_IF_METHOD_FAILS(hr, xmlSrc.GetRoot( &xdnRootSrc ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, xmlDst.GetRoot( &xdnRootDst ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, xdnRootSrc->get_firstChild( &xdnSrc ));
            if(!xdnSrc) continue;

            __MPC_EXIT_IF_METHOD_FAILS(hr, xdnSrc    ->get_nodeName    ( &bstrTag          ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, xdnRootDst->selectSingleNode(  bstrTag, &xdnDst ));
            if(!xdnDst)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, xdnRootDst->appendChild( xdnSrc, &xdn ));
            }
            else
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, xdnSrc->get_childNodes( &xdnl ));

                for(; SUCCEEDED(hr = xdnl->nextNode( &xdn )) && xdn != NULL; xdn.Release())
                {
                    CComPtr<IXMLDOMNode> xdn2;

                    __MPC_EXIT_IF_METHOD_FAILS(hr, xdnDst->appendChild( xdn, &xdn2 ));
                }
            }
        }
        else
        {
            fCreated = true;
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////

static void FixString( /*[in/out]*/ MPC::wstring& strText, /*[in]*/ const MPC::wstring& strRootOld, /*[in]*/ const MPC::wstring& strRoot )
{
    if(!_wcsnicmp( strText.c_str(), strRootOld.c_str(), strRootOld.size() ))
    {
        strText.replace( 0, strRootOld.size(), strRoot );
    }
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT operator>>( /*[in ]*/ MPC::Serializer& stream ,
                    /*[out]*/ SetupImageEntry& val    )
{
    __HCP_FUNC_ENTRY( "operator>> SetupImageEntry" );

    HRESULT hr;

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_strSKU              );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_strLocalization     );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_strPurpose          );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_strSourceFile       );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_strTemporaryName    );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_strDestinationName  );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_strDestinationDir   );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_lastModified        );

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_strTemporaryFullPath);

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT operator<<( /*[in]*/ MPC::Serializer&       stream ,
                    /*[in]*/ const SetupImageEntry& val    )
{
    __HCP_FUNC_ENTRY( "operator<< SetupImageEntry" );

    HRESULT hr;

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_strSKU              );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_strLocalization     );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_strPurpose          );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_strSourceFile       );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_strTemporaryName    );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_strDestinationName  );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_strDestinationDir   );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_lastModified        );

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_strTemporaryFullPath);

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT SetupImageEntry::Import( /*[in]*/ PostBuildEntry& pbe, /*[in]*/ const MPC::wstring& strRoot )
{
    __HCP_FUNC_ENTRY( "SetupImageEntry::Import" );

    HRESULT hr;
    DATE    dFileSrc;
    DATE    dFileDst;


    m_strTemporaryFullPath  = strRoot;
    m_strTemporaryFullPath += m_strLocalization;
    m_strTemporaryFullPath += L"\\";
    m_strTemporaryFullPath += m_strTemporaryName;

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MakeDir( m_strTemporaryFullPath ));

    dFileSrc = MPC::GetLastModifiedDate( m_strSourceFile        );
    dFileDst = MPC::GetLastModifiedDate( m_strTemporaryFullPath );

    if(dFileSrc == 0) __MPC_SET_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);

    if(dFileSrc > dFileDst)
    {
        l_FileLog.LogRecord( L"Copying file '%s' to '%s'", m_strSourceFile.c_str(), m_strTemporaryFullPath.c_str() );

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CopyFile( m_strSourceFile, m_strTemporaryFullPath ));

        m_lastModified = MPC::GetLastModifiedDate( m_strTemporaryFullPath );
        m_fUpdated     = true;
    }
    else
    {
        m_lastModified = dFileDst;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT SetupImageEntry::Export( /*[in]*/ PostBuildEntry& pbe, /*[in]*/ const MPC::wstring& strRoot )
{
    return S_OK;
}


void SetupImageEntry::FixRoot( /*[in]*/ const MPC::wstring& strRootOld, /*[in]*/ const MPC::wstring& strRoot )
{
    FixString( m_strTemporaryFullPath, strRootOld, strRoot );
}

////////////////////////////////////////

HRESULT operator>>( /*[in ]*/ MPC::Serializer& stream ,
                    /*[out]*/ FileEntry&       val    )
{
    __HCP_FUNC_ENTRY( "operator>> FileEntry" );

    HRESULT hr;

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_strName          );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_strFullPath      );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_lastModified_HIGH);
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_lastModified_LOW );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_lChunks          );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT operator<<( /*[in]*/ MPC::Serializer& stream ,
                    /*[in]*/ const FileEntry& val    )
{
    __HCP_FUNC_ENTRY( "operator<< FileEntry" );

    HRESULT hr;

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_strName          );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_strFullPath      );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_lastModified_HIGH);
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_lastModified_LOW );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_lChunks          );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


void FileEntry::GenerateChunkName( /*[in]*/  long          lChunk  ,
                                   /*[out]*/ MPC::wstring& strFile ) const
{
    WCHAR rgTmp[64]; _snwprintf( rgTmp, MAXSTRLEN(rgTmp), L"_%ld", lChunk );

    strFile = m_strFullPath;
    strFile.append( rgTmp );
}

void FileEntry::GetDate( /*[out]*/ DATE& dHIGH ,
                         /*[out]*/ DATE& dLOW  ) const
{
    if(m_lChunks == 0)
    {
        dHIGH = dLOW = MPC::GetLastModifiedDate( m_strFullPath );
    }
    else
    {
        MPC::wstring strFile;
        DATE         date;
        bool         fNotExist = false;

        dHIGH = 0;
        dLOW  = 0;

        for(long l = 0; l<m_lChunks; l++)
        {
            GenerateChunkName( l, strFile );

            date = MPC::GetLastModifiedDate( strFile );
            if(date)
            {
                if(!dHIGH || dHIGH < date) dHIGH = date;
                if(!dLOW  || dLOW  > date) dLOW  = date;
            }
            else
            {
                fNotExist = true;
            }
        }

        if(fNotExist) dLOW = 0; // In case one chunk doesn't exist, dLOW should reflect that.
    }
}

void FileEntry::SetDate( /*[in]*/ bool fLookForChunks )
{
    if(fLookForChunks && m_lChunks == 0)
    {
        MPC::wstring strFile;

        while(1)
        {
            GenerateChunkName( m_lChunks, strFile );

            if(!MPC::FileSystemObject::IsFile( strFile.c_str() )) break;

            m_lChunks++;
        }
    }

    GetDate( m_lastModified_HIGH, m_lastModified_LOW );
}

bool FileEntry::WasModified() const
{
    DATE dHIGH;
    DATE dLOW;

    GetDate( dHIGH, dLOW );

    return (dHIGH == 0 || dHIGH > m_lastModified_HIGH);
}


void FileEntry::FixRoot( /*[in]*/ const MPC::wstring& strRootOld, /*[in]*/ const MPC::wstring& strRoot )
{
    FixString( m_strFullPath, strRootOld, strRoot );
}

bool FileEntry::IsNewer( /*[in]*/ const FileEntry& fe )
{
    return IsNewer( fe.m_lastModified_LOW );
}

bool FileEntry::IsNewer( /*[in]*/ DATE date )
{
    return (m_lastModified_HIGH > date);
}

////////////////////////////////////////

HRESULT operator>>( /*[in ]*/ MPC::Serializer& stream ,
                    /*[out]*/ TaxonomyEntry&   val    )
{
    __HCP_FUNC_ENTRY( "operator>> TaxonomyEntry" );

    HRESULT hr;

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_fe      );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_feMANUAL);
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_feSYNSET);
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_feLOC   );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_feNOLOC );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT operator<<( /*[in]*/ MPC::Serializer&    stream ,
                   /*[in]*/ const TaxonomyEntry& val    )
{
    __HCP_FUNC_ENTRY( "operator<< TaxonomyEntry" );

    HRESULT hr;

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_fe      );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_feMANUAL);
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_feSYNSET);
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_feLOC   );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_feNOLOC );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


HRESULT TaxonomyEntry::Import( /*[in]*/ PackageEntry& pe, /*[in]*/ PostBuildEntry& pbe, /*[in]*/ const MPC::wstring& strRoot )
{
    __HCP_FUNC_ENTRY( "TaxonomyEntry::Import" );

    HRESULT hr;


    m_feMANUAL.m_strFullPath = m_fe.m_strFullPath; m_feMANUAL.m_strFullPath += L"_MANUAL"; m_feMANUAL.SetDate(                        );
    m_feSYNSET.m_strFullPath = m_fe.m_strFullPath; m_feSYNSET.m_strFullPath += L"_SYNSET"; m_feSYNSET.SetDate(                        );
    m_feLOC   .m_strFullPath = m_fe.m_strFullPath; m_feLOC   .m_strFullPath += L"_LOC";    m_feLOC   .SetDate( /*fLookForChunks*/true );
    m_feNOLOC .m_strFullPath = m_fe.m_strFullPath; m_feNOLOC .m_strFullPath += L"_NOLOC";  m_feNOLOC .SetDate(                        );

    if(m_fe.IsNewer( m_feMANUAL ) ||
       m_fe.IsNewer( m_feSYNSET ) ||
       m_fe.IsNewer( m_feLOC    ) ||
       m_fe.IsNewer( m_feNOLOC  )  )
    {
        MPC::XmlUtil xml;
        bool         fLoaded;
        bool         fFound;


        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, xml.Load( m_fe.m_strFullPath.c_str(), c_szHHT_rootTag, fLoaded, &fFound ));
        if(fLoaded == false ||
           fFound  == false  )
        {
            l_FileLog.LogRecord( L"Not a valid HHT: '%s'", m_fe.m_strFullPath.c_str() );
            __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
        }

        if(m_fe.IsNewer( m_feMANUAL ))
        {
            MPC::XmlUtil             xmlMANUAL;
            CComPtr<IXMLDOMNodeList> xdnl;
            CComPtr<IXMLDOMNode>     xdn;

            l_FileLog.LogRecord( L"Processing HHT '%s' : MANUAL part", m_fe.m_strFullPath.c_str() );

            __MPC_EXIT_IF_METHOD_FAILS(hr, xmlMANUAL.New( c_szHHT_rootTag, L"UTF-16" ));

            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, MoveDataIsland( xml, xmlMANUAL, c_szHHT_manual_STOPSIGN ));
            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, MoveDataIsland( xml, xmlMANUAL, c_szHHT_manual_STOPWORD ));
            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, MoveDataIsland( xml, xmlMANUAL, c_szHHT_manual_OPERATOR ));

            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, xmlMANUAL.Save( m_feMANUAL.m_strFullPath.c_str() ));

            m_feMANUAL.SetDate();
            m_feMANUAL.m_fUpdated = true;
        }

        if(m_fe.IsNewer( m_feSYNSET ))
        {
            MPC::XmlUtil             xmlSYNSET;
            CComPtr<IXMLDOMNodeList> xdnl;
            CComPtr<IXMLDOMNode>     xdn;

            l_FileLog.LogRecord( L"Processing HHT '%s' : SYNSET part", m_fe.m_strFullPath.c_str() );

            __MPC_EXIT_IF_METHOD_FAILS(hr, xmlSYNSET.New( c_szHHT_rootTag, L"UTF-16" ));

            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, MoveDataIsland( xml, xmlSYNSET, c_szHHT_synset_SYNTABLE ));

            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, xmlSYNSET.Save( m_feSYNSET.m_strFullPath.c_str() ));

            m_feSYNSET.SetDate();
            m_feSYNSET.m_fUpdated = true;
        }

        if(m_fe.IsNewer( m_feLOC ))
        {
            MPC::XmlUtil             xmlLOC;
            CComPtr<IXMLDOMNodeList> xdnl;
            CComPtr<IXMLDOMNode>     xdn;

            l_FileLog.LogRecord( L"Processing HHT '%s' : LOC part", m_fe.m_strFullPath.c_str() );

            __MPC_EXIT_IF_METHOD_FAILS(hr, xmlLOC.New( c_szHHT_rootTag, L"UTF-16" ));

            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, MoveDataIsland( xml, xmlLOC, c_szHHT_loc_SCOPE    ));
            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, MoveDataIsland( xml, xmlLOC, c_szHHT_loc_TAXONOMY ));

            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, ConvertAttributesToElements( xmlLOC, c_szHHT_conv_SCOPE   , c_rgHHT_conv_SCOPE   , ARRAYSIZE(c_rgHHT_conv_SCOPE   ) ));
            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, ConvertAttributesToElements( xmlLOC, c_szHHT_conv_TAXONOMY, c_rgHHT_conv_TAXONOMY, ARRAYSIZE(c_rgHHT_conv_TAXONOMY) ));

            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, SpreadToFiles( xmlLOC, m_feLOC, l_lMaxElements ));

            m_feLOC.SetDate();
            m_feLOC.m_fUpdated = true;
        }

        if(m_fe.IsNewer( m_feNOLOC ))
        {
            MPC::XmlUtil             xmlNOLOC;
            CComPtr<IXMLDOMNodeList> xdnl;
            CComPtr<IXMLDOMNode>     xdn;

            l_FileLog.LogRecord( L"Processing HHT '%s' : NOLOC part", m_fe.m_strFullPath.c_str() );

            __MPC_EXIT_IF_METHOD_FAILS(hr, xmlNOLOC.New( c_szHHT_rootTag ));

            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, MoveDataIsland( xml, xmlNOLOC, c_szHHT_noloc_FTS       ));
            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, MoveDataIsland( xml, xmlNOLOC, c_szHHT_noloc_INDEX     ));
            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, MoveDataIsland( xml, xmlNOLOC, c_szHHT_noloc_HELPIMAGE ));

            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, xmlNOLOC.Save( m_feNOLOC.m_strFullPath.c_str() ));

            m_feNOLOC.SetDate();
            m_feNOLOC.m_fUpdated = true;
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT TaxonomyEntry::Export( /*[in]*/ PackageEntry& pe, /*[in]*/ PostBuildEntry& pbe, /*[in]*/ const MPC::wstring& strRoot )
{
    __HCP_FUNC_ENTRY( "TaxonomyEntry::Export" );

    HRESULT hr;


    m_fe_New.m_strFullPath = m_fe.m_strFullPath; m_fe_New.m_strFullPath += L"_GEN";

    m_feMANUAL.SetDate();
    m_feSYNSET.SetDate();
    m_feLOC   .SetDate();
    m_feNOLOC .SetDate();
    m_fe_New  .SetDate();

    if(m_feMANUAL.IsNewer( m_fe_New ) ||
       m_feSYNSET.IsNewer( m_fe_New ) ||
       m_feLOC   .IsNewer( m_fe_New ) ||
       m_feNOLOC .IsNewer( m_fe_New )  )
    {
        MPC::XmlUtil xml;
        bool         fLoaded;
        bool         fFound;


        l_FileLog.LogRecord( L"Processing HHT '%s'", m_fe_New.m_strFullPath.c_str() );

        __MPC_EXIT_IF_METHOD_FAILS(hr, xml.New( c_szHHT_rootTag, L"UTF-16" ));

        {
            MPC::XmlUtil             xmlMANUAL;
            CComPtr<IXMLDOMNodeList> xdnl;
            CComPtr<IXMLDOMNode>     xdn;

            l_FileLog.LogRecord( L"Processing HHT '%s' : MANUAL part", m_fe_New.m_strFullPath.c_str() );

            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, xmlMANUAL.Load( m_feMANUAL.m_strFullPath.c_str(), c_szHHT_rootTag, fLoaded, &fFound ));
            if(fLoaded == false ||
               fFound  == false  )
            {
                l_FileLog.LogRecord( L"Not a valid HHT: '%s'", m_feMANUAL.m_strFullPath.c_str() );
                __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
            }

            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, MoveDataIsland( xmlMANUAL, xml, c_szHHT_manual_STOPSIGN ));
            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, MoveDataIsland( xmlMANUAL, xml, c_szHHT_manual_STOPWORD ));
            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, MoveDataIsland( xmlMANUAL, xml, c_szHHT_manual_OPERATOR ));
        }

        {
            MPC::XmlUtil             xmlSYNSET;
            CComPtr<IXMLDOMNodeList> xdnl;
            CComPtr<IXMLDOMNode>     xdn;

            l_FileLog.LogRecord( L"Processing HHT '%s' : SYNSET part", m_fe_New.m_strFullPath.c_str() );

            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, xmlSYNSET.Load( m_feSYNSET.m_strFullPath.c_str(), c_szHHT_rootTag, fLoaded, &fFound ));
            if(fLoaded == false ||
               fFound  == false  )
            {
                l_FileLog.LogRecord( L"Not a valid HHT: '%s'", m_feSYNSET.m_strFullPath.c_str() );
                __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
            }

            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, MoveDataIsland( xmlSYNSET, xml, c_szHHT_synset_SYNTABLE ));
        }

        {
            MPC::XmlUtil             xmlLOC;
            CComPtr<IXMLDOMNodeList> xdnl;
            CComPtr<IXMLDOMNode>     xdn;

            l_FileLog.LogRecord( L"Processing HHT '%s' : LOC part", m_fe_New.m_strFullPath.c_str() );

            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, CollateFromFiles( xmlLOC, c_szHHT_rootTag, m_feLOC ));

            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, ConvertElementsToAttributes( xmlLOC, c_szHHT_conv_SCOPE   , c_rgHHT_conv_SCOPE   , ARRAYSIZE(c_rgHHT_conv_SCOPE   ) ));
            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, ConvertElementsToAttributes( xmlLOC, c_szHHT_conv_TAXONOMY, c_rgHHT_conv_TAXONOMY, ARRAYSIZE(c_rgHHT_conv_TAXONOMY) ));

            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, MoveDataIsland( xmlLOC, xml, c_szHHT_loc_SCOPE    ));
            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, MoveDataIsland( xmlLOC, xml, c_szHHT_loc_TAXONOMY ));
        }

        {
            MPC::XmlUtil             xmlNOLOC;
            CComPtr<IXMLDOMNodeList> xdnl;
            CComPtr<IXMLDOMNode>     xdn;

            l_FileLog.LogRecord( L"Processing HHT '%s' : NOLOC part", m_fe_New.m_strFullPath.c_str() );

            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, xmlNOLOC.Load( m_feNOLOC.m_strFullPath.c_str(), c_szHHT_rootTag, fLoaded, &fFound ));
            if(fLoaded == false ||
               fFound  == false  )
            {
                l_FileLog.LogRecord( L"Not a valid HHT: '%s'", m_feNOLOC.m_strFullPath.c_str() );
                __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
            }

            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, MoveDataIsland( xmlNOLOC, xml, c_szHHT_noloc_FTS       ));
            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, MoveDataIsland( xmlNOLOC, xml, c_szHHT_noloc_INDEX     ));
            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, MoveDataIsland( xmlNOLOC, xml, c_szHHT_noloc_HELPIMAGE ));
        }

        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, xml.Save( m_fe_New.m_strFullPath.c_str() ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


void TaxonomyEntry::FixRoot( /*[in]*/ const MPC::wstring& strRootOld, /*[in]*/ const MPC::wstring& strRoot )
{
    m_fe      .FixRoot( strRootOld, strRoot );
    m_feMANUAL.FixRoot( strRootOld, strRoot );
    m_feSYNSET.FixRoot( strRootOld, strRoot );
    m_feLOC   .FixRoot( strRootOld, strRoot );
    m_feNOLOC .FixRoot( strRootOld, strRoot );

    m_fe_New  .FixRoot( strRootOld, strRoot );
}

////////////////////////////////////////

HRESULT operator>>( /*[in ]*/ MPC::Serializer& stream ,
                    /*[out]*/ PackageEntry&    val    )
{
    __HCP_FUNC_ENTRY( "operator>> PackageEntry" );

    HRESULT hr;

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_strDir               );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_strPackageDescription);
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_flSAF                );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_flINSTALL            );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_flHHT                );

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_DB_strSKU            );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_DB_lLCID             );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_DB_strDisplayName    );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT operator<<( /*[in]*/ MPC::Serializer&    stream ,
                    /*[in]*/ const PackageEntry& val    )
{
    __HCP_FUNC_ENTRY( "operator<< PackageEntry" );

    HRESULT hr;

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_strDir               );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_strPackageDescription);
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_flSAF                );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_flINSTALL            );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_flHHT                );

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_DB_strSKU            );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_DB_lLCID             );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_DB_strDisplayName    );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT PackageEntry::Import( /*[in]*/ PostBuildEntry& pbe, /*[in]*/ const MPC::wstring& strRoot )
{
    __HCP_FUNC_ENTRY( "PackageEntry::Import" );

    HRESULT            hr;
    MPC::Cabinet::List lst;
    MPC::wstring       strFile;
    MPC::wstring       strFile_Base;
    LPCWSTR            szSourceFile;
    LPCWSTR            szEnd;
    DATE               dFile_PackageDescription;


    strFile = pbe.m_entry.m_strTemporaryFullPath;


    //
    // Create temp dir from the file name.
    //
    szSourceFile = strFile.c_str();
    szEnd = wcsrchr( szSourceFile, '.' );
    if(szEnd)
    {
        m_strDir.assign( szSourceFile, szEnd );
    }
    else
    {
        m_strDir = szSourceFile;
    }

    m_strDir += L"\\";

    if(pbe.m_entry.m_fUpdated)
    {
        RemoveDirectory( m_strDir );

        m_flSAF    .clear();
        m_flINSTALL.clear();
        m_flHHT    .clear();
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MakeDir( m_strDir ));


    //
    // Analyze Package_Description.xml
    //
    {
        MPC::XmlUtil xml;
        bool         fFound;


        m_strPackageDescription  = m_strDir;
        m_strPackageDescription += c_szPackageDescription;

        dFile_PackageDescription = MPC::GetLastModifiedDate( m_strPackageDescription );

        if(dFile_PackageDescription == 0 || pbe.m_entry.m_lastModified > dFile_PackageDescription)
        {
            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, ExtractFile( szSourceFile, m_strPackageDescription.c_str(), c_szPackageDescription ));

            dFile_PackageDescription = MPC::GetLastModifiedDate( m_strPackageDescription );;
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, OpenPackageDescription( xml ));

        //
        // Parse the SAF section.
        //
        {
            CComPtr<IXMLDOMNodeList> xdnl;
            CComPtr<IXMLDOMNode>     xdn;
            FileEntry                fe;

            __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetNodes( L"CONFIG/SAF/@FILE", &xdnl ));
            for(;SUCCEEDED(hr = xdnl->nextNode( &xdn )) && xdn != NULL; xdn.Release())
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetValue( NULL, fe.m_strName, fFound, xdn ));
                if(fFound)
                {
                    fe.m_strFullPath  = m_strDir;
                    fe.m_strFullPath += fe.m_strName;

                    m_flSAF.push_back( fe );
                }
            }
        }

        //
        // Parse the INSTALL section.
        //
        {
            CComPtr<IXMLDOMNodeList> xdnl;
            CComPtr<IXMLDOMNode>     xdn;
            FileEntry                fe;

            __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetNodes( L"INSTALL_CONTENT/FILE/@SOURCE", &xdnl ));
            for(;SUCCEEDED(hr = xdnl->nextNode( &xdn )) && xdn != NULL; xdn.Release())
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetValue( NULL, fe.m_strName, fFound, xdn ));
                if(fFound)
                {
                    fe.m_strFullPath  = m_strDir;
                    fe.m_strFullPath += fe.m_strName;

                    m_flINSTALL.push_back( fe );
                }
            }
        }

        //
        // Parse the HHT section.
        //
        {
            CComPtr<IXMLDOMNodeList> xdnl;
            CComPtr<IXMLDOMNode>     xdn;
            TaxonomyEntry            te;

            __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetNodes( L"METADATA/HHT/@FILE", &xdnl ));
            for(;SUCCEEDED(hr = xdnl->nextNode( &xdn )) && xdn != NULL; xdn.Release())
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetValue( NULL, te.m_fe.m_strName, fFound, xdn ));
                if(fFound)
                {
                    te.m_fe.m_strFullPath  = m_strDir;
                    te.m_fe.m_strFullPath += te.m_fe.m_strName;

                    m_flHHT.push_back( te );
                }
            }
        }
    }

    //
    // Extract all the required files.
    //
    {
        MPC::WStringUCSet setDecompress;
        MPC::Cabinet      cab;
        FileIter          it1;
        FileIter          it2;
        TaxonomyIter      it3;


        __MPC_EXIT_IF_METHOD_FAILS(hr, cab.put_CabinetFile( szSourceFile ));

        for(it1=m_flSAF.begin(); it1!=m_flSAF.end(); it1++)
        {
            FileEntry& fe = *it1;

            if(dFile_PackageDescription > MPC::GetLastModifiedDate( fe.m_strFullPath ))
            {
                if(setDecompress.find( fe.m_strName ) == setDecompress.end())
                {
                    setDecompress.insert( fe.m_strName );

                    l_FileLog.LogRecord( L"Extracting '%s' from '%s'", fe.m_strName.c_str(), szSourceFile );
                    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.AddFile( fe.m_strFullPath.c_str(), fe.m_strName.c_str() ));

                    fe.m_fUpdated = true;
                }
            }
        }

        for(it2=m_flINSTALL.begin(); it2!=m_flINSTALL.end(); it2++)
        {
            FileEntry& fe = *it2;

            if(dFile_PackageDescription > MPC::GetLastModifiedDate( fe.m_strFullPath ))
            {
                if(setDecompress.find( fe.m_strName ) == setDecompress.end())
                {
                    setDecompress.insert( fe.m_strName );

                    l_FileLog.LogRecord( L"Extracting '%s' from '%s'", fe.m_strName.c_str(), szSourceFile );
                    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.AddFile( fe.m_strFullPath.c_str(), fe.m_strName.c_str() ));

                    fe.m_fUpdated = true;
                }
            }
        }

        for(it3=m_flHHT.begin(); it3!=m_flHHT.end(); it3++)
        {
            TaxonomyEntry& te = *it3;

            if(dFile_PackageDescription > MPC::GetLastModifiedDate( te.m_fe.m_strFullPath ))
            {
                if(setDecompress.find( te.m_fe.m_strName ) == setDecompress.end())
                {
                    setDecompress.insert( te.m_fe.m_strName );

                    l_FileLog.LogRecord( L"Extracting '%s' from '%s'", te.m_fe.m_strName.c_str(), szSourceFile );
                    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.AddFile( te.m_fe.m_strFullPath.c_str(), te.m_fe.m_strName.c_str() ));

                    te.m_fe.m_fUpdated = true;
                }
            }
        }

        hr = cab.Decompress();
        if(FAILED(hr))
        {
            MPC::Cabinet::List lst;
            MPC::Cabinet::Iter it;

            if(SUCCEEDED(cab.GetFiles( lst )))
            {
                for(it=lst.begin(); it != lst.end(); it++)
                {
                    if(it->m_fFound == false)
                    {
                        l_FileLog.LogRecord( L"!!ERROR: Missing %s \n", it->m_szName.c_str() );
                    }
                }
            }

            __MPC_FUNC_LEAVE;
        }


        for(it1=m_flSAF.begin(); it1!=m_flSAF.end(); it1++)
        {
            FileEntry& fe = *it1;

            fe.SetDate();
        }

        for(it2=m_flINSTALL.begin(); it2!=m_flINSTALL.end(); it2++)
        {
            FileEntry& fe = *it2;

            fe.SetDate();
        }

        for(it3=m_flHHT.begin(); it3!=m_flHHT.end(); it3++)
        {
            TaxonomyEntry& te = *it3;

            te.m_fe.SetDate();
        }
    }

    //
    // Process the HHTs.
    //
    {
        for(TaxonomyIter it=m_flHHT.begin(); it!=m_flHHT.end(); it++)
        {
            TaxonomyEntry& te = *it;

            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, te.Import( *this, pbe, strRoot ));
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT PackageEntry::Export( /*[in]*/ PostBuildEntry& pbe, /*[in]*/ const MPC::wstring& strRoot )
{
    __HCP_FUNC_ENTRY( "PackageEntry::Export" );

    HRESULT hr;
    DATE    dFile_Cabinet;
    DATE    dFile_PackageDescription;


    m_strNew_Cabinet  = pbe.m_entry.m_strTemporaryFullPath;
    m_strNew_Cabinet += L"_GEN";

    dFile_Cabinet            = MPC::GetLastModifiedDate( m_strNew_Cabinet        );
    dFile_PackageDescription = MPC::GetLastModifiedDate( m_strPackageDescription );


    //
    // Process the HHTs.
    //
    {
        for(TaxonomyIter it=m_flHHT.begin(); it!=m_flHHT.end(); it++)
        {
            TaxonomyEntry& te = *it;

            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, te.Export( *this, pbe, strRoot ));
        }
    }


    //
    // Compress all the required files.
    //
    {
        MPC::Cabinet cab;
        FileIter     it1;
        FileIter     it2;
        TaxonomyIter it3;
        bool         fNew = false;


        __MPC_EXIT_IF_METHOD_FAILS(hr, cab.put_CabinetFile( m_strNew_Cabinet.c_str() ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, cab.AddFile( m_strPackageDescription.c_str(), c_szPackageDescription ));
        if(dFile_PackageDescription > dFile_Cabinet) fNew = true;

        for(it1=m_flSAF.begin(); it1!=m_flSAF.end(); it1++)
        {
            FileEntry& fe = *it1;

            fe.SetDate(); if(fe.IsNewer( dFile_Cabinet )) fNew = true;
            __MPC_EXIT_IF_METHOD_FAILS(hr, cab.AddFile( fe.m_strFullPath.c_str(), fe.m_strName.c_str() ));
        }

        for(it2=m_flINSTALL.begin(); it2!=m_flINSTALL.end(); it2++)
        {
            FileEntry& fe = *it2;

            fe.SetDate(); if(fe.IsNewer( dFile_Cabinet )) fNew = true;
            __MPC_EXIT_IF_METHOD_FAILS(hr, cab.AddFile( fe.m_strFullPath.c_str(), fe.m_strName.c_str() ));
        }

        for(it3=m_flHHT.begin(); it3!=m_flHHT.end(); it3++)
        {
            TaxonomyEntry& te = *it3;

            te.m_fe_New.SetDate(); if(te.m_fe_New.IsNewer( dFile_Cabinet )) fNew = true;
            __MPC_EXIT_IF_METHOD_FAILS(hr, cab.AddFile( te.m_fe_New.m_strFullPath.c_str(), te.m_fe.m_strName.c_str() ));
        }

        if(fNew)
        {
            l_FileLog.LogRecord( L"Compressing '%s'", m_strNew_Cabinet.c_str() );

            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, cab.Compress());
        }
    }

    if(pbe.m_pbt == POSTBUILDTYPE_HHT)
    {
        DATE dCabinet;
        DATE dDatabase;

        m_strNew_Database  = pbe.m_entry.m_strTemporaryFullPath;
        m_strNew_Database += L"_EDB";

        {
            MPC::XmlUtil xml;

            __MPC_EXIT_IF_METHOD_FAILS(hr, OpenPackageDescription( xml ));
        }

        dCabinet  = MPC::GetLastModifiedDate( m_strNew_Cabinet  );
        dDatabase = MPC::GetLastModifiedDate( m_strNew_Database );

        if(dDatabase == 0.0 || dCabinet > dDatabase)
        {
            MPC::wstring strTmp;

            GetRootDirectory( strTmp );
            strTmp += L"\\EDB_";
            strTmp += m_DB_strSKU;
            strTmp += L"\\";

            l_FileLog.LogRecord( L"Create database '%s'", m_strNew_Database.c_str() );

            try
            {
                hr = CreateDatabase( strTmp );
            }
            catch(...)
            {
                hr = E_FAIL;
            }

            //
            // Something JetBlue fails because of a bad checkpoint directory.
            //
            if(FAILED(hr))
            {
                try
                {
                    RemoveDirectory( strTmp );

                    hr = CreateDatabase( strTmp );
                }
                catch(...)
                {
                    hr = E_FAIL;
                }
            }

            if(FAILED(hr))
            {
                (void)MPC::DeleteFile( m_strNew_Database );
            }

            RemoveDirectory( strTmp );

            __MPC_EXIT_IF_METHOD_FAILS(hr, hr);
        }
    }


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////

HRESULT PackageEntry::OpenPackageDescription( /*[in/out]*/ MPC::XmlUtil& xml )
{
    __HCP_FUNC_ENTRY( "PackageEntry::OpenPackageDescription" );

    HRESULT      hr;
    MPC::wstring strLanguage;
    bool         fLoaded;
    bool         fFound;


    LOG__MPC_EXIT_IF_METHOD_FAILS(hr, xml.Load( m_strPackageDescription.c_str(), L"HELPCENTERPACKAGE", fLoaded, &fFound ));
    if(fLoaded == false ||
       fFound  == false  )
    {
        l_FileLog.LogRecord( L"Not a valid Package_Description: '%s'", m_strPackageDescription.c_str() );
        __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( L"SKU", L"VALUE"      , m_DB_strSKU        , fFound ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( L"SKU", L"DISPLAYNAME", m_DB_strDisplayName, fFound ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetAttribute( L"LANGUAGE", L"VALUE" , strLanguage        , fFound )); if(fFound) m_DB_lLCID = _wtol( strLanguage.c_str() );

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT PackageEntry::ProcessHHTFile( /*[in]*/ LPCWSTR                 szHHTFile ,
                                      /*[in]*/ JetBlue::SessionHandle* handle    ,
                                      /*[in]*/ JetBlue::Database*      db        )
{
    __HCP_FUNC_ENTRY( "PackageEntry::ProcessHHTFile" );

    HRESULT                   hr;
    CComPtr<HCUpdate::Engine> obj;
    MPC::wstring              strDBLog; GetDBLogFile( strDBLog );

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &obj ));

    LOG__MPC_EXIT_IF_METHOD_FAILS(hr, obj->PopulateDatabase( m_strNew_Cabinet.c_str(), szHHTFile, strDBLog.c_str(), m_DB_strSKU.c_str(), m_DB_lLCID, *handle, db ));

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT PackageEntry::CreateDatabase( /*[in]*/ const MPC::wstring& strTmp )
{
    __HCP_FUNC_ENTRY( "PackageEntry::CreateDatabase" );

    USES_CONVERSION;

    HRESULT                hr;
    JetBlue::SessionPool   pool;
    JetBlue::SessionHandle handle;
    JetBlue::Database*     db;
    long                   lMSFTid;
    bool                   fPool     = false;
    bool                   fSession  = false;
    bool                   fDatabase = false;

    //    if(g_fVerbose) wprintf( L"Creating database %s\n", szDatabase );

    //
    // Remove any old database.
    //
    (void)MPC::DeleteFile( m_strNew_Database );

    ////////////////////////////////////////////////////////////////////////////////

    //
    // Create new database.
    //
    RemoveDirectory( strTmp );
    LOG__MPC_EXIT_IF_METHOD_FAILS(hr, pool.Init( strTmp.c_str() )); fPool = true;

    LOG__MPC_EXIT_IF_METHOD_FAILS(hr, pool.GetSession( handle )); fSession = true;

    LOG__MPC_EXIT_IF_METHOD_FAILS(hr, handle->GetDatabase( W2A( m_strNew_Database.c_str() ), db, /*fReadOnly*/false, /*fCreate*/true, /*fRepair*/false )) fDatabase = true;

    ////////////////////////////////////////////////////////////////////////////////

    //
    // Load the schema in the database.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, handle->BeginTransaction());
    {
        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::CreateSchema( db ));
    }
    __MPC_EXIT_IF_METHOD_FAILS(hr, handle->CommitTransaction());

    ////////////////////////////////////////////////////////////////////////////////

    {
        Taxonomy::Settings ts( m_DB_strSKU.c_str(), m_DB_lLCID );
        Taxonomy::Updater  updater;

        __MPC_EXIT_IF_METHOD_FAILS(hr, updater.Init( ts, db ));

        //
        // Generate content owner
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, handle->BeginTransaction());
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, updater.CreateOwner( lMSFTid, HC_MICROSOFT_DN, /*fIsOEM*/true ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, updater.LocateOwner(          HC_MICROSOFT_DN                 ));
        }
        __MPC_EXIT_IF_METHOD_FAILS(hr, handle->CommitTransaction());


        //
        // Create the root and non-mapped node in the topic table
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, handle->BeginTransaction());
        {
            Taxonomy::RS_Taxonomy* rs;

            __MPC_EXIT_IF_METHOD_FAILS(hr, updater.GetTaxonomy( &rs ));

            rs->m_ID_owner = lMSFTid;
            rs->m_strEntry = L"<ROOT>";
            __MPC_EXIT_IF_METHOD_FAILS(hr, rs->Insert());
        }
        __MPC_EXIT_IF_METHOD_FAILS(hr, handle->CommitTransaction());

        //
        // Create the system scope.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, handle->BeginTransaction());
        {
            Taxonomy::RS_Scope* rs;

            __MPC_EXIT_IF_METHOD_FAILS(hr, updater.GetScope( &rs ));

            rs->m_ID_owner = lMSFTid;
            rs->m_strID    = L"<SYSTEM>";
            __MPC_EXIT_IF_METHOD_FAILS(hr, rs->Insert());
        }
        __MPC_EXIT_IF_METHOD_FAILS(hr, handle->CommitTransaction());

        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, updater.Close());
    }

    ////////////////////////////////////////////////////////////////////////////////

    //
    // Process the HHT file, after closing the updater.
    //
    {
        for(TaxonomyIter it=m_flHHT.begin(); it!=m_flHHT.end(); it++)
        {
            TaxonomyEntry& te = *it;

            LOG__MPC_EXIT_IF_METHOD_FAILS(hr, ProcessHHTFile( te.m_fe_New.m_strFullPath.c_str(), &handle, db ));
        }
    }

    ////////////////////////////////////////////////////////////////////////////////


    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    if(fDatabase) { ;                         }
    if(fSession ) { handle.Release();         }
    if(fPool    ) { (void)pool.Close( true ); }

    __HCP_FUNC_EXIT(hr);
}


void PackageEntry::FixRoot( /*[in]*/ const MPC::wstring& strRootOld, /*[in]*/ const MPC::wstring& strRoot )
{
    FileIter     it1;
    TaxonomyIter it2;

    FixString( m_strDir               , strRootOld, strRoot );
    FixString( m_strPackageDescription, strRootOld, strRoot );

    for(it1=m_flSAF    .begin(); it1!=m_flSAF    .end(); it1++) it1->FixRoot( strRootOld, strRoot );
    for(it1=m_flINSTALL.begin(); it1!=m_flINSTALL.end(); it1++) it1->FixRoot( strRootOld, strRoot );
    for(it2=m_flHHT    .begin(); it2!=m_flHHT    .end(); it2++) it2->FixRoot( strRootOld, strRoot );

    FixString( m_strNew_Cabinet , strRootOld, strRoot );
    FixString( m_strNew_Database, strRootOld, strRoot );
}

////////////////////////////////////////

HRESULT operator>>( /*[in ]*/ MPC::Serializer& stream ,
                    /*[out]*/ PostBuildEntry&  val    )
{
    __HCP_FUNC_ENTRY( "operator>> PostBuildEntry" );

    HRESULT hr;
    long    pbt;

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >>     pbt      ); val.m_pbt = (PostBuildType)pbt;
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_entry  );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_package);

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT operator<<( /*[in]*/ MPC::Serializer&      stream ,
                    /*[in]*/ const PostBuildEntry& val    )
{
    __HCP_FUNC_ENTRY( "operator<< PostBuildEntry" );

    HRESULT hr;
    long    pbt = (long)val.m_pbt;

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream <<     pbt      );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_entry  );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_package);

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


void PostBuildEntry::FixRoot( /*[in]*/ const MPC::wstring& strRootOld, /*[in]*/ const MPC::wstring& strRoot )
{
    m_entry  .FixRoot( strRootOld, strRoot );
    m_package.FixRoot( strRootOld, strRoot );
}

////////////////////////////////////////

HRESULT operator>>( /*[in ]*/ MPC::Serializer& stream ,
                    /*[out]*/ SkuInformation&  val    )
{
    __HCP_FUNC_ENTRY( "operator>> SkuInformation" );

    HRESULT hr;

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_strName    );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_strCabinet );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_strProdFilt);
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_fDesktop   );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_fServer    );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> val.m_fEmbedded  );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT operator<<( /*[in]*/ MPC::Serializer&      stream ,
                    /*[in]*/ const SkuInformation& val    )
{
    __HCP_FUNC_ENTRY( "operator<< SkuInformation" );

    HRESULT hr;

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_strName    );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_strCabinet );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_strProdFilt);
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_fDesktop   );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_fServer    );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << val.m_fEmbedded  );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////

static void Usage()
{
    wprintf( L"Usage: HssSetupTool <options> <command> <parameters>\n\n"                       );
    wprintf( L"Available commands:\n\n"                                                        );
    wprintf( L"  BINPLACE <sku file> <setup image file> <root directory> <object directory>\n" );
    wprintf( L"  COMPILE  <root directory> <sku>\n"                                            );
    wprintf( L"  LIST     <input cabinet>\n"                                                   );
    wprintf( L"  EXTRACT  <input cabinet> <file>\n"                                            );
    wprintf( L"  INSTALL  <input cabinet>\n"                                                   );
    wprintf( L"\n"                                                                             );
    wprintf( L"  UNPACK   <input cabinet> <directory>\n"                                       );
    wprintf( L"  PACK     <directory> <output cabinet>\n"                                      );
}

#define CHECK_ARGS(argc,num) if(argc < num) { Usage(); __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG); }

////////////////////////////////////////

static bool LookupBoolean( /*[in] */ LPCWSTR szString )
{
    if(_wcsicmp( szString, L"TRUE" ) == 0 ||
       _wcsicmp( szString, L"1"    ) == 0 ||
       _wcsicmp( szString, L"ON"   ) == 0  )
    {
		return true;
    }

	return false;
}

static bool ParseFile( /*[in ]*/ LPSTR            szLine ,
                       /*[out]*/ SetupImageEntry& en     )
{
    USES_CONVERSION;

    HRESULT                   hr;
    LPSTR                     szEnd;
    std::vector<MPC::wstring> vec;

    //
    // Skip comments.
    //
    if(szLine[0] == '#') return false;

    if((szEnd = strchr( szLine, '\r' ))) szEnd[0] = 0;
    if((szEnd = strchr( szLine, '\n' ))) szEnd[0] = 0;

    MPC::SplitAtDelimiter( vec, A2W( szLine ), L"," );
    if(vec.size() != 7) return false;


    en.m_strSKU             = vec[0];
    en.m_strLocalization    = vec[1];
    en.m_strPurpose         = vec[2];
    en.m_strSourceFile      = vec[3];
    en.m_strTemporaryName   = vec[4];
    en.m_strDestinationName = vec[5];
    en.m_strDestinationDir  = vec[6];

    return true;
}

static bool ParseFile( /*[in ]*/ LPSTR           szLine ,
                       /*[out]*/ SkuInformation& si     )
{
    USES_CONVERSION;

    HRESULT                   hr;
    LPSTR                     szEnd;
    std::vector<MPC::wstring> vec;

    //
    // Skip comments.
    //
    if(szLine[0] == '#') return false;

    if((szEnd = strchr( szLine, '\r' ))) szEnd[0] = 0;
    if((szEnd = strchr( szLine, '\n' ))) szEnd[0] = 0;

    MPC::SplitAtDelimiter( vec, A2W( szLine ), L" ", /*fDelimIsAString*/false, /*fSkipAdjacentDelims*/true );
    if(vec.size() != 6) return false;


    si.m_strName     = 				  vec[0];
    si.m_strCabinet  = 				  vec[1];
    si.m_strProdFilt = 				  vec[2];
    si.m_fDesktop    = LookupBoolean( vec[3].c_str() );
    si.m_fServer     = LookupBoolean( vec[4].c_str() );
    si.m_fEmbedded   = LookupBoolean( vec[5].c_str() );

    return true;
}

static bool GetSetupImageFile( /*[in ]*/ SkuInformationList&     sil        ,
							   /*[in ]*/ LPCWSTR                 szSKU      ,
                               /*[out]*/ MPC::wstring&           strCabinet ,
                               /*[out]*/ Taxonomy::InstanceBase& data       )
{
	if(!_wcsicmp( szSKU, L"NONE" ))
	{
		strCabinet       = L"none.cab";
		data.m_fDesktop  = false;
		data.m_fServer   = false;
		data.m_fEmbedded = false;
		return true;
	}

    for(SkuInformationIter it=sil.begin(); it!=sil.end(); it++)
    {
        if(!_wcsicmp( szSKU, it->m_strName.c_str() ))
        {
            strCabinet       = it->m_strCabinet;
            data.m_fDesktop  = it->m_fDesktop  ;
            data.m_fServer   = it->m_fServer   ;
            data.m_fEmbedded = it->m_fEmbedded ;

            return true;
        }
    }

    return false;
}

static HRESULT OpenFile( /*[in ]*/ const MPC::wstring& strFile ,
                         /*[out]*/ FILE*&              fh     )
{
    __HCP_FUNC_ENTRY( "OpenFile" );

    HRESULT hr;


    fh = _wfopen( strFile.c_str(), L"r" );
    if(fh == NULL)
    {
        DWORD dwRes = ::GetLastError();

        l_FileLog.LogRecord( L"%08x: Can't open file '%s'", HRESULT_FROM_WIN32(dwRes), strFile.c_str() );

        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRes);
    }


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////


static HRESULT Index_SAVE( /*[in]*/ const MPC::wstring& strRoot ,
                           /*[in]*/ PostBuildList&      pbl     ,
						   /*[in]*/ SkuInformationList& sil     )
{
    __HCP_FUNC_ENTRY( "Index_SAVE" );

    HRESULT      hr;
    MPC::wstring strFileOut;
    HANDLE       hFile = NULL;


    strFileOut  = strRoot;
    strFileOut += c_szNTTREE_INDEX;


    //
    // Create the new file.
    //
    __MPC_EXIT_IF_INVALID_HANDLE__CLEAN(hr, hFile, ::CreateFileW( strFileOut.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL ));

    //
    // Dump to file.
    //
    {
        MPC::Serializer_File      streamReal( hFile      );
        MPC::Serializer_Buffering streamBuf ( streamReal );

        __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf << c_dwVersion );
        __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf << strRoot     );
        __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf << pbl         );
        __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf << sil         );

        __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf.Flush());
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(hFile) ::CloseHandle( hFile );

    __HCP_FUNC_EXIT(hr);
}

static HRESULT Index_LOAD( /*[in]*/ const MPC::wstring& strRoot ,
                           /*[in]*/ PostBuildList&      pbl     ,
						   /*[in]*/ SkuInformationList& sil     )
{
    __HCP_FUNC_ENTRY( "Index_LOAD" );

    HRESULT      hr;
    MPC::wstring strFileOut;
    HANDLE       hFile = NULL;


    strFileOut  = strRoot;
    strFileOut += c_szNTTREE_INDEX;


    pbl.clear();

    __MPC_EXIT_IF_INVALID_HANDLE__CLEAN(hr, hFile, ::CreateFileW( strFileOut.c_str(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL ));

    {
        MPC::Serializer_File      streamReal( hFile      );
        MPC::Serializer_Buffering streamBuf ( streamReal );
        MPC::wstring              strRootOld;
        DWORD                     dwVer;

        __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf >> dwVer      ); if(dwVer != c_dwVersion) __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
        __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf >> strRootOld );
        __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf >> pbl        );
        __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf >> sil        );

        if(strRootOld != strRoot)
        {
            for(PostBuildIter it=pbl.begin(); it!=pbl.end(); it++)
            {
                it->FixRoot( strRootOld, strRoot );
            }
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(hFile) ::CloseHandle( hFile );

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

static HRESULT Binplace( /*[in]*/ LPCWSTR szSKUList  ,
						 /*[in]*/ LPCWSTR szFileList ,
						 /*[in]*/ LPCWSTR szRoot     ,
                         /*[in]*/ LPCWSTR szObject   )
{
    __HCP_FUNC_ENTRY( "Binplace" );

    HRESULT            hr;
    FILE*              in = NULL;
    char               buf[1024];
    MPC::wstring       strFileList;
    MPC::wstring       strRoot;
    PostBuildList      pbl;
    SkuInformationList sil;


    strFileList  = szFileList;
    MPC::SubstituteEnvVariables( strFileList );

    strRoot  = szRoot;
    strRoot += L"\\";
    strRoot += c_szNTTREE_BASE;
    strRoot += L"\\";
    MPC::SubstituteEnvVariables( strRoot );

    l_FileLog.LogRecord( L"\n==================\n"
                           L"BINPLACE - start\n\n" );

    ////////////////////////////////////////

    ::SetEnvironmentVariableW( L"OBJECTDIR", szObject );

    {
        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, OpenFile( szSKUList, in ));
        while(fgets( buf, 1024, in ))
        {
            SkuInformation si;

            if(ParseFile( buf, si ))
            {
				sil.push_back( si );

				l_FileLog.LogRecord( L"Found SKU: %-30s %-15s %-15s %s%s%s" , 
									 si.m_strName    .c_str()               ,
									 si.m_strCabinet .c_str()			    ,
									 si.m_strProdFilt.c_str()			    ,
									 si.m_fDesktop  ? L"DESKTOP "  : L""    , 
									 si.m_fServer   ? L"SERVER "   : L""    , 
									 si.m_fEmbedded ? L"EMBEDDED " : L""    );
			}
        }
        fclose( in ); in = NULL;

		l_FileLog.LogRecord( L"\n" );
    }

    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MakeDir( strRoot.c_str() ));

        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, OpenFile( strFileList, in ));
        while(fgets( buf, 1024, in ))
        {
            SetupImageEntry en;

            if(ParseFile( buf, en ))
            {
                PostBuildEntry& pbe = *( pbl.insert( pbl.end() ) );

                MPC::SubstituteEnvVariables( en.m_strSourceFile );
                pbe.m_entry = en;

                //
                // This copies the file if newer.
                //
                LOG__MPC_EXIT_IF_METHOD_FAILS(hr, pbe.m_entry.Import( pbe, strRoot ));

                if(!MPC::StrICmp( en.m_strLocalization, L"HHT" ))
                {
                    //
                    // Expand the cabinet and process the HHTs.
                    //
                    LOG__MPC_EXIT_IF_METHOD_FAILS(hr, pbe.m_package.Import( pbe, strRoot ));

                    pbe.m_pbt = POSTBUILDTYPE_HHT;
                }
                else if(!MPC::StrICmp( en.m_strLocalization, L"SAF" ))
                {
                    //
                    // Expand the cabinet and process the channel.
                    //
                    LOG__MPC_EXIT_IF_METHOD_FAILS(hr, pbe.m_package.Import( pbe, strRoot ));

                    pbe.m_pbt = POSTBUILDTYPE_SAF;
                }
                else
                {
                    pbe.m_pbt = POSTBUILDTYPE_NORMAL;
                }
            }
        }
        fclose( in ); in = NULL;

        LOG__MPC_EXIT_IF_METHOD_FAILS(hr, Index_SAVE( strRoot, pbl, sil ));
    }

    ////////////////////////////////////////

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    l_FileLog.LogRecord( L"\nBINPLACE - done\n"
                           L"=================\n\n" );

    if(in) fclose( in );

    __HCP_FUNC_EXIT(hr);
}

static HRESULT Compile( /*[in]*/ LPCWSTR szRoot ,
                        /*[in]*/ LPCWSTR szSKU  )
{
    __HCP_FUNC_ENTRY( "Compile" );

    HRESULT                 hr;
    Installer::Package      pkg;
    Taxonomy::InstanceBase& data = pkg.GetData();
    MPC::wstring            strRoot;
    MPC::wstring            strCabinet;
    MPC::wstring            strFullPath;
    PostBuildList           pbl;
    SkuInformationList      sil;
    DATE                    dFile_SetupImage;
    bool                    fNew = false;


    l_FileLog.LogRecord( L"\n==================\n"
                           L"COMPILE - start\n\n" );

    ////////////////////////////////////////

    strRoot  = szRoot;
    strRoot += L"\\";
    strRoot += c_szNTTREE_BASE;
    strRoot += L"\\";
    MPC::SubstituteEnvVariables( strRoot );

    LOG__MPC_EXIT_IF_METHOD_FAILS(hr, Index_LOAD( strRoot, pbl, sil ));

    if(GetSetupImageFile( sil, szSKU, strCabinet, data ) == false)
    {
		l_FileLog.LogRecord( L"'%s' is not a valid SKU name!\n\n", szSKU );

        __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }

    strFullPath  = szRoot;
    strFullPath += L"\\";
    strFullPath += c_szNTTREE_BASE;
    strFullPath += L"\\";
    strFullPath += strCabinet;
    MPC::SubstituteEnvVariables( strFullPath );


    dFile_SetupImage = MPC::GetLastModifiedDate( strFullPath );
    __MPC_EXIT_IF_METHOD_FAILS(hr, pkg.Init( strFullPath.c_str() ));


    for(PostBuildIter itPB=pbl.begin(); itPB!=pbl.end(); itPB++)
    {
        PostBuildEntry& pbe = *itPB;

        if(MPC::StrICmp( pbe.m_entry.m_strSKU, L"All" ) == 0 ||
           MPC::StrICmp( pbe.m_entry.m_strSKU, szSKU  ) == 0  )
        {
            Installer::Iter itFile     = pkg.NewFile();
            MPC::wstring    strFileSrc = pbe.m_entry.m_strTemporaryFullPath;
            MPC::wstring    strFileDst = pbe.m_entry.m_strDestinationDir; strFileDst += L"\\"; strFileDst += pbe.m_entry.m_strDestinationName;

            __MPC_EXIT_IF_METHOD_FAILS(hr, itFile->SetPurpose( pbe.m_entry.m_strPurpose.c_str() ));

            itFile->m_strFileLocal    = strFileSrc;
            itFile->m_strFileInner    = pbe.m_entry.m_strTemporaryName;
            itFile->m_strFileLocation = strFileDst;

            if(pbe.m_pbt == POSTBUILDTYPE_HHT ||
               pbe.m_pbt == POSTBUILDTYPE_SAF  )
            {
                LOG__MPC_EXIT_IF_METHOD_FAILS(hr, pbe.m_package.Export( pbe, strRoot ));

                itFile->m_strFileLocal = (pbe.m_pbt == POSTBUILDTYPE_SAF) ? pbe.m_package.m_strNew_Cabinet : pbe.m_package.m_strNew_Database;
            }

            if(pbe.m_pbt == POSTBUILDTYPE_HHT)
            {
                data.m_ths.m_strSKU   = pbe.m_package.m_DB_strSKU;
                data.m_ths.m_lLCID    = pbe.m_package.m_DB_lLCID;
                data.m_strDisplayName = pbe.m_package.m_DB_strDisplayName;
                data.m_strProductID   = L"Windows_XP";
                data.m_strVersion     = L"1.0.0.0";
            }

            if(FAILED(hr = itFile->UpdateSignature()))
            {
                l_FileLog.LogRecord( L"%08x: Can't locate '%s'\n", hr, strFileSrc.c_str() );

                __HCP_FUNC_LEAVE;
            }

            if(MPC::GetLastModifiedDate( itFile->m_strFileLocal ) > dFile_SetupImage) fNew = true;
        }
    }

    if(fNew)
    {
        l_FileLog.LogRecord( L"Create setup image '%s'", strFullPath.c_str() );

        //
        // Create the output cabinet.
        //
        if(FAILED(hr = pkg.Save()))
        {
            l_FileLog.LogRecord( L"%08x: Can't create output file '%s'\n", strFullPath.c_str() );

            __HCP_FUNC_LEAVE;
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    l_FileLog.LogRecord( L"\nCOMPILE - done\n"
                           L"=================\n\n" );

    __HCP_FUNC_EXIT(hr);
}

static HRESULT List( /*[in]*/ LPCWSTR szInput )
{
    __HCP_FUNC_ENTRY( "List" );

    HRESULT            hr;
    Installer::Package pkg;


    __MPC_EXIT_IF_METHOD_FAILS(hr, pkg.Init( szInput ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pkg.Load());


    {
        Installer::Iter itBegin = pkg.GetBegin();
        Installer::Iter itEnd   = pkg.GetEnd  ();

        for(;itBegin != itEnd; itBegin++)
        {
            wprintf( L"%s -> %s\n", itBegin->m_strFileInner.c_str(), itBegin->m_strFileLocation.c_str() );
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

static HRESULT Extract( /*[in]*/ LPCWSTR szInput ,
                        /*[in]*/ LPCWSTR szFile  )
{
    __HCP_FUNC_ENTRY( "Extract" );

    HRESULT            hr;
    Installer::Package pkg;


    __MPC_EXIT_IF_METHOD_FAILS(hr, pkg.Init( szInput ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pkg.Load());


    {
        Installer::Iter itBegin = pkg.GetBegin();
        Installer::Iter itEnd   = pkg.GetEnd  ();

        for(;itBegin != itEnd; itBegin++)
        {
            if(!MPC::StrICmp( itBegin->m_strFileInner, szFile ))
            {
                itBegin->m_strFileLocal = szFile; // Extract the file in the current directory.

                __MPC_EXIT_IF_METHOD_FAILS(hr, itBegin->Extract( szInput ));
                break;
            }
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

static HRESULT Install( /*[in]*/ LPCWSTR szInput )
{
    __HCP_FUNC_ENTRY( "Install" );

    HRESULT            hr;
    Installer::Package pkg;


    __MPC_EXIT_IF_METHOD_FAILS(hr, pkg.Init( szInput ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pkg.Install());

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

static HRESULT Unpack( /*[in]*/ LPCWSTR szInput ,
                       /*[in]*/ LPCWSTR szDir   )
{
    __HCP_FUNC_ENTRY( "Unpack" );

    HRESULT            hr;
    Installer::Package pkg;


    __MPC_EXIT_IF_METHOD_FAILS(hr, pkg.Init( szInput ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pkg.Unpack( szDir ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

static HRESULT Pack( /*[in]*/ LPCWSTR szDir    ,
                     /*[in]*/ LPCWSTR szOutput )
{
    __HCP_FUNC_ENTRY( "Pack" );

    HRESULT            hr;
    Installer::Package pkg;


    __MPC_EXIT_IF_METHOD_FAILS(hr, pkg.Init( szOutput ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pkg.Pack( szDir ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

static HRESULT ProcessArguments( int     argc   ,
                                 LPCWSTR argv[] )
{
    __HCP_FUNC_ENTRY( "ProcessArguments" );

    HRESULT hr;

    argv++;
    argc--;

    while(argc-->0)
    {
        LPCWSTR szArg = *argv++;
        int     adv   = -1;

        if(szArg[0] == '-' ||
           szArg[0] == '/'  )
        {
            szArg++;

            if(argc >= 1)
            {
                LPCWSTR szArg2 = argv[0];

                if(!_wcsicmp( szArg, L"ROOT"        )) { l_szRoot       =        szArg2  ; adv = 1; }
                if(!_wcsicmp( szArg, L"LOG"         )) { l_szLog        =        szArg2  ; adv = 1; }
                if(!_wcsicmp( szArg, L"DBLOG"       )) { l_szDBLog      =        szArg2  ; adv = 1; }
                if(!_wcsicmp( szArg, L"MAXELEMENTS" )) { l_lMaxElements = _wtol( szArg2 ); adv = 1; }
            }
        }
        else
        {
            {
                MPC::wstring strLog;

                GetLogFile( strLog );

                l_FileLog.SetLocation( strLog.c_str() );
            }

            if(!_wcsicmp( szArg, L"BINPLACE" ) && argc >= 4) // <sku file> <setup image file> <root directory> <object directory>
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, Binplace( argv[0], argv[1], argv[2], argv[3] )); adv = 4;
            }
            else if(!_wcsicmp( szArg, L"COMPILE" ) && argc >= 2) // <root directory> <sku>
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, Compile( argv[0], argv[1] )); adv = 2;
            }
            else if(!_wcsicmp( szArg, L"LIST" ) && argc >= 1) // <input cabinet>
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, List( argv[0] )); adv = 2;
            }
            else if(!_wcsicmp( szArg, L"EXTRACT" ) && argc >= 2) // <input cabinet> <file>
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, Extract( argv[0], argv[1] )); adv = 2;
            }
            else if(!_wcsicmp( szArg, L"INSTALL" ) && argc >= 1) // <input cabinet>
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, Install( argv[0] )); adv = 1;
            }
            else if(!_wcsicmp( szArg, L"UNPACK" ) && argc >= 2) // <input cabinet> <directory>
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, Unpack( argv[0], argv[1] )); adv = 2;
            }
            else if(!_wcsicmp( szArg, L"PACK" ) && argc >= 2) // <directory> <output cabinet>
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, Pack( argv[0], argv[1] )); adv = 2;
            }
        }

        if(adv == -1)
        {
            Usage(); __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
        }

        argv += adv;
        argc -= adv;
    }


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

int __cdecl wmain( int     argc   ,
                   LPCWSTR argv[] )
{
    HRESULT hr;

    //DebugBreak();

    //
    // We need to be a single-threaded application, because we are hosting script engines and
    // script engines don't like to be called from different threads...
    //
    if(SUCCEEDED(hr = ::CoInitializeEx( NULL, COINIT_APARTMENTTHREADED )))
    {
        if(SUCCEEDED(hr = ::CoInitializeSecurity( NULL                     ,
                                                  -1                       , // We don't care which authentication service we use.
                                                  NULL                     ,
                                                  NULL                     ,
                                                  RPC_C_AUTHN_LEVEL_CONNECT, // We want to identify the callers.
                                                  RPC_C_IMP_LEVEL_DELEGATE , // We want to be able to forward the caller's identity.
                                                  NULL                     ,
                                                  EOAC_DYNAMIC_CLOAKING    , // Let's use the thread token for outbound calls.
                                                  NULL                     )))
        {
            __MPC_TRACE_INIT();

            //
            // Process arguments.
            //
            try
            {
                hr = ProcessArguments( argc, argv );
            }
            catch(...)
            {
                hr = E_FAIL;
            }

            __MPC_TRACE_TERM();
        }

        ::CoUninitialize();
    }

    return FAILED(hr) ? 10 : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\setupsupport\lib\filelist.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    FileList.cpp

Abstract:
    This file contains the implementation of the writer/reader for the
    list of signed files, used to authenticate files to be copied into the
    VxD-protected directories.

Revision History:
    Davide Massarenti   (Dmassare)  03/11/2000
        created

******************************************************************************/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////

static const DWORD l_dwVersion = 0x02314953; // IS1 02

static const WCHAR c_SignatureFileName[] = L"SIGNATURES";

static const WCHAR c_MicrosoftOID[] = L"CN=Microsoft Corporation,L=Redmond,S=Washington,C=US";
static const WCHAR c_PCHTestOID  [] = L"CN=pchtest,L=Redmond,S=Washington,C=US";

static const WCHAR c_RelocationBase[] = HC_ROOT_HELPSVC L"\\";

/////////////////////////////////////////////////////////////////////////////

Installer::FileEntry::FileEntry()
{
    m_purpose = PURPOSE_INVALID; // PURPOSE      m_purpose;
                                 // MPC::wstring m_strFileLocal;
                                 // MPC::wstring m_strFileLocation;
                                 // MPC::wstring m_strFileInner;
    m_dwCRC   = 0;               // DWORD        m_dwCRC;
}

HRESULT Installer::operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/ Installer::FileEntry& val )
{
    HRESULT hr;
    DWORD   dwPurpose;

    if(SUCCEEDED(hr = (stream >> dwPurpose            )) &&
       SUCCEEDED(hr = (stream >> val.m_strFileLocation)) &&
       SUCCEEDED(hr = (stream >> val.m_strFileInner   )) &&
       SUCCEEDED(hr = (stream >> val.m_dwCRC          ))  )
    {
        val.m_purpose = (Installer::PURPOSE)dwPurpose;
        hr = S_OK;
    }

    return hr;
}

HRESULT Installer::operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const Installer::FileEntry& val )
{
    HRESULT hr;
    DWORD   dwPurpose = val.m_purpose;

    if(SUCCEEDED(hr = (stream << dwPurpose            )) &&
       SUCCEEDED(hr = (stream << val.m_strFileLocation)) &&
       SUCCEEDED(hr = (stream << val.m_strFileInner   )) &&
       SUCCEEDED(hr = (stream << val.m_dwCRC          ))  )
    {
        hr = S_OK;
    }

    return hr;
}

////////////////////

HRESULT Installer::FileEntry::SetPurpose( /*[in ]*/ LPCWSTR szID )
{
    if(!_wcsicmp( szID, L"BINARY"   )) { m_purpose = PURPOSE_BINARY  ; return S_OK; }
    if(!_wcsicmp( szID, L"OTHER"    )) { m_purpose = PURPOSE_OTHER   ; return S_OK; }
    if(!_wcsicmp( szID, L"DATABASE" )) { m_purpose = PURPOSE_DATABASE; return S_OK; }
    if(!_wcsicmp( szID, L"PACKAGE"  )) { m_purpose = PURPOSE_PACKAGE ; return S_OK; }
    if(!_wcsicmp( szID, L"UI"       )) { m_purpose = PURPOSE_UI      ; return S_OK; }

    return E_INVALIDARG;
}

////////////////////

HRESULT Installer::FileEntry::UpdateSignature()
{
    __HCP_FUNC_ENTRY( "Installer::FileEntry::UpdateSignature" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ComputeCRC( m_dwCRC, m_strFileLocal.c_str() ));

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Installer::FileEntry::VerifySignature() const
{
    __HCP_FUNC_ENTRY( "Installer::FileEntry::VerifySignature" );

    HRESULT hr;
    LPCWSTR szFile = m_strFileLocal.c_str();
    DWORD   dwCRC;


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ComputeCRC( dwCRC, szFile ));
    if(m_dwCRC != dwCRC)
    {
        int iLen = wcslen( szFile );

        //
        // The file has the wrong CRC and is not a cabinet, exit with failure.
        //
        if(iLen < 4 || _wcsicmp( &szFile[iLen-4], L".cab" ) != 0)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
        }


        //
        // It's a cabinet, check if it comes from the same source as the signature file.
        //
        {
            Installer::Package fl;

            fl.Init( szFile );

            __MPC_EXIT_IF_METHOD_FAILS(hr, fl.VerifyTrust());
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Installer::FileEntry::Extract( /*[in]*/ LPCWSTR szCabinetFile )
{
    __HCP_FUNC_ENTRY( "Installer::FileEntry::Extract" );

    HRESULT      hr;
    MPC::Cabinet cab;


    if(m_strFileLocal.length() == 0)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetTemporaryFileName( m_strFileLocal ));
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MakeDir( m_strFileLocal ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.put_CabinetFile( szCabinetFile                                  ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.AddFile        ( m_strFileLocal.c_str(), m_strFileInner.c_str() ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.Decompress     (                                                ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Installer::FileEntry::Extract( /*[in]*/ MPC::Cabinet& cab )
{
    __HCP_FUNC_ENTRY( "Installer::FileEntry::Extract" );

    HRESULT hr;


    if(m_strFileLocal.length() == 0)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetTemporaryFileName( m_strFileLocal ));
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MakeDir( m_strFileLocal ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.AddFile( m_strFileLocal.c_str(), m_strFileInner.c_str() ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Installer::FileEntry::Install()
{
    __HCP_FUNC_ENTRY( "Installer::FileEntry::Install" );

    HRESULT hr;
    MPC::wstring strFileLocation( m_strFileLocation ); MPC::SubstituteEnvVariables( strFileLocation );


    if(m_strFileLocal.length() == 0)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MakeDir( strFileLocation ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CopyFile( m_strFileLocal, strFileLocation, /*fForce*/true, /*fDelayed*/true ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, RemoveLocal());

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Installer::FileEntry::RemoveLocal()
{
    __HCP_FUNC_ENTRY( "Installer::FileEntry::RemoveLocal" );

    HRESULT hr;


    if(m_strFileLocal.length() == 0)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::DeleteFile( m_strFileLocal, true, true ));

    m_strFileLocal.erase();
    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

Installer::Package::Package()
{
    __HCP_FUNC_ENTRY( "Installer::Package::Package" );

    // MPC::wstring       m_strFile;
    // Taxonomy::Instance m_data;
    // List               m_lstFiles;
}

HRESULT Installer::operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/ Installer::Package& val )
{
    HRESULT hr;
    DWORD   dwVer;

    if(FAILED(stream >> dwVer) || dwVer != l_dwVersion) return E_FAIL;

    if(SUCCEEDED(hr = (stream >> val.m_data    )) &&
       SUCCEEDED(hr = (stream >> val.m_lstFiles))  )
    {
        hr = S_OK;
    }

    return hr;
}

HRESULT Installer::operator<<( /*[in]*/ MPC::Serializer& stream, /*[in] */ const Installer::Package& val )
{
    HRESULT hr;
    DWORD   dwVer = l_dwVersion;

    if(SUCCEEDED(hr = (stream << dwVer         )) &&
       SUCCEEDED(hr = (stream << val.m_data    )) &&
       SUCCEEDED(hr = (stream << val.m_lstFiles))  )
    {
        hr = S_OK;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////

LPCWSTR             	Installer::Package::GetFile () { return m_strFile.c_str();                     }
Taxonomy::InstanceBase& Installer::Package::GetData () { return m_data;                                }
Installer::Iter     	Installer::Package::GetBegin() { return m_lstFiles.begin();                    }
Installer::Iter     	Installer::Package::GetEnd  () { return m_lstFiles.end  ();                    }
Installer::Iter     	Installer::Package::NewFile () { return m_lstFiles.insert( m_lstFiles.end() ); }

/////////////////////////////////////////////////////////////////////////////

HRESULT Installer::Package::Init( /*[in]*/ LPCWSTR szFile )
{
    __HCP_FUNC_ENTRY( "Installer::Package::Init" );

    HRESULT hr;


    m_lstFiles.clear();

    m_strFile = szFile;
    hr        = S_OK;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Installer::Package::GetList( /*[in]*/ LPCWSTR szSignatureFile )
{
    __HCP_FUNC_ENTRY( "Installer::Package::GetList" );

    HRESULT hr;
    HANDLE  hFile = NULL;


    m_lstFiles.clear();


    //
    // Open file and read it.
    //
    hFile = ::CreateFileW( szSignatureFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
    if(hFile != INVALID_HANDLE_VALUE)
    {
        MPC::Serializer_File      streamReal( hFile      );
        MPC::Serializer_Buffering streamBuf ( streamReal );

        __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf >> *this );
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(hFile) ::CloseHandle( hFile );

    __HCP_FUNC_EXIT(hr);
}

HRESULT Installer::Package::GenerateList( /*[in]*/ LPCWSTR szSignatureFile )
{
    __HCP_FUNC_ENTRY( "Installer::Package::GenerateList" );

    HRESULT   hr;
    HANDLE    hFile = NULL;
    IterConst it;


    //
    // Create the new file.
    //
    __MPC_EXIT_IF_INVALID_HANDLE__CLEAN(hr, hFile, ::CreateFileW( szSignatureFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL ));

    //
    // Dump to file.
    //
    {
        MPC::Serializer_File      streamReal( hFile      );
        MPC::Serializer_Buffering streamBuf ( streamReal );

        __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf << *this);

        __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf.Flush());
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(hFile) ::CloseHandle( hFile );

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT Installer::Package::Load()
{
    __HCP_FUNC_ENTRY( "Installer::Package::Load" );

    HRESULT   hr;
    FileEntry fe;


    fe.m_strFileInner = c_SignatureFileName;

    __MPC_EXIT_IF_METHOD_FAILS(hr, fe.Extract( m_strFile.c_str() ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, GetList( fe.m_strFileLocal.c_str() ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    (void)fe.RemoveLocal();

    __HCP_FUNC_EXIT(hr);
}

HRESULT Installer::Package::Save()
{
    __HCP_FUNC_ENTRY( "Installer::Package::Save" );

    HRESULT      hr;
    MPC::wstring strFileOut;
    MPC::Cabinet cab;
    IterConst    it;


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetTemporaryFileName( strFileOut ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, GenerateList( strFileOut.c_str() ));


    //
    // Create cabinet, reserving 6144 bytes for the digital signature.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.put_CabinetFile( m_strFile.c_str(), 6144 ));

    //
    // Add the signature file plus all the data files.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.AddFile( strFileOut.c_str(), c_SignatureFileName ));
    for(it = m_lstFiles.begin(); it != m_lstFiles.end(); it++)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, cab.AddFile( it->m_strFileLocal.c_str(), it->m_strFileInner.c_str() ));
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.Compress());

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    (void)MPC::RemoveTemporaryFile( strFileOut );

    __HCP_FUNC_EXIT(hr);
}

HRESULT Installer::Package::Install( /*[in]*/ const PURPOSE* rgPurpose, /*[in]*/ LPCWSTR szRelocation )
{
    __HCP_FUNC_ENTRY( "Installer::Package::Install" );

    HRESULT      hr;
    Iter         it;
    MPC::Cabinet cab;


    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.put_CabinetFile( m_strFile.c_str() ));

	for(int pass=0; pass<2; pass++)
	{
		for(it = m_lstFiles.begin(); it != m_lstFiles.end(); it++)
		{
			FileEntry& en = *it;

			if(rgPurpose)
			{
				const PURPOSE* ptr = rgPurpose;
				PURPOSE        p;

				while((p = *ptr++) != PURPOSE_INVALID)
				{
					if(en.m_purpose == p) break;
				}

				if(p == PURPOSE_INVALID) continue;

				if(szRelocation)
				{
					//
					// Just install files in the SYSTEM subtree.
					//
					if(_wcsnicmp( en.m_strFileLocation.c_str(), c_RelocationBase, MAXSTRLEN(c_RelocationBase) )) continue;
				}
			}

			if(pass == 0)
			{
				__MPC_EXIT_IF_METHOD_FAILS(hr, it->Extract( cab ));
			}
			else
			{
				if(szRelocation)
				{
					en.m_strFileLocation.replace( 0, MAXSTRLEN(c_RelocationBase), szRelocation );
				}

				if(FAILED(en.VerifySignature()))
				{
					// Something went wrong....
				}
				else
				{
					__MPC_EXIT_IF_METHOD_FAILS(hr, en.Install());
				}
			}
		}

		if(pass == 0)
		{
			__MPC_EXIT_IF_METHOD_FAILS(hr, cab.Decompress());
		}
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

	//
	// Cleanup the files not installed.
	//
    for(it = m_lstFiles.begin(); it != m_lstFiles.end(); it++)
    {
		FileEntry& en = *it;
		
		(void)en.RemoveLocal();
    }

    __HCP_FUNC_EXIT(hr);
}

HRESULT Installer::Package::Unpack( /*[in]*/ LPCWSTR szDirectory )
{
    __HCP_FUNC_ENTRY( "Installer::Package::Unpack" );

    HRESULT      hr;
    MPC::wstring strDir;
    LPCWSTR      szEnd;

    if(!STRINGISPRESENT(szDirectory))
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }

    szEnd = szDirectory + wcslen( szDirectory );
    while(szEnd > szDirectory && (szEnd[-1] == '\\' || szEnd[-1] == '/')) szEnd--;
    strDir.append( szDirectory, szEnd );
    strDir.append( L"\\"              );


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MakeDir( strDir ));


    //
    // Phase one, get the list of files.
    //
    {
        FileEntry fe;

        fe.m_strFileLocal = strDir; fe.m_strFileLocal += c_SignatureFileName;
        fe.m_strFileInner =                              c_SignatureFileName;

        __MPC_EXIT_IF_METHOD_FAILS(hr, fe.Extract( m_strFile.c_str() ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, GetList( fe.m_strFileLocal.c_str() ));
    }

    //
    // Phase two, decompress all the files.
    //
    {
        MPC::Cabinet cab;
        Iter         it;

        __MPC_EXIT_IF_METHOD_FAILS(hr, cab.put_CabinetFile( m_strFile.c_str() ));

        for(it = m_lstFiles.begin(); it != m_lstFiles.end(); it++)
        {
            it->m_strFileLocal = strDir; it->m_strFileLocal += it->m_strFileInner;

            __MPC_EXIT_IF_METHOD_FAILS(hr, it->Extract( cab ));
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, cab.Decompress());
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Installer::Package::Pack( /*[in]*/ LPCWSTR szDirectory )
{
    __HCP_FUNC_ENTRY( "Installer::Package::Pack" );

    HRESULT      hr;
    MPC::wstring strDir;
    LPCWSTR      szEnd;
    MPC::wstring strSignature;


    if(!STRINGISPRESENT(szDirectory))
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }


    szEnd = szDirectory + wcslen( szDirectory );
    while(szEnd > szDirectory && (szEnd[-1] == '\\' || szEnd[-1] == '/')) szEnd--;
    strDir.append( szDirectory, szEnd );
    strDir.append( L"\\"              );


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MakeDir( strDir ));


    //
    // Phase one, get the list of files.
    //
    {
        strSignature = strDir; strSignature += c_SignatureFileName;

        __MPC_EXIT_IF_METHOD_FAILS(hr, GetList( strSignature.c_str() ));
    }

    //
    // Phase two, compress all the files.
    //
    {
        MPC::Cabinet cab;
        Iter         it;

        __MPC_EXIT_IF_METHOD_FAILS(hr, cab.put_CabinetFile( m_strFile.c_str() ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, cab.AddFile( strSignature.c_str(), c_SignatureFileName ));
        for(it = m_lstFiles.begin(); it != m_lstFiles.end(); it++)
        {
            it->m_strFileLocal = strDir; it->m_strFileLocal += it->m_strFileInner;

            __MPC_EXIT_IF_METHOD_FAILS(hr, it->UpdateSignature());

            __MPC_EXIT_IF_METHOD_FAILS(hr, cab.AddFile( it->m_strFileLocal.c_str(), it->m_strFileInner.c_str() ));
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, GenerateList( strSignature.c_str() ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, cab.Compress());
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

static void GetDNInfo( PCCERT_CONTEXT pCC       ,
                       LPCSTR         field     ,
                       LPCWSTR        fieldName ,
                       MPC::wstring&  strBuf    )
{
    WCHAR rgTmp[512];

    if(strBuf.length()) strBuf += L",";

    strBuf += fieldName;

    ::CertGetNameStringW( pCC, CERT_NAME_ATTR_TYPE, 0, (void*)field, rgTmp, MAXSTRLEN(rgTmp) ); rgTmp[MAXSTRLEN(rgTmp)] = 0;

    strBuf += rgTmp;
}

HRESULT Installer::Package::VerifyTrust()
{
    __HCP_FUNC_ENTRY( "Installer::Package::VerifyTrust" );

    HRESULT            hr;
    MPC::wstring       strInfo;
    WINTRUST_DATA      wtdWinTrust;
    WINTRUST_FILE_INFO wtfWinTrustFile;
    GUID               guidPubSoftwareTrustProv = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    HCERTSTORE         hCertStore               = NULL;
    PCCERT_CONTEXT     pCC                      = NULL;
    DWORD              dwEncoding;
    DWORD              dwContentType;
    DWORD              dwFormatType;


    // set up wintrust file info struct
    ::ZeroMemory( &wtfWinTrustFile, sizeof(wtfWinTrustFile) );
    wtfWinTrustFile.cbStruct      = sizeof(wtfWinTrustFile);
    wtfWinTrustFile.pcwszFilePath = m_strFile.c_str();

    // set up wintrust data struct
    ::ZeroMemory( &wtdWinTrust, sizeof(wtdWinTrust) );
    wtdWinTrust.cbStruct      = sizeof(wtdWinTrust);
    wtdWinTrust.dwUnionChoice = WTD_CHOICE_FILE;
    wtdWinTrust.pFile         = &wtfWinTrustFile;
    wtdWinTrust.dwUIChoice    = WTD_UI_NONE;

    // Verify the trust of the help package
    __MPC_EXIT_IF_METHOD_FAILS(hr, ::WinVerifyTrust( 0, &guidPubSoftwareTrustProv, &wtdWinTrust ));

    // Start querying the cert object
    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CryptQueryObject( CERT_QUERY_OBJECT_FILE                     ,   // dwObjectType
                                                             m_strFile.c_str()                          ,   // pvObject
                                                             CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED ,   // dwExpectedContentTypeFlags
                                                             CERT_QUERY_FORMAT_FLAG_ALL                 ,   // dwExpectedFormatTypeFlags
                                                             0                                          ,   // dwFlags
                                                             &dwEncoding                                ,   // pdwMsgAndCertEncodingType
                                                             &dwContentType                             ,   // pdwContentType
                                                             &dwFormatType                              ,   // pdwFormatType
                                                             &hCertStore                                ,   // phCertStore
                                                             NULL                                       ,   // phMsg
                                                             NULL                                       )); // ppvContext

    // get the first cert
    __MPC_EXIT_IF_CALL_RETURNS_NULL(hr, (pCC = ::CertEnumCertificatesInStore( hCertStore, NULL )));

    GetDNInfo( pCC, szOID_COMMON_NAME           , L"CN=", strInfo );
    GetDNInfo( pCC, szOID_LOCALITY_NAME         , L"L=" , strInfo );
    GetDNInfo( pCC, szOID_STATE_OR_PROVINCE_NAME, L"S=" , strInfo );
    GetDNInfo( pCC, szOID_COUNTRY_NAME          , L"C=" , strInfo );

    //
    // Check identity...
    //
    if(MPC::StrICmp( strInfo, c_MicrosoftOID ) &&
       MPC::StrICmp( strInfo, c_PCHTestOID   )  )
    {
        __MPC_SET_ERROR_AND_EXIT(hr, TRUST_E_EXPLICIT_DISTRUST);
    }


    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    if(pCC       ) ::CertFreeCertificateContext( pCC           );
    if(hCertStore) ::CertCloseStore            ( hCertStore, 0 );

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\setupsupport\client\stdafx.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    StdAfx.h

Abstract:
    Precompiled header.

Revision History:
    Davide Massarenti   (Dmassare)  04/07/2000
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__35881994_CD02_11D2_9370_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__35881994_CD02_11D2_9370_00C04F72DAF7__INCLUDED_

#include <module.h>

#include <stdio.h>
#include <stdlib.h>
#include <float.h>

#include <HCP_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_COM.h>
#include <MPC_logging.h>

#include <JetBlueLib.h>
#include <PCHUpdate.h>
#include <TaxonomyDatabase.h>


#include <FileList.h>
#include <wintrust.h>
#include <wincrypt.h>
#include <softpub.h>

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__35881994_CD02_11D2_9370_00C04F72DAF7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\trustedscripts\stdafx.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    stdafx.h

Abstract:
    include file for standard system include files,
    or project specific include files that are used frequently,
    but are changed infrequently


Revision History:
    Davide Massarenti   (Dmassare)  07/21/99
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_

#include <module.h>

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

//////

#include <HCP_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_COM.h>

#include <Debug.h>

//////

#include <ProjectConstants.h>

//////

#include <SecurityLib.h>

//////

#include <AccountsLib.h>

//////

#include <TrustedScripts.h>

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\trustedscripts\scriptlauncher.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    ScriptWrapper_ClientSide.cpp

Abstract:
    File for implementation of CPCHScriptLauncher class,
    a generic wrapper for remoting scripting engines.

Revision History:
    Davide Massarenti created  04/02/2001

********************************************************************/

#include "stdafx.h"

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

CPCHScriptWrapper_Launcher::CPCHScriptWrapper_Launcher()
{
    				 // MPC::CComPtrThreadNeutral<IUnknown> m_engine;
	m_pCLSID = NULL; // const CLSID*                        m_pCLSID;
	                 // CComBSTR                            m_bstrURL;
}

CPCHScriptWrapper_Launcher::~CPCHScriptWrapper_Launcher()
{
	Thread_Abort();
}

HRESULT CPCHScriptWrapper_Launcher::Run()
{
    __HCP_FUNC_ENTRY( "CPCHScriptWrapper_Launcher::Run" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

    while(Thread_IsAborted() == false)
    {
		if(m_pCLSID)
		{
			(void)CreateEngine();

			m_pCLSID = NULL;
			Thread_SignalMain();
		}
		else
		{
			lock = NULL;
			MPC::WaitForSingleObject( Thread_GetSignalEvent(), INFINITE );
			lock = this;
		}
	}

    hr = S_OK;

    Thread_Abort(); // To tell the MPC:Thread object to close the worker thread...

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHScriptWrapper_Launcher::CreateEngine()
{
	__HCP_FUNC_ENTRY( "CPCHScriptWrapper_Launcher::CreateEngine" );

	HRESULT                               hr;
	CComPtr<CPCHScriptWrapper_ServerSide> obj;
	CComPtr<IUnknown>                     unk;


	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &obj ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, obj->FinalConstructInner( m_pCLSID, m_bstrURL ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, obj.QueryInterface( &unk ));

	m_engine = unk;

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	m_hr = hr;

	__HCP_FUNC_EXIT(hr);
}

HRESULT CPCHScriptWrapper_Launcher::CreateScriptWrapper( /*[in ]*/ REFCLSID   rclsid   ,
														 /*[in ]*/ BSTR       bstrCode ,
														 /*[in ]*/ BSTR       bstrURL  ,
														 /*[out]*/ IUnknown* *ppObj    )
{
	__HCP_FUNC_ENTRY( "CPCHScriptWrapper_Launcher::CreateScriptWrapper" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_POINTER_AND_SET(ppObj,NULL);
	__MPC_PARAMCHECK_END();


	if(Thread_IsRunning() == false &&
	   Thread_IsAborted() == false  )
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, Thread_Start( this, Run, NULL ));
	}


	if(Thread_IsRunning())
	{
		CComPtr<IUnknown> unk;

		m_pCLSID  = &rclsid;
		m_bstrURL =  bstrURL;

		Thread_Signal();

		lock = NULL;
		Thread_WaitNotificationFromWorker( INFINITE, /*fNoMessagePump*/true );
		lock = this;

		__MPC_EXIT_IF_METHOD_FAILS(hr, m_hr); // The real error code.

		unk = m_engine; m_engine.Release();

		*ppObj = unk.Detach();
	}

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\setupsupport\lib\stdafx.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    StdAfx.h

Abstract:
    Precompiled header.

Revision History:
    Davide Massarenti   (Dmassare)  04/07/2000
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__35881994_CD02_11D2_9370_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__35881994_CD02_11D2_9370_00C04F72DAF7__INCLUDED_

#include <module.h>

#include <stdio.h>
#include <stdlib.h>
#include <float.h>

#include <HCP_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_COM.h>
#include <MPC_streams.h>
#include <MPC_logging.h>

#include <FileList.h>
#include <wintrust.h>
#include <wincrypt.h>
#include <softpub.h>

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__35881994_CD02_11D2_9370_00C04F72DAF7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\service\trustedscripts\scriptwrapper_serverside.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    ScriptWrapper_ClientSide.cpp

Abstract:
    File for implementation of CPCHScriptWrapper_ServerSide class,
    a generic wrapper for remoting scripting engines.

Revision History:
    Davide Massarenti created  03/28/2000

********************************************************************/

#include "stdafx.h"

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

CPCHScriptWrapper_ServerSide::CPCHScriptWrapper_ServerSide()
{
    // CComPtr<IPCHActiveScriptSite> m_Browser;
    // CComPtr<IActiveScript>        m_Script;
    // CComPtr<IActiveScriptParse>   m_ScriptParse;
}

CPCHScriptWrapper_ServerSide::~CPCHScriptWrapper_ServerSide()
{
}

HRESULT CPCHScriptWrapper_ServerSide::FinalConstructInner( /*[in]*/ const CLSID* pWrappedCLSID, /*[in]*/ BSTR bstrURL )
{
    __HCP_FUNC_ENTRY( "CPCHScriptWrapper_ServerSide::FinalConstructInner" );

    HRESULT           hr;
    CComPtr<IUnknown> unk;


	m_bstrURL = bstrURL;


    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateInstance( *pWrappedCLSID, NULL, CLSCTX_ALL, IID_IUnknown, (void**)&unk ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, unk->QueryInterface( IID_IActiveScript     , (void**)&m_Script      ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, unk->QueryInterface( IID_IActiveScriptParse, (void**)&m_ScriptParse ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void CPCHScriptWrapper_ServerSide::FinalRelease()
{
    m_Browser    .Release();
    m_Script     .Release();
    m_ScriptParse.Release();
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHScriptWrapper_ServerSide::Remote_SetScriptSite( /*[in]*/ IPCHActiveScriptSite* pass )
{
    m_Browser = pass;

    return S_OK;
}

STDMETHODIMP CPCHScriptWrapper_ServerSide::Remote_SetScriptState( /*[in] */ SCRIPTSTATE ss )
{
    if(m_Script == NULL) return E_FAIL;

    return m_Script->SetScriptState( ss );
}

STDMETHODIMP CPCHScriptWrapper_ServerSide::Remote_GetScriptState( /*[out]*/ SCRIPTSTATE *pssState )
{
    if(m_Script == NULL) return E_FAIL;

    return m_Script->GetScriptState( pssState );
}

STDMETHODIMP CPCHScriptWrapper_ServerSide::Remote_Close()
{
    if(m_Script == NULL) return E_FAIL;

    return m_Script->Close();
}


STDMETHODIMP CPCHScriptWrapper_ServerSide::Remote_AddNamedItem( /*[in]*/ BSTR  bstrName ,
                                                                /*[in]*/ DWORD dwFlags  )
{
    if(m_Script == NULL) return E_FAIL;

    return m_Script->AddNamedItem( bstrName, dwFlags );
}

STDMETHODIMP CPCHScriptWrapper_ServerSide::Remote_AddTypeLib( /*[in]*/ BSTR  bstrTypeLib ,
                                                              /*[in]*/ DWORD dwMajor     ,
                                                              /*[in]*/ DWORD dwMinor     ,
                                                              /*[in]*/ DWORD dwFlags     )
{
    GUID guidTypeLib;

    if(m_Script == NULL) return E_FAIL;

    ::CLSIDFromString( bstrTypeLib, &guidTypeLib );

    return m_Script->AddTypeLib( guidTypeLib, dwMajor, dwMinor, dwFlags );
}

STDMETHODIMP CPCHScriptWrapper_ServerSide::Remote_GetScriptDispatch( /*[in ]*/ BSTR        pstrItemName ,
                                                                     /*[out]*/ IDispatch* *ppdisp       )
{
    if(m_Script == NULL) return E_FAIL;

    return m_Script->GetScriptDispatch( pstrItemName, ppdisp );
}

STDMETHODIMP CPCHScriptWrapper_ServerSide::Remote_GetCurrentScriptThreadID( /*[out]*/ SCRIPTTHREADID *pstidThread )
{
    if(m_Script == NULL) return E_FAIL;

    return m_Script->GetCurrentScriptThreadID( pstidThread );
}

STDMETHODIMP CPCHScriptWrapper_ServerSide::Remote_GetScriptThreadID( /*[in ]*/ DWORD           dwWin32ThreadId ,
                                                                     /*[out]*/ SCRIPTTHREADID *pstidThread     )
{
    if(m_Script == NULL) return E_FAIL;

    return m_Script->GetScriptThreadID( dwWin32ThreadId, pstidThread );
}

STDMETHODIMP CPCHScriptWrapper_ServerSide::Remote_GetScriptThreadState( /*[in ]*/ SCRIPTTHREADID     stidThread ,
                                                                        /*[out]*/ SCRIPTTHREADSTATE *pstsState  )
{
    if(m_Script == NULL) return E_FAIL;

    return m_Script->GetScriptThreadState( stidThread, pstsState );
}

STDMETHODIMP CPCHScriptWrapper_ServerSide::Remote_InterruptScriptThread( /*[in]*/ SCRIPTTHREADID stidThread ,
                                                                         /*[in]*/ DWORD          dwFlags    )
{
    if(m_Script == NULL) return E_FAIL;

    return m_Script->InterruptScriptThread( stidThread, NULL, dwFlags );
}

STDMETHODIMP CPCHScriptWrapper_ServerSide::Remote_InitNew()
{
    HRESULT hr;

    if(m_Script      == NULL) return E_FAIL;
    if(m_ScriptParse == NULL) return E_FAIL;

    if(FAILED(hr = m_ScriptParse->InitNew())) return hr;

    return m_Script->SetScriptSite( this );
}

STDMETHODIMP CPCHScriptWrapper_ServerSide::Remote_AddScriptlet( /*[in ]*/ BSTR       bstrDefaultName       ,
                                                                /*[in ]*/ BSTR       bstrCode              ,
                                                                /*[in ]*/ BSTR       bstrItemName          ,
                                                                /*[in ]*/ BSTR       bstrSubItemName       ,
                                                                /*[in ]*/ BSTR       bstrEventName         ,
                                                                /*[in ]*/ BSTR       bstrDelimiter         ,
                                                                /*[in ]*/ DWORD_PTR  dwSourceContextCookie ,
                                                                /*[in ]*/ ULONG      ulStartingLineNumber  ,
                                                                /*[in ]*/ DWORD      dwFlags               ,
                                                                /*[out]*/ BSTR      *pbstrName             )
{
    if(m_ScriptParse == NULL) return E_FAIL;

    return m_ScriptParse->AddScriptlet( bstrDefaultName       ,
                                        bstrCode              ,
                                        bstrItemName          ,
                                        bstrSubItemName       ,
                                        bstrEventName         ,
                                        bstrDelimiter         ,
                                        dwSourceContextCookie ,
                                        ulStartingLineNumber  ,
                                        dwFlags               ,
                                        pbstrName             ,
                                        NULL                  );
}

STDMETHODIMP CPCHScriptWrapper_ServerSide::Remote_ParseScriptText( /*[in ]*/ BSTR       bstrCode              ,
                                                                   /*[in ]*/ BSTR       bstrItemName          ,
                                                                   /*[in ]*/ IUnknown*  punkContext           ,
                                                                   /*[in ]*/ BSTR       bstrDelimiter         ,
                                                                   /*[in ]*/ DWORD_PTR  dwSourceContextCookie ,
                                                                   /*[in ]*/ ULONG      ulStartingLineNumber  ,
                                                                   /*[in ]*/ DWORD      dwFlags               ,
                                                                   /*[out]*/ VARIANT*   pvarResult            )
{
    __HCP_FUNC_ENTRY( "CPCHScriptWrapper_ServerSide::Remote_ParseScriptText" );

	HRESULT                                  hr;
	CComBSTR                                 bstrRealCode;
	CPCHScriptWrapper_ServerSide::HeaderList lst;


    if(m_ScriptParse == NULL) __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);

	__MPC_EXIT_IF_METHOD_FAILS(hr, CPCHScriptWrapper_ServerSide::ProcessBody( bstrCode, bstrRealCode, lst ));

	hr = m_ScriptParse->ParseScriptText( bstrRealCode          ,
										 bstrItemName          ,
										 punkContext           ,
										 bstrDelimiter         ,
										 dwSourceContextCookie ,
										 ulStartingLineNumber  ,
										 dwFlags               ,
										 pvarResult            ,
										 NULL                  );


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHScriptWrapper_ServerSide::GetLCID( /*[out]*/ LCID *plcid )
{
	HRESULT  	hr;
	CComBSTR 	bstr;
	CComVariant v;

    if(m_Browser == NULL) return E_FAIL;

	if(FAILED(hr = m_Browser->Remote_GetLCID( &bstr ))) return hr;

	v = bstr; v.ChangeType( VT_I4 );

	if(plcid) *plcid = v.lVal;

	return S_OK;
}

STDMETHODIMP CPCHScriptWrapper_ServerSide::GetItemInfo( /*[in ]*/ LPCOLESTR   pstrName     ,
														/*[in ]*/ DWORD       dwReturnMask ,
														/*[out]*/ IUnknown*  *ppiunkItem   ,
														/*[out]*/ ITypeInfo* *ppti         )
{
	HRESULT            hr;
	CComBSTR           bstrName( pstrName );
	CComPtr<IUnknown>  unk;
	CComPtr<ITypeInfo> pti;

    if(m_Browser == NULL) return E_FAIL;

    if(FAILED(hr = m_Browser->Remote_GetItemInfo( bstrName, dwReturnMask, &unk, &pti ))) return hr;

	if(ppiunkItem) *ppiunkItem = unk.Detach();
	if(ppti      ) *ppti       = pti.Detach();

	return S_OK;
}

STDMETHODIMP CPCHScriptWrapper_ServerSide::GetDocVersionString( /*[out]*/ BSTR *pbstrVersion )
{
    if(m_Browser == NULL) return E_FAIL;

    return m_Browser->Remote_GetDocVersionString( pbstrVersion );
}

STDMETHODIMP CPCHScriptWrapper_ServerSide::OnScriptTerminate( /*[in]*/ const VARIANT*   pvarResult ,
                                                              /*[in]*/ const EXCEPINFO* pexcepinfo )
{
    if(m_Browser == NULL) return E_FAIL;

    return m_Browser->Remote_OnScriptTerminate( (VARIANT*)pvarResult );
}

STDMETHODIMP CPCHScriptWrapper_ServerSide::OnStateChange( /*[in]*/ SCRIPTSTATE ssScriptState )
{
    if(m_Browser == NULL) return E_FAIL;

    return m_Browser->Remote_OnStateChange( ssScriptState );
}

STDMETHODIMP CPCHScriptWrapper_ServerSide::OnScriptError( /*[in]*/ IActiveScriptError *pscripterror )
{
    if(m_Browser == NULL) return E_FAIL;

    return m_Browser->Remote_OnScriptError( pscripterror );
}

STDMETHODIMP CPCHScriptWrapper_ServerSide::OnEnterScript( void )
{
    if(m_Browser == NULL) return E_FAIL;

    return m_Browser->Remote_OnEnterScript();
}

STDMETHODIMP CPCHScriptWrapper_ServerSide::OnLeaveScript( void )
{
    if(m_Browser == NULL) return E_FAIL;

    return m_Browser->Remote_OnLeaveScript();
}

////////////////////////////////////////////////////////////////////////////////

bool CPCHScriptWrapper_ServerSide::KeyValue::operator==( /*[in]*/ LPCOLESTR szKey ) const
{
    return MPC::StrICmp( m_strKey, szKey ) == 0;
}

HRESULT CPCHScriptWrapper_ServerSide::ProcessBody( /*[in ]*/ BSTR        bstrCode     ,
												   /*[out]*/ CComBSTR&   bstrRealCode ,
												   /*[out]*/ HeaderList& lst          )
{
	__HCP_FUNC_ENTRY( "CPCHScriptWrapper_ServerSide::ProcessBody" );

	HRESULT hr;
	LPCWSTR szLineStart = SAFEBSTR( bstrCode );
	LPCWSTR szLineEnd;
	LPCWSTR szLineNext;
	bool    fSkipEmpty = true;


	lst.clear();


	while(szLineStart[0])
	{
		HeaderIter it;
		LPCWSTR    szColon;
		LPCWSTR    szEndLF;
		LPCWSTR    szEndCR;

		szColon = wcschr( szLineStart, ':'  );
		szEndLF = wcschr( szLineStart, '\n' );
		szEndCR = wcschr( szLineStart, '\r' );

		if(szEndLF == NULL)
		{
			if(szEndCR == NULL) break; // No end of line, exit.

			szLineEnd  = szEndCR;
			szLineNext = szEndCR+1;
		}
		else if(szEndCR == NULL)
		{
			szLineEnd  = szEndLF;
			szLineNext = szEndLF+1;
		}
		else if(szEndCR+1 == szEndLF) // \r\n
		{
			szLineEnd  = szEndCR;
			szLineNext = szEndLF+1;
		}
		else if(szEndLF < szEndCR)
		{
			szLineEnd  = szEndLF;
			szLineNext = szEndLF+1;
		}
		else
		{
			szLineEnd  = szEndCR;
			szLineNext = szEndCR+1;
		}

		if(szEndLF == szLineStart || szEndCR == szLineStart) // Empty line, skip it and exit.
		{
			if(fSkipEmpty)
			{
				szLineStart = szLineNext;
				continue;
			}

			szLineStart = szLineNext;
			break;
		}


		if(szColon == NULL) break; // No colon, so it's not an header field, exit

        it = lst.insert( lst.end() );
		it->m_strKey   = MPC::wstring( szLineStart, szColon   );
		it->m_strValue = MPC::wstring( szColon+1  , szLineEnd );

		fSkipEmpty  = false;
		szLineStart = szLineNext;
	}

	bstrRealCode = szLineStart;
	hr           = S_OK;


	__HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\binarybehaviors\behav_body.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Behav_BODY.cpp

Abstract:
    This file contains the implementation of the CPCHBehavior_BODY class,
	that dictates how hyperlinks work in the help center.

Revision History:
    Davide Massarenti (dmassare)  06/06/2000
        created

******************************************************************************/

#include "stdafx.h"

#include <ShellApi.h>

static const CPCHBehavior::EventDescription s_events[] =
{
    { L"ondragstart", DISPID_HTMLELEMENTEVENTS_ONDRAGSTART },

    { NULL },
};

////////////////////////////////////////////////////////////////////////////////

CPCHBehavior_BODY::CPCHBehavior_BODY()
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_BODY::CPCHBehavior_BODY" );
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHBehavior_BODY::Init( /*[in]*/ IElementBehaviorSite* pBehaviorSite )
{
	__HCP_FUNC_ENTRY( "CPCHBehavior_BODY::Init" );

	HRESULT hr;

	__MPC_EXIT_IF_METHOD_FAILS(hr, CPCHBehavior::Init( pBehaviorSite ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, AttachToEvents( s_events, (CLASS_METHOD)onEvent ));

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHBehavior_BODY::onEvent( DISPID id, DISPPARAMS* pDispParams, VARIANT* pVarResult )
{
	__HCP_FUNC_ENTRY( "CPCHBehavior_BODY::onEvent" );

	HRESULT                hr;
    CComPtr<IHTMLEventObj> ev;

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetEventObject( ev ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, CancelEvent( ev ));

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\binarybehaviors\behav_bitmap.cpp ===
/******************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:
    Behav_BITMAP.cpp

Abstract:
    This file contains the implementation of the CPCHBehavior_BITMAP class,
    that renders bitmap images with 8-bit alpha channel.

Revision History:
    Davide Massarenti (dmassare)  25/03/2001
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

static HBITMAP CreateMirroredBitmap( /*[in]*/ HBITMAP hbmOrig, /*[in]*/ BITMAP& bm )
{
	HBITMAP hbmMirrored = NULL;

    HDC hdc = ::GetDC( NULL ); // Grab the screen DC
	if(hdc)
	{
		HDC hdcMem1 = ::CreateCompatibleDC( hdc );
		if(hdcMem1)
		{
			HDC hdcMem2 = ::CreateCompatibleDC( hdc );
			if(hdcMem2)
			{
				BITMAPINFO bi = { sizeof(BITMAPINFOHEADER), bm.bmWidth, bm.bmHeight, 1, 32 };
				void*      p;

				hbmMirrored = ::CreateDIBSection( hdc, &bi, DIB_RGB_COLORS, &p, NULL, 0 );
				if(hbmMirrored)
				{
					HBITMAP hOld_bm1 = (HBITMAP)SelectObject( hdcMem1, hbmOrig     );
					HBITMAP hOld_bm2 = (HBITMAP)SelectObject( hdcMem2, hbmMirrored );

					
					//
					// Flip the bitmap
					//
					::SetLayout( hdcMem2, LAYOUT_RTL                                            );
					::BitBlt   ( hdcMem2, 0, 0, bm.bmWidth, bm.bmHeight, hdcMem1, 0, 0, SRCCOPY );

					::SelectObject( hdcMem2, hOld_bm2 );
					::SelectObject( hdcMem1, hOld_bm1 );
				}
    
				::DeleteDC( hdcMem2 );
			}

			::DeleteDC( hdcMem1 );
		}

		::ReleaseDC( NULL, hdc );
	}

    return hbmMirrored;
}

////////////////////////////////////////////////////////////////////////////////

static const CPCHBehavior::EventDescription s_events[] =
{
    { L"onpropertychange", DISPID_HTMLELEMENTEVENTS_ONPROPERTYCHANGE },

    { L"onmousedown"     , DISPID_HTMLELEMENTEVENTS_ONMOUSEDOWN      },
    { L"onmouseup"       , DISPID_HTMLELEMENTEVENTS_ONMOUSEUP        },

    { L"onmouseout"      , DISPID_HTMLELEMENTEVENTS_ONMOUSEOUT       },
    { L"onmouseover"     , DISPID_HTMLELEMENTEVENTS_ONMOUSEOVER      },

    { NULL                                                           },
};


////////////////////////////////////////////////////////////////////////////////

CPCHBehavior_BITMAP::CPCHBehavior_BITMAP()
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_BITMAP::CPCHBehavior_BITMAP" );

                          // CComBSTR   m_bstrBaseURL;
                          // CComBSTR   m_bstrImage;
                          //
                          // CComBSTR   m_bstrImageNormal;
                          // CComBSTR   m_bstrImageMouseOver;
                          // CComBSTR   m_bstrImageMouseDown;
    m_fFlipH     = false; // bool       m_fFlipH;
    m_fAutoRTL   = true;  // bool       m_fAutoRTL;
                          //
    m_himl       = NULL;  // HIMAGELIST m_himl;
    m_hBMP       = NULL;  // HBITMAP    m_hBMP;
                          // BITMAP     m_bm;
    m_lWidth     = 0;     // LONG       m_lWidth;
    m_lHeight    = 0;     // LONG       m_lHeight;
                          //
    m_fMouseOver = false; // bool       m_fMouseOver;
    m_fMouseDown = false; // bool       m_fMouseDown;
}

CPCHBehavior_BITMAP::~CPCHBehavior_BITMAP()
{
    ReleaseImage( /*fOnlyIL*/false );
}

/////////////////////////////////////////////////////////////////////////////

#ifndef ILC_COLORMASK
#define ILC_COLORMASK   0x00FE
#define ILD_BLENDMASK   0x000E
#endif

void CPCHBehavior_BITMAP::ReleaseImage( /*[in]*/ bool fOnlyIL )
{
    if(m_himl)
    {
        (void)::ImageList_Destroy( m_himl ); m_himl = NULL;

        m_lWidth  = 0;
        m_lHeight = 0;
    }

    if(!fOnlyIL)
    {
        if(m_hBMP)
        {
            (void)::DeleteObject( m_hBMP ); m_hBMP = NULL;
        }
    }
}

HRESULT CPCHBehavior_BITMAP::GrabImage()
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_BITMAP::GrabImage" );

    HRESULT  hr;

    if(m_hBMP == NULL)
    {
        COLORREF crMask = RGB( 255, 0, 255 );

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::HTML::DownloadBitmap( m_bstrBaseURL, m_bstrImage, crMask, m_hBMP ));
        if(::GetObject( m_hBMP, sizeof(m_bm), &m_bm ) != sizeof(m_bm))
        {
            __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
        }

		if(m_fFlipH || (m_fAutoRTL && m_fRTL))
		{
			HBITMAP hbmMirrored;

			__MPC_EXIT_IF_ALLOC_FAILS(hr, hbmMirrored, CreateMirroredBitmap( m_hBMP, m_bm ));

            (void)::DeleteObject( m_hBMP ); m_hBMP = hbmMirrored;

			if(::GetObject( m_hBMP, sizeof(m_bm), &m_bm ) != sizeof(m_bm))
			{
				__MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
			}
		}
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHBehavior_BITMAP::ScaleImage( /*[in]*/ LPRECT prc )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_BITMAP::ScaleImage" );

    HRESULT hr;
    LONG    lWidth     = prc->right  - prc->left;
    LONG    lHeight    = prc->bottom - prc->top;
    HBITMAP hBMPScaled = NULL;


    __MPC_EXIT_IF_METHOD_FAILS(hr, GrabImage());


    if(m_lWidth  != lWidth  ||
       m_lHeight != lHeight ||
       m_himl    == NULL     )
    {
        COLORREF crMask = RGB( 255, 0, 255 );
        UINT     flags  = 0;


        ReleaseImage( /*fOnlyIL*/true );


        if(m_bm.bmWidth  != lWidth  ||
           m_bm.bmHeight != lHeight  )
        {
            hBMPScaled = (HBITMAP)::CopyImage( m_hBMP, IMAGE_BITMAP, lWidth, lHeight, LR_CREATEDIBSECTION );
            if(hBMPScaled == NULL) __MPC_SET_ERROR_AND_EXIT(hr, E_OUTOFMEMORY);
        }


        if(crMask != CLR_NONE) flags |= ILC_MASK;
        if(m_bm.bmBits)        flags |= (m_bm.bmBitsPixel & ILC_COLORMASK);

        m_himl = ::ImageList_Create( lWidth, lHeight, flags, 1, 1 );
        if(m_himl == NULL) __MPC_SET_ERROR_AND_EXIT(hr, E_OUTOFMEMORY);

        if(::ImageList_AddMasked( m_himl, hBMPScaled ? hBMPScaled : m_hBMP, crMask ) < 0)
        {
            ReleaseImage( /*fOnlyIL*/true );

            __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
        }

        m_lWidth  = lWidth;
        m_lHeight = lHeight;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(hBMPScaled) ::DeleteObject( hBMPScaled );

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHBehavior_BITMAP::RefreshImages()
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_BITMAP::RefreshImages" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::COMUtil::GetPropertyByName( m_elem, L"srcNormal"   , m_bstrImageNormal    ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::COMUtil::GetPropertyByName( m_elem, L"srcMouseOver", m_bstrImageMouseOver ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::COMUtil::GetPropertyByName( m_elem, L"srcMouseDown", m_bstrImageMouseDown ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::COMUtil::GetPropertyByName( m_elem, L"FlipH"       , m_fFlipH             ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::COMUtil::GetPropertyByName( m_elem, L"AutoRTL"	   , m_fAutoRTL           ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


HRESULT CPCHBehavior_BITMAP::onMouse( DISPID id, DISPPARAMS*, VARIANT* )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_BITMAP::onMouse" );

    HRESULT hr;
    BSTR    bstrCurrentImage = NULL;


    switch(id)
    {
    case DISPID_HTMLELEMENTEVENTS_ONPROPERTYCHANGE: __MPC_EXIT_IF_METHOD_FAILS(hr, RefreshImages()); break;


    case DISPID_HTMLELEMENTEVENTS_ONMOUSEDOWN: m_fMouseDown = true ;                       break;
    case DISPID_HTMLELEMENTEVENTS_ONMOUSEUP  : m_fMouseDown = false;                       break;

    case DISPID_HTMLELEMENTEVENTS_ONMOUSEOVER: 						 m_fMouseOver = true ; break;
    case DISPID_HTMLELEMENTEVENTS_ONMOUSEOUT : m_fMouseDown = false; m_fMouseOver = false; break;
    }

    if     (m_fMouseDown && m_bstrImageMouseDown) bstrCurrentImage = m_bstrImageMouseDown;
    else if(m_fMouseOver && m_bstrImageMouseOver) bstrCurrentImage = m_bstrImageMouseOver;
    else                                          bstrCurrentImage = m_bstrImageNormal;

    if(bstrCurrentImage && MPC::StrCmp( bstrCurrentImage, m_bstrImage ))
    {
        CComQIPtr<IElementBehaviorSiteRender> render;

        ReleaseImage( /*fOnlyIL*/false );

        m_bstrImage = bstrCurrentImage;


        render = m_siteOM;
        if(render)
        {
            (void)render->InvalidateRenderInfo();
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHBehavior_BITMAP::Init( /*[in]*/ IElementBehaviorSite* pBehaviorSite )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_BITMAP::Init" );

    HRESULT                 hr;
    CComPtr<IHTMLDocument2> doc;
    CComPtr<IHTMLLocation>  loc;


    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHBehavior::Init( pBehaviorSite ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, AttachToEvents( s_events, (CLASS_METHOD)onMouse ));

	//
	// We need to set the font size to something really small or Trident will enlarge the element.
	//
	{
		CComPtr<IHTMLStyle> pStyle;

		if(SUCCEEDED(m_elem->get_style( &pStyle )) && pStyle)
		{
			CComVariant v( L"1px" );

			(void)pStyle->put_fontSize( v );
		}
	}

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::HTML::IDispatch_To_IHTMLDocument2( doc, m_elem ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, doc->get_location( &loc ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, loc->get_href( &m_bstrBaseURL ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, RefreshImages());
    m_bstrImage = m_bstrImageNormal;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHBehavior_BITMAP::Draw( /*[in]*/ RECT   rcBounds     ,
										/*[in]*/ RECT   rcUpdate     ,
										/*[in]*/ LONG   lDrawFlags   ,
										/*[in]*/ HDC    hdc          ,
										/*[in]*/ LPVOID pvDrawObject )
{
	if(SUCCEEDED(ScaleImage( &rcBounds )))
	{
		if(m_himl)
		{
			IMAGELISTDRAWPARAMS imldp; ::ZeroMemory( &imldp, sizeof(imldp) );

			imldp.cbSize  = sizeof(imldp);
			imldp.himl    = m_himl;
			imldp.i       = 0;
			imldp.hdcDst  = hdc;
			imldp.x       = rcBounds.left;
			imldp.y       = rcBounds.top;
			imldp.cx      = 0;
			imldp.cy      = 0;
			imldp.xBitmap = 0;
			imldp.yBitmap = 0;
			imldp.rgbBk   = CLR_NONE;
			imldp.rgbFg   = CLR_DEFAULT;
			imldp.fStyle  = ILD_TRANSPARENT;
			imldp.fState  = 0;
			imldp.Frame   = 0;

			::ImageList_DrawIndirect( &imldp );
		}
	}

    return S_OK;
}

STDMETHODIMP CPCHBehavior_BITMAP::GetPainterInfo( /*[in]*/ HTML_PAINTER_INFO *pInfo )
{
    if(pInfo)
    {
		pInfo->lFlags          = HTMLPAINTER_TRANSPARENT;
		pInfo->lZOrder         = HTMLPAINT_ZORDER_BELOW_CONTENT;
		pInfo->iidDrawObject   = IID_NULL;
		pInfo->rcExpand.left   = 0;
		pInfo->rcExpand.top    = 0;
		pInfo->rcExpand.right  = 0;
		pInfo->rcExpand.bottom = 0;
    }

    return S_OK;
}

STDMETHODIMP CPCHBehavior_BITMAP::HitTestPoint( /*[in]*/ POINT pt       ,
												/*[in]*/ BOOL* pbHit    ,
												/*[in]*/ LONG* plPartID )
{
    return E_NOTIMPL;
}

STDMETHODIMP CPCHBehavior_BITMAP::OnResize( /*[in]*/ SIZE pt )
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\binarybehaviors\behaviorstypelibdid.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    BehaviorsTypeLibDID.h

Abstract:
    This file contains the definition of some constants used by
    the Help Center Application.

Revision History:
    Davide Massarenti   (Dmassare)  08/16/2000
        created

******************************************************************************/

#if !defined(__INCLUDED___PCH___BEHAVIORSTYPELIBDID_H___)
#define __INCLUDED___PCH___BEHAVIORSTYPELIBDID_H___

/////////////////////////////////////////////////////////////////////////

#define DISPID_PCH_BEHAVIORS_BASE                             0x08010000

#define DISPID_PCH_BEHAVIORS_BASE_PRIV                        (DISPID_PCH_BEHAVIORS_BASE + 0x0000)
#define DISPID_PCH_BEHAVIORS_BASE_COMMON                      (DISPID_PCH_BEHAVIORS_BASE + 0x0100)

#define DISPID_PCH_BEHAVIORS_BASE_SUBSITE                     (DISPID_PCH_BEHAVIORS_BASE + 0x0200)

#define DISPID_PCH_BEHAVIORS_BASE_TREE                        (DISPID_PCH_BEHAVIORS_BASE + 0x0300)
#define DISPID_PCH_BEHAVIORS_BASE_TREENODE                    (DISPID_PCH_BEHAVIORS_BASE + 0x0400)

#define DISPID_PCH_BEHAVIORS_BASE_CONTEXT                     (DISPID_PCH_BEHAVIORS_BASE + 0x0500)

#define DISPID_PCH_BEHAVIORS_BASE_STATE                       (DISPID_PCH_BEHAVIORS_BASE + 0x0600)

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

#define DISPID_PCH_BEHAVIORS_PRIV__NEWDATAAVAILABLE           (DISPID_PCH_BEHAVIORS_BASE_PRIV     + 0x00)
  																									  
/////////////////////////////////////////////////////////////////////////  							  
  																									  
#define DISPID_PCH_BEHAVIORS_COMMON__DATA                     (DISPID_PCH_BEHAVIORS_BASE_COMMON	  + 0x00)
#define DISPID_PCH_BEHAVIORS_COMMON__ELEMENT                  (DISPID_PCH_BEHAVIORS_BASE_COMMON	  + 0x01)
  																									  
#define DISPID_PCH_BEHAVIORS_COMMON__LOAD                     (DISPID_PCH_BEHAVIORS_BASE_COMMON	  + 0x10)
#define DISPID_PCH_BEHAVIORS_COMMON__SAVE                     (DISPID_PCH_BEHAVIORS_BASE_COMMON	  + 0x11)
#define DISPID_PCH_BEHAVIORS_COMMON__LOCATE                   (DISPID_PCH_BEHAVIORS_BASE_COMMON	  + 0x12)
#define DISPID_PCH_BEHAVIORS_COMMON__UNSELECT                 (DISPID_PCH_BEHAVIORS_BASE_COMMON	  + 0x13)
																									  
/////////////////////////////////////////////////////////////////////////							  
																									  
#define DISPID_PCH_BEHAVIORS_SUBSITE__ROOT               	  (DISPID_PCH_BEHAVIORS_BASE_SUBSITE  + 0x00)
																									  
#define DISPID_PCH_BEHAVIORS_SUBSITE__SELECT               	  (DISPID_PCH_BEHAVIORS_BASE_SUBSITE  + 0x10)
																									  
/////////////////////////////////////////////////////////////////////////							  
																									  
#define DISPID_PCH_BEHAVIORS_TREE__POPULATE               	  (DISPID_PCH_BEHAVIORS_BASE_TREE     + 0x00)
																									  
#define DISPID_PCH_BEHAVIORS_TREENODE__TYPE                   (DISPID_PCH_BEHAVIORS_BASE_TREENODE + 0x00)
#define DISPID_PCH_BEHAVIORS_TREENODE__KEY                    (DISPID_PCH_BEHAVIORS_BASE_TREENODE + 0x01)
#define DISPID_PCH_BEHAVIORS_TREENODE__TITLE                  (DISPID_PCH_BEHAVIORS_BASE_TREENODE + 0x02)
#define DISPID_PCH_BEHAVIORS_TREENODE__DESCRIPTION            (DISPID_PCH_BEHAVIORS_BASE_TREENODE + 0x03)
#define DISPID_PCH_BEHAVIORS_TREENODE__ICON                   (DISPID_PCH_BEHAVIORS_BASE_TREENODE + 0x04)
#define DISPID_PCH_BEHAVIORS_TREENODE__URL                    (DISPID_PCH_BEHAVIORS_BASE_TREENODE + 0x05)
																									  
/////////////////////////////////////////////////////////////////////////							  
																									  
#define DISPID_PCH_BEHAVIORS_CONTEXT__MINIMIZED               (DISPID_PCH_BEHAVIORS_BASE_CONTEXT  + 0x00)
#define DISPID_PCH_BEHAVIORS_CONTEXT__MAXIMIZED               (DISPID_PCH_BEHAVIORS_BASE_CONTEXT  + 0x01)
									           				  										  
#define DISPID_PCH_BEHAVIORS_CONTEXT__X                       (DISPID_PCH_BEHAVIORS_BASE_CONTEXT  + 0x02)
#define DISPID_PCH_BEHAVIORS_CONTEXT__Y                       (DISPID_PCH_BEHAVIORS_BASE_CONTEXT  + 0x03)
#define DISPID_PCH_BEHAVIORS_CONTEXT__WIDTH                   (DISPID_PCH_BEHAVIORS_BASE_CONTEXT  + 0x04)
#define DISPID_PCH_BEHAVIORS_CONTEXT__HEIGHT                  (DISPID_PCH_BEHAVIORS_BASE_CONTEXT  + 0x05)
																									  
#define DISPID_PCH_BEHAVIORS_CONTEXT__CHANGECONTEXT           (DISPID_PCH_BEHAVIORS_BASE_CONTEXT  + 0x10)
#define DISPID_PCH_BEHAVIORS_CONTEXT__SETWINDOWDIMENSIONS     (DISPID_PCH_BEHAVIORS_BASE_CONTEXT  + 0x11)
#define DISPID_PCH_BEHAVIORS_CONTEXT__BRINGTOFOREGROUND       (DISPID_PCH_BEHAVIORS_BASE_CONTEXT  + 0x12)
																									  
/////////////////////////////////////////////////////////////////////////							  
																									  
#define DISPID_PCH_BEHAVIORS_STATE__PROPERTY                  (DISPID_PCH_BEHAVIORS_BASE_STATE    + 0x00)

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___PCH___BEHAVIORSTYPELIBDID_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\binarybehaviors\behav_a.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Behav_A.cpp

Abstract:
    This file contains the implementation of the CPCHBehavior_A class,
	that dictates how hyperlinks work in the help center.

Revision History:
    Davide Massarenti (dmassare)  06/06/2000
        created

******************************************************************************/

#include "stdafx.h"

#include <ShellApi.h>

////////////////////////////////////////////////////////////////////////////////

static const WCHAR s_APPprefix [] = L"APP:";
static const WCHAR s_HCPprefix [] = L"HCP:";
static const WCHAR s_HTTPprefix[] = L"HTTP:";

////////////////////////////////////////////////////////////////////////////////

HRESULT Local_ShellRun( LPCWSTR szCommandOrig ,
						LPCWSTR szArgs        )
{
	__HCP_FUNC_ENTRY( "Local_ShellRun" );

	HRESULT      	  hr;
	MPC::wstring 	  szCommand( szCommandOrig );
    SHELLEXECUTEINFOW oExecInfo;


	::ZeroMemory( &oExecInfo, sizeof(oExecInfo) ); oExecInfo.cbSize = sizeof(oExecInfo);


	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SubstituteEnvVariables( szCommand ));


    oExecInfo.fMask         = SEE_MASK_FLAG_NO_UI;
    oExecInfo.hwnd          = NULL;
    oExecInfo.lpVerb        = L"Open";
	oExecInfo.lpFile        = szCommand.c_str();
	oExecInfo.lpParameters  = (szArgs && szArgs[0]) ? szArgs : NULL;
	oExecInfo.lpDirectory   = NULL;
	oExecInfo.nShow         = SW_SHOWNORMAL;

	__MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::ShellExecuteExW( &oExecInfo ));

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	if(oExecInfo.hProcess) ::CloseHandle( oExecInfo.hProcess );

	__HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

CPCHBehavior_A::CPCHBehavior_A()
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_A::CPCHBehavior_A" );
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHBehavior_A::Init( /*[in]*/ IElementBehaviorSite* pBehaviorSite )
{
	__HCP_FUNC_ENTRY( "CPCHBehavior_A::Init" );

	HRESULT hr;

	__MPC_EXIT_IF_METHOD_FAILS(hr, CPCHBehavior::Init( pBehaviorSite ));


	__MPC_EXIT_IF_METHOD_FAILS(hr, AttachToEvent( L"onclick", (CLASS_METHOD)onClick ));

	////////////////////

	{
		CComQIPtr<IHTMLAnchorElement> elemHyperLink;

		if((elemHyperLink = m_elem))
		{
			CComBSTR bstrHref;

			MPC_SCRIPTHELPER_GET__DIRECT(bstrHref, elemHyperLink, href);

			if(STRINGISPRESENT(bstrHref)) (void)HyperLinks::Lookup::s_GLOBAL->Queue( bstrHref );
		}
	}

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHBehavior_A::onClick( DISPID, DISPPARAMS*, VARIANT* )
{
	__HCP_FUNC_ENTRY( "CPCHBehavior_A::onClick" );

	HRESULT hr;


	if(!m_parent) __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);

	//
	// If we are navigating, abort the click.
	//
	{
		VARIANT_BOOL     fCancel;
		CPCHHelpSession* hs = m_parent->HelpSession();

		if(hs)
		{
			__MPC_EXIT_IF_METHOD_FAILS(hr, hs->IsNavigating( &fCancel ));
			if(fCancel)
			{
				__MPC_EXIT_IF_METHOD_FAILS(hr, CancelEvent());

				__MPC_SET_ERROR_AND_EXIT(hr, S_OK);
			}
			
			hs->CancelThreshold();
		}
	}


	//
	// If the URL is an APP: one, process the redirect.
	//
	if(m_fTrusted)
	{
		CComPtr<IHTMLElement>  		  elemSrc;
		CComPtr<IHTMLElement>  		  elemParent;
		CComQIPtr<IHTMLAnchorElement> elemHyperLink;

		__MPC_EXIT_IF_METHOD_FAILS(hr, GetEvent_SrcElement( elemSrc ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::HTML::FindFirstParentWithThisTag( elemParent, elemSrc, L"A" ));
		if((elemHyperLink = elemParent))
		{
			CComBSTR bstrHref;
			CComBSTR bstrTarget;

			MPC_SCRIPTHELPER_GET__DIRECT(bstrHref  , elemHyperLink, href  );
			MPC_SCRIPTHELPER_GET__DIRECT(bstrTarget, elemHyperLink, target);

			if(bstrHref && !_wcsnicmp( bstrHref, s_APPprefix, MAXSTRLEN( s_APPprefix ) ))
			{
				LPCWSTR szRealHRef = bstrHref + MAXSTRLEN( s_APPprefix );

				//
				// The URL starts with "app:", so let's cancel the event.
				//
				__MPC_EXIT_IF_METHOD_FAILS(hr, CancelEvent());

				//
				// Is it for hcp:// ?
				//
				if(!_wcsnicmp( szRealHRef, s_HCPprefix, MAXSTRLEN( s_HCPprefix ) ))
				{
					//
					// Then navigate from the top level window.
					//
					CComPtr<IHTMLWindow2> win;

					__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::HTML::LocateFrame( win, elemSrc, L"_top" ));

					__MPC_EXIT_IF_METHOD_FAILS(hr, win->navigate( CComBSTR( szRealHRef ) ));
				}
				else
				//
				// Launch an external program. 
				//
				{
					MPC::wstring 	   szFile;
					MPC::wstring 	   szArgs;
					MPC::WStringLookup mapQuery;


					//
					// Parse the query string.
					//
					MPC::HTML::ParseHREF( szRealHRef, szFile, mapQuery );


					//
					// Is it for http:// ? Then assume the url is properly escape and pass it directly to the shell.
					//
					if(!_wcsnicmp( szFile.c_str(), s_HTTPprefix, MAXSTRLEN( s_HTTPprefix ) ))
					{
						szFile = szRealHRef;
					}
					else
					{
						szArgs = mapQuery[ L"arg" ];
					}

					(void)Local_ShellRun( szFile.c_str(), szArgs.c_str() );

					//
					// If we have a "topic" argument from the query string, navigate the original target to it.
					//
					szFile = mapQuery[ L"topic" ];
					if(szFile.size())
					{
						//
						// Then navigate from the top level window.
						//
						CComPtr<IHTMLWindow2> win;

						__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::HTML::LocateFrame( win, elemSrc, bstrTarget ));

						__MPC_EXIT_IF_METHOD_FAILS(hr, win->navigate( CComBSTR( szFile.c_str() ) ));
					}
				}
			}
		}
	}

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\binarybehaviors\behav_context.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Behav_CONTEXT.cpp

Abstract:
    This file contains the implementation of the CPCHBehavior_CONTEXT class,
	that dictates how hyperlinks work in the help center.

Revision History:
    Davide Massarenti (dmassare)  06/06/2000
        created

******************************************************************************/

#include "stdafx.h"

#include <ShellApi.h>

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHBehavior_CONTEXT::Init( /*[in]*/ IElementBehaviorSite* pBehaviorSite )
{
	__HCP_FUNC_ENTRY( "CPCHBehavior_CONTEXT::Init" );

	HRESULT  	hr;
	CComBSTR 	bstrCtxName;
	CComVariant vCtxInfo;
	CComVariant vCtxURL;

	__MPC_EXIT_IF_METHOD_FAILS(hr, CPCHBehavior::Init( pBehaviorSite ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::COMUtil::GetPropertyByName( m_elem, L"contextName", bstrCtxName ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::COMUtil::GetPropertyByName( m_elem, L"contextInfo",    vCtxInfo ));

	if(bstrCtxName.Length())
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, changeContext( bstrCtxName, vCtxInfo, vCtxURL ));
	}

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHBehavior_CONTEXT::get_minimized( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
	IMarsWindowOM* win = m_parent->Shell();

	return win ? win->get_minimized( pVal ) : E_FAIL;
}

STDMETHODIMP CPCHBehavior_CONTEXT::put_minimized( /*[in]*/ VARIANT_BOOL newVal )
{
	IMarsWindowOM* win = m_parent->Shell();

	return win ? win->put_minimized( newVal ) : E_FAIL;
}

STDMETHODIMP CPCHBehavior_CONTEXT::get_maximized( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
	IMarsWindowOM* win = m_parent->Shell();

	return win ? win->get_maximized( pVal ) : E_FAIL;
}

STDMETHODIMP CPCHBehavior_CONTEXT::put_maximized( /*[in]*/ VARIANT_BOOL newVal )
{
	IMarsWindowOM* win = m_parent->Shell();

	return win ? win->put_maximized( newVal ) : E_FAIL;
}

////////////////////

STDMETHODIMP CPCHBehavior_CONTEXT::get_x( /*[out, retval]*/ long *pVal )
{
	IMarsWindowOM* win = m_parent->Shell();

	return win ? win->get_x( pVal ) : E_FAIL;
}

STDMETHODIMP CPCHBehavior_CONTEXT::get_y( /*[out, retval]*/ long *pVal )
{
	IMarsWindowOM* win = m_parent->Shell();

	return win ? win->get_y( pVal ) : E_FAIL;
}

STDMETHODIMP CPCHBehavior_CONTEXT::get_width( /*[out, retval]*/ long *pVal )
{
	IMarsWindowOM* win = m_parent->Shell();

	return win ? win->get_width( pVal ) : E_FAIL;
}

STDMETHODIMP CPCHBehavior_CONTEXT::get_height( /*[out, retval]*/ long *pVal )
{
	IMarsWindowOM* win = m_parent->Shell();

	return win ? win->get_height( pVal ) : E_FAIL;
}

////////////////////

STDMETHODIMP CPCHBehavior_CONTEXT::changeContext( /*[in]*/ BSTR bstrName, /*[in]*/ VARIANT vInfo, /*[in]*/ VARIANT vURL )
{
	CPCHHelpSession* hs = m_parent->HelpSession();

	return hs ? hs->ChangeContext( bstrName, vInfo, vURL ) : E_FAIL;
}

STDMETHODIMP CPCHBehavior_CONTEXT::setWindowDimensions( /*[in]*/ long lX, /*[in]*/ long lY, /*[in]*/ long lW, /*[in]*/ long lH )
{
	IMarsWindowOM* win  = m_parent->Shell();
	VARIANT_BOOL   fMax = VARIANT_FALSE;

	if(win == NULL) return E_FAIL;

	win->get_maximized( &fMax );

	if(fMax != VARIANT_FALSE)
	{
		win->put_maximized( VARIANT_FALSE );
	}

	return win->setWindowDimensions( lX, lY, lW, lH );
}

STDMETHODIMP CPCHBehavior_CONTEXT::bringToForeground()
{
	::SetForegroundWindow( m_parent->Window() );

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\binarybehaviors\behav_basictree.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Behav_BasicTree.cpp

Abstract:
    This file contains the implementation of the CPCHBehavior_BasicTree class.

Revision History:
    Davide Massarenti (dmassare)  08/15/2000
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

static const LPCWSTR s_icons_Expand[] =
{
    L"hcp://system/images/Expando/collapsed.gif",
////L"hcp://system/images/Expando/expand_rest.gif"      ,
////L"hcp://system/images/Expando/expand_mouseover.gif" ,
////L"hcp://system/images/Expando/expand_mousedown.gif" ,
};

static const LPCWSTR s_icons_Collapse[] =
{
    L"hcp://system/images/Expando/expanded.gif",
////L"hcp://system/images/Expando/collapse_rest.gif"      ,
////L"hcp://system/images/Expando/collapse_mouseover.gif" ,
////L"hcp://system/images/Expando/collapse_mousedown.gif" ,
};

static const LPCWSTR s_icons_Empty[] =
{
    L"hcp://system/images/Expando/endnode.gif",
////L"hcp://system/images/Expando/empty_rest.gif"      ,
////L"hcp://system/images/Expando/empty_mouseover.gif" ,
////L"hcp://system/images/Expando/empty_mousedown.gif" ,
};

static const WCHAR s_icons_Bullet[] = L"hcp://system/images/Expando/helpdoc.gif";

static const WCHAR s_prefix_APP[] = L"app:";

static CComBSTR s_event_onContextSelect( L"onContextSelect" );
static CComBSTR s_event_onSelect       ( L"onSelect"        );
static CComBSTR s_event_onUnselect     ( L"onUnselect"      );

static CComBSTR s_style_None           ( L"None" );

static const DWORD l_dwVersion = 0x04005442; // BT 04

////////////////////////////////////////////////////////////////////////////////

static const CPCHBehavior::EventDescription s_events[] =
{
    { L"onselectstart", DISPID_HTMLELEMENTEVENTS_ONSELECTSTART },

    { L"onclick"      , DISPID_HTMLELEMENTEVENTS_ONCLICK       },
    { L"onkeydown"    , DISPID_HTMLELEMENTEVENTS_ONKEYDOWN     },
    { L"onkeypress"   , DISPID_HTMLELEMENTEVENTS_ONKEYPRESS    },
    { L"onmousedown"  , DISPID_HTMLELEMENTEVENTS_ONMOUSEDOWN   },
    { L"onmouseup"    , DISPID_HTMLELEMENTEVENTS_ONMOUSEUP     },
    { L"oncontextmenu", DISPID_HTMLELEMENTEVENTS_ONCONTEXTMENU },

    { L"onmouseout"   , DISPID_HTMLELEMENTEVENTS_ONMOUSEOUT    },
    { L"onmouseover"  , DISPID_HTMLELEMENTEVENTS_ONMOUSEOVER   },

    { NULL },
};

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

CPCHBehavior_BasicTree::Node::Node()
{
    m_owner                = NULL;            // CPCHBehavior_BasicTree*  m_owner;
    m_parent               = NULL;            // Node*                    m_parent;
                                              // CComBSTR                 m_bstrNode;
                                              // NodeType                 m_iType;
    m_iSelection           = SELECTION__NONE; // SelectionMode            m_iSelection;
                                              //
    m_fLoaded_Self         = false;           // bool                     m_fLoaded_Self;
    m_fLoaded_Children     = false;           // bool                     m_fLoaded_Children;
    m_fDisplayed_Self      = false;           // bool                     m_fDisplayed_Self;
    m_fDisplayed_Children  = false;           // bool                     m_fDisplayed_Children;
    m_fInvalid             = false;           // bool                     m_fInvalid;
    m_fRefreshNotification = false;           // bool                     m_fRefreshNotification;
                                              //
    m_fExpanded            = false;           // bool                     m_fExpanded;
    m_fMouseOver           = false;           // bool                     m_fMouseOver;
    m_fMouseDown           = false;           // bool                     m_fMouseDown;
                                              //
                                              // CComPtr<IHTMLElement>    m_parentElement;
                                              // CComBSTR                 m_bstrID;
                                              //
                                              // CComPtr<IHTMLElement>    m_DIV;
                                              // CComPtr<IHTMLElement>    m_IMG;
                                              // CComPtr<IHTMLElement>    m_DIV_children;
                                              //
                                              // List                     m_lstSubnodes;
};

CPCHBehavior_BasicTree::Node::~Node()
{
    MPC::ReleaseAll( m_lstSubnodes );
}

HRESULT CPCHBehavior_BasicTree::Node::Init( /*[in]*/ LPCWSTR  szNode ,
                                            /*[in]*/ NodeType iType  )
{
    m_bstrNode = szNode;
    m_iType    = iType;

    switch(m_iType)
    {
    case NODETYPE__FRAME1       :
    case NODETYPE__FRAME2       :
    case NODETYPE__FRAME3       :
    case NODETYPE__FRAME1_EXPAND:
    case NODETYPE__FRAME2_EXPAND:
    case NODETYPE__FRAME3_EXPAND:
    case NODETYPE__GROUP        : m_fExpanded = true; break;

    case NODETYPE__LINK         :
    case NODETYPE__SPACER       : m_fExpanded = false; break;
    }

    return S_OK;
}

HRESULT CPCHBehavior_BasicTree::Node::NotifyMainThread()
{
    if(m_fRefreshNotification) return S_OK; // Already done...

    m_fRefreshNotification = true;

    return m_owner->NotifyMainThread( this );
}

CPCHBehavior_BasicTree::Node* CPCHBehavior_BasicTree::Node::FindNode( /*[in]*/ LPCWSTR szNode, /*[in]*/ bool fUseID )
{
    Node* node = NULL;

    if((!fUseID && MPC::StrICmp( szNode, m_bstrNode ) == 0) ||
       ( fUseID && MPC::StrCmp ( szNode, m_bstrID   ) == 0)  )
    {
        node = this;
    }
    else
    {
        Iter it;

        for(it = m_lstSubnodes.begin(); it != m_lstSubnodes.end(); it++)
        {
            if((node = (*it)->FindNode( szNode, fUseID ))) break;
        }
    }

    return node;
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHBehavior_BasicTree::Node::QueryInterface( /*[in]*/ REFIID riid, /*[iid_is][out]*/ void** ppvObject )
{
    return E_NOTIMPL;
}

HRESULT CPCHBehavior_BasicTree::Node::Passivate()
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_BasicTree::Node::Passivate" );

    HRESULT hr;

                               // CPCHBehavior_BasicTree*  m_owner;
                               // Node*                    m_parent;
                               // CComBSTR                 m_bstrNode;
                               // NodeType                 m_iType;
                               // SelectionMode            m_iSelection;
                               //
                               // bool                     m_fLoaded_Self;
                               // bool                     m_fLoaded_Children;
                               // bool                     m_fDisplayed_Self;
                               // bool                     m_fDisplayed_Children;
                               // bool                     m_fInvalid;
                               // bool                     m_fRefreshNotification;
                               //
                               // bool                     m_fExpanded;
                               // bool                     m_fMouseOver;
                               // bool                     m_fMouseDown;
                               //
    m_parentElement.Release(); // CComPtr<IHTMLElement>    m_parentElement;
                               // CComBSTR                 m_bstrID;
                               //
    m_DIV          .Release(); // CComPtr<IHTMLElement>    m_DIV;
    m_IMG          .Release(); // CComPtr<IHTMLElement>    m_IMG;
    m_DIV_children .Release(); // CComPtr<IHTMLElement>    m_DIV_children;
                               //
                               // List                     m_lstSubnodes;


    for(Iter it = m_lstSubnodes.begin(); it != m_lstSubnodes.end(); it++)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, (*it)->Passivate());
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHBehavior_BasicTree::Node::ProcessRefreshRequest()
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_BasicTree::Node::ProcessRefreshRequest" );

    HRESULT hr;
    bool    fNotify = true;


    if(!m_fLoaded_Self)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, PopulateSelf());

        fNotify = true;
    }

    if(!m_fLoaded_Children)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, PopulateChildren());

        fNotify = true;
    }

    if(m_fDisplayed_Self == false)
    {
        fNotify = true;
    }

    if(IsParentDisplayingUs())
    {
        Iter it;

        for(it = m_lstSubnodes.begin(); it != m_lstSubnodes.end(); it++)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, (*it)->ProcessRefreshRequest());
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(fNotify) NotifyMainThread();

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHBehavior_BasicTree::Node::LoadHTML( /*[in]*/ LPCWSTR szHTML )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_BasicTree::Node::LoadHTML" );

    HRESULT hr;


    if(!m_parentElement)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_NOT_READY);
    }

    ////////////////////

    //  ::MessageBoxW( NULL, szHTML, L"HTML", MB_OK );

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_parentElement->put_innerHTML( CComBSTR( szHTML ) ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::HTML::FindElement( m_DIV         , m_parentElement, L"tree_Title"    ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::HTML::FindElement( m_IMG         , m_parentElement, L"tree_Img"      ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::HTML::FindElement( m_DIV_children, m_parentElement, L"tree_Children" ));

    if(m_DIV)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::HTML::GetUniqueID( m_bstrID, m_DIV ));
    }


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHBehavior_BasicTree::Node::GenerateHTML( /*[in]*/ LPCWSTR szTitle, /*[in]*/ LPCWSTR szDescription, /*[in]*/ LPCWSTR szIcon, /*[in]*/ LPCWSTR szURL )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_BasicTree::Node::GenerateHTML" );

    const int F_TABLE      = 0x00000001;
    const int F_TOPPANE    = 0x00000002;
    const int F_BOTTOMPANE = 0x00000004;
    const int F_NOPANE     = 0x00000008;
    const int F_EXPANDO    = 0x00000010;
    const int F_GROUP      = 0x00000020;

    HRESULT      hr;
    MPC::wstring strHTML; INCREASESIZE(strHTML);
    bool         fValid_Title  = (STRINGISPRESENT(szTitle));
    bool         fValid_Icon   = (STRINGISPRESENT(szIcon ) && wcschr( szIcon, '"' ) == NULL); // Quote is not allowed in a URL!!
    bool         fValid_URL    = (STRINGISPRESENT(szURL  ) && wcschr( szURL , '"' ) == NULL);
    bool         fTitleDefined = false;
    int          iFlags        = 0;

    if(!m_fLoaded_Self)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_NOT_READY);
    }

    ////////////////////

    if(m_owner->GetNavModel() == QR_SERVER)
    {
        if(!STRINGISPRESENT(szDescription)) szDescription = szTitle;
    }

    switch(m_iType)
    {
    case NODETYPE__FRAME1       : iFlags =           F_TOPPANE                     ; fValid_Icon = false;                     break;
    case NODETYPE__FRAME2       : iFlags =           F_BOTTOMPANE                  ; fValid_Icon = false;                     break;
    case NODETYPE__FRAME3       : iFlags =           F_NOPANE                      ; fValid_Icon = false;                     break;
    case NODETYPE__FRAME1_EXPAND: iFlags = F_TABLE | F_TOPPANE                     ; fValid_Icon = false;                     break;
    case NODETYPE__FRAME2_EXPAND: iFlags = F_TABLE | F_BOTTOMPANE                  ; fValid_Icon = false;                     break;
    case NODETYPE__FRAME3_EXPAND: iFlags = F_TABLE | F_NOPANE                      ; fValid_Icon = false;                     break;
    case NODETYPE__EXPANDO      : iFlags =                        F_EXPANDO        ; fValid_Icon = false; fValid_URL = false; break;
    case NODETYPE__EXPANDO_LINK : iFlags =                        F_EXPANDO        ; fValid_Icon = false;                     break;
    case NODETYPE__EXPANDO_TOPIC: iFlags =                        F_EXPANDO        ; fValid_Icon = false;                     break;
    case NODETYPE__GROUP        : iFlags =                                  F_GROUP; fValid_Icon = false; fValid_URL = false; break;
    case NODETYPE__LINK         :                                                                                             break;
    case NODETYPE__SPACER       :                                                    fValid_Icon = false; fValid_URL = false; break;
    }

    ////////////////////

    if(iFlags & F_TABLE)
    {
        strHTML += L"<TABLE border=0 cellPadding=0 cellSpacing=0 WIDTH=100% HEIGHT=100% style='table-layout: fixed'><TR WIDTH=100%><TD>";
    }

    if(iFlags & (F_TOPPANE | F_BOTTOMPANE))
    {
        static const LPCWSTR c_TopPane   [] = { L"sys-toppane-color-border sys-toppane-header-color sys-toppane-header-bgcolor"          };
        static const LPCWSTR c_BottomPane[] = { L"sys-bottompane-color-border sys-bottompane-header-color sys-bottompane-header-bgcolor" };

        const LPCWSTR* c_Pane = (iFlags & F_TOPPANE) ? c_TopPane : c_BottomPane;

        //; text-overflow: ellipsis; overflow: hidden
        strHTML += L"<DIV style='width: 100%; border : 1pt solid' class='sys-font-body-bold ";
        strHTML += c_Pane[0];
        strHTML += L"'><DIV ID=tree_Title style='padding: 0.5em 11px' TITLE=\""; MPC::HTML::HTMLEscape( strHTML, szDescription ); //; border: 1pt solid red
        strHTML += L"\">";

        fTitleDefined = true;
    }

    if(iFlags & F_NOPANE)
    {
        strHTML += L"<DIV style='width: 100%' class='sys-font-heading2 sys-rhp-color-title'>";
        strHTML += L"<DIV ID=tree_Title style='padding: 0.5em 11px 0.5em 6px' TITLE=\""; MPC::HTML::HTMLEscape( strHTML, szDescription ); //; border: 1pt solid red
        strHTML += L"\">";

        fTitleDefined = true;
    }

    if(iFlags & F_EXPANDO)
    {
        if(m_iType == NODETYPE__EXPANDO)
        {
            if(m_lstSubnodes.size())
            {
                szIcon = (m_fExpanded ? s_icons_Collapse[0] : s_icons_Expand[0]);
            }
            else
            {
                szIcon = s_icons_Empty[0];
            }
        }
        else
        {
            szIcon = s_icons_Bullet;
        }

        strHTML += (m_owner->GetNavModel() == QR_SERVER) ? L"<DIV NOWRAP" : L"<DIV";
        strHTML += L" ID=tree_Title style='padding: 0.5em; cursor: hand' TITLE=\""; MPC::HTML::HTMLEscape( strHTML, szDescription );//; border: 1pt solid green
        strHTML += L"\"><IMG ID=tree_Img ALIGN=absmiddle src=\""; strHTML += szIcon;

        strHTML += m_owner->IsRTL() ? L"\" style='margin-left : 0.5em'>" :
                                      L"\" style='margin-right: 0.5em'>";

        fTitleDefined = true;

        if(!fValid_URL)
        {
            fValid_URL = true;
            szURL      = L"about:blank";
        }
    }

    if(iFlags & F_GROUP)
    {
        strHTML += (m_owner->GetNavModel() == QR_SERVER) ? L"<DIV NOWRAP" : L"<DIV";
        strHTML += L" ID=tree_Title CLASS='sys-color-body sys-font-body-bold' style='padding: 0.5em 11px 0.5em 6px' TITLE=\""; MPC::HTML::HTMLEscape( strHTML, szDescription );//; border: 1pt solid navy
        strHTML += L"\">";

        fTitleDefined = true;
    }

    ////////////////////

    if(!fTitleDefined)
    {
        strHTML += (m_owner->GetNavModel() == QR_SERVER) ? L"<DIV NOWRAP" : L"<DIV";
        strHTML += L" ID=tree_Title style='padding: 0.5em 11px' TITLE=\""; MPC::HTML::HTMLEscape( strHTML, szDescription );//; border: 1pt solid navy
        strHTML += L"\">";
    }

    if(fValid_URL)
    {
        LPCWSTR szClass = (iFlags & (F_TOPPANE | F_BOTTOMPANE)) ? L"sys-link-header" : L"sys-link-normal";

        strHTML += L"<A class='"; strHTML += szClass; strHTML += L"' tabIndex=1 href=\""; strHTML += szURL; InsertOptionalTarget( strHTML );
        strHTML += L"\">";
    }

    if(fValid_Icon)
    {
        LPCWSTR szExt = wcsrchr( szIcon, '.' );
        bool    fBMP  = false;

        if(szExt && !_wcsicmp( szExt, L".BMP" )) fBMP = true;


        if(fBMP)
        {
            strHTML += L"<helpcenter:bitmap style='position: relative; width: 12px; height: 12px' SRCNORMAL=\"";
        }
        else
        {
            strHTML += L"<IMG BORDER=0 ALIGN=absmiddle SRC=\"";
        }

        strHTML += szIcon;
        strHTML += m_owner->IsRTL() ? L"\" style='margin-left : 0.5em'>" :
                                      L"\" style='margin-right: 0.5em'>";

        if(fBMP)
        {
            strHTML += L"</helpcenter:bitmap>";
        }
    }

    MPC::HTML::HTMLEscape( strHTML, szTitle );

    if(fValid_URL)
    {
        // Removed because of bug 434589
        // if(_wcsnicmp( szURL, s_prefix_APP, MAXSTRLEN(s_prefix_APP) ) == 0)
        // {
        //    strHTML += L"&nbsp;<helpcenter:bitmap style='position: relative; top: 1px; width: 12px; height: 12px' SRCNORMAL='hcp://system/images/icon_newwindow_12x.bmp'></helpcenter:bitmap>";
        // }

        strHTML += L"</A>";
    }

    if(!fTitleDefined)
    {
        strHTML += L"</DIV>";
    }

    ////////////////////

    if(iFlags & F_GROUP)
    {
        //; border: 1pt solid pink
        strHTML += L"</DIV>";
        strHTML += (m_owner->GetNavModel() == QR_SERVER) ? L"<DIV NOWRAP" : L"<DIV";
        strHTML += L" ID=tree_Children></DIV>";
    }

    if(iFlags & F_EXPANDO)
    {
        strHTML += L"</DIV>";
        strHTML += (m_owner->GetNavModel() == QR_SERVER) ? L"<DIV NOWRAP" : L"<DIV";

        strHTML += m_owner->IsRTL() ? L" ID=tree_Children style='padding-right: 1.0em; display: none'></DIV>" : //; border: 1pt solid pink
                                      L" ID=tree_Children style='padding-left : 1.0em; display: none'></DIV>" ;
    }

    if(iFlags & (F_TOPPANE | F_BOTTOMPANE | F_NOPANE))
    {
        strHTML += L"</DIV></DIV>";
    }

    if(iFlags & F_TABLE)
    {
        strHTML += L"</TD></TR><TR><TD HEIGHT=100%>";
    }

    if(iFlags & (F_TOPPANE | F_BOTTOMPANE))
    {
        static const LPCWSTR c_TopPane   [] = { L"sys-toppane-color-border sys-toppane-bgcolor"       };
        static const LPCWSTR c_BottomPane[] = { L"sys-bottompane-color-border sys-bottompane-bgcolor" };

        const LPCWSTR* c_Pane = (iFlags & F_TOPPANE) ? c_TopPane : c_BottomPane;

        strHTML += L"<DIV ID=tree_Children class='sys-font-body ";
        strHTML += c_Pane[0];
        strHTML += L"' style='width: 100%; ";

        if(iFlags & F_TABLE)
        {
            strHTML += L"height: 100%; ";
        }

////        if(m_owner->GetNavModel() == QR_SERVER)
////        {
////            strHTML += L"text-overflow: ellipsis; overflow-x: hidden; overflow-y: auto; ";
////        }
////        else
////        {
////            strHTML += L"overflow: auto; ";
////        }
        strHTML += L"overflow: auto; ";

        strHTML += L"border : 1pt solid; border-top : 0; padding: 11px'></DIV>";
    }

    if(iFlags & F_NOPANE)
    {
        strHTML += L"<DIV ID=tree_Children class='sys-font-body' style='width: 100%; ";

        if(iFlags & F_TABLE)
        {
            strHTML += L"height: 100%; ";
        }

////        if(m_owner->GetNavModel() == QR_SERVER)
////        {
////            strHTML += L"text-overflow: ellipsis; overflow-x: hidden; overflow-y: auto; ";
////        }

        strHTML += L"'></DIV>";
    }

    if(iFlags & F_TABLE)
    {
        strHTML += L"</TD></TR></TABLE>";
    }

    ////////////////////

    __MPC_EXIT_IF_METHOD_FAILS(hr, LoadHTML( strHTML.c_str() ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void CPCHBehavior_BasicTree::Node::InsertOptionalTarget( /*[in/out]*/ MPC::wstring& strHTML )
{
    BSTR bstrTargetFrame = m_owner->m_bstrTargetFrame;

    if(STRINGISPRESENT(bstrTargetFrame))
    {
        strHTML += L"\" target=\""; strHTML += bstrTargetFrame;
    }
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHBehavior_BasicTree::Node::GenerateChildren()
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_BasicTree::Node::GenerateChildren" );

    HRESULT hr;


    if(!m_fLoaded_Children)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_NOT_READY);
    }

    ////////////////////

    if(m_lstSubnodes.size() && m_DIV_children)
    {
        MPC::wstring strHTML;
        Iter         it;

        for(it = m_lstSubnodes.begin(); it != m_lstSubnodes.end(); it++)
        {
            INCREASESIZE(strHTML);

            strHTML += L"<DIV></DIV>";
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_DIV_children->put_innerHTML( CComBSTR( strHTML.c_str() ) ));

        ////////////////////

        {
            MPC::HTML::IHTMLElementList lstDIV;
            MPC::HTML::IHTMLElementIter itDIV;

            __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::HTML::EnumerateElements( lstDIV, m_DIV_children, L"<DIV" ));

            itDIV = lstDIV       .begin();
            it    = m_lstSubnodes.begin();

            while(itDIV != lstDIV       .end() &&
                  it    != m_lstSubnodes.end()  )
            {
                Node* node = *it++;

                node->m_parentElement = *itDIV++;

                (void)node->Display();
            }

            MPC::ReleaseAll( lstDIV );
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHBehavior_BasicTree::Node::Display()
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_BasicTree::Node::Display" );

    HRESULT hr;
    bool    fNotify = false;

    m_fRefreshNotification = false;

    if(m_fInvalid)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }

    if(m_fDisplayed_Self == false)
    {
        if(SUCCEEDED(GenerateSelf()))
        {
            m_fDisplayed_Self = true;

            fNotify = true;
        }
    }

    if(m_fDisplayed_Self && !m_fDisplayed_Children)
    {
        if(SUCCEEDED(GenerateChildren()))
        {
            m_fDisplayed_Children = true;

            fNotify = true;
        }
    }

    if(m_fDisplayed_Self)
    {
        if(m_iSelection == SELECTION__NEXTACTIVE        ||
           m_iSelection == SELECTION__NEXTACTIVE_NOTIFY  )
        {
            Node* node = m_parent;

            //
            // Reset all the NEXTACTIVE flags for the parents.
            //
            while(node)
            {
                if(node->m_iSelection == SELECTION__NEXTACTIVE        ||
                   node->m_iSelection == SELECTION__NEXTACTIVE_NOTIFY  )
                {
                    node->m_iSelection = SELECTION__NONE;
                }

                node = node->m_parent;
            }

            __MPC_EXIT_IF_METHOD_FAILS(hr, m_owner->ChangeSelection( this, /*fNotify*/(m_iSelection == SELECTION__NEXTACTIVE_NOTIFY) ));
        }
    }

    if(m_iSelection == SELECTION__ACTIVE && m_owner->m_nSelected != this)
    {
        MPC::Attach( m_owner->m_nSelected, this );
    }

    ////////////////////

    if((m_iType == NODETYPE__EXPANDO      ||
        m_iType == NODETYPE__EXPANDO_LINK  ) && m_IMG && m_DIV_children)
    {
        const LPCWSTR* rgIcons;


        if(m_lstSubnodes.size())
        {
            CComPtr<IHTMLStyle> pStyle;
            CComBSTR            bstrDisplay;
            bool                fFlip = false;

            MPC_SCRIPTHELPER_GET__DIRECT__NOTNULL(pStyle     , m_DIV_children, style  );
            MPC_SCRIPTHELPER_GET__DIRECT         (bstrDisplay, pStyle        , display);

            if(MPC::StrICmp( bstrDisplay, s_style_None ) == 0)
            {
                if(m_fExpanded) fFlip = true;
            }
            else
            {
                if(!m_fExpanded) fFlip = true;
            }

            if(fFlip)
            {
                MPC_SCRIPTHELPER_PUT__DIRECT(pStyle, display, m_fExpanded ? NULL : s_style_None );

                if(m_fExpanded)
                {
                    fNotify = true;
                }
                else
                {
                    //
                    // If the currently selected node is a child of ours, grab the selection.
                    //
                    Node* selected = m_owner->m_nSelected;

                    while(selected)
                    {
                        if(selected == this)
                        {
                            __MPC_EXIT_IF_METHOD_FAILS(hr, m_owner->ChangeSelection( this, /*fNotify*/true ));
                            break;
                        }

                        selected = selected->m_parent;
                    }

                    //
                    // On desktop SKUs, we close the subnodes.
                    //
                    if(m_owner->GetNavModel() == QR_DESKTOP)
                    {
                        Iter it;

                        for(it = m_lstSubnodes.begin(); it != m_lstSubnodes.end(); it++)
                        {
                            Node* node = *it;

                            if(node->m_iType      == NODETYPE__EXPANDO &&
                               node->m_fExpanded  == true               )
                            {
                                node->m_fExpanded = false;

                                node->NotifyMainThread();
                            }
                        }
                    }
                }
            }

            rgIcons = (m_fExpanded ? s_icons_Collapse : s_icons_Expand);
        }
        else
        {
            rgIcons = s_icons_Empty;
        }

        {
            CComQIPtr<IHTMLImgElement> img = m_IMG;
            CComBSTR                   bstrIcon;
            int                        i = 0;

////            if     (m_fMouseDown) i = 2;
////            else if(m_fMouseOver) i = 1;
////            else                  i = 0;

            MPC_SCRIPTHELPER_GET__DIRECT(bstrIcon, img, src);

            if(MPC::StrICmp( bstrIcon, rgIcons[i] ))
            {
                bstrIcon = rgIcons[i];

                MPC_SCRIPTHELPER_PUT__DIRECT(img, src, bstrIcon );
            }
        }
    }

    if((m_iType == NODETYPE__EXPANDO       ||
        m_iType == NODETYPE__EXPANDO_LINK  ||
        m_iType == NODETYPE__EXPANDO_TOPIC ||
        m_iType == NODETYPE__LINK           ) && m_DIV)
    {
        //
        // Update styles to reflect current state.
        //
        MPC::wstring strClass; strClass.reserve( 1024 );
        CComBSTR     bstrClass;

        if(m_iSelection == SELECTION__ACTIVE) strClass += L"sys-toppane-selection";

////        if     (m_fMouseDown) strClass += L" Tree-Selectable-MouseDown";
////        else if(m_fMouseOver) strClass += L" Tree-Selectable-MouseOver";
////        else                  strClass += L" Tree-Selectable-Normal";

        MPC_SCRIPTHELPER_GET__DIRECT(bstrClass, m_DIV, className);

        if(MPC::StrICmp( strClass, bstrClass ))
        {
            bstrClass = strClass.c_str();

            MPC_SCRIPTHELPER_PUT__DIRECT(m_DIV, className, bstrClass);
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(fNotify) m_owner->Thread_Signal();

    __HCP_FUNC_EXIT(hr);
}

bool CPCHBehavior_BasicTree::Node::IsParentDisplayingUs()
{
    if(m_parent == NULL) return true; // No parent, we are displayed for sure.

    switch(m_parent->m_iType)
    {
    case NODETYPE__FRAME1       : return true;
    case NODETYPE__FRAME2       : return true;
    case NODETYPE__FRAME3       : return true;
    case NODETYPE__FRAME1_EXPAND: return true;
    case NODETYPE__FRAME2_EXPAND: return true;
    case NODETYPE__FRAME3_EXPAND: return true;
    case NODETYPE__EXPANDO      : return m_parent->m_fExpanded;
    case NODETYPE__EXPANDO_LINK : return m_parent->m_fExpanded;
    case NODETYPE__EXPANDO_TOPIC: return m_parent->m_fExpanded;
    case NODETYPE__GROUP        : return true;
    case NODETYPE__LINK         : return false;
    case NODETYPE__SPACER       : return false;
    }

    return false;
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHBehavior_BasicTree::Node::Load( /*[in]*/ MPC::Serializer& stream )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_BasicTree::Node::Load" );

    HRESULT hr;
    int     iCount;
    int     iType;
    int     iSelection;

                                                                  // CPCHBehavior_BasicTree*  m_owner;
                                                                  // Node*                    m_parent;
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> m_bstrNode        ); // CComBSTR                 m_bstrNode;
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> iType             ); // NodeType                 m_iType;
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> iSelection        ); // SelectionMode            m_iSelection;
                                                                  //
                                                                  // bool                     m_fLoaded_Self;
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> m_fLoaded_Children); // bool                     m_fLoaded_Children;
                                                                  // bool                     m_fDisplayed_Self;
                                                                  // bool                     m_fDisplayed_Children;
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> m_fInvalid        ); // bool                     m_fInvalid;
                                                                  // bool                     m_fRefreshNotification;
                                                                  //
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> m_fExpanded       ); // bool                     m_fExpanded;
                                                                  // bool                     m_fMouseOver;
                                                                  // bool                     m_fMouseDown;
                                                                  //
                                                                  // CComPtr<IHTMLElement>    m_parentElement;
                                                                  // CComBSTR                 m_bstrID;
                                                                  //
                                                                  // CComPtr<IHTMLElement>    m_DIV;
                                                                  // CComPtr<IHTMLElement>    m_IMG;
                                                                  // CComPtr<IHTMLElement>    m_DIV_children;
                                                                  //
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> iCount            ); // List                     m_lstSubnodes;


    m_iType      = (NodeType     )iType;
    m_iSelection = (SelectionMode)iSelection;

    if(m_fLoaded_Children)
    {
        while(iCount-- > 0)
        {
            Node* subnode;

            __MPC_EXIT_IF_METHOD_FAILS(hr, CreateInstance( m_owner, this, subnode ));
            m_lstSubnodes.push_back( subnode );


            __MPC_EXIT_IF_METHOD_FAILS(hr, subnode->Load( stream ));
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHBehavior_BasicTree::Node::Save( /*[in]*/ MPC::Serializer& stream, /*[in]*/ bool fSaveChildren )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_BasicTree::Node::Save" );

    HRESULT hr;
    Iter    it         = m_lstSubnodes.begin();
    int     iCount     = m_lstSubnodes.size();
    int     iType      = m_iType;
    int     iSelection = m_iSelection;

    if( fSaveChildren) fSaveChildren = m_fLoaded_Children;
    if(!fSaveChildren) iCount        = 0;

                                                             // CPCHBehavior_BasicTree*  m_owner;
                                                             // Node*                    m_parent;
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << m_bstrNode   ); // CComBSTR                 m_bstrNode;
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << iType        ); // NodeType                 m_iType;
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << iSelection   ); // SelectionMode            m_iSelection
                                                             //
                                                             // bool                     m_fLoaded_Self;
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << fSaveChildren); // bool                     m_fLoaded_Children;
                                                             // bool                     m_fDisplayed_Self;
                                                             // bool                     m_fDisplayed_Children;
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << m_fInvalid   ); // bool                     m_fInvalid;
                                                             // bool                     m_fRefreshNotification;
                                                             //
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << m_fExpanded  ); // bool                     m_fExpanded;
                                                             // bool                     m_fMouseOver;
                                                             // bool                     m_fMouseDown;
                                                             //
                                                             // CComPtr<IHTMLElement>    m_parentElement;
                                                             // CComBSTR                 m_bstrID;
                                                             //
                                                             // CComPtr<IHTMLElement>    m_DIV;
                                                             // CComPtr<IHTMLElement>    m_IMG;
                                                             // CComPtr<IHTMLElement>    m_DIV_children;
                                                             //
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << iCount       ); // List                     m_lstSubnodes;


    while(iCount-- > 0)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, (*it++)->Save( stream, fSaveChildren ));
    }


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHBehavior_BasicTree::Node::OnMouse( /*[in]*/ DISPID id       ,
                                               /*[in]*/ long   lButton  ,
                                               /*[in]*/ long   lKey     ,
                                               /*[in]*/ bool   fIsImage )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_BasicTree::Node::OnMouse" );

    HRESULT hr;


    if(m_iType == NODETYPE__EXPANDO       ||
       m_iType == NODETYPE__EXPANDO_TOPIC ||
       m_iType == NODETYPE__EXPANDO_LINK  ||
       m_iType == NODETYPE__LINK           )
    {
        bool fMouseDown = m_fMouseDown;

        switch(id)
        {
        case DISPID_HTMLELEMENTEVENTS_ONMOUSEDOWN: m_fMouseDown = true ;                       break;
        case DISPID_HTMLELEMENTEVENTS_ONMOUSEUP  : m_fMouseDown = false;                       break;

        case DISPID_HTMLELEMENTEVENTS_ONMOUSEOVER:                       m_fMouseOver = true ; break;
        case DISPID_HTMLELEMENTEVENTS_ONMOUSEOUT : m_fMouseDown = false; m_fMouseOver = false; break;
        }


        if(m_iType == NODETYPE__EXPANDO      ||
           m_iType == NODETYPE__EXPANDO_LINK  )
        {
            if(fIsImage)
            {
                if(m_lstSubnodes.size())
                {
                    if(id == DISPID_HTMLELEMENTEVENTS_ONMOUSEDOWN && lButton == 1)
                    {
                        m_fExpanded = !m_fExpanded;
                    }
                    else
                    {
                        if(m_owner->GetNavModel() == QR_SERVER)
                        {
                            id = 0; // Ignore the event down the road...
                        }
                    }
                }
            }
            else
            {
                if(id == DISPID_HTMLELEMENTEVENTS_ONMOUSEDOWN && lButton == 1)
                {
                    //
                    // On Desktop, keep the node always open.
                    // On Server, toggle its state.
                    //
                    if(m_owner->GetNavModel() == QR_DESKTOP)
                    {
                        m_fExpanded = true;
                    }
                    else
                    {
                        m_fExpanded = !m_fExpanded;
                    }
                }
            }

            if(id == DISPID_HTMLELEMENTEVENTS_ONKEYDOWN)
            {
                switch(lKey)
                {
                case VK_RIGHT: m_fExpanded = m_owner->IsRTL() ? false : true ; break;
                case VK_LEFT : m_fExpanded = m_owner->IsRTL() ? true  : false; break;
                }
            }

            if(id == DISPID_HTMLELEMENTEVENTS_ONKEYPRESS)
            {
                switch(lKey)
                {
                case VK_RETURN: m_fExpanded = true ; break;
                }
            }
        }

	//BUG 531001 (IAccessibility Default ACtions do not work)
	//ONCLICK event needs to be handled. It was being intercepted but not handled.
	//Replaced ONMOUSEUP handling with ONCLICK.
        if((id == DISPID_HTMLELEMENTEVENTS_ONCLICK ) ||     //(id == DISPID_HTMLELEMENTEVENTS_ONMOUSEUP  && lButton == 1         && fMouseDown) ||
           (id == DISPID_HTMLELEMENTEVENTS_ONKEYPRESS && lKey    == VK_RETURN              ))
        {
			if(m_owner->m_nToSelect)
			{
				delete m_owner->m_nToSelect; m_owner->m_nToSelect = NULL;
			}

            __MPC_EXIT_IF_METHOD_FAILS(hr, m_owner->ChangeSelection( this, /*fNotify*/true ));
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, Display());
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

CPCHBehavior_BasicTree::CPCHBehavior_BasicTree()
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_BasicTree::CPCHBehavior_BasicTree" );

                                            // CComBSTR        m_bstrTargetFrame;
                                            //
    m_lCookie_onContextSelect = 0;          // long            m_lCookie_onContextSelect;
    m_lCookie_onSelect        = 0;          // long            m_lCookie_onSelect;
    m_lCookie_onUnselect      = 0;          // long            m_lCookie_onUnselect;
                                            //
    m_nTopNode                = NULL;       // Node*           m_nTopNode;
    m_nSelected               = NULL;       // Node*           m_nSelected;
    m_nCurrent                = NULL;       // Node*           m_nCurrent;
    m_nToSelect               = NULL;       // NodeToSelect*   m_nToSelect;
                                            // CPCHTimerHandle m_Timer;
                                            //
    m_fRefreshing             = true;       // bool            m_fRefreshing;
    m_lNavModel               = QR_DEFAULT; // long            m_lNavModel;
}

CPCHBehavior_BasicTree::~CPCHBehavior_BasicTree()
{
    (void)Empty();
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHBehavior_BasicTree::RefreshThread()
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_BasicTree::RefreshThread" );

    HRESULT hr;


	if(m_lNavModel == QR_DEFAULT) m_lNavModel = (m_parent->UserSettings()->IsDesktopSKU() ? QR_DESKTOP : QR_SERVER);


    __MPC_EXIT_IF_METHOD_FAILS(hr, RefreshThread_Enter());

    //
    // Process database request.
    //
    while(Thread_IsAborted() == false)
    {
        SetRefreshingFlag( false );

        Thread_WaitForEvents( NULL, INFINITE );
        if(Thread_IsAborted()) break;

        SetRefreshingFlag( true );

        if(m_nTopNode)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_nTopNode->ProcessRefreshRequest());
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    SetRefreshingFlag( false );

    RefreshThread_Leave();

    Thread_Abort(); // Kill the thread.

    __HCP_FUNC_EXIT(hr);
}

void CPCHBehavior_BasicTree::SetRefreshingFlag( /*[in]*/ bool fVal )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    m_fRefreshing = fVal;
}

void CPCHBehavior_BasicTree::WaitForRefreshing( /*[in]*/ MPC::SmartLock<_ThreadModel>& lock   ,
                                                /*[in]*/ bool                          fYield )
{
    if(fYield)
    {
        lock = NULL;

        Thread_Signal();
        ::Sleep( 0 ); // Yield processor.

        lock = this;
    }

    while(m_fRefreshing)
    {
        lock = NULL;

        if(Thread_IsRunning() == false) break;
        MPC::SleepWithMessagePump( 10 );

        lock = this;
    }
}

HRESULT CPCHBehavior_BasicTree::NotifyMainThread( /*[in]*/ Node* node )
{
    CComQIPtr<IDispatch> self = Thread_Self();
    CComVariant          v    = node ? node->m_bstrNode : L"";


    return MPC::AsyncInvoke( self, DISPID_PCH_BEHAVIORS_PRIV__NEWDATAAVAILABLE, &v, 1 );
}

HRESULT CPCHBehavior_BasicTree::ChangeSelection( /*[in]*/ Node* node    ,
                                                 /*[in]*/ bool  fNotify )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_BasicTree::ChangeSelection" );

    HRESULT hr;


    if(m_nSelected)
    {
        m_nSelected->m_iSelection = SELECTION__NONE;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_nSelected->Display());

        if(fNotify)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, FireEvent( m_lCookie_onUnselect ));
        }
    }

    MPC::Attach( m_nSelected, node );

    if(m_nSelected)
    {
        m_nSelected->m_iSelection = SELECTION__ACTIVE;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_nSelected->Display());

        if(fNotify)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, FireEvent( m_lCookie_onSelect ));
        }
        else
        {
            m_Timer.Start( this, TimerCallback_ScrollIntoView, 100 );
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

CPCHBehavior_BasicTree::Node* CPCHBehavior_BasicTree::NodeFromElement( /*[in]*/ IHTMLElement* elem )
{
    CComPtr<IHTMLElement> elemDIV;

    if(SUCCEEDED(MPC::HTML::FindFirstParentWithThisTag( elemDIV, elem, L"DIV" )) && elemDIV)
    {
        CComBSTR bstrID;

        if(SUCCEEDED(MPC::HTML::GetUniqueID( bstrID, elemDIV )))
        {
            return NodeFromKey( bstrID, true );
        }
    }

    return NULL;
}

CPCHBehavior_BasicTree::Node* CPCHBehavior_BasicTree::NodeFromKey( /*[in]*/ LPCWSTR szNode, /*[in]*/ bool fUseID )
{
    return m_nTopNode ? m_nTopNode->FindNode( szNode, fUseID ) : NULL;
}

HRESULT CPCHBehavior_BasicTree::InterceptInvoke( /*[in]*/ DISPID dispidMember, /*[in]*/ DISPPARAMS* pdispparams )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_BasicTree::InterceptInvoke" );

    HRESULT hr;

    if(dispidMember              == DISPID_PCH_BEHAVIORS_PRIV__NEWDATAAVAILABLE &&
       pdispparams->cArgs        == 1                                           &&
       pdispparams->rgvarg[0].vt == VT_BSTR                                      )
    {
        MPC::SmartLock<_ThreadModel> lock( this ); WaitForRefreshing( lock );
        Node*                        node;

        node = NodeFromKey( pdispparams->rgvarg[0].bstrVal );
        if(node)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, node->Display());
        }

        hr = S_OK;
    }
    else
    {
        hr = E_INVALIDARG;
    }


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHBehavior_BasicTree::TimerCallback_ScrollIntoView( /*[in]*/ VARIANT )
{
    if(m_nSelected && m_nSelected->m_DIV)
    {
        CComVariant v( VARIANT_TRUE );

        (void)m_nSelected->m_DIV->scrollIntoView( v );
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHBehavior_BasicTree::Init( /*[in]*/ IElementBehaviorSite* pBehaviorSite )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_BasicTree::Init" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHBehavior::Init( pBehaviorSite ));

    m_Timer.Initialize( m_parent->Timer() );

    __MPC_EXIT_IF_METHOD_FAILS(hr, AttachToEvents( s_events, (CLASS_METHOD)onMouse ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, CreateEvent( s_event_onContextSelect, m_lCookie_onContextSelect ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, CreateEvent( s_event_onSelect       , m_lCookie_onSelect        ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, CreateEvent( s_event_onUnselect     , m_lCookie_onUnselect      ));

    ////////////////////////////////////////////////////////////////////////////////

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::COMUtil::GetPropertyByName( m_elem, L"target", m_bstrTargetFrame ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHBehavior_BasicTree::Detach()
{
    Thread_Wait();

    if(m_nTopNode) m_nTopNode->Passivate();

    m_lCookie_onContextSelect = 0;
    m_lCookie_onSelect        = 0;
    m_lCookie_onUnselect      = 0;


    return CPCHBehavior::Detach();
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHBehavior_BasicTree::Load( /*[in]*/ MPC::Serializer& stream )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_BasicTree::Load" );

    HRESULT hr;
    bool    fNodePresent;


    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> fNodePresent);

    if(fNodePresent)
    {
        if(!m_nTopNode)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, E_FAIL);
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_nTopNode->Load( stream ));
    }

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHBehavior_BasicTree::Save( /*[in]*/ MPC::Serializer& stream )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_BasicTree::Save" );

    HRESULT hr;
    bool    fNodePresent = (m_nTopNode != NULL);


    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << fNodePresent);

    if(m_nTopNode) __MPC_EXIT_IF_METHOD_FAILS(hr, m_nTopNode->Save( stream, /*fSaveChildren*/true ));


    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////

HRESULT CPCHBehavior_BasicTree::Persist_Load( /*[in]*/ BSTR newVal )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_BasicTree::Persist_Load" );

    HRESULT          hr;
    CComPtr<IStream> stream;
    HGLOBAL          hg = NULL;


    Empty();


    //
    // Convert BSTR to IStream.
    //
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertHexToHGlobal( newVal, hg ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, ::CreateStreamOnHGlobal( hg, FALSE, &stream ));
    }

    //
    // Unserialize state from IStream.
    //
    {
        MPC::Serializer_IStream   streamReal( stream     );
        MPC::Serializer_Buffering streamBuf ( streamReal );
        DWORD                     dwVer;

        __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf >> dwVer); if(dwVer != l_dwVersion) __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE);

        __MPC_EXIT_IF_METHOD_FAILS(hr, Load( streamBuf ));
    }


    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    if(hg) ::GlobalFree( hg );

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHBehavior_BasicTree::Persist_Save( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_BasicTree::Persist_Save" );

    HRESULT          hr;
    CComPtr<IStream> streamResult;
    CComBSTR         bstr;
    HGLOBAL          hg;


    //
    // Serialize state to IStream.
    //
    {
        MPC::Serializer_IStream   streamReal;
        MPC::Serializer_Buffering streamBuf( streamReal );

        __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf << l_dwVersion );
        __MPC_EXIT_IF_METHOD_FAILS(hr, Save( streamBuf ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf .Flush    (               )); // Flush buffering stream.
        __MPC_EXIT_IF_METHOD_FAILS(hr, streamReal.Reset    (               )); // Rewind real stream.
        __MPC_EXIT_IF_METHOD_FAILS(hr, streamReal.GetStream( &streamResult )); // Extract pointer to IStream.
    }

    //
    // Convert IStream to BSTR.
    //
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, ::GetHGlobalFromStream( streamResult, &hg ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertHGlobalToHex( hg, bstr ));
    }


    *pVal = bstr.Detach();
    hr    = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

void CPCHBehavior_BasicTree::Empty()
{
                                 // CComBSTR        m_bstrTargetFrame;
	                             // 
                                 // long            m_lCookie_onContextSelect;
                                 // long            m_lCookie_onSelect;
                                 // long            m_lCookie_onUnselect;
	                             // 
    MPC::Release( m_nTopNode  ); // Node*           m_nTopNode;
    MPC::Release( m_nSelected ); // Node*           m_nSelected;
    MPC::Release( m_nCurrent  ); // Node*           m_nCurrent;
                                 // NodeToSelect*   m_nToSelect;
                                 // CPCHTimerHandle m_Timer;
	                             // 
                                 // bool            m_fRefreshing;
    m_lNavModel = QR_DEFAULT;    // long            m_lNavModel;

    if(m_nToSelect)
    {
        delete m_nToSelect;

        m_nToSelect = NULL;
    }
}

HRESULT CPCHBehavior_BasicTree::onMouse( DISPID id, DISPPARAMS*, VARIANT* )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_BasicTree::onMouse" );

    HRESULT                hr;
    CComPtr<IHTMLEventObj> ev;
    CComPtr<IHTMLElement>  elemSrc;
    CComPtr<IHTMLElement>  elemTo;
    CComBSTR               bstrTagName;
    long                   lButton;
    long                   lKey;
    bool                   fIsImage     = false;
    bool                   fClicked     = false;
    bool                   fContextMenu = false;
    bool                   fFocusEnter  = false;
    bool                   fFocusLeave  = false;
    Node*                  node         = NULL;
    Node*                  nodeTo       = NULL;



    AddRef(); // To protect against early deletion.


    __MPC_EXIT_IF_METHOD_FAILS(hr, GetEventObject( ev ));

    MPC_SCRIPTHELPER_GET__DIRECT__NOTNULL(elemSrc    , ev     , srcElement );
    MPC_SCRIPTHELPER_GET__DIRECT         (elemTo     , ev     , toElement  );
    MPC_SCRIPTHELPER_GET__DIRECT         (lButton    , ev     , button     );
    MPC_SCRIPTHELPER_GET__DIRECT         (lKey       , ev     , keyCode    );
    MPC_SCRIPTHELPER_GET__DIRECT         (bstrTagName, elemSrc, tagName    ); fIsImage = (MPC::StrICmp( bstrTagName, L"IMG" ) == 0);

    //
    // Find the node associated with the element.
    //
    node   = NodeFromElement( elemSrc );
    nodeTo = NodeFromElement( elemTo  );

    ////////////////////////////////////////

    if(g_Debug_CONTEXTMENU)
    {
        if(id == DISPID_HTMLELEMENTEVENTS_ONCONTEXTMENU)
        {
            VARIANT_BOOL fCtrlKey;

            MPC_SCRIPTHELPER_GET__DIRECT(fCtrlKey, ev, ctrlKey);
            if(fCtrlKey == VARIANT_TRUE)
            {
                id = 0; // Ignore event...
            }
        }
    }

    switch(id)
    {
    case DISPID_HTMLELEMENTEVENTS_ONCLICK    :
    case DISPID_HTMLELEMENTEVENTS_ONMOUSEDOWN:
    case DISPID_HTMLELEMENTEVENTS_ONMOUSEUP  :
        if(node)
        {
            bool fCancel = true;

            switch(node->m_iType)
            {
            case NODETYPE__FRAME1       :
            case NODETYPE__FRAME2       :
            case NODETYPE__FRAME3       :
            case NODETYPE__FRAME1_EXPAND:
            case NODETYPE__FRAME2_EXPAND:
            case NODETYPE__FRAME3_EXPAND:
            case NODETYPE__LINK         :
                fCancel = false; // Let IE handle the navigation for these nodes...
                break;
            }

            if(!fCancel) break;
        }

    case DISPID_HTMLELEMENTEVENTS_ONSELECTSTART:
    case DISPID_HTMLELEMENTEVENTS_ONCONTEXTMENU:
        __MPC_EXIT_IF_METHOD_FAILS(hr, CancelEvent( ev ));
        break;
    }

    if(node)
    {
        if(id == DISPID_HTMLELEMENTEVENTS_ONMOUSEOUT && node == nodeTo) // We are moving within the node...
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, S_OK);
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, node->OnMouse( id, lButton, lKey, fIsImage ));

        if(id == DISPID_HTMLELEMENTEVENTS_ONCONTEXTMENU)
        {
            MPC::Attach( m_nCurrent, node );

            __MPC_EXIT_IF_METHOD_FAILS(hr, FireEvent( m_lCookie_onContextSelect ));

            MPC::Release( m_nCurrent );
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    Release(); // To protect against early deletion.

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\binarybehaviors\behav_gradient.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Behav_GRADIENT.cpp

Abstract:
    This file contains the implementation of the CPCHBehavior_GRADIENT class,
    that dictates how hyperlinks work in the help center.

Revision History:
    Davide Massarenti (dmassare)  06/06/2000
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

static const CComBSTR c_bstrStartColor  ( L"start-color"    );
static const CComBSTR c_bstrEndColor    ( L"end-color"      );

static const CComBSTR c_bstrGradientType( L"gradient-type"  );
static const CComBSTR c_bstrReturnToZero( L"return-to-zero" );

////////////////////////////////////////////////////////////////////////////////

static COLORREF local_GetColor( /*[in]*/  IHTMLElement*      elem     ,
                                /*[in]*/  IHTMLCurrentStyle* style    ,
                                /*[in]*/  BSTR               bstrName )
{
    CComVariant vColor;
    COLORREF    color;
    bool        fSystem;

    (void)style->getAttribute( bstrName, 0, &vColor );

    (void)MPC::HTML::ConvertColor( vColor, color, fSystem );

    return color;
}

////////////////////////////////////////////////////////////////////////////////

CPCHBehavior_GRADIENT::CPCHBehavior_GRADIENT()
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_GRADIENT::CPCHBehavior_GRADIENT" );

    m_lCookie       = 0;     // long     m_lCookie;
                             //
                             // COLORREF m_clsStart;
                             // COLORREF m_clsEnd;
    m_fHorizontal   = true;  // bool     m_fHorizontal;
    m_fReturnToZero = false; // bool     m_fReturnToZero;
}

/////////////////////////////////////////////////////////////////////////////

void CPCHBehavior_GRADIENT::GetColors( /*[in]*/ bool fForce )
{
    CComPtr<IHTMLCurrentStyle> pStyle;
    CComVariant                v;

	if(m_elem && m_elem2 && SUCCEEDED(m_elem2->get_currentStyle( &pStyle )) && pStyle)
	{
		m_clsStart = local_GetColor( m_elem, pStyle, c_bstrStartColor );
		m_clsEnd   = local_GetColor( m_elem, pStyle, c_bstrEndColor   );

		if(SUCCEEDED(pStyle->getAttribute( c_bstrGradientType, 0, &v )) && v.vt == VT_BSTR &&
		   SUCCEEDED(v.ChangeType        ( VT_I4                     ))                     )
		{
			if(v.lVal == 0) m_fHorizontal = false;
		}
		v.Clear();
	
		if(SUCCEEDED(pStyle->getAttribute( c_bstrReturnToZero, 0, &v )) && v.vt == VT_BSTR &&
		   SUCCEEDED(v.ChangeType        ( VT_I4                     ))                     )
		{
			if(v.lVal != 0) m_fReturnToZero = true;
		}
		v.Clear();
	
		if(m_fRTL && m_fHorizontal && !m_fReturnToZero)
		{
			COLORREF tmp;
	
			tmp        = m_clsStart;
			m_clsStart = m_clsEnd;
			m_clsEnd   = tmp;
		}
	}
}

HRESULT CPCHBehavior_GRADIENT::onEvent( DISPID id, DISPPARAMS* pdispparams, VARIANT* )
{
	if(id == DISPID_PCH_E_CSSCHANGED)
	{
		GetColors( /*fForce*/true );
	}

	return S_OK;
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHBehavior_GRADIENT::Init( /*[in]*/ IElementBehaviorSite* pBehaviorSite )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_GRADIENT::Init" );

    HRESULT            hr;
	CComPtr<IDispatch> pDisp;


    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHBehavior::Init( pBehaviorSite ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, AttachToEvent( NULL, (CLASS_METHOD)onEvent, NULL, &pDisp ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->Events().RegisterEvents( -1, 0, pDisp, &m_lCookie ));

	GetColors( /*fForce*/false );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHBehavior_GRADIENT::Detach()
{
    if(m_lCookie)
    {
		(void)m_parent->Events().UnregisterEvents( m_lCookie );

        m_lCookie = 0;
    }

    return CPCHBehavior::Detach();
}

////////////////////////////////////////////////////////////////////////////////

#define COLOR2COLOR16(col) (COLOR16)((col) << 8);

STDMETHODIMP CPCHBehavior_GRADIENT::Draw( /*[in]*/ RECT   rcBounds     ,
										  /*[in]*/ RECT   rcUpdate     ,
										  /*[in]*/ LONG   lDrawFlags   ,
										  /*[in]*/ HDC    hdc          ,
										  /*[in]*/ LPVOID pvDrawObject )
{
	if(m_clsStart != m_clsEnd)
	{
		TRIVERTEX     vert[2];
		GRADIENT_RECT gRect;
		ULONG         dwMode = m_fHorizontal ? GRADIENT_FILL_RECT_H : GRADIENT_FILL_RECT_V;
	
		vert[0].x      = rcBounds.left;
		vert[0].y      = rcBounds.top;
		vert[0].Red    = COLOR2COLOR16(GetRValue(m_clsStart));
		vert[0].Green  = COLOR2COLOR16(GetGValue(m_clsStart));
		vert[0].Blue   = COLOR2COLOR16(GetBValue(m_clsStart));
		vert[0].Alpha  = 0;
	
		vert[1].x      = rcBounds.right;
		vert[1].y      = rcBounds.bottom;
		vert[1].Red    = COLOR2COLOR16(GetRValue(m_clsEnd));
		vert[1].Green  = COLOR2COLOR16(GetGValue(m_clsEnd));
		vert[1].Blue   = COLOR2COLOR16(GetBValue(m_clsEnd));
		vert[1].Alpha  = 0;
	
		gRect.UpperLeft  = 0;
		gRect.LowerRight = 1;
	
		if(m_fReturnToZero)
		{
			if(m_fHorizontal) vert[1].x = vert[0].x + (rcBounds.right  - rcBounds.left) / 2;
			else              vert[1].y = vert[0].y + (rcBounds.bottom - rcBounds.top ) / 2;
			
			::GradientFill(hdc, vert, 2, &gRect, 1, dwMode );
	
	
			if(m_fHorizontal) vert[0].x = rcBounds.right;
			else              vert[0].y = rcBounds.bottom;
		}
	
		////DebugLog( "GRADIENT %d %d %d %d\n", (int)rcBounds.left, (int)rcBounds.top, (int)rcBounds.right, (int)rcBounds.bottom );
		::GradientFill( hdc, vert, 2, &gRect, 1, dwMode );
	}
	else
	{
		HBRUSH hbrush = ::CreateSolidBrush( m_clsStart );
		
		if(hbrush)
		{
			::FillRect( hdc, &rcBounds, hbrush );
			
			::DeleteObject( hbrush );
		}
	}

    return S_OK;
}

STDMETHODIMP CPCHBehavior_GRADIENT::GetPainterInfo( /*[in]*/ HTML_PAINTER_INFO *pInfo )
{
    if(pInfo)
    {
		pInfo->lFlags          = HTMLPAINTER_TRANSPARENT;
		pInfo->lZOrder         = HTMLPAINT_ZORDER_BELOW_CONTENT;
		pInfo->iidDrawObject   = IID_NULL;
		pInfo->rcExpand.left   = 0;
		pInfo->rcExpand.top    = 0;
		pInfo->rcExpand.right  = 0;
		pInfo->rcExpand.bottom = 0;
    }

    return S_OK;
}

STDMETHODIMP CPCHBehavior_GRADIENT::HitTestPoint( /*[in]*/ POINT pt       ,
												  /*[in]*/ BOOL* pbHit    ,
												  /*[in]*/ LONG* plPartID )
{
    return E_NOTIMPL;
}

STDMETHODIMP CPCHBehavior_GRADIENT::OnResize( /*[in]*/ SIZE pt )
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\binarybehaviors\behav_event.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Behav_EVENT.cpp

Abstract:
    This file contains the implementation of the CPCHBehavior_EVENT class,
    that dictates how hyperlinks work in the help center.

Revision History:
    Davide Massarenti (dmassare)  06/06/2000
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

static const int c_NumOfEvents = DISPID_PCH_E_LASTEVENT - DISPID_PCH_E_FIRSTEVENT;

////////////////////////////////////////////////////////////////////////////////

CPCHBehavior_EVENT::CPCHBehavior_EVENT()
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_EVENT::CPCHBehavior_EVENT" );

    m_lCookieIN  = 0;    // long                 m_lCookieIN;
    m_lCookieOUT = NULL; // LONG*                m_lCookieOUT;
    					 //
    					 // CComQIPtr<IPCHEvent> m_evCurrent;
}

CPCHBehavior_EVENT::~CPCHBehavior_EVENT()
{
	Detach();
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHBehavior_EVENT::Init( /*[in]*/ IElementBehaviorSite* pBehaviorSite )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_EVENT::Init" );

    HRESULT     hr;
    CComVariant vPriority;
    long        lPriority = 0;

    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHBehavior::Init( pBehaviorSite ));

	__MPC_EXIT_IF_ALLOC_FAILS(hr, m_lCookieOUT, new LONG[c_NumOfEvents]);


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::COMUtil::GetPropertyByName( m_elem, L"priority", vPriority ));
    if(SUCCEEDED(vPriority.ChangeType( VT_I4 )))
    {
        lPriority = vPriority.lVal;
    }


    if(m_fTrusted)
    {
        CComPtr<IDispatch> pDisp;

        //
        // Attach to all the events from CPCHEvents.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, AttachToEvent( NULL, (CLASS_METHOD)onFire, NULL, &pDisp ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->Events().RegisterEvents( -1, lPriority, pDisp, &m_lCookieIN ));

        //
        // Register all the custom events.
        //
        for(int i=0; i<c_NumOfEvents; i++)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, CreateEvent( CComBSTR( CPCHEvents::ReverseLookup( i + DISPID_PCH_E_FIRSTEVENT ) ), m_lCookieOUT[i] ));
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHBehavior_EVENT::Detach()
{
    if(m_lCookieIN)
    {
		(void)m_parent->Events().UnregisterEvents( m_lCookieIN );

        m_lCookieIN = 0;
    }

    if(m_lCookieOUT)
    {
		delete [] m_lCookieOUT;

        m_lCookieOUT = NULL;
    }

    return CPCHBehavior::Detach();
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHBehavior_EVENT::get_data   ( /*[out, retval]*/ VARIANT    *pVal ) { return GetAsVARIANT  ( m_evCurrent, pVal ); }
STDMETHODIMP CPCHBehavior_EVENT::get_element( /*[out, retval]*/ IDispatch* *pVal ) { return GetAsIDISPATCH( NULL       , pVal ); }

STDMETHODIMP CPCHBehavior_EVENT::Load  	 (                        /*[in         ]*/ BSTR     newVal ) {                         return S_FALSE; }
STDMETHODIMP CPCHBehavior_EVENT::Save  	 (                        /*[out, retval]*/ BSTR    *pVal   ) { if(pVal) *pVal = NULL;  return S_FALSE; }
STDMETHODIMP CPCHBehavior_EVENT::Locate	 ( /*[in]*/ BSTR bstrKey, /*[out, retval]*/ VARIANT *pVal   ) {                         return S_FALSE; }
STDMETHODIMP CPCHBehavior_EVENT::Unselect(                                                          ) {                         return S_FALSE; }

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHBehavior_EVENT::onFire( DISPID id, DISPPARAMS* pdispparams, VARIANT* )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_EVENT::onFire" );

	AddRef(); // Protect against early deletion during event firing...

    HRESULT            hr;
    VARIANT&           v          = pdispparams->rgvarg[0];
    CComPtr<IPCHEvent> evPrevious = m_evCurrent;


    if(v.vt == VT_DISPATCH)
    {
        m_evCurrent = v.pdispVal;
    }

    for(int i=0; i<c_NumOfEvents; i++)
    {
        if((i + DISPID_PCH_E_FIRSTEVENT) == id)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, FireEvent( m_lCookieOUT[i] ));

            break;
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    m_evCurrent = evPrevious;

	Release(); // Revert protection against early deletion during event firing...

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\binarybehaviors\behav_subsite.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Behav_SUBSITE.cpp

Abstract:
    This file contains the implementation of the CPCHBehavior_SUBSITE class.

Revision History:
    Davide Massarenti (dmassare)  08/15/2000
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

CPCHBehavior_SUBSITE::QueryNode::QueryNode()
{
    				  	  // CComPtr<IPCHQueryResult> m_qrNode;
	m_fQueryDone = false; // bool                     m_fQueryDone;
	m_fTopic     = false; // bool                     m_fTopic;
};

CPCHBehavior_SUBSITE::QueryNode::~QueryNode()
{
    ;
}

HRESULT CPCHBehavior_SUBSITE::QueryNode::Init( /*[in]*/ LPCWSTR          szNode ,
											   /*[in]*/ NodeType         iType  ,
                                               /*[in]*/ CPCHQueryResult* qr     ,
											   /*[in]*/ bool             fTopic )
{
	m_fTopic = fTopic;

	if(qr)
	{
		m_qrNode       = qr;
		m_fQueryDone   = true;
		m_fLoaded_Self = true;

		if(fTopic)
		{
			m_fLoaded_Children = true;
		}
	}

    return Node::Init( szNode, iType );
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHBehavior_SUBSITE::QueryNode::ProcessRefreshRequest()
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_SUBSITE::QueryNode::ProcessRefreshRequest" );

    HRESULT 	  hr;
	bool    	  fNotify = false;
	NodeToSelect* nts;


	if(m_fLoaded_Self && m_fLoaded_Children && (nts = m_owner->GetNodeToSelect()))
	{
		bool fSelect = false;

		if(m_fTopic)
		{
			if(nts->m_bstrURL && MPC::StrICmp( m_bstrNode, nts->m_bstrURL ) == 0)
			{
				nts->m_bstrURL .Empty();
				nts->m_bstrNode.Empty();

				fSelect = true;
			}
		}
		else
		{
			if(nts->m_bstrNode && m_bstrNode)
			{
				int iSize = m_bstrNode.Length();

				if(_wcsnicmp( m_bstrNode, nts->m_bstrNode, iSize ) == 0)
				{
					switch(nts->m_bstrNode[iSize])
					{
					case 0: // Full match.
						nts->m_bstrNode.Empty();
						m_fExpanded = true;
						fSelect     = true;
						break;

					case '/': // Partial match, expand node.
						if(m_fExpanded == false)
						{
							m_fExpanded = true;
							fNotify     = true;
						}
						break;
					}
				}
			}
		}

		if(fSelect)
		{
			Node* node = m_parent;

			//
			// Reset all the NEXTACTIVE flags for the parents, also expanding them.
			//
			while(node)
			{
				if(node->m_iSelection == SELECTION__NEXTACTIVE        ||
				   node->m_iSelection == SELECTION__NEXTACTIVE_NOTIFY  )
				{
					node->m_iSelection = SELECTION__NONE;
				}

				node->m_fExpanded = true; node->NotifyMainThread();

				node = node->m_parent;
			}

			m_iSelection = nts->m_fNotify ? SELECTION__NEXTACTIVE_NOTIFY : SELECTION__NEXTACTIVE;
			fNotify      = true;
		}
	}

	__MPC_EXIT_IF_METHOD_FAILS(hr, CPCHBehavior_BasicTree::Node::ProcessRefreshRequest());


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(fNotify) NotifyMainThread();

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHBehavior_SUBSITE::QueryNode::CreateInstance( /*[in]*/ CPCHBehavior_BasicTree* owner, /*[in]*/ Node* parent, /*[out]*/ Node*& subnode )
{
	return CreateInstance_QueryNode( owner, parent, subnode );
}

HRESULT CPCHBehavior_SUBSITE::QueryNode::CreateInstance_QueryNode( /*[in]*/ CPCHBehavior_BasicTree* owner, /*[in]*/ Node* parent, /*[out]*/ Node*& subnode )
{
	__HCP_FUNC_ENTRY( "CPCHBehavior_SUBSITE::QueryNode::CreateInstance_QueryNode" );

	HRESULT    hr;
	QueryNode* node;

	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &node ));

	node->m_owner  = owner;
	node->m_parent = parent;
	hr             = S_OK;


	__HCP_FUNC_CLEANUP;

	subnode = node;

	__HCP_FUNC_EXIT(hr);
}

HRESULT CPCHBehavior_SUBSITE::QueryNode::PopulateSelf()
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_SUBSITE::QueryNode::PopulateSelf" );

    HRESULT                         hr;
	CPCHProxy_IPCHTaxonomyDatabase* db = (m_owner ? ((CPCHBehavior_SUBSITE*)m_owner)->m_db : NULL);


    if(m_fLoaded_Self == false && db)
    {
        //
        // Load self.
        //
		if(m_fTopic == false)
		{
			CComPtr<CPCHQueryResultCollection> pColl;

			if(SUCCEEDED(db->ExecuteQuery( OfflineCache::ET_NODE, m_bstrNode, &pColl )))
			{
				m_qrNode.Release();
				if(SUCCEEDED(pColl->GetItem( 0, &m_qrNode )))
				{
					if(m_parent == NULL)
					{
						m_owner->SetNavModel( m_qrNode->GetData().m_lNavModel );
					}
				}
			}
			m_fQueryDone = true;
		}
		else
		{
			m_fLoaded_Children = true;
		}

        m_fLoaded_Self = true;
	}

    hr = S_OK;


    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHBehavior_SUBSITE::QueryNode::PopulateChildren()
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_SUBSITE::QueryNode::PopulateChildren" );

    HRESULT                         hr;
	CPCHProxy_IPCHTaxonomyDatabase* db = (m_owner ? ((CPCHBehavior_SUBSITE*)m_owner)->m_db : NULL);


    if(m_fLoaded_Children == false && db)
    {
        //
        // Load sub nodes.
        //
		if(m_fTopic == false)
		{
			CComPtr<CPCHQueryResultCollection> pColl;
			int                                iType;


			iType = (m_owner->GetNavModel() == QR_DESKTOP ? OfflineCache::ET_SUBNODES_VISIBLE : OfflineCache::ET_NODESANDTOPICS_VISIBLE);

			if(SUCCEEDED(db->ExecuteQuery( iType, m_bstrNode, &pColl )))
			{
				long lPos;
				long lCount;

				MPC_SCRIPTHELPER_GET__DIRECT(lCount, pColl, Count);
				for(lPos=0; lPos<lCount; lPos++)
				{
					CComPtr<CPCHQueryResult> qr;
					CComBSTR                 bstrNode;
					CComBSTR                 bstrEntry;
					QueryNode*               node;
					bool                     fTopic;

					__MPC_EXIT_IF_METHOD_FAILS(hr, pColl->GetItem( lPos, &qr ));

					{
						const CPCHQueryResult::Payload& pl = qr->GetData();

						__MPC_EXIT_IF_METHOD_FAILS(hr, CreateInstance_QueryNode( m_owner, this, (Node*&)node ));
						m_lstSubnodes.push_back( node );

						if(pl.m_bstrEntry.Length() > 0) // It's a node.
						{
							MPC_SCRIPTHELPER_GET__DIRECT(bstrNode, qr, FullPath);
							fTopic = false;
						}
						else
						{
							bstrNode = pl.m_bstrTopicURL;
							fTopic = true;
						}
					}

					__MPC_EXIT_IF_METHOD_FAILS(hr, node->Init( bstrNode, fTopic ? NODETYPE__EXPANDO_TOPIC : NODETYPE__EXPANDO, qr, fTopic ));
				}
			}
        }

        m_fLoaded_Children = true;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(FAILED(hr))
    {
        MPC::CallDestructorForAll( m_lstSubnodes );

		m_fInvalid         = true;
        m_fLoaded_Children = true;
        hr                 = S_OK;
    }

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHBehavior_SUBSITE::QueryNode::GenerateSelf()
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_SUBSITE::QueryNode::GenerateSelf" );

    HRESULT hr;

	if(!m_fInvalid)
	{
		if(!m_fLoaded_Self || !m_fLoaded_Children || !m_fQueryDone)
		{
			m_owner->Thread_Signal(); // Tell the worker thread to process something...
		}
			
		if(!m_fLoaded_Self || !m_fQueryDone)
		{
			__MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_NOT_READY);
		}
	}

    ////////////////////

	if(m_qrNode)
	{
		const CPCHQueryResult::Payload& pl      = m_qrNode->GetData();
		LPCWSTR 	 					szTitle = pl.m_bstrTitle ? pl.m_bstrTitle : pl.m_bstrCategory;
		LPCWSTR 	 					szDesc  = pl.m_bstrDescription;
		LPCWSTR 	 					szIcon  = pl.m_bstrIconURL;
		LPCWSTR 	 					szURL   = pl.m_bstrTopicURL;

		__MPC_EXIT_IF_METHOD_FAILS(hr, GenerateHTML( szTitle, szDesc, szIcon, szURL ));
	}
	else
	{
		MPC::wstring strTitle; MPC::LocalizeString( IDS_HELPCTR_TAXO_UNKNOWN_NODE, strTitle );

		__MPC_EXIT_IF_METHOD_FAILS(hr, GenerateHTML( strTitle.c_str(), NULL, NULL, NULL ));
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHBehavior_SUBSITE::QueryNode::Load( /*[in]*/ MPC::Serializer& stream )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_SUBSITE::QueryNode::Load" );

    HRESULT hr;
	bool    fSavedNode;


	__MPC_EXIT_IF_METHOD_FAILS(hr, Node::Load( stream ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, stream >> m_fLoaded_Self);
	__MPC_EXIT_IF_METHOD_FAILS(hr, stream >> m_fTopic      );
	__MPC_EXIT_IF_METHOD_FAILS(hr, stream >>   fSavedNode  );
	if(fSavedNode)
	{
		m_qrNode.Release();
		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &m_qrNode ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, m_qrNode->Load( stream ));
		m_fQueryDone = true;
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHBehavior_SUBSITE::QueryNode::Save( /*[in]*/ MPC::Serializer& stream, /*[in]*/ bool fSaveChildren )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_SUBSITE::QueryNode::Save" );

    HRESULT hr;
	bool    fSaveNode = (m_fLoaded_Self && m_qrNode);

	if(m_fExpanded == false) fSaveChildren = false;

	__MPC_EXIT_IF_METHOD_FAILS(hr, Node::Save( stream, fSaveChildren ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, stream << m_fLoaded_Self);
	__MPC_EXIT_IF_METHOD_FAILS(hr, stream << m_fTopic      );
	__MPC_EXIT_IF_METHOD_FAILS(hr, stream <<   fSaveNode   );
	if(fSaveNode)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, m_qrNode->Save( stream ));
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

CPCHBehavior_SUBSITE::CPCHBehavior_SUBSITE()
{
    m_db      = NULL;  // CPCHProxy_IPCHTaxonomyDatabase* m_db;
	                   // CComBSTR                        m_bstrRoot;
	m_fExpand = false; // bool                            m_fExpand;
}

HRESULT CPCHBehavior_SUBSITE::RefreshThread_Enter()
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_SUBSITE::RefreshThread_Enter" );

	HRESULT hr;

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->Utility()->GetDatabase( &m_db ));

	if(m_nTopNode == NULL)
	{
		//
		// Generate the outer UI.
		//
		__MPC_EXIT_IF_METHOD_FAILS(hr, QueryNode::CreateInstance_QueryNode( this, NULL, m_nTopNode ));

		{
			QueryNode* node = (QueryNode*)m_nTopNode;

			__MPC_EXIT_IF_METHOD_FAILS(hr, node->Init        	 ( m_bstrRoot, m_fExpand ? NODETYPE__FRAME1_EXPAND : NODETYPE__FRAME2, NULL, /*fTopic*/false ));
			__MPC_EXIT_IF_METHOD_FAILS(hr, node->PopulateSelf    (                                                                                           ));
			__MPC_EXIT_IF_METHOD_FAILS(hr, node->PopulateChildren(                                                                                           ));

			node->m_parentElement = m_elem;
		}
	}

    m_nTopNode->NotifyMainThread();


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void CPCHBehavior_SUBSITE::RefreshThread_Leave()
{
    MPC::Release2<IPCHTaxonomyDatabase>( m_db );
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHBehavior_SUBSITE::Invoke( DISPID      dispidMember ,
                                           REFIID      riid         ,
                                           LCID        lcid         ,
                                           WORD        wFlags       ,
                                           DISPPARAMS* pdispparams  ,
                                           VARIANT*    pvarResult   ,
                                           EXCEPINFO*  pexcepinfo   ,
                                           UINT*       puArgErr     )
{
    if(SUCCEEDED(InterceptInvoke( dispidMember, pdispparams ))) return S_OK;

    return CPCHBehavior__IDispatch_SubSite::Invoke( dispidMember ,
												   riid         ,
												   lcid         ,
												   wFlags       ,
												   pdispparams  ,
												   pvarResult   ,
												   pexcepinfo   ,
												   puArgErr     );
}

STDMETHODIMP CPCHBehavior_SUBSITE::Init( /*[in]*/ IElementBehaviorSite* pBehaviorSite )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_SUBSITE::Init" );

    HRESULT     hr;
	CComVariant v;


    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHBehavior_BasicTree::Init( pBehaviorSite ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::COMUtil::GetPropertyByName( m_elem, L"expand", v ));
	if(SUCCEEDED(v.ChangeType( VT_BOOL )) && v.boolVal == VARIANT_TRUE) m_fExpand = true;

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::COMUtil::GetPropertyByName( m_elem, L"root", m_bstrRoot ));
	if(m_bstrRoot.Length())
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, Thread_Start( this, RefreshThread, this ));
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CPCHBehavior_SUBSITE::Load( /*[in]*/ MPC::Serializer& stream )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_SUBSITE::Load" );

    HRESULT hr;


	__MPC_EXIT_IF_METHOD_FAILS(hr, stream >> m_bstrRoot );
	__MPC_EXIT_IF_METHOD_FAILS(hr, stream >> m_lNavModel);
	__MPC_EXIT_IF_METHOD_FAILS(hr, stream >> m_fExpand  );

	//
	// Create top level node.
	//
	__MPC_EXIT_IF_METHOD_FAILS(hr, QueryNode::CreateInstance_QueryNode( this, NULL, m_nTopNode ));

	{
		QueryNode* node = (QueryNode*)m_nTopNode;

		__MPC_EXIT_IF_METHOD_FAILS(hr, node->Init( m_bstrRoot, m_fExpand ? NODETYPE__FRAME1_EXPAND : NODETYPE__FRAME2, NULL, /*fTopic*/false ));

		node->m_parentElement = m_elem;
	}
	
	__MPC_EXIT_IF_METHOD_FAILS(hr, CPCHBehavior_BasicTree::Load( stream ));


	hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHBehavior_SUBSITE::Save( /*[in]*/ MPC::Serializer& stream )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_SUBSITE::Save" );

    HRESULT hr;


	__MPC_EXIT_IF_METHOD_FAILS(hr, stream << m_bstrRoot );
	__MPC_EXIT_IF_METHOD_FAILS(hr, stream << m_lNavModel);
	__MPC_EXIT_IF_METHOD_FAILS(hr, stream << m_fExpand  );

	__MPC_EXIT_IF_METHOD_FAILS(hr, CPCHBehavior_BasicTree::Save( stream ));


	hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHBehavior_SUBSITE::get_data( /*[out, retval]*/ VARIANT *pVal )
{
	MPC::SmartLock<_ThreadModel> lock( this ); WaitForRefreshing( lock );
	QueryNode*                   node = (QueryNode*)(m_nCurrent ? m_nCurrent : m_nSelected);

	return GetAsVARIANT( node ? node->m_qrNode : NULL, pVal );
}

STDMETHODIMP CPCHBehavior_SUBSITE::get_element( /*[out, retval]*/ IDispatch* *pVal )
{
	MPC::SmartLock<_ThreadModel> lock( this ); WaitForRefreshing( lock );
	QueryNode*                   node = (QueryNode*)(m_nCurrent ? m_nCurrent : m_nSelected);

	return GetAsIDISPATCH( node ? node->m_DIV : NULL, pVal );
}

STDMETHODIMP CPCHBehavior_SUBSITE::Load( /*[in]*/ BSTR newVal )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_SUBSITE::Load" );

    HRESULT hr;


	Thread_Wait();

	__MPC_EXIT_IF_METHOD_FAILS(hr, Persist_Load( newVal ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, Thread_Start( this, RefreshThread, this ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHBehavior_SUBSITE::Save( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_SUBSITE::Save" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this ); WaitForRefreshing( lock );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


	__MPC_EXIT_IF_METHOD_FAILS(hr, Persist_Save( pVal ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHBehavior_SUBSITE::Locate( /*[in         ]*/ BSTR     bstrKey ,
										   /*[out, retval]*/ VARIANT *pVal    )
{
	MPC::SmartLock<_ThreadModel> lock( this ); WaitForRefreshing( lock );
	QueryNode*                   node = (QueryNode*)NodeFromKey( bstrKey );
	
	return GetAsVARIANT( node ? node->m_qrNode : NULL, pVal );
}

STDMETHODIMP CPCHBehavior_SUBSITE::Unselect()
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_SUBSITE::Unselect" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this ); WaitForRefreshing( lock );


	__MPC_EXIT_IF_METHOD_FAILS(hr, ChangeSelection( NULL, /*fNotify*/true ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHBehavior_SUBSITE::get_root( /*[out, retval]*/ BSTR *pVal )
{
	return MPC::GetBSTR( m_bstrRoot, pVal );
}

STDMETHODIMP CPCHBehavior_SUBSITE::put_root( /*[in]*/ BSTR pVal )
{
	__HCP_FUNC_ENTRY( "CPCHBehavior_SUBSITE::put_root" );

    HRESULT hr;


	Thread_Wait();

	Empty();
	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::PutBSTR( m_bstrRoot, pVal ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, Thread_Start( this, RefreshThread, this ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHBehavior_SUBSITE::Select( /*[in]*/ BSTR         bstrNode ,
										   /*[in]*/ BSTR         bstrURL  ,
										   /*[in]*/ VARIANT_BOOL fNotify  )
{
	__HCP_FUNC_ENTRY( "CPCHBehavior_SUBSITE::Select" );

    HRESULT  					 hr;
    MPC::SmartLock<_ThreadModel> lock( this ); WaitForRefreshing( lock );


	delete m_nToSelect; __MPC_EXIT_IF_ALLOC_FAILS(hr, m_nToSelect, new NodeToSelect);

	m_nToSelect->m_bstrNode = bstrNode;
	m_nToSelect->m_bstrURL  = bstrURL;
	m_nToSelect->m_fNotify  = fNotify == VARIANT_TRUE;

	Thread_Signal();

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\binarybehaviors\behav_handle.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Behav_HANDLE.cpp

Abstract:
    This file contains the implementation of the CPCHBehavior_HANDLE class,
    used for resizing panels.

Revision History:
    Davide Massarenti (dmassare)  07/14/2000
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

static const CPCHBehavior::EventDescription s_events[] =
{
    { L"onselectstart", DISPID_HTMLELEMENTEVENTS_ONSELECTSTART },

    { L"onmousedown"  , DISPID_HTMLELEMENTEVENTS_ONMOUSEDOWN   },
    { L"onmousemove"  , DISPID_HTMLELEMENTEVENTS_ONMOUSEMOVE   },
    { L"onmouseup"    , DISPID_HTMLELEMENTEVENTS_ONMOUSEUP     },

    { NULL                                                     },
};

////////////////////////////////////////////////////////////////////////////////

CPCHBehavior_HANDLE::CPCHBehavior_HANDLE()
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_HANDLE::CPCHBehavior_HANDLE" );

    m_fCaptured = false; // bool                m_fCaptured;
    m_xStart    = 0;     // long                m_xStart;
                         //						
                         // CComPtr<IMarsPanel> m_panel;
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHBehavior_HANDLE::Init( /*[in]*/ IElementBehaviorSite* pBehaviorSite )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_HANDLE::Init" );

    HRESULT            hr;
    CComPtr<IDispatch> pDisp;


    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHBehavior::Init( pBehaviorSite ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, AttachToEvents( s_events, (CLASS_METHOD)onMouse ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHBehavior_HANDLE::Detach()
{
    return CPCHBehavior::Detach();
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHBehavior_HANDLE::onMouse( DISPID id, DISPPARAMS*, VARIANT* )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_HANDLE::onMouse" );

    HRESULT                hr;
    CComPtr<IHTMLEventObj> ev;


    __MPC_EXIT_IF_METHOD_FAILS(hr, GetEventObject( ev ));

    switch(id)
    {
    case DISPID_HTMLELEMENTEVENTS_ONSELECTSTART:
        __MPC_EXIT_IF_METHOD_FAILS(hr, CancelEvent( ev ));
        break;

    case DISPID_HTMLELEMENTEVENTS_ONMOUSEMOVE:
        if(m_fCaptured)
        {
            long x;

            MPC_SCRIPTHELPER_GET__DIRECT(x, ev, screenX);

            if(x != m_xStart)
            {
				CComPtr<IMarsPanel> pPanel;
                RECT                rc;
                long                widthMax;
                long                widthPre;
                long                widthPost;


				__MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->GetPanel( HSCPANEL_CONTEXT, &pPanel, true ));


                ::GetClientRect( m_parent->Window(), &rc ); widthMax = (rc.right - rc.left);

                MPC_SCRIPTHELPER_GET__DIRECT(widthPre, pPanel, width);

                widthPost = widthPre + (x - m_xStart) * (m_fRTL ? -1 : 1);

                if(widthPost <             14) widthPost =            14;
                if(widthPost >= widthMax - 14) widthPost = widthMax - 14;

                if(widthPre != widthPost)
                {
                    VARIANT_BOOL fOk;

                    if(SUCCEEDED(pPanel->canResize( (widthPost - widthPre), 0, &fOk )) && fOk == VARIANT_TRUE)
                    {
                        MPC_SCRIPTHELPER_PUT__DIRECT(pPanel, width, widthPost);

                        MPC_SCRIPTHELPER_GET__DIRECT(widthPost, pPanel, width);
                    }
                    else
                    {
                        widthPost = widthPre;
                    }
                }

                m_xStart += (widthPost - widthPre) * (m_fRTL ? -1 : 1);
            }
        }
        break;

    case DISPID_HTMLELEMENTEVENTS_ONMOUSEDOWN:
		__MPC_EXIT_IF_METHOD_FAILS(hr, CancelEvent( ev ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, m_elem2->setCapture( VARIANT_TRUE ));

////		{
////			CComPtr<IHTMLWindow2>   win;
////			CComPtr<IHTMLDocument2> doc;
////			CComPtr<IHTMLElement>   body;
////			CComPtr<IHTMLStyle>     style;
////
////			__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::HTML::LocateFrame( win, m_elem, L"SubPanels" ));
////			__MPC_EXIT_IF_METHOD_FAILS(hr, win->get_document( &doc ));
////			__MPC_EXIT_IF_METHOD_FAILS(hr, doc->get_body    ( &body ));
////			__MPC_EXIT_IF_METHOD_FAILS(hr, body->get_style  ( &style ));
////
////			__MPC_EXIT_IF_METHOD_FAILS(hr, style->put_display( CComBSTR( L"NONE" ) ));
////		}

		m_fCaptured = true;

		MPC_SCRIPTHELPER_GET__DIRECT(m_xStart, ev, screenX);
        break;

    case DISPID_HTMLELEMENTEVENTS_ONMOUSEUP:
        __MPC_EXIT_IF_METHOD_FAILS(hr, CancelEvent( ev ));

        if(m_fCaptured)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_elem2->releaseCapture());

////			{
////				CComPtr<IHTMLWindow2>   win;
////				CComPtr<IHTMLDocument2> doc;
////				CComPtr<IHTMLElement>   body;
////				CComPtr<IHTMLStyle>     style;
////
////				__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::HTML::LocateFrame( win, m_elem, L"SubPanels" ));
////				__MPC_EXIT_IF_METHOD_FAILS(hr, win->get_document( &doc ));
////				__MPC_EXIT_IF_METHOD_FAILS(hr, doc->get_body    ( &body ));
////				__MPC_EXIT_IF_METHOD_FAILS(hr, body->get_style  ( &style ));
////
////				__MPC_EXIT_IF_METHOD_FAILS(hr, style->put_display( CComBSTR( L"" ) ));
////			}

            m_fCaptured = false;
        }
        break;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\binarybehaviors\behav_tree.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Behav_TREE.cpp

Abstract:
    This file contains the implementation of the CPCHBehavior_TREE class.

Revision History:
    Davide Massarenti (dmassare)  08/15/2000
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

static const WCHAR s_nodetype_FRAME1       [] = L"FRAME1"       ;
static const WCHAR s_nodetype_FRAME2       [] = L"FRAME2"       ;
static const WCHAR s_nodetype_FRAME3       [] = L"FRAME3"       ;
static const WCHAR s_nodetype_FRAME1_EXPAND[] = L"FRAME1_EXPAND";
static const WCHAR s_nodetype_FRAME2_EXPAND[] = L"FRAME2_EXPAND";
static const WCHAR s_nodetype_FRAME3_EXPAND[] = L"FRAME3_EXPAND";
static const WCHAR s_nodetype_EXPANDO      [] = L"EXPANDO"      ;
static const WCHAR s_nodetype_EXPANDO_LINK [] = L"EXPANDO_LINK" ;
static const WCHAR s_nodetype_GROUP        [] = L"GROUP"        ;
static const WCHAR s_nodetype_LINK         [] = L"LINK"         ;
static const WCHAR s_nodetype_SPACER       [] = L"SPACER"       ;

////////////////////////////////////////////////////////////////////////////////

CPCHBehavior_TREE::TreeNode::TreeNode()
{
    // CComBSTR m_bstrTitle;
    // CComBSTR m_bstrDescription;
    // CComBSTR m_bstrIcon;
    // CComBSTR m_bstrURL;
}

CPCHBehavior_TREE::TreeNode::~TreeNode()
{
    ;
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHBehavior_TREE::TreeNode::CreateInstance( /*[in]*/ CPCHBehavior_BasicTree* owner, /*[in]*/ Node* parent, /*[out]*/ Node*& subnode )
{
    return CreateInstance_TreeNode( owner, parent, subnode );
}

HRESULT CPCHBehavior_TREE::TreeNode::CreateInstance_TreeNode( /*[in]*/ CPCHBehavior_BasicTree* owner, /*[in]*/ Node* parent, /*[out]*/ Node*& subnode )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_TREE::TreeNode::CreateInstance_TreeNode" );

    HRESULT   hr;
    TreeNode* node;

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &node ));

    node->m_owner  = owner;
    node->m_parent = parent;
    hr             = S_OK;


    __HCP_FUNC_CLEANUP;

    subnode = node;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHBehavior_TREE::TreeNode::PopulateSelf()
{
    m_fLoaded_Self = true;

    return S_OK;
}

HRESULT CPCHBehavior_TREE::TreeNode::PopulateChildren()
{
    m_fLoaded_Children = true;

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHBehavior_TREE::TreeNode::GenerateSelf()
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_TREE::TreeNode::GenerateSelf" );

    HRESULT hr;


    if(!m_fLoaded_Self || !m_fLoaded_Children)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_NOT_READY);
    }

    ////////////////////

    __MPC_EXIT_IF_METHOD_FAILS(hr, GenerateHTML( m_bstrTitle, m_bstrDescription, m_bstrIcon, m_bstrURL ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHBehavior_TREE::TreeNode::Load( /*[in]*/ MPC::Serializer& stream )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_TREE::TreeNode::Load" );

    HRESULT hr;

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> m_bstrTitle      );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> m_bstrDescription);
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> m_bstrIcon       );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> m_bstrURL        );

    __MPC_EXIT_IF_METHOD_FAILS(hr, Node::Load( stream ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHBehavior_TREE::TreeNode::Save( /*[in]*/ MPC::Serializer& stream, /*[in]*/ bool fSaveChildren )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_TREE::TreeNode::Save" );

    HRESULT hr;

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << m_bstrTitle      );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << m_bstrDescription);
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << m_bstrIcon       );
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream << m_bstrURL        );

    __MPC_EXIT_IF_METHOD_FAILS(hr, Node::Save( stream, /*fSaveChildren*/true ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHBehavior_TREE::TreeNode::PopulateFromXML( /*[in]*/ CPCHBehavior_TREE* owner   ,
                                                      /*[in]*/ TreeNode*          parent  ,
                                                      /*[in]*/ IXMLDOMNode*       xdnNode )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_TREE::TreeNode::PopulateFromXML" );

    HRESULT      hr;
    MPC::XmlUtil xmlutil( xdnNode );
    TreeNode*    node = NULL;
    MPC::wstring strKey;
    CComBSTR     bstrNodeType;
    long         lExpanded;
    bool         fFound;


    __MPC_EXIT_IF_METHOD_FAILS(hr, xmlutil.GetAttribute( NULL, L"Key"     , strKey      , fFound ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, xmlutil.GetAttribute( NULL, L"NodeType", bstrNodeType, fFound ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, xmlutil.GetAttribute( NULL, L"Expanded", lExpanded   , fFound )); if(!fFound) lExpanded = 0;

    __MPC_EXIT_IF_METHOD_FAILS(hr, TreeNode::CreateInstance_TreeNode( owner, parent, (Node*&)node ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, node->Init( strKey.c_str(), LookupType( bstrNodeType ) ));

    if(node->m_iType == NODETYPE__EXPANDO && lExpanded)
    {
        node->m_fExpanded = true;
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, xmlutil.GetAttribute( NULL, L"Title"      , node->m_bstrTitle      , fFound ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, xmlutil.GetAttribute( NULL, L"Description", node->m_bstrDescription, fFound ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, xmlutil.GetAttribute( NULL, L"Icon"       , node->m_bstrIcon       , fFound ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, xmlutil.GetAttribute( NULL, L"URL"        , node->m_bstrURL        , fFound ));

    {
        CComPtr<IXMLDOMNodeList> xdnlChildren;
        CComPtr<IXMLDOMNode>     xdnChild;

        __MPC_EXIT_IF_METHOD_FAILS(hr, xmlutil.GetNodes( L"NODE", &xdnlChildren ));
        for(;SUCCEEDED(hr = xdnlChildren->nextNode( &xdnChild )) && xdnChild != NULL; xdnChild.Release())
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, PopulateFromXML( owner, node, xdnChild ));
        }
    }


    if(parent)
    {
        parent->m_lstSubnodes.push_back( node );
    }
    else
    {
        node->m_parentElement = owner->m_elem;
        owner->m_nTopNode     = node;
    }

    node = NULL;
    hr   = S_OK;


    __HCP_FUNC_CLEANUP;

    MPC::Release( node );

    __HCP_FUNC_EXIT(hr);

}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

CPCHBehavior_TREE::NodeType CPCHBehavior_TREE::LookupType( /*[in]*/ LPCWSTR szNodeType )
{
    if(szNodeType)
    {
        if(!_wcsicmp( szNodeType, s_nodetype_FRAME1       )) return NODETYPE__FRAME1       ;
        if(!_wcsicmp( szNodeType, s_nodetype_FRAME2       )) return NODETYPE__FRAME2       ;
        if(!_wcsicmp( szNodeType, s_nodetype_FRAME3       )) return NODETYPE__FRAME3       ;
        if(!_wcsicmp( szNodeType, s_nodetype_FRAME1_EXPAND)) return NODETYPE__FRAME1_EXPAND;
        if(!_wcsicmp( szNodeType, s_nodetype_FRAME2_EXPAND)) return NODETYPE__FRAME2_EXPAND;
        if(!_wcsicmp( szNodeType, s_nodetype_FRAME3_EXPAND)) return NODETYPE__FRAME3_EXPAND;
        if(!_wcsicmp( szNodeType, s_nodetype_EXPANDO      )) return NODETYPE__EXPANDO      ;
        if(!_wcsicmp( szNodeType, s_nodetype_EXPANDO_LINK )) return NODETYPE__EXPANDO_LINK ;
        if(!_wcsicmp( szNodeType, s_nodetype_GROUP        )) return NODETYPE__GROUP        ;
        if(!_wcsicmp( szNodeType, s_nodetype_LINK         )) return NODETYPE__LINK         ;
        if(!_wcsicmp( szNodeType, s_nodetype_SPACER       )) return NODETYPE__SPACER       ;
    }

    return NODETYPE__EXPANDO;
}

LPCWSTR CPCHBehavior_TREE::LookupType( /*[in]*/ NodeType iNodeType )
{
    switch(iNodeType)
    {
    case NODETYPE__FRAME1       : return s_nodetype_FRAME1       ;
    case NODETYPE__FRAME2       : return s_nodetype_FRAME2       ;
    case NODETYPE__FRAME3       : return s_nodetype_FRAME3       ;
    case NODETYPE__FRAME1_EXPAND: return s_nodetype_FRAME1_EXPAND;
    case NODETYPE__FRAME2_EXPAND: return s_nodetype_FRAME2_EXPAND;
    case NODETYPE__FRAME3_EXPAND: return s_nodetype_FRAME3_EXPAND;
    case NODETYPE__EXPANDO     	: return s_nodetype_EXPANDO      ;
    case NODETYPE__EXPANDO_LINK	: return s_nodetype_EXPANDO_LINK ;
    case NODETYPE__GROUP       	: return s_nodetype_GROUP        ;
    case NODETYPE__LINK        	: return s_nodetype_LINK         ;
    case NODETYPE__SPACER      	: return s_nodetype_SPACER       ;
    }

    return NULL;
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHBehavior_TREE::RefreshThread_Enter()
{
    Thread_Signal(); // This forces a refresh of the state.

    return S_OK;
}

void CPCHBehavior_TREE::RefreshThread_Leave()
{
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHBehavior_TREE::Invoke( DISPID      dispidMember ,
                                           REFIID      riid         ,
                                           LCID        lcid         ,
                                           WORD        wFlags       ,
                                           DISPPARAMS* pdispparams  ,
                                           VARIANT*    pvarResult   ,
                                           EXCEPINFO*  pexcepinfo   ,
                                           UINT*       puArgErr     )
{
    if(SUCCEEDED(InterceptInvoke( dispidMember, pdispparams ))) return S_OK;

    return CPCHBehavior__IDispatch_Tree::Invoke( dispidMember ,
                                                    riid         ,
                                                    lcid         ,
                                                    wFlags       ,
                                                    pdispparams  ,
                                                    pvarResult   ,
                                                    pexcepinfo   ,
                                                    puArgErr     );
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHBehavior_TREE::Init( /*[in]*/ IElementBehaviorSite* pBehaviorSite )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_TREE::Init" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHBehavior_BasicTree::Init( pBehaviorSite ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, Thread_Start( this, RefreshThread, this ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHBehavior_TREE::Load( /*[in]*/ MPC::Serializer& stream )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_TREE::Load" );

    HRESULT hr;


    //
    // Create top level node.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, TreeNode::CreateInstance_TreeNode( this, NULL, m_nTopNode ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_nTopNode->Init( NULL ));

    m_nTopNode->m_parentElement = m_elem;


    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHBehavior_BasicTree::Load( stream ));


    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHBehavior_TREE::Save( /*[in]*/ MPC::Serializer& stream )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_TREE::Save" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHBehavior_BasicTree::Save( stream ));


    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHBehavior_TREE::WrapData( /*[in]*/ TreeNode* node, /*[out, retval]*/ VARIANT* pVal )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_TREE::WrapData" );

    HRESULT                hr;
    CPCHBehavior_TREENODE* obj  = NULL;


    if(node)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &obj ));

        MPC::Attach( obj->m_data, node );
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetAsVARIANT( obj, pVal ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    MPC::Release( obj );

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHBehavior_TREE::get_data( /*[out, retval]*/ VARIANT* pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this ); WaitForRefreshing( lock );

    return WrapData( (TreeNode*)(m_nCurrent ? m_nCurrent : m_nSelected), pVal );
}

STDMETHODIMP CPCHBehavior_TREE::get_element( /*[out, retval]*/ IDispatch* *pVal )
{
    MPC::SmartLock<_ThreadModel> lock( this ); WaitForRefreshing( lock );
    TreeNode*                    node = (TreeNode*)(m_nCurrent ? m_nCurrent : m_nSelected);

    return GetAsIDISPATCH( node ? node->m_DIV : NULL, pVal );
}

STDMETHODIMP CPCHBehavior_TREE::Load( /*[in]*/ BSTR newVal )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_TREE::Load" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this ); WaitForRefreshing( lock );


    __MPC_EXIT_IF_METHOD_FAILS(hr, Persist_Load( newVal )); Thread_Signal();


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHBehavior_TREE::Save( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_TREE::Save" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this ); WaitForRefreshing( lock );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, Persist_Save( pVal ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHBehavior_TREE::Locate( /*[in         ]*/ BSTR     bstrKey ,
                                        /*[out, retval]*/ VARIANT *pVal    )
{
    MPC::SmartLock<_ThreadModel> lock( this ); WaitForRefreshing( lock );
    Node*                        node = NodeFromKey( bstrKey );

    return WrapData( (TreeNode*)node, pVal );
}

STDMETHODIMP CPCHBehavior_TREE::Unselect()
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_TREE::Load" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this ); WaitForRefreshing( lock );


	__MPC_EXIT_IF_METHOD_FAILS(hr, ChangeSelection( NULL, /*fNotify*/true ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////

STDMETHODIMP CPCHBehavior_TREE::Populate( /*[in]*/ VARIANT newVal )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_TREE::Populate" );

    HRESULT                      hr;
    CComPtr<IXMLDOMNode>         xdnRoot;
    MPC::SmartLock<_ThreadModel> lock( this ); WaitForRefreshing( lock );


    Empty();


    if(newVal.vt == VT_BSTR)
    {
        MPC::XmlUtil xmlutil;
        bool         fLoaded;

        __MPC_EXIT_IF_METHOD_FAILS(hr, xmlutil.LoadAsString( newVal.bstrVal, L"NODE", fLoaded ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, xmlutil.GetRoot( &xdnRoot ));
    }
    else if(newVal.vt == VT_UNKNOWN && newVal.punkVal)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, newVal.punkVal->QueryInterface( __uuidof(xdnRoot), (void**)&xdnRoot ));
    }
    else if(newVal.vt == VT_DISPATCH && newVal.pdispVal)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, newVal.punkVal->QueryInterface( __uuidof(xdnRoot), (void**)&xdnRoot ));
    }

    if(xdnRoot)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHBehavior_TREE::TreeNode::PopulateFromXML( this, NULL, xdnRoot ));
    }

    Thread_Signal();

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

CPCHBehavior_TREENODE::CPCHBehavior_TREENODE()
{
    m_data = NULL; // CPCHBehavior_TREE::TreeNode* m_data;
}

CPCHBehavior_TREENODE::~CPCHBehavior_TREENODE()
{
    MPC::Release( m_data );
}

STDMETHODIMP CPCHBehavior_TREENODE::get_Type       ( /*[out, retval]*/ BSTR *pVal ) { return MPC::GetBSTR( CPCHBehavior_TREE::LookupType( m_data->m_iType          ), pVal ); }
STDMETHODIMP CPCHBehavior_TREENODE::get_Key        ( /*[out, retval]*/ BSTR *pVal ) { return MPC::GetBSTR(                                m_data->m_bstrNode        , pVal ); }
STDMETHODIMP CPCHBehavior_TREENODE::get_Title      ( /*[out, retval]*/ BSTR *pVal ) { return MPC::GetBSTR(                                m_data->m_bstrTitle       , pVal ); }
STDMETHODIMP CPCHBehavior_TREENODE::get_Description( /*[out, retval]*/ BSTR *pVal ) { return MPC::GetBSTR(                                m_data->m_bstrDescription , pVal ); }
STDMETHODIMP CPCHBehavior_TREENODE::get_Icon       ( /*[out, retval]*/ BSTR *pVal ) { return MPC::GetBSTR(                                m_data->m_bstrIcon        , pVal ); }
STDMETHODIMP CPCHBehavior_TREENODE::get_URL        ( /*[out, retval]*/ BSTR *pVal ) { return MPC::GetBSTR(                                m_data->m_bstrURL         , pVal ); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\binarybehaviors\factories.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Factories.h

Abstract:
    This file contains the declaration of various binary behaviors.

Revision History:
    Davide Massarenti   (Dmassare)  07/12/2000
        created

******************************************************************************/

#if !defined(__INCLUDED___PCH___FACTORIES_H___)
#define __INCLUDED___PCH___FACTORIES_H___

#include <Behaviors.h>

//
// From BehaviorsTypeLib.idl
//
#include <BehaviorsTypeLib.h>

#define INCREASESIZE(x) x.reserve( (x.size() + 4097) & ~4095 )

////////////////////////////////////////////////////////////////////////////////

typedef IDispatchImpl<IPCHBehaviors_Common  , &IID_IPCHBehaviors_Common  , &LIBID_BehaviorsTypeLib> CPCHBehavior__IDispatch_Event;
typedef IDispatchImpl<IPCHBehaviors_SubSite , &IID_IPCHBehaviors_SubSite , &LIBID_BehaviorsTypeLib> CPCHBehavior__IDispatch_SubSite;
typedef IDispatchImpl<IPCHBehaviors_Tree    , &IID_IPCHBehaviors_Tree    , &LIBID_BehaviorsTypeLib> CPCHBehavior__IDispatch_Tree;
typedef IDispatchImpl<IPCHBehaviors_TreeNode, &IID_IPCHBehaviors_TreeNode, &LIBID_BehaviorsTypeLib> CPCHBehavior__IDispatch_TreeNode;
typedef IDispatchImpl<IPCHBehaviors_Context , &IID_IPCHBehaviors_Context , &LIBID_BehaviorsTypeLib> CPCHBehavior__IDispatch_Context;
typedef IDispatchImpl<IPCHBehaviors_State   , &IID_IPCHBehaviors_State   , &LIBID_BehaviorsTypeLib> CPCHBehavior__IDispatch_State;

////////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHBehavior_EVENT : public CPCHBehavior, public CPCHBehavior__IDispatch_Event
{
    long                 m_lCookieIN;
    LONG*                m_lCookieOUT;

    CComQIPtr<IPCHEvent> m_evCurrent;

    ////////////////////

    HRESULT onFire( DISPID, DISPPARAMS*, VARIANT* );


public:
BEGIN_COM_MAP(CPCHBehavior_EVENT)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHBehaviors_Common)
    COM_INTERFACE_ENTRY_CHAIN(CPCHBehavior)
END_COM_MAP()

    CPCHBehavior_EVENT();
    virtual ~CPCHBehavior_EVENT();

    //
    // IElementBehavior
    //
    STDMETHOD(Init  )( /*[in]*/ IElementBehaviorSite* pBehaviorSite );
    STDMETHOD(Detach)(                                              );

    //
    // IPCHBehaviors_Common
    //
    STDMETHOD(get_data   )( /*[out, retval]*/ VARIANT    *pVal );
    STDMETHOD(get_element)( /*[out, retval]*/ IDispatch* *pVal );

    STDMETHOD(Load    )(                        /*[in         ]*/ BSTR     newVal );
    STDMETHOD(Save    )(                        /*[out, retval]*/ BSTR    *pVal   );
    STDMETHOD(Locate  )( /*[in]*/ BSTR bstrKey, /*[out, retval]*/ VARIANT *pVal   );
    STDMETHOD(Unselect)(                                                          );
};

/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHBehavior_BODY : public CPCHBehavior
{
    HRESULT onEvent( DISPID, DISPPARAMS*, VARIANT* );

    ////////////////////

public:
    CPCHBehavior_BODY();

    //
    // IElementBehavior
    //
    STDMETHOD(Init)( /*[in]*/ IElementBehaviorSite* pBehaviorSite );
};

/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHBehavior_A : public CPCHBehavior
{
    HRESULT onClick( DISPID, DISPPARAMS*, VARIANT* );

    HRESULT onMouseMovement( DISPID, DISPPARAMS*, VARIANT* );

public:
    CPCHBehavior_A();

    //
    // IElementBehavior
    //
    STDMETHOD(Init)( /*[in]*/ IElementBehaviorSite* pBehaviorSite );
};

/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHBehavior_HANDLE : public CPCHBehavior
{
    bool m_fCaptured;
    long m_xStart;

    ////////////////////

    HRESULT onMouse( DISPID, DISPPARAMS*, VARIANT* );

public:
    CPCHBehavior_HANDLE();

    //
    // IElementBehavior
    //
    STDMETHOD(Init  )( /*[in]*/ IElementBehaviorSite* pBehaviorSite );
    STDMETHOD(Detach)(                                              );
};

/////////////////////////////////////////////////////////////////////////////

////class ATL_NO_VTABLE CPCHBehavior_TOPLEVEL : public CPCHBehavior, public CPCHBehavior__IDispatch_SubSite
////{
////    struct Node;
////    friend struct Node;
////
////    typedef std::list< Node* >   List;
////    typedef List::iterator       Iter;
////    typedef List::const_iterator IterConst;
////
////    ////////////////////////////////////////
////
////    struct Node : public CComObjectRootEx<MPC::CComSafeMultiThreadModel>, public IUnknown
////    {
////        CPCHBehavior_TOPLEVEL*   m_owner;
////        CComPtr<CPCHQueryResult> m_qrNode;
////
////        CComPtr<IHTMLElement>    m_TR_title;
////        CComPtr<IHTMLElement>    m_TR_description;
////        CComPtr<IHTMLElement>    m_TD_title;
////        CComPtr<IHTMLElement>    m_TD_description;
////
////        ////////////////////
////
////        BEGIN_COM_MAP(Node)
////             COM_INTERFACE_ENTRY(IUnknown)
////        END_COM_MAP()
////
////        Node();
////
////        void Detach();
////    };
////
////    ////////////////////////////////////////
////
////    long          m_lCookie_onClick;
////    long          m_lCookie_onContextSelect;
////    long          m_lCookie_onSelect;
////    long          m_lCookie_onUnselect;
////
////    CComBSTR      m_bstrRoot;
////    CComPtr<Node> m_selectedNode;
////    List          m_lstNodes;
////
////    ////////////////////
////
////    HRESULT onMouse( DISPID, DISPPARAMS*, VARIANT* );
////
////    void FromElementToNode( /*[in/out]*/ CComPtr<Node>& node, /*[in]*/ IHTMLElement* elem );
////
////    void Empty();
////
////public:
////BEGIN_COM_MAP(CPCHBehavior_TOPLEVEL)
////    COM_INTERFACE_ENTRY(IDispatch)
////    COM_INTERFACE_ENTRY(IPCHBehaviors_Common)
////    COM_INTERFACE_ENTRY_CHAIN(CPCHBehavior)
////END_COM_MAP()
////
////    CPCHBehavior_TOPLEVEL();
////    ~CPCHBehavior_TOPLEVEL();
////
////    //
////    // IElementBehavior
////    //
////    STDMETHOD(Init  )( /*[in]*/ IElementBehaviorSite* pBehaviorSite );
////    STDMETHOD(Detach)(                                              );
////
////
////    //
////    // IPCHBehaviors_Common
////    //
////    STDMETHOD(get_data   )( /*[out, retval]*/ VARIANT    *pVal );
////    STDMETHOD(get_element)( /*[out, retval]*/ IDispatch* *pVal );
////
////    STDMETHOD(Refresh)(                                                          );
////    STDMETHOD(Load   )(                        /*[in         ]*/ BSTR     newVal );
////    STDMETHOD(Save   )(                        /*[out, retval]*/ BSTR    *pVal   );
////    STDMETHOD(Locate )( /*[in]*/ BSTR bstrKey, /*[out, retval]*/ VARIANT *pVal   );
////
////    //
////    // IPCHBehaviors_SubSite
////    //
////    STDMETHOD(get_root)( /*[out, retval]*/ BSTR *pVal   );
////    STDMETHOD(put_root)( /*[in         ]*/ BSTR  newVal );
////
////    STDMETHOD(Select)( /*[in]*/ BSTR bstrNode, /*[in]*/ BSTR bstrURL, /*[in]*/ VARIANT_BOOL fNotify );
////};

/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHBehavior_BasicTree : public CPCHBehavior, public MPC::Thread<CPCHBehavior_BasicTree,IDispatch>
{
protected:
    struct Node;
    friend struct Node;

    typedef std::list< Node* >   List;
    typedef List::iterator       Iter;
    typedef List::const_iterator IterConst;

    ////////////////////////////////////////

    typedef enum
    {
        NODETYPE__FRAME1       ,
        NODETYPE__FRAME2       ,
        NODETYPE__FRAME3       ,
        NODETYPE__FRAME1_EXPAND,
        NODETYPE__FRAME2_EXPAND,
        NODETYPE__FRAME3_EXPAND,
        NODETYPE__EXPANDO      ,
        NODETYPE__EXPANDO_LINK ,
        NODETYPE__EXPANDO_TOPIC,
        NODETYPE__GROUP        ,
        NODETYPE__LINK         ,
        NODETYPE__SPACER       ,
    } NodeType;

    typedef enum
    {
        SELECTION__NONE             ,
        SELECTION__ACTIVE           ,
        SELECTION__NEXTACTIVE       ,
        SELECTION__NEXTACTIVE_NOTIFY,
    } SelectionMode;

    struct Node : public CComObjectRootEx<MPC::CComSafeMultiThreadModel>, public IUnknown
    {
        CPCHBehavior_BasicTree*  m_owner;
        Node*                    m_parent;
        CComBSTR                 m_bstrNode;
        NodeType                 m_iType;
        SelectionMode            m_iSelection;

        bool                     m_fLoaded_Self;
        bool                     m_fLoaded_Children;
        bool                     m_fDisplayed_Self;
        bool                     m_fDisplayed_Children;
        bool                     m_fInvalid;
        bool                     m_fRefreshNotification;

        bool                     m_fExpanded;
        bool                     m_fMouseOver;
        bool                     m_fMouseDown;

        CComPtr<IHTMLElement>    m_parentElement;
        CComBSTR                 m_bstrID;

        CComPtr<IHTMLElement>    m_DIV;
        CComPtr<IHTMLElement>    m_IMG;
        CComPtr<IHTMLElement>    m_DIV_children;

        List                     m_lstSubnodes;

        ////////////////////

        BEGIN_COM_MAP(Node)
             COM_INTERFACE_ENTRY(IUnknown)
        END_COM_MAP()

        Node();
        virtual ~Node();

        HRESULT Init( /*[in]*/ LPCWSTR szNode, /*[in]*/ NodeType iType = NODETYPE__EXPANDO );

        HRESULT NotifyMainThread();

        Node*   FindNode( /*[in]*/ LPCWSTR szNode, /*[in]*/ bool fUseID );

        HRESULT OnMouse( /*[in]*/ DISPID id, /*[in]*/ long lButton, /*[in]*/ long lKey, /*[in]*/ bool fIsImage );

        HRESULT LoadHTML( /*[in]*/ LPCWSTR szHTML );
        HRESULT GenerateHTML( /*[in]*/ LPCWSTR szTitle, /*[in]*/ LPCWSTR szDescription, /*[in]*/ LPCWSTR szIcon, /*[in]*/ LPCWSTR szURL );

        void InsertOptionalTarget( /*[in/out]*/ MPC::wstring& strHTML );

        ////////////////////

        virtual HRESULT Passivate            (                                                                                         );
        virtual HRESULT ProcessRefreshRequest(                                                                                         );
        virtual HRESULT CreateInstance       ( /*[in]*/ CPCHBehavior_BasicTree* owner, /*[in]*/ Node* parent, /*[out]*/ Node*& subnode ) = 0;
        virtual HRESULT PopulateSelf         (                                                                                         ) = 0;
        virtual HRESULT PopulateChildren     (                                                                                         ) = 0;
        virtual HRESULT GenerateSelf         (                                                                                         ) = 0;
        virtual HRESULT GenerateChildren     (                                                                                         );
        virtual HRESULT Display              (                                                                                         );
        virtual bool    IsParentDisplayingUs (                                                                                         );

        virtual HRESULT Load( /*[in]*/ MPC::Serializer& stream                              );
        virtual HRESULT Save( /*[in]*/ MPC::Serializer& stream, /*[in]*/ bool fSaveChildren );
    };

    struct NodeToSelect
    {
        CComBSTR m_bstrNode;
        CComBSTR m_bstrURL;
        bool     m_fNotify;
    };


    ////////////////////

    CComBSTR        m_bstrTargetFrame;

    long            m_lCookie_onContextSelect;
    long            m_lCookie_onSelect;
    long            m_lCookie_onUnselect;

    Node*           m_nTopNode;
    Node*           m_nSelected;
    Node*           m_nCurrent;
    NodeToSelect*   m_nToSelect;
    CPCHTimerHandle m_Timer;

    bool            m_fRefreshing;
    long            m_lNavModel;

    ////////////////////

    void Empty              ();
    void ProtectFromDetach  ();
    void UnprotectFromDetach();

    HRESULT onMouse( DISPID, DISPPARAMS*, VARIANT* );

    HRESULT RefreshThread    (                                                                           );
    void    SetRefreshingFlag( /*[in]*/ bool                          fVal                               );
    void    WaitForRefreshing( /*[in]*/ MPC::SmartLock<_ThreadModel>& lock, /*[in]*/ bool fYield = false );
    HRESULT NotifyMainThread ( /*[in]*/ Node*                         node                               );
    HRESULT ChangeSelection  ( /*[in]*/ Node*                         node, /*[in]*/ bool fNotify        );

    Node* NodeFromElement( /*[in]*/ IHTMLElement* elem                                 );
    Node* NodeFromKey    ( /*[in]*/ LPCWSTR       szNode, /*[in]*/ bool fUseID = false );

    HRESULT InterceptInvoke( /*[in]*/ DISPID dispidMember, /*[in]*/ DISPPARAMS* pdispparams );

    HRESULT TimerCallback_ScrollIntoView( /*[in]*/ VARIANT );

    ////////////////////

    virtual HRESULT RefreshThread_Enter() = 0;
    virtual void    RefreshThread_Leave() = 0;

    virtual HRESULT Load( /*[in]*/ MPC::Serializer& stream );
    virtual HRESULT Save( /*[in]*/ MPC::Serializer& stream );

    HRESULT Persist_Load( /*[in         ]*/ BSTR  newVal );
    HRESULT Persist_Save( /*[out, retval]*/ BSTR *pVal   );

public:
    CPCHBehavior_BasicTree();
    ~CPCHBehavior_BasicTree();

    void          SetNavModel    ( /*[in]*/ long lNavModel ) { if(lNavModel != QR_DEFAULT) m_lNavModel = lNavModel; }
    long          GetNavModel    (                         ) { return m_lNavModel;                                  }
    NodeToSelect* GetNodeToSelect(                         ) { return m_nToSelect;                                  }
    bool          IsRTL          (                         ) { return m_fRTL;                                       }

    //
    // IElementBehavior
    //
    STDMETHOD(Init  )( /*[in]*/ IElementBehaviorSite* pBehaviorSite );
    STDMETHOD(Detach)(                                              );
};

/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHBehavior_SUBSITE : public CPCHBehavior_BasicTree, public CPCHBehavior__IDispatch_SubSite
{
protected:
    struct QueryNode;
    friend struct QueryNode;

    ////////////////////////////////////////

    struct QueryNode : public CPCHBehavior_BasicTree::Node
    {
        CComPtr<CPCHQueryResult> m_qrNode;
        bool                     m_fQueryDone;
        bool                     m_fTopic;

        ////////////////////

    public:
        QueryNode();
        virtual ~QueryNode();

        HRESULT Init( /*[in]*/ LPCWSTR szNode, /*[in]*/ NodeType iType, /*[in]*/ CPCHQueryResult* qr, /*[in]*/ bool fTopic );

        virtual HRESULT ProcessRefreshRequest(                                                                                         );
        virtual HRESULT CreateInstance       ( /*[in]*/ CPCHBehavior_BasicTree* owner, /*[in]*/ Node* parent, /*[out]*/ Node*& subnode );
        virtual HRESULT PopulateSelf         (                                                                                         );
        virtual HRESULT PopulateChildren     (                                                                                         );
        virtual HRESULT GenerateSelf         (                                                                                         );

        virtual HRESULT Load( /*[in]*/ MPC::Serializer& stream                              );
        virtual HRESULT Save( /*[in]*/ MPC::Serializer& stream, /*[in]*/ bool fSaveChildren );

        static HRESULT CreateInstance_QueryNode( /*[in]*/ CPCHBehavior_BasicTree* owner, /*[in]*/ Node* parent, /*[out]*/ Node*& subnode );
    };

    ////////////////////

    CPCHProxy_IPCHTaxonomyDatabase* m_db;
    CComBSTR                        m_bstrRoot;
    bool                            m_fExpand;

    ////////////////////

    virtual HRESULT RefreshThread_Enter();
    virtual void    RefreshThread_Leave();

    virtual HRESULT Load( /*[in]*/ MPC::Serializer& stream );
    virtual HRESULT Save( /*[in]*/ MPC::Serializer& stream );

public:
BEGIN_COM_MAP(CPCHBehavior_SUBSITE)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHBehaviors_Common)
    COM_INTERFACE_ENTRY(IPCHBehaviors_SubSite)
    COM_INTERFACE_ENTRY_CHAIN(CPCHBehavior_BasicTree)
END_COM_MAP()

    CPCHBehavior_SUBSITE();

    //
    // IDispatch
    //
    STDMETHOD(Invoke)( DISPID      dispidMember ,
                       REFIID      riid         ,
                       LCID        lcid         ,
                       WORD        wFlags       ,
                       DISPPARAMS* pdispparams  ,
                       VARIANT*    pvarResult   ,
                       EXCEPINFO*  pexcepinfo   ,
                       UINT*       puArgErr     );

    // IElementBehavior
    //
    STDMETHOD(Init)( /*[in]*/ IElementBehaviorSite* pBehaviorSite );

    //
    // IPCHBehaviors_Common
    //
    STDMETHOD(get_data   )( /*[out, retval]*/ VARIANT    *pVal );
    STDMETHOD(get_element)( /*[out, retval]*/ IDispatch* *pVal );

    STDMETHOD(Load    )(                        /*[in         ]*/ BSTR     newVal );
    STDMETHOD(Save    )(                        /*[out, retval]*/ BSTR    *pVal   );
    STDMETHOD(Locate  )( /*[in]*/ BSTR bstrKey, /*[out, retval]*/ VARIANT *pVal   );
    STDMETHOD(Unselect)(                                                          );

    //
    // IPCHBehaviors_SubSite
    //
    STDMETHOD(get_root)( /*[out, retval]*/ BSTR *pVal   );
    STDMETHOD(put_root)( /*[in         ]*/ BSTR  newVal );

    STDMETHOD(Select)( /*[in]*/ BSTR bstrNode, /*[in]*/ BSTR bstrURL, /*[in]*/ VARIANT_BOOL fNotify );
};

/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHBehavior_TREE : public CPCHBehavior_BasicTree, public CPCHBehavior__IDispatch_Tree
{
protected:
    struct TreeNode;
    friend struct TreeNode;
    friend class CPCHBehavior_TREENODE;

    ////////////////////////////////////////

    struct TreeNode : public CPCHBehavior_BasicTree::Node
    {
        CComBSTR m_bstrTitle;
        CComBSTR m_bstrDescription;
        CComBSTR m_bstrIcon;
        CComBSTR m_bstrURL;

        ////////////////////

    public:
        TreeNode();
        virtual ~TreeNode();

        virtual HRESULT CreateInstance  ( /*[in]*/ CPCHBehavior_BasicTree* owner, /*[in]*/ Node* parent, /*[out]*/ Node*& subnode );
        virtual HRESULT PopulateSelf    (                                                                                         );
        virtual HRESULT PopulateChildren(                                                                                         );
        virtual HRESULT GenerateSelf    (                                                                                         );

        virtual HRESULT Load( /*[in]*/ MPC::Serializer& stream                              );
        virtual HRESULT Save( /*[in]*/ MPC::Serializer& stream, /*[in]*/ bool fSaveChildren );

        static HRESULT CreateInstance_TreeNode( /*[in]*/ CPCHBehavior_BasicTree* owner, /*[in]*/ Node* parent, /*[out]*/ Node*& subnode );

        static HRESULT PopulateFromXML( /*[in]*/ CPCHBehavior_TREE* owner, /*[in]*/ TreeNode* parent, /*[in]*/ IXMLDOMNode* xdnNode );
    };

    ////////////////////

    virtual HRESULT RefreshThread_Enter();
    virtual void    RefreshThread_Leave();

    virtual HRESULT Load( /*[in]*/ MPC::Serializer& stream );
    virtual HRESULT Save( /*[in]*/ MPC::Serializer& stream );

    HRESULT WrapData( /*[in]*/ TreeNode* node, /*[out, retval]*/ VARIANT* pVal );

public:
BEGIN_COM_MAP(CPCHBehavior_TREE)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHBehaviors_Common)
    COM_INTERFACE_ENTRY(IPCHBehaviors_Tree)
    COM_INTERFACE_ENTRY_CHAIN(CPCHBehavior_BasicTree)
END_COM_MAP()

    static NodeType LookupType( /*[in]*/ LPCWSTR  szNodeType );
    static LPCWSTR  LookupType( /*[in]*/ NodeType iNodeType  );

    //
    // IDispatch
    //
    STDMETHOD(Invoke)( DISPID      dispidMember ,
                       REFIID      riid         ,
                       LCID        lcid         ,
                       WORD        wFlags       ,
                       DISPPARAMS* pdispparams  ,
                       VARIANT*    pvarResult   ,
                       EXCEPINFO*  pexcepinfo   ,
                       UINT*       puArgErr     );

    //
    // IElementBehavior
    //
    STDMETHOD(Init)( /*[in]*/ IElementBehaviorSite* pBehaviorSite );

    //
    // IPCHBehaviors_Common
    //
    STDMETHOD(get_data   )( /*[out, retval]*/ VARIANT    *pVal );
    STDMETHOD(get_element)( /*[out, retval]*/ IDispatch* *pVal );

    STDMETHOD(Load    )(                        /*[in         ]*/ BSTR     newVal );
    STDMETHOD(Save    )(                        /*[out, retval]*/ BSTR    *pVal   );
    STDMETHOD(Locate  )( /*[in]*/ BSTR bstrKey, /*[out, retval]*/ VARIANT *pVal   );
    STDMETHOD(Unselect)(                                                          );

    //
    // IPCHBehaviors_Tree
    //
    STDMETHOD(Populate)( /*[in]*/ VARIANT newVal );
};

class ATL_NO_VTABLE CPCHBehavior_TREENODE : public CComObjectRootEx<MPC::CComSafeMultiThreadModel>, public CPCHBehavior__IDispatch_TreeNode
{
    friend class CPCHBehavior_TREE;

    CPCHBehavior_TREE::TreeNode* m_data;

public:
BEGIN_COM_MAP(CPCHBehavior_TREENODE)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHBehaviors_TreeNode)
END_COM_MAP()

    CPCHBehavior_TREENODE();
    ~CPCHBehavior_TREENODE();

    //
    // IPCHBehaviors_TreeNode
    //
    STDMETHOD(get_Type       )( /*[out, retval]*/ BSTR *pVal );
    STDMETHOD(get_Key        )( /*[out, retval]*/ BSTR *pVal );
    STDMETHOD(get_Title      )( /*[out, retval]*/ BSTR *pVal );
    STDMETHOD(get_Description)( /*[out, retval]*/ BSTR *pVal );
    STDMETHOD(get_Icon       )( /*[out, retval]*/ BSTR *pVal );
    STDMETHOD(get_URL        )( /*[out, retval]*/ BSTR *pVal );
};

/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHBehavior_CONTEXT : public CPCHBehavior, public CPCHBehavior__IDispatch_Context
{
public:
BEGIN_COM_MAP(CPCHBehavior_CONTEXT)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHBehaviors_Context)
    COM_INTERFACE_ENTRY_CHAIN(CPCHBehavior)
END_COM_MAP()

    //
    // IElementBehavior
    //
    STDMETHOD(Init)( /*[in]*/ IElementBehaviorSite* pBehaviorSite );

    //
    // IPCHBehaviors_TreeNode
    //
    STDMETHOD(get_minimized)( /*[out, retval]*/ VARIANT_BOOL *pVal   );
    STDMETHOD(put_minimized)( /*[in         ]*/ VARIANT_BOOL  newVal );
    STDMETHOD(get_maximized)( /*[out, retval]*/ VARIANT_BOOL *pVal   );
    STDMETHOD(put_maximized)( /*[in         ]*/ VARIANT_BOOL  newVal );

    STDMETHOD(get_x        )( /*[out, retval]*/ long         *pVal   );
    STDMETHOD(get_y        )( /*[out, retval]*/ long         *pVal   );
    STDMETHOD(get_width    )( /*[out, retval]*/ long         *pVal   );
    STDMETHOD(get_height   )( /*[out, retval]*/ long         *pVal   );

    STDMETHOD(changeContext      )( /*[in]*/ BSTR bstrName, /*[in,optional]*/ VARIANT vInfo, /*[in,optional]*/ VARIANT vURL );
    STDMETHOD(setWindowDimensions)( /*[in]*/ long lX, /*[in]*/ long lY, /*[in]*/ long lW, /*[in]*/ long lH );
    STDMETHOD(bringToForeground  )();
};

/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHBehavior_STATE : public CPCHBehavior, public CPCHBehavior__IDispatch_State
{
    long     m_lCookie_PERSISTLOAD;
    long     m_lCookie_PERSISTSAVE;
    CComBSTR m_bstrIdentity;

    ////////////////////

    HRESULT onPersistLoad( DISPID, DISPPARAMS*, VARIANT* );
    HRESULT onPersistSave( DISPID, DISPPARAMS*, VARIANT* );

public:
BEGIN_COM_MAP(CPCHBehavior_STATE)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHBehaviors_State)
    COM_INTERFACE_ENTRY_CHAIN(CPCHBehavior)
END_COM_MAP()

    CPCHBehavior_STATE();

    //
    // IElementBehavior
    //
    STDMETHOD(Init  )( /*[in]*/ IElementBehaviorSite* pBehaviorSite     );
    STDMETHOD(Notify)( /*[in]*/ LONG lEvent, /*[in/out]*/ VARIANT* pVar );
    STDMETHOD(Detach)(                                                  );

    //
    // IPCHBehaviors_State
    //
    STDMETHOD(get_stateProperty)( /*[in]*/ BSTR bstrName, /*[out, retval]*/ VARIANT *pVal   );
    STDMETHOD(put_stateProperty)( /*[in]*/ BSTR bstrName, /*[in]         */ VARIANT  newVal );
};

/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHBehavior_GRADIENT : public CPCHBehavior, public IHTMLPainter
{
    long     m_lCookie;

    COLORREF m_clsStart;
    COLORREF m_clsEnd;
    bool     m_fHorizontal;
    bool     m_fReturnToZero;

    void GetColors( /*[in]*/ bool fForce );

    HRESULT onEvent( DISPID, DISPPARAMS*, VARIANT* );

    ////////////////////

public:
BEGIN_COM_MAP(CPCHBehavior_GRADIENT)
    COM_INTERFACE_ENTRY(IHTMLPainter)
    COM_INTERFACE_ENTRY_CHAIN(CPCHBehavior)
END_COM_MAP()

    CPCHBehavior_GRADIENT();

    //
    // IElementBehavior
    //
    STDMETHOD(Init  )( /*[in]*/ IElementBehaviorSite* pBehaviorSite );
    STDMETHOD(Detach)(                                              );

    //
    // IHTMLPainter
    //
    STDMETHOD(Draw)( /*[in]*/ RECT   rcBounds     ,
                     /*[in]*/ RECT   rcUpdate     ,
                     /*[in]*/ LONG   lDrawFlags   ,
                     /*[in]*/ HDC    hdc          ,
                     /*[in]*/ LPVOID pvDrawObject );

    STDMETHOD(GetPainterInfo)( /*[in]*/ HTML_PAINTER_INFO *pInfo );

    STDMETHOD(HitTestPoint)( /*[in]*/ POINT pt       ,
                             /*[in]*/ BOOL* pbHit    ,
                             /*[in]*/ LONG* plPartID );

    STDMETHOD(OnResize)( /*[in]*/ SIZE pt );
};

/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHBehavior_BITMAP : public CPCHBehavior, public IHTMLPainter
{
    CComBSTR   m_bstrBaseURL;
    CComBSTR   m_bstrImage;

    CComBSTR   m_bstrImageNormal;
    CComBSTR   m_bstrImageMouseOver;
    CComBSTR   m_bstrImageMouseDown;
    bool       m_fFlipH;
    bool       m_fAutoRTL;

    HIMAGELIST m_himl;
    HBITMAP    m_hBMP;
    BITMAP     m_bm;
    LONG       m_lWidth;
    LONG       m_lHeight;

    bool       m_fMouseOver;
    bool       m_fMouseDown;

    ////////////////////

    void    ReleaseImage( /*[in]*/ bool fOnlyIL );
    HRESULT GrabImage   (                       );
    HRESULT ScaleImage  ( /*[in]*/ LPRECT prc   );

    HRESULT RefreshImages();

    HRESULT onMouse( DISPID, DISPPARAMS*, VARIANT* );

public:
BEGIN_COM_MAP(CPCHBehavior_BITMAP)
    COM_INTERFACE_ENTRY(IHTMLPainter)
    COM_INTERFACE_ENTRY_CHAIN(CPCHBehavior)
END_COM_MAP()

    CPCHBehavior_BITMAP();
    virtual ~CPCHBehavior_BITMAP();

    //
    // IElementBehavior
    //
    STDMETHOD(Init)( /*[in]*/ IElementBehaviorSite* pBehaviorSite );

    //
    // IHTMLPainter
    //
    STDMETHOD(Draw)( /*[in]*/ RECT   rcBounds     ,
                     /*[in]*/ RECT   rcUpdate     ,
                     /*[in]*/ LONG   lDrawFlags   ,
                     /*[in]*/ HDC    hdc          ,
                     /*[in]*/ LPVOID pvDrawObject );

    STDMETHOD(GetPainterInfo)( /*[in]*/ HTML_PAINTER_INFO *pInfo );

    STDMETHOD(HitTestPoint)( /*[in]*/ POINT pt       ,
                             /*[in]*/ BOOL* pbHit    ,
                             /*[in]*/ LONG* plPartID );

    STDMETHOD(OnResize)( /*[in]*/ SIZE pt );
};

/////////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___PCH___BEHAVIORS_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\binarybehaviors\behav_state.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Behav_STATE.cpp

Abstract:
    This file contains the implementation of the CPCHBehavior_STATE class,
    that dictates how hyperlinks work in the help center.

Revision History:
    Davide Massarenti (dmassare)  06/06/2000
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

static const WCHAR c_rgFMT[] = L"INTERNAL_%s###%s";

////////////////////////////////////////////////////////////////////////////////

CPCHBehavior_STATE::CPCHBehavior_STATE()
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_STATE::CPCHBehavior_STATE" );

    m_lCookie_PERSISTLOAD = 0; // long m_lCookie_PERSISTLOAD;
    m_lCookie_PERSISTSAVE = 0; // long m_lCookie_PERSISTSAVE;
	                           // CComBSTR m_bstrIdentity;
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHBehavior_STATE::Init( /*[in]*/ IElementBehaviorSite* pBehaviorSite )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_STATE::Init" );

    HRESULT            hr;
	CComPtr<IDispatch> pDisp;


    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHBehavior::Init( pBehaviorSite ));


	if(!m_fTrusted)
	{
		__MPC_SET_ERROR_AND_EXIT(hr, E_ACCESSDENIED);
	}


	//
	// Attach to all the events from CPCHEvents.
	//
	__MPC_EXIT_IF_METHOD_FAILS(hr, AttachToEvent( NULL, (CLASS_METHOD)onPersistLoad, NULL, &pDisp ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->Events().RegisterEvents( DISPID_PCH_E_PERSISTLOAD, MAXLONG, pDisp, &m_lCookie_PERSISTLOAD ));
	pDisp.Release();

	__MPC_EXIT_IF_METHOD_FAILS(hr, AttachToEvent( NULL, (CLASS_METHOD)onPersistSave, NULL, &pDisp ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->Events().RegisterEvents( DISPID_PCH_E_PERSISTSAVE, MINLONG, pDisp, &m_lCookie_PERSISTSAVE ));
	pDisp.Release();

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::COMUtil::GetPropertyByName( m_elem, L"identity", m_bstrIdentity ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHBehavior_STATE::Notify( /*[in]*/ LONG lEvent, /*[in/out]*/ VARIANT* pVar )
{
	if(lEvent == BEHAVIOREVENT_CONTENTREADY)
	{
		m_parent->HelpHost()->ChangeStatus( m_bstrIdentity, true );
	}

    return S_OK;
}


STDMETHODIMP CPCHBehavior_STATE::Detach()
{
	m_parent->HelpHost()->ChangeStatus( m_bstrIdentity, false );

    if(m_lCookie_PERSISTLOAD) { (void)m_parent->Events().UnregisterEvents( m_lCookie_PERSISTLOAD ); m_lCookie_PERSISTLOAD = 0; }
    if(m_lCookie_PERSISTSAVE) { (void)m_parent->Events().UnregisterEvents( m_lCookie_PERSISTSAVE ); m_lCookie_PERSISTSAVE = 0; }

    return CPCHBehavior::Detach();
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHBehavior_STATE::onPersistLoad( DISPID id, DISPPARAMS* pdispparams, VARIANT* )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_STATE::onPersistLoad" );

    HRESULT  hr;
    VARIANT& v = pdispparams->rgvarg[0];

    if(v.vt == VT_DISPATCH)
    {
		CComQIPtr<IPCHEvent> evCurrent = v.pdispVal;
    }

    hr = S_OK;


//    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHBehavior_STATE::onPersistSave( DISPID id, DISPPARAMS* pdispparams, VARIANT* )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior_STATE::onPersistLoad" );

    HRESULT  hr;
    VARIANT& v = pdispparams->rgvarg[0];

    if(v.vt == VT_DISPATCH)
    {
		CComQIPtr<IPCHEvent> evCurrent = v.pdispVal;
    }

    hr = S_OK;


//    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHBehavior_STATE::get_stateProperty( /*[in]*/ BSTR bstrName, /*[out, retval]*/ VARIANT *pVal )
{
	WCHAR rgName[512];

	_snwprintf( rgName, MAXSTRLEN(rgName), c_rgFMT, SAFEBSTR( m_bstrIdentity ), SAFEBSTR( bstrName ) );

    return m_parent->HelpSession()->Current()->get_Property( rgName, pVal );
}

STDMETHODIMP CPCHBehavior_STATE::put_stateProperty( /*[in]*/ BSTR bstrName, /*[in]*/ VARIANT newVal )
{
	WCHAR rgName[512];

	_snwprintf( rgName, MAXSTRLEN(rgName), c_rgFMT, SAFEBSTR( m_bstrIdentity ), SAFEBSTR( bstrName ) );

    return m_parent->HelpSession()->Current()->put_Property( rgName, newVal );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\binarybehaviors\factory.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Factory.cpp

Abstract:
    This file contains the implementation of the CPCHElementBehaviorFactory class,
    which is used to attach binary behaviors to HTML elements.

Revision History:
    Davide Massarenti (dmassare)  06/06/2000
        created

******************************************************************************/

#include "stdafx.h"

#include <mshtmdid.h>

#include <initguid.h>
#include <BehaviorsTypeLib_i.c>

////////////////////////////////////////////////////////////////////////////////

typedef HRESULT (*pfnBehaviorCreator)( /*[in]*/ CPCHHelpCenterExternal* parent, /*[out]*/ IElementBehavior* *ppBehavior );

template <class T> class BehaviorCreator
{
public:
    static HRESULT CreateInstance( /*[in]*/ CPCHHelpCenterExternal* parent, /*[out]*/ IElementBehavior* *ppBehavior )
    {
        HRESULT        hr;
        CComObject<T>* obj;

        if(SUCCEEDED(hr = obj->CreateInstance( &obj )))
        {
            obj->AddRef(); obj->Initialize( parent );

            hr = obj->QueryInterface( IID_IElementBehavior, (void**)ppBehavior );

            obj->Release();
        }

        return hr;
    }
};

struct BehaviorDefinition
{
    LPCWSTR            szBehaviorName;
    LPCWSTR            szTagName;
    pfnBehaviorCreator pfnCreator;
};

static const BehaviorDefinition s_Behaviors[] =
{
//  { NULL             , L"A", BehaviorCreator<CPCHBehavior_A>       ::CreateInstance },
    { L"pch_body"      , NULL, BehaviorCreator<CPCHBehavior_BODY>    ::CreateInstance },
    { L"pch_context"   , NULL, BehaviorCreator<CPCHBehavior_CONTEXT> ::CreateInstance },
    { L"pch_events"    , NULL, BehaviorCreator<CPCHBehavior_EVENT>   ::CreateInstance },
    { L"pch_handle"    , NULL, BehaviorCreator<CPCHBehavior_HANDLE>  ::CreateInstance },
    { L"pch_hyperlink" , NULL, BehaviorCreator<CPCHBehavior_A>       ::CreateInstance },
    { L"pch_state"     , NULL, BehaviorCreator<CPCHBehavior_STATE>   ::CreateInstance },
    { L"pch_subsite"   , NULL, BehaviorCreator<CPCHBehavior_SUBSITE> ::CreateInstance },
    { L"pch_tree"      , NULL, BehaviorCreator<CPCHBehavior_TREE>    ::CreateInstance },
////////////////////////////////////////////////////////////////////////////////////////
    { L"pch_gradient"  , NULL, BehaviorCreator<CPCHBehavior_GRADIENT>::CreateInstance },
    { L"pch_bitmap"    , NULL, BehaviorCreator<CPCHBehavior_BITMAP>  ::CreateInstance },
};

////////////////////////////////////////////////////////////////////////////////

CPCHElementBehaviorFactory::CPCHElementBehaviorFactory()
{
	m_parent = NULL; // CPCHHelpCenterExternal* m_parent;
}

void CPCHElementBehaviorFactory::Initialize( /*[in]*/ CPCHHelpCenterExternal* parent )
{
	m_parent = parent;
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHElementBehaviorFactory::QueryService( REFGUID guidService, REFIID riid, void **ppv )
{
    HRESULT hr = E_NOINTERFACE;

    if(InlineIsEqualGUID( riid, IID_IElementBehaviorFactory ))
    {
        hr = QueryInterface( riid, ppv );
    }
	else if(InlineIsEqualGUID( riid, IID_IPCHHelpCenterExternal ) && m_parent)
    {
		*ppv = m_parent; m_parent->AddRef();

		hr = S_OK;
	}

    return hr;
}


STDMETHODIMP CPCHElementBehaviorFactory::FindBehavior( /*[in]*/  BSTR                   bstrBehavior    ,
                                                       /*[in]*/  BSTR                   bstrBehaviorUrl ,
                                                       /*[in]*/  IElementBehaviorSite*  pSite           ,
                                                       /*[out]*/ IElementBehavior*     *ppBehavior      )
{
    __HCP_FUNC_ENTRY( "CPCHElementBehaviorFactory::FindBehavior" );

    HRESULT                   hr;
    CComPtr<IHTMLElement>     pElement;
    CComBSTR                  bstrTagName;
    const BehaviorDefinition* pBehaviorDef;
    int                       i;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pSite);
        __MPC_PARAMCHECK_POINTER_AND_SET(ppBehavior,NULL);
    __MPC_PARAMCHECK_END();


    //
    // Get tag name.
    //
    if(SUCCEEDED(pSite->GetElement( &pElement )) && pElement)
    {
        (void)pElement->get_tagName( &bstrTagName );
    }


    for(pBehaviorDef=s_Behaviors, i=0; i<ARRAYSIZE(s_Behaviors); i++, pBehaviorDef++)
    {
        if((pBehaviorDef->szBehaviorName == NULL || (bstrBehavior && !_wcsicmp( pBehaviorDef->szBehaviorName, bstrBehavior ))) &&
           (pBehaviorDef->szTagName      == NULL || (bstrTagName  && !_wcsicmp( pBehaviorDef->szTagName     , bstrTagName  )))  )
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, pBehaviorDef->pfnCreator( m_parent, ppBehavior ));

            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }
    }

    hr = E_FAIL;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

CPCHBehavior::EventSink::EventSink( CPCHBehavior* parent )
{
	m_lRef       = 1;       // long               m_lRef;
	                        //
    m_Parent     = parent;  // CPCHBehavior*      m_Parent;
                            // CComPtr<IDispatch> m_elem;
                            // CComBSTR           m_bstrName;
    m_pfn        = NULL;    // CLASS_METHOD       m_pfn;
    m_fAttached  = false;   // bool               m_fAttached;
    m_idNotifyAs = -1;      // DISPID             m_idNotifyAs;
}

CPCHBehavior::EventSink::~EventSink()
{
    (void)Detach();
}

HRESULT CPCHBehavior::EventSink::Attach()
{
    HRESULT hr = S_FALSE;

    if(m_fAttached)
    {
        hr = S_OK;
    }
    else if(m_elem && m_bstrName)
    {
        CComDispatchDriver disp (             m_elem     );
        CComVariant        vName(             m_bstrName );
        CComVariant        vDisp( (IDispatch*)this       );
        CComVariant        vRes;


        if(SUCCEEDED(hr = disp.Invoke2( DISPID_IHTMLELEMENT2_ATTACHEVENT, &vName, &vDisp, &vRes )))
        {
            if(vRes.vt == VT_BOOL && vRes.boolVal == VARIANT_TRUE)
            {
                m_fAttached = true;
            }
        }
    }

    return hr;
}

HRESULT CPCHBehavior::EventSink::Detach()
{
    HRESULT hr = S_FALSE;

    if(m_fAttached == false)
    {
        hr = S_OK;
    }
    else if(m_elem && m_bstrName)
    {
        CComDispatchDriver disp (             m_elem     );
        CComVariant        vName(             m_bstrName );
        CComVariant        vDisp( (IDispatch*)this       );

		//
		// EXTERNAL BUG: if we detach from the events, in a particular situation MSHTML crashes...
		//
        //if(SUCCEEDED(hr = disp.Invoke2( DISPID_IHTMLELEMENT2_DETACHEVENT, &vName, &vDisp )))
        {
            m_fAttached = false;
        }
    }

	m_elem.Release();

    return hr;
}

////////////////////////////////////////

STDMETHODIMP_(ULONG) CPCHBehavior::EventSink::AddRef()
{
    return ::InterlockedIncrement( &m_lRef );
}

STDMETHODIMP_(ULONG) CPCHBehavior::EventSink::Release()
{
    ULONG l =  ::InterlockedDecrement( &m_lRef );

    if(l == 0) delete this;

    return l;
}

STDMETHODIMP CPCHBehavior::EventSink::QueryInterface( REFIID iid, void ** ppvObject )
{
    if(ppvObject == NULL) return E_POINTER;

    if(InlineIsEqualGUID( iid, IID_IDispatch ))
    {
        *ppvObject = this; AddRef();
        return S_OK;
    }

    *ppvObject = NULL;

    return E_NOINTERFACE;
}

////////////////////////////////////////

STDMETHODIMP CPCHBehavior::EventSink::GetTypeInfoCount( UINT* pctinfo )
{
    return E_NOTIMPL;
}

STDMETHODIMP CPCHBehavior::EventSink::GetTypeInfo( UINT        itinfo  ,
                                                   LCID        lcid    ,
                                                   ITypeInfo* *pptinfo )
{
    return E_NOTIMPL;
}

STDMETHODIMP CPCHBehavior::EventSink::GetIDsOfNames( REFIID    riid      ,
                                                     LPOLESTR* rgszNames ,
                                                     UINT      cNames    ,
                                                     LCID      lcid      ,
                                                     DISPID*   rgdispid  )
{
    return E_NOTIMPL;
}

STDMETHODIMP CPCHBehavior::EventSink::Invoke( DISPID      dispidMember ,
                                              REFIID      riid         ,
                                              LCID        lcid         ,
                                              WORD        wFlags       ,
                                              DISPPARAMS* pdispparams  ,
                                              VARIANT*    pvarResult   ,
                                              EXCEPINFO*  pexcepinfo   ,
                                              UINT*       puArgErr     )
{
    if(m_Parent && m_pfn)
    {
        return (m_Parent->*m_pfn)( m_idNotifyAs == -1 ? dispidMember : m_idNotifyAs, pdispparams, pvarResult );
    }
    else
    {
        return S_FALSE;
    }
}

////////////////////////////////////////

HRESULT CPCHBehavior::EventSink::CreateInstance( /*[in]*/ CPCHBehavior* parent, /*[out]*/ EventSink*& pObj )
{
    pObj = new EventSink( parent );

    return (pObj == NULL) ? E_OUTOFMEMORY : S_OK;
}

////////////////////////////////////////////////////////////////////////////////

CPCHBehavior::CPCHBehavior()
{
    m_parent   = NULL;  // CPCHHelpCenterExternal*         m_parent;
                        //
                        // CComPtr<IElementBehaviorSiteOM> m_siteOM;
                        // CComPtr<IHTMLElement>           m_elem;
                        // CComPtr<IHTMLElement2>          m_elem2;
                        // SinkList                        m_lstEventSinks;
    m_fRTL     = false; // bool                            m_fRTL;
    m_fTrusted = false; // bool                            m_fTrusted;
    m_fSystem  = false; // bool                            m_fSystem;
}

void CPCHBehavior::Initialize( /*[in]*/ CPCHHelpCenterExternal* parent )
{
	m_parent = parent;
}

STDMETHODIMP CPCHBehavior::Init( /*[in]*/ IElementBehaviorSite* pBehaviorSite )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior::Init" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(m_parent);
        __MPC_PARAMCHECK_NOTNULL(pBehaviorSite);
    __MPC_PARAMCHECK_END();


    Detach();


    __MPC_EXIT_IF_METHOD_FAILS(hr, pBehaviorSite->QueryInterface( IID_IElementBehaviorSiteOM, (LPVOID*)&m_siteOM ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pBehaviorSite->GetElement    (                                      &m_elem   ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_elem        .QueryInterface(                                      &m_elem2  ));

    //
    // Look for security stuff.
    //
    {
        CComPtr<IHTMLDocument2> doc;
        CComPtr<IHTMLDocument3> doc3;

        if(SUCCEEDED(MPC::HTML::IDispatch_To_IHTMLDocument2( doc, m_elem )))
        {
            CComBSTR bstrURL;
			CComBSTR bstrDir;

            if(SUCCEEDED(doc->get_URL( &bstrURL )))
            {
                m_fTrusted = m_parent->SecurityManager()->IsUrlTrusted( SAFEBSTR( bstrURL ), &m_fSystem );
            }

			__MPC_EXIT_IF_METHOD_FAILS(hr, doc.QueryInterface( &doc3 ));

			__MPC_EXIT_IF_METHOD_FAILS(hr, doc3->get_dir( &bstrDir ));

			m_fRTL = (MPC::StrICmp( bstrDir, L"RTL" ) == 0);
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHBehavior::Notify( /*[in]*/ LONG lEvent, /*[in/out]*/ VARIANT* pVar )
{
    int i = 2;

    return S_OK;
}

STDMETHODIMP CPCHBehavior::Detach()
{
    for(SinkIter it = m_lstEventSinks.begin(); it != m_lstEventSinks.end(); it++)
    {
        EventSink* obj = *it;;

        if(obj)
        {
            obj->m_Parent = NULL;
            obj->Detach ();
            obj->Release();
        }
    }
    m_lstEventSinks.clear();

    m_siteOM.Release();
    m_elem  .Release();
    m_elem2 .Release();

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHBehavior::AttachToEvent( /*[in] */ LPCWSTR       szName ,
                                     /*[in] */ CLASS_METHOD  pfn    ,
                                     /*[in] */ IDispatch*    elem   ,
                                     /*[out]*/ IDispatch*   *pVal   ,
                                     /*[in] */ DISPID        id     )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior::AttachToEvent" );

    HRESULT    hr;
    SinkIter   it;
    EventSink* obj = NULL;


    __MPC_EXIT_IF_METHOD_FAILS(hr, obj->CreateInstance( this, obj ));

    obj->m_elem       = elem ? elem : m_elem2;
    obj->m_bstrName   = szName;
    obj->m_pfn        = pfn;
    obj->m_idNotifyAs = id;

    if(pVal) // Don't attach to the site, simply return the IDispatch interface.
    {
        *pVal = obj; obj->AddRef();
    }
    else
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, obj->Attach());
    }

    m_lstEventSinks.push_back( obj ); obj = NULL;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(obj) obj->Release();

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHBehavior::AttachToEvents( /*[in] */ const EventDescription* pEvents ,
									  /*[in] */ CLASS_METHOD 			pfn     ,
									  /*[in] */ IDispatch*   			elem    )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior::AttachToEvents" );

    HRESULT hr;

    while(pEvents->szName)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, AttachToEvent( pEvents->szName, pfn, elem, NULL, pEvents->id ));

		pEvents++;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHBehavior::CreateEvent( /*[in]*/ LPCWSTR szName, /*[out]*/ LONG& lEventCookie )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior::CreateEvent" );

    HRESULT hr;

    hr = m_siteOM ? m_siteOM->RegisterEvent( CComBSTR( szName ), 0, &lEventCookie ) : E_POINTER;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

HRESULT CPCHBehavior::GetEventObject( /*[out]*/ CComPtr<IHTMLEventObj>& ev )
{
    return MPC::HTML::GetEventObject( ev, m_elem );
}

HRESULT CPCHBehavior::CreateEventObject( /*[out]*/ CComPtr<IHTMLEventObj>& ev )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior::CreateEventObject" );

    HRESULT hr;

    ev.Release();

    hr = m_siteOM ? m_siteOM->CreateEventObject( &ev ) : E_POINTER;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHBehavior::FireEvent( /*[in ]*/ IHTMLEventObj* ev, /*[in]*/ LONG lEventCookie )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior::FireEvent" );

    HRESULT hr;

    hr = m_siteOM ? m_siteOM->FireEvent( lEventCookie, ev ) : E_POINTER;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHBehavior::FireEvent( /*[in]*/ LONG lEventCookie )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior::FireEvent" );

    HRESULT                hr;
	CComPtr<IHTMLEventObj> pEvent;


	__MPC_EXIT_IF_METHOD_FAILS(hr, CreateEventObject( pEvent               ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, FireEvent        ( pEvent, lEventCookie ));

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

HRESULT CPCHBehavior::CancelEvent( /*[in]*/ IHTMLEventObj* ev, /*[in]*/ VARIANT* pvReturnValue, /*[in]*/ VARIANT_BOOL fCancelBubble )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior::CancelEvent" );

    HRESULT hr;
    CComPtr<IHTMLEventObj> pEvent;
    CComVariant            vDefault;

	if(ev == NULL)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, GetEventObject( pEvent ));

		ev = pEvent;
	}

    if(pvReturnValue == NULL)
    {
        vDefault = false;

        pvReturnValue = &vDefault;
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, ev->put_returnValue ( *pvReturnValue ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, ev->put_cancelBubble( fCancelBubble  ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHBehavior::GetEvent_SrcElement( /*[in]*/ CComPtr<IHTMLElement>& elem )
{
    __HCP_FUNC_ENTRY( "CPCHBehavior::GetEvent_SrcElement" );

    HRESULT                hr;
    CComPtr<IHTMLEventObj> ev;

    elem.Release();

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetEventObject( ev ));

    MPC_SCRIPTHELPER_GET__DIRECT__NOTNULL(elem, ev, srcElement);

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

HRESULT CPCHBehavior::GetAsVARIANT( /*[in]*/ BSTR value, /*[out, retval]*/ VARIANT *pVal )
{
	if(pVal == NULL) return E_POINTER;

	::VariantClear( pVal );

	pVal->vt      = VT_BSTR;
	pVal->bstrVal = ::SysAllocString( value );

	return S_OK;
}

HRESULT CPCHBehavior::GetAsVARIANT( /*[in]*/ IDispatch* value, /*[out, retval]*/ VARIANT *pVal )
{
	if(pVal == NULL) return E_POINTER;

	::VariantClear( pVal );

	if(value)
	{
		pVal->vt       = VT_DISPATCH;
		pVal->pdispVal = value; value->AddRef();
	}

	return S_OK;
}

HRESULT CPCHBehavior::GetAsIDISPATCH( /*[in]*/ IDispatch* value, /*[out, retval]*/ IDispatch* *pVal )
{
	return MPC::CopyTo( value, pVal );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\binarybehaviors\stdafx.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    StdAfx.h

Abstract:
    Precompiled header.

Revision History:
    Davide Massarenti   (Dmassare)  06/06/2000
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__6877C875_4E31_4E1C_8AC2_024A50599D66__INCLUDED_)
#define AFX_STDAFX_H__6877C875_4E31_4E1C_8AC2_024A50599D66__INCLUDED_


#include <module.h>

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

//
// From HelpCenterTypeLib.idl
//
#include <HelpCenterTypeLib.h>

//
// For debug trace
//
#include <HCP_trace.h>
#include <MPC_utils.h>
#include <MPC_html.h>
#include <MPC_html2.h>
#include <MPC_xml.h>
#include <MPC_COM.h>

#include <NameSpace_Impl.h>
#include <HelpCenter.h>
#include <HelpCenterExternal.h>

#include <Behaviors.h>

#include <Factories.h>

#endif // !defined(AFX_STDAFX_H__6877C875_4E31_4E1C_8AC2_024A50599D66__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\connectivity\connectioncheck.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Connection.cpp

Abstract:
    This file contains the implementation of the CHCPConnection class,
    which implements the internet connection functionality.

Revision History:
    Anand Arvind (aarvind)  2000-03-22
        created

Test Code : UnitTest/test_concheck.htm

******************************************************************************/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////

CPCHConnectionCheck::UrlEntry::UrlEntry()
{
    m_lStatus = CN_URL_INVALID; // CN_URL_STATUS m_lStatus;
                                // CComBSTR      m_bstrURL;
                                // CComVariant   m_vCtx;
}

HRESULT CPCHConnectionCheck::UrlEntry::CheckStatus()
{
    __HCP_FUNC_ENTRY( "CPCHConnectionCheck::UrlEntry::CheckStatus" );

    HRESULT  hr;


    m_lStatus = CN_URL_UNREACHABLE;


    //
    // Verify immediately if it's a CHM.
    //
    {
        CComBSTR bstrStorageName;
        CComBSTR bstrFilePath;

        if(MPC::MSITS::IsCHM( SAFEBSTR( m_bstrURL ), &bstrStorageName, &bstrFilePath ))
        {
            CComPtr<IStream> stream;

            __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MSITS::OpenAsStream( bstrStorageName, bstrFilePath, &stream ));

            m_lStatus = CN_URL_ALIVE;

            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }
    }

    //
    // Check destination
    //
    {
        HyperLinks::UrlHandle  uh;
        HyperLinks::ParsedUrl* pu;

        __MPC_EXIT_IF_METHOD_FAILS(hr, HyperLinks::Lookup::s_GLOBAL->Get( m_bstrURL, uh, /*dwWaitForCheck*/HC_TIMEOUT_CONNECTIONCHECK, /*fForce*/true ));

        pu = uh;
        if(!pu) __MPC_EXIT_IF_METHOD_FAILS(hr, E_FAIL);

        switch(pu->m_state)
        {
        case HyperLinks::STATE_ALIVE      :                                                                        break;
        case HyperLinks::STATE_NOTFOUND   : __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_INTERNET_ITEM_NOT_FOUND    ); break;
        case HyperLinks::STATE_UNREACHABLE: __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_INTERNET_SERVER_UNREACHABLE); break;
        case HyperLinks::STATE_OFFLINE    : __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_INTERNET_DISCONNECTED      ); break;
        }
    }

    m_lStatus = CN_URL_ALIVE;
    hr        = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

CPCHConnectionCheck::CPCHConnectionCheck()
{
    __HCP_FUNC_ENTRY( "CPCHConnectionCheck::CPCHConnectionCheck" );

    m_cnStatus = CN_NOTACTIVE; // CN_STATUS                            m_cnStatus;
                               // UrlList                              m_lstUrl;
                               //
                               // MPC::CComPtrThreadNeutral<IDispatch> m_sink_onProgressURL;
                               // MPC::CComPtrThreadNeutral<IDispatch> m_sink_onComplete;
}

void CPCHConnectionCheck::FinalRelease()
{
    __HCP_FUNC_ENTRY( "CPCHConnectionCheck::FinalRelease" );

    Thread_Wait();
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT CPCHConnectionCheck::Run()
{
    __HCP_FUNC_ENTRY( "CPCHConnectionCheck::Run" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    HRESULT                      hrExtendedError;
    UrlEntry                     urlEntry;
    UrlIter                      it;


    ::SetThreadPriority( ::GetCurrentThread(), THREAD_PRIORITY_LOWEST );


    while(1)
    {
        //
        // If no item in the list, go back to WaitForSingleObject.
        //
        it = m_lstUrl.begin(); if(it == m_lstUrl.end()) break;

        //
        // Get the first event in the list.
        //
        urlEntry = *it;

        //
        // Remove the event from the list.
        //
        m_lstUrl.erase( it );


        put_Status( CN_CHECKING );


        //
        // Now that we have the data, let's unlock the object.
        //
        lock = NULL;


        if(Thread_IsAborted())
        {
            urlEntry.m_lStatus = CN_URL_ABORTED;
            hrExtendedError    = E_ABORT;
        }
        else
        {
            hrExtendedError = E_ABORT;

            __MPC_PROTECT( hrExtendedError = urlEntry.CheckStatus() );
        }

        //
        // Fire event for the destination's status
        //
        (void)Fire_onCheckDone( this, urlEntry.m_lStatus, hrExtendedError, urlEntry.m_bstrURL, urlEntry.m_vCtx );


        //
        // Before looping, relock the object.
        //
        lock = this;
    }


    put_Status( CN_IDLE );


    __HCP_FUNC_EXIT(S_OK);
}

/////////////////////////////////////////////////////////////////////////////

////////////////
//            //
// Properties //
//            //
////////////////

STDMETHODIMP CPCHConnectionCheck::put_onCheckDone( /*[in]*/ IDispatch* function )
{
    __HCP_BEGIN_PROPERTY_PUT("CPCHConnectionCheck::put_onCheckDone",hr);

    if(Thread_IsRunning())
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_ACCESSDENIED);
    }

    m_sink_onCheckDone = function;

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHConnectionCheck::put_onStatusChange( /*[in]*/ IDispatch* function )
{
    __HCP_BEGIN_PROPERTY_PUT("CPCHConnectionCheck::put_onStatusChange",hr);

    if(Thread_IsRunning())
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_ACCESSDENIED);
    }

    m_sink_onStatusChange = function;

    __HCP_END_PROPERTY(hr);
}

HRESULT CPCHConnectionCheck::put_Status( /*[in]*/ CN_STATUS pVal ) // Inner method
{
    __HCP_BEGIN_PROPERTY_PUT("CPCHConnectionCheck::put_Status",hr);

    if(m_cnStatus != pVal)
    {
        Fire_onStatusChange( this, m_cnStatus = pVal );
    }

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHConnectionCheck::get_Status( /*[out]*/ CN_STATUS *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CPCHConnectionCheck::get_Status",hr,pVal,m_cnStatus);

    __HCP_END_PROPERTY(hr);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHConnectionCheck::StartUrlCheck( /*[in]*/ BSTR bstrURL, /*[in]*/ VARIANT vCtx )
{
    __HCP_FUNC_ENTRY( "CPCHConnectionCheck::StartUrlCheck" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrURL);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, HyperLinks::IsValid( bstrURL ));


    //
    // Add the URL to the list of pending items.
    //
    {
        UrlIter it = m_lstUrl.insert( m_lstUrl.end() );

        it->m_bstrURL = bstrURL;
        it->m_vCtx    = vCtx;
    }

    if(Thread_IsRunning() == false ||
       Thread_IsAborted() == true   )
    {
        //
        // Release the lock on current object, otherwise a deadlock could occur.
        //
        lock = NULL;

        __MPC_EXIT_IF_METHOD_FAILS(hr, Thread_Start( this, Run, NULL ));
    }


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHConnectionCheck::Abort()
{
    __HCP_FUNC_ENTRY( "CPCHConnectionCheck::Abort" );

    Thread_Abort(); // To tell the MPC:Thread object to close the worker thread...

    __HCP_FUNC_EXIT(S_OK);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//////////////////////////
//                      //
// Event Firing Methods //
//                      //
//////////////////////////

HRESULT CPCHConnectionCheck::Fire_onCheckDone( IPCHConnectionCheck* obj, CN_URL_STATUS lStatus, HRESULT hr, BSTR bstrURL, VARIANT vCtx )
{
    CComVariant pvars[5];

    pvars[4] = obj;
    pvars[3] = lStatus;
    pvars[2] = hr;
    pvars[1] = bstrURL;
    pvars[0] = vCtx;

    return FireAsync_Generic( DISPID_PCH_CNE__ONCHECKDONE, pvars, ARRAYSIZE( pvars ), m_sink_onCheckDone );
}

HRESULT CPCHConnectionCheck::Fire_onStatusChange( IPCHConnectionCheck* obj, CN_STATUS lStatus )
{
    CComVariant pvars[2];

    pvars[1] = obj;
    pvars[0] = lStatus;

    return FireAsync_Generic( DISPID_PCH_CNE__ONSTATUSCHANGE, pvars, ARRAYSIZE( pvars ), m_sink_onStatusChange );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\connectivity\stdafx.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    stdafx.h

Abstract:
    include file for standard system include files,
    or project specific include files that are used frequently,
    but are changed infrequently


Revision History:
    Davide Massarenti   (Dmassare)  07/21/99
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_

//#define _DEBUG
//#define ATL_TRACE_LEVEL 100
////#define _ATL_DEBUG_INTERFACES
//#define _ATL_DEBUG_QI

#include <module.h>

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

//
// From HelpCenterTypeLib.idl
//
#include <HelpCenterTypeLib.h>

//////

#include <HCP_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_html.h>
#include <MPC_COM.h>

#include <Debug.h>

//////

#include <HelpCenter.h>
#include <HelpCenterExternal.h>

#include <NameSpace_Impl.h>

#include <ConnectivityLib.h>

#include <HyperLinksLib.h>


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\connectivity\connectivity.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Connectivity.cpp

Abstract:
    This file contains the implementation of the CPCHConnectivity class.

Revision History:
    Davide Massarenti   (Dmassare)  04/15/2000
        created

******************************************************************************/

#include "stdafx.h"

//
// Required by REGSTR_* macros.
//
#ifdef __TEXT
#undef __TEXT
#define __TEXT(quote) L##quote      // r_winnt
#endif

#include <ras.h>
#include <raserror.h>
#include <inetreg.h>
#include <Iphlpapi.h>

static const WCHAR c_szURL_Connection[] = L"hcp://system/errors/Connection.htm";

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

CPCHConnectivity::CPCHConnectivity()
{
    m_parent = NULL; // CPCHHelpCenterExternal* m_parent;
}

HRESULT CPCHConnectivity::ConnectToParent( /*[in]*/ CPCHHelpCenterExternal* parent )
{
    m_parent = parent;

    return S_OK;
}

STDMETHODIMP CPCHConnectivity::get_IsAModem( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHConnectivity::get_IsAModem" );

    HRESULT hr;
    DWORD   dwMode = 0;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,VARIANT_FALSE);
    __MPC_PARAMCHECK_END();


    if(::InternetGetConnectedState( &dwMode, 0 ) == TRUE)
    {
        if(dwMode & INTERNET_CONNECTION_MODEM) *pVal = VARIANT_TRUE;
    }


    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHConnectivity::get_IsALan( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHConnectivity::get_IsALan" );

    HRESULT hr;
    DWORD   dwMode = 0;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,VARIANT_FALSE);
    __MPC_PARAMCHECK_END();


    if(::InternetGetConnectedState( &dwMode, 0 ) == TRUE)
    {
        if(dwMode & INTERNET_CONNECTION_LAN) *pVal = VARIANT_TRUE;
    }


    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHConnectivity::get_AutoDialEnabled( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHConnectivity::get_AutoDialEnabled" );

    HRESULT hr;
    DWORD   dwValue;
    bool    fFound;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,VARIANT_FALSE);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::RegKey_Value_Read( dwValue, fFound, REGSTR_PATH_INTERNET_SETTINGS, REGSTR_VAL_ENABLEAUTODIAL, HKEY_CURRENT_USER ));
    if(fFound && dwValue != 0) *pVal = VARIANT_TRUE;


    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHConnectivity::get_HasConnectoid( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHConnectivity::get_HasConnectoid" );

    HRESULT        hr;
    RASENTRYNAMEW* pEntries = NULL;
    DWORD          cb       = sizeof(*pEntries);
    DWORD          cEntries = 0;
    DWORD          dwRet;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,VARIANT_FALSE);
    __MPC_PARAMCHECK_END();

    for(int pass=0; pass<2; pass++)
    {
        __MPC_EXIT_IF_ALLOC_FAILS(hr, pEntries, (RASENTRYNAMEW*)malloc( cb ));

        ::ZeroMemory( pEntries, cb ); pEntries[0].dwSize = sizeof(*pEntries);

        dwRet = ::RasEnumEntriesW( NULL, NULL, pEntries, &cb, &cEntries );
        if(dwRet == ERROR_SUCCESS) break;

        if(dwRet == ERROR_BUFFER_TOO_SMALL)
        {
            free( pEntries ); pEntries = NULL; continue;
        }

        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRet);
    }

    *pVal = (cEntries > 0) ? VARIANT_TRUE : VARIANT_FALSE;

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    if(pEntries) free( pEntries );

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHConnectivity::get_IPAddresses( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHConnectivity::get_IPAddresses" );

    HRESULT          hr;
    IP_ADAPTER_INFO* pAdapterInfo = NULL;
    ULONG            cb           = 1024; // Start with a default buffer.
    MPC::wstring     strList;
    DWORD            dwRet;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();



    for(int pass=0; pass<2; pass++)
    {
        __MPC_EXIT_IF_ALLOC_FAILS(hr, pAdapterInfo, (IP_ADAPTER_INFO*)malloc( cb ));

        ::ZeroMemory( pAdapterInfo, cb );

        dwRet = ::GetAdaptersInfo( pAdapterInfo, &cb );
        if(dwRet == ERROR_SUCCESS) break;

        if(dwRet == ERROR_BUFFER_TOO_SMALL)
        {
            free( pAdapterInfo ); pAdapterInfo = NULL; continue;
        }

        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRet);
    }

    if(pAdapterInfo)
    {
        IP_ADAPTER_INFO* ptr = pAdapterInfo;

        while(ptr)
        {
            IP_ADDR_STRING* addr = &ptr->IpAddressList;

            while(addr)
            {
                WCHAR rgAddr[4 * 4 + 1]; ::MultiByteToWideChar( CP_ACP, 0, addr->IpAddress.String, -1, rgAddr, MAXSTRLEN(rgAddr) ); rgAddr[MAXSTRLEN(rgAddr)] = 0;

                if(strList.size()) strList.append( L";" );
                strList.append( rgAddr );

                addr = addr->Next;
            }

            ptr = ptr->Next;
        }
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( strList.c_str(), pVal ));

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    if(pAdapterInfo) free( pAdapterInfo );

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

STDMETHODIMP CPCHConnectivity::CreateObject_ConnectionCheck( /*[out, retval]*/ IPCHConnectionCheck* *ppCC )
{
    __HCP_FUNC_ENTRY( "CPCHConnectivity::CreateObject_ConnectionCheck" );

    HRESULT                      hr;
    CComPtr<CPCHConnectionCheck> cc;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(ppCC,NULL);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &cc ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, cc.QueryInterface( ppCC ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

STDMETHODIMP CPCHConnectivity::NetworkAlive( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHConnectivity::NetworkAlive" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,VARIANT_FALSE);
    __MPC_PARAMCHECK_END();


    *pVal = SUCCEEDED(MPC::Connectivity::NetworkAlive( HC_TIMEOUT_NETWORKALIVE )) ? VARIANT_TRUE : VARIANT_FALSE;
    hr    = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHConnectivity::DestinationReachable( /*[in]*/ BSTR bstrURL, /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHConnectivity::DestinationReachable" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrURL);
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,VARIANT_FALSE);
    __MPC_PARAMCHECK_END();


    if(SUCCEEDED(HyperLinks::IsValid                    ( bstrURL                                        )) &&
       SUCCEEDED(MPC::Connectivity::DestinationReachable( bstrURL, HC_TIMEOUT_DESTINATIONREACHABLE, NULL ))  )
    {
        *pVal = VARIANT_TRUE;
    }

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

STDMETHODIMP CPCHConnectivity::AutoDial( /*[in]*/ VARIANT_BOOL bUnattended )
{
    __HCP_FUNC_ENTRY( "CPCHConnectivity::AutoDial" );

    HRESULT hr;

    //
    // Only call the Autodial API if we are really offline.
    //
    if(FAILED(MPC::Connectivity::NetworkAlive( HC_TIMEOUT_NETWORKALIVE )))
    {
        if(!::InternetAutodial( bUnattended == VARIANT_TRUE ? INTERNET_AUTODIAL_FORCE_UNATTENDED : INTERNET_AUTODIAL_FORCE_ONLINE, NULL ))
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ::GetLastError());
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHConnectivity::AutoDialHangup()
{
    __HCP_FUNC_ENTRY( "CPCHConnectivity::AutoDialHangup" );

    HRESULT hr;


    if(!::InternetAutodialHangup( 0 ))
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ::GetLastError());
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHConnectivity::NavigateOnline( /*[in         ]*/ BSTR    bstrTargetURL  ,
                                               /*[in         ]*/ BSTR    bstrTopicTitle ,
                                               /*[in         ]*/ BSTR    bstrTopicIntro ,
                                               /*[in,optional]*/ VARIANT vOfflineURL    )
{
    __HCP_FUNC_ENTRY( "CPCHConnectivity::NavigateOnline" );

    HRESULT      hr;
    MPC::wstring strURL;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrTargetURL);
        __MPC_PARAMCHECK_NOTNULL(m_parent);
    __MPC_PARAMCHECK_END();

    MPC::HTML::vBuildHREF( strURL, c_szURL_Connection, L"online_url" ,                             bstrTargetURL                ,
                                                       L"topic_title",                             bstrTopicTitle               ,
                                                       L"topic_intro",                             bstrTopicIntro               ,
                                                       L"offline_url", vOfflineURL.vt == VT_BSTR ? vOfflineURL   .bstrVal : NULL,
                                                       NULL );

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->SetPanelUrl( HSCPANEL_CONTENTS, strURL.c_str() ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\context\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__412B7974_2F00_11D3_9A30_00C04F72D6C5__INCLUDED_)
#define AFX_STDAFX_H__412B7974_2F00_11D3_9A30_00C04F72D6C5__INCLUDED_

#include <module.h>

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

//
// From HelpCenterTypeLib.idl
//
#include <HelpCenterTypeLib.h>

//
// For debug trace
//
#include <HCP_trace.h>
#include <MPC_COM.h>
#include <MPC_utils.h>
#include <MPC_html.h>
#include <MPC_xml.h>

#include <HelpCenter.h>
#include <HelpViewerWrapper.h>
#include <HelpCenterExternal.h>
#include <Context.h>

//
// Content Store
//
#include <ContentStoreMgr.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__412B7974_2F00_11D3_9A30_00C04F72D6C5__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\context\helphost.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    HelpHost.cpp

Abstract:
    This file contains the implementation of the CPCHHelpHost class,
    UI-side version of IHelpHost.

Revision History:
    Davide Massarenti   (Dmassare)  11/03/2000
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

#define GRANT_ACCESS_AND_CALL(ext,func,fail)                                         \
    HRESULT hr;                                                                      \
                                                                                     \
    if(ext)                                                                          \
    {                                                                                \
        CPCHHelpCenterExternal::TLS* tlsOld = ext->GetTLS();                         \
        CPCHHelpCenterExternal::TLS  tlsNew;  ext->SetTLS( &tlsNew );                \
                                                                                     \
        tlsNew.m_fSystem  = true;                                                    \
        tlsNew.m_fTrusted = true;                                                    \
                                                                                     \
        hr = ext->func;                                                              \
                                                                                     \
        ext->SetTLS( tlsOld );                                                       \
    }                                                                                \
    else                                                                             \
    {                                                                                \
        hr = fail;                                                                   \
    }                                                                                \
                                                                                     \
    return hr

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HelpHost::Main::Main()
{
                         // CComPtr<IRunningObjectTable>     m_rt;
                         // CComPtr<IMoniker>                m_moniker;
    m_dwRegister = 0;    // DWORD                            m_dwRegister;
                         //
    m_External   = NULL; // CPCHHelpCenterExternal*          m_External;
                         //
    m_hEvent     = NULL; // HANDLE m_hEvent;
                         // bool   m_comps[COMPID_MAX];

    ::ZeroMemory( m_comps, sizeof(m_comps) ); // Initialize to false...
}


HelpHost::Main::~Main()
{
    Passivate();

    if(m_hEvent) ::CloseHandle( m_hEvent );
}

HRESULT HelpHost::Main::Initialize( /*[in]*/ CPCHHelpCenterExternal* external )
{
    __HCP_FUNC_ENTRY( "HelpHost::Main::Initialize" );

    HRESULT hr;

    m_External = external;

    //
    // Get a pointer to the ROT and create a class moniker.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, ::GetRunningObjectTable( 0, &m_rt ));


    __MPC_EXIT_IF_CALL_RETURNS_NULL(hr, (m_hEvent = ::CreateEvent( NULL, FALSE, TRUE, NULL )));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void HelpHost::Main::Passivate()
{
    if(m_rt)
    {
        if(m_dwRegister)
        {
            (void)m_rt->Revoke( m_dwRegister );

            m_dwRegister = NULL;
        }
    }


    m_rt     .Release();
    m_moniker.Release();

    m_External = NULL;
}

HRESULT HelpHost::Main::Locate( /*[in]*/ CLSID& clsid, /*[out]*/ CComPtr<IPCHHelpHost>& pVal )
{
    __HCP_FUNC_ENTRY( "HelpHost::Main::Locate" );

    HRESULT           hr;
    CComPtr<IUnknown> obj;


    m_moniker.Release();
    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CreateClassMoniker( clsid, &m_moniker ));


    if(SUCCEEDED(m_rt->GetObject( m_moniker, &obj )) && obj)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, obj.QueryInterface( &pVal ));
    }
    else
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_NOINTERFACE);
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT HelpHost::Main::Register( /*[in]*/ CLSID& clsid )
{
    __HCP_FUNC_ENTRY( "HelpHost::Main::Register" );

    HRESULT hr;

    m_moniker.Release();
    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CreateClassMoniker( clsid, &m_moniker ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_rt->Register( ROTFLAGS_REGISTRATIONKEEPSALIVE, this, m_moniker, &m_dwRegister ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////

void HelpHost::Main::ChangeStatus( /*[in]*/ LPCWSTR szComp, /*[in]*/ bool fStatus )
{
    static struct
    {
        LPCWSTR szName;
        CompId  comp;
    } s_lookup[] =
    {
        { L"NAVBAR"    , COMPID_NAVBAR     },
        { L"MININAVBAR", COMPID_MININAVBAR },
        { L"CONTEXT"   , COMPID_CONTEXT    },
        { L"CONTENTS"  , COMPID_CONTENTS   },
        { L"HHWINDOW"  , COMPID_HHWINDOW   },
        { L"FIRSTPAGE" , COMPID_FIRSTPAGE  },
        { L"HOMEPAGE"  , COMPID_HOMEPAGE   },
        { L"SUBSITE"   , COMPID_SUBSITE    },
        { L"SEARCH"    , COMPID_SEARCH     },
        { L"INDEX"     , COMPID_INDEX      },
        { L"FAVORITES" , COMPID_FAVORITES  },
        { L"HISTORY"   , COMPID_HISTORY    },
        { L"CHANNELS"  , COMPID_CHANNELS   },
        { L"OPTIONS"   , COMPID_OPTIONS    }
    };

    if(szComp == NULL) return;

    for(int i=0; i<ARRAYSIZE(s_lookup); i++)
    {
        if(!_wcsicmp( szComp, s_lookup[i].szName ))
        {
            ChangeStatus( s_lookup[i].comp, fStatus );
            break;
        }
    }
}

void HelpHost::Main::ChangeStatus( /*[in]*/ CompId idComp, /*[in]*/ bool fStatus )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    if(idComp < COMPID_MAX)
    {
        m_comps[idComp] = fStatus;

        if(m_hEvent)
        {
            ::SetEvent( m_hEvent );
        }
    }
}

bool HelpHost::Main::GetStatus( /*[in]*/ CompId idComp )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    if(idComp >= COMPID_MAX) return false;

    return m_comps[idComp];
}

bool HelpHost::Main::WaitUntilLoaded( /*[in]*/ CompId idComp, /*[in]*/ DWORD dwTimeout )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    if(idComp >= COMPID_MAX) return false;

    //
    // On machine without enough RAM, increase the timeout.
    //
    {
        MEMORYSTATUSEX ms;

        ::ZeroMemory( &ms, sizeof(ms) ); ms.dwLength = sizeof(ms);

        if(::GlobalMemoryStatusEx( &ms ))
        {
            if(ms.ullAvailPhys < 32 * 1024 * 1024) dwTimeout *= 10;
        }
    }

    while(m_comps[idComp] == false)
    {
        //
        // Wait without holding a lock on the object.
        //
        lock = NULL;
        if(MPC::WaitForSingleObject( m_hEvent, dwTimeout ) != WAIT_OBJECT_0) return false;
        lock = this;
    }

    return true;
}

////////////////////

STDMETHODIMP HelpHost::Main::DisplayTopicFromURL( /*[in]*/ BSTR url, /*[in]*/ VARIANT options )
{
    GRANT_ACCESS_AND_CALL(m_External, ChangeContext( HSCCONTEXT_CONTENT, NULL, url, /*fAlsoContent*/true ), S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\context\xmlconfig.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    XMLConfig.cpp

Abstract:
    This file contains the implementation of the HelpHost::XMLConfig class.

Revision History:
    Davide Massarenti   (Dmassare)  12/03/2000
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

CFG_BEGIN_FIELDS_MAP(HelpHost::XMLConfig::Context)
    CFG_ATTRIBUTE( L"ID"              , BSTR, m_bstrID              ),

    CFG_ELEMENT  ( L"TaxonomyPath"    , BSTR, m_bstrTaxonomyPath    ),
    CFG_ELEMENT  ( L"NodeToHighlight" , BSTR, m_bstrNodeToHighlight ),
    CFG_ELEMENT  ( L"TopicToHighlight", BSTR, m_bstrTopicToHighlight),
    CFG_ELEMENT  ( L"Query"           , BSTR, m_bstrQuery           ),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(HelpHost::XMLConfig::Context)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(HelpHost::XMLConfig::Context,L"Context")

DEFINE_CONFIG_METHODS__NOCHILD(HelpHost::XMLConfig::Context)

////////////////////

CFG_BEGIN_FIELDS_MAP(HelpHost::XMLConfig::WindowSettings)
    CFG_ATTRIBUTE__TRISTATE( L"NoResize" , bool, m_fNoResize , m_fPresence_NoResize  ),
    CFG_ATTRIBUTE__TRISTATE( L"Maximized", bool, m_fMaximized, m_fPresence_Maximized ),

    CFG_ELEMENT__TRISTATE  ( L"Title"    , BSTR, m_bstrTitle , m_fPresence_Title     ),

    CFG_ELEMENT__TRISTATE  ( L"Left"     , BSTR, m_bstrLeft  , m_fPresence_Left      ),
    CFG_ELEMENT__TRISTATE  ( L"Top"      , BSTR, m_bstrTop   , m_fPresence_Top       ),
    CFG_ELEMENT__TRISTATE  ( L"Width"    , BSTR, m_bstrWidth , m_fPresence_Width     ),
    CFG_ELEMENT__TRISTATE  ( L"Height"   , BSTR, m_bstrHeight, m_fPresence_Height    ),

    CFG_ELEMENT            ( L"Layout"   , BSTR, m_bstrLayout                        ),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(HelpHost::XMLConfig::WindowSettings)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(HelpHost::XMLConfig::WindowSettings,L"WindowSettings")

DEFINE_CONFIG_METHODS__NOCHILD(HelpHost::XMLConfig::WindowSettings)

////////////////////

CFG_BEGIN_FIELDS_MAP(HelpHost::XMLConfig::ApplyTo)
    CFG_ATTRIBUTE( L"SKU"           , BSTR, m_bstrSKU           ),
    CFG_ATTRIBUTE( L"Language"      , BSTR, m_bstrLanguage      ),

    CFG_ELEMENT  ( L"TopicToDisplay", BSTR, m_bstrTopicToDisplay),
    CFG_ELEMENT  ( L"Application"   , BSTR, m_bstrApplication   ),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(HelpHost::XMLConfig::ApplyTo)
    CFG_CHILD(HelpHost::XMLConfig::WindowSettings)
    CFG_CHILD(HelpHost::XMLConfig::Context)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(HelpHost::XMLConfig::ApplyTo,L"ApplyTo")


DEFINE_CONFIG_METHODS_CREATEINSTANCE_SECTION(HelpHost::XMLConfig::ApplyTo,tag,defSubType)
    if(tag == _cfg_table_tags[0])
    {
        delete m_WindowSettings;
        m_WindowSettings = new WindowSettings; if(!m_WindowSettings) return E_OUTOFMEMORY;

        defSubType = m_WindowSettings;
        return S_OK;
    }
    if(tag == _cfg_table_tags[1])
    {
        delete m_Context;
        m_Context = new Context; if(!m_Context) return E_OUTOFMEMORY;

        defSubType = m_Context;
        return S_OK;
    }
DEFINE_CONFIG_METHODS_SAVENODE_SECTION(HelpHost::XMLConfig::ApplyTo,xdn)
    if(m_WindowSettings)
    {
        if(FAILED(hr = MPC::Config::SaveSubNode( m_WindowSettings, xdn ))) return hr;
    }

    if(m_Context)
    {
        if(FAILED(hr = MPC::Config::SaveSubNode( m_Context, xdn ))) return hr;
    }
DEFINE_CONFIG_METHODS_END(HelpHost::XMLConfig::ApplyTo)

////////////////////

CFG_BEGIN_FIELDS_MAP(HelpHost::XMLConfig)
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(HelpHost::XMLConfig)
    CFG_CHILD(HelpHost::XMLConfig::ApplyTo)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(HelpHost::XMLConfig,L"HelpSession")


DEFINE_CONFIG_METHODS_CREATEINSTANCE_SECTION(HelpHost::XMLConfig,tag,defSubType)
    if(tag == _cfg_table_tags[0])
    {
        defSubType = &(*(m_lstSessions.insert( m_lstSessions.end() )));
        return S_OK;
    }
DEFINE_CONFIG_METHODS_SAVENODE_SECTION(HelpHost::XMLConfig,xdn)
    hr = MPC::Config::SaveList( m_lstSessions, xdn );
DEFINE_CONFIG_METHODS_END(HelpHost::XMLConfig)

////////////////////////////////////////////////////////////////////////////////

HelpHost::XMLConfig::Context::Context()
{
    // CComBSTR m_bstrID;
    //
    // CComBSTR m_bstrTaxonomyPath;
    // CComBSTR m_bstrNodeToHighlight;
    // CComBSTR m_bstrTopicToHighlight;
    // CComBSTR m_bstrQuery;
}

////////////////////////////////////////////////////////////////////////////////

HelpHost::XMLConfig::WindowSettings::WindowSettings()
{
                                                         // CComBSTR m_bstrLayout;
    m_fNoResize  = false; m_fPresence_NoResize  = false; // bool     m_fNoResize ; bool m_fPresence_NoResize;
    m_fMaximized = false; m_fPresence_Maximized = false; // bool     m_fMaximized; bool m_fPresence_Maximized;
                          m_fPresence_Title     = false; // CComBSTR m_bstrTitle ; bool m_fPresence_Title;
                          m_fPresence_Left      = false; // CComBSTR m_bstrLeft  ; bool m_fPresence_Left;
                          m_fPresence_Top       = false; // CComBSTR m_bstrTop   ; bool m_fPresence_Top;
                          m_fPresence_Width     = false; // CComBSTR m_bstrWidth ; bool m_fPresence_Width;
                          m_fPresence_Height    = false; // CComBSTR m_bstrHeight; bool m_fPresence_Height;
}

////////////////////////////////////////////////////////////////////////////////

HelpHost::XMLConfig::ApplyTo::ApplyTo()
{
                             // CComBSTR        m_bstrSKU;
                             // CComBSTR        m_bstrLanguage;
                             //
                             // CComBSTR        m_bstrTopicToDisplay;
                             // CComBSTR        m_bstrApplication;
    m_WindowSettings = NULL; // WindowSettings* m_WindowSettings;
    m_Context        = NULL; // Context*        m_Context;
}

HelpHost::XMLConfig::ApplyTo::~ApplyTo()
{
    delete m_WindowSettings;
    delete m_Context;
}

bool HelpHost::XMLConfig::ApplyTo::MatchSystem( /*[in]*/  CPCHHelpCenterExternal* external ,
												/*[out]*/ Taxonomy::HelpSet&      ths      )
{
	if(OfflineCache::Root::s_GLOBAL->IsReady())
	{
		if(SUCCEEDED(OfflineCache::Root::s_GLOBAL->FindMatch( m_bstrSKU, m_bstrLanguage, ths )))
		{
			return true;
		}
	}

	return false;
}

////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\connectivity\hyperlinks.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    HyperLinks.cpp

Abstract:
    This file contains the implementation of the HyperLinks library.

Revision History:
    Davide Massarenti   (Dmassare)  11/28/2000
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

static const DATE l_TIME_hour    = 1.0 / 24.0;
static const DATE l_TIME_minute  = l_TIME_hour / 60.0;
static const DATE l_TIME_second  = l_TIME_hour / 60.0;
static const DATE l_TIME_timeout = l_TIME_minute * 5.0;

static const WCHAR l_szMS_ITS     [] = L"ms-its:";
static const WCHAR l_szMSITSTORE  [] = L"mk:@MSITStore:";
static const WCHAR l_szITS        [] = L"its:";

static const WCHAR l_szHOMEPAGE   [] = L"hcp://services/centers/homepage";
static const WCHAR l_szSUPPORT    [] = L"hcp://services/centers/support";
static const WCHAR l_szOPTIONS    [] = L"hcp://services/centers/options";
static const WCHAR l_szUPDATE     [] = L"hcp://services/centers/update";
static const WCHAR l_szCOMPAT     [] = L"hcp://services/centers/compat";
static const WCHAR l_szTOOLS      [] = L"hcp://services/centers/tools";
static const WCHAR l_szERRMSG     [] = L"hcp://services/centers/errmsg";

static const WCHAR l_szSEARCH     [] = L"hcp://services/search";
static const WCHAR l_szINDEX      [] = L"hcp://services/index";
static const WCHAR l_szSUBSITE    [] = L"hcp://services/subsite";

static const WCHAR l_szFULLWINDOW [] = L"hcp://services/layout/fullwindow";
static const WCHAR l_szCONTENTONLY[] = L"hcp://services/layout/contentonly";
static const WCHAR l_szKIOSK      [] = L"hcp://services/layout/kiosk";
static const WCHAR l_szXML        [] = L"hcp://services/layout/xml";

static const WCHAR l_szREDIRECT   [] = L"hcp://services/redirect";

static const WCHAR l_szHCP        [] = L"hcp://";
static const WCHAR l_szHCP_redir  [] = L"hcp:";

static const WCHAR l_szAPPLICATION[] = L"app:";

static const WCHAR l_szRESOURCE   [] = L"res://";

//////////////////////////////////////////////////////////////////////////////////

typedef enum
{
    QFT_TEXT       ,
    QFT_URL        ,
    QFT_TAXONOMY   ,
    QFT_APPLICATION,
} QueryFieldType;

struct QueryField
{
    LPCWSTR        szName;
    QueryFieldType qft;
    bool           fOptional;
};

struct Pattern
{
    LPCWSTR            szTxt;
    size_t             iLen; /* -1 for complete match */
    HyperLinks::Format fmt;

    const QueryField*  rgQueryFields;
    size_t             iQueryFields;
};

////////////////////

static const QueryField l_rgTopic   [] = { { L"topic"      , QFT_URL        , false } };
static const QueryField l_rgTopicOpt[] = { { L"topic"      , QFT_URL        , true  } };

static const QueryField l_rgSEARCH  [] = { { L"query"      , QFT_TEXT       , false } ,
                                           { L"topic"      , QFT_URL        , true  } };

static const QueryField l_rgINDEX   [] = { { L"scope"      , QFT_APPLICATION, true  } ,
                                           { L"select"     , QFT_APPLICATION, true  } ,
                                           { L"topic"      , QFT_URL        , true  } };

static const QueryField l_rgSUBSITE [] = { { L"node"       , QFT_TAXONOMY   , false } ,
                                           { L"select"     , QFT_TAXONOMY   , true  } ,
                                           { L"topic"      , QFT_URL        , true  } };

static const QueryField l_rgXML     [] = { { L"definition" , QFT_URL        , false } ,
                                           { L"topic"      , QFT_URL        , true  } };

static const QueryField l_rgREDIRECT[] = { { L"online"     , QFT_URL        , false } ,
                                           { L"offline"    , QFT_URL        , false } };

static const QueryField l_rgAPP     [] = { { L"topic"      , QFT_URL        , true  } };


static const Pattern l_rgPattern[] =
{
    { l_szMS_ITS     , MAXSTRLEN( l_szMS_ITS      ), HyperLinks::FMT_MSITS                                                      },
    { l_szMSITSTORE  , MAXSTRLEN( l_szMSITSTORE   ), HyperLinks::FMT_MSITS                                                      },
    { l_szITS        , MAXSTRLEN( l_szITS         ), HyperLinks::FMT_MSITS                                                      },

    ////////////////////

    { l_szHOMEPAGE   , -1                          , HyperLinks::FMT_CENTER_HOMEPAGE                                            },
    { l_szSUPPORT    , -1                          , HyperLinks::FMT_CENTER_SUPPORT    , l_rgTopicOpt, ARRAYSIZE(l_rgTopicOpt ) },
    { l_szOPTIONS    , -1                          , HyperLinks::FMT_CENTER_OPTIONS    , l_rgTopicOpt, ARRAYSIZE(l_rgTopicOpt ) },
    { l_szUPDATE     , -1                          , HyperLinks::FMT_CENTER_UPDATE                                              },
    { l_szCOMPAT     , -1                          , HyperLinks::FMT_CENTER_COMPAT                                              },
    { l_szTOOLS      , -1                          , HyperLinks::FMT_CENTER_TOOLS      , l_rgTopicOpt, ARRAYSIZE(l_rgTopicOpt ) },
    { l_szERRMSG     , -1                          , HyperLinks::FMT_CENTER_ERRMSG                                              },

    { l_szSEARCH     , -1                          , HyperLinks::FMT_SEARCH            , l_rgSEARCH  , ARRAYSIZE(l_rgSEARCH   ) },
    { l_szINDEX      , -1                          , HyperLinks::FMT_INDEX             , l_rgINDEX   , ARRAYSIZE(l_rgINDEX    ) },
    { l_szSUBSITE    , -1                          , HyperLinks::FMT_SUBSITE           , l_rgSUBSITE , ARRAYSIZE(l_rgSUBSITE  ) },

    { l_szFULLWINDOW , -1                          , HyperLinks::FMT_LAYOUT_FULLWINDOW , l_rgTopic   , ARRAYSIZE(l_rgTopic    ) },
    { l_szCONTENTONLY, -1                          , HyperLinks::FMT_LAYOUT_CONTENTONLY, l_rgTopic   , ARRAYSIZE(l_rgTopic    ) },
    { l_szKIOSK      , -1                          , HyperLinks::FMT_LAYOUT_KIOSK      , l_rgTopic   , ARRAYSIZE(l_rgTopic    ) },
    { l_szXML        , -1                          , HyperLinks::FMT_LAYOUT_XML        , l_rgXML     , ARRAYSIZE(l_rgXML      ) },

    { l_szREDIRECT   , -1                          , HyperLinks::FMT_REDIRECT          , l_rgREDIRECT, ARRAYSIZE(l_rgREDIRECT ) },

    { l_szHCP        , MAXSTRLEN( l_szHCP         ), HyperLinks::FMT_HCP                                                        },
    { l_szHCP_redir  , MAXSTRLEN( l_szHCP_redir   ), HyperLinks::FMT_HCP_REDIR                                                  },

    ////////////////////

    { l_szAPPLICATION, MAXSTRLEN( l_szAPPLICATION ), HyperLinks::FMT_APPLICATION       , l_rgAPP     , ARRAYSIZE(l_rgAPP      ) },

    ////////////////////

    { l_szRESOURCE   , MAXSTRLEN( l_szRESOURCE    ), HyperLinks::FMT_RESOURCE                                                   },

    ////////////////////

    { NULL                                                                                                                      }
};

HyperLinks::ParsedUrl::ParsedUrl()
{
                                                // MPC::wstring       m_strURL;
    m_fmt          = HyperLinks::FMT_INVALID;   // Format             m_fmt;
    m_state        = HyperLinks::STATE_INVALID; // State              m_state;
    m_dLastChecked = 0;                         // DATE               m_dLastChecked;
    m_fBackground  = true;                      // bool               m_fBackground;
                                                //
                                                // MPC::wstring       m_strBasePart;
                                                // MPC::WStringLookup m_mapQuery;
                                                //
    m_hcpRedir     = false;                     // bool			      m_hcpRedir;

}

HRESULT HyperLinks::ParsedUrl::Initialize( /*[in]*/ LPCWSTR szURL )
{
    __HCP_FUNC_ENTRY( "HyperLinks::ParsedUrl::Initialize" );

    HRESULT hr;

    SANITIZEWSTR(szURL);


    m_strURL  = szURL;
    m_fmt     = HyperLinks::FMT_INVALID;
    m_state   = HyperLinks::STATE_NOTPROCESSED;


    MPC::HTML::ParseHREF( m_strURL.c_str(), m_strBasePart, m_mapQuery );


    if(m_strBasePart.size() == 0)
    {
        m_state = HyperLinks::STATE_MALFORMED;
    }
    else if(MPC::MSITS::IsCHM( m_strBasePart.c_str() ))
    {
        m_fmt = HyperLinks::FMT_MSITS;
    }
    else
    {
        CComBSTR bstrURL( m_strBasePart.c_str() ); if(bstrURL) ::CharLowerW( bstrURL );

        szURL = bstrURL;
        for(const Pattern* ptr=l_rgPattern; ptr->szTxt; ptr++)
        {
            int iCmp;

            if(ptr->iLen) iCmp = wcsncmp( szURL, ptr->szTxt, ptr->iLen );
            else          iCmp = wcscmp ( szURL, ptr->szTxt            );

            if(iCmp == 0)
            {
                const QueryField* field = ptr->rgQueryFields;

                for(size_t i=0; i<ptr->iQueryFields; i++, field++)
                {
                    CComBSTR bstrValue;

                    if(GetQueryField( field->szName, bstrValue ) == false)
                    {
                        if(field->fOptional == false)
                        {
                            m_state = HyperLinks::STATE_MALFORMED;
                            break;
                        }
                    }
                    else
                    {
                        if(field->qft == QFT_TEXT)
                        {
                            ;
                        }
                        else if(field->qft == QFT_URL)
                        {
                            if(FAILED(IsValid( bstrValue )))
                            {
                                m_state = HyperLinks::STATE_MALFORMED;
                                break;
                            }
                        }
                        else if(field->qft == QFT_TAXONOMY)
                        {
                            /* TO DO */
                        }
                        else if(field->qft == QFT_APPLICATION)
                        {
                            /* TO DO */
                        }
                    }
                }

                m_fmt = ptr->fmt;
                break;
            }
        }

        //
        // If the URL begins with HCP://, check if it's valid HCP or is HCP redirection
        //
        if(m_fmt == HyperLinks::FMT_HCP)
        {
            if (CHCPProtocol::IsHCPRedirection(szURL))
            {
                // Treat as HCP redirection
                m_fmt = HyperLinks::FMT_HCP_REDIR;
                m_hcpRedir = true;
                __MPC_SET_ERROR_AND_EXIT(hr, Initialize( m_strURL.c_str() + MAXSTRLEN( l_szHCP ) ));
            }
        }

        //
        // If the URL begins with HCP: but not HCP://, it's a protocol redirection, so recurse.
        //
        if(m_fmt == HyperLinks::FMT_HCP_REDIR)
        {
            m_hcpRedir = true;
            __MPC_SET_ERROR_AND_EXIT(hr, Initialize( m_strURL.c_str() + MAXSTRLEN( l_szHCP_redir ) ));
        }

        if(m_fmt == HyperLinks::FMT_INVALID) // Still not resolved...
        {
            MPC::URL        url;
            INTERNET_SCHEME scheme;

            if(SUCCEEDED(url.put_URL   ( szURL  )) &&
               SUCCEEDED(url.get_Scheme( scheme ))  )
            {
                switch(scheme)
                {
                case INTERNET_SCHEME_UNKNOWN   : m_fmt   = HyperLinks::FMT_INTERNET_UNKNOWN   ; break;
                case INTERNET_SCHEME_FTP       : m_fmt   = HyperLinks::FMT_INTERNET_FTP       ; break;
                case INTERNET_SCHEME_GOPHER    : m_fmt   = HyperLinks::FMT_INTERNET_GOPHER    ; break;
                case INTERNET_SCHEME_HTTP      : m_fmt   = HyperLinks::FMT_INTERNET_HTTP      ; break;
                case INTERNET_SCHEME_HTTPS     : m_fmt   = HyperLinks::FMT_INTERNET_HTTPS     ; break;
                case INTERNET_SCHEME_FILE      : m_fmt   = HyperLinks::FMT_INTERNET_FILE      ; break;
                case INTERNET_SCHEME_NEWS      : m_fmt   = HyperLinks::FMT_INTERNET_NEWS      ; break;
                case INTERNET_SCHEME_MAILTO    : m_fmt   = HyperLinks::FMT_INTERNET_MAILTO    ; break;
                case INTERNET_SCHEME_SOCKS     : m_fmt   = HyperLinks::FMT_INTERNET_SOCKS     ; break;
                case INTERNET_SCHEME_JAVASCRIPT: m_fmt   = HyperLinks::FMT_INTERNET_JAVASCRIPT; break;
                case INTERNET_SCHEME_VBSCRIPT  : m_fmt   = HyperLinks::FMT_INTERNET_VBSCRIPT  ; break;
                default                        : m_state = HyperLinks::STATE_MALFORMED        ; break;
                }
            }
        }
    }

    hr = S_OK;



    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

bool HyperLinks::ParsedUrl::IsLocal()
{
    switch(m_fmt)
    {
    case HyperLinks::FMT_INTERNET_UNKNOWN   :
    case HyperLinks::FMT_INTERNET_FTP       :
    case HyperLinks::FMT_INTERNET_GOPHER    :
    case HyperLinks::FMT_INTERNET_HTTP      :
    case HyperLinks::FMT_INTERNET_HTTPS     :
    case HyperLinks::FMT_INTERNET_FILE      :
    case HyperLinks::FMT_INTERNET_NEWS      :
    case HyperLinks::FMT_INTERNET_MAILTO    :
    case HyperLinks::FMT_INTERNET_SOCKS     :
    case HyperLinks::FMT_INTERNET_JAVASCRIPT:
    case HyperLinks::FMT_INTERNET_VBSCRIPT  :
        return false;

    case HyperLinks::FMT_MSITS:
        //
        // Make sure it's not on a network share!
        //
        {
            CComBSTR bstrStorageName;
            CComBSTR bstrFilePath;

            if(MPC::MSITS::IsCHM( m_strURL.c_str(), &bstrStorageName, &bstrFilePath ))
            {
                if(wcsncmp( L"\\\\", SAFEBSTR(bstrStorageName), 2 ) == 0)
                {
                    return false;
                }
            }
        }
        break;

    }

    return true;
}

HyperLinks::State HyperLinks::ParsedUrl::CheckState( /*[in/out]*/ bool& fFirstWinInetUse )
{
    HRESULT  hr;
    State    state = HyperLinks::STATE_NOTFOUND;
    LPCWSTR  szURL = m_strURL.c_str();
    LPCWSTR  szEnd;
    CComBSTR bstrURL;

    //
    // Skip the bookmark sign.
    //
    if((szEnd = wcschr( szURL, '#' )))
    {
        bstrURL.Attach( ::SysAllocStringLen( szURL, (szEnd - szURL) ) );
        szURL = SAFEBSTR( bstrURL );
    }

    switch(m_fmt)
    {
    case HyperLinks::FMT_INVALID            :
        state = HyperLinks::STATE_MALFORMED;
        break;

    case HyperLinks::FMT_INTERNET_FTP       :
    case HyperLinks::FMT_INTERNET_GOPHER    :
    case HyperLinks::FMT_INTERNET_HTTP      :
    case HyperLinks::FMT_INTERNET_HTTPS     :
    case HyperLinks::FMT_INTERNET_FILE      :
    case HyperLinks::FMT_INTERNET_NEWS      :
		while(1)
        {
            DWORD dwTimeout = m_fBackground ? HC_TIMEOUT_LINKCHECKER_BACKGROUND : HC_TIMEOUT_LINKCHECKER_FOREGROUND;

            if(SUCCEEDED(hr = MPC::Connectivity::DestinationReachable( szURL, dwTimeout )))
            {
                state = HyperLinks::STATE_ALIVE;
            }
            else if(hr == E_INVALIDARG) // Unsupported protocol, assume the link is OK.
            {
                state = HyperLinks::STATE_ALIVE;
            }
            else if(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
            {
                state = HyperLinks::STATE_NOTFOUND;
            }
            else if(hr == HRESULT_FROM_WIN32(ERROR_INTERNET_DISCONNECTED))
            {
                state = HyperLinks::STATE_OFFLINE;
            }
            else
            {
                //
                // If it's the first time through, it could be that WinINET couldn't activate the proxy code in time...
                //
                if(fFirstWinInetUse == true)
                {
					fFirstWinInetUse = false; continue;
                }

				if(SUCCEEDED(MPC::Connectivity::NetworkAlive( dwTimeout )))
				{
					state = HyperLinks::STATE_UNREACHABLE;
				}
				else
				{
					state = HyperLinks::STATE_OFFLINE;
				}
            }

            fFirstWinInetUse = false; break;
        }
        break;

    case HyperLinks::FMT_INTERNET_UNKNOWN   :
    case HyperLinks::FMT_INTERNET_MAILTO    :
    case HyperLinks::FMT_INTERNET_SOCKS     :
    case HyperLinks::FMT_INTERNET_JAVASCRIPT:
    case HyperLinks::FMT_INTERNET_VBSCRIPT  :
        state = HyperLinks::STATE_ALIVE;
        break;

    case HyperLinks::FMT_HCP                :
        {
            CComPtr<IInternetProtocolRoot> obj;

            state = HyperLinks::STATE_NOTFOUND;

            if(SUCCEEDED(CHCPProtocol::CreateInstance( &obj )))
            {
                if(SUCCEEDED(obj->Start( szURL, NULL, NULL, 0, NULL )))
                {
                    state = HyperLinks::STATE_ALIVE;
                }
            }
        }
        break;

    case HyperLinks::FMT_MSITS              :
        {
            MPC::wstring     strUrlModified;
            MPC::wstring     strUrlModified2;
            CComBSTR         bstrStorageName;
            CComBSTR         bstrFilePath;
            CComPtr<IStream> stream;

            state = HyperLinks::STATE_NOTFOUND;

            CPCHWrapProtocolInfo::NormalizeUrl( szURL                 , strUrlModified , /*fReverse*/true  );
            CPCHWrapProtocolInfo::NormalizeUrl( strUrlModified.c_str(), strUrlModified2, /*fReverse*/false );
            if(MPC::MSITS::IsCHM( strUrlModified2.c_str(), &bstrStorageName, &bstrFilePath ))
            {
                if(SUCCEEDED(MPC::MSITS::OpenAsStream( bstrStorageName, bstrFilePath, &stream )))
                {
                    state = HyperLinks::STATE_ALIVE;
                }
            }
        }
        break;

    case HyperLinks::FMT_CENTER_HOMEPAGE    :
    case HyperLinks::FMT_CENTER_SUPPORT     :
    case HyperLinks::FMT_CENTER_OPTIONS     :
    case HyperLinks::FMT_CENTER_UPDATE      :
    case HyperLinks::FMT_CENTER_COMPAT      :
    case HyperLinks::FMT_CENTER_TOOLS       :
    case HyperLinks::FMT_CENTER_ERRMSG      :
        state = HyperLinks::STATE_ALIVE;
        break;

    case HyperLinks::FMT_SEARCH             :
    case HyperLinks::FMT_INDEX              :
    case HyperLinks::FMT_SUBSITE            :
        state = HyperLinks::STATE_ALIVE;
        break;

    case HyperLinks::FMT_LAYOUT_FULLWINDOW  :
    case HyperLinks::FMT_LAYOUT_CONTENTONLY :
    case HyperLinks::FMT_LAYOUT_KIOSK       :
    case HyperLinks::FMT_LAYOUT_XML         :
        state = HyperLinks::STATE_ALIVE;
        break;

    case HyperLinks::FMT_REDIRECT           :
        state = HyperLinks::STATE_ALIVE;
        break;

    case HyperLinks::FMT_APPLICATION        :
        state = HyperLinks::STATE_ALIVE;
        break;

    case HyperLinks::FMT_RESOURCE           :
        state = HyperLinks::STATE_UNREACHABLE;
        break;
    }

    m_dLastChecked = MPC::GetLocalTime();

    return state;
}

bool HyperLinks::ParsedUrl::IsOkToProceed()
{
    switch(m_state)
    {
    case HyperLinks::STATE_NOTPROCESSED:
    case HyperLinks::STATE_CHECKING    :
    case HyperLinks::STATE_ALIVE       :
        return true;
    }

    return false;
}


bool HyperLinks::ParsedUrl::HasQueryField( /*[in]*/ LPCWSTR szField )
{
    MPC::WStringLookupIter it = m_mapQuery.find( szField );

    return (it != m_mapQuery.end());
}

bool HyperLinks::ParsedUrl::GetQueryField( /*[in]*/ LPCWSTR szField, /*[in]*/ CComBSTR& bstrValue )
{
    MPC::WStringLookupIter it = m_mapQuery.find( szField );

    if(it != m_mapQuery.end())
    {
        bstrValue = it->second.c_str();
        return true;
    }

    bstrValue.Empty();
    return false;
}

////////////////////////////////////////////////////////////////////////////////

HyperLinks::UrlHandle::UrlHandle()
{
    m_main = NULL; // Lookup*    m_main;
    m_pu   = NULL; // ParsedUrl* m_pu;
}

HyperLinks::UrlHandle::~UrlHandle()
{
    Release();
}

void HyperLinks::UrlHandle::Attach( /*[in]*/ Lookup*    main ,
                                    /*[in]*/ ParsedUrl* pu   )
{
    Release();

    m_main = main; if(main) main->Lock();
    m_pu   = pu;
}

void HyperLinks::UrlHandle::Release()
{
    if(m_main) m_main->Unlock();

    m_main = NULL;
    m_pu   = NULL;
}

////////////////////////////////////////////////////////////////////////////////

HyperLinks::Lookup::Lookup()
{
    // PendingUrlList m_lst;
    // UrlMap         m_map;
}

HyperLinks::Lookup::~Lookup()
{
    Thread_Wait();
}

////////////////////

HyperLinks::Lookup* HyperLinks::Lookup::s_GLOBAL( NULL );

HRESULT HyperLinks::Lookup::InitializeSystem()
{
    if(s_GLOBAL == NULL)
    {
        s_GLOBAL = new HyperLinks::Lookup;
    }

    return s_GLOBAL ? S_OK : E_OUTOFMEMORY;
}

void HyperLinks::Lookup::FinalizeSystem()
{
    if(s_GLOBAL)
    {
        delete s_GLOBAL; s_GLOBAL = NULL;
    }
}

////////////////////

HRESULT HyperLinks::Lookup::RunChecker()
{
    __HCP_FUNC_ENTRY( "HyperLinks::Lookup::RunChecker" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    bool                         fFirstWinInetUse = true;


    Thread_SignalMain();

    while(Thread_IsAborted() == false)
    {
        bool           fSleep  = true;
        ParsedUrl*     urlBest = NULL;
        PendingUrlIter it;

        //
        // Look for the first query store not ready and execute it.
        //
        for(it = m_lst.begin(); it != m_lst.end();)
        {
            ParsedUrl* url = *it;

            if(url->m_state != HyperLinks::STATE_NOTPROCESSED)
            {
                m_lst.erase( it );

                it      = m_lst.begin();
                urlBest = NULL;
            }
            else
            {
                if(url->m_fBackground == false)
                {
                    urlBest = url;
                    break;
                }

                urlBest = url;
                it++;
            }
        }

        if(urlBest)
        {
            State state = HyperLinks::STATE_NOTFOUND;

            //
            // Remove this query from the pending list.
            //
            for(it = m_lst.begin(); it != m_lst.end(); )
            {
                if(*it == urlBest)
                {
                    m_lst.erase( it );

                    it = m_lst.begin();
                }
                else
                {
                    it++;
                }
            }

            DebugLog( L"%%%%%%%%%%%%%%%%%%%% CHECKING %s\n", urlBest->m_strURL.c_str() );
            urlBest->m_state = HyperLinks::STATE_CHECKING;

            lock = NULL;
            __MPC_PROTECT( state = urlBest->CheckState( fFirstWinInetUse ) );
            lock = this;

            urlBest->m_state = state;

            Thread_SignalMain();

            fSleep = false;
        }

        if(fSleep)
        {
            lock = NULL;
            Thread_WaitForEvents( NULL, INFINITE );
            lock = this;
        }
    }

    hr = S_OK;


    Thread_Abort();

    __HCP_FUNC_EXIT(hr);
}

HRESULT HyperLinks::Lookup::CreateItem( /*[in ]*/ LPCWSTR     szURL ,
                                        /*[out]*/ ParsedUrl*& pu    )
{
    __HCP_FUNC_ENTRY( "HyperLinks::Lookup::CreateItem" );

    HRESULT        hr;
    UrlIter        it;
    MPC::wstringUC strURL( SAFEWSTR( szURL ) );

    it = m_map.find( strURL );
    if(it == m_map.end())
    {
        pu = &(m_map[ strURL ]);

        __MPC_EXIT_IF_METHOD_FAILS(hr, pu->Initialize( szURL ));
    }
    else
    {
        pu = &it->second;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////

HRESULT HyperLinks::Lookup::Queue( /*[in]*/ LPCWSTR szURL )
{
    UrlHandle uh;

    return Get( szURL, uh );
}

HRESULT HyperLinks::Lookup::Get( /*[in]*/ LPCWSTR    szURL          ,
                                 /*[in]*/ UrlHandle& uh             ,
                                 /*[in]*/ DWORD      dwWaitForCheck ,
                                 /*[in]*/ bool       fForce         )
{
    __HCP_FUNC_ENTRY( "HyperLinks::Lookup::Get" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    ParsedUrl*                   pu = NULL;


    uh.Release();

    ////////////////////////////////////////////////////////////////////////////////

    if(Thread_IsRunning() == false)
    {
        lock = NULL;
        __MPC_EXIT_IF_METHOD_FAILS(hr, Thread_Start( this, RunChecker, NULL ));

        Thread_WaitNotificationFromWorker( INFINITE, /*fNoMessagePump*/true );
        lock = this;
    }

    ////////////////////////////////////////////////////////////////////////////////

    __MPC_EXIT_IF_METHOD_FAILS(hr, CreateItem( szURL, pu ));

    if(fForce)
    {
        pu->m_state = HyperLinks::STATE_NOTPROCESSED;
    }

    switch(pu->m_state)
    {
    case HyperLinks::STATE_ALIVE      :
    case HyperLinks::STATE_NOTFOUND   :
    case HyperLinks::STATE_UNREACHABLE:
    case HyperLinks::STATE_OFFLINE    :
        if(dwWaitForCheck)
        {
            //
            // Make sure the state is not stale.
            //
            DATE dNow = MPC::GetLocalTime();

            if((dNow - pu->m_dLastChecked) >= l_TIME_timeout)
            {
                pu->m_state = HyperLinks::STATE_NOTPROCESSED;
            }
        }
        break;
    }

    if(pu->m_state == HyperLinks::STATE_NOTPROCESSED)
    {
        bool fQueue = false;
        bool fWait  = false;

        if(dwWaitForCheck)
        {
            //
            // Elevate the URL to "important".
            //
            pu->m_fBackground = false;

            fWait = true;

            if(pu->IsLocal() == false)
            {
                fQueue = true;
            }
        }
        else
        {
            fQueue = true;
        }

        if(fQueue)
        {
            m_lst.push_back( pu );
            Thread_Signal();
        }

        if(fWait)
        {
            if(pu->IsLocal())
            {
                bool fFirstWinInetUse = false;

                pu->m_state = pu->CheckState( fFirstWinInetUse );
            }
            else
            {
                int iRetry = 5;

                dwWaitForCheck /= iRetry;

                while(pu->m_state == HyperLinks::STATE_NOTPROCESSED ||
                      pu->m_state == HyperLinks::STATE_CHECKING      )
                {
                    DWORD dwRes;

                    lock  = NULL;
                    dwRes = Thread_WaitNotificationFromWorker( dwWaitForCheck, /*fNoMessagePump*/true );
                    lock  = this;

                    if(iRetry-- == 0)
                    {
                        __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE);
                    }
                }
            }
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(pu) uh.Attach( this, pu );

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT HyperLinks::IsValid( /*[in]*/ LPCWSTR szURL )
{
    __HCP_FUNC_ENTRY( "HyperLinks::IsValid" );

    HRESULT   hr;
    ParsedUrl pu;

    __MPC_EXIT_IF_METHOD_FAILS(hr, pu.Initialize( szURL ));

    switch(pu.m_state)
    {
    case HyperLinks::STATE_INVALID  :
    case HyperLinks::STATE_MALFORMED:
        __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\controls\helpviewerwrapper.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    HelpViewerWrapper.cpp

Abstract:
    This file contains the code to embed the Html Help Viewer as a normal ActiveX control.

Revision History:
    Davide Massarenti   (Dmassare)  10/10/99
        created

******************************************************************************/

#include "stdafx.h"

#include <shlguid.h>

//
// STAGING definition, until the new HTMLHELP.H gets into public.
//
#ifndef HH_SET_QUERYSERVICE
#define HH_SET_QUERYSERVICE     0x001E  // Set the Host IQueryService interface
#endif

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

CPCHHelpViewerWrapper::ServiceProvider::ServiceProvider()
{
    m_parent = NULL; // CPCHHelpCenterExternal* m_parent;
    m_hWnd   = NULL; // HWND                    m_hWnd;
}

CPCHHelpViewerWrapper::ServiceProvider::~ServiceProvider()
{
    Detach();
}

HRESULT CPCHHelpViewerWrapper::ServiceProvider::Attach( /*[in]*/ CPCHHelpCenterExternal* parent, /*[in]*/ HWND hWnd )
{
    HRESULT hr;

    m_parent = parent;

    if(::HtmlHelpW( hWnd, NULL, HH_SET_QUERYSERVICE, (DWORD_PTR)this ))
    {
        m_hWnd = hWnd;
        hr     = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

void CPCHHelpViewerWrapper::ServiceProvider::Detach()
{
    if(m_hWnd)
    {
        (void)::HtmlHelpW( m_hWnd, NULL, HH_SET_QUERYSERVICE, (DWORD_PTR)NULL );
    }

    m_parent = NULL;
    m_hWnd   = NULL;
}

////////////////////////////////////////

STDMETHODIMP CPCHHelpViewerWrapper::ServiceProvider::QueryService( REFGUID guidService, REFIID riid, void **ppv )
{
    HRESULT hr = E_NOINTERFACE;

    if(m_parent)
    {
        if(InlineIsEqualGUID( guidService, SID_SInternetSecurityManager ) && m_parent->SecurityManager())
        {
            hr = m_parent->SecurityManager()->QueryInterface( riid, ppv );
        }
        else if(InlineIsEqualGUID( guidService, SID_SElementBehaviorFactory ))
        {
            if(InlineIsEqualGUID( riid, IID_IPCHHelpCenterExternal ))
            {
                hr = m_parent->QueryInterface( riid, ppv );
            }
            else if(m_parent->BehaviorFactory())
            {
                hr = m_parent->BehaviorFactory()->QueryInterface( riid, ppv );
            }
        }
        else if(InlineIsEqualGUID( riid, IID_IDocHostUIHandler ) && m_parent->DocHostUIHandler())
        {
            hr = m_parent->DocHostUIHandler()->QueryInterface( riid, ppv );
        }
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

MPC::CComSafeAutoCriticalSection CPCHHelpViewerWrapper::s_csec;
bool                             CPCHHelpViewerWrapper::s_fInitialized = false;
DWORD                            CPCHHelpViewerWrapper::s_dwLastStyle  = 0;
MPC::WStringList                 CPCHHelpViewerWrapper::s_lstAvailable;

HINSTANCE                        CPCHHelpViewerWrapper::s_hInst               = NULL;
LPFNOBJECTFROMLRESULT            CPCHHelpViewerWrapper::s_pfObjectFromLresult = NULL;


/////////////////////////////////////////////////////////////////////////////

static WCHAR l_szHCP      [] = L"hcp://";
static WCHAR l_szMS_ITS   [] = L"ms-its:";
static WCHAR l_szMSITSTORE[] = L"mk@MSITStore:";

static WCHAR l_szBLANK    [] = L"hcp://system/panels/blank.htm";
static WCHAR l_szBLANK2   [] = L"hcp://system/panels/HHWRAPPER.htm";

/////////////////////////////////////////////////////////////////////////////

CPCHHelpViewerWrapper::CPCHHelpViewerWrapper()
{
    m_bWindowOnly     = TRUE; // Inherited from CComControlBase


    m_parent          = NULL; // CPCHHelpCenterExternal*                 m_parent;
    m_ServiceProvider = NULL; // CPCHHelpViewerWrapper::ServiceProvider* m_ServiceProvider;
                              //
    m_fFirstTime      = true; // bool                                    m_fFirstTime;
                              // MPC::wstring                            m_szWindowStyle;
    m_hwndHH          = NULL; // HWND                                    m_hwndHH;
                              //
                              // CComPtr<IHTMLDocument2>                 m_spDoc;
                              // CComPtr<IWebBrowser2>                   m_WB2;
                              // CComBSTR                                m_bstrPendingNavigation;
}

CPCHHelpViewerWrapper::~CPCHHelpViewerWrapper()
{
}

STDMETHODIMP CPCHHelpViewerWrapper::SetClientSite( IOleClientSite *pClientSite )
{
    CComQIPtr<IServiceProvider> sp = pClientSite;

    MPC::Release( (IUnknown*&)m_parent );

    if(sp && SUCCEEDED(sp->QueryService( SID_SElementBehaviorFactory, IID_IPCHHelpCenterExternal, (void **)&m_parent )))
    {
        ;
    }

    return IOleObjectImpl<CPCHHelpViewerWrapper>::SetClientSite( pClientSite );
}

/////////////////////////////////////////////////////////////////////////////

void CPCHHelpViewerWrapper::AcquireWindowStyle()
{
    if(m_szWindowStyle.length() == 0)
    {
        ////////////////////////////////////////
        //
        //
        //
        s_csec.Lock();

        // Explicitly load MSAA so we know if it's installed
        if(s_hInst == NULL)
        {
            s_hInst = ::LoadLibraryW( L"OLEACC.DLL" );
            if(s_hInst)
            {
                s_pfObjectFromLresult = (LPFNOBJECTFROMLRESULT)::GetProcAddress( s_hInst, "ObjectFromLresult" );
            }
        }

        //
        // If there's an old window style avaiable, reuse it!
        //
        {
            MPC::WStringIter it = s_lstAvailable.begin();

            if(it != s_lstAvailable.end())
            {
                m_szWindowStyle = *it;

                s_lstAvailable.erase( it );
            }
            else
            {
                WCHAR szSeq[64];

                swprintf( szSeq, L"HCStyle_%d", s_dwLastStyle++ );
                m_szWindowStyle = szSeq;
            }
        }

        s_csec.Unlock();
        //
        //
        //
        ////////////////////////////////////////


        //////////////////////////////////////////
        //
        // Initialize HH as single threaded.
        //
        if(s_fInitialized == false)
        {
            HH_GLOBAL_PROPERTY prop; ::VariantInit( &prop.var );

            prop.id          = HH_GPROPID_SINGLETHREAD;
            prop.var.vt      = VT_BOOL;
            prop.var.boolVal = VARIANT_TRUE;

            (void)::HtmlHelpW( NULL, NULL, HH_SET_GLOBAL_PROPERTY, (DWORD_PTR)&prop );

            ::VariantClear( &prop.var );

            s_fInitialized = true;
        }
        //
        //////////////////////////////////////////

        //////////////////////////////////////////
        //
        // Register Window Style
        //
        {
            USES_CONVERSION;

            HH_WINTYPE hhWinType;

            ::ZeroMemory( &hhWinType, sizeof(hhWinType) );

            hhWinType.idNotify        = ID_NOTIFY_FROM_HH;
            hhWinType.pszType         = (LPCTSTR)W2A(m_szWindowStyle.c_str()); // Unfortunately, HH_WINTYPE is using TCHAR instead of CHAR.
            hhWinType.fsValidMembers  = HHWIN_PARAM_RECT       |
                                        HHWIN_PARAM_PROPERTIES |
                                        HHWIN_PARAM_STYLES     |
                                        HHWIN_PARAM_EXSTYLES   |
                                        HHWIN_PARAM_TB_FLAGS;
            hhWinType.fsWinProperties = HHWIN_PROP_NODEF_STYLES   |
                                        HHWIN_PROP_NODEF_EXSTYLES |
                                        HHWIN_PROP_NOTITLEBAR;
            hhWinType.tabpos          = HHWIN_NAVTAB_LEFT;
            hhWinType.fNotExpanded    = FALSE;
            hhWinType.dwStyles        = WS_CHILD;
            hhWinType.dwExStyles      = WS_EX_CONTROLPARENT;

            ::GetWindowRect( m_hWnd, &hhWinType.rcWindowPos );
            hhWinType.rcWindowPos.right  -= hhWinType.rcWindowPos.left; hhWinType.rcWindowPos.left = 0;
            hhWinType.rcWindowPos.bottom -= hhWinType.rcWindowPos.top;  hhWinType.rcWindowPos.top  = 0;


            (void)::HtmlHelpA( m_hWnd, NULL, HH_SET_WIN_TYPE, (DWORD_PTR)&hhWinType );
        }
        //
        //////////////////////////////////////////
    }
}

void CPCHHelpViewerWrapper::ReleaseWindowStyle()
{
    if(m_szWindowStyle.length())
    {
        s_csec.Lock();

        //
        // Add the style to the list of available styles.
        //
        s_lstAvailable.push_back( m_szWindowStyle );
        m_szWindowStyle.erase();

        s_csec.Unlock();
    }
}

////////////////////////////////////////////////////////////////////////////////

//BUGBUG (carled) these are defined in a private copy of winuser.h from the oleacc team.
// these should be removed once this is checked in.
#ifndef WMOBJ_ID
#define WMOBJ_ID 0x0000
#endif

#ifndef WMOBJ_SAMETHREAD
#define WMOBJ_SAMETHREAD 0xFFFFFFFF
#endif

static BOOL CALLBACK EnumChildProc( HWND hwnd,LPARAM lParam )
{
    WCHAR buf[100];

    ::GetClassNameW( hwnd, buf, MAXSTRLEN(buf) );

    if(MPC::StrICmp( buf, L"Internet Explorer_Server" ) == 0)
    {
        *(HWND*)lParam = hwnd;

        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

void CPCHHelpViewerWrapper::ExtractWebBrowser()
{
    if(!m_spDoc && m_hwndHH && s_pfObjectFromLresult)
    {
        HWND hWndChild = NULL;

        // Get 1st document window
        ::EnumChildWindows( m_hwndHH, EnumChildProc, (LPARAM)&hWndChild );

        if(hWndChild)
        {
            LRESULT lRetVal;
            LRESULT ref    = 0;
            UINT    nMsg   = ::RegisterWindowMessageW( L"WM_HTML_GETOBJECT" );
            WPARAM  wParam = WMOBJ_ID;

            //------------------------------------------------
            //  If the window is on our thread, optimize the
            //  marshalling/unmarshalling.
            //
            //  However, the proxy support in IE is broken, so let's fake as if we are in the same thread.
            //
            //------------------------------------------------
            /*if(::GetWindowThreadProcessId( hWndChild, NULL ) == ::GetCurrentThreadId())*/ wParam |= WMOBJ_SAMETHREAD;

            lRetVal = ::SendMessageTimeout( hWndChild, nMsg, wParam, 0L, SMTO_ABORTIFHUNG, 10000, (PDWORD_PTR)&ref );
            if(lRetVal)
            {
                if(SUCCEEDED(s_pfObjectFromLresult( ref, IID_IHTMLDocument2, wParam, (void**)&m_spDoc )))
                {
                    CComQIPtr<IServiceProvider> sp = m_spDoc;
                    if(sp)
                    {
                        (void)sp->QueryService( IID_IWebBrowserApp, IID_IWebBrowser2, (void**)&m_WB2 );
                    }
                }
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHHelpViewerWrapper::get_WebBrowser( /*[out,retval]*/ IUnknown* *pVal )
{
    return MPC::CopyTo( (IWebBrowser2*)m_WB2, pVal );
}

STDMETHODIMP CPCHHelpViewerWrapper::Navigate( /*[in]*/ BSTR bstrURL )
{
    if(m_fFirstTime)
    {
        m_bstrPendingNavigation = bstrURL;
    }
    else
    {
        if(m_hWnd && m_parent)
        {
            AcquireWindowStyle();

            InternalDisplayTopic( bstrURL );
        }
    }

    return S_OK;
}

STDMETHODIMP CPCHHelpViewerWrapper::Print()
{
    __HCP_FUNC_ENTRY( "CPCHHelpViewerWrapper::Print" );

    HRESULT hr;

    if(m_WB2)
    {
        (void)m_WB2->ExecWB( OLECMDID_PRINT, OLECMDEXECOPT_DODEFAULT, NULL, NULL );
    }

    hr = S_OK;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

void CPCHHelpViewerWrapper::InternalDisplayTopic( /*[in]*/ LPCWSTR szURL )
{
    if(szURL)
    {
        MPC::wstring strURL;

        //
        // If the protocol begins with HCP:// and it for an MS-ITS: domain, remove HCP://
        //
        if(!_wcsnicmp( szURL, l_szHCP, MAXSTRLEN( l_szHCP ) ))
        {
            LPCWSTR szURL2 = &szURL[ MAXSTRLEN( l_szHCP ) ];

            if(!_wcsnicmp( szURL2, l_szMS_ITS   , MAXSTRLEN( l_szMS_ITS    ) ) ||
               !_wcsnicmp( szURL2, l_szMSITSTORE, MAXSTRLEN( l_szMSITSTORE ) )  )
            {
                szURL = szURL2;
            }
        }

        strURL  = szURL;
        strURL += L">";
        strURL += m_szWindowStyle;

        m_hwndHH = ::HtmlHelpW( m_hWnd, strURL.c_str(), HH_DISPLAY_TOPIC, NULL );
    }
}

////////////////////////////////////////////////////////////////////////////////

BOOL CPCHHelpViewerWrapper::ProcessWindowMessage( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult, DWORD dwMsgMapID )
{
    lResult = 0;

    switch(uMsg)
    {
    case WM_CREATE:
        {
            m_fFirstTime = true;

            AcquireWindowStyle();

            if(SUCCEEDED(MPC::CreateInstance( &m_ServiceProvider )))
            {
                (void)m_ServiceProvider->Attach( m_parent, m_hWnd );
            }

			InternalDisplayTopic( l_szBLANK ); // Load a blank page....
        }
        return TRUE;


    case WM_DESTROY:
        {
            if(m_parent) m_parent->SetHelpViewer( NULL );

            if(m_ServiceProvider)
            {
                m_ServiceProvider->Detach();

                MPC::Release( (IUnknown*&)m_ServiceProvider );
            }

            if(m_hwndHH)
            {
                ::SendMessage( m_hwndHH, WM_CLOSE, 0, 0 );

                m_hwndHH = NULL;
            }

            ReleaseWindowStyle();
        }
        return TRUE;

    case WM_ERASEBKGND:
        lResult = 1;
        return TRUE;

    case WM_SIZE:
        {
            if(m_hwndHH)
            {
                int nWidth  = LOWORD(lParam);  // width of client area
                int nHeight = HIWORD(lParam); // height of client area

                ::MoveWindow( m_hwndHH, 0, 0, nWidth, nHeight, TRUE );
            }
        }
        return TRUE;

////    case WM_PAINT:
////        {
////            static bool fFirst = true;
////
////            //          if(fFirst)
////            {
////                fFirst = false;
////
////                PAINTSTRUCT ps;
////
////                HDC hdc = ::BeginPaint( m_hWnd, &ps );
////                if(hdc)
////                {
////                    RECT rc;
////
////                    rc.left   = 20;
////                    rc.top    = 20;
////                    rc.right  = 200;
////                    rc.bottom = 200;
////
////                    ::FillRect( hdc, &rc, (HBRUSH)(COLOR_WINDOWTEXT+1) );
////                }
////                ::EndPaint( m_hWnd, &ps );
////            }
////        }
////        return TRUE;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            if(pnmh->idFrom == ID_NOTIFY_FROM_HH && pnmh->code == HHN_NAVCOMPLETE)
            {
                HHN_NOTIFY* notification = (HHN_NOTIFY*)pnmh;

                if(notification->pszUrl)
                {
                    if(m_fFirstTime)
                    {
                        m_fFirstTime = false;

                        ExtractWebBrowser();

                        if(m_parent)
                        {
                            CPCHHelpSession* hs = m_parent->HelpSession();

                            m_parent->SetHelpViewer( this );

                            if(hs) hs->IgnoreUrl( l_szBLANK2 );
                        }

						InternalDisplayTopic( l_szBLANK2 );
                    }
                    else
                    {
						if(m_bstrPendingNavigation)
						{
							InternalDisplayTopic( m_bstrPendingNavigation ); m_bstrPendingNavigation.Empty();
						}
                    }
                }

                return TRUE;
            }
        }
        break;
    }

    return CComControl<CPCHHelpViewerWrapper>::ProcessWindowMessage( hWnd, uMsg, wParam, lParam, lResult, dwMsgMapID );
}

/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////
//
// Private APIs shared with HTMLHelp.
//
#define HH_PRETRANSLATEMESSAGE2     0x0100   // Fix for Millenium pretranslate problem. Bug 7921

BOOL CPCHHelpViewerWrapper::PreTranslateAccelerator( LPMSG pMsg, HRESULT& hRet )
{
    hRet = S_FALSE;

    if(m_hwndHH)
    {
        // (weizhao) Added the following code to fix the problem with switching
        // panels using Ctrl-Tab and F6. HtmlHelp control's handling of these
        // messages is not consistent with Mars or Browser control. The following
        // fixes some of the inconsistencies.
        
        // check if self or any offspring window has focus
        for (HWND hwnd = ::GetFocus(); hwnd && hwnd != m_hwndHH; hwnd = ::GetParent(hwnd)) ;
        BOOL hasFocus = (hwnd == m_hwndHH);

        // identify Ctrl-Tab and F6 keystrokes
        BOOL isKeydown = (pMsg && (pMsg->message == WM_KEYDOWN));
        BOOL isTab = (isKeydown && (pMsg->wParam == VK_TAB));
        BOOL isCtrlTab = (isTab && (::GetKeyState( VK_CONTROL ) & 0x8000));
        BOOL isF6 = (isKeydown && (pMsg->wParam == VK_F6));

        // map F6 and Ctrl-TAB from external windows into TAB for HtmlHelp to handle
        // so it can receive focus
        if (!hasFocus && isF6) pMsg->wParam = VK_TAB;

        // fake control status
        BYTE bState[256];
        if (!hasFocus && isCtrlTab)
        {
            ::GetKeyboardState(bState);
            bState[VK_CONTROL] &= 0x7F;
            ::SetKeyboardState(bState);
        }
 
        // pass the message to HtmlHelp for processing
        if(::HtmlHelp( m_hwndHH, NULL, HH_PRETRANSLATEMESSAGE2, (DWORD_PTR)pMsg ))
        {
		    hRet = S_OK;
        }

        // if it should accept focus, give it another chance (seems to have
        // problem accepting focus the first time after a navigate)
        if (!hasFocus && (isTab || isF6) && hRet != S_OK)
        {
            if(::HtmlHelp( m_hwndHH, NULL, HH_PRETRANSLATEMESSAGE2, (DWORD_PTR)pMsg ))
            {
    		    hRet = S_OK;
            }
        }

        // restore control status
        if (!hasFocus && isCtrlTab) 
        {
            bState[VK_CONTROL] |= 0x80;
            ::SetKeyboardState(bState);
        }

        // if the message is Ctrl-Tab and F6 and the focus is leaving,
        // relegate the processing to other windows by setting processed to false
        if (hasFocus && (isCtrlTab || isF6)) 
        {
            hRet = S_FALSE;
        }

    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\core\resource.h ===
//******************************************************************************
// 
// Copyright (c) 1999 Microsoft Corporation
// 
// Module Name:
// 	   resource.h
// 
// Abstract:
// 	   This file contains the definition of the constants used to describe
// 	   resources.
// 
// Revision History:
// 	   Davide Massarenti   (Dmassare)  08/07/99
// 		   created
// 
//******************************************************************************

#define IDS_PROJNAME                    100

#define IDR_HC                          101

#define IDI_HELPCENTER                  200

#define IDB_TB_DEF_24                   300
#define IDB_TB_HOT_24                   301
#define IDB_TB_DEF_16                   302
#define IDB_TB_HOT_16                   303
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\controls\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__412B7974_2F00_11D3_9A30_00C04F72D6C5__INCLUDED_)
#define AFX_STDAFX_H__412B7974_2F00_11D3_9A30_00C04F72D6C5__INCLUDED_

#include <module.h>

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

//
// From HelpCenterTypeLib.idl
//
#include <HelpCenterTypeLib.h>

//
// For debug trace
//
#include <HCP_trace.h>
#include <MPC_COM.h>
#include <MPC_utils.h>
#include <MPC_html.h>
#include <MPC_html2.h>
#include <MPC_xml.h>

#include <HelpCenter.h>
#include <HelpViewerWrapper.h>
#include <HelpCenterExternal.h>

#include <HtmlToolBar.h>
#include <HtmlProgressBar.h>

#include <resource.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__412B7974_2F00_11D3_9A30_00C04F72D6C5__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\core\dload.c ===
#include <windows.h>
#include <delayimp.h>

////////////////////////////////////////////////////////////////////////////////

static VOID* WINAPI hook_NULL()
{
	SetLastError( ERROR_PROC_NOT_FOUND );

	return NULL;
}

static DWORD WINAPI hook_NOTFOUND()
{
	return ERROR_PROC_NOT_FOUND;
}

////////////////////////////////////////////////////////////////////////////////

FARPROC WINAPI HELPCTR_DelayLoadFailureHook( UINT unReason, PDelayLoadInfo pDelayInfo )
{
	if(!lstrcmpiA( pDelayInfo->szDll, "iphlpapi.dll" ) ||
	   !lstrcmpiA( pDelayInfo->szDll, "rasapi32.dll" )  )
	{
		// IPHLPAPI.DLL	:: GetAdaptersInfo
		// RASAPI32.DLL	:: RasEnumEntriesW
		return (FARPROC)hook_NOTFOUND;
	}

	// COMDLG32.DLL :: PrintDlgW
	// CRYPT32.DLL  :: CryptBinaryToString
	// USERENV.DLL 	:: GetProfileType
	// WINSPOOL.DRV :: ClosePrinter
	// WINSPOOL.DRV :: EndDocPrinter
	// WINSPOOL.DRV :: EndPagePrinter
	// WINSPOOL.DRV :: OpenPrinterW
	// WINSPOOL.DRV :: StartDocPrinterW
	// WINSPOOL.DRV :: StartPagePrinter
	// WINSPOOL.DRV :: WritePrinter
	return (FARPROC)hook_NULL; // Also covers hook_ZERO and hook_FALSE.
}

// we assume DELAYLOAD_VERSION >= 0x0200
PfnDliHook __pfnDliFailureHook2 = HELPCTR_DelayLoadFailureHook;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\controls\htmltoolbar.cpp ===
/******************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:
    Toolbar.cpp

Abstract:
    This file contains the ActiveX control that makes Win32 ToolBars available to HTML.

Revision History:
    Davide Massarenti   (Dmassare)  03/04/2001
        created

******************************************************************************/

#include "stdafx.h"

#include <comctrlp.h>

////////////////////////////////////////////////////////////////////////////////

#define HISTORY_MENU__LIMIT  (10) // Just pick a limited number of items.

////////////////////////////////////////////////////////////////////////////////

static const MPC::StringToBitField c_Images[] =
{
    { L"BACK"        , -1,  0, -1 },
    { L"FORWARD"     , -1,  1, -1 },
    { L"HOME"        , -1,  2, -1 },
    { L"INDEX"       , -1,  3, -1 },
    { L"FAVORITES"   , -1,  4, -1 },
    { L"HISTORY"     , -1,  5, -1 },
    { L"SUPPORT"     , -1,  6, -1 },
    { L"OPTIONS"     , -1,  7, -1 },
    { L"ADDFAV"      , -1,  8, -1 },
    { L"PRINT"       , -1,  9, -1 },
    { L"LOCATE"      , -1, 10, -1 },

    { L"LAYOUT_SMALL", -1, 11, -1 },
    { L"LAYOUT_LARGE", -1, 12, -1 },

    { NULL                        }
};

const MPC::StringToBitField CPCHToolBar::c_TypeLookup[] =
{
    { L"BACK"     , -1, CPCHToolBar::TYPE_back     , -1 },
    { L"FORWARD"  , -1, CPCHToolBar::TYPE_forward  , -1 },
    { L"SEPARATOR", -1, CPCHToolBar::TYPE_separator, -1 },
    { L"GENERIC"  , -1, CPCHToolBar::TYPE_generic  , -1 },

    { NULL                                              }
};

CFG_BEGIN_FIELDS_MAP(CPCHToolBar::Button)
    CFG_ATTRIBUTE          ( L"ID"           , wstring, m_strID                         ),
    CFG_ATTRIBUTE          ( L"ACCESSKEY"    , WCHAR  , m_wch                           ),
    CFG_ATTRIBUTE          ( L"ENABLED"      , bool   , m_fEnabled                      ),
    CFG_ATTRIBUTE          ( L"VISIBLE"      , bool   , m_fVisible                      ),
    CFG_ATTRIBUTE          ( L"HIDETEXT"     , bool   , m_fHideText                     ),
    CFG_ATTRIBUTE          ( L"SYSTEMMENU"   , bool   , m_fSystemMenu                   ),
																						
    CFG_ATTRIBUTE__BITFIELD( L"TYPE"         ,          m_dwType         , c_TypeLookup ),
																						
    CFG_ELEMENT            ( L"IMAGE_NORMAL" , wstring, m_strImage_Normal               ),
    CFG_ELEMENT            ( L"IMAGE_HOT"    , wstring, m_strImage_Hot                  ),
    CFG_ELEMENT            ( L"TEXT"         , wstring, m_strText                       ),
    CFG_ELEMENT            ( L"TOOLTIP"      , wstring, m_strToolTip                    ),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(CPCHToolBar::Button)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(CPCHToolBar::Button,L"BUTTON")

DEFINE_CONFIG_METHODS__NOCHILD(CPCHToolBar::Button)

////////////////////

CFG_BEGIN_FIELDS_MAP(CPCHToolBar::Config)
    CFG_ATTRIBUTE( L"WIDTH"   , long, m_lWidth    ),
    CFG_ATTRIBUTE( L"HEIGHT"  , long, m_lHeight   ),
    CFG_ATTRIBUTE( L"ICONSIZE", long, m_lIconSize ),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(CPCHToolBar::Config)
    CFG_CHILD(CPCHToolBar::Button)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(CPCHToolBar::Config,L"TOOLBAR")


DEFINE_CONFIG_METHODS_CREATEINSTANCE_SECTION(CPCHToolBar::Config,tag,defSubType)
    if(tag == _cfg_table_tags[0])
    {
        defSubType = &(*(m_lstButtons.insert( m_lstButtons.end() )));
        return S_OK;
    }
DEFINE_CONFIG_METHODS_SAVENODE_SECTION(CPCHToolBar::Config,xdn)
DEFINE_CONFIG_METHODS_END(CPCHToolBar::Config)

////////////////////////////////////////////////////////////////////////////////

CPCHToolBar::Button::Button()
{
                             // MPC::wstring m_strID;
    m_wch           = 0;     // WCHAR        m_wch;
    m_fEnabled      = false; // bool         m_fEnabled;
    m_fVisible      = false; // bool         m_fVisible;
    m_fHideText     = false; // bool         m_fHideText;
    m_fSystemMenu   = false; // bool         m_fSystemMenu;
                             // MPC::wstring m_strType;
                             //
                             // MPC::wstring m_strImage_Normal;
                             // MPC::wstring m_strImage_Hot;
                             // MPC::wstring m_strText;
                             // MPC::wstring m_strToolTip;
                             //
                             //
    m_idCmd         = 0;     // int          m_idCmd;
    m_iImage_Normal = -1;    // int          m_iImage_Normal;
    m_iImage_Hot    = -1;    // int          m_iImage_Hot;
}

void CPCHToolBar::Button::UpdateState( /*[in]*/ HWND hwndTB )
{
    LRESULT lResult = ::SendMessageW( hwndTB, TB_GETSTATE, m_idCmd, 0 );

    lResult &= ~(TBSTATE_ENABLED | TBSTATE_INDETERMINATE | TBSTATE_HIDDEN);

    lResult |= (m_fEnabled ? TBSTATE_ENABLED : TBSTATE_INDETERMINATE);
    lResult |= (m_fVisible ? 0               : TBSTATE_HIDDEN       );

    ::SendMessageW( hwndTB, TB_SETSTATE, m_idCmd, MAKELONG(lResult, 0) );
}

////////////////////////////////////////////////////////////////////////////////

CPCHToolBar::Config::Config()
{
                                // long       m_lWidth;
                                // long       m_lHeight;
                                // long       m_lIconSize;
                                //
    m_mode       = TB_SELECTED; // TB_MODE    m_mode;
                                // ButtonList m_lstButtons;
                                //
    m_himlNormal = NULL;        // HIMAGELIST m_himlNormal;
    m_himlHot    = NULL;        // HIMAGELIST m_himlHot;

	if(CPCHOptions::s_GLOBAL)
	{
		m_mode = CPCHOptions::s_GLOBAL->TextLabels();
	}

    Reset();
}

CPCHToolBar::Button* CPCHToolBar::Config::LookupButton( /*[in]*/ LPCWSTR szID  ,
                                                        /*[in]*/ int     idCmd )
{
    for(ButtonIter it = m_lstButtons.begin(); it != m_lstButtons.end(); it++)
    {
        Button& bt = *it;

        if(szID  != NULL && bt.m_strID == szID ) return &bt;
        if(idCmd != -1   && bt.m_idCmd == idCmd) return &bt;
    }

    return NULL;
}


void CPCHToolBar::Config::Reset()
{
    (void)::ImageList_Destroy( m_himlNormal );
    (void)::ImageList_Destroy( m_himlHot    );

    m_lWidth    = 0;      // long       m_lWidth;
    m_lHeight   = 0;      // long       m_lHeight;
    m_lIconSize = 24;     // long       m_lIconSize;
    m_fRTL      = false;  // bool       m_fRTL;
                          //
    m_lstButtons.clear(); // ButtonList m_lstButtons;
                          //
    m_himlNormal = NULL;  // HIMAGELIST m_himlNormal;
    m_himlHot    = NULL;  // HIMAGELIST m_himlHot;
}

HRESULT CPCHToolBar::Config::Load( /*[in]*/ LPCWSTR szBaseURL    ,
                                   /*[in]*/ LPCWSTR szDefinition ,
								   /*[in]*/ LPCWSTR szDir        )
{
    __HCP_FUNC_ENTRY( "CPCHToolBar::Config::Load" );

    HRESULT          hr;
    CComPtr<IStream> stream;


    Reset();

	m_fRTL = (MPC::StrICmp( szDir, L"RTL" ) == 0);

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::HTML::OpenStream( szBaseURL, szDefinition, stream ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::Config::LoadStream( this, stream ));

    //
    // Load all the images.
    //
    {
        COLORREF crMask = RGB( 255, 0, 255 );
        LPCWSTR  szDef;
        LPCWSTR  szHot;
        int      cx;

        if(m_lIconSize == 24)
        {
            szDef = MAKEINTRESOURCEW(IDB_TB_DEF_24);
            szHot = MAKEINTRESOURCEW(IDB_TB_HOT_24);
            cx    = 24;
        }
        else
        {
            szDef = MAKEINTRESOURCEW(IDB_TB_DEF_16);
            szHot = MAKEINTRESOURCEW(IDB_TB_HOT_16);
            cx    = 16;
        }

        m_himlNormal = ::ImageList_LoadImageW( ::GetModuleHandle( NULL ), szDef, cx, 0, crMask, IMAGE_BITMAP, LR_CREATEDIBSECTION );
        m_himlHot    = ::ImageList_LoadImageW( ::GetModuleHandle( NULL ), szHot, cx, 0, crMask, IMAGE_BITMAP, LR_CREATEDIBSECTION );

        for(ButtonIter it = m_lstButtons.begin(); it != m_lstButtons.end(); it++)
        {
            Button& bt = *it;

            if(bt.m_strImage_Normal.size())
            {
                if(bt.m_strImage_Hot.length() == 0) bt.m_strImage_Hot = bt.m_strImage_Normal;

                __MPC_EXIT_IF_METHOD_FAILS(hr, MergeImage( szBaseURL, bt.m_strImage_Normal.c_str(), m_himlNormal, bt.m_iImage_Normal ));
                __MPC_EXIT_IF_METHOD_FAILS(hr, MergeImage( szBaseURL, bt.m_strImage_Hot   .c_str(), m_himlHot   , bt.m_iImage_Hot    ));
            }
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(FAILED(hr)) Reset();

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHToolBar::Config::CreateButtons( /*[in]*/ HWND hwndTB )
{
    __HCP_FUNC_ENTRY( "CPCHToolBar::Config::CreateButtons" );

    HRESULT   hr;
    TBBUTTON* tbs  = NULL;
    int       iNum = m_lstButtons.size();
    int       iCmd = 1;

    //
    // Remove previous buttons.
    //
    {
        INT_PTR nCount = ::SendMessageW( hwndTB, TB_BUTTONCOUNT, 0, 0L );

        while(nCount-- > 0) ::SendMessageW( hwndTB, TB_DELETEBUTTON, nCount, 0L );
    }

    if(iNum)
    {
        TBBUTTON*  ptr;
        ButtonIter it;

        __MPC_EXIT_IF_ALLOC_FAILS(hr, tbs, new TBBUTTON[iNum]);

        ::SendMessageW( hwndTB, TB_SETIMAGELIST   , 0, (LPARAM)m_himlNormal );
        ::SendMessageW( hwndTB, TB_SETHOTIMAGELIST, 0, (LPARAM)m_himlHot    );

        for(ptr = tbs, it = m_lstButtons.begin(); it != m_lstButtons.end(); ptr++, it++)
        {
            Button& bt = *it; ::ZeroMemory( ptr, sizeof(TBBUTTON) );

            bt.m_idCmd = iCmd++;

            ptr->iBitmap    = I_IMAGECALLBACK;
            ptr->idCommand  = bt.m_idCmd;
            ptr->fsState    = (bt.m_fEnabled ? TBSTATE_ENABLED : TBSTATE_INDETERMINATE) | (bt.m_fVisible ? 0 : TBSTATE_HIDDEN) | TBSTATE_ELLIPSES;
			ptr->fsStyle   |= BTNS_AUTOSIZE;

            if(bt.m_strText.size())
            {
                switch(m_mode)
                {
                case TB_NONE:
					break;

                case TB_SELECTED:
					if(bt.m_fHideText) break;

                case TB_ALL:
                    ptr->iString  = (INT_PTR)bt.m_strText.c_str();
                    ptr->fsStyle |= BTNS_SHOWTEXT;
                    break;
                }
            }

            switch(bt.m_dwType)
            {
            case TYPE_back     : ptr->fsStyle |= BTNS_DROPDOWN;                                                   break;
            case TYPE_forward  : ptr->fsStyle |= BTNS_DROPDOWN;                                                   break;
            case TYPE_separator: ptr->fsStyle |= BTNS_SEP     ; ptr->fsStyle &= ~(BTNS_AUTOSIZE | BTNS_SHOWTEXT); break;
            case TYPE_generic  :                                                                                  break;
            }
        }

        ::SendMessageW( hwndTB, TB_ADDBUTTONSW, iNum, (LPARAM)tbs );
    }

	::SendMessageW( hwndTB, TB_AUTOSIZE, 0, 0 );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    delete [] tbs;

    __HCP_FUNC_EXIT(hr);
}

void CPCHToolBar::Config::UpdateSize( /*[in]*/ HWND hwndTB, /*[in]*/ HWND hwndRB, /*[out]*/ SIZEL& ptIdeal )
{
    REBARBANDINFOW rbbi; ::ZeroMemory( &rbbi, sizeof(rbbi) );
    RECT           rcMax = { 0, 0, 0, 0 };

    for(ButtonIter it = m_lstButtons.begin(); it != m_lstButtons.end(); it++)
    {
        Button& bt = *it;
        RECT    rc;

        if(::SendMessage( hwndTB, TB_GETRECT, bt.m_idCmd, (LPARAM)&rc ))
        {
            if(rcMax.left   > rc.left  ) rcMax.left   = rc.left  ;
            if(rcMax.right  < rc.right ) rcMax.right  = rc.right ;
            if(rcMax.top    > rc.top   ) rcMax.top    = rc.top   ;
            if(rcMax.bottom < rc.bottom) rcMax.bottom = rc.bottom;
        }
    }

    ptIdeal.cx = rcMax.right  - rcMax.left;
    ptIdeal.cy = rcMax.bottom - rcMax.top;

    if(hwndRB)
    {
        rbbi.cbSize = sizeof(REBARBANDINFOW);
        rbbi.fMask  = RBBIM_IDEALSIZE;

        ::SendMessage( hwndRB, RB_GETBANDINFOW, 0, (LPARAM)&rbbi );

        if(rbbi.cxIdeal != ptIdeal.cx)
        {
            rbbi.cxIdeal = ptIdeal.cx;

            ::SendMessage( hwndRB, RB_SETBANDINFOW, 0, (LPARAM)&rbbi );
        }
    }
}

HRESULT CPCHToolBar::Config::MergeImage( /*[in ]*/ LPCWSTR    szBaseURL     ,
                                         /*[in ]*/ LPCWSTR    szRelativeURL ,
                                         /*[in ]*/ HIMAGELIST himl          ,
                                         /*[out]*/ int&       iImage        )
{
    __HCP_FUNC_ENTRY( "CPCHToolBar::Config::MergeImage" );

    HRESULT hr;
    HBITMAP hBMP = NULL;


    if(wcschr( szRelativeURL, '#' ))
    {
        DWORD dwImage = -1;

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertStringToBitField( &szRelativeURL[1], dwImage, c_Images, /*fUseTilde*/false ));

        iImage = dwImage;
    }
    else
    {
        COLORREF crMask = RGB( 255, 0, 255 );

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::HTML::DownloadBitmap( szBaseURL, szRelativeURL, crMask, hBMP ));

        iImage = ::ImageList_GetImageCount( himl );

        ::ImageList_AddMasked( himl, (HBITMAP)hBMP, crMask );
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(hBMP) ::DeleteObject( hBMP );

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

CPCHToolBar::CPCHToolBar()
{
    m_bWindowOnly = TRUE; // Inherited from CComControlBase


    m_parent      = NULL;  // CPCHHelpCenterExternal* m_parent;
    m_hwndRB      = NULL;  // HWND                    m_hwndRB;
    m_hwndTB      = NULL;  // HWND                    m_hwndTB;
                           //
                           // Config                  m_cfg;
    m_fLoaded     = false; // bool                    m_fLoaded;

    {
        SIZE ptIdeal;

        ptIdeal.cx = 30;
        ptIdeal.cy = 30;

        AtlPixelToHiMetric( &ptIdeal, &m_sizeExtent );
    }
}

CPCHToolBar::~CPCHToolBar()
{
}

STDMETHODIMP CPCHToolBar::SetClientSite( IOleClientSite *pClientSite )
{
    CComQIPtr<IServiceProvider> sp = pClientSite;

    if(m_parent)
    {
        CComQIPtr<IPCHHelpCenterExternalPrivate> hcep = m_parent;

        if(hcep)
        {
            hcep->RegisterForMessages( this, /*fRemove*/true );
        }
    }

    MPC::Release( (IUnknown*&)m_parent );


    if(sp && SUCCEEDED(sp->QueryService( SID_SElementBehaviorFactory, IID_IPCHHelpCenterExternal, (void **)&m_parent )))
    {
        CComQIPtr<IPCHHelpCenterExternalPrivate> hcep = m_parent;

        if(hcep)
        {
            hcep->RegisterForMessages( this, /*fRemove*/false );
        }
    }

    return IOleObjectImpl<CPCHToolBar>::SetClientSite( pClientSite );
}

STDMETHODIMP CPCHToolBar::GetExtent( DWORD dwDrawAspect, SIZEL *psizel )
{
    if(SUCCEEDED(Config_Load()))
    {
        UpdateSize();

        if(m_cfg.m_lWidth || m_cfg.m_lHeight)
        {
            SIZE  ptIdeal;
            SIZEL sizeExtent;

            ptIdeal.cx = m_cfg.m_lWidth;
            ptIdeal.cy = m_cfg.m_lHeight;

            AtlPixelToHiMetric( &ptIdeal, &sizeExtent );

            if(m_cfg.m_lWidth  != 0) m_sizeExtent.cx = sizeExtent.cx;
            if(m_cfg.m_lHeight != 0) m_sizeExtent.cy = sizeExtent.cy;
        }
    }

    return IOleObjectImpl<CPCHToolBar>::GetExtent( dwDrawAspect, psizel );
}

/////////////////////////////////////////////////////////////////////////////

static bool local_IsButtonObscured( /*[in]*/ HWND hwnd, /*[in]*/ RECT& rcSrc, /*[in]*/ UINT_PTR iCmd )
{
    UINT_PTR iButton = (UINT_PTR)::SendMessage( hwnd, TB_COMMANDTOINDEX, iCmd, 0 );

    if(iButton != -1)
    {
        RECT rcItem;

        if(::SendMessage( hwnd, TB_GETITEMRECT, iButton, (LPARAM)&rcItem ))
        {
            if(rcSrc.left   <= rcItem.left   &&
               rcSrc.right  >= rcItem.right  &&
               rcSrc.top    <= rcItem.top    &&
               rcSrc.bottom >= rcItem.bottom  )
            {
                return false;
            }
        }
    }

    return true;
}

BOOL CPCHToolBar::ProcessWindowMessage( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult, DWORD dwMsgMapID )
{
    lResult = 0;

    switch(uMsg)
    {
    case WM_THEMECHANGED:
    case WM_SYSCOLORCHANGE:
        UpdateSize();
        break;

    case WM_SETTINGCHANGE:
        // (weizhao) Relay message to the toolbar control for appropriate handling
        // of settings change.
        ::SendMessageW( m_hwndTB, uMsg, wParam, lParam);
        UpdateSize();
        break;


    case WM_NOTIFYFORMAT:
        if(lParam == NF_QUERY)
        {
            lResult = NFR_UNICODE;
            return TRUE;
        }
        break;


    case WM_CREATE:
        if(SUCCEEDED(Rebar_Create  ()) &&
           SUCCEEDED(Toolbar_Create()) &&
           SUCCEEDED(Rebar_AddBand ())  )
        {
			;
        }
        return TRUE;


    case WM_SIZE:
        {
            int  nWidth  = LOWORD(lParam);  // width of client area
            int  nHeight = HIWORD(lParam); // height of client area

            if(m_hwndRB)
            {
                RECT rc;
                int  nClientWidth;
                int  nClientHeight;

                ::GetClientRect( m_hwndRB, &rc );

                nClientWidth  = rc.right  - rc.left;
                nClientHeight = rc.bottom - rc.top;

                // resize the width of the toolbar
                if(nClientWidth  != nWidth  ||
                   nClientHeight != nHeight  )
                {
                    ::SetWindowPos( m_hwndRB, NULL, 0, 0, nWidth, nHeight, SWP_NOZORDER|SWP_NOACTIVATE );
                }
            }

			if(m_parent) (void)m_parent->RefreshLayout();
        }
        return TRUE;


    case WM_DESTROY:
        m_hwndRB = NULL;
        m_hwndTB = NULL;
        return TRUE;


    case WM_COMMAND:
        switch( HIWORD(wParam) )
        {
        case BN_CLICKED:
            (void)Fire_onCommand( LOWORD(wParam) );
            return TRUE;
        }
        break;


    case WM_SYSCOMMAND:
		{
			for(Config::ButtonIter it = m_cfg.m_lstButtons.begin(); it != m_cfg.m_lstButtons.end(); it++)
			{
				Button& bt = *it;

				if(bt.m_idCmd == LOWORD(wParam))
				{
					(void)Fire_onCommand( LOWORD(wParam) );
					return TRUE;
				}
			}
		}
		break;


    case WM_NOTIFY:
        switch( ((LPNMHDR)lParam)->code )
        {
        case TBN_GETINFOTIPW:
            (void)OnTooltipRequest( (int)wParam, (LPNMTBGETINFOTIPW)lParam );
            return TRUE;

        case TBN_GETDISPINFOW:
            (void)OnDispInfoRequest( (int)wParam, (LPNMTBDISPINFOW)lParam );
            return TRUE;

        case TBN_DROPDOWN:
            (void)OnDropDown( (int)wParam, (LPNMTOOLBAR)lParam );
            return TRUE;

        case RBN_CHEVRONPUSHED:
            (void)OnChevron( (int)wParam, (LPNMREBARCHEVRON)lParam );
            return TRUE;

        }
        break;

    case WM_SYSCHAR:
        if(ProcessAccessKey( uMsg, wParam, lParam ))
        {
            lResult = TRUE;
            return TRUE;
        }
        break;
    }

    return CComControl<CPCHToolBar>::ProcessWindowMessage( hWnd, uMsg, wParam, lParam, lResult, dwMsgMapID );
}

BOOL CPCHToolBar::ProcessAccessKey( UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    if(m_hwndTB && ::IsWindowVisible( m_hwndTB ))
    {
        WCHAR rgBuf1[2]; rgBuf1[0] = (WCHAR)wParam; rgBuf1[1] = 0; ::CharUpperW( rgBuf1 );
        WCHAR rgBuf2[2];                            rgBuf2[1] = 0;

        for(Config::ButtonIter it = m_cfg.m_lstButtons.begin(); it != m_cfg.m_lstButtons.end(); it++)
        {
            Button& bt = *it;

            rgBuf2[0] = bt.m_wch; ::CharUpperW( rgBuf2 );
            if(rgBuf1[0] == rgBuf2[0])
            {
                LRESULT lState = ::SendMessageW( m_hwndTB, TB_GETSTATE, bt.m_idCmd, 0 );

                if(!(lState & TBSTATE_HIDDEN ) &&
                   (lState & TBSTATE_ENABLED)  )
                {
                    //  (weizhao) - Check if button is obscured (i.e. out of the toolbar
                    //  window). If so, fire the command directly. Otherwise, fire the
                    //  command by sending the mouse messages, as explained below.
                    //  This is added to enable keyboard accessability.
                    RECT rcSrc;
                    ::GetClientRect( m_hwndTB, &rcSrc );

                    if (local_IsButtonObscured( m_hwndTB, rcSrc, bt.m_idCmd ))
                    {
                        Fire_onCommand(&bt);
                    }
                    else
                    {
                        //  (tnoonan) - it feels kinda cheesy to send mouse messages, but
                        //  I don't know of a cleaner way which will accomplish what we
                        //  want (like deal with split buttons, mutually exclusive
                        //  buttons, etc.).
                        RECT rc;

                        ::SendMessage( m_hwndTB, TB_GETRECT, bt.m_idCmd, (LPARAM)&rc );

                        ::SendMessage( m_hwndTB, WM_LBUTTONDOWN, MK_LBUTTON, MAKELONG(rc.left, rc.top) );
                        ::SendMessage( m_hwndTB, WM_LBUTTONUP  , 0         , MAKELONG(rc.left, rc.top) );
                    }

                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CPCHToolBar::Fire_onCommand( /*[in]*/ Button* bt )
{
    if(bt)
    {
        CComVariant pvars[2];

        pvars[1] = this;
        pvars[0] = bt->m_strID.c_str();

        (void)FireAsync_Generic( DISPID_PCH_TBE__ONCOMMAND, pvars, ARRAYSIZE( pvars ), NULL );
    }

    return S_OK;
}

HRESULT CPCHToolBar::Fire_onCommand( /*[in]*/ UINT_PTR iCmd )
{
    return Fire_onCommand( m_cfg.LookupButton( NULL, iCmd ) );
}

////////////////////

HRESULT CPCHToolBar::OnTooltipRequest( int idCtrl, LPNMTBGETINFOTIPW tool )
{
    Button* bt = m_cfg.LookupButton( NULL, tool->iItem );

    if(bt)
    {
        wcsncpy( tool->pszText, bt->m_strToolTip.c_str(), tool->cchTextMax - 1 );
    }

    return S_OK;
}

HRESULT CPCHToolBar::OnDispInfoRequest( int idCtrl, LPNMTBDISPINFOW info )
{
    Button* bt = m_cfg.LookupButton( NULL, info->idCommand );

    if(bt)
    {
        if(info->dwMask & TBNF_IMAGE)
        {
            info->iImage = bt->m_iImage_Normal;
        }
    }

    return S_OK;
}

HRESULT CPCHToolBar::OnDropDown( int idCtrl, LPNMTOOLBAR tool )
{
    __HCP_FUNC_ENTRY( "CPCHToolBar::OnDropDown" );

    HRESULT hr;
    Button* bt    = m_cfg.LookupButton( NULL, tool->iItem );
    HMENU   hMenu = NULL;

    if(bt)
    {
        if(m_parent)
        {
            CPCHHelpSession* hs = m_parent->HelpSession();
            if(hs && hs->IsTravelling() == false)
            {
				CPCHHelpSessionItem* item   = hs->Current();

				if(item)
				{
                    int iCount = 0;

					__MPC_EXIT_IF_CALL_RETURNS_NULL(hr, (hMenu = ::CreatePopupMenu()));

                    while((item = (bt->m_dwType == TYPE_back ? item->Previous() : item->Next())))
                    {
						if(iCount++ < HISTORY_MENU__LIMIT)
						{
							CComBSTR bstrTitle;

							__MPC_EXIT_IF_METHOD_FAILS(hr, item->get_Title( &bstrTitle ));

							if(bstrTitle.Length() == 0) MPC::LocalizeString( IDS_HELPCTR_HIST_NOTITLE, bstrTitle );

							__MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::AppendMenuW( hMenu, MF_STRING, iCount, bstrTitle ));
						}
                    }

                    if(iCount)
                    {
                        ::MapWindowPoints( tool->hdr.hwndFrom, HWND_DESKTOP, (LPPOINT)&tool->rcButton, 2 );

                        iCount = ::TrackPopupMenu( hMenu, TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RIGHTBUTTON | TPM_RETURNCMD | TPM_NONOTIFY,
                                                   tool->rcButton.left, tool->rcButton.bottom, 0, m_hWnd, NULL );

                        if(iCount != 0)
						{
							if(bt->m_dwType == TYPE_back) hs->Back   ( iCount );
							else                          hs->Forward( iCount );
						}
                    }
                }
            }
        }
    }


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(hMenu) ::DestroyMenu( hMenu );

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHToolBar::OnChevron( int idCtrl, LPNMREBARCHEVRON chev )
{
    __HCP_FUNC_ENTRY( "CPCHToolBar::OnChevron" );

    HRESULT hr;
    RECT    rcSrc;
    HMENU   hMenu  = NULL;
    bool    fFound = false;


    __MPC_EXIT_IF_CALL_RETURNS_NULL(hr, (hMenu = ::CreatePopupMenu()));

    ::GetClientRect( m_hwndTB, &rcSrc );
    for(Config::ButtonIter it = m_cfg.m_lstButtons.begin(); it != m_cfg.m_lstButtons.end(); it++)
    {
        Button& bt = *it;

        if(bt.m_fVisible && bt.m_fEnabled && bt.m_strText.size() && local_IsButtonObscured( m_hwndTB, rcSrc, bt.m_idCmd ))
        {
            __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::AppendMenuW( hMenu, MF_STRING, bt.m_idCmd, bt.m_strText.c_str() ));

            fFound = true;
        }
    }

    if(fFound)
    {
        int iSelected;

        ::MapWindowPoints( chev->hdr.hwndFrom, HWND_DESKTOP, (LPPOINT)&chev->rc, 2 );

        iSelected = ::TrackPopupMenu( hMenu, TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RIGHTBUTTON | TPM_RETURNCMD | TPM_NONOTIFY, chev->rc.left, chev->rc.bottom, 0, m_hWnd, NULL );
        if(iSelected != 0)
        {
            (void)Fire_onCommand( iSelected );
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(hMenu) ::DestroyMenu( hMenu );

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

void CPCHToolBar::UpdateSize()
{
    if(m_hwndTB)
    {
        SIZE  ptIdeal;
        SIZEL sizeExtent;

        m_cfg.UpdateSize( m_hwndTB, m_hwndRB, ptIdeal );

        AtlPixelToHiMetric( &ptIdeal, &sizeExtent );

        if(m_cfg.m_lHeight == 0) m_sizeExtent.cy = sizeExtent.cy;

		{
			CComPtr<IHTMLElement>    elem;
			CComQIPtr<IHTMLElement2> elem2;

			if(SUCCEEDED(FindElementThroughThunking( elem )) && (elem2 = elem))
			{
				CComPtr<IHTMLCurrentStyle> style1;
				CComPtr<IHTMLStyle>        style2;

				if(SUCCEEDED(elem2->get_currentStyle( &style1 )) && style1 &&
				   SUCCEEDED(elem ->get_style       ( &style2 )) && style2  )
				{
					CComVariant v1;
					CComVariant v2;
					WCHAR 		rgBuf[64]; swprintf( rgBuf, L"%ldpx", ptIdeal.cy );

					v2 = rgBuf;

					style1->get_height( &v1 );
					if(v1 != v2)
					{
						style2->put_height( v2 );
					}
				}
			}
		}

		if(m_parent && m_parent->Window())
		{
			HMENU hSys = NULL;

			for(Config::ButtonIter it = m_cfg.m_lstButtons.begin(); it != m_cfg.m_lstButtons.end(); it++)
			{
				Button& bt = *it;

				if(bt.m_fSystemMenu)
				{
					if(!hSys)
					{
						HMENU        hTop;
						MENUITEMINFO mii;
						CComBSTR     bstrTitle; MPC::LocalizeString( IDS_HELPCTR_SYSMENU_GOTO, bstrTitle );

						::ZeroMemory( &mii, sizeof(mii) );

						mii.cbSize 	   = sizeof(mii);
						mii.fMask  	   = MIIM_ID | MIIM_STRING | MIIM_SUBMENU;
						mii.fType  	   = MFT_STRING;
						mii.wID    	   = 1;
						mii.dwTypeData = bstrTitle;
						mii.hSubMenu   = hSys = ::CreatePopupMenu();

						(void) ::GetSystemMenu( m_parent->Window(), TRUE  );
						hTop = ::GetSystemMenu( m_parent->Window(), FALSE );

						::AppendMenuW   ( hTop, MF_SEPARATOR, 0, 0 );
						::InsertMenuItem( hTop, ::GetMenuItemCount(hTop), TRUE, &mii );
					}

					if(hSys)
					{
						switch(bt.m_dwType)
						{
						case TYPE_separator:
							(void)::AppendMenuW( hSys, MF_SEPARATOR, 0, 0 );
						    break;

						case TYPE_back   :
						case TYPE_forward:
						case TYPE_generic:
							(void)::AppendMenuW( hSys, MF_STRING | (bt.m_fEnabled ? 0 : MF_GRAYED), bt.m_idCmd, bt.m_strText.c_str() );
							break;
						}
					}
				}
			}
		}
    }
}

void CPCHToolBar::Config_Clear()
{
    m_cfg.Reset();
    m_fLoaded = false;
}

HRESULT CPCHToolBar::Config_Load()
{
    __HCP_FUNC_ENTRY( "CPCHToolBar::Config_Load" );

    HRESULT hr;

    if(!m_fLoaded)
    {
        CComPtr<IServiceProvider> sp;
        CComPtr<IHTMLDocument2>   doc2;
        CComPtr<IHTMLDocument3>   doc3;
        CComBSTR                  bstrBase;
        CComBSTR                  bstrDir;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_spAmbientDispatch->QueryInterface( IID_IServiceProvider, (void**)&sp ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, sp->QueryService( SID_SContainerDispatch, IID_IHTMLDocument2, (void **)&doc2 ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, doc2->get_URL( &bstrBase ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, sp->QueryService( SID_SContainerDispatch, IID_IHTMLDocument3, (void **)&doc3 ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, doc3->get_dir( &bstrDir  ));

        Config_Clear();

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_cfg.Load( bstrBase, m_bstrDefinition, bstrDir ));
        m_fLoaded = true;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(FAILED(hr))
    {
        Config_Clear();
    }

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHToolBar::Toolbar_Create()
{
    __HCP_FUNC_ENTRY( "CPCHToolBar::Toolbar_Create" );

    HRESULT hr;


    if(FAILED(Config_Load()))
    {
        ; // Empty toolbar...
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, Rebar_Create());

    if(m_hwndRB && !m_hwndTB)
    {
        DWORD dwStyle = WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS |
                        TBSTYLE_TOOLTIPS | TBSTYLE_FLAT |
			            CCS_NORESIZE | CCS_NODIVIDER | CCS_NOPARENTALIGN;

        DWORD dwStyleEx = TBSTYLE_EX_DRAWDDARROWS | TBSTYLE_EX_HIDECLIPPEDBUTTONS | TBSTYLE_EX_DOUBLEBUFFER;


        if(m_cfg.m_mode == TB_SELECTED)
        {
            dwStyle |= TBSTYLE_LIST;
        }


        m_hwndTB = ::CreateWindowEx( WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, NULL, dwStyle, 0, 0, 0, 0, m_hwndRB, NULL, NULL, NULL );
        if(m_hwndTB == NULL)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ::GetLastError());
        }


        ::SendMessageW( m_hwndTB, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON)                   , 0         );
        ::SendMessageW( m_hwndTB, TB_SETEXTENDEDSTYLE, dwStyleEx                          , dwStyleEx );
        ::SendMessageW( m_hwndTB, TB_SETMAXTEXTROWS  , 1                                  , 0         );
        ::SendMessageW( m_hwndTB, TB_SETDROPDOWNGAP  , ::GetSystemMetrics( SM_CXEDGE ) / 2, 0         );
        ::SendMessageW( m_hwndTB, CCM_SETVERSION     , COMCTL32_VERSION                   , 0         );

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_cfg.CreateButtons( m_hwndTB ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHToolBar::Rebar_Create()
{
    __HCP_FUNC_ENTRY( "CPCHToolBar::Rebar_Create" );

    HRESULT hr;


    if(m_hWnd && !m_hwndRB)
    {
        DWORD dwStyle = RBS_VARHEIGHT | RBS_BANDBORDERS | RBS_AUTOSIZE |
                        WS_VISIBLE | WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS |
                        CCS_NODIVIDER | CCS_NOPARENTALIGN;

		DWORD dwStyleEx = WS_EX_TOOLWINDOW;

		if(m_cfg.m_fRTL) dwStyleEx |= WS_EX_LAYOUTRTL;

        m_hwndRB = ::CreateWindowEx( dwStyleEx, REBARCLASSNAME, NULL, dwStyle, 0, 0, 24, 24, m_hWnd, NULL, NULL, NULL );
        if(m_hwndRB == NULL)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ::GetLastError());
        }

        ::SendMessageW( m_hwndRB, RB_SETTEXTCOLOR, 0               , CLR_DEFAULT );
        ::SendMessageW( m_hwndRB, RB_SETBKCOLOR  , 0               , CLR_DEFAULT );
        ::SendMessageW( m_hwndRB, CCM_SETVERSION , COMCTL32_VERSION, 0           );
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHToolBar::Rebar_AddBand()
{
    __HCP_FUNC_ENTRY( "CPCHToolBar::Rebar_AddBand" );

    HRESULT hr;

    if(m_hwndRB && m_hwndTB)
    {
        REBARBANDINFOW rbbi; ::ZeroMemory( &rbbi, sizeof(rbbi) );
        SIZE           ptIdeal;

        m_cfg.UpdateSize( m_hwndTB, NULL, ptIdeal );

        rbbi.cbSize      = sizeof(rbbi);
        rbbi.fMask       = RBBIM_ID | RBBIM_CHILDSIZE | RBBIM_CHILD | RBBIM_SIZE | RBBIM_STYLE | RBBIM_IDEALSIZE;
        rbbi.fStyle      = RBBS_NOGRIPPER | RBBS_USECHEVRON/* | RBBS_CHILDEDGE | RBBS_FIXEDBMP*/;
        rbbi.hwndChild   = m_hwndTB;
        rbbi.cx          = 0;
        rbbi.cxMinChild  = 0;
		rbbi.cyMinChild  = ptIdeal.cy;
		rbbi.cxIdeal     = ptIdeal.cx;

        ::SendMessageW( m_hwndRB, RB_INSERTBANDW, 0, (LPARAM)&rbbi );
        ::SendMessageW( m_hwndRB, RB_SHOWBAND   , 0, (LPARAM)TRUE  );
    }

    hr = S_OK;


    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

////#define CH_PREFIX TEXT('&')
////
////static WCHAR local_GetAccelerator( LPCWSTR sz, BOOL bUseDefault )
////{
////    WCHAR   ch = (TCHAR)-1;
////    LPCWSTR szAccel = sz;
////
////    // then prefixes are allowed.... see if it has one
////    do
////    {
////        szAccel = StrChrW( szAccel, CH_PREFIX );
////        if(szAccel)
////        {
////            szAccel++;
////
////            // handle having &&
////            if(*szAccel != CH_PREFIX)
////            {
////                ch = *szAccel;
////            }
////            else
////            {
////                szAccel++;
////            }
////        }
////    } while (szAccel && (ch == (WCHAR)-1));
////
////    if((ch == (WCHAR)-1) && bUseDefault)
////    {
////        ch = *sz;
////    }
////
////    return ch;
////}

BOOL CPCHToolBar::PreTranslateAccelerator( LPMSG pMsg, HRESULT& hRet )
{
    //  Give toolbar a chance.
    if(m_hwndTB)
    {
        if(::SendMessage( m_hwndTB, TB_TRANSLATEACCELERATOR, 0, (LPARAM)pMsg )) return TRUE;

        if(::SendMessage( m_hwndTB, WM_FORWARDMSG, 0, (LPARAM)pMsg )) return TRUE;

////        if(pMsg->message == WM_SYSCHAR)
////        {
////            UINT idBtn;
////
////            if(::SendMessage( m_hwndTB, TB_MAPACCELERATOR, pMsg->wParam, (LPARAM)&idBtn ))
////            {
////                WCHAR rgButtonText[MAX_PATH];
////
////                //  comctl says this one is the one, let's make sure we aren't getting
////                //  one of the unwanted "use the first letter" accelerators that it
////                //  will return.
////                if((::SendMessage( m_hwndTB, TB_GETBUTTONTEXTW, idBtn, (LPARAM)rgButtonText ) > 0) &&
////                   (local_GetAccelerator( rgButtonText, FALSE ) != (WCHAR)-1))
////                {
////                    //  (tnoonan) - it feels kinda cheesy to send mouse messages, but
////                    //  I don't know of a cleaner way which will accomplish what we
////                    //  want (like deal with split buttons, mutually exclusive
////                    //  buttons, etc.).
////                    RECT rc;
////
////                    ::SendMessage( m_hwndTB, TB_GETRECT, idBtn, (LPARAM)&rc );
////
////                    ::SendMessage( m_hwndTB, WM_LBUTTONDOWN, MK_LBUTTON, MAKELONG(rc.left, rc.top) );
////                    ::SendMessage( m_hwndTB, WM_LBUTTONUP  , 0         , MAKELONG(rc.left, rc.top) );
////
////                    return TRUE;
////                }
////            }
////        }
    }

    return CComControl<CPCHToolBar>::PreTranslateAccelerator( pMsg, hRet );
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHToolBar::get_Definition( /*[out, retval]*/ BSTR *pVal )
{
    return MPC::GetBSTR( m_bstrDefinition, pVal );
}

STDMETHODIMP CPCHToolBar::put_Definition( /*[in]*/ BSTR newVal )
{
    Config_Clear();

    return MPC::PutBSTR( m_bstrDefinition, newVal );
}

STDMETHODIMP CPCHToolBar::get_Mode( /*[out, retval]*/ TB_MODE *pVal )
{
    if(!pVal) return E_POINTER;

    *pVal = m_cfg.m_mode;

    return S_OK;
}

STDMETHODIMP CPCHToolBar::put_Mode( /*[in]*/ TB_MODE newVal )
{
	bool fRecreate = false;

    switch(newVal)
    {
    case TB_ALL     :
    case TB_SELECTED:
    case TB_NONE    : break;
    default: return E_INVALIDARG;
    }

	//
	// Adjust style.
	//
    if(m_hwndRB && (m_cfg.m_mode != newVal))
	{
		::DestroyWindow( m_hwndRB );

		m_hwndRB = NULL;
		m_hwndTB = NULL;

		fRecreate = true;
	}

    m_cfg.m_mode = newVal;

	if(fRecreate)
	{
        if(SUCCEEDED(Rebar_Create  ()) &&
           SUCCEEDED(Toolbar_Create()) &&
           SUCCEEDED(Rebar_AddBand ()) &&
		   m_hwndRB                     )
        {
			RECT rc;

			::GetClientRect( m_hWnd, &rc );

			::SetWindowPos( m_hwndRB, NULL, 0, 0, rc.right  - rc.left, rc.bottom - rc.top, SWP_NOZORDER|SWP_NOACTIVATE );

            UpdateSize();
        }
	}

	return S_OK;
}

STDMETHODIMP CPCHToolBar::SetState( /*[in]*/ BSTR bstrText, /*[in]*/ VARIANT_BOOL fEnabled )
{
    if(SUCCEEDED(Config_Load()))
    {
        Button* bt = m_cfg.LookupButton( bstrText, -1 );

        if(bt)
        {
            bt->m_fEnabled = (fEnabled == VARIANT_TRUE);

            bt->UpdateState( m_hwndTB );

            UpdateSize();
        }
    }

    return S_OK;
}


STDMETHODIMP CPCHToolBar::SetVisibility( /*[in]*/ BSTR bstrText, /*[in]*/ VARIANT_BOOL fVisible )
{
    if(SUCCEEDED(Config_Load()))
    {
        Button* bt = m_cfg.LookupButton( bstrText, -1 );

        if(bt)
        {
            bt->m_fVisible = (fVisible == VARIANT_TRUE);

            bt->UpdateState( m_hwndTB );

            UpdateSize();
        }
    }

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////

//
// This is ugly, but unless we find a better way to get the HTML element for our site it's our only hope..
//
HRESULT CPCHToolBar::FindElementThroughThunking( /*[out]*/ CComPtr<IHTMLElement>& elem )
{
	__HCP_FUNC_ENTRY( "CPCHToolBar::FindElementThroughThunking" );

	HRESULT                         hr;
	CComPtr<IServiceProvider>       sp;
	CComPtr<IHTMLDocument2>         doc2;
	CComPtr<IHTMLElementCollection> coll;
	MPC::HTML::IHTMLElementList     lst;


	elem.Release();


	//
	// Get Document element.
	//
	__MPC_EXIT_IF_METHOD_FAILS(hr, m_spAmbientDispatch->QueryInterface( IID_IServiceProvider, (void**)&sp ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, sp->QueryService( SID_SContainerDispatch, IID_IHTMLDocument2, (void **)&doc2 ));

	//
	// Get list of OBJECT elements.
	//
    MPC_SCRIPTHELPER_GET__DIRECT__NOTNULL(coll, doc2, all);
	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::HTML::EnumerateCollection( lst, coll, L"<OBJECT" ));

	//
	// Try to locate ourself.
	//
	for(MPC::HTML::IHTMLElementIter it=lst.begin(); it != lst.end(); it++)
	{
		CComQIPtr<IPCHToolBarPrivate> tb = *it;

		if(tb && SUCCEEDED(tb->SameObject( this )))
		{
			elem = *it;
			break;
		}
	}

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\controls\htmlprogressbar.cpp ===
/******************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:
    Toolbar.cpp

Abstract:
    This file contains the ActiveX control that makes Win32 ProgressBars available to HTML.

Revision History:
    Davide Massarenti   (Dmassare)  03/04/2001
        created

******************************************************************************/

#include "stdafx.h"

#include <comctrlp.h>

////////////////////////////////////////////////////////////////////////////////

CPCHProgressBar::CPCHProgressBar()
{
    m_bWindowOnly = TRUE; // Inherited from CComControlBase


    m_hwndPB     = NULL; // HWND m_hwndPB;
                         //		 
    m_lLowLimit  =   0;  // long m_lLowLimit;
    m_lHighLimit = 100;  // long m_lHighLimit;
    m_lPos       =   0;  // long m_lPos;
}

/////////////////////////////////////////////////////////////////////////////

BOOL CPCHProgressBar::ProcessWindowMessage( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult, DWORD dwMsgMapID )
{
    lResult = 0;

    switch(uMsg)
    {
    case WM_CREATE:
		{
			CComPtr<IServiceProvider> sp;
			CComPtr<IHTMLDocument3>   doc3;
			CComBSTR                  bstrDir;
			DWORD                     dwStyleEx = 0;

			if(SUCCEEDED(m_spAmbientDispatch->QueryInterface( IID_IServiceProvider                      , (void**)&sp   	  )) &&
			   SUCCEEDED(sp->QueryService                   ( SID_SContainerDispatch, IID_IHTMLDocument3, (void**)&doc3 	  )) &&
			   SUCCEEDED(doc3->get_dir                      (                                                     &bstrDir ))  )
			{
				if(MPC::StrICmp( bstrDir, L"RTL" ) == 0)
				{
					dwStyleEx = WS_EX_LAYOUTRTL;
				}
			}

			m_hwndPB = ::CreateWindowExW( dwStyleEx, PROGRESS_CLASS, NULL, WS_CHILD | WS_VISIBLE, 0, 0, 0, 0, m_hWnd, NULL, NULL, NULL );
			if(m_hwndPB)
			{
				// Set the range and increment of the progress bar. 
				::SendMessage( m_hwndPB, PBM_SETRANGE32, m_lLowLimit, m_lHighLimit ); 
				::SendMessage( m_hwndPB, PBM_SETPOS    , m_lPos     , 0            );
			}
        }
        return TRUE;


    case WM_SIZE:
		if(m_hwndPB)
        {
            int  nWidth  = LOWORD(lParam);  // width of client area
            int  nHeight = HIWORD(lParam); // height of client area

			::SetWindowPos( m_hwndPB, NULL, 0, 0, nWidth, nHeight, SWP_NOZORDER|SWP_NOACTIVATE );
        }
        return TRUE;


    case WM_DESTROY:
        m_hwndPB = NULL;
        return TRUE;
    }

    return CComControl<CPCHProgressBar>::ProcessWindowMessage( hWnd, uMsg, wParam, lParam, lResult, dwMsgMapID );
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHProgressBar::get_LowLimit( /*[out, retval]*/ long *pVal )
{
	if(pVal) *pVal = m_lLowLimit;

	return S_OK;
}

STDMETHODIMP CPCHProgressBar::put_LowLimit( /*[in]*/ long newVal )
{
	m_lLowLimit = newVal;

	if(m_hwndPB)
	{
		::SendMessage( m_hwndPB, PBM_SETRANGE32, m_lLowLimit, m_lHighLimit ); 
	}

	return S_OK;
}


STDMETHODIMP CPCHProgressBar::get_HighLimit( /*[out, retval]*/ long *pVal )
{
	if(pVal) *pVal = m_lHighLimit;

	return S_OK;
}

STDMETHODIMP CPCHProgressBar::put_HighLimit( /*[in]*/ long newVal )
{
	m_lHighLimit = newVal;

	if(m_hwndPB)
	{
		::SendMessage( m_hwndPB, PBM_SETRANGE32, m_lLowLimit, m_lHighLimit ); 
	}

	return S_OK;
}


STDMETHODIMP CPCHProgressBar::get_Pos( /*[out, retval]*/ long *pVal )
{
	if(pVal) *pVal = m_lPos;

	return S_OK;
}

STDMETHODIMP CPCHProgressBar::put_Pos( /*[in]*/ long newVal )
{
	m_lPos = newVal;

	if(m_hwndPB)
	{
		::SendMessage( m_hwndPB, PBM_SETPOS, m_lPos, 0 ); 
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\core\hc.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    HC.cpp

Abstract:
    This file contains the start-up code to create and initialize the Help Center.

Revision History:
    Davide Massarenti   (Dmassare)  08/07/99
        created

******************************************************************************/

#include "stdafx.h"

#include <DataCollection.h>

#include "resource.h"
#include <initguid.h>

#include <HelpServiceTypeLib_i.c>
#include <HelpCenterTypeLib_i.c>

#include <NameSpace_Impl.h>

#include "msscript.h"

/////////////////////////////////////////////////////////////////////////////

static const WCHAR MARSCORE_DLL  [] = L"pchshell.dll";
static const WCHAR HCP_PROTOCOL  [] = L"HCP";
static const WCHAR MSITS_PROTOCOL[] = L"MS-ITS";

static const WCHAR HELPSVC_REGISTRATION[] = HC_ROOT_HELPSVC_BINARIES L"\\HelpSvc.exe /svchost netsvcs /regserver";

/////////////////////////////////////////////////////////////////////////////

EXTERN_C const CLSID CLSID_JavaScript = { 0xF414C260, 0x6AC0, 0x11CF, { 0xB6, 0xD1, 0x00, 0xAA, 0x00, 0xBB, 0xBB, 0x58 } };

/////////////////////////////////////////////////////////////////////////////

// From "mars.h"
typedef int (APIENTRY *PFNMARSMAIN)(HICON  hAppIcon,
                                    LPWSTR lpAppTitle,
                                    LPWSTR lpCmdLine,
                                    int    nCmdShow);

/////////////////////////////////////////////////////////////////////////////

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_PCHBootstrapper     , CPCHBootstrapper                                 )
    OBJECT_ENTRY(CLSID_PCHHelpViewerWrapper, CPCHHelpViewerWrapper                            )
    OBJECT_ENTRY(CLSID_PCHToolBar          , CPCHToolBar                                      )
    OBJECT_ENTRY(CLSID_PCHProgressBar      , CPCHProgressBar                                  )
    OBJECT_ENTRY(CLSID_PCHJavaScriptWrapper, CPCHScriptWrapper_ClientSide< &CLSID_JavaScript >)
    OBJECT_ENTRY(CLSID_PCHVBScriptWrapper  , CPCHScriptWrapper_ClientSide< &CLSID_VBScript   >)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////

#define DEBUG_REGKEY       HC_REGISTRY_HELPCTR L"\\Debug"
#define DEBUG_BREAKONSTART L"BREAKONSTART"

#define DEBUG_BLOCKERRORS  L"BLOCKERRORS"
#define DEBUG_CONTEXTMENU  L"CONTEXTMENU"
#define DEBUG_BUILDTREE    L"BUILDTREE"
#define DEBUG_FORCESTYLE   L"FORCESTYLE"
#define DEBUG_FORCERTL     L"FORCERTL"

bool  g_Debug_BLOCKERRORS = true;
bool  g_Debug_CONTEXTMENU = false;
bool  g_Debug_BUILDTREE   = false;
WCHAR g_Debug_FORCESTYLE[64];

/////////////////////////////////////////////////////////////////////////////

static bool FindMarsDLL( HMODULE&           hModule         ,
                         PFNMARSTHREADPROC& pMarsThreadProc )
{
    hModule = ::LoadLibraryW( MARSCORE_DLL );
    if(hModule)
    {
        pMarsThreadProc = (PFNMARSTHREADPROC)GetProcAddress( hModule, (LPCSTR)ORD_MARSTHREADPROC );
        if(pMarsThreadProc == NULL)
        {
            MPC::LocalizedMessageBox( IDS_HELPCTR_DLG_ERROR, IDS_HELPCTR_MARSCORE_INCORRECT_VERSION, MB_OK );
            return false;
        }
    }
    else
    {
        MPC::LocalizedMessageBox( IDS_HELPCTR_DLG_ERROR, IDS_HELPCTR_MARSCORE_NOT_FOUND, MB_OK );
        return false;
    }

    return true;
}

/////////////////////////////////////////////////////////////////////////////

static HRESULT RegisterProtocols( /*[in/out]*/ CComPtr<IInternetSession>& pSession      ,
                                  /*[in/out]*/ CComPtr<IClassFactory>   & pFactoryHCP   ,
                                  /*[in/out]*/ CComPtr<IClassFactory>   & pFactoryMSITS )
{
    __HCP_FUNC_ENTRY( "RegisterProtocols" );

    HRESULT                       hr;
    CComPtr<CHCPProtocolInfo>     objHCP;
    CComPtr<CPCHWrapProtocolInfo> objMSITS;


    __MPC_EXIT_IF_METHOD_FAILS(hr, _Module.RegisterClassObjects( CLSCTX_INPROC_SERVER, REGCLS_MULTIPLEUSE ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoInternetGetSession( 0, &pSession, 0 ));


    //
    // Create an instance of CHCPProtocolInfo, that acts also as a class factory for CHCPProtocol.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &objHCP ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, objHCP->QueryInterface( IID_IClassFactory, (void **)&pFactoryHCP ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pSession->RegisterNameSpace( pFactoryHCP, CLSID_HCPProtocol, HCP_PROTOCOL, 0, NULL, 0 ));


    //
    // Create an instance of CPCHWrapProtocolInfo, that acts as a wrapper around the real MS-ITS class factory.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &objMSITS ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, objMSITS->Init( CLSID_MSITSProtocol ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, objMSITS->QueryInterface( IID_IClassFactory, (void **)&pFactoryMSITS ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pSession->RegisterNameSpace( pFactoryMSITS, CLSID_MSITSProtocol, MSITS_PROTOCOL, 0, NULL, 0 ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

static HRESULT UnregisterProtocols( /*[in/out]*/ CComPtr<IInternetSession>& pSession      ,
                                    /*[in/out]*/ CComPtr<IClassFactory>   & pFactoryHCP   ,
                                    /*[in/out]*/ CComPtr<IClassFactory>   & pFactoryMSITS )
{
    __HCP_FUNC_ENTRY( "UnregisterProtocols" );

    HRESULT hr;


    if(pSession)
    {
        if(pFactoryHCP)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, pSession->UnregisterNameSpace( pFactoryHCP, HCP_PROTOCOL ));

            pFactoryHCP.Release();
        }

        if(pFactoryMSITS)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, pSession->UnregisterNameSpace( pFactoryMSITS, MSITS_PROTOCOL ));

            pFactoryMSITS.Release();
        }

        pSession.Release();
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, _Module.RevokeClassObjects());

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

static HRESULT InitAll()
{
    __HCP_FUNC_ENTRY( "InitAll" );

    HRESULT hr;

    // Fix environment block if necessary
    if (!GetEnvironmentVariableW(L"windir", NULL, 0))
    {
        // %windir% not in the env block (e.g. 16-bit apps), add it
        WCHAR szWindir[MAX_PATH + 1];
        int nChars = GetWindowsDirectory(szWindir, ARRAYSIZE(szWindir));
        if (nChars > 0 && nChars < ARRAYSIZE(szWindir))
        {
            SetEnvironmentVariable(L"windir", szWindir);
        }
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::LocalizeInit());

    __MPC_EXIT_IF_METHOD_FAILS(hr, OfflineCache::Root     ::InitializeSystem( /*fMaster*/false ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHContentStore       ::InitializeSystem( /*fMaster*/false ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, HyperLinks::Lookup     ::InitializeSystem(                  ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHHelpCenterExternal ::InitializeSystem(                  ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHFavorites          ::InitializeSystem(                  ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHOptions            ::InitializeSystem(                  ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, CHCPProtocolEnvironment::InitializeSystem(                  ));


    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

static void CleanAll()
{
	CHCPProtocolEnvironment::FinalizeSystem();
	CPCHFavorites          ::FinalizeSystem();
	CPCHOptions            ::FinalizeSystem();
	CPCHHelpCenterExternal ::FinalizeSystem();
	HyperLinks::Lookup     ::FinalizeSystem();

	CPCHContentStore       ::FinalizeSystem();
	OfflineCache::Root     ::FinalizeSystem();
}

////////////////////////////////////////////////////////////////////////////////

static HRESULT ProcessArguments( int      argc ,
                                 LPCWSTR* argv )
{
    __HCP_FUNC_ENTRY( "ProcessArguments" );

    HRESULT                   hr;
    HMODULE                   hModule         = NULL;
    PFNMARSTHREADPROC         pMarsThreadProc = NULL;
    CComPtr<IInternetSession> pSession;
    CComPtr<IClassFactory>    pFactoryHCP;
    CComPtr<IClassFactory>    pFactoryMSITS;
	bool                      fCOM_reg   = false;
	bool                      fCOM_unreg = false;
    int                       i;



    DEBUG_AppendPerf( DEBUG_PERF_BASIC, "ProcessArguments" );

	__MPC_EXIT_IF_METHOD_FAILS(hr, InitAll());

    for(i=1; i<argc; i++)
    {
        LPCWSTR szArg = argv[i];

        if(szArg[0] == '-' ||
           szArg[0] == '/'  )
        {
            szArg++;

            if(_wcsicmp( szArg, L"RegServer"   ) == 0) fCOM_reg   = true;
            if(_wcsicmp( szArg, L"UnregServer" ) == 0) fCOM_unreg = true;
        }
    }

	if(fCOM_reg || fCOM_unreg)
	{
		MPC::wstring             strDir( HC_ROOT_HELPSVC_BINARIES ); MPC::SubstituteEnvVariables( strDir );
		struct _ATL_REGMAP_ENTRY rgREG[] =
		{
			{ L"BINARIES", strDir.c_str() },
			{ NULL       , NULL           }
		};

		_Module.UpdateRegistryFromResource( IDR_HC, fCOM_reg ? TRUE : FALSE, rgREG );

		if(fCOM_reg)
		{
			_Module.RegisterTypeLib( _T("\\1") );
			_Module.RegisterTypeLib( _T("\\2") );
		}

		if(fCOM_unreg)
		{
			_Module.UnRegisterTypeLib( _T("\\1") );
			_Module.UnRegisterTypeLib( _T("\\2") );
		}

		__MPC_SET_ERROR_AND_EXIT(hr, S_OK);
	}

    //////////////////////////////////////////////////////////////////////

	{
		MPC::RegKey rkBase;
		bool        fFound;

		if(SUCCEEDED(rkBase.SetRoot( HKEY_LOCAL_MACHINE )) &&
		   SUCCEEDED(rkBase.Attach ( DEBUG_REGKEY       )) &&
		   SUCCEEDED(rkBase.Exists ( fFound             )) && fFound)
		{
			CComVariant vValue;

#ifdef DEBUG
			if(SUCCEEDED(rkBase.get_Value( vValue, fFound, DEBUG_BREAKONSTART )) && fFound && vValue.vt == VT_I4)
			{
				if(vValue.lVal) DebugBreak();
			}

			g_Debug_CONTEXTMENU = true;
			g_Debug_BUILDTREE   = true;

			if(SUCCEEDED(rkBase.get_Value( vValue, fFound, DEBUG_FORCESTYLE )) && fFound && vValue.vt == VT_BSTR && vValue.bstrVal)
			{
				wcsncpy( g_Debug_FORCESTYLE, vValue.bstrVal, MAXSTRLEN(g_Debug_FORCESTYLE) );
			}

			if(SUCCEEDED(rkBase.get_Value( vValue, fFound, DEBUG_FORCERTL )) && fFound && vValue.vt == VT_I4)
			{
				if(vValue.lVal) ::SetProcessDefaultLayout( LAYOUT_RTL );
			}

#endif

			if(SUCCEEDED(rkBase.get_Value( vValue, fFound, DEBUG_BLOCKERRORS )) && fFound && vValue.vt == VT_I4)
			{
				g_Debug_BLOCKERRORS = (vValue.lVal != 0);
			}

			if(SUCCEEDED(rkBase.get_Value( vValue, fFound, DEBUG_CONTEXTMENU )) && fFound && vValue.vt == VT_I4)
			{
				g_Debug_CONTEXTMENU = (vValue.lVal != 0);
			}

			if(SUCCEEDED(rkBase.get_Value( vValue, fFound, DEBUG_BUILDTREE )) && fFound && vValue.vt == VT_I4)
			{
				g_Debug_BUILDTREE = (vValue.lVal != 0);
			}
		}
	}

    //////////////////////////////////////////////////////////////////////

    __MPC_EXIT_IF_METHOD_FAILS(hr, RegisterProtocols( pSession, pFactoryHCP, pFactoryMSITS ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHHelpCenterExternal::s_GLOBAL->Initialize());

    //
    // Look for the service and warn the user if we cannot find it.
    //
    if(CPCHHelpCenterExternal::s_GLOBAL->IsServiceRunning() == false)
    {
  	       //
	       // Bug 535303 SVR: Security:  Help And Support Service Resets to Automatic after Set to Disabled
	       // Modified 4/24 gschua
	       //
		//
		// Try re-registering the service.
		//
		/*
		{
			MPC::wstring strCmdLine( HELPSVC_REGISTRATION ); MPC::SubstituteEnvVariables( strCmdLine );

			(void)MPC::ExecuteCommand( strCmdLine );
		}

		if(CPCHHelpCenterExternal::s_GLOBAL->IsServiceRunning() == false)
		{
			MPC::LocalizedMessageBox( IDS_HELPCTR_DLG_ERROR, IDS_HELPCTR_SVC_MISSING, MB_OK );

			__MPC_SET_ERROR_AND_EXIT(hr, S_OK);
		}

		*/

		MPC::LocalizedMessageBox( IDS_HELPCTR_DLG_ERROR, IDS_HELPCTR_SVC_MISSING, MB_OK );
		__MPC_SET_ERROR_AND_EXIT(hr, S_OK);

    }

    for(i=1; i<argc; i++)
    {
        LPCWSTR szArg = argv[i];

        if(szArg[0] == '-' ||
           szArg[0] == '/'  )
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHHelpCenterExternal::s_GLOBAL->ProcessArgument( i, &szArg[1], argc, argv ));
        }
    }

    if(CPCHHelpCenterExternal::s_GLOBAL->DoWeNeedUI())
    {
        MPC::wstring szTitle; MPC::LocalizeString( IDS_MAINWND_TITLE, szTitle );

		{
			INITCOMMONCONTROLSEX icc;

			icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
			icc.dwICC  = ICC_USEREX_CLASSES | ICC_COOL_CLASSES | ICC_INTERNET_CLASSES | ICC_PAGESCROLLER_CLASS | ICC_NATIVEFNTCTL_CLASS;

			::InitCommonControlsEx( &icc );
		}

        //
        // Load the UI.
        //
        DEBUG_AppendPerf( DEBUG_PERF_BASIC, "UI - Pre FindMarsDLL" );

        if(FindMarsDLL( hModule, pMarsThreadProc ))
        {
            DEBUG_AppendPerf( DEBUG_PERF_BASIC, "UI - Post FindMarsDLL" );


            DEBUG_AppendPerf( DEBUG_PERF_BASIC, "UI - Ready to go" );
            hr = CPCHHelpCenterExternal::s_GLOBAL->RunUI( szTitle, pMarsThreadProc );
            DEBUG_AppendPerf( DEBUG_PERF_BASIC, "UI - Passivating" );
        }
    }

    //////////////////////////////////////////////////////////////////////

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    if(hModule) ::FreeLibrary( hModule );

    (void)UnregisterProtocols( pSession, pFactoryHCP, pFactoryMSITS );

	CleanAll();

    __HCP_FUNC_EXIT(hr);
}


extern "C" int WINAPI wWinMain( HINSTANCE   hInstance    ,
                                HINSTANCE   hPrevInstance,
                                LPWSTR      lpCmdLine    ,
                                int         nShowCmd     )
{
    HRESULT  hr;
    int      argc;
    LPCWSTR* argv;


    DEBUG_AppendPerf( DEBUG_PERF_BASIC, "wWinMain" );

    if(SUCCEEDED(hr = ::CoInitialize( NULL )))
    {
        if(SUCCEEDED(hr = ::CoInitializeSecurity( NULL                     ,
                                                  -1                       , // We don't care which authentication service we use.
                                                  NULL                     ,
                                                  NULL                     ,
                                                  RPC_C_AUTHN_LEVEL_CONNECT, // We want to identify the callers.
                                                  RPC_C_IMP_LEVEL_DELEGATE , // We want to be able to forward the caller's identity.
                                                  NULL                     ,
                                                  EOAC_DYNAMIC_CLOAKING    , // Let's use the thread token for outbound calls.
                                                  NULL                     )))
        {
            __MPC_TRACE_INIT();

            //
            // Parse the command line.
            //
            if(SUCCEEDED(hr = MPC::CommandLine_Parse( argc, argv )))
            {
                //
                // Initialize ATL modules.
                //
                _Module.Init( ObjectMap, hInstance, L"helpctr", 0, 0 );

                //
                // Initialize MPC module.
                //
                if(SUCCEEDED(hr = MPC::_MPC_Module.Init()))
                {
                    //
                    // Process arguments.
                    //
                    hr = ProcessArguments( argc, argv );

                    MPC::_MPC_Module.Term();
                }

                _Module.Term();

                MPC::CommandLine_Free( argc, argv );
            }

            __MPC_TRACE_TERM();
        }

        ::CoUninitialize();
    }

    DEBUG_AppendPerf( DEBUG_PERF_BASIC, "Shutdown"            );
    DEBUG_DumpPerf  ( L"%WINDIR%\\TEMP\\HC_perf_counters.txt" );

    return FAILED(hr) ? 10 : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\include\behaviors.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Behaviors.h

Abstract:
    This file contains the declaration of various classes associated with
    binary behaviors.

Revision History:
    Davide Massarenti   (Dmassare)  06/06/2000
        created

******************************************************************************/

#if !defined(__INCLUDED___PCH___BEHAVIORS_H___)
#define __INCLUDED___PCH___BEHAVIORS_H___

#include <mshtmlc.h>

class CPCHHelpCenterExternal;

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHElementBehaviorFactory : // Hungarian: hcebf
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public IServiceProvider,
    public IElementBehaviorFactory
{
	CPCHHelpCenterExternal* m_parent;

public:
BEGIN_COM_MAP(CPCHElementBehaviorFactory)
    COM_INTERFACE_ENTRY(IServiceProvider)
    COM_INTERFACE_ENTRY(IElementBehaviorFactory)
END_COM_MAP()

    CPCHElementBehaviorFactory();

    void Initialize( /*[in]*/ CPCHHelpCenterExternal* parent );

    //////////////////////////////////////////////////////////////////////

    //
    // IServiceProvider
    //
    STDMETHOD(QueryService)( REFGUID guidService, REFIID riid, void **ppv );

    //
    // IElementBehaviorFactory
    //
    STDMETHOD(FindBehavior)( /*[in]*/  BSTR                   bstrBehavior    ,
                             /*[in]*/  BSTR                   bstrBehaviorUrl ,
                             /*[in]*/  IElementBehaviorSite*  pSite           ,
                             /*[out]*/ IElementBehavior*     *ppBehavior      );
};

/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHBehavior :
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public IElementBehavior
{
public:
	struct EventDescription
	{
		LPCWSTR szName;
		DISPID  id;
	};

protected:
    typedef HRESULT (CPCHBehavior::*CLASS_METHOD)( DISPID, DISPPARAMS*, VARIANT* );

    struct EventSink : public IDispatch
    {
		long               m_lRef;

        CPCHBehavior*      m_Parent;
        CComPtr<IDispatch> m_elem;
        CComBSTR           m_bstrName;
        CLASS_METHOD       m_pfn;
        bool               m_fAttached;
		DISPID             m_idNotifyAs;

        EventSink( CPCHBehavior* parent );
        ~EventSink();

        HRESULT Attach();
        HRESULT Detach();

        //
        // IUnknown
        //
        STDMETHOD_(ULONG, AddRef)();
        STDMETHOD_(ULONG, Release)();
        STDMETHOD(QueryInterface)( REFIID iid, void ** ppvObject );

        //
        // IDispatch
        //
        STDMETHOD(GetTypeInfoCount)( UINT* pctinfo );

        STDMETHOD(GetTypeInfo)( UINT        itinfo  ,
                                LCID        lcid    ,
                                ITypeInfo* *pptinfo );

        STDMETHOD(GetIDsOfNames)( REFIID    riid      ,
                                  LPOLESTR* rgszNames ,
                                  UINT      cNames    ,
                                  LCID      lcid      ,
                                  DISPID*   rgdispid  );

        STDMETHOD(Invoke)( DISPID      dispidMember ,
                           REFIID      riid         ,
                           LCID        lcid         ,
                           WORD        wFlags       ,
                           DISPPARAMS* pdispparams  ,
                           VARIANT*    pvarResult   ,
                           EXCEPINFO*  pexcepinfo   ,
                           UINT*       puArgErr     );

		static HRESULT CreateInstance( /*[in]*/ CPCHBehavior* parent, /*[out]*/ EventSink*& pObj );
    };

    typedef std::list< EventSink* >    SinkList;
    typedef SinkList::iterator         SinkIter;
    typedef SinkList::const_iterator   SinkIterConst;

    ////////////////////////////////////////

    CPCHHelpCenterExternal*         m_parent;

    CComPtr<IElementBehaviorSiteOM> m_siteOM;
    CComPtr<IHTMLElement>           m_elem;
    CComPtr<IHTMLElement2>          m_elem2;
    SinkList                        m_lstEventSinks;
    bool                            m_fRTL;
    bool                            m_fTrusted;
    bool                            m_fSystem;

    ////////////////////////////////////////

    HRESULT AttachToEvent( /*[in] */ LPCWSTR       szName        ,
						   /*[in] */ CLASS_METHOD  pfn           ,
						   /*[in] */ IDispatch*    elem   = NULL ,
						   /*[out]*/ IDispatch*   *pVal   = NULL ,
						   /*[in] */ DISPID        id     = -1   );

    HRESULT AttachToEvents( /*[in] */ const EventDescription*  pEvents       ,
							/*[in] */ CLASS_METHOD 			   pfn           ,
							/*[in] */ IDispatch*   			   elem   = NULL );

    HRESULT CreateEvent  ( /*[in]*/ LPCWSTR szName, /*[out]*/ LONG& lEventCookie );

    HRESULT GetEventObject   ( /*[out]*/ CComPtr<IHTMLEventObj>& ev                             );
    HRESULT CreateEventObject( /*[out]*/ CComPtr<IHTMLEventObj>& ev                             );
    HRESULT FireEvent        ( /*[in ]*/         IHTMLEventObj*  ev, /*[in]*/ LONG lEventCookie );
    HRESULT FireEvent        (                                       /*[in]*/ LONG lEventCookie );

    HRESULT CancelEvent( /*[in]*/ IHTMLEventObj* ev = NULL, /*[in]*/ VARIANT* pvReturnValue = NULL, /*[in]*/ VARIANT_BOOL fCancelBubble = VARIANT_TRUE );

    ////////////////////////////////////////

    HRESULT GetEvent_SrcElement( /*[in]*/ CComPtr<IHTMLElement>& elem );

    ////////////////////////////////////////

	HRESULT GetAsVARIANT  ( /*[in]*/ BSTR       value, /*[out, retval]*/ VARIANT    *pVal );
	HRESULT GetAsVARIANT  ( /*[in]*/ IDispatch* value, /*[out, retval]*/ VARIANT    *pVal );
	HRESULT GetAsIDISPATCH( /*[in]*/ IDispatch* value, /*[out, retval]*/ IDispatch* *pVal );

    ////////////////////////////////////////
public:
BEGIN_COM_MAP(CPCHBehavior)
    COM_INTERFACE_ENTRY(IElementBehavior)
END_COM_MAP()

    CPCHBehavior();

    void Initialize( /*[in]*/ CPCHHelpCenterExternal* parent );

    //
    // IElementBehavior
    //
    STDMETHOD(Init  )( /*[in]*/ IElementBehaviorSite* pBehaviorSite     );
    STDMETHOD(Notify)( /*[in]*/ LONG lEvent, /*[in/out]*/ VARIANT* pVar );
    STDMETHOD(Detach)(                                                  );
};

/////////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___PCH___BEHAVIORS_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\core\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__412B7974_2F00_11D3_9A30_00C04F72D6C5__INCLUDED_)
#define AFX_STDAFX_H__412B7974_2F00_11D3_9A30_00C04F72D6C5__INCLUDED_


#include <module.h>


//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

//
// From HelpCenterTypeLib.idl
//
#include <HelpCenterTypeLib.h>

//
// For debug trace
//
#include <HCP_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_COM.h>

#include <HelpCenter.h>
#include <HelpCenterExternal.h>

#include <HelpCenter.h>
#include <HelpViewerWrapper.h>
#include <HelpCenterExternal.h>

#include <HtmlToolBar.h>
#include <HtmlProgressBar.h>

#include <QueryResult.h>
#include <Favorites.h>
#include <Options.h>

#include <TrustedScripts.h>

#include <rtccore.h>

//
// Content Store
//
#include <ContentStoreMgr.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__412B7974_2F00_11D3_9A30_00C04F72D6C5__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\include\connectivitylib.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    ConnectivityLib.h

Abstract:
    This file contains the declaration of the classes used to
    detect the status of the network.

Revision History:
    Davide Massarenti   (Dmassare)  04/15/200
        created

******************************************************************************/

#if !defined(__INCLUDED___PCH___CONNECTIVITYLIB_H___)
#define __INCLUDED___PCH___CONNECTIVITYLIB_H___

#include <MPC_COM.h>
#include <MPC_Utils.h>

/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHConnectionCheck : // Hungarian: pchcc
    public MPC::Thread             < CPCHConnectionCheck, IPCHConnectionCheck                                            >,
    public MPC::ConnectionPointImpl< CPCHConnectionCheck, &DIID_DPCHConnectionCheckEvents, MPC::CComSafeMultiThreadModel >,
    public IDispatchImpl           < IPCHConnectionCheck, &IID_IPCHConnectionCheck, &LIBID_HelpCenterTypeLib             >
{
    class UrlEntry
    {
    public:
        CN_URL_STATUS              m_lStatus;
        CComBSTR                   m_bstrURL;
        MPC::AsyncInvoke::CallItem m_vCtx;

        UrlEntry();

        HRESULT CheckStatus();
    };

    typedef std::list<UrlEntry>     UrlList;
    typedef UrlList::iterator       UrlIter;
    typedef UrlList::const_iterator UrlIterConst;

    CN_STATUS                            m_cnStatus;
    UrlList                              m_lstUrl;

    MPC::CComPtrThreadNeutral<IDispatch> m_sink_onCheckDone;
    MPC::CComPtrThreadNeutral<IDispatch> m_sink_onStatusChange;

    //////////////////////////////////////////////////////////////////////

    HRESULT Run();

    HRESULT put_Status( /*[in]*/ CN_STATUS pVal );

    //////////////////////////////////////////////////////////////////////

    //
    // Event firing methods.
    //
    HRESULT Fire_onCheckDone   ( IPCHConnectionCheck* obj, CN_URL_STATUS lStatus, HRESULT hr, BSTR bstrURL, VARIANT vCtx );
    HRESULT Fire_onStatusChange( IPCHConnectionCheck* obj, CN_STATUS     lStatus                                         );

    //////////////////////////////////////////////////////////////////////

public:
DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CPCHConnectionCheck)
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CPCHConnectionCheck)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHConnectionCheck)
    COM_INTERFACE_ENTRY(IConnectionPointContainer)
END_COM_MAP()

    CPCHConnectionCheck();

    void FinalRelease();

public:
    // IPCHConnectionCheck
    STDMETHOD(put_onCheckDone   )( /*[in] */ IDispatch*  function );
    STDMETHOD(put_onStatusChange)( /*[in] */ IDispatch*  function );
    STDMETHOD(get_Status        )( /*[out]*/ CN_STATUS  *pVal     );

    STDMETHOD(StartUrlCheck)( /*[in]*/ BSTR bstrURL, /*[in]*/ VARIANT vCtx );
    STDMETHOD(Abort        )(                                              );
};

////////////////////////////////////////////////////////////////////////////////

class CPCHHelpCenterExternal;

class ATL_NO_VTABLE CPCHConnectivity : // Hungarian: pchcc
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public IDispatchImpl<IPCHConnectivity, &IID_IPCHConnectivity, &LIBID_HelpCenterTypeLib>
{
    CPCHHelpCenterExternal* m_parent;

public:
BEGIN_COM_MAP(CPCHConnectivity)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHConnectivity)
END_COM_MAP()

    CPCHConnectivity();

    HRESULT ConnectToParent( /*[in]*/ CPCHHelpCenterExternal* parent );

    ////////////////////////////////////////////////////////////////////////////////

    // IPCHConnectivity
    STDMETHOD(get_IsAModem       )( /*[out, retval]*/ VARIANT_BOOL *pVal );
    STDMETHOD(get_IsALan         )( /*[out, retval]*/ VARIANT_BOOL *pVal );
    STDMETHOD(get_AutoDialEnabled)( /*[out, retval]*/ VARIANT_BOOL *pVal );
    STDMETHOD(get_HasConnectoid  )( /*[out, retval]*/ VARIANT_BOOL *pVal );
    STDMETHOD(get_IPAddresses    )( /*[out, retval]*/ BSTR         *pVal );

    STDMETHOD(CreateObject_ConnectionCheck)( /*[out, retval]*/ IPCHConnectionCheck* *ppCC );

    STDMETHOD(NetworkAlive        )(                        /*[out, retval]*/ VARIANT_BOOL *pVal );
    STDMETHOD(DestinationReachable)( /*[in]*/ BSTR bstrURL, /*[out, retval]*/ VARIANT_BOOL *pVal );

    STDMETHOD(AutoDial      )( /*[in]*/ VARIANT_BOOL bUnattended );
    STDMETHOD(AutoDialHangup)(                                   );

    STDMETHOD(NavigateOnline)( /*[in         ]*/ BSTR    bstrTargetURL  ,
                               /*[in         ]*/ BSTR    bstrTopicTitle ,
                               /*[in         ]*/ BSTR    bstrTopicIntro ,
                               /*[in,optional]*/ VARIANT vOfflineURL    );
};

////////////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___PCH___CONNECTIVITYLIB_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\include\favorites.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Favorites.h

Abstract:
    This file contains the declaration of the class used to implement
    the Favorites inside the Help Center Application.

Revision History:
    Davide Massarenti   (dmassare)  05/10/2000
        created

******************************************************************************/

#if !defined(__INCLUDED___PCH___FAVORITES_H___)
#define __INCLUDED___PCH___FAVORITES_H___

/////////////////////////////////////////////////////////////////////////////

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

//
// From HelpCenterTypeLib.idl
//
#include <HelpCenterTypeLib.h>

typedef MPC::CComCollection< IPCHFavorites, &LIBID_HelpCenterTypeLib, MPC::CComSafeMultiThreadModel> CPCHFavorites_Parent;

class ATL_NO_VTABLE CPCHFavorites : // Hungarian: pchf
    public CPCHFavorites_Parent
{
public:
    struct Entry
    {
    public:
        CComPtr<CPCHHelpSessionItem> m_Data;

        HRESULT Init(                                     );
        HRESULT Load( /*[in]*/ MPC::Serializer& streamIn  );
        HRESULT Save( /*[in]*/ MPC::Serializer& streamOut );
    };

    typedef std::list< Entry >   List;
    typedef List::iterator       Iter;
    typedef List::const_iterator IterConst;

    ////////////////////////////////////////

private:
    List m_lstFavorites;
    bool m_fLoaded;

    ////////////////////////////////////////

    HRESULT Erase();

    HRESULT Load();
    HRESULT Save();

    HRESULT FindEntry( /*[in]*/ IPCHHelpSessionItem* pItem, /*[out]*/ Iter& it );

    ////////////////////////////////////////

public:
BEGIN_COM_MAP(CPCHFavorites)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHCollection)
    COM_INTERFACE_ENTRY(IPCHFavorites)
END_COM_MAP()

    CPCHFavorites();
    virtual ~CPCHFavorites();

	////////////////////////////////////////////////////////////////////////////////

	static CPCHFavorites* s_GLOBAL;

    static HRESULT InitializeSystem();
	static void    FinalizeSystem  ();
	
	////////////////////////////////////////////////////////////////////////////////

    HRESULT Synchronize( /*[in]*/ bool fForce );

public:
    // IPCHFavorites
    STDMETHOD(IsDuplicate)( /*[in]*/ BSTR bstrURL,                                      /*[out, retval]*/ VARIANT_BOOL         *pfDup  );
    STDMETHOD(Add        )( /*[in]*/ BSTR bstrURL, /*[in,optional]*/ VARIANT vTitle   , /*[out, retval]*/ IPCHHelpSessionItem* *ppItem );
    STDMETHOD(Rename     )(                        /*[in]*/          BSTR    bstrTitle, /*[in]*/          IPCHHelpSessionItem*   pItem );
    STDMETHOD(Move       )( /*[in]*/ IPCHHelpSessionItem* pInsertAfter,                 /*[in]*/          IPCHHelpSessionItem*   pItem );
    STDMETHOD(Delete     )(                                                             /*[in]*/          IPCHHelpSessionItem*   pItem );
};

/////////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___PCH___FAVORITES_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\include\events.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Events.h

Abstract:
    This file contains the declaration of the classes related to events.

Revision History:
    Davide Massarenti   (dmassare) 10/31/99
        modified

******************************************************************************/

#if !defined(__INCLUDED___PCH___EVENTS_H___)
#define __INCLUDED___PCH___EVENTS_H___

#include <MPC_COM.h>

#include <dispex.h>
#include <ocmm.h>

#include <HelpSession.h>

/////////////////////////////////////////////////////////////////////////////

class CPCHEvent;
class CPCHEvents;
class CPCHWebBrowserEvents;

class CPCHHelpCenterExternal;

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/*
// DISPID_STATUSTEXTCHANGE   void StatusTextChange([in] BSTR Text);
// DISPID_PROGRESSCHANGE     void ProgressChange([in] long Progress, [in] long ProgressMax);
// DISPID_COMMANDSTATECHANGE void CommandStateChange([in] long Command, [in] VARIANT_BOOL Enable);
// DISPID_DOWNLOADBEGIN      void DownloadBegin();
// DISPID_DOWNLOADCOMPLETE   void DownloadComplete();
// DISPID_TITLECHANGE        void TitleChange([in] BSTR Text);
// DISPID_PROPERTYCHANGE     void PropertyChange([in] BSTR szProperty);
// DISPID_BEFORENAVIGATE2    void BeforeNavigate2([in] IDispatch* pDisp, [in] VARIANT* URL, [in] VARIANT* Flags, [in] VARIANT* TargetFrameName, [in] VARIANT* PostData, [in] VARIANT* Headers, [in, out] VARIANT_BOOL* Cancel);
// DISPID_NEWWINDOW2         void NewWindow2([in, out] IDispatch** ppDisp, [in, out] VARIANT_BOOL* Cancel);
// DISPID_NAVIGATECOMPLETE2  void NavigateComplete2([in] IDispatch* pDisp, [in] VARIANT* URL);
// DISPID_DOCUMENTCOMPLETE   void DocumentComplete([in] IDispatch* pDisp, [in] VARIANT* URL);
// DISPID_ONQUIT             void OnQuit();
// DISPID_ONVISIBLE          void OnVisible([in] VARIANT_BOOL Visible);
// DISPID_ONTOOLBAR          void OnToolBar([in] VARIANT_BOOL ToolBar);
// DISPID_ONMENUBAR          void OnMenuBar([in] VARIANT_BOOL MenuBar);
// DISPID_ONSTATUSBAR        void OnStatusBar([in] VARIANT_BOOL StatusBar);
// DISPID_ONFULLSCREEN       void OnFullScreen([in] VARIANT_BOOL FullScreen);
// DISPID_ONTHEATERMODE      void OnTheaterMode([in] VARIANT_BOOL TheaterMode);
*/


////////////////////////////////////////////////////////////////////////////////

class CPCHTimerHandle
{
    struct CallbackBase : public ITimerSink
    {
        long m_lRef;

    public:
        CallbackBase();

        virtual void Detach() = 0;

        ////////////////////

        //
        // IUnknown
        //
        STDMETHOD_(ULONG, AddRef)();
        STDMETHOD_(ULONG, Release)();
        STDMETHOD(QueryInterface)( REFIID iid, void ** ppvObject );
    };

    template <class C> class Callback : public CallbackBase
    {
    public:
        typedef HRESULT (C::*CLASS_METHOD)( /*[in]*/ VARIANT );

    private:
        C*           m_pThis;
        CLASS_METHOD m_pCallback;

    public:
        Callback( /*[in]*/ C* pThis, /*[in]*/ CLASS_METHOD pCallback )
        {
            m_pThis     = pThis;
            m_pCallback = pCallback;
        }

        virtual void Detach()
        {
            m_pThis     = NULL;
            m_pCallback = NULL;
        }

        //
        // ITimerSink
        //
        STDMETHOD(OnTimer)( /*[in]*/ VARIANT vtimeAdvise )
        {
            if(m_pThis == NULL || m_pCallback == NULL) return S_FALSE;

            return (m_pThis->*m_pCallback)( vtimeAdvise );
        }
    };

    ////////////////////

    CComPtr<ITimer> m_timer;
    DWORD           m_dwCookie;
    CallbackBase*   m_callback;

    ////////////////////

    HRESULT Advise  ( /*[in]*/ CallbackBase* callback, /*[in]*/ DWORD dwWait );
    void    Unadvise(                                                        );

public:
    CPCHTimerHandle();
    ~CPCHTimerHandle();

    void Initialize( /*[in]*/ ITimer* timer );

    template <class C> HRESULT Start( /*[in/out]*/ C* pThis, /*[in]*/ HRESULT (C::*pCallback)( /*[in]*/ VARIANT ), /*[in]*/ DWORD dwWait )
    {
        if(pThis == NULL || pCallback == NULL) return E_INVALIDARG;

        return Advise( new Callback<C>( pThis, pCallback ), dwWait );
    }

    void Stop()
    {
        Unadvise();
    }
};

////////////////////////////////////////////////////////////////////////////////

typedef IDispEventImpl<0,CPCHWebBrowserEvents,&DIID_DWebBrowserEvents2,&LIBID_SHDocVw,1> CPCHWebBrowserEvents_DWebBrowserEvents2;

class CPCHWebBrowserEvents :
    public CPCHWebBrowserEvents_DWebBrowserEvents2
{
    CPCHHelpCenterExternal* m_parent;
    HscPanel                m_idPanel;

    CComPtr<IWebBrowser2>   m_pWB2;
    bool                    m_fLoading;

    CPCHTimerHandle         m_TimerDelay;
    CPCHTimerHandle         m_TimerExpire;

    ////////////////////

    enum TimerMode
    {
        TIMERMODE_STOP    ,
        TIMERMODE_RESTART ,
        TIMERMODE_MORETIME,
        TIMERMODE_COMPLETE,
    };

    void TimerControl( /*[in]*/ TimerMode mode );

public:
BEGIN_SINK_MAP(CPCHWebBrowserEvents)
    SINK_ENTRY_EX(0,DIID_DWebBrowserEvents2,DISPID_BEFORENAVIGATE2  ,BeforeNavigate2  )
    SINK_ENTRY_EX(0,DIID_DWebBrowserEvents2,DISPID_NEWWINDOW2       ,NewWindow2       )
    SINK_ENTRY_EX(0,DIID_DWebBrowserEvents2,DISPID_NAVIGATECOMPLETE2,NavigateComplete2)
    SINK_ENTRY_EX(0,DIID_DWebBrowserEvents2,DISPID_DOCUMENTCOMPLETE ,DocumentComplete )
END_SINK_MAP()

    CPCHWebBrowserEvents();
    virtual ~CPCHWebBrowserEvents();

    void Initialize( /*[in]*/ CPCHHelpCenterExternal* parent, /*[in]*/ HscPanel idPanel );
    void Passivate (                                                                    );
    void Attach    ( /*[in]*/ IWebBrowser2* pWB                                         );
    void Detach    (                                                                    );


    void NotifyStartOfNavigation( /*[in]*/ BSTR url );
    void NotifyEndOfNavigation  (                   );
    void NotifyStop             (                   );

    ////////////////////////////////////////

    HRESULT OnTimer( VARIANT vtimeAdvise );

public:
    // Event Handlers
    void __stdcall BeforeNavigate2  ( IDispatch*   pDisp, VARIANT* URL, VARIANT* Flags, VARIANT* TargetFrameName, VARIANT* PostData, VARIANT* Headers, VARIANT_BOOL* Cancel );
    void __stdcall NewWindow2       ( IDispatch* *ppDisp,                                                                                              VARIANT_BOOL* Cancel );
    void __stdcall NavigateComplete2( IDispatch*   pDisp, VARIANT* URL                                                                                                      );
    void __stdcall DocumentComplete ( IDispatch*   pDisp, VARIANT* URL                                                                                                      );
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHEvent : // Hungarian: hce
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<IPCHEvent, &IID_IPCHEvent, &LIBID_HelpCenterTypeLib>
{
    friend class CPCHEvents;

    DISPID                       m_idAction;
    VARIANT_BOOL                 m_fCancel;

    CComBSTR                     m_bstrURL;
    CComBSTR                     m_bstrFrame;
    CComBSTR                     m_bstrPanel;
    CComBSTR                     m_bstrPlace;
    CComBSTR                     m_bstrContextData;

    CComPtr<CPCHHelpSessionItem> m_hsiCurrentContext;
    CComPtr<CPCHHelpSessionItem> m_hsiPreviousContext;
    CComPtr<CPCHHelpSessionItem> m_hsiNextContext;

public:
BEGIN_COM_MAP(CPCHEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHEvent)
END_COM_MAP()

    CPCHEvent();
    virtual ~CPCHEvent();

    //
    // IPCHEvent
    //
public:
    STDMETHOD(get_Action         )( /*[out, retval]*/ BSTR                 *  pVal );
    STDMETHOD(put_Cancel         )( /*[in         ]*/ VARIANT_BOOL          newVal );
    STDMETHOD(get_Cancel         )( /*[out, retval]*/ VARIANT_BOOL         *  pVal );

    HRESULT   put_URL             ( /*[in]*/          BSTR                  newVal ); // Internal method.
    STDMETHOD(get_URL            )( /*[out, retval]*/ BSTR                 *  pVal );
    HRESULT   put_Frame           ( /*[in]*/          BSTR                  newVal ); // Internal method.
    STDMETHOD(get_Frame          )( /*[out, retval]*/ BSTR                 *  pVal );
    HRESULT   put_Panel           ( /*[in]*/          BSTR                  newVal ); // Internal method.
    STDMETHOD(get_Panel          )( /*[out, retval]*/ BSTR                 *  pVal );
    HRESULT   put_Place           ( /*[in]*/          BSTR                  newVal ); // Internal method.
    STDMETHOD(get_Place          )( /*[out, retval]*/ BSTR                 *  pVal );

    STDMETHOD(get_CurrentContext )( /*[out, retval]*/ IPCHHelpSessionItem* *  pVal );
    STDMETHOD(get_PreviousContext)( /*[out, retval]*/ IPCHHelpSessionItem* *  pVal );
    STDMETHOD(get_NextContext 	 )( /*[out, retval]*/ IPCHHelpSessionItem* *  pVal );
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class CPCHEvents
{
    class EventRegistration
    {
    public:
        long                                 m_lCookie;
        DISPID                               m_id;
        long                                 m_lPriority;
        MPC::CComPtrThreadNeutral<IDispatch> m_fnCallback;

        bool operator==( /*[in]*/ const long lCookie   ) const;
        bool operator< ( /*[in]*/ const long lPriority ) const;
    };

    typedef std::list<EventRegistration> List;
    typedef List::iterator               Iter;
    typedef List::const_iterator         IterConst;

    CPCHHelpCenterExternal* m_parent;
    List                    m_lstEvents;
    List                    m_lstEvents_Staging;
    long                    m_lLastCookie;

public:
    CPCHEvents();
    ~CPCHEvents();

    void Initialize( /*[in]*/ CPCHHelpCenterExternal* parent );
    void Passivate (                                         );

    HRESULT RegisterEvents  ( /*[in]*/ long id, /*[in]*/ long pri, /*[in]*/ IDispatch* function, /*[out,retval]*/ long *cookie );
    HRESULT RegisterEvents  ( /*[in]*/ BSTR id, /*[in]*/ long pri, /*[in]*/ IDispatch* function, /*[out,retval]*/ long *cookie );
    HRESULT UnregisterEvents(                                                                    /*[in]*/         long  cookie );

    HRESULT FireEvent( /*[in]*/ CPCHEvent* eventObj );

    ////////////////////////////////////////

    HRESULT FireEvent_Generic         	 ( /*[in]*/ DISPID     id       , /*[out,retval]*/ VARIANT_BOOL *Cancel = NULL );
   	 
    HRESULT FireEvent_BeforeNavigate  	 ( /*[in]*/ BSTR       bstrURL  ,
                                      	   /*[in]*/ BSTR       bstrFrame,
                                      	   /*[in]*/ HscPanel   idPanel  , /*[out,retval]*/ VARIANT_BOOL *Cancel = NULL );
    HRESULT FireEvent_NavigateComplete	 ( /*[in]*/ BSTR       bstrURL  ,
                                      	   /*[in]*/ HscPanel   idPanel  , /*[out,retval]*/ VARIANT_BOOL *Cancel = NULL );
   	 
    HRESULT FireEvent_BeforeTransition	 ( /*[in]*/ BSTR       bstrPlace, /*[out,retval]*/ VARIANT_BOOL *Cancel = NULL );
    HRESULT FireEvent_Transition      	 ( /*[in]*/ BSTR       bstrPlace                                               );

    HRESULT FireEvent_BeforeContextSwitch( /*[in]*/ HscContext iVal     ,
                                           /*[in]*/ BSTR       bstrInfo ,
                                           /*[in]*/ BSTR       bstrURL  , /*[out,retval]*/ VARIANT_BOOL *Cancel = NULL );
    HRESULT FireEvent_ContextSwitch      (                                                                             );

    HRESULT FireEvent_PersistLoad        (                            												   );
    HRESULT FireEvent_PersistSave        (                            												   );
	 
    HRESULT FireEvent_TravelDone         (                            												   );
	
	
	
    HRESULT FireEvent_Shutdown           (                            	  /*[out,retval]*/ VARIANT_BOOL *Cancel = NULL );
	
    HRESULT FireEvent_Print              (                            	  /*[out,retval]*/ VARIANT_BOOL *Cancel = NULL );

    HRESULT FireEvent_SwitchedHelpFiles  (                            												   );
    HRESULT FireEvent_FavoritesUpdate    (                            												   );
    HRESULT FireEvent_OptionsChanged     (                            												   );
    HRESULT FireEvent_CssChanged         (                            												   );

    ////////////////////////////////////////

    static DISPID  Lookup       ( LPCWSTR szName  );
    static LPCWSTR ReverseLookup( DISPID  idEvent );
};

#endif // !defined(__INCLUDED___PCH___EVENTS_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\include\helpcenterexternal.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    HelpCenterExternal.h

Abstract:
    This file contains the declaration of the class exposed as the "pchealth" object.

Revision History:
    Ghim-Sim Chua       (gschua)   07/23/99
        created
    Davide Massarenti   (dmassare) 07/25/99
        modified

******************************************************************************/

#if !defined(__INCLUDED___PCH___HELPCENTEREXTERNAL_H___)
#define __INCLUDED___PCH___HELPCENTEREXTERNAL_H___

#include <MPC_COM.h>
#include <MPC_HTML2.h>

#include <marscore.h>

#include <Debug.h>

#include <ServiceProxy.h>

#include <Events.h>
#include <HelpSession.h>
#include <Context.h>

#include <Behaviors.h>

#include <ConnectivityLib.h>
#include <HyperLinksLib.h>
#include <OfflineCache.h>

/////////////////////////////////////////////////////////////////////////////

//
// From RDSHost.idl
//
#include <RDSHost.h>

//
// From RDCHost.idl
//
#include <RDCHost.h>

//
// From RDSChan.idl
//
#include <RDSChan.h>

//
// From SAFRDM.idl
//
#include <SAFRDM.h>


/////////////////////////////////////////////////////////////////////////////

class CPCHHelpCenterExternal;

class ATL_NO_VTABLE CPCHSecurityManager : // Hungarian: hcsm
    public MPC::Thread<CPCHSecurityManager,IUnknown>,
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public IServiceProvider,
    public IInternetSecurityManager
{
    CPCHHelpCenterExternal* m_parent;
    bool                    m_fActivated;

    HRESULT ActivateService();

public:
BEGIN_COM_MAP(CPCHSecurityManager)
    COM_INTERFACE_ENTRY(IServiceProvider)
    COM_INTERFACE_ENTRY(IInternetSecurityManager)
END_COM_MAP()

    CPCHSecurityManager();

    void Initialize( /*[in]*/ CPCHHelpCenterExternal* parent );

    //////////////////////////////////////////////////////////////////////

    //
    // IServiceProvider
    //
    STDMETHOD(QueryService)( REFGUID guidService, REFIID riid, void **ppv );

    //
    // IInternetSecurityManager
    //
    // The only two methods implemented are: MapUrlToZone and ProcessUrlAction.
    //
    STDMETHOD(SetSecuritySite)( /*[unique][in]*/ IInternetSecurityMgrSite*  pSite  ) { return INET_E_DEFAULT_ACTION; }
    STDMETHOD(GetSecuritySite)( /*[out]       */ IInternetSecurityMgrSite* *ppSite ) { return INET_E_DEFAULT_ACTION; }

    STDMETHOD(MapUrlToZone )( /*[in] */ LPCWSTR  pwszUrl ,
                              /*[out]*/ DWORD   *pdwZone ,
                              /*[in] */ DWORD    dwFlags );

    STDMETHOD(GetSecurityId)( /*[in]    */ LPCWSTR    pwszUrl      ,
                              /*[out]   */ BYTE      *pbSecurityId ,
                              /*[in/out]*/ DWORD     *pcbSecurityId,
                              /*[in]    */ DWORD_PTR  dwReserved   ) { return INET_E_DEFAULT_ACTION; }

    STDMETHOD(ProcessUrlAction)( /*[in] */ LPCWSTR  pwszUrl    ,
                                 /*[in] */ DWORD    dwAction   ,
                                 /*[out]*/ BYTE    *pPolicy    ,
                                 /*[in] */ DWORD    cbPolicy   ,
                                 /*[in] */ BYTE    *pContext   ,
                                 /*[in] */ DWORD    cbContext  ,
                                 /*[in] */ DWORD    dwFlags    ,
                                 /*[in] */ DWORD    dwReserved );

    STDMETHOD(QueryCustomPolicy)( /*[in] */ LPCWSTR  pwszUrl    ,
                                  /*[in] */ REFGUID  guidKey    ,
                                  /*[out]*/ BYTE*   *ppPolicy   ,
                                  /*[out]*/ DWORD   *pcbPolicy  ,
                                  /*[in] */ BYTE*    pContext   ,
                                  /*[in] */ DWORD    cbContext  ,
                                  /*[in] */ DWORD    dwReserved ) { return INET_E_DEFAULT_ACTION; }

    STDMETHOD(SetZoneMapping )( /*[in]*/ DWORD   dwZone      ,
                                /*[in]*/ LPCWSTR lpszPattern ,
                                /*[in]*/ DWORD   dwFlags     ) { return INET_E_DEFAULT_ACTION; }

    STDMETHOD(GetZoneMappings)( /*[in] */ DWORD         dwZone      ,
                                /*[out]*/ IEnumString* *ppenumString,
                                /*[in] */ DWORD         dwFlags     ) { return INET_E_DEFAULT_ACTION; }


    bool IsUrlTrusted( /*[in]*/ LPCWSTR pwszURL, /*[in]*/ bool *pfSystem = NULL );
};

////////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHHelper_IDocHostUIHandler :
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public IServiceProvider,
    public IDocHostUIHandler
{
    CPCHHelpCenterExternal* m_parent;

public:
BEGIN_COM_MAP(CPCHHelper_IDocHostUIHandler)
    COM_INTERFACE_ENTRY(IServiceProvider)
    COM_INTERFACE_ENTRY(IDocHostUIHandler)
END_COM_MAP()

    CPCHHelper_IDocHostUIHandler();

    void Initialize( /*[in]*/ CPCHHelpCenterExternal* parent );

    //////////////////////////////////////////////////////////////////////

    //
    // IServiceProvider
    //
    STDMETHOD(QueryService)( REFGUID guidService, REFIID riid, void **ppv );

    //
    // IDocHostUIHandler
    //
    STDMETHOD(ShowContextMenu)( DWORD dwID, POINT* pptPosition, IUnknown* pCommandTarget, IDispatch* pDispatchObjectHit );
    STDMETHOD(GetHostInfo)(DOCHOSTUIINFO* pInfo);
    STDMETHOD(ShowUI)(DWORD dwID, IOleInPlaceActiveObject* pActiveObject, IOleCommandTarget* pCommandTarget, IOleInPlaceFrame* pFrame, IOleInPlaceUIWindow* pDoc);
    STDMETHOD(HideUI)();
    STDMETHOD(UpdateUI)();
    STDMETHOD(EnableModeless)(BOOL fEnable);
    STDMETHOD(OnDocWindowActivate)(BOOL fActivate);
    STDMETHOD(OnFrameWindowActivate)(BOOL fActivate);
    STDMETHOD(ResizeBorder)(LPCRECT prcBorder, IOleInPlaceUIWindow* pUIWindow, BOOL fFrameWindow);
    STDMETHOD(TranslateAccelerator)(LPMSG lpMsg, const GUID* pguidCmdGroup, DWORD nCmdID);
    STDMETHOD(GetOptionKeyPath)(BSTR* pbstrKey, DWORD dwReserved);
    STDMETHOD(GetDropTarget)(IDropTarget* pDropTarget, IDropTarget** ppDropTarget);
    STDMETHOD(GetExternal)(IDispatch** ppDispatch);
    STDMETHOD(TranslateUrl)(DWORD dwTranslate, OLECHAR* pchURLIn, OLECHAR** ppchURLOut);
    STDMETHOD(FilterDataObject)(IDataObject* pDO, IDataObject** ppDORet);
};

////////////////////////////////////////////////////////////////////////////////

MIDL_INTERFACE("FC7D9EA0-3F9E-11d3-93C0-00C04F72DAF7")
IPCHHelpCenterExternalPrivate : public IUnknown
{
public:
    STDMETHOD(RegisterForMessages)( /*[in]*/ IOleInPlaceObjectWindowless* ptr, /*[in]*/ bool fRemove );

    STDMETHOD(ProcessMessage)( /*[in]*/ MSG* msg );
};

class ATL_NO_VTABLE CPCHHelpCenterExternal :
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public MPC::IDispatchExImpl<IPCHHelpCenterExternal, &IID_IPCHHelpCenterExternal, &LIBID_HelpCenterTypeLib>,
    public IPCHHelpCenterExternalPrivate
{
public:
	typedef enum 
	{
		DELAYMODE_INVALID      ,
		DELAYMODE_NAVIGATEWEB  ,
		DELAYMODE_NAVIGATEHH   ,
		DELAYMODE_CHANGECONTEXT,
		DELAYMODE_REFRESHLAYOUT,
	} DelayedExecutionMode;

    struct DelayedExecution
    {
		DelayedExecutionMode mode;

        HscContext 			 iVal;
        CComBSTR   			 bstrInfo;
        CComBSTR   			 bstrURL;
        bool       			 fAlsoContent;

        DelayedExecution();
    };

    typedef std::list<DelayedExecution>             DelayedExecList;
    typedef DelayedExecList::iterator               DelayedExecIter;
    typedef DelayedExecList::const_iterator         DelayedExecIterConst;


    typedef std::list<IOleInPlaceObjectWindowless*> MsgProcList;
    typedef MsgProcList::iterator                   MsgProcIter;
    typedef MsgProcList::const_iterator             MsgProcIterConst;


    class TLS
    {
    public:
        bool                    m_fTrusted;
        bool                    m_fSystem;
        CComPtr<IHTMLDocument2> m_Doc;
        CComPtr<IWebBrowser2>   m_WB;

        TLS()
        {
            m_fTrusted = false;
            m_fSystem  = false;
        }
    };

private:
    bool                                    m_fFromStartHelp;
    bool                                    m_fLayout;
    bool                                    m_fWindowVisible;
    bool                                    m_fControlled;
    bool                                    m_fPersistSettings;
    bool                                    m_fHidden;

    CComBSTR                                m_bstrExtraArgument;
    HelpHost::XMLConfig*                    m_HelpHostCfg;
    CComBSTR                                m_bstrStartURL;
    CComBSTR                                m_bstrCurrentPlace;
    MARSTHREADPARAM*                        m_pMTP;

    MPC::CComConstantHolder                 m_constHELPCTR;
    MPC::CComConstantHolder                 m_constHELPSVC;

    ////////////////////////////////////////

    CPCHSecurityHandle                      m_SecurityHandle;
    DWORD                                   m_tlsID;
    bool                                    m_fShuttingDown;
    bool                                    m_fPassivated;

    CComPtr<HelpHost::Main>                 m_HelpHost;

    CComPtr<CPCHHelpSession>                m_hs;
    CComPtr<CPCHSecurityManager>            m_SECMGR;
    CComPtr<CPCHElementBehaviorFactory>     m_BEHAV;
    CComPtr<CPCHHelper_IDocHostUIHandler>   m_DOCUI;

    CPCHProxy_IPCHService*                  m_Service;
    CPCHProxy_IPCHUtility*                  m_Utility;
    CPCHProxy_IPCHUserSettings2*            m_UserSettings;

    CComPtr<CPCHTextHelpers>                m_TextHelpers;

    //
    // Unfortunately, up to now IMarsPanel is not a registered interface, so no proxy available.
    //
    DWORD                                   m_panel_ThreadID;

    CComPtr<IMarsPanel>                     m_panel_NAVBAR;
    CComPtr<IMarsPanel>                     m_panel_MININAVBAR;

    CComPtr<IMarsPanel>                     m_panel_CONTEXT;
    MPC::CComPtrThreadNeutral<IWebBrowser2> m_panel_CONTEXT_WebBrowser;
    CPCHWebBrowserEvents                    m_panel_CONTEXT_Events;

    CComPtr<IMarsPanel>                     m_panel_CONTENTS;
    MPC::CComPtrThreadNeutral<IWebBrowser2> m_panel_CONTENTS_WebBrowser;
    CPCHWebBrowserEvents                    m_panel_CONTENTS_Events;

    CComPtr<IMarsPanel>                     m_panel_HHWINDOW;
    CComPtr<IPCHHelpViewerWrapper>          m_panel_HHWINDOW_Wrapper;
    MPC::CComPtrThreadNeutral<IWebBrowser2> m_panel_HHWINDOW_WebBrowser;
    CPCHWebBrowserEvents                    m_panel_HHWINDOW_Events;

    CComPtr<IMarsWindowOM>                  m_shell;
    CComPtr<ITimer>                         m_timer;
    CPCHTimerHandle                         m_DisplayTimer;

    DWORD                                   m_dwInBeforeNavigate;
    DelayedExecList                         m_DelayedActions;
    CPCHTimerHandle                         m_ActionsTimer;

    HWND                                    m_hwnd;
    CPCHEvents                              m_Events;

    MsgProcList                             m_lstMessageCrackers;

    void Passivate();

    HRESULT TimerCallback_DisplayNormal  ( /*[in]*/ VARIANT );
    HRESULT TimerCallback_DisplayHTMLHELP( /*[in]*/ VARIANT );
    HRESULT TimerCallback_DelayedActions ( /*[in]*/ VARIANT );

	////////////////////

	DelayedExecution& DelayedExecutionAlloc();
	HRESULT           DelayedExecutionStart();

public:
BEGIN_COM_MAP(CPCHHelpCenterExternal)
    COM_INTERFACE_ENTRY2(IDispatch, IDispatchEx)
    COM_INTERFACE_ENTRY(IDispatchEx)
    COM_INTERFACE_ENTRY(IPCHHelpCenterExternal)
    COM_INTERFACE_ENTRY(IPCHHelpCenterExternalPrivate)
END_COM_MAP()

    CPCHHelpCenterExternal();
    virtual ~CPCHHelpCenterExternal();

    INTERNETSECURITY__INVOKEEX();

    ////////////////////////////////////////////////////////////////////////////////

    static CPCHHelpCenterExternal* s_GLOBAL;

    static HRESULT InitializeSystem();
    static void    FinalizeSystem  ();

    ////////////////////////////////////////////////////////////////////////////////

    bool IsServiceRunning();

    bool IsFromStartHelp    () { return m_fFromStartHelp;   }
    bool HasLayoutDefinition() { return m_fLayout;          }
    bool CanDisplayWindow   () { return m_fWindowVisible;   }
    bool IsControlled       () { return m_fControlled;      }
    bool DoesPersistSettings() { return m_fPersistSettings; }
    bool IsHidden           () { return m_fHidden;          }

    HRESULT Initialize();

    bool ProcessNavigation( /*[in]*/ HscPanel idPanel, /*[in]*/ BSTR bstrURL, /*[in]*/ BSTR bstrFrame, /*[in]*/ bool fLoading, /*[in/out]*/ VARIANT_BOOL& Cancel );

    ////////////////////////////////////////

    TLS* GetTLS(          );
    void SetTLS( TLS* tls );

    HRESULT SetTLSAndInvoke( /*[in] */ IDispatch*        obj       ,
                             /*[in] */ DISPID            id        ,
                             /*[in] */ LCID              lcid      ,
                             /*[in] */ WORD              wFlags    ,
                             /*[in] */ DISPPARAMS*       pdp       ,
                             /*[out]*/ VARIANT*          pvarRes   ,
                             /*[out]*/ EXCEPINFO*        pei       ,
                             /*[in] */ IServiceProvider* pspCaller );

    HRESULT IsTrusted();
    HRESULT IsSystem ();

    ////////////////////////////////////////

    HWND                 		  Window          (                      ) const;
    ITimer*              		  Timer           (                      ) const;
    IMarsWindowOM*       		  Shell           (                      ) const;
    IMarsPanel*          		  Panel           ( /*[in]*/ HscPanel id ) const;
    LPCWSTR              		  PanelName       ( /*[in]*/ HscPanel id ) const;
    IWebBrowser2*        		  Context         (                      );
    IWebBrowser2*        		  Contents        (                      );
    IWebBrowser2*        		  HHWindow        (                      );
    HelpHost::Main*      		  HelpHost        (                      ) { return m_HelpHost; }
    CPCHHelpSession*     		  HelpSession     (                      ) { return m_hs      ; }
    CPCHSecurityManager* 		  SecurityManager (                      ) { return m_SECMGR  ; }
    CPCHElementBehaviorFactory*   BehaviorFactory (                      ) { return m_BEHAV   ; }
    CPCHHelper_IDocHostUIHandler* DocHostUIHandler(                      ) { return m_DOCUI   ; }
    CPCHEvents&                   Events          (                      ) { return m_Events  ; }

	bool IsHHWindowVisible();

    ////////////////////////////////////////

    CPCHProxy_IPCHService*       Service     () { return m_Service;      }
    CPCHProxy_IPCHUtility*       Utility     () { return m_Utility;      }
    CPCHProxy_IPCHUserSettings2* UserSettings() { return m_UserSettings; }

    ////////////////////////////////////////

    HRESULT NavigateHH          (                       /*[in ]*/ LPCWSTR        szURL                                          );
    HRESULT SetPanelUrl         ( /*[in]*/ HscPanel id, /*[in ]*/ LPCWSTR        szURL                                          );
    HRESULT GetPanel            ( /*[in]*/ HscPanel id, /*[out]*/ IMarsPanel*   *pVal, /*[in]*/ bool    fEnsurePresence = false );
    HRESULT GetPanelWindowObject( /*[in]*/ HscPanel id, /*[out]*/ IHTMLWindow2* *pVal, /*[in]*/ LPCWSTR szFrame         = NULL  );


    void GetPanelDirect( /*[in]*/ HscPanel id, /*[out]*/ CComPtr<IMarsPanel>& pVal );

    ////////////////////////////////////////

    HRESULT ProcessLayoutXML( /*[in]*/ LPCWSTR szURL );

    HRESULT ProcessArgument( /*[in]*/ int& pos, /*[in]*/ LPCWSTR szArg, /*[in]*/ const int argc, /*[in]*/ LPCWSTR* const argv );

    bool    DoWeNeedUI(                                                                                  );
    HRESULT RunUI     ( /*[in]*/ const MPC::wstring& szTitle, /*[in]*/ PFNMARSTHREADPROC pMarsThreadProc );

    ////////////////////////////////////////

    HRESULT OnHostNotify       ( /*[in]*/ MARSHOSTEVENT event, /*[in]*/ IUnknown *punk, /*[in]*/ LPARAM lParam );
    HRESULT PreTranslateMessage( /*[in]*/ MSG* msg                                                             );


    HRESULT SetHelpViewer( /*[in]*/ IPCHHelpViewerWrapper* pWrapper );

    HRESULT CreateScriptWrapper( /*[in]*/ REFCLSID rclsid, /*[in]*/ BSTR bstrCode, /*[in]*/ BSTR bstrURL, /*[out]*/ IUnknown* *ppObj );

    HRESULT RequestShutdown();

    //////////////////////////////////////////////////////////////////////

    HRESULT CallFunctionOnPanel( /*[in] */ HscPanel id             ,
                                 /*[in] */ LPCWSTR  szFrame        ,
                                 /*[in] */ BSTR     bstrName       ,
                                 /*[in] */ VARIANT* pvarParams     ,
                                 /*[in] */ int      nParams        ,
                                 /*[out]*/ VARIANT* pvarRet = NULL );

    HRESULT ReadVariableFromPanel( /*[in] */ HscPanel     id           ,
                                   /*[in] */ LPCWSTR      szFrame      ,
                                   /*[in] */ BSTR         bstrVariable ,
                                   /*[out]*/ CComVariant& varRet       );

    HRESULT ChangeContext( /*[in]*/ HscContext iVal, /*[in]*/ BSTR bstrInfo = NULL, /*[in]*/ BSTR bstrURL = NULL, /*[in]*/ bool fAlsoContent = true );

    HRESULT SetCorrectContentView ( /*[in]*/ bool fShrinked                                                    );
    HRESULT SetCorrectContentPanel( /*[in]*/ bool fShowNormal, /*[in]*/ bool fShowHTMLHELP, /*[in]*/ bool fNow );

	HRESULT RefreshLayout    (                         );
    HRESULT EnsurePlace      (                         );
    HRESULT TransitionToPlace( /*[in]*/ LPCWSTR szMode );

	HRESULT ExtendNavigation();

    //////////////////////////////////////////////////////////////////////

    //
    // IDispatch
    //
    STDMETHOD(GetIDsOfNames)( REFIID    riid      ,
                              LPOLESTR* rgszNames ,
                              UINT      cNames    ,
                              LCID      lcid      ,
                              DISPID*   rgdispid  );

    STDMETHOD(Invoke)( DISPID      dispidMember ,
                       REFIID      riid         ,
                       LCID        lcid         ,
                       WORD        wFlags       ,
                       DISPPARAMS* pdispparams  ,
                       VARIANT*    pvarResult   ,
                       EXCEPINFO*  pexcepinfo   ,
                       UINT*       puArgErr     );

    //
    // IPCHHelpCenterExternal
    //
    STDMETHOD(get_HelpSession   )( /*[out, retval]*/ IPCHHelpSession*      *pVal );
    STDMETHOD(get_Channels      )( /*[out, retval]*/ ISAFReg*              *pVal );
    STDMETHOD(get_UserSettings  )( /*[out, retval]*/ IPCHUserSettings2*    *pVal );
    STDMETHOD(get_Security      )( /*[out, retval]*/ IPCHSecurity*         *pVal );
    STDMETHOD(get_Connectivity  )( /*[out, retval]*/ IPCHConnectivity*     *pVal );
    STDMETHOD(get_Database      )( /*[out, retval]*/ IPCHTaxonomyDatabase* *pVal );
    STDMETHOD(get_TextHelpers   )( /*[out, retval]*/ IPCHTextHelpers*      *pVal );

    STDMETHOD(get_ExtraArgument )( /*[out, retval]*/ BSTR                  *pVal );

    STDMETHOD(get_HelpViewer    )( /*[out, retval]*/ IUnknown*             *pVal );

    HRESULT   get_UI_Panel       ( /*[out, retval]*/ IUnknown*             *pVal, /*[in]*/ HscPanel id ); // Internal method.
    STDMETHOD(get_UI_NavBar     )( /*[out, retval]*/ IUnknown*             *pVal );
    STDMETHOD(get_UI_MiniNavBar )( /*[out, retval]*/ IUnknown*             *pVal );
    STDMETHOD(get_UI_Context    )( /*[out, retval]*/ IUnknown*             *pVal );
    STDMETHOD(get_UI_Contents   )( /*[out, retval]*/ IUnknown*             *pVal );
    STDMETHOD(get_UI_HHWindow   )( /*[out, retval]*/ IUnknown*             *pVal );

    HRESULT   get_WEB_Panel      ( /*[out, retval]*/ IUnknown*             *pVal, /*[in]*/ HscPanel id ); // Internal method.
    STDMETHOD(get_WEB_Context   )( /*[out, retval]*/ IUnknown*             *pVal );
    STDMETHOD(get_WEB_Contents  )( /*[out, retval]*/ IUnknown*             *pVal );
    STDMETHOD(get_WEB_HHWindow  )( /*[out, retval]*/ IUnknown*             *pVal );


    STDMETHOD(RegisterEvents  )( /*[in]*/ BSTR id, /*[in]*/ long pri, /*[in]*/ IDispatch* function, /*[out,retval]*/ long *cookie );
    STDMETHOD(UnregisterEvents)(                                                                    /*[in]*/         long  cookie );

    ////////////////////////////////////////

    STDMETHOD(CreateObject_SearchEngineMgr        )( /*[out, retval]*/ IPCHSEManager*               *ppSE                );

    STDMETHOD(CreateObject_DataCollection         )( /*[out, retval]*/ ISAFDataCollection*          *ppDC                );

    STDMETHOD(CreateObject_Cabinet                )( /*[out, retval]*/ ISAFCabinet*                 *ppCB                );

    STDMETHOD(CreateObject_Channel                )( /*[in         ]*/ BSTR                          bstrVendorID        ,
                                                     /*[in         ]*/ BSTR                          bstrProductID       ,
                                                     /*[out, retval]*/ ISAFChannel*                 *ppCh                );

    STDMETHOD(CreateObject_Incident               )( /*[out, retval]*/ ISAFIncident*                *ppIn                );

    STDMETHOD(CreateObject_Encryption             )( /*[out, retval]*/ ISAFEncrypt*                 *ppEn                );

    STDMETHOD(CreateObject_RemoteDesktopSession   )( 
                                                     /*[in         ]*/ long                          lTimeout            ,
                                                     /*[in         ]*/ BSTR                          bstrConnectionParms ,
                                                     /*[in         ]*/ BSTR                          bstrUserHelpBlob    ,
                                                     /*[out, retval]*/ ISAFRemoteDesktopSession*    *ppRCS               );

    STDMETHOD(ConnectToExpert                     )( /* [in]          */ BSTR bstrExpertConnectParm,
                                                     /* [in]          */ LONG lTimeout,
                                                     /* [retval][out] */ LONG *lSafErrorCode);

    STDMETHOD(CreateObject_RemoteAssistanceIncident)( /* [in] */         BSTR bstrRCTicket, 
                                                      /* [in] */         long lTimeout, 
                                                      /* [in] */         BSTR bstrUserName, 
                                                      /* [in] */         BSTR bstrMessage, 
                                                      /* [in] */         BSTR bstrPassword, 
                                                      /* [out,retval] */ ISAFIncident* *ppIn);

    STDMETHOD(CreateObject_RemoteDesktopManager   )( /*[out, retval]*/ ISAFRemoteDesktopManager*    *ppRDM               );

    STDMETHOD(CreateObject_RemoteDesktopConnection)( /*[out, retval]*/ ISAFRemoteDesktopConnection* *ppRDC               );

    STDMETHOD(CreateObject_IntercomClient     )( /*[out, retval]*/ ISAFIntercomClient*      *ppI         );
    STDMETHOD(CreateObject_IntercomServer     )( /*[out, retval]*/ ISAFIntercomServer*      *ppI         );


    STDMETHOD(CreateObject_ContextMenu            )( /*[out, retval]*/ IPCHContextMenu*             *ppCM                );
    STDMETHOD(CreateObject_PrintEngine            )( /*[out, retval]*/ IPCHPrintEngine*             *ppPE                );

    ////////////////////////////////////////

    STDMETHOD(OpenFileAsStream  )( /*[in]*/ BSTR bstrFilename, /*[out, retval]*/ IUnknown* *stream );
    STDMETHOD(CreateFileAsStream)( /*[in]*/ BSTR bstrFilename, /*[out, retval]*/ IUnknown* *stream );
    STDMETHOD(CopyStreamToFile  )( /*[in]*/ BSTR bstrFilename, /*[in]         */ IUnknown*  stream );

    STDMETHOD(NetworkAlive        )(                        /*[out, retval]*/ VARIANT_BOOL *pVal );
    STDMETHOD(DestinationReachable)( /*[in]*/ BSTR bstrURL, /*[out, retval]*/ VARIANT_BOOL *pVal );

    STDMETHOD(FormatError)( /*[in]*/ VARIANT vError, /*[out, retval]*/ BSTR *pVal );

    HRESULT   RegInit   ( /*[in]*/ BSTR bstrKey, /*[in]*/ bool fRead, /*[out]*/ MPC::RegKey& rk, /*[out]*/ MPC::wstring& strValue ); // Internal method.
    STDMETHOD(RegRead  )( /*[in]*/ BSTR bstrKey, /*[out, retval]*/ VARIANT *pVal                                    );
    STDMETHOD(RegWrite )( /*[in]*/ BSTR bstrKey, /*[in         ]*/ VARIANT  newVal, /*[in,optional]*/ VARIANT vKind );
    STDMETHOD(RegDelete)( /*[in]*/ BSTR bstrKey                                                                     );

    ////////////////////////////////////////////////////////////////////////////////

    STDMETHOD(Close)();

    STDMETHOD(RefreshUI)();

    STDMETHOD(Print)( /*[in]*/ VARIANT window, /*[in]*/ VARIANT_BOOL fEvent, /*[out, retval]*/ VARIANT_BOOL *pVal );

    STDMETHOD(HighlightWords)( /*[in]*/ VARIANT window, /*[in]*/ VARIANT words );

    STDMETHOD(MessageBox  )( /*[in]*/ BSTR bstrText , /*[in]*/ BSTR bstrKind   , /*[out, retval]*/ BSTR *pVal );
    STDMETHOD(SelectFolder)( /*[in]*/ BSTR bstrTitle, /*[in]*/ BSTR bstrDefault, /*[out, retval]*/ BSTR *pVal );


    //
    // IPCHHelpCenterExternalPrivate
    //
    STDMETHOD(RegisterForMessages)( /*[in]*/ IOleInPlaceObjectWindowless* ptr, /*[in]*/ bool fRemove );

    STDMETHOD(ProcessMessage)( /*[in]*/ MSG* msg );
};

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHContextMenu :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<IPCHContextMenu, &IID_IPCHContextMenu, &LIBID_HelpCenterTypeLib>
{
    struct Entry
    {
        CComBSTR bstrText;
        CComBSTR bstrID;
        int      iID;
        UINT     uFlags;
    };

    typedef std::list<Entry>     List;
    typedef List::iterator       Iter;
    typedef List::const_iterator IterConst;

    CPCHHelpCenterExternal* m_parent;
    List                    m_lstItems;
    int                     m_iLastItem;

public:
BEGIN_COM_MAP(CPCHContextMenu)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHContextMenu)
END_COM_MAP()

    CPCHContextMenu();
    virtual ~CPCHContextMenu();

    void Initialize( /*[in]*/ CPCHHelpCenterExternal* parent );


    // IPCHContextMenu
    STDMETHOD(AddItem     )( /*[in]*/         BSTR bstrText, /*[in]*/ BSTR bstrID, /*[in, optional]*/ VARIANT vFlags );
    STDMETHOD(AddSeparator)(                                                                                         );
    STDMETHOD(Display     )( /*[out,retval]*/ BSTR *pVal                                                             );
};

#endif // !defined(__INCLUDED___PCH___HELPCENTEREXTERNAL_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\include\helpctruidid.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    HelpCtrUIDID.h

Abstract:
    This file contains the definition of some constants used by
    the Help Center Application.

Revision History:
    Davide Massarenti   (Dmassare)  07/21/99
        created

******************************************************************************/

#if !defined(__INCLUDED___PCH___HELPCTRUIDID_H___)
#define __INCLUDED___PCH___HELPCTRUIDID_H___

/////////////////////////////////////////////////////////////////////////

#define DISPID_PCH_HELPCTR_BASE                                  0x08100000

#define DISPID_PCH_HELPCTR_BASE_HCE                              (DISPID_PCH_HELPCTR_BASE + 0x0100) // IPCHHelpCenterExternal
#define DISPID_PCH_HELPCTR_BASE_E                                (DISPID_PCH_HELPCTR_BASE + 0x0200) // IPCHEvent
#define DISPID_PCH_HELPCTR_BASE_SS                               (DISPID_PCH_HELPCTR_BASE + 0x0300) // IPCHScriptableStream
#define DISPID_PCH_HELPCTR_BASE_HVW                              (DISPID_PCH_HELPCTR_BASE + 0x0400) // IPCHHelpViewerWrapper

#define DISPID_PCH_HELPCTR_BASE_HS                               (DISPID_PCH_HELPCTR_BASE + 0x0500) // IPCHHelpSession
#define DISPID_PCH_HELPCTR_BASE_HSI                              (DISPID_PCH_HELPCTR_BASE + 0x0600) // IPCHHelpSessionItem

#define DISPID_PCH_HELPCTR_BASE_US2                              (DISPID_PCH_HELPCTR_BASE + 0x0700) // IPCHUserSettings2
#define DISPID_PCH_HELPCTR_BASE_FAV                              (DISPID_PCH_HELPCTR_BASE + 0x0800) // IPCHFavorites
#define DISPID_PCH_HELPCTR_BASE_O                                (DISPID_PCH_HELPCTR_BASE + 0x0900) // IPCHOptions

#define DISPID_PCH_HELPCTR_BASE_CM                               (DISPID_PCH_HELPCTR_BASE + 0x0980) // IPCHContextMenu

#define DISPID_PCH_HELPCTR_BASE_PE                               (DISPID_PCH_HELPCTR_BASE + 0x0A00) // IPCHPrintEngine
#define DISPID_PCH_HELPCTR_BASE_PEE                              (DISPID_PCH_HELPCTR_BASE + 0x0A50) // DPCHPrintEngineEvents

#define DISPID_PCH_HELPCTR_BASE_TB                               (DISPID_PCH_HELPCTR_BASE + 0x0B00) // IPCHToolBar
#define DISPID_PCH_HELPCTR_BASE_TBE                              (DISPID_PCH_HELPCTR_BASE + 0x0B20) // DPCHToolBarEvents

#define DISPID_PCH_HELPCTR_BASE_PB                               (DISPID_PCH_HELPCTR_BASE + 0x0B40) // IPCHProgressBar

#define DISPID_PCH_HELPCTR_BASE_C                                (DISPID_PCH_HELPCTR_BASE + 0x0C00) // IPCHConnectivity
#define DISPID_PCH_HELPCTR_BASE_CN                               (DISPID_PCH_HELPCTR_BASE + 0x0C40) // IPCHConnectionCheck
#define DISPID_PCH_HELPCTR_BASE_CNE                              (DISPID_PCH_HELPCTR_BASE + 0x0C80) // DPCHConnectionCheckEvents

#define DISPID_PCH_HELPCTR_BASE_INC                              (DISPID_PCH_HELPCTR_BASE + 0x0D00) // ISAFIntercomClient
#define DISPID_PCH_HELPCTR_BASE_INCE                             (DISPID_PCH_HELPCTR_BASE + 0x0D40) // DSAFIntercomClientEvents

#define DISPID_PCH_HELPCTR_BASE_INS                              (DISPID_PCH_HELPCTR_BASE + 0x0E00) // ISAFIntercomServer
#define DISPID_PCH_HELPCTR_BASE_INSE                             (DISPID_PCH_HELPCTR_BASE + 0x0E40) // DSAFIntercomServerEvents

#define DISPID_PCH_HELPCTR_BASE_TH                               (DISPID_PCH_HELPCTR_BASE + 0x0F00) // IPCHTextHelpers
#define DISPID_PCH_HELPCTR_BASE_PU                               (DISPID_PCH_HELPCTR_BASE + 0x0F40) // IPCHParsedURL

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

#define DISPID_PCH_HCE__HELPSESSION                              (DISPID_PCH_HELPCTR_BASE_HCE   + 0x00)
#define DISPID_PCH_HCE__CHANNELS                                 (DISPID_PCH_HELPCTR_BASE_HCE   + 0x01)
#define DISPID_PCH_HCE__USERSETTINGS                             (DISPID_PCH_HELPCTR_BASE_HCE   + 0x02)
#define DISPID_PCH_HCE__SECURITY                                 (DISPID_PCH_HELPCTR_BASE_HCE   + 0x03)
#define DISPID_PCH_HCE__CONNECTIVITY                             (DISPID_PCH_HELPCTR_BASE_HCE   + 0x04)
#define DISPID_PCH_HCE__DATABASE                                 (DISPID_PCH_HELPCTR_BASE_HCE   + 0x05)
#define DISPID_PCH_HCE__TEXTHELPERS                              (DISPID_PCH_HELPCTR_BASE_HCE   + 0x06)
#define DISPID_PCH_HCE__EXTRAARGUMENT                            (DISPID_PCH_HELPCTR_BASE_HCE   + 0x07)
																									
#define DISPID_PCH_HCE__HELPVIEWER                               (DISPID_PCH_HELPCTR_BASE_HCE   + 0x10)
#define DISPID_PCH_HCE__UI_NAVBAR                                (DISPID_PCH_HELPCTR_BASE_HCE   + 0x11)
#define DISPID_PCH_HCE__UI_MININAVBAR                            (DISPID_PCH_HELPCTR_BASE_HCE   + 0x12)
#define DISPID_PCH_HCE__UI_CONTEXT                               (DISPID_PCH_HELPCTR_BASE_HCE   + 0x13)
#define DISPID_PCH_HCE__UI_CONTENTS                              (DISPID_PCH_HELPCTR_BASE_HCE   + 0x14)
#define DISPID_PCH_HCE__UI_HHWINDOW                              (DISPID_PCH_HELPCTR_BASE_HCE   + 0x15)
																									
#define DISPID_PCH_HCE__WEB_CONTEXT                              (DISPID_PCH_HELPCTR_BASE_HCE   + 0x18)
#define DISPID_PCH_HCE__WEB_CONTENTS                             (DISPID_PCH_HELPCTR_BASE_HCE   + 0x19)
#define DISPID_PCH_HCE__WEB_HHWINDOW                             (DISPID_PCH_HELPCTR_BASE_HCE   + 0x1A)
																									
#define DISPID_PCH_HCE__REGISTEREVENTS                           (DISPID_PCH_HELPCTR_BASE_HCE   + 0x20)
#define DISPID_PCH_HCE__UNREGISTEREVENTS                         (DISPID_PCH_HELPCTR_BASE_HCE   + 0x21)
																									
																									
#define DISPID_PCH_HCE__CREATEOBJECT_SEARCHENGINEMGR             (DISPID_PCH_HELPCTR_BASE_HCE   + 0x30)
#define DISPID_PCH_HCE__CREATEOBJECT_DATACOLLECTION              (DISPID_PCH_HELPCTR_BASE_HCE   + 0x31)
#define DISPID_PCH_HCE__CREATEOBJECT_CABINET                     (DISPID_PCH_HELPCTR_BASE_HCE   + 0x32)
#define DISPID_PCH_HCE__CREATEOBJECT_ENCRYPTION                  (DISPID_PCH_HELPCTR_BASE_HCE   + 0x33)
#define DISPID_PCH_HCE__CREATEOBJECT_INCIDENT                    (DISPID_PCH_HELPCTR_BASE_HCE   + 0x34)
#define DISPID_PCH_HCE__CREATEOBJECT_CHANNEL                     (DISPID_PCH_HELPCTR_BASE_HCE   + 0x35)
																									
#define DISPID_PCH_HCE__CREATEOBJECT_REMOTEDESKTOPSESSION        (DISPID_PCH_HELPCTR_BASE_HCE   + 0x36)
#define DISPID_PCH_HCE__CREATEOBJECT_REMOTEDESKTOPMANAGER        (DISPID_PCH_HELPCTR_BASE_HCE   + 0x37)
#define DISPID_PCH_HCE__CREATEOBJECT_REMOTEDESKTOPCONNECTION     (DISPID_PCH_HELPCTR_BASE_HCE   + 0x38)
#define DISPID_PCH_HCE__CONNECTTOEXPERT                          (DISPID_PCH_HELPCTR_BASE_HCE   + 0x39)
																									
#define DISPID_PCH_HCE__CREATEOBJECT_REMOTEASSISTANCEINCIDENT    (DISPID_PCH_HELPCTR_BASE_HCE   + 0x3A)																									

#define DISPID_PCH_HCE__CREATEOBJECT_INTERCOMCLIENT              (DISPID_PCH_HELPCTR_BASE_HCE   + 0x3B)
#define DISPID_PCH_HCE__CREATEOBJECT_INTERCOMSERVER              (DISPID_PCH_HELPCTR_BASE_HCE   + 0x3C)
																									
#define DISPID_PCH_HCE__CREATEOBJECT_CONTEXTMENU                 (DISPID_PCH_HELPCTR_BASE_HCE   + 0x3D)
#define DISPID_PCH_HCE__CREATEOBJECT_PRINTENGINE                 (DISPID_PCH_HELPCTR_BASE_HCE   + 0x3E)
																									
																									
#define DISPID_PCH_HCE__OPENFILEASSTREAM                         (DISPID_PCH_HELPCTR_BASE_HCE   + 0x50)
#define DISPID_PCH_HCE__CREATEFILEASSTREAM                       (DISPID_PCH_HELPCTR_BASE_HCE   + 0x51)
#define DISPID_PCH_HCE__COPYSTREAMTOFILE                         (DISPID_PCH_HELPCTR_BASE_HCE   + 0x52)
																									
#define DISPID_PCH_HCE__NETWORKALIVE                             (DISPID_PCH_HELPCTR_BASE_HCE   + 0x60)
#define DISPID_PCH_HCE__DESTINATIONREACHABLE                     (DISPID_PCH_HELPCTR_BASE_HCE   + 0x61)
#define DISPID_PCH_HCE__FORMATERROR                              (DISPID_PCH_HELPCTR_BASE_HCE   + 0x62)
#define DISPID_PCH_HCE__REGREAD                               	 (DISPID_PCH_HELPCTR_BASE_HCE   + 0x63)
#define DISPID_PCH_HCE__REGWRITE                              	 (DISPID_PCH_HELPCTR_BASE_HCE   + 0x64)
#define DISPID_PCH_HCE__REGDELETE                              	 (DISPID_PCH_HELPCTR_BASE_HCE   + 0x65)
																									
#define DISPID_PCH_HCE__CLOSE                                    (DISPID_PCH_HELPCTR_BASE_HCE   + 0x70)
#define DISPID_PCH_HCE__REFRESHUI                                (DISPID_PCH_HELPCTR_BASE_HCE   + 0x71)
#define DISPID_PCH_HCE__PRINT                                    (DISPID_PCH_HELPCTR_BASE_HCE   + 0x72)
#define DISPID_PCH_HCE__HIGHLIGHTWORDS                           (DISPID_PCH_HELPCTR_BASE_HCE   + 0x73)
#define DISPID_PCH_HCE__MESSAGEBOX                               (DISPID_PCH_HELPCTR_BASE_HCE   + 0x74)
#define DISPID_PCH_HCE__SELECTFOLDER                             (DISPID_PCH_HELPCTR_BASE_HCE   + 0x75)
																									
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_E__ACTION                                     (DISPID_PCH_HELPCTR_BASE_E     + 0x00)
#define DISPID_PCH_E__CANCEL                                     (DISPID_PCH_HELPCTR_BASE_E     + 0x01)
																									
#define DISPID_PCH_E__URL                                        (DISPID_PCH_HELPCTR_BASE_E     + 0x02)
#define DISPID_PCH_E__FRAME                                      (DISPID_PCH_HELPCTR_BASE_E     + 0x03)
#define DISPID_PCH_E__PANEL                                      (DISPID_PCH_HELPCTR_BASE_E     + 0x04)
#define DISPID_PCH_E__PLACE                                      (DISPID_PCH_HELPCTR_BASE_E     + 0x05)
																									
#define DISPID_PCH_E__CURRENTCONTEXT                             (DISPID_PCH_HELPCTR_BASE_E     + 0x10)
#define DISPID_PCH_E__PREVIOUSCONTEXT                            (DISPID_PCH_HELPCTR_BASE_E     + 0x11)
#define DISPID_PCH_E__NEXTCONTEXT                                (DISPID_PCH_HELPCTR_BASE_E     + 0x12)
																									
																									
#define DISPID_PCH_E_FIRSTEVENT                                  (DISPID_PCH_HELPCTR_BASE_E     + 0x80) //#### MARKER
#define DISPID_PCH_E_BEFORENAVIGATE                              (DISPID_PCH_E_FIRSTEVENT       + 0x00)
#define DISPID_PCH_E_NAVIGATECOMPLETE                            (DISPID_PCH_E_FIRSTEVENT       + 0x01)
#define DISPID_PCH_E_BEFORETRANSITION                            (DISPID_PCH_E_FIRSTEVENT       + 0x02)
#define DISPID_PCH_E_TRANSITION                                  (DISPID_PCH_E_FIRSTEVENT       + 0x03)
#define DISPID_PCH_E_BEFORECONTEXTSWITCH                         (DISPID_PCH_E_FIRSTEVENT       + 0x04)
#define DISPID_PCH_E_CONTEXTSWITCH                               (DISPID_PCH_E_FIRSTEVENT       + 0x05)
#define DISPID_PCH_E_PERSISTLOAD                                 (DISPID_PCH_E_FIRSTEVENT       + 0x06)
#define DISPID_PCH_E_PERSISTSAVE                                 (DISPID_PCH_E_FIRSTEVENT       + 0x07)
#define DISPID_PCH_E_TRAVELDONE                                  (DISPID_PCH_E_FIRSTEVENT       + 0x08)
#define DISPID_PCH_E_SHUTDOWN                                    (DISPID_PCH_E_FIRSTEVENT       + 0x09)
#define DISPID_PCH_E_PRINT                                       (DISPID_PCH_E_FIRSTEVENT       + 0x0A)
#define DISPID_PCH_E_SWITCHEDHELPFILES                           (DISPID_PCH_E_FIRSTEVENT       + 0x0B)
#define DISPID_PCH_E_FAVORITESUPDATE                             (DISPID_PCH_E_FIRSTEVENT       + 0x0C)
#define DISPID_PCH_E_OPTIONSCHANGED                              (DISPID_PCH_E_FIRSTEVENT       + 0x0D)
#define DISPID_PCH_E_CSSCHANGED                                  (DISPID_PCH_E_FIRSTEVENT       + 0x0E)
#define DISPID_PCH_E_LASTEVENT                                   (DISPID_PCH_E_FIRSTEVENT       + 0x0F) //##### MARKER
																									
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_SS__SIZE                                      (DISPID_PCH_HELPCTR_BASE_SS    + 0x00)
																									
#define DISPID_PCH_SS__READ                                      (DISPID_PCH_HELPCTR_BASE_SS    + 0x01)
#define DISPID_PCH_SS__READHEX                                   (DISPID_PCH_HELPCTR_BASE_SS    + 0x02)
																									
#define DISPID_PCH_SS__WRITE                                     (DISPID_PCH_HELPCTR_BASE_SS    + 0x03)
#define DISPID_PCH_SS__WRITEHEX                                  (DISPID_PCH_HELPCTR_BASE_SS    + 0x04)
																									
#define DISPID_PCH_SS__SEEK                                      (DISPID_PCH_HELPCTR_BASE_SS    + 0x05)
#define DISPID_PCH_SS__CLOSE                                     (DISPID_PCH_HELPCTR_BASE_SS    + 0x06)
																									
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_HCIPC__NAVIGATE                               (DISPID_PCH_HELPCTR_BASE_HCIPC + 0x00)
#define DISPID_PCH_HCIPC__CLOSE                                  (DISPID_PCH_HELPCTR_BASE_HCIPC + 0x01)
#define DISPID_PCH_HCIPC__POPUP                                  (DISPID_PCH_HELPCTR_BASE_HCIPC + 0x02)
#define DISPID_PCH_HCIPC__PING                                   (DISPID_PCH_HELPCTR_BASE_HCIPC + 0x03)
																									
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_HVW__WEBBROWSER                               (DISPID_PCH_HELPCTR_BASE_HVW   + 0x00)
																									
#define DISPID_PCH_HVW__NAVIGATE                                 (DISPID_PCH_HELPCTR_BASE_HVW   + 0x10)
#define DISPID_PCH_HVW__PRINT                                    (DISPID_PCH_HELPCTR_BASE_HVW   + 0x11)
																									
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_HS__CURRENTCONTEXT                            (DISPID_PCH_HELPCTR_BASE_HS    + 0x00)
																									
#define DISPID_PCH_HS__VISITEDHELPPAGES                          (DISPID_PCH_HELPCTR_BASE_HS    + 0x10)
																									
#define DISPID_PCH_HS__SETTITLE                                  (DISPID_PCH_HELPCTR_BASE_HS    + 0x20)
#define DISPID_PCH_HS__FORCENAVIGATION                           (DISPID_PCH_HELPCTR_BASE_HS    + 0x21)
#define DISPID_PCH_HS__IGNORENAVIGATION                          (DISPID_PCH_HELPCTR_BASE_HS    + 0x22)
#define DISPID_PCH_HS__ERASENAVIGATION                           (DISPID_PCH_HELPCTR_BASE_HS    + 0x23)
#define DISPID_PCH_HS__ISNAVIGATING                              (DISPID_PCH_HELPCTR_BASE_HS    + 0x24)
																									
#define DISPID_PCH_HS__BACK                                      (DISPID_PCH_HELPCTR_BASE_HS    + 0x30)
#define DISPID_PCH_HS__FORWARD                                   (DISPID_PCH_HELPCTR_BASE_HS    + 0x31)
#define DISPID_PCH_HS__ISVALID                                   (DISPID_PCH_HELPCTR_BASE_HS    + 0x32)
#define DISPID_PCH_HS__NAVIGATE                                  (DISPID_PCH_HELPCTR_BASE_HS    + 0x33)
																									
#define DISPID_PCH_HS__CHANGECONTEXT                             (DISPID_PCH_HELPCTR_BASE_HS    + 0x40)
																									
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_HSI__SKU                                      (DISPID_PCH_HELPCTR_BASE_HSI   + 0x00)
#define DISPID_PCH_HSI__LANGUAGE                                 (DISPID_PCH_HELPCTR_BASE_HSI   + 0x01)
																									
#define DISPID_PCH_HSI__URL                                      (DISPID_PCH_HELPCTR_BASE_HSI   + 0x02)
#define DISPID_PCH_HSI__TITLE                                    (DISPID_PCH_HELPCTR_BASE_HSI   + 0x03)
#define DISPID_PCH_HSI__LASTVISITED                              (DISPID_PCH_HELPCTR_BASE_HSI   + 0x04)
#define DISPID_PCH_HSI__DURATION                                 (DISPID_PCH_HELPCTR_BASE_HSI   + 0x05)
#define DISPID_PCH_HSI__NUMOFHITS                                (DISPID_PCH_HELPCTR_BASE_HSI   + 0x06)
																									
#define DISPID_PCH_HSI__CONTEXTNAME                              (DISPID_PCH_HELPCTR_BASE_HSI   + 0x07)
#define DISPID_PCH_HSI__CONTEXTINFO                              (DISPID_PCH_HELPCTR_BASE_HSI   + 0x08)
#define DISPID_PCH_HSI__CONTEXTURL                               (DISPID_PCH_HELPCTR_BASE_HSI   + 0x09)
																									
#define DISPID_PCH_HSI__PROPERTY                                 (DISPID_PCH_HELPCTR_BASE_HSI   + 0x0A)
																									
#define DISPID_PCH_HSI__CHECKPROPERTY                            (DISPID_PCH_HELPCTR_BASE_HSI   + 0x10)
																									
/////////////////////////////////////////////////////////////////////////							
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_US2__FAVORITES                                (DISPID_PCH_HELPCTR_BASE_US2   + 0x00)
#define DISPID_PCH_US2__OPTIONS                                  (DISPID_PCH_HELPCTR_BASE_US2   + 0x01)
#define DISPID_PCH_US2__SCOPE                                    (DISPID_PCH_HELPCTR_BASE_US2   + 0x02)
																									
#define DISPID_PCH_US2__ISREMOTESESSION                          (DISPID_PCH_HELPCTR_BASE_US2   + 0x10)
#define DISPID_PCH_US2__ISTERMINALSERVER                         (DISPID_PCH_HELPCTR_BASE_US2   + 0x11)
#define DISPID_PCH_US2__ISDESKTOPVERSION                         (DISPID_PCH_HELPCTR_BASE_US2   + 0x12)
																									
#define DISPID_PCH_US2__ISADMIN                                  (DISPID_PCH_HELPCTR_BASE_US2   + 0x20)
#define DISPID_PCH_US2__ISPOWERUSER                              (DISPID_PCH_HELPCTR_BASE_US2   + 0x21)
																									
#define DISPID_PCH_US2__ISSTARTPANELON                           (DISPID_PCH_HELPCTR_BASE_US2   + 0x30)
#define DISPID_PCH_US2__ISWEBVIEWBARRICADEON                     (DISPID_PCH_HELPCTR_BASE_US2   + 0x31)
																									
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_FAV__ISDUPLICATE                              (DISPID_PCH_HELPCTR_BASE_FAV   + 0x00)
#define DISPID_PCH_FAV__ADD                                      (DISPID_PCH_HELPCTR_BASE_FAV   + 0x01)
#define DISPID_PCH_FAV__RENAME                                   (DISPID_PCH_HELPCTR_BASE_FAV   + 0x02)
#define DISPID_PCH_FAV__MOVE                                     (DISPID_PCH_HELPCTR_BASE_FAV   + 0x03)
#define DISPID_PCH_FAV__DELETE                                   (DISPID_PCH_HELPCTR_BASE_FAV   + 0x04)

/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_O__SHOWFAVORITES                              (DISPID_PCH_HELPCTR_BASE_O 	+ 0x00)
#define DISPID_PCH_O__SHOWHISTORY                                (DISPID_PCH_HELPCTR_BASE_O 	+ 0x01)
#define DISPID_PCH_O__FONTSIZE                                   (DISPID_PCH_HELPCTR_BASE_O 	+ 0x02)
#define DISPID_PCH_O__TEXTLABELS                                 (DISPID_PCH_HELPCTR_BASE_O 	+ 0x03)
#define DISPID_PCH_O__DISABLESCRIPTDEBUGGER                      (DISPID_PCH_HELPCTR_BASE_O 	+ 0x04)

#define DISPID_PCH_O__APPLY                                      (DISPID_PCH_HELPCTR_BASE_O 	+ 0x10)
																									
/////////////////////////////////////////////////////////////////////////							
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_CM__ADDITEM                                   (DISPID_PCH_HELPCTR_BASE_CM    + 0x00)
#define DISPID_PCH_CM__ADDSEPARATOR                              (DISPID_PCH_HELPCTR_BASE_CM    + 0x01)
#define DISPID_PCH_CM__DISPLAY                                   (DISPID_PCH_HELPCTR_BASE_CM    + 0x02)

/////////////////////////////////////////////////////////////////////////							
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_PE__ONPROGRESS                                (DISPID_PCH_HELPCTR_BASE_PE    + 0x00)
#define DISPID_PCH_PE__ONCOMPLETE                                (DISPID_PCH_HELPCTR_BASE_PE    + 0x01)
																									
#define DISPID_PCH_PE__ADDTOPIC                                  (DISPID_PCH_HELPCTR_BASE_PE    + 0x10)
#define DISPID_PCH_PE__START                                     (DISPID_PCH_HELPCTR_BASE_PE    + 0x11)
#define DISPID_PCH_PE__ABORT                                     (DISPID_PCH_HELPCTR_BASE_PE    + 0x12)
																									
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_PEE__ONPROGRESS                               (DISPID_PCH_HELPCTR_BASE_PEE   + 0x00)
#define DISPID_PCH_PEE__ONCOMPLETE                               (DISPID_PCH_HELPCTR_BASE_PEE   + 0x01)
																									
/////////////////////////////////////////////////////////////////////////							
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_TB__DEFINITION                                (DISPID_PCH_HELPCTR_BASE_TB    + 0x00)
#define DISPID_PCH_TB__MODE                                      (DISPID_PCH_HELPCTR_BASE_TB    + 0x01)
																									
#define DISPID_PCH_TB__SETSTATE                                  (DISPID_PCH_HELPCTR_BASE_TB    + 0x08)
#define DISPID_PCH_TB__SETVISIBILITY                             (DISPID_PCH_HELPCTR_BASE_TB    + 0x09)
																									
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_TBE__ONCOMMAND                                (DISPID_PCH_HELPCTR_BASE_TBE   + 0x00)
																									
/////////////////////////////////////////////////////////////////////////							
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_PB__LOWLIMIT                                  (DISPID_PCH_HELPCTR_BASE_PB    + 0x00)
#define DISPID_PCH_PB__HIGHLIMIT                                 (DISPID_PCH_HELPCTR_BASE_PB    + 0x01)
#define DISPID_PCH_PB__POS                                       (DISPID_PCH_HELPCTR_BASE_PB    + 0x02)
																									
/////////////////////////////////////////////////////////////////////////							
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_INC__CONNECT                                  (DISPID_PCH_HELPCTR_BASE_INC   + 0x21)
#define DISPID_PCH_INC__DISCONNECT                               (DISPID_PCH_HELPCTR_BASE_INC   + 0x22)
#define DISPID_PCH_INC__STOPVOICE                                (DISPID_PCH_HELPCTR_BASE_INC   + 0x23)
#define DISPID_PCH_INC__STARTVOICE                               (DISPID_PCH_HELPCTR_BASE_INC   + 0x24)
#define DISPID_PCH_INC__EXIT                                     (DISPID_PCH_HELPCTR_BASE_INS   + 0x25)
																									
#define DISPID_PCH_INC__RUNSETUPWIZARD							 (DISPID_PCH_HELPCTR_BASE_INC   + 0x30)
#define DISPID_PCH_INC__SAMPLINGRATE							 (DISPID_PCH_HELPCTR_BASE_INC   + 0x31)
																									
// Property Put IDs																					
#define DISPID_PCH_INC__ONCONNECTIONCOMPLETE                     (DISPID_PCH_HELPCTR_BASE_INC   + 0x25)
#define DISPID_PCH_INC__ONNEWCONNECTED                           (DISPID_PCH_HELPCTR_BASE_INC   + 0x26)
#define DISPID_PCH_INC__ONDISCONNECTED                           (DISPID_PCH_HELPCTR_BASE_INC   + 0x27)
#define DISPID_PCH_INC__ONVOICECONNECTED                         (DISPID_PCH_HELPCTR_BASE_INC   + 0x28)
#define DISPID_PCH_INC__ONVOICEDISCONNECTED                      (DISPID_PCH_HELPCTR_BASE_INC   + 0x29)
#define DISPID_PCH_INC__ONVOICEDISABLED                          (DISPID_PCH_HELPCTR_BASE_INC   + 0x2A)
																									
/////////////////////////////////////////////////////////////////////////							
																									
// DispInterface Events																				
#define DISPID_PCH_INCE__ONCONNECTIONCOMPLETE                    (DISPID_PCH_HELPCTR_BASE_INCE  + 0x10)
#define DISPID_PCH_INCE__ONNEWCONNECTED                          (DISPID_PCH_HELPCTR_BASE_INCE  + 0x11)
#define DISPID_PCH_INCE__ONDISCONNECTED                          (DISPID_PCH_HELPCTR_BASE_INCE  + 0x12)
#define DISPID_PCH_INCE__ONVOICECONNECTED                        (DISPID_PCH_HELPCTR_BASE_INCE  + 0x13)
#define DISPID_PCH_INCE__ONVOICEDISCONNECTED                     (DISPID_PCH_HELPCTR_BASE_INCE  + 0x14)
#define DISPID_PCH_INCE__ONVOICEDISABLED                         (DISPID_PCH_HELPCTR_BASE_INCE  + 0x15)
																									
																									
/////////////////////////////////////////////////////////////////////////							
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_INS__LISTEN                                   (DISPID_PCH_HELPCTR_BASE_INS   + 0x20)
#define DISPID_PCH_INS__DISCONNECT                               (DISPID_PCH_HELPCTR_BASE_INS   + 0x22)
#define DISPID_PCH_INS__STOPVOICE                                (DISPID_PCH_HELPCTR_BASE_INS   + 0x23)
#define DISPID_PCH_INS__STARTVOICE                               (DISPID_PCH_HELPCTR_BASE_INS   + 0x24)
#define DISPID_PCH_INS__RESET                                    (DISPID_PCH_HELPCTR_BASE_INS   + 0x25)
#define DISPID_PCH_INS__EXIT                                     (DISPID_PCH_HELPCTR_BASE_INS   + 0x26)
																									
#define DISPID_PCH_INS__RUNSETUPWIZARD							 (DISPID_PCH_HELPCTR_BASE_INS   + 0x30)
#define DISPID_PCH_INS__SAMPLINGRATE							 (DISPID_PCH_HELPCTR_BASE_INS   + 0x31)
																									
// Property IDs																						
#define DISPID_PCH_INS__ONCONNECTIONCOMPLETE                     (DISPID_PCH_HELPCTR_BASE_INS   + 0x26)
#define DISPID_PCH_INS__ONNEWCONNECTED                           (DISPID_PCH_HELPCTR_BASE_INS   + 0x27)
#define DISPID_PCH_INS__ONDISCONNECTED                           (DISPID_PCH_HELPCTR_BASE_INS   + 0x28)
#define DISPID_PCH_INS__ONVOICECONNECTED                         (DISPID_PCH_HELPCTR_BASE_INS   + 0x29)
#define DISPID_PCH_INS__ONVOICEDISCONNECTED                      (DISPID_PCH_HELPCTR_BASE_INS   + 0x2A)
#define DISPID_PCH_INS__ONVOICEDISABLED                          (DISPID_PCH_HELPCTR_BASE_INS   + 0x2B)

																									
#define DISPID_PCH_INS__CRYPTKEY		                         (DISPID_PCH_HELPCTR_BASE_INS   + 0x2C)
																									
/////////////////////////////////////////////////////////////////////////							
																									
// DispInterface Events																				
#define DISPID_PCH_INSE__ONCONNECTIONCOMPLETE                    (DISPID_PCH_HELPCTR_BASE_INSE  + 0x10)
#define DISPID_PCH_INSE__ONNEWCONNECTED                          (DISPID_PCH_HELPCTR_BASE_INSE  + 0x11)
#define DISPID_PCH_INSE__ONDISCONNECTED                          (DISPID_PCH_HELPCTR_BASE_INSE  + 0x12)
#define DISPID_PCH_INSE__ONVOICECONNECTED                        (DISPID_PCH_HELPCTR_BASE_INSE  + 0x13)
#define DISPID_PCH_INSE__ONVOICEDISCONNECTED                     (DISPID_PCH_HELPCTR_BASE_INSE  + 0x14)
#define DISPID_PCH_INSE__ONVOICEDISABLED                         (DISPID_PCH_HELPCTR_BASE_INSE  + 0x15)
																									
/////////////////////////////////////////////////////////////////////////							
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_C__ISAMODEM                      			 (DISPID_PCH_HELPCTR_BASE_C     + 0x00)
#define DISPID_PCH_C__ISALAN                       			     (DISPID_PCH_HELPCTR_BASE_C     + 0x01)
#define DISPID_PCH_C__AUTODIALENABLED               			 (DISPID_PCH_HELPCTR_BASE_C     + 0x02)
#define DISPID_PCH_C__HASCONNECTOID                 			 (DISPID_PCH_HELPCTR_BASE_C     + 0x03)
#define DISPID_PCH_C__IPADDRESSES                   			 (DISPID_PCH_HELPCTR_BASE_C     + 0x04)
																									
																									
#define DISPID_PCH_C__CREATEOBJECT_CONNECTIONCHECK               (DISPID_PCH_HELPCTR_BASE_C     + 0x10)
																									
#define DISPID_PCH_C__NETWORKALIVE                               (DISPID_PCH_HELPCTR_BASE_C     + 0x11)
#define DISPID_PCH_C__DESTINATIONREACHABLE                       (DISPID_PCH_HELPCTR_BASE_C     + 0x12)
																									
#define DISPID_PCH_C__AUTODIAL                                   (DISPID_PCH_HELPCTR_BASE_C     + 0x13)
#define DISPID_PCH_C__AUTODIALHANGUP                             (DISPID_PCH_HELPCTR_BASE_C     + 0x14)

#define DISPID_PCH_C__NAVIGATEONLINE                             (DISPID_PCH_HELPCTR_BASE_C     + 0x15)
																									
////////////////////////////////////////															
																									
#define DISPID_PCH_CN__ONCHECKDONE                               (DISPID_PCH_HELPCTR_BASE_CN    + 0x00)
#define DISPID_PCH_CN__ONSTATUSCHANGE                            (DISPID_PCH_HELPCTR_BASE_CN    + 0x01)
#define DISPID_PCH_CN__STATUS                                    (DISPID_PCH_HELPCTR_BASE_CN    + 0x02)
																									
#define DISPID_PCH_CN__STARTURLCHECK                             (DISPID_PCH_HELPCTR_BASE_CN    + 0x10)
#define DISPID_PCH_CN__ABORT                                     (DISPID_PCH_HELPCTR_BASE_CN    + 0x11)
																									
////////////////////////////////////////															
																									
#define DISPID_PCH_CNE__ONCHECKDONE                              (DISPID_PCH_HELPCTR_BASE_CNE   + 0x00)
#define DISPID_PCH_CNE__ONSTATUSCHANGE                           (DISPID_PCH_HELPCTR_BASE_CNE   + 0x01)

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
																									
#define DISPID_PCH_TH__QUOTEESCAPE  			 				 (DISPID_PCH_HELPCTR_BASE_TH	+ 0x00)
#define DISPID_PCH_TH__URLUNESCAPE  			 				 (DISPID_PCH_HELPCTR_BASE_TH	+ 0x01)
#define DISPID_PCH_TH__URLESCAPE    			 				 (DISPID_PCH_HELPCTR_BASE_TH	+ 0x02)
#define DISPID_PCH_TH__HTMLESCAPE   			 				 (DISPID_PCH_HELPCTR_BASE_TH	+ 0x03)
				   								 									
#define DISPID_PCH_TH__PARSEURL                  				 (DISPID_PCH_HELPCTR_BASE_TH    + 0x10)
#define DISPID_PCH_TH__GETLCIDDISPLAYSTRING        				 (DISPID_PCH_HELPCTR_BASE_TH    + 0x11)

////////////////////////////////////////															
																									
#define DISPID_PCH_PU__BASEPART                           		 (DISPID_PCH_HELPCTR_BASE_PU    + 0x00)
#define DISPID_PCH_PU__BASEPART                           		 (DISPID_PCH_HELPCTR_BASE_PU    + 0x00)
#define DISPID_PCH_PU__QUERYPARAMETERS                           (DISPID_PCH_HELPCTR_BASE_PU 	+ 0x01)

#define DISPID_PCH_PU__GETQUERYPARAMETER                         (DISPID_PCH_HELPCTR_BASE_PU 	+ 0x10)
#define DISPID_PCH_PU__SETQUERYPARAMETER                         (DISPID_PCH_HELPCTR_BASE_PU 	+ 0x11)
#define DISPID_PCH_PU__DELETEQUERYPARAMETER                      (DISPID_PCH_HELPCTR_BASE_PU 	+ 0x12)

#define DISPID_PCH_PU__BUILDFULLURL                              (DISPID_PCH_HELPCTR_BASE_PU    + 0x13)

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___PCH___HELPCTRUIDID_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\include\context.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Context.h

Abstract:
    This file contains the declaration of the classes for the IHelpHost*.

Revision History:
    Davide Massarenti   (dmassare) 11/03/2000
        modified

******************************************************************************/

#if !defined(__INCLUDED___PCH___CONTEXT_H___)
#define __INCLUDED___PCH___CONTEXT_H___

/////////////////////////////////////////////////////////////////////////////

#include <dispex.h>
#include <ocmm.h>

//
// Forward declarations.
//
class CPCHHelpCenterExternal;

namespace HelpHost
{
    //
    // Forward declarations.
    //
    class Main;
    class Panes;
    class Pane;
    class Window;

    ////////////////////////////////////////////////////////////////////////////////

    typedef enum
    {
        COMPID_NAVBAR     = 0,
        COMPID_MININAVBAR    ,
        COMPID_CONTEXT       ,
        COMPID_CONTENTS      ,
        COMPID_HHWINDOW      ,

        COMPID_FIRSTPAGE     ,
        COMPID_HOMEPAGE      ,
        COMPID_SUBSITE       ,
        COMPID_SEARCH        ,
        COMPID_INDEX         ,
        COMPID_FAVORITES     ,
        COMPID_HISTORY       ,
        COMPID_CHANNELS      ,
        COMPID_OPTIONS       ,

        COMPID_MAX           ,
    } CompId;

    ////////////////////////////////////////////////////////////////////////////////

    class ATL_NO_VTABLE Main :
        public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
        public IDispatchImpl<IPCHHelpHost, &IID_IPCHHelpHost, &LIBID_HelpCenterTypeLib>
    {
    public:
        CComPtr<IRunningObjectTable>     m_rt;
        CComPtr<IMoniker>                m_moniker;
        DWORD                            m_dwRegister;

        CPCHHelpCenterExternal*          m_External;

        HANDLE                           m_hEvent;
        bool                             m_comps[COMPID_MAX];

    public:
    BEGIN_COM_MAP(Main)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IPCHHelpHost)
    END_COM_MAP()

        Main();
        virtual ~Main();

        HRESULT Initialize( /*[in]*/ CPCHHelpCenterExternal* external );
        void    Passivate (                                           );

        HRESULT Locate  ( /*[in]*/ CLSID& clsid, /*[out]*/ CComPtr<IPCHHelpHost>& pVal );
        HRESULT Register( /*[in]*/ CLSID& clsid                                        );

        ////////////////////

        void ChangeStatus   ( /*[in]*/ LPCWSTR szComp, /*[in]*/ bool  fStatus          );
        void ChangeStatus   ( /*[in]*/ CompId  idComp, /*[in]*/ bool  fStatus          );
        bool GetStatus      ( /*[in]*/ CompId  idComp                                  );
        bool WaitUntilLoaded( /*[in]*/ CompId  idComp, /*[in]*/ DWORD dwTimeout = 5000 ); // 5 seconds wait for page load.

        ////////////////////

        STDMETHOD(DisplayTopicFromURL)( /*[in]*/ BSTR url, /*[in]*/ VARIANT options );
    };

    ////////////////////////////////////////////////////////////////////////////////

    class XMLConfig : public MPC::Config::TypeConstructor
    {
        DECLARE_CONFIG_MAP(XMLConfig);

    public:

        class Context : public MPC::Config::TypeConstructor
        {
            DECLARE_CONFIG_MAP(Context);

        public:
            CComBSTR m_bstrID;

            CComBSTR m_bstrTaxonomyPath;
            CComBSTR m_bstrNodeToHighlight;
            CComBSTR m_bstrTopicToHighlight;
            CComBSTR m_bstrQuery;

            ////////////////////////////////////////
            //
            // MPC::Config::TypeConstructor
            //
            DEFINE_CONFIG_DEFAULTTAG();
            DECLARE_CONFIG_METHODS();
            //
            ////////////////////////////////////////

            Context();
        };

        class WindowSettings : public MPC::Config::TypeConstructor
        {
            DECLARE_CONFIG_MAP(WindowSettings);

        public:
            CComBSTR m_bstrLayout;
			bool     m_fNoResize ; bool m_fPresence_NoResize;
            bool     m_fMaximized; bool m_fPresence_Maximized;
            CComBSTR m_bstrTitle ; bool m_fPresence_Title;
            CComBSTR m_bstrLeft  ; bool m_fPresence_Left;
            CComBSTR m_bstrTop   ; bool m_fPresence_Top;
            CComBSTR m_bstrWidth ; bool m_fPresence_Width;
            CComBSTR m_bstrHeight; bool m_fPresence_Height;

            ////////////////////////////////////////
            //
            // MPC::Config::TypeConstructor
            //
            DEFINE_CONFIG_DEFAULTTAG();
            DECLARE_CONFIG_METHODS();
            //
            ////////////////////////////////////////

            WindowSettings();
        };

        class ApplyTo : public MPC::Config::TypeConstructor
        {
            DECLARE_CONFIG_MAP(ApplyTo);

        public:
            CComBSTR        m_bstrSKU;
            CComBSTR        m_bstrLanguage;

            CComBSTR        m_bstrTopicToDisplay;
            CComBSTR        m_bstrApplication;
            WindowSettings* m_WindowSettings;
            Context*        m_Context;

            ////////////////////////////////////////
            //
            // MPC::Config::TypeConstructor
            //
            DEFINE_CONFIG_DEFAULTTAG();
            DECLARE_CONFIG_METHODS();
            //
            ////////////////////////////////////////

            ApplyTo();
            ~ApplyTo();

			bool MatchSystem( /*[in]*/  CPCHHelpCenterExternal* external ,
							  /*[out]*/ Taxonomy::HelpSet&      ths      );
        };

        typedef std::list< ApplyTo >        ApplyToList;
        typedef ApplyToList::iterator       ApplyToIter;
        typedef ApplyToList::const_iterator ApplyToIterConst;

        ApplyToList m_lstSessions;

        ////////////////////////////////////////
        //
        // MPC::Config::TypeConstructor
        //
        DEFINE_CONFIG_DEFAULTTAG();
        DECLARE_CONFIG_METHODS();
        //
        ////////////////////////////////////////
    };
};

#endif // !defined(__INCLUDED___PCH___CONTEXT_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\include\helpsession.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    HelpSession.h

Abstract:
    This file contains the declaration of the class used to implement
    the Help Session inside the Help Center Application.

Revision History:
    Davide Massarenti   (dmassare)  08/07/99
        created

******************************************************************************/

#if !defined(__INCLUDED___PCH___HELPSESSION_H___)
#define __INCLUDED___PCH___HELPSESSION_H___

/////////////////////////////////////////////////////////////////////////////

//
// Uncomment if you want to enable Help Session traces.
//
//#define HSS_RPRD

////////////////////////////////////////

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

//
// From HelpCenterTypeLib.idl
//
#include <HelpCenterTypeLib.h>

#include <MPC_streams.h>

#include <TaxonomyDatabase.h>

////////////////////

class CPCHHelpCenterExternal;

class CPCHHelpSessionItem;
class CPCHHelpSession;

////////////////////////////////////////////////////////////////////////////////

typedef enum
{
    HSCPANEL_INVALID    = 0,
    HSCPANEL_NAVBAR        ,
    HSCPANEL_MININAVBAR    ,
    HSCPANEL_CONTEXT       ,
    HSCPANEL_CONTENTS      ,
    HSCPANEL_HHWINDOW      ,
} HscPanel;

typedef enum
{
    HSCCONTEXT_INVALID  = 0,
    HSCCONTEXT_STARTUP     ,
    HSCCONTEXT_HOMEPAGE    ,
    HSCCONTEXT_CONTENT     ,
    HSCCONTEXT_SUBSITE     ,
    HSCCONTEXT_SEARCH      ,
    HSCCONTEXT_INDEX       ,
    HSCCONTEXT_FAVORITES   ,
    HSCCONTEXT_HISTORY     ,
    HSCCONTEXT_CHANNELS    ,
    HSCCONTEXT_OPTIONS     ,
    ////////////////////////////////////////
    HSCCONTEXT_CONTENTONLY ,
    HSCCONTEXT_FULLWINDOW  ,
    HSCCONTEXT_KIOSKMODE   ,
} HscContext;

////////////////////

class ATL_NO_VTABLE CPCHHelpSessionItem : // Hungarian: hchsi
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public IDispatchImpl<IPCHHelpSessionItem, &IID_IPCHHelpSessionItem, &LIBID_HelpCenterTypeLib>
{
    friend class CPCHHelpSession;

    static const int NO_LINK = -1;

    struct State
    {
        typedef std::map<MPC::wstringUC,MPC::wstring> PropertyMap;
        typedef PropertyMap::iterator                 PropertyIter;
        typedef PropertyMap::const_iterator           PropertyIterConst;

        ////////////////////////////////////////

        CPCHHelpSessionItem* m_parent;
        bool                 m_fValid;
        bool                 m_fDirty;
        DWORD                m_dwLoaded;

        MPC::CComHGLOBAL     m_hgWebBrowser_CONTENTS;
        MPC::CComHGLOBAL     m_hgWebBrowser_HHWINDOW;
        PropertyMap          m_mapProperties;

        ////////////////////////////////////////

        void    Erase( /*[in]*/ bool fUnvalidate );
        HRESULT Load (                           );
        HRESULT Save (                           );

    private:
        // copy constructors...
        State           ( /*[in]*/ const State& state );
        State& operator=( /*[in]*/ const State& state );

    public:
        State( /*[in]*/ CPCHHelpSessionItem* parent );

        HRESULT AcquireState(                      );
        HRESULT ReleaseState( /*[in]*/ bool fForce );

        HRESULT Populate( /*[in ]*/ bool   fUseHH );
        HRESULT Restore ( /*[in ]*/ bool   fUseHH );
        HRESULT Delete  (                         );
        HRESULT Clone   ( /*[out]*/ State& state  );
    };

    ////////////////////////////////////////

    CPCHHelpSession*  m_parent;
    State             m_state;
    bool              m_fSaved;
    bool              m_fInitialized;
    ////////////////////
    //
    // Persisted
    //
    Taxonomy::HelpSet m_ths;

    CComBSTR          m_bstrURL;
    CComBSTR          m_bstrTitle;
    DATE              m_dLastVisited;
    DATE              m_dDuration;
    long              m_lNumOfHits;

    int               m_iIndexPrev;
    int               m_iIndex;
    int               m_iIndexNext;

    long              m_lContextID;      // HscContext
    CComBSTR          m_bstrContextInfo;
    CComBSTR          m_bstrContextURL;

    bool              m_fUseHH;
    //
    ////////////////////

    ////////////////////////////////////////

	void    HistorySelect  (                                                           );
    HRESULT HistoryPopulate(                                                           );
    HRESULT HistoryRestore (                                                           );
    HRESULT HistoryDelete  (                                                           );
    HRESULT HistoryClone   ( /*[in]*/ bool fContext, /*[in]*/ CPCHHelpSessionItem* hsi );

public:
BEGIN_COM_MAP(CPCHHelpSessionItem)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHHelpSessionItem)
END_COM_MAP()

    CPCHHelpSessionItem();

    void Initialize( /*[in]*/ CPCHHelpSession* parent, /*[in]*/ bool fNew );
    void Passivate (                                                      );

    HRESULT Load( /*[in]*/ MPC::Serializer& streamIn                       );
    HRESULT Save( /*[in]*/ MPC::Serializer& streamOut, bool fForce = false );

    ////////////////////////////////////////

    HRESULT Enter();
    HRESULT Leave();

    bool SeenLongEnough( DWORD dwSeconds ) const;

    bool SameURL( CPCHHelpSessionItem* right ) const;
    bool SameURL( LPCWSTR              right ) const;

    bool SameSKU( /*[in]*/ const Taxonomy::HelpSet& ths ) const;

    ////////////////////////////////////////

    CPCHHelpSession* GetParent     ()       { return             m_parent         ; }
    const CComBSTR&  GetURL        () const { return             m_bstrURL        ; }

    int              GetIndex      () const { return             m_iIndex         ; }

    const HscContext GetContextID  () const { return (HscContext)m_lContextID     ; }
    const CComBSTR&  GetContextInfo() const { return             m_bstrContextInfo; }
    const CComBSTR&  GetContextURL () const { return             m_bstrContextURL ; }

    static HscContext LookupContext( /*[in]*/ LPCWSTR    szName );
    static LPCWSTR    LookupContext( /*[in]*/ HscContext iVal   );

    ////////////////////////////////////////

    CPCHHelpSessionItem* Previous();
    CPCHHelpSessionItem* Next    ();

    HRESULT ExtractTitle();

    ////////////////////////////////////////

public:
    // IPCHHelpSessionItem
    void      put_THS         ( /*[in]*/ const Taxonomy::HelpSet& ths ); // Internal Method.
    STDMETHOD(get_SKU        )( /*[out, retval]*/ BSTR *  pVal );
    STDMETHOD(get_Language   )( /*[out, retval]*/ long *  pVal );

    STDMETHOD(get_URL        )( /*[out, retval]*/ BSTR *  pVal );
    HRESULT   put_URL         ( /*[in]*/          BSTR  newVal ); // Internal Method.
    STDMETHOD(get_Title      )( /*[out, retval]*/ BSTR *  pVal );
    HRESULT   put_Title       ( /*[in]*/          BSTR  newVal ); // Internal Method.
    STDMETHOD(get_LastVisited)( /*[out, retval]*/ DATE *  pVal );
    STDMETHOD(get_Duration   )( /*[out, retval]*/ DATE *  pVal );
    STDMETHOD(get_NumOfHits  )( /*[out, retval]*/ long *  pVal );

    STDMETHOD(get_ContextName)(                         /*[out, retval]*/ BSTR    *pVal   );
    STDMETHOD(get_ContextInfo)(                         /*[out, retval]*/ BSTR    *pVal   );
    STDMETHOD(get_ContextURL )(                         /*[out, retval]*/ BSTR    *pVal   );

    STDMETHOD(get_Property   )( /*[in]*/ BSTR bstrName, /*[out, retval]*/ VARIANT *pVal   );
    STDMETHOD(put_Property   )( /*[in]*/ BSTR bstrName, /*[in]*/          VARIANT  newVal );

    STDMETHOD(CheckProperty)( /*[in]*/ BSTR bstrName, /*[out, retval]*/ VARIANT_BOOL *pVal );
};

/////////////////////////////////////////////////////////////////////////////


class ATL_NO_VTABLE CPCHHelpSession : // Hungarian: hchs
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public IDispatchImpl<IPCHHelpSession, &IID_IPCHHelpSession, &LIBID_HelpCenterTypeLib>
{
	friend class CPCHHelpSessionItem;

#ifdef DEBUG

    void DEBUG_DumpState_HG  ( /*[in]*/ MPC::FileLog& log, /*[in]*/ MPC::CComHGLOBAL&    hg  );
    void DEBUG_DumpState_BLOB( /*[in]*/ MPC::FileLog& log, /*[in]*/ CPCHHelpSessionItem* hsi );

    void DEBUG_DumpState( /*[in]*/ LPCWSTR szText, /*[in]*/ bool fHeader, /*[in]*/ bool fCurrent, /*[in]*/ bool fAll, /*[in]*/ bool fState );

	void DEBUG_DumpSavedPages();

#else

    inline void DEBUG_DumpState_HG  ( /*[in]*/ MPC::FileLog& log, /*[in]*/ MPC::CComHGLOBAL&    hg  ) {}
    inline void DEBUG_DumpState_BLOB( /*[in]*/ MPC::FileLog& log, /*[in]*/ CPCHHelpSessionItem* hsi ) {}

    inline void DEBUG_DumpState( /*[in]*/ LPCWSTR szText, /*[in]*/ bool fHeader, /*[in]*/ bool fCurrent, /*[in]*/ bool fAll, /*[in]*/ bool fState ) {}

	inline void DEBUG_DumpSavedPages() {}

#endif

    ////////////////////////////////////////

public:
    struct TitleEntry
    {
        MPC::wstring m_szTitle;
        bool         m_fStrong;

        TitleEntry()
        {
            m_fStrong = false;
        }
    };

    typedef std::map<MPC::wstringUC,TitleEntry> TitleMap;
    typedef TitleMap::iterator                  TitleIter;
    typedef TitleMap::const_iterator            TitleIterConst;

    typedef std::list< CPCHHelpSessionItem* >   List;
    typedef List::iterator                      Iter;
    typedef List::const_iterator                IterConst;

    ////////////////////////////////////////

private:
    friend class CPCHHelpSessionItem;

    CPCHHelpCenterExternal*      m_parent;

    MPC::wstring                 m_szBackupFile;
    MPC::StorageObject           m_disk;
    DATE                         m_dStartOfSession;

    CComPtr<IUrlHistoryStg>      m_pIHistory; // For looking up URL titles.

	MPC::WStringUCList           m_lstIgnore;
    TitleMap                     m_mapTitles;
    List                         m_lstVisitedPages;
    List                         m_lstCachedVisitedPages;
    CComPtr<CPCHHelpSessionItem> m_hsiCurrentPage;
    DWORD                        m_dwTravelling;
    bool                         m_fAlreadySaved;
    bool                         m_fAlreadyCreated;
    bool                         m_fOverwrite;
    DWORD                        m_dwIgnore;
    DWORD                        m_dwNoEvents;
    DATE                         m_dLastNavigation;
    int                          m_iLastIndex;

    long                         m_lContextID;
    CComBSTR                     m_bstrContextInfo;
    CComBSTR                     m_bstrContextURL;

	bool                         m_fPossibleBack;
	DWORD                        m_dwPossibleBack;

    ////////////////////////////////////////

    HRESULT Load (                                  );
    HRESULT Save (                                  );
    HRESULT Clone( /*[in]*/ CPCHHelpSession& hsCopy );

    HRESULT ItemState_GetIndexObject  (                      /*[in]*/ bool fCreate, /*[out]*/ MPC::StorageObject*& child );
    HRESULT ItemState_GetStorageObject( /*[in]*/ int iIndex, /*[in]*/ bool fCreate, /*[out]*/ MPC::StorageObject*& child );

    ////////////////////////////////////////

#ifdef HSS_RPRD
    HRESULT DumpSession();
#endif

    ////////////////////////////////////////

    HRESULT              Erase();
    HRESULT              ResetTitles();
    HRESULT              FilterPages( /*[in]*/ HS_MODE hsMode, /*[out]*/ List& lstObject );

    CPCHHelpSessionItem* FindPage( /*[in]*/ BSTR                 bstrURL );
    CPCHHelpSessionItem* FindPage( /*[in]*/ IPCHHelpSessionItem* pHSI    );
    CPCHHelpSessionItem* FindPage( /*[in]*/ int                  iIndex  );

    ////////////////////////////////////////

    HRESULT LeaveCurrentPage( /*[in]*/ bool fSaveHistory = true , /*[in]*/ bool fClearPage = true );

    HRESULT FindTravelLog( /*[in]*/ long lLength, /*[out]*/ CPCHHelpSessionItem*& hsi );
    HRESULT Travel       (                        /*[in] */ CPCHHelpSessionItem*  hsi );
    HRESULT Travel       ( /*[in]*/ long lLength                                      );

    HRESULT AllocateItem  ( /*[in]*/ bool fNew, /*[in]*/ bool fLink, /*[in]*/ bool fNewIndex, /*[out]*/ CComPtr<CPCHHelpSessionItem>& hsi );
    HRESULT SetCurrentItem(                     /*[in]*/ bool fLink,                          /*[in ]*/         CPCHHelpSessionItem*  hsi );
    HRESULT AppendToCached(                                                                   /*[in ]*/         CPCHHelpSessionItem*  hsi );

    ////////////////////////////////////////

public:
BEGIN_COM_MAP(CPCHHelpSession)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHHelpSession)
END_COM_MAP()

    CPCHHelpSession();
    virtual ~CPCHHelpSession();

    HRESULT Initialize( /*[in]*/ CPCHHelpCenterExternal* parent );
    HRESULT Persist   (                                         );
    void    Passivate (                                         );

    CPCHHelpCenterExternal* GetParent() { return m_parent; }

    ////////////////////

    HRESULT ItemState_CreateStream( /*[in]*/ int iIndex, /*[out]*/ CComPtr<IStream>& stream );
    HRESULT ItemState_GetStream   ( /*[in]*/ int iIndex, /*[out]*/ CComPtr<IStream>& stream );
    HRESULT ItemState_DeleteStream( /*[in]*/ int iIndex                                     );

    HRESULT ForceHistoryPopulate();

    ////////////////////

    HRESULT RecordTitle( /*[in]*/ BSTR bstrURL, /*[in ]*/ BSTR      bstrTitle, /*[in]*/ bool fStrong     );
    HRESULT LookupTitle( /*[in]*/ BSTR bstrURL, /*[out]*/ CComBSTR& bstrTitle, /*[in]*/ bool fUseIECache );

    HRESULT RegisterContextSwitch    ( /*[in]*/ HscContext iVal, /*[in]*/ BSTR bstrInfo, /*[in]*/ BSTR bstrURL, /*[out]*/ CPCHHelpSessionItem* *pVal = NULL );
    HRESULT RecordNavigationInAdvance( /*[in]*/ BSTR bstrURL                                                                                                );
    HRESULT DuplicateNavigation      (                                                                                                                      );
    HRESULT CancelNavigation         (                                                                                                                      );

	void    SetThreshold             (                                                                                                                      );
	void    CancelThreshold          (                                                                                                                      );
	bool    HasThresholdExpired      (                                                                                                                      );
    bool    IsUrlToIgnore            ( /*[in]*/ LPCWSTR   szURL, /*[in]*/ bool fRemove                                                                      );
    HRESULT IgnoreUrl                ( /*[in]*/ LPCWSTR   szURL                                                                                             );
    HRESULT StartNavigation          ( /*[in]*/ BSTR    bstrURL, /*[in]*/ HscPanel idPanel                                                                  );
    HRESULT CompleteNavigation       (                           /*[in]*/ HscPanel idPanel                                                                  );

    bool                 IsTravelling() { return m_dwTravelling != 0; }
    CPCHHelpSessionItem* Current     () { return m_hsiCurrentPage;    }

    void PossibleBack  ();
    bool IsPossibleBack();

    ////////////////////

public:
#ifdef DEBUG
    void DebugDump() const;
#endif

public:
    // IPCHHelpSession
    STDMETHOD(get_CurrentContext)( /*[out, retval]*/ IPCHHelpSessionItem* *ppHSI );

    STDMETHOD(VisitedHelpPages)( /*[in]*/ HS_MODE hsMode, /*[out, retval]*/ IPCHCollection* *ppC );

    STDMETHOD(SetTitle        )( /*[in]*/ BSTR bstrURL, /*[in]*/ BSTR bstrTitle );
    STDMETHOD(ForceNavigation )( /*[in]*/ BSTR bstrURL                          );
    STDMETHOD(IgnoreNavigation)(                                                );
    STDMETHOD(EraseNavigation )(                                                );
    STDMETHOD(IsNavigating    )( /*[out, retval]*/ VARIANT_BOOL *pVal           );

    STDMETHOD(Back    )( /*[in]*/ long lLength                                       );
    STDMETHOD(Forward )( /*[in]*/ long lLength                                       );
    STDMETHOD(IsValid )( /*[in]*/ long lLength, /*[out, retval]*/ VARIANT_BOOL *pVal );
    STDMETHOD(Navigate)( /*[in]*/ IPCHHelpSessionItem* pHSI                          );

    STDMETHOD(ChangeContext)( /*[in]*/ BSTR bstrName, /*[in,optional]*/ VARIANT vInfo, /*[in,optional]*/ VARIANT vURL );
};

/////////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___PCH___HELPSESSION_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\include\htmlprogressbar.h ===
/******************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:
    Toolbar.cpp

Abstract:
    This file contains the declaration of the ActiveX control that makes Win32 ProgressBars available to HTML.

Revision History:
    Davide Massarenti   (Dmassare)  03/04/2001
        created

******************************************************************************/

#if !defined(__INCLUDED___PCH___HTMLPROGRESSBAR_H___)
#define __INCLUDED___PCH___HTMLPROGRESSBAR_H___

#include <HelpCenter.h>

class ATL_NO_VTABLE CPCHProgressBar :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CStockPropImpl                 <CPCHProgressBar, IPCHProgressBar, &IID_IPCHProgressBar, &LIBID_HelpCenterTypeLib>,
    public CComControl                    <CPCHProgressBar>,
    public IPersistPropertyBagImpl        <CPCHProgressBar>,
    public IOleControlImpl                <CPCHProgressBar>,
    public IOleObjectImpl                 <CPCHProgressBar>,
    public IOleInPlaceActiveObjectImpl    <CPCHProgressBar>,
    public IViewObjectExImpl              <CPCHProgressBar>,
    public IOleInPlaceObjectWindowlessImpl<CPCHProgressBar>,
    public CComCoClass                    <CPCHProgressBar, &CLSID_PCHProgressBar>
{
    HWND m_hwndPB;
		 
	long m_lLowLimit;
	long m_lHighLimit;
	long m_lPos;

    ////////////////////////////////////////

public:
DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CPCHProgressBar)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPCHProgressBar)
    COM_INTERFACE_ENTRY(IPCHProgressBar)
    COM_INTERFACE_ENTRY2(IDispatch, IPCHProgressBar)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObject2)
    COM_INTERFACE_ENTRY(IViewObject)
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IPersistPropertyBag)
    COM_INTERFACE_ENTRY2(IPersist, IPersistPropertyBag)
END_COM_MAP()

BEGIN_PROP_MAP(CPCHProgressBar)
	PROP_ENTRY("LowLimit" , DISPID_PCH_PB__LOWLIMIT , CLSID_NULL)
	PROP_ENTRY("HighLimit", DISPID_PCH_PB__HIGHLIMIT, CLSID_NULL)
END_PROP_MAP()

    CPCHProgressBar();

    BOOL ProcessWindowMessage( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult, DWORD dwMsgMapID = 0 );

// IViewObjectEx
    DECLARE_VIEW_STATUS(0)

// IPCHProgressBar
public:
    STDMETHOD(get_LowLimit )( /*[out, retval]*/ long *  pVal );
    STDMETHOD(put_LowLimit )( /*[in         ]*/ long  newVal );
    STDMETHOD(get_HighLimit)( /*[out, retval]*/ long *  pVal );
    STDMETHOD(put_HighLimit)( /*[in         ]*/ long  newVal );
    STDMETHOD(get_Pos  	   )( /*[out, retval]*/ long *  pVal );
    STDMETHOD(put_Pos  	   )( /*[in         ]*/ long  newVal );
};

/////////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___PCH___HTMLPROGRESSBAR_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\include\htmltoolbar.h ===
/******************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:
    Toolbar.cpp

Abstract:
    This file contains the declaration of the ActiveX control that makes Win32 ToolBars available to HTML.

Revision History:
    Davide Massarenti   (Dmassare)  03/04/2001
        created

******************************************************************************/

#if !defined(__INCLUDED___PCH___HTMLTOOLBAR_H___)
#define __INCLUDED___PCH___HTMLTOOLBAR_H___

#include <HelpCenter.h>

MIDL_INTERFACE("FC7D9EA1-3F9E-11d3-93C0-00C04F72DAF7")
IPCHToolBarPrivate : public IUnknown
{
public:
    STDMETHOD(SameObject)( /*[in]*/ IPCHToolBar* ptr );
};

class ATL_NO_VTABLE CPCHToolBar :
    public MPC::ConnectionPointImpl       <      CPCHToolBar, &DIID_DPCHToolBarEvents, CComSingleThreadModel   >,
	public IProvideClassInfo2Impl         <&CLSID_PCHToolBar, &DIID_DPCHToolBarEvents, &LIBID_HelpCenterTypeLib>,
    public IDispatchImpl                  <      IPCHToolBar, & IID_IPCHToolBar      , &LIBID_HelpCenterTypeLib>,
    public CComControl                    <CPCHToolBar>,
    public IPersistPropertyBagImpl        <CPCHToolBar>,
    public IOleControlImpl                <CPCHToolBar>,
    public IOleObjectImpl                 <CPCHToolBar>,
    public IOleInPlaceActiveObjectImpl    <CPCHToolBar>,
    public IViewObjectExImpl              <CPCHToolBar>,
    public IOleInPlaceObjectWindowlessImpl<CPCHToolBar>,
    public CComCoClass                    <CPCHToolBar, &CLSID_PCHToolBar>,
	public IPCHToolBarPrivate               
{
	typedef enum
    {
		TYPE_invalid  ,
		TYPE_back     ,
		TYPE_forward  ,
		TYPE_separator,
		TYPE_generic  ,
	} Types;
	
	static const MPC::StringToBitField c_TypeLookup[];

    class Button : public MPC::Config::TypeConstructor
    {
        DECLARE_CONFIG_MAP(Button);

    public:
        MPC::wstring m_strID;
        WCHAR        m_wch;
        bool     	 m_fEnabled;
        bool     	 m_fVisible;
        bool     	 m_fHideText;
        bool     	 m_fSystemMenu;
        DWORD        m_dwType;
	
        MPC::wstring m_strImage_Normal;
        MPC::wstring m_strImage_Hot;
        MPC::wstring m_strText;
        MPC::wstring m_strToolTip;

		int          m_idCmd;
		int          m_iImage_Normal;
		int          m_iImage_Hot;

        ////////////////////////////////////////
        //
        // MPC::Config::TypeConstructor
        //
        DEFINE_CONFIG_DEFAULTTAG();
        DECLARE_CONFIG_METHODS();
        //
        ////////////////////////////////////////

		Button();

		void UpdateState( /*[in]*/ HWND hwndTB );
    };

    class Config : public MPC::Config::TypeConstructor
    {
        DECLARE_CONFIG_MAP(Config);

    public:
        typedef std::list< Button >        ButtonList;
        typedef ButtonList::iterator       ButtonIter;
        typedef ButtonList::const_iterator ButtonIterConst;

		long	   m_lWidth;
		long	   m_lHeight;
		long	   m_lIconSize;
		bool       m_fRTL;

		TB_MODE    m_mode;
        ButtonList m_lstButtons;

		HIMAGELIST m_himlNormal;
		HIMAGELIST m_himlHot;
							

        ////////////////////////////////////////
        //
        // MPC::Config::TypeConstructor
        //
        DEFINE_CONFIG_DEFAULTTAG();
        DECLARE_CONFIG_METHODS();
        //
        ////////////////////////////////////////

		Config();

        Button* LookupButton( /*[in]*/ LPCWSTR szID, /*[in]*/ int idCmd );


		void    Reset(                                                                                   );
		HRESULT Load ( /*[in]*/ LPCWSTR szBaseURL, /*[in]*/ LPCWSTR szDefinition, /*[in]*/ LPCWSTR szDir );

		HRESULT CreateButtons( /*[in]*/ HWND hwndTB                                                 );
		void    UpdateSize   ( /*[in]*/ HWND hwndTB, /*[in]*/ HWND hwndRB, /*[out]*/ SIZEL& ptIdeal );

		////////////////////

		HRESULT MergeImage( /*[in]*/ LPCWSTR szBaseURL, /*[in]*/ LPCWSTR szRelativeURL, /*[in ]*/ HIMAGELIST himl, /*[out]*/ int& iImage );
    };

	////////////////////////////////////////////////////////////////////////////////


    CPCHHelpCenterExternal* m_parent;
    HWND                    m_hwndRB;
    HWND                    m_hwndTB;
							
	CComBSTR                m_bstrBaseURL;
	CComBSTR                m_bstrDefinition;

	Config                  m_cfg;
	bool                    m_fLoaded;

    ////////////////////////////////////////

    //
    // Event firing methods.
    //
    HRESULT Fire_onCommand( /*[in]*/ Button*  bt   );
    HRESULT Fire_onCommand( /*[in]*/ UINT_PTR iCmd );

    ////////////////////////////////////////

    HRESULT OnTooltipRequest ( int idCtrl, LPNMTBGETINFOTIPW tool );
    HRESULT OnDispInfoRequest( int idCtrl, LPNMTBDISPINFOW   info );
    HRESULT OnDropDown       ( int idCtrl, LPNMTOOLBAR       tool );
	HRESULT OnChevron        ( int idCtrl, LPNMREBARCHEVRON  chev );

	void UpdateSize();

	void    Config_Clear();
	HRESULT Config_Load ();

	HRESULT Toolbar_Create();
	HRESULT Rebar_Create  ();
	HRESULT Rebar_AddBand ();

public:
DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CPCHToolBar)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPCHToolBar)
    COM_INTERFACE_ENTRY(IPCHToolBar)
    COM_INTERFACE_ENTRY2(IDispatch, IPCHToolBar)
    COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObject2)
    COM_INTERFACE_ENTRY(IViewObject)
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IPersistPropertyBag)
    COM_INTERFACE_ENTRY2(IPersist, IPersistPropertyBag)
    COM_INTERFACE_ENTRY(IPCHToolBarPrivate)
END_COM_MAP()

BEGIN_PROP_MAP(CPCHToolBar)
	PROP_ENTRY("Definition", DISPID_PCH_TB__DEFINITION, CLSID_NULL)
END_PROP_MAP()

    CPCHToolBar();
    virtual ~CPCHToolBar();

    BOOL ProcessWindowMessage( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult, DWORD dwMsgMapID = 0 );

	BOOL ProcessAccessKey( UINT uMsg, WPARAM wParam, LPARAM lParam );

    BOOL PreTranslateAccelerator( LPMSG pMsg, HRESULT& hRet );

// IViewObjectEx
    DECLARE_VIEW_STATUS(0)

// IOleObject
    STDMETHOD(SetClientSite)(IOleClientSite *pClientSite);
    STDMETHOD(GetExtent    )(DWORD dwDrawAspect, SIZEL *psizel);

// IPCHToolBar
public:
    STDMETHOD(get_Definition)( /*[out, retval]*/ BSTR 	 *  pVal );
    STDMETHOD(put_Definition)( /*[in         ]*/ BSTR 	  newVal );
    STDMETHOD(get_Mode	    )( /*[out, retval]*/ TB_MODE *  pVal );
    STDMETHOD(put_Mode	    )( /*[in         ]*/ TB_MODE  newVal );

    STDMETHOD(SetState     )( /*[in]*/ BSTR bstrText, /*[in]*/ VARIANT_BOOL fEnabled );
    STDMETHOD(SetVisibility)( /*[in]*/ BSTR bstrText, /*[in]*/ VARIANT_BOOL fVisible );

// IPCHToolBarPrivate
public:
    STDMETHOD(SameObject)( /*[in]*/ IPCHToolBar* ptr ) { return this == ptr ? S_OK : E_FAIL; }

	HRESULT FindElementThroughThunking( /*[out]*/ CComPtr<IHTMLElement>& elem );
};

/////////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___PCH___HTMLTOOLBAR_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\include\helpcenter.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    HelpCenter.h

Abstract:
    This file contains the declaration of the class used to implement
    the Help Center Application.

Revision History:
    Sridhar Chandrashekar   (SridharC)  07/21/99
        created

******************************************************************************/

#if !defined(__INCLUDED___PCH___HELPCENTER_H___)
#define __INCLUDED___PCH___HELPCENTER_H___

#include <atlcom.h>
#include <atlwin.h>
#include <atlhost.h>
#include <atlctl.h>

#include <exdisp.h>
#include <exdispid.h>

#include <HelpCenterExternal.h>

#include <shobjidl.h>
#include <marscore.h>

#include <ScriptingFrameworkDID.h>

#include <Perhist.h>

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHBootstrapper : // Hungarian: hcpbs
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public CComCoClass<CPCHBootstrapper, &CLSID_PCHBootstrapper>,
    public IObjectWithSite,
    public IObjectSafety
{
    CComPtr<IUnknown> m_spUnkSite;
    CComPtr<IUnknown> m_parent;

    ////////////////////

    static HRESULT ForwardQueryInterface( void* pv, REFIID iid, void** ppvObject, DWORD_PTR offset );

public:
DECLARE_NO_REGISTRY()

BEGIN_COM_MAP(CPCHBootstrapper)
    COM_INTERFACE_ENTRY(IObjectWithSite)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC_BLIND(0, ForwardQueryInterface)
END_COM_MAP()

    //
    // IObjectWithSite
    //
    STDMETHOD(SetSite)(IUnknown *pUnkSite);
    STDMETHOD(GetSite)(REFIID riid, void **ppvSite);

    //
    // IObjectSafety
    //
    STDMETHOD(GetInterfaceSafetyOptions)( /*[in ]*/ REFIID  riid                ,  // Interface that we want options for
                                          /*[out]*/ DWORD  *pdwSupportedOptions ,  // Options meaningful on this interface
                                          /*[out]*/ DWORD  *pdwEnabledOptions   ); // current option values on this interface

    STDMETHOD(SetInterfaceSafetyOptions)( /*[in]*/ REFIID riid             ,  // Interface to set options for
										  /*[in]*/ DWORD  dwOptionSetMask  ,  // Options to change
										  /*[in]*/ DWORD  dwEnabledOptions ); // New option values
};

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHMarsHost : // Hungarian: hcpmh
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public IMarsHost
{
    CPCHHelpCenterExternal* m_parent;
    MPC::wstring            m_strTitle;
	MPC::wstring            m_strCmdLine;
    MARSTHREADPARAM         m_mtp;

public:
BEGIN_COM_MAP(CPCHMarsHost)
    COM_INTERFACE_ENTRY(IMarsHost)
END_COM_MAP()

    CPCHMarsHost();

    //////////////////////////////////////////////////////////////////////

    HRESULT Init( /*[in]*/ CPCHHelpCenterExternal* parent, /*[in]*/ const MPC::wstring& szTitle, /*[out]*/ MARSTHREADPARAM*& pMTP );

    //
    // IMarsHost
    //
    STDMETHOD(OnHostNotify)( /*[in]*/ MARSHOSTEVENT event, /*[in]*/ IUnknown *punk, /*[in]*/ LPARAM lParam );

    STDMETHOD(PreTranslateMessage)( /*[in]*/ MSG* msg );
};

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHScriptableStream : // Hungarian: pchss
    public MPC::FileStream,
    public IDispatchImpl<IPCHScriptableStream, &IID_IPCHScriptableStream, &LIBID_HelpCenterTypeLib>
{
    HRESULT ReadToHGLOBAL( /*[in]*/ long lCount, /*[out]*/ HGLOBAL& hg, /*[out]*/ ULONG& lReadTotal );

public:
BEGIN_COM_MAP(CPCHScriptableStream)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHScriptableStream)
    COM_INTERFACE_ENTRY_CHAIN(MPC::FileStream)
END_COM_MAP()

    //////////////////////////////////////////////////////////////////////

    // IPCHScriptableStream
    STDMETHOD(get_Size)( /*[out, retval]*/ long *plSize );

    STDMETHOD(Read    )( /*[in]*/ long lCount , /*[out, retval]*/ VARIANT *   pvData                                      );
    STDMETHOD(ReadHex )( /*[in]*/ long lCount , /*[out, retval]*/ BSTR    *pbstrData                                      );

    STDMETHOD(Write   )( /*[in]*/ long lCount , /*[in         ]*/ VARIANT      vData  , /*[out, retval]*/ long *plWritten );
    STDMETHOD(WriteHex)( /*[in]*/ long lCount , /*[in         ]*/ BSTR      bstrData  , /*[out, retval]*/ long *plWritten );

    STDMETHOD(Seek    )( /*[in]*/ long lOffset, /*[in         ]*/ BSTR      bstrOrigin, /*[out, retval]*/ long *plNewPos  );
    STDMETHOD(Close   )(                                                                                                  );
};

/////////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___PCH___HELPCENTER_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\include\makefile.inc ===
$(O)\HelpCenterInterfaces_i.c : $(LOCALLIBPATH)\HelpCenterTypeLib_i.c
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\include\mpc_html2.h ===
/******************************************************************************

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:
    MPC_html2.h

Abstract:
    This file contains the declaration of various functions and classes
    designed to help the handling of HTML elements.

Revision History:
    Davide Massarenti   (Dmassare)  18/03/2001
        created

******************************************************************************/

#if !defined(__INCLUDED___MPC___HTML2_H___)
#define __INCLUDED___MPC___HTML2_H___

#include <MPC_html.h>

/////////////////////////////////////////////////////////////////////////

namespace MPC
{
    namespace HTML
    {

        HRESULT OpenStream    ( /*[in]*/ LPCWSTR szBaseURL, /*[in]*/ LPCWSTR szRelativeURL, /*[out]*/ CComPtr<IStream>& stream               );
        HRESULT DownloadBitmap( /*[in]*/ LPCWSTR szBaseURL, /*[in]*/ LPCWSTR szRelativeURL, /*[in]*/ COLORREF crMask, /*[out]*/ HBITMAP& hbm );

    }; // namespace HTML

}; // namespace MPC

/////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHTextHelpers : // Hungarian: pchth
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public IDispatchImpl<IPCHTextHelpers, &IID_IPCHTextHelpers, &LIBID_HelpCenterTypeLib>
{
public:
BEGIN_COM_MAP(CPCHTextHelpers)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHTextHelpers)
END_COM_MAP()

    ////////////////////////////////////////////////////////////////////////////////

public:
    // IPCHTextHelpers
    STDMETHOD(QuoteEscape)( /*[in]*/ BSTR bstrText, /*[in,optional]*/ VARIANT vQuote        , /*[out, retval]*/ BSTR *pVal );
    STDMETHOD(URLUnescape)( /*[in]*/ BSTR bstrText, /*[in,optional]*/ VARIANT vAsQueryString, /*[out, retval]*/ BSTR *pVal );
    STDMETHOD(URLEscape  )( /*[in]*/ BSTR bstrText, /*[in,optional]*/ VARIANT vAsQueryString, /*[out, retval]*/ BSTR *pVal );
    STDMETHOD(HTMLEscape )( /*[in]*/ BSTR bstrText,                                           /*[out, retval]*/ BSTR *pVal );

    STDMETHOD(ParseURL            )( /*[in]*/ BSTR bstrURL, /*[out, retval]*/ IPCHParsedURL* *pVal );
    STDMETHOD(GetLCIDDisplayString)( /*[in]*/ long lLCID  , /*[out, retval]*/ BSTR           *pVal );
};

class ATL_NO_VTABLE CPCHParsedURL : // Hungarian: pchpu
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public IDispatchImpl<IPCHParsedURL, &IID_IPCHParsedURL, &LIBID_HelpCenterTypeLib>
{
	MPC::wstring       m_strBaseURL;
	MPC::WStringLookup m_mapQuery;

public:
BEGIN_COM_MAP(CPCHParsedURL)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHParsedURL)
END_COM_MAP()

	HRESULT Initialize( /*[in]*/ LPCWSTR szURL );

    ////////////////////////////////////////////////////////////////////////////////

public:
    // IPCHParsedURL
    STDMETHOD(get_BasePart		 )( /*[out, retval]*/ BSTR 	  *  pVal );
    STDMETHOD(put_BasePart		 )( /*[in         ]*/ BSTR 	   newVal );
    STDMETHOD(get_QueryParameters)( /*[out, retval]*/ VARIANT *  pVal );

    STDMETHOD(GetQueryParameter   )( /*[in]*/ BSTR bstrName, /*[out, retval]*/ VARIANT*   pvValue );
    STDMETHOD(SetQueryParameter   )( /*[in]*/ BSTR bstrName, /*[in         ]*/ BSTR     bstrValue );
    STDMETHOD(DeleteQueryParameter)( /*[in]*/ BSTR bstrName                                       );

    STDMETHOD(BuildFullURL)( /*[out, retval]*/ BSTR *pVal );
};

////////////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___MPC___HTML2_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\include\hyperlinkslib.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    HyperLinksLib.h

Abstract:
    This file contains the declaration of the HyperLinks library of classes.

Revision History:
    Davide Massarenti   (Dmassare)  11/28/2000
        created

******************************************************************************/

#if !defined(__INCLUDED___PCH___HYPERLINKSLIB_H___)
#define __INCLUDED___PCH___HYPERLINKSLIB_H___

#include <MPC_COM.h>
#include <MPC_Utils.h>
#include <MPC_HTML.h>

////////////////////////////////////////////////////////////////////////////////

namespace HyperLinks
{
    typedef enum
    {
        FMT_INVALID            ,

        FMT_INTERNET_UNKNOWN   ,
        FMT_INTERNET_FTP       , // InternetCrackUrl returned INTERNET_SCHEME_FTP
        FMT_INTERNET_GOPHER    , // InternetCrackUrl returned INTERNET_SCHEME_GOPHER
        FMT_INTERNET_HTTP      , // InternetCrackUrl returned INTERNET_SCHEME_HTTP
        FMT_INTERNET_HTTPS     , // InternetCrackUrl returned INTERNET_SCHEME_HTTPS
        FMT_INTERNET_FILE      , // InternetCrackUrl returned INTERNET_SCHEME_FILE
        FMT_INTERNET_NEWS      , // InternetCrackUrl returned INTERNET_SCHEME_NEWS
        FMT_INTERNET_MAILTO    , // InternetCrackUrl returned INTERNET_SCHEME_MAILTO
        FMT_INTERNET_SOCKS     , // InternetCrackUrl returned INTERNET_SCHEME_SOCKS
        FMT_INTERNET_JAVASCRIPT, // InternetCrackUrl returned INTERNET_SCHEME_JAVASCRIPT
        FMT_INTERNET_VBSCRIPT  , // InternetCrackUrl returned INTERNET_SCHEME_VBSCRIPT

        FMT_HCP                , // hcp://<something>
        FMT_HCP_REDIR          , // hcp:<something>
        FMT_MSITS              , // ms-its:<file name>::/<stream name>

        FMT_CENTER_HOMEPAGE    , // hcp://services/centers/homepage
        FMT_CENTER_SUPPORT     , // hcp://services/centers/support
        FMT_CENTER_OPTIONS     , // hcp://services/centers/options
        FMT_CENTER_UPDATE      , // hcp://services/centers/update
        FMT_CENTER_COMPAT      , // hcp://services/centers/compat
        FMT_CENTER_TOOLS       , // hcp://services/centers/tools
        FMT_CENTER_ERRMSG      , // hcp://services/centers/errmsg

        FMT_SEARCH             , // hcp://services/search?query=<text to look up>
        FMT_INDEX              , // hcp://services/index?application=<optional island of help ID>
        FMT_SUBSITE            , // hcp://services/subsite?node=<subsite location>&topic=<url of the topic to display>&select=<subnode to highlight>

        FMT_LAYOUT_FULLWINDOW  , // hcp://services/layout/fullwindow?topic=<url of the topic to display>
        FMT_LAYOUT_CONTENTONLY , // hcp://services/layout/contentonly?topic=<url of the topic to display>
        FMT_LAYOUT_KIOSK       , // hcp://services/layout/kiosk?topic=<url of the topic to display>
        FMT_LAYOUT_XML         , // hcp://services/layout/xml?definition=<url of the layout definition>&topic=<url of the topic to display>

        FMT_REDIRECT           , // hcp://services/redirect?online=<url>&offline=<backup url>

        FMT_APPLICATION        , // app:<application to launch>?arg=<optional arguments>&topic=<url of optional topic to display>

        FMT_RESOURCE           , // res://<file path>/<resource name>

    } Format;

    typedef enum
    {
        STATE_INVALID     ,
        STATE_NOTPROCESSED,
        STATE_CHECKING    ,
        STATE_MALFORMED   ,
        STATE_ALIVE       ,
        STATE_NOTFOUND    ,
        STATE_UNREACHABLE ,
        STATE_OFFLINE     ,
    } State;

    ////////////////////

    struct ParsedUrl
    {
        MPC::wstring       m_strURL;
        Format             m_fmt;
        State              m_state;
        DATE               m_dLastChecked;
        bool               m_fBackground;

        MPC::wstring       m_strBasePart;
        MPC::WStringLookup m_mapQuery;

        bool			   m_hcpRedir;

        ////////////////////

        ParsedUrl();

        HRESULT Initialize( /*[in]*/ LPCWSTR szURL );

        bool  IsLocal      (                                     );
        State CheckState   ( /*[in/out]*/ bool& fFirstWinInetUse );
        bool  IsOkToProceed(                                     );

        bool HasQueryField( /*[in]*/ LPCWSTR szField                               );
        bool GetQueryField( /*[in]*/ LPCWSTR szField, /*[in]*/ CComBSTR& bstrValue );
    };

    class UrlHandle
    {
        friend class Lookup;

        Lookup*    m_main; // We have a lock on it.
        ParsedUrl* m_pu;

        void Attach( /*[in]*/ Lookup* main, /*[in]*/ ParsedUrl* pu );

    public:
        UrlHandle();
        ~UrlHandle();

        void Release();

        operator ParsedUrl*()   { return m_pu; }
        ParsedUrl* operator->() { return m_pu; }
    };

    class Lookup :
        public CComObjectRootEx<MPC::CComSafeMultiThreadModel>, // For locking...
        public MPC::Thread< Lookup, IUnknown >
    {
        typedef std::list<ParsedUrl*>              PendingUrlList;
        typedef PendingUrlList::iterator           PendingUrlIter;
        typedef PendingUrlList::const_iterator     PendingUrlIterConst;

        typedef std::map<MPC::wstringUC,ParsedUrl> UrlMap;
        typedef UrlMap::iterator                   UrlIter;
        typedef UrlMap::const_iterator             UrlIterConst;

        PendingUrlList m_lst;
        UrlMap         m_map;

        HRESULT RunChecker();

        HRESULT CreateItem( /*[in]*/ LPCWSTR szURL, /*[out]*/ ParsedUrl*& pu );

    public:
        Lookup();
        ~Lookup();

        ////////////////////////////////////////////////////////////////////////////////

        static Lookup* s_GLOBAL;

        static HRESULT InitializeSystem();
        static void    FinalizeSystem  ();

        ////////////////////////////////////////////////////////////////////////////////

        HRESULT Queue( /*[in]*/ LPCWSTR szURL                                                                                          );
        HRESULT Get  ( /*[in]*/ LPCWSTR szURL, /*[in]*/ UrlHandle& uh, /*[in]*/ DWORD dwWaitForCheck = 0, /*[in]*/ bool fForce = false );
    };

    HRESULT IsValid( /*[in/out]*/ LPCWSTR szURL );
};

////////////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___PCH___HYPERLINKSLIB_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\include\helpviewerwrapper.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    HelpViewerWrapper.h

Abstract:
    This file contains the declaration of the class used to wrap the HTML Help Viewer.

Revision History:
    Davide Massarenti   (dmassare)  01/20/2000
        created

******************************************************************************/

#if !defined(__INCLUDED___PCH___HELPVIEWERWRAPPER_H___)
#define __INCLUDED___PCH___HELPVIEWERWRAPPER_H___

#include <HelpCenter.h>

#include <htmlhelp.h>

#include <oleacc.h>


#define ID_NOTIFY_FROM_HH (12345)
#define WINDOW_STYLE      "HCStyle"


class ATL_NO_VTABLE CPCHHelpViewerWrapper :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CStockPropImpl                 <CPCHHelpViewerWrapper, IPCHHelpViewerWrapper, &IID_IPCHHelpViewerWrapper, &LIBID_HelpCenterTypeLib>,
    public CComControl                    <CPCHHelpViewerWrapper>,
    public IPersistStreamInitImpl         <CPCHHelpViewerWrapper>,
    public IOleControlImpl                <CPCHHelpViewerWrapper>,
    public IOleObjectImpl                 <CPCHHelpViewerWrapper>,
    public IOleInPlaceActiveObjectImpl    <CPCHHelpViewerWrapper>,
    public IViewObjectExImpl              <CPCHHelpViewerWrapper>,
    public IOleInPlaceObjectWindowlessImpl<CPCHHelpViewerWrapper>,
    public CComCoClass                    <CPCHHelpViewerWrapper, &CLSID_PCHHelpViewerWrapper>
{
    static MPC::CComSafeAutoCriticalSection s_csec;
    static bool                    			s_fInitialized;
    static DWORD                   			s_dwLastStyle;
    static MPC::WStringList        			s_lstAvailable;

    //
    // This is the OLEACC stuff used to access the WebBrowser object inside the HTMLHelp viewer.
    //
    static HINSTANCE               s_hInst;
    static LPFNOBJECTFROMLRESULT   s_pfObjectFromLresult;

    ////////////////////////////////////////

    class ATL_NO_VTABLE ServiceProvider :
        public CComObjectRootEx<CComSingleThreadModel>,
        public IServiceProvider
    {
        CPCHHelpCenterExternal* m_parent;
		HWND                    m_hWnd;

    public:
    BEGIN_COM_MAP(ServiceProvider)
        COM_INTERFACE_ENTRY(IServiceProvider)
    END_COM_MAP()

        ServiceProvider();
        virtual ~ServiceProvider();

        HRESULT Attach( /*[in]*/ CPCHHelpCenterExternal* parent, /*[in]*/ HWND hWnd );
        void    Detach(                                                             );

        //
        // IServiceProvider
        //
        STDMETHOD(QueryService)( REFGUID guidService, REFIID riid, void **ppv );
    };

    ////////////////////////////////////////

    CPCHHelpCenterExternal*          		m_parent;
	CPCHHelpViewerWrapper::ServiceProvider* m_ServiceProvider;

    bool                           	 		m_fFirstTime;
    MPC::wstring                   	 		m_szWindowStyle;
    HWND                           	 		m_hwndHH;
  		 
    CComPtr<IHTMLDocument2>        	 		m_spDoc;
    CComPtr<IWebBrowser2>          	 		m_WB2;
	CComBSTR                         		m_bstrPendingNavigation;

    ////////////////////////////////////////

    void AcquireWindowStyle();
    void ReleaseWindowStyle();
    void ExtractWebBrowser();

    void InternalDisplayTopic( /*[in]*/ LPCWSTR szURL );


public:
DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CPCHHelpViewerWrapper)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPCHHelpViewerWrapper)
    COM_INTERFACE_ENTRY(IPCHHelpViewerWrapper)
    COM_INTERFACE_ENTRY2(IDispatch, IPCHHelpViewerWrapper)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObject2)
    COM_INTERFACE_ENTRY(IViewObject)
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
END_COM_MAP()

BEGIN_PROP_MAP(CPCHHelpViewerWrapper)
END_PROP_MAP()

    CPCHHelpViewerWrapper();
    virtual ~CPCHHelpViewerWrapper();

	BOOL ProcessWindowMessage( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult, DWORD dwMsgMapID = 0 );

    BOOL PreTranslateAccelerator( LPMSG pMsg, HRESULT& hRet );

// IViewObjectEx
    DECLARE_VIEW_STATUS(0)

// IOleObject
    STDMETHOD(SetClientSite)(IOleClientSite *pClientSite);

// IPCHHelpViewerWrapper
public:
	STDMETHOD(get_WebBrowser)( /*[out,retval]*/ IUnknown* *pVal );

    STDMETHOD(Navigate)( /*[in]*/ BSTR bstrURL );
    STDMETHOD(Print   )(                       );
};

/////////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___PCH___HELPVIEWERWRAPPER_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\include\namespace_impl.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    NameSpace_Impl.h

Abstract:
    This file contains the declaration of the classes used to implement the
    pluggable protocol: CHCPProtocol, CHCPProtocolInfo and CHCPBindStatusCallback.

Revision History:
    Davide Massarenti   (Dmassare)  07/05/99
        created
    Davide Massarenti   (Dmassare)  07/23/99
        moved to "include"

******************************************************************************/

#if !defined(__INCLUDED___HCP___NAMESPACE_H___)
#define __INCLUDED___HCP___NAMESPACE_H___

#include <MPC_utils.h>
#include <MPC_streams.h>

#include <TaxonomyDatabase.h>

/////////////////////////////////////////////////////////////////////////////

extern bool  g_Debug_BLOCKERRORS;
extern bool  g_Debug_CONTEXTMENU;
extern bool  g_Debug_BUILDTREE;
extern WCHAR g_Debug_FORCESTYLE[];

////////////////////////////////////////////////////////////////////////////////

#ifdef DEBUG_PROTOCOLLEAK

#include <set>

class CHCPProtocol;

class DEBUG_ProtocolLeak
{
    typedef std::set<CHCPProtocol*> Set;
    typedef Set::iterator           Iter;
    typedef Set::const_iterator     IterConst;

    Set m_set;
    Set m_setStart;
    Set m_setComplete;
    int m_num;
    int m_numOut;
    int m_numStart;
    int m_numComplete;

public:
    DEBUG_ProtocolLeak();
    ~DEBUG_ProtocolLeak();

    void Add( CHCPProtocol* ptr );
    void Del( CHCPProtocol* ptr );

    void CheckStart( CHCPProtocol* ptr );
    void Completed ( CHCPProtocol* ptr );
};

#endif

/////////////////////////////////////////////////////////////////////////////

class CHCPBindStatusCallback;

/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE ISimpleBindStatusCallback : public IUnknown
{
public:
    STDMETHOD(ForwardQueryInterface)( REFIID riid, void** ppv );

    STDMETHOD(GetBindInfo)( BINDINFO *pbindInfo );

    STDMETHOD(PreBindMoniker)( IBindCtx* pBindCtx, IMoniker* pMoniker );

    STDMETHOD(OnProgress)( ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText );

    STDMETHOD(OnData)( CHCPBindStatusCallback* pbsc, BYTE* pBytes, DWORD dwSize, DWORD grfBSCF, FORMATETC *pformatetc, STGMEDIUM *pstgmed );

    STDMETHOD(OnBindingFailure)( HRESULT hr, LPCWSTR szError );
};

class ATL_NO_VTABLE CHCPBindStatusCallback : // Hungarian: bscb
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public IBindStatusCallback,
    public IHttpNegotiate
{
    CComPtr<ISimpleBindStatusCallback> m_pT;
    DWORD                              m_dwTotalRead;
    DWORD                              m_dwAvailableToRead;

    CComPtr<IMoniker>                  m_spMoniker;
    CComPtr<IBindCtx>                  m_spBindCtx;
    CComPtr<IBinding>                  m_spBinding;
    CComPtr<IStream>                   m_spStream;

public:

BEGIN_COM_MAP(CHCPBindStatusCallback)
    COM_INTERFACE_ENTRY(IBindStatusCallback)
    COM_INTERFACE_ENTRY(IHttpNegotiate)
    //  COM_INTERFACE_ENTRY_FUNC_BLIND(0,TestQuery)
    //  COM_INTERFACE_ENTRY(IServiceProvider)
END_COM_MAP()

    CHCPBindStatusCallback();
    virtual ~CHCPBindStatusCallback();

    //static HRESULT TestQuery( void* pv, REFIID iid, void** ppvObject, DWORD dw )
    //{
    //    *ppvObject = NULL;
    //    return E_NOINTERFACE;
    //}

    /////////////////////////////////////////////////////////////////////////////
    // IBindStatusCallback
    STDMETHOD(OnStartBinding)( DWORD     dwReserved ,
                               IBinding *pBinding   );

    STDMETHOD(GetPriority)( LONG *pnPriority );

    STDMETHOD(OnLowResource)( DWORD reserved );

    STDMETHOD(OnProgress)( ULONG   ulProgress    ,
                           ULONG   ulProgressMax ,
                           ULONG   ulStatusCode  ,
                           LPCWSTR szStatusText  );

    STDMETHOD(OnStopBinding)( HRESULT hresult ,
                              LPCWSTR szError );

    STDMETHOD(GetBindInfo)( DWORD    *pgrfBINDF ,
                            BINDINFO *pbindInfo );

    STDMETHOD(OnDataAvailable)( DWORD      grfBSCF    ,
                                DWORD      dwSize     ,
                                FORMATETC *pformatetc ,
                                STGMEDIUM *pstgmed    );

    STDMETHOD(OnObjectAvailable)( REFIID    riid ,
                                  IUnknown *punk );

    /////////////////////////////////////////////////////////////////////////////
    // IHttpNegotiate
    STDMETHOD(BeginningTransaction)( LPCWSTR  szURL                ,
                                     LPCWSTR  szHeaders            ,
                                     DWORD    dwReserved           ,
                                     LPWSTR  *pszAdditionalHeaders );

    STDMETHOD(OnResponse)( DWORD    dwResponseCode              ,
                           LPCWSTR  szResponseHeaders           ,
                           LPCWSTR  szRequestHeaders            ,
                           LPWSTR  *pszAdditionalRequestHeaders );

    /////////////////////////////////////////////////////////////////////////////

    HRESULT StartAsyncDownload( ISimpleBindStatusCallback* pT, BSTR bstrURL, IUnknown* pUnkContainer = NULL, BOOL bRelative = FALSE );

    HRESULT Abort();
};

/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CHCPProtocol :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CHCPProtocol>,
    public ISimpleBindStatusCallback,
    public IInternetProtocol,
	public IWinInetInfo
{
#ifdef DEBUG
    friend class DEBUG_ProtocolLeak;
#endif

    typedef CComObject< CHCPBindStatusCallback > InnerDownloader;


    bool                           	m_fDone;                     // Indicates whether we've received LASTDATANOTIFICATION yet
    bool                           	m_fReportResult;             // Indicates whether we've called ReportResult on the sink.
                                   								 //
    DWORD                          	m_cbAvailableSize;           // Amount of data received up to now.
    DWORD                          	m_cbTotalSize;               // Total number of bytes to be expected. For redirected requests,
                                   								 // it comes from "ulProgressMax" parm to OnProgress for BEGINDOWNLOADDATA
                                   								 //
    CComPtr<IStream>               	m_pstrmRead;                 // Streams used for redirected request. We use two stream pointers to allow
    CComPtr<IStream>               	m_pstrmWrite;                // concurrent access to the same bits from two seek ptrs.
                                   								 //
    CComPtr<IInternetProtocolSink> 	m_pIProtSink;                // Sink interface through which we should report progress.
    CComPtr<IInternetBindInfo>     	m_pIBindInfo;                // BindInfo interface used to get info about the binding.
    DWORD                          	m_grfSTI;                    // STI flags handed to us
    BINDINFO                       	m_bindinfo;                  // From m_pIBindInfo
    DWORD                          	m_bindf;                     // From m_pIBindInfo
                                   								 //
    CComBSTR                       	m_bstrUrlComplete;           // The complete URL requested.
    CComBSTR                       	m_bstrUrlRedirected;         // The part that has been used as a redirection.
    InnerDownloader*                m_pDownloader;               // The object that performs the redirection.
                                   								 //
    bool                           	m_fRedirected;               // The request has been redirected.
    bool                           	m_fCSS;                      // The request has been redirected.
    bool                           	m_fBypass;                   // The request has been sent to ms-its, with a bypass.
                                   								 //
    CComPtr<IInternetProtocol>     	m_ipiBypass;                 // Aggregated object.
                                   								 //
    CComBSTR                       	m_bstrMimeType;              // Type of the content.
    DWORD                          	m_dwContentLength;           // Length of the page.
                                   								 //
    HANDLE                         	m_hCache;                    // Handle for the cache entry.
    WCHAR                          	m_szCacheFileName[MAX_PATH]; // Name of the file inside the cache.

    ////////////////////////////////////////////////////////////////////////////////

    HRESULT InnerReportProgress( /*[in]*/ ULONG ulStatusCode, /*[in]*/ LPCWSTR szStatusText );

    HRESULT InnerReportData( /*[in]*/ DWORD grfBSCF, /*[in]*/ ULONG ulProgress, /*[in]*/ ULONG ulProgressMax );

    HRESULT InnerReportResult( /*[in]*/ HRESULT hrResult, /*[in]*/ DWORD dwError, /*[in]*/ LPCWSTR szResult );

public:
DECLARE_NO_REGISTRY()

BEGIN_COM_MAP(CHCPProtocol)
    COM_INTERFACE_ENTRY(IInternetProtocol    )
    COM_INTERFACE_ENTRY(IInternetProtocolRoot)
    COM_INTERFACE_ENTRY(IWinInetInfo)
END_COM_MAP()

    CHCPProtocol();
    virtual ~CHCPProtocol();

    ////////////////////////////////////////////////////////////////////////////////

    bool OpenCacheEntry (                                           );
    void WriteCacheEntry( /*[in]*/ void *pv, /*[in]*/ ULONG  cbRead );
    void CloseCacheEntry( /*[in]*/ bool fDelete                     );

    ////////////////////////////////////////////////////////////////////////////////

    void Shutdown( /*[in]*/ bool fAll = true );

    /////////////////////////////////////////////////////////////////////////////
    // IInternetProtocol interface
    STDMETHOD(Start)( LPCWSTR                szUrl      ,
                      IInternetProtocolSink *pIProtSink ,
                      IInternetBindInfo     *pIBindInfo ,
                      DWORD                  grfSTI     ,
                      HANDLE_PTR             dwReserved );

    STDMETHOD(Continue)( PROTOCOLDATA *pStateInfo );

    STDMETHOD(Abort    )( HRESULT hrReason, DWORD dwOptions );
    STDMETHOD(Terminate)(                   DWORD dwOptions );
    STDMETHOD(Suspend  )(                                   );
    STDMETHOD(Resume   )(                                   );

    STDMETHOD(Read)( void *pv, ULONG cb, ULONG *pcbRead                                      );
    STDMETHOD(Seek)( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition );

    STDMETHOD(LockRequest  )( DWORD dwOptions );
    STDMETHOD(UnlockRequest)(                 );


    /////////////////////////////////////////////////////////////////////////////
    // IWinInetInfo interface
    STDMETHOD(QueryOption)( DWORD dwOption, LPVOID pBuffer, DWORD *pcbBuf );

public:
    HRESULT DoParse( /*[in]*/ LPCWSTR wstr );
    HRESULT DoBind();

    HRESULT DoBind_Exists( /*[in] */ MPC::FileSystemObject& fso, /*[out]*/ bool& fFound, /*[out]*/ bool& fIsAFile );

    HRESULT DoBind_Redirect_UrlMoniker();
    HRESULT DoBind_Redirect_MSITS     ();
    HRESULT DoBind_CSS                ();
    HRESULT DoBind_File               ();
    HRESULT DoBind_ReturnData         ( /*[in]*/ bool fCloneStream, /*[in]*/ LPCWSTR szMimeType );

    /////////////////////////////////////////////////////////////////////////////
    // ISimpleBindStatusCallback
    STDMETHOD(ForwardQueryInterface)( REFIID riid, void** ppv );

    STDMETHOD(GetBindInfo)( BINDINFO *pbindInfo );

    STDMETHOD(PreBindMoniker)( IBindCtx* pBindCtx, IMoniker* pMoniker );

    STDMETHOD(OnBindingFailure)( HRESULT hr, LPCWSTR szError );

    STDMETHOD(OnProgress)( ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText );

    STDMETHOD(OnData)( CHCPBindStatusCallback* pbsc, BYTE* pBytes, DWORD dwSize, DWORD grfBSCF, FORMATETC *pformatetc, STGMEDIUM *pstgmed );

    /////////////////////////////////////////////////////////////////////////////
    static bool IsHCPRedirection(LPCWSTR szURL);
};

/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CHCPProtocolInfo :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IClassFactory,
    public IInternetProtocolInfo
{
public:

DECLARE_NO_REGISTRY()

BEGIN_COM_MAP(CHCPProtocolInfo)
    COM_INTERFACE_ENTRY(IClassFactory)
    COM_INTERFACE_ENTRY(IInternetProtocolInfo)
END_COM_MAP()

    CHCPProtocolInfo();
    virtual ~CHCPProtocolInfo();


    // IClassFactory interface
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj);
    STDMETHOD(LockServer)(BOOL fLock);


    // IInternetProtocolInfo interface
    STDMETHOD(ParseUrl)( LPCWSTR      pwzUrl      ,
                         PARSEACTION  ParseAction ,
                         DWORD        dwParseFlags,
                         LPWSTR       pwzResult   ,
                         DWORD        cchResult   ,
                         DWORD       *pcchResult  ,
                         DWORD        dwReserved  );

    STDMETHOD(CombineUrl)( LPCWSTR pwzBaseUrl    ,
                           LPCWSTR pwzRelativeUrl,
                           DWORD   dwCombineFlags,
                           LPWSTR  pwzResult     ,
                           DWORD   cchResult     ,
                           DWORD  *pcchResult    ,
                           DWORD   dwReserved    );

    STDMETHOD(CompareUrl)( LPCWSTR pwzUrl1        ,
                           LPCWSTR pwzUrl2        ,
                           DWORD   dwCompareFlags );

    STDMETHOD(QueryInfo)( LPCWSTR      pwzUrl      ,
                          QUERYOPTION  QueryOption ,
                          DWORD        dwQueryFlags,
                          LPVOID       pBuffer     ,
                          DWORD        cbBuffer    ,
                          DWORD       *pcbBuf      ,
                          DWORD        dwReserved  );

    /////////////////////////////////////////////////////////////////////////////

    static bool LookForHCP( LPCWSTR pwzUrl, bool& fRedirect, LPCWSTR& pwzRedirect );
};

/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHWrapProtocolInfo :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IClassFactory,
    public IInternetProtocolInfo
{
    CComPtr<IClassFactory>         m_realClass;
    CComPtr<IInternetProtocolInfo> m_realInfo;

	static void ExpandAndConcat( /*[out]*/ CComBSTR& bstrStorageName, /*[in]*/ LPCWSTR szVariable, /*[in]*/ LPCWSTR szAppend );

public:
DECLARE_NO_REGISTRY()

BEGIN_COM_MAP(CHCPProtocolInfo)
    COM_INTERFACE_ENTRY(IClassFactory)
    COM_INTERFACE_ENTRY(IInternetProtocolInfo)
END_COM_MAP()

    CPCHWrapProtocolInfo();
    virtual ~CPCHWrapProtocolInfo();

    HRESULT Init( REFGUID realClass );

	////////////////////

	static void NormalizeUrl( /*[in]*/ LPCWSTR pwzUrl, /*[out]*/ MPC::wstring& strUrlModified, /*[in]*/ bool fReverse );

	////////////////////

    // IClassFactory interface
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj);
    STDMETHOD(LockServer)(BOOL fLock);


    // IInternetProtocolInfo interface
    STDMETHOD(ParseUrl)( LPCWSTR      pwzUrl      ,
                         PARSEACTION  ParseAction ,
                         DWORD        dwParseFlags,
                         LPWSTR       pwzResult   ,
                         DWORD        cchResult   ,
                         DWORD       *pcchResult  ,
                         DWORD        dwReserved  );

    STDMETHOD(CombineUrl)( LPCWSTR pwzBaseUrl    ,
                           LPCWSTR pwzRelativeUrl,
                           DWORD   dwCombineFlags,
                           LPWSTR  pwzResult     ,
                           DWORD   cchResult     ,
                           DWORD  *pcchResult    ,
                           DWORD   dwReserved    );

    STDMETHOD(CompareUrl)( LPCWSTR pwzUrl1        ,
                           LPCWSTR pwzUrl2        ,
                           DWORD   dwCompareFlags );

    STDMETHOD(QueryInfo)( LPCWSTR      pwzUrl      ,
                          QUERYOPTION  QueryOption ,
                          DWORD        dwQueryFlags,
                          LPVOID       pBuffer     ,
                          DWORD        cbBuffer    ,
                          DWORD       *pcbBuf      ,
                          DWORD        dwReserved  );
};

////////////////////////////////////////////////////////////////////////////////

class CHCPProtocolEnvironment
{
    bool     		   m_fHighContrast;
    bool     		   m_f16Colors;
	Taxonomy::Instance m_inst;

	MPC::string        m_strCSS;

	////////////////////

	HRESULT ProcessCSS();

public:
    CHCPProtocolEnvironment();
    ~CHCPProtocolEnvironment();

	////////////////////////////////////////////////////////////////////////////////

	static CHCPProtocolEnvironment* s_GLOBAL;

	static HRESULT InitializeSystem();
	static void    FinalizeSystem  ();
		
	////////////////////////////////////////////////////////////////////////////////

    bool UpdateState();

    void ReformatURL( CComBSTR& bstrURL );

    void    				  SetHelpLocation( /*[in]*/ const Taxonomy::Instance& inst );
    LPCWSTR 				  HelpLocation   (                                         );
    LPCWSTR 				  System         (                                         );
	const Taxonomy::Instance& Instance       (                                         );

    HRESULT GetCSS( /*[out]*/ CComPtr<IStream>& stream );
};

#endif // !defined(__INCLUDED___HCP___NAMESPACE_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\include\safintercomserver.h ===
// SAFIntercomServer.h : Declaration of the CSAFIntercomServer

#ifndef __SAFIntercomServer_H_
#define __SAFIntercomServer_H_

//JP:not in connectivitylib.h//#include "resource.h"       // main symbols

#include <MPC_COM.h>
#include <MPC_Utils.h>

#include <rtccore.h>

/////////////////////////////////////////////////////////////////////////////
// CSAFIntercomServer
class ATL_NO_VTABLE CSAFIntercomServer : // Hungarian safi
	public IDispatchImpl	       < ISAFIntercomServer, &IID_ISAFIntercomServer, &LIBID_HelpCenterTypeLib             >,
	public MPC::ConnectionPointImpl< CSAFIntercomServer, &DIID_DSAFIntercomServerEvents, MPC::CComSafeMultiThreadModel >,
	public IRTCEventNotification
{


private:
	
	CComPtr<IRTCClient>			m_pRTCClient;
	CComPtr<IRTCSession>		m_pRTCSession;

	DWORD						m_dwSinkCookie;

	BOOL						m_bInit;
	BOOL						m_bRTCInit;
	BOOL						m_bAdvised;
	BOOL						m_bOnCall;

	CComBSTR					m_bstrKey;

	int							m_iSamplingRate;

	CComPtr<IDispatch> m_sink_onVoiceConnected;
	CComPtr<IDispatch> m_sink_onVoiceDisconnected;
	CComPtr<IDispatch> m_sink_onVoiceDisabled;

	HRESULT Fire_onVoiceConnected	 (ISAFIntercomServer * safe);
	HRESULT Fire_onVoiceDisconnected (ISAFIntercomServer * safe);
	HRESULT Fire_onVoiceDisabled	 (ISAFIntercomServer * safe);
	
	// Worker functions
	HRESULT Init();
	HRESULT Cleanup();
	DWORD GenerateRandomString(DWORD dwSizeRandomSeed, BSTR *pBstr);
	DWORD GenerateRandomBytes(DWORD dwSize, LPBYTE pbBuffer);

public:

	CSAFIntercomServer();
	~CSAFIntercomServer();



//DECLARE_PROTECT_FINAL_CONSTRUCT()	// TODO: JP: Do we need this here?

BEGIN_COM_MAP(CSAFIntercomServer)
	COM_INTERFACE_ENTRY(ISAFIntercomServer)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IRTCEventNotification)
END_COM_MAP()

// ISAFIntercomServer
public:
	STDMETHOD(Listen)(/* out, retval */ BSTR * pVal);
	STDMETHOD(Disconnect)();

	STDMETHOD(RunSetupWizard)();
	STDMETHOD(Exit)();


	STDMETHOD(put_onVoiceConnected)		(/* in */ IDispatch * function);
	STDMETHOD(put_onVoiceDisconnected)  (/* in */ IDispatch * function);
	STDMETHOD(put_onVoiceDisabled)	    (/* in */ IDispatch * function);

	STDMETHOD(put_SamplingRate)			(/* in */ LONG newVal);
	STDMETHOD(get_SamplingRate)			(/* out, retval */ LONG * pVal);

	// IRTCEventNotification
	STDMETHOD(Event)( RTC_EVENT RTCEvent, IDispatch * pEvent );
	HRESULT OnSessionChange(IRTCSession *pSession, 
							    RTC_SESSION_STATE nState, 
								HRESULT ResCode);

    HRESULT onMediaEvent(IRTCMediaEvent * pMedEvent);

};

#endif //__SAFINTERCOMCLIENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\include\safintercomclient.h ===
// SAFIntercomClient.h : Declaration of the CSAFIntercomClient

#ifndef __SAFIntercomClient_H_
#define __SAFIntercomClient_H_

//JP:not in connectivitylib.h//#include "resource.h"       // main symbols

#include <MPC_COM.h>
#include <MPC_Utils.h>

#include <rtccore.h>

/////////////////////////////////////////////////////////////////////////////
// CSAFIntercomClient
class ATL_NO_VTABLE CSAFIntercomClient : // Hungarian safi
	public IDispatchImpl	       < ISAFIntercomClient, &IID_ISAFIntercomClient, &LIBID_HelpCenterTypeLib             >,
	public MPC::ConnectionPointImpl< CSAFIntercomClient, &DIID_DSAFIntercomClientEvents, MPC::CComSafeMultiThreadModel >,
	public IRTCEventNotification
{
private:

	CComPtr<IRTCClient>		m_pRTCClient;
	CComPtr<IRTCSession>	m_pRTCSession;

	DWORD					m_dwSinkCookie;
	
	BOOL					m_bOnCall;
	BOOL					m_bRTCInit;
	BOOL					m_bAdvised;

	int						m_iSamplingRate;

	CComPtr<IDispatch> m_sink_onVoiceConnected;
	CComPtr<IDispatch> m_sink_onVoiceDisconnected;
	CComPtr<IDispatch> m_sink_onVoiceDisabled;

	HRESULT Fire_onVoiceConnected	 (ISAFIntercomClient * safe);
	HRESULT Fire_onVoiceDisconnected (ISAFIntercomClient * safe);
	HRESULT Fire_onVoiceDisabled	 (ISAFIntercomClient * safe);

	// Worker functions
	HRESULT Init();
	HRESULT Cleanup();


public:

	

	CSAFIntercomClient();
	~CSAFIntercomClient();



//DECLARE_PROTECT_FINAL_CONSTRUCT()	// TODO: JP: Do we need this here?

BEGIN_COM_MAP(CSAFIntercomClient)
	COM_INTERFACE_ENTRY(ISAFIntercomClient)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IRTCEventNotification)
END_COM_MAP()

// ISAFIntercomClient
public:

	STDMETHOD(Disconnect)();
	STDMETHOD(Connect)(BSTR bstrIP, BSTR bstrKey);
	STDMETHOD(RunSetupWizard)();

	STDMETHOD(Exit)();

	STDMETHOD(put_onVoiceConnected)		(/* in */ IDispatch * function);
	STDMETHOD(put_onVoiceDisconnected)  (/* in */ IDispatch * function);
	STDMETHOD(put_onVoiceDisabled)	    (/* in */ IDispatch * function);

	STDMETHOD(put_SamplingRate)			(/* in */ LONG newVal);
	STDMETHOD(get_SamplingRate)			(/* out, retval */ LONG * pVal);


	// IRTCEventNotification
	STDMETHOD(Event)( RTC_EVENT RTCEvent, IDispatch * pEvent );

	HRESULT OnSessionChange(IRTCSession *pSession, 
							    RTC_SESSION_STATE nState, 
								HRESULT ResCode);

    HRESULT onMediaEvent(IRTCMediaEvent * pMedEvent);


};

#endif //__SAFIntercomClient_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\include\options.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Options.h

Abstract:
    This file contains the declaration of the class used to implement
    the Options inside the Help Center Application.

Revision History:
    Davide Massarenti   (dmassare)  04/08/2001
        created

******************************************************************************/

#if !defined(__INCLUDED___PCH___OPTIONS_H___)
#define __INCLUDED___PCH___OPTIONS_H___

/////////////////////////////////////////////////////////////////////////////

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

//
// From HelpCenterTypeLib.idl
//
#include <HelpCenterTypeLib.h>


#include <TaxonomyDatabase.h>

class ATL_NO_VTABLE CPCHOptions : // Hungarian: pcho
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<IPCHOptions, &IID_IPCHOptions, &LIBID_HelpCenterTypeLib>
{
	typedef enum
	{
		c_Type_bool        ,
		c_Type_long        ,
		c_Type_DWORD       ,
		c_Type_VARIANT_BOOL,
		c_Type_STRING      ,
		c_Type_FONTSIZE    ,
		c_Type_TEXTLABELS  ,
	} OptType;

	struct OptionsDef
	{
		LPCWSTR szKey;
		LPCWSTR szValue;
		size_t  iOffset;
		size_t  iOffsetFlag;
		OptType iType;
		bool    fSaveAlways;
	};

	static const OptionsDef c_tbl   [];
	static const OptionsDef c_tbl_TS[];

    bool              m_fLoaded;
    bool              m_fDirty;
    bool              m_fNoSave;

    Taxonomy::HelpSet m_ths;
    Taxonomy::HelpSet m_ths_TS;
    VARIANT_BOOL      m_ShowFavorites;         bool m_flag_ShowFavorites;
    VARIANT_BOOL      m_ShowHistory;           bool m_flag_ShowHistory;
    OPT_FONTSIZE      m_FontSize;              bool m_flag_FontSize;
	TB_MODE           m_TextLabels;            bool m_flag_TextLabels;

    DWORD             m_DisableScriptDebugger; bool m_flag_DisableScriptDebugger;

	void ReadTable ( /*[in]*/ const OptionsDef* tbl, /*[in]*/ int len, /*[in]*/ MPC::RegKey& rk );
	void WriteTable( /*[in]*/ const OptionsDef* tbl, /*[in]*/ int len, /*[in]*/ MPC::RegKey& rk );

public:
BEGIN_COM_MAP(CPCHOptions)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHOptions)
END_COM_MAP()

    CPCHOptions();

    ////////////////////////////////////////////////////////////////////////////////

    static CPCHOptions* s_GLOBAL;

    static HRESULT InitializeSystem();
    static void    FinalizeSystem  ();

    ////////////////////////////////////////////////////////////////////////////////

    HRESULT Load( /*[in]*/ bool fForce = false );
    HRESULT Save( /*[in]*/ bool fForce = false );

    void DontPersistSKU() { m_fNoSave = true; }

    Taxonomy::HelpSet& CurrentHelpSet       () { return m_ths                                                 ; }
    Taxonomy::HelpSet& TerminalServerHelpSet() { return m_ths_TS                                              ; }
    VARIANT_BOOL       ShowFavorites        () { return m_ShowFavorites                                       ; }
    VARIANT_BOOL       ShowHistory          () { return m_ShowHistory                                         ; }
    OPT_FONTSIZE       FontSize             () { return m_FontSize                                            ; }
    TB_MODE            TextLabels           () { return m_TextLabels                                          ; }
    VARIANT_BOOL       DisableScriptDebugger() { return m_DisableScriptDebugger ? VARIANT_TRUE : VARIANT_FALSE; }

	HRESULT ApplySettings( /*[in]*/ CPCHHelpCenterExternal* ext, /*[in]*/ IUnknown* unk );

public:
    // IPCHOptions
    STDMETHOD(get_ShowFavorites        )( /*[out, retval]*/	VARIANT_BOOL *  pVal );
    STDMETHOD(put_ShowFavorites        )( /*[in         ]*/	VARIANT_BOOL  newVal );
    STDMETHOD(get_ShowHistory          )( /*[out, retval]*/	VARIANT_BOOL *  pVal );
    STDMETHOD(put_ShowHistory          )( /*[in         ]*/	VARIANT_BOOL  newVal );
    STDMETHOD(get_FontSize             )( /*[out, retval]*/	OPT_FONTSIZE *  pVal );
    STDMETHOD(put_FontSize             )( /*[in         ]*/	OPT_FONTSIZE  newVal );
    STDMETHOD(get_TextLabels           )( /*[out, retval]*/	TB_MODE 	 *  pVal );
    STDMETHOD(put_TextLabels           )( /*[in         ]*/	TB_MODE 	  newVal );
    STDMETHOD(get_DisableScriptDebugger)( /*[out, retval]*/	VARIANT_BOOL *  pVal );
    STDMETHOD(put_DisableScriptDebugger)( /*[in         ]*/	VARIANT_BOOL  newVal );

    STDMETHOD(Apply)();

    HRESULT put_CurrentHelpSet( /*[in]*/ Taxonomy::HelpSet& ths ); // INTERNAL_METHOD
};

/////////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___PCH___OPTIONS_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\include\printing.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Printing.h

Abstract:
    Trident control hosting code for multi-topic printing.

Revision History:
    Davide Massarenti   (Dmassare)  05/07/2000
        created

******************************************************************************/

#if !defined(__INCLUDED___HCP___PRINTING_H___)
#define __INCLUDED___HCP___PRINTING_H___

#include <commdlg.h>
#include <shlobj.h>
#include <exdisp.h>
#include <exdispid.h>

namespace Printing
{
    class HostWindow :
        public CAxHostWindow,
        public IOleCommandTarget
    {
        ULONG        m_cRef;

        MPC::wstring m_szPrintFileName;
        bool         m_fMultiTopic;

        bool         m_fShowPrintDlg;
		LPDEVMODEW   m_pDevMode;
		CComBSTR     m_bstrPrinterName;

		bool         m_fAborted;
		HANDLE       m_hEvent;

    public:
        HostWindow();
        virtual ~HostWindow();

        DECLARE_GET_CONTROLLING_UNKNOWN()
        DECLARE_PROTECT_FINAL_CONSTRUCT()

        BEGIN_COM_MAP(HostWindow)
            COM_INTERFACE_ENTRY(IOleCommandTarget)
            COM_INTERFACE_ENTRY_CHAIN(CAxHostWindow)
        END_COM_MAP()

        //
        // IOleCommandTarget
        //
        STDMETHODIMP QueryStatus( /*[in]    */ const GUID* pguidCmdGroup ,
                                  /*[in]    */ ULONG       cCmds         ,
                                  /*[in/out]*/ OLECMD     *prgCmds       ,
                                  /*[in/out]*/ OLECMDTEXT *pCmdText      );

        STDMETHODIMP Exec( /*[in] */ const GUID* pguidCmdGroup ,
                           /*[in] */ DWORD       nCmdID        ,
                           /*[in] */ DWORD       nCmdExecOpt   ,
                           /*[in] */ VARIANTARG* pvaIn         ,
                           /*[out]*/ VARIANTARG* pvaOut        );


        void SetMultiTopic   ( /*[in]*/ bool    fMulti          );
        void SetPrintFileName( /*[in]*/ LPCWSTR szPrintFileName );
		void SetAbortEvent   ( /*[in]*/ HANDLE  hEvent          );
		bool GetAbortState   (                                  );
        BSTR GetPrinterName  (                                  );
    };

    template <typename TDerived, typename TWindow = CAxWindow> class WindowImplT : public CWindowImplBaseT< TWindow >
    {
    public:
        typedef WindowImplT<TWindow> thisClass;

        BEGIN_MSG_MAP(thisClass)
            MESSAGE_HANDLER(WM_CREATE,OnCreate)
            MESSAGE_HANDLER(WM_NCDESTROY,OnNCDestroy)
        END_MSG_MAP()

        DECLARE_WND_SUPERCLASS(_T("AtlPchAxWin"), CAxWindow::GetWndClassName())

        virtual HRESULT PrivateCreateControlEx( LPCOLESTR  lpszName       ,
												HWND       hWnd           ,
												IStream*   pStream        ,
												IUnknown* *ppUnkContainer ,
												IUnknown* *ppUnkControl   ,
												REFIID     iidSink        ,
												IUnknown*  punkSink       )
	    {
            return AtlAxCreateControlEx( lpszName       ,
										 hWnd           ,
										 pStream        ,
										 ppUnkContainer ,
										 ppUnkControl   ,
										 iidSink        ,
										 punkSink       );
		}

        HWND Create( HWND    hWndParent,
                     RECT&   rcPos,
                     LPCTSTR szWindowName  = NULL ,
                     DWORD   dwStyle       = 0    ,
                     DWORD   dwExStyle     = 0    ,
                     UINT    nID           = 0    ,
                     LPVOID  lpCreateParam = NULL )
        {
            if(GetWndClassInfo().m_lpszOrigName == NULL)
            {
                GetWndClassInfo().m_lpszOrigName = GetWndClassName();
            }

            ATOM atom = GetWndClassInfo().Register( &m_pfnSuperWindowProc );

            dwStyle   = GetWndStyle  ( dwStyle   );
            dwExStyle = GetWndExStyle( dwExStyle );

            return CWindowImplBaseT<TWindow>::Create( hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, atom, lpCreateParam );
        }

        ////////////////////////////////////////////////////////////////////////////////

        LRESULT OnCreate( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
        {
            USES_CONVERSION;

            CREATESTRUCT*     lpCreate    = (CREATESTRUCT*)lParam;
            int               nLen        = ::GetWindowTextLength( m_hWnd );
            LPTSTR            lpstrName   = (LPTSTR)_alloca( (nLen + 1) * sizeof(TCHAR) );
            IAxWinHostWindow* pAxWindow   = NULL;
            int               nCreateSize = 0;
            CComPtr<IUnknown> spUnk;
            CComPtr<IStream>  spStream;



            ::GetWindowText( m_hWnd, lpstrName, nLen + 1 );
            ::SetWindowText( m_hWnd, _T("")              );

            if(lpCreate && lpCreate->lpCreateParams)
            {
                nCreateSize = *((WORD*)lpCreate->lpCreateParams);
            }

            //
            // Get the data for the initialization stream.
            //
            if(nCreateSize)
            {
                HGLOBAL h = GlobalAlloc( GHND, nCreateSize );

                if(h)
                {
                    BYTE* pBytes  =  (BYTE*)GlobalLock( h );
                    BYTE* pSource = ((BYTE*)(lpCreate->lpCreateParams)) + sizeof(WORD);

                    //Align to DWORD
                    //pSource += (((~((DWORD)pSource)) + 1) & 3);
                    memcpy( pBytes, pSource, nCreateSize );

                    ::GlobalUnlock( h );
                    ::CreateStreamOnHGlobal( h, TRUE, &spStream );
                }
            }

            //
            // call the real creation routine here...
            //
            HRESULT hRet = PrivateCreateControlEx( T2COLE( lpstrName ), m_hWnd, spStream, &spUnk, NULL, IID_NULL, NULL );
            if(FAILED(hRet)) return -1; // abort window creation

            hRet = spUnk->QueryInterface( IID_IAxWinHostWindow, (void**)&pAxWindow );
            if(FAILED(hRet)) return -1; // abort window creation

			::SetWindowLongPtr( m_hWnd, GWLP_USERDATA, (LONG_PTR)pAxWindow );

            //
            // check for control parent style if control has a window
            //
            {
                HWND hWndChild = ::GetWindow( m_hWnd, GW_CHILD );

                if(hWndChild != NULL)
                {
                    if(::GetWindowLong( hWndChild, GWL_EXSTYLE ) & WS_EX_CONTROLPARENT)
                    {
                        DWORD dwExStyle = ::GetWindowLong( m_hWnd, GWL_EXSTYLE );

                        dwExStyle |= WS_EX_CONTROLPARENT;

                        ::SetWindowLong(m_hWnd, GWL_EXSTYLE, dwExStyle );
                    }
                }
            }

            bHandled = TRUE;
            return 0L;
        }

        LRESULT OnNCDestroy( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
        {
			IAxWinHostWindow* pAxWindow = (IAxWinHostWindow*)::GetWindowLongPtr( m_hWnd, GWLP_USERDATA );

            if(pAxWindow != NULL) pAxWindow->Release();

            m_hWnd   = NULL;
            bHandled = TRUE;

            return 0L;
        }
    };

	////////////////////////////////////////////////////////////////////////////////

    class WindowHandle : public WindowImplT<WindowHandle>
    {
    public:
        typedef WindowImplT<WindowHandle> baseClass;
        typedef CComObject<HostWindow>    theSite;

    private:
        theSite*      m_pSiteObject;
        bool          m_fMultiTopic;
        MPC::wstring  m_szPrintFileName;
		HANDLE        m_hEvent;

    public:
        WindowHandle();
        ~WindowHandle();

        BEGIN_MSG_MAP(WindowHandle)
            CHAIN_MSG_MAP(baseClass)
        END_MSG_MAP()

        virtual HRESULT PrivateCreateControlEx( LPCOLESTR  lpszName       ,
												HWND       hWnd           ,
												IStream*   pStream        ,
												IUnknown* *ppUnkContainer ,
												IUnknown* *ppUnkControl   ,
												REFIID     iidSink        ,
												IUnknown*  punkSink       );

		void SetMultiTopic   ( /*[in]*/ bool    fMulti          );
		void SetPrintFileName( /*[in]*/ LPCWSTR szPrintFileName );
		void SetAbortEvent   ( /*[in]*/ HANDLE  hEvent          );
		bool GetAbortState   (                                  );
		BSTR GetPrinterName  (                                  );
	};

	////////////////////////////////////////////////////////////////////////////////

	class ATL_NO_VTABLE CDispatchSink :
		public CComObjectRootEx<CComSingleThreadModel>,
		public IDispatch
	{
		HANDLE   m_hEvent;
		CComBSTR m_URL;

	public:
		BEGIN_COM_MAP(CDispatchSink)
			COM_INTERFACE_ENTRY(IDispatch)
			COM_INTERFACE_ENTRY_IID(DIID_DWebBrowserEvents2, IDispatch)
		END_COM_MAP()

		CDispatchSink();

		void SetNotificationEvent( /*[in]*/ HANDLE hEvent );
		BSTR GetCurrentURL       (                        );

		STDMETHOD(GetTypeInfoCount)(UINT* pctinfo);
		STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
		STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames, LCID lcid, DISPID* rgdispid);

		STDMETHOD(Invoke)( DISPID      dispidMember ,
						   REFIID      riid         ,
						   LCID        lcid         ,
						   WORD        wFlags       ,
						   DISPPARAMS* pdispparams  ,
						   VARIANT*    pvarResult   ,
						   EXCEPINFO*  pexcepinfo   ,
						   UINT*       puArgErr     );
	};

	////////////////////////////////////////////////////////////////////////////////

	class Print
	{
	public:
		class Notification
		{
		public:
			virtual HRESULT Progress( /*[in]*/ LPCWSTR szURL, /*[in]*/ int iDone, /*[in]*/ int iTotal ) = 0;
		};

	private:
		Notification*              m_pCallback;               // Client for notification.
                                                              //
		MPC::WStringList      	   m_lstURLs;                 // list of urls to be printed
                                                              //
		HWND                       m_hwnd;                    // parent window.
		WindowHandle          	   m_wnd;                     // window for hosting Trident
		CComPtr<IWebBrowser2>      m_spWebBrowser2;           // pointer for Navigate call
                                                              //
		CComPtr<CDispatchSink>     m_spObjDisp;               // our sink object for Trident events
		HANDLE                     m_eventDocComplete;	      // this event is for notifying our code when the webbrowser is done loading a topic
		HANDLE                     m_eventAbortPrint;         // this event is for notifying our code when the webbrowser is done printing a topic
                                                              //
		CComPtr<IUnknown>     	   m_spUnkControl;            // IUnknown of our control
		DWORD                 	   m_dwCookie;                // cookie for our Unadvise call
		CComPtr<IOleCommandTarget> m_spOleCmdTarg;            // pointer we need to tell Trident to print
		MPC::wstring			   m_szPrintDir;   			  // directory to print to
		MPC::wstring			   m_szPrintFile;  			  // file to print to
                                                              //
		CComPtr<IStream>           m_streamPrintData;         // pointer to raw printer data


		HRESULT PrintSingleURL( /*[in]*/ MPC::wstring& szUrl );	// print a single URL

		HRESULT HookUpEventSink();      // hook up our event sink
		HRESULT PreparePrintFileLoc();  // prepare our temporary print files
		HRESULT WaitForDocComplete();   // wait for Trident to load the page
		HRESULT DoPrint();              // send the print command to Trident
		HRESULT WaitForPrintComplete(); // wait for Trident to finish printing
		HRESULT UpdatePrintBuffer();    // load the print file data into our buffer
		HRESULT RawDataToPrinter();     // dump a raw stream of data to the printer

	public:
		Print();
		~Print();

		HRESULT Initialize( /*[in]*/ HWND hwnd );
		HRESULT Terminate (                    );

		HRESULT AddUrl( /*[in]*/ LPCWSTR szUrl );

		HRESULT PrintAll( /*[in]*/ Notification* pCallback );
	};
};

////////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHPrintEngine : // Hungarian: hcppe
    public MPC::Thread             < CPCHPrintEngine, IPCHPrintEngine, COINIT_APARTMENTTHREADED                  >,
    public MPC::ConnectionPointImpl< CPCHPrintEngine, &DIID_DPCHPrintEngineEvents, MPC::CComSafeMultiThreadModel >,
    public IDispatchImpl           < IPCHPrintEngine, &IID_IPCHPrintEngine, &LIBID_HelpCenterTypeLib             >,
	public Printing::Print::Notification
{
	Printing::Print                      m_engine;

    MPC::CComPtrThreadNeutral<IDispatch> m_sink_onProgress;
    MPC::CComPtrThreadNeutral<IDispatch> m_sink_onComplete;

    //////////////////////////////////////////////////////////////////////

    HRESULT Run();

    HRESULT CanModifyProperties();

    //////////////////////////////////////////////////////////////////////

    //
    // Event firing methods.
    //
    HRESULT Fire_onProgress( IPCHPrintEngine* hcppe, BSTR bstrURL, long lDone, long lTotal );
    HRESULT Fire_onComplete( IPCHPrintEngine* hcppe, HRESULT hrRes                         );

	//
	// Callbacks
	//
	HRESULT Progress( /*[in]*/ LPCWSTR szURL, /*[in]*/ int iDone, /*[in]*/ int iTotal );

    //////////////////////////////////////////////////////////////////////

public:
BEGIN_COM_MAP(CPCHPrintEngine)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHPrintEngine)
    COM_INTERFACE_ENTRY(IConnectionPointContainer)
END_COM_MAP()

    CPCHPrintEngine();

    void FinalRelease();

public:
    // IPCHPrintEngine
    STDMETHOD(put_onProgress)( /*[in] */ IDispatch* function );
    STDMETHOD(put_onComplete)( /*[in] */ IDispatch* function );


    STDMETHOD(AddTopic)( /*[in]*/ BSTR bstrURL );

    STDMETHOD(Start)();
    STDMETHOD(Abort)();
};

#endif // !defined(__INCLUDED___HCP___PRINTING_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\pchealth\helpctr\shell\include\serviceproxy.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    ServiceProxy.h

Abstract:
    All the interaction with the Help Service is done through this class.
    It's responsible for kickstarting the service as late as possible.

Revision History:
    Davide Massarenti   (dmassare) 07/17/2000
        created

    Kalyani Narlanka    (KalyaniN)  03/15/01
	    Moved Incident and Encryption Objects from HelpService to HelpCtr to improve Perf.
******************************************************************************/

#if !defined(__INCLUDED___PCH___SERVICEPROXY_H___)
#define __INCLUDED___PCH___SERVICEPROXY_H___

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>


#include <MPC_COM.h>

#include <Events.h>
#include <HelpSession.h>
#include <Options.h>

#include <ConnectivityLib.h>
#include <OfflineCache.h>

/////////////////////////////////////////////////////////////////////////////

class CPCHProxy_IPCHService;
class CPCHProxy_IPCHUtility;
class CPCHProxy_IPCHUserSettings2;
class CPCHProxy_IPCHSetOfHelpTopics;
class CPCHProxy_IPCHTaxonomyDatabase;
class CPCHHelpCenterExternal;

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//
// IDispatchEx (We override the default implementation to get a chance to look at the TRUSTED/UNTRUSTED settings)
//
#define INTERNETSECURITY__INVOKEEX()                                                               \
    STDMETHOD(InvokeEx)( DISPID            id        ,                                             \
                         LCID              lcid      ,                                             \
                         WORD              wFlags    ,                                             \
                         DISPPARAMS*       pdp       ,                                             \
                         VARIANT*          pvarRes   ,                                             \
                         EXCEPINFO*        pei       ,                                             \
                         IServiceProvider* pspCaller )                                             \
    {                                                                                              \
        return m_SecurityHandle.ForwardInvokeEx( id, lcid, wFlags, pdp, pvarRes, pei, pspCaller ); \
    }

#define INTERNETSECURITY__CHECK_TRUST()  __MPC_EXIT_IF_METHOD_FAILS(hr, m_SecurityHandle.IsTrusted())
#define INTERNETSECURITY__CHECK_SYSTEM() __MPC_EXIT_IF_METHOD_FAILS(hr, m_SecurityHandle.IsSystem())

class CPCHSecurityHandle
{
    CPCHHelpCenterExternal* m_ext;
    IDispatch*              m_object;

public:
    CPCHSecurityHandle();

    void Initialize( /*[in]*/ CPCHHelpCenterExternal* ext, /*[in] */ IDispatch* object );
    void Passivate (                                                                   );

	operator CPCHHelpCenterExternal*() const { return m_ext; }

    ////////////////////

    HRESULT ForwardInvokeEx( /*[in] */ DISPID            id        ,
                             /*[in] */ LCID              lcid      ,
                             /*[in] */ WORD              wFlags    ,
                             /*[in] */ DISPPARAMS*       pdp       ,
                             /*[out]*/ VARIANT*          pvarRes   ,
                             /*[out]*/ EXCEPINFO*        pei       ,
                             /*[in] */ IServiceProvider* pspCaller );

    HRESULT IsTrusted();
    HRESULT IsSystem ();
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

namespace AsynchronousTaxonomyDatabase
{
    class Notifier;
    class QueryStore;
    class Engine;

    ////////////////////

    class NotifyHandle : public CComObjectRootEx<MPC::CComSafeMultiThreadModel> // For locking and reference counting...
    {
        friend class Notifier;

        int                        m_iType;
        CComBSTR                   m_bstrID;

        bool                       m_fAttached;
        HANDLE                     m_hEvent;

        HRESULT                    m_hr;
        CPCHQueryResultCollection* m_pColl;

        ////////////////////

        HRESULT Init(                                           );
        void    Bind( /*[in]*/ int iType, /*[in]*/ LPCWSTR szID );

        virtual void Call( /*[in]*/ QueryStore* qs );

    public:
        NotifyHandle();
        virtual ~NotifyHandle();

        STDMETHOD_(ULONG, AddRef)();
        STDMETHOD_(ULONG, Release)();

        virtual void Detach();
        virtual bool IsAttached();

        HRESULT GetData( /*[out]*/ CPCHQueryResultCollection* *pColl                );
        HRESULT Wait   ( /*[in]*/  DWORD                       dwTimeout = INFINITE );
    };

    template <class C> class NotifyHandle_Method : public NotifyHandle
    {
        typedef void (C::*CLASS_METHOD)( /*[in]*/ NotifyHandle* notify );

        C*           m_pThis;
        CLASS_METHOD m_pCallback;

        ////////////////////

        void Call( /*[in]*/ QueryStore* qs )
        {
            MPC::SmartLock<_ThreadModel> lock( this );

            NotifyHandle::Call( qs );

            if(m_pThis)
            {
                (m_pThis->*m_pCallback)( this );
            }
        }

    public:
        NotifyHandle_Method( /*[in]*/ C* pThis, /*[in]*/ CLASS_METHOD pCallback )
        {
            m_pThis     = pThis;
            m_pCallback = pCallback;
        }

        void Detach()
        {
            MPC::SmartLock<_ThreadModel> lock( this );

            NotifyHandle::Detach( qs );

            m_pThis = NULL;
        }
    };

    class Notifier : public CComObjectRootEx<MPC::CComSafeMultiThreadModel> // For locking...
    {
        typedef std::list< NotifyHandle* > List;
        typedef List::iterator             Iter;
        typedef List::const_iterator       IterConst;

        List m_lstCallback;

        ////////////////////

    private: // Disable copy constructors...
        Notifier           ( /*[in]*/ const Notifier& );
        Notifier& operator=( /*[in]*/ const Notifier& );

    public:
        Notifier();
        ~Notifier();

        ////////////////////

        void Notify( /*[in]*/ QueryStore* qs );

        ////////////////////

        HRESULT AddNotification( /*[in]*/ QueryStore* qs, /*[in]*/ NotifyHandle* nb );
    };

    ////////////////////

    class QueryStore
    {
        friend class Notifier;
        friend class Engine;

        int              m_iType;
        CComBSTR         m_bstrID;
		CComVariant      m_vOption;

        bool             m_fDone;
        HRESULT          m_hr;
        MPC::CComHGLOBAL m_hgData;
        FILETIME         m_dLastUsed;

    private: // Disable copy constructors...
        QueryStore           ( /*[in]*/ const QueryStore& );
        QueryStore& operator=( /*[in]*/ const QueryStore& );

    public:
        QueryStore( /*[in]*/ int iType, /*[in]*/ LPCWSTR szID, /*[in]*/ VARIANT* option );
        ~QueryStore();

        bool LessThen ( /*[in]*/ QueryStore const &qs ) const;
        bool NewerThen( /*[in]*/ QueryStore const &qs ) const;

        ////////////////////

        HRESULT Execute( /*[in]*/ OfflineCache::Handle* handle, /*[in]*/ CPCHProxy_IPCHTaxonomyDatabase* parent, /*[in]*/ bool fForce = false );

        HRESULT GetData( /*[out]*/ CPCHQueryResultCollection* *pColl );

        void Invalidate();
    };

    ////////////////////

    class Engine :
        public MPC::Thread<Engine,IUnknown>,
        public CComObjectRootEx<MPC::CComSafeMultiThreadModel>
    {
        class CompareQueryStores
        {
        public:
            bool operator()( /*[in]*/ const QueryStore *, /*[in]*/ const QueryStore * ) const;
        };

        typedef std::set<QueryStore *,CompareQueryStores> Set;
        typedef Set::iterator                             Iter;
        typedef Set::const_iterator                       IterConst;

        CPCHProxy_IPCHTaxonomyDatabase* m_parent;
        Set                             m_setQueries;
        Notifier                        m_notifier;

        ////////////////////

        bool LookupCache( /*[out]*/ OfflineCache::Handle& handle );

        HRESULT Run();

        void InvalidateQueries();

    public:
        Engine( /*[in]*/ CPCHProxy_IPCHTaxonomyDatabase* parent );
        virtual ~Engine();

        void Passivate        ();
        void RefreshConnection();

        ////////////////////

        HRESULT ExecuteQuery( /*[in]*/ int iType, /*[in]*/ LPCWSTR szID, /*[in]*/ VARIANT* option, /*[in]*/          NotifyHandle*               nb  );
        HRESULT ExecuteQuery( /*[in]*/ int iType, /*[in]*/ LPCWSTR szID, /*[in]*/ VARIANT* option, /*[out, retval]*/ CPCHQueryResultCollection* *ppC );
    };
};

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

typedef MPC::SmartLockGeneric<MPC::CComSafeAutoCriticalSection> ProxySmartLock;

class ATL_NO_VTABLE CPCHProxy_IPCHService :
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public MPC::IDispatchExImpl< IPCHService, &IID_IPCHService, &LIBID_HelpServiceTypeLib>
{
    CPCHSecurityHandle                     m_SecurityHandle;
    CPCHHelpCenterExternal*                m_parent;

	MPC::CComSafeAutoCriticalSection       m_DirectLock;
    MPC::CComPtrThreadNeutral<IPCHService> m_Direct_Service;
    bool                                   m_fContentStoreTested;

    CPCHProxy_IPCHUtility*                 m_Utility;

public:
BEGIN_COM_MAP(CPCHProxy_IPCHService)
    COM_INTERFACE_ENTRY2(IDispatch, IDispatchEx)
    COM_INTERFACE_ENTRY(IDispatchEx)
    COM_INTERFACE_ENTRY(IPCHService)
END_COM_MAP()

    CPCHProxy_IPCHService();
    virtual ~CPCHProxy_IPCHService();

    INTERNETSECURITY__INVOKEEX();

    ////////////////////

    CPCHHelpCenterExternal* Parent     () { return   m_parent;         }
    bool                    IsConnected() { return !!m_Direct_Service; }

    ////////////////////

    HRESULT ConnectToParent       ( /*[in]*/ CPCHHelpCenterExternal* parent                             );
    void    Passivate             (                                                                     );
    HRESULT EnsureDirectConnection( /*[out]*/ CComPtr<IPCHService>& svc, /*[in]*/ bool fRefresh = false );
    HRESULT EnsureContentStore    (                                                                     );

    HRESULT GetUtility( /*[out]*/ CPCHProxy_IPCHUtility* *pVal = NULL );

    ////////////////////

public:
    // IPCHService
    STDMETHOD(get_RemoteSKUs          )( /*[out, retval]*/ IPCHCollection* *pVal ) { return E_NOTIMPL; }
	STDMETHOD(get_RemoteModemConnected)( /*[out, retval]*/ VARIANT_BOOL    *pVal ) { return E_NOTIMPL; }

    STDMETHOD(IsTrusted)( /*[in]*/ BSTR bstrURL, /*[out, retval]*/ VARIANT_BOOL *pfTrusted ) { return E_NOTIMPL; }

    STDMETHOD(Utility           )( /*[in]*/ BSTR bstrSKU, /*[in]*/ long	lLCID, /*[out]*/ IPCHUtility*            *pVal ) { return E_NOTIMPL; }
    STDMETHOD(RemoteHelpContents)( /*[in]*/ BSTR bstrSKU, /*[in]*/ long	lLCID, /*[out]*/ IPCHRemoteHelpContents* *pVal ) { return E_NOTIMPL; }

    STDMETHOD(RegisterHost       )(                           /*[in]*/ BSTR bstrID  ,                        /*[in ]*/ IUnknown*   pObj ) { return E_NOTIMPL; }
    STDMETHOD(CreateScriptWrapper)( /*[in]*/ REFCLSID rclsid, /*[in]*/ BSTR bstrCode, /*[in]*/ BSTR bstrURL, /*[out]*/ IUnknown* *ppObj );

    STDMETHOD(TriggerScheduledDataCollection)( /*[in]*/ VARIANT_BOOL fStart ) { return E_NOTIMPL; }
    STDMETHOD(PrepareForShutdown            )(                              ) { return E_NOTIMPL; }

    STDMETHOD(ForceSystemRestore)(                                            ) { return E_NOTIMPL; }
    STDMETHOD(UpgradeDetected	)(                                            ) { return E_NOTIMPL; }
    STDMETHOD(MUI_Install  	 	)( /*[in]*/ long LCID, /*[in]*/ BSTR bstrFile ) { return E_NOTIMPL; }
    STDMETHOD(MUI_Uninstall	 	)( /*[in]*/ long LCID                         ) { return E_NOTIMPL; }


    STDMETHOD(RemoteConnectionParms)( /*[in	]*/ BSTR 			 bstrUserName          ,
									  /*[in	]*/ BSTR 			 bstrDomainName        ,
									  /*[in	]*/ long 			 lSessionID            ,
									  /*[in	]*/ BSTR 			 bstrUserHelpBlob      ,
									  /*[out]*/ BSTR            *pbstrConnectionString ) { return E_NOTIMPL; }
    STDMETHOD(RemoteUserSessionInfo)( /*[out]*/ IPCHCollection* *pVal                  ) { return E_NOTIMPL; }
};

////////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHProxy_IPCHUtility :
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public MPC::IDispatchExImpl< IPCHUtility, &IID_IPCHUtility, &LIBID_HelpServiceTypeLib>
{
    CPCHSecurityHandle                     m_SecurityHandle;
    CPCHProxy_IPCHService*                 m_parent;
										   
	MPC::CComSafeAutoCriticalSection       m_DirectLock;
    MPC::CComPtrThreadNeutral<IPCHUtility> m_Direct_Utility;

    CPCHProxy_IPCHUserSettings2*    	   m_UserSettings2;
    CPCHProxy_IPCHTaxonomyDatabase* 	   m_TaxonomyDatabase;

public:
BEGIN_COM_MAP(CPCHProxy_IPCHUtility)
    COM_INTERFACE_ENTRY2(IDispatch, IDispatchEx)
    COM_INTERFACE_ENTRY(IDispatchEx)
    COM_INTERFACE_ENTRY(IPCHUtility)
END_COM_MAP()

    CPCHProxy_IPCHUtility();
    virtual ~CPCHProxy_IPCHUtility();

    INTERNETSECURITY__INVOKEEX();

    ////////////////////

    CPCHProxy_IPCHService* Parent     () { return   m_parent;         }
    bool                   IsConnected() { return !!m_Direct_Utility; }

    ////////////////////

    HRESULT ConnectToParent       ( /*[in]*/ CPCHProxy_IPCHService* parent, /*[in]*/ CPCHHelpCenterExternal* ext );
    void    Passivate             (                                                                              );
    HRESULT EnsureDirectConnection( /*[out]*/ CComPtr<IPCHUtility>& util, /*[in]*/ bool fRefresh = false         );

    HRESULT GetUserSettings2( /*[out]*/ CPCHProxy_IPCHUserSettings2*    *pVal = NULL );
    HRESULT GetDatabase     ( /*[out]*/ CPCHProxy_IPCHTaxonomyDatabase* *pVal = NULL );

    ////////////////////

public:
    // IPCHUtility
    STDMETHOD(get_UserSettings)( /*[out, retval]*/ IPCHUserSettings*     *pVal );
    STDMETHOD(get_Channels    )( /*[out, retval]*/ ISAFReg*              *pVal );
    STDMETHOD(get_Security    )( /*[out, retval]*/ IPCHSecurity*         *pVal );
    STDMETHOD(get_Database    )( /*[out, retval]*/ IPCHTaxonomyDatabase* *pVal );


    STDMETHOD(FormatError)( /*[in]*/ VARIANT vError, /*[out, retval]*/ BSTR *pVal );

    STDMETHOD(CreateObject_SearchEngineMgr)(                                                          /*[out, retval]*/ IPCHSEManager*      *ppSE );
    STDMETHOD(CreateObject_DataCollection )(                                                          /*[out, retval]*/ ISAFDataCollection* *ppDC );
    STDMETHOD(CreateObject_Cabinet        )(                                                          /*[out, retval]*/ ISAFCabinet*        *ppCB );
    STDMETHOD(CreateObject_Encryption     )(                                                          /*[out, retval]*/ ISAFEncrypt*        *ppEn );
    STDMETHOD(CreateObject_Channel        )( /*[in]*/ BSTR bstrVendorID, /*[in]*/ BSTR bstrProductID, /*[out, retval]*/ ISAFChannel*        *ppCh );

	STDMETHOD(CreateObject_RemoteDesktopConnection)( /*[out, retval]*/ ISAFRemoteDesktopConnection* *ppRDC               );
	STDMETHOD(CreateObject_RemoteDesktopSession   )( /*[in]         */ REMOTE_DESKTOP_SHARING_CLASS  sharingClass        ,
                                                     /*[in]         */ long 						 lTimeout            ,
                                                     /*[in]         */ BSTR 						 bstrConnectionParms ,
													 /*[in]         */ BSTR 						 bstrUserHelpBlob    ,
													 /*[out, retval]*/ ISAFRemoteDesktopSession*    *ppRCS               );


    STDMETHOD(ConnectToExpert)( /*[in]*/ BSTR bstrExpertConnectParm, /*[in]*/ LONG lTimeout, /*[out, retval]*/ LONG *lSafErrorCode );

	STDMETHOD(SwitchDesktopMode)( /*[in]*/ int nMode, /* [in]*/ int nRAType );
};

////////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHProxy_IPCHUserSettings2 :
    public MPC::Thread<CPCHProxy_IPCHUserSettings2,IPCHUserSettings2>,
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public MPC::IDispatchExImpl<IPCHUserSettings2, &IID_IPCHUserSettings2, &LIBID_HelpCenterTypeLib>
{
    CPCHSecurityHandle                          m_SecurityHandle;
    CPCHProxy_IPCHUtility*                      m_parent;

	MPC::CComSafeAutoCriticalSection            m_DirectLock;
    MPC::CComPtrThreadNeutral<IPCHUserSettings> m_Direct_UserSettings;

    CPCHProxy_IPCHSetOfHelpTopics*     	        m_MachineSKU;
    CPCHProxy_IPCHSetOfHelpTopics*     	        m_CurrentSKU;
	Taxonomy::HelpSet                           m_ths;
	CComBSTR                                    m_bstrScope;

    bool                                        m_fReady;
	Taxonomy::Instance                          m_instMachine;
	Taxonomy::Instance                          m_instCurrent;

	bool                                        m_Ne