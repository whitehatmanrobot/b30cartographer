 call the minidriver's event routine, if present.
    //

	IFN_MF(
	    if (DeviceExtension->HwEventRoutine) {

    	    Status = DeviceExtension->HwEventRoutine(Event);

	    }                           // if eventroutine
	)
	IF_MF(
	    if (FilterInstance->HwEventRoutine) {

    	    Status = FilterInstance->HwEventRoutine(Event);

	    }                           // if eventroutine
	)

	
    if (!NT_SUCCESS(Status)) {

        //
        // minidriver did not like it.  remove the entry from the list.
        //

        DebugPrint((DebugLevelError, "DeviceEnableEvent: minidriver failed enable!\n"));

        RemoveEntryList(&Event->EventEntry->ListEntry);
    }
    return (Status);
}

VOID
SCFreeDeadEvents(
                 IN PDEVICE_EXTENSION DeviceExtension
)
/*++

Routine Description:

    Free dead events at passive level

Arguments:

    DeviceExtension - address of device extension.

Return Value:

    None

--*/

{
    LIST_ENTRY      EventList;
    PLIST_ENTRY     EventListEntry;
    PKSEVENT_ENTRY  EventEntry;
    KIRQL           Irql;

    //
    // capture the dead list at the appropriate synchronization level.
    //

    // hack to save code.  store the DeviceExtension* in the list entry.

    EventList.Flink = (PLIST_ENTRY) DeviceExtension;

    KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

    DeviceExtension->SynchronizeExecution(
                                          DeviceExtension->InterruptObject,
                                          (PVOID) SCGetDeadListSynchronized,
                                          &EventList);

    KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

    //
    // discard each event on the captured list
    //

    while (!IsListEmpty(&EventList)) {


        EventListEntry = RemoveHeadList(&EventList);

        EventEntry = CONTAINING_RECORD(EventListEntry,
                                       KSEVENT_ENTRY,
                                       ListEntry);

        KsDiscardEvent(EventEntry);
    }                           // while not empty

    //
    // show event has been run
    //

    DeviceExtension->DeadEventItemQueued = FALSE;

    return;
}

VOID
SCGetDeadListSynchronized(
                          IN PLIST_ENTRY NewEventList
)
/*++

Routine Description:

    Get the list of dead events at the appropriate sync level

Arguments:

    NewListEntry - list head to add the event list.

Return Value:

    None

--*/

{

    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) NewEventList->Flink;
    PLIST_ENTRY     ListEntry;

    InitializeListHead(NewEventList);


    //
    // capture the dead list to our temp list head
    //

    while (!IsListEmpty(&DeviceExtension->DeadEventList)) {

        ListEntry = RemoveTailList(&DeviceExtension->DeadEventList);

        InsertHeadList(NewEventList,
                       ListEntry);

    }                           // while dead list not empty

    InitializeListHead(&DeviceExtension->DeadEventList);
    return;

}

#if SUPPORT_MULTIPLE_FILTER_TYPES

VOID
SCRescanStreams(
                IN PDEVICE_EXTENSION DeviceExtension
)
/*++

Routine Description:

    Rescan minidriver streams of all filters with the request

Arguments:

    DeviceExtension - address of device extension.

Return Value:

    None

--*/

{
    PHW_STREAM_DESCRIPTOR StreamBuffer;
    PDEVICE_OBJECT  DeviceObject = DeviceExtension->DeviceObject;
    PFILTER_INSTANCE	FilterInstance;
    BOOLEAN         RequestIssued;
    KEVENT          Event;
    NTSTATUS        Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PIRP            Irp;
    ULONG           ul;
    PLIST_ENTRY         Node;

    PAGED_CODE();

    TRAP;
    DebugPrint((DebugLevelVerbose, "'RescanStreams: enter\n"));


    //
    // take the control event to avoid race
    //

    KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                          Executive,
                          KernelMode,
                          FALSE,// not alertable
                          NULL);

    ASSERT( !IsListEmpty( DeviceExtension->FilterInstanceList ));

        
    Node = &DeviceExtension->FilterInstanceList;

	while ( Node !=  Node->Flink ) {
	    
        FilterInstance = CONTAINING_RECORD(Node,
                                           FILTER_INSTANCE,
                                           NextFilterInstance);
    
        if ( InterlockedExchange( &FilterInstance->NeedReenumeration, 0)) {
            //
            // send an SRB to retrieve the stream information
            //
            ASSERT( FilterInstance->StreamDescriptorSize );
            StreamBuffer =
                ExAllocatePool(NonPagedPool,
                       FilterInstance->StreamDescriptorSize);

            if (!StreamBuffer) {
                DebugPrint((DebugLevelError,
                           "RescanStreams: couldn't allocate!\n"));
                TRAP;
                KeSetEvent( &DeviceExtension->ControlEvent,IO_NO_INCREMENT, FALSE);
                return;
            }
            
            //
            // zero-init the buffer
            //

            RtlZeroMemory(StreamBuffer, ConfigInfo->StreamDescriptorSize);

            //
            // allocate IRP for issuing the get stream info.
            // Since this IRP
            // should not really be referenced, use dummy IOCTL code.
            // I chose this one since it will always fail in the KS
            // property handler if someone is silly enough to try to
            // process it. Also make the irp internal i/o control.
            //


            // IoVerifier.c test code does not check IrpStack bound like
            // the formal production code. And the owner does not want to
            // fix it. It's more productive just work around here.

            //Irp = IoBuildDeviceIoControlRequest(
            //                                    IOCTL_KS_PROPERTY,
            //                                    DeviceObject,
            //                                    NULL,
            //                                    0,
            //                                    NULL,
            //                                    0,
            //                                    TRUE,
            //                                    &Event,
            //                                    &IoStatusBlock);

            Irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);
            if (!Irp) {
                //
                // could not allocate IRP.  fail.
                //

          		ExFreePool( StreamBuffer );
                DebugPrint((DebugLevelError, "RescanStreams: couldn't allocate!\n"));
                TRAP;
                return;
            } else {
                PIO_STACK_LOCATION NextStack;
                //
                // This is a dummy Ir, the MJ is arbitrary
                //
                NextStack = IoGetNextIrpStackLocation(Irp);
                ASSERT(NextStack != NULL);
                NextStack->MajorFunction = IRP_MJ_PNP;
                NextStack->MinorFunction = IRP_MN_CANCEL_STOP_DEVICE;
                Irp->UserIosb = &IoStatusBlock;
                Irp->UserEvent = &Event;                        
            }

            //
            // show one more I/O pending on the device.
            //

            InterlockedIncrement(&DeviceExtension->OneBasedIoCount);

            //
            // submit the command to retrieve the stream info.
            // additional processing will be done by the callback
            // procedure.
            //

            Status = SCSubmitRequest(SRB_GET_STREAM_INFO,
                             StreamBuffer,
                             ConfigInfo->StreamDescriptorSize,
                             SCStreamInfoCallback,
                             DeviceExtension,
                             FilterInstance->HwInstanceExtension,
                             NULL,
                             Irp,
                             &RequestIssued,
                             &DeviceExtension->PendingQueue,
                             (PVOID) DeviceExtension->
                             MinidriverData->HwInitData.
                             HwReceivePacket
        );

        if (!RequestIssued) {
            KeSetEvent( &DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
            ExFreePool(StreamBuffer);
            DebugPrint((DebugLevelError, "RescanStreams: couldn't issue request!\n"));
            TRAP;
            SCCompleteIrp(Irp, Status, DeviceExtension);
            return;
        }
    } // check all filterinstances
    
    //
    // processing will continue in callback procedure.
    //
    
    return;
}

#else // SUPPORT_MULTIPLE_FILTER_TYPES

VOID
SCRescanStreams(
                IN PDEVICE_EXTENSION DeviceExtension
)
/*++

Routine Description:

    Rescan minidriver streams

Arguments:

    DeviceExtension - address of device extension.

Return Value:

    None

--*/

{
    PHW_STREAM_DESCRIPTOR StreamBuffer;
    PDEVICE_OBJECT  DeviceObject = DeviceExtension->DeviceObject;
    PPORT_CONFIGURATION_INFORMATION ConfigInfo =
    DeviceExtension->ConfigurationInformation;
    BOOLEAN         RequestIssued;
    KEVENT          Event;
    NTSTATUS        Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PIRP            Irp;

    PAGED_CODE();

    TRAP;
    DebugPrint((DebugLevelVerbose, "'RescanStreams: enter\n"));

    //
    // send an SRB to retrieve the stream information
    //

    ASSERT(ConfigInfo->StreamDescriptorSize);

    StreamBuffer =
        ExAllocatePool(NonPagedPool,
                       ConfigInfo->StreamDescriptorSize
        );

    if (!StreamBuffer) {

        DebugPrint((DebugLevelError, "RescanStreams: couldn't allocate!\n"));
        TRAP;
        return;
    }
    //
    // take the control event to avoid race
    //

    KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                          Executive,
                          KernelMode,
                          FALSE,// not alertable
                          NULL);

    //
    // zero-init the buffer
    //

    RtlZeroMemory(StreamBuffer, ConfigInfo->StreamDescriptorSize);

    //
    // allocate IRP for issuing the get stream info.
    // Since this IRP
    // should not really be referenced, use dummy IOCTL code.
    // I chose this one since it will always fail in the KS
    // property handler if someone is silly enough to try to
    // process it. Also make the irp internal i/o control.
    //

    Irp = IoBuildDeviceIoControlRequest(
                                        IOCTL_KS_PROPERTY,
                                        DeviceObject,
                                        NULL,
                                        0,
                                        NULL,
                                        0,
                                        TRUE,
                                        &Event,
                                        &IoStatusBlock);

    if (!Irp) {

        //
        // could not allocate IRP.  fail.
        //
		ExFreePool( StreamBuffer );
        DebugPrint((DebugLevelError, "RescanStreams: couldn't allocate!\n"));
        TRAP;
        return;

    }                           // if ! irp
    //
    // show one more I/O pending on the device.
    //

    InterlockedIncrement(&DeviceExtension->OneBasedIoCount);

    //
    // submit the command to retrieve the stream info.
    // additional processing will be done by the callback
    // procedure.
    //

    Status = SCSubmitRequest(SRB_GET_STREAM_INFO,
                             StreamBuffer,
                             ConfigInfo->StreamDescriptorSize,
                             SCStreamInfoCallback,
                             DeviceExtension,
                             NULL,
                             NULL,
                             Irp,
                             &RequestIssued,
                             &DeviceExtension->PendingQueue,
                             (PVOID) DeviceExtension->
                             MinidriverData->HwInitData.
                             HwReceivePacket
        );

    if (!RequestIssued) {

        ExFreePool(StreamBuffer);
        DebugPrint((DebugLevelError, "RescanStreams: couldn't issue request!\n"));
        TRAP;
        SCCompleteIrp(Irp, Status, DeviceExtension);
        return;

    }
    //
    // processing will continue in callback procedure.
    //

    return;

}
#endif // SUPPORT_MULTIPLE_FILTER_TYPES

BOOLEAN
SCCheckIfStreamsRunning(
                        IN PFILTER_INSTANCE FilterInstance
)
/*++

Routine Description:

Arguments:

Return Value:

--*/

{

    PSTREAM_OBJECT  StreamObject;
    PLIST_ENTRY     StreamListEntry,
                    StreamObjectEntry;

    //
    // process the streams on this list
    //


    StreamListEntry = StreamObjectEntry = &FilterInstance->FirstStream;

    while (StreamObjectEntry->Flink != StreamListEntry) {

        StreamObjectEntry = StreamObjectEntry->Flink;

        //
        // follow the link to the stream
        // object
        //

        StreamObject = CONTAINING_RECORD(StreamObjectEntry,
                                         STREAM_OBJECT,
                                         NextStream);

        if (StreamObject->CurrentState == KSSTATE_RUN) {

            return (TRUE);


        }                       // if running
    }                           // while streams

    return (FALSE);

}

VOID
SCCallBackSrb(
              IN PSTREAM_REQUEST_BLOCK Srb,
              IN PDEVICE_EXTENSION DeviceExtension
)
/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    KIRQL           Irql;

    if (DeviceExtension->NoSync) {

        KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

        if (Srb->DoNotCallBack) {
            TRAP;
            DebugPrint((DebugLevelError, "'ScCallback: NOT calling back request - Irp = %x",
                        Srb->HwSRB.Irp));
            KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);
            return;

        }                       // if NoCallback
        KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);
    }                           // if NoSync
    (Srb->Callback) (Srb);

}

#if DBG
VOID
SCDebugPriorityWorkItem(
                        IN PDEBUG_WORK_ITEM WorkItemStruct
)
/*++

Routine Description:


Arguments:


Return Value:

    None

--*/

{
    PCOMMON_OBJECT  Object = WorkItemStruct->Object;
    PHW_PRIORITY_ROUTINE Routine = WorkItemStruct->HwPriorityRoutine;
    PVOID           Context = WorkItemStruct->HwPriorityContext;

//    DebugPrint((DebugLevelFatal, "F %x\n", WorkItemStruct));
    ExFreePool(WorkItemStruct);

    Object->PriorityWorkItemScheduled = FALSE;

    if (Object->InterruptData.Flags &
        INTERRUPT_FLAGS_PRIORITY_CHANGE_REQUEST) {

        DebugPrint((DebugLevelFatal, "Stream Minidriver scheduled priority twice!\n"));
        ASSERT(1 == 0);
    }                           // if scheduled twice
    Routine(Context);

    if (Object->InterruptData.Flags &
        INTERRUPT_FLAGS_PRIORITY_CHANGE_REQUEST) {

        DebugPrint((DebugLevelFatal, "Stream Minidriver scheduled priority twice!\n"));
        ASSERT(1 == 0);
    }                           // if scheduled twice
}

#endif

PKSPROPERTY_SET
SCCopyMinidriverProperties(
                           IN ULONG NumProps,
                           IN PKSPROPERTY_SET MinidriverProps
)
/*++

Routine Description:

  Makes a private copy of the minidriver's properties

Arguments:

    NumProps - number of properties to process
    MinidriverProps - pointer to the array of properties to process

Return Value:

     None.

--*/

{
    PKSPROPERTY_ITEM CurrentPropItem;
    PKSPROPERTY_SET CurrentProp;
    ULONG           i,
                    BufferSize;
    PVOID           NewPropertyBuffer;

    #if DBG
    ULONG           TotalBufferUsed;
    #endif

    PAGED_CODE();

    CurrentProp = MinidriverProps;
    BufferSize = NumProps * sizeof(KSPROPERTY_SET);

    //
    // walk the minidriver's property sets to determine the size of the
    // buffer
    // needed.   Size computed from # of sets from above, + # of items.
    //

    for (i = 0; i < NumProps; i++) {

        BufferSize += CurrentProp->PropertiesCount * sizeof(KSPROPERTY_ITEM);

        //
        // index to next property set in
        // array
        //

        CurrentProp++;

    }                           // for number of property sets

    if (!(NewPropertyBuffer = ExAllocatePool(NonPagedPool, BufferSize))) {

        TRAP;
        return (NULL);
    }
    //
    // copy the array of sets over to the 1st part of the buffer.
    //

    RtlCopyMemory(NewPropertyBuffer,
                  MinidriverProps,
                  sizeof(KSPROPERTY_SET) * NumProps);

    //
    // walk thru the sets, copying the items for each set, and updating the
    // pointer to each item array in each set as we go.
    //

    CurrentProp = (PKSPROPERTY_SET) NewPropertyBuffer;
    CurrentPropItem = (PKSPROPERTY_ITEM) ((ULONG_PTR) NewPropertyBuffer + sizeof(KSPROPERTY_SET) * NumProps);

    #if DBG
    TotalBufferUsed = sizeof(KSPROPERTY_SET) * NumProps;
    #endif

    for (i = 0; i < NumProps; i++) {

        RtlCopyMemory(CurrentPropItem,
                      CurrentProp->PropertyItem,
                    CurrentProp->PropertiesCount * sizeof(KSPROPERTY_ITEM));

        #if DBG
        TotalBufferUsed += CurrentProp->PropertiesCount * sizeof(KSPROPERTY_ITEM);
        ASSERT(TotalBufferUsed <= BufferSize);
        #endif

        CurrentProp->PropertyItem = CurrentPropItem;

        CurrentPropItem += CurrentProp->PropertiesCount;
        CurrentProp++;

    }

    return ((PKSPROPERTY_SET) NewPropertyBuffer);

}


PKSEVENT_SET
SCCopyMinidriverEvents(
                       IN ULONG NumEvents,
                       IN PKSEVENT_SET MinidriverEvents
)
/*++

Routine Description:

  Makes a private copy of the minidriver's properties

Arguments:

    NumEvents - number of event sets to process
    MinidriverEvents - pointer to the array of properties to process

Return Value:

     None.

--*/

{
    PKSEVENT_ITEM   CurrentEventItem;
    PKSEVENT_SET    CurrentEvent;
    ULONG           i,
                    BufferSize;
    PVOID           NewEventBuffer;

	#if DBG
    ULONG           TotalBufferUsed;
	#endif

    PAGED_CODE();

    CurrentEvent = MinidriverEvents;
    BufferSize = NumEvents * sizeof(KSEVENT_SET);

    //
    // walk the minidriver's property sets to determine the size of the
    // buffer
    // needed.   Size computed from # of sets from above, + # of items.
    //

    for (i = 0; i < NumEvents; i++) {

        BufferSize += CurrentEvent->EventsCount * sizeof(KSEVENT_ITEM);

        //
        // index to next property set in
        // array
        //

        CurrentEvent++;

    }                           // for number of property sets

    if (!(NewEventBuffer = ExAllocatePool(NonPagedPool, BufferSize))) {

        TRAP;
        return (NULL);
    }
    //
    // copy the array of sets over to the 1st part of the buffer.
    //

    RtlCopyMemory(NewEventBuffer,
                  MinidriverEvents,
                  sizeof(KSEVENT_SET) * NumEvents);

    //
    // walk thru the sets, copying the items for each set, and updating the
    // pointer to each item array in each set as we go.
    //

    CurrentEvent = (PKSEVENT_SET) NewEventBuffer;
    CurrentEventItem = (PKSEVENT_ITEM) ((ULONG_PTR) NewEventBuffer + sizeof(KSEVENT_SET) * NumEvents);

	#if DBG
    TotalBufferUsed = sizeof(KSEVENT_SET) * NumEvents;
	#endif

    for (i = 0; i < NumEvents; i++) {

        RtlCopyMemory(CurrentEventItem,
                      CurrentEvent->EventItem,
                      CurrentEvent->EventsCount * sizeof(KSEVENT_ITEM));

		#if DBG
        TotalBufferUsed += CurrentEvent->EventsCount * sizeof(KSEVENT_ITEM);
        ASSERT(TotalBufferUsed <= BufferSize);
		#endif

        CurrentEvent->EventItem = CurrentEventItem;

        CurrentEventItem += CurrentEvent->EventsCount;
        CurrentEvent++;

    }

    return ((PKSEVENT_SET) NewEventBuffer);

}

#ifdef ENABLE_KS_METHODS

PKSMETHOD_SET
SCCopyMinidriverMethods(
                           IN ULONG NumMethods,
                           IN PKSMETHOD_SET MinidriverMethods
)
/*++

Routine Description:

  Makes a private copy of the minidriver's properties

Arguments:

    NumMethods - number of properties to process
    MinidriverMethods - pointer to the array of properties to process

Return Value:

     None.

--*/

{
    PKSMETHOD_ITEM CurrentMethodItem;
    PKSMETHOD_SET CurrentMethod;
    ULONG           i,
                    BufferSize;
    PVOID           NewMethodBuffer;

	#if DBG
    ULONG           TotalBufferUsed;
	#endif

    PAGED_CODE();

    CurrentMethod = MinidriverMethods;
    BufferSize = NumMethods * sizeof(KSMETHOD_SET);

    //
    // walk the minidriver's property sets to determine the size of the
    // buffer
    // needed.   Size computed from # of sets from above, + # of items.
    //

    for (i = 0; i < NumMethods; i++) {

        BufferSize += CurrentMethod->MethodsCount * sizeof(KSMETHOD_ITEM);

        //
        // index to next property set in
        // array
        //

        CurrentMethod++;

    }                           // for number of property sets

    if (!(NewMethodBuffer = ExAllocatePool(NonPagedPool, BufferSize))) {

        TRAP;
        return (NULL);
    }
    //
    // copy the array of sets over to the 1st part of the buffer.
    //

    RtlCopyMemory(NewMethodBuffer,
                  MinidriverMethods,
                  sizeof(KSMETHOD_SET) * NumMethods);

    //
    // walk thru the sets, copying the items for each set, and updating the
    // pointer to each item array in each set as we go.
    //

    CurrentMethod = (PKSMETHOD_SET) NewMethodBuffer;
    CurrentMethodItem = (PKSMETHOD_ITEM) ((ULONG_PTR) NewMethodBuffer + sizeof(KSMETHOD_SET) * NumMethods);

	#if DBG
    TotalBufferUsed = sizeof(KSMETHOD_SET) * NumMethods;
	#endif

    for (i = 0; i < NumMethods; i++) {

        RtlCopyMemory(CurrentMethodItem,
                      CurrentMethod->MethodItem,
                      CurrentMethod->MethodsCount * sizeof(KSMETHOD_ITEM));

		#if DBG
        TotalBufferUsed += CurrentMethod->MethodsCount * sizeof(KSMETHOD_ITEM);
        ASSERT(TotalBufferUsed <= BufferSize);
		#endif

        CurrentMethod->MethodItem = CurrentMethodItem;

        CurrentMethodItem += CurrentMethod->MethodsCount;
        CurrentMethod++;

    }

    return ((PKSMETHOD_SET) NewMethodBuffer);

}

VOID
SCUpdateMinidriverMethods(
                             IN ULONG NumMethods,
                             IN PKSMETHOD_SET MinidriverMethods,
                             IN BOOLEAN Stream
)
/*++

Routine Description:

     Process method to the device.

Arguments:

    NumMethods - number of methods to process
    MinidriverMethods - pointer to the array of methods to process
    Stream - TRUE indicates we are processing a set for the stream

Return Value:

     None.

--*/

{
    PKSMETHOD_ITEM CurrentMethodId;
    PKSMETHOD_SET CurrentMethod;
    ULONG           i,
                    j;

    PAGED_CODE();

    //
    // walk the minidriver's property info to fill in the dispatch
    // vectors as appropriate.
    //

    CurrentMethod = MinidriverMethods;

    for (i = 0; i < NumMethods; i++) {

        CurrentMethodId = (PKSMETHOD_ITEM) CurrentMethod->MethodItem;

        for (j = 0; j < CurrentMethod->MethodsCount; j++) {

            //
            // if support handler is supported, send it to the handler
            //

            if (CurrentMethodId->SupportHandler) {

                if (Stream) {

                    CurrentMethodId->SupportHandler = StreamClassMinidriverStreamMethod;

                } else {

                    CurrentMethodId->SupportHandler = StreamClassMinidriverDeviceMethod;
                }               // if stream

            }
            //
            // if method routine is
            // supported, add our vector.
            //

            if (CurrentMethodId->MethodHandler) {

                if (Stream) {

                    CurrentMethodId->MethodHandler = StreamClassMinidriverStreamMethod;
                } else {

                    CurrentMethodId->MethodHandler = StreamClassMinidriverDeviceMethod;
                }               // if stream

            }                   // if supported

            //
            // index to next method item in
            // array
            //

            CurrentMethodId++;

        }                       // for number of property items

        //
        // index to next method set in
        // array
        //

        CurrentMethod++;

    }                           // for number of method sets

}



NTSTATUS
SCMinidriverDeviceMethodHandler(
                                  IN SRB_COMMAND Command,
                                  IN PIRP Irp,
                                  IN PKSMETHOD Method,
                                  IN OUT PVOID MethodInfo
)
/*++

Routine Description:

     Process get/set method to the device.

Arguments:

    Command - either GET or SET method
    Irp - pointer to the IRP
    Method - pointer to the method structure
    MethodInfo - buffer for method information

Return Value:

     NTSTATUS returned as appropriate.

--*/

{
    PIO_STACK_LOCATION IrpStack;
    PDEVICE_EXTENSION DeviceExtension;
    PFILTER_INSTANCE FilterInstance;
    PSTREAM_METHOD_DESCRIPTOR MethodDescriptor;
    NTSTATUS        Status;
    BOOLEAN         RequestIssued;

    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = (PDEVICE_EXTENSION)
        (IrpStack->DeviceObject)->DeviceExtension;

    FilterInstance = IrpStack->FileObject->FsContext;

    MethodDescriptor = ExAllocatePool(NonPagedPool,
                                    sizeof(STREAM_METHOD_DESCRIPTOR));
    if (MethodDescriptor == NULL) {
        DEBUG_BREAKPOINT();
        DebugPrint((DebugLevelError,
                    "SCDeviceMethodHandler: No pool for descriptor"));
        return (STATUS_INSUFFICIENT_RESOURCES);
    }
    //
    // compute the index of the method set.
    //
    // this value is calculated by subtracting the base method set
    // pointer from the requested method set pointer.
    //
    // The requested method set is pointed to by Context[0] by
    // KsMethodHandler.
    //

    MethodDescriptor->MethodSetID = (ULONG)
        ((ULONG_PTR) Irp->Tail.Overlay.DriverContext[0] -
         IFN_MF((ULONG_PTR) DeviceExtension->DeviceMethodsArray)
         IF_MF((ULONG_PTR) FilterInstance->DeviceMethodsArray)
         ) / sizeof(KSMETHOD_SET);

    MethodDescriptor->Method = Method;
    MethodDescriptor->MethodInfo = MethodInfo;
    MethodDescriptor->MethodInputSize =
        IrpStack->Parameters.DeviceIoControl.InputBufferLength;
    MethodDescriptor->MethodOutputSize =
        IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // send a get or set method SRB to the device.
    //

    Status = SCSubmitRequest(Command,
                             MethodDescriptor,
                             0,
                             SCProcessCompletedMethodRequest,
                             DeviceExtension,
                             FilterInstance->HwInstanceExtension,
                             NULL,
                             Irp,
                             &RequestIssued,
                             &DeviceExtension->PendingQueue,
                             (PVOID) DeviceExtension->
                             MinidriverData->HwInitData.
                             HwReceivePacket
        );
    if (!RequestIssued) {

        DEBUG_BREAKPOINT();
        ExFreePool(MethodDescriptor);
    }
    return (Status);
}

NTSTATUS
SCMinidriverStreamMethodHandler(
                                  IN SRB_COMMAND Command,
                                  IN PIRP Irp,
                                  IN PKSMETHOD Method,
                                  IN OUT PVOID MethodInfo
)
/*++

Routine Description:

     Process get or set method to the device.

Arguments:

    Command - either GET or SET method
    Irp - pointer to the IRP
    Method - pointer to the method structure
    MethodInfo - buffer for method information

Return Value:

     None.

--*/

{
    PIO_STACK_LOCATION IrpStack;
    PDEVICE_EXTENSION DeviceExtension;
    PSTREAM_OBJECT  StreamObject;
    PSTREAM_METHOD_DESCRIPTOR MethodDescriptor;
    NTSTATUS        Status;
    BOOLEAN         RequestIssued;

    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = (PDEVICE_EXTENSION)
        (IrpStack->DeviceObject)->DeviceExtension;

    StreamObject = IrpStack->FileObject->FsContext;

    MethodDescriptor = ExAllocatePool(NonPagedPool,
                                    sizeof(STREAM_METHOD_DESCRIPTOR));
    if (MethodDescriptor == NULL) {
        DEBUG_BREAKPOINT();
        DebugPrint((DebugLevelError,
                    "SCDeviceMethodHandler: No pool for descriptor"));
        return (STATUS_INSUFFICIENT_RESOURCES);
    }
    //
    // compute the index of the method set.
    //
    // this value is calculated by subtracting the base method set
    // pointer from the requested method set pointer.
    //
    // The requested method set is pointed to by Context[0] by
    // KsMethodHandler.
    //

    MethodDescriptor->MethodSetID = (ULONG)
        ((ULONG_PTR) Irp->Tail.Overlay.DriverContext[0] -
         (ULONG_PTR) StreamObject->MethodInfo)
        / sizeof(KSMETHOD_SET);

    MethodDescriptor->Method = Method;
    MethodDescriptor->MethodInfo = MethodInfo;
    MethodDescriptor->MethodInputSize =
        IrpStack->Parameters.DeviceIoControl.InputBufferLength;
    MethodDescriptor->MethodOutputSize =
        IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    //
    // send a get or set method SRB to the stream.
    //

    Status = SCSubmitRequest(Command,
                             MethodDescriptor,
                             0,
                             SCProcessCompletedMethodRequest,
                             DeviceExtension,
                          StreamObject->FilterInstance->HwInstanceExtension,
                             &StreamObject->HwStreamObject,
                             Irp,
                             &RequestIssued,
                             &StreamObject->ControlPendingQueue,
                             (PVOID) StreamObject->HwStreamObject.
                             ReceiveControlPacket
        );

    if (!RequestIssued) {

        DEBUG_BREAKPOINT();
        ExFreePool(MethodDescriptor);
    }
    return (Status);
}

NTSTATUS
SCProcessCompletedMethodRequest(
                                  IN PSTREAM_REQUEST_BLOCK SRB
)
/*++
Routine Description:

    This routine processes a method request which has completed.

Arguments:

    SRB- address of completed STREAM request block

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    // free the method info structure and
    // complete the request
    //

    ExFreePool(SRB->HwSRB.CommandData.MethodInfo);

    //
    // set the information field from the SRB
    // transferlength field
    //

    SRB->HwSRB.Irp->IoStatus.Information = SRB->HwSRB.ActualBytesTransferred;

    return (SCDequeueAndDeleteSrb(SRB));

}
#endif // ENABLE_KS_METHODS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\dvd\class\upperapi.c ===
/*
Copyright (c) 1996  Microsoft Corporation

Module Name:

   upperapi.c

Abstract:

   This is the WDM streaming class driver.  This module contains code related
   to the driver's upper edge api.

Author:

   billpa

Environment:

   Kernel mode only


Revision History:

--*/

#include "codcls.h"
#include "ksguid.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FilterDispatchGlobalCreate)
#pragma alloc_text(PAGE, FilterDispatchIoControl)
#pragma alloc_text(PAGE, FilterDispatchClose)
#pragma alloc_text(PAGE, StreamDispatchCreate)
#pragma alloc_text(PAGE, StreamDispatchIoControl)
#pragma alloc_text(PAGE, StreamDispatchClose)
#pragma alloc_text(PAGE, ClockDispatchCreate)
#pragma alloc_text(PAGE, ClockDispatchIoControl)
#pragma alloc_text(PAGE, ClockDispatchClose)
#pragma alloc_text(PAGE, StreamClassMinidriverDeviceGetProperty)
#pragma alloc_text(PAGE, StreamClassMinidriverDeviceSetProperty)
#pragma alloc_text(PAGE, StreamClassMinidriverStreamGetProperty)
#pragma alloc_text(PAGE, StreamClassMinidriverStreamSetProperty)
#pragma alloc_text(PAGE, StreamClassNull)
#pragma alloc_text(PAGE, SCStreamDeviceState)
#pragma alloc_text(PAGE, SCStreamDeviceRate)
#pragma alloc_text(PAGE, SCFilterPinInstances)
#pragma alloc_text(PAGE, SCFilterPinPropertyHandler)
#pragma alloc_text(PAGE, SCOpenStreamCallback)
#pragma alloc_text(PAGE, SCOpenMasterCallback)

#if ENABLE_MULTIPLE_FILTER_TYPES
#else
#pragma alloc_text(PAGE, SCGlobalInstanceCallback)
#endif

#pragma alloc_text(PAGE, SCSetMasterClock)
#pragma alloc_text(PAGE, SCClockGetTime)
#pragma alloc_text(PAGE, SCGetStreamDeviceState)
#pragma alloc_text(PAGE, SCStreamDeviceRateCapability)
#pragma alloc_text(PAGE, SCStreamProposeNewFormat)
#pragma alloc_text(PAGE, SCStreamSetFormat)
#pragma alloc_text(PAGE, AllocatorDispatchCreate)
#pragma alloc_text(PAGE, SCGetMasterClock)
#pragma alloc_text(PAGE, SCClockGetPhysicalTime)
#pragma alloc_text(PAGE, SCClockGetSynchronizedTime)
#pragma alloc_text(PAGE, SCClockGetFunctionTable)
#pragma alloc_text(PAGE, SCCloseClockCallback)
#pragma alloc_text(PAGE, SCFilterTopologyHandler)
#pragma alloc_text(PAGE, SCFilterPinIntersectionHandler)
#pragma alloc_text(PAGE, SCIntersectHandler)
#pragma alloc_text(PAGE, SCDataIntersectionCallback)
#pragma alloc_text(PAGE, SCGetStreamHeaderSize)
#pragma alloc_text(PAGE, DllUnload)

#ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
#pragma alloc_text(PAGE, SCStreamAllocator)
#pragma alloc_text(PAGE, AllocateFrame)
#pragma alloc_text(PAGE, FreeFrame)
#pragma alloc_text(PAGE, PrepareTransfer)
#pragma alloc_text(PAGE, PinCreateHandler)
#endif

#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif

static const WCHAR ClockTypeName[] = KSSTRING_Clock;
static const WCHAR AllocatorTypeName[] = KSSTRING_Allocator;

//
// this structure is the dispatch table for a filter instance of the device
//

DEFINE_KSDISPATCH_TABLE(
                        FilterDispatchTable,
                        FilterDispatchIoControl,
                        KsDispatchInvalidDeviceRequest,
                        KsDispatchInvalidDeviceRequest,
                        KsDispatchInvalidDeviceRequest,
                        FilterDispatchClose,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL);

//
// dispatch table for pin properties that we support in the class driver
//

static          DEFINE_KSPROPERTY_TABLE(PinPropertyHandlers)
{
    DEFINE_KSPROPERTY_ITEM_PIN_CINSTANCES(SCFilterPinInstances),
    DEFINE_KSPROPERTY_ITEM_PIN_CTYPES(SCFilterPinPropertyHandler),
    DEFINE_KSPROPERTY_ITEM_PIN_DATAFLOW(SCFilterPinPropertyHandler),
    DEFINE_KSPROPERTY_ITEM_PIN_DATARANGES(SCFilterPinPropertyHandler),
    DEFINE_KSPROPERTY_ITEM_PIN_DATAINTERSECTION(SCFilterPinIntersectionHandler),
    DEFINE_KSPROPERTY_ITEM_PIN_INTERFACES(SCFilterPinPropertyHandler),
    DEFINE_KSPROPERTY_ITEM_PIN_MEDIUMS(SCFilterPinPropertyHandler),
    DEFINE_KSPROPERTY_ITEM_PIN_COMMUNICATION(SCFilterPinPropertyHandler),
//  DEFINE_KSPROPERTY_ITEM_PIN_GLOBALCINSTANCES(),
//  DEFINE_KSPROPERTY_ITEM_PIN_NECESSARYINSTANCES(),
//  DEFINE_KSPROPERTY_ITEM_PIN_PHYSICALCONNECTION(),
    DEFINE_KSPROPERTY_ITEM_PIN_CATEGORY(SCFilterPinPropertyHandler),
    DEFINE_KSPROPERTY_ITEM_PIN_NAME(SCFilterPinPropertyHandler)
};

static          DEFINE_KSPROPERTY_TOPOLOGYSET(
                                                   TopologyPropertyHandlers,
                                                   SCFilterTopologyHandler);

//
// filter property sets supported by the class driver
//

static          DEFINE_KSPROPERTY_SET_TABLE(FilterPropertySets)
{
    DEFINE_KSPROPERTY_SET(
                          &KSPROPSETID_Pin,
                          SIZEOF_ARRAY(PinPropertyHandlers),
                          (PKSPROPERTY_ITEM) PinPropertyHandlers,
                          0, NULL),
    DEFINE_KSPROPERTY_SET(
                          &KSPROPSETID_Topology,
                          SIZEOF_ARRAY(TopologyPropertyHandlers),
                          (PKSPROPERTY_ITEM) TopologyPropertyHandlers,
                          0, NULL),
};

//
// handlers for the control properties
//

static          DEFINE_KSPROPERTY_TABLE(StreamControlHandlers)
{
    DEFINE_KSPROPERTY_ITEM_CONNECTION_STATE(SCGetStreamDeviceState, SCStreamDeviceState),
//  DEFINE_KSPROPERTY_ITEM_CONNECTION_PRIORITY(),
//  DEFINE_KSPROPERTY_ITEM_CONNECTION_DATAFORMAT(),
//  DEFINE_KSPROPERTY_ITEM_CONNECTION_ALLOCATORFRAMING(),
    DEFINE_KSPROPERTY_ITEM_CONNECTION_PROPOSEDATAFORMAT(SCStreamProposeNewFormat),
    DEFINE_KSPROPERTY_ITEM_CONNECTION_DATAFORMAT(NULL, SCStreamSetFormat),
//  DEFINE_KSPROPERTY_ITEM_CONNECTION_ACQUIREORDERING(),
};

DEFINE_KSPROPERTY_TABLE(StreamStreamHandlers)
{
#ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
    DEFINE_KSPROPERTY_ITEM_STREAM_ALLOCATOR(SCStreamAllocator,SCStreamAllocator),
#else
//  DEFINE_KSPROPERTY_ITEM_STREAM_ALLOCATOR(),
#endif
//  DEFINE_KSPROPERTY_ITEM_STREAM_QUALITY(),
//  DEFINE_KSPROPERTY_ITEM_STREAM_DEGRADATION(),
    DEFINE_KSPROPERTY_ITEM_STREAM_MASTERCLOCK(NULL, SCSetMasterClock),
//  DEFINE_KSPROPERTY_ITEM_STREAM_TIMEFORMAT(),
//  DEFINE_KSPROPERTY_ITEM_STREAM_PRESENTATIONTIME(),
//  DEFINE_KSPROPERTY_ITEM_STREAM_PRESENTATIONEXTENT(),
//  DEFINE_KSPROPERTY_ITEM_STREAM_FRAMETIME(),
        DEFINE_KSPROPERTY_ITEM_STREAM_RATECAPABILITY(SCStreamDeviceRateCapability),
        DEFINE_KSPROPERTY_ITEM_STREAM_RATE(NULL, SCStreamDeviceRate),
};

DEFINE_KSPROPERTY_TABLE(StreamInterfaceHandlers)
{
    {
        KSPROPERTY_STREAMINTERFACE_HEADERSIZE,
            SCGetStreamHeaderSize,
            0,
            0,
            NULL,
            0,
            0,
            NULL
    }
};

//
// stream property sets supported by the class driver
//

static          DEFINE_KSPROPERTY_SET_TABLE(StreamProperties)
{
    DEFINE_KSPROPERTY_SET(
                          &KSPROPSETID_Connection,
                          SIZEOF_ARRAY(StreamControlHandlers),
                          (PVOID) StreamControlHandlers,
                          0, NULL),
    DEFINE_KSPROPERTY_SET(
                          &KSPROPSETID_Stream,
                          SIZEOF_ARRAY(StreamStreamHandlers),
                          (PVOID) StreamStreamHandlers,
                          0, NULL),
    DEFINE_KSPROPERTY_SET(
                          &KSPROPSETID_StreamInterface,
                          SIZEOF_ARRAY(StreamInterfaceHandlers),
                          (PVOID) StreamInterfaceHandlers,
                          0, NULL),
};

//
// template for on the fly constructed properties
// DO NOT CHANGE without MODIFYING the code that references this set.
//

DEFINE_KSPROPERTY_TABLE(ConstructedStreamHandlers)
{
    DEFINE_KSPROPERTY_ITEM_STREAM_MASTERCLOCK(SCGetMasterClock, SCSetMasterClock)
};


//
// template for on-the-fly constructed property sets.
// DO NOT CHANGE without MODIFYING the code that references this set.
//

static          DEFINE_KSPROPERTY_SET_TABLE(ConstructedStreamProperties)
{
    DEFINE_KSPROPERTY_SET(
                          &KSPROPSETID_Stream,
                          SIZEOF_ARRAY(ConstructedStreamHandlers),
                          (PVOID) ConstructedStreamHandlers,
                          0, NULL),
};


static const    DEFINE_KSCREATE_DISPATCH_TABLE(StreamDriverDispatch)
{

    DEFINE_KSCREATE_ITEM(ClockDispatchCreate,
                         ClockTypeName,
                         0),
    DEFINE_KSCREATE_ITEM(AllocatorDispatchCreate,
                         AllocatorTypeName,
                         0),
};


//
// dispatch table for stream functions
//

DEFINE_KSDISPATCH_TABLE(
                        StreamDispatchTable,
                        StreamDispatchIoControl,
                        KsDispatchInvalidDeviceRequest,
                        KsDispatchInvalidDeviceRequest,
                        KsDispatchInvalidDeviceRequest,
                        StreamDispatchClose,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL);

DEFINE_KSDISPATCH_TABLE(
                        ClockDispatchTable,
                        ClockDispatchIoControl,
                        KsDispatchInvalidDeviceRequest,
                        KsDispatchInvalidDeviceRequest,
                        KsDispatchInvalidDeviceRequest,
                        ClockDispatchClose,
                        KsDispatchInvalidDeviceRequest,
                        KsDispatchInvalidDeviceRequest,
                        KsDispatchFastIoDeviceControlFailure,
                        KsDispatchFastReadFailure,
                        KsDispatchFastWriteFailure);

DEFINE_KSPROPERTY_TABLE(ClockPropertyItems)
{
    DEFINE_KSPROPERTY_ITEM_CLOCK_TIME(SCClockGetTime),
        DEFINE_KSPROPERTY_ITEM_CLOCK_PHYSICALTIME(SCClockGetPhysicalTime),
        DEFINE_KSPROPERTY_ITEM_CLOCK_CORRELATEDTIME(SCClockGetSynchronizedTime),
//  DEFINE_KSPROPERTY_ITEM_CLOCK_CORRELATEDPHYSICALTIME(),
//  DEFINE_KSPROPERTY_ITEM_CLOCK_RESOLUTION(SCClockGetResolution),
//  DEFINE_KSPROPERTY_ITEM_CLOCK_STATE(SCClockGetState),
        DEFINE_KSPROPERTY_ITEM_CLOCK_FUNCTIONTABLE(SCClockGetFunctionTable)
};


DEFINE_KSPROPERTY_SET_TABLE(ClockPropertySets)
{
    DEFINE_KSPROPERTY_SET(
                          &KSPROPSETID_Clock,
                          SIZEOF_ARRAY(ClockPropertyItems),
                          ClockPropertyItems,
                          0,
                          NULL
        )
};

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

#if ENABLE_MULTIPLE_FILTER_TYPES

NTSTATUS
FilterDispatchGlobalCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp)
/*++

Routine Description:

    This routine receives global createfile IRP's for the device.

	After the Srb_Open_Device_Instance instance we immediate
	send Srb_Get_Stream_Info for this filter.

Arguments:
    DeviceObject - device object for the device
    Irp - probably an IRP, silly

Return Value:

    The IRP status is set as appropriate

--*/
{

    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION IrpStack;
    PFILTER_INSTANCE FilterInstance;
    NTSTATUS        Status; // = STATUS_TOO_MANY_OPENED_FILES;

    IFN_MF( PAGED_CODE());

    IrpStack = IoGetCurrentIrpStackLocation(Irp);


    DebugPrint((DebugLevelTrace,
                "'Closing global filter with Irp %x\n", Irp));


    //
    // show one more I/O pending & verify that we can actually do I/O.
    //

    Status = SCShowIoPending(DeviceObject->DeviceExtension, Irp);

    if ( !NT_SUCCESS ( Status )) {
        //
        // the device is currently not accessible, so just return with error
        //

        return (Status);

    }                           // if !showiopending
    
    //
    // if the device is not started, bail out.
    // swenum enables device interfaces very early. It should not have
    // done that for the pdo. we, the fdo, should be the one to
    // enable this. for now, try to work around the problem that we
    // come here before device is started.
    //
    if ( DeviceExtension->RegistryFlags & DRIVER_USES_SWENUM_TO_LOAD ) {
        #define OPEN_TIMEOUT -1000*1000 // 100 mili second
        #define OPEN_WAIT 50
        LARGE_INTEGER liOpenTimeOut;
        int i;

        liOpenTimeOut.QuadPart = OPEN_TIMEOUT;

        for ( i=0; i < OPEN_WAIT; i++ ) {
            if ( DeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED ) {
                break;
            }
            KeDelayExecutionThread( KernelMode, FALSE, &liOpenTimeOut );
        }

        if ( 0 == (DeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED) ) {
            Status = STATUS_DEVICE_NOT_READY;
            Irp->IoStatus.Status = Status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            DebugPrint((DebugLevelError,
                        "SWEnum device %p not ready!\n", DeviceObject));
            return Status;
        }
    }

    //
    // show one more reference to driver.
    //

    SCReferenceDriver(DeviceExtension);
    
    //
    // set the context of createfiles for the filter
    //

    KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                          Executive,
                          KernelMode,
                          FALSE,// not alertable
                          NULL);

    //
    // Make sure adapter is powered on
    //

    SCCheckPoweredUp(DeviceExtension);

    Status = SCOpenMinidriverInstance(DeviceExtension,
                                      &FilterInstance,
                                      NULL, //SCGlobalInstanceCallback,
                                      Irp);

    //
    // if status != success, we failed so dereference the
    // driver.
    //

    if (!NT_SUCCESS(Status)) {

        //
        // show one fewer reference to driver.
        //
        SCDereferenceDriver(DeviceExtension);
    }

    else {
        //
   	    // Open is successul. Fill in the filter dispatch table pointer
       	//
        
       	if ( 0 == DeviceExtension->NumberOfOpenInstances ||
       	     0 != DeviceExtension->FilterExtensionSize ) {
       	    //
            // 1st open of 1x1 or non 1x1 ( i.e. instance opne )
       		//
       		// add FilterInstance to DeviceExtension except non-1st open of legacy 1x1 
			//		
            PHW_STREAM_DESCRIPTOR StreamDescriptor, StreamDescriptorI;
            ULONG nPins;

            //
            // remeber DO for later
            //
            FilterInstance->DeviceObject = DeviceObject;

			//
			// Process stream info for this filterinstance
			//
			StreamDescriptorI = DeviceExtension->FilterTypeInfos
    			    [FilterInstance->FilterTypeIndex].StreamDescriptor;

    	    nPins = StreamDescriptorI->StreamHeader.NumberOfStreams;
			
            StreamDescriptor = 
                ExAllocatePool(	NonPagedPool,
                    sizeof(HW_STREAM_HEADER) +
                        sizeof(HW_STREAM_INFORMATION) * nPins );

            if ( NULL != StreamDescriptor ) {

                RtlCopyMemory( StreamDescriptor,
                               StreamDescriptorI,
                               sizeof(HW_STREAM_HEADER) +
                                   sizeof(HW_STREAM_INFORMATION) * nPins );

    			    
    			Status = SciOnFilterStreamDescriptor( 
    			                FilterInstance,
    			                StreamDescriptor);

                if ( NT_SUCCESS( Status ) ) {
                    FilterInstance->StreamDescriptor = StreamDescriptor;
                    DebugPrint((DebugLevelInfo,
                               "NumNameExtensions=%x NumopenInstances=%x "
                               "FilterInstance %x StreamDescriptor %x\n",
                               DeviceExtension->NumberOfNameExtensions,
                               DeviceExtension->NumberOfOpenInstances,
                               FilterInstance,
                               StreamDescriptor));
                }
            }
            else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }

		}
		
        DeviceExtension->NumberOfOpenInstances++;        
        DebugPrint((DebugLevelVerbose,
                    "DevExt:%x, Open OpenCount=%x\n", 
                    DeviceExtension,
                    DeviceExtension->NumberOfOpenInstances));

        //
        // Make FilterInstance the File Handle Context
        //
        IrpStack->FileObject->FsContext = FilterInstance;
        DebugPrint((DebugLevelVerbose, 
                    "CreateFilterInstance=%x ExtSize=%x\n",
                    FilterInstance, 
                    DeviceExtension->MinidriverData->HwInitData.FilterInstanceExtensionSize ));

        //
        // Reference the FDO so that itwon't go away before all handles are closed.
        //
        ObReferenceObject(DeviceObject);
    }

    //
    // we're done so release the event
    //

    KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);



    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    return (SCCompleteIrp(Irp, Status, DeviceExtension));
}

#else // ENABLE_MULTIPLE_FILTER_TYPES

#endif // ENABLE_MULTIPLE_FILTER_TYPES


NTSTATUS
StreamDispatchCreate(
                     IN PDEVICE_OBJECT DeviceObject,
                     IN PIRP Irp
)
/*++

Routine Description:

    This routine receives createfile IRP's for a stream.

Arguments:
    DeviceObject - device object for the device
    Irp - probably an IRP, silly

Return Value:

    The IRP status is set as appropriate

--*/

{

    NTSTATUS        Status;
    PFILTER_INSTANCE FilterInstance;
    PIO_STACK_LOCATION IrpStack;
    PKSPIN_CONNECT  Connect;
    PFILE_OBJECT    FileObject;
    PSTREAM_OBJECT  StreamObject;
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION)
    DeviceObject->DeviceExtension;
    PHW_STREAM_INFORMATION CurrentInfo;
    ULONG           i;
    BOOLEAN         RequestIssued;
    PADDITIONAL_PIN_INFO AdditionalInfo;

    DebugPrint((DebugLevelTrace,
                "'Creating stream with Irp %x\n", Irp));

    PAGED_CODE();

    DebugPrint((DebugLevelTrace,"entering StreamDispatchCreate()\n"));

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    DeviceExtension = DeviceObject->DeviceExtension;

    //
    // show one more I/O pending & verify that we can actually do I/O.
    //

    Status = SCShowIoPending(DeviceExtension, Irp);

    if ( !NT_SUCCESS ( Status )) {

        //
        // the device is currently not accessible, so just return with error
        //

        DebugPrint((DebugLevelError,"exiting StreamDispatchCreate():error1\n"));
        return (Status);

    }

    //
    // get the parent file object from the child object.
    //

    FileObject = IrpStack->FileObject->RelatedFileObject;

    //
    // get the filter instance & additional info pointers
    //

    FilterInstance =
        (PFILTER_INSTANCE) FileObject->FsContext;

    AdditionalInfo = FilterInstance->PinInstanceInfo;
    
    DebugPrint((DebugLevelVerbose,
                    "FilterInstance=%x NumberOfPins=%x PinInfo=%x\n",
                    FilterInstance,
                    FilterInstance->NumberOfPins,
                    FilterInstance->PinInformation));
                    
    Status = KsValidateConnectRequest(Irp,
                                          FilterInstance->NumberOfPins,
                                          FilterInstance->PinInformation,
                                          &Connect);
                                          
    if ( !NT_SUCCESS( Status )) {                                                      

            DebugPrint((DebugLevelError,
                        "exiting StreamDispatchCreate():error2\n"));
            return (SCCompleteIrp(Irp, Status, DeviceExtension));
    }
    
    //
    // take the control event to protect the instance counter
    //

    KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                          Executive,
                          KernelMode,
                          FALSE,// not alertable
                          NULL);

    //
    // if the # of instances for this pin is already opened, error the
    // request.
    //

    DebugPrint((DebugLevelVerbose,
               "AdditionalInfo@%x PinId=%x CurrentInstances=%x Max=%x\n",
               AdditionalInfo, Connect->PinId, 
               AdditionalInfo[Connect->PinId].CurrentInstances,
               AdditionalInfo[Connect->PinId].MaxInstances));
               
    if (AdditionalInfo[Connect->PinId].CurrentInstances ==
        AdditionalInfo[Connect->PinId].MaxInstances) {

        DebugPrint((DebugLevelWarning,
                    "StreamDispatchCreate: too many opens "));
        KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
        DebugPrint((DebugLevelError,"exiting StreamDispatchCreate():error3\n"));
        return (SCCompleteIrp(Irp, STATUS_TOO_MANY_OPENED_FILES, DeviceExtension));
    }
    //
    // initialize the stream object for this instance
    //

    StreamObject = ExAllocatePool(NonPagedPool,
                                  sizeof(STREAM_OBJECT) +
                                  DeviceExtension->MinidriverData->
                                  HwInitData.PerStreamExtensionSize
        );

    if (!StreamObject) {
        DebugPrint((DebugLevelError,
                    "StreamDispatchCreate: No pool for stream info"));

        KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
        DebugPrint((DebugLevelError,"exiting StreamDispatchCreate():error4\n"));
        return (SCCompleteIrp(Irp, STATUS_INSUFFICIENT_RESOURCES, DeviceExtension));
    }
    RtlZeroMemory(StreamObject,
                  sizeof(STREAM_OBJECT) +
                  DeviceExtension->MinidriverData->
                  HwInitData.PerStreamExtensionSize
        );

    //
    // TODO: Remove this once KS can multiplex CLEANUP requests.
    //
    StreamObject->ComObj.Cookie = STREAM_OBJECT_COOKIE;

    //
    // default state to stopped
    //

    StreamObject->CurrentState = KSSTATE_STOP;

    KsAllocateObjectHeader(&StreamObject->ComObj.DeviceHeader,
                           SIZEOF_ARRAY(StreamDriverDispatch),
                           (PKSOBJECT_CREATE_ITEM) StreamDriverDispatch,
                           Irp,
                           (PKSDISPATCH_TABLE) & StreamDispatchTable);

    StreamObject->HwStreamObject.StreamNumber = Connect->PinId;
    StreamObject->FilterFileObject = FileObject;
    StreamObject->FileObject = IrpStack->FileObject;
    StreamObject->FilterInstance = FilterInstance;
    StreamObject->DeviceExtension = DeviceExtension;

    #ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
    StreamObject->PinToHandle = Connect->PinToHandle;
    #endif

    KeInitializeEvent (&StreamObject -> StopEvent, SynchronizationEvent, FALSE);

    //
    // For potential "source" pins, don't start sourcing standard 
    // medium/interface stream requests across non-standard medium/interfaces.
    //
    if (!IsEqualGUIDAligned (&Connect->Medium.Set, &KSMEDIUMSETID_Standard) ||
        !IsEqualGUIDAligned (&Connect->Interface.Set, &KSINTERFACESETID_Standard)) {
        StreamObject->StandardTransport = FALSE;
    } else {
        StreamObject -> StandardTransport = TRUE;
    }

    //
    // set the minidriver's parameters in the HwStreamObject struct.
    //

    StreamObject->HwStreamObject.SizeOfThisPacket = sizeof(HW_STREAM_OBJECT);

    StreamObject->HwStreamObject.HwDeviceExtension =
        DeviceExtension->HwDeviceExtension;

    StreamObject->HwStreamObject.HwStreamExtension =
        (PVOID) (StreamObject + 1);

    //
    // walk the minidriver's stream info structure to find the properties
    // for this stream.
    //

    
    if ( NULL == FilterInstance->StreamDescriptor ) {
        //
        // has not reenum, use the global one
        //
        CurrentInfo = &DeviceExtension->StreamDescriptor->StreamInfo;
    }
    else {
        CurrentInfo = &FilterInstance->StreamDescriptor->StreamInfo;
    }

    CurrentInfo = CurrentInfo + Connect->PinId;

    //
    // set the property info in the stream object.
    //
    
    StreamObject->PropertyInfo = FilterInstance->
        StreamPropEventArray[Connect->PinId].StreamPropertiesArray;
    StreamObject->PropInfoSize = CurrentInfo->
        NumStreamPropArrayEntries;
        
    //
    // set the event info in the stream object
    //

    StreamObject->EventInfo = FilterInstance->
        StreamPropEventArray[Connect->PinId].StreamEventsArray;
    StreamObject->EventInfoCount = CurrentInfo->
        NumStreamEventArrayEntries;

    // moved from callback
    InitializeListHead(&StreamObject->NotifyList);        

    //
    // call the minidriver to open the stream.  processing will continue
    // when the callback procedure is called.
    //

    Status = SCSubmitRequest(SRB_OPEN_STREAM,
                             (PVOID) (Connect + 1),
                             0,
                             SCOpenStreamCallback,
                             DeviceExtension,
                             FilterInstance->HwInstanceExtension,
                             &StreamObject->HwStreamObject,
                             Irp,
                             &RequestIssued,
                             &DeviceExtension->PendingQueue,
                             (PVOID) DeviceExtension->
                             MinidriverData->HwInitData.
                             HwReceivePacket
        );

    if (!RequestIssued) {

        //
        // failure submitting the request
        //

        DEBUG_BREAKPOINT();

        ExFreePool(StreamObject);
        DebugPrint((DebugLevelWarning,
                    "StreamClassOpen: stream open failed"));

        KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
        DebugPrint((DebugLevelError,"exiting StreamDispatchCreate():error6\n"));
        return (SCCompleteIrp(Irp, Status, DeviceExtension));

    }

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    DebugPrint((DebugLevelTrace,"exiting StreamDispatchCreate()\n"));
    return (Status);
}




NTSTATUS
SCOpenStreamCallback(
                     IN PSTREAM_REQUEST_BLOCK SRB
)
/*++

Routine Description:

     Process the completion of a stream open

Arguments:

     SRB - address of the completed SRB

Return Value:

     None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;
    PSTREAM_OBJECT  StreamObject = CONTAINING_RECORD(
                                                     SRB->HwSRB.StreamObject,
                                                     STREAM_OBJECT,
                                                     HwStreamObject
    );

    PIRP            Irp = SRB->HwSRB.Irp;
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS        Status = SRB->HwSRB.Status;
    PADDITIONAL_PIN_INFO AdditionalInfo;
    PVOID           PropertyInfo;
    PKSPROPERTY_ITEM PropertyItem;
    PHW_STREAM_INFORMATION CurrentInfo;
    ULONG           i;

    PAGED_CODE();

    if (NT_SUCCESS(Status)) {

        //
        // if required parameters have not been filled in, fail the open.
        //

        if (!StreamObject->HwStreamObject.ReceiveControlPacket) {

            DEBUG_BREAKPOINT();

            ExFreePool(StreamObject);
            SRB->HwSRB.Status = STATUS_ADAPTER_HARDWARE_ERROR;
            KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
            return (SCProcessCompletedRequest(SRB));
        }
        //
        // if the minidriver does not accept data, use dummy routine.
        //

        if (!StreamObject->HwStreamObject.ReceiveDataPacket) {

            StreamObject->HwStreamObject.ReceiveDataPacket = SCErrorDataSRB;
        }
        //
        // Save the pointer to our per stream structure in the FsContext
        // field of FileObject.  Null out the 2nd context param.
        //

        IrpStack->FileObject->FsContext = StreamObject;
        IrpStack->FileObject->FsContext2 = NULL;

        //
        // Initialize ControlSetMasterClock to serialize the concurrent
        // calls of the function on us, and lock the Read/write of the
        // MasterLockInfo
        //
        KeInitializeEvent(&StreamObject->ControlSetMasterClock, SynchronizationEvent, TRUE);
        KeInitializeSpinLock(&StreamObject->LockUseMasterClock );
                    
        DebugPrint((DebugLevelTrace, "'StreamClassOpen: Stream opened.\n"));

        //
        // Initialize minidriver timer and timer DPC for this stream
        //

        KeInitializeTimer(&StreamObject->ComObj.MiniDriverTimer);
        KeInitializeDpc(&StreamObject->ComObj.MiniDriverTimerDpc,
                        SCMinidriverStreamTimerDpc,
                        StreamObject);

        //
        // initialize the lists for this stream
        //
 
        InitializeListHead(&StreamObject->DataPendingQueue);
        InitializeListHead(&StreamObject->ControlPendingQueue);
        InitializeListHead(&StreamObject->NextStream);
        // a mini driver might start to call GetNextEvent once
        // returns from SRB_OPNE_STREAM. Do it earlier than submit.
        //InitializeListHead(&StreamObject->NotifyList);

        #ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR

        InitializeListHead(&StreamObject->FreeQueue);
        KeInitializeSpinLock(&StreamObject->FreeQueueLock );

        InitializeListHead(&StreamObject->Queues[READ].ActiveQueue);
        KeInitializeSpinLock(&StreamObject->Queues[READ].QueueLock );

        InitializeListHead(&StreamObject->Queues[WRITE].ActiveQueue);
        KeInitializeSpinLock(&StreamObject->Queues[WRITE].QueueLock );

        StreamObject->PinId = StreamObject->HwStreamObject.StreamNumber;
    	StreamObject->PinType = IrpSink;		// assume irp sink

        if (StreamObject->PinToHandle) {  // if irp source

            StreamObject->PinType = IrpSource;
            Status = PinCreateHandler( Irp, StreamObject );
    
            if (!NT_SUCCESS(Status)) {
                DebugPrint((DebugLevelError,
                    "\nStreamDispatchCreate: PinCreateHandler() returned ERROR"));

                ExFreePool(StreamObject);
                SRB->HwSRB.Status = Status;
                KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
                return (SCProcessCompletedRequest(SRB));
            }
        }
        #endif
        //
        // show we're ready for a request.   Don't show this for data if the
        // minidriver does not want data on this stream.
        //

        CurrentInfo = &DeviceExtension->StreamDescriptor->StreamInfo;

        for (i = 0; i < StreamObject->HwStreamObject.StreamNumber; i++) {

            //
            // index to next streaminfo structure
            //

            CurrentInfo++;
        }

        if (CurrentInfo->DataAccessible) {

            StreamObject->ReadyForNextDataReq = TRUE;
        }
        StreamObject->ReadyForNextControlReq = TRUE;

        //
        // call locked routine to insert this stream in the list
        //

        SCInsertStreamInFilter(StreamObject, DeviceExtension);

        //
        // reference the filter so we won't be called to close the instance
        // before all streams are closed.
        //

        ObReferenceObject(IrpStack->FileObject->RelatedFileObject);

        //
        // call routine to update the persisted properties for this pin, if
        // any.
        //

        SCUpdatePersistedProperties(StreamObject, DeviceExtension,
                                    IrpStack->FileObject);

        //
        // show one more instance of this pin opened.
        //

        AdditionalInfo = ((PFILTER_INSTANCE) IrpStack->FileObject->
                          RelatedFileObject->FsContext)->PinInstanceInfo;

        AdditionalInfo[StreamObject->HwStreamObject.StreamNumber].
            CurrentInstances++;

        //
        // construct on-the-fly properties for the stream, if necessary
        //

        if (StreamObject->HwStreamObject.HwClockObject.HwClockFunction) {

            //
            // create a property set describing the characteristics of the
            // clock.
            //

            PropertyInfo = ExAllocatePool(PagedPool,
                                          sizeof(ConstructedStreamHandlers) +
                                       sizeof(ConstructedStreamProperties));

            if (PropertyInfo) {

                PropertyItem = (PKSPROPERTY_ITEM) ((ULONG_PTR) PropertyInfo +
                                       sizeof(ConstructedStreamProperties));

                RtlCopyMemory(PropertyInfo,
                              &ConstructedStreamProperties,
                              sizeof(ConstructedStreamProperties));

                RtlCopyMemory(PropertyItem,
                              &ConstructedStreamHandlers,
                              sizeof(ConstructedStreamHandlers));


                //
                // patch the address of the handler
                //

                ((PKSPROPERTY_SET) PropertyInfo)->PropertyItem = PropertyItem;

                //
                // modify the master clock property based on the support
                // level.
                //

                if (0 == (StreamObject->HwStreamObject.HwClockObject.ClockSupportFlags
                    & CLOCK_SUPPORT_CAN_RETURN_STREAM_TIME)) {

                    DEBUG_BREAKPOINT();
                    PropertyItem->GetPropertyHandler
                        = NULL;
                }               // if cannot return stream time
                StreamObject->ConstructedPropInfoSize =
                    SIZEOF_ARRAY(ConstructedStreamProperties);

                StreamObject->ConstructedPropertyInfo =
                    (PKSPROPERTY_SET) PropertyInfo;

            }                   // if property info
        }                       // if clock function
    } else {

        ExFreePool(StreamObject);
    }                           // if good status

    //
    // signal the event and complete the IRP.
    //

    KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
    SCProcessCompletedRequest(SRB);
    return (Status);
}

NTSTATUS
SCSetMasterClockWhenDeviceInaccessible( 
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp )
/*++

Description:

    This function look for special case in pin property request when the device
    is inaccessible, probably by surprise removal. Yet we need to process the 
    SetMasterClock(NULL) so that the MC ref'ed by us can be released. The MC could
    be on our pin or external.

    This function should only be called in StreamDispatchIoControl. We look for the
    Stream property.SetMasterClock(NULL). We returned SUCCESS if it is. Otherwise
    we return STATUS_UNCESSFUL to indicate that we don't process it.

Arguments:

    DeviceObject - Device Object for the device
    Irp - the request packet

Return:

    SUCCESS : If it is streamproperty.setmasterclock(NULL).
    UNSUCCESSFUL : otherwise.
    
--*/
{
    NTSTATUS Status=STATUS_UNSUCCESSFUL;
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG InputBufferLength = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
    ULONG OutputBufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    PKSPROPERTY Property;
    
    if ( IOCTL_KS_PROPERTY == IrpStack->Parameters.DeviceIoControl.IoControlCode && 
         InputBufferLength >= sizeof(KSPROPERTY) && 
         OutputBufferLength >= sizeof( HANDLE )) {
        //
        // only ksproperty is in our interest.
        //
        try {
            //
            // Validate the pointers if the client is not trusted.
            //
            if (Irp->RequestorMode != KernelMode) {
                ProbeForRead(IrpStack->Parameters.DeviceIoControl.Type3InputBuffer, 
                             InputBufferLength,
                             sizeof(BYTE));                           
                ProbeForRead(Irp->UserBuffer, 
                             OutputBufferLength,
                             sizeof(DWORD));                                 
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return STATUS_UNSUCCESSFUL;
        }
        //
        // Capture the property request
        //
        Property = (PKSPROPERTY)IrpStack->Parameters.DeviceIoControl.Type3InputBuffer;
        
        if ( KSPROPERTY_TYPE_SET == Property->Flags && 
             KSPROPERTY_STREAM_MASTERCLOCK == Property->Id &&
             IsEqualGUIDAligned(&Property->Set, &KSPROPSETID_Stream) &&
             NULL == *(PHANDLE) Irp->UserBuffer ) {
            //
            // All match. Now process it. In theory we should call mini driver. 
            // But we did not before. To avoid potential regression in mini drivers
            // we refrain from sending set_master_clock in this condition.
            //
            PSTREAM_OBJECT StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->FsContext;
            
            DebugPrint((DebugLevelInfo, "SCSetMasterClockWhen:Devobj %x Irp %x\n",
                        DeviceObject, Irp));
                        
            if (StreamObject->MasterClockInfo) {
                ObDereferenceObject(StreamObject->MasterClockInfo->ClockFileObject);
                ExFreePool(StreamObject->MasterClockInfo);
                StreamObject->MasterClockInfo = NULL;
            }
            return STATUS_SUCCESS;
        }             
    }
    return Status;
}

NTSTATUS
StreamDispatchIoControl
(
 IN PDEVICE_OBJECT DeviceObject,
 IN PIRP Irp
)
/*++

Routine Description:

     Process an ioctl to the stream.

Arguments:

    DeviceObject - device object for the device
    Irp - probably an IRP, silly

Return Value:

     NTSTATUS returned as appropriate.

--*/

{
    NTSTATUS        Status;
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION DeviceExtension;
    PSTREAM_OBJECT  StreamObject = (PSTREAM_OBJECT)
    IrpStack->FileObject->FsContext;

    PAGED_CODE();

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // show one more I/O pending & verify that we can actually do I/O.
    //
    Status = STATUS_INVALID_DEVICE_REQUEST;
    
    ///Status = SCShowIoPending(DeviceExtension, Irp);
    if (DeviceExtension->Flags & DEVICE_FLAGS_DEVICE_INACCESSIBLE) {
        ///
        // Note. When our device is surprised removed && we have ref on the master clock
        // && we receive the stream property to set the master clock to null, 
        // we need to process it to deref the MC so the MC can be released. 
        // We will special case it here otherwise there will be big code churn. And
        // the perf impact of this special case should be minimum for we get
        // in here quite rarely.
        //
        // (the device is currently not accessible, so just return with error)
        //
        NTSTATUS StatusProcessed;
        StatusProcessed = SCSetMasterClockWhenDeviceInaccessible( DeviceObject, Irp );

        if ( NT_SUCCESS( StatusProcessed ) ) {
            Status = StatusProcessed;
        }         
        Irp->IoStatus.Status = Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return (Status);
    }
    //
    // show one more IO pending.
    //
    InterlockedIncrement(&DeviceExtension->OneBasedIoCount);
    
    switch (IrpStack->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_KS_READ_STREAM:

        //
        // process read data request
        //

        DebugPrint((DebugLevelTrace, "'SCReadStream:Irp %x\n", Irp));
        Status = SCProcessDataTransfer(DeviceExtension,
                                       Irp,
                                       SRB_READ_DATA);
        break;

    case IOCTL_KS_WRITE_STREAM:

        //
        // process write data request
        //

        DebugPrint((DebugLevelTrace, "'SCWriteStream:Irp %x\n", Irp));
        Status = SCProcessDataTransfer(DeviceExtension,
                                       Irp,
                                       SRB_WRITE_DATA);
        break;

    case IOCTL_KS_RESET_STATE:
        {

            BOOLEAN         RequestIssued;
            KSRESET        *Reset,
                            ResetType;

            Reset = (KSRESET *) IrpStack->Parameters.DeviceIoControl.Type3InputBuffer;

            if (Irp->RequestorMode != KernelMode) {
                try {
                    ProbeForRead(Reset, sizeof(KSRESET), sizeof(ULONG));
                    ResetType = *Reset;

                } except(EXCEPTION_EXECUTE_HANDLER) {
                    TRAP;
                    Status = GetExceptionCode();
                    break;
                }               // except
            }                   // if !kernelmode

            else {

                //
                // trusted kernel mode, just use it. #131858 prefixbug 17400
                //
                
                ResetType = *Reset;
            }
            
            ASSERT(ResetType == *Reset);
            if (ResetType == KSRESET_BEGIN) {

                StreamObject->InFlush = TRUE;

                Status = SCSubmitRequest(SRB_BEGIN_FLUSH,
                                         NULL,
                                         0,
                                         SCDequeueAndDeleteSrb,
                                         DeviceExtension,
                                         ((PFILTER_INSTANCE)
                                          (StreamObject->FilterInstance))
                                         ->HwInstanceExtension,
                                         &StreamObject->HwStreamObject,
                                         Irp,
                                         &RequestIssued,
                                         &StreamObject->ControlPendingQueue,
                                         StreamObject->HwStreamObject.
                                         ReceiveControlPacket
                    );


                StreamFlushIo(DeviceExtension, StreamObject);

            } else {

                Status = SCSubmitRequest(SRB_END_FLUSH,
                                         NULL,
                                         0,
                                         SCDequeueAndDeleteSrb,
                                         DeviceExtension,
                                         ((PFILTER_INSTANCE)
                                          (StreamObject->FilterInstance))
                                         ->HwInstanceExtension,
                                         &StreamObject->HwStreamObject,
                                         Irp,
                                         &RequestIssued,
                                         &StreamObject->ControlPendingQueue,
                                         StreamObject->HwStreamObject.
                                         ReceiveControlPacket
                    );

                StreamObject->InFlush = FALSE;

            }                   // if begin

            break;
        }                       // case reset

    case IOCTL_KS_PROPERTY:

        DebugPrint((DebugLevelTrace,
                    "'StreamDispatchIO: Property with Irp %x\n", Irp));

        //
        // assume that there are no minidriver properties.
        //

        Status = STATUS_PROPSET_NOT_FOUND;

        //
        // first try the minidriver's properties, giving it a chance to
        // override our built in sets.
        //

        if (StreamObject->PropInfoSize) {

            ASSERT( StreamObject->PropertyInfo );
            Status = KsPropertyHandler(Irp,
                                       StreamObject->PropInfoSize,
                                       StreamObject->PropertyInfo);

        }                       // if minidriver props
        //
        // if the minidriver did not support it, try our on the fly set.
        //

        if ((Status == STATUS_PROPSET_NOT_FOUND) ||
            (Status == STATUS_NOT_FOUND)) {

            if (StreamObject->ConstructedPropertyInfo) {

                Status = KsPropertyHandler(Irp,
                                      StreamObject->ConstructedPropInfoSize,
                                     StreamObject->ConstructedPropertyInfo);

            }                   // if constructed exists
        }                       // if not found
        //
        // if neither supported it, try our built-in set.
        //

        if ((Status == STATUS_PROPSET_NOT_FOUND) ||
            (Status == STATUS_NOT_FOUND)) {

            Status =
                KsPropertyHandler(Irp,
                                  SIZEOF_ARRAY(StreamProperties),
                                  (PKSPROPERTY_SET) StreamProperties);


        }                       // if property not found
        break;

    case IOCTL_KS_ENABLE_EVENT:

        DebugPrint((DebugLevelTrace,
                    "'StreamDispatchIO: Enable event with Irp %x\n", Irp));

        Status = KsEnableEvent(Irp,
                               StreamObject->EventInfoCount,
                               StreamObject->EventInfo,
                               NULL, 0, NULL);


        break;

    case IOCTL_KS_DISABLE_EVENT:

        {

            KSEVENTS_LOCKTYPE LockType;
            PVOID           LockObject;

            DebugPrint((DebugLevelTrace,
                    "'StreamDispatchIO: Disable event with Irp %x\n", Irp));

            //
            // determine the type of lock necessary based on whether we are
            // using interrupt or spinlock synchronization.
            //


            #if DBG
            if (DeviceExtension->SynchronizeExecution == SCDebugKeSynchronizeExecution) {
            #else
            if (DeviceExtension->SynchronizeExecution == KeSynchronizeExecution) {
            #endif
                LockType = KSEVENTS_INTERRUPT;
                LockObject = DeviceExtension->InterruptObject;

            } else {

                LockType = KSEVENTS_SPINLOCK;
                LockObject = &DeviceExtension->SpinLock;

            }

            Status = KsDisableEvent(Irp,
                                    &StreamObject->NotifyList,
                                    LockType,
                                    LockObject);

        }

        break;

    case IOCTL_KS_METHOD:

    	#ifdef ENABLE_KS_METHODS
        DebugPrint((DebugLevelTrace,
                     "'StreamDispatchIO: Method in Irp %x\n", Irp));

        //
        // assume that there are no minidriver properties.
        //

        Status = STATUS_PROPSET_NOT_FOUND;

        if ((Status == STATUS_PROPSET_NOT_FOUND) ||
            (Status == STATUS_NOT_FOUND)) {

            if (StreamObject->MethodInfo) {

                Status = KsMethodHandler(Irp,
                                       StreamObject->MethodInfoSize,
                                      StreamObject->MethodInfo);

            }                   // if constructed exists
        }                       // if not found
        break;

		#else

        Status = STATUS_PROPSET_NOT_FOUND;
        break;
        #endif

    }

    if (Status != STATUS_PENDING) {

        SCCompleteIrp(Irp, Status, DeviceExtension);
    }
    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    return Status;
}


NTSTATUS
SCStreamDeviceState
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PKSSTATE DeviceState
)
/*++

Routine Description:

     Process get/set device state to the stream.

Arguments:

    Irp - pointer to the irp
    Property - pointer to the information for device state property
    DeviceState - state to which the device is to be set

Return Value:

     NTSTATUS returned as appropriate.

--*/

{
    NTSTATUS            Status;
    PIO_STACK_LOCATION  IrpStack;
    PDEVICE_EXTENSION   DeviceExtension;
    PSTREAM_OBJECT      StreamObject;
    BOOLEAN             RequestIssued;

    #ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR

    PFILTER_INSTANCE    FilterInstance;
    PADDITIONAL_PIN_INFO AdditionalInfo;

    
	PAGED_CODE();


    DebugPrint((DebugLevelTrace, "'SCStreamDeviceState:Irp %x, State = %x\n",
                Irp, *DeviceState));
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = (PDEVICE_EXTENSION)
        (IrpStack->DeviceObject)->DeviceExtension;
    StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->FsContext;

    FilterInstance = ((PFILTER_INSTANCE) (StreamObject->FilterInstance));
    AdditionalInfo = FilterInstance->PinInstanceInfo;

    Status = STATUS_SUCCESS;

    //
    // Synchronize pin state changes
    //

    KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                          Executive,
                          KernelMode,
                          FALSE,// not alertable
                          NULL);


    if (StreamObject->CurrentState == *DeviceState) {
        KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
        return STATUS_SUCCESS;
    }

    switch (*DeviceState) {
    case KSSTATE_RUN:
        DebugPrint((DebugLevelTrace, "STREAM: KSSTATE_RUN on stream:%x\n",StreamObject)); 
        break;

    case KSSTATE_ACQUIRE:
        DebugPrint((DebugLevelTrace, "STREAM: KSSTATE_ACQUIRE on stream:%x\n",StreamObject)); 
        break;

    case KSSTATE_PAUSE:
        DebugPrint((DebugLevelTrace, "STREAM: KSSTATE_PAUSE on stream:%x\n",StreamObject)); 
        break;

    case KSSTATE_STOP:

        DebugPrint((DebugLevelTrace, "STREAM: KSSTATE_STOP on stream:%x\n",StreamObject)); 
        break;

    default:
        DebugPrint((DebugLevelTrace, "STREAM: Invalid Device State\n")); 
        break;

    }
    DebugPrint((DebugLevelTrace, "STREAM: Stream->AllocatorFileObject:%x\n",StreamObject->AllocatorFileObject)); 
    DebugPrint((DebugLevelTrace, "STREAM: Stream->NextFileObject:%x\n",StreamObject->NextFileObject)); 
    DebugPrint((DebugLevelTrace, "STREAM: Stream->FileObject:%x\n",StreamObject->FileObject)); 
    DebugPrint((DebugLevelTrace, "STREAM: Stream->PinType:")); 
    if (StreamObject->PinType == IrpSource)
        DebugPrint((DebugLevelTrace, "IrpSource\n")); 
    else if (StreamObject->PinType == IrpSink)
        DebugPrint((DebugLevelTrace, "IrpSink\n")); 
    else {
        DebugPrint((DebugLevelTrace, "neither\n"));     // this is a bug.
    }
    //
    // send a set state SRB to the stream.
    //

    //
    // GUBGUB: "we may need to send this if Status == STATUS_SUCCESS only"
    // is a bugus concern since Status is inited to Success.
    //
    Status = SCSubmitRequest(SRB_SET_STREAM_STATE,
                             (PVOID) * DeviceState,
                             0,
                             SCDequeueAndDeleteSrb,
                             DeviceExtension,
                             ((PFILTER_INSTANCE)
                              (StreamObject->FilterInstance))
                             ->HwInstanceExtension,
                             &StreamObject->HwStreamObject,
                             Irp,
                             &RequestIssued,
                             &StreamObject->ControlPendingQueue,
                             StreamObject->HwStreamObject.
                             ReceiveControlPacket
        );

    //
    // if good status, set the new state in the stream object.
    //
                      
    if (NT_SUCCESS(Status)) {

        StreamObject->CurrentState = *DeviceState;
    }
    else {
        DebugPrint((DebugLevelTrace, "STREAM: error sending DeviceState Irp\n")); 
    }

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    switch (*DeviceState) {
    //
    // 1. should start sourcing irps at pause
    // 2. worker thread shutdown if pins are connected in certain order.......
    // 3. check MSTEE bugs assigned to dalesat.
    //
    case KSSTATE_RUN:
        if(StreamObject->PinType == IrpSource &&
           StreamObject->StandardTransport)
        {
            Status = BeginTransfer(
                FilterInstance,
                StreamObject);
        }
        break;

    case KSSTATE_ACQUIRE:
        Status = STATUS_SUCCESS;
        break;

    case KSSTATE_PAUSE:
        if (NT_SUCCESS (Status)) {
            if(StreamObject->PinType == IrpSource &&
               StreamObject->StandardTransport)
            {
                Status = PrepareTransfer(
                    FilterInstance,
                    StreamObject);
            }
        }
        break;

    case KSSTATE_STOP:
        if(StreamObject->PinType == IrpSource &&
           StreamObject->StandardTransport)
            Status = EndTransfer( FilterInstance, StreamObject );
        else 
            //
            // cancel any pending I/O on this stream if the state is STOP.
            //
            StreamFlushIo(DeviceExtension, StreamObject);

        break;

    default:
        break;

    }


    KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
    return (Status);
}
#else
    PAGED_CODE();

    DebugPrint((DebugLevelTrace, "'SCStreamDeviceState:Irp %x, State = %x\n",
                Irp, *DeviceState));
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = (PDEVICE_EXTENSION)
        (IrpStack->DeviceObject)->DeviceExtension;
    StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->FsContext;

    //
    // cancel any pending I/O on this stream if the state is STOP.
    //

    if (*DeviceState == KSSTATE_STOP) {

        StreamFlushIo(DeviceExtension, StreamObject);
    }
    //
    // send a set state SRB to the stream.
    //

    DebugPrint((DebugLevelTrace,
             "'SetStreamState: State %x with Irp %x\n", *DeviceState, Irp));

    Status = SCSubmitRequest(SRB_SET_STREAM_STATE,
                             (PVOID) * DeviceState,
                             0,
                             SCDequeueAndDeleteSrb,
                             DeviceExtension,
                             ((PFILTER_INSTANCE)
                              (StreamObject->FilterInstance))
                             ->HwInstanceExtension,
                             &StreamObject->HwStreamObject,
                             Irp,
                             &RequestIssued,
                             &StreamObject->ControlPendingQueue,
                             StreamObject->HwStreamObject.
                             ReceiveControlPacket
        );

    //
    // if good status, set the new state in the stream object.
    //

    if (NT_SUCCESS(Status)) {

        StreamObject->CurrentState = *DeviceState;
    }
    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    return (Status);
    }
#endif


NTSTATUS
SCGetStreamDeviceStateCallback
(
 IN PSTREAM_REQUEST_BLOCK SRB
)
{
// yep, its a do nothing routine.
    return (SRB->HwSRB.Status);

}

NTSTATUS
SCGetStreamDeviceState
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PKSSTATE DeviceState
)
/*++

Routine Description:

     Process get device state to the stream.

Arguments:

    Irp - pointer to the irp
    Property - pointer to the information for device state property
    DeviceState - state to which the device is to be set

Return Value:

     NTSTATUS returned as appropriate.

--*/

{

    NTSTATUS        Status;
    PIO_STACK_LOCATION IrpStack;
    PDEVICE_EXTENSION DeviceExtension;
    PSTREAM_OBJECT  StreamObject;
    BOOLEAN         RequestIssued;
    PSTREAM_REQUEST_BLOCK SRB;

    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = (PDEVICE_EXTENSION)
        (IrpStack->DeviceObject)->DeviceExtension;
    StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->FsContext;

    //
    // send a get state SRB to the stream.
    //

    #ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
    DebugPrint((DebugLevelTrace,
                "'GetStreamState: State with StreamObj:%x\n", StreamObject));
    if (StreamObject->PinType == IrpSource)
        DebugPrint((DebugLevelTrace, "'GetStreamState: Is IrpSource\n"));
    else
        DebugPrint((DebugLevelTrace,"'GetStreamState: Is IrpSink\n"));
    #endif

    //
    // set the returned data size to the correct size regardless of status.
    //

    Irp->IoStatus.Information = sizeof(KSSTATE);

    Status = SCSubmitRequest(SRB_GET_STREAM_STATE,
                             (PVOID) DeviceState,
                             0,
                             SCGetStreamDeviceStateCallback,
                             DeviceExtension,
                             ((PFILTER_INSTANCE)
                              (StreamObject->FilterInstance))
                             ->HwInstanceExtension,
                             &StreamObject->HwStreamObject,
                             Irp,
                             &RequestIssued,
                             &StreamObject->ControlPendingQueue,
                             StreamObject->HwStreamObject.
                             ReceiveControlPacket
        );
    SRB = (PSTREAM_REQUEST_BLOCK) Irp->Tail.Overlay.DriverContext[0];
    *DeviceState = SRB->HwSRB.CommandData.StreamState;

    SCDequeueAndDeleteSrb(SRB);

    //
    // if not supported, return the last known state of the stream.
    //

    if ((Status == STATUS_NOT_SUPPORTED)
        || (Status == STATUS_NOT_IMPLEMENTED)) {

        Status = STATUS_SUCCESS;
        *DeviceState = StreamObject->CurrentState;

    }
    DebugPrint((DebugLevelTrace,
                "'GetStreamState: Returning:%x: DeviceState:", Status));

    switch (*DeviceState) {
    case KSSTATE_RUN:
        DebugPrint((DebugLevelTrace, "KSSTATE_RUN\n")); 
        break;

    case KSSTATE_ACQUIRE:
        DebugPrint((DebugLevelTrace, "KSSTATE_AQUIRE\n")); 
        break;

    case KSSTATE_PAUSE:
        DebugPrint((DebugLevelTrace, "KSSTATE_PAUSE\n")); 
        break;

    case KSSTATE_STOP:
        DebugPrint((DebugLevelTrace, "KSSTATE_STOP\n")); 
        break;

    default:
        DebugPrint((DebugLevelTrace, "Invalid Device State\n")); 
        break;
    }

    return (Status);
}

NTSTATUS
SCStreamDeviceRate
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PKSRATE DeviceRate
)
/*++

Routine Description:

     Process set device rate to the stream.

Arguments:

    Irp - pointer to the irp
    Property - pointer to the information for device state property
    DeviceRate - rate at which the device is to be set

Return Value:

     NTSTATUS returned as appropriate.

--*/

{
    NTSTATUS        Status;
    PIO_STACK_LOCATION IrpStack;
    PDEVICE_EXTENSION DeviceExtension;
    PSTREAM_OBJECT  StreamObject;
    BOOLEAN         RequestIssued;

    PAGED_CODE();

    DebugPrint((DebugLevelTrace, "'SCStreamDeviceRate:Irp %x, Rate = %x\n",
                Irp, *DeviceRate));
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = (PDEVICE_EXTENSION)
        (IrpStack->DeviceObject)->DeviceExtension;
    StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->FsContext;

    //
    // send a set rate SRB to the stream.
    //

    Status = SCSubmitRequest(SRB_SET_STREAM_RATE,
                             (PVOID) DeviceRate,
                             0,
                             SCDequeueAndDeleteSrb,
                             DeviceExtension,
                             ((PFILTER_INSTANCE)
                              (StreamObject->FilterInstance))
                             ->HwInstanceExtension,
                             &StreamObject->HwStreamObject,
                             Irp,
                             &RequestIssued,
                             &StreamObject->ControlPendingQueue,
                             StreamObject->HwStreamObject.
                             ReceiveControlPacket
        );


    //
    // change STATUS_NOT_IMPLEMENTED to STATUS_NOT_FOUND so that the proxy 
    // does not get confused (GUBGUB). A necessary mapping between r0 and r3
    // worlds.
    //

    if (Status == STATUS_NOT_IMPLEMENTED) {
             Status = STATUS_NOT_FOUND;

    }

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    return (Status);
}

NTSTATUS
SCStreamDeviceRateCapability
(
 IN PIRP Irp,
 IN PKSRATE_CAPABILITY RateCap,
 IN OUT PKSRATE DeviceRate
)
/*++

Routine Description:

     Process set device rate to the stream.

Arguments:

    Irp - pointer to the irp
    RateCap - pointer to the information for device state property
    DeviceRate - rate to which the device was set

Return Value:

     NTSTATUS returned as appropriate.

--*/

{
    NTSTATUS        Status;
    PIO_STACK_LOCATION IrpStack;
    PDEVICE_EXTENSION DeviceExtension;
    PSTREAM_OBJECT  StreamObject;
    BOOLEAN         RequestIssued;

    PAGED_CODE();

    DebugPrint((DebugLevelTrace, "'SCStreamDeviceRate:Irp %x, Rate = %x\n",
                Irp, *DeviceRate));
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = (PDEVICE_EXTENSION)
        (IrpStack->DeviceObject)->DeviceExtension;
    StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->FsContext;

    //
    // presuppose a successful completion, which means that the minidriver
    // can normalize rate to 1.
    //

    *DeviceRate = RateCap->Rate;
    DeviceRate->Rate = 1000;
    Irp->IoStatus.Information = sizeof(KSRATE);

    //
    // send a set rate SRB to the stream.
    //

    Status = SCSubmitRequest(
    		SRB_PROPOSE_STREAM_RATE,
            (PVOID) RateCap,
            0,
            SCDequeueAndDeleteSrb,
            DeviceExtension,
            ((PFILTER_INSTANCE)(StreamObject->FilterInstance))->HwInstanceExtension,
            &StreamObject->HwStreamObject,
            Irp,
            &RequestIssued,
            &StreamObject->ControlPendingQueue,
            StreamObject->HwStreamObject.ReceiveControlPacket
        	);


    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // change STATUS_NOT_IMPLEMENTED to STATUS_NOT_FOUND so that the proxy 
    // does not get confused (GUBGUB). A necessary mapping between r0 and r3
    // worlds.
    //

    if (Status == STATUS_NOT_IMPLEMENTED) {
             Status = STATUS_NOT_FOUND;

    }

    return (Status);
}


NTSTATUS
SCStreamProposeNewFormat

(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PKSDATAFORMAT Format
)
/*++

Routine Description:

     Process propose data format to the stream.

Arguments:

    Irp - pointer to the irp
    Property - pointer to the information for propose format property
    DeviceState - state to which the device is to be set

Return Value:

     NTSTATUS returned as appropriate.

--*/

{
    NTSTATUS        Status;
    PIO_STACK_LOCATION IrpStack;
    PDEVICE_EXTENSION DeviceExtension;
    PSTREAM_OBJECT  StreamObject;
    BOOLEAN         RequestIssued;

    PAGED_CODE();

    DebugPrint((DebugLevelTrace, "'SCStreamProposeNewFormat:Irp %x, Format = %x\n",
                Irp, *Format));
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = (PDEVICE_EXTENSION)
        (IrpStack->DeviceObject)->DeviceExtension;
    StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->FsContext;

    //
    // send a propose format SRB to the stream.
    //

    Status = SCSubmitRequest(SRB_PROPOSE_DATA_FORMAT,
                             (PVOID) Format,
                    IrpStack->Parameters.DeviceIoControl.OutputBufferLength,
                             SCDequeueAndDeleteSrb,
                             DeviceExtension,
                             ((PFILTER_INSTANCE)
                              (StreamObject->FilterInstance))
                             ->HwInstanceExtension,
                             &StreamObject->HwStreamObject,
                             Irp,
                             &RequestIssued,
                             &StreamObject->ControlPendingQueue,
                             StreamObject->HwStreamObject.
                             ReceiveControlPacket
        );


    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // change STATUS_NOT_IMPLEMENTED to STATUS_NOT_FOUND so that the proxy 
    // does not get confused (GUBGUB). A necessary mapping between r0 and r3
    // worlds.
    //

    if (Status == STATUS_NOT_IMPLEMENTED) {
             Status = STATUS_NOT_FOUND;

    }

    return (Status);
}



NTSTATUS
SCStreamSetFormat
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PKSDATAFORMAT Format
)
/*++

Routine Description:

    Sets the data format on the stream.

Arguments:

    Irp - pointer to the irp
    Property - pointer to the information for the set format property
    DeviceState - state to which the device is to be set

Return Value:

     NTSTATUS returned as appropriate.

--*/

{
    NTSTATUS        Status;
    PIO_STACK_LOCATION IrpStack;
    PDEVICE_EXTENSION DeviceExtension;
    PSTREAM_OBJECT  StreamObject;
    BOOLEAN         RequestIssued;

    PAGED_CODE();

    DebugPrint((DebugLevelTrace, "'SCStreamSetFormat:Irp %x, Format = %x\n",
                Irp, *Format));
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = (PDEVICE_EXTENSION)
        (IrpStack->DeviceObject)->DeviceExtension;
    StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->FsContext;

    //
    // send a set format SRB to the stream.
    //

    Status = SCSubmitRequest(SRB_SET_DATA_FORMAT,
                             (PVOID) Format,
                    IrpStack->Parameters.DeviceIoControl.OutputBufferLength,
                             SCDequeueAndDeleteSrb,
                             DeviceExtension,
                             ((PFILTER_INSTANCE)
                              (StreamObject->FilterInstance))
                             ->HwInstanceExtension,
                             &StreamObject->HwStreamObject,
                             Irp,
                             &RequestIssued,
                             &StreamObject->ControlPendingQueue,
                             StreamObject->HwStreamObject.
                             ReceiveControlPacket
        );


    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // change STATUS_NOT_IMPLEMENTED to STATUS_NOT_FOUND so that the proxy 
    // does not get confused (GUBGUB). A necessary mapping between r0 and r3
    // worlds.
    //

    if (Status == STATUS_NOT_IMPLEMENTED) {
             Status = STATUS_NOT_FOUND;

    }

    return (Status);
}


NTSTATUS
StreamClassMinidriverDeviceGetProperty
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PVOID PropertyInfo
)
/*++

Routine Description:

     Process get property to the device.

Arguments:

    Irp - pointer to the irp
    Property - pointer to the information for the property
    PropertyInfo - buffer to return the property data to

Return Value:

     NTSTATUS returned as appropriate.

--*/

{
    NTSTATUS        Status;

    PAGED_CODE();

    Status = SCMinidriverDevicePropertyHandler(SRB_GET_DEVICE_PROPERTY,
                                               Irp,
                                               Property,
                                               PropertyInfo
        );

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    return (Status);
}

NTSTATUS
StreamClassMinidriverDeviceSetProperty
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PVOID PropertyInfo
)
/*++

Routine Description:

     Process set property to the device.

Arguments:

    Irp - pointer to the irp
    Property - pointer to the information for the property
    PropertyInfo - buffer that contains the property info

Return Value:

     NTSTATUS returned as appropriate.

--*/

{
    NTSTATUS        Status;

    PAGED_CODE();

    Status = SCMinidriverDevicePropertyHandler(SRB_SET_DEVICE_PROPERTY,
                                               Irp,
                                               Property,
                                               PropertyInfo);

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    return (Status);
}


NTSTATUS
StreamClassMinidriverStreamGetProperty
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PVOID PropertyInfo
)
/*++

Routine Description:

     Process get property of a stream.

Arguments:

    Irp - pointer to the irp
    Property - pointer to the information for the property
    PropertyInfo - buffer to return the property data to

Return Value:

     NTSTATUS returned as appropriate.

--*/

{
    NTSTATUS        Status;

    PAGED_CODE();

    Status = SCMinidriverStreamPropertyHandler(SRB_GET_STREAM_PROPERTY,
                                               Irp,
                                               Property,
                                               PropertyInfo
        );

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    return (Status);
}

NTSTATUS
StreamClassMinidriverStreamSetProperty
(
 IN PIRP Irp,
 IN PKSPROPERTY Property,
 IN OUT PVOID PropertyInfo
)
/*++

Routine Description:

     Process set property to a stream.

Arguments:

    Irp - pointer to the irp
    Property - pointer to the information for the property
    PropertyInfo - buffer that contains the property info

Return Value:

     NTSTATUS returned as appropriate.

--*/

{
    NTSTATUS        Status;

    PAGED_CODE();

    Status = SCMinidriverStreamPropertyHandler(SRB_SET_STREAM_PROPERTY,
                                               Irp,
                                               Property,
                                               PropertyInfo);

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    return (Status);
}


#ifdef ENABLE_KS_METHODS

NTSTATUS
StreamClassMinidriverStreamMethod(  
    IN PIRP Irp,
    IN PKSMETHOD Method,
    IN OUT PVOID MethodInfo)
/*++

Routine Description:

     Process get property of a stream.

Arguments:

    Irp - pointer to the irp
    Property - pointer to the information for the property
    PropertyInfo - buffer to return the property data to

Return Value:

     NTSTATUS returned as appropriate.

--*/

{
    NTSTATUS        Status;

    PAGED_CODE();

    Status = SCMinidriverStreamMethodHandler(SRB_STREAM_METHOD,
                                               Irp,
                                               Method,
                                               MethodInfo
        );

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    return (Status);
}

NTSTATUS
StreamClassMinidriverDeviceMethod(
    IN PIRP Irp,
    IN PKSMETHOD Method,
    IN OUT PVOID MethodInfo)
/*++

Routine Description:

     Process get property of a device.

Arguments:

    Irp - pointer to the irp
    Property - pointer to the information for the property
    PropertyInfo - buffer to return the property data to

Return Value:

     NTSTATUS returned as appropriate.

--*/

{
    NTSTATUS        Status;

    PAGED_CODE();

    Status = SCMinidriverDeviceMethodHandler(SRB_DEVICE_METHOD,
                                               Irp,
                                               Method,
                                               MethodInfo
        );

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    return (Status);
}
#endif


NTSTATUS
StreamClassEnableEventHandler(
                              IN PIRP Irp,
                              IN PKSEVENTDATA EventData,
                              IN PKSEVENT_ENTRY EventEntry
)
/*++

Routine Description:

    Process an enable event for the stream.

Arguments:

    Irp - pointer to the IRP
    EventData - data describing the event
    EventEntry - more info about the event :-)

Return Value:

     None.

--*/

{
    PIO_STACK_LOCATION IrpStack;
    PDEVICE_EXTENSION DeviceExtension;
    PSTREAM_OBJECT  StreamObject;
    NTSTATUS        Status;
    ULONG           EventSetID;
    KIRQL           irql;
    HW_EVENT_DESCRIPTOR Event;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = (PDEVICE_EXTENSION)
        (IrpStack->DeviceObject)->DeviceExtension;

    //
    // clock events are indicated on the pin by the minidriver, for
    // simplicity.
    // but, we will receive clock events on the clock's handle.   We need to
    // determine if this file object is the clock's or the pin's.
    //

    StreamObject = IrpStack->FileObject->FsContext;

    if ((PVOID) StreamObject == IrpStack->FileObject->FsContext2) {

        StreamObject = ((PCLOCK_INSTANCE) StreamObject)->StreamObject;
    }
    //
    // compute the index of the event set.
    //
    // this value is calculated by subtracting the base event set
    // pointer from the requested event set pointer.
    //
    //

    EventSetID = (ULONG) ((ULONG_PTR) EventEntry->EventSet -
                          (ULONG_PTR) StreamObject->EventInfo)
        / sizeof(KSEVENT_SET);

    //
    // build an event info structure to represent the event to the
    // minidriver.
    //

    Event.EnableEventSetIndex = EventSetID;
    Event.EventEntry = EventEntry;
    Event.StreamObject = &StreamObject->HwStreamObject;
    Event.Enable = TRUE;
    Event.EventData = EventData;

    //
    // acquire the spinlock to protect the interrupt structures
    //

    KeAcquireSpinLock(&DeviceExtension->SpinLock, &irql);

    //
    // call the synchronized routine to add the event to the list
    //

    Status = DeviceExtension->SynchronizeExecution(
                                           DeviceExtension->InterruptObject,
                          (PKSYNCHRONIZE_ROUTINE) SCEnableEventSynchronized,
                                                   &Event);

    KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);

    return (Status);

}


VOID
StreamClassDisableEventHandler(
                               IN PFILE_OBJECT FileObject,
                               IN PKSEVENT_ENTRY EventEntry
)
/*++

Routine Description:

    Process an event disable for the stream.
    NOTE: we are either at interrupt IRQL or the spinlock is taken on this call!

Arguments:

    FileObject - file object for the pin
    EventEntry - info about the event

Return Value:

     None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension;
    PSTREAM_OBJECT  StreamObject;
    HW_EVENT_DESCRIPTOR Event;

    //
    // clock events are indicated on the pin by the minidriver, for
    // simplicity.
    // but, we will receive clock events on the clock's handle.   We need to
    // determine if this file object is the clock's or the pin's.
    //

    StreamObject = FileObject->FsContext;

    if ((PVOID) StreamObject == FileObject->FsContext2) {

        StreamObject = ((PCLOCK_INSTANCE) StreamObject)->StreamObject;
    }
    DeviceExtension = StreamObject->DeviceExtension;

    //
    // build an event info structure to represent the event to the
    // minidriver.
    //

    Event.EventEntry = EventEntry;
    Event.StreamObject = &StreamObject->HwStreamObject;
    Event.Enable = FALSE;

    if (StreamObject->HwStreamObject.HwEventRoutine) {

        //
        // call the minidriver.  ignore the status.  note that we are
        // already at the correct synchronization level.
        //

        StreamObject->HwStreamObject.HwEventRoutine(&Event);

    }                           // if eventroutine
    //
    // remove the event from the list.
    //

    RemoveEntryList(&EventEntry->ListEntry);
}

NTSTATUS
StreamClassEnableDeviceEventHandler(
                                    IN PIRP Irp,
                                    IN PKSEVENTDATA EventData,
                                    IN PKSEVENT_ENTRY EventEntry
)
/*++

Routine Description:

    Process an enable event for the device.

Arguments:

    Irp - pointer to the IRP
    EventData - data describing the event
    EventEntry - more info about the event :-)

Return Value:

     None.

--*/

{
    PIO_STACK_LOCATION IrpStack;
    PDEVICE_EXTENSION DeviceExtension;
    NTSTATUS        Status;
    ULONG           EventSetID;
    KIRQL           irql;
    HW_EVENT_DESCRIPTOR Event;
    PFILTER_INSTANCE FilterInstance;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = (PDEVICE_EXTENSION)
        (IrpStack->DeviceObject)->DeviceExtension;


    FilterInstance = IrpStack->FileObject->FsContext;

    //
    // compute the index of the event set.
    //
    // this value is calculated by subtracting the base event set
    // pointer from the requested event set pointer.
    //
    //

    EventSetID = (ULONG) ((ULONG_PTR) EventEntry->EventSet -
                          (ULONG_PTR) FilterInstance->EventInfo)
                           / sizeof(KSEVENT_SET);
                           
    //
    // build an event info structure to represent the event to the
    // minidriver.
    //

    Event.EnableEventSetIndex = EventSetID;
    Event.EventEntry = EventEntry;
    Event.DeviceExtension = DeviceExtension->HwDeviceExtension;
    IF_MF( Event.HwInstanceExtension = FilterInstance->HwInstanceExtension; )
    Event.Enable = TRUE;
    Event.EventData = EventData;

    //
    // acquire the spinlock to protect the interrupt structures
    //

    KeAcquireSpinLock(&DeviceExtension->SpinLock, &irql);

    //
    // call the synchronized routine to add the event to the list
    //

    Status = DeviceExtension->SynchronizeExecution(
                                           DeviceExtension->InterruptObject,
                    (PKSYNCHRONIZE_ROUTINE) SCEnableDeviceEventSynchronized,
                                                   &Event);

    KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);

    return (Status);

}


VOID
StreamClassDisableDeviceEventHandler(
                                     IN PFILE_OBJECT FileObject,
                                     IN PKSEVENT_ENTRY EventEntry
)
/*++

Routine Description:

    Process an event disable for the stream.
    NOTE: we are either at interrupt IRQL or the spinlock is taken on this call!

Arguments:

    FileObject - file object for the pin
    EventEntry - info about the event

Return Value:

     None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension;
    HW_EVENT_DESCRIPTOR Event;
    PFILTER_INSTANCE FilterInstance;

    FilterInstance = (PFILTER_INSTANCE) FileObject->FsContext;
    ASSERT_FILTER_INSTANCE( FilterInstance );

    DeviceExtension = FilterInstance->DeviceExtension;

    //
    // build an event info structure to represent the event to the
    // minidriver.
    //

    Event.EventEntry = EventEntry;
    Event.DeviceExtension = DeviceExtension->HwDeviceExtension;
    Event.Enable = FALSE;


	Event.HwInstanceExtension = FilterInstance->HwInstanceExtension;
    if (FilterInstance->HwEventRoutine) {

	    //
        // call the minidriver.  ignore the status.  note that we are
	    // already at the correct synchronization level.
        //

        FilterInstance->HwEventRoutine(&Event);
    }
	
    //
    // remove the event from the list.
    //

    RemoveEntryList(&EventEntry->ListEntry);
}

NTSTATUS
FilterDispatchIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp)
/*++

Routine Description:

    This routine receives control IRP's for the device.

Arguments:
    DeviceObject - device object for the device
    Irp - probably an IRP, silly

Return Value:

    The IRP status is set as appropriate

--*/
{
    PIO_STACK_LOCATION IrpStack;
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    PFILTER_INSTANCE FilterInstance;
    NTSTATUS        Status;

    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    Status = SCShowIoPending(DeviceExtension, Irp);

    if ( !NT_SUCCESS ( Status )) {

        //
        // the device is currently not accessible, so just return.
        //

        return (Status);
    }
    switch (IrpStack->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_KS_PROPERTY:

        Status = STATUS_PROPSET_NOT_FOUND;

        FilterInstance = (PFILTER_INSTANCE) IrpStack->FileObject->FsContext; 
        ASSERT( FilterInstance );
        if (FilterInstance->StreamDescriptor->
            StreamHeader.NumDevPropArrayEntries) {
            ASSERT( FilterInstance->DevicePropertiesArray );
            Status = KsPropertyHandler(Irp,
                                   FilterInstance->StreamDescriptor->
                                   StreamHeader.NumDevPropArrayEntries,
                                   FilterInstance->DevicePropertiesArray);
        }
        
        if ((Status == STATUS_PROPSET_NOT_FOUND) ||
            (Status == STATUS_NOT_FOUND)) {

            Status = KsPropertyHandler(Irp,
                                    SIZEOF_ARRAY(FilterPropertySets),
                                    (PKSPROPERTY_SET) &FilterPropertySets);


        }
        break;

    case IOCTL_KS_ENABLE_EVENT:

        DebugPrint((DebugLevelTrace,
                    "'FilterDispatchIO: Enable event with Irp %x\n", Irp));

        FilterInstance = (PFILTER_INSTANCE) IrpStack->FileObject->FsContext;

        Status = KsEnableEvent(Irp,
                           FilterInstance->EventInfoCount,
                           FilterInstance->EventInfo,
                           NULL, 0, NULL);

        break;

    case IOCTL_KS_DISABLE_EVENT:

        {

            KSEVENTS_LOCKTYPE LockType;
            PVOID           LockObject;

            DebugPrint((DebugLevelTrace,
                    "'FilterDispatchIO: Disable event with Irp %x\n", Irp));

            //
            // determine the type of lock necessary based on whether we are
            // using interrupt or spinlock synchronization.
            //

            #if DBG
            if (DeviceExtension->SynchronizeExecution == SCDebugKeSynchronizeExecution) {
            #else
            if (DeviceExtension->SynchronizeExecution == KeSynchronizeExecution) {
            #endif
                LockType = KSEVENTS_INTERRUPT;
                LockObject = DeviceExtension->InterruptObject;

            } else {

                LockType = KSEVENTS_SPINLOCK;
                LockObject = &DeviceExtension->SpinLock;

            }

            FilterInstance = (PFILTER_INSTANCE) IrpStack->
                                FileObject->FsContext;
            Status = KsDisableEvent(Irp,
                                &FilterInstance->NotifyList,
                                LockType,
                                LockObject);

        }

        break;

    case IOCTL_KS_METHOD:

        Status = STATUS_PROPSET_NOT_FOUND;
        break;
    default:

        Status = STATUS_NOT_SUPPORTED;

    }

    if (Status != STATUS_PENDING) {

        SCCompleteIrp(Irp, Status, DeviceExtension);
    }
    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    return (Status);
}

NTSTATUS
ClockDispatchIoControl(
                       IN PDEVICE_OBJECT DeviceObject,
                       IN PIRP Irp
)
/*++

Routine Description:

    This routine receives control IRP's for the clock.

Arguments:
    DeviceObject - device object for the device
    Irp - probably an IRP, silly

Return Value:

    The IRP status is set as appropriate

--*/

{
    NTSTATUS        Status;
    PIO_STACK_LOCATION IrpStack;
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    PSTREAM_OBJECT  StreamObject;

    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    Status = SCShowIoPending(DeviceExtension, Irp);

    if ( !NT_SUCCESS ( Status )) {

        //
        // the device is currently not accessible, so just return.
        //

        return (Status);
    }
    switch (IrpStack->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_KS_PROPERTY:

        Status = KsPropertyHandler(Irp,
                                   SIZEOF_ARRAY(ClockPropertySets),
                                   (PKSPROPERTY_SET) & ClockPropertySets);

        break;

    case IOCTL_KS_ENABLE_EVENT:

        DebugPrint((DebugLevelTrace,
                    "'StreamDispatchIO: Enable event with Irp %x\n", Irp));

        //
        // locate the stream object of the pin for this clock from the IRP.
        // note that we use the event set of the pin for the clock events.
        //

        StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->RelatedFileObject->
            FsContext;

        ASSERT(StreamObject);

        Status = KsEnableEvent(Irp,
                               StreamObject->EventInfoCount,
                               StreamObject->EventInfo,
                               NULL, 0, NULL);


        break;

    case IOCTL_KS_DISABLE_EVENT:

        {

            KSEVENTS_LOCKTYPE LockType;
            PVOID           LockObject;

            //
            // locate the stream object of the pin for this clock from the
            // IRP.
            // note that we use the event set of the pin for the clock
            // events.
            //

            StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->RelatedFileObject->
                FsContext;

            ASSERT(StreamObject);

            DebugPrint((DebugLevelTrace,
                    "'StreamDispatchIO: Disable event with Irp %x\n", Irp));

            //
            // determine the type of lock necessary based on whether we are
            // using interrupt or spinlock synchronization.
            //

            #if DBG
            if (DeviceExtension->SynchronizeExecution == SCDebugKeSynchronizeExecution) {
            #else
            if (DeviceExtension->SynchronizeExecution == KeSynchronizeExecution) {
            #endif
                LockType = KSEVENTS_INTERRUPT;
                LockObject = DeviceExtension->InterruptObject;

            } else {

                LockType = KSEVENTS_SPINLOCK;
                LockObject = &DeviceExtension->SpinLock;

            }

            Status = KsDisableEvent(Irp,
                                    &StreamObject->NotifyList,
                                    LockType,
                                    LockObject);

        }

        break;

    case IOCTL_KS_METHOD:

    	#ifdef ENABLE_KS_METHODS

        Status = STATUS_PROPSET_NOT_FOUND;
        {
            PFILTER_INSTANCE FilterInstance;
            PHW_STREAM_DESCRIPTOR StreamDescriptor;

            FilterInstance = (PFILTER_INSTANCE) IrpStack->FileObject->FsContext;
            if ( NULL == FilterInstance->StreamDescriptor ) {
                StreamDescriptor = DeviceExtension->FilterTypeInfos
                    [FilterInstance->FilterTypeIndex].StreamDescriptor;
            }
            else {
                StreamDescriptor = FilterInstance->StreamDescriptor;
            }

            Status = KsMethodHandler(Irp,
                                     StreamDescriptor->
                                     StreamHeader.NumDevMethodArrayEntries,
                                     FilterInstance->DeviceMethodsArray);

        }
        break;
		#else

        Status = STATUS_PROPSET_NOT_FOUND;
        break;
        #endif

    default:

        DEBUG_BREAKPOINT();
        Status = STATUS_NOT_SUPPORTED;

    }

    if (Status != STATUS_PENDING) {

        SCCompleteIrp(Irp, Status, DeviceExtension);
    }
    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    return (Status);
}

NTSTATUS
FilterDispatchClose(
 IN PDEVICE_OBJECT DeviceObject,
 IN PIRP Irp
)
/*++

Routine Description:

    This routine receives CLOSE IRP's for the device/instance

Arguments:
    DeviceObject - device object for the device
    Irp - probably an IRP, silly

Return Value:

    The IRP status is set as appropriate

--*/

{
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    PFILTER_INSTANCE FilterInstance =
    (PFILTER_INSTANCE) IrpStack->FileObject->FsContext;
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    NTSTATUS        Status;
    BOOLEAN         IsGlobal;
    BOOLEAN         RequestIssued;

    PAGED_CODE();

    InterlockedIncrement(&DeviceExtension->OneBasedIoCount);

    //
    // remove the filter instance structure from our list
    //

    #if DBG
    IFN_MF( 
        if (DeviceExtension->NumberOfGlobalInstances == 1) {

            ASSERT(IsListEmpty(&FilterInstance->FirstStream));
        }                           // if global = 1
    )
    #endif

    //
    // check to see if this is a global instance
    //

    KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                          Executive,
                          KernelMode,
                          FALSE,// not alertable
                          NULL);

    DebugPrint(( DebugLevelInfo,
                 "Closing FilterInstance %x NeameExts=%x\n",
                 FilterInstance,
                 DeviceExtension->NumberOfNameExtensions));
                     
    if ( 0 == DeviceExtension->FilterExtensionSize &&
         DeviceExtension->NumberOfOpenInstances > 1) {

        PFILE_OBJECT pFileObject;
            
        //
        // this is not the last close of the global instance, so just
        // deref this instance and return good status.
        //

        DeviceExtension->NumberOfOpenInstances--;
                
        DebugPrint(( DebugLevelInfo,
                     "DevExt=%x Close OpenCount=%x\n",
                     DeviceExtension,
                     DeviceExtension->NumberOfOpenInstances));
                     
        IrpStack->FileObject->FsContext = NULL;
        KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
        ObDereferenceObject(DeviceObject);
        SCDereferenceDriver(DeviceExtension);
        ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

        return (SCCompleteIrp(Irp, STATUS_SUCCESS, DeviceExtension));
    }
       

    //
    // we now know that this is either a local instance, or the last open of
    // the global instance.   process the close.
    //

    if ( 0 != DeviceExtension->FilterExtensionSize ) {

        Status = SCSubmitRequest(SRB_CLOSE_DEVICE_INSTANCE,
                                 NULL,
                                 0,
                                 SCCloseInstanceCallback,
                                 DeviceExtension,
                                 FilterInstance->HwInstanceExtension,
                                 NULL,
                                 Irp,
                                 &RequestIssued,
                                 &DeviceExtension->PendingQueue,
                                 (PVOID) DeviceExtension->
                                 MinidriverData->HwInitData.
                                 HwReceivePacket);

        if (!RequestIssued) {
            DEBUG_BREAKPOINT();
            KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
            SCCompleteIrp(Irp, Status, DeviceExtension);
        }
        ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
        return (Status);


    } else {                    // if instanceextension

        //
        // the minidriver doesn't need to be called as it does not support
        // instancing.   dereference the instance now.
        //

        DeviceExtension->NumberOfOpenInstances--;
                
        DebugPrint(( DebugLevelInfo,
                     "DevExt=%x Close OpenCount=%x\n",
                     DeviceExtension,
                     DeviceExtension->NumberOfOpenInstances));
        //
        // we are ready to free the instance.   if it is global, just zero
        // the pointer.   if it is local, remove it from the list.
        //

        IrpStack->FileObject->FsContext = NULL;

        DebugPrint((DebugLevelInfo, "FilterCloseInstance=%x\n", FilterInstance));

        if ( !IsListEmpty( &DeviceExtension->FilterInstanceList)) {
            //
            // The list could be emptied at surprise removal
            // where all instances are removed. so when come in here
            // check it first. Event is taken, check is safe.
            //
            RemoveEntryList(&FilterInstance->NextFilterInstance);
            SciFreeFilterInstance( FilterInstance );
            FilterInstance = NULL;
        }
        
        else {
            //
            // it has been closed by surprise removal. mark it.
            //
            FilterInstance= NULL;
        }

        //
        // if this is the last close of a removed device, detach from
        // the PDO now, since we couldn't do it on the remove.  note that
        // we will NOT do this if the NT style surprise remove IRP has been
        // received, since we'll still receive an IRP_REMOVE in that case
        // after
        // this close.
        //

        if ((DeviceExtension->NumberOfOpenInstances == 0) &&
            (DeviceExtension->Flags & DEVICE_FLAGS_DEVICE_INACCESSIBLE) &&
        !(DeviceExtension->Flags & DEVICE_FLAGS_SURPRISE_REMOVE_RECEIVED)) {

            DebugPrint((DebugLevelInfo,
                        "SCPNP: detaching %x from %x\n",
                        DeviceObject,
                        DeviceExtension->AttachedPdo));

            //
            // detach could happen at remove, check before leap.
            // event is taken, check is safe.
            //
            if ( NULL != DeviceExtension->AttachedPdo ) {
                IoDetachDevice(DeviceExtension->AttachedPdo);
                DeviceExtension->AttachedPdo = NULL;
            }
        } 

        else {

            //
            // check if we can power down the device.
            //

            SCCheckPowerDown(DeviceExtension);

        }                       // if inaccessible

        KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
        if ( NULL != FilterInstance ) {
            DebugPrint(( DebugLevelVerbose,
                     "Unregistering ReadWorker %x WriteWorker %x\n",
                     FilterInstance->WorkerRead,
                     FilterInstance->WorkerWrite));                     
            KsUnregisterWorker( FilterInstance->WorkerRead );
            KsUnregisterWorker( FilterInstance->WorkerWrite );
            KsFreeObjectHeader(FilterInstance->DeviceHeader);
            ExFreePool(FilterInstance);
        }

        SCDereferenceDriver(DeviceExtension);
        ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
        Status = SCCompleteIrp(Irp, STATUS_SUCCESS, DeviceExtension);
        ObDereferenceObject(DeviceObject);
        return (Status);
    }
}



NTSTATUS
SCCloseInstanceCallback(
                        IN PSTREAM_REQUEST_BLOCK SRB
)
/*++

Routine Description:

     Process the completion of an instance close.

Arguments:

     SRB - address of the completed SRB

Return Value:

     None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;
    PIRP            Irp = SRB->HwSRB.Irp;
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    PFILTER_INSTANCE FilterInstance =
    (PFILTER_INSTANCE) SRB->HwSRB.HwInstanceExtension - 1;
    NTSTATUS        Status = SRB->HwSRB.Status;
    KIRQL           irql;

    //
    // Close should not fail. If it does, should clean up anyway
    ASSERT( NT_SUCCESS(Status) && "Close Instance failed" );    
    ///if (NT_SUCCESS(Status)) {

        //
        // we are ready to free the instance.   if it is global, just zero
        // the pointer.   if it is local, remove it from the list.
        //

        DeviceExtension->NumberOfOpenInstances--;

        KeAcquireSpinLock(&DeviceExtension->SpinLock, &irql);


        RemoveEntryList(&FilterInstance->NextFilterInstance);

        //
        // free the instance and return success.
        //

        KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);

        //
        // if this is the last close of a removed device, detach from
        // the PDO now, since we couldn't do it on the remove.
        //

        if ((DeviceExtension->NumberOfOpenInstances == 0) &&
            (DeviceExtension->Flags & DEVICE_FLAGS_DEVICE_INACCESSIBLE)) {

            DebugPrint((DebugLevelTrace,
                        "'SCPNP: detaching from PDO\n"));

            TRAP;
            IoDetachDevice(DeviceExtension->AttachedPdo);
            DeviceExtension->AttachedPdo = NULL;
        }
        //
        // check if we can power down the device.
        //

        SCCheckPowerDown(DeviceExtension);
        ObDereferenceObject(DeviceExtension->DeviceObject);

        //
        // free the instance and header and dereference the driver
        //

        SciFreeFilterInstance( FilterInstance );
        ///#ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
        
        ///DebugPrint(( DebugLevelVerbose,
        ///             "Unregistering ReadWorker %x WriteWorker %x\n",
        ///             FilterInstance->WorkerRead,
        ///             FilterInstance->WorkerWrite));
        ///             
        ///KsUnregisterWorker( FilterInstance->WorkerRead );
        ///KsUnregisterWorker( FilterInstance->WorkerWrite );
        ///#endif
        
        ///KsFreeObjectHeader(FilterInstance->DeviceHeader);
        ///ExFreePool(FilterInstance);
        SCDereferenceDriver(DeviceExtension);

    ///}                           // if good status
    //
    // signal the event and complete the IRP.
    //

    KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
    SCProcessCompletedRequest(SRB);
    return (Status);

}

NTSTATUS
StreamDispatchCleanup 
(
 IN PDEVICE_OBJECT DeviceObject,
 IN PIRP Irp
)
/*++

Routine Description:

    This routine receives CLEANUP IRP's for a stream

Arguments:

    DeviceObject - device object for the device
    Irp - The CLEANUP Irp

Return Value:

    The IRP status set as appropriate

--*/

{

    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation (Irp);
    PSTREAM_OBJECT StreamObject =
        (PSTREAM_OBJECT) IrpStack -> FileObject -> FsContext;
    PDEVICE_EXTENSION DeviceExtension =
        (PDEVICE_EXTENSION) DeviceObject -> DeviceExtension;
    BOOLEAN BreakClockCycle = FALSE;

    KeWaitForSingleObject (
        &DeviceExtension -> ControlEvent,
        Executive,
        KernelMode,
        FALSE,
        NULL
        );

    //
    // If the stream in question is a source stream and it has not yet
    // stopped the sourcing worker, it must be done at this point in time.
    //
    if (StreamObject -> CurrentState > KSSTATE_STOP &&
        StreamObject -> PinType == IrpSource &&
        StreamObject -> StandardTransport) {

        EndTransfer (StreamObject -> FilterInstance, StreamObject);

    }

    //
    // Check for the clock<->pin cycle and break it if present.
    //
    if (StreamObject -> MasterClockInfo) {

        PFILE_OBJECT ClockFile = StreamObject -> MasterClockInfo -> 
            ClockFileObject;

        if (ClockFile && 
            ClockFile -> RelatedFileObject == StreamObject -> FileObject) 

            BreakClockCycle = TRUE;

    }

    KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

    //
    // Synchronously submit an Irp down our own stack to get break the 
    // clock<->pin cycle.  Otherwise, the stream can't close.  The driver should
    // guard against the clock disappearing while running.  Stream class does
    // on TOP of that if they do not.
    //
    if (BreakClockCycle) {
        KSPROPERTY Property;
        HANDLE NewClock = NULL;
        ULONG BytesReturned;
        NTSTATUS Status;

        Property.Set = KSPROPSETID_Stream;
        Property.Id = KSPROPERTY_STREAM_MASTERCLOCK;
        Property.Flags = KSPROPERTY_TYPE_SET;

        Status =
            KsSynchronousIoControlDevice (
                StreamObject -> FileObject,
                KernelMode,
                IOCTL_KS_PROPERTY,
                &Property,
                sizeof (KSPROPERTY),
                &NewClock,
                sizeof (HANDLE),
                &BytesReturned
                );

        ASSERT (NT_SUCCESS (Status));

    }

    Irp -> IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;

}

NTSTATUS
StreamDispatchClose
(
 IN PDEVICE_OBJECT DeviceObject,
 IN PIRP Irp
)
/*++

Routine Description:

    This routine receives CLOSE IRP's for a stream

Arguments:
    DeviceObject - device object for the device
    Irp - probably an IRP, silly

Return Value:

    The IRP status is set as appropriate

--*/

{
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    PSTREAM_OBJECT  StreamObject =
    (PSTREAM_OBJECT) IrpStack->FileObject->FsContext;
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    NTSTATUS        Status;
    BOOLEAN         RequestIssued;
    KSEVENTS_LOCKTYPE LockType;
    PVOID           LockObject;

    PAGED_CODE();

    InterlockedIncrement(&DeviceExtension->OneBasedIoCount);

    ASSERT(IsListEmpty(&StreamObject->ControlPendingQueue));
    ASSERT(IsListEmpty(&StreamObject->DataPendingQueue));

    //
    // free events associated with this stream. this will cause our remove
    // handler to be called for each, and will hence notify the minidriver.
    //

    //
    // determine the type of lock necessary based on whether we are
    // using interrupt or spinlock synchronization.
    //

    #if DBG
    if (DeviceExtension->SynchronizeExecution == SCDebugKeSynchronizeExecution) {
    #else
    if (DeviceExtension->SynchronizeExecution == KeSynchronizeExecution) {
    #endif
        LockType = KSEVENTS_INTERRUPT;
        LockObject = DeviceExtension->InterruptObject;

    } else {

        LockType = KSEVENTS_SPINLOCK;
        LockObject = &DeviceExtension->SpinLock;

    }

    KsFreeEventList(IrpStack->FileObject,
                    &StreamObject->NotifyList,
                    LockType,
                    LockObject);

    //
    // call the minidriver to close the stream.  processing will continue
    // when the callback procedure is called.
    //

    KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                          Executive,
                          KernelMode,
                          FALSE,// not alertable
                          NULL);

    Status = SCSubmitRequest(SRB_CLOSE_STREAM,
                             NULL,
                             0,
                             SCCloseStreamCallback,
                             DeviceExtension,
                             StreamObject->
                             FilterInstance->HwInstanceExtension,
                             &StreamObject->HwStreamObject,
                             Irp,
                             &RequestIssued,
                             &DeviceExtension->PendingQueue,
                             (PVOID) DeviceExtension->
                             MinidriverData->HwInitData.
                             HwReceivePacket);

    if (!RequestIssued) {
        DEBUG_BREAKPOINT();
        KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
        SCCompleteIrp(Irp, Status, DeviceExtension);
    }
    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    return (Status);

}



NTSTATUS
SCCloseStreamCallback(
                      IN PSTREAM_REQUEST_BLOCK SRB
)
/*++

Routine Description:

     Process the completion of a stream close.

Arguments:

     SRB - address of the completed SRB

Return Value:

     None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;
    PADDITIONAL_PIN_INFO AdditionalInfo;
    PSTREAM_OBJECT  StreamObject = CONTAINING_RECORD(
                                                     SRB->HwSRB.StreamObject,
                                                     STREAM_OBJECT,
                                                     HwStreamObject
    );
    PIRP            Irp = SRB->HwSRB.Irp;
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    KIRQL           Irql;
    NTSTATUS        Status = SRB->HwSRB.Status;

    ASSERT( NT_SUCCESS(Status) && "CloseStream Failed by Minidriver");

    //
    // Close should not fail. Even it does, we want to clean up.
    //
    // if (NT_SUCCESS(Status)) {

        //
        // show one fewer instance open
        //

        DebugPrint((DebugLevelInfo, "SC Closing StreamObject %x\n", StreamObject));

        AdditionalInfo = ((PFILTER_INSTANCE) IrpStack->FileObject->
                          RelatedFileObject->FsContext)->PinInstanceInfo;
        AdditionalInfo[StreamObject->HwStreamObject.StreamNumber].
            CurrentInstances--;

        //
        // free the object header for the stream
        //

        KsFreeObjectHeader(StreamObject->ComObj.DeviceHeader);

        //
        // free the constructed props, if any.
        //

        if (StreamObject->ConstructedPropertyInfo) {

            ExFreePool(StreamObject->ConstructedPropertyInfo);
        }
        //
        // signal the event.
        // signal now so that we won't
        // deadlock when we dereference the object and the filter is closed.
        //

        KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

        //
        // Zero the pointer to our per stream structure in the FsContext
        // field of
        // of FileObject.
        //

        IrpStack->FileObject->FsContext = 0;

        //
        // remove the stream object from the filter instance list
        //

        KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

        RemoveEntryList(&StreamObject->NextStream);

        KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

        //
        // kill the timer, which might have been left dangling by the
        // minidriver.
        //

        KeCancelTimer(&StreamObject->ComObj.MiniDriverTimer);

        //
        // dereference the master clock if any
        //

        if (StreamObject->MasterClockInfo) {

            ObDereferenceObject(StreamObject->MasterClockInfo->ClockFileObject);
            ExFreePool(StreamObject->MasterClockInfo);
        }
 
        #ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
        //
        // dereference the next file object
        //
        if (StreamObject->NextFileObject)
        {
            ObDereferenceObject(StreamObject->NextFileObject);
            StreamObject->NextFileObject = NULL;
        }

        //
        // Dereference the allocator object or stream obj won't be
        // release while it should. Problems would follow particularly
        // with SWEnum loaded driver.
        //
        if ( StreamObject->AllocatorFileObject ) {
            ObDereferenceObject( StreamObject->AllocatorFileObject );
            StreamObject->AllocatorFileObject = NULL;
        }            
        #endif

        //
        // dereference the filter
        //

        ObDereferenceObject(StreamObject->FilterFileObject);
 
        ExFreePool(StreamObject);
    ///} else {                    // if good status

    ///    KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

    ///}                           // if good status

    SCProcessCompletedRequest(SRB);
    return (Status);

}



BOOLEAN
StreamClassInterrupt(
                     IN PKINTERRUPT Interrupt,
                     IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    Process interrupt from the device

Arguments:

    Interrupt - interrupt object

    Device Object - device object which is interrupting

Return Value:

    Returns TRUE if interrupt expected.

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    BOOLEAN         returnValue;

    UNREFERENCED_PARAMETER(Interrupt);

    //
    // check if the interrupt cannot currently go down
    //

    if (deviceExtension->DriverInfo->Flags & DRIVER_FLAGS_PAGED_OUT) {

        return (FALSE);
    }
    //
    // call the minidriver's interrupt service routine.
    //

    returnValue = deviceExtension->MinidriverData->
        HwInitData.HwInterrupt(deviceExtension->HwDeviceExtension);

    //
    // Queue up a DPC if needed.
    //

    if ((deviceExtension->NeedyStream) || (deviceExtension->ComObj.
             InterruptData.Flags & INTERRUPT_FLAGS_NOTIFICATION_REQUIRED)) {

        KeInsertQueueDpc(&deviceExtension->WorkDpc, NULL, NULL);

    }
    return (returnValue);

}                               // end StreamClassInterrupt()


NTSTATUS
StreamClassNull(
                IN PDEVICE_OBJECT DeviceObject,
                IN PIRP Irp

)
/*++

Routine Description:

    This routine fails incoming irps.

Arguments:
    DeviceObject - device object for the device
    Irp - probably an IRP, silly

Return Value:

    The IRP status is returned

--*/

{
    //
    // complete the IRP with error status
    //

    PAGED_CODE();
    return (SCCompleteIrp(Irp, STATUS_NOT_SUPPORTED, DeviceObject->DeviceExtension));
}

NTSTATUS
SCFilterPinInstances(
                     IN PIRP Irp,
                     IN PKSPROPERTY Property,
                     IN OUT PVOID Data)
/*++

Routine Description:

    Returns the # of instances supported by a pin

Arguments:

         Irp - pointer to the irp
         Property - pointer to the property info
         Data - instance info

Return Value:

    NTSTATUS returned as appropriate

--*/

{
    ULONG           Pin;
    PKSPIN_CINSTANCES CInstances;
    PIO_STACK_LOCATION IrpStack;
    PDEVICE_EXTENSION DeviceExtension;
    PFILTER_INSTANCE FilterInstance;
    PADDITIONAL_PIN_INFO AdditionalPinInfo;

    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = (PDEVICE_EXTENSION) IrpStack->
        DeviceObject->DeviceExtension;

    FilterInstance = IrpStack->FileObject->FsContext;

    //
    // get the pin #
    //

    Pin = ((PKSP_PIN) Property)->PinId;

    //
    // if max pin number exceeded, return error
    //

    IFN_MF(
        if (Pin >= DeviceExtension->NumberOfPins) {

            DEBUG_BREAKPOINT();
         return (STATUS_INVALID_PARAMETER);
        }
    )

    IF_MF(
        if (Pin >= FilterInstance->NumberOfPins) {

            DEBUG_BREAKPOINT();
            return (STATUS_INVALID_PARAMETER);
        }
    )
    CInstances = (PKSPIN_CINSTANCES) Data;

    AdditionalPinInfo = FilterInstance->PinInstanceInfo;

    CInstances->PossibleCount = AdditionalPinInfo[Pin].MaxInstances;
    CInstances->CurrentCount = AdditionalPinInfo[Pin].CurrentInstances;

    Irp->IoStatus.Information = sizeof(KSPIN_CINSTANCES);
    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    return (STATUS_SUCCESS);
}

NTSTATUS
SCFilterPinPropertyHandler(
                           IN PIRP Irp,
                           IN PKSPROPERTY Property,
                           IN OUT PVOID Data)
/*++

Routine Description:

    Dispatches a pin property request

Arguments:

         Irp - pointer to the irp
         Property - pointer to the property info
         Data - property specific buffer

Return Value:

    NTSTATUS returned as appropriate

--*/

{
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) IrpStack->
                                        DeviceObject->DeviceExtension;
        PFILTER_INSTANCE    FilterInstance= (PFILTER_INSTANCE) IrpStack->
                                            FileObject->FsContext;

    PAGED_CODE();
    

    return KsPinPropertyHandler(Irp,
                            Property,
                            Data,
                            FilterInstance->NumberOfPins,
                            FilterInstance->PinInformation);
}



VOID
StreamClassTickHandler(
                       IN PDEVICE_OBJECT DeviceObject,
                       IN PVOID Context
)
/*++

Routine Description:

    Tick handler for device.

Arguments:

    DeviceObject - pointer to the device object
    Context - unreferenced

Return Value:

    None.

--*/

{

    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    PLIST_ENTRY     ListEntry;
    PLIST_ENTRY     SrbListEntry = ListEntry = &DeviceExtension->OutstandingQueue;
    PSTREAM_REQUEST_BLOCK Srb;

    UNREFERENCED_PARAMETER(Context);

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // acquire the device spinlock to protect the queues.
    //

    KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

    //
    // process any timed out requests on the device
    //

    while (SrbListEntry->Flink != ListEntry) {

        SrbListEntry = SrbListEntry->Flink;

        Srb = CONTAINING_RECORD(SrbListEntry,
                                STREAM_REQUEST_BLOCK,
                                SRBListEntry);
        //
        // first make sure the request is active, since it could have been
        // called back but not yet removed from the queue.
        //

        if (Srb->Flags & SRB_FLAGS_IS_ACTIVE) {

            //
            // check for a timeout if the counter is currently nonzero.
            //

            if (Srb->HwSRB.TimeoutCounter != 0) {

                if (--Srb->HwSRB.TimeoutCounter == 0) {

                    //
                    // request timed out.  Call the minidriver to process it.
                    // first reset the timer in case the minidriver is
                    // busted.
                    //

                    DebugPrint((DebugLevelError, "SCTickHandler: Irp %x timed out!  SRB = %x, SRB func = %x, Stream Object = %x\n",
                                Srb->HwSRB.Irp, Srb, Srb->HwSRB.Command, Srb->HwSRB.StreamObject));
                    Srb->HwSRB.TimeoutCounter = Srb->HwSRB.TimeoutOriginal;

                    DeviceExtension = (PDEVICE_EXTENSION)
                        Srb->HwSRB.HwDeviceExtension - 1;

                    //
                    // if we are not synchronizing the minidriver, release
                    // and reacquire the spinlock around the call into it.
                    //

                    if (DeviceExtension->NoSync) {

                        //
                        // we need to ensure that the SRB memory is valid for
                        // the async
                        // minidriver, EVEN if it happens to call back the
                        // request just
                        // before we call it to cancel it!   This is done for
                        // two reasons:
                        // it obviates the need for the minidriver to walk
                        // its request
                        // queues to find the request, and I failed to pass
                        // the dev ext
                        // pointer to the minidriver in the below call, which
                        // means that
                        // the SRB HAS to be valid, and it's too late to
                        // change the API.
                        //
                        // Oh, well.   Spinlock is now taken (by caller).
                        //

                        Srb->DoNotCallBack = TRUE;

                        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

                        (DeviceExtension->MinidriverData->HwInitData.HwRequestTimeoutHandler)
                            (&Srb->HwSRB);
                        KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

                        //
                        // if the ACTIVE flag is now clear, it indicates that
                        // the
                        // SRB was completed during the above call into the
                        // minidriver.
                        // since we blocked the internal completion of the
                        // request,
                        // we must call it back ourselves in this case.
                        //

                        Srb->DoNotCallBack = FALSE;
                        if (!(Srb->Flags & SRB_FLAGS_IS_ACTIVE)) {
                            TRAP;

                            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);
                            (Srb->Callback) (Srb);
                            KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);
                        }       // if ! active
                        break;

                    } else {    // if nosync

                        DeviceExtension->SynchronizeExecution(
                            DeviceExtension->InterruptObject,
                            (PVOID) DeviceExtension->MinidriverData->HwInitData.HwRequestTimeoutHandler,
                            &Srb->HwSRB);

                        // return now in case the minidriver aborted any
                        // other
                        // requests that
                        // may be timing out now.
                        //

                        break;

                    }           // if nosync


                }               // if timed out
            }                   // if counter != 0
        }                       // if active
    }                           // while list entry

    //
    // let my people go...
    //

    KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    return;

}                               // end StreamClassTickHandler()


VOID
StreamClassCancelPendingIrp(
                            IN PDEVICE_OBJECT DeviceObject,
                            IN PIRP Irp
)
/*++

Routine Description:

    Cancel routine for pending IRP's.

Arguments:

    DeviceObject - pointer to the device object
    Irp - pointer to IRP to be cancelled

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    PFILTER_INSTANCE FilterInstance;
    PLIST_ENTRY     ListHead, ListEntry;
    KIRQL           CancelIrql,
                    Irql;
    PSTREAM_REQUEST_BLOCK SRB;

    DebugPrint((DebugLevelWarning, "'SCCancelPending: trying to cancel Irp = %x\n",
                Irp));

    //
    // acquire the device spinlock then release the cancel spinlock.
    //

    KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

    CancelIrql = Irp->CancelIrql;

    IoReleaseCancelSpinLock(Irql);

    //
    // there are two possibilities here.   1) the IRP is on the pending queue
    // for the particular stream.  2) the IRP was moved from pending to
    // outstanding and has been submitted to the minidriver.
    // If we are running above an external bus driver, don't
    //

    //
    // now process all streams on the local filter instances.
    //

    ListHead = &DeviceExtension->FilterInstanceList;
    ListEntry = ListHead->Flink;

    while ( ListEntry != ListHead ) {

        //
        // follow the link to the instance
        //

        FilterInstance = CONTAINING_RECORD(ListEntry,
                                           FILTER_INSTANCE,
                                           NextFilterInstance);

        //
        // process the streams on this list
        //

        if (SCCheckFilterInstanceStreamsForIrp(FilterInstance, Irp)) {
            goto found;
        }

        ListEntry = ListEntry->Flink;
    }

    //
    // now process any requests on the device itself
    //

    if (SCCheckRequestsForIrp(
          &DeviceExtension->OutstandingQueue, Irp, TRUE, DeviceExtension)) {
        goto found;
    }
    //
    // request is not on pending queue, so call to check the outstanding
    // queue
    //

    SCCancelOutstandingIrp(DeviceExtension, Irp);

    KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

exit:

    //
    // now call the DPC in case the request was successfully aborted.
    //

    StreamClassDpc(NULL,
                   DeviceExtension->DeviceObject,
                   NULL,
                   NULL);

    KeLowerIrql(CancelIrql);

    return;

found:

    //
    // the irp is on one of our pending queues.  remove it from the queue and
    // complete it.
    //

    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

    //
    // retrieve the SRB.
    //

    SRB = Irp->Tail.Overlay.DriverContext[0];

    //
    // hack - the completion handlers will try to remove the SRB from the
    // outstanding queue.  Point the SRB's queues to itself so this will not
    // cause a problem.
    //

    SRB->SRBListEntry.Flink = &SRB->SRBListEntry;
    SRB->SRBListEntry.Blink = &SRB->SRBListEntry;

    SRB->HwSRB.Status = STATUS_CANCELLED;

    KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

    (SRB->Callback) (SRB);
    goto exit;

}

VOID
StreamClassCancelOutstandingIrp(
                                IN PDEVICE_OBJECT DeviceObject,
                                IN PIRP Irp
)
/*++

Routine Description:

    Cancel routine for IRP's outstanding in the minidriver

Arguments:

    DeviceObject - pointer to the device object
    Irp - pointer to IRP to be cancelled

Return Value:

    None.

--*/

{

    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    KIRQL           Irql,
                    CancelIrql;

    DebugPrint((DebugLevelWarning, "'SCCancelOutstanding: trying to cancel Irp = %x\n",
                Irp));

    //
    // acquire the device spinlock.
    //

    KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

    CancelIrql = Irp->CancelIrql;

    IoReleaseCancelSpinLock(Irql);

    SCCancelOutstandingIrp(DeviceExtension, Irp);

    KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

    //
    // now call the DPC in case the request was successfully aborted.
    //

    StreamClassDpc(NULL,
                   DeviceExtension->DeviceObject,
                   NULL,
                   NULL);

    KeLowerIrql(CancelIrql);
    return;
}


VOID
StreamFlushIo(
              IN PDEVICE_EXTENSION DeviceExtension,
              IN PSTREAM_OBJECT StreamObject
)
/*++

Routine Description:

    Cancel all IRP's on the specified stream.

Arguments:

Return Value:

    STATUS_SUCCESS

--*/

{

    PLIST_ENTRY     IrpEntry;
    KIRQL           Irql;
    PSTREAM_REQUEST_BLOCK SRB;
    PIRP            Irp;

    //
    // abort all I/O on the specified stream.   first acquire the spinlock.
    //

    KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

    //
    // if there is I/O on our pending data queue, abort it.
    //

    while (!IsListEmpty(&StreamObject->DataPendingQueue)) {

        //
        // grab the IRP at the head of the queue and abort it.
        //

        IrpEntry = StreamObject->DataPendingQueue.Flink;

        Irp = CONTAINING_RECORD(IrpEntry,
                                IRP,
                                Tail.Overlay.ListEntry);

        //
        // remove the IRP from our pending queue and call it back with
        // cancelled status
        //

        RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

        //
        // null out the cancel routine
        //

        IoSetCancelRoutine(Irp, NULL);

        DebugPrint((DebugLevelTrace,
                    "'StreamFlush: Canceling Irp %x \n", Irp));


        KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

        //
        // The request cannot just be completed or all the resources
        // associated with it will not be freed.  Call it back.
        //
        SRB = (PSTREAM_REQUEST_BLOCK)(Irp->Tail.Overlay.DriverContext [0]);
        ASSERT (SRB);

        //
        // hack - the completion handlers will try to remove the SRB from the
        // outstanding queue.  Point the SRB's queues to itself so this will not
        // cause a problem.
        //
        SRB->SRBListEntry.Flink = &SRB->SRBListEntry;
        SRB->SRBListEntry.Blink = &SRB->SRBListEntry;
        SRB->HwSRB.Status = STATUS_CANCELLED;

        SCCallBackSrb (SRB, DeviceExtension);

        KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

    }

    //
    // if there is I/O on our pending control queue, abort it.
    //

    while (!IsListEmpty(&StreamObject->ControlPendingQueue)) {

        //
        // grab the IRP at the head of the queue and abort it.
        //

        DEBUG_BREAKPOINT();
        IrpEntry = StreamObject->ControlPendingQueue.Flink;

        Irp = CONTAINING_RECORD(IrpEntry,
                                IRP,
                                Tail.Overlay.ListEntry);


        //
        // remove the IRP from our pending queue and call it back with
        // cancelled status
        //

        RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

        //
        // null out the cancel routine
        //

        IoSetCancelRoutine(Irp, NULL);

        DebugPrint((DebugLevelTrace,
                    "'StreamFlush: Canceling Irp %x \n", Irp));

        KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

        //
        // The request cannot just be completed or all the resources
        // associated with it will not be freed.  Call it back.
        //
        SRB = (PSTREAM_REQUEST_BLOCK)(Irp->Tail.Overlay.DriverContext [0]);
        ASSERT (SRB);

        //
        // hack - the completion handlers will try to remove the SRB from the
        // outstanding queue.  Point the SRB's queues to itself so this will not
        // cause a problem.
        //
        SRB->SRBListEntry.Flink = &SRB->SRBListEntry;
        SRB->SRBListEntry.Blink = &SRB->SRBListEntry;
        SRB->HwSRB.Status = STATUS_CANCELLED;

        SCCallBackSrb (SRB, DeviceExtension);

        KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

    }

    //
    // now cancel any irps for this stream on the outstanding queue.
    // walk the outstanding queue trying to find an SRB for this stream.
    //

    IrpEntry = &DeviceExtension->OutstandingQueue;

    while (IrpEntry->Flink != &DeviceExtension->OutstandingQueue) {

        IrpEntry = IrpEntry->Flink;

        //
        // follow the link to the SRB
        //

        SRB = (PSTREAM_REQUEST_BLOCK) (CONTAINING_RECORD(IrpEntry,
                                                       STREAM_REQUEST_BLOCK,
                                                         SRBListEntry));
        //
        // if this SRB's stream object matches the one we're cancelling for,
        // AND it has not been previously cancelled, AND the IRP itself has
        // not been completed (non-null IRP field), abort this request.
        //


        if ((StreamObject == CONTAINING_RECORD(
                                               SRB->HwSRB.StreamObject,
                                               STREAM_OBJECT,
                                               HwStreamObject)) &&
            (SRB->HwSRB.Irp) &&
            !(SRB->HwSRB.Irp->Cancel)) {

            //
            // The IRP has not been previously cancelled, so cancel it after
            // releasing the spinlock to avoid deadlock with the cancel
            // routine.
            //

            DebugPrint((DebugLevelTrace,
                      "'StreamFlush: Canceling Irp %x \n", SRB->HwSRB.Irp));

            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

            IoCancelIrp(SRB->HwSRB.Irp);

            KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

            //
            // restart at the top of the queue since we released the
            // spinlock.
            // we won't get in an endless loop since we set the cancel flag
            // in the IRP.
            //

            IrpEntry = &DeviceExtension->OutstandingQueue;


        }                       // if streamobjects match
    }                           // while entries


    //
    // release the spinlock but remain at DPC level.
    //

    KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

    //
    // now call the DPC in case the request was successfully aborted.
    //

    StreamClassDpc(NULL,
                   DeviceExtension->DeviceObject,
                   NULL,
                   NULL);

    //
    // lower IRQL
    //

    KeLowerIrql(Irql);

}

NTSTATUS
ClockDispatchCreate(
                    IN PDEVICE_OBJECT DeviceObject,
                    IN PIRP Irp
)
{
    NTSTATUS        Status;
    PCLOCK_INSTANCE ClockInstance=NULL; //Prefixbug 17399
    PIO_STACK_LOCATION IrpStack;
    PKSCLOCK_CREATE ClockCreate;
    PFILE_OBJECT    ParentFileObject;
    PSTREAM_OBJECT  StreamObject=NULL; // prefixbug 17399
    BOOLEAN         RequestIssued=FALSE; // prefixbug 17398

    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // show one more I/O pending & verify that we can actually do I/O.
    //

    Status = SCShowIoPending(DeviceObject->DeviceExtension, Irp);

    if ( !NT_SUCCESS ( Status )) {

        //
        // the device is currently not accessible, so just return with error
        //

        return (Status);

    }
    Status = KsValidateClockCreateRequest(Irp,
                                          &ClockCreate);

    ParentFileObject = IrpStack->FileObject->RelatedFileObject;

    DebugPrint((DebugLevelTrace,
                "'ClockCreate: Creating clock with Irp %x \n", Irp));

    if (NT_SUCCESS(Status)) {

        //
        // allocate a clock instance for the clock
        //

        ClockInstance =
            (PCLOCK_INSTANCE)
            ExAllocatePool(NonPagedPool, sizeof(CLOCK_INSTANCE));

        if (ClockInstance) {

            //
            // fill in the clock instance structure and reference it in the
            // file
            // object for the clock
            //

            ClockInstance->ParentFileObject = ParentFileObject;

            #if 0
            ClockInstance->ClockFileObject = IrpStack->FileObject;
            DebugPrint((DebugLevelInfo,
                       "++++++++ClockInstance=%x, FileObject=%x\n",
                       ClockInstance,
                       ClockInstance->ClockFileObject));
            #endif

            KsAllocateObjectHeader(&ClockInstance->DeviceHeader,
                                   SIZEOF_ARRAY(StreamDriverDispatch),
                                   (PKSOBJECT_CREATE_ITEM) NULL,
                                   Irp,
                                   (PKSDISPATCH_TABLE) & ClockDispatchTable);

            IrpStack->FileObject->FsContext = ClockInstance;

            //
            // set the 2nd context parameter so that we can identify this
            // object as the clock object.
            //

            IrpStack->FileObject->FsContext2 = ClockInstance;

            //
            // call the minidriver to indicate that this stream is the master
            // clock.  pass the file object as a handle to the master clock.
            //

            StreamObject = (PSTREAM_OBJECT) ParentFileObject->FsContext;

            StreamObject->ClockInstance = ClockInstance;
            ClockInstance->StreamObject = StreamObject;


            Status = SCSubmitRequest(SRB_OPEN_MASTER_CLOCK,
                                     (HANDLE) IrpStack->FileObject,
                                     0,
                                     SCOpenMasterCallback,
                                     StreamObject->DeviceExtension,
                          StreamObject->FilterInstance->HwInstanceExtension,
                                     &StreamObject->HwStreamObject,
                                     Irp,
                                     &RequestIssued,
                                     &StreamObject->ControlPendingQueue,
                                     (PVOID) StreamObject->HwStreamObject.
                                     ReceiveControlPacket
                );

        } else {                // if clockinstance

            Status = STATUS_INSUFFICIENT_RESOURCES;

        }                       // if clockinstance

    }                           // if validate success
    if (!RequestIssued) {

        if ( NULL != StreamObject && NULL != StreamObject->ClockInstance ) {
            ExFreePool(StreamObject->ClockInstance);
            StreamObject->ClockInstance = NULL; // prefixbug 17399
        }

        SCCompleteIrp(Irp,
                      STATUS_INSUFFICIENT_RESOURCES,
                      DeviceObject->DeviceExtension);

    }
    return (Status);

}

NTSTATUS
AllocatorDispatchCreate(
                        IN PDEVICE_OBJECT DeviceObject,
                        IN PIRP Irp
)
/*++

Routine Description:

     Processes the allocator create IRP.   Currently just uses the default
     allocator.

Arguments:

Return Value:

     None.

--*/
{
    PIO_STACK_LOCATION IrpStack;
    PFILE_OBJECT    ParentFileObject;
    PSTREAM_OBJECT  StreamObject;
    NTSTATUS        Status;

    PAGED_CODE();

    DebugPrint((DebugLevelTrace,"entering AllocatorDispatchCreate\n"));
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    ParentFileObject = IrpStack->FileObject->RelatedFileObject;
    StreamObject = (PSTREAM_OBJECT) ParentFileObject->FsContext;

    //
    // show one more I/O pending & verify that we can actually do I/O.
    //

    Status = SCShowIoPending(DeviceObject->DeviceExtension, Irp);

    if ( !NT_SUCCESS ( Status )) {

        //
        // the device is currently not accessible, so just return with error
        //

        DebugPrint((DebugLevelError,"exiting AllocatorDispatchCreate-REMOVED\n"));
        return (Status);

    }
    //
    // if allocator is not needed for this stream, just fail the call.
    //

    if (!StreamObject->HwStreamObject.Allocator) {

        DebugPrint((DebugLevelTrace,"exiting AllocatorDispatchCreate-not implemented\n"));
        return SCCompleteIrp(Irp,
                             STATUS_NOT_IMPLEMENTED,
                             DeviceObject->DeviceExtension);
    }

    DebugPrint((DebugLevelTrace,"exiting AllocatorDispatchCreate-complete\n"));
    return SCCompleteIrp(Irp,
                         KsCreateDefaultAllocator(Irp),
                         DeviceObject->DeviceExtension);
}

NTSTATUS
SCOpenMasterCallback(
                     IN PSTREAM_REQUEST_BLOCK SRB
)
/*++

Routine Description:

     Process the completion of a master clock open.

Arguments:

     SRB - address of the completed SRB

Return Value:

     None.

--*/

{
    PSTREAM_OBJECT  StreamObject = CONTAINING_RECORD(
                                                     SRB->HwSRB.StreamObject,
                                                     STREAM_OBJECT,
                                                     HwStreamObject
    );
    PIRP            Irp = SRB->HwSRB.Irp;
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);

    PAGED_CODE();

    // log 'oMC ', StreamObject, DevExt, Status
    SCLOG( ' CMo', StreamObject, StreamObject->DeviceExtension, SRB->HwSRB.Status);
    
    if (!NT_SUCCESS(SRB->HwSRB.Status)) {

        //
        // if we could not set the master, free the clock handle and zero
        // the link to the clock.
        //

        ExFreePool(StreamObject->ClockInstance);
        StreamObject->ClockInstance = NULL;

    } else {                    // if status success

        //
        // reference the pin handle so we won't be called to close the pin
        // before the clock is closed
        //

        ObReferenceObject(IrpStack->FileObject->RelatedFileObject);
    }                           // if status success

    //
    // complete the SRB
    //

    return (SCProcessCompletedRequest(SRB));
}


NTSTATUS
SCGetMasterClock(
                 IN PIRP Irp,
                 IN PKSPROPERTY Property,
                 IN OUT PHANDLE ClockHandle
)
{
    //
    // WorkWork - for now do nothing.
    //

    PAGED_CODE();

    return (STATUS_NOT_SUPPORTED);

}

VOID
SciSetMasterClockInfo(
    IN PSTREAM_OBJECT pStreamObject,
    IN PMASTER_CLOCK_INFO pMasterClockInfo )
/*++
    Decription:

        This function simply set the new masterclock info for the stream
        with LockUseMasterClock hold. Because of taking a spinlock we need
        this function in lock memory. This function is intended to be called
        by SCSetMasterClockOnly. pStreamObject is assumed valid.

    Parameters:

        pStreamObject: the target stream object to set to the new MasterCLockInfo
        pMasterClockInfo: the new master clock info.

    Return: None.
    
--*/
{
    KIRQL SavedIrql;
    
    KeAcquireSpinLock( &pStreamObject->LockUseMasterClock, &SavedIrql );
    pStreamObject->MasterClockInfo = pMasterClockInfo;
    KeReleaseSpinLock( &pStreamObject->LockUseMasterClock, SavedIrql );

    return;
}


NTSTATUS
SCSetMasterClock(
                 IN PIRP Irp,
                 IN PKSPROPERTY Property,
                 IN PHANDLE ClockHandle
)
/*++

Description:

    This is a Set property on a the stream. The request may be setting to
    NULL CLockHandle which indicates master clock is revoked. If ClockHandle
    is non-NULL, it is a new Master clock chosen by the graph manager. 

Parameters:

    Irp: the IO request packet to Set the master clock.
    Property: the Set Master clock property
    ClockHanlde: the handle of the clock designated as the new master clcok.

Return: 

    NTSTAUS: depending on the result of processing the request.

Comments:

    This function must be called at IRQL < DISPATCH_LEVEL

--*/
{
    NTSTATUS        Status;
    PIO_STACK_LOCATION IrpStack;
    PSTREAM_OBJECT  StreamObject;
    KSPROPERTY      FuncProperty;
    PMASTER_CLOCK_INFO NewMasterClockInfo=NULL; //prefixbug 17396
    PMASTER_CLOCK_INFO OldMasterClockInfo;
    ULONG           BytesReturned;
    PFILE_OBJECT    ClockFileObject = NULL;
    BOOLEAN         RequestIssued=FALSE;

    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->FsContext;

    
    //
    // This function can be called from multiple threads. We will serialize
    // this function on the Stream to protect against concurrent accesses.
    //
    KeWaitForSingleObject(&StreamObject->ControlSetMasterClock,
                          Executive,
                          KernelMode,
                          FALSE,// not alertable
                          NULL);

    //
    // N.B.
    //
    // If our clock is open, we are potentially the master clock. But this
    // is not guaranteed. Ksproxy opens our clock in attempt to use it as
    // the master clock. But it can change its mind to choose another clock,
    // while keeping our clock open.
    //

    //
    // log 'sMC ', StreamObject, MasterClockInfo, *ClockHandle )
    //
    SCLOG( ' CMs', StreamObject, StreamObject->MasterClockInfo, *ClockHandle );

    /* 
        Not so soon. We have not told mini drivers the new master clock yet. 
        Mini drivers might think they still have the retiring Master clock and
        can query the clock in the mean time. We would crash on accessing NULL
        MasterClockInfo. We should not nullify it before we notify the mini 
        driver first.
        
    if (StreamObject->MasterClockInfo) {

        ObDereferenceObject(StreamObject->MasterClockInfo->ClockFileObject);
        ExFreePool(StreamObject->MasterClockInfo);
        StreamObject->MasterClockInfo = NULL;
    }
    */
    OldMasterClockInfo = StreamObject->MasterClockInfo;
    
    //
    // if there is a clock, reference it.  If not, we'll send down a null handle.
    //

    if (*ClockHandle) {

        //
        // alloc a structure to represent the master clock
        //

        NewMasterClockInfo = ExAllocatePool(NonPagedPool, sizeof(MASTER_CLOCK_INFO));

        if (!NewMasterClockInfo) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit;

        }

        //
        // This is too early to assign. We have not setup MasterClockInfo yet.
        //
        // StreamObject->MasterClockInfo = MasterClockInfo;

        //
        // reference the clock handle, thereby getting the file object for it.
        //

        if (!NT_SUCCESS((Status = ObReferenceObjectByHandle(*ClockHandle,
                                             FILE_READ_ACCESS | SYNCHRONIZE,
                                                          *IoFileObjectType,
                                                         Irp->RequestorMode,
                                                            &ClockFileObject,
                                                            NULL
                                                            )))) {

            ExFreePool(NewMasterClockInfo);
            NewMasterClockInfo = NULL;
            goto exit;

        }                       // if Ob succeeded
        NewMasterClockInfo->ClockFileObject = ClockFileObject;
        
        // check master clock
        #if 0
        {
            if ( StreamObject->ClockInstance ) {
                //
                // we are chosen the master clock
                //
                DebugPrint((DebugLevelInfo,
                            "--------ClockInstance=%x, FileObject=%x "
                            "Indicated ClockFileObject=%x context=%x\n",
                            StreamObject->ClockInstance,
                            StreamObject->ClockInstance->ParentFileObject,
                            ClockFileObject,
                            ClockFileObject->FsContext));
            }
            else {
                DebugPrint((DebugLevelInfo,
                            "--------Indicated ClockFileObject=%x context=%x\n",
                            ClockFileObject,
                            ClockFileObject->FsContext));
            }
        }
        #endif

        //
        // issue the IOCtl to get the function table of the master clock.
        //

        FuncProperty.Id = KSPROPERTY_CLOCK_FUNCTIONTABLE;
        FuncProperty.Flags = KSPROPERTY_TYPE_GET;

        RtlMoveMemory(&FuncProperty.Set, &KSPROPSETID_Clock, sizeof(GUID));

        if (!NT_SUCCESS((Status = KsSynchronousIoControlDevice(
                                                            ClockFileObject,
                                                               KernelMode,
                                                          IOCTL_KS_PROPERTY,
                                                               &FuncProperty,
                                                         sizeof(KSPROPERTY),
                                            &NewMasterClockInfo->FunctionTable,
                                              sizeof(KSCLOCK_FUNCTIONTABLE),
                                                        &BytesReturned)))) {


            ObDereferenceObject(NewMasterClockInfo->ClockFileObject);
            ExFreePool(NewMasterClockInfo);
            NewMasterClockInfo = NULL;
            goto exit;
        }
    }                           // if *ClockHandle
    //
    // call the minidriver to indicate the master clock. 
    //
    if ( NULL != NewMasterClockInfo ) {
        //
        // but first, let's put in the MasterClockInfo. When mini driver
        // gets notified with the masterclock, it could fire GetTime right away
        // before the notification returns. Get ready to deal with it. This is
        // critical if oldMasterClockInfo is NULL. Not much so otherwise.
        //
        //
        // Make sure no one is querying master clock when setting the new clock info.
        //
        SciSetMasterClockInfo( StreamObject, NewMasterClockInfo );
    }

    Status = SCSubmitRequest(SRB_INDICATE_MASTER_CLOCK,
                             ClockFileObject,
                             0,
                             SCDequeueAndDeleteSrb,
                             StreamObject->DeviceExtension,
                             StreamObject->FilterInstance->HwInstanceExtension,
                             &StreamObject->HwStreamObject,
                             Irp,
                             &RequestIssued,
                             &StreamObject->ControlPendingQueue,
                             (PVOID) StreamObject->HwStreamObject.
                             ReceiveControlPacket);

    ASSERT( RequestIssued );
    ASSERT( NT_SUCCESS( Status ) );
    
    //
    // SCSubmitRequest is a synch call. When we return here, We can finish our work
    // based on the Status code.
    //
    if ( NT_SUCCESS( Status )) {
        //
        // Everything is cool. Finish up. The assignment is redundent if 
        // NewMasterClockInfo is not NULL. Better assign unconditionally than check.
        //
        //
        // Make sure no one is querying master clock when updating MasterClockInfo
        //
        SciSetMasterClockInfo( StreamObject, NewMasterClockInfo );

        if (NULL != OldMasterClockInfo) {
            
            ObDereferenceObject(OldMasterClockInfo->ClockFileObject);
            ExFreePool(OldMasterClockInfo);
        }
        
    } else {
        //
        // Failed to tell mini driver the new clock. Clean up shop. But don't update
        // StreamObject->MasterClockInfo. Keep the status quo.
        //
        //
        // Make sure no one is querying master clock when updateing MasterClockInfo.
        //
        SciSetMasterClockInfo( StreamObject, OldMasterClockInfo );
        
        if (NewMasterClockInfo) {
            ObDereferenceObject(ClockFileObject);
            ExFreePool(NewMasterClockInfo);
        }
    }
    
exit:
    KeSetEvent(&StreamObject->ControlSetMasterClock, IO_NO_INCREMENT, FALSE);
    return (Status);

}


NTSTATUS
SCClockGetTime(
               IN PIRP Irp,
               IN PKSPROPERTY Property,
               IN OUT PULONGLONG StreamTime
)
{
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    PCLOCK_INSTANCE ClockInstance =
    (PCLOCK_INSTANCE) IrpStack->FileObject->FsContext;
    PSTREAM_OBJECT  StreamObject = ClockInstance->ParentFileObject->FsContext;

    PAGED_CODE();

    if (StreamObject->HwStreamObject.HwClockObject.ClockSupportFlags &
        CLOCK_SUPPORT_CAN_RETURN_STREAM_TIME) {

        *StreamTime = SCGetStreamTime(IrpStack->FileObject);

        Irp->IoStatus.Information = sizeof(ULONGLONG);

        return STATUS_SUCCESS;

    } else {

        return (STATUS_NOT_SUPPORTED);

    }
}


NTSTATUS
SCClockGetPhysicalTime(
                       IN PIRP Irp,
                       IN PKSPROPERTY Property,
                       IN OUT PULONGLONG PhysicalTime
)
{
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    PCLOCK_INSTANCE ClockInstance =
    (PCLOCK_INSTANCE) IrpStack->FileObject->FsContext;
    PSTREAM_OBJECT  StreamObject = ClockInstance->ParentFileObject->FsContext;

    PAGED_CODE();

    if (StreamObject->HwStreamObject.HwClockObject.ClockSupportFlags &
        CLOCK_SUPPORT_CAN_READ_ONBOARD_CLOCK) {

        *PhysicalTime = SCGetPhysicalTime(IrpStack->FileObject->FsContext);

        Irp->IoStatus.Information = sizeof(ULONGLONG);

        return (STATUS_SUCCESS);

    } else {

        return (STATUS_NOT_SUPPORTED);

    }
}


NTSTATUS
SCClockGetSynchronizedTime(
                           IN PIRP Irp,
                           IN PKSPROPERTY Property,
                           IN OUT PKSCORRELATED_TIME SyncTime
)
{
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    PCLOCK_INSTANCE ClockInstance =
    (PCLOCK_INSTANCE) IrpStack->FileObject->FsContext;
    PSTREAM_OBJECT  StreamObject = ClockInstance->ParentFileObject->FsContext;

    PAGED_CODE();

    if (StreamObject->HwStreamObject.HwClockObject.ClockSupportFlags &
        CLOCK_SUPPORT_CAN_RETURN_STREAM_TIME) {

        SyncTime->Time = SCGetSynchronizedTime(IrpStack->FileObject,
                                               &SyncTime->SystemTime);

        Irp->IoStatus.Information = sizeof(KSCORRELATED_TIME);

        return (STATUS_SUCCESS);

    } else {

        return (STATUS_NOT_SUPPORTED);

    }
}

NTSTATUS
SCClockGetFunctionTable(
                        IN PIRP Irp,
                        IN PKSPROPERTY Property,
                        IN OUT PKSCLOCK_FUNCTIONTABLE FunctionTable
)
{
    PCLOCK_INSTANCE ClockInstance;
    PIO_STACK_LOCATION IrpStack;
    PSTREAM_OBJECT  StreamObject;

    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    ClockInstance = (PCLOCK_INSTANCE) IrpStack->FileObject->FsContext;
    StreamObject = ClockInstance->ParentFileObject->FsContext;

    RtlZeroMemory(FunctionTable, sizeof(KSCLOCK_FUNCTIONTABLE));

    if (StreamObject->HwStreamObject.HwClockObject.ClockSupportFlags &
        CLOCK_SUPPORT_CAN_RETURN_STREAM_TIME) {

        FunctionTable->GetTime = (PFNKSCLOCK_GETTIME) SCGetStreamTime;
        FunctionTable->GetCorrelatedTime = (PFNKSCLOCK_CORRELATEDTIME) SCGetSynchronizedTime;

    }
    if (StreamObject->HwStreamObject.HwClockObject.ClockSupportFlags &
        CLOCK_SUPPORT_CAN_READ_ONBOARD_CLOCK) {

        FunctionTable->GetPhysicalTime = (PFNKSCLOCK_GETTIME) SCGetPhysicalTime;
    }
    Irp->IoStatus.Information = sizeof(KSCLOCK_FUNCTIONTABLE);
    return STATUS_SUCCESS;
}


NTSTATUS
ClockDispatchClose
(
 IN PDEVICE_OBJECT DeviceObject,
 IN PIRP Irp
)
/*++

Routine Description:

    This routine receives CLOSE IRP's for a stream

Arguments:
    DeviceObject - device object for the device
    Irp - probably an IRP, silly

Return Value:

    The IRP status is set as appropriate

--*/

{
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    NTSTATUS        Status;
    BOOLEAN         RequestIssued;
    PCLOCK_INSTANCE ClockInstance = (PCLOCK_INSTANCE)
    IrpStack->FileObject->FsContext;
    PSTREAM_OBJECT  StreamObject = ClockInstance->StreamObject;

    PAGED_CODE();

    InterlockedIncrement(&DeviceExtension->OneBasedIoCount);

    //
    // call the minidriver to indicate that there is no master clock.
    // processing will continue when the callback procedure is called.
    //

    Status = SCSubmitRequest(SRB_CLOSE_MASTER_CLOCK,
                             NULL,
                             0,
                             SCCloseClockCallback,
                             DeviceExtension,
                          StreamObject->FilterInstance->HwInstanceExtension,
                             &StreamObject->HwStreamObject,
                             Irp,
                             &RequestIssued,
                             &StreamObject->ControlPendingQueue,
                             (PVOID) StreamObject->HwStreamObject.
                             ReceiveControlPacket
        );

    if (!RequestIssued) {
        DEBUG_BREAKPOINT();
        SCCompleteIrp(Irp, Status, DeviceExtension);
    }
    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    return (Status);

}


NTSTATUS
SCCloseClockCallback(
                     IN PSTREAM_REQUEST_BLOCK SRB
)
/*++

Routine Description:

     Process the completion of a stream close.

Arguments:

     SRB - address of the completed SRB

Return Value:

     None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;
    PSTREAM_OBJECT  StreamObject = CONTAINING_RECORD(
                                                     SRB->HwSRB.StreamObject,
                                                     STREAM_OBJECT,
                                                     HwStreamObject
    );
    PIRP            Irp = SRB->HwSRB.Irp;
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS        Status = SRB->HwSRB.Status;
    PCLOCK_INSTANCE ClockInstance;

    PAGED_CODE();

    // log 'cMC ', StreamObject, ClockInstance, Status )
    SCLOG( ' CMc', StreamObject, IrpStack->FileObject->FsContext, Status );

    if (NT_SUCCESS(Status)) {

        //
        // free the clock instance structure and the object header
        //

        ClockInstance =
            (PCLOCK_INSTANCE) IrpStack->FileObject->FsContext;

        KsFreeObjectHeader(ClockInstance->DeviceHeader);

        ExFreePool(ClockInstance);
        StreamObject->ClockInstance = NULL;

        //
        // dereference the pin handle
        //

        ObDereferenceObject(IrpStack->FileObject->RelatedFileObject);

    }                           // if good status
    SCProcessCompletedRequest(SRB);
    return (Status);

}


NTSTATUS
SCFilterTopologyHandler(
                        IN PIRP Irp,
                        IN PKSPROPERTY Property,
                        IN OUT PVOID Data)
/*++

Routine Description:

    Dispatches a pin property request

Arguments:

         Irp - pointer to the irp
         Property - pointer to the property info
         Data - property specific buffer

Return Value:

    NTSTATUS returned as appropriate

--*/

{
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) IrpStack->
    DeviceObject->DeviceExtension;

    PAGED_CODE();

    IFN_MF(
        return KsTopologyPropertyHandler(Irp,
                                     Property,
                                     Data,
                    DeviceExtension->StreamDescriptor->StreamHeader.Topology
        );
    )
    IF_MFS(
        PFILTER_INSTANCE FilterInstance;

        FilterInstance = (PFILTER_INSTANCE) IrpStack->FileObject->FsContext;
        
        return KsTopologyPropertyHandler(
                    Irp,
                    Property,
                    Data,
                    FilterInstance->StreamDescriptor->StreamHeader.Topology);
    )
}



NTSTATUS
SCFilterPinIntersectionHandler(
                               IN PIRP Irp,
                               IN PKSP_PIN Pin,
                               OUT PVOID Data
)
/*++

Routine Description:

    Handles the KSPROPERTY_PIN_DATAINTERSECTION property in the Pin property set.
    Returns the first acceptable data format given a list of data ranges for a specified
    Pin factory. Actually just calls the Intersection Enumeration helper, which then
    calls the IntersectHandler callback with each data range.

Arguments:

    Irp -
        Device control Irp.

    Pin -
        Specific property request followed by Pin factory identifier, followed by a
        KSMULTIPLE_ITEM structure. This is followed by zero or more data range structures.

    Data -
        The place in which to return the data format selected as the first intersection
        between the list of data ranges passed, and the acceptable formats.

Return Values:

    returns STATUS_SUCCESS or STATUS_NO_MATCH, else STATUS_INVALID_PARAMETER,
    STATUS_BUFFER_TOO_SMALL, or STATUS_INVALID_BUFFER_SIZE.

--*/
{
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) IrpStack->
    DeviceObject->DeviceExtension;

    PAGED_CODE();

    IFN_MF(
        return KsPinDataIntersection(
                                 Irp,
                                 Pin,
                                 Data,
                                 DeviceExtension->NumberOfPins,
                                 DeviceExtension->PinInformation,
                                 SCIntersectHandler);
    )
    IF_MFS(
        PSTREAM_OBJECT StreamObject;
        PFILTER_INSTANCE FilterInstance;

        FilterInstance = (PFILTER_INSTANCE) IrpStack->FileObject->FsContext;
        
        DebugPrint((DebugLevelVerbose, 
                   "PinIntersection FilterInstance=%p\n", FilterInstance ));
                   
        return KsPinDataIntersection(
                                 Irp,
                                 Pin,
                                 Data,
                                 FilterInstance->NumberOfPins,
                                 FilterInstance->PinInformation,
                                 SCIntersectHandler);
    )    
}

NTSTATUS
SCIntersectHandler(
                   IN PIRP Irp,
                   IN PKSP_PIN Pin,
                   IN PKSDATARANGE DataRange,
                   OUT PVOID Data
)
/*++

Routine Description:

    This is the data range callback for KsPinDataIntersection, which is called by
    FilterPinIntersection to enumerate the given list of data ranges, looking for
    an acceptable match. If a data range is acceptable, a data format is copied
    into the return buffer. If there is a wave format selected in a current pin
    connection, and it is contained within the data range passed in, it is chosen
    as the data format to return. A STATUS_NO_MATCH continues the enumeration.

Arguments:

    Irp -
        Device control Irp.

    Pin -
        Specific property request followed by Pin factory identifier, followed by a
        KSMULTIPLE_ITEM structure. This is followed by zero or more data range structures.
        This enumeration callback does not need to look at any of this though. It need
        only look at the specific pin identifier.

    DataRange -
        Contains a specific data range to validate.

    Data -
        The place in which to return the data format selected as the first intersection
        between the list of data ranges passed, and the acceptable formats.

Return Values:

    returns STATUS_SUCCESS or STATUS_NO_MATCH, else STATUS_INVALID_PARAMETER,
    STATUS_BUFFER_TOO_SMALL, or STATUS_INVALID_BUFFER_SIZE.

--*/
{
    PIO_STACK_LOCATION IrpStack;
    NTSTATUS        Status;
    PFILTER_INSTANCE FilterInstance;
    STREAM_DATA_INTERSECT_INFO IntersectInfo;
    PDEVICE_EXTENSION DeviceExtension;
    BOOLEAN         RequestIssued;

    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    FilterInstance = (PFILTER_INSTANCE) IrpStack->FileObject->FsContext;
    DeviceExtension = (PDEVICE_EXTENSION)
        IrpStack->DeviceObject->DeviceExtension;

    ASSERT_FILTER_INSTANCE( FilterInstance );
    ASSERT_DEVICE_EXTENSION( DeviceExtension );

    //
    // fill in the intersect info struct from the input params.
    //

    IntersectInfo.DataRange = DataRange;
    IntersectInfo.DataFormatBuffer = Data;
    IntersectInfo.SizeOfDataFormatBuffer =
        IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    IntersectInfo.StreamNumber = Pin->PinId;

    //
    // call the minidriver to process the intersection.  processing will
    // continue
    // when the callback procedure is called.  take the event to ensure that
    // pins don't come and go as we process the intersection.
    //

    KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                          Executive,
                          KernelMode,
                          FALSE,// not alertable
                          NULL);

    Status = SCSubmitRequest(SRB_GET_DATA_INTERSECTION,
                             &IntersectInfo,
                             0,
                             SCDataIntersectionCallback,
                             DeviceExtension,
                             FilterInstance->HwInstanceExtension,
                             NULL,
                             Irp,
                             &RequestIssued,
                             &DeviceExtension->PendingQueue,
                             (PVOID) DeviceExtension->
                             MinidriverData->HwInitData.
                             HwReceivePacket);

    if (!RequestIssued) {
        DEBUG_BREAKPOINT();
        KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
    }
    return Status;
}


NTSTATUS
SCDataIntersectionCallback(
                           IN PSTREAM_REQUEST_BLOCK SRB
)
/*++

Routine Description:

     Process the completion of a data intersection query.

Arguments:

     SRB - address of the completed SRB

Return Value:

     None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension =
    (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;
    PIRP            Irp = SRB->HwSRB.Irp;
    NTSTATUS        Status = SRB->HwSRB.Status;

    PAGED_CODE();

    Irp->IoStatus.Information = SRB->HwSRB.ActualBytesTransferred;

    //
    // signal the event
    //

    KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

    SCDequeueAndDeleteSrb(SRB);
    return (Status);

}

NTSTATUS
SCGetStreamHeaderSize(
                      IN PIRP Irp,
                      IN PKSPROPERTY Property,
                      IN OUT PULONG StreamHeaderSize
)
/*++

Routine Description:

     Process the get stream header extension property

Arguments:

Return Value:

     None.

--*/
{
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    PSTREAM_OBJECT  StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->FsContext;

    PAGED_CODE();

    ASSERT(StreamObject);

    *StreamHeaderSize = StreamObject->HwStreamObject.StreamHeaderMediaSpecific;

    Irp->IoStatus.Information = sizeof(ULONG);
    return (STATUS_SUCCESS);

}

NTSTATUS
DllUnload(
          VOID
)
{
    NTSTATUS Status=STATUS_SUCCESS;
    
    #if DBG
    NTSTATUS DbgDllUnload();
    DebugPrint((1, "Stream Class DllUnload: Unloading\n"));
    Status = DbgDllUnload();
    #endif 

    return Status;
}
#ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
NTSTATUS
SCStreamAllocator(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PHANDLE AllocatorHandle
    )

/*++

Routine Description:
    If KSPROPERTY_TYPE_SET, this function sets the stream allocator
    for this connection by referencing the file handle to obtain
    the file object pointer and stores this pointer in the filter(stream?)
    instance structure.

    Otherwise, a KSPROPERTY_TYPE_GET request returns a NULL handle
    and STATUS_SUCCESS to show that we support allocator creation.

Arguments:
    IN PIRP Irp -
        pointer to the I/O request packet

    IN PKSPROPERTY Property -
        pointer to the property structure

    IN OUT PHANDLE AllocatorHandle -
        pointer to the handle representing the file object

Return:
    STATUS_SUCCESS or an appropriate error code

--*/

{
    NTSTATUS                Status;
    PIO_STACK_LOCATION      IrpStack;
    PSTREAM_OBJECT          StreamObject;
    PDEVICE_EXTENSION       DeviceExtension;

    IrpStack = IoGetCurrentIrpStackLocation( Irp );

    StreamObject = IrpStack->FileObject->FsContext;

    DebugPrint((DebugLevelTrace, "STREAM:entering SCStreamAllocator:Stream:%x\n",StreamObject));
    if (Property->Flags & KSPROPERTY_TYPE_GET) {
        //
        // This is a query to see if we support the creation of
        // allocators.  The returned handle is always NULL, but we
        // signal that we support the creation of allocators by
        // returning STATUS_SUCCESS.
        //
        *AllocatorHandle = NULL;
        Status = STATUS_SUCCESS;
        DebugPrint((DebugLevelTrace,"SCStreamAllocator-GET"));
    } else {
        PFILTER_INSTANCE    FilterInstance;

        FilterInstance =
            (PFILTER_INSTANCE) StreamObject->FilterFileObject->FsContext;

        DeviceExtension = StreamObject->DeviceExtension;

        DebugPrint((DebugLevelTrace,"SCStreamAllocator-SET"));
        KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                          Executive,
                          KernelMode,
                          FALSE,// not alertable
                          NULL);

        //
        // The allocator can only be specified when the device is
        // in KSSTATE_STOP.
        //

        if (StreamObject->CurrentState != KSSTATE_STOP) {
            KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
            DebugPrint((DebugLevelTrace,"SCStreamAllocator-device not in STOP"));
            return STATUS_INVALID_DEVICE_STATE;
        }

// if we are in _STOP, the flush was already done.
// this call may have to be enabled.
//
//        StreamFlushIo(DeviceExtension, StreamObject);

        //
        // Release the previous allocator, if any.
        //
        if (StreamObject->AllocatorFileObject) {
            ObDereferenceObject( StreamObject->AllocatorFileObject );
            StreamObject->AllocatorFileObject = NULL;
        }

        //
        // Reference this handle and store the resultant pointer
        // in the filter instance.  Note that the default allocator
        // does not ObReferenceObject() for its parent
        // (which would be the pin handle).  If it did reference
        // the pin handle, we could never close this pin as there
        // would always be a reference to the pin file object held
        // by the allocator and the pin object has a reference to the
        // allocator file object.
        //
        if (*AllocatorHandle != NULL) {
            Status =
                ObReferenceObjectByHandle(
                    *AllocatorHandle,
                    FILE_READ_DATA | SYNCHRONIZE,
                    *IoFileObjectType,
                    ExGetPreviousMode(),
                    &StreamObject->AllocatorFileObject,
                    NULL );
        DebugPrint((DebugLevelTrace, "SCStreamAllocator: got %x as Allocator file object\n",StreamObject->AllocatorFileObject));
        } else {
            Status = STATUS_SUCCESS;
        }
        KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
    }

    DebugPrint((DebugLevelTrace,"exiting SCStreamAllocator-normal path\n"));
    return Status;
}

//---------------------------------------------------------------------------
BOOLEAN
HeaderTransfer(
    IN PFILTER_INSTANCE FilterInstance,
    IN PSTREAM_OBJECT StreamObject,
    IN PFILE_OBJECT   DestinationFileObject,
    IN OUT PSTREAM_HEADER_EX *StreamHeader
    )

/*++

Routine Description:
    Sets up the stream header for a no-copy transfer to the
    opposite pin.

Arguments:
    IN PFILTER_INSTANCE FilterInstance -
        pointer to the filter instance

    IN PSTREAM_OBJECT StreamObject -
        pointer to the transform instance structure

    IN PSTREAM_OBJECT DestinationInstance -
        pointer to the opposite transform instance structure

    IN OUT PSTREAM_HEADER_EX *StreamHeader -
        pointer containing a pointer to the current stream header,
        this member is updated with a pointer to the next stream
        header to submit to the opposite pin or NULL if there is
        no header to submit.

Return:
    An indication of whether stop can proceed now or not

Comments:
    Not pageable, uses SpinLocks.
    
--*/

{
    KIRQL               irqlQueue, irqlFree;
    ULONG WhichQueue = (*StreamHeader)->WhichQueue;    
    ULONG OppositeQueue = WhichQueue ^ 0x00000001; // 1 to 0, 0 to 1   
    BOOLEAN SignalStop = FALSE;
    
    ASSERT(DestinationFileObject);
    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );
    
    if (StreamObject->PinState > PinStopPending) { // if normal running case

        //
        // If we are here after submitting an ENDOFSTREAM Irp to the 
        // outflow pin, then we have already read the end of stream 
        // from the input and there is no need to continue I/O.
        //    
    
        if (DestinationFileObject) {
            ULONG HeaderFlags = (*StreamHeader)->Header.OptionsFlags;

            //
            // Clear the options flags so that we continue
            // reading from where we left off.  
            //
            
//            (*StreamHeader)->Header.OptionsFlags = 0;
        
            //
            // Reset the stream segment valid data length
            //
//            (*StreamHeader)->Header.DataUsed = 0;
//            (*StreamHeader)->Header.Duration = 0;
                
            //
            // Check for the end of the stream.
            //
            if ((HeaderFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM) ||
                StreamObject->EndOfStream) {
                
                DebugPrint((DebugLevelTrace,
                    "end of stream") );
                
                //
                // Make sure that this is set for the next time through.
                //
                StreamObject->EndOfStream = TRUE;


                if (!(*StreamHeader)->ReferenceCount) {
                    
                    //
                    // Put the header back on the free list of the inflow pin.
                    //
                    
                    KeAcquireSpinLock( &StreamObject->FreeQueueLock, &irqlFree );
#if (DBG)
                    if ((*StreamHeader)->OnFreeList) {
                        DebugPrint((DebugLevelTrace,
                            "stream header already on free list.") );
                    }
#endif
                    DebugPrint((DebugLevelTrace,
                        "EOS adding %x to free queue", *StreamHeader) );

                    InsertTailList( 
                        &StreamObject->FreeQueue, 
                        &(*StreamHeader)->ListEntry );

                    if (!InterlockedDecrement (
                        &StreamObject -> QueuedFramesPlusOne
                        ))
                        SignalStop = TRUE;

#if (DBG)
                    (*StreamHeader)->OnFreeList = TRUE;
                    if ((*StreamHeader)->OnActiveList) {
                        DebugPrint((DebugLevelTrace,
                            "stream header on both lists.") );
                    }
#endif
                    KeReleaseSpinLock( &StreamObject->FreeQueueLock, irqlFree );        
                }                        
                
                //
                // No more I/O to opposite pin.
                //
                *StreamHeader = NULL;
            }
        }
    
        //
        // Grab the spin lock for the other queue, insert this
        // stream header on the queue.
        //
        
        if (*StreamHeader) {
            KeAcquireSpinLock( &StreamObject->Queues[OppositeQueue].QueueLock, &irqlQueue );

#if (DBG)
            if ((*StreamHeader)->OnActiveList) {
                DebugPrint((DebugLevelTrace,
                    "stream header already on active list.") );
            }
#endif

            InsertTailList(
                &StreamObject->Queues[OppositeQueue].ActiveQueue,
                &(*StreamHeader)->ListEntry );
#if (DBG)
            (*StreamHeader)->OnActiveList = TRUE;

            if ((*StreamHeader)->OnFreeList) {
                DebugPrint((DebugLevelTrace,
                    "stream header on both lists.") );
            }
#endif
            KeReleaseSpinLock( &StreamObject->Queues[OppositeQueue].QueueLock, irqlQueue );        
        }
        
    } 
    else                           // pin stop IS pending 
    {
        //
        // Location of frames (for this type of transfer, all frames
        // are held on the source pin).
        //
        
        if (!(*StreamHeader)->ReferenceCount) {
    
            DebugPrint((DebugLevelTrace,
                "stop: adding %x to free queue.", *StreamHeader) );
    
            KeAcquireSpinLock( &StreamObject->FreeQueueLock, &irqlFree );
#if (DBG)
            if ((*StreamHeader)->OnFreeList) {
                DebugPrint((DebugLevelTrace,
                    "stream header already on free list.") );
            }
#endif
            InsertTailList( 
                &StreamObject->FreeQueue, &(*StreamHeader)->ListEntry );

            if (!InterlockedDecrement (&StreamObject -> QueuedFramesPlusOne)) 
                SignalStop = TRUE;
#if (DBG)
            (*StreamHeader)->OnFreeList = TRUE;
            if ((*StreamHeader)->OnActiveList) {
                DebugPrint((DebugLevelTrace,
                    "stream header on both lists.") );
            }
#endif
            KeReleaseSpinLock( &StreamObject->FreeQueueLock, irqlFree );        
        }
    
        //
        // No I/O to opposite pin this round.
        //

        *StreamHeader = NULL;

    }

    return SignalStop;

}
//---------------------------------------------------------------------------
VOID
IoWorker(
    PVOID Context,
    ULONG WhichQueue
    )

/*++

Routine Description:
    This is the work item for the source pins.  Walks the queue
    associated with the stream header looking for sequentially 
    completed headers and submits those headers to the opposite
    pin.

Arguments:
    PVOID Context -
        pointer to the stream header 

Return:
    Nothing.
    
Comments:
    Not pageable, uses SpinLocks.
    
--*/

{
    KIRQL               irqlOld;
    PFILTER_INSTANCE    FilterInstance;
    PADDITIONAL_PIN_INFO AdditionalInfo;
    PLIST_ENTRY         Node;
    PSTREAM_OBJECT      StreamObject;
    PFILE_OBJECT        DestinationFileObject;
    PSTREAM_HEADER_EX   StreamHeader;
    NTSTATUS            Status;
    ULONG               Operation;
    PDEVICE_EXTENSION   DeviceExtension;
    BOOLEAN             SignalStop = FALSE;
    
    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

    StreamObject =  (PSTREAM_OBJECT) Context;

    DeviceExtension = StreamObject->DeviceExtension;

#if (DBG)
    DebugPrint((DebugLevelTrace,
        "entering IoWorker:Source StreamObject:%x\n",StreamObject));
#endif
    FilterInstance = 
        (PFILTER_INSTANCE)
            StreamObject->FilterFileObject->FsContext;

    if (!FilterInstance) {
        //
        // For some reason, the filter instance has gone missing.
        //
        DebugPrint((DebugLevelTrace,
            "error: FilterInstance has gone missing.\n") );
        return;
    }

    AdditionalInfo = FilterInstance->PinInstanceInfo;

    //
    // Synchronize with control changes and protect from reentrancy.
    //    

    KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                          Executive,
                          KernelMode,
                          FALSE,// not alertable
                          NULL);
     
    //
    // Synchronize with queues.
    //

    KeAcquireSpinLock( &StreamObject->Queues[WhichQueue].QueueLock, &irqlOld );
    
    //
    // Loop while there are completed items on the queue.
    //     
    
    while (!IsListEmpty( &StreamObject->Queues[WhichQueue].ActiveQueue )) {
        Node = StreamObject->Queues[WhichQueue].ActiveQueue.Flink;
        
        StreamHeader = 
            CONTAINING_RECORD( 
                Node,
                STREAM_HEADER_EX,
                ListEntry );
        
#if (DBG)
            DebugPrint((DebugLevelTrace,
                "got StreamHeader:%08x\n", StreamHeader ));
#endif
        if (StreamHeader->ReferenceCount) {

            DebugPrint((DebugLevelTrace,
                "breaking StreamHeader:%08x\n", StreamHeader ));

            break;
        } else {
            //
            // Remove this header from the current queue.
            //
            
            RemoveHeadList( &StreamObject->Queues[WhichQueue].ActiveQueue );
#if (DBG)
            StreamHeader->OnActiveList = FALSE;
#endif
            KeReleaseSpinLock( &StreamObject->Queues[WhichQueue].QueueLock, irqlOld );
            
            //
            // Wait for the APC to complete.  Note that if an error was
            // returned, the I/O status block is not updated and the
            // event is not signalled.
            //
            
            DebugPrint((DebugLevelTrace,
                "waiting for StreamHeader (%08x) to complete\n",  StreamHeader ));
        
            KeWaitForSingleObject(
                &StreamHeader->CompletionEvent,
                Executive,
                KernelMode,
                FALSE,
                NULL);

            DebugPrint((DebugLevelTrace,
                "StreamHeader (%08x) completed\n",  StreamHeader));
        
            DestinationFileObject = 
                StreamHeader->NextFileObject;

            //
            // At the time this returns TRUE, the loop will be finished.
            //
            SignalStop = HeaderTransfer(
                FilterInstance,
                StreamObject, 
                DestinationFileObject,
                &StreamHeader );
        

            if (StreamHeader)
            {    
                DebugPrint((DebugLevelTrace, "IoWorker issuing: "));

                if (DestinationFileObject == StreamObject->NextFileObject)
                {
                    DebugPrint((DebugLevelTrace,"KSSTREAM_WRITE:dest=%x\n",DestinationFileObject));

                    Operation = KSSTREAM_WRITE;

                    StreamHeader->NextFileObject =
                        StreamObject->FileObject;

					#if (DBG)
                    if (StreamHeader->Id == 7)
                        DebugPrint((DebugLevelVerbose,"iw%x\n",StreamHeader->Id));
                    else
                        DebugPrint((DebugLevelVerbose,"iw%x",StreamHeader->Id));
					#endif

                }
                else
                {
                    DebugPrint((DebugLevelTrace,"KSSTREAM_READ:dest=%x\n",DestinationFileObject));
                    Operation = KSSTREAM_READ;
                    StreamHeader->Header.OptionsFlags = 0;
                    //
                    // Reset the stream segment valid data length
                    //
                    StreamHeader->Header.DataUsed = 0;
                    StreamHeader->Header.Duration = 0;

                    StreamHeader->NextFileObject = StreamObject->NextFileObject;
					#if (DBG)
                    if (StreamHeader->Id == 7)
                        DebugPrint((DebugLevelVerbose,"ir%x\n",StreamHeader->Id));
                    else
                        DebugPrint((DebugLevelVerbose,"ir%x",StreamHeader->Id));
					#endif
                }

                InterlockedIncrement( &StreamHeader->ReferenceCount );

                StreamHeader->WhichQueue = WhichQueue ^ 0x00000001;

                Status =    
                    KsStreamIo(
                        DestinationFileObject,
                        &StreamHeader->CompletionEvent, // Event
                        NULL,                           // PortContext
                        IoCompletionRoutine,
                        StreamHeader,                   // CompletionContext
                        KsInvokeOnSuccess |
                            KsInvokeOnCancel |
                            KsInvokeOnError,
                        &StreamHeader->IoStatus,
                        &StreamHeader->Header,
                        StreamHeader->Header.Size,
                        KSSTREAM_SYNCHRONOUS | Operation,
                        KernelMode );
                
                if (Status != STATUS_PENDING) {
                    //
                    // If this I/O completes immediately (failure or not), the
                    // event is not signalled.
                    //
                    KeSetEvent( &StreamHeader->CompletionEvent, IO_NO_INCREMENT, FALSE );
                }
            }
            KeAcquireSpinLock( &StreamObject->Queues[WhichQueue].QueueLock, &irqlOld );
        }
    //
    // Ok to schedule another work item now.
    //
    } // end while
    
    InterlockedExchange( &StreamObject->Queues[WhichQueue].WorkItemQueued, FALSE );

    // 
    // If a stop needs to be signalled, signal it.
    //    
    if (SignalStop) { 
        KeSetEvent( &StreamObject->StopEvent,
                    IO_NO_INCREMENT,
                    FALSE );
    }

    KeReleaseSpinLock( &StreamObject->Queues[WhichQueue].QueueLock, irqlOld );
    
    //
    // Release the control event
    //
    
    KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

    DebugPrint((DebugLevelTrace,"exiting IoWorker\n"));
}
//---------------------------------------------------------------------------
/*++

Routine Description:
    These are the work items for the source and destination pins.  
    Calls the IoWorker code above, passing in READ or WRITE header
    queue information. 

Arguments:
    PVOID Context -
        pointer to the stream header 

Return:
    Nothing.
    
Comments:
    
--*/

VOID
IoWorkerRead(
    PVOID Context
    )
{
    IoWorker(Context,READ);
}

VOID
IoWorkerWrite(
    PVOID Context
    )
{
    IoWorker(Context,WRITE);
}
//---------------------------------------------------------------------------
NTSTATUS
IoCompletionRoutine(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    )

/*++

Routine Description:
    Processes the completion of the given Irp by marking the
    associated stream header as completed and scheduling a
    worker item to complete processing if necessary.

Arguments:
    PDEVICE_OBJECT DeviceObject -
        pointer to the device object

    PIRP Irp -
        pointer to the I/O request packet

    PVOID Context -
        a context pointer (pointer to the associated stream header)
        

Return:
    The IoStatus.Status member of the Irp.

Comments:
    Not pageable, uses SpinLocks and may be called at DISPATCH_LEVEL.
    
--*/

{
    KIRQL               irqlOld;
    PSTREAM_HEADER_EX   StreamHeader = Context;
    PFILTER_INSTANCE    FilterInstance;
    PSTREAM_OBJECT      StreamObject;
    ULONG WhichQueue;
    
#if (DBG)
     ASSERT( StreamHeader->Data == StreamHeader->Header.Data );
#endif                                        
                        
    StreamObject = 
        (PSTREAM_OBJECT) StreamHeader->OwnerFileObject->FsContext;

    DebugPrint((DebugLevelTrace,
        "IoCompletionRoutine:StreamHeader %08x, StreamObject %08x\n",StreamHeader,StreamObject));

    FilterInstance = 
        (PFILTER_INSTANCE) 
            StreamHeader->OwnerFileObject->RelatedFileObject->FsContext;
        
        
    WhichQueue = StreamHeader->WhichQueue;
    KeAcquireSpinLock( &StreamObject->Queues[WhichQueue].QueueLock, &irqlOld );
    
    //
    // Remove this reference count on the IRP so that we can continue
    // the loop if this work item is not the head item of the list.
    //

    InterlockedDecrement( &StreamHeader->ReferenceCount );
    
    //
    // Copy the status block so that we don't have to wait for the APC.
    //
    StreamHeader->IoStatus = Irp->IoStatus;

    //
    // Sweep the active queue in the worker to complete the transfer.
    //
    if (!StreamObject->Queues[WhichQueue].WorkItemQueued) {
        //
        // A work item is not pending, initialize the worker item
        // for the new context and queue it.
        //

        ExInitializeWorkItem( 
            &StreamObject->Queues[WhichQueue].WorkItem,
            (WhichQueue == READ) ? IoWorkerRead : IoWorkerWrite,
            StreamObject );
    
        InterlockedExchange( &StreamObject->Queues[WhichQueue].WorkItemQueued, TRUE );
        
        KsQueueWorkItem( 
            (WhichQueue == READ) ? FilterInstance->WorkerRead :
            FilterInstance->WorkerWrite,
            &StreamObject->Queues[WhichQueue].WorkItem );
    }
    
    KeReleaseSpinLock( &StreamObject->Queues[WhichQueue].QueueLock, irqlOld );
    
    
    DebugPrint((DebugLevelTrace,
        "exiting IoCompletionRoutine:Irp->IoStatus.Status:%x\n",Irp->IoStatus.Status));

    return Irp->IoStatus.Status;
}
//---------------------------------------------------------------------------
NTSTATUS
PrepareTransfer(
    IN PFILTER_INSTANCE FilterInstance,
    IN PSTREAM_OBJECT StreamObject
    )

/*++

Routine Description:
    Prepares for the data transfer by distributing the assigned allocators
    for the source and destination pins.

Arguments:
    IN PFILTER_INSTANCE FilterInstance,
        pointer to the filter instance
        
    IN PSTREAM_OBJECT StreamObject -
        pointer to the transform instance
        
Return:
    STATUS_SUCCESS or an appropriate error code.

--*/

{
    KSPROPERTY                  Property;
    KSSTREAMALLOCATOR_STATUS    AllocatorStatus;
    NTSTATUS                    Status;
    PSTREAM_HEADER_EX           StreamHeader;
    ULONG                       i, Returned;
    PADDITIONAL_PIN_INFO AdditionalInfo;
    
    //
    // If the PinState is not PinStopped, then return.
    //
    
    DebugPrint((DebugLevelTrace,"entering PrepareTransfer\n"));
    
    if (!StreamObject->AllocatorFileObject) {
        DebugPrint((DebugLevelTrace,"!! AllocatorFileObject is NULL"));
        return STATUS_SUCCESS;
    }
    if (StreamObject->PinState != PinStopped) {
        //
        // We only need to do this work when the pin has been 
        // completely stopped.  If we were running, just reflect the
        // state.
        //
        DebugPrint((DebugLevelTrace,"PrepareTransfer exiting, PinState != PinStopped\n"));
        StreamObject->PinState = PinPrepared;    
        return STATUS_SUCCESS;
    }

    AdditionalInfo = FilterInstance->PinInstanceInfo;

    //
    // Retrieve the allocator framing information for the pin.
    //    
    
    Property.Set = KSPROPSETID_StreamAllocator;
    Property.Id = KSPROPERTY_STREAMALLOCATOR_STATUS;
    Property.Flags = KSPROPERTY_TYPE_GET;
    
    Status = 
        KsSynchronousIoControlDevice(
            StreamObject->AllocatorFileObject,
            KernelMode,
            IOCTL_KS_PROPERTY,
            &Property,
            sizeof( Property ),
            &AllocatorStatus,
            sizeof( AllocatorStatus ),
            &Returned );
    
    if (!NT_SUCCESS( Status )) 
    {
        DebugPrint((DebugLevelTrace,
            "PrepareTransfer exiting, unable to retrieve allocator status\n"));
        return Status;        
    }        
    
    //
    // Save the framing information
    //    

    StreamObject->Framing = AllocatorStatus.Framing;    
            
    //
    // Allocate the frames from the allocator
    //
    // 1. Always allocate frames when starting the IrpSource.
    //
    // 2. If the allocator is not shared, then allocate the frames when
    //    the (each) destination pin is started.
    //
    
    if (StreamObject->PinType == IrpSource) {

        InterlockedExchange (&StreamObject -> QueuedFramesPlusOne, 1);

#if (DBG)
       DebugPrint((DebugLevelTrace,"Framing.Frames:%x\n", StreamObject->Framing.Frames));
       DebugPrint((DebugLevelTrace,"Framing.FrameSize:%x\n", StreamObject->Framing.FrameSize));
#endif
        for (i = 0; i < StreamObject->Framing.Frames; i++) {
			DebugPrint((DebugLevelTrace,"StreamObject->ExtendedHeaderSize:%x\n", StreamObject->HwStreamObject.StreamHeaderMediaSpecific));

            StreamHeader = 
                ExAllocatePoolWithTag( 
                    NonPagedPool, 
                    sizeof( STREAM_HEADER_EX ) +
                        StreamObject->HwStreamObject.StreamHeaderMediaSpecific,
                    STREAMCLASS_TAG_STREAMHEADER );
                                
            if (NULL == StreamHeader) {
                DebugPrint((DebugLevelTrace,
                    "out of pool while allocating frames\n") );
                Status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                
                RtlZeroMemory( 
                    StreamHeader, 
                    sizeof( STREAM_HEADER_EX ) +
                        StreamObject->HwStreamObject.StreamHeaderMediaSpecific);

                KeInitializeEvent( 
                    &StreamHeader->CompletionEvent, 
                    SynchronizationEvent, 
                    FALSE );

                StreamHeader->Header.Size =
                    sizeof( KSSTREAM_HEADER ) +
                        StreamObject->HwStreamObject.StreamHeaderMediaSpecific;
                        
                if (StreamObject->HwStreamObject.StreamHeaderMediaSpecific) {                        
                    *(PULONG)((&StreamHeader->Header) + 1) =
                        StreamObject->HwStreamObject.StreamHeaderMediaSpecific;
                }                        
                
                Status = 
                    AllocateFrame( 
                        StreamObject->AllocatorFileObject, 
                        &StreamHeader->Header.Data );
#if (DBG)                        
                //
                // Track who is stomping on the headers...
                //        
                StreamHeader->Data = StreamHeader->Header.Data;        
#endif                

                StreamHeader->WhichQueue = READ;

                StreamHeader->Id = i;
                
                if (!NT_SUCCESS( Status )) {
                    DebugPrint((DebugLevelTrace,
                        "failed to allocate a frame\n") );
                    //
                    // Free this header here and the routine below will 
                    // clean up whatever has been added to the queue.
                    // 
                    
                    ExFreePool( StreamHeader );
                } else {
                    //
                    // Start with the owner file object as this connection,
                    // if a no-copy condition exists, this will be adjusted
                    // in the transfer function.
                    //
                    StreamHeader->OwnerFileObject = 
                        StreamObject->FileObject;
                    StreamHeader->Header.DataUsed = 0;
                    StreamHeader->Header.FrameExtent = 
                        StreamObject->Framing.FrameSize;
#if (DBG)
                    if (StreamHeader->OnFreeList) {
                        DebugPrint((DebugLevelTrace,"stream header already on free list.\n") );
                    }
#endif
                    InsertTailList( 
                        &StreamObject->FreeQueue, 
                        &StreamHeader->ListEntry );
#if (DBG)
                    StreamHeader->OnFreeList = TRUE;
#endif
                }
            }    
        }
        
        //
        // Clean up orphaned frames from the allocator and free headers
        // to the pool if there was a failure.
        //   
         
        if (!NT_SUCCESS( Status )) {
            while (!IsListEmpty( &StreamObject->FreeQueue )) {
                PLIST_ENTRY Node;
                
                Node = RemoveHeadList( &StreamObject->FreeQueue );
                StreamHeader = 
                    CONTAINING_RECORD( 
                        Node,
                        STREAM_HEADER_EX,
                        ListEntry );

#if (DBG)
                StreamHeader->OnFreeList = FALSE;

                ASSERT( StreamHeader->Data == StreamHeader->Header.Data );
#endif                                        
                FreeFrame( 
                    StreamObject->AllocatorFileObject, 
                    StreamHeader->Header.Data );

#if (DBG)
                if (StreamHeader->OnFreeList || StreamHeader->OnActiveList) {
                    DebugPrint((DebugLevelTrace,
                        "freeing header %x still on list\n", StreamHeader) );
                }
#endif
                ExFreePool( StreamHeader );
            }
            DebugPrint((DebugLevelTrace,
                "PrepareTransfer exiting, frame allocation failed: %08x\n", Status) );
            return Status;    
        } 
    }

    StreamObject->PinState = PinPrepared;    

    DebugPrint((DebugLevelTrace,"exiting PrepareTransfer\n"));

    return STATUS_SUCCESS;    
}

//---------------------------------------------------------------------------

NTSTATUS
BeginTransfer(
    IN PFILTER_INSTANCE FilterInstance,
    IN PSTREAM_OBJECT StreamObject
    )

/*++

Routine Description:
    Begins the data transfer from each pin by initiating stream reads
    from the inflow pin. The completion routine for each read will
    continue the stream processing.

Arguments:
    IN PFILTER_INSTANCE FilterInstance,
        pointer to the filter instance
        
    IN PSTREAM_OBJECT StreamObject -
        pointer to the transform instance
        
Return:
    STATUS_SUCCESS or an appropriate error code.
    
Comments:
    Not pageable, uses SpinLocks.

--*/

{
    KIRQL                       irql0,irqlFree;
    NTSTATUS                    Status;
    PSTREAM_HEADER_EX           StreamHeader;
    PADDITIONAL_PIN_INFO AdditionalInfo;
    
    DebugPrint((DebugLevelTrace,"entering BeginTransfer\n"));
    
    //
    // If the PinState is not PinPrepared, then return.
    //
    
    if (StreamObject->PinState != PinPrepared) {
        DebugPrint((DebugLevelTrace,"BeginTransfer exiting, PinState != PinPrepared\n") );
        return STATUS_INVALID_DEVICE_STATE;
    }

    AdditionalInfo = FilterInstance->PinInstanceInfo;

    StreamObject->PinState = PinRunning;
    
    //
    // All preparation is complete.  If this is the source pin, begin
    // the actual data transfer.
    //
    
    Status = STATUS_SUCCESS;
    
    if (StreamObject->PinType == IrpSource) {

#if (DBG)
//
// get the dataflow direction
//
            DebugPrint((DebugLevelVerbose,
                "BeginTransfer, DataFlow:"));
    
            if (StreamObject->DeviceExtension->StreamDescriptor->StreamInfo.DataFlow == KSPIN_DATAFLOW_IN)
                    DebugPrint((DebugLevelVerbose,
                        "KSPIN_DATAFLOW_IN\n"));
            else
                DebugPrint((DebugLevelVerbose,
                    "KSPIN_DATAFLOW_OUT\n"));
#endif
        //
        // Begin the transfer by reading from the inflow pin.
        // 
        
        KeAcquireSpinLock( &StreamObject->Queues[0].QueueLock, &irql0 );
        KeAcquireSpinLock( &StreamObject->FreeQueueLock, &irqlFree );
        while (!IsListEmpty( &StreamObject->FreeQueue )) {
            PLIST_ENTRY Node;
            
            Node = RemoveHeadList( &StreamObject->FreeQueue );

            StreamHeader = 
                CONTAINING_RECORD( 
                    Node,
                    STREAM_HEADER_EX,
                    ListEntry );
#if (DBG)
            StreamHeader->OnFreeList = FALSE;

            if (StreamHeader->OnActiveList) {
                DebugPrint((DebugLevelTrace,"stream header %x already on active list.\n",StreamHeader) );
            }
#endif
            InterlockedIncrement (&StreamObject -> QueuedFramesPlusOne);
            InsertTailList( &StreamObject->Queues[0].ActiveQueue, Node );

#if (DBG)
            StreamHeader->OnActiveList = TRUE;
#endif

            KeReleaseSpinLock( &StreamObject->FreeQueueLock, irqlFree );
            KeReleaseSpinLock( &StreamObject->Queues[0].QueueLock, irql0 );

            DebugPrint((DebugLevelTrace,
                "BeginTransfer, KsStreamIo: %x\n", StreamHeader));
                
            DebugPrint((DebugLevelTrace,
                "BeginTransfer, KsStreamIo: FileObject:%x\n", StreamObject->FileObject));
            DebugPrint((DebugLevelTrace,
                "BeginTransfer:HeaderSize:=%x\n",StreamHeader->Header.Size));

            InterlockedIncrement( &StreamHeader->ReferenceCount );

            StreamHeader->NextFileObject = StreamObject->NextFileObject;

			//
			// send a data irp to myself, first.
			//
            DebugPrint((DebugLevelTrace,
                "BeginTransfer:Reading:%x\n",StreamHeader->Id));
            Status =
                KsStreamIo(
                    StreamObject->FileObject,
                    &StreamHeader->CompletionEvent,     // Event
                    NULL,                               // PortContext
                    IoCompletionRoutine,
                    StreamHeader,                       // CompletionContext
                    KsInvokeOnSuccess |
                        KsInvokeOnCancel |
                        KsInvokeOnError,
                    &StreamHeader->IoStatus,
                    &StreamHeader->Header,
                    StreamHeader->Header.Size,
                    KSSTREAM_SYNCHRONOUS | KSSTREAM_READ,
                    KernelMode );
            
            if (Status != STATUS_PENDING) {
                //
                // If this I/O completes immediately (failure or not), the
                // event is not signalled.
                //
                KeSetEvent( &StreamHeader->CompletionEvent, IO_NO_INCREMENT, FALSE );
            }        
            
            if (!NT_SUCCESS( Status )) {
                DebugPrint((DebugLevelTrace, "KsStreamIo returned %08x\n", Status ));
            } else {
                Status = STATUS_SUCCESS;
            }
            KeAcquireSpinLock( &StreamObject->Queues[0].QueueLock, &irql0 );
            KeAcquireSpinLock( &StreamObject->FreeQueueLock, &irqlFree );
        }        
        KeReleaseSpinLock( &StreamObject->FreeQueueLock, irqlFree );
        KeReleaseSpinLock( &StreamObject->Queues[0].QueueLock, irql0 );
    }

    DebugPrint((DebugLevelTrace,"exiting BeginTransfer\n"));
    return Status;
}

//---------------------------------------------------------------------------

NTSTATUS
EndTransfer(
    IN PFILTER_INSTANCE FilterInstance,
    IN PSTREAM_OBJECT   StreamObject
    )

/*++

Routine Description:
    Ends the data transfer, waits for all Irps to complete

Arguments:
    IN PFILTER_INSTANCE FilterInstance -
        pointer to the filter instance

    IN PSTREAM_OBJECT   StreamObject
        pointer to the Stream object

Return:
    STATUS_SUCCESS or an appropriate error code.

Comments:
    Not pageable, uses SpinLocks.

--*/

{
    PDEVICE_EXTENSION   DeviceExtension;
    KIRQL irqlOld;

    DeviceExtension = StreamObject->DeviceExtension;
    
    DebugPrint((DebugLevelTrace,"entering EndTransfer!\n"));

    //
    // Set the marker indicating that we stop sourcing frames and then flush
    // to ensure that anything blocked on the output pin at least gets 
    // cancelled before we block and deadlock on it.
    //
    StreamObject -> PinState = PinStopPending;
    StreamFlushIo (DeviceExtension, StreamObject);
    if (InterlockedDecrement (&StreamObject -> QueuedFramesPlusOne)) {
        //
        // Release the control mutex to allow the I/O thread to run.
        //
        KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

        DebugPrint((DebugLevelTrace,
            "waiting for pin %d queue to empty\n", StreamObject->PinId));
        
        //
        // Wait for the queue to empty
        //
        KeWaitForSingleObject(
            &StreamObject -> StopEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL);
    
        DebugPrint((DebugLevelTrace,"queue emptied\n") );
        
        //
        // Re-acquire the control object.
        //    
        
        KeWaitForSingleObject(&DeviceExtension->ControlEvent,
                          Executive,
                          KernelMode,
                          FALSE,// not alertable
                          NULL);
    }

    //
    // Free the frames so that we can reprepare for new allocator
    // framing, a new allocator or just general cleanup/shutdown.
    //    
    
    KeAcquireSpinLock( &StreamObject->FreeQueueLock, &irqlOld );
    
    while (!IsListEmpty( &StreamObject->FreeQueue )) {
    
        PLIST_ENTRY         Node;
        PSTREAM_HEADER_EX   StreamHeader;
        
        Node = RemoveHeadList( &StreamObject->FreeQueue );

        StreamHeader = 
            CONTAINING_RECORD( 
                Node,
                STREAM_HEADER_EX,
                ListEntry );

#if (DBG)
        StreamHeader->OnFreeList = FALSE;
#endif
        KeReleaseSpinLock( &StreamObject->FreeQueueLock, irqlOld );    
#if (DBG)
        ASSERT( StreamHeader->Data == StreamHeader->Header.Data );
#endif                                        
        FreeFrame( 
            StreamObject->AllocatorFileObject, 
            StreamHeader->Header.Data );

        DebugPrint((DebugLevelTrace,
            "freeing header: %08x, list: %08x\n", StreamHeader, &StreamObject->FreeQueue) );

#if (DBG)
        if (StreamHeader->OnFreeList || StreamHeader->OnActiveList) {
            DebugPrint((DebugLevelTrace,
                "freeing header %x still on list\n", StreamHeader) );
        }
#endif

        ExFreePool( StreamHeader );

        KeAcquireSpinLock( &StreamObject->FreeQueueLock, &irqlOld );
    }
    StreamObject->PinState = PinStopped;

    KeReleaseSpinLock( &StreamObject->FreeQueueLock, irqlOld );    
    
    DebugPrint((DebugLevelTrace,"exiting CleanupTransfer\n"));
    return STATUS_SUCCESS;
}

//---------------------------------------------------------------------------

NTSTATUS
AllocateFrame(
    PFILE_OBJECT Allocator,
    PVOID *Frame
    )

/*++

Routine Description:
    Allocates a frame from the given allocator

Arguments:
    PFILE_OBJECT Allocator -
        pointer to the allocator's file object

    PVOID *Frame -
        pointer to receive the allocated frame pointer

Return:
    STATUS_SUCCESS and *Frame contains a pointer to the allocated
    frame, otherwise an appropriate error code.

--*/

{
    NTSTATUS    Status;
    KSMETHOD    Method;
    ULONG       Returned;

    DebugPrint((DebugLevelTrace,"entering AllocateFrame\n"));
    Method.Set = KSMETHODSETID_StreamAllocator;
    Method.Id = KSMETHOD_STREAMALLOCATOR_ALLOC;
    Method.Flags = KSMETHOD_TYPE_WRITE;

    Status =
        KsSynchronousIoControlDevice(
            Allocator,
            KernelMode,
            IOCTL_KS_METHOD,
            &Method,
            sizeof( Method ),
            Frame,
            sizeof( PVOID ),
            &Returned );

    DebugPrint((DebugLevelTrace,"exiting AllocateFrame\n"));
    return Status;
}

//---------------------------------------------------------------------------

NTSTATUS
FreeFrame(
    PFILE_OBJECT Allocator,
    PVOID Frame
    )

/*++

Routine Description:
    Frees a frame to the given allocator

Arguments:
    PFILE_OBJECT Allocator -
        pointer to the allocator's file object

    PVOID Frame -
        pointer to the frame to be freed.

Return:
    STATUS_SUCCESS or else an appropriate error code.

--*/

{
    NTSTATUS    Status;
    KSMETHOD    Method;
    ULONG       Returned;

    DebugPrint((DebugLevelTrace,"entering FreeFrame\n"));
    Method.Set = KSMETHODSETID_StreamAllocator;
    Method.Id = KSMETHOD_STREAMALLOCATOR_FREE;
    Method.Flags = KSMETHOD_TYPE_READ;

    Status =
        KsSynchronousIoControlDevice(
            Allocator,
            KernelMode,
            IOCTL_KS_METHOD,
            &Method,
            sizeof( Method ),
            &Frame,
            sizeof( PVOID ),
            &Returned );

    DebugPrint((DebugLevelTrace,"exiting FreeFrame\n"));
    return Status;
}
//---------------------------------------------------------------------------

NTSTATUS 
PinCreateHandler(
    IN PIRP Irp,
    IN PSTREAM_OBJECT StreamObject
    )

/*++

Routine Description:
    This is the pin creation handler which is called by KS when a
    pin create request is submitted to the filter.

Arguments:
    IN PIRP Irp -
        pointer to the I/O request packet

Return:
    STATUS_SUCCESS or an appropriate error return code.

--*/

{
    NTSTATUS            Status;
    PIO_STACK_LOCATION  IrpStack;
    PFILTER_INSTANCE    FilterInstance;
    PADDITIONAL_PIN_INFO AdditionalInfo;

    PFILE_OBJECT    NextFileObject;


    IrpStack = IoGetCurrentIrpStackLocation( Irp );
    DebugPrint((DebugLevelTrace,"entering PinCreateHandler\n"));

    FilterInstance = 
        (PFILTER_INSTANCE) IrpStack->FileObject->RelatedFileObject->FsContext;
    AdditionalInfo = FilterInstance->PinInstanceInfo;

    Status = STATUS_SUCCESS;
    StreamObject->NextFileObject = NULL;

    DebugPrint((DebugLevelTrace,"PinCreateHandler:its an IrpSource\n"));
    //
    // Validate that we can handle this connection request
    //
    if (StreamObject->NextFileObject) {
        DebugPrint((DebugLevelTrace,"invalid connection request\n") );
        Status = STATUS_CONNECTION_REFUSED;
	}
    else
	{
	    Status =
    	    ObReferenceObjectByHandle( 
        	    StreamObject->PinToHandle,
	            FILE_READ_ACCESS | FILE_WRITE_ACCESS | SYNCHRONIZE,
    	        *IoFileObjectType,
        	    KernelMode, 
            	&NextFileObject,
	            NULL );
    
    	if (!NT_SUCCESS(Status)) {
        	DebugPrint((DebugLevelTrace,"PinCreateHandler:error referencing PinToHandle\n"));
	  	}
		else
		{

		// NextFileObject must be per instance
		//AdditionalInfo[ StreamObject->PinId ].NextFileObject = NextFileObject;
		StreamObject->NextFileObject = 	NextFileObject;	
	    	//
		    // Add the pin's target to the list of targets for 
    		// recalculating stack depth.
		    //
    		KsSetTargetDeviceObject(
	    	    StreamObject->ComObj.DeviceHeader,
    	    	IoGetRelatedDeviceObject( 
	            NextFileObject ) );
        }

    }

    DebugPrint((DebugLevelTrace,"PinCreateHandler returning %x\n", Status ));
    return Status;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\client\hclient\hclient.h ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    hclient.h

Abstract:

    This module contains the public declarations and definitions that are
    defined in hclient.c and available to other modules outside of it.
              
Environment:

    User mode

Revision History:

    Nov-97 : Created 

--*/

#ifndef __HCLIENT_H__
#define __HCLIENT_H__

#define WM_UNREGISTER_HANDLE    WM_USER+1
#define WM_DISPLAY_READ_DATA    WM_USER+2
#define WM_READ_DONE            WM_USER+3

#define READ_THREAD_TIMEOUT     1000

#define HCLIENT_ERROR           "HClient Error"

typedef struct _READ_THREAD_CONTEXT 
{
    PHID_DEVICE HidDevice;

    HWND        DisplayWindow;
    HANDLE      DisplayEvent;

    BOOL        DoOneRead;
    BOOL        TerminateThread;

} READ_THREAD_CONTEXT, *PREAD_THREAD_CONTEXT;


typedef NTSTATUS __stdcall GETEXTATTRIB (
    HIDP_REPORT_TYPE,
    USHORT,
    PHIDP_PREPARSED_DATA,
    PHIDP_EXTENDED_ATTRIBUTES,
    PULONG);

typedef GETEXTATTRIB *PGETEXTATTRIB;

typedef NTSTATUS __stdcall INITREPORT (
    HIDP_REPORT_TYPE,
    UCHAR,
    PHIDP_PREPARSED_DATA,
    PCHAR,
    ULONG);

typedef INITREPORT *PINITREPORT;


extern PGETEXTATTRIB pfnHidP_GetExtendedAttributes;

extern PINITREPORT   pfnHidP_InitializeReportForID;

VOID
vDisplayDeviceAttributes(
    IN PHIDD_ATTRIBUTES pAttrib,
    IN HWND             hControl
);

VOID
vDisplayButtonAttributes(
    IN PHIDP_BUTTON_CAPS pButton,
    IN HWND              hControl
);

VOID
vDisplayDataAttributes(
    PHIDP_DATA pData, 
    BOOL IsButton, 
    HWND hControl
);

VOID
vCreateUsageAndPageString(
    IN  PUSAGE_AND_PAGE   pUsageList,
    OUT CHAR              szString[]
);

VOID
vCreateUsageString(
    IN  PUSAGE   pUsageList,
    OUT CHAR     szString[]
);

VOID
vDisplayDeviceCaps(
    IN PHIDP_CAPS pCaps,
    IN HWND       hControl
);

VOID 
vDisplayValueAttributes(
    IN PHIDP_VALUE_CAPS pValue,
    IN HWND             hControl
);

VOID
vDisplayLinkCollectionNode(
    IN  PHIDP_LINK_COLLECTION_NODE  pLCNode,
    IN  ULONG                       ulLinkIndex,
    IN  HWND                        hControl
);

VOID
vCreateUsageValueStringFromArray(
    PCHAR       pBuffer,
    USHORT      BitSize,
    USHORT      UsageIndex,
    CHAR        szString[]
);

VOID 
vDisplayValueAttributes(
    IN PHIDP_VALUE_CAPS pValue,
    IN HWND hControl
);

DWORD WINAPI
AsynchReadThreadProc(
    PREAD_THREAD_CONTEXT    Context
);

DWORD WINAPI
SynchReadThreadProc(
    PREAD_THREAD_CONTEXT    Context
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\client\hclient\hid.h ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    hid.h

Abstract:

    This module contains the declarations and definitions for use with the
    hid user mode client sample driver.

Environment:

    Kernel & user mode

@@BEGIN_DDKSPLIT

Revision History:

    Nov-96 : Created by Kenneth D. Ray

@@END_DDKSPLIT
--*/

#ifndef HID_H
#define HID_H

#include "hidsdi.h"
#include "setupapi.h"

typedef struct _SP_FNCLASS_DEVICE_DATA {
   DWORD cbSize;
   GUID  FunctionClassGuid;
   TCHAR DevicePath [ANYSIZE_ARRAY];
} SP_FNCLASS_DEVICE_DATA, *PSP_FNCLASS_DEVICE_DATA;

BOOLEAN
SetupDiGetFunctionClassDeviceInfo (
   IN    HDEVINFO                DeviceInfoSet,
   IN    PSP_DEVINFO_DATA        DeviceInfoData,
   OUT   PSP_FNCLASS_DEVICE_DATA FunctionClassDeviceData,
   IN    DWORD                   FunctionClassDeviceDataSize,
   OUT   PDWORD                  RequiredSize
   );

#define ASSERT(x)

//
// A structure to hold the steady state data received from the hid device.
// Each time a read packet is received we fill in this structure.
// Each time we wish to write to a hid device we fill in this structure.
// This structure is here only for convenience.  Most real applications will
// have a more efficient way of moving the hid data to the read, write, and
// feature routines.
//
typedef struct _HID_DATA {
   BOOLEAN     IsButtonData;
   UCHAR       Reserved;
   USAGE       UsagePage;   // The usage page for which we are looking.
   ULONG       Status;      // The last status returned from the accessor function
                            // when updating this field.
   ULONG       ReportID;    // ReportID for this given data structure
   BOOLEAN     IsDataSet;   // Variable to track whether a given data structure
                            //  has already been added to a report structure

   union {
      struct {
         ULONG       UsageMin;       // Variables to track the usage minimum and max
         ULONG       UsageMax;       // If equal, then only a single usage
         ULONG       MaxUsageLength; // Usages buffer length.
         PUSAGE      Usages;         // list of usages (buttons ``down'' on the device.

      } ButtonData;
      struct {
         USAGE       Usage; // The usage describing this value;
         USHORT      Reserved;

         ULONG       Value;
         LONG        ScaledValue;
      } ValueData;
   };
} HID_DATA, *PHID_DATA;

typedef struct _HID_DEVICE {   
    PCHAR                DevicePath;
    HANDLE               HidDevice; // A file handle to the hid device.
    BOOL                 OpenedForRead;
    BOOL                 OpenedForWrite;
    BOOL                 OpenedOverlapped;
    BOOL                 OpenedExclusive;
    
    PHIDP_PREPARSED_DATA Ppd; // The opaque parser info describing this device
    HIDP_CAPS            Caps; // The Capabilities of this hid device.
    HIDD_ATTRIBUTES      Attributes;

    PCHAR                InputReportBuffer;
    PHID_DATA            InputData; // array of hid data structures
    ULONG                InputDataLength; // Num elements in this array.
    PHIDP_BUTTON_CAPS    InputButtonCaps;
    PHIDP_VALUE_CAPS     InputValueCaps;

    PCHAR                OutputReportBuffer;
    PHID_DATA            OutputData;
    ULONG                OutputDataLength;
    PHIDP_BUTTON_CAPS    OutputButtonCaps;
    PHIDP_VALUE_CAPS     OutputValueCaps;

    PCHAR                FeatureReportBuffer;
    PHID_DATA            FeatureData;
    ULONG                FeatureDataLength;
    PHIDP_BUTTON_CAPS    FeatureButtonCaps;
    PHIDP_VALUE_CAPS     FeatureValueCaps;
} HID_DEVICE, *PHID_DEVICE;


BOOLEAN
OpenHidDevice (
    IN       PCHAR          DevicePath,
    IN       BOOL           HasReadAccess,
    IN       BOOL           HasWriteAccess,
    IN       BOOL           IsOverlapped,
    IN       BOOL           IsExclusive,
    IN OUT   PHID_DEVICE    HidDevice
);

BOOLEAN
FindKnownHidDevices (
   OUT PHID_DEVICE * HidDevices, // A array of struct _HID_DEVICE
   OUT PULONG        NumberDevices // the length of this array.
   );

BOOLEAN
FillDeviceInfo(
    IN  PHID_DEVICE HidDevice
);

VOID
CloseHidDevices (
   OUT PHID_DEVICE   HidDevices, // A array of struct _HID_DEVICE
   OUT ULONG         NumberDevices // the length of this array.
   );

VOID
CloseHidDevice (
    IN PHID_DEVICE   HidDevice
    );


BOOLEAN
Read (
   PHID_DEVICE    HidDevice
   );

BOOLEAN
ReadOverlapped (
    PHID_DEVICE     HidDevice,
    HANDLE          CompletionEvent
   );
   
BOOLEAN
Write (
   PHID_DEVICE    HidDevice
   );

BOOLEAN
UnpackReport (
   IN       PCHAR                ReportBuffer,
   IN       USHORT               ReportBufferLength,
   IN       HIDP_REPORT_TYPE     ReportType,
   IN OUT   PHID_DATA            Data,
   IN       ULONG                DataLength,
   IN       PHIDP_PREPARSED_DATA Ppd
   );

BOOLEAN
SetFeature (
   PHID_DEVICE    HidDevice
   );

BOOLEAN
GetFeature (
   PHID_DEVICE    HidDevice
   );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\client\hclient\ecdisp.h ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    ecdisp.h

Abstract:

    This module contains the public declarations for the extended calls dialog
    box.

Environment:

    User mode

Revision History:

    May-98 : Created 

--*/

#ifndef _ECDISP_H_
#define _ECDISP_H_

typedef struct {
    HANDLE                    DeviceHandle;
    HIDP_REPORT_TYPE          ReportType;
    PHIDP_PREPARSED_DATA      Ppd;
    USAGE                     UsagePage;
    USAGE                     Usage;
    USHORT                    LinkCollection;
    UCHAR                     ReportID;
    PCHAR                     ReportBuffer;
    ULONG                     ReportLength;
    PVOID                     List;
    ULONG                     ListLength;
    ULONG                     Index;
    union {              
        struct {
            USHORT            ReportCount;
            USHORT            BitSize;
        };

        struct {
            PUSAGE            List2;
            PUSAGE            MakeList;
            PUSAGE            BreakList;
        };

        PHIDP_PREPARSED_DATA *ppPd;
        ULONG                 Value;
        LONG                  ScaledValue;
    };
} EXTCALL_PARAMS, *PEXTCALL_PARAMS;

typedef struct {
    BOOL                IsHidError;
    NTSTATUS            HidErrorCode;
    
} EXTCALL_STATUS, *PEXTCALL_STATUS;


/*****************************************************************************
/* Global Extended Call display function declarations
/*****************************************************************************/

LRESULT CALLBACK
bExtCallDlgProc(
    HWND   hDlg,
    UINT   message,
    WPARAM wParam, 
    LPARAM lParam
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\client\hclient\buffers.c ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    buffers.c

Abstract:

    This module contains the code for handling the display of HID report
    buffers for the extended calls dialog box.  

Environment:

    User mode

Revision History:

    May-98 : Created 

--*/

#include <windows.h>
#include <malloc.h>
#include <setupapi.h>
#include "hidsdi.h"
#include "hidpi.h"
#include "buffers.h"
#include "strings.h"

#define CURRENT_REPORT(pDisp)   (pDisp -> ReportBuffers + pDisp -> iCurrSelectionIndex)

BOOLEAN
BufferDisplay_Init(
    IN  HWND                hCB,
    IN  HWND                hEB,
    IN  INT                 nBuffers,
    IN  INT                 iBufferSize,
    IN  HIDP_REPORT_TYPE    RType,
    OUT PBUFFER_DISPLAY     *ppBufferDisplay
)
/*++
Routine Description:
    This routine initializes the buffer display mechanism for a given report type

    The display mechanism maintains a list of list of nBuffers, where is each
    is buffer is of iBufferSize and hCB and hEB are handles to the combo box and
    edit box for displaying the buffer. 

    The variable ppBufferDisplay is allocated block which is passed into other
    buffer routines and contains information about the buffer for the other 
    routines.

    This function will return FALSE if there was a problem allocating memory
--*/
{
    PBUFFER_DISPLAY pNewDisplay;
    CHAR            *pszBufferHeader;
    CHAR            szBufferName[24];
    INT             iIndex;
    INT             iCBIndex;

    pNewDisplay = (PBUFFER_DISPLAY) malloc(sizeof(BUFFER_DISPLAY));

    *ppBufferDisplay = NULL;

    if (NULL == pNewDisplay)
    {
        return (FALSE);
    }

    pNewDisplay -> ReportBuffers = (PREPORT_BUFFER) malloc(sizeof(REPORT_BUFFER) * nBuffers);

    if (NULL == pNewDisplay -> ReportBuffers) 
    {
        free(pNewDisplay);

        return (FALSE);
    }
    
    memset(pNewDisplay -> ReportBuffers, 0x00, sizeof(REPORT_BUFFER) * nBuffers);

    pNewDisplay -> hBufferComboBox = hCB;
    pNewDisplay -> hBufferEditBox = hEB;
    pNewDisplay -> nReportBuffers = nBuffers;
    pNewDisplay -> iBufferSize = iBufferSize;
    pNewDisplay -> ReportType = RType;

    switch (pNewDisplay -> ReportType) 
    {
        case HidP_Input:
            pszBufferHeader = "Input";
            break;

        case HidP_Output:
            pszBufferHeader = "Output";
            break;

        case HidP_Feature:
            pszBufferHeader = "Feature";
            break;

        default:
            pszBufferHeader = "Other";
            break;
    }

    for (iIndex = 0; iIndex < pNewDisplay -> nReportBuffers; iIndex++) 
    {
        wsprintf(szBufferName, "%s Buffer #%d", pszBufferHeader, iIndex);

        iCBIndex = (INT) SendMessage(pNewDisplay -> hBufferComboBox,
                                     CB_ADDSTRING,
                                     0, 
                                     (LPARAM) szBufferName);

        if (CB_ERR == iCBIndex || CB_ERRSPACE == iCBIndex) 
        {
            BufferDisplay_Destroy(pNewDisplay);
            return (FALSE);
        }

        iCBIndex = (INT) SendMessage(pNewDisplay -> hBufferComboBox,
                                     CB_SETITEMDATA,
                                     iCBIndex,
                                     iIndex);

        if (CB_ERR == iCBIndex || CB_ERRSPACE == iCBIndex)  
        {
            BufferDisplay_Destroy(pNewDisplay);
            return (FALSE);
        }
    }

    SendMessage(pNewDisplay -> hBufferComboBox, CB_SETCURSEL, 0, 0);

    BufferDisplay_ChangeSelection(pNewDisplay);

    *ppBufferDisplay = pNewDisplay;
    return (TRUE);
}

VOID
BufferDisplay_Destroy(
    IN  PBUFFER_DISPLAY     pBufferDisplay
)
/*++
Routine Description:
    This routine cleans up the buffer display variable that was allocated by
    the initialize routine
--*/
{
    INT     iIndex;

    for (iIndex = 0; iIndex < pBufferDisplay -> nReportBuffers; iIndex++) 
    {
        if (NULL != pBufferDisplay -> ReportBuffers[iIndex].pBuffer) 
        {
            free(pBufferDisplay -> ReportBuffers[iIndex].pBuffer);
        }
    }

    free(pBufferDisplay -> ReportBuffers);
    free(pBufferDisplay);
    return;
}

VOID
BufferDisplay_ChangeSelection(
    IN  PBUFFER_DISPLAY     pBufferDisplay
)
/*++
Routine Description:
    This routine has the selection of a buffer to display via the combo box
--*/
{
    INT     iNewIndex;

    iNewIndex = (INT) SendMessage(pBufferDisplay -> hBufferComboBox,
                                  CB_GETCURSEL, 
                                  0,
                                  0);

    if (CB_ERR == iNewIndex)
    {
        return;
    }

    iNewIndex = (INT) SendMessage(pBufferDisplay -> hBufferComboBox,
                                  CB_GETITEMDATA,
                                  iNewIndex,
                                  0);

    if (CB_ERR == iNewIndex)
    {
        return;
    }

    pBufferDisplay -> iCurrSelectionIndex = iNewIndex;

    BufferDisplay_OutputBuffer(pBufferDisplay -> hBufferEditBox,
                               &(pBufferDisplay -> ReportBuffers[iNewIndex]));

    return;
}

VOID
BufferDisplay_OutputBuffer(
    HWND            hEditBox,
    PREPORT_BUFFER  pReportBuffer
)
/*++
Routine Description:
    This routine outputs to hEditBox a byte representation of pReportBuffer
--*/
{
    PCHAR           BufferString;

    if (0 == pReportBuffer -> iBufferSize || NULL == pReportBuffer -> pBuffer) 
    {
        SetWindowText(hEditBox, "");
    }
    else 
    {
        /*
        // Create a buffer string the size of the buffer and display 
        //   as bytes
        */
        
        Strings_CreateDataBufferString(pReportBuffer -> pBuffer,
                                       pReportBuffer -> iBufferSize,
                                       pReportBuffer -> iBufferSize,
                                       1,
                                       &BufferString);

        if (NULL == BufferString) 
        {
            SetWindowText(hEditBox, "");
        }
        else
        {
            SetWindowText(hEditBox, BufferString);
            free(BufferString);
        }
    }
    return;
}

BOOLEAN
BufferDisplay_UpdateBuffer(
    IN  PBUFFER_DISPLAY     pBufferDisplay,
    IN  PCHAR               pNewBuffer
)
/*++
Routine Description:
    This routine changes the data of the currently active report buffer for the
    given buffer display structure.  

    It returns FALSE if it needed to allocate a new buffer and the memory allocation
    failed.
--*/
{
    PREPORT_BUFFER          pCurrentReport;

    pCurrentReport = CURRENT_REPORT(pBufferDisplay);
    
    if (NULL == pCurrentReport -> pBuffer) 
    {
        pCurrentReport -> pBuffer = malloc(pBufferDisplay -> iBufferSize);
        if ((NULL == pCurrentReport) || (NULL == pCurrentReport -> pBuffer))
        {
            return (FALSE);
        }

        pCurrentReport -> iBufferSize = pBufferDisplay -> iBufferSize;
    }

    memmove (pCurrentReport -> pBuffer, pNewBuffer, pCurrentReport -> iBufferSize);

    BufferDisplay_OutputBuffer(pBufferDisplay -> hBufferEditBox, pCurrentReport);

    return (TRUE);
}

INT
BufferDisplay_GetBufferSize(
    IN  PBUFFER_DISPLAY      pBufferDisplay
)
/*++
Routine Description:
    This routine simply returns the size of the given buffer
--*/
{
    return (pBufferDisplay -> iBufferSize);
}

VOID
BufferDisplay_CopyCurrentBuffer(
    IN  PBUFFER_DISPLAY     pBufferDisplay,
    OUT PCHAR               pCopyBuffer
)
/*++
Routine Description:
    This routine copies the currently active buffer for the given buffer display
    into the buffer passed in by the caller.

    It is the caller's responsibility to allocate a buffer of the appropriate size
    The appropriate size can be obtain by calling BufferDisplay_GetBufferSize
--*/
{
    PREPORT_BUFFER          pCurrentReport;

    pCurrentReport = CURRENT_REPORT(pBufferDisplay);

    if (NULL == pCurrentReport -> pBuffer) 
    {
        memset(pCopyBuffer, 0x0, pBufferDisplay -> iBufferSize);
    }
    else
    {
        memcpy(pCopyBuffer, pCurrentReport -> pBuffer, pCurrentReport -> iBufferSize);
    }
    return;
}

INT
BufferDisplay_GetCurrentBufferNumber(
    IN  PBUFFER_DISPLAY      pBufferDisplay
)
/*++
Routine Description:
    This routine returns the buffer number of the current buffer selection
--*/
{
    return (pBufferDisplay -> iCurrSelectionIndex);
}

UCHAR
BufferDisplay_GetCurrentReportID(
    IN  PBUFFER_DISPLAY      pBufferDisplay
)
/*++
Routine Description:
    This routine returns the report ID of the current buffer selection
--*/
{
    PREPORT_BUFFER pCurrentReport;

    pCurrentReport = CURRENT_REPORT(pBufferDisplay);

    return (pCurrentReport -> ucReportID);
}

VOID
BufferDisplay_ClearBuffer(
    IN  PBUFFER_DISPLAY pBufferDisplay
)
/*++
Routine Description:
    This routine frees the current report buffer and set's it to NULL
--*/
{
    PREPORT_BUFFER pCurrentReport;

    pCurrentReport = CURRENT_REPORT(pBufferDisplay);

    if (NULL != pCurrentReport -> pBuffer) 
    {
        free(pCurrentReport -> pBuffer);

        pCurrentReport -> iBufferSize = 0;
        pCurrentReport -> ucReportID = 0;
        pCurrentReport -> pBuffer = NULL;
    }

    BufferDisplay_OutputBuffer(pBufferDisplay -> hBufferEditBox,
                               pCurrentReport);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\client\hclient\hclient.c ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    hclient.c

Abstract:

    This module contains the code for handling HClient's main dialog box and 
    for performing/calling the appropriate other routines.

Environment:

    User mode

Revision History:

    Nov-97 : Created 

--*/

#define __HCLIENT_C__
#define LOG_FILE_NAME   NULL

//****************************************************************************
// HClient include files
//****************************************************************************

#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>
#include <math.h>
#include <assert.h>
#include <dbt.h>
#include "hidsdi.h"
#include "hid.h"
#include "resource.h"
#include "hclient.h"
#include "buffers.h"
#include "ecdisp.h"
#include "list.h"
#include <strsafe.h>

//****************************************************************************
// Local display macro definitions
//****************************************************************************

#define INPUT_BUTTON    1
#define INPUT_VALUE     2
#define OUTPUT_BUTTON   3
#define OUTPUT_VALUE    4
#define FEATURE_BUTTON  5
#define FEATURE_VALUE   6
#define HID_CAPS        7
#define DEVICE_ATTRIBUTES 8
                           
#define MAX_LB_ITEMS 200

#define MAX_WRITE_ELEMENTS 100
#define MAX_OUTPUT_ELEMENTS 50

#define CONTROL_COUNT 9
#define MAX_LABEL 128
#define MAX_VALUE 128
#define SMALL_BUFF 128

//****************************************************************************
// Macro definition to get device block from the main dialog box procedure
//****************************************************************************

#define GET_CURRENT_DEVICE(hDlg, pDevice)   \
{ \
    pDevice = NULL; \
    iIndex = (INT) SendDlgItemMessage(hDlg, \
                                      IDC_DEVICES, \
                                      CB_GETCURSEL, \
                                      0, \
                                      0); \
    if (CB_ERR != iIndex) { \
        pDevice = (PHID_DEVICE) SendDlgItemMessage(hDlg, \
                                                   IDC_DEVICES, \
                                                   CB_GETITEMDATA, \
                                                   iIndex, \
                                                   0); \
    } \
}

//****************************************************************************
// Data types local to the HClient display routines
//****************************************************************************

typedef struct rWriteDataStruct_type
{

    char szLabel[MAX_LABEL];
    char szValue[MAX_VALUE];

} rWriteDataStruct, *prWriteDataStruct;

typedef struct rGetWriteDataParams_type
{
        prWriteDataStruct   prItems;
        int                 iCount;
        
} rGetWriteDataParams, *prGetWriteDataParams;

typedef struct _DEVICE_LIST_NODE
{
    LIST_NODE_HDR   Hdr;
    HDEVNOTIFY      NotificationHandle;
    HID_DEVICE      HidDeviceInfo;
    BOOL            DeviceOpened;

} DEVICE_LIST_NODE, *PDEVICE_LIST_NODE;

//****************************************************************************
// Global program variables
//****************************************************************************

//
// Pointers to the HID.DLL functions that were added into the Win98 OSR and 
//  Windows 2000 but we're not included in the original implementation of 
//  HID.DLL in Windows 98.  By getting pointers to these functions instead of
//  statically linking with them, we can avoid the link error that would 
//  occur when this runs on Windows 98.  The typedefs to make this easier to
//  declare are also included below.
//

PGETEXTATTRIB pfnHidP_GetExtendedAttributes = NULL;

PINITREPORT   pfnHidP_InitializeReportForID = NULL;

   
//****************************************************************************
// Global module variables
//****************************************************************************
static HINSTANCE          hGInstance; //global application instance handle

static HANDLE             HIDDLLModuleHandle;

//
// Variables for handling the two different types of devices that can be loaded
//   into the system.  PhysicalDeviceList contains all the actual HID devices
//   attached via the USB bus. 
//

static LIST               PhysicalDeviceList;

//****************************************************************************
// Local data routine declarations
//****************************************************************************

VOID 
vReadDataFromControls(
    HWND hDlg,
    prWriteDataStruct prData,
    int iOffset,
    int iCount
);

INT_PTR CALLBACK 
bGetDataDlgProc(
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam
);

INT_PTR CALLBACK 
bMainDlgProc(
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam
);

INT_PTR CALLBACK 
bFeatureDlgProc(
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam
);

INT_PTR CALLBACK 
bReadDlgProc(
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam
);

VOID 
vLoadItemTypes(
    HWND hItemTypes
);

BOOL 
bGetData(
    prWriteDataStruct,
    int iCount,
    HWND hParent, 
    char *pszDialogName
);

VOID 
vLoadDevices(
    HWND hDeviceCombo
);

VOID 
vFreeDeviceList(
    PHID_DEVICE  DeviceList,
    ULONG nDevices
);

VOID 
vDisplayInputButtons(
    PHID_DEVICE pDevice,
    HWND hControl
);

VOID 
vDisplayInputValues(
    PHID_DEVICE pDevice,
    HWND hControl
);

VOID 
vDisplayOutputButtons(
    PHID_DEVICE pDevice,
    HWND hControl
);

VOID 
vDisplayOutputValues(
    PHID_DEVICE pDevice,
    HWND hControl
);

VOID 
vDisplayFeatureButtons(
    PHID_DEVICE pDevice,
    HWND hControl
);

VOID 
vDisplayFeatureValues(
    PHID_DEVICE pDevice,
    HWND hControl
);

VOID 
vWriteDataToControls(
    HWND hDlg,
    prWriteDataStruct prData,
    int iOffset,
    int iCount
);

int 
iPrepareDataFields(
    PHID_DATA pData, 
    ULONG ulDataLength, 
    rWriteDataStruct rWriteData[],
    int iMaxElements
);

BOOL 
bParseData(
    PHID_DATA pData,
    rWriteDataStruct rWriteData[],
    INT iCount,
    INT *piErrorLine
);

BOOL 
bSetButtonUsages(
    PHID_DATA pCap,
    PCHAR     pszInputString
);

VOID
BuildReportIDList(
    IN  PHIDP_BUTTON_CAPS  phidButtonCaps,
    IN  USHORT             nButtonCaps,
    IN  PHIDP_VALUE_CAPS   phidValueCaps,
    IN  USHORT             nValueCaps,
    OUT UCHAR            **ppReportIDList,
    OUT INT               *nReportIDs
);

VOID
ReportToString(
   PHID_DATA    pData,
   PCHAR        szBuff,
   UINT          iBuffSize
);

BOOL
RegisterHidDevice(
    IN  HWND                WindowHandle,
    IN  PDEVICE_LIST_NODE   DeviceNode
);

VOID
DestroyDeviceListCallback(
    IN  PLIST_NODE_HDR   ListNode
);

//****************************************************************************
// Function Definitions
//****************************************************************************

/*******************************
*WinMain: Windows Entry point  *
*******************************/
int PASCAL 
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     lpCmdLine,
    int       nCmdShow
)
{
    //
    // Save instance of the application for further reference
    //

    hGInstance = hInstance;

    //
    // Attempt to load HID.DLL...This should already be loaded due to the 
    //  static linking of HID.DLL to this app on compilation.  However,
    //  to insure that this application runs on Windows 98 gold, we cannot
    //  directly reference the new functions HidP_GetExtendedAttributes and 
    //  HidP_InitializeReportForID so to use them, we'll get pointers to their
    //  functions instead.
    //

    HIDDLLModuleHandle = LoadLibrary("HID.DLL");

    if (NULL == HIDDLLModuleHandle) 
    {
        //
        // Something really bad happened here...Throw up and error dialog
        //  and bolt.
        //

        MessageBox(NULL, 
                   "Unable to open HID.DLL\n"
                   "This should never occur",
                   HCLIENT_ERROR,
                   MB_ICONSTOP);

        return (0);
    }

    //
    // Get the function pointers,
    //

    pfnHidP_GetExtendedAttributes = (PGETEXTATTRIB) GetProcAddress(HIDDLLModuleHandle,
                                                                   "HidP_GetExtendedAttributes");

    pfnHidP_InitializeReportForID = (PINITREPORT) GetProcAddress(HIDDLLModuleHandle,
                                                                 "HidP_InitializeReportForID");

    //
    // Try to create the main dialog box.  Cannot do much else if it fails
    //   so we'll throw up a message box and then exit the app
    //

    if (-1 == DialogBox(hInstance, "MAIN_DIALOG", NULL, bMainDlgProc)) 
    {
        MessageBox(NULL,
                   "Unable to create root dialog!",
                   "DialogBox failure",
                   MB_ICONSTOP);
    }

    FreeLibrary (HIDDLLModuleHandle);

    return (0);
}
 
/*************************************************
 * Main Dialog proc                              *
 *************************************************/

//
// This the dialog box procedure for the main dialog display.
//

INT_PTR CALLBACK 
bMainDlgProc(
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam
)
{
    static HWND                             hComboCtrl;
    static rWriteDataStruct                 rWriteData[MAX_OUTPUT_ELEMENTS];
    static HDEVNOTIFY                       diNotifyHandle;
           INT                              iIndex;
           INT                              iCount;
           CHAR                             szTempBuff[SMALL_BUFF];
           PHID_DEVICE                      pDevice;
           PHIDP_BUTTON_CAPS                pButtonCaps;
           PHIDP_VALUE_CAPS                 pValueCaps;
           INT                              iErrorLine;
           INT                              iItemType;
           PHID_DEVICE                      tempDeviceList;
           ULONG                            numberDevices;
           PDEVICE_LIST_NODE                listNode;
           DEV_BROADCAST_DEVICEINTERFACE    broadcastInterface;
           HID_DEVICE                       writeDevice;
           BOOL                             status;
		   HRESULT							stringReturn;

    switch (message)
    {
        case WM_INITDIALOG:

            //
            // Initialize the device list.
            //  -- PhysicalDeviceList is for devices that are actually attached
            //     to the HID bus
            //
            
            InitializeList(&PhysicalDeviceList);
            
            //
            // Begin by finding all the Physical HID devices currently attached to
            //  the system. If that fails, exit the dialog box.  
            //
            
            if (!FindKnownHidDevices(&tempDeviceList, &numberDevices)) 
            {
                EndDialog(hDlg, 0);
                return FALSE;                
            }
          
            //
            // For each device in the newly acquired list, create a device list
            //  node and add it the the list of physical device on the system  
            //
            
            pDevice = tempDeviceList;
            for (iIndex = 0; (ULONG) iIndex < numberDevices; iIndex++, pDevice++)
            {
                listNode = malloc(sizeof(DEVICE_LIST_NODE));

                if (NULL == listNode) {

                    //
                    // When freeing up the device list, we need to kill those
                    //  already in the Physical Device List and close
                    //  that have not been added yet in the enumerated list
                    //
                    
                    DestroyListWithCallback(&PhysicalDeviceList, DestroyDeviceListCallback);

                    CloseHidDevices(pDevice, numberDevices - iIndex);

                    free(tempDeviceList);
                    
                    EndDialog(hDlg, 0);
                    return FALSE;
                }

                listNode -> HidDeviceInfo = *pDevice;
                listNode -> DeviceOpened = TRUE;

                //
                // Register this device node with the PnP system so the dialog
                //  window can recieve notification if this device is unplugged.
                //
                
                if (!RegisterHidDevice(hDlg, listNode)) 
                {
                    DestroyListWithCallback(&PhysicalDeviceList, DestroyDeviceListCallback);

                    CloseHidDevices(pDevice, numberDevices - iIndex);

                    free(tempDeviceList);
                    free(listNode);
                    
                    EndDialog(hDlg, 0);
                    return FALSE;
                }                    

                InsertTail(&PhysicalDeviceList, listNode);
            }

            //
            // Free the temporary device list...It is no longer needed
            //
            
            free(tempDeviceList);
            
            //
            // Register for notification from the HidDevice class.  Doing so 
            //  allows the dialog box to receive device change notifications 
            //  whenever a new HID device is added to the system
            //  

            broadcastInterface.dbcc_size = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
            broadcastInterface.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;

            HidD_GetHidGuid(&broadcastInterface.dbcc_classguid);

            diNotifyHandle = RegisterDeviceNotification(hDlg,
                                                        &broadcastInterface,
                                                        DEVICE_NOTIFY_WINDOW_HANDLE
                                                       );
            if (NULL == diNotifyHandle)
            {
                DestroyListWithCallback(&PhysicalDeviceList, DestroyDeviceListCallback);
                           
                EndDialog(hDlg, 0);
                return FALSE;
            }
                    
            //
            // Update the device list box...
            // 
            //

            vLoadDevices(GetDlgItem(hDlg, IDC_DEVICES));

            //
            // Load the types box
            //
            
            vLoadItemTypes(GetDlgItem(hDlg, IDC_TYPE));
                          
            //
            // Post a message that the device changed so the appropriate
            //   data for the first device in the system can be displayed
            //

            PostMessage(hDlg,
                        WM_COMMAND,
                        IDC_DEVICES + (CBN_SELCHANGE<<16),
                        (LPARAM) GetDlgItem(hDlg, IDC_DEVICES));

            break; // end WM_INITDIALOG case

        case WM_COMMAND:

            switch(LOWORD(wParam))
            {
                //
                // For a read, simply get the current device instance
                //   from the DEVICES combo box and call the read procedure
                //   with the HID_DEVICE block 
                //

                case IDC_READ:
                    GET_CURRENT_DEVICE(hDlg, pDevice);

                    if (NULL != pDevice)
                    {
                        iIndex = (INT) DialogBoxParam(hGInstance,
                                                      "READDATA",
                                                      hDlg,
                                                      bReadDlgProc,
                                                      (LPARAM) pDevice);
                    } 
                    break;

                //
                // For a write, the following steps are performed:
                //   1) Get the current device data from the combo box
                //   2) Prepare the data fields for display based on the data
                //       output data stored in the device data
                //   3) Retrieve the data the from the user that is to be sent
                //       to the device
                //   4) If all goes well and the data parses correctly, send the
                //        the new data values to the device
                //

                case IDC_WRITE:

                    GET_CURRENT_DEVICE(hDlg, pDevice);

                    if (NULL != pDevice) 
                    {
                        //
                        // In order to write to the device, need to get a
                        //  writable handle to the device.  In this case, the
                        //  write will be a synchronous write.  Begin by
                        //  trying to open a second instance of this device with
                        //  write access
                        //
                        
                        status = OpenHidDevice(pDevice -> DevicePath, 
                                                FALSE,
                                                TRUE,
                                                FALSE,
                                                FALSE,
                                                &writeDevice);
                                            
                        if (!status) 
                        {
                            MessageBox(hDlg,
                                       "Couldn't open device for write access",
                                       HCLIENT_ERROR,
                                       MB_ICONEXCLAMATION);
                        }
                        else 
                        {
                            iCount = iPrepareDataFields(writeDevice.OutputData,
                                                        writeDevice.OutputDataLength,
                                                        rWriteData,
                                                        MAX_OUTPUT_ELEMENTS);

                            if (bGetData(rWriteData, iCount, hDlg, "WRITEDATA"))
                            {

                                if (bParseData(writeDevice.OutputData, rWriteData, iCount, &iErrorLine))
                                {
                                    Write(&writeDevice);
                                }
                                else
                                {
                                    stringReturn = StringCbPrintf(szTempBuff,
                                                   SMALL_BUFF,
                                                   "Unable to parse line %x of output data",
                                                   iErrorLine);

                                    MessageBox(hDlg,
                                               szTempBuff,
                                               HCLIENT_ERROR,
                                               MB_ICONEXCLAMATION);
                                }
                            }
                            CloseHidDevice(&writeDevice);
                        }                            
                        
                    } 
                    break; //end case IDC_WRITE//
                    
                //
                // For processing features, get the current device data and call
                //   the Features dialog box,  This dialog box will deal with 
                //   sending and retrieving the features.
                //

                case IDC_FEATURES:
                    GET_CURRENT_DEVICE(hDlg, pDevice);

                    if (NULL != pDevice) 
                    {
                        iIndex = (INT) DialogBoxParam(hGInstance, 
                                                      "FEATURES", 
                                                      hDlg, 
                                                      bFeatureDlgProc, 
                                                      (LPARAM) pDevice);
                    }
                    break;
                    
                //
                // Likewise with extended calls dialog box.  This procedure
                //   passes the address to the device data structure and lets
                //   the dialog box procedure manipulate the data however it 
                //   wants to.
                //

                case IDC_EXTCALLS:
                    GET_CURRENT_DEVICE(hDlg, pDevice);

                    if (NULL != pDevice) 
                    {
                        iIndex = (INT) DialogBoxParam(hGInstance,
                                                      "EXTCALLS",
                                                      hDlg,
                                                      bExtCallDlgProc,
                                                      (LPARAM) pDevice);
                    }
                    break;
                                          
                //
                // If there was a device change, issue an IDC_TYPE
                //   change to insure that the currently displayed types are
                //    updated to reflect the values of the device that has
                //    been selected
                //

                case IDC_DEVICES:
                    switch (HIWORD(wParam)) 
                    {
                        case CBN_SELCHANGE:

                            GET_CURRENT_DEVICE(hDlg, pDevice);

                            EnableWindow(GetDlgItem(hDlg, IDC_READ), 
                                         (pDevice != NULL) && 
                                         (pDevice -> Caps.InputReportByteLength));

                            EnableWindow(GetDlgItem(hDlg, IDC_WRITE), 
                                         (pDevice != NULL) && 
                                         (pDevice -> Caps.OutputReportByteLength));
                                         
                            EnableWindow(GetDlgItem(hDlg, IDC_FEATURES),
                                         (pDevice != NULL) && 
                                         (pDevice -> Caps.FeatureReportByteLength));
                                         
                            PostMessage(hDlg,
                                        WM_COMMAND,
                                        IDC_TYPE + (CBN_SELCHANGE<<16),
                                        (LPARAM) GetDlgItem(hDlg,IDC_TYPE));
                            break;

                    } 
                    break;

                //
                // On a type change, retrieve the currently active device
                //   from the IDC_DEVICES box and display the data that 
                //   corresponds to the item just selected
                //
                
                case IDC_TYPE:
                    switch (HIWORD(wParam))
                    {
                        case CBN_SELCHANGE:
                            GET_CURRENT_DEVICE(hDlg, pDevice);
                            
                            SendDlgItemMessage(hDlg,
                                               IDC_ITEMS,
                                               LB_RESETCONTENT,
                                               0,
                                               0);

                            SendDlgItemMessage(hDlg,
                                               IDC_ATTRIBUTES,
                                               LB_RESETCONTENT,
                                               0,
                                               0);
                            
                            if (NULL != pDevice)
                            {
                                iIndex = (INT) SendDlgItemMessage(hDlg,
                                                                  IDC_TYPE,
                                                                  CB_GETCURSEL,
                                                                  0,
                                                                  0);

                                iItemType = (INT) SendDlgItemMessage(hDlg,
                                                                     IDC_TYPE,
                                                                     CB_GETITEMDATA,
                                                                     iIndex,
                                                                     0);

                                switch(iItemType)
                                {
                                    case INPUT_BUTTON:
                                        vDisplayInputButtons(pDevice,GetDlgItem(hDlg,IDC_ITEMS));
                                        break;

                                    case INPUT_VALUE:
                                         vDisplayInputValues(pDevice,GetDlgItem(hDlg,IDC_ITEMS));
                                         break;

                                    case OUTPUT_BUTTON:
                                        vDisplayOutputButtons(pDevice,GetDlgItem(hDlg,IDC_ITEMS));
                                        break;

                                    case OUTPUT_VALUE:
                                        vDisplayOutputValues(pDevice,GetDlgItem(hDlg,IDC_ITEMS));
                                        break;

                                    case FEATURE_BUTTON:
                                        vDisplayFeatureButtons(pDevice,GetDlgItem(hDlg,IDC_ITEMS));
                                        break;

                                    case FEATURE_VALUE:
                                        vDisplayFeatureValues(pDevice,GetDlgItem(hDlg,IDC_ITEMS));
                                        break;
                                } 

                                PostMessage(hDlg,
                                            WM_COMMAND,
                                            IDC_ITEMS + (LBN_SELCHANGE << 16),
                                            (LPARAM) GetDlgItem(hDlg,IDC_ITEMS));
                            } 
                            break; // case CBN_SELCHANGE

                    } //end switch HIWORD wParam
                    break; //case IDC_TYPE control

                case IDC_ITEMS:
                    switch(HIWORD(wParam))
                    {
                        case LBN_SELCHANGE:

                            iItemType = 0;

                            iIndex = (INT) SendDlgItemMessage(hDlg,
                                                              IDC_TYPE,
                                                              CB_GETCURSEL,
                                                              0,
                                                              0);

                            if (-1 != iIndex)
                            {
                                iItemType = (INT) SendDlgItemMessage(hDlg,
                                                                     IDC_TYPE,
                                                                     CB_GETITEMDATA,
                                                                     iIndex,
                                                                     0);
                            }

                            iIndex = (INT) SendDlgItemMessage(hDlg,
                                                              IDC_ITEMS,
                                                              LB_GETCURSEL,
                                                              0,
                                                              0);

                            switch (iItemType)
                            {
                                case INPUT_BUTTON:
                                case OUTPUT_BUTTON:
                                case FEATURE_BUTTON:

                                    pButtonCaps = NULL;

                                    if (-1 != iIndex)
                                    {
                                        pButtonCaps = (PHIDP_BUTTON_CAPS) SendDlgItemMessage(hDlg,
                                                                                             IDC_ITEMS,
                                                                                             LB_GETITEMDATA,
                                                                                             iIndex,
                                                                                             0);
                                    }

                                    SendDlgItemMessage(hDlg, IDC_ATTRIBUTES, LB_RESETCONTENT, 0, 0);
                                    if (NULL != pButtonCaps)
                                    {
                                        vDisplayButtonAttributes(pButtonCaps, GetDlgItem(hDlg,IDC_ATTRIBUTES));
                                    }
                                    break;

                                case INPUT_VALUE:
                                case OUTPUT_VALUE:
                                case FEATURE_VALUE:

                                    pValueCaps = NULL;

                                    if (-1 != iIndex)
                                    {
                                        pValueCaps = (PHIDP_VALUE_CAPS) SendDlgItemMessage(hDlg,
                                                                                             IDC_ITEMS,
                                                                                             LB_GETITEMDATA,
                                                                                             iIndex,
                                                                                             0);
                                    }

                                    SendDlgItemMessage(hDlg, IDC_ATTRIBUTES, LB_RESETCONTENT, 0, 0);

                                    if (NULL != pValueCaps) 
                                    {
                                        vDisplayValueAttributes(pValueCaps,GetDlgItem(hDlg,IDC_ATTRIBUTES));
                                    }
                                    break;

                                case HID_CAPS:
                                    GET_CURRENT_DEVICE(hDlg, pDevice);

                                    if (NULL != pDevice)
                                    {
                                        vDisplayDeviceCaps(&(pDevice -> Caps),GetDlgItem(hDlg,IDC_ATTRIBUTES));
                                    }
                                    break;

                                case DEVICE_ATTRIBUTES:
                                    GET_CURRENT_DEVICE(hDlg, pDevice);

                                    if (NULL != pDevice) 
                                    {
                                        SendDlgItemMessage(hDlg, IDC_ATTRIBUTES, LB_RESETCONTENT, 0, 0);

                                        vDisplayDeviceAttributes(&(pDevice -> Attributes) ,GetDlgItem(hDlg,IDC_ATTRIBUTES));
                                    }
                                    break;

                            } //end switch iItemType//
                            break; //end case LBN_SELCHANGE in IDC_ITEMS//

                    } //end switch HIWORD wParam//
                    break; //case IDC_ITEMS//

                case IDC_ABOUT:

                    MessageBox(hDlg,
                               "Sample HID client Application.  Microsoft Corp \nCopyright (C) 1997",
                               "About HClient",
                               MB_ICONINFORMATION);
                    break;

                case IDOK:
                case IDCANCEL:

                    //
                    // Destroy the physical device list for exit
                    //

                    DestroyListWithCallback(&PhysicalDeviceList, DestroyDeviceListCallback);

                    EndDialog(hDlg,0);

                    break;

            } //end switch wParam//
            break;

        //
        // For a device change message, we are only concerned about the 
        //    DBT_DEVICEREMOVECOMPLETE and DBT_DEVICEARRIVAL events. I have
        //    yet to determine how to process the device change message
        //    only for HID devices.  Therefore, there are two problems
        //    with the below implementation.  First of all, we must reload
        //    the device list any time a device is added to the system.  
        //    Secondly, at least two DEVICEARRIVAL messages are received 
        //    per HID.  One corresponds to the physical device.  The second
        //    change and any more correspond to each collection on the 
        //    physical device so a system that has one HID device with
        //    two top level collections (a keyboard and a mouse) will receive
        //    three DEVICEARRIVAL/REMOVALs causing the program to reload it's
        //    device list more than once.
        //

        //
        // To handle dynamic changing of devices, we have already registered
        //    notification for both HID class changes and for notification 
        //    for our open file objects.  Since we are only concerned about
        //    arrival/removal of devices, we only need to process those wParam.
        //    lParam points to some sort of DEV_BROADCAST_HDR struct.  For device
        //    arrival, we only deal with the message if that struct is a 
        //    DEV_BROADCAST_DEVICEINTERFACE structure.  For device removal, we're
        //    only concerned if the struct is a DEV_BROADCAST_HANDLE structure.
        //

        case WM_DEVICECHANGE:
            switch (wParam) 
            {
                PDEV_BROADCAST_HDR broadcastHdr;

                case DBT_DEVICEARRIVAL:

                    broadcastHdr = (PDEV_BROADCAST_HDR) lParam;

                    if (DBT_DEVTYP_DEVICEINTERFACE == broadcastHdr -> dbch_devicetype)
                    {
                        PDEV_BROADCAST_DEVICEINTERFACE  pbroadcastInterface;
                        PDEVICE_LIST_NODE               currNode, lastNode;
                        
                        pbroadcastInterface = (PDEV_BROADCAST_DEVICEINTERFACE) lParam;

                        //
                        // Search for a previous instance of this device
                        //  in the device list...In some cases, multiple
                        //  messages are received for the same device.  We
                        //  obviously only want one instance of the device
                        //  showing up in the dialog box.
                        //

                        if (!IsListEmpty(&PhysicalDeviceList)) 
                        {
                            currNode = (PDEVICE_LIST_NODE) GetListHead(&PhysicalDeviceList);
                            lastNode = (PDEVICE_LIST_NODE) GetListTail(&PhysicalDeviceList);
                            
                            //
                            // This loop should always terminate since the device 
                            //  handle should be somewhere in the physical device list
                            //
                            
                            while (1)
                            {
                                if (0 == strcmp(currNode -> HidDeviceInfo.DevicePath, 
                                                pbroadcastInterface -> dbcc_name)) 
                                {
                                    return (TRUE);
                                }
                                
                                if (currNode == lastNode) 
                                {
                                    break;
                                }

                                currNode = (PDEVICE_LIST_NODE) GetNextEntry(currNode);
                            }
                        }

                        //
                        // In this structure, we are given the name of the device
                        //    to open.  So all that needs to be done is open 
                        //    a new hid device with the string
                        //

                        listNode = (PDEVICE_LIST_NODE) malloc(sizeof(DEVICE_LIST_NODE));

                        if (NULL == listNode)
                        {
                            MessageBox(hDlg,
                               "Error -- Couldn't allocate memory for new device list node",
                               HCLIENT_ERROR,
                               MB_ICONEXCLAMATION | MB_OK | MB_TASKMODAL);

                            break;

                        }
                       
                        //
                        // Open the hid device for query access
                        //
                        
                        if (!OpenHidDevice (pbroadcastInterface -> dbcc_name,
                                            FALSE,
                                            FALSE,
                                            FALSE,
                                            FALSE,
                                            &(listNode -> HidDeviceInfo)))
                        {

                            MessageBox(hDlg,
                               "Error -- Couldn't open HID device",
                               HCLIENT_ERROR,
                               MB_ICONEXCLAMATION | MB_OK | MB_TASKMODAL);
                            
                            free(listNode);

                            break;
                        }

                        if (!RegisterHidDevice(hDlg, listNode))
                        {
                            MessageBox(hDlg,
                               "Error -- Couldn't register handle notification",
                               HCLIENT_ERROR,
                               MB_ICONEXCLAMATION | MB_OK | MB_TASKMODAL);

                            CloseHidDevice(&(listNode -> HidDeviceInfo));

                            free(listNode);

                            break;

                        }                         

                        listNode -> DeviceOpened = TRUE;

                        InsertTail(&PhysicalDeviceList, listNode);

                        vLoadDevices(GetDlgItem(hDlg,IDC_DEVICES));

                        PostMessage(hDlg,
                                   WM_COMMAND,
                                   IDC_DEVICES + (CBN_SELCHANGE << 16),
                                   (LPARAM) GetDlgItem(hDlg,IDC_DEVICES));
                                   
                    }
                    break;

                case DBT_DEVICEQUERYREMOVE:

                    //
                    // If this message is received, the device is either
                    //  being disabled or removed through device manager.
                    //  To properly handle this request, we need to close
                    //  the handle to the device.
                    //

                    broadcastHdr = (PDEV_BROADCAST_HDR) lParam;

                    if (DBT_DEVTYP_HANDLE == broadcastHdr -> dbch_devicetype)
                    {
                        PDEV_BROADCAST_HANDLE broadcastHandle;
                        PDEVICE_LIST_NODE     currNode;
                        HANDLE                deviceHandle;
                        
                        broadcastHandle = (PDEV_BROADCAST_HANDLE) lParam;

                        //
                        // Get the file handle of the device that was removed
                        //  from the system
                        //
                        
                        deviceHandle = (HANDLE) broadcastHandle -> dbch_handle;

                        //
                        // Search the physical device list for the handle that
                        //  was removed...
                        //

                        currNode = (PDEVICE_LIST_NODE) GetListHead(&PhysicalDeviceList);

                        //
                        // This loop should always terminate since the device 
                        //  handle should be somewhere in the physical device list
                        //
                        
                        while (currNode -> HidDeviceInfo.HidDevice != deviceHandle)
                        {
                            currNode = (PDEVICE_LIST_NODE) GetNextEntry(currNode);
                        }

                        CloseHidDevice(&(currNode -> HidDeviceInfo));

                        currNode -> DeviceOpened = FALSE;
                    }
                    return (TRUE);

                case DBT_DEVICEREMOVEPENDING:
                case DBT_DEVICEREMOVECOMPLETE:

                    //
                    // Do the same steps for DBT_DEVICEREMOVEPENDING and 
                    //   DBT_DEVICEREMOVECOMPLETE.  We do not receive the 
                    //   remove complete request for a device if it is
                    //   disabled or removed via Device Manager.  However,
                    //   in that case will receive the remove pending.  
                    //   We remove the device from our currently displayed
                    //   list of devices and unregister notification.
                    //
                    
                    broadcastHdr = (PDEV_BROADCAST_HDR) lParam;

                    if (DBT_DEVTYP_HANDLE == broadcastHdr -> dbch_devicetype)
                    {
                        PDEV_BROADCAST_HANDLE broadcastHandle;
                        PDEVICE_LIST_NODE     currNode;
                        HANDLE                deviceHandle;
                        
                        broadcastHandle = (PDEV_BROADCAST_HANDLE) lParam;

                        //
                        // Get the file handle of the device that was removed
                        //  from the system
                        //
                        
                        deviceHandle = (HANDLE) broadcastHandle -> dbch_handle;

                        //
                        // Search the physical device list for the handle that
                        //  was removed...
                        //

                        currNode = (PDEVICE_LIST_NODE) GetListHead(&PhysicalDeviceList);

                        //
                        // This loop should always terminate since the device 
                        //  handle should be somewhere in the physical device list
                        //
                        
                        while (currNode -> HidDeviceInfo.HidDevice != deviceHandle)
                        {
                            currNode = (PDEVICE_LIST_NODE) GetNextEntry(currNode);
                        }

                        //
                        // Node in PhysicalDeviceList has been found, do:
                        //  1) Unregister notification
                        //  2) Close the hid device
                        //  3) Remove the entry from the list
                        //  4) Free the memory for the entry
                        // 
                        //

                        PostMessage(hDlg, 
                                    WM_UNREGISTER_HANDLE, 
                                    0, 
                                    (LPARAM) currNode -> NotificationHandle);

                        //
                        // Close the device if still opened...This would 
                        //  occur on surprise removal.
                        //

                        if (currNode -> DeviceOpened) 
                        {
                            CloseHidDevice(&(currNode -> HidDeviceInfo));
                        }

                        RemoveNode(currNode);

                        free(currNode);
                
                        //
                        // Reload the device list
                        //
                        
                        vLoadDevices(GetDlgItem(hDlg,IDC_DEVICES));

                        PostMessage(hDlg,
                                   WM_COMMAND,
                                   IDC_DEVICES + (CBN_SELCHANGE << 16),
                                   (LPARAM) GetDlgItem(hDlg,IDC_DEVICES));
                    }
                    break;
    
                default:
                    break;
            }
            break;

        //
        // Application specific message used to defer the unregistering of a 
        //  file object for device change notification.  This separte message
        //  is sent when a WM_DEVICECHANGE (DBT_DEVICEREMOVECOMPLETE) has been
        //  received.  The Unregistering of the notification must be deferred
        //  until after the WM_DEVICECHANGE message has been processed or the 
        //  system will deadlock.  The handle that is to be freed will be passed
        //  in as lParam for this message
        //
        
        case WM_UNREGISTER_HANDLE:
            UnregisterDeviceNotification ( (HDEVNOTIFY) lParam ); 
            break;
                           
   } // end switch message
   return FALSE;
} // end MainDlgProc


BOOL 
bParseData(
    PHID_DATA           pData,
    rWriteDataStruct    rWriteData[],
    int                 iCount,
    int                 *piErrorLine
)
{  
    INT       iCap;
    PHID_DATA pWalk;
    BOOL      noError = TRUE;

    pWalk = pData;

    for (iCap = 0; (iCap < iCount) && noError; iCap++)
    {
        //
        // Check to see if our data is a value cap or not
        //

        if (!pWalk->IsButtonData)
        {
            pWalk -> ValueData.Value = atol(rWriteData[iCap].szValue);
        } 
        else
        {
            if (!bSetButtonUsages(pWalk, rWriteData[iCap].szValue) )
            {
               *piErrorLine = iCap;

               noError = FALSE;
            } 
        } 
        pWalk++;
    }
    return (noError);
}

BOOL 
bSetButtonUsages(
    PHID_DATA pCap,
    PCHAR     pszInputString
)
{
    CHAR   szTempString[SMALL_BUFF];
    CHAR   pszDelimiter[] = " ";
    PCHAR  pszToken;
    INT    iLoop;
    PUSAGE pUsageWalk;
    BOOL   bNoError=TRUE;
	HRESULT	stringReturn;

    stringReturn = StringCbCopy(szTempString, SMALL_BUFF, pszInputString);

    pszToken = strtok(szTempString, pszDelimiter);
    
    pUsageWalk = pCap -> ButtonData.Usages;

    memset(pUsageWalk, 0, pCap->ButtonData.MaxUsageLength * sizeof(USAGE));

    for (iLoop = 0; ((ULONG) iLoop < pCap->ButtonData.MaxUsageLength) && (pszToken != NULL) && bNoError; iLoop++)
    {
        *pUsageWalk = (USAGE) atoi(pszToken);

        pszToken = strtok(NULL, pszDelimiter);

        pUsageWalk++;
    } 

     return bNoError;
} //end function bSetButtonUsages//


INT 
iPrepareDataFields(
    PHID_DATA           pData,
    ULONG               ulDataLength, 
    rWriteDataStruct    rWriteData[],
    int                 iMaxElements
)
{
    INT i;
    PHID_DATA pWalk;
	HRESULT   stringReturn;

    pWalk = pData;

    for (i = 0; (i < iMaxElements) && ((unsigned) i < ulDataLength); i++)
    {
        if (!pWalk->IsButtonData) 
        {
            stringReturn = StringCbPrintf(rWriteData[i].szLabel,
                           MAX_LABEL,
                           "ValueCap; ReportID: 0x%x, UsagePage=0x%x, Usage=0x%x",
                           pWalk->ReportID,
                           pWalk->UsagePage,
                           pWalk->ValueData.Usage);
        }
        else
        {
            stringReturn = StringCbPrintf(rWriteData[i].szLabel,
                           MAX_LABEL,
                           "Button; ReportID: 0x%x, UsagePage=0x%x, UsageMin: 0x%x, UsageMax: 0x%x",
                           pWalk->ReportID,
                           pWalk->UsagePage,
                           pWalk->ButtonData.UsageMin,
                           pWalk->ButtonData.UsageMax);
        }
        pWalk++;
     } 
     return i;
}  //end function iPrepareDataFields//


INT_PTR CALLBACK 
bReadDlgProc(
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam
)
{
    static INT                  iLbCounter;
    static CHAR                 szTempBuff[1024];
    static READ_THREAD_CONTEXT  readContext;
    static HANDLE               readThread;
    static HID_DEVICE           syncDevice;
    static HID_DEVICE           asyncDevice;
    static BOOL                 doAsyncReads;
    static BOOL                 doSyncReads;

           PHID_DEVICE          pDevice;
           DWORD                threadID;
           INT                  iIndex;
           PHID_DATA            pData;
           UINT                 uLoop;


    switch(message)
    {
        case WM_INITDIALOG:

            //
            // Initialize the list box counter, the readThread, and the 
            //  readContext.DisplayEvent.
            //
            
            iLbCounter = 0;
            readThread = NULL;
            readContext.DisplayEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

            if (NULL == readContext.DisplayEvent)
            {
                EndDialog(hDlg, 0);
            } 
            
            //
            // Get the opened device information for the device to perform
            //  reads upon
            //
            
            pDevice = (PHID_DEVICE) lParam;

            //
            // To do sync and async reads requires file handles with different
            //  attributes (ie. an async must be opened with the OVERLAPPED flag
            //  set).  The device node that was passed in the context parameter
            //  was not opened for reading.  Therefore, two more devices will
            //  be opened, one for async reads and one for sync reads.
            //
            
            doSyncReads = OpenHidDevice(pDevice -> DevicePath, 
                                       TRUE,
                                       FALSE,
                                       FALSE,
                                       FALSE,
                                       &syncDevice);

            if (!doSyncReads)
            {
                MessageBox(hDlg, 
                           "Unable to open device for synchronous reading",
                           HCLIENT_ERROR,
                           MB_ICONEXCLAMATION);
            }

            //
            // For asynchronous read, default to using the same information
            //    passed in as the lParam.  This is because data related to
            //    Ppd and such cannot be retrieved using the standard HidD_ 
            //    functions.  However, it is necessary to parse future reports.
            //
            
            doAsyncReads = OpenHidDevice(pDevice -> DevicePath, 
                                       TRUE,
                                       FALSE,
                                       TRUE,
                                       FALSE,
                                       &asyncDevice);

            if (!doAsyncReads) 
            {
                MessageBox(hDlg, 
                           "Unable to open device for asynchronous reading",
                           HCLIENT_ERROR,
                           MB_ICONEXCLAMATION);
            }

            PostMessage(hDlg, WM_READ_DONE, 0, 0);
            break; 

        case WM_DISPLAY_READ_DATA:

            //
            // LParam is the device that was read from
            // 

            pDevice = (PHID_DEVICE) lParam;
            
            //
            // Display all the data stored in the Input data field for the device
            //
            
            pData = pDevice -> InputData;

            SendDlgItemMessage(hDlg,
                               IDC_OUTPUT,
                               LB_ADDSTRING,
                               0,
                               (LPARAM)"-------------------------------------------");
                               
            iLbCounter++;

            if (iLbCounter > MAX_LB_ITEMS)
            {
                SendDlgItemMessage(hDlg,
                                   IDC_OUTPUT,
                                   LB_DELETESTRING,
                                   0,
                                   0);
            }

            for (uLoop = 0; uLoop < pDevice->InputDataLength; uLoop++)
            {
                ReportToString(pData, szTempBuff, sizeof(szTempBuff));
          
                iIndex = (INT) SendDlgItemMessage(hDlg,
                                                  IDC_OUTPUT,
                                                  LB_ADDSTRING,
                                                  0,
                                                  (LPARAM) szTempBuff);

                SendDlgItemMessage(hDlg,
                                   IDC_OUTPUT,
                                   LB_SETCURSEL,
                                   iIndex,
                                   0);

                iLbCounter++;

                if (iLbCounter > MAX_LB_ITEMS)
                {
                    SendDlgItemMessage(hDlg,
                                       IDC_OUTPUT,
                                       LB_DELETESTRING,
                                       0,
                                       0);
                }
                pData++;
            }
            SetEvent( readContext.DisplayEvent );
            break;

        case WM_READ_DONE:
            EnableWindow(GetDlgItem(hDlg, IDOK), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_READ_SYNCH), doSyncReads);
            EnableWindow(GetDlgItem(hDlg, IDC_READ_ASYNCH_ONCE), doAsyncReads);
            EnableWindow(GetDlgItem(hDlg, IDC_READ_ASYNCH_CONT), doAsyncReads);

            SetWindowText(GetDlgItem(hDlg, IDC_READ_ASYNCH_ONCE), 
                          "One Asynchronous Read");       

            SetWindowText(GetDlgItem(hDlg, IDC_READ_ASYNCH_CONT),
                          "Continuous Asynchronous Read");       

            readThread = NULL;
            break;
            
        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDC_READ_SYNCH:

                    EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
                    EnableWindow(GetDlgItem(hDlg, IDC_READ_SYNCH), FALSE);
                    EnableWindow(GetDlgItem(hDlg, IDC_READ_ASYNCH_ONCE), FALSE);
                    EnableWindow(GetDlgItem(hDlg, IDC_READ_ASYNCH_CONT), FALSE);                    

                    Read(&syncDevice);

                    PostMessage(hDlg, WM_DISPLAY_READ_DATA, 0, (LPARAM) &syncDevice);
                    PostMessage(hDlg, WM_READ_DONE, 0, 0);

                    break;

                case IDC_READ_ASYNCH_ONCE:
                case IDC_READ_ASYNCH_CONT:

                    //
                    // When these buttons are pushed there are two options:
                    //  1) Start a new asynch read thread (readThread == NULL)
                    //  2) Stop a previous asych read thread
                    //
                    
                    if (NULL == readThread) 
                    {
                        //
                        // Start a new read thread
                        //

                        readContext.HidDevice = &asyncDevice;
                        readContext.TerminateThread = FALSE;
                        readContext.DoOneRead = (IDC_READ_ASYNCH_ONCE == LOWORD(wParam));
                        readContext.DisplayWindow = hDlg;
                        
                        readThread = CreateThread(  NULL,
                                                    0,
                                                    AsynchReadThreadProc,
                                                    &readContext,
                                                    0,
                                                    &threadID);

                        if (NULL == readThread)
                        {
                            MessageBox(hDlg,
                                       "Unable to create read thread",
                                       HCLIENT_ERROR,
                                       MB_ICONEXCLAMATION);
                        }
                        else
                        {
                            EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
                            EnableWindow(GetDlgItem(hDlg, IDC_READ_SYNCH), FALSE);
                            EnableWindow(GetDlgItem(hDlg, IDC_READ_ASYNCH_ONCE),
                                         IDC_READ_ASYNCH_ONCE == LOWORD(wParam));

                            EnableWindow(GetDlgItem(hDlg, IDC_READ_ASYNCH_CONT),
                                         IDC_READ_ASYNCH_CONT == LOWORD(wParam));                                     

                            SetWindowText(GetDlgItem(hDlg, LOWORD(wParam)), 
                                          "Stop Asynchronous Read");
                        }
                    }
                    else
                    {
                        //
                        // Signal the terminate thread variable and
                        //  wait for the read thread to complete.
                        //
                        
                        readContext.TerminateThread = TRUE;
                        WaitForSingleObject(readThread, INFINITE);
                    }                        
                    break;
                        
                case IDCANCEL:
                    readContext.TerminateThread = TRUE;
                    WaitForSingleObject(readThread, INFINITE);
					//Fall through!!!

				case IDOK:                
                    CloseHidDevice(&asyncDevice);                    
                    EndDialog(hDlg,0);
                    break;
            }
            break;
     } // end switch message 
     return FALSE;
} // end bReadDlgProc 

VOID
ReportToString(
   PHID_DATA pData,
   PCHAR     szBuff,
   UINT      iBuffSize
)
{
    PCHAR   pszWalk;
    PUSAGE  pUsage;
    ULONG   i;
	UINT	iRemainingBuffer;
	UINT	iStringLength;
	HRESULT stringReturn;

    //
    // For button data, all the usages in the usage list are to be displayed
    //
    
    if (pData -> IsButtonData)
    {
        stringReturn = StringCbPrintf (szBuff,
                        iBuffSize,
                        "Usage Page: 0x%x, Usages: ",
                        pData -> UsagePage);

        iRemainingBuffer = 0;
		iStringLength = strlen(szBuff);
		pszWalk = szBuff + iStringLength;
		if (iStringLength < iBuffSize)
		{
			iRemainingBuffer = iBuffSize - iStringLength;
		}
		

        for (i = 0, pUsage = pData -> ButtonData.Usages;
                     i < pData -> ButtonData.MaxUsageLength;
                         i++, pUsage++) 
        {
            if (0 == *pUsage)
            {
                break; // A usage of zero is a non button.
            }
            stringReturn = StringCbPrintf (pszWalk, iRemainingBuffer, " 0x%x", *pUsage);
			iRemainingBuffer -= strlen(pszWalk);
			pszWalk += strlen(pszWalk);
        }   
    }
    else
    {
        stringReturn = StringCbPrintf (szBuff,
                        iBuffSize,
                        "Usage Page: 0x%x, Usage: 0x%x, Scaled: %d Value: %d",
                        pData->UsagePage,
                        pData->ValueData.Usage,
                        pData->ValueData.ScaledValue,
                        pData->ValueData.Value);
    }
}

INT_PTR CALLBACK 
bFeatureDlgProc(
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam
)
{
    static PHID_DEVICE       pDevice;
    static INT               iLbCounter;
    static rWriteDataStruct  rWriteData[MAX_WRITE_ELEMENTS];
    static CHAR              szTempBuff[1024];
           INT               iIndex;
           INT               iCount;
           INT               iErrorLine;
           PHID_DATA         pData;
           UINT              uLoop;
		   HRESULT			 stringReturn;

    switch(message)
    {
        case WM_INITDIALOG:
            iLbCounter = 0;
            pDevice = (PHID_DEVICE) lParam;
            break; 

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDC_READ:

                    GetFeature(pDevice);

                    pData = pDevice -> FeatureData;

                    SendDlgItemMessage(hDlg,
                                       IDC_OUTPUT,
                                       LB_ADDSTRING,
                                       0,
                                       (LPARAM)"------------ Read Features ---------------");

                    iLbCounter++;

                    if (iLbCounter > MAX_LB_ITEMS) 
                    {
                        SendDlgItemMessage(hDlg,
                                           IDC_OUTPUT,
                                           LB_DELETESTRING,
                                           0,
                                           0);
                    }

                    for (uLoop = 0; uLoop < pDevice -> FeatureDataLength; uLoop++)
                    {
                        ReportToString(pData, szTempBuff, sizeof(szTempBuff));

                        iIndex = (INT) SendDlgItemMessage(hDlg,
                                                          IDC_OUTPUT,
                                                          LB_ADDSTRING,
                                                          0,
                                                          (LPARAM) szTempBuff);
                                                   
                        SendDlgItemMessage(hDlg,
                                           IDC_OUTPUT,
                                           LB_SETCURSEL,
                                           iIndex,
                                           (LPARAM) 0);

                        iLbCounter++;
                        if (iLbCounter > MAX_LB_ITEMS)
                        {
                            SendDlgItemMessage(hDlg,
                                               IDC_OUTPUT,
                                               LB_DELETESTRING,
                                               0,
                                               0);
                        }
                        pData++;
                    } 
                    break;

                case IDC_WRITE:
                    iCount = iPrepareDataFields(pDevice -> FeatureData, 
                                                pDevice -> FeatureDataLength,
                                                rWriteData,
                                                MAX_OUTPUT_ELEMENTS);

                    if (bGetData(rWriteData, iCount, hDlg, "WRITEFEATURE"))
                    {
                        if (!bParseData(pDevice -> FeatureData, rWriteData,iCount, &iErrorLine)) 
                        {
                            stringReturn = StringCbPrintf(szTempBuff,
                                           sizeof(szTempBuff),
                                           "Unable to parse line %x of output data",
                                           iErrorLine);
                            
                            MessageBox(hDlg,
                                        szTempBuff,
                                        HCLIENT_ERROR,
                                        MB_ICONEXCLAMATION);
                        }
                        else
                        {
                            if ( SetFeature(pDevice) )
                            {
                                SendDlgItemMessage(hDlg,
                                                   IDC_OUTPUT,
                                                   LB_ADDSTRING,
                                                   0,
                                                   (LPARAM)"------------ Write Feature ---------------");                                             
                            }
                            else
                            {
                                 SendDlgItemMessage(hDlg,
                                                    IDC_OUTPUT,
                                                    LB_ADDSTRING,
                                                    0,
                                                    (LPARAM)"------------ Write Feature Error ---------------");                                             
                            }                                                             
                        }
                     }
                     break;
                      
                      
                 case IDOK:
                 case IDCANCEL:
                     EndDialog(hDlg,0);
                     break;
            }
            break;
   } //end switch message//
   return FALSE;
} //end bReadDlgProc//

VOID 
vDisplayDeviceCaps(
    IN PHIDP_CAPS pCaps,
    IN HWND hControl
)
{
    static CHAR szTempBuff[SMALL_BUFF];
	HRESULT		stringReturn;

    SendMessage(hControl, LB_RESETCONTENT, 0, 0);

    stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Usage Page: 0x%x", pCaps -> UsagePage);
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Usage: 0x%x",pCaps -> Usage);
    SendMessage(hControl,LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Input report byte length: %d",pCaps -> InputReportByteLength);
    SendMessage(hControl,LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Output report byte length: %d",pCaps -> OutputReportByteLength);
    SendMessage(hControl,LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Feature report byte length: %d",pCaps -> FeatureReportByteLength);
    SendMessage(hControl,LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Number of collection nodes %d: ", pCaps -> NumberLinkCollectionNodes);
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    return;
}

VOID
vDisplayDeviceAttributes(
    PHIDD_ATTRIBUTES pAttrib,
    HWND hControl
)
{
    static CHAR szTempBuff[SMALL_BUFF];
	HRESULT		stringReturn;

    stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Vendor ID: 0x%x", pAttrib -> VendorID);
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Product ID: 0x%x", pAttrib -> ProductID);
    SendMessage(hControl, LB_ADDSTRING, 0,(LPARAM) szTempBuff);

    stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Version Number  0x%x", pAttrib -> VersionNumber);
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    return;
}

VOID
vDisplayDataAttributes(
    PHIDP_DATA pData, 
    BOOL IsButton, 
    HWND hControl
)
{
    static CHAR szTempBuff[SMALL_BUFF];
	HRESULT		stringReturn;

    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) "================");

    stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Index: 0x%x", pData -> DataIndex);
    SendMessage(hControl,LB_ADDSTRING, 0, (LPARAM) szTempBuff);
    
    stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "IsButton: %s", IsButton ? "TRUE" : "FALSE");
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    if (IsButton) 
    {
        stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Button pressed: %s", pData -> On ? "TRUE" : "FALSE");
        SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);
    }
    else
    {
        stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Data value: 0x%x", pData -> RawValue);
        SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);
    }
}

VOID 
vDisplayButtonAttributes(
    IN PHIDP_BUTTON_CAPS pButton,
    IN HWND hControl
)
{
    static CHAR szTempBuff[SMALL_BUFF];
	HRESULT		stringReturn;
   
    stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Report ID: 0x%x", pButton->ReportID);
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);
     
    stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Usage Page: 0x%x", pButton->UsagePage);
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);
        
    stringReturn = StringCbPrintf(szTempBuff,
                   SMALL_BUFF, 
                   "Alias: %s",
                   pButton -> IsAlias ? "TRUE" : "FALSE");
    
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);
   
    stringReturn = StringCbPrintf(szTempBuff,
                   SMALL_BUFF,
                   "Link Collection: %hu",
                   pButton -> LinkCollection);

    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);
   
    stringReturn = StringCbPrintf(szTempBuff,
                   SMALL_BUFF,
                   "Link Usage Page: 0x%x",
                   pButton -> LinkUsagePage);
 
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);        
   
    stringReturn = StringCbPrintf(szTempBuff,
                   SMALL_BUFF,
                   "Link Usage: 0x%x",
                   pButton -> LinkUsage);

    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    if (pButton->IsRange) 
    {
        stringReturn = StringCbPrintf(szTempBuff,
                       SMALL_BUFF,
                       "Usage Min: 0x%x, Usage Max: 0x%x",
                       pButton->Range.UsageMin, 
                       pButton->Range.UsageMax);
    } 
    else
    {
        stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Usage: 0x%x",pButton->NotRange.Usage);

    } 
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    if (pButton->IsRange)
    {
         stringReturn = StringCbPrintf(szTempBuff,
                        SMALL_BUFF,
                        "Data Index Min: 0x%x, Data Index Max: 0x%x",
                        pButton->Range.DataIndexMin, 
                        pButton->Range.DataIndexMax);

    } 
    else 
    {
        stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "DataIndex: 0x%x",pButton->NotRange.DataIndex);
    } 

    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    if (pButton->IsStringRange)
    {
        stringReturn = StringCbPrintf(szTempBuff,
                       SMALL_BUFF,
                       "String Min: 0x%x, String Max: 0x%x",
                       pButton->Range.StringMin, 
                       pButton->Range.StringMax);
    } 
    else
    {
        stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "String Index: 0x%x",pButton->NotRange.StringIndex);
    } 
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    if (pButton->IsDesignatorRange) 
    {
        stringReturn = StringCbPrintf(szTempBuff,
                       SMALL_BUFF,
                       "Designator Min: 0x%x, Designator Max: 0x%x",
                       pButton->Range.DesignatorMin, 
                       pButton->Range.DesignatorMax);

    } 
    else
    {
        stringReturn = StringCbPrintf(szTempBuff,
                       SMALL_BUFF,
                       "Designator Index: 0x%x",
                       pButton->NotRange.DesignatorIndex);
    } 
    SendMessage(hControl, LB_ADDSTRING, 0,(LPARAM) szTempBuff);

    if (pButton->IsAbsolute)
    {
        SendMessage(hControl, LB_ADDSTRING,0, (LPARAM) "Absolute: Yes");
    }
    else
    {
        SendMessage(hControl, LB_ADDSTRING,0, (LPARAM) "Absolute: No");
    }
    return;
} 

VOID
vDisplayValueAttributes(
    IN PHIDP_VALUE_CAPS pValue,
    HWND hControl
)
{
    static CHAR szTempBuff[SMALL_BUFF];
	HRESULT		stringReturn;

    stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Report ID 0x%x", pValue->ReportID);
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);
 
    stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Usage Page: 0x%x", pValue->UsagePage);
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Bit size: 0x%x", pValue->BitSize);
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Report Count: 0x%x", pValue->ReportCount);
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Unit Exponent: 0x%x", pValue->UnitsExp);
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Has Null: 0x%x", pValue->HasNull);
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);    

 
    if (pValue->IsAlias)
    {
        stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Alias");
    }
    else 
    {
        stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "=====");
    }
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    if (pValue->IsRange)
    {
        stringReturn = StringCbPrintf(szTempBuff,
                       SMALL_BUFF,
                       "Usage Min: 0x%x, Usage Max 0x%x",
                       pValue->Range.UsageMin, 
                       pValue->Range.UsageMax);
    } 
    else
    {
        stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Usage: 0x%x", pValue -> NotRange.Usage);
    } 
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    if (pValue->IsRange)
    {
        stringReturn = StringCbPrintf(szTempBuff,
                       SMALL_BUFF,
                       "Data Index Min: 0x%x, Data Index Max: 0x%x",
                       pValue->Range.DataIndexMin, 
                       pValue->Range.DataIndexMax);
    } 
    else
    {
        stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "DataIndex: 0x%x", pValue->NotRange.DataIndex);
    } 
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    stringReturn = StringCbPrintf(szTempBuff,
                   SMALL_BUFF,
                   "Physical Minimum: %d, Physical Maximum: %d",
                   pValue->PhysicalMin, 
                   pValue->PhysicalMax);

    SendMessage(hControl, LB_ADDSTRING, 0,(LPARAM) szTempBuff);

    stringReturn = StringCbPrintf(szTempBuff,
                   SMALL_BUFF,
                   "Logical Minimum: 0x%x, Logical Maximum: 0x%x",
                   pValue->LogicalMin,
                   pValue->LogicalMax);

    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    if (pValue->IsStringRange) 
    {
       stringReturn = StringCbPrintf(szTempBuff,
                      SMALL_BUFF,
                      "String  Min: 0x%x String Max 0x%x",
                      pValue->Range.StringMin,
                      pValue->Range.StringMax);
    } 
    else
    {
        stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "String Index: 0x%x",pValue->NotRange.StringIndex);
    } 
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

    if (pValue->IsDesignatorRange) 
    {
        stringReturn = StringCbPrintf(szTempBuff,
                       SMALL_BUFF,
                       "Designator Minimum: 0x%x, Max: 0x%x",
                       pValue->Range.DesignatorMin, 
                       pValue->Range.DesignatorMax);
    } 
    else 
    {
        stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Designator Index: 0x%x",pValue->NotRange.DesignatorIndex);
    } 
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);
 
    if (pValue->IsAbsolute) 
    { 
        SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) "Absolute: Yes");
    }
    else
    {
        SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) "Absolute: No");
    }
    return;
}

VOID 
vDisplayInputButtons(
    IN PHID_DEVICE pDevice,
    IN HWND hControl
)
{
    INT               iLoop;
    PHIDP_BUTTON_CAPS pButtonCaps;
    static CHAR       szTempBuff[SMALL_BUFF];
    INT               iIndex;
	HRESULT			  stringReturn;

    SendMessage(hControl, LB_RESETCONTENT, 0, (LPARAM) 0);

    pButtonCaps = pDevice->InputButtonCaps;
    for (iLoop = 0; iLoop < pDevice->Caps.NumberInputButtonCaps; iLoop++) 
    {
        stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Input button cap # %d", iLoop);

        iIndex = (INT) SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

        if (-1 != iIndex)
        {
            SendMessage(hControl, LB_SETITEMDATA, iIndex,(LPARAM) pButtonCaps);
        }

        pButtonCaps++;
    } 
    SendMessage(hControl, LB_SETCURSEL, 0, 0 );
}

VOID 
vDisplayOutputButtons(
   IN PHID_DEVICE pDevice,
   IN HWND hControl
)
{
    INT               iLoop;
    static CHAR       szTempBuff[SMALL_BUFF];
    INT               iIndex;
    PHIDP_BUTTON_CAPS pButtonCaps;
	HRESULT			  stringReturn;

    SendMessage(hControl, LB_RESETCONTENT, 0, (LPARAM) 0);

    pButtonCaps = pDevice -> OutputButtonCaps;

    for (iLoop = 0; iLoop < pDevice->Caps.NumberOutputButtonCaps; iLoop++) 
    {
        stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Output button cap # %d", iLoop);
        iIndex = (INT) SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

        if (-1 != iIndex)
        {
            SendMessage(hControl, LB_SETITEMDATA, iIndex, (LPARAM) pButtonCaps);
        }
        pButtonCaps++;
    }

    SendMessage(hControl, LB_SETCURSEL, 0, 0);
    return;
}

VOID 
vDisplayInputValues(
    IN PHID_DEVICE pDevice,
    IN HWND hControl
)
{
    INT              iLoop;
    static CHAR      szTempBuff[SMALL_BUFF];
    INT              iIndex;
    PHIDP_VALUE_CAPS pValueCaps;
	HRESULT			 stringReturn;

    SendMessage(hControl, LB_RESETCONTENT, 0, 0);

    pValueCaps = pDevice -> InputValueCaps;

    for (iLoop=0; iLoop < pDevice->Caps.NumberInputValueCaps; iLoop++) 
    {
        stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Input value cap # %d",iLoop);
        iIndex = (INT) SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

        if (-1 != iIndex) 
        {
           SendMessage(hControl, LB_SETITEMDATA, iIndex,(LPARAM) pValueCaps);
        }
        pValueCaps++;
    }

    SendMessage(hControl, LB_SETCURSEL, 0, 0);
    return;
}

VOID
vDisplayOutputValues(
    IN PHID_DEVICE pDevice,
    IN HWND hControl)
{
    INT              iLoop;
    static CHAR      szTempBuff[SMALL_BUFF];
    INT              iIndex;
    PHIDP_VALUE_CAPS pValueCaps;
	HRESULT			 stringReturn;
   
    SendMessage(hControl, LB_RESETCONTENT, 0, 0);
    pValueCaps = pDevice -> OutputValueCaps;
   
    for (iLoop = 0; iLoop < pDevice->Caps.NumberOutputValueCaps; iLoop++) 
    {
        stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Output value cap # %d", iLoop);
        iIndex = (INT) SendMessage(hControl, 
                                   LB_ADDSTRING, 
                                   0, 
                                   (LPARAM) szTempBuff);
       
        if (-1 != iIndex) 
        {
            SendMessage(hControl, LB_SETITEMDATA, iIndex, (LPARAM) pValueCaps);
        }
        pValueCaps++;
    }

    SendMessage(hControl, LB_SETCURSEL, 0, 0);

    return;
}

VOID
vDisplayFeatureButtons(
    IN PHID_DEVICE pDevice,
    IN HWND hControl
)
{
    INT               iLoop;
    static CHAR       szTempBuff[SMALL_BUFF];
    INT               iIndex;
    PHIDP_BUTTON_CAPS pButtonCaps;
	HRESULT			  stringReturn;

    SendMessage(hControl, LB_RESETCONTENT, 0, 0);

    pButtonCaps = pDevice -> FeatureButtonCaps;

    for (iLoop = 0; iLoop < pDevice->Caps.NumberFeatureButtonCaps; iLoop++) 
    {
        stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Feature button cap # %d", iLoop);
        iIndex = (INT) SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

        if (-1 != iIndex) 
        {
            SendMessage(hControl, LB_SETITEMDATA, iIndex, (LPARAM) pButtonCaps);
        }
        pButtonCaps++;
    } 
    SendMessage(hControl, LB_SETCURSEL, 0, 0);
    return;
}

VOID
vDisplayFeatureValues(
    IN PHID_DEVICE pDevice,
    IN HWND hControl
)
{
    INT              iLoop;
    static CHAR      szTempBuff[SMALL_BUFF];
    INT              iIndex;
    PHIDP_VALUE_CAPS pValueCaps;
	HRESULT			 stringReturn;

    SendMessage(hControl, LB_RESETCONTENT, 0, 0);
    pValueCaps = pDevice ->FeatureValueCaps;

    for (iLoop = 0; iLoop < pDevice->Caps.NumberFeatureValueCaps; iLoop++) 
    {
        stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Feature value cap # %d", iLoop);
        iIndex = (INT) SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);

        if (-1 != iIndex) 
        {
            SendMessage(hControl, LB_SETITEMDATA, iIndex, (LPARAM) pValueCaps);
        }

        pValueCaps++;
    } 
    SendMessage(hControl, LB_SETCURSEL, 0, 0);
    return;
}

VOID
vLoadItemTypes(
    IN HWND hItemTypes
)
{
    INT iIndex;

    iIndex = (INT) SendMessage(hItemTypes, CB_ADDSTRING, 0, (LPARAM) "INPUT BUTTON");

    if (-1 != iIndex) 
    {
        SendMessage(hItemTypes, CB_SETITEMDATA, iIndex, INPUT_BUTTON);

        iIndex = (INT) SendMessage(hItemTypes, CB_ADDSTRING, 0 ,(LPARAM) "INPUT VALUE");
        if (-1 != iIndex) 
        {
            SendMessage(hItemTypes, CB_SETITEMDATA, iIndex, INPUT_VALUE);
        }

        iIndex = (INT) SendMessage(hItemTypes, CB_ADDSTRING, 0, (LPARAM) "OUTPUT BUTTON");
        if (-1 != iIndex)
        {
            SendMessage(hItemTypes,CB_SETITEMDATA,iIndex,OUTPUT_BUTTON);
        }

        iIndex = (INT) SendMessage(hItemTypes, CB_ADDSTRING, 0, (LPARAM) "OUTPUT VALUE");
        if (-1 != iIndex)
        {
            SendMessage(hItemTypes, CB_SETITEMDATA, iIndex, OUTPUT_VALUE);
        }

        iIndex = (INT) SendMessage(hItemTypes, CB_ADDSTRING, 0, (LPARAM) "FEATURE BUTTON");
        if (-1 != iIndex) 
        {
            SendMessage(hItemTypes, CB_SETITEMDATA, iIndex, FEATURE_BUTTON);
        }

        iIndex = (INT) SendMessage(hItemTypes, CB_ADDSTRING, 0, (LPARAM) "FEATURE VALUE");
        if (-1 != iIndex)
        {
            SendMessage(hItemTypes, CB_SETITEMDATA, iIndex, FEATURE_VALUE);
        }

        iIndex = (INT) SendMessage(hItemTypes, CB_ADDSTRING, 0, (LPARAM) "HID CAPS");
        if (-1 != iIndex )
        {
            SendMessage(hItemTypes, CB_SETITEMDATA, iIndex, HID_CAPS);
        }

        iIndex = (INT) SendMessage(hItemTypes, CB_ADDSTRING, 0, (LPARAM) "DEVICE ATTRIBUTES");
        if (-1 != iIndex)
        {
            SendMessage(hItemTypes, CB_SETITEMDATA, iIndex, DEVICE_ATTRIBUTES);
        }

        SendMessage(hItemTypes, CB_SETCURSEL, 0, 0);
    }
} 

VOID vLoadDevices(
    HWND    hDeviceCombo
)
{
    PDEVICE_LIST_NODE   currNode;
    
    static CHAR szTempBuff[SMALL_BUFF];
    INT         iIndex;
	HRESULT		stringReturn;

    //
    // Reset the content of the device list box.
    //

    SendMessage(hDeviceCombo, CB_RESETCONTENT, 0, 0);


    if (!IsListEmpty(&PhysicalDeviceList))
    {
        currNode = (PDEVICE_LIST_NODE) GetListHead(&PhysicalDeviceList);
          
        do
        {
            stringReturn = StringCbPrintf(szTempBuff,
                           SMALL_BUFF,
                           "Device %d, UsagePage 0%x, Usage 0%x",
                           HandleToULong(currNode -> HidDeviceInfo.HidDevice),
                           currNode -> HidDeviceInfo.Caps.UsagePage,
                           currNode -> HidDeviceInfo.Caps.Usage);

            iIndex = (INT) SendMessage(hDeviceCombo, CB_ADDSTRING, 0, (LPARAM) szTempBuff);

            if (CB_ERR != iIndex) 
            {
                SendMessage(hDeviceCombo, CB_SETITEMDATA, iIndex, (LPARAM) &(currNode -> HidDeviceInfo));
            }

            currNode = (PDEVICE_LIST_NODE) GetNextEntry(currNode);
            
        } while ((PLIST) currNode != &PhysicalDeviceList);
       
    } 

   
    SendMessage(hDeviceCombo, CB_SETCURSEL, 0, 0);
  
    return;
}

BOOL
bGetData(
    prWriteDataStruct pItems,
    INT               iCount,
    HWND              hParent, 
    PCHAR             pszDialogName
)
{
    rGetWriteDataParams        rParams;
    static rWriteDataStruct    arTempItems[MAX_WRITE_ELEMENTS];
    INT                        iResult;


    if (iCount > MAX_WRITE_ELEMENTS) 
    {
        iCount = MAX_WRITE_ELEMENTS;
    }

    memcpy( &(arTempItems[0]), pItems, sizeof(rWriteDataStruct)*iCount);

    rParams.iCount = iCount;
    rParams.prItems = &(arTempItems[0]);

    iResult = (INT) DialogBoxParam(hGInstance,
                                   pszDialogName,
                                   hParent,
                                   bGetDataDlgProc,
                                   (LPARAM) &rParams);
    if (iResult) 
    {
       memcpy(pItems, arTempItems, sizeof(rWriteDataStruct)*iCount);
    }
    return iResult;
} 

INT_PTR CALLBACK 
bGetDataDlgProc(
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam
)
{
    static prWriteDataStruct    prData;
    static prGetWriteDataParams pParams;
    static INT                  iDisplayCount;
    static INT                  iScrollRange;
    static INT                  iCurrentScrollPos=0;
    static HWND                 hScrollBar;
           INT                  iTemp;
           SCROLLINFO           rScrollInfo;
           INT                  iReturn;

    switch(message) 
    {
        case WM_INITDIALOG:

            pParams = (prGetWriteDataParams) lParam;
            prData = pParams -> prItems;
            hScrollBar = GetDlgItem(hDlg, IDC_SCROLLBAR);

            if (pParams -> iCount > CONTROL_COUNT) 
            {
                iDisplayCount = CONTROL_COUNT;
                iScrollRange = pParams -> iCount - CONTROL_COUNT;
                rScrollInfo.fMask = SIF_RANGE | SIF_POS;
                rScrollInfo.nPos = 0;
                rScrollInfo.nMin = 0;
                rScrollInfo.nMax = iScrollRange;
                rScrollInfo.cbSize = sizeof(rScrollInfo);
                rScrollInfo.nPage = CONTROL_COUNT;
                iReturn = SetScrollInfo(hScrollBar,SB_CTL,&rScrollInfo,TRUE);
            }
            else
            {
                iDisplayCount=pParams->iCount;
                EnableWindow(hScrollBar,FALSE);
            }
            vWriteDataToControls(hDlg, prData, 0, pParams->iCount);
            break;

        case WM_COMMAND:
            switch(LOWORD(wParam)) 
            {
                case IDOK:
                case ID_SEND:
                    vReadDataFromControls(hDlg, prData, iCurrentScrollPos, iDisplayCount);
                    EndDialog(hDlg,1);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg,0);
                    break;
             } 
             break;

        case WM_VSCROLL:
            vReadDataFromControls(hDlg, prData, iCurrentScrollPos, iDisplayCount);

            switch(LOWORD(wParam)) 
            {
                case SB_LINEDOWN:
                    ++iCurrentScrollPos;
                    break;

                case SB_LINEUP:
                    --iCurrentScrollPos;
                    break;

                case SB_THUMBPOSITION:
                    iCurrentScrollPos = HIWORD(wParam);

                case SB_PAGEUP:
                    iCurrentScrollPos -= CONTROL_COUNT;
                    break;

                case SB_PAGEDOWN:
                    iCurrentScrollPos += CONTROL_COUNT;
                    break;
            }

            if (iCurrentScrollPos < 0) 
            {
                iCurrentScrollPos = 0;
            }
             
            if (iCurrentScrollPos > iScrollRange)
            {
                iCurrentScrollPos = iScrollRange; 
            }

            SendMessage(hScrollBar, SBM_SETPOS, iCurrentScrollPos, TRUE);
            iTemp = LOWORD(wParam);

            if ( (iTemp == SB_LINEDOWN) || (iTemp == SB_LINEUP) || (iTemp == SB_THUMBPOSITION)|| (iTemp == SB_PAGEUP) || (iTemp==SB_PAGEDOWN) )
            {
                vWriteDataToControls(hDlg, prData, iCurrentScrollPos, iDisplayCount);
            }
            break; 
    } 
    return FALSE;
} //end function bGetDataDlgProc//

VOID
vReadDataFromControls(
    HWND hDlg,
    prWriteDataStruct prData,
    INT iOffset,
    INT iCount
)
{
    INT               iLoop;
    INT               iValueControlID = IDC_OUT_EDIT1;
    prWriteDataStruct pDataWalk;
    HWND              hValueWnd;

    pDataWalk = prData + iOffset;
    for (iLoop = 0; (iLoop < iCount) && (iLoop < CONTROL_COUNT); iLoop++) 
    {
        hValueWnd = GetDlgItem(hDlg, iValueControlID);

        GetWindowText(hValueWnd, pDataWalk -> szValue, MAX_VALUE);

        iValueControlID++;

        pDataWalk++;
    } 

    return;
} 

VOID
vWriteDataToControls(
    HWND                hDlg,
    prWriteDataStruct   prData,
    INT                 iOffset,
    INT                 iCount
)
{
    INT               iLoop;
    INT               iLabelControlID = IDC_OUT_LABEL1;
    INT               iValueControlID = IDC_OUT_EDIT1;
    HWND              hLabelWnd, hValueWnd;
    prWriteDataStruct pDataWalk;

    pDataWalk = prData + iOffset;

    for (iLoop = 0; (iLoop < iCount) && (iLoop < CONTROL_COUNT); iLoop++) 
    {
         hLabelWnd = GetDlgItem(hDlg, iLabelControlID);
         hValueWnd = GetDlgItem(hDlg, iValueControlID);
         
         ShowWindow(hLabelWnd, SW_SHOW);
         ShowWindow(hValueWnd, SW_SHOW);
         
         SetWindowText(hLabelWnd, pDataWalk -> szLabel);
         SetWindowText(hValueWnd, pDataWalk -> szValue);
         
         iLabelControlID++;
         iValueControlID++;
         pDataWalk++;
    }     
     
    //
    // Hide the controls
    //

    for (; iLoop < CONTROL_COUNT; iLoop++) 
    {
        hLabelWnd = GetDlgItem(hDlg,iLabelControlID);
        hValueWnd = GetDlgItem(hDlg,iValueControlID);
        
        ShowWindow(hLabelWnd,SW_HIDE);
        ShowWindow(hValueWnd,SW_HIDE);
        
        iLabelControlID++;
        iValueControlID++;
     } 
} 

VOID
vCreateUsageString(
    IN  PUSAGE   pUsageList,
    OUT CHAR     szString[]
)
{
    HRESULT stringReturn;
	
	stringReturn = StringCbPrintf(szString,
                   SMALL_BUFF,
                   "Usage: %#04x",
                   *pUsageList);

    return;
}

VOID
vCreateUsageAndPageString(
    IN  PUSAGE_AND_PAGE pUsageList,
    OUT CHAR            szString[]
)
{
    HRESULT stringReturn;
	
	stringReturn = StringCbPrintf(szString,
                   SMALL_BUFF,
                   "Usage Page: %#04x  Usage: %#04x",
                   pUsageList -> UsagePage,
                   pUsageList -> Usage);

    return;
}

VOID
vDisplayLinkCollectionNode(
    IN  PHIDP_LINK_COLLECTION_NODE  pLCNode,
    IN  ULONG                       ulLinkIndex,
    IN  HWND                        hControl
)
{
    static CHAR szTempBuff[SMALL_BUFF];
	HRESULT		stringReturn;

    stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Index: 0x%x", ulLinkIndex);
    SendMessage(hControl, LB_ADDSTRING, 0, (LPARAM) szTempBuff);
    
    stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Usage Page: 0x%x", pLCNode -> LinkUsagePage);
    SendMessage(hControl, LB_ADDSTRING,0, (LPARAM)szTempBuff);

    stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Usage: 0x%x", pLCNode -> LinkUsage);
    SendMessage(hControl, LB_ADDSTRING,0, (LPARAM) szTempBuff);

    stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Parent Index: 0x%x", pLCNode -> Parent);
    SendMessage(hControl, LB_ADDSTRING,0, (LPARAM) szTempBuff);

    stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Number of Children: 0x%x", pLCNode -> NumberOfChildren);
    SendMessage(hControl, LB_ADDSTRING,0, (LPARAM) szTempBuff);

    stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "Next Sibling: 0x%x", pLCNode -> NextSibling);
    SendMessage(hControl, LB_ADDSTRING,0, (LPARAM) szTempBuff);

    stringReturn = StringCbPrintf(szTempBuff, SMALL_BUFF, "First Child: 0x%x", pLCNode -> FirstChild);
    SendMessage(hControl, LB_ADDSTRING,0, (LPARAM) szTempBuff);

    return;
}

VOID
vCreateUsageValueStringFromArray(
    PCHAR       pBuffer,
    USHORT      BitSize,
    USHORT      UsageIndex,
    CHAR        szString[]
)
/*++
Routine Description:
    Given a report buffer, pBuffer, this routine extracts the given usage
    at UsageIndex from the array and outputs to szString the string
    representation of that value.  The input parameter BitSize specifies
    the number of bits representing that value in the array.  This is
    useful for extracting individual members of a UsageValueArray.
--*/
{
    INT         iByteIndex;
    INT         iByteOffset;
    UCHAR       ucLeftoverBits;
    ULONG       ulMask;
    ULONG       ulValue;
	HRESULT		stringReturn;

    //
    // Calculate the byte and byte offset into the buffer for the given
    //   index value
    //
    
    iByteIndex = (UsageIndex * BitSize) >> 3;
    iByteOffset = (UsageIndex * BitSize) & 7;

    //
    // Extract the 32-bit value beginning at ByteIndex.  This value
    //   will contain some or all of the value we are attempting to retrieve
    //
    
    ulValue = *(PULONG) (pBuffer + iByteIndex);

    //
    // Shift that value to the right by our byte offset..
    //
    
    ulValue = ulValue >> iByteOffset;

    //
    // At this point, ulValue contains the first 32-iByteOffset bits beginning
    //    the appropriate offset in the buffer.  There are now two cases to 
    //    look at:
    //      
    //    1) BitSize > 32-iByteOffset -- In which case, we need to extract
    //                                   iByteOffset bits from the next
    //                                   byte in the array and OR them as
    //                                   the MSBs of ulValue
    //
    //    2) BitSize < 32-iByteOffset -- Need to get only the BitSize LSBs
    //                                   
    //

    //
    // Case #1
    //
    
    if (BitSize > sizeof(ULONG)*8 - iByteOffset) 
    {
        //
        // Get the next byte of the report following the four bytes we
        //   retrieved earlier for ulValue
        //
        
        ucLeftoverBits =  *(pBuffer+iByteIndex+4);

        //
        // Shift those bits to the left for anding to our previous value
        //
        
        ulMask = ucLeftoverBits << (24 + (8 - iByteOffset));
        ulValue |= ulMask;

    }
    else if (BitSize < sizeof(ULONG)*8 - iByteOffset) 
    {
        //
        // Need to mask the most significant bits that are part of another
        //    value(s), not the one we are currently working with.
        //
        
        ulMask = (1 << BitSize) - 1;
        ulValue &= ulMask;
    }
    
    //
    // We've now got the correct value, now output to the string
    //

    stringReturn = StringCbPrintf(szString, SMALL_BUFF, "Usage value: %lu", ulValue);

    return;
}


BOOL
RegisterHidDevice(
    IN  HWND                WindowHandle,
    IN  PDEVICE_LIST_NODE   DeviceNode
)
{
    DEV_BROADCAST_HANDLE broadcastHandle;
    
    broadcastHandle.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
    broadcastHandle.dbch_devicetype = DBT_DEVTYP_HANDLE;
    broadcastHandle.dbch_handle = DeviceNode -> HidDeviceInfo.HidDevice;

    DeviceNode -> NotificationHandle = RegisterDeviceNotification( 
                                                WindowHandle,
                                                &broadcastHandle,
                                                DEVICE_NOTIFY_WINDOW_HANDLE);

    return (NULL != DeviceNode -> NotificationHandle);
}   

VOID
DestroyDeviceListCallback(
    PLIST_NODE_HDR   ListNode
)
{
    PDEVICE_LIST_NODE   deviceNode;

    deviceNode = (PDEVICE_LIST_NODE) ListNode;
    
    //
    // The callback function needs to do the following steps...
    //   1) Close the HidDevice
    //   2) Unregister device notification (if registered)
    //   3) Free the allocated memory block
    //

    CloseHidDevice(&(deviceNode -> HidDeviceInfo));

    if (NULL != deviceNode -> NotificationHandle) 
    {
        UnregisterDeviceNotification(deviceNode -> NotificationHandle);
    }

    free (deviceNode);

    return;
}

DWORD WINAPI
AsynchReadThreadProc( 
    PREAD_THREAD_CONTEXT    Context
)
{
    HANDLE  completionEvent;
    BOOL    readStatus;
    DWORD   waitStatus;
    
    //
    // Create the completion event to send to the the OverlappedRead routine
    //

    completionEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    //
    // If NULL returned, then we cannot proceed any farther so we just exit the 
    //  the thread
    //
    
    if (NULL == completionEvent) 
    {
        goto AsyncRead_End;
    }

    //
    // Now we enter the main read loop, which does the following:
    //  1) Calls ReadOverlapped()
    //  2) Waits for read completion with a timeout just to check if 
    //      the main thread wants us to terminate our the read request
    //  3) If the read fails, we simply break out of the loop
    //      and exit the thread
    //  4) If the read succeeds, we call UnpackReport to get the relevant
    //      info and then post a message to main thread to indicate that
    //      there is new data to display.
    //  5) We then block on the display event until the main thread says
    //      it has properly displayed the new data
    //  6) Look to repeat this loop if we are doing more than one read
    //      and the main thread has yet to want us to terminate
    //

    do 
    {
        //
        // Call ReadOverlapped() and if the return status is TRUE, the ReadFile
        //  succeeded so we need to block on completionEvent, otherwise, we just
        //  exit
        //

        readStatus = ReadOverlapped( Context -> HidDevice, completionEvent );

    
        if (!readStatus) 
        {
           break;
        }

        while (!Context -> TerminateThread) 
        {
            //
            // Wait for the completion event to be signaled or a timeout
            //
            
            waitStatus = WaitForSingleObject (completionEvent, READ_THREAD_TIMEOUT );

            //
            // If completionEvent was signaled, then a read just completed
            //   so let's leave this loop and process the data
            //
            
            if ( WAIT_OBJECT_0 == waitStatus)
            { 
                break;
            }
        }

        //
        // Check the TerminateThread again...If it is not set, then data has
        //  been read.  In this case, we want to Unpack the report into our
        //  input info and then send a message to the main thread to display
        //  the new data.
        //
        
        if (!Context -> TerminateThread) 
        {
            UnpackReport(Context -> HidDevice -> InputReportBuffer,
                          Context -> HidDevice -> Caps.InputReportByteLength,
                          HidP_Input,
                          Context -> HidDevice -> InputData,
                          Context -> HidDevice -> InputDataLength,
                          Context -> HidDevice -> Ppd);
            
            if (NULL != Context -> DisplayEvent) 
            { 
                PostMessage(Context -> DisplayWindow,
                            WM_DISPLAY_READ_DATA,
                            0,
                            (LPARAM) Context -> HidDevice);

                WaitForSingleObject( Context -> DisplayEvent, INFINITE );
            }
        }
    } while ( !Context -> TerminateThread && !Context -> DoOneRead );


AsyncRead_End:

    PostMessage( Context -> DisplayWindow, WM_READ_DONE, 0, 0);
    ExitThread(0);
    return (0);
}

DWORD WINAPI
SynchReadThreadProc(
    PREAD_THREAD_CONTEXT    Context
)
{
    do 
    {
        Read(Context -> HidDevice);

        UnpackReport(Context -> HidDevice -> InputReportBuffer,
                     Context -> HidDevice -> Caps.InputReportByteLength,
                     HidP_Input,
                     Context -> HidDevice -> InputData,
                     Context -> HidDevice -> InputDataLength,
                     Context -> HidDevice -> Ppd);

        if (NULL != Context -> DisplayEvent) 
        {
            PostMessage(Context -> DisplayWindow,
                        WM_DISPLAY_READ_DATA,
                        0,
                        (LPARAM) Context -> HidDevice);

            WaitForSingleObject( Context -> DisplayEvent, INFINITE );
        }
    } while ( !Context -> TerminateThread && !Context -> DoOneRead );

    PostMessage( Context -> DisplayWindow, WM_READ_DONE, 0, 0);
    ExitThread(0);
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\client\hclient\buffers.h ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    buffers.h

Abstract:

    This module declares the functions that and structures that are visible
    to other modules.

Environment:

    User mode

Revision History:

    May-98 : Created 

--*/

#ifndef _BUFFERS_H_
#define _BUFFERS_H_

typedef struct _REPORT_BUFFER
{
    PUCHAR      pBuffer;
    INT         iBufferSize;
    UCHAR       ucReportID;

} REPORT_BUFFER, *PREPORT_BUFFER;
    
typedef struct _BUFFER_DISPALY 
{
    HWND                hBufferComboBox;
    HWND                hBufferEditBox;
    INT                 iBufferSize;
    INT                 iCurrSelectionIndex;
    INT                 nReportBuffers;
    PREPORT_BUFFER      ReportBuffers;
    HIDP_REPORT_TYPE    ReportType;
} BUFFER_DISPLAY, *PBUFFER_DISPLAY;

BOOLEAN
BufferDisplay_Init(
    IN  HWND                hCB,
    IN  HWND                hEB,
    IN  INT                 nBuffers,
    IN  INT                 iBufferSize,
    IN  HIDP_REPORT_TYPE    RType,
    OUT PBUFFER_DISPLAY     *ppBufferDisplay
);

VOID
BufferDisplay_Destroy(
    IN  PBUFFER_DISPLAY     pBufferDisplay
);

VOID
BufferDisplay_ChangeSelection(
    IN  PBUFFER_DISPLAY     pBufferDisplay
);

BOOLEAN
BufferDisplay_UpdateBuffer(
    IN  PBUFFER_DISPLAY     pBufferDisplay,
    IN  PCHAR               pNewBuffer
);

INT
BufferDisplay_GetBufferSize(
    IN  PBUFFER_DISPLAY      pBufferDisplay
);

VOID
BufferDisplay_CopyCurrentBuffer(
    IN  PBUFFER_DISPLAY     pBufferDisplay,
    OUT PCHAR               pCopyBuffer
);

INT
BufferDisplay_GetCurrentBufferNumber(
    IN  PBUFFER_DISPLAY      pBufferDisplay
);

UCHAR
BufferDisplay_GetCurrentReportID(
    IN  PBUFFER_DISPLAY      pBufferDisplay
);

VOID
BufferDisplay_OutputBuffer(
    HWND            hEditBox,
    PREPORT_BUFFER  pReportBuffer
);

VOID
BufferDisplay_ClearBuffer(
    IN  PBUFFER_DISPLAY pBufferDisplay
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\client\hclient\ecdisp.c ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    ecdisp.c

Abstract:

    This module contains the code to handle the extended calls dialog box
    and the actions that can be performed in the dialog box.

Environment:

    User mode

Revision History:

    May-98 : Created 

--*/

/*****************************************************************************
/* Extended call display include files
/*****************************************************************************/
#include <windows.h>
#include <limits.h>
#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <setupapi.h>
#include <vfw.h>
#include <assert.h>
#include "hidusage.h"
#include "hidsdi.h"
#include "hid.h"
#include "hclient.h"
#include "resource.h"
#include "buffers.h"
#include "ecdisp.h"
#include "strings.h"
#include <strsafe.h>

/*****************************************************************************
/* Local macro definitions for the supported function calls
/*****************************************************************************/

#define HID_DEVCALLS                    20
#define HID_PPDCALLS                    29

#define HID_NUMCALLS                    HID_DEVCALLS + HID_PPDCALLS

#define HIDD_GET_HID_GUID              1
#define HIDD_GET_FREE_PREPARSED_DATA   2
#define HIDD_GET_CONFIGURATION         3
#define HIDD_SET_CONFIGURATION         4
#define HIDD_FLUSH_QUEUE               5
#define HIDD_GET_ATTRIBUTES            6
#define HIDD_SET_FEATURE               7
#define HIDD_GET_FEATURE               8
#define HIDD_GET_INPUT_REPORT          9
#define HIDD_SET_OUTPUT_REPORT        10
#define HIDD_GET_NUM_INPUT_BUFFERS    11
#define HIDD_SET_NUM_INPUT_BUFFERS    12
#define HIDD_GET_PHYSICAL_DESCRIPTOR  13
#define HIDD_GET_MANUFACTURER_STRING  14
#define HIDD_GET_PRODUCT_STRING       15
#define HIDD_GET_INDEXED_STRING       16
#define HIDD_GET_SERIAL_NUMBER_STRING 17
#define HIDD_GET_MS_GENRE_DESCRIPTOR  18
#define HID_READ_REPORT               19
#define HID_WRITE_REPORT              20
#define HIDP_GET_BUTTON_CAPS          21
#define HIDP_GET_BUTTONS              22
#define HIDP_GET_BUTTONS_EX           23
#define HIDP_GET_CAPS                 24 
#define HIDP_GET_DATA                 25
#define HIDP_GET_EXTENDED_ATTRIBUTES  26
#define HIDP_GET_LINK_COLL_NODES      27
#define HIDP_GET_SCALED_USAGE_VALUE   28
#define HIDP_GET_SPECIFIC_BUTTON_CAPS 29
#define HIDP_GET_SPECIFIC_VALUE_CAPS  30
#define HIDP_GET_USAGES               31
#define HIDP_GET_USAGES_EX            32
#define HIDP_GET_USAGE_VALUE          33
#define HIDP_GET_USAGE_VALUE_ARRAY    34
#define HIDP_GET_VALUE_CAPS           35
#define HIDP_INITIALIZE_REPORT_FOR_ID 36
#define HIDP_MAX_DATA_LIST_LENGTH     37
#define HIDP_MAX_USAGE_LIST_LENGTH    38
#define HIDP_SET_BUTTONS              39
#define HIDP_SET_DATA                 40
#define HIDP_SET_SCALED_USAGE_VALUE   41
#define HIDP_SET_USAGES               42
#define HIDP_SET_USAGE_VALUE          43
#define HIDP_SET_USAGE_VALUE_ARRAY    44
#define HIDP_TRANSLATE_USAGES         45
#define HIDP_UNSET_BUTTONS            46
#define HIDP_UNSET_USAGES             47
#define HIDP_USAGE_LIST_DIFFERENCE    48
#define HID_CLEAR_REPORT              49

/*
// These two definitions are not used by the display routines since 
//    the two functions were molded together into one for purpose of execution
*/

#define HIDD_GET_PREPARSED_DATA       50
#define HIDD_FREE_PREPARSED_DATA      51


#define IS_HIDD_FUNCTION(func)        (((func) >= HIDD_GET_HID_GUID) && \
                                       ((func) <= HIDD_GET_MS_GENRE_DESCRIPTOR))


#define IS_HIDP_FUNCTION(func)        (((func) >= HIDP_GET_BUTTON_CAPS) && \
                                       ((func) <= HIDP_USAGE_LIST_DIFFERENCE))

#define IS_HID_FUNCTION(func)         (((func) >= HID_READ_REPORT) && \
                                       ((func) <= HID_WRITE_REPORT))

#define IS_NOT_IMPLEMENTED(func)      (((func) == HIDD_GET_CONFIGURATION) || \
                                      ((func) == HIDD_SET_CONFIGURATION) || \
                                      ((func) == HIDP_TRANSLATE_USAGES) || \
                                      (((func) == HIDP_INITIALIZE_REPORT_FOR_ID) && \
                                       (NULL == pfnHidP_InitializeReportForID)) || \
                                      (((func) == HIDP_GET_EXTENDED_ATTRIBUTES) && \
                                       (NULL == pfnHidP_GetExtendedAttributes)))

/*****************************************************************************
/* Local macro definitions for buffer display sizes
/*****************************************************************************/

#define NUM_INPUT_BUFFERS       16
#define NUM_OUTPUT_BUFFERS      16
#define NUM_FEATURE_BUFFERS     16

/*****************************************************************************
/* Local macro definition for HidP_SetData dialog box
/*****************************************************************************/

#define SETDATA_LISTBOX_FORMAT  "Index: %u,  DataValue: %u"

/*****************************************************************************
/* Local macro definition for display output to output windows
/*****************************************************************************/

#define TEMP_BUFFER_SIZE 1024
#define OUTSTRING(win, str)         SendMessage(win, LB_ADDSTRING, 0, (LPARAM) str)
#define OUTWSTRING(win, str) \
{ \
    SIZE_T  nBytes; \
\
    nBytes = wcstombs(szTempBuffer, str, TEMP_BUFFER_SIZE-1); \
    if ((SIZE_T) -1 == nBytes) { \
        OUTSTRING(win, "Cannot convert wide-character string"); \
    } \
    else { \
        szTempBuffer[nBytes] = '\0'; \
        OUTSTRING(win, szTempBuffer); \
    } \
}

#define DISPLAY_HIDD_STATUS(win, func, status, strret) \
{ \
    strret = StringCbPrintf(szTempBuffer, \
                   TEMP_BUFFER_SIZE,  \
                   "%s returned: %s", \
                   func, \
                   (status).IsHidError ? "FALSE" : "TRUE"); \
\
    OUTSTRING(win, szTempBuffer); \
\
    if ((status).IsHidError) { \
        strret = StringCbPrintf(szTempBuffer, \
                       TEMP_BUFFER_SIZE, \
                       "ErrorCode: %d", \
                       GetLastError()); \
    }\
    OUTSTRING(win, szTempBuffer); \
}

#define DISPLAY_HIDP_STATUS(win, func, status, strret) \
{ \
    strret = StringCbPrintf(szTempBuffer, \
                   TEMP_BUFFER_SIZE, \
                   "%s returned: %s", \
                   func, \
                   ECDisp_GetHidAppStatusString(status.HidErrorCode)); \
\
    OUTSTRING(win, szTempBuffer); \
}

#define ECDISP_ERROR(win, msg) \
{ \
    MessageBox(win, \
               msg, \
               HCLIENT_ERROR, \
               MB_ICONEXCLAMATION); \
}

#define GET_FUNCTION_NAME(index)     ResolveFunctionName(index)


/*****************************************************************************
/* Local macro definition for retrieving data based on report type
/*****************************************************************************/
#define SELECT_ON_REPORT_TYPE(rt, ival, oval, fval, res) \
{ \
    switch ((rt)) { \
    case HidP_Input: \
        (res) = (ival); \
        break; \
\
    case HidP_Output: \
        (res) = (oval); \
        break; \
\
    case HidP_Feature: \
        (res) = (fval); \
        break; \
\
    } \
}

/*****************************************************************************
/* Local macro definition for calculating size of a usage value array buffer
/*****************************************************************************/
#define ROUND_TO_NEAREST_BYTE(val)  (((val) % 8) ? ((val) / 8) + 1 : ((val) / 8))

/*****************************************************************************
/* Data types local to this module
/*****************************************************************************/

typedef struct _FUNCTION_NAMES
{
    UINT uiIndex;
    char *szFunctionName;
} FUNCTION_NAMES;

typedef struct _PARAMETER_STATE 
{
    BOOL fInputReport;
    BOOL fOutputReport;
    BOOL fFeatureReport;
    BOOL fReportID;
    BOOL fUsagePage;
    BOOL fUsage;
    BOOL fLinkCollection;
    BOOL fInputReportSelect;
    BOOL fOutputReportSelect;
    BOOL fFeatureReportSelect;
} PARAMETER_STATE;

typedef enum { DLGBOX_INIT_FAILED = -1, DLGBOX_ERROR, DLGBOX_CANCEL, DLGBOX_OK } DLGBOX_STATUS;

typedef struct _ECDISPLAY_PARAMS 
{
    HIDP_REPORT_TYPE          ReportType;
    USAGE                     UsagePage;
    USAGE                     Usage;
    USHORT                    LinkCollection;
    UCHAR                     ReportID;
    PCHAR                     szListString;
    PCHAR                     szListString2;
    PUSAGE                    UsageList;
    PUSAGE                    UsageList2;
    ULONG                     ListLength;
    ULONG                     ListLength2;
    ULONG                     Index;
    union {
        PHIDP_DATA            pDataList;
        PULONG                pValueList;
        LONG                  ScaledValue;
        ULONG                 Value;
    };
} ECDISPLAY_PARAMS, *PECDISPLAY_PARAMS;

typedef struct _READ_PARAMS
{
    PHID_DEVICE device;
    BOOLEAN     stopThread;
} READ_PARAMS, *PREAD_PARAMS;
    
/*****************************************************************************
/* Local data variables
/*****************************************************************************/

static CHAR             szTempBuffer[TEMP_BUFFER_SIZE];

static PBUFFER_DISPLAY  pInputDisplay;
static PBUFFER_DISPLAY  pOutputDisplay;
static PBUFFER_DISPLAY  pFeatureDisplay;

static FUNCTION_NAMES DeviceCalls[HID_DEVCALLS] = {
                             { HIDD_GET_HID_GUID,               "HidD_GetHidGuid" },
                             { HIDD_GET_FREE_PREPARSED_DATA,    "HidD_GetFreePreparsedData" },
                             { HIDD_GET_CONFIGURATION,          "HidD_GetConfiguration" },
                             { HIDD_SET_CONFIGURATION,          "HidD_SetConfiguration" },
                             { HIDD_FLUSH_QUEUE,                "HidD_FlushQueue" },
                             { HIDD_GET_ATTRIBUTES,             "HidD_GetAttributes" },
                             { HIDD_SET_FEATURE,                "HidD_SetFeature" },
                             { HIDD_GET_FEATURE,                "HidD_GetFeature" },
                             { HIDD_GET_INPUT_REPORT,           "HIDD_GetInputReport" },
                             { HIDD_SET_OUTPUT_REPORT,          "HidD_SetOutputReport" },
                             { HIDD_GET_NUM_INPUT_BUFFERS,      "HidD_GetNumInputBuffers" },
                             { HIDD_SET_NUM_INPUT_BUFFERS,      "HidD_SetNumInputBuffers" },
                             { HIDD_GET_PHYSICAL_DESCRIPTOR,    "HidD_GetPhysicalDescriptor" },
                             { HIDD_GET_MANUFACTURER_STRING,    "HidD_GetManufacturerString" },
                             { HIDD_GET_PRODUCT_STRING,         "HidD_GetProductString" },
                             { HIDD_GET_INDEXED_STRING,         "HidD_GetIndexedString" },
                             { HIDD_GET_SERIAL_NUMBER_STRING,   "HidD_GetSerialNumberString" },
                             { HIDD_GET_MS_GENRE_DESCRIPTOR,    "HidD_GetMsGenreDescriptor" },
                             { HID_READ_REPORT,                 "Read Input Report"        },
                             { HID_WRITE_REPORT,                "Write Report Buffer"      }

};

static FUNCTION_NAMES PpdCalls[HID_PPDCALLS] = {
                             { HIDP_GET_BUTTON_CAPS,            "HidP_GetButtonCaps" },
                             { HIDP_GET_BUTTONS,                "HidP_GetButtons" },
                             { HIDP_GET_BUTTONS_EX,             "HidP_GetButtonsEx" },
                             { HIDP_GET_CAPS,                   "HidP_GetCaps" },
                             { HIDP_GET_DATA,                   "HidP_GetData" },
                             { HIDP_GET_EXTENDED_ATTRIBUTES,    "HidP_GetExtendedAttributes" },
                             { HIDP_GET_LINK_COLL_NODES,        "HidP_GetLinkCollectionNodes" },
                             { HIDP_GET_SCALED_USAGE_VALUE,     "HidP_GetScaledUsageValue" },
                             { HIDP_GET_SPECIFIC_BUTTON_CAPS,   "HidP_GetSpecificButtonCaps" },
                             { HIDP_GET_SPECIFIC_VALUE_CAPS,    "HidP_GetSpecificValueCaps" },
                             { HIDP_GET_USAGES,                 "HidP_GetUsages" },
                             { HIDP_GET_USAGES_EX,              "HidP_GetUsagesEx" },
                             { HIDP_GET_USAGE_VALUE,            "HidP_GetUsageValue" },
                             { HIDP_GET_USAGE_VALUE_ARRAY,      "HidP_GetUsageValueArray" },
                             { HIDP_GET_VALUE_CAPS,             "HidP_GetValueCaps" },
                             { HIDP_INITIALIZE_REPORT_FOR_ID,   "HidP_InitializeReportForID" },
                             { HIDP_MAX_DATA_LIST_LENGTH,       "HidP_MaxDataListLength" },
                             { HIDP_MAX_USAGE_LIST_LENGTH,      "HidP_MaxUsageListLength" },
                             { HIDP_SET_BUTTONS,                "HidP_SetButtons" },
                             { HIDP_SET_DATA,                   "HidP_SetData" },
                             { HIDP_SET_SCALED_USAGE_VALUE,     "HidP_SetScaledUsageValue" },
                             { HIDP_SET_USAGES,                 "HidP_SetUsages" },
                             { HIDP_SET_USAGE_VALUE,            "HidP_SetUsageValue" },
                             { HIDP_SET_USAGE_VALUE_ARRAY,      "HidP_SetUsageValueArray" },
                             { HIDP_TRANSLATE_USAGES,           "HidP_TranslateUsagesToI8042ScanCodes" },
                             { HIDP_UNSET_BUTTONS,              "HidP_UnsetButtons" },
                             { HIDP_UNSET_USAGES,               "HidP_UnsetUsages" },
                             { HIDP_USAGE_LIST_DIFFERENCE,      "HidP_UsageListDifference" },
                             { HID_CLEAR_REPORT,                "Clear Report Buffer"      }
};

static PARAMETER_STATE pState[HID_NUMCALLS] = {
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDD_GET_HID_GUID
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDD_GET_FREE_PREPARSED_DATA
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDD_GET_CONFIGURATION
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDD_SET_CONFIGURATION
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDD_FLUSH_QUEUE
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDD_GETATTRIBUTES
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,  TRUE }, // HIDD_SET_FEATURE
                                         { FALSE, FALSE, FALSE,  TRUE, FALSE, FALSE, FALSE, FALSE, FALSE,  TRUE }, // HIDD_GET_FEATURE
                                         { FALSE, FALSE, FALSE,  TRUE, FALSE, FALSE, FALSE,  TRUE, FALSE, FALSE }, // HIDD_GET_INPUT_REPORT
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,  TRUE, FALSE }, // HIDD_SET_OUTPUT_REPORT
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDD_GET_NUM_INPUT_BUFFERS
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDD_SET_NUM_INPUT_BUFFERS
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDD_GET_PHYSICAL_DESCRIPTOR
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDD_GET_MANUFACTURER_STRING
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDD_GET_PRODUCT_STRING
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDD_GET_INDEXED_STRING
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDD_GET_SERIAL_NUMBER_STRING
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDD_GET_MS_GENRE_DESCRIPTOR
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,  TRUE, FALSE, FALSE }, // HID_READ_REPORT
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,  TRUE, FALSE }, // HID_WRITE_BUFFER
                                         {  TRUE,  TRUE,  TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDP_GET_BUTTON_CAPS
                                         {  TRUE,  TRUE,  TRUE, FALSE,  TRUE, FALSE,  TRUE,  TRUE,  TRUE,  TRUE }, // HIDP_GET_BUTTONS
                                         {  TRUE,  TRUE,  TRUE, FALSE, FALSE, FALSE,  TRUE,  TRUE,  TRUE,  TRUE }, // HIDP_GET_BUTTONS_EX
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDP_GET_CAPS
                                         {  TRUE,  TRUE,  TRUE, FALSE, FALSE, FALSE, FALSE,  TRUE,  TRUE,  TRUE }, // HIDP_GET_DATA
                                         {  TRUE,  TRUE,  TRUE,  TRUE, FALSE, FALSE, FALSE,  TRUE,  TRUE,  TRUE }, // HIDP_GET_EXTENDED_ATTRIBUTES 
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDP_GET_LINK_COLL_NODES
                                         {  TRUE,  TRUE,  TRUE, FALSE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE }, // HIDP_GET_SCALED_USAGE_VALUE
                                         {  TRUE,  TRUE,  TRUE, FALSE,  TRUE,  TRUE,  TRUE, FALSE, FALSE, FALSE }, // HIDP_GET_SPECIFIC_BUTTON_CAPS
                                         {  TRUE,  TRUE,  TRUE, FALSE,  TRUE,  TRUE,  TRUE, FALSE, FALSE, FALSE }, // HIDP_GET_SPECIFIC_VALUE_CAPS
                                         {  TRUE,  TRUE,  TRUE, FALSE,  TRUE, FALSE,  TRUE,  TRUE,  TRUE,  TRUE }, // HIDP_GET_USAGES
                                         {  TRUE,  TRUE,  TRUE, FALSE, FALSE, FALSE,  TRUE,  TRUE,  TRUE,  TRUE }, // HIDP_GET_USAGES_EX
                                         {  TRUE,  TRUE,  TRUE, FALSE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE }, // HIDP_GET_USAGE_VALUE
                                         {  TRUE,  TRUE,  TRUE, FALSE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE }, // HIDP_GET_USAGE_VALUE_ARRAY
                                         {  TRUE,  TRUE,  TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDP_GET_VALUE_CAPS
                                         {  TRUE,  TRUE,  TRUE,  TRUE, FALSE, FALSE, FALSE,  TRUE,  TRUE,  TRUE }, // HIDP_INITIALIZE_REPORT_FOR_ID
                                         {  TRUE,  TRUE,  TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDP_MAX_DATA_LIST_LENGTH
                                         {  TRUE,  TRUE,  TRUE, FALSE,  TRUE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDP_MAX_USAGE_LIST_LENGTH
                                         {  TRUE,  TRUE,  TRUE, FALSE,  TRUE, FALSE,  TRUE,  TRUE,  TRUE,  TRUE }, // HIDP_SET_BUTTONS
                                         {  TRUE,  TRUE,  TRUE, FALSE, FALSE, FALSE, FALSE,  TRUE,  TRUE,  TRUE }, // HIDP_SET_DATA
                                         {  TRUE,  TRUE,  TRUE, FALSE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE }, // HIDP_SET_SCALED_USAGE_VALUE
                                         {  TRUE,  TRUE,  TRUE, FALSE,  TRUE, FALSE,  TRUE,  TRUE,  TRUE,  TRUE }, // HIDP_SET_USAGES                                        
                                         {  TRUE,  TRUE,  TRUE, FALSE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE }, // HIDP_SET_USAGE_VALUE
                                         {  TRUE,  TRUE,  TRUE, FALSE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE }, // HIDP_SET_USAGE_VALUE_ARRAY
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDP_TRANSLATE_USAGES
                                         {  TRUE,  TRUE,  TRUE, FALSE,  TRUE, FALSE,  TRUE,  TRUE,  TRUE,  TRUE }, // HIDP_UNSET_BUTTONS
                                         {  TRUE,  TRUE,  TRUE, FALSE,  TRUE, FALSE,  TRUE,  TRUE,  TRUE,  TRUE }, // HIDP_UNSET_USAGES
                                         { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE }, // HIDP_USAGE_LIST_DIFFERENCE
                                         {  TRUE,  TRUE,  TRUE, FALSE, FALSE, FALSE, FALSE,  TRUE,  TRUE,  TRUE }  // HID_CLEAR_BUFFER
                                        }; 


/*****************************************************************************
/* Local function declarations
/*****************************************************************************/

VOID
vLoadExtCalls(
    HWND hExtCalls
);

VOID
vSetReportType(
    HWND hDlg, 
    LONG lId
);

VOID 
vInitEditText(
    HWND   hText, 
    INT    cbTextSize, 
    CHAR   *pchText
);

VOID vEnableParameters(
    HWND     hDlg, 
    LRESULT  iCallSelection
);

BOOL 
fGetAndVerifyParameters(
    HWND              hDlg, 
    PECDISPLAY_PARAMS pParams
);

BOOL
ECDisp_Execute(
    IN     INT             FuncCall,
    IN OUT PEXTCALL_PARAMS CallParams,
    OUT    PEXTCALL_STATUS CallStatus
);

VOID
ECDisp_DisplayOutput(
    IN HWND            hOutputWindow,
    IN INT             FuncCall,
    IN PEXTCALL_PARAMS Results
);

VOID 
vExecuteAndDisplayOutput(
    HWND              hOutputWindow, 
    PHID_DEVICE       pDevice, 
    INT               iFuncCall, 
    PECDISPLAY_PARAMS pParams
);              

CHAR *pchGetHidAppStatusString(
    NTSTATUS StatusCode
);

VOID
vInitECControls(
    HWND            hDlg,
    USHORT          InputReportByteLength,
    PBUFFER_DISPLAY *ppInputDisplay,
    USHORT          OutputReportByteLength,
    PBUFFER_DISPLAY *ppOutputDisplay,
    USHORT          FeatureReportByteLength,
    PBUFFER_DISPLAY *ppFeatureDisplay
);

VOID
BuildReportIDList(
    IN  PHIDP_BUTTON_CAPS  phidButtonCaps,
    IN  USHORT             nButtonCaps,
    IN  PHIDP_VALUE_CAPS   phidValueCaps,
    IN  USHORT             nValueCaps,
    OUT UCHAR            **ppReportIDList,
    OUT INT               *nReportIDs
);

LRESULT CALLBACK
bSetUsagesDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
);

LRESULT CALLBACK
bSetValueDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
);

LRESULT CALLBACK
bSetInputBuffDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
);

LRESULT CALLBACK
bSetDataDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
);

LRESULT CALLBACK
bSetBufLenDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
);

LRESULT CALLBACK
bSetInputBuffersDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
);

LRESULT CALLBACK
bGetIndexedDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
);

LRESULT CALLBACK
bGetUsageDiffDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
);

BOOL
ConvertStringToUnsignedList(
    IN     INT     iUnsignedSize,
    IN     INT     iBase,
    IN OUT PCHAR   InString,
    OUT    PCHAR   *UnsignedList,
    OUT    PULONG  nUnsigneds
); 

BOOL
ConvertStringToUlongList(
    IN OUT PCHAR   InString,
    OUT    PULONG  *UlongList,
    OUT    PULONG  nUlongs
);

BOOL
ConvertStringToUsageList(
    IN OUT PCHAR   InString,
    OUT    PUSAGE  *UsageList,
    OUT    PULONG  nUsages
);

VOID
ECDisp_MakeGUIDString(
    IN  GUID guid, 
    OUT CHAR szString[],
	IN  UINT uiBuffSize
);

PCHAR
ECDisp_GetHidAppStatusString(
    NTSTATUS StatusCode
);

BOOL
ECDisp_ConvertUlongListToValueList(
    IN  PULONG  UlongList,
    IN  ULONG   nUlongs,
    IN  USHORT  BitSize,
    IN  USHORT  ReportCount,
    OUT PCHAR   *ValueList,
    OUT PULONG  ValueListSize
);

BOOL
SetDlgItemIntHex(
   HWND hDlg, 
   INT nIDDlgItem, 
   UINT uValue, 
   INT nBytes
);

PCHAR
ResolveFunctionName(
    INT Index
);


DWORD WINAPI
ECDisp_ReadThreadProc(
    LPVOID  ThreadContext
);

VOID
DisplayExtendedAttributes(
    IN  HWND                OutputWindow,
    IN  PHIDP_UNKNOWN_TOKEN UnknownList,
    IN  ULONG               UnknownListLength
);

/*****************************************************************************
/* Global function definitions
/*****************************************************************************/

LRESULT CALLBACK
bExtCallDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
)
{
    static PHID_DEVICE          pDevice;
    static CHAR                 szTempBuff[1024]; 
    static CHAR                 szLabel[512];
    static CHAR                 szValue[512];
    static INT                  iLBCounter;
    static UCHAR                *pucInputReportIDs;
    static UCHAR                *pucOutputReportIDs;
    static UCHAR                *pucFeatureReportIDs;
    static INT                  nInputReportIDs;
    static INT                  nOutputReportIDs;
    static INT                  nFeatureReportIDs;
    static HANDLE               ReadThread;
    static READ_THREAD_CONTEXT  readContext;
    
           INT                  iIndex;
           ECDISPLAY_PARAMS     params;
           DWORD                threadID;

    switch(message)
    {
    case WM_INITDIALOG:
    
        /*
        // Initializing the dialog box involves the following steps:
        //  1) Determine from the parameter the pointer to the selected device
        //  2) Initializing the controls in the dialog box to their initial values
        //  3) Send a message that our list of routines has changed 
        */
    
        pDevice = (PHID_DEVICE) lParam;

        vInitECControls(hDlg,
                        pDevice -> Caps.InputReportByteLength,
                        &pInputDisplay,
                        pDevice -> Caps.OutputReportByteLength,
                        &pOutputDisplay,
                        pDevice -> Caps.FeatureReportByteLength,
                        &pFeatureDisplay);                        

        ReadThread = NULL;
        
        PostMessage(hDlg,
                    WM_COMMAND,
                    IDC_EXTCALLS + (CBN_SELCHANGE << 16),
                    (LPARAM) GetDlgItem(hDlg,IDC_EXTCALLS));
        break; 

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDC_EXTCALLS:
            switch (HIWORD(wParam))
            {
            case CBN_SELCHANGE:
                iIndex = (INT) SendDlgItemMessage(hDlg, 
                                                  IDC_EXTCALLS,
                                                  CB_GETCURSEL,
                                                  0,
                                                  0);
                vEnableParameters(hDlg,
                                  SendDlgItemMessage(hDlg, 
                                                     IDC_EXTCALLS,
                                                     CB_GETITEMDATA,
                                                     iIndex,
                                                     0));
                break;
            }
            break;

        case IDC_INPUT_SELECT:
            if (CBN_SELCHANGE == HIWORD(wParam))
            {
                BufferDisplay_ChangeSelection(pInputDisplay);
            }
            break;

        case IDC_OUTPUT_SELECT:
            if (CBN_SELCHANGE == HIWORD(wParam)) 
            {
                 BufferDisplay_ChangeSelection(pOutputDisplay);
            }
            break;

        case IDC_FEATURE_SELECT:
            if (CBN_SELCHANGE == HIWORD(wParam)) 
            {
                 BufferDisplay_ChangeSelection(pFeatureDisplay);
            }
            break;
             
        case IDC_EXECUTE:
            /*
            // Get the parameters and verify that they are all correct
            //   If there is an error, display an error message and
            //   don't continue any further.
            */

            if ( !fGetAndVerifyParameters(hDlg, &params) ) 
            {
                ECDISP_ERROR(hDlg, "Error: One or more parameters are invalid");
            }

            /*
            // Else the parameters are valid and we can execute the call
            */
              
            else
            {
                iIndex = (INT) SendDlgItemMessage(hDlg, IDC_EXTCALLS, CB_GETCURSEL, 0, 0);
                iIndex = (INT) SendDlgItemMessage(hDlg, IDC_EXTCALLS, CB_GETITEMDATA, iIndex, 0);

                /*
                // Now that we know the function to execute we need to execute it
                //    and output the data
                */

                SendDlgItemMessage(hDlg, IDC_CALLOUTPUT, LB_RESETCONTENT, 0, 0);
                vExecuteAndDisplayOutput(GetDlgItem(hDlg, IDC_CALLOUTPUT), pDevice, iIndex, &params);
            }
            break;  /* end IDC_EXECUTE case */

        /*
        // Start up a read thread that can read input reports while
        //  we operate on the other stuff
        */
        
        case IDC_READ_SYNCH:
        case IDC_READ_ASYNCH:
        
            if (NULL == ReadThread) 
            {
                readContext.HidDevice = pDevice;
                readContext.TerminateThread = FALSE;
                readContext.DoOneRead = TRUE;
                readContext.DisplayEvent = NULL;
                readContext.DisplayWindow = hDlg;

                ReadThread = CreateThread(  NULL,
                                            0,
                                            (LOWORD(wParam) == IDC_READ_SYNCH) ? 
                                            SynchReadThreadProc :
                                            AsynchReadThreadProc,
                                            (LPVOID) &readContext,
                                            0,
                                            &threadID);

                if (NULL == ReadThread) 
                {
                    MessageBox(hDlg,
                               "Unable to create read thread",
                               HCLIENT_ERROR,
                               MB_ICONEXCLAMATION);
                }
                else 
                {
                    EnableWindow(GetDlgItem(hDlg, IDC_READ_SYNCH),
                                 (LOWORD(wParam) == IDC_READ_SYNCH));

                    EnableWindow(GetDlgItem(hDlg, IDC_READ_ASYNCH),
                                 (LOWORD(wParam) == IDC_READ_ASYNCH));

                    SetWindowText(GetDlgItem(hDlg, LOWORD(wParam)),
                                  "Stop Read Thread");
                                 
                    EnableWindow(GetDlgItem(hDlg, IDC_CANCEL), FALSE);
                }
            }
            else 
            {
                readContext.TerminateThread = TRUE;

                WaitForSingleObject(ReadThread, INFINITE);

                ReadThread = NULL;
                
                SetWindowText(GetDlgItem(hDlg, IDC_READ_SYNCH),
                              "Start Synchronous Read Thread");

                SetWindowText(GetDlgItem(hDlg, IDC_READ_ASYNCH),
                              "Start Asynchronous Read Thread");

                EnableWindow(GetDlgItem(hDlg, IDC_READ_SYNCH), TRUE);                                     
                EnableWindow(GetDlgItem(hDlg, IDC_READ_ASYNCH), TRUE);                                     
                EnableWindow(GetDlgItem(hDlg, IDC_CANCEL), TRUE);                                     
            }                                     
            break;    

        case IDC_CANCEL:
            BufferDisplay_Destroy(pInputDisplay);
            BufferDisplay_Destroy(pOutputDisplay);
            BufferDisplay_Destroy(pFeatureDisplay);
            EndDialog(hDlg, 0);
            break;
        }
        break;

    case WM_CLOSE:
        PostMessage(hDlg, WM_COMMAND, IDC_CANCEL, 0);
        break;

    } 
    return FALSE;
}

VOID
vLoadExtCalls(
    HWND hExtCalls
)
{
    INT  iIndex;
    UINT uiIndex;

    /*
    // Load the physical device specific calls
    */
    
    for (uiIndex = 0; uiIndex < HID_DEVCALLS; uiIndex++) 
    {
        iIndex = (INT) SendMessage(hExtCalls, 
                                   CB_ADDSTRING, 
                                   0, 
                                   (LPARAM) DeviceCalls[uiIndex].szFunctionName);

        if (CB_ERR != iIndex && CB_ERRSPACE != iIndex) 
        {
            SendMessage(hExtCalls,
                        CB_SETITEMDATA,
                        iIndex, 
                        DeviceCalls[uiIndex].uiIndex);
        }
    }

    /*
    // Load the other device calls no matter what
    */

    for (uiIndex = 0; uiIndex < HID_PPDCALLS; uiIndex++)
    {
        iIndex = (INT) SendMessage(hExtCalls, 
                                   CB_ADDSTRING, 
                                   0, 
                                   (LPARAM) PpdCalls[uiIndex].szFunctionName);

        if (CB_ERR != iIndex && CB_ERRSPACE != iIndex) 
        {
            SendMessage(hExtCalls,
                        CB_SETITEMDATA,
                        iIndex, 
                        PpdCalls[uiIndex].uiIndex);
        }
    }
    SendMessage(hExtCalls, CB_SETCURSEL, 0, 0);

    return;
}

VOID vSetReportType(
    HWND hDlg, 
    LONG lId
)
{
    CheckRadioButton(hDlg, IDC_INPUT, IDC_FEATURE, lId);
    return;
}

VOID 
vInitEditText(
    HWND hText, 
    INT  cbTextSize, 
    CHAR *pchText
)
{
    SendMessage(hText, EM_SETLIMITTEXT, (WPARAM) cbTextSize, 0); 
    SendMessage(hText, EM_REPLACESEL, 0, (LPARAM) pchText);

    return;
}

VOID vEnableParameters(
    HWND     hDlg,
    LRESULT  iCallSelection
)
{
    EnableWindow(GetDlgItem(hDlg, IDC_INPUT), pState[iCallSelection-1].fInputReport);
    EnableWindow(GetDlgItem(hDlg, IDC_OUTPUT), pState[iCallSelection-1].fOutputReport);
    EnableWindow(GetDlgItem(hDlg, IDC_FEATURE), pState[iCallSelection-1].fFeatureReport);
    EnableWindow(GetDlgItem(hDlg, IDC_REPORTID), pState[iCallSelection-1].fReportID);
    EnableWindow(GetDlgItem(hDlg, IDC_USAGEPAGE), pState[iCallSelection-1].fUsagePage);
    EnableWindow(GetDlgItem(hDlg, IDC_USAGE), pState[iCallSelection-1].fUsage);
    EnableWindow(GetDlgItem(hDlg, IDC_LINKCOLL), pState[iCallSelection-1].fLinkCollection);
    EnableWindow(GetDlgItem(hDlg, IDC_INPUT_SELECT), pState[iCallSelection-1].fInputReportSelect);
    EnableWindow(GetDlgItem(hDlg, IDC_OUTPUT_SELECT), pState[iCallSelection-1].fOutputReportSelect);
    EnableWindow(GetDlgItem(hDlg, IDC_FEATURE_SELECT), pState[iCallSelection-1].fFeatureReportSelect);

    return;
}
    
BOOL 
fGetAndVerifyParameters(
    HWND              hDlg, 
    PECDISPLAY_PARAMS pParams
)
{
    /*
    // Declare a text buffer of size 7 since the parameter limit is at most 6
    //   characters in the edit box.  
    */
    
    CHAR    WindowText[7];
    BOOL    fStatus = TRUE;
    PCHAR   nptr;
    
    if (IsDlgButtonChecked(hDlg, IDC_INPUT)) 
    {
        pParams -> ReportType = HidP_Input;
    }
    else if (IsDlgButtonChecked(hDlg, IDC_OUTPUT))
    {
        pParams -> ReportType = HidP_Output;
    }
    else
    {
        pParams -> ReportType = HidP_Feature;
    }

    /*
    // Get and verify the usage page window text;
    */
    
    GetWindowText(GetDlgItem(hDlg, IDC_USAGEPAGE), WindowText, 7);

    pParams -> UsagePage = (USAGE) strtol(WindowText, &nptr, 16);

    if (*nptr != '\0') 
    {
        fStatus = FALSE;
        pParams -> UsagePage = 0;
    }

    /*
    // Get and verify the usage window text
    */

    GetWindowText(GetDlgItem(hDlg, IDC_USAGE), WindowText, 7);

    pParams -> Usage = (USAGE) strtol(WindowText, &nptr, 16);

    if (*nptr != '\0') 
    {
        fStatus = FALSE;
        pParams -> Usage = 0;
    }
    
    /*
    // Get and verify the link collection window text
    */

    GetWindowText(GetDlgItem(hDlg, IDC_LINKCOLL), WindowText, 7);

    pParams -> LinkCollection = (USAGE) strtol(WindowText, &nptr, 16);

    if (*nptr != '\0')
    {
        fStatus = FALSE;
        pParams -> LinkCollection = 0;
    }
    
    GetWindowText(GetDlgItem(hDlg, IDC_REPORTID), WindowText, 7);

    pParams -> ReportID = (UCHAR) strtol(WindowText, &nptr, 10);
 
    if (*nptr != '\0') 
    {
        fStatus = FALSE;
        pParams -> ReportID = 0;
    }

    return (fStatus);
}

VOID
vInitECControls(
    HWND                hDlg,
    USHORT              InputReportByteLength,
    PBUFFER_DISPLAY     *ppInputDisplay,
    USHORT              OutputReportByteLength,
    PBUFFER_DISPLAY     *ppOutputDisplay,
    USHORT              FeatureReportByteLength,
    PBUFFER_DISPLAY     *ppFeatureDisplay
)
{
    BOOLEAN     fInitStatus;

    /*
    // Begin by initializing the combo box with the calls that can be executed
    */

    vLoadExtCalls(GetDlgItem(hDlg, IDC_EXTCALLS));

    /*
    // Set the radio buttons initially to the input report type
    */
    
    vSetReportType(hDlg, IDC_INPUT);
    
    /*
    // Initialize the edit controls text
    */

    vInitEditText(GetDlgItem(hDlg, IDC_USAGEPAGE), 6, "0x0000");
    vInitEditText(GetDlgItem(hDlg, IDC_USAGE), 6, "0x0000");
    vInitEditText(GetDlgItem(hDlg, IDC_LINKCOLL), 2, "0");
    vInitEditText(GetDlgItem(hDlg, IDC_REPORTID), 3, "0");

    /*
    // Initialize the report buffer boxes
    */

    fInitStatus = BufferDisplay_Init(GetDlgItem(hDlg, IDC_INPUT_SELECT),
                                     GetDlgItem(hDlg, IDC_INPUT_BUFFER),
                                     NUM_INPUT_BUFFERS,
                                     InputReportByteLength,
                                     HidP_Input,
                                     ppInputDisplay);

    if (!fInitStatus) 
    {
        ECDISP_ERROR(hDlg, "Error initializing input buffer display");
    }

    fInitStatus = BufferDisplay_Init(GetDlgItem(hDlg, IDC_OUTPUT_SELECT),
                                     GetDlgItem(hDlg, IDC_OUTPUT_BUFFER),
                                     NUM_OUTPUT_BUFFERS,
                                     OutputReportByteLength,
                                     HidP_Output,
                                     ppOutputDisplay);

    if (!fInitStatus) 
    {
        ECDISP_ERROR(hDlg,  "Error initializing output buffer display");
    }

    fInitStatus = BufferDisplay_Init(GetDlgItem(hDlg, IDC_FEATURE_SELECT),
                                     GetDlgItem(hDlg, IDC_FEATURE_BUFFER),
                                     NUM_FEATURE_BUFFERS,
                                     FeatureReportByteLength,
                                     HidP_Feature,
                                     ppFeatureDisplay);

    if (!fInitStatus) 
    {
        ECDISP_ERROR(hDlg, "Error initializing feature buffer display");
    }

    /*
    // Reset the output box content
    */
    
    SendMessage(GetDlgItem(hDlg, IDC_CALLOUTPUT), LB_RESETCONTENT, 0, 0);
    return;
}
    
BOOL
ECDisp_Execute(
    IN     INT             FuncCall,
    IN OUT PEXTCALL_PARAMS CallParams,
    OUT    PEXTCALL_STATUS CallStatus
)
/*++
RoutineDescription:
    This routine is a complex routine for executing all of the functions.  The
    routine was originally developed with consideration for future use that 
    never materialized.  

    It makes use of the calls in extcalls.c which basically execute the given
    function and does some verification on the buffers that are passed down to 
    HID.DLL.  

    The input parameters are specify the function call to execute, the 
    call parameters structures and the call status structure.

    If any further buffers are needed for the specific calls, they will be
    allocated here.  

    The CallStatus parameters is a structure set by the ExtCalls_ routines

    Future versions of the HClient sample may remove this routine and/or the
    ExtCalls_ routines to simply the code.
--*/
{
    BOOL                ExecuteStatus;
    HIDP_VALUE_CAPS     ValueCaps;
    USHORT              ValueCapsLength;
    PULONG              ValueList;

    NTSTATUS            status;
    DWORD               numBytes;
    ULONG               size;

    /*
    // Initially assume everything will go correctly and will set otherwise
    //    depending on the function call.
    */

    CallStatus -> IsHidError = FALSE;

    switch (FuncCall) 
    {
    case HID_READ_REPORT:
        CallStatus -> IsHidError = !ReadFile(CallParams -> DeviceHandle,
                                             CallParams -> ReportBuffer,
                                             CallParams -> ReportLength,
                                             &numBytes,
                                             NULL);
        return (TRUE);
        break;

    case HID_WRITE_REPORT:
        CallStatus -> IsHidError = !WriteFile(CallParams -> DeviceHandle,
                                              CallParams -> ReportBuffer,
                                              CallParams -> ReportLength,
                                              &numBytes,
                                              NULL);
        return (TRUE);
        break;

    case HIDD_FLUSH_QUEUE:
        CallStatus -> IsHidError = !HidD_FlushQueue(CallParams -> DeviceHandle);
        return (TRUE);
        break;

    case HIDD_GET_HID_GUID:
        CallParams -> List = malloc(sizeof(GUID));

        if (NULL != CallParams -> List) 
        {
            HidD_GetHidGuid((GUID *) CallParams -> List);
        }
        return (NULL != CallParams -> List);
        break;

    case HIDD_GET_PREPARSED_DATA:
        CallStatus -> IsHidError = !HidD_GetPreparsedData(CallParams -> DeviceHandle,
                                                          CallParams -> ppPd);
        return (TRUE);

    case HIDD_FREE_PREPARSED_DATA:
        CallStatus -> IsHidError = !HidD_FreePreparsedData(CallParams -> Ppd);
        return (TRUE);

    case HIDD_GET_ATTRIBUTES:
        CallParams -> List = malloc(sizeof(HIDD_ATTRIBUTES));

        if (NULL != CallParams -> List) 
        {
            CallStatus -> IsHidError = !HidD_GetAttributes(CallParams -> DeviceHandle,
                                                           CallParams -> List);
        }
        return (NULL != CallParams -> List);
        
    case HIDD_GET_FEATURE:
        *(CallParams -> ReportBuffer) = CallParams -> ReportID;

        CallStatus -> IsHidError = !HidD_GetFeature(CallParams -> DeviceHandle,
                                                    CallParams -> ReportBuffer,
                                                    CallParams -> ReportLength);
        return (TRUE);

    case HIDD_SET_FEATURE:
        CallStatus -> IsHidError = !HidD_SetFeature(CallParams -> DeviceHandle,
                                                    CallParams -> ReportBuffer,
                                                    CallParams -> ReportLength);
        return (TRUE);

    case HIDD_GET_INPUT_REPORT:
        *(CallParams -> ReportBuffer) = CallParams -> ReportID;

        CallStatus -> IsHidError = !HidD_GetInputReport(CallParams -> DeviceHandle,
                                                        CallParams -> ReportBuffer,
                                                        CallParams -> ReportLength);
        return (TRUE);

    case HIDD_SET_OUTPUT_REPORT:
        CallStatus -> IsHidError = !HidD_SetOutputReport(CallParams -> DeviceHandle,
                                                         CallParams -> ReportBuffer,
                                                         CallParams -> ReportLength);
        return (TRUE);

    case HIDD_GET_NUM_INPUT_BUFFERS:
        CallStatus -> IsHidError = !HidD_GetNumInputBuffers(CallParams -> DeviceHandle,
                                                            &CallParams -> Value);
        return (TRUE);

    case HIDD_SET_NUM_INPUT_BUFFERS:
        CallStatus -> IsHidError = !HidD_SetNumInputBuffers(CallParams -> DeviceHandle,
                                                            CallParams -> Value);

        return (TRUE);

    case HIDD_GET_PHYSICAL_DESCRIPTOR:
        CallParams -> List = (PCHAR) malloc (CallParams -> ListLength);

        if (NULL != CallParams -> List ) 
        {
            CallStatus -> IsHidError = !HidD_GetPhysicalDescriptor(CallParams -> DeviceHandle,
                                                                   CallParams -> List,
                                                                   CallParams -> ListLength);
        }
        return (NULL != CallParams -> List);

    case HIDD_GET_MANUFACTURER_STRING:
        
        CallParams -> List = (PWCHAR) malloc (CallParams -> ListLength);

        if (NULL != CallParams -> List ) 
        {
            CallStatus -> IsHidError = !HidD_GetManufacturerString(CallParams -> DeviceHandle,
                                                                   CallParams -> List,
                                                                   CallParams -> ListLength);
        }
        return (NULL != CallParams -> List);

    case HIDD_GET_PRODUCT_STRING:
        CallParams -> List = (PWCHAR) malloc (CallParams -> ListLength);

        if (NULL != CallParams -> List ) 
        {
            CallStatus -> IsHidError = !HidD_GetProductString(CallParams -> DeviceHandle,
                                                             CallParams -> List,
                                                             CallParams -> ListLength);
        }
        return (NULL != CallParams -> List);

    case HIDP_GET_EXTENDED_ATTRIBUTES:
        CallParams -> List = (PWCHAR) malloc (CallParams -> ListLength);
        if (NULL != CallParams -> List )
        {
            status = pfnHidP_GetExtendedAttributes(CallParams -> ReportType,
                                                  (USHORT) CallParams -> Index,
                                                   CallParams -> Ppd,
                                                   CallParams -> List,
                                                   &CallParams -> ListLength);

            CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
            CallStatus -> HidErrorCode = status;
        }
        return (NULL != CallParams -> List);
        
    case HIDD_GET_INDEXED_STRING:
        CallParams -> List = (PWCHAR) malloc (CallParams -> ListLength);

        if (NULL != CallParams -> List ) 
        {
            CallStatus -> IsHidError = !HidD_GetIndexedString(CallParams -> DeviceHandle,
                                                              CallParams -> Index,
                                                              CallParams -> List,
                                                              CallParams -> ListLength);
        }
        return (NULL != CallParams -> List);
        
    case HIDD_GET_SERIAL_NUMBER_STRING:
        CallParams -> List = (PWCHAR) malloc (CallParams -> ListLength);

        if (NULL != CallParams -> List ) 
        {
            CallStatus -> IsHidError = !HidD_GetSerialNumberString(CallParams -> DeviceHandle,
                                                                   CallParams -> List,
                                                                   CallParams -> ListLength);
        }
        return (NULL != CallParams -> List);

    case HIDD_GET_MS_GENRE_DESCRIPTOR:
        CallParams -> List = (PCHAR) malloc (CallParams -> ListLength);

        if (NULL != CallParams -> List ) 
        {
            CallStatus -> IsHidError = !HidD_GetMsGenreDescriptor(CallParams -> DeviceHandle,
                                                                  CallParams -> List,
                                                                  CallParams -> ListLength);
        }
        return (NULL != CallParams -> List);

    case HIDP_GET_BUTTON_CAPS:
        size = CallParams -> ListLength * sizeof(HIDP_BUTTON_CAPS);

        CallParams -> List = malloc(size);

        if (NULL != CallParams -> List) 
        {
            status = HidP_GetButtonCaps(CallParams -> ReportType,
                                        CallParams -> List,
                                        (PUSHORT) &CallParams -> ListLength,
                                        CallParams -> Ppd);

            CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
            CallStatus -> HidErrorCode = status;
        }
        return (NULL != CallParams -> List);

    case HIDP_GET_BUTTONS:

        CallParams -> ListLength = HidP_MaxUsageListLength(CallParams -> ReportType,
                                                           CallParams -> UsagePage,
                                                           CallParams -> Ppd);

        CallParams -> List = malloc(CallParams -> ListLength * sizeof(USAGE));

        if (NULL != CallParams -> List) 
        {
            status = HidP_GetButtons(CallParams -> ReportType,
                                     CallParams -> UsagePage,
                                     CallParams -> LinkCollection,
                                     CallParams -> List,
                                     &CallParams -> ListLength,
                                     CallParams -> Ppd,
                                     CallParams -> ReportBuffer,
                                     CallParams -> ReportLength);

            CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
            CallStatus -> HidErrorCode = status;
        }
        return (NULL != CallParams -> List);

    case HIDP_GET_BUTTONS_EX:

        CallParams -> ListLength = HidP_MaxUsageListLength(CallParams -> ReportType,
                                                           CallParams -> UsagePage,
                                                           CallParams -> Ppd);

        CallParams -> List = malloc(CallParams -> ListLength * sizeof(USAGE_AND_PAGE));

        if (NULL != CallParams -> List) 
        {
            status = HidP_GetButtonsEx(CallParams -> ReportType,
                                       CallParams -> LinkCollection,
                                       CallParams -> List,
                                       &CallParams -> ListLength,
                                       CallParams -> Ppd,
                                       CallParams -> ReportBuffer,
                                       CallParams -> ReportLength);

            CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
            CallStatus -> HidErrorCode = status;
        }
        return (NULL != CallParams -> List);

        
    case HIDP_GET_CAPS:

        CallParams -> ListLength = sizeof(HIDP_CAPS);

        CallParams -> List = malloc(sizeof(HIDP_CAPS));

        if (NULL != CallParams -> List)
        {
            status = HidP_GetCaps(CallParams -> Ppd, CallParams -> List);

            CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
            CallStatus -> HidErrorCode = status;
        }
        return (NULL != CallParams -> List);

    case HIDP_GET_DATA:

        CallParams -> ListLength = HidP_MaxDataListLength(CallParams -> ReportType,
                                                          CallParams -> Ppd);

        CallParams -> List = malloc(CallParams -> ListLength * sizeof(HIDP_DATA));

        if (NULL != CallParams -> List)
        {
            status = HidP_GetData(CallParams -> ReportType,
                                  CallParams -> List,
                                  &CallParams -> ListLength,
                                  CallParams -> Ppd,
                                  CallParams -> ReportBuffer,
                                  CallParams -> ReportLength);

            CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
            CallStatus -> HidErrorCode = status;
        }
        return (NULL != CallParams -> List);

    case HIDP_GET_LINK_COLL_NODES:
        CallParams -> List = malloc(CallParams -> ListLength * sizeof(HIDP_LINK_COLLECTION_NODE));

        if (NULL != CallParams -> List)
        {
            status = HidP_GetLinkCollectionNodes(CallParams -> List,
                                                 &CallParams -> ListLength,
                                                 CallParams -> Ppd);

            CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
            CallStatus -> HidErrorCode = status;
        }
        return (NULL != CallParams -> List);

    case HIDP_GET_SCALED_USAGE_VALUE:

        status = HidP_GetScaledUsageValue(CallParams -> ReportType,
                                          CallParams -> UsagePage,
                                          CallParams -> LinkCollection,
                                          CallParams -> Usage,
                                         &CallParams -> ScaledValue,
                                          CallParams -> Ppd,
                                          CallParams -> ReportBuffer,
                                          CallParams -> ReportLength);

        CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
        CallStatus -> HidErrorCode = status;

        return (TRUE);

    case HIDP_GET_SPECIFIC_BUTTON_CAPS:

        CallParams -> List = malloc(CallParams -> ListLength * sizeof(HIDP_BUTTON_CAPS));

        if (NULL != CallParams -> List)
        {
            status = HidP_GetSpecificButtonCaps(CallParams -> ReportType,
                                                CallParams -> UsagePage,
                                                CallParams -> LinkCollection,
                                                CallParams -> Usage,
                                                CallParams -> List,
                                                (PUSHORT) &CallParams -> ListLength,
                                                CallParams -> Ppd);

            CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
            CallStatus -> HidErrorCode = status;
       }
       return (NULL != CallParams -> List);
        
    case HIDP_GET_SPECIFIC_VALUE_CAPS:

        CallParams -> List = malloc(CallParams -> ListLength * sizeof(HIDP_VALUE_CAPS));

        if (NULL != CallParams -> List)
        {
            status = HidP_GetSpecificValueCaps(CallParams -> ReportType,
                                               CallParams -> UsagePage,
                                               CallParams -> LinkCollection,
                                               CallParams -> Usage,
                                               CallParams -> List,
                                               (PUSHORT) &CallParams -> ListLength,
                                               CallParams -> Ppd);

            CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
            CallStatus -> HidErrorCode = status;
       }
       return (NULL != CallParams -> List);

    case HIDP_GET_USAGES:
        CallParams -> ListLength = HidP_MaxUsageListLength(CallParams -> ReportType,
                                                           CallParams -> UsagePage,
                                                           CallParams -> Ppd);

        CallParams -> List = malloc(CallParams -> ListLength * sizeof(USAGE));

        if (NULL != CallParams -> List)
        {
            status = HidP_GetUsages(CallParams -> ReportType,
                                    CallParams -> UsagePage,
                                    CallParams -> LinkCollection,
                                    CallParams -> List,
                                   &CallParams -> ListLength,
                                    CallParams -> Ppd,
                                    CallParams -> ReportBuffer,
                                    CallParams -> ReportLength);

            CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
            CallStatus -> HidErrorCode = status;
       }
       return (NULL != CallParams -> List);

    case HIDP_GET_USAGES_EX:
        CallParams -> ListLength = HidP_MaxUsageListLength(CallParams -> ReportType,
                                                           CallParams -> UsagePage,
                                                           CallParams -> Ppd);

        CallParams -> List = malloc(CallParams -> ListLength * sizeof(USAGE_AND_PAGE));

        if (NULL != CallParams -> List)
        {
            status = HidP_GetUsagesEx(CallParams -> ReportType,
                                      CallParams -> LinkCollection,
                                      CallParams -> List,
                                     &CallParams -> ListLength,
                                      CallParams -> Ppd,
                                      CallParams -> ReportBuffer,
                                      CallParams -> ReportLength);

            CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
            CallStatus -> HidErrorCode = status;
       }
       return (NULL != CallParams -> List);
         
    case HIDP_GET_USAGE_VALUE:
        status = HidP_GetUsageValue(CallParams -> ReportType,
                                    CallParams -> UsagePage,
                                    CallParams -> LinkCollection,
                                    CallParams -> Usage,
                                    &CallParams -> Value,
                                    CallParams -> Ppd,
                                    CallParams -> ReportBuffer,
                                    CallParams -> ReportLength);

        CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
        CallStatus -> HidErrorCode = status;

        return (TRUE);

    case HIDP_GET_USAGE_VALUE_ARRAY:

        ValueCapsLength = 1;
        status = HidP_GetSpecificValueCaps(CallParams -> ReportType,
                                           CallParams -> UsagePage,
                                           CallParams -> LinkCollection,
                                           CallParams -> Usage,
                                           &ValueCaps,
                                           &ValueCapsLength,
                                           CallParams -> Ppd);

        if (HIDP_STATUS_SUCCESS != status) 
        {
            return (FALSE);
        }

        CallParams -> BitSize     = ValueCaps.BitSize;
        CallParams -> ReportCount = ValueCaps.ReportCount;
        CallParams -> ListLength
                 = ROUND_TO_NEAREST_BYTE(CallParams -> BitSize * CallParams -> ReportCount);

        CallParams -> List = malloc(CallParams -> ListLength);

        if (NULL != CallParams -> List) 
        {
            status = HidP_GetUsageValueArray(CallParams -> ReportType,
                                             CallParams -> UsagePage,
                                             CallParams -> LinkCollection,
                                             CallParams -> Usage,
                                             CallParams -> List,
                                             (USHORT) CallParams -> ListLength,
                                             CallParams -> Ppd,
                                             CallParams -> ReportBuffer,
                                             CallParams -> ReportLength);

            CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
            CallStatus -> HidErrorCode = status;
        }
        return (NULL != CallParams -> List);

    case HIDP_GET_VALUE_CAPS:
        CallParams -> List = malloc(CallParams -> ListLength * sizeof(HIDP_VALUE_CAPS));
        if (NULL != CallParams -> List) 
        {
            status = HidP_GetValueCaps(CallParams -> ReportType,
                                       CallParams -> List,
                                       (PUSHORT) &CallParams -> ListLength,
                                       CallParams -> Ppd);

            CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
            CallStatus -> HidErrorCode = status;
        }


    case HIDP_INITIALIZE_REPORT_FOR_ID:
        
        status = pfnHidP_InitializeReportForID(CallParams -> ReportType,
                                               CallParams -> ReportID,
                                               CallParams -> Ppd,
                                               CallParams -> ReportBuffer,
                                               CallParams -> ReportLength);

        CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
        CallStatus -> HidErrorCode = status;

        return (TRUE);

    case HIDP_MAX_USAGE_LIST_LENGTH:

        CallParams -> Value = HidP_MaxUsageListLength(CallParams -> ReportType,
                                                      CallParams -> UsagePage,
                                                      CallParams -> Ppd);

        CallStatus -> IsHidError = FALSE;
        CallStatus -> HidErrorCode = HIDP_STATUS_SUCCESS;

        return (TRUE);

    case HIDP_MAX_DATA_LIST_LENGTH:

        CallParams -> Value = HidP_MaxDataListLength(CallParams -> ReportType,
                                                     CallParams -> Ppd);

        CallStatus -> IsHidError = FALSE;
        CallStatus -> HidErrorCode = HIDP_STATUS_SUCCESS;

        return (TRUE);

    case HIDP_SET_BUTTONS:

        status = HidP_SetButtons(CallParams -> ReportType,
                                 CallParams -> UsagePage,
                                 CallParams -> LinkCollection,
                                 CallParams -> List,
                                 &CallParams -> ListLength,
                                 CallParams -> Ppd,
                                 CallParams -> ReportBuffer,
                                 CallParams -> ReportLength);

        CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
        CallStatus -> HidErrorCode = status;

        return (TRUE);

    case HIDP_SET_DATA:

        status = HidP_SetData(CallParams -> ReportType,
                              CallParams -> List,
                              &CallParams -> ListLength,
                              CallParams -> Ppd,
                              CallParams -> ReportBuffer,
                              CallParams -> ReportLength);

        CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
        CallStatus -> HidErrorCode = status;

        return (TRUE);

    case HIDP_SET_SCALED_USAGE_VALUE:
        status = HidP_SetUsageValue(CallParams -> ReportType,
                                    CallParams -> UsagePage,
                                    CallParams -> LinkCollection,
                                    CallParams -> Usage,
                                    CallParams -> ScaledValue,
                                    CallParams -> Ppd,
                                    CallParams -> ReportBuffer,
                                    CallParams -> ReportLength);

        CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
        CallStatus -> HidErrorCode = status;

        return (TRUE);

    case HIDP_SET_USAGES:
        status = HidP_SetUsages(CallParams -> ReportType,
                                CallParams -> UsagePage,
                                CallParams -> LinkCollection,
                                CallParams -> List,
                               &CallParams -> ListLength,
                                CallParams -> Ppd,
                                CallParams -> ReportBuffer,
                                CallParams -> ReportLength);

        CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
        CallStatus -> HidErrorCode = status;

        return (TRUE);

    case HIDP_SET_USAGE_VALUE:
        status = HidP_SetUsageValue(CallParams -> ReportType,
                                    CallParams -> UsagePage,
                                    CallParams -> LinkCollection,
                                    CallParams -> Usage,
                                    CallParams -> Value,
                                    CallParams -> Ppd,
                                    CallParams -> ReportBuffer,
                                    CallParams -> ReportLength);

        CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
        CallStatus -> HidErrorCode = status;

        return (TRUE);

    case HIDP_SET_USAGE_VALUE_ARRAY:

        ValueCapsLength = 1;
        status = HidP_GetSpecificValueCaps(CallParams -> ReportType,
                                           CallParams -> UsagePage,
                                           CallParams -> LinkCollection,
                                           CallParams -> Usage,
                                           &ValueCaps,
                                           &ValueCapsLength,
                                           CallParams -> Ppd);

        if (HIDP_STATUS_SUCCESS != status) 
        {
            return (FALSE);
        }
        
        CallParams -> BitSize     = ValueCaps.BitSize;
        CallParams -> ReportCount = ValueCaps.ReportCount;

        ValueList = CallParams -> List;
        ExecuteStatus = ECDisp_ConvertUlongListToValueList(ValueList,
                                                           CallParams -> ListLength,
                                                           CallParams -> BitSize,
                                                           CallParams -> ReportCount,
                                                           (PCHAR *) &CallParams -> List,
                                                           &CallParams -> ListLength);

        if (!ExecuteStatus) 
        {
            return (FALSE);
        }

        status = HidP_SetUsageValueArray(CallParams -> ReportType,
                                         CallParams -> UsagePage,
                                         CallParams -> LinkCollection,
                                         CallParams -> Usage,
                                         CallParams -> List,
                                         (USHORT) CallParams -> ListLength,
                                         CallParams -> Ppd,
                                         CallParams -> ReportBuffer,
                                         CallParams -> ReportLength);

        CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
        CallStatus -> HidErrorCode = status;

        return (TRUE);

    case HIDP_UNSET_BUTTONS:
        status = HidP_UnsetButtons(CallParams -> ReportType,
                                   CallParams -> UsagePage,
                                   CallParams -> LinkCollection,
                                   CallParams -> List,
                                   &CallParams -> ListLength,
                                   CallParams -> Ppd,
                                   CallParams -> ReportBuffer,
                                   CallParams -> ReportLength);

        CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
        CallStatus -> HidErrorCode = status;

        return (TRUE);

    case HIDP_UNSET_USAGES:
        status = HidP_UnsetUsages(CallParams -> ReportType,
                                  CallParams -> UsagePage,
                                  CallParams -> LinkCollection,
                                  CallParams -> List,
                                 &CallParams -> ListLength,
                                  CallParams -> Ppd,
                                  CallParams -> ReportBuffer,
                                  CallParams -> ReportLength);
                          
        CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
        CallStatus -> HidErrorCode = status;
                          
        return (TRUE);    

    case HIDP_USAGE_LIST_DIFFERENCE:
        CallParams -> MakeList = (PUSAGE) malloc (sizeof(USAGE) * CallParams -> ListLength);

        if (NULL == CallParams -> MakeList)
        {
            return (FALSE);
        }

        CallParams -> BreakList = (PUSAGE) malloc (sizeof(USAGE) * CallParams -> ListLength);
        if (NULL == CallParams -> BreakList) 
        {
            free(CallParams -> MakeList);

            return (FALSE);
        }

        status = HidP_UsageListDifference(CallParams -> List,
                                          CallParams -> List2,
                                          CallParams -> BreakList,
                                          CallParams -> MakeList,
                                          CallParams -> ListLength);

        CallStatus -> IsHidError = (HIDP_STATUS_SUCCESS != status);
        CallStatus -> HidErrorCode = status;

        return (TRUE);
    }
    return (FALSE);
}

VOID
ECDisp_DisplayOutput(
    IN HWND            hOutputWindow,
    IN INT             FuncCall,
    IN PEXTCALL_PARAMS Results
)
/*++
RoutineDescription:
    This routine is responsible for displaying the output from calls to HID.DLL
    functions.  It must extract and interpret the appropriate data from the 
    PEXTCALL_PARAMS structure. 
--*/
{
    PHIDP_LINK_COLLECTION_NODE NodeList;
    PHIDP_BUTTON_CAPS          ButtonCaps;
    PHIDP_VALUE_CAPS           ValueCaps;
    PHIDP_DATA                 DataList;
    PHIDP_EXTENDED_ATTRIBUTES  ExtAttrib;
    PUSAGE_AND_PAGE            UsageAndPageList;
    PUSAGE                     UsageList;
    PCHAR                      UsageValueArray;
    PBUFFER_DISPLAY            pDisplay;
    PCHAR                      PhysDescString;
    PCHAR                      GenreDescString;
    SIZE_T                     StringLength;
	UINT					   RemainingBuffer=0;

    ULONG                      Index;
	HRESULT					   stringReturn;


    switch (FuncCall) {
    case HIDD_GET_HID_GUID:

        stringReturn = StringCbCopy(szTempBuffer, TEMP_BUFFER_SIZE, "HID Guid: ");
        StringLength = strlen(szTempBuffer);
		if (StringLength < TEMP_BUFFER_SIZE)
		{
			RemainingBuffer = (UINT)(TEMP_BUFFER_SIZE - StringLength);
		}
        ECDisp_MakeGUIDString(*((LPGUID) Results -> List),
                              &szTempBuffer[StringLength],
							  RemainingBuffer);

        OUTSTRING(hOutputWindow, szTempBuffer);
        break;

    case HIDD_GET_ATTRIBUTES:
        vDisplayDeviceAttributes((PHIDD_ATTRIBUTES) Results -> List, 
                                 hOutputWindow);
        break;

    case HIDD_GET_NUM_INPUT_BUFFERS:
        stringReturn = StringCbPrintf(szTempBuffer, TEMP_BUFFER_SIZE,
                       "Number input buffers: %u", Results -> Value);

        OUTSTRING(hOutputWindow, szTempBuffer);
        break;

    case HIDD_GET_MS_GENRE_DESCRIPTOR:
        OUTSTRING(hOutputWindow, "MS Genre Descriptor");
        OUTSTRING(hOutputWindow, "===================");
    
            /*
        // To display a physical descriptor, the procedure currently just
        //   creates a string data buffer by bytes and displays that 
        //   in the results box.  It will display in rows of 16 bytes apiece.
        */
        
        Index = 0;
        while (Index < Results -> ListLength) 
        {
            Strings_CreateDataBufferString(((PCHAR) Results -> List) + Index,
                                           Results -> ListLength - Index,
                                           16,
                                           1,
                                           &GenreDescString);

            if (NULL != GenreDescString) 
            {
                OUTSTRING(hOutputWindow, GenreDescString);
                free(GenreDescString);
            }
            else 
            {
               OUTSTRING(hOutputWindow, "Error trying to display ms genre descriptor");
            }
            Index += 16;
        }
        break;

    case HIDD_GET_PHYSICAL_DESCRIPTOR: 
        OUTSTRING(hOutputWindow, "Physical Descriptor");
        OUTSTRING(hOutputWindow, "===================");

        /*
        // To display a physical descriptor, the procedure currently just
        //   creates a string data buffer by bytes and displays that 
        //   in the results box.  It will display in rows of 16 bytes apiece.
        */
        
        Index = 0;
        while (Index < Results -> ListLength) 
        {
            Strings_CreateDataBufferString(((PCHAR) Results -> List) + Index,
                                           Results -> ListLength - Index,
                                           16,
                                           1,
                                           &PhysDescString);

            if (NULL != PhysDescString) 
            {
                OUTSTRING(hOutputWindow, PhysDescString);
                free(PhysDescString);
            }
            else 
            {
               OUTSTRING(hOutputWindow, "Error trying to display physical descriptor");
            }
            Index += 16;
        }
        break;

    /*
    // For the string descriptor call routines, the returned string is stored
    //   in the Results -> List parameter.  It should be noted that the
    //   strings returned by these calls are wide-char strings and that these
    //   string are terminated with a NULL character if there was space withing
    //   the buffer to add such a character.  If the buffer was only big enough
    //   to hold the characters of the string, there will be no null terminator
    //   and the output string display mechanism may fail to properly display this
    //   type of string.  Fixing of this display mechanism is a future (low priority)
    //   workitem.
    */
    
    case HIDD_GET_PRODUCT_STRING:
        OUTSTRING(hOutputWindow, "Product String");
        OUTSTRING(hOutputWindow, "==============");
        OUTWSTRING(hOutputWindow, Results -> List);
        break;

    case HIDD_GET_MANUFACTURER_STRING:
        OUTSTRING(hOutputWindow, "Manufacturer String");
        OUTSTRING(hOutputWindow, "===================");
        OUTWSTRING(hOutputWindow, Results -> List);
        break;

    case HIDD_GET_INDEXED_STRING:
        stringReturn = StringCbPrintf(szTempBuffer, TEMP_BUFFER_SIZE,
                       "Indexed String #%u:", Results -> Index);

        OUTSTRING(hOutputWindow, szTempBuffer);
        OUTSTRING(hOutputWindow, "===================");
        OUTWSTRING(hOutputWindow, Results -> List);
        break;

    case HIDD_GET_SERIAL_NUMBER_STRING:
        OUTSTRING(hOutputWindow, "Serial Number String");
        OUTSTRING(hOutputWindow, "=====================");
        OUTWSTRING(hOutputWindow, Results -> List);
        break;
        
    case HIDP_GET_BUTTON_CAPS:
    case HIDP_GET_SPECIFIC_BUTTON_CAPS:

        ButtonCaps = (PHIDP_BUTTON_CAPS) (Results -> List);
        for (Index = 0; Index < Results -> ListLength; Index++, ButtonCaps++) 
        {
             OUTSTRING(hOutputWindow, "==========================");
             vDisplayButtonAttributes(ButtonCaps, hOutputWindow);
        }
        break;

    /*
    // HidP_GetButtons and HidP_GetUsages are in reality the same call.  
    //   HidP_GetButtons actually a macro which gets redefined into 
    //   HidP_GetUsages with the same parameter order.  That is why their
    //   display mechanisms are identical.  This call returns in the 
    //   List parameter a list of Usages.  The display mechanism converts
    //   these usages into a string of numbers.
    */
    
    case HIDP_GET_BUTTONS:
    case HIDP_GET_USAGES:

        OUTSTRING(hOutputWindow, "Usages Returned");
        OUTSTRING(hOutputWindow, "===============");

        UsageList = (PUSAGE) Results -> List;
        for (Index = 0; Index < Results -> ListLength; Index++) 
        {
            vCreateUsageString(UsageList + Index, szTempBuffer);

            OUTSTRING(hOutputWindow, szTempBuffer);
        }
        break;

    /*
    // Like get their siblings, the normal get functions, these routines are
    //   currently one in the same.  The difference between these routines 
    //   and their siblings is the return of a usage page along with each
    //   usage.  Therefore, both values must be displayed at the same time.
    */
    
    case HIDP_GET_BUTTONS_EX:
    case HIDP_GET_USAGES_EX:

        OUTSTRING(hOutputWindow, "Usages Returned");
        OUTSTRING(hOutputWindow, "===============");

        UsageAndPageList = (PUSAGE_AND_PAGE) Results -> List;
        for (Index = 0; Index < Results -> ListLength; Index++) 
        {
            vCreateUsageAndPageString(UsageAndPageList + Index,
                                      szTempBuffer);

            OUTSTRING(hOutputWindow, szTempBuffer);
        }
        break;

    case HIDP_GET_CAPS:
        vDisplayDeviceCaps((PHIDP_CAPS) Results -> List, hOutputWindow);
        break;

    case HIDP_GET_DATA:
        OUTSTRING(hOutputWindow, "Data Indices");
        OUTSTRING(hOutputWindow, "============");
        
        DataList = (PHIDP_DATA) Results -> List;
        for (Index = 0; Index < Results -> ListLength; Index++) 
        {
            vDisplayDataAttributes(DataList+Index,
                                   FALSE,
                                   hOutputWindow);
        }
        break;

    case HIDP_GET_EXTENDED_ATTRIBUTES:
        OUTSTRING(hOutputWindow, "Extended Attributes");
        OUTSTRING(hOutputWindow, "===================");
        
        ExtAttrib = (PHIDP_EXTENDED_ATTRIBUTES) Results -> List;

        DisplayExtendedAttributes(hOutputWindow,
                                  ExtAttrib -> GlobalUnknowns, 
                                  ExtAttrib -> NumGlobalUnknowns);
        break;
        
    case HIDP_GET_LINK_COLL_NODES:

        OUTSTRING(hOutputWindow, "Link Collection Nodes");
        OUTSTRING(hOutputWindow, "=====================");
        
        NodeList = (PHIDP_LINK_COLLECTION_NODE) Results -> List;
        for (Index = 0; Index < Results -> ListLength; Index++) 
        {
            OUTSTRING(hOutputWindow, "===========================");
            vDisplayLinkCollectionNode(NodeList+Index,
                                       Index,
                                       hOutputWindow);
        }
        break;

    case HIDP_GET_SCALED_USAGE_VALUE:
    
        stringReturn = StringCbPrintf(szTempBuffer, TEMP_BUFFER_SIZE,
                       "Scaled usage value: %ld", Results -> ScaledValue);
        OUTSTRING(hOutputWindow, szTempBuffer);

        break;

    case HIDP_GET_USAGE_VALUE:
        stringReturn = StringCbPrintf(szTempBuffer, TEMP_BUFFER_SIZE,
                       "Usage value: %lu", Results -> Value);
        OUTSTRING(hOutputWindow, szTempBuffer);
        break;

    /*
    // To display a usage value array, we must extract each of the values
    //   in the array based on the ReportSize.  The ReportSize is not necessarily
    //   an even byte size so we must use the special extraction routine to get
    //   each of the values in the array.
    */
    
    case HIDP_GET_USAGE_VALUE_ARRAY:

        UsageValueArray = (PCHAR) Results -> List;

        for (Index = 0; Index < Results -> ReportCount; Index++) 
        {
            vCreateUsageValueStringFromArray(UsageValueArray,
                                             Results -> BitSize,
                                             (USHORT) Index,
                                             szTempBuffer);
    
            OUTSTRING(hOutputWindow, szTempBuffer);
        }
        break;

    case HIDP_GET_VALUE_CAPS:
    case HIDP_GET_SPECIFIC_VALUE_CAPS:
        
        ValueCaps = (PHIDP_VALUE_CAPS) Results -> List;

        for (Index = 0; Index < (INT) Results -> ListLength; Index++) 
        {
            OUTSTRING(hOutputWindow, "==========================");
            vDisplayValueAttributes(ValueCaps + Index,
                                    hOutputWindow);
        }
        break;

    case HIDP_MAX_DATA_LIST_LENGTH:
        stringReturn = StringCbPrintf(szTempBuffer, TEMP_BUFFER_SIZE,
                       "MaxDataListLength: %u", Results -> Value);
        OUTSTRING(hOutputWindow, szTempBuffer);
        break;

    case HIDP_MAX_USAGE_LIST_LENGTH:
        stringReturn = StringCbPrintf(szTempBuffer, TEMP_BUFFER_SIZE,
                       "MaxUsageListLength: %u", Results -> Value);
        OUTSTRING(hOutputWindow, szTempBuffer);
        break;

    /*
    // For HidP_UsageListDifference, we need to display both of the make and
    //   break lists generated by the function.  Therefore, we end up creating
    //   two different usage list strings.
    */
    
    case HIDP_USAGE_LIST_DIFFERENCE:
        
        OUTSTRING(hOutputWindow, "Make List");
        OUTSTRING(hOutputWindow, "=========");

        UsageList = (PUSAGE) Results -> MakeList;
        Index = 0;

        while (0 != *(UsageList+Index) && Index < Results -> ListLength) 
        {
            vCreateUsageString(UsageList + Index,
                               szTempBuffer);

            OUTSTRING(hOutputWindow, szTempBuffer);
            Index++;
        }

        OUTSTRING(hOutputWindow, "Break List");
        OUTSTRING(hOutputWindow, "==========");

        UsageList = (PUSAGE) Results -> BreakList;
        Index = 0;

        while (0 != *(UsageList+Index) && Index < Results -> ListLength) 
        {
            vCreateUsageString(UsageList + Index,
                               szTempBuffer);

            OUTSTRING(hOutputWindow, szTempBuffer);
            Index++;
        }
        break;

    /*
    // These functions simply update the buffer that is specified as the 
    //   input parameter.  We must select the correct display buffer mechanism
    //   based on the ReportType for the call and then update the given report
    //   in that display mechanism.
    */
    
    case HID_READ_REPORT:
    case HIDD_GET_FEATURE:
    case HIDD_GET_INPUT_REPORT:
    case HIDP_INITIALIZE_REPORT_FOR_ID:
    case HIDP_SET_BUTTONS:
    case HIDP_SET_DATA:
    case HIDP_SET_SCALED_USAGE_VALUE:
    case HIDP_SET_USAGES:
    case HIDP_SET_USAGE_VALUE:
    case HIDP_SET_USAGE_VALUE_ARRAY:
    case HIDP_UNSET_BUTTONS:
    case HIDP_UNSET_USAGES:
        SELECT_ON_REPORT_TYPE(Results -> ReportType,
                              pInputDisplay,
                              pOutputDisplay,
                              pFeatureDisplay,
                              pDisplay);

        BufferDisplay_UpdateBuffer(pDisplay,
                                   Results -> ReportBuffer);
        break;
    }
    return;
}

VOID 
vExecuteAndDisplayOutput(
    HWND              hOutputWindow,
    PHID_DEVICE       pDevice,
    INT               iFuncCall,
    PECDISPLAY_PARAMS params
)
/*++
RoutineDescription:
    This routine is a long function that is responsible for retrieving all the 
    paramter for a given function call, setting up the CallParameters structure
    and then call the execute routine to get the necessary results and status of 
    the operation.  It is then responsible for displaying the appropriate status
    and results if the function did not fail

    This routine is a fairly long, complex routine to do a simple task.  It may
    be broken down in future versions to simplify some of the complexity.
--*/
{
    EXTCALL_PARAMS    CallParameters;
    EXTCALL_STATUS    CallStatus;

    DLGBOX_STATUS     iDlgStatus;
    BOOL              ExecuteStatus;
    PBUFFER_DISPLAY   pBufferDisplay;
    PCHAR             pCopyBuffer;
    PCHAR             endp;
    UINT              DlgBoxNumber;
    BOOL              List2Alloc;
    BOOL              MakeListAlloc;
    BOOL              BreakListAlloc;

    HID_DEVICE        readDevice, writeDevice;
    BOOL              status;
	HRESULT			  stringReturn;

    /*
    // ExecuteAndDisplayOutput needless to say, consists of two parts: 
    //    Executing and Displaying output.  The first section involves the
    //     execution phase where all parameters are filled in if necessary
    //     and ECDisp_Execute is called
    */

    if (IS_NOT_IMPLEMENTED(iFuncCall)) 
    {
        OUTSTRING(hOutputWindow, "Function not yet implemented");
        return;
    }

    /*
    // Check first to see if this is a HID_CLEAR_REPORT command.  If it is
    //    all we need to do is get the report buffer that is checked and
    //    then call the clear buffer command
    */

    if (HID_CLEAR_REPORT == iFuncCall) 
    {
        SELECT_ON_REPORT_TYPE(params -> ReportType,
                              pInputDisplay,
                              pOutputDisplay,
                              pFeatureDisplay,
                              pBufferDisplay);

        BufferDisplay_ClearBuffer(pBufferDisplay);
        return;
    }

    /*
    // Need to perform the following steps in order to get the parameters for
    //    our call and then execute the call:
    //      1) Get any additional parameters not supplied by the above dialog
    //           procedure.  This occurs for such functions as:
    //                  HIDP_SET_BUTTONS
    //                  HIDP_SET_DATA
    //                  HIDP_SET_USAGES
    //                  HIDP_SET_USAGE_VALUE
    //                  HIDP_SET_SCALED_USAGE_VALUE
    //                  HIDP_SET_USAGE_VALUE_ARRAY
    //                  HIDP_UNSET_BUTTONS
    //                  HIDP_UNSET_USAGES
    //          For these functions, a separate dialog box must be called
    //
    //      2) Fill in the common parameters from the passed in params struct
    //
    */

    /*
    // Step 1: We're storing the values retrieved by these additional dialog
    //          box in the params struct since we may actually be passed in
    //          these values in the future instead of getting them here.  Hence,
    //          we won't break any of the code that follows the switch statement
    */

    switch (iFuncCall) 
    {
    case HIDP_SET_BUTTONS:
    case HIDP_SET_USAGES:
    case HIDP_UNSET_BUTTONS:
    case HIDP_UNSET_USAGES:

        switch (iFuncCall) 
        {
        case HIDP_SET_BUTTONS:
            DlgBoxNumber = IDD_SET_BUTTONS;
            break;

        case HIDP_SET_USAGES:
            DlgBoxNumber = IDD_SET_USAGES;
            break;

        case HIDP_UNSET_BUTTONS:
            DlgBoxNumber = IDD_UNSET_BUTTONS;
            break;

        case HIDP_UNSET_USAGES:
            DlgBoxNumber = IDD_UNSET_USAGES;
            break;
        }

        iDlgStatus = (DLGBOX_STATUS) DialogBoxParam(NULL,
                                                    MAKEINTRESOURCE(DlgBoxNumber),
                                                    GetParent(hOutputWindow),
                                                    bSetUsagesDlgProc,
                                                    (LPARAM) params);
        /*                      
        // If the above call returns 1, then the dialog box routine
        //     successfully acquired a string from the user and put the
        //     pointer to it in params -> szListString.
        //     Now we need to convert the string to a usage list
        */

        if (DLGBOX_OK != iDlgStatus) 
            return;

        ExecuteStatus = ConvertStringToUsageList(params -> szListString,
                                                 &params -> UsageList,
                                                 &params -> ListLength);
        free(params -> szListString);

        if (!ExecuteStatus) 
        {
            ECDISP_ERROR(GetParent(hOutputWindow),
                         "Error getting usage list");
            return;
        }
        break;

    case HIDP_GET_EXTENDED_ATTRIBUTES:
        iDlgStatus = (DLGBOX_STATUS) DialogBoxParam(NULL,
                                                    MAKEINTRESOURCE(IDD_GET_EXT_ATTRIB),
                                                    GetParent(hOutputWindow),
                                                    bGetIndexedDlgProc,
                                                    (LPARAM) params);

        if (DLGBOX_OK != iDlgStatus) 
            return;

        params -> Index = strtoul(params -> szListString, &endp, 10);
        
        if ('\0' != *endp) 
        {
            ECDISP_ERROR(GetParent(hOutputWindow),
                         "Invalid index value");

            free(params -> szListString);
            free(params -> szListString2);                            
            return;
        }
        
        free(params -> szListString);
        params -> ListLength = strtoul(params -> szListString2, &endp, 10);

        if ('\0' != *endp) 
        {
            ECDISP_ERROR(GetParent(hOutputWindow),
                         "Invalid buffer size");

            free(params -> szListString2);
            return;
        }
        free(params -> szListString2);
        break;

    case HIDD_GET_INDEXED_STRING:
        iDlgStatus = (DLGBOX_STATUS) DialogBoxParam(NULL,
                                                    MAKEINTRESOURCE(IDD_GET_INDEX_STRING),
                                                    GetParent(hOutputWindow),
                                                    bGetIndexedDlgProc,
                                                    (LPARAM) params);

        if (DLGBOX_OK != iDlgStatus) 
            return;

        params -> Index = strtoul(params -> szListString, &endp, 10);
        
        if ('\0' != *endp) 
        {
            ECDISP_ERROR(GetParent(hOutputWindow),
                         "Invalid index value");

            free(params -> szListString);
            free(params -> szListString2);                            
            return;
        }
        
        free(params -> szListString);
        params -> ListLength = strtoul(params -> szListString2, &endp, 10);

        if ('\0' != *endp) 
        {
            ECDISP_ERROR(GetParent(hOutputWindow),
                         "Invalid buffer size");
            free(params -> szListString2);
            return;
        }
        free(params -> szListString2);
        break;
        
    case HIDD_GET_MS_GENRE_DESCRIPTOR:
    case HIDD_GET_PHYSICAL_DESCRIPTOR:
    case HIDD_GET_MANUFACTURER_STRING:
    case HIDD_GET_PRODUCT_STRING:
    case HIDD_GET_SERIAL_NUMBER_STRING:
        iDlgStatus = (DLGBOX_STATUS) DialogBoxParam(NULL,
                                                    MAKEINTRESOURCE(IDD_SET_BUFFER_LENGTH),
                                                    GetParent(hOutputWindow),
                                                    bSetBufLenDlgProc,
                                                    (LPARAM) params);

        if (DLGBOX_OK != iDlgStatus) 
            return;

        params -> ListLength = strtoul(params -> szListString, &endp, 10);

        if ('\0' != *endp) 
        {
            free(params -> szListString);                
            ECDISP_ERROR(GetParent(hOutputWindow),
                         "Invalid buffer length");
            return;
        }
        free(params -> szListString);
        break;

    case HIDD_SET_NUM_INPUT_BUFFERS:
        iDlgStatus = (DLGBOX_STATUS) DialogBoxParam(NULL,
                                                    MAKEINTRESOURCE(IDD_SET_INPUT_BUFFERS),
                                                    GetParent(hOutputWindow),
                                                    bSetInputBuffDlgProc,
                                                    (LPARAM) params);
        /*
        // If the above call returns 1, then the dialog box routine
        //     successfully acquired a string from the user and put the
        //     pointer to it in params -> szListString.
        //     Now we need to convert the string to a usage list
        */

        if (DLGBOX_OK != iDlgStatus) 
           return;

        params -> Value = strtoul(params -> szListString, &endp, 10);

        if ('\0' != *endp) 
        {
            ECDISP_ERROR(GetParent(hOutputWindow),
                         "Invalid value specified");

            free(params -> szListString);
            return;
        }
        free(params -> szListString);
        break;

    case HIDP_SET_DATA:
        iDlgStatus = (DLGBOX_STATUS) DialogBoxParam(NULL,
                                                    MAKEINTRESOURCE(IDD_SET_DATA),
                                                    GetParent(hOutputWindow),
                                                    bSetDataDlgProc,
                                                    (LPARAM) params);

        if (DLGBOX_OK != iDlgStatus) 
            return;

        break;

    case HIDP_SET_SCALED_USAGE_VALUE:
        iDlgStatus = (DLGBOX_STATUS) DialogBoxParam(NULL,
                                                    MAKEINTRESOURCE(IDD_SET_SCALED_VALUE),
                                                    GetParent(hOutputWindow),
                                                    bSetValueDlgProc,
                                                    (LPARAM) params);
        /*
        // If the above call returns DLGBOX_OK, then the dialog box routine
        //     successfully acquired a string from the user and put the
        //     pointer to it in params -> szListString.
        //     Now we need to convert the string to a usage list
        */

        if (DLGBOX_OK != iDlgStatus) 
            return;

        params -> ScaledValue = strtol(params -> szListString, &endp, 10);

        if ('\0' != *endp) 
        {
            ECDISP_ERROR(GetParent(hOutputWindow),
                         "Invalid scaled usage value");

            free(params -> szListString);
            return;
        }

        free(params -> szListString);
        break;

    case HIDP_SET_USAGE_VALUE:
        iDlgStatus = (DLGBOX_STATUS) DialogBoxParam(NULL,
                                                    MAKEINTRESOURCE(IDD_SET_USAGE_VALUE),
                                                    GetParent(hOutputWindow),
                                                    bSetValueDlgProc,
                                                    (LPARAM) params);
        /*
        // If the above call returns 1, then the dialog box routine
        //     successfully acquired a string from the user and put the
        //     pointer to it in params -> szListString.
        //     Now we need to convert the string to a usage list
        */

        if (DLGBOX_OK != iDlgStatus) 
           return;

        params -> Value = strtoul(params -> szListString, &endp, 10);
        
        if ('\0' != *endp) 
        {
            ECDISP_ERROR(GetParent(hOutputWindow),
                         "Invalid usage value");

            free(params -> szListString);
            return;
        }
        free(params -> szListString);
        break;


    case HIDP_SET_USAGE_VALUE_ARRAY:
        iDlgStatus = (DLGBOX_STATUS) DialogBoxParam(NULL,
                                                    MAKEINTRESOURCE(IDD_SET_USAGE_VALUE_ARRAY),
                                                    GetParent(hOutputWindow),
                                                    bSetValueDlgProc,
                                                    (LPARAM) params);

        /*
        // If the above call returns 1, then the dialog box routine
        //     successfully acquired a string from the user and put the
        //     pointer to it in params -> szListString.
        //     Now we need to convert the string to a usage list
        */

        if (DLGBOX_OK != iDlgStatus) 
            return;

        ExecuteStatus = ConvertStringToUlongList(params -> szListString,
                                                 &params -> pValueList,
                                                 &params -> ListLength);
        free(params -> szListString);

        if (!ExecuteStatus) 
        {
            ECDISP_ERROR(GetParent(hOutputWindow),
                         "Error getting list of values");
            return;
        }
        break;

    case HIDP_USAGE_LIST_DIFFERENCE:
        iDlgStatus = (DLGBOX_STATUS) DialogBoxParam(NULL,
                                                    MAKEINTRESOURCE(IDD_USAGE_LIST_DIFFERENCE),
                                                    GetParent(hOutputWindow),
                                                    bGetUsageDiffDlgProc,
                                                    (LPARAM) params);

        if (DLGBOX_OK != iDlgStatus) 
        {
            return;
        }

        ExecuteStatus = Strings_StringToUnsignedList(params -> szListString,
                                                     sizeof(USAGE),
                                                     16,
                                                     (PCHAR *) &params -> UsageList,
                                                     &params -> ListLength);

        if (!ExecuteStatus) 
        {
            ECDISP_ERROR(GetParent(hOutputWindow),
                         "Error getting list of values");

            free(params -> szListString);
            free(params -> szListString2);
            return;
        }

        ExecuteStatus = Strings_StringToUnsignedList(params -> szListString2,
                                                     sizeof(USAGE),
                                                     16, 
                                                     (PCHAR *) &params -> UsageList2,
                                                     &params -> ListLength2);

        if (!ExecuteStatus) 
        {
            ECDISP_ERROR(GetParent(hOutputWindow),
                         "Error getting list of values");

            free(params -> szListString);
            free(params -> szListString2);
            free(params -> UsageList);
            return;
        }

        free(params -> szListString);
        free(params -> szListString2);
        break;
    }

    /*
    // Step 2: Extract the common parameters.  It's probably easier
    //    to simply fill in the spots in call parameters whether they are used
    //    or not instead of filling in only those that are relevant to a given
    //    function.  The details of some function relevant parameters are 
    //    handled after this.
    */

    CallParameters.DeviceHandle   = pDevice -> HidDevice;
    CallParameters.ReportType     = params -> ReportType;
    CallParameters.Ppd            = pDevice -> Ppd;
    CallParameters.UsagePage      = params -> UsagePage;
    CallParameters.Usage          = params -> Usage;
    CallParameters.LinkCollection = params -> LinkCollection;
    CallParameters.ReportID       = params -> ReportID;
    CallParameters.List           = NULL;
    CallParameters.List2          = NULL;
    CallParameters.MakeList       = NULL;
    CallParameters.BreakList      = NULL;
    CallParameters.ListLength     = 0;

    List2Alloc     = FALSE;
    MakeListAlloc  = FALSE;
    BreakListAlloc = FALSE;

    /*
    // Step 3: Now we'll deal with those functions that require a report buffer of some kind
    //    which means we'll copy the current buffer of the selected reported
    //    type
    */

    switch (iFuncCall) 
    {
    case HID_READ_REPORT:

        status = OpenHidDevice(pDevice -> DevicePath,
                               TRUE,
                               FALSE,
                               FALSE,
                               FALSE,
                               &readDevice);
        
        if (!status) 
        {
            OUTSTRING(hOutputWindow, "Unable to open device for reading");
        }
        
        CallParameters.DeviceHandle  = readDevice.HidDevice;
        CallParameters.ReportType   = HidP_Input;
        CallParameters.ReportBuffer = readDevice.InputReportBuffer;
        CallParameters.ReportLength = readDevice.Caps.InputReportByteLength;
        break;

    case HID_WRITE_REPORT:

        status = OpenHidDevice(pDevice -> DevicePath,
                               TRUE,
                               FALSE,
                               FALSE,
                               FALSE,
                               &writeDevice);
                               
        if (!status) 
        {
            OUTSTRING(hOutputWindow, "Unable to open device for writing");
        }
        
        BufferDisplay_CopyCurrentBuffer(pOutputDisplay,
                                        writeDevice.OutputReportBuffer);

        CallParameters.DeviceHandle  = writeDevice.HidDevice;
        CallParameters.ReportType    = HidP_Output;
        CallParameters.ReportBuffer  = writeDevice.OutputReportBuffer;
        CallParameters.ReportLength  = writeDevice.Caps.OutputReportByteLength;
        break;

    case HIDD_GET_INPUT_REPORT:
        CallParameters.ReportType   = HidP_Input;
        CallParameters.ReportBuffer = pDevice -> InputReportBuffer;
        CallParameters.ReportLength = pDevice -> Caps.InputReportByteLength;
        break;

    case HIDD_GET_FEATURE:
        CallParameters.ReportType   = HidP_Feature;
        CallParameters.ReportBuffer = pDevice -> FeatureReportBuffer;
        CallParameters.ReportLength = pDevice -> Caps.FeatureReportByteLength;
        break;

    case HIDD_GET_INDEXED_STRING:
    case HIDP_GET_EXTENDED_ATTRIBUTES:
        CallParameters.Index = params -> Index;
        CallParameters.ListLength  = params -> ListLength;
        break;

    case HIDD_SET_OUTPUT_REPORT:
        CallParameters.ReportType = HidP_Output;
        BufferDisplay_CopyCurrentBuffer(pOutputDisplay,
                                        pDevice -> OutputReportBuffer);
        CallParameters.ReportLength = BufferDisplay_GetBufferSize(pOutputDisplay);
        CallParameters.ReportBuffer = pDevice -> OutputReportBuffer;
        break;

    case HIDD_SET_FEATURE:
       CallParameters.ReportType = HidP_Feature;
       BufferDisplay_CopyCurrentBuffer(pFeatureDisplay,
                                       pDevice -> FeatureReportBuffer);
       CallParameters.ReportLength = BufferDisplay_GetBufferSize(pFeatureDisplay);
       CallParameters.ReportBuffer = pDevice -> FeatureReportBuffer;
       break;

    case HIDP_GET_BUTTONS:
    case HIDP_GET_BUTTONS_EX:
    case HIDP_GET_DATA:
    case HIDP_GET_SCALED_USAGE_VALUE:
    case HIDP_GET_USAGES:
    case HIDP_GET_USAGES_EX:
    case HIDP_GET_USAGE_VALUE:
    case HIDP_GET_USAGE_VALUE_ARRAY:
    case HIDP_INITIALIZE_REPORT_FOR_ID:
    case HIDP_SET_BUTTONS:
    case HIDP_SET_DATA:
    case HIDP_SET_SCALED_USAGE_VALUE:
    case HIDP_SET_USAGES:
    case HIDP_SET_USAGE_VALUE:
    case HIDP_SET_USAGE_VALUE_ARRAY:
    case HIDP_UNSET_BUTTONS:
    case HIDP_UNSET_USAGES:
        
        switch (CallParameters.ReportType) 
        {
        case HidP_Input:
            pBufferDisplay = pInputDisplay;
            pCopyBuffer    = pDevice -> InputReportBuffer;
            break;

        case HidP_Output:
            pBufferDisplay = pOutputDisplay;
            pCopyBuffer    = pDevice -> OutputReportBuffer;
            break;

        case HidP_Feature:
            pBufferDisplay = pFeatureDisplay;
            pCopyBuffer    = pDevice -> FeatureReportBuffer;
            break;

        }
        BufferDisplay_CopyCurrentBuffer(pBufferDisplay,
                                        pCopyBuffer);

        CallParameters.ReportLength = BufferDisplay_GetBufferSize(pBufferDisplay);
        CallParameters.ReportBuffer = pCopyBuffer;
        break;

    default:
        CallParameters.ReportLength = 0;
        CallParameters.ReportBuffer = NULL;
    }

    /*
    // Now, we need to deal with those functions which have a List that is 
    //   used for either retrieving or gathering data.  There are two different
    //   cases.  The first involves the user inputting a buffer and the system 
    //   performing some action on the buffer, such as SetButtons.  We'll also 
    //   the other functions that require one of the union fields to be set.
    //   
    */

    /*
    // The second case is where data is retrieved for the device.  In this case,
    //     all we do is specify either the number of elements need for the buffer,
    //     the execute routine will worry about allocating the correct amount of
    //     space for those elements.  Remember, however, that if the Execute routine
    //     allocates space, we need to free it up.
    */

    /*
    // Then there's the third case UsageListDifference which truly changes
    //   everything.  We've got to determine the size of the resulting lists
    //   is the MaxSize of the other two lists.  Plus, we need to insure that 
    //   our buffers are 00 terminated if they are less than the max size, ie
    //   there not the same size as the larger buffer.  This may require
    //   reallocation of the block.
    */

    switch (iFuncCall) 
    {
    /*
    // First Case functions
    */

    case HIDP_SET_DATA:
        CallParameters.List       = (PVOID) params -> pDataList;
        CallParameters.ListLength = params -> ListLength;
        break;

    case HIDP_SET_BUTTONS:
    case HIDP_UNSET_BUTTONS:
    case HIDP_SET_USAGES:
    case HIDP_UNSET_USAGES:
        CallParameters.List       = (PVOID) params -> UsageList;
        CallParameters.ListLength = params -> ListLength;
        break;

    case HIDP_SET_USAGE_VALUE_ARRAY:
        CallParameters.List       = (PVOID) params -> pValueList;
        CallParameters.ListLength = params -> ListLength;
        break;

    /*
    // Second Case functions
    */

    case HIDP_GET_BUTTON_CAPS:
    case HIDP_GET_SPECIFIC_BUTTON_CAPS:
        SELECT_ON_REPORT_TYPE(CallParameters.ReportType,
                              pDevice -> Caps.NumberInputButtonCaps,
                              pDevice -> Caps.NumberOutputButtonCaps,
                              pDevice -> Caps.NumberFeatureButtonCaps,
                              CallParameters.ListLength);
        break;

    case HIDP_GET_LINK_COLL_NODES:
        CallParameters.ListLength = pDevice -> Caps.NumberLinkCollectionNodes;
        break;

    case HIDD_GET_MS_GENRE_DESCRIPTOR:
    case HIDD_GET_PHYSICAL_DESCRIPTOR:
    case HIDD_GET_MANUFACTURER_STRING:
    case HIDD_GET_PRODUCT_STRING:
    case HIDD_GET_SERIAL_NUMBER_STRING:
        CallParameters.ListLength = params -> ListLength;
        break;

    case HIDP_GET_VALUE_CAPS:
    case HIDP_GET_SPECIFIC_VALUE_CAPS:
        SELECT_ON_REPORT_TYPE(CallParameters.ReportType,
                              pDevice -> Caps.NumberInputValueCaps,
                              pDevice -> Caps.NumberOutputValueCaps,
                              pDevice -> Caps.NumberFeatureValueCaps,
                              CallParameters.ListLength);

    case HIDD_GET_FREE_PREPARSED_DATA:
        CallParameters.ppPd = &CallParameters.Ppd;
        break;

    case HIDP_SET_SCALED_USAGE_VALUE:
        CallParameters.ScaledValue = params -> ScaledValue;
        break;

    case HIDP_SET_USAGE_VALUE:
    case HIDD_SET_NUM_INPUT_BUFFERS:
        CallParameters.Value = params -> Value;
        break;

    /*
    // That third case
    */

    case HIDP_USAGE_LIST_DIFFERENCE:
        CallParameters.ListLength = max(params -> ListLength,
                                        params -> ListLength2);

        CallParameters.List  = params -> UsageList;
        CallParameters.List2 = params -> UsageList2;

        if (CallParameters.ListLength > params -> ListLength) 
        {
            CallParameters.List = (PUSAGE) realloc(params -> UsageList,
                                                   (params -> ListLength+1) * sizeof(USAGE));

            if (NULL == CallParameters.List) 
            {
                ECDISP_ERROR(GetParent(hOutputWindow),
                             "Error allocating memory");

                free(params -> UsageList);
                free(params -> UsageList2);

                return;
            }

            *(((PUSAGE) CallParameters.List) + CallParameters.ListLength - 1) = 0;
        }
        else if (CallParameters.ListLength > params -> ListLength2) 
        {
            CallParameters.List2 = (PUSAGE) realloc(params -> UsageList2,
                                                   (params -> ListLength+1) * sizeof(USAGE));

            if (NULL == CallParameters.List2) 
            {
                ECDISP_ERROR(GetParent(hOutputWindow),
                             "Error allocating memory");

                free(params -> UsageList);
                free(params -> UsageList2);
                return;
            }

            *(((PUSAGE) CallParameters.List2) + CallParameters.ListLength - 1) = 0;
        }
        List2Alloc = TRUE;
        MakeListAlloc = TRUE;
        BreakListAlloc = TRUE;
        break;
    }

    /*
    // Params are now set up and ready to go, let's execute
    */

    if (HIDD_GET_FREE_PREPARSED_DATA == iFuncCall) 
    {
        ExecuteStatus = ECDisp_Execute(HIDD_GET_PREPARSED_DATA,
                                       &CallParameters,
                                       &CallStatus);

        if (!ExecuteStatus)
        {
            OUTSTRING(hOutputWindow, "Unknown error: Couldn't execute function");
            return;
        }

        DISPLAY_HIDD_STATUS(hOutputWindow, 
                            "HidD_GetPreparsedData",
                            CallStatus,
							stringReturn);

        if (!CallStatus.IsHidError)
        {
            ExecuteStatus = ECDisp_Execute(HIDD_FREE_PREPARSED_DATA,
                                           &CallParameters,
                                           &CallStatus);

            OUTSTRING(hOutputWindow, "=======================");
            
            if (!ExecuteStatus) 
            {
                OUTSTRING(hOutputWindow, "Unknown error: Couldn't execute function");
                return;
            }

            DISPLAY_HIDD_STATUS(hOutputWindow, 
                                "HidD_FreePreparsedData",
                                CallStatus,
								stringReturn);
        }
    }
    else
    {
        if ((HID_READ_REPORT == iFuncCall || HID_WRITE_REPORT == iFuncCall) &&
            (!status)) 
        {
            //
            // Indicate there was an error so we don't display anything further
            //
        
            CallStatus.IsHidError = TRUE;
        }
        else 
        {    
            ExecuteStatus = ECDisp_Execute(iFuncCall,
                                           &CallParameters,
                                           &CallStatus);

            if (!ExecuteStatus) 
            {
                OUTSTRING(hOutputWindow, "Unknown error: Couldn't execute function");
                return;
            }

            if (IS_HIDD_FUNCTION(iFuncCall) || IS_HID_FUNCTION(iFuncCall)) 
            {
                DISPLAY_HIDD_STATUS(hOutputWindow, 
                                    GET_FUNCTION_NAME(iFuncCall),
                                    CallStatus,
									stringReturn);

            }
            else 
            {
                DISPLAY_HIDP_STATUS(hOutputWindow,
                                    GET_FUNCTION_NAME(iFuncCall),
                                    CallStatus,
									stringReturn);
            }
        }            
    }

    /*
    // Display the other results only if there wasn't a HID error
    */

    if (!CallStatus.IsHidError || (HIDP_STATUS_NULL == CallStatus.HidErrorCode)) 
    {
        OUTSTRING(hOutputWindow, "=======================");

        /*
        // Now that general status information has been displayed, we need to
        //   display the info for the parts that are dependent on the function being
        //   called
        */
    
        ECDisp_DisplayOutput(hOutputWindow,
                            iFuncCall,
                            &CallParameters);
    }

    if (CallParameters.List != NULL) 
    {
        free(CallParameters.List);
    }

    if (List2Alloc && CallParameters.List2 != NULL) 
    {
        free(CallParameters.List2);
    }

    if (MakeListAlloc && CallParameters.MakeList != NULL) 
    {
        free(CallParameters.MakeList);
    }

    if (BreakListAlloc && CallParameters.BreakList != NULL)
    {
        free(CallParameters.BreakList);
    }

    return;
}

VOID
BuildReportIDList(
    IN  PHIDP_BUTTON_CAPS  phidButtonCaps,
    IN  USHORT             nButtonCaps,
    IN  PHIDP_VALUE_CAPS   phidValueCaps,
    IN  USHORT             nValueCaps,
    OUT PUCHAR            *ppReportIDList,
    OUT INT               *nReportIDs
)
/*++
RoutineDescription:
    This routine builds a list of report IDs that are listed in the passed in set
    of ButtonCaps and ValueCaps structure.  It allocates a buffer to store all
    the ReportIDs, if it can.  Otherwise the buffer is returned as NULL.

    Currently, this routine has no purpose in the HClient program. It was written
    for some purpose which never materialized but was left in because it might be
    useful in the future.
--*/
{    
    INT               nAllocatedIDs;
    INT               nFoundIDs;
    INT               nWalkCount;
    USHORT            usIndex;
    BOOL              fIDFound;
    UCHAR             *pucBuffer;
    UCHAR             *pucNewBuffer;
    UCHAR             *pucWalk;
    UCHAR             ucReportID;
    PHIDP_BUTTON_CAPS pButtonWalk;
    PHIDP_VALUE_CAPS  pValueWalk;

    /*
    // Initialize the output parameters in case there is some sort of failure
    */

    *nReportIDs = 0;
    *ppReportIDList = NULL;

    if (0 == nButtonCaps && 0 == nValueCaps)
        return;

    /*
    // Initialize the beginning array size to 2 report IDs and alloc space
    // for those IDs.  If we need to add more report IDs we allocate more
    // space
    */

    nAllocatedIDs = 2;
    nFoundIDs = 0;
    pButtonWalk = phidButtonCaps;
    pValueWalk = phidValueCaps;
                                              
    pucBuffer = (UCHAR *) malloc(sizeof(UCHAR) * nAllocatedIDs);
    if (NULL == pucBuffer) 
        return;

    /*
    // Beginning with the button caps and then going to the value caps do the
    // following
    //
    // 1) Take the report ID and search the array of report IDs looking for 
    //       an existing report ID and add to the array if not there.  
    //
    // 2) Add the report ID to the array in sorted order that way we sort the
    //      array at any time.  
    // 
    // 3) Must also realloc the array if we run out of array space
    */

    for (usIndex = 0; usIndex < nButtonCaps; usIndex++, pButtonWalk++) 
    {
        ucReportID = pButtonWalk -> ReportID;
        
        pucWalk = pucBuffer;
        nWalkCount = 0;
        fIDFound = FALSE;

        while (!fIDFound && nWalkCount < nFoundIDs) 
        {
            if (*pucWalk == ucReportID) 
            {
                fIDFound = TRUE;
            }
            else if (ucReportID > *pucWalk) 
            {
                pucWalk++;
                nWalkCount++;
            }
        }

        if (!fIDFound) 
        {
            if (nFoundIDs == nAllocatedIDs) 
            {
                nAllocatedIDs *= 2;

                pucNewBuffer = (UCHAR *) realloc(pucBuffer, sizeof(UCHAR) * nAllocatedIDs);

                if (NULL == pucNewBuffer)
				{
					free(pucBuffer);
					pucBuffer = NULL;
					return;
				}
				else
				{
					pucBuffer = pucNewBuffer;
				}

                pucWalk = pucBuffer + nWalkCount;
            }

            /*
            // At this point, pucWalk points to the smallest ReportID in the
            //   buffer that is greater than the ReportID we want to insert.
            //   We need to bump all reportIDs beginning at pucWalk up one 
            //   spot and insert the new ReportID at pucWalk
            */

            memmove (pucWalk+1, pucWalk, (nFoundIDs - nWalkCount) * sizeof(UCHAR));
            *pucWalk = ucReportID;
            nFoundIDs++;
        }
    }

    *ppReportIDList = pucBuffer;
    *nReportIDs = nFoundIDs;
    
    return;
}

LRESULT CALLBACK
bSetUsagesDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
)
{
    static PECDISPLAY_PARAMS  pParams;
           INT                StringLength;
           DLGBOX_STATUS      RetValue;

    switch (message) 
    {
    case WM_INITDIALOG:
        
        pParams = (PECDISPLAY_PARAMS) lParam;

        SetDlgItemIntHex(hDlg, 
                         IDC_USAGE_PAGE, 
                         pParams -> UsagePage,
                         2);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) 
        {
        case IDOK:
            StringLength = GetWindowTextLength(GetDlgItem(hDlg, IDC_USAGE_LIST));

            if (StringLength > 0) 
            {
                pParams -> szListString = (PCHAR) malloc(StringLength+1);
                if (NULL == pParams -> szListString) 
                {
                    ECDISP_ERROR(hDlg, "Error allocating memory");
                    RetValue = DLGBOX_ERROR;
                }
                else
                {
                    GetWindowText(GetDlgItem(hDlg, IDC_USAGE_LIST),
                                  pParams -> szListString,
                                  StringLength+1);

                    RetValue = DLGBOX_OK;
                }
            }
            else 
            {
                pParams -> szListString = NULL;
                RetValue = DLGBOX_CANCEL;
            }

            EndDialog(hDlg, RetValue);
            break;

        case IDCANCEL:
            EndDialog(hDlg, DLGBOX_CANCEL);
            break;
        }
        break;
    }
    return (FALSE);
}

LRESULT CALLBACK
bSetValueDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
)
{
    static PECDISPLAY_PARAMS  pParams;
           INT                StringLength;
           DLGBOX_STATUS      RetValue;

    switch (message) 
    {
    case WM_INITDIALOG:

        pParams = (PECDISPLAY_PARAMS) lParam;

        SetDlgItemIntHex(hDlg, 
                         IDC_USAGE_PAGE, 
                         pParams -> UsagePage,
                         sizeof(USAGE));

        SetDlgItemIntHex(hDlg,
                         IDC_USAGE,
                         pParams -> Usage,
                         sizeof(USAGE));
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) 
        {
        case IDOK:
            StringLength = GetWindowTextLength(GetDlgItem(hDlg, IDC_VALUE));

            if (StringLength > 0) 
            {
                pParams -> szListString = (PCHAR) malloc(StringLength+1);
                if (NULL == pParams -> szListString) 
                {
                    ECDISP_ERROR(hDlg, "Error allocating memory");

                    RetValue = DLGBOX_ERROR;
                }
                else 
                {
                    GetWindowText(GetDlgItem(hDlg, IDC_VALUE),
                                  pParams -> szListString,
                                  StringLength+1);

                    RetValue = DLGBOX_OK;
                }
            }
            else
            {
                pParams -> szListString = NULL;
                RetValue = DLGBOX_CANCEL;
            }

            EndDialog(hDlg, RetValue);
            break;

        case IDCANCEL:
            EndDialog(hDlg, DLGBOX_CANCEL);
            break;
        }
        break;
    }
    return (FALSE);
}

LRESULT CALLBACK
bSetInputBuffDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
)
{
    static PECDISPLAY_PARAMS  pParams;
           INT                StringLength;
           DLGBOX_STATUS      RetValue;

    switch (message) 
    {
    case WM_INITDIALOG:
        pParams = (PECDISPLAY_PARAMS) lParam;
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) 
        {
        case IDOK:
            StringLength = GetWindowTextLength(GetDlgItem(hDlg, IDC_INPUT_BUFFERS));

            if (StringLength > 0) 
            {
                pParams -> szListString = (PCHAR) malloc(StringLength+1);

                if (NULL == pParams -> szListString) 
                {
                    ECDISP_ERROR(hDlg, "Error allocating memory");

                    RetValue = DLGBOX_ERROR;
                }
                else 
                {
                    GetWindowText(GetDlgItem(hDlg, IDC_INPUT_BUFFERS),
                                  pParams -> szListString,
                                  StringLength+1);

                    RetValue = DLGBOX_OK;
                }
            }
            else 
            {
                pParams -> szListString = NULL;
                RetValue = DLGBOX_CANCEL;
            }

            EndDialog(hDlg, RetValue);
            break;

        case IDCANCEL:
            EndDialog(hDlg, DLGBOX_CANCEL);
            break;
        }
        break;
    }
    return (FALSE);
}


LRESULT CALLBACK
bSetDataDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
)
{
    static CHAR               DataString[TEMP_BUFFER_SIZE];
    static PECDISPLAY_PARAMS  pParams;
           UINT               IndexValue;
           ULONG              Value;
           BOOL               lpTranslated;
           DLGBOX_STATUS      RetValue;
           PCHAR              endp;
           INT                ListBoxStatus;
           PHIDP_DATA         DataList;
           PHIDP_DATA         CurrData;
           ULONG              DataListLength;
           ULONG              Index;
		   HRESULT			  stringReturn;
		   INT				  iReturn;

    switch (message)
    {
    case WM_INITDIALOG:

        pParams = (PECDISPLAY_PARAMS) lParam;
        SendMessage(GetDlgItem(hDlg, IDC_VALUE),
                    EM_SETLIMITTEXT,
                    (WPARAM) 1024,
                    0);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) 
        {
        case IDC_ADD_DATA:
            IndexValue = GetDlgItemInt(hDlg,
                                       IDC_INDEX,
                                       &lpTranslated,
                                       FALSE);
            if (!lpTranslated) 
            {
                ECDISP_ERROR(hDlg,
                           "Invalid index value: must be unsigned integer");
                break;
            }
            
            if (0 == GetWindowText(GetDlgItem(hDlg, IDC_VALUE), 
                                   DataString, 1023)) 
            {                                          
                ECDISP_ERROR(hDlg, "Invalid data value");
                break;
            }

            CharUpperBuff(DataString, lstrlen(DataString));

            if (0 == lstrcmp(DataString, "TRUE"))
            {
                Value = 1;
            }
            else if (0 == lstrcmp(DataString, "FALSE")) 
            {
                Value = 0;
            }
            else 
            {
                Value = strtoul(DataString, &endp, 10);
                if (*endp != '\0') 
                {
                    ECDISP_ERROR(hDlg, "Invalid data value");
                    break;
                }
            }
            stringReturn = StringCbPrintf(DataString,
                           TEMP_BUFFER_SIZE,
                           SETDATA_LISTBOX_FORMAT, 
                           IndexValue,
                           Value);

            ListBoxStatus = (INT) SendMessage(GetDlgItem(hDlg, IDC_DATA_LIST),
                                              LB_ADDSTRING,
                                              0,
                                              (LPARAM) DataString);

            if (CB_ERR == ListBoxStatus || CB_ERRSPACE == ListBoxStatus) 
            {
                ECDISP_ERROR(hDlg, "Error adding string to data list");
                break;
            }
            break;

        case IDC_REMOVE_DATA:
            SendMessage(GetDlgItem(hDlg, IDC_DATA_LIST),
                        LB_DELETESTRING,
                        SendMessage(GetDlgItem(hDlg, IDC_DATA_LIST),
                                    LB_GETCURSEL,
                                    0, 0),
                        0);
            break;

        case IDOK:
            DataListLength = (ULONG) SendMessage(GetDlgItem(hDlg, IDC_DATA_LIST),
                                                 LB_GETCOUNT,
                                                 0, 0);

            if (0 != DataListLength)
            {
                DataList = malloc(DataListLength * sizeof(HIDP_DATA));
                if (NULL == DataList) 
                {
                    ECDISP_ERROR(hDlg, "Error allocating memory");

                    DataListLength = 0;
                    RetValue = DLGBOX_CANCEL;
                    break;
                }
                
                for (Index = 0, CurrData = DataList; Index < DataListLength; Index++, CurrData++) 
                {
                    SendMessage(GetDlgItem(hDlg, IDC_DATA_LIST),
                                LB_GETTEXT,
                                Index,
                                (LPARAM) DataString);

                    iReturn = sscanf(DataString, 
                           SETDATA_LISTBOX_FORMAT,
                           &IndexValue,
                           &Value);

                    CurrData -> DataIndex = (USHORT) IndexValue;
                    CurrData -> RawValue = Value;
                }
                RetValue = DLGBOX_OK;
            }
            else 
            {
                DataList = NULL;
                RetValue = DLGBOX_CANCEL;
            }

            pParams -> pDataList = DataList;
            pParams -> ListLength = DataListLength;
            EndDialog(hDlg, RetValue);
            break;

        case IDCANCEL:
            EndDialog(hDlg, DLGBOX_CANCEL);
            break;
        }
        break;
    }
    return (FALSE);
}

LRESULT CALLBACK
bSetBufLenDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
)
{
    static PECDISPLAY_PARAMS  pParams;
           INT                StringLength;
           DLGBOX_STATUS      RetValue;

    switch (message) 
    { 
   case WM_INITDIALOG:

        pParams = (PECDISPLAY_PARAMS) lParam;
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) 
        {
        case IDOK:
            StringLength = GetWindowTextLength(GetDlgItem(hDlg, IDC_BUFFER_LENGTH));

            if (StringLength > 0) 
            {
                pParams -> szListString = (PCHAR) malloc(StringLength+1);
                if (NULL == pParams -> szListString) 
                {
                    ECDISP_ERROR(hDlg, "Error allocating memory");

                    RetValue = DLGBOX_ERROR;

                }
                else 
                {
                    GetWindowText(GetDlgItem(hDlg, IDC_BUFFER_LENGTH),
                                  pParams -> szListString,
                                  StringLength+1);

                    RetValue = DLGBOX_OK;
                }
            }
            else
            {
                pParams -> szListString = NULL;
                RetValue = DLGBOX_CANCEL;
            }

            EndDialog(hDlg, RetValue);
            break;

        case IDCANCEL:
            EndDialog(hDlg, DLGBOX_CANCEL);
            break;
        }
        break;
    }
    return (FALSE);
}

LRESULT CALLBACK
bSetInputBuffersDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
)
{
    static PECDISPLAY_PARAMS  pParams;
           INT                StringLength;
           DLGBOX_STATUS      RetValue;

    switch (message) 
    {
    case WM_INITDIALOG:

        pParams = (PECDISPLAY_PARAMS) lParam;
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) 
        {
        case IDOK:
            StringLength = GetWindowTextLength(GetDlgItem(hDlg, IDC_INPUT_BUFFERS));

            if (StringLength > 0) 
            {
                pParams -> szListString = (PCHAR) malloc(StringLength+1);

                if (NULL == pParams -> szListString) 
                {
                    ECDISP_ERROR(hDlg, "Error allocating memory");
                    RetValue = DLGBOX_ERROR;
                }
                else 
                {
                    GetWindowText(GetDlgItem(hDlg, IDC_INPUT_BUFFERS),
                                  pParams -> szListString,
                                  StringLength+1
                                 );
                    RetValue = DLGBOX_OK;
                }
            }
            else
            {
                pParams -> szListString = NULL;
                RetValue = DLGBOX_CANCEL;
            }

            EndDialog(hDlg, RetValue);
            break;

        case IDCANCEL:
            EndDialog(hDlg, DLGBOX_CANCEL);
            break;
        }
        break;
    }
    return (FALSE);
}

LRESULT CALLBACK
bGetIndexedDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
)
{
    static PECDISPLAY_PARAMS  pParams;
           INT                StringLength;
           INT                StringLength2;
           DLGBOX_STATUS      RetValue;

    switch (message) 
    {
    case WM_INITDIALOG:

        pParams = (PECDISPLAY_PARAMS) lParam;
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) 
        {
        case IDOK:       
            StringLength  = GetWindowTextLength(GetDlgItem(hDlg, IDC_INDEX));
            StringLength2 = GetWindowTextLength(GetDlgItem(hDlg, IDC_BUFFER_LENGTH));

            if (StringLength <= 0 || StringLength2 <= 0) 
            {
                pParams -> szListString = NULL;
                pParams -> szListString2 = NULL;
                RetValue = DLGBOX_CANCEL;
                EndDialog(hDlg, DLGBOX_CANCEL);
            }

            pParams -> szListString = (PCHAR) malloc(StringLength+1);
            pParams -> szListString2 = (PCHAR) malloc(StringLength2+1);

            if (NULL == pParams -> szListString || NULL == pParams -> szListString2) 
            {
                   ECDISP_ERROR(hDlg, "Error allocating memory");

                   if (NULL != pParams -> szListString) 
                       free(pParams -> szListString);

                   if (NULL != pParams -> szListString2) 
                       free(pParams -> szListString2);

                   RetValue = DLGBOX_ERROR;
            }
            else 
            {
                GetWindowText(GetDlgItem(hDlg, IDC_INDEX),
                              pParams -> szListString,
                              StringLength+1);

                GetWindowText(GetDlgItem(hDlg, IDC_BUFFER_LENGTH),
                              pParams -> szListString2,
                              StringLength2+1);

                RetValue = DLGBOX_OK;
            }
            EndDialog(hDlg, RetValue);
            break;

        case IDCANCEL:
            EndDialog(hDlg, DLGBOX_CANCEL);
            break;
        }
        break;
    }
    return (FALSE);
}

LRESULT CALLBACK
bGetUsageDiffDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
)
{
    static PECDISPLAY_PARAMS  pParams;
           INT                StringLength;
           INT                StringLength2;
           DLGBOX_STATUS      RetValue;

    switch (message) 
    {
    case WM_INITDIALOG:

        pParams = (PECDISPLAY_PARAMS) lParam;
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) 
        {
        case IDOK:       
            StringLength  = GetWindowTextLength(GetDlgItem(hDlg, IDC_USAGE_LIST1));
            StringLength2 = GetWindowTextLength(GetDlgItem(hDlg, IDC_USAGE_LIST2));

            if (StringLength <= 0) 
            {
                pParams -> szListString = NULL;
            }
            else 
            {
                pParams -> szListString = (PCHAR) malloc(StringLength+1);
                if (NULL == pParams -> szListString) 
                {
                    ECDISP_ERROR(hDlg,
                                 "Error allocating memory");

                    EndDialog(hDlg, DLGBOX_ERROR);
                    break;
                }
            }

            if (StringLength2 <= 0) 
            {
                pParams -> szListString2 = NULL;
            }
            else 
            {
                pParams -> szListString2 = (PCHAR) malloc(StringLength2+1);
                if (NULL == pParams -> szListString2) 
                {
                    ECDISP_ERROR(hDlg,
                                 "Error allocating memory");

                    if (NULL != pParams -> szListString)
                    {
                        free(pParams -> szListString);
                    }
                    EndDialog(hDlg, DLGBOX_ERROR);
                    break;
                }
            }

            if ( !(pParams->szListString) )
            {
                GetWindowText(GetDlgItem(hDlg, IDC_USAGE_LIST1),
                              pParams -> szListString,
                              StringLength+1);
            }

            if ( !(pParams->szListString2) )
            {
                GetWindowText(GetDlgItem(hDlg, IDC_USAGE_LIST2),
                              pParams -> szListString2,
                              StringLength2+1);
            }

            RetValue = DLGBOX_OK;

            EndDialog(hDlg, RetValue);
            break;

        case IDCANCEL:
            EndDialog(hDlg, DLGBOX_CANCEL);
            break;
        }
        break;
    }
    return (FALSE);
}

BOOL
ConvertStringToUsageList(
    IN OUT PCHAR   InString,
    OUT    PUSAGE  *UsageList,
    OUT    PULONG  nUsages
)
/*++
RoutineDescription:
    This routine converts a string of values into a string of usages which are
    currently 2 byte values.  We use base 16 to specify that the usages should 
    be expressed as hexidecimal numbers.
--*/
{
    return (Strings_StringToUnsignedList(InString,
                                         sizeof(ULONG),
                                         16,
                                         (PCHAR *) UsageList,
                                         nUsages));
}

BOOL
ConvertStringToUlongList(
    IN OUT PCHAR   InString,
    OUT    PULONG  *UlongList,
    OUT    PULONG  nUlongs
)
/*++
RoutineDescription
    This routine converts a string of values into a string of ulongs which are
    currently 2 byte values.  It requires that the numbers in the string be in
    base 10
--*/
{
    return (Strings_StringToUnsignedList(InString,
                                         sizeof(ULONG),
                                         10,
                                         (PCHAR *) UlongList,
                                         nUlongs));
}

BOOL
SetDlgItemIntHex(
   HWND hDlg, 
   INT nIDDlgItem, 
   UINT uValue, 
   INT nBytes
)
{
    char szTempBuff[] = "0x00000000";
    int  iEndIndex, iWidth;
	HRESULT stringReturn;

    assert (1 == nBytes || 2 == nBytes || 4 == nBytes);

    /*
    // Determine the width necessary to store the value
    */

    stringReturn = StringCbPrintf(szTempBuff,
				   (sizeof(szTempBuff)),
                   "0x%*X", (nBytes*2), uValue);

    SetDlgItemText(hDlg, nIDDlgItem, szTempBuff);

    return (TRUE);
}

VOID
ECDisp_MakeGUIDString(
    IN  GUID guid, 
    OUT CHAR szString[],
	IN  UINT uiBuffSize
)
{
    CHAR szCharString[18];
    INT i;
	HRESULT stringReturn;

    for (i = 0; i < 8; i++) 
    {
        stringReturn = StringCbPrintf(&(szCharString[i]), sizeof(szCharString),
                       "%x", guid.Data4[i]);
    }
    
    stringReturn = StringCbPrintf(szString, uiBuffSize,
                   "%x-%x%x-%s", guid.Data1, guid.Data2, guid.Data3, szCharString);
    return;
}

PCHAR
ECDisp_GetHidAppStatusString(
    NTSTATUS StatusCode
)
{
    static CHAR hidString[128];
	HRESULT		stringReturn;

    switch (StatusCode) 
    {
    case HIDP_STATUS_SUCCESS:
        return ("Success");

    case HIDP_STATUS_NULL:
        return ("Status NULL");

    case HIDP_STATUS_INVALID_PREPARSED_DATA:
        return ("Invalid Preparsed Data");

    case HIDP_STATUS_INVALID_REPORT_TYPE:
        return ("Invalid Report Type");

    case HIDP_STATUS_INVALID_REPORT_LENGTH:
        return ("Invalid Report Length");

    case HIDP_STATUS_USAGE_NOT_FOUND:
        return ("Usage not found");

    case HIDP_STATUS_VALUE_OUT_OF_RANGE:
        return ("Value out of range");

    case HIDP_STATUS_BAD_LOG_PHY_VALUES:
        return ("Bad logical physical values");

    case HIDP_STATUS_BUFFER_TOO_SMALL:
        return ("Buffer too small");

    case HIDP_STATUS_INTERNAL_ERROR:
        return ("Internal error");

    case HIDP_STATUS_I8242_TRANS_UNKNOWN:
        return ("I8242 Translation unknown");

    case HIDP_STATUS_INCOMPATIBLE_REPORT_ID:
        return ("Incompatible report ID");

    case HIDP_STATUS_NOT_VALUE_ARRAY:
        return ("Not value array");

    case HIDP_STATUS_IS_VALUE_ARRAY:
        return ("Is value array");

    case HIDP_STATUS_DATA_INDEX_NOT_FOUND:   
        return ("Data index not found");

    case HIDP_STATUS_DATA_INDEX_OUT_OF_RANGE:
        return ("Data index out of range");

    case HIDP_STATUS_BUTTON_NOT_PRESSED:     
        return ("Button not pressed");

    case HIDP_STATUS_REPORT_DOES_NOT_EXIST:
        return ("Report does not exist");

    case HIDP_STATUS_NOT_IMPLEMENTED:        
        return ("Not implemented");

    default:
        stringReturn = StringCbPrintf(hidString, sizeof(hidString),
                       "Unknown HID Status error: 0x%x", StatusCode);
        return (hidString);
    }
}             

BOOL
ECDisp_ConvertUlongListToValueList(
    IN  PULONG  UlongList,
    IN  ULONG   nUlongs,
    IN  USHORT  BitSize,
    IN  USHORT  ReportCount,
    OUT PCHAR   *ValueList,
    OUT PULONG  ValueListSize
)
/*++
RoutineDescription:
    This routine takes a list of ULong values and formats a value list that is 
    used as input to HidP_SetUsageValueArray.  Unfortunately, this HidP function
    requires the caller to format the input buffer which means taking each of
    the values in Ulong, truncating their values to meet bit size and then set 
    those bits at the appropriate spot in the buffer.  That is the purpose of
    this function

    The function will return TRUE if everything succeeded, FALSE otherwise.
--*/
{

    ULONG       ulMask;
    PCHAR       List;
    INT         iByteIndex;
    INT         iByteOffset;
    ULONG       UlongIndex;
    ULONG       ListSize;
    USHORT      BitsToAdd;
    USHORT      nBits;
    ULONG       ulValue;
    UCHAR       LowByte;

    *ValueList = NULL;
    *ValueListSize = 0;
    
    //
    // Do some parameter validation...ReportCount should never be zero.
    //

    if (0 == ReportCount)
    {
        SetLastError(ERROR_INVALID_PARAMETER);

        return (FALSE);
    }

    //
    // Check the number of ulongs passed in is actually less than or equal
    //  to the report count and if not, use only the first ReportCount
    //  number of ULongs.
    //

    if (nUlongs > ReportCount)
    {
        nUlongs = ReportCount;
    }

    /*
    // Allocate our buffer for the value list and return FALSE if it couldn't
    //   be done
    */

    ListSize = ROUND_TO_NEAREST_BYTE(BitSize * ReportCount);
    List = (PCHAR) malloc(ListSize);

    if (NULL == List) 
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return (FALSE);
    }

    /*
    // Initialize the buffer to all zeroes
    */

    memset(List, 0x00, ListSize);

    /*
    // Buffer has been allocated let's convert those values
    */

    /*
    // Determine the mask that will be used to retrieve the cared about bits
    //   of our value
    */

    ulMask = (sizeof(ULONG)*8 == BitSize) ? ULONG_MAX : (1 << BitSize)-1;

    /*
    // Initialize the iByteIndex and iByteOffset fields before entering the
    //    conversion loop.
    */

    iByteIndex = 0;
    iByteOffset = 0;

    /*
    // This is the main conversion loop.  It performs the following steps on
    //    each Ulong in the ulong list
    //      1) Sets BitsToAdd = BitSize
    //      2) Gets the ulValue and the masks off the upper bits that we don't
    //           care about.
    //      3) Determines how many bits can fit at the current byte index based
    //          on the current byte offset and the number of bits left to add
    //      4) Retrieve those bits, shift them to the correct position and 
    //            use bitwise or to get the correct values in the buffer
    //      5) Increment the byte index and set our new byte offset
    //      6) Shift our Ulong value right to get rid of least significant bits
    //           that have already been added
    //      7) Repeat through step 3 until no more bits to add
    */

    for (UlongIndex = 0; UlongIndex < nUlongs; UlongIndex++) 
    {    
        BitsToAdd = BitSize;

        ulValue = *(UlongList + UlongIndex) & ulMask;

        while (BitsToAdd > 0) 
        {
            nBits = min (8 - iByteOffset, BitsToAdd);
            
            LowByte = (UCHAR) (ulValue & 0xFF);
            
            LowByte = LowByte << iByteOffset;

            *(List+iByteIndex) |= LowByte;

            iByteIndex = (iByteOffset+nBits) >= 8 ? iByteIndex+1 : iByteIndex;
            iByteOffset = (iByteOffset + nBits) % 8;

            BitsToAdd -= nBits;

            ulValue = ulValue >> nBits;
        }
    }
        
    *ValueList = List;
    *ValueListSize = ListSize;

    return (TRUE);
}

PCHAR
ResolveFunctionName(
    INT Index
)
{
    PCHAR   FuncName;

    if (IS_HIDD_FUNCTION(Index) || IS_HID_FUNCTION(Index))
    {
        FuncName = DeviceCalls[Index-1].szFunctionName;
    }
    else
    {
        FuncName = PpdCalls[Index-HID_DEVCALLS-1].szFunctionName;
    }

    return (FuncName);
}

VOID
DisplayExtendedAttributes(
    IN  HWND                OutputWindow,
    IN  PHIDP_UNKNOWN_TOKEN UnknownList,
    IN  ULONG               UnknownListLength
)
{
    PHIDP_UNKNOWN_TOKEN current;
    ULONG               index;
	HRESULT				stringReturn;

    stringReturn = StringCbPrintf(szTempBuffer, TEMP_BUFFER_SIZE,
                   "Number of attributes: %d", UnknownListLength);
    OUTSTRING(OutputWindow, szTempBuffer);
    
    current = UnknownList;
    for (index = 0; index < UnknownListLength; index++) 
    {
       stringReturn = StringCbPrintf(szTempBuffer,
                      TEMP_BUFFER_SIZE,
                      "Token: %d  BitField: 0x%X", 
                      current -> Token,
                      current -> BitField);
            
        OUTSTRING(OutputWindow, szTempBuffer);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\client\hclient\pnp.c ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    pnp.c

Abstract:

    This module contains the code
    for finding, adding, removing, and identifying hid devices.

Environment:

    User mode

@@BEGIN_DDKSPLIT

Revision History:

    Nov-96 : Created by Kenneth D. Ray

@@END_DDKSPLIT
--*/

#include <basetyps.h>
#include <stdlib.h>
#include <wtypes.h>
#include <setupapi.h>
#include "hidsdi.h"
#include "hid.h"
#include <strsafe.h>

BOOLEAN
FindKnownHidDevices (
   OUT PHID_DEVICE * HidDevices, // A array of struct _HID_DEVICE
   OUT PULONG        NumberDevices // the length of this array.
   )
/*++
Routine Description:
   Do the required PnP things in order to find all the HID devices in
   the system at this time.
--*/
{
    HDEVINFO                            hardwareDeviceInfo;
    SP_DEVICE_INTERFACE_DATA            deviceInfoData;
    ULONG                               i;
    BOOLEAN                             done;
    PHID_DEVICE                         hidDeviceInst;
    GUID                                hidGuid;
    PSP_DEVICE_INTERFACE_DETAIL_DATA    functionClassDeviceData = NULL;
    ULONG                               predictedLength = 0;
    ULONG                               requiredLength = 0;
    PHID_DEVICE                         newHidDevices;


    HidD_GetHidGuid (&hidGuid);

    *HidDevices = NULL;
    *NumberDevices = 0;

    //
    // Open a handle to the plug and play dev node.
    //
    hardwareDeviceInfo = SetupDiGetClassDevs ( &hidGuid,
                                               NULL, // Define no enumerator (global)
                                               NULL, // Define no
                                               (DIGCF_PRESENT | // Only Devices present
                                                DIGCF_DEVICEINTERFACE)); // Function class devices.

    //
    // Take a wild guess to start
    //
    
    *NumberDevices = 4;
    done = FALSE;
    deviceInfoData.cbSize = sizeof (SP_DEVICE_INTERFACE_DATA);

    i=0;
    while (!done) 
    {
        *NumberDevices *= 2;

        if (*HidDevices) 
        {
            newHidDevices =
               realloc (*HidDevices, (*NumberDevices * sizeof (HID_DEVICE)));

            if (NULL == newHidDevices)
			{
				free(*HidDevices);				
			}

            *HidDevices = newHidDevices;
        }
        else
        {
            *HidDevices = calloc (*NumberDevices, sizeof (HID_DEVICE));
        }

        if (NULL == *HidDevices) 
        {
            SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
            return FALSE;
        }

        hidDeviceInst = *HidDevices + i;

        for (; i < *NumberDevices; i++, hidDeviceInst++) 
        {
            if (SetupDiEnumDeviceInterfaces (hardwareDeviceInfo,
                                             0, // No care about specific PDOs
                                             &hidGuid,
                                             i,
                                             &deviceInfoData))
            {
                //
                // allocate a function class device data structure to receive the
                // goods about this particular device.
                //

                SetupDiGetDeviceInterfaceDetail (
                        hardwareDeviceInfo,
                        &deviceInfoData,
                        NULL, // probing so no output buffer yet
                        0, // probing so output buffer length of zero
                        &requiredLength,
                        NULL); // not interested in the specific dev-node


                predictedLength = requiredLength;

                functionClassDeviceData = malloc (predictedLength);
                if (functionClassDeviceData)
                {
                    functionClassDeviceData->cbSize = sizeof (SP_DEVICE_INTERFACE_DETAIL_DATA);
                }
                else
                {
                    SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
                    return FALSE;
                }

                //
                // Retrieve the information from Plug and Play.
                //

                if (! SetupDiGetDeviceInterfaceDetail (
                           hardwareDeviceInfo,
                           &deviceInfoData,
                           functionClassDeviceData,
                           predictedLength,
                           &requiredLength,
                           NULL)) 
                {
                    SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
					free(functionClassDeviceData);
                    return FALSE;
                }

                //
                // Open device with just generic query abilities to begin with
                //
                
                if (! OpenHidDevice (functionClassDeviceData -> DevicePath, 
                               FALSE,      // ReadAccess - none
                               FALSE,      // WriteAccess - none
                               FALSE,       // Overlapped - no
                               FALSE,       // Exclusive - no
                               hidDeviceInst))
                {
                    SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
					free(functionClassDeviceData);
                    return FALSE;
                }

            } 
            else
            {
                if (ERROR_NO_MORE_ITEMS == GetLastError()) 
                {
                    done = TRUE;
                    break;
                }
            }
        }
    }

    *NumberDevices = i;

    SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
	free(functionClassDeviceData);
    return TRUE;
}

BOOLEAN
OpenHidDevice (
    IN       PCHAR          DevicePath,
    IN       BOOL           HasReadAccess,
    IN       BOOL           HasWriteAccess,
    IN       BOOL           IsOverlapped,
    IN       BOOL           IsExclusive,
    IN OUT   PHID_DEVICE    HidDevice
)
/*++
RoutineDescription:
    Given the HardwareDeviceInfo, representing a handle to the plug and
    play information, and deviceInfoData, representing a specific hid device,
    open that device and fill in all the relivant information in the given
    HID_DEVICE structure.

    return if the open and initialization was successfull or not.

--*/
{
    DWORD   accessFlags = 0;
    DWORD   sharingFlags = 0;
    BOOLEAN bSuccess;
    INT     iDevicePathSize;
	HRESULT stringReturn;

    iDevicePathSize = strlen(DevicePath) + 1;
    
    HidDevice -> DevicePath = malloc(iDevicePathSize);

    if (NULL == HidDevice -> DevicePath) 
    {
        return (FALSE);
    }

    stringReturn = StringCbCopy(HidDevice -> DevicePath, iDevicePathSize, DevicePath);
    
    if (HasReadAccess)
    {
        accessFlags |= GENERIC_READ;
    }

    if (HasWriteAccess)
    {
        accessFlags |= GENERIC_WRITE;
    }

    if (!IsExclusive)
    {
        sharingFlags = FILE_SHARE_READ | FILE_SHARE_WRITE;
    }
    
    //
	//  The hid.dll api's do not pass the overlapped structure into deviceiocontrol
	//  so to use them we must have a non overlapped device.  If the request is for
	//  an overlapped device we will close the device below and get a handle to an
	//  overlapped device
	//
	
	HidDevice->HidDevice = CreateFile (DevicePath,
                                       accessFlags,
                                       sharingFlags,
                                       NULL,        // no SECURITY_ATTRIBUTES structure
                                       OPEN_EXISTING, // No special create flags
                                       0,   // Open device as non-overlapped so we can get data
                                       NULL);       // No template file

    if (INVALID_HANDLE_VALUE == HidDevice->HidDevice) 
    {
        free(HidDevice -> DevicePath);
		HidDevice -> DevicePath = INVALID_HANDLE_VALUE ;
        return FALSE;
    }

    HidDevice -> OpenedForRead = HasReadAccess;
    HidDevice -> OpenedForWrite = HasWriteAccess;
    HidDevice -> OpenedOverlapped = IsOverlapped;
    HidDevice -> OpenedExclusive = IsExclusive;
    
    //
    // If the device was not opened as overlapped, then fill in the rest of the
    //  HidDevice structure.  However, if opened as overlapped, this handle cannot
    //  be used in the calls to the HidD_ exported functions since each of these
    //  functions does synchronous I/O.
    //

	if (!HidD_GetPreparsedData (HidDevice->HidDevice, &HidDevice->Ppd)) 
	{
		free(HidDevice -> DevicePath);
		HidDevice -> DevicePath = NULL ;
		CloseHandle(HidDevice -> HidDevice);
		HidDevice -> HidDevice = INVALID_HANDLE_VALUE ;
		return FALSE;
	}

	if (!HidD_GetAttributes (HidDevice->HidDevice, &HidDevice->Attributes)) 
	{
		free(HidDevice -> DevicePath);
		HidDevice -> DevicePath = NULL;
		CloseHandle(HidDevice -> HidDevice);
		HidDevice -> HidDevice = INVALID_HANDLE_VALUE;
		HidD_FreePreparsedData (HidDevice->Ppd);
		HidDevice->Ppd = NULL;

		return FALSE;
	}

	if (!HidP_GetCaps (HidDevice->Ppd, &HidDevice->Caps))
	{
		free(HidDevice -> DevicePath);
		HidDevice -> DevicePath = NULL;
		CloseHandle(HidDevice -> HidDevice);
		HidDevice -> HidDevice = INVALID_HANDLE_VALUE;
		HidD_FreePreparsedData (HidDevice->Ppd);
		HidDevice->Ppd = NULL;

		return FALSE;
	}

	//
	// At this point the client has a choice.  It may chose to look at the
	// Usage and Page of the top level collection found in the HIDP_CAPS
	// structure.  In this way it could just use the usages it knows about.
	// If either HidP_GetUsages or HidP_GetUsageValue return an error then
	// that particular usage does not exist in the report.
	// This is most likely the preferred method as the application can only
	// use usages of which it already knows.
	// In this case the app need not even call GetButtonCaps or GetValueCaps.
	//
	// In this example, however, we will call FillDeviceInfo to look for all
	//    of the usages in the device.
	//

	bSuccess = FillDeviceInfo(HidDevice);

	if (FALSE == bSuccess)
	{
		CloseHidDevice(HidDevice);
		return (FALSE);
	}
    
	if (IsOverlapped)
	{
		CloseHandle(HidDevice->HidDevice);

	    HidDevice->HidDevice = CreateFile (DevicePath,
                                       accessFlags,
                                       sharingFlags,
                                       NULL,        // no SECURITY_ATTRIBUTES structure
                                       OPEN_EXISTING, // No special create flags
                                       FILE_FLAG_OVERLAPPED, // Now we open the device as overlapped
                                       NULL);       // No template file
	
	    if (INVALID_HANDLE_VALUE == HidDevice->HidDevice) 
		{
			CloseHidDevice(HidDevice);
			return FALSE;
		}
	}

    return (TRUE);
}

BOOLEAN
FillDeviceInfo(
    IN  PHID_DEVICE HidDevice
)
{
    USHORT              numValues;
    USHORT              numCaps;
    PHIDP_BUTTON_CAPS   buttonCaps;
    PHIDP_VALUE_CAPS    valueCaps;
    PHID_DATA           data;
    ULONG               i;
    USAGE               usage;

    //
    // setup Input Data buffers.
    //

    //
    // Allocate memory to hold on input report
    //

    HidDevice->InputReportBuffer = (PCHAR) 
        calloc (HidDevice->Caps.InputReportByteLength, sizeof (CHAR));


    //
    // Allocate memory to hold the button and value capabilities.
    // NumberXXCaps is in terms of array elements.
    //
    
    HidDevice->InputButtonCaps = buttonCaps = (PHIDP_BUTTON_CAPS)
        calloc (HidDevice->Caps.NumberInputButtonCaps, sizeof (HIDP_BUTTON_CAPS));

    if (NULL == buttonCaps)
    {
        return (FALSE);
    }

    HidDevice->InputValueCaps = valueCaps = (PHIDP_VALUE_CAPS)
        calloc (HidDevice->Caps.NumberInputValueCaps, sizeof (HIDP_VALUE_CAPS));

    if (NULL == valueCaps)
    {
        return(FALSE);
    }

    //
    // Have the HidP_X functions fill in the capability structure arrays.
    //

    numCaps = HidDevice->Caps.NumberInputButtonCaps;

    HidP_GetButtonCaps (HidP_Input,
                        buttonCaps,
                        &numCaps,
                        HidDevice->Ppd);

    numCaps = HidDevice->Caps.NumberInputValueCaps;

    HidP_GetValueCaps (HidP_Input,
                       valueCaps,
                       &numCaps,
                       HidDevice->Ppd);


    //
    // Depending on the device, some value caps structures may represent more
    // than one value.  (A range).  In the interest of being verbose, over
    // efficient, we will expand these so that we have one and only one
    // struct _HID_DATA for each value.
    //
    // To do this we need to count up the total number of values are listed
    // in the value caps structure.  For each element in the array we test
    // for range if it is a range then UsageMax and UsageMin describe the
    // usages for this range INCLUSIVE.
    //
    
    numValues = 0;
    for (i = 0; i < HidDevice->Caps.NumberInputValueCaps; i++, valueCaps++) 
    {
        if (valueCaps->IsRange) 
        {
            numValues += valueCaps->Range.UsageMax - valueCaps->Range.UsageMin + 1;
        }
        else
        {
            numValues++;
        }
    }
    valueCaps = HidDevice->InputValueCaps;


    //
    // Allocate a buffer to hold the struct _HID_DATA structures.
    // One element for each set of buttons, and one element for each value
    // found.
    //

    HidDevice->InputDataLength = HidDevice->Caps.NumberInputButtonCaps
                               + numValues;

    HidDevice->InputData = data = (PHID_DATA)
        calloc (HidDevice->InputDataLength, sizeof (HID_DATA));

    if (NULL == data)
    {
        return (FALSE);
    }

    //
    // Fill in the button data
    //

    for (i = 0;
         i < HidDevice->Caps.NumberInputButtonCaps;
         i++, data++, buttonCaps++) 
    {
        data->IsButtonData = TRUE;
        data->Status = HIDP_STATUS_SUCCESS;
        data->UsagePage = buttonCaps->UsagePage;
        if (buttonCaps->IsRange) 
        {
            data->ButtonData.UsageMin = buttonCaps -> Range.UsageMin;
            data->ButtonData.UsageMax = buttonCaps -> Range.UsageMax;
        }
        else
        {
            data -> ButtonData.UsageMin = data -> ButtonData.UsageMax = buttonCaps -> NotRange.Usage;
        }
        
        data->ButtonData.MaxUsageLength = HidP_MaxUsageListLength (
                                                HidP_Input,
                                                buttonCaps->UsagePage,
                                                HidDevice->Ppd);
        data->ButtonData.Usages = (PUSAGE)
            calloc (data->ButtonData.MaxUsageLength, sizeof (USAGE));

        data->ReportID = buttonCaps -> ReportID;
    }

    //
    // Fill in the value data
    //

    for (i = 0; i < numValues; i++, valueCaps++)
    {
        if (valueCaps->IsRange) 
        {
            for (usage = valueCaps->Range.UsageMin;
                 usage <= valueCaps->Range.UsageMax;
                 usage++) 
            {
                data->IsButtonData = FALSE;
                data->Status = HIDP_STATUS_SUCCESS;
                data->UsagePage = valueCaps->UsagePage;
                data->ValueData.Usage = usage;
                data->ReportID = valueCaps -> ReportID;
                data++;
            }
        } 
        else
        {
            data->IsButtonData = FALSE;
            data->Status = HIDP_STATUS_SUCCESS;
            data->UsagePage = valueCaps->UsagePage;
            data->ValueData.Usage = valueCaps->NotRange.Usage;
            data->ReportID = valueCaps -> ReportID;
            data++;
        }
    }

    //
    // setup Output Data buffers.
    //

    HidDevice->OutputReportBuffer = (PCHAR)
        calloc (HidDevice->Caps.OutputReportByteLength, sizeof (CHAR));

    HidDevice->OutputButtonCaps = buttonCaps = (PHIDP_BUTTON_CAPS)
        calloc (HidDevice->Caps.NumberOutputButtonCaps, sizeof (HIDP_BUTTON_CAPS));

    if (NULL == buttonCaps)
    {
        return (FALSE);
    }    

    HidDevice->OutputValueCaps = valueCaps = (PHIDP_VALUE_CAPS)
        calloc (HidDevice->Caps.NumberOutputValueCaps, sizeof (HIDP_VALUE_CAPS));

    if (NULL == valueCaps)
    {
        return (FALSE);
    }

    numCaps = HidDevice->Caps.NumberOutputButtonCaps;
    HidP_GetButtonCaps (HidP_Output,
                        buttonCaps,
                        &numCaps,
                        HidDevice->Ppd);

    numCaps = HidDevice->Caps.NumberOutputValueCaps;
    HidP_GetValueCaps (HidP_Output,
                       valueCaps,
                       &numCaps,
                       HidDevice->Ppd);

    numValues = 0;
    for (i = 0; i < HidDevice->Caps.NumberOutputValueCaps; i++, valueCaps++) 
    {
        if (valueCaps->IsRange) 
        {
            numValues += valueCaps->Range.UsageMax
                       - valueCaps->Range.UsageMin + 1;
        } 
        else
        {
            numValues++;
        }
    }
    valueCaps = HidDevice->OutputValueCaps;

    HidDevice->OutputDataLength = HidDevice->Caps.NumberOutputButtonCaps
                                + numValues;

    HidDevice->OutputData = data = (PHID_DATA)
       calloc (HidDevice->OutputDataLength, sizeof (HID_DATA));

    if (NULL == data)
    {
        return (FALSE);
    }

    for (i = 0;
         i < HidDevice->Caps.NumberOutputButtonCaps;
         i++, data++, buttonCaps++) 
    {
        data->IsButtonData = TRUE;
        data->Status = HIDP_STATUS_SUCCESS;
        data->UsagePage = buttonCaps->UsagePage;

        if (buttonCaps->IsRange)
        {
            data->ButtonData.UsageMin = buttonCaps -> Range.UsageMin;
            data->ButtonData.UsageMax = buttonCaps -> Range.UsageMax;
        }
        else
        {
            data -> ButtonData.UsageMin = data -> ButtonData.UsageMax = buttonCaps -> NotRange.Usage;
        }

        data->ButtonData.MaxUsageLength = HidP_MaxUsageListLength (
                                                   HidP_Output,
                                                   buttonCaps->UsagePage,
                                                   HidDevice->Ppd);

        data->ButtonData.Usages = (PUSAGE)
            calloc (data->ButtonData.MaxUsageLength, sizeof (USAGE));

        data->ReportID = buttonCaps -> ReportID;
    }

    for (i = 0; i < numValues; i++, valueCaps++)
    {
        if (valueCaps->IsRange)
        {
            for (usage = valueCaps->Range.UsageMin;
                 usage <= valueCaps->Range.UsageMax;
                 usage++) 
            {
                data->IsButtonData = FALSE;
                data->Status = HIDP_STATUS_SUCCESS;
                data->UsagePage = valueCaps->UsagePage;
                data->ValueData.Usage = usage;
                data->ReportID = valueCaps -> ReportID;
                data++;
            }
        }
        else
        {
            data->IsButtonData = FALSE;
            data->Status = HIDP_STATUS_SUCCESS;
            data->UsagePage = valueCaps->UsagePage;
            data->ValueData.Usage = valueCaps->NotRange.Usage;
            data->ReportID = valueCaps -> ReportID;
            data++;
        }
    }

    //
    // setup Feature Data buffers.
    //

    HidDevice->FeatureReportBuffer = (PCHAR)
           calloc (HidDevice->Caps.FeatureReportByteLength, sizeof (CHAR));

    HidDevice->FeatureButtonCaps = buttonCaps = (PHIDP_BUTTON_CAPS)
        calloc (HidDevice->Caps.NumberFeatureButtonCaps, sizeof (HIDP_BUTTON_CAPS));

    if (NULL == buttonCaps)
    {
        return (FALSE);
    }

    HidDevice->FeatureValueCaps = valueCaps = (PHIDP_VALUE_CAPS)
        calloc (HidDevice->Caps.NumberFeatureValueCaps, sizeof (HIDP_VALUE_CAPS));

    if (NULL == valueCaps)
    {
        return (FALSE);
    }

    numCaps = HidDevice->Caps.NumberFeatureButtonCaps;
    HidP_GetButtonCaps (HidP_Feature,
                        buttonCaps,
                        &numCaps,
                        HidDevice->Ppd);

    numCaps = HidDevice->Caps.NumberFeatureValueCaps;
    HidP_GetValueCaps (HidP_Feature,
                       valueCaps,
                       &numCaps,
                       HidDevice->Ppd);

    numValues = 0;
    for (i = 0; i < HidDevice->Caps.NumberFeatureValueCaps; i++, valueCaps++) 
    {
        if (valueCaps->IsRange) 
        {
            numValues += valueCaps->Range.UsageMax
                       - valueCaps->Range.UsageMin + 1;
        }
        else
        {
            numValues++;
        }
    }
    valueCaps = HidDevice->FeatureValueCaps;

    HidDevice->FeatureDataLength = HidDevice->Caps.NumberFeatureButtonCaps
                                 + numValues;

    HidDevice->FeatureData = data = (PHID_DATA)
        calloc (HidDevice->FeatureDataLength, sizeof (HID_DATA));

    if (NULL == data)
    {
        return (FALSE);
    }


    for (i = 0;
         i < HidDevice->Caps.NumberFeatureButtonCaps;
         i++, data++, buttonCaps++) 
    {
        data->IsButtonData = TRUE;
        data->Status = HIDP_STATUS_SUCCESS;
        data->UsagePage = buttonCaps->UsagePage;

        if (buttonCaps->IsRange)
        {
            data->ButtonData.UsageMin = buttonCaps -> Range.UsageMin;
            data->ButtonData.UsageMax = buttonCaps -> Range.UsageMax;
        }
        else
        {
            data -> ButtonData.UsageMin = data -> ButtonData.UsageMax = buttonCaps -> NotRange.Usage;
        }
        
        data->ButtonData.MaxUsageLength = HidP_MaxUsageListLength (
                                                HidP_Feature,
                                                buttonCaps->UsagePage,
                                                HidDevice->Ppd);
        data->ButtonData.Usages = (PUSAGE)
             calloc (data->ButtonData.MaxUsageLength, sizeof (USAGE));

        data->ReportID = buttonCaps -> ReportID;
    }

    for (i = 0; i < numValues; i++, valueCaps++) 
    {
        if (valueCaps->IsRange)
        {
            for (usage = valueCaps->Range.UsageMin;
                 usage <= valueCaps->Range.UsageMax;
                 usage++)
            {
                data->IsButtonData = FALSE;
                data->Status = HIDP_STATUS_SUCCESS;
                data->UsagePage = valueCaps->UsagePage;
                data->ValueData.Usage = usage;
                data->ReportID = valueCaps -> ReportID;
                data++;
            }
        } 
        else
        {
            data->IsButtonData = FALSE;
            data->Status = HIDP_STATUS_SUCCESS;
            data->UsagePage = valueCaps->UsagePage;
            data->ValueData.Usage = valueCaps->NotRange.Usage;
            data->ReportID = valueCaps -> ReportID;
            data++;
        }
    }

    return (TRUE);
}

VOID
CloseHidDevices(
    IN  PHID_DEVICE HidDevices,
    IN  ULONG       NumberDevices
)
{
    ULONG   Index;

    for (Index = 0; Index < NumberDevices; Index++) 
    {
        CloseHidDevice(HidDevices+Index);
    }

    return;
}

VOID
CloseHidDevice (
    IN PHID_DEVICE HidDevice
)
{
    free(HidDevice -> DevicePath);
    
    if (INVALID_HANDLE_VALUE != HidDevice -> HidDevice)
    {
        CloseHandle(HidDevice -> HidDevice);
		HidDevice -> HidDevice = INVALID_HANDLE_VALUE;
    }
    
    if (NULL != HidDevice -> Ppd)
    {
        HidD_FreePreparsedData(HidDevice -> Ppd);
		HidDevice -> Ppd = NULL;
    }

    if (NULL != HidDevice -> InputReportBuffer)
    {
        free(HidDevice -> InputReportBuffer);
		HidDevice -> InputReportBuffer = NULL;
    }

    if (NULL != HidDevice -> InputData)
    {
        free(HidDevice -> InputData);
		HidDevice -> InputData = NULL;
    }

    if (NULL != HidDevice -> InputButtonCaps)
    {
        free(HidDevice -> InputButtonCaps);
		HidDevice -> InputButtonCaps = NULL;
    }

    if (NULL != HidDevice -> InputValueCaps)
    {
        free(HidDevice -> InputValueCaps);
		HidDevice -> InputValueCaps = NULL;
    }

    if (NULL != HidDevice -> OutputReportBuffer)
    {
        free(HidDevice -> OutputReportBuffer);
		HidDevice -> OutputReportBuffer = NULL;
    }

    if (NULL != HidDevice -> OutputData)
    {
        free(HidDevice -> OutputData);
		HidDevice -> OutputData = NULL;
    }

    if (NULL != HidDevice -> OutputButtonCaps) 
    {
        free(HidDevice -> OutputButtonCaps);
		HidDevice -> OutputButtonCaps = NULL;
    }

    if (NULL != HidDevice -> OutputValueCaps)
    {
        free(HidDevice -> OutputValueCaps);
		HidDevice -> OutputValueCaps = NULL;
    }

    if (NULL != HidDevice -> FeatureReportBuffer)
    {
        free(HidDevice -> FeatureReportBuffer);
		HidDevice -> FeatureReportBuffer = NULL;
    }

    if (NULL != HidDevice -> FeatureData) 
    {
        free(HidDevice -> FeatureData);
		HidDevice -> FeatureData = NULL;
    }

    if (NULL != HidDevice -> FeatureButtonCaps) 
    {
        free(HidDevice -> FeatureButtonCaps);
		HidDevice -> FeatureButtonCaps = NULL;
    }

    if (NULL != HidDevice -> FeatureValueCaps) 
    {
        free(HidDevice -> FeatureValueCaps);
		HidDevice -> FeatureValueCaps = NULL;
    }

     return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\client\hclient\list.h ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    list.h

Abstract:

    This module contains the code for manipulating list structures.

Environment:

    User mode

Revision History:

    Nov-97 : Created 

--*/


#ifndef __LIST_H__
#define __LIST_H__

#include <windows.h>

typedef LIST_ENTRY      LIST_NODE_HDR, *PLIST_NODE_HDR;
typedef LIST_NODE_HDR   LIST, *PLIST;

typedef VOID PLIST_CALLBACK(PLIST_NODE_HDR);

VOID
InitializeList(
    IN  PLIST   NewList
);

VOID
InsertHead(
    IN  PLIST           List,
    IN  PLIST_NODE_HDR  ListNode
);

VOID
InsertTail(
    IN  PLIST           List,
    IN  PLIST_NODE_HDR  ListNode
);

VOID
RemoveNode(
    IN  PLIST_NODE_HDR  ListNode   
);

PLIST_NODE_HDR
RemoveHead(
    IN  PLIST   List
);

PLIST_NODE_HDR
RemoveTail(
    IN  PLIST   List
);

BOOL
IsListEmpty(
    IN  PLIST   List
);

PLIST_NODE_HDR
GetListHead(
    IN  PLIST   List
);

PLIST_NODE_HDR
GetListTail(
    IN  PLIST   List
);

PLIST_NODE_HDR
GetNextEntry(
    IN  PLIST_NODE_HDR  ListNode
);

PLIST_NODE_HDR
GetPrevEntry(
    IN  PLIST_NODE_HDR  ListNode
);

VOID
DestroyListNoCallback(
    IN  PLIST           List
);

VOID
DestroyListWithCallback(
    IN  PLIST           List,
    IN  PLIST_CALLBACK  Callback
);


/*****************************************************************************
/* Macro definitions of list functions
/*****************************************************************************/

    /*
    // VOID
    // InitializeList(
    //     IN  PLIST    NewList
    // );
    */
    
    #define InitializeList(nl) \
        { ((PLIST)(nl)) -> Flink = ((PLIST)(nl)) -> Blink = nl; }
    
    /* 
    // VOID
    // InsertHead(
     /     IN  PLIST            List,
    //     IN  PLIST_NODE_HDR   ListNode
    // );
    */
    
    #define InsertHead(List, Node) {                    \
        PLIST_NODE_HDR _EX_Flink;                       \
        PLIST_NODE_HDR _EX_List;                        \
                                                        \
        _EX_List = ((PLIST_NODE_HDR) (List));           \
        _EX_Flink = _EX_List -> Flink;                  \
        ((PLIST_NODE_HDR) (Node))->Blink = _EX_List;    \
        ((PLIST_NODE_HDR) (Node))->Flink = _EX_Flink;   \
        _EX_Flink->Blink = (((PLIST_NODE_HDR) (Node))); \
        _EX_List->Flink = ((PLIST_NODE_HDR) (Node));    \
    }
    
    
    /* 
    // VOID
    // InsertTail(
    //     IN  PLIST            List,
    //     IN  PLIST_NODE_HDR   ListNode
    // );
    */
    
    #define InsertTail(List, Node) {                    \
        PLIST_NODE_HDR _EX_Blink;                       \
        PLIST_NODE_HDR _EX_List;                        \
                                                        \
        _EX_List = ((PLIST_NODE_HDR) (List));           \
        _EX_Blink = _EX_List->Blink;                    \
        ((PLIST_NODE_HDR) (Node))->Flink = _EX_List;    \
        ((PLIST_NODE_HDR) (Node))->Blink = _EX_Blink;   \
        _EX_Blink->Flink = (((PLIST_NODE_HDR) (Node))); \
        _EX_List->Blink = ((PLIST_NODE_HDR) (Node));    \
    }
    
    /*
    //  VOID
    //  RemoveNode(
    //      IN  PLIST_NODE_HDR  ListNode   
    //  );
    */
    
    #define RemoveNode(node) {                          \
        PLIST_NODE_HDR _EX_Blink;                       \
        PLIST_NODE_HDR _EX_Flink;                       \
                                                        \
        _EX_Flink = ((PLIST_NODE_HDR) (node))->Flink;   \
        _EX_Blink = ((PLIST_NODE_HDR) (node))->Blink;   \
        _EX_Blink->Flink = _EX_Flink;                   \
        _EX_Flink->Blink = _EX_Blink;                   \
    }
    
    
    /* 
    // PLIST_NODE_HDR
    // RemoveHead(
    //     IN  PLIST    List
    // );               
    */                  
    
    #define RemoveHead(List)                            \
        GetListHead((List));                            \
        RemoveNode(((PLIST_NODE_HDR) (List))->Flink)  
                        
    /*                  
    // PLIST_NODE_HDR   
    // RemoveTail(      
    //     IN  PLIST    List
    // );               
    */                  
    
    #define RemoveTail(List)                            \
        GetListTail((List));                            \
        RemoveNode(((PLIST_NODE_HDR) (List))->Blink)    
    
    /*                  
    // BOOL             
    // IsListEmpty(     
    //     IN  PLIST    List
    // );               
    */                  
    
    #define IsListEmpty(List)                           \
        (((PLIST_NODE_HDR) (List))->Flink == ((PLIST_NODE_HDR) (List)))
                        
    /*                  
    // PLIST_NODE_HDR   
    // GetListHead(     
    //     IN  PLIST    List
    // );               
    */                  
    
    #define GetListHead(List)                           \
        (((PLIST_NODE_HDR) (List))->Flink)
    
    /*                  
    // PLIST_NODE_HDR   
    // GetListTail(     
    //     IN  PLIST    List
    // );               
    */                  
    
    #define GetListTail(List)                           \
        (((PLIST_NODE_HDR) (List))->Blink)
                        

    /*
    // PLIST_NODE_HDR
    // GetNextEntry(
    //    IN  PLIST_NODE_HDR  ListNode
    // );
    */

    #define GetNextEntry(ListNode)                      \
        (((PLIST_NODE_HDR) (ListNode)) -> Flink);

    /* 
    // PLIST_NODE_HDR
    // GetPrevEntry(
    //    IN  PLIST_NODE_HDR  ListNode
    // );
    */

    #define GetPrevEntry(ListNode)                      \
        (((PLIST_NODE_HDR) (ListNode)) -> Blink);

    /* 
    // VOID
    // DestroyListNoCallback(
    //     IN  PLIST           List,
    //     IN  PLIST_CALLBACK  Callback
    // );
    */ 
    
    #define DestroyListNoCallback(list)                 \
        PLIST_NODE_HDR  currNode;                       \
                                                        \
        while (!IsListEmpty((list))) {                  \
            currNode = RemoveHead((list));              \
        }                                               \
    }

    /* 
    // VOID
    // DestroyListWithCallback(
    //     IN  PLIST           List,
    //     IN  PLIST_CALLBACK  Callback
    // );
    */ 
    
    #define DestroyListWithCallback(list, cb) {         \
        PLIST_NODE_HDR  currNode;                       \
                                                        \
        while (!IsListEmpty((list))) {                  \
            currNode = RemoveHead((list));              \
            (cb)(currNode);                             \
        }                                               \
    }
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\client\hclient\strings.c ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    strings.c

Abstract:

    This module contains code for converting data buffers and integer values
    to and from string representation for display.

Environment:

    User mode

Revision History:

    May-98 : Created 

--*/

#include <windows.h>
#include <stdlib.h>
#include <limits.h>
#include <math.h>
#include "strings.h"

#define ROUND_UP_ON_DIVIDE(d, n)    (0 == ((d) % (n)) ? ((d)/(n)) : ((d)/(n))+1)

VOID
Strings_CreateDataBufferString(
    IN  PCHAR    DataBuffer,
    IN  ULONG    DataBufferLength,
    IN  ULONG    NumBytesToDisplay,
    IN  ULONG    DisplayBlockSize,
    OUT PCHAR    *BufferString
)
/*++
Routine Description:
    This routine takes a DataBuffer of size DataBufferLength and creates a string
    in BufferString that contains a string representation of the bytes stored in
    data buffer.  

    The parameter NumBytesToDisplay tells the routine the maximum number of bytes
    from the buffer to display.  For instance, a caller may only want to convert
    the first four bytes of an eight byte buffer to a string

    The parameter DisplayBlockSize indicates how many bytes should be grouped 
    together in the display.  Valid values are 1, 2, 4 and would indicate whether
    the displayed bytes should be displayed as bytes, words, or dwords.

    The routine allocates a buffer big enough to store the data.  Callers of this
    routine are responsible for freeing this string buffer.  
--*/
{
    ULONG   BufferStringLength;
    ULONG   MaxDisplayedBytes;
    PUCHAR  NextByte;
    PUCHAR  String;
    PUCHAR  CurrentBufferOffset;
    INT     nFullIterations;
    INT     LeftOverBytes;
    INT     IterationIndex;
    INT     ByteOffset;

    /*
    // Determine the maximum number of bytes that will be displayed in 
    //    the string
    */
    
    MaxDisplayedBytes = (NumBytesToDisplay > DataBufferLength) ? DataBufferLength
                                                               : NumBytesToDisplay;

    /*
    // Determine the size of the string we'll need: This is based on the 
    //   maximum number of displayed bytes (MaxDisplayedBytes) and the 
    //   DisplayBlockSize
    */

    BufferStringLength = 2*MaxDisplayedBytes + ROUND_UP_ON_DIVIDE(MaxDisplayedBytes,
                                                                  DisplayBlockSize
                                                                 );

    /*
    // Now we need to allocate string space
    */

    String = (PCHAR) malloc(BufferStringLength * sizeof(CHAR));

    if (NULL != String) {

        /*
        // Determine how many iterations through the conversion routine must be made.
        */
        
        nFullIterations = MaxDisplayedBytes / DisplayBlockSize;

        /*
        // Initialize our variables which point to data in the buffer to convert
        //   and the byte in the string in which to put the converted data value. 
        //   Next byte is set to String-1 because it is incremented on entry into the
        //   loop.
        */
        
        CurrentBufferOffset = DataBuffer;
        NextByte = String-1;

        /*
        // Each iteration of the loop creates a block of DisplayBlockSize.  Any
        //   partial iterations are performed afterwards if the number of bytes
        //   to display is not a multiple of the display block size
        */
        
        for (IterationIndex = 0; IterationIndex < nFullIterations; IterationIndex++) 
        {
            NextByte++;

            /*
            // Output a block of data size.  Notice the bytes are accessed in
            //    reverse order to display the the MSB of a block as the first
            //    value in the string
            */
            
            for (ByteOffset = DisplayBlockSize-1; ByteOffset >= 0; ByteOffset--) 
            {
                wsprintf(NextByte, "%02X", *(CurrentBufferOffset+ByteOffset));

                NextByte += 2;
            }

            /*
            // Insert the space to separate blocks
            */
            
            *(NextByte) = ' ';

            CurrentBufferOffset += DisplayBlockSize;
        }

        /*
        // Resolve any other bytes that are left over
        */
        
        LeftOverBytes = (MaxDisplayedBytes % DisplayBlockSize);

        if (0 == LeftOverBytes) 
        {
            *(NextByte) = '\0';
        }

        for (ByteOffset = LeftOverBytes-1, NextByte++; ByteOffset >= 0; ByteOffset--) 
        {
            wsprintf(NextByte, "%02X", *(CurrentBufferOffset+ByteOffset));
            NextByte += 2;
        }
    }
    
    *BufferString = String;

    return;
}

BOOL
Strings_StringToUnsignedList(
    IN OUT  PCHAR   InString,
    IN      ULONG   UnsignedSize,
    IN      ULONG   Base,
    OUT     PCHAR   *UnsignedList,
    OUT     PULONG  nUnsigneds
)
/*++
Routine Description:
    This routine takes an input string, InString, and creates a list of unsigned
    values of all the values that are in the list.  The caller can specify a
    base, Base, for all the numbers in the list or specify 0 to let the function
    determine the base depending on the format of the number in the string.

    The parameter UnsignedSize specifies the size of unsigneds to store in the list.
    
    The routine allocates a CHAR buffer to store the list of unsigned values.  

    On exit, nUnsigneds will report the number of unsigned values stored in 
    UnsignedList.
    
    The function will return TRUE if it could convert all of the numbers in the
    string into the unsigned list.  It will return FALSE if there was a problem
    with the string or if there was a problem allocating memory to store the 
    unsigned list.  
--*/
{
    CHAR    tokDelims[] = "\t,; ";
    PCHAR   strToken;
    PCHAR   endp;
    BOOL    fStatus;
    ULONG   ulValue;
    PCHAR   pList;
    PCHAR   pNewList;
    ULONG   nAllocUnsigneds;
    ULONG   nActualUnsigneds;
    ULONG   ulMaxValue;

    /*
    // Begin by initializing our unsigned list
    //      1) Start with initial allocation for 2 unsigneds, this will
    //          be expanded if necessary
    //      2) If initial allocation fails, return FALSE;
    */

    nAllocUnsigneds = 2;
    nActualUnsigneds = 0;

    pList = (PCHAR) malloc(nAllocUnsigneds * sizeof(ULONG));

    if (NULL == pList) 
    {
        return (FALSE);
    }

    /*
    // Calculate the maximum value that can be represented with the value for
    //   iBufferSize;
    */

    ulMaxValue = (sizeof(ULONG) == UnsignedSize) ? ULONG_MAX 
                                                 : (1 << (UnsignedSize*8)) - 1;

    /*
    // Begin our processing of the token string.
    //  1) Set fStatus to TRUE to get through loop the first time
    //  2) Try to get the first token -- if we can't get the first token
    //        then we pass through loop
    */

    fStatus = TRUE;

    strToken = strtok(InString, tokDelims);

    /*
    // Loop until there are no more tokens or we detect an error (fStatus == FALSE)
    */

    while (NULL != strToken && fStatus) 
    {
        /*
        // Set fStatus initially to false.  Only if nothing goes wrong in 
        //    the loop will this get set to TRUE
        */

        fStatus = FALSE;

        /*
        // Attempt to convert the token
        */

        ulValue = strtoul(strToken, &endp, Base);

        /*
        // To be a valid value, *endp must point to the NULL character
        */

        if ('\0' == *endp) 
        {
            /*
            // Check to see that the ulValue found is less than or equal to 
            //     the maximum allowed by UnsignedSize.
            */

            if (ulValue <= ulMaxValue) 
            {    
                /*
                // If we're set to overrun our buffer, attempt to allocate
                //    more space.  If we can't then release the old space
                //    and fail the loop.  
                */

                if (nAllocUnsigneds == nActualUnsigneds) 
                {
                    nAllocUnsigneds *= 2;

                    pNewList = (PCHAR) realloc(pList, UnsignedSize*nAllocUnsigneds);

                    if (NULL == pNewList)
                    {
                        break;
                    }
                    pList = pNewList;
                }

                /*
                // Add the token to the end of the list of unsigneds
                */

                memcpy(pList + (UnsignedSize * nActualUnsigneds),
                       &ulValue,
                       UnsignedSize);

                nActualUnsigneds++;

                /*
                // Prepare to reenter the loop.  Set fStatus = TRUE 
                //    Try to get another token
                */

                fStatus = TRUE;

                strToken = strtok(NULL, tokDelims);
            }
        }
    }

    /*
    // If the loop failed for some reason or we found no unsigneds
    //     release the list
    */

    if (!fStatus || 0 == nActualUnsigneds) 
    {
        free(pList);
        pList = NULL;
        nActualUnsigneds = 0;
    }

    *UnsignedList = pList;
    *nUnsigneds = nActualUnsigneds;
    
    return (fStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\client\hclient\strings.h ===
/*++

Copyright (c) Microsoft 1998, All Rights Reserved

Module Name:

    strings.h

Abstract:

    This module contains the public function definitions for the routines
    in strings.c that handle conversion of integer/data buffer to/from 
    string represenation

Environment:

    User mode

Revision History:

    May-98 : Created 

--*/

#ifndef __STRINGS_H__
#define __STRINGS_H__

VOID
Strings_CreateDataBufferString(
    IN  PCHAR    DataBuffer,
    IN  ULONG    DataBufferLength,
    IN  ULONG    NumBytesToDisplay,
    IN  ULONG    DisplayBlockSize,
    OUT PCHAR    *BufferString
);

VOID
Strings_StringToUnsigned(
    IN  PCHAR   InString,
    IN  ULONG   Base,
    OUT PCHAR   *endp,
    OUT PULONG  pValue
);

BOOL
Strings_StringToUnsignedList(
    IN  PCHAR   InString,
    IN  ULONG   UnsignedSize,
    IN  ULONG   Base,
    OUT PCHAR   *UnsignedList,
    OUT PULONG  nUnsigneds
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\client\hclient\resource.h ===
#define IDC_STATIC                      -1

#define IDD_SET_BUTTONS                 108
#define IDD_SET_SCALED_VALUE            109
#define IDD_SET_USAGE_VALUE             110
#define IDD_AUTOTEST_PARAMS             111
#define IDD_SET_USAGE_VALUE_ARRAY       112
#define IDD_USAGE_LIST_DIFFERENCE       113
#define IDD_UNSET_BUTTONS               114
#define IDD_UNSET_USAGES                115
#define IDD_SET_DATA                    116
#define IDD_SET_BUFFER_LENGTH           117
#define IDD_SET_INPUT_BUFFERS           118
#define IDD_GET_INDEX_STRING            119
#define IDD_SET_USAGES                  120
#define IDD_AUTOTEST_RESULTS            121
#define IDD_AUTOTEST_NEW                122
#define IDD_GET_EXT_ATTRIB              123
#define IDC_DEVICES                     1001
#define IDC_TYPE                        1002
#define IDC_ITEMS                       1003
#define IDC_ATTRIBUTES                  1004
#define IDC_READ                        1005
#define IDC_ABOUT                       1006
#define IDC_WRITE                       1007
#define IDC_EXTCALLS                    1008
#define IDC_SEND                        1100
#define ID_SEND                         1100
#define IDC_OUTPUT                      1101
#define IDC_EDIT1                       1102
#define IDC_USAGEPAGE                   1102
#define IDC_USAGE_LIST                  1102
#define IDC_STRING_INDEX                1102
#define IDC_LOGFILE                     1102
#define IDC_REPORTID                    1103
#define IDC_USAGE_LIST2                 1103
#define box                             1111
#define IDC_SCROLLBAR1                  1121
#define IDC_SCROLLBAR                   1121
#define IDC_INPUT                       1122
#define IDC_FEATURE                     1124
#define IDC_USAGE                       1126
#define IDC_LINKCOLL                    1127
#define IDC_CALLOUTPUT                  1128
#define IDC_EXECUTE                     1129
#define IDC_CANCEL                      1130
#define IDC_FEATURES                    1131
#define IDC_SET_PARAMS                  1131
#define IDC_REPORT_BUFFER               1132
#define IDC_INPUT_BUFFER                1132
#define IDC_BUFFER_TYPE                 1133
#define IDC_BUFFER_SIZE                 1134
#define IDC_INPUT_SELECT                1135
#define IDC_FEATURE_BUFFER              1136
#define IDC_USAGE_PAGE                  1136
#define IDC_FEATURE_SELECT              1137
#define IDC_OUTPUT_BUFFER               1138
#define IDC_VALUE                       1138
#define IDC_OUTPUT_SELECT               1139
#define IDC_INDEX                       1142
#define IDC_ADD_DATA                    1143
#define IDC_REMOVE_DATA                 1144
#define IDC_DATA_LIST                   1145
#define IDC_INPUT_BUFFERS               1147
#define IDC_BUFFER_LENGTH               1149
#define IDC_USAGE_LIST1                 1150
#define IDC_START_TESTS                 1151
#define IDC_LOAD_LOGICAL_DEVICE         1152
#define IDC_USELOG                      1152
#define IDC_INFINITE                    1153
#define IDC_PPD_ITS                     1154
#define IDC_STRESSLOG                   1154
#define IDC_RUN_PPD                     1155
#define IDC_RUN_CAPS                    1156
#define IDC_RUN_ATTRIB                  1157
#define IDC_RUN_STRINGS                 1158
#define IDC_RUN_GUID                    1159
#define IDC_ITERATIONS                  1160
#define IDC_CAPS_ITS                    1161
#define IDC_ATT_ITS                     1162
#define IDC_STR_ITS                     1163
#define IDC_GUID_ITS                    1164
#define IDC_TEST_ITS                    1165
#define IDC_RUN_BUFFERS                 1165
#define IDC_BUFFER_ITS                  1166
#define IDC_STOP_TESTS                  1167
#define IDC_RUN_GETFEATURE              1167
#define IDC_GETFEA_ITS                  1168
#define IDC_GETFEAT_ITS                 1168
#define IDC_LOGFILENAME                 1169
#define IDC_RUN_SETFEATURE              1169
#define IDC_SETFEA_ITS                  1170
#define IDC_TEST_RESULTS                1172
#define IDC_DEVICE_LIST                 1174
#define IDC_END_TESTS                   1175
#define IDC_READ_SYNCH                  1176
#define IDC_READ_ASYNCH_ONCE            1177
#define IDC_READ_ASYNCH                 1177
#define IDC_READ_ASYNCH_CONT            1178
#define IDC_RUN_LIST                    1178
#define IDC_NRUN_LIST                   1179
#define IDC_REMOVE_TEST                 1180
#define IDC_ADD_TEST                    1181
#define IDC_DESELECT_RUN                1182
#define IDC_SELECT_RUN                  1183
#define IDC_DESELECT_NRUN               1184
#define IDC_SELECT_NRUN                 1185
#define IDC_SET_ITERATIONS              1186
#define IDC_OUT_LABEL1                  2000
#define IDC_OUT_LABEL2                  2001
#define IDC_OUT_LABEL3                  2002
#define IDC_OUT_LABEL4                  2003
#define IDC_OUT_LABEL5                  2004
#define IDC_OUT_LABEL6                  2005
#define IDC_OUT_LABEL7                  2006
#define IDC_OUT_LABEL8                  2007
#define IDC_OUT_LABEL9                  2008
#define IDC_OUT_EDIT1                   3000
#define IDC_OUT_EDIT2                   3001
#define IDC_OUT_EDIT3                   3002
#define IDC_OUT_EDIT4                   3003
#define IDC_OUT_EDIT5                   3004
#define IDC_OUT_EDIT6                   3005
#define IDC_OUT_EDIT7                   3006
#define IDC_OUT_EDIT8                   3007
#define IDC_OUT_EDIT9                   3008

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        122
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1188
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\client\hclient\report.c ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    report.c

Abstract:

    This module contains the code for reading/writing hid reports and 
    translating those HID reports into useful information. 

Environment:

    User mode

@@BEGIN_DDKSPLIT

Revision History:

    Nov-96 : Created by Kenneth D. Ray

@@END_DDKSPLIT
--*/

#include <stdlib.h>
#include <wtypes.h>
#include "hidsdi.h"
#include "hid.h"

BOOLEAN
UnpackReport (
   IN       PCHAR                ReportBuffer,
   IN       USHORT               ReportBufferLength,
   IN       HIDP_REPORT_TYPE     ReportType,
   IN OUT   PHID_DATA            Data,
   IN       ULONG                DataLength,
   IN       PHIDP_PREPARSED_DATA Ppd
   );

BOOLEAN
PackReport (
   OUT      PCHAR                ReportBuffer,
   IN       USHORT               ReportBufferLength,
   IN       HIDP_REPORT_TYPE     ReportType,
   IN       PHID_DATA            Data,
   IN       ULONG                DataLength,
   IN       PHIDP_PREPARSED_DATA Ppd
   );

BOOLEAN
Read (
   PHID_DEVICE    HidDevice
   )
/*++
RoutineDescription:
   Given a struct _HID_DEVICE, obtain a read report and unpack the values
   into the InputData array.
--*/
{
    DWORD    bytesRead;

    if (!ReadFile (HidDevice->HidDevice,
                  HidDevice->InputReportBuffer,
                  HidDevice->Caps.InputReportByteLength,
                  &bytesRead,
                  NULL)) 
    {
        return FALSE;
    }

    ASSERT (bytesRead == HidDevice->Caps.InputReportByteLength);
    if (bytesRead != HidDevice->Caps.InputReportByteLength)
    {
        return FALSE;
    }

    return UnpackReport (HidDevice->InputReportBuffer,
                         HidDevice->Caps.InputReportByteLength,
                         HidP_Input,
                         HidDevice->InputData,
                         HidDevice->InputDataLength,
                         HidDevice->Ppd);
}

BOOLEAN
ReadOverlapped (
    PHID_DEVICE     HidDevice,
    HANDLE          CompletionEvent
   )
/*++
RoutineDescription:
   Given a struct _HID_DEVICE, obtain a read report and unpack the values
   into the InputData array.
--*/
{
    static OVERLAPPED  overlap;
    DWORD       bytesRead;
    BOOL        readStatus;

    /*
    // Setup the overlap structure using the completion event passed in to
    //  to use for signalling the completion of the Read
    */

    memset(&overlap, 0, sizeof(OVERLAPPED));
    
    overlap.hEvent = CompletionEvent;
    
    /*
    // Execute the read call saving the return code to determine how to 
    //  proceed (ie. the read completed synchronously or not).
    */

    readStatus = ReadFile ( HidDevice -> HidDevice,
                            HidDevice -> InputReportBuffer,
                            HidDevice -> Caps.InputReportByteLength,
                            &bytesRead,
                            &overlap);
                          
    /*
    // If the readStatus is FALSE, then one of two cases occurred.  
    //  1) ReadFile call succeeded but the Read is an overlapped one.  Here,
    //      we should return TRUE to indicate that the Read succeeded.  However,
    //      the calling thread should be blocked on the completion event
    //      which means it won't continue until the read actually completes
    //    
    //  2) The ReadFile call failed for some unknown reason...In this case,
    //      the return code will be FALSE
    */        

    if (!readStatus) 
    {
        return (ERROR_IO_PENDING == GetLastError());
    }

    /*
    // If readStatus is TRUE, then the ReadFile call completed synchronously,
    //   since the calling thread is probably going to wait on the completion
    //   event, signal the event so it knows it can continue.
    */

    else 
    {
        SetEvent(CompletionEvent);
        return (TRUE);
    }
}

BOOLEAN
Write (
   PHID_DEVICE    HidDevice
)
/*++
RoutineDescription:
   Given a struct _HID_DEVICE, take the information in the HID_DATA array
   pack it into multiple write reports and send each report to the HID device
--*/
{
    DWORD     bytesWritten;
    PHID_DATA pData;
    ULONG     Index;
    BOOLEAN   Status;
    BOOLEAN   WriteStatus;

    /*
    // Begin by looping through the HID_DEVICE's HID_DATA structure and setting
    //   the IsDataSet field to FALSE to indicate that each structure has
    //   not yet been set for this Write call.
    */

    pData = HidDevice -> OutputData;

    for (Index = 0; Index < HidDevice -> OutputDataLength; Index++, pData++) 
    {
        pData -> IsDataSet = FALSE;
    }

    /*
    // In setting all the data in the reports, we need to pack a report buffer
    //   and call WriteFile for each report ID that is represented by the 
    //   device structure.  To do so, the IsDataSet field will be used to 
    //   determine if a given report field has already been set.
    */

    Status = TRUE;

    pData = HidDevice -> OutputData;
    for (Index = 0; Index < HidDevice -> OutputDataLength; Index++, pData++) 
    {

        if (!pData -> IsDataSet) 
        {
            /*
            // Package the report for this data structure.  PackReport will
            //    set the IsDataSet fields of this structure and any other 
            //    structures that it includes in the report with this structure
            */

            PackReport (HidDevice->OutputReportBuffer,
                     HidDevice->Caps.OutputReportByteLength,
                     HidP_Output,
                     pData,
                     HidDevice->OutputDataLength - Index,
                     HidDevice->Ppd);

            /*
            // Now a report has been packaged up...Send it down to the device
            */

            WriteStatus = WriteFile (HidDevice->HidDevice,
                                  HidDevice->OutputReportBuffer,
                                  HidDevice->Caps.OutputReportByteLength,
                                  &bytesWritten,
                                  NULL) && (bytesWritten == HidDevice -> Caps.OutputReportByteLength);

            Status = Status && WriteStatus;                         
        }
    }
    return (Status);
}

BOOLEAN
SetFeature (
    PHID_DEVICE    HidDevice
)
/*++
RoutineDescription:
Given a struct _HID_DEVICE, take the information in the HID_DATA array
pack it into multiple reports and send it to the hid device via HidD_SetFeature()
--*/
{
    PHID_DATA pData;
    ULONG     Index;
    BOOLEAN   Status;
    BOOLEAN   FeatureStatus;
    /*
    // Begin by looping through the HID_DEVICE's HID_DATA structure and setting
    //   the IsDataSet field to FALSE to indicate that each structure has
    //   not yet been set for this SetFeature() call.
    */

    pData = HidDevice -> FeatureData;

    for (Index = 0; Index < HidDevice -> FeatureDataLength; Index++, pData++) 
    {
        pData -> IsDataSet = FALSE;
    }

    /*
    // In setting all the data in the reports, we need to pack a report buffer
    //   and call WriteFile for each report ID that is represented by the 
    //   device structure.  To do so, the IsDataSet field will be used to 
    //   determine if a given report field has already been set.
    */

    Status = TRUE;

    pData = HidDevice -> FeatureData;
    for (Index = 0; Index < HidDevice -> FeatureDataLength; Index++, pData++) 
    {
        if (!pData -> IsDataSet) 
        {
            /*
            // Package the report for this data structure.  PackReport will
            //    set the IsDataSet fields of this structure and any other 
            //    structures that it includes in the report with this structure
            */

            PackReport (HidDevice->FeatureReportBuffer,
                     HidDevice->Caps.FeatureReportByteLength,
                     HidP_Feature,
                     pData,
                     HidDevice->FeatureDataLength - Index,
                     HidDevice->Ppd);

            /*
            // Now a report has been packaged up...Send it down to the device
            */

            FeatureStatus =(HidD_SetFeature (HidDevice->HidDevice,
                                          HidDevice->FeatureReportBuffer,
                                          HidDevice->Caps.FeatureReportByteLength));

            Status = Status && FeatureStatus;
        }
    }
    return (Status);
}

BOOLEAN
GetFeature (
   PHID_DEVICE    HidDevice
)
/*++
RoutineDescription:
   Given a struct _HID_DEVICE, fill in the feature data structures with
   all features on the device.  May issue multiple HidD_GetFeature() calls to
   deal with multiple report IDs.
--*/
{
    ULONG     Index;
    PHID_DATA pData;
    BOOLEAN   FeatureStatus;
    BOOLEAN   Status;

    /*
    // As with writing data, the IsDataSet value in all the structures should be
    //    set to FALSE to indicate that the value has yet to have been set
    */

    pData = HidDevice -> FeatureData;

    for (Index = 0; Index < HidDevice -> FeatureDataLength; Index++, pData++) 
    {
        pData -> IsDataSet = FALSE;
    }

    /*
    // Next, each structure in the HID_DATA buffer is filled in with a value
    //   that is retrieved from one or more calls to HidD_GetFeature.  The 
    //   number of calls is equal to the number of reportIDs on the device
    */

    Status = TRUE; 
    pData = HidDevice -> FeatureData;

    for (Index = 0; Index < HidDevice -> FeatureDataLength; Index++, pData++) 
    {
        /*
        // If a value has yet to have been set for this structure, build a report
        //    buffer with its report ID as the first byte of the buffer and pass
        //    it in the HidD_GetFeature call.  Specifying the report ID in the
        //    first specifies which report is actually retrieved from the device.
        //    The rest of the buffer should be zeroed before the call
        */

        if (!pData -> IsDataSet) 
        {
            memset(HidDevice -> FeatureReportBuffer, 0x00, HidDevice->Caps.FeatureReportByteLength);

            HidDevice -> FeatureReportBuffer[0] = (UCHAR) pData -> ReportID;

            FeatureStatus = HidD_GetFeature (HidDevice->HidDevice,
                                              HidDevice->FeatureReportBuffer,
                                              HidDevice->Caps.FeatureReportByteLength);

            /*
            // If the return value is TRUE, scan through the rest of the HID_DATA
            //    structures and fill whatever values we can from this report
            */


            if (FeatureStatus) 
            {
                FeatureStatus = UnpackReport ( HidDevice->FeatureReportBuffer,
                                           HidDevice->Caps.FeatureReportByteLength,
                                           HidP_Feature,
                                           HidDevice->FeatureData,
                                           HidDevice->FeatureDataLength,
                                           HidDevice->Ppd);
            }

            Status = Status && FeatureStatus;
        }
   }

   return (Status);
}


BOOLEAN
UnpackReport (
   IN       PCHAR                ReportBuffer,
   IN       USHORT               ReportBufferLength,
   IN       HIDP_REPORT_TYPE     ReportType,
   IN OUT   PHID_DATA            Data,
   IN       ULONG                DataLength,
   IN       PHIDP_PREPARSED_DATA Ppd
)
/*++
Routine Description:
   Given ReportBuffer representing a report from a HID device where the first
   byte of the buffer is the report ID for the report, extract all the HID_DATA
   in the Data list from the given report.
--*/
{
    ULONG       numUsages; // Number of usages returned from GetUsages.
    ULONG       i;
    UCHAR       reportID;
    ULONG       Index;
    ULONG       nextUsage;

    reportID = ReportBuffer[0];

    for (i = 0; i < DataLength; i++, Data++) 
    {
        if (reportID == Data->ReportID) 
        {
            if (Data->IsButtonData) 
            {
                numUsages = Data->ButtonData.MaxUsageLength;

                Data->Status = HidP_GetUsages (ReportType,
                                               Data->UsagePage,
                                               0, // All collections
                                               Data->ButtonData.Usages,
                                               &numUsages,
                                               Ppd,
                                               ReportBuffer,
                                               ReportBufferLength);


                //
                // Get usages writes the list of usages into the buffer
                // Data->ButtonData.Usages newUsage is set to the number of usages
                // written into this array.
                // A usage cannot not be defined as zero, so we'll mark a zero
                // following the list of usages to indicate the end of the list of
                // usages
                //
                // NOTE: One anomaly of the GetUsages function is the lack of ability
                //        to distinguish the data for one ButtonCaps from another
                //        if two different caps structures have the same UsagePage
                //        For instance:
                //          Caps1 has UsagePage 07 and UsageRange of 0x00 - 0x167
                //          Caps2 has UsagePage 07 and UsageRange of 0xe0 - 0xe7
                //
                //        However, calling GetUsages for each of the data structs
                //          will return the same list of usages.  It is the 
                //          responsibility of the caller to set in the HID_DEVICE
                //          structure which usages actually are valid for the
                //          that structure. 
                //      

                /*
                // Search through the usage list and remove those that 
                //    correspond to usages outside the define ranged for this
                //    data structure.
                */
                
                for (Index = 0, nextUsage = 0; Index < numUsages; Index++) 
                {
                    if (Data -> ButtonData.UsageMin <= Data -> ButtonData.Usages[Index] &&
                            Data -> ButtonData.Usages[Index] <= Data -> ButtonData.UsageMax) 
                    {
                        Data -> ButtonData.Usages[nextUsage++] = Data -> ButtonData.Usages[Index];
                        
                    }
                }

                if (nextUsage < Data -> ButtonData.MaxUsageLength) 
                {
                    Data->ButtonData.Usages[nextUsage] = 0;
                }
            }
            else 
            {
                Data->Status = HidP_GetUsageValue (
                                                ReportType,
                                                Data->UsagePage,
                                                0,               // All Collections.
                                                Data->ValueData.Usage,
                                                &Data->ValueData.Value,
                                                Ppd,
                                                ReportBuffer,
                                                ReportBufferLength);

                if (HIDP_STATUS_SUCCESS != Data->Status)
                {
                    return (FALSE);
                }

                Data->Status = HidP_GetScaledUsageValue (
                                                       ReportType,
                                                       Data->UsagePage,
                                                       0, // All Collections.
                                                       Data->ValueData.Usage,
                                                       &Data->ValueData.ScaledValue,
                                                       Ppd,
                                                       ReportBuffer,
                                                       ReportBufferLength);
            } 
            Data -> IsDataSet = TRUE;
        }
    }
    return (TRUE);
}


BOOLEAN
PackReport (
   OUT PCHAR                ReportBuffer,
   IN  USHORT               ReportBufferLength,
   IN  HIDP_REPORT_TYPE     ReportType,
   IN  PHID_DATA            Data,
   IN  ULONG                DataLength,
   IN  PHIDP_PREPARSED_DATA Ppd
   )
/*++
Routine Description:
   This routine takes in a list of HID_DATA structures (DATA) and builds 
      in ReportBuffer the given report for all data values in the list that 
      correspond to the report ID of the first item in the list.  

   For every data structure in the list that has the same report ID as the first
      item in the list will be set in the report.  Every data item that is 
      set will also have it's IsDataSet field marked with TRUE.

   A return value of FALSE indicates an unexpected error occurred when setting
      a given data value.  The caller should expect that assume that no values
      within the given data structure were set.

   A return value of TRUE indicates that all data values for the given report
      ID were set without error.
--*/
{
    ULONG       numUsages; // Number of usages to set for a given report.
    ULONG       i;
    ULONG       CurrReportID;

    /*
    // All report buffers that are initially sent need to be zero'd out
    */

    memset (ReportBuffer, (UCHAR) 0, ReportBufferLength);

    /*
    // Go through the data structures and set all the values that correspond to
    //   the CurrReportID which is obtained from the first data structure 
    //   in the list
    */

    CurrReportID = Data -> ReportID;

    for (i = 0; i < DataLength; i++, Data++) 
    {
        /*
        // There are two different ways to determine if we set the current data
        //    structure: 
        //    1) Store the report ID were using and only attempt to set those
        //        data structures that correspond to the given report ID.  This
        //        example shows this implementation.
        //
        //    2) Attempt to set all of the data structures and look for the 
        //        returned status value of HIDP_STATUS_INVALID_REPORT_ID.  This 
        //        error code indicates that the given usage exists but has a 
        //        different report ID than the report ID in the current report 
        //        buffer
        */

        if (Data -> ReportID == CurrReportID) 
        {
            if (Data->IsButtonData) 
            {
                numUsages = Data->ButtonData.MaxUsageLength;
                Data->Status = HidP_SetUsages (ReportType,
                                               Data->UsagePage,
                                               0, // All collections
                                               Data->ButtonData.Usages,
                                               &numUsages,
                                               Ppd,
                                               ReportBuffer,
                                               ReportBufferLength);
            }
            else
            {
                Data->Status = HidP_SetUsageValue (ReportType,
                                                   Data->UsagePage,
                                                   0, // All Collections.
                                                   Data->ValueData.Usage,
                                                   Data->ValueData.Value,
                                                   Ppd,
                                                   ReportBuffer,
                                                   ReportBufferLength);
            }

            if (HIDP_STATUS_SUCCESS != Data->Status)
            {
                return FALSE;
            }
        }
    }   

    /*
    // At this point, all data structures that have the same ReportID as the
    //    first one will have been set in the given report.  Time to loop 
    //    through the structure again and mark all of those data structures as
    //    having been set.
    */

    for (i = 0; i < DataLength; i++, Data++) 
    {
        if (CurrReportID == Data -> ReportID)
        {
            Data -> IsDataSet = TRUE;
        }
    }
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\client\hidserv\appcmd.c ===
/*++
 *
 *  Component:  hidserv.dll
 *  File:       appcmd.c
 *  Purpose:    routines to run the HID Audio server.
 *
 *  Copyright (C) Microsoft Corporation 1997,1998. All rights reserved.
 *
 *  WGJ
--*/

#define GLOBALS
#include "hidserv.h"

#define HIDSERV_FROM_SPEAKER 0x8000

/*++
 * IMPORTANT - All work within this service is synchronized by the
 * message procedure HidServProc() except the per device work thread
 * HidThreadProc(). All concurrent access to shared data is within the
 * message procedure thread and therefore is serialized. For example,
 * HidThreadProc() posts messages to the message thread when it needs
 * to perform a serialized action. Any deviation from this scheme must
 * be protected by critical section.
--*/

DWORD
WINAPI
HidServMain(
    HANDLE InitDoneEvent
    )
/*++
Routine Description:
    Creates the main message loop and executes the
    Hid Audio server.
--*/
{
    MSG msg;
    HANDLE thread;
    BOOLEAN classRegistered = FALSE;

    // Some controls have Auto Repeat timers. This mutex prevents
    // concurrent access to data by these async timers.
    hMutexOOC = CreateMutex(NULL, FALSE, TEXT("OOC State Mutex"));

    if (!hMutexOOC) {
        goto HidServMainBail;
    }
    // Use CreateMutex to detect previous instances of the app.
    if (GetLastError() == ERROR_ALREADY_EXISTS){
        WARN(("Exiting multiple Hid Service instance."));
        goto HidServMainBail;
    }

    hInputEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!hInputEvent) {
        goto HidServMainBail;   
    }

    hInputDoneEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!hInputDoneEvent) {
        goto HidServMainBail;
    }
    hDesktopSwitch = OpenEvent(SYNCHRONIZE, FALSE, TEXT("WinSta0_DesktopSwitch"));
    if (!hDesktopSwitch) {
        goto HidServMainBail;
    }
    InputThreadEnabled = TRUE;

    // Register the window class
    {
        WNDCLASSEX wce;
        wce.cbSize = sizeof(WNDCLASSEX);
        wce.style = 0;
        wce.lpfnWndProc = HidServProc;
        wce.cbClsExtra = 0;
        wce.cbWndExtra = 0;
        wce.hInstance = hInstance;
        wce.hIcon = NULL;
        wce.hIconSm = NULL;
        wce.hCursor = NULL;
        wce.hbrBackground = NULL;
        wce.lpszMenuName = NULL;
        wce.lpszClassName = TEXT("HidServClass");

        if (!RegisterClassEx(&wce)){
            WARN(("Cannot register thread window class: 0x%.8x\n", GetLastError()));
            goto HidServMainBail;            
        }

        classRegistered = TRUE;

    }

    // Create the app window.
    // Most events will be processed through this hidden window. Look at HidServProc() to see
    // what work this window message loop does.
    hWndHidServ = CreateWindow(TEXT("HidServClass"),
                            TEXT("HID Input Service"),
                            WS_OVERLAPPEDWINDOW,
                            0,
                            0,
                            0,
                            0,
                            (HWND) NULL,
                            (HMENU) NULL,
                            hInstance,
                            (LPVOID) NULL);

    TRACE(("hWndHidServ == %x", hWndHidServ));
    // If the window cannot be created, terminate
    if (!hWndHidServ){
        WARN(("Window creation failed."));
        goto HidServMainBail;     
    }

    // Register for selective device nofication
    // This only required for NT5
    {
    DEV_BROADCAST_DEVICEINTERFACE DevHdr;
        ZeroMemory(&DevHdr, sizeof(DevHdr));
        DevHdr.dbcc_size = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
        DevHdr.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
        HidD_GetHidGuid (&DevHdr.dbcc_classguid);

        hNotifyArrival =
        RegisterDeviceNotification( hWndHidServ,
                                    &DevHdr,
                                    DEVICE_NOTIFY_WINDOW_HANDLE);

        if (!hNotifyArrival){
            WARN(("RegisterDeviceNotification failure (%x).", GetLastError()));
            goto HidServMainBail;
        }
    }

    // We do this here, not in WM_CREATE handler, because the init routines need
    // to know the new window handle.
    HidServInit();

    InputSessionId = 0;
    InputSessionLocked = FALSE;
    WinStaDll = NULL;
    WinStaDll = LoadLibrary(TEXT("winsta.dll"));
    if (!WinStaDll) {
        goto HidServMainBail;
    }
    WinStaProc = (WINSTATIONSENDWINDOWMESSAGE)
        GetProcAddress(WinStaDll, "WinStationSendWindowMessage");

    if (!WinStaProc) {
        goto HidServMainBail;
    }
    
    thread = CreateThread(
        NULL, // pointer to thread security attributes
        0, // initial thread stack size, in bytes (0 = default)
        HidThreadInputProc, // pointer to thread function
        NULL, // argument for new thread
        0, // creation flags
        &InputThreadId // pointer to returned thread identifier
        );

    if (!thread) {
        goto HidServMainBail;
    }

    if (InitDoneEvent) {
        SetEvent(InitDoneEvent);
    }

    SET_SERVICE_STATE(SERVICE_RUNNING);

    // Start the message loop. This is terminated by system shutdown
    // or End Task. There is no UI to close the app.
    while (GetMessage(&msg, (HWND) NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    // To terminate, we only need to destroy the window. MmHidExit() was
    // already called on WM_CLOSE.
    DestroyWindow(hWndHidServ);
    INFO(("UnRegistering window class"));
    UnregisterClass(TEXT("HidServClass"),
                    hInstance);


    // Don't let this process go until all HidThreadProc() threads are complete.

    // Lets first wait for the thread to complete so that the thread has a chance
    // to at least increment the cThreadRef
    WaitForSingleObject(thread,
                        INFINITE);

    // 
    // Since we don't have the per-device thread handles, we will just wait for 
    // the ref count to hid zero
    //
    while (cThreadRef) SleepEx(1000, FALSE);

    return 0;

HidServMainBail:
    if (hMutexOOC) {
        CloseHandle(hMutexOOC);
    }

    if (hInputEvent) {
        CloseHandle(hInputEvent);
    }

    if (hInputDoneEvent) {
        CloseHandle(hInputDoneEvent);
    }

    if (hDesktopSwitch) {
        CloseHandle(hDesktopSwitch);
    }

    if (hWndHidServ) {
        DestroyWindow(hWndHidServ);
    }

    if (classRegistered) {
        UnregisterClass(TEXT("HidServClass"),
                        hInstance);
    }

    if (WinStaDll) {
        FreeLibrary(WinStaDll);
    }


    // unstick ServiceMain
    if (InitDoneEvent) {
        SetEvent(InitDoneEvent);
    }


    SET_SERVICE_STATE(SERVICE_STOPPED);

    return 0;
}

void
HidservSetPnP(
    BOOL Enable
    )
{
    if (Enable) {
        if (!PnpEnabled){
            // Enable device refresh.
            PnpEnabled = TRUE;

            PostMessage(hWndHidServ, WM_HIDSERV_PNP_HID, 0, 0);
        }
    } else {
        // Prevent any device refresh.
        PnpEnabled = FALSE;

        DestroyHidDeviceList();
    }
}

void
HidServStart(
    void
    )
/*++
Routine Description:
    Restart the Hid Audio server if it has been stopped.
--*/
{
    HidservSetPnP(TRUE);

    SET_SERVICE_STATE(SERVICE_RUNNING);
}


void
HidServStop(
    void
    )
/*++
Routine Description:
    Stop all activity, but keep static data, and keep
    the message queue running.
--*/
{

    // Prevent any device refresh.
    HidservSetPnP(FALSE);

    SET_SERVICE_STATE(SERVICE_STOPPED);
}


BOOL
HidServInit(
    void
    )
/*++
Routine Description:
    Setup all data structures and open system handles.
--*/
{

    HidServStart();

    return TRUE;
}

void
HidServExit(
    void
    )
/*++
Routine Description:
    Close all system handles.
--*/
{
    if (WinStaDll) {
        FreeLibrary(WinStaDll);
    }
    UnregisterDeviceNotification(hNotifyArrival);
    HidServStop();
    CloseHandle(hMutexOOC);

    if (InputThreadEnabled) {
        InputThreadEnabled = FALSE;
        SetEvent(hInputEvent);
    }
}

VOID
HidThreadChangeDesktop (
    )
{
    HDESK hDesk, hPrevDesk;
    BOOL result;
    HWINSTA prevWinSta, winSta = NULL;

    hPrevDesk = GetThreadDesktop(GetCurrentThreadId());
    prevWinSta = GetProcessWindowStation();

    INFO(("Setting the input thread's desktop"));
    winSta = OpenWindowStation(TEXT("WinSta0"), FALSE, MAXIMUM_ALLOWED);

    if (!winSta) {
        WARN(("Couldn't get the window station! Error: 0x%x", GetLastError()));
        goto HidThreadChangeDesktopError;
    }

    if (!SetProcessWindowStation(winSta)) {
        WARN(("Couldn't set the window station! Error: 0x%x", GetLastError()));
        goto HidThreadChangeDesktopError;
    }

    hDesk = OpenInputDesktop(0,
                             FALSE,
                             MAXIMUM_ALLOWED);

    if (!hDesk) {
        WARN(("Couldn't get the input desktop! Error: 0x%x", GetLastError()));
        goto HidThreadChangeDesktopError;
    }

    if (!SetThreadDesktop(hDesk)) {
        WARN(("Couldn't set the thread's desktop to the input desktop! Error: 0x%x", GetLastError()));
    }

HidThreadChangeDesktopError:
    if (hPrevDesk) {
        CloseDesktop(hPrevDesk);
    }
    if (prevWinSta) {
        CloseWindowStation(prevWinSta);
    }
}

DWORD
WINAPI
HidThreadInputProc(
    PVOID Ignore
    )
{
    GUITHREADINFO threadInfo;
    HWND hWndForeground;
    INPUT input;
    HANDLE events[2];
    DWORD ret;
    DWORD nEvents = 0;

    InterlockedIncrement(&cThreadRef);

    events[nEvents++] = hDesktopSwitch;
    events[nEvents++] = hInputEvent;

    //
    // This thread needs to run on the input desktop.
    //
    HidThreadChangeDesktop();

    while (TRUE) {

        ret = WaitForMultipleObjects(nEvents, events, FALSE, INFINITE);
        if (!InputThreadEnabled) {
            break;
        }
        if (0 == (ret - WAIT_OBJECT_0)) {
            HidThreadChangeDesktop();
            continue;
        }
        if (InputIsAppCommand) {
            threadInfo.cbSize = sizeof(GUITHREADINFO);
            if (GetGUIThreadInfo(0, &threadInfo)) {
                hWndForeground = threadInfo.hwndFocus ? threadInfo.hwndFocus : threadInfo.hwndActive;
                if (hWndForeground) {
                    INFO(("Sending app command 0x%x", InputAppCommand));
                    SendNotifyMessage(hWndForeground,
                                      WM_APPCOMMAND,
                                      (WPARAM)hWndForeground,
                                      ((InputAppCommand | FAPPCOMMAND_OEM)<<16));
                } else {
                    WARN(("No window available to send to, error %x", GetLastError()));
                }
            } else {
                WARN(("Unable to get the focus window, error %x", GetLastError()));
            }
        } else {

            ZeroMemory(&input, sizeof(INPUT));

            input.type = INPUT_KEYBOARD;
            input.ki.dwFlags = InputDown ? 0 : KEYEVENTF_KEYUP;

            if (InputIsChar) {
                input.ki.wScan = InputVKey;
                input.ki.dwFlags |= KEYEVENTF_UNICODE;
                INFO(("Sending character %c %s", InputVKey, InputDown ? "down" : "up"));
            } else {
                input.ki.wVk = InputVKey;
                input.ki.dwFlags |= KEYEVENTF_EXTENDEDKEY;
                INFO(("Sending VK 0x%x %s", InputVKey, InputDown ? "down" : "up"));
            }

            SendInput(1, &input, sizeof(INPUT));
        }
        SetEvent(hInputDoneEvent);
    }

    CloseHandle(hDesktopSwitch);
    CloseHandle(hInputEvent);
    CloseHandle(hInputDoneEvent);

    InterlockedDecrement(&cThreadRef);

    return 0;
}


DWORD
WINAPI
HidThreadProc(
   PHID_DEVICE    HidDevice
   )
/*++
Routine Description:
    Create this I/O thread for each Consumer Collection we have
    open. The thread dies when we close our handle on the HID device.
--*/
{
    DWORD Ret;
    DWORD bytesRead;
    BOOL bRet;
    DWORD dwError;
    USAGE_AND_PAGE *pPrevious;
    PHID_DATA data = HidDevice->InputData;

    TRACE(("Entering HidThreadProc. Device(%x)", HidDevice));

    InterlockedIncrement(&cThreadRef);

    // wait for an async read
    INFO(("HidThreadProc waiting for read event..."));
    WaitForSingleObject(HidDevice->ReadEvent, INFINITE);

    while (HidDevice->fThreadEnabled){

        TRACE(("Reading from Handle(%x)", HidDevice->HidDevice));
        bRet = ReadFile (HidDevice->HidDevice,
                       HidDevice->InputReportBuffer,
                       HidDevice->Caps.InputReportByteLength,
                       &bytesRead,
                       &HidDevice->Overlap);
        dwError = GetLastError();

        // wait for read to complete
        TRACE(("HidThreadProc waiting for completion."));

        if(bRet){
            TRACE(("Read completed synchronous."));
        }else{
            if (dwError == ERROR_IO_PENDING) {
                TRACE(("Read pending."));

                // work thread waits for completion
                while (TRUE) {
                    Ret = WaitForSingleObject(HidDevice->CompletionEvent, 5000);
                    if (Ret == WAIT_OBJECT_0) {
                        TRACE(("Read completed on device (%x).", HidDevice));
                        break;
                    }
                    if (!HidDevice->fThreadEnabled) {
                        if (CancelIo(HidDevice->HidDevice)) {
                            TRACE(("CancelIo succeeded for device (%x).", HidDevice));
                            break;
                        }
                    }
                }
                TRACE(("Read complete async."));

            } else {
                WARN(("Read Failed with error %x. device = %x, handle = %x", dwError, HidDevice, HidDevice->HidDevice));
                INFO(("Device may no longer be connected. Waiting for device notification from pnp..."));
                // Just wait for the device notification to come thru from PnP.
                // Then we'll remove the device.
                WaitForSingleObject(HidDevice->ReadEvent, INFINITE);
                break;
            }
        }

        // don't parse data if we are exiting.
        if (!HidDevice->fThreadEnabled) {
            WaitForSingleObject(HidDevice->ReadEvent, INFINITE);
            break;
        }

        // parse the hid report
        ParseReadReport(HidDevice);

        // post message to dispatch this report
        HidServReportDispatch(HidDevice);
    }

    // Exit Thread means completely clean up this device instance
    TRACE(("HidThreadProc (%x) Exiting...", HidDevice));

    //
    // Send any leftover button up events
    //
    if (data->IsButtonData) {
        pPrevious = data->ButtonData.PrevUsages;
        while (pPrevious->Usage){
        int j;
            // find the client that handled the button down.
            for(j=0; j<MAX_PENDING_BUTTONS; j++){
                if ( PendingButtonList[j].Collection == data->LinkUsage &&
                    PendingButtonList[j].Page == pPrevious->UsagePage &&
                    PendingButtonList[j].Usage == pPrevious->Usage){
                    PendingButtonList[j].Collection = 0;
                    PendingButtonList[j].Page = 0;
                    PendingButtonList[j].Usage = 0;
                    break;
                }
            }

            PostMessage(hWndHidServ,
                        WM_CI_USAGE,
                        (WPARAM)MakeLongUsage(data->LinkUsage,pPrevious->Usage),
                        (LPARAM)MakeLongUsage(pPrevious->UsagePage, 0));
            pPrevious++;
        }
    }

    CloseHandle(HidDevice->HidDevice);
    CloseHandle(HidDevice->ReadEvent);
    CloseHandle(HidDevice->CompletionEvent);

    INFO(("Free device data. (%x)", HidDevice));

    HidFreeDevice (HidDevice);

    InterlockedDecrement(&cThreadRef);
    TRACE(("HidThreadProc Exit complete."));
    return 0;
}

BOOL
UsageInList(
    PUSAGE_AND_PAGE   pUsage,
    PUSAGE_AND_PAGE   pUsageList
    )
/*++
Routine Description:
    This utility function returns TRUE if the usage is found in the array.
--*/
{
    while (pUsageList->Usage){
        if ( (pUsage->Usage == pUsageList->Usage) &&
            (pUsage->UsagePage == pUsageList->UsagePage))
            return TRUE;
        pUsageList++;
    }
    return FALSE;
}

void
HidServReportDispatch(
    PHID_DEVICE     HidDevice
    )
/*++
Routine Description:
    Look at the HID input structure and determine what button down,
    button up, or value data events have occurred. We send info about these events
    to the most appropriate client.
--*/
{
    USAGE_AND_PAGE *     pUsage;
    USAGE_AND_PAGE *     pPrevious;
    DWORD       i;
    PHID_DATA   data = HidDevice->InputData;

    TRACE(("Input data length = %d", HidDevice->InputDataLength));
    TRACE(("Input data -> %.8x", HidDevice->InputData));

    for (i = 0;
         i < HidDevice->InputDataLength;
         i++, data++) {

        // If Collection is 0, then make it default
        if (!data->LinkUsage)
            data->LinkUsage = CInputCollection_Consumer_Control;

        if (data->Status != HIDP_STATUS_SUCCESS){
            // never try to process errored data
            //TRACE(("Input data is invalid. Status = %x", data->Status));

        }else if (data->IsButtonData){
            TRACE(("Input data is button data:"));
            TRACE(("    Input Usage Page = %x, Collection = %x", data->UsagePage, data->LinkUsage));

            pUsage = data->ButtonData.Usages;
            pPrevious = data->ButtonData.PrevUsages;

            /// Notify clients of any button down events
            //
            while (pUsage->Usage){
            int j;
                TRACE(("    Button Usage Page = %x", pUsage->UsagePage));
                TRACE(("    Button Usage      = %x", pUsage->Usage));

                if (HidDevice->Speakers) {
                    pUsage->Usage |= HIDSERV_FROM_SPEAKER;
                }

                // is this button already down?
                for(j=0; j<MAX_PENDING_BUTTONS; j++)
                    // The Pending Button List is used to keep state for all
                    // currently pressed buttons.
                    if ( PendingButtonList[j].Collection == data->LinkUsage &&
                        PendingButtonList[j].Page == pUsage->UsagePage &&
                        PendingButtonList[j].Usage == pUsage->Usage)
                            break;
                // discard successive button downs
                if (j<MAX_PENDING_BUTTONS){
                    pUsage++;
                    continue;
                }

                // post the message
                PostMessage(hWndHidServ,
                            WM_CI_USAGE,
                            (WPARAM)MakeLongUsage(data->LinkUsage,pUsage->Usage),
                            (LPARAM)MakeLongUsage(pUsage->UsagePage, 1)
                            );

                // Add to the pending button list
                for(j=0; j<MAX_PENDING_BUTTONS; j++){
                    if (!PendingButtonList[j].Collection &&
                        !PendingButtonList[j].Page &&
                        !PendingButtonList[j].Usage){
                        PendingButtonList[j].Collection = data->LinkUsage;
                        PendingButtonList[j].Page = pUsage->UsagePage;
                        PendingButtonList[j].Usage = pUsage->Usage;
                        break;
                    }
                }

                // if it didn't make the list, send button up now.
                if (j==MAX_PENDING_BUTTONS){
                    PostMessage(    hWndHidServ,
                                    WM_CI_USAGE,
                                    (WPARAM)MakeLongUsage(data->LinkUsage,pUsage->Usage),
                                    (LPARAM)MakeLongUsage(pUsage->UsagePage, 0)
                                    );
                    WARN(("Emitting immediate button up (C=%.2x,U=%.2x,P=%.2x)", data->LinkUsage, pUsage->Usage, pUsage->UsagePage));
                }

            pUsage++;
            }

            /// Notify clients of any button up events
            //
            while (pPrevious->Usage){
            int j;
                if (!UsageInList(pPrevious, pUsage)){

                    // we have a button up.
                    //
                    TRACE(("    Button Up  (C=%.2x,U=%.2x,P=%.2x)", data->LinkUsage, pPrevious->Usage, pPrevious->UsagePage));

                    // find the client that handled the button down.
                    for(j=0; j<MAX_PENDING_BUTTONS; j++){
                        if ( PendingButtonList[j].Collection == data->LinkUsage &&
                            PendingButtonList[j].Page == pPrevious->UsagePage &&
                            PendingButtonList[j].Usage == pPrevious->Usage){
                            PendingButtonList[j].Collection = 0;
                            PendingButtonList[j].Page = 0;
                            PendingButtonList[j].Usage = 0;
                            break;
                        }
                    }

                    // post the message if client found
                    if (j<MAX_PENDING_BUTTONS){
                        PostMessage(    hWndHidServ,
                                        WM_CI_USAGE,
                                        (WPARAM)MakeLongUsage(data->LinkUsage,pPrevious->Usage),
                                        (LPARAM)MakeLongUsage(pPrevious->UsagePage, 0)
                                        );
                    } else {
                        WARN(("Button Up client not found (C=%.2x,U=%.2x,P=%.2x)", data->LinkUsage, pPrevious->Usage, pPrevious->UsagePage));
                    }
                }
                pPrevious++;
            }

            // Remember what buttons were down, so next time we can
            // detect if they come up.
            pPrevious = data->ButtonData.Usages;
            data->ButtonData.Usages = data->ButtonData.PrevUsages;
            data->ButtonData.PrevUsages = pPrevious;

         } else {
            TRACE(("Input data is value data:"));
            TRACE(("    Input Usage Page = %x, Collection = %x", data->UsagePage, data->LinkUsage));
            TRACE(("    Input Usage      = %x", data->ValueData.Usage));

            // don't send zeroes or invalid range.
            if ( data->ValueData.ScaledValue &&
                data->ValueData.LogicalRange){

                // post the message
                // rescale the data to a standard range
                PostMessage(hWndHidServ,
                            WM_CI_USAGE,
                            (WPARAM)MakeLongUsage(data->LinkUsage,data->ValueData.Usage),
                            (LPARAM)MakeLongUsage(data->UsagePage,(USHORT)(((double)data->ValueData.ScaledValue/data->ValueData.LogicalRange)*65536)));
            }
         }
    }


}

void
SendVK(
    UCHAR VKey,
    SHORT Down
    )
{
    if (InputThreadEnabled && !InputSessionLocked) {
        if (InputSessionId == 0) {
            InputVKey = VKey;
            InputDown = Down;
            InputIsAppCommand = FALSE;
            InputIsChar = FALSE;
            SetEvent(hInputEvent);
            WaitForSingleObject(hInputDoneEvent, INFINITE);
        } else {
            CrossSessionWindowMessage(Down ? WM_KEYDOWN : WM_KEYUP, VKey, 0);
        }
    }
}

void
SendChar(
    UCHAR wScan,
    SHORT Down
    )
{
    if (InputThreadEnabled && !InputSessionLocked) {
        if (InputSessionId == 0) {
            InputVKey = wScan;
            InputDown = Down;
            InputIsAppCommand = FALSE;
            InputIsChar = TRUE;
            SetEvent(hInputEvent);
            WaitForSingleObject(hInputDoneEvent, INFINITE);
        } else {
            CrossSessionWindowMessage(Down ? WM_KEYDOWN : WM_KEYUP, 0, wScan);
        }
    }
}

void
SendAppCommand(
    USHORT AppCommand
    )
{
    if (InputThreadEnabled && !InputSessionLocked) {
        if (InputSessionId == 0) {
            InputAppCommand = AppCommand;
            InputIsAppCommand = TRUE;
            InputIsChar = FALSE;
            SetEvent(hInputEvent);
            WaitForSingleObject(hInputDoneEvent, INFINITE);
        } else {
            CrossSessionWindowMessage(WM_APPCOMMAND, AppCommand, 0);
        }
    }
}

VOID
VolumeTimerHandler(
    WPARAM   TimerID
    )
/*++
Routine Description:
    This timer handler routine is called for all timeouts on auto-repeat capable
    contols.
--*/
{
    INFO(("Timer triggered, TimerId = %d", TimerID));
    WaitForSingleObject(hMutexOOC, INFINITE);

    switch (TimerID){
    case TIMERID_VOLUMEUP_VK:
        if (OOC(TIMERID_VOLUMEUP_VK)){
            SendVK(VK_VOLUME_UP, 0x1);
            OOC(TIMERID_VOLUMEUP_VK) = SetTimer(hWndHidServ, TIMERID_VOLUMEUP_VK, REPEAT_INTERVAL, NULL);
        }
        break;
    case TIMERID_VOLUMEDN_VK:
        if (OOC(TIMERID_VOLUMEDN_VK)){
            SendVK(VK_VOLUME_DOWN, 0x1);
            OOC(TIMERID_VOLUMEDN_VK) = SetTimer(hWndHidServ, TIMERID_VOLUMEDN_VK, REPEAT_INTERVAL, NULL);
        }
        break;
    case TIMERID_VOLUMEUP:
        if (OOC(TIMERID_VOLUMEUP)){
            SendAppCommand(APPCOMMAND_VOLUME_UP);
            OOC(TIMERID_VOLUMEUP) = SetTimer(hWndHidServ, TIMERID_VOLUMEUP, REPEAT_INTERVAL, NULL);
        }
        break;
    case TIMERID_VOLUMEDN:
        if (OOC(TIMERID_VOLUMEDN)){
            SendAppCommand(APPCOMMAND_VOLUME_DOWN);
            OOC(TIMERID_VOLUMEDN) = SetTimer(hWndHidServ, TIMERID_VOLUMEDN, REPEAT_INTERVAL, NULL);
        }
        break;
    case TIMERID_BASSUP:
        if (OOC(TIMERID_BASSUP)){
            SendAppCommand(APPCOMMAND_BASS_UP);
            OOC(TIMERID_BASSUP) = SetTimer(hWndHidServ, TIMERID_BASSUP, REPEAT_INTERVAL, NULL);
        }
        break;
    case TIMERID_BASSDN:
        if (OOC(TIMERID_BASSDN)){
            SendAppCommand(APPCOMMAND_BASS_DOWN);
            OOC(TIMERID_BASSDN) = SetTimer(hWndHidServ, TIMERID_BASSDN, REPEAT_INTERVAL, NULL);
        }
        break;
    case TIMERID_TREBLEUP:
        if (OOC(TIMERID_TREBLEUP)){
            SendAppCommand(APPCOMMAND_TREBLE_UP);
            OOC(TIMERID_TREBLEUP) = SetTimer(hWndHidServ, TIMERID_TREBLEUP, REPEAT_INTERVAL, NULL);
        }
        break;
    case TIMERID_TREBLEDN:
        if (OOC(TIMERID_TREBLEDN)){
            SendAppCommand(APPCOMMAND_TREBLE_DOWN);
            OOC(TIMERID_TREBLEDN) = SetTimer(hWndHidServ, TIMERID_TREBLEDN, REPEAT_INTERVAL, NULL);
        }
        break;
    case TIMERID_APPBACK:
        if (OOC(TIMERID_APPBACK)){
            SendVK(VK_BROWSER_BACK, 0x1);
            OOC(TIMERID_APPBACK) = SetTimer(hWndHidServ, TIMERID_APPBACK, REPEAT_INTERVAL, NULL);
        }
        break;
    case TIMERID_APPFORWARD:
        if (OOC(TIMERID_APPFORWARD)){
            SendVK(VK_BROWSER_FORWARD, 0x1);
            OOC(TIMERID_APPFORWARD) = SetTimer(hWndHidServ, TIMERID_APPFORWARD, REPEAT_INTERVAL, NULL);
        }
        break;
    case TIMERID_PREVTRACK:
        if (OOC(TIMERID_PREVTRACK)){
            SendVK(VK_MEDIA_PREV_TRACK, 0x1);
            OOC(TIMERID_PREVTRACK) = SetTimer(hWndHidServ, TIMERID_PREVTRACK, REPEAT_INTERVAL, NULL);
        }
        break;
    case TIMERID_NEXTTRACK:
        if (OOC(TIMERID_NEXTTRACK)){
            SendVK(VK_MEDIA_NEXT_TRACK, 0x1);
            OOC(TIMERID_NEXTTRACK) = SetTimer(hWndHidServ, TIMERID_NEXTTRACK, REPEAT_INTERVAL, NULL);
        }
        break;
    case TIMERID_KEYPAD_LPAREN:
        if (OOC(TIMERID_KEYPAD_LPAREN)) {
            SendChar(L'(', 0x1);
            OOC(TIMERID_KEYPAD_LPAREN) = SetTimer(hWndHidServ, TIMERID_KEYPAD_LPAREN, REPEAT_INTERVAL, NULL);
        }
        break;
    case TIMERID_KEYPAD_RPAREN:
        if (OOC(TIMERID_KEYPAD_RPAREN)) {
            SendChar(L')', 0x1);
            OOC(TIMERID_KEYPAD_RPAREN) = SetTimer(hWndHidServ, TIMERID_KEYPAD_RPAREN, REPEAT_INTERVAL, NULL);
        }
        break;
    case TIMERID_KEYPAD_AT:
        if (OOC(TIMERID_KEYPAD_AT)) {
            SendChar(L'@', 0x1);
            OOC(TIMERID_KEYPAD_AT) = SetTimer(hWndHidServ, TIMERID_KEYPAD_AT, REPEAT_INTERVAL, NULL);
        }
        break;
    case TIMERID_KEYPAD_EQUAL:
        if (OOC(TIMERID_KEYPAD_EQUAL)) {
            SendChar(L'=', 0x1);
            OOC(TIMERID_KEYPAD_EQUAL) = SetTimer(hWndHidServ, TIMERID_KEYPAD_EQUAL, REPEAT_INTERVAL, NULL);
        }
        break;
    }

    ReleaseMutex(hMutexOOC);
}

void
HidRepeaterCharButtonDown(
    UINT TimerId,
    SHORT Value,
    UCHAR WScan
    )
{
   INFO(("Received update char,value = %d, TimerId = %d", Value, TimerId));
   WaitForSingleObject(hMutexOOC, INFINITE);
   if (Value){
       if (!OOC(TimerId)){
           SendChar(WScan, 0x1);
           OOC(TimerId) = SetTimer(hWndHidServ, TimerId, INITIAL_WAIT, NULL);
       }
   } else {
       KillTimer(hWndHidServ, TimerId);
       OOC(TimerId) = 0;
       SendChar(WScan, 0x0);
   }
   ReleaseMutex(hMutexOOC);

}


void
HidRepeaterVKButtonDown(
    UINT TimerId,
    SHORT Value,
    UCHAR VKey
    )
{
    INFO(("Received update vk,value = %d, TimerId = %d", Value, TimerId));
    WaitForSingleObject(hMutexOOC, INFINITE);
    if (Value){
        if (!OOC(TimerId)){
            SendVK(VKey, 0x1);
            OOC(TimerId) = SetTimer(hWndHidServ, TimerId, INITIAL_WAIT, NULL);
        }
    } else {
        KillTimer(hWndHidServ, TimerId);
        OOC(TimerId) = 0;
        SendVK(VKey, 0x0);
    }
    ReleaseMutex(hMutexOOC);
}

void
HidServUpdate(
    DWORD   LongUsage,
    DWORD   LongValue
    )
/*++
Routine Description:
    This is the client routine for the default handler. This client attempts to satisfy
    input events by injecting appcommands or keypresses to the current input window.
--*/
{
    USAGE Collection = (USAGE)HIWORD(LongUsage);
    USAGE Usage = (USAGE)LOWORD(LongUsage);
    USAGE Page = (USAGE)HIWORD(LongValue);
    SHORT Value = (SHORT)LOWORD(LongValue);
    BOOLEAN fromSpeaker = ((Usage & HIDSERV_FROM_SPEAKER) == HIDSERV_FROM_SPEAKER);

    Usage &= ~HIDSERV_FROM_SPEAKER;

    INFO(("Update collection = %x", Collection));
    INFO(("Update page  = %x", Page));
    INFO(("Update usage = %x", Usage));
    INFO(("Update data  = %d", Value));

    if (Collection == CInputCollection_Consumer_Control){

        // NOTE: If we ever choose to support this page thing, keep in mind
        // that the Altec Lansing ADA 70s report page zero. Should take out
        // the consumer page and make it the default.
        switch (Page) {
        case HID_USAGE_PAGE_UNDEFINED:
        case HID_USAGE_PAGE_CONSUMER:
            switch (Usage){
            /// Button Usages
            //

            //
            // These buttons have auto repeat capability...
            // delay for .5 sec before auto repeat kicks in.
            //
            case CInputUsage_Volume_Increment:
                INFO(("Volume increment."));
                if (fromSpeaker) {
                    INFO(("From speaker."));
                    WaitForSingleObject(hMutexOOC, INFINITE);
                    if (Value){
                        if (!OOC(TIMERID_VOLUMEUP)){
                            SendAppCommand(APPCOMMAND_VOLUME_UP);
                            OOC(TIMERID_VOLUMEUP) = SetTimer(hWndHidServ, TIMERID_VOLUMEUP, INITIAL_WAIT, NULL);
                        }
                    } else {
                        KillTimer(hWndHidServ, TIMERID_VOLUMEUP);
                        OOC(TIMERID_VOLUMEUP) = 0;
                    }
                    ReleaseMutex(hMutexOOC);
                } else {
                    INFO(("From keyboard."));
                    HidRepeaterVKButtonDown(TIMERID_VOLUMEUP_VK, Value, VK_VOLUME_UP);
                }
                break;
            case CInputUsage_Volume_Decrement:
                INFO(("Volume decrement."));
                if (fromSpeaker) {
                    INFO(("From speaker."));
                    WaitForSingleObject(hMutexOOC, INFINITE);
                    if (Value){
                        if (!OOC(TIMERID_VOLUMEDN)){
                            SendAppCommand(APPCOMMAND_VOLUME_DOWN);
                            OOC(TIMERID_VOLUMEDN) = SetTimer(hWndHidServ, TIMERID_VOLUMEDN, INITIAL_WAIT, NULL);
                        }
                    } else {
                        KillTimer(hWndHidServ, TIMERID_VOLUMEDN);
                        OOC(TIMERID_VOLUMEDN) = 0;
                    }
                    ReleaseMutex(hMutexOOC);
                } else {
                    INFO(("From keyboard."));
                    HidRepeaterVKButtonDown(TIMERID_VOLUMEDN_VK, Value, VK_VOLUME_DOWN);
                }
                break;
            case CInputUsage_App_Back:
                INFO(("App Back."));
                HidRepeaterVKButtonDown(TIMERID_APPBACK, Value, VK_BROWSER_BACK);
                break;
            case CInputUsage_App_Forward:
                INFO(("App Forward."));
                HidRepeaterVKButtonDown(TIMERID_APPFORWARD, Value, VK_BROWSER_FORWARD);
                break;
            case CInputUsage_Scan_Previous_Track:
                INFO(("Media Previous Track."));
                HidRepeaterVKButtonDown(TIMERID_PREVTRACK, Value, VK_MEDIA_PREV_TRACK);
                break;
            case CInputUsage_Scan_Next_Track:
                INFO(("Media Next Track."));
                HidRepeaterVKButtonDown(TIMERID_NEXTTRACK, Value, VK_MEDIA_NEXT_TRACK);
                break;

            case CInputUsage_Bass_Increment:
                INFO(("Bass increment."));
                WaitForSingleObject(hMutexOOC, INFINITE);
                if (Value){
                    if (!OOC(TIMERID_BASSUP)){
                        SendAppCommand(APPCOMMAND_BASS_UP);
                        OOC(TIMERID_BASSUP) = SetTimer(hWndHidServ, TIMERID_BASSUP, INITIAL_WAIT, NULL);
                    }
                } else {
                    KillTimer(hWndHidServ, TIMERID_BASSUP);
                    OOC(TIMERID_BASSUP) = 0;
                }
                ReleaseMutex(hMutexOOC);
                break;
            case CInputUsage_Bass_Decrement:
                INFO(("Bass decrement."));
                WaitForSingleObject(hMutexOOC, INFINITE);
                if (Value){
                    if (!OOC(TIMERID_BASSDN)){
                        SendAppCommand(APPCOMMAND_BASS_DOWN);
                        OOC(TIMERID_BASSDN) = SetTimer(hWndHidServ, TIMERID_BASSDN, INITIAL_WAIT, NULL);
                    }
                } else {
                    KillTimer(hWndHidServ, TIMERID_BASSDN);
                    OOC(TIMERID_BASSDN) = 0;
                }
                ReleaseMutex(hMutexOOC);
                break;

            case CInputUsage_Treble_Increment:
                INFO(("Treble increment."));
                WaitForSingleObject(hMutexOOC, INFINITE);
                if (Value){
                    if (!OOC(TIMERID_TREBLEUP)){
                        SendAppCommand(APPCOMMAND_TREBLE_UP);
                        OOC(TIMERID_TREBLEUP) = SetTimer(hWndHidServ, TIMERID_TREBLEUP, INITIAL_WAIT, NULL);
                    }
                } else {
                    KillTimer(hWndHidServ, TIMERID_TREBLEUP);
                    OOC(TIMERID_TREBLEUP) = 0;
                }
                ReleaseMutex(hMutexOOC);
                break;
            case CInputUsage_Treble_Decrement:
                INFO(("Treble decrement."));
                WaitForSingleObject(hMutexOOC, INFINITE);
                if (Value){
                    if (!OOC(TIMERID_TREBLEDN)){
                        SendAppCommand(APPCOMMAND_TREBLE_DOWN);
                        OOC(TIMERID_TREBLEDN) = SetTimer(hWndHidServ, TIMERID_TREBLEDN, INITIAL_WAIT, NULL);
                    }
                } else {
                    KillTimer(hWndHidServ, TIMERID_TREBLEDN);
                    OOC(TIMERID_TREBLEDN) = 0;
                }
                ReleaseMutex(hMutexOOC);
                break;

            // These buttons do not auto repeat...
            case CInputUsage_Loudness:
                    if (Value){
                    INFO(("Toggle Loudness."));
                    //SendAppCommandEx(??);
                }
                break;
            case CInputUsage_Bass_Boost:
                if (Value) {
                    INFO(("Toggle BassBoost."));
                    SendAppCommand(APPCOMMAND_BASS_BOOST);
                }
                break;

            case CInputUsage_Mute:
                INFO(("Toggle Mute."));
                if (fromSpeaker) {
                    INFO(("From speaker."));
                    if (Value) {
                        SendAppCommand(APPCOMMAND_VOLUME_MUTE);
                    }
                } else {
                    INFO(("From keyboard."));
                    SendVK(VK_VOLUME_MUTE, Value);
                }
                break;
            case CInputUsage_Play_Pause:
                INFO(("Media Play/Pause."));
                SendVK(VK_MEDIA_PLAY_PAUSE, Value);
                break;
            case CInputUsage_Stop:
                INFO(("Media Stop."));
                SendVK(VK_MEDIA_STOP, Value);
                break;
            case CInputUsage_Launch_Configuration:
                INFO(("Launch Configuration."));
                SendVK(VK_LAUNCH_MEDIA_SELECT, Value);
                break;
            case CInputUsage_Launch_Email:
                INFO(("Launch Email."));
                SendVK(VK_LAUNCH_MAIL, Value);
                break;
            case CInputUsage_Launch_Calculator:
                INFO(("Launch Calculator."));
                SendVK(VK_LAUNCH_APP2, Value);
                break;
            case CInputUsage_Launch_Browser:
                INFO(("Launch Browser."));
                SendVK(VK_LAUNCH_APP1, Value);
                break;
            case CInputUsage_App_Search:
                INFO(("App Search."));
                SendVK(VK_BROWSER_SEARCH, Value);
                break;
            case CInputUsage_App_Home:
                INFO(("App Home."));
                SendVK(VK_BROWSER_HOME, Value);
                break;
            case CInputUsage_App_Stop:
                INFO(("App Stop."));
                SendVK(VK_BROWSER_STOP, Value);
                break;
            case CInputUsage_App_Refresh:
                INFO(("App Refresh."));
                SendVK(VK_BROWSER_REFRESH, Value);
                break;
            case CInputUsage_App_Bookmarks:
                INFO(("App Bookmarks."));
                SendVK(VK_BROWSER_FAVORITES, Value);
                break;

            case CInputUsage_App_Previous:
                if (Value){
                    INFO(("App Previous."));
                    //SendAppCommand(??);
                }
                break;

            case CInputUsage_App_Next:
                if (Value){
                    INFO(("App Next."));
                    //SendAppCommand(??);
                }
                break;
#if(0)
            // New buttons
            case CInputUsage_App_Help:
                if (Value) {
                    INFO(("App Help"));
                    SendAppCommand(APPCOMMAND_HELP);
                }
                break;

            case CInputUsage_App_Find:
                if (Value) {
                    INFO(("App Find"));
                    SendAppCommand(APPCOMMAND_FIND);
                }
                break;

            case CInputUsage_App_New:
                if (Value) {
                    INFO(("App New"));
                    SendAppCommand(APPCOMMAND_NEW);
                }
                break;

            case CInputUsage_App_Open:
                if (Value) {
                    INFO(("App Open"));
                    SendAppCommand(APPCOMMAND_OPEN);
                }
                break;

            case CInputUsage_App_Close:
                if (Value) {
                    INFO(("App Close"));
                    SendAppCommand(APPCOMMAND_CLOSE);
                }
                break;

            case CInputUsage_App_Save:
                if (Value) {
                    INFO(("App Save"));
                    SendAppCommand(APPCOMMAND_SAVE);
                }
                break;

            case CInputUsage_App_Print:
                if (Value) {
                    INFO(("App Print"));
                    SendAppCommand(APPCOMMAND_PRINT);
                }
                break;

            case CInputUsage_App_Undo:
                if (Value) {
                    INFO(("App Undo"));
                    SendAppCommand(APPCOMMAND_UNDO);
                }
                break;

            case CInputUsage_App_Redo:
                if (Value) {
                    INFO(("App Redo"));
                    SendAppCommand(APPCOMMAND_REDO);
                }
                break;

            case CInputUsage_App_Copy:
                if (Value) {
                    INFO(("App Copy"));
                    SendAppCommand(APPCOMMAND_COPY);
                }
                break;

            case CInputUsage_App_Cut:
                if (Value) {
                    INFO(("App Cut"));
                    SendAppCommand(APPCOMMAND_CUT);
                }
                break;

            case CInputUsage_App_Paste:
                if (Value) {
                    INFO(("App Paste"));
                    SendAppCommand(APPCOMMAND_PASTE);
                }
                break;

            case CInputUsage_App_Reply_To_Mail:
                if (Value) {
                    INFO(("App Reply To Mail"));
                    SendAppCommand(APPCOMMAND_REPLY_TO_MAIL);
                }
                break;

            case CInputUsage_App_Forward_Mail:
                if (Value) {
                    INFO(("App Forward Mail"));
                    SendAppCommand(APPCOMMAND_FORWARD_MAIL);
                }
                break;

            case CInputUsage_App_Send_Mail:
                if (Value) {
                    INFO(("App Send Mail"));
                    SendAppCommand(APPCOMMAND_SEND_MAIL);
                }
                break;

            case CInputUsage_App_Spell_Check:
                if (Value) {
                    INFO(("App Spell Check"));
                    SendAppCommand(APPCOMMAND_SPELL_CHECK);
                }
                break;
#endif

            /// Value Usages
            //  These are not buttons, but are "value" events and do not have
            //  a corresponding button up event. Also, these never have an
            //  auto repeat function.
            case CInputUsage_Volume:
                INFO(("Volume dial"));
                if (Value>0) SendAppCommand(APPCOMMAND_VOLUME_UP);
                else if (Value<0)SendAppCommand(APPCOMMAND_VOLUME_DOWN);
                break;
            case CInputUsage_Bass:
                INFO(("Bass dial"));
                if (Value>0) SendAppCommand(APPCOMMAND_BASS_UP);
                else if (Value<0)SendAppCommand(APPCOMMAND_BASS_DOWN);
                break;
            case CInputUsage_Treble:
                INFO(("Treble dial"));
                if (Value>0) SendAppCommand(APPCOMMAND_TREBLE_UP);
                else if (Value<0)SendAppCommand(APPCOMMAND_TREBLE_DOWN);
                break;

            ////
            /// Media Select usages are not handled in this sample.
            //

            default:
                INFO(("Unhandled Usage (%x)", Usage));
                break;
            }
            break;
#if(0)
        case HID_USAGE_PAGE_KEYBOARD:

           switch (Usage) {
           case CInputUsage_Keypad_Equals:
              INFO(("Keypad ="));
              HidRepeaterCharButtonDown(TIMERID_KEYPAD_EQUAL, Value, L'=');
              break;
           case CInputUsage_Keypad_LParen:
              INFO(("Keypad ("));
              HidRepeaterCharButtonDown(TIMERID_KEYPAD_LPAREN, Value, L'(');
              break;
           case CInputUsage_Keypad_RParen:
              INFO(("Keypad )"));
              HidRepeaterCharButtonDown(TIMERID_KEYPAD_RPAREN, Value, L')');
              break;
           case CInputUsage_Keypad_At:
              INFO(("Keypad @"));
              HidRepeaterCharButtonDown(TIMERID_KEYPAD_AT, Value, L'@');
              break;
           }
           break;
#endif
        default:
           INFO(("Unhandled Page (%x)", Page));
           break;
        }

    } else {
        INFO(("Unhandled Collection (%x), usage = %x", Collection, Usage));
    }

}

BOOL
DeviceChangeHandler(
    WPARAM wParam,
    LPARAM lParam
    )
/*++
Routine Description:
    This is the handler for WM_DEVICECHANGE messages and is called
    whenever a device node is added or removed in the system. This
    event will cause us to refrsh our device information.
--*/
{
    struct _DEV_BROADCAST_HEADER    *pdbhHeader;
    pdbhHeader = (struct _DEV_BROADCAST_HEADER *)lParam;

    switch (wParam) {
    case DBT_DEVICEQUERYREMOVE :
        TRACE(("DBT_DEVICEQUERYREMOVE, fall through to..."));

        //
        // Fall thru.
        //

    case DBT_DEVICEREMOVECOMPLETE:
        TRACE(("DBT_DEVICEREMOVECOMPLETE"));

        TRACE(("dbcd_devicetype %x", pdbhHeader->dbcd_devicetype));
        if (pdbhHeader->dbcd_devicetype==DBT_DEVTYP_HANDLE)
        {
        PDEV_BROADCAST_HANDLE pdbHandle = (PDEV_BROADCAST_HANDLE)lParam;
            INFO(("Closing HID device (%x).", pdbHandle->dbch_handle));
            DestroyDeviceByHandle(pdbHandle->dbch_handle);
            break;
        }
        break;
    case DBT_DEVICEQUERYREMOVEFAILED:
        TRACE(("DBT_DEVICEQUERYREMOVEFAILED, fall through to..."));
        // The notification handle has already been closed
        // so we should never actually get this message. If we do,
        // falling through to device arrival is the correct thing to do.

        //
        // Fall thru.
        //

    case DBT_DEVICEARRIVAL:
        TRACE(("DBT_DEVICEARRIVAL: reenumerate"));
        TRACE(("dbcd_devicetype %x", pdbhHeader->dbcd_devicetype));
        if (pdbhHeader->dbcd_devicetype==DBT_DEVTYP_DEVICEINTERFACE)
        {
            // We will refresh our device info for any devnode arrival or removal.
            INFO(("HID device refresh."));
            PostMessage(hWndHidServ, WM_HIDSERV_PNP_HID, 0, 0);
            break;
        }
    }

    return TRUE;
}

VOID
HidKeyboardSettingsChange(WPARAM WParam)
{
    if (WParam == SPI_SETKEYBOARDSPEED ||
        WParam == SPI_SETKEYBOARDDELAY) {
        DWORD dwV;
        int v;
        //
        // The repeat rate has changed. Adjust the timer interval.
        // The keyboard delay has changed. Adjust the timer interval.
        //
        INFO(("Getting keyboard repeat rate."));
        SystemParametersInfo(SPI_GETKEYBOARDSPEED, 0, &dwV, 0);
        REPEAT_INTERVAL = 400 - (12*dwV);

        INFO(("Getting keyboard delay."));
        SystemParametersInfo(SPI_GETKEYBOARDDELAY, 0, &v, 0);
        INITIAL_WAIT = (1+v)*250;
    }
}

LRESULT
CALLBACK
HidServProc(
    HWND            hWnd,
    UINT            uMsg,
    WPARAM          wParam,
    LPARAM          lParam
    )
/*++
Routine Description:
    The primary message queue for the app.
--*/
{

    TRACE(("HidServProc uMsg=%x", uMsg));


    switch (uMsg)
    {

    // init
    case WM_CREATE :
        TRACE(("WM_CREATE"));
        //
        // Find out the default key values
        //
        HidKeyboardSettingsChange(SPI_SETKEYBOARDSPEED);
        return DefWindowProc(hWnd, uMsg, wParam, lParam);
        break;

    // start
    case WM_HIDSERV_START :
        TRACE(("WM_HIDSERV_START"));
        HidServStart();
        break;

    // stop
    case WM_HIDSERV_STOP :
        TRACE(("WM_HIDSERV_STOP"));
        HidServStop();
        break;

    // configuration change
    case WM_DEVICECHANGE:
        TRACE(("WM_DEVICECHANGE"));
        DeviceChangeHandler(wParam, lParam);
        return DefWindowProc(hWnd, uMsg, wParam, lParam);
        break;

    // Process Consumer Input usage
    case WM_CI_USAGE:
        TRACE(("WM_CI_USAGE"));
        HidServUpdate((DWORD)wParam, (DWORD)lParam);
        break;

    // HID device list refresh.
    case WM_HIDSERV_PNP_HID:
        TRACE(("WM_HIDSERV_PNP_HID"));
        if (PnpEnabled){
            INFO(("HID DeviceChange rebuild."));
            RebuildHidDeviceList();
            TRACE(("DeviceChange rebuild done."));
        }
        break;

#if WIN95_BUILD
    // Stop the specified hid device that has already been removed from
    // the global list.
    case WM_HIDSERV_STOP_DEVICE:
        StopHidDevice((PHID_DEVICE) lParam);
        break;
#endif // WIN95_BUILD

    // Process Timer
    case WM_TIMER:
        TRACE(("WM_TIMER"));

        // All auto-repeat controls handled here.
        VolumeTimerHandler(wParam); // wParam is Timer ID.
        break;

    // Usually an app need not respond to suspend/resume events, but there
    // have been problems with keeping some system handles open. So on
    // suspend, we close everything down except this message loop. On resume,
    // we bring it all back.
    case WM_POWERBROADCAST:
        TRACE(("WM_POWERBROADCAST"));
        switch ( (DWORD)wParam )
        {
        case PBT_APMQUERYSUSPEND:
            TRACE(("\tPBT_APMQUERYSUSPEND"));
            HidservSetPnP(FALSE);
            break;

        case PBT_APMQUERYSUSPENDFAILED:
            TRACE(("\tPBT_APMQUERYSUSPENDFAILED"));
            HidservSetPnP(TRUE);
            break;

        case PBT_APMSUSPEND:
            TRACE(("\tPBT_APMSUSPEND"));

            // Handle forced suspend
            if(PnpEnabled) {
                // Prevent any device refresh.
                HidservSetPnP(FALSE);
            }
            break;

        case PBT_APMRESUMESUSPEND:
            TRACE(("\tPBT_APMRESUMESUSPEND"));
            HidservSetPnP(TRUE);
            break;

        case PBT_APMRESUMEAUTOMATIC:
            TRACE(("\tPBT_APMRESUMEAUTOMATIC"));
            HidservSetPnP(TRUE);
            break;
        }
        break;

    // close
    case WM_CLOSE :
        TRACE(("WM_CLOSE"));
        HidServExit();
        PostMessage(hWndHidServ, WM_QUIT, 0, 0);
        return DefWindowProc(hWnd, uMsg, wParam, lParam);
        break;

    case WM_WTSSESSION_CHANGE:
        WARN(("WM_WTSSESSION_CHANGE type %x, session %d", wParam, lParam));
        switch (wParam) {
        case WTS_CONSOLE_CONNECT:
            InputSessionId = (ULONG)lParam;
            InputSessionLocked = FALSE;
            break;
        case WTS_CONSOLE_DISCONNECT:
            if (InputSessionId == (ULONG)lParam) {
                InputSessionId = 0;
            }
            break;
        case WTS_SESSION_LOCK:
            if (InputSessionId == (ULONG)lParam) {
                InputSessionLocked = TRUE;
            }
            break;
        case WTS_SESSION_UNLOCK:
            if (InputSessionId == (ULONG)lParam) {
                InputSessionLocked = FALSE;
            }
            break;
        }
        break;

    case WM_SETTINGCHANGE:
        HidKeyboardSettingsChange(wParam);
        TRACE(("WM_SETTINGCHANGE"));

    default:
        return DefWindowProc(hWnd, uMsg, wParam, lParam);
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\client\hidserv\dbg.h ===
/*++
 *
 *  Component:  hidserv.dll
 *  File:       dbg.h
 *  Purpose:    Ascii char debug macros.
 * 
 *  Copyright (C) Microsoft Corporation 1997,1998. All rights reserved.
 *
 *  WGJ
--*/

#ifndef _DBG_H_
#define _DBG_H_

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#define DBG_NAME "HidServ"

#ifdef DBG



#define TL_ALL          0
#define TL_DUMP         1
#define TL_TRACE        2
#define TL_INFO         3
#define TL_WARN         4
#define TL_ERROR        5

GLOBALS DWORD   G_TraceLevel EQU TL_WARN;

static void _dprint( IN PCHAR format, IN ... )
{
        char    buf[1024];
        va_list ap;

        va_start(ap, format);

        wvsprintfA( buf, format, ap );

        OutputDebugStringA(buf);

        va_end(ap);
}

#define DPRINTF _dprint
#define HPRINTF _dprint

#define VPRINTF _dprint

#define DUMP(strings) { \
    if(TL_DUMP >= G_TraceLevel){ \
        VPRINTF(DBG_NAME " DUMP: "); \
        VPRINTF##strings; \
        VPRINTF("\n"); \
    } \
}

#define TRACE(strings) { \
    if(TL_TRACE >= G_TraceLevel){ \
        VPRINTF(DBG_NAME " TRACE: "); \
        VPRINTF##strings; \
        VPRINTF("\n"); \
    } \
}

#define INFO(strings) { \
    if(TL_INFO >= G_TraceLevel){ \
        HPRINTF(DBG_NAME " INFO: "); \
        HPRINTF##strings; \
        HPRINTF("\n"); \
    } \
}

#define WARN(strings) {\
    if(TL_WARN >= G_TraceLevel){ \
        HPRINTF(DBG_NAME " WARNS: "); \
        HPRINTF##strings; \
        HPRINTF("\n"); \
    } \
}

#define TERROR(strings) 
        
#else //DBG

#define DPRINTF
#define HPRINTF
#define VPRINTF

#define DUMP(strings) 
#define TRACE(strings) 
#define INFO(strings) 
#define WARN(strings)
#define TERROR(strings)
#define ASSERT(exp)

#endif //DBG


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif //_DBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\client\hidserv\hid.h ===
/*++
 *
 *  Component:  hidserv.dll
 *  File:       hid.h
 *  Purpose:    header to support hid client capability.
 * 
 *  Copyright (C) Microsoft Corporation 1997,1998. All rights reserved.
 *
 *  WGJ
--*/

#ifndef HIDEXE_H
#define HIDEXE_H

#include <hidsdi.h>
#include <setupapi.h>

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

//
// A structure to hold the steady state data received from the hid device.
// Each time a read packet is received we fill in this structure.
// Each time we wish to write to a hid device we fill in this structure.
// This structure is here only for convenience.  Most real applications will
// have a more efficient way of moving the hid data to the read, write, and
// feature routines.
//
typedef struct _HID_DATA {
   BOOLEAN     IsButtonData;
   UCHAR       Reserved;
   USAGE       UsagePage;       // The usage page for which we are looking.
   USHORT      LinkCollection;  // hidparse internal index
   USAGE       LinkUsage;       // the actual logical collection usage
   ULONG       Status; // The last status returned from the accessor function
                       // when updating this field.
   union {
      struct {
         ULONG              MaxUsageLength; // Usages buffer length.
         PUSAGE_AND_PAGE    Usages; // list of usages (buttons ``down'' on the device.
         PUSAGE_AND_PAGE    PrevUsages; // list of usages previously ``down'' on the device.
      } ButtonData;
      struct {
         USAGE       Usage; // The usage describing this value;
         USHORT      Reserved;

         ULONG       Value;
         LONG        ScaledValue;
         ULONG       LogicalRange;
      } ValueData;
   };
} HID_DATA, *PHID_DATA;

typedef struct _HID_DEVICE {
   struct _HID_DEVICE * pNext;
   HANDLE               HidDevice; // A file handle to the hid device.
   PHIDP_PREPARSED_DATA Ppd; // The opaque parser info describing this device
   HIDP_CAPS            Caps; // The Capabilities of this hid device.
   HIDD_ATTRIBUTES      Attributes;
   
   // PnP info
   DWORD                DevInst;    // the devnode
   BOOL                 Active;     // Dead or alive?
   HDEVNOTIFY           hNotify;    // Device notification handle
    
   OVERLAPPED           Overlap;    // used for overlapped read.
   HANDLE               ReadEvent;  // when io pending occurs
   HANDLE               CompletionEvent;  // signals read completion.
   BOOL                 fThreadEnabled;
   DWORD                ThreadId;
   HANDLE               ThreadHandle;

   PCHAR                InputReportBuffer;
   PHID_DATA            InputData; // array of hid data structures
   ULONG                InputDataLength; // Num elements in this array.

   BOOLEAN              Speakers;
} HID_DEVICE, *PHID_DEVICE;


// pnp.c
BOOL
RebuildHidDeviceList (void);

BOOL
StartHidDevice(
    PHID_DEVICE      pHidDevice);

BOOL
StopHidDevice(
    PHID_DEVICE     pHidDevice);

BOOL
DestroyHidDeviceList(
    void);

BOOL
DestroyDeviceByHandle(
    HANDLE hDevice
    );

// report.c
BOOL
Read (
   PHID_DEVICE    HidDevice
   );

BOOL
ParseReadReport (
   PHID_DEVICE    HidDevice
   );

BOOL
Write (
   PHID_DEVICE    HidDevice
   );

BOOL
SetFeature (
   PHID_DEVICE    HidDevice
   );

BOOL
GetFeature (
   PHID_DEVICE    HidDevice
   );


#ifdef __cplusplus
}
#endif  /* __cplusplus */


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\filter\hidvalid\read.c ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\client\hidserv\hidserv.c ===
/*++
 *
 *  Component:  hidserv.dll
 *  File:       hidserv.c
 *  Purpose:    main entry and NT service routines.
 *
 *  Copyright (C) Microsoft Corporation 1997,1998. All rights reserved.
 *
 *  WGJ
--*/

#include "hidserv.h"

TCHAR HidservDisplayName[] = TEXT("HID Input Service");


VOID
InitializeGlobals()
/*++
Routine Description:
   Since .dll might be unloaded/loaded into the same process, so must reinitialize global vars
--*/
{
    PnpEnabled = FALSE;
    hNotifyArrival = 0;
    INITIAL_WAIT = 500;
    REPEAT_INTERVAL = 150;
    hInstance = 0;
    hWndHidServ = 0;
    cThreadRef = 0;
    hMutexOOC = 0;
    hService = 0;
}


void
StartHidserv(
            void
            )
/*++
Routine Description:
    Cal the SCM to start the NT service.
--*/
{
    SC_HANDLE hSCM;
    SC_HANDLE hService;
    BOOL Ret;

    INFO(("Start HidServ Service."));

    // Open the SCM on this machine.
    hSCM = OpenSCManager(   NULL,
                            NULL,
                            SC_MANAGER_CONNECT);

    if (hSCM) {
        // Open this service for DELETE access
        hService = OpenService( hSCM,
                                HidservServiceName,
                                SERVICE_START);

        if (hService) {
            // Start this service.
            Ret = StartService( hService,
                                0,
                                NULL);

            // Close the service and the SCM
            CloseServiceHandle(hService);
        }

        CloseServiceHandle(hSCM);
    }
}

void 
InstallHidserv(
    HWND        hwnd,
    HINSTANCE   hInstance,
    LPSTR       szCmdLine,
    int         iCmdShow
    ) 
/*++
Routine Description:
    Install the NT service to Auto-start with no dependencies.
--*/
{
    SC_HANDLE hService;
    SC_HANDLE hSCM;

    // Open the SCM on this machine.
    hSCM = OpenSCManager(   NULL, 
                            NULL, 
                            SC_MANAGER_CREATE_SERVICE);

    if (hSCM) {

            // Service exists, set to autostart

        hService = OpenService(hSCM,
                               HidservServiceName,
                               SERVICE_ALL_ACCESS);
        if (hService) {
            QUERY_SERVICE_CONFIG config;
            DWORD junk;
            HKEY hKey;
            LONG status;

            if (ChangeServiceConfig(hService,
                                    SERVICE_NO_CHANGE,
                                    SERVICE_AUTO_START,
                                    SERVICE_NO_CHANGE,
                                    NULL, NULL, NULL,
                                    NULL, NULL, NULL,
                                    HidservDisplayName)) {
                    // Wait until we're configured correctly.
                while (QueryServiceConfig(hService, 
                                          &config,
                                          sizeof(config),
                                          &junk)) {
                    if (config.dwStartType == SERVICE_AUTO_START) {
                        break;
                    }
                }
            }

            CloseServiceHandle(hService);
        }


    }

    // Go ahead and start the service for no-reboot install.
    StartHidserv();
}


DWORD
WINAPI
ServiceHandlerEx(
                DWORD fdwControl,     // requested control code
                DWORD dwEventType,   // event type
                LPVOID lpEventData,  // event data
                LPVOID lpContext     // user-defined context data
                )
/*++
Routine Description:
    Handle the service handler requests as required by the app.
    This should virtually always be an async PostMessage. Do not
    block this thread.
--*/
{
    PWTSSESSION_NOTIFICATION sessionNotification;

    switch (fdwControl) {
    case SERVICE_CONTROL_INTERROGATE:
        INFO(("ServiceHandler Request SERVICE_CONTROL_INTERROGATE (%x)", fdwControl));
        SetServiceStatus(hService, &ServiceStatus);
        return NO_ERROR;
    case SERVICE_CONTROL_CONTINUE:
        INFO(("ServiceHandler Request SERVICE_CONTROL_CONTINUE (%x)", fdwControl));
        //SET_SERVICE_STATE(SERVICE_START_PENDING);
        //PostMessage(hWndMmHid, WM_MMHID_START, 0, 0);
        return NO_ERROR;
    case SERVICE_CONTROL_PAUSE:
        INFO(("ServiceHandler Request SERVICE_CONTROL_PAUSE (%x)", fdwControl));
        //SET_SERVICE_STATE(SERVICE_PAUSE_PENDING);
        //PostMessage(hWndMmHid, WM_MMHID_STOP, 0, 0);
        return NO_ERROR;
    case SERVICE_CONTROL_STOP:
        INFO(("ServiceHandler Request SERVICE_CONTROL_STOP (%x)", fdwControl));
        SET_SERVICE_STATE(SERVICE_STOP_PENDING);
        PostMessage(hWndHidServ, WM_CLOSE, 0, 0);
        return NO_ERROR;
    case SERVICE_CONTROL_SHUTDOWN:
        INFO(("ServiceHandler Request SERVICE_CONTROL_SHUTDOWN (%x)", fdwControl));
        SET_SERVICE_STATE(SERVICE_STOP_PENDING);
        PostMessage(hWndHidServ, WM_CLOSE, 0, 0);
        return NO_ERROR;
    case SERVICE_CONTROL_SESSIONCHANGE:
        INFO(("ServiceHandler Request SERVICE_CONTROL_SESSIONCHANGE (%x)", fdwControl));
        sessionNotification = (PWTSSESSION_NOTIFICATION)lpEventData;
        PostMessage(hWndHidServ, WM_WTSSESSION_CHANGE, dwEventType, (LPARAM)sessionNotification->dwSessionId);
        return NO_ERROR;
    default:
        WARN(("Unhandled ServiceHandler code, (%x)", fdwControl));
    }
    return ERROR_CALL_NOT_IMPLEMENTED;
}

VOID
WINAPI
ServiceMain(
           DWORD dwArgc,
           LPWSTR * lpszArgv
           )
/*++
Routine Description:
    The main thread for the Hid service.
--*/
{
    HANDLE initDoneEvent;
    HANDLE threadHandle;

    InitializeGlobals();

    initDoneEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (!initDoneEvent) {
        goto ServiceMainError;
    }

    ServiceStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
    ServiceStatus.dwCurrentState = SERVICE_START_PENDING;
    ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN | SERVICE_ACCEPT_SESSIONCHANGE;
    ServiceStatus.dwWin32ExitCode = NO_ERROR;
    ServiceStatus.dwServiceSpecificExitCode = NO_ERROR;
    ServiceStatus.dwCheckPoint = 0;
    ServiceStatus.dwWaitHint = 0;

    hService =
    RegisterServiceCtrlHandlerEx(HidservServiceName,
                                 ServiceHandlerEx,
                                 NULL);

    if (!hService) {
        goto ServiceMainError;
    }

    SET_SERVICE_STATE(SERVICE_START_PENDING);

    threadHandle = CreateThread(NULL, // pointer to thread security attributes
                                0, // initial thread stack size, in bytes (0 = default)
                                HidServMain, // pointer to thread function
                                initDoneEvent, // argument for new thread
                                0, // creation flags
                                &MessagePumpThreadId); // pointer to returned thread identifier

    if (!threadHandle) {
        goto ServiceMainError;
    }

    WaitForSingleObject(initDoneEvent, INFINITE);

    CloseHandle(threadHandle);
    
ServiceMainError:

    if (initDoneEvent) {
        CloseHandle(initDoneEvent);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\client\hidserv\list.h ===
/*++
 *
 *  Component:  hidserv.dll
 *  File:       list.h
 *  Purpose:    Generic singly linked list.
 * 
 *  Copyright (C) Microsoft Corporation 1997,1998. All rights reserved.
 *
 *  WGJ
--*/

#ifndef _LIST_H_
#define _LIST_H_


typedef struct _ListEntry{
    struct _ListEntry * pNext;
} LIST_NODE, *PLIST_NODE;

void 
InsertTailList(
    PLIST_NODE head, 
    PLIST_NODE entry);

BOOL 
RemoveEntryList(
    PLIST_NODE head, 
    PLIST_NODE entry);

void 
InsertHeadList(
    PLIST_NODE head, 
    PLIST_NODE entry);

BOOL
IsNodeOnList(
    PLIST_NODE head, 
    PLIST_NODE entry);


#endif // _LIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\filter\hidvalid\write.c ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\client\hidserv\list.c ===
/*++
 *
 *  Component:  hidserv.dll
 *  File:       list.c
 *  Purpose:    Generic singly linked list.
 *  
 *  Copyright (C) Microsoft Corporation 1997,1998. All rights reserved.
 *
 *  WGJ
--*/

#include "hidserv.h"


void 
InsertTailList(
    PLIST_NODE head, 
    PLIST_NODE entry
    )
/*++
Routine Description:

--*/
{
    PLIST_NODE pCurrent = head;

    entry->pNext = 0;
    while(pCurrent->pNext)
        pCurrent = pCurrent->pNext;
    pCurrent->pNext = entry;

}

BOOL 
RemoveEntryList(
    PLIST_NODE head, 
    PLIST_NODE entry
    )
/*++
Routine Description:

--*/
{
    PLIST_NODE pCurrent = head;

    while(pCurrent->pNext != entry){
        pCurrent = pCurrent->pNext;
        if(pCurrent == 0) return FALSE;
    }
    pCurrent->pNext = entry->pNext;
    return TRUE;
}
    
void 
InsertHeadList(
    PLIST_NODE head, 
    PLIST_NODE entry
    )
/*++
Routine Description:

--*/
{
    entry->pNext = head->pNext;
    head->pNext = entry;
}

BOOL 
IsNodeOnList(
    PLIST_NODE head, 
    PLIST_NODE entry
    )
/*++
Routine Description:

--*/
{
    PLIST_NODE pCurrent = head;

    while(pCurrent->pNext != entry){
        pCurrent = pCurrent->pNext;
        if(pCurrent == 0) return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\client\hidserv\pnp.c ===
/*++
 *
 *  Component:  hidserv.exe
 *  File:       pnp.c
 *  Purpose:    routines to support pnp hid devices.
 * 
 *  Copyright (C) Microsoft Corporation 1997,1998. All rights reserved.
 *
 *  WGJ
--*/

#include "hidserv.h"
#include <cfgmgr32.h>
#include <tchar.h>

BOOL
OpenHidDevice (
              IN       HDEVINFO                    HardwareDeviceInfo,
              IN       PSP_DEVICE_INTERFACE_DATA   DeviceInfoData,
              IN OUT   PHID_DEVICE                 *HidDevice
              );

BOOL
RebuildHidDeviceList (
                     void
                     )
/*++
Routine Description:
   Do the required PnP things in order to find, the all the HID devices in
   the system at this time.
--*/
{
    HDEVINFO                 hardwareDeviceInfo;
    SP_DEVICE_INTERFACE_DATA deviceInfoData;
    PHID_DEVICE              hidDeviceInst;
    GUID                     hidGuid;
    DWORD                    i=0;
    PHID_DEVICE              pCurrent, pTemp;

    HidD_GetHidGuid (&hidGuid);

    TRACE(("Getting class devices"));

    //
    // Open a handle to the plug and play dev node.
    //
    hardwareDeviceInfo = SetupDiGetClassDevs (
                                             &hidGuid,
                                             NULL,    // Define no enumerator (global)
                                             NULL,    // Define no
                                             (DIGCF_PRESENT |    // Only Devices present
                                              DIGCF_DEVICEINTERFACE));    // Function class devices.

    if (!hardwareDeviceInfo) {
        TRACE(("Get class devices failed"));
        return FALSE;
    }

    //
    // Take a wild guess to start
    //
    deviceInfoData.cbSize = sizeof (SP_DEVICE_INTERFACE_DATA);

    TRACE(("Marking existing devnodes"));
    // Unmark all existing nodes. They will be remarked if the device still exists.
    pCurrent = (PHID_DEVICE)HidDeviceList.pNext;
    while (pCurrent) {
        pCurrent->Active = FALSE;
        pCurrent = pCurrent->pNext;
    }

    TRACE(("Entering loop"));
    while (TRUE) {

        TRACE(("Enumerating device interfaces"));
        if (SetupDiEnumDeviceInterfaces (hardwareDeviceInfo,    //HDEVINFO
                                         0,    // No care about specific PDOs //PSP_DEVINFO_DATA
                                         &hidGuid,    // LPGUID
                                         i,    //DWORD MemberIndex
                                         &deviceInfoData)) {    //PSP_DEVICE_INTERFACE_DATA

            TRACE(("Got an item"));
            if (!OpenHidDevice (hardwareDeviceInfo, &deviceInfoData, &hidDeviceInst)) {
                TRACE(("Open hid device failed"));
            } else {
                if (StartHidDevice(hidDeviceInst)) {
                    TRACE(("Start hid device succeeded."));
                    InsertTailList((PLIST_NODE)&HidDeviceList, (PLIST_NODE)hidDeviceInst);
                } else {
                    WARN(("Failed to start hid device. (%x)", hidDeviceInst));
                    HidFreeDevice(hidDeviceInst);
                }
            }
        } else {
            DWORD error = GetLastError();
            if (ERROR_NO_MORE_ITEMS == error) {
                TRACE(("No more items. Exitting"));
                break;
            } else {
                WARN(("Unexpected error getting device interface: 0x%xh", error));
            }
            break;
        }
        i++;
    }

    TRACE(("Removing unmarked device nodes"));
    // RemoveUnmarkedNodes();
    pCurrent = (PHID_DEVICE)HidDeviceList.pNext;
    while (pCurrent) {
        pTemp = pCurrent->pNext;
        if (!pCurrent->Active) {
            INFO(("Device (DevInst = %x) is gone.", pCurrent->DevInst));
            RemoveEntryList((PLIST_NODE)&HidDeviceList, (PLIST_NODE)pCurrent);
            StopHidDevice(pCurrent);    // this frees pCurrent
        }
        pCurrent = pTemp;
    }

    TRACE(("Destroying device info list"));
    SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
    return TRUE;
}

VOID
HidFreeDevice(PHID_DEVICE HidDevice)
{
    PHID_DATA data;
    UCHAR j;

    HidD_FreePreparsedData (HidDevice->Ppd);

    data = HidDevice->InputData;

    //
    // Release the button data
    //
    for (j = 0; j < HidDevice->Caps.NumberLinkCollectionNodes; j++, data++) {
        LocalFree(data->ButtonData.PrevUsages);
        LocalFree(data->ButtonData.Usages);
    }

    LocalFree(HidDevice->InputData);
    LocalFree(HidDevice->InputReportBuffer);
    LocalFree(HidDevice);
}

BOOL
OpenHidDevice (
              IN       HDEVINFO                    HardwareDeviceInfo,
              IN       PSP_DEVICE_INTERFACE_DATA   DeviceInfoData,
              IN OUT   PHID_DEVICE                 *HidDevice
              )
/*++
RoutineDescription:
    Given the HardwareDeviceInfo, representing a handle to the plug and
    play information, and deviceInfoData, representing a specific hid device,
    open that device and fill in all the relivant information in the given
    HID_DEVICE structure.

    return if the open and initialization was successfull or not.

--*/
{
    PSP_DEVICE_INTERFACE_DETAIL_DATA    functionClassDeviceData = NULL;
    SP_DEVINFO_DATA                     DevInfoData;
    ULONG                               predictedLength = 0;
    ULONG                               requiredLength = 0;
    UCHAR                               i = 0;
    PHID_DATA                           data = NULL;
    PHIDP_BUTTON_CAPS                   pButtonCaps = NULL;
    PHIDP_VALUE_CAPS                    pValueCaps = NULL;
    USHORT                              numCaps;
    PHIDP_LINK_COLLECTION_NODE          LinkCollectionNodes = NULL;
    PHID_DEVICE                         hidDevice = NULL;

    WCHAR buf[512];
    CONFIGRET cr = CR_SUCCESS;
    DEVINST devInst, parentDevInst;
    DWORD len = 0;

    if (!(hidDevice = LocalAlloc (LPTR, sizeof (HID_DEVICE)))) {
        //
        // Alloc failed. Drop out of the loop and let the device list
        // get deleted.
        //
        WARN(("Alloc HID_DEVICE struct failed."));
        return FALSE;
    }

    TRACE(("Creating Device Node (%x)", hidDevice));
    //
    // allocate a function class device data structure to receive the
    // goods about this particular device.
    //
    SetupDiGetDeviceInterfaceDetail (
                                    HardwareDeviceInfo,
                                    DeviceInfoData,
                                    NULL,    // probing so no output buffer yet
                                    0,    // probing so output buffer length of zero
                                    &requiredLength,
                                    NULL);    // get the specific dev-node


    predictedLength = requiredLength;
    // sizeof (SP_FNCLASS_DEVICE_DATA) + 512;

    if (!(functionClassDeviceData = LocalAlloc (LPTR, predictedLength))) {
        WARN(("Allocation failed, our of resources!"));
        goto OpenHidDeviceError;
    }
    functionClassDeviceData->cbSize = sizeof (SP_DEVICE_INTERFACE_DETAIL_DATA);
    DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    DevInfoData.DevInst = 0;

    //
    // Retrieve the information from Plug and Play.
    //
    if (! SetupDiGetDeviceInterfaceDetail (
                                          HardwareDeviceInfo,
                                          DeviceInfoData,    // PSP_DEVICE_INTERFACE_DATA
                                          functionClassDeviceData,    // PSP_DEVICE_INTERFACE_DETAIL_DATA
                                          predictedLength,
                                          &requiredLength,
                                          &DevInfoData)) {    //PSP_DEVINFO_DATA
        WARN(("SetupDiGetDeviceInterfaceDetail failed"));
        goto OpenHidDeviceError;
    }
    INFO(("Just got interface detail for %S", functionClassDeviceData->DevicePath));
    hidDevice->DevInst = DevInfoData.DevInst;

    //
    // <HACK>
    //
    // Find out it this is a set of speakers with buttons on it. This is for 
    // but 136800. We want to only emit WM_APPCOMMANDs for speakers, not the
    // VK. This is because certain games leave the opening movie scene when
    // you press any key, so if someone presses volume down on their speakers
    // it will leave the scene. They just want that to affect volume.
    // 
    cr = CM_Get_Parent(&parentDevInst,
                       DevInfoData.DevInst,
                       0);
    //
    // We need to get the grandparent, then get the child, to make sure that
    // we get the first child in the set. From there, if the child we've got
    // is the same parent of the devnode that we started with, we want to
    // look at its sibling. But if the devnode we've got is different from 
    // the parent, then we've got the right one to look at!
    //
    if (cr == CR_SUCCESS) {
        cr = CM_Get_Parent(&devInst,
                           parentDevInst,
                           0);
    }
    if (cr == CR_SUCCESS) {
        cr = CM_Get_Child(&devInst,
                          devInst,
                          0);
    }

    if (cr == CR_SUCCESS) {
        if (devInst == parentDevInst) {
            //
            // Only look at the first sibling, because this covers all sets
            // of speakers currently on the market.
            //
            cr = CM_Get_Sibling(&devInst,
                                devInst,
                                0);
        }

        if (cr == CR_SUCCESS) {
            len = sizeof(buf);
            cr = CM_Get_DevNode_Registry_Property(devInst,
                                                  CM_DRP_CLASS,
                                                  NULL,
                                                  buf,
                                                  &len,
                                                  0);
            if ((cr == CR_SUCCESS) && 
                (len == (sizeof(TEXT("MEDIA"))))) {
                if (lstrcmpi(TEXT("MEDIA"), buf) == 0) {
                    hidDevice->Speakers = TRUE;
                }
            }
        }    // else - definitely not speakers
    }
    //
    // </HACK>
    //

    // Do we already have this device open?
    {
        PHID_DEVICE pCurrent = (PHID_DEVICE)HidDeviceList.pNext;

        while (pCurrent) {
            if (pCurrent->DevInst == hidDevice->DevInst) break;
            pCurrent = pCurrent->pNext;
        }
        if (pCurrent) {
            // Yes. Mark it and bail on the new node.
            pCurrent->Active = TRUE;
            INFO(("Device (DevInst = %x) already open.", DevInfoData.DevInst));
            goto OpenHidDeviceError;
        } else {
            // No. Mark the new node and continue.
            INFO(("Device (DevInst = %x) is new.", DevInfoData.DevInst));
            hidDevice->Active = TRUE;
        }
    }

    hidDevice->HidDevice = CreateFile (
                                      functionClassDeviceData->DevicePath,
                                      GENERIC_READ,
                                      FILE_SHARE_READ | FILE_SHARE_WRITE,
                                      NULL,    // no SECURITY_ATTRIBUTES structure
                                      OPEN_EXISTING,    // No special create flags
                                      FILE_FLAG_OVERLAPPED,    // Do overlapped read/write
                                      NULL);    // No template file

    if (INVALID_HANDLE_VALUE == hidDevice->HidDevice) {
        INFO(("CreateFile failed - %x (%S)", GetLastError(), functionClassDeviceData->DevicePath));
        goto OpenHidDeviceError;
    } else {
       INFO(("CreateFile succeeded Handle(%x) - %S", hidDevice->HidDevice, functionClassDeviceData->DevicePath));
    }

    if (!HidD_GetPreparsedData (hidDevice->HidDevice, &hidDevice->Ppd)) {
        WARN(("HidD_GetPreparsedData failed"));
        goto OpenHidDeviceError;
    }

    if (!HidD_GetAttributes (hidDevice->HidDevice, &hidDevice->Attributes)) {
        WARN(("HidD_GetAttributes failed"));
        goto OpenHidDeviceError;
    }

    if (!HidP_GetCaps (hidDevice->Ppd, &hidDevice->Caps)) {
        WARN(("HidP_GetCaps failed"));
        goto OpenHidDeviceError;
    }

    // ***Instructive comment from KenRay:
    // At this point the client has a choice.  It may chose to look at the
    // Usage and Page of the top level collection found in the HIDP_CAPS
    // structure.  In this way it could just use the usages it knows about.
    // If either HidP_GetUsages or HidP_GetUsageValue return an error then
    // that particular usage does not exist in the report.
    // This is most likely the preferred method as the application can only
    // use usages of which it already knows.
    // In this case the app need not even call GetButtonCaps or GetValueCaps.


    // If this is a collection we care about, continue. Else, we get out now.
    if (hidDevice->Caps.UsagePage != HIDSERV_USAGE_PAGE) {
        TRACE(("This device is not for us (%x)", hidDevice));
        goto OpenHidDeviceError;
    }

    //
    // setup Input Data buffers.
    //
    TRACE(("NumberLinkCollectionNodes = %d", hidDevice->Caps.NumberLinkCollectionNodes));
    {
        ULONG   numNodes = hidDevice->Caps.NumberLinkCollectionNodes;

        if (!(LinkCollectionNodes = LocalAlloc(LPTR, hidDevice->Caps.NumberLinkCollectionNodes*sizeof(HIDP_LINK_COLLECTION_NODE)))) {
            WARN(("LinkCollectionNodes alloc failed."));
            goto OpenHidDeviceError;
        }
        HidP_GetLinkCollectionNodes(LinkCollectionNodes,
                                    &numNodes,
                                    hidDevice->Ppd);
        for (i=0; i<hidDevice->Caps.NumberLinkCollectionNodes; i++) {
            INFO(("Link Collection [%d] Type = %x, Alias = %x", i, LinkCollectionNodes[i].CollectionType, LinkCollectionNodes[i].IsAlias));
            INFO(("Link Collection [%d] Page = %x, Usage = %x", i, LinkCollectionNodes[i].LinkUsagePage, LinkCollectionNodes[i].LinkUsage));
        }
    }

    //
    // Allocate memory to hold on input report
    //

    if (!(hidDevice->InputReportBuffer = (PCHAR)
          LocalAlloc (LPTR, hidDevice->Caps.InputReportByteLength * sizeof (CHAR)))) {
        WARN(("InputReportBuffer alloc failed."));
        goto OpenHidDeviceError;
    }

    //
    // Allocate memory to hold the button and value capabilities.
    // NumberXXCaps is in terms of array elements.
    //
    if (!(pButtonCaps = (PHIDP_BUTTON_CAPS)
          LocalAlloc (LPTR, hidDevice->Caps.NumberInputButtonCaps*sizeof (HIDP_BUTTON_CAPS)))) {
        WARN(("buttoncaps alloc failed."));
        goto OpenHidDeviceError;
    }
    if (!(pValueCaps = (PHIDP_VALUE_CAPS)
          LocalAlloc (LPTR, hidDevice->Caps.NumberInputValueCaps*sizeof (HIDP_VALUE_CAPS)))) {
        WARN(("valuecaps alloc failed."));
        goto OpenHidDeviceError;
    }

    //
    // Have the HidP_X functions fill in the capability structure arrays.
    //
    numCaps = hidDevice->Caps.NumberInputButtonCaps;
    TRACE(("NumberInputButtonCaps = %d", numCaps));
    HidP_GetButtonCaps (HidP_Input,
                        pButtonCaps,
                        &numCaps,
                        hidDevice->Ppd);

    numCaps = hidDevice->Caps.NumberInputValueCaps;
    TRACE(("NumberInputValueCaps = %d", numCaps));
    HidP_GetValueCaps (HidP_Input,
                       pValueCaps,
                       &numCaps,
                       hidDevice->Ppd);

    TRACE(("Buttons:"));
    for (i=0; i<hidDevice->Caps.NumberInputButtonCaps; i++) {
        TRACE(("UsagePage = 0x%x", pButtonCaps[i].UsagePage));
        TRACE(("LinkUsage = 0x%x", pButtonCaps[i].LinkUsage));
        TRACE(("LinkUsagePage = 0x%x\n", pButtonCaps[i].LinkUsagePage));
    }

    //
    // Allocate a buffer to hold the struct _HID_DATA structures.
    //
    hidDevice->InputDataLength = hidDevice->Caps.NumberLinkCollectionNodes + 
    hidDevice->Caps.NumberInputValueCaps;
    if (!(hidDevice->InputData = data = (PHID_DATA)
          LocalAlloc (LPTR, hidDevice->InputDataLength * sizeof (HID_DATA)))) {
        WARN(("InputData alloc failed."));
        goto OpenHidDeviceError;
    }

    TRACE(("InputDataLength = %d", hidDevice->InputDataLength));

    //
    // Fill in the button data
    // Group button sets by link collection.
    //
    for (i = 0; i < hidDevice->Caps.NumberLinkCollectionNodes; i++, data++) {
        data->IsButtonData = TRUE;
        data->LinkUsage = LinkCollectionNodes[i].LinkUsage;
        data->UsagePage = LinkCollectionNodes[i].LinkUsagePage;
        if (i)
            data->LinkCollection = i;
        else
            data->LinkCollection = HIDP_LINK_COLLECTION_ROOT;
        INFO(("Button Link Usage = %x", data->LinkUsage));
        INFO(("Button Link Usage Page = %x", data->UsagePage));
        INFO(("Button Link Collection = %x", data->LinkCollection));
        data->Status = HIDP_STATUS_SUCCESS;
        data->ButtonData.MaxUsageLength = HidP_MaxUsageListLength (
                                                                  HidP_Input,
                                                                  hidDevice->Caps.UsagePage,
                                                                  hidDevice->Ppd);
        //make room for the terminator
        data->ButtonData.MaxUsageLength++;
        if (!(data->ButtonData.Usages = (PUSAGE_AND_PAGE)
              LocalAlloc (LPTR, data->ButtonData.MaxUsageLength * sizeof (USAGE_AND_PAGE)))) {
            WARN(("Usages alloc failed."));
            goto OpenHidDeviceError;
        }
        if (!(data->ButtonData.PrevUsages = (PUSAGE_AND_PAGE)
              LocalAlloc (LPTR, data->ButtonData.MaxUsageLength * sizeof (USAGE_AND_PAGE)))) {
            WARN(("PrevUsages alloc failed."));
            goto OpenHidDeviceError;
        }
    }

    //
    // Fill in the value data
    // 
    for (i = 0; i < hidDevice->Caps.NumberInputValueCaps; i++, data++) {
        if (pValueCaps[i].IsRange) {
            WARN(("Can't handle value ranges!!"));
        }
        data->IsButtonData = FALSE;
        data->LinkUsage = pValueCaps[i].LinkUsage;
        data->UsagePage = pValueCaps[i].LinkUsagePage;
        if (pValueCaps[i].LinkCollection)
            data->LinkCollection = pValueCaps[i].LinkCollection;
        else
            data->LinkCollection = HIDP_LINK_COLLECTION_ROOT;
        INFO(("Value Link Usage = %x", data->LinkUsage));
        INFO(("Value Link Usage Page = %x", data->UsagePage));
        INFO(("Value Link Collection = %x", data->LinkCollection));
        INFO(("Value LogicalMin = %x", pValueCaps[i].LogicalMin));
        INFO(("Value LogicalMax = %x", pValueCaps[i].LogicalMax));
        data->ValueData.LogicalRange = pValueCaps[i].LogicalMax - pValueCaps[i].LogicalMin;
        data->Status = HIDP_STATUS_SUCCESS;
        data->ValueData.Usage = pValueCaps[i].NotRange.Usage;
    }

    LocalFree(pButtonCaps);
    LocalFree(pValueCaps);
    LocalFree(LinkCollectionNodes);
    LocalFree(functionClassDeviceData);

    *HidDevice = hidDevice;
    return TRUE;
OpenHidDeviceError:
    if (data) {
        for (i = 0; i < hidDevice->Caps.NumberLinkCollectionNodes; i++, data++) {
            if (data->ButtonData.Usages) {
                LocalFree(data->ButtonData.Usages);
            }
            if (data->ButtonData.PrevUsages) {
                LocalFree(data->ButtonData.PrevUsages);
            }
        }
        LocalFree(data);
    }

    if (pValueCaps) {
        LocalFree(pValueCaps);
    }
    if (pButtonCaps) {
        LocalFree (pButtonCaps);
    }
    if (hidDevice->InputReportBuffer) {
        LocalFree (hidDevice->InputReportBuffer);
    }
    if (LinkCollectionNodes) {
        LocalFree (LinkCollectionNodes);
    }
    if (hidDevice->Ppd) {
        HidD_FreePreparsedData (hidDevice->Ppd);
    }
    if (hidDevice->HidDevice &&
        hidDevice->HidDevice != INVALID_HANDLE_VALUE) {
        CloseHandle (hidDevice->HidDevice);
    }
    if (functionClassDeviceData) {
        LocalFree (functionClassDeviceData);
    }
    LocalFree (hidDevice);
    return FALSE;
}


BOOL
StartHidDevice(
              PHID_DEVICE      pHidDevice
              )
/*++
RoutineDescription:
    Create a work thread to go with the new hid device. This thread lives
    as long as the associated hid device is open.
--*/
{
    //
    // Init read sync objects
    //
    pHidDevice->ReadEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (!pHidDevice->ReadEvent) {
        WARN(("Failed creating read event."));
        return FALSE;
    }

    pHidDevice->CompletionEvent = CreateEvent(NULL, TRUE, TRUE, NULL);
    if (!pHidDevice->CompletionEvent) {
        CloseHandle(pHidDevice->ReadEvent);

        WARN(("Failed creating read event."));
        return FALSE;
    }

    // event handle for overlap.
    pHidDevice->Overlap.hEvent = pHidDevice->CompletionEvent;

    //
    // Create hid work thread
    //
    pHidDevice->fThreadEnabled = TRUE;

    pHidDevice->ThreadHandle =
    CreateThread(
                NULL,    // pointer to thread security attributes 
                0,    // initial thread stack size, in bytes (0 = default)
                HidThreadProc,    // pointer to thread function 
                pHidDevice,    // argument for new thread 
                0,    // creation flags 
                &pHidDevice->ThreadId    // pointer to returned thread identifier 
                );  

    if (!pHidDevice->ThreadHandle) {
        CloseHandle(pHidDevice->ReadEvent);
        CloseHandle(pHidDevice->CompletionEvent);

        WARN(("Failed creating hid work thread."));
        return FALSE;
    }

    // Register device nofication for this file handle
    // This only required for NT5
    {
        DEV_BROADCAST_HANDLE  DevHdr;
        ZeroMemory(&DevHdr, sizeof(DevHdr));
        DevHdr.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
        DevHdr.dbch_devicetype = DBT_DEVTYP_HANDLE;
        DevHdr.dbch_handle = pHidDevice->HidDevice;

        pHidDevice->hNotify = 
        RegisterDeviceNotification( hWndHidServ,
                                    &DevHdr,
                                    DEVICE_NOTIFY_WINDOW_HANDLE);

        if (!pHidDevice->hNotify) {
            WARN(("RegisterDeviceNotification failure (%x).", GetLastError()));
        }
    }

    // 
    // Start the read
    //
    SetEvent(pHidDevice->ReadEvent);

    return TRUE;
}

BOOL
StopHidDevice(
             PHID_DEVICE     pHidDevice
             )
/*++
RoutineDescription:
    Eaxh device has a thread that needs to be cleaned up when the device
    is "stopped". Here we signal the thread to exit and clean up.
--*/
{
    HANDLE  hThreadHandle;
    DWORD   dwResult;
    
    TRACE(("StopHidDevice (%x)", pHidDevice));
    // without a device, nothing can be done.
    if (!pHidDevice) return FALSE;

    // Doing this here prevents us from seeing
    // DBT_DEVICEQUERYREMOVEFAILED since the notify handle
    // is gone. However, this is acceptable since there is
    // nothing useful we will do in response to that event
    // anyway.
    UnregisterDeviceNotification(pHidDevice->hNotify);
    hThreadHandle = pHidDevice->ThreadHandle;
    
    //
    // Allow the hid work thread to exit.
    //
    pHidDevice->fThreadEnabled = FALSE;

    // Signal the read event, in case thread is waiting there
    INFO(("Set Read Event."));
    SetEvent(pHidDevice->ReadEvent);
    INFO(("Waiting for work thread to exit..."));
    WaitForSingleObject(hThreadHandle, INFINITE);

    TRACE(("StopHidDevice (%x) done.", pHidDevice));

    return TRUE;
}


BOOL
DestroyHidDeviceList(
                    void
                    )
/*++
RoutineDescription:
    Unlike a rebuild, all devices here are closed so the process can
    exit.
--*/
{
    PHID_DEVICE pNext, pCurrent = (PHID_DEVICE)HidDeviceList.pNext;
    while (pCurrent) {

        RemoveEntryList((PLIST_NODE)&HidDeviceList, (PLIST_NODE)pCurrent);
        pNext = pCurrent->pNext;
        StopHidDevice(pCurrent);

        pCurrent = pNext;
    }

    return TRUE;
}

BOOL
DestroyDeviceByHandle(
                     HANDLE hDevice
                     )
/*++
RoutineDescription:
    Here we need to remove a specific device.
--*/
{
    PHID_DEVICE pCurrent = (PHID_DEVICE)HidDeviceList.pNext;

    while (pCurrent) {

        if (hDevice == pCurrent->HidDevice) {
            RemoveEntryList((PLIST_NODE)&HidDeviceList, (PLIST_NODE)pCurrent);
#if WIN95_BUILD
            //
            // Can't do the UnregisterDeviceNotification in the same context
            // as when we receive the WM_DEVICECHANGE DBT_REMOVEDEVICECOMPLETE 
            // for a DBT_DEVTYP_HANDLE
            //
            PostMessage(hWndHidServ, WM_HIDSERV_STOP_DEVICE, 0, (LPARAM)pCurrent);
#else
            StopHidDevice(pCurrent);
#endif // WIN95_BUILD
            break;
        }
        pCurrent = pCurrent->pNext;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\client\hidserv\hidserv.h ===
/*++
 *
 *  Component:  hidserv.dll
 *  File:       hidaudio.h
 *  Purpose:    main application header
 *
 *  Copyright (C) Microsoft Corporation 1997,1998. All rights reserved.
 *
 *  WGJ
--*/

#ifndef _HIDSERV_H_
#define _HIDSERV_H_

////
///  Defines
//

#define STRICT

#ifndef GLOBALS
#define GLOBALS extern
#define  EQU  ; / ## /
#else
#define  EQU  =
#endif //GLOBALS

#define HIDSERV_USAGE_PAGE   0x0c

// default step size is 4% of max volume.
#define DEFAULT_STEP        ((int)(65535/25))
#define MAX_BUTTON_LIST     10

// APP messages
#define WM_HIDSERV_START                         (WM_APP+301)
#define WM_HIDSERV_STOP                          (WM_APP+302)
#define WM_HIDSERV_REPORT_DISPATCH               (WM_APP+304)
#define WM_HIDSERV_SERVICE_REQUEST               (WM_APP+305)
#define WM_HIDSERV_INPUT_CLIENT                  (WM_APP+306)
#define WM_HIDSERV_MEDIAFOCUS_CLIENT             (WM_APP+307)
#define WM_HIDSERV_SETMEDIAFOCUS                 (WM_APP+308)
#define WM_HIDSERV_MEDIAFOCUS_NOTIFY             (WM_APP+309)
#define WM_HIDSERV_PNP_HID                       (WM_APP+310)
#if WIN95_BUILD
#define WM_HIDSERV_STOP_DEVICE                   (WM_APP+311)
#endif // WIN95_BUILD

#define WM_CUSTOM_USAGE                        (WM_APP+313)

// CInput Messages
//
#define WM_CI_USAGE                        (WM_APP+314)
#define WM_CI_MEDIA_FOCUS                  (WM_APP+315)
#define WM_CI_DEVICE_CHANGE                (WM_APP+316)


#define TIMERID_BASE            3
#define TIMERID_TOP             18

#define TIMERID_VOLUMEUP        3
#define TIMERID_VOLUMEDN        4
#define TIMERID_BASSUP          5
#define TIMERID_BASSDN          6
#define TIMERID_TREBLEUP        7
#define TIMERID_TREBLEDN        8
#define TIMERID_APPBACK         9
#define TIMERID_APPFORWARD      10
#define TIMERID_PREVTRACK       11
#define TIMERID_NEXTTRACK       12
#define TIMERID_VOLUMEUP_VK     13
#define TIMERID_VOLUMEDN_VK     14
#define TIMERID_KEYPAD_LPAREN   15
#define TIMERID_KEYPAD_RPAREN   16
#define TIMERID_KEYPAD_AT       17
#define TIMERID_KEYPAD_EQUAL    18


#define MAX_MEDIA_TYPES         33
#define MAX_CLIENTS             16
#define MAX_USAGE_LIST          32
#define MAX_PENDING_BUTTONS     16

#define MakeLongUsage(c,u)  ((ULONG)(c<<16) | (u))

#define SET_SERVICE_STATE(Status) if(hService){ ServiceStatus.dwCurrentState = Status; \
                                    SetServiceStatus(hService, &ServiceStatus);}

////
///  Includes
//
#include <windows.h>
#include <windowsx.h>
#include <winuser.h>
#include <shellapi.h>
#include <mmsystem.h>
#include <math.h>

#include <basetyps.h>
#include <wtypes.h>
#include <setupapi.h>
#include <hidsdi.h>
#include <dbt.h>
#include <regstr.h>
#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

// Local includes
#include "hid.h"
#include "list.h"
#include "dbg.h"

//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//

#define ContainingRecord(address, type, field) ((type *)( \
                          (PCHAR)(address) - \
                          (PCHAR)(&((type *)0)->field)))


// Data Types
//
typedef unsigned long CI_CLIENT_ID;

typedef UINT_PTR OOC_STATE;

typedef struct _Pending_Button{
    USAGE    Collection;
    USAGE    Page;
    USAGE    Usage;
} PENDING_BUTTON, *PPENDING_BUTTON;

typedef LONG (WINAPI *WINSTATIONSENDWINDOWMESSAGE)
       (HANDLE  hServer,
        ULONG   sessionID,
        ULONG   timeOut,
        ULONG   hWnd,
        ULONG   Msg,
        WPARAM  wParam,
        LPARAM  lParam,
        LONG    *pResponse);

////
///  Globals
//

// Linked list of current hid devices
GLOBALS LIST_NODE       HidDeviceList;

GLOBALS BOOL            PnpEnabled      EQU FALSE;
GLOBALS HDEVNOTIFY      hNotifyArrival  EQU 0;

// This timeout (150ms) is selected to allow the control to cover the range
// (25 steps) in about 5 sec..
GLOBALS UINT            INITIAL_WAIT    EQU 500;
GLOBALS UINT            REPEAT_INTERVAL EQU 150;

// The instance and hwnd for the main thread.
GLOBALS HANDLE          hInstance       EQU 0;
GLOBALS HWND            hWndHidServ     EQU 0;

// how many threads are active?
GLOBALS ULONG           cThreadRef      EQU 0;

// Access to OOC state data is mutex protected.
GLOBALS OOC_STATE       OOC_State[TIMERID_TOP-TIMERID_BASE+1];
GLOBALS HANDLE          hMutexOOC       EQU 0;

GLOBALS PENDING_BUTTON          PendingButtonList[MAX_PENDING_BUTTONS];

// NT Service data
GLOBALS SERVICE_STATUS_HANDLE  hService EQU 0;
GLOBALS TCHAR HidservServiceName[]      EQU TEXT("HidServ");
GLOBALS SERVICE_STATUS ServiceStatus;

// The event signalling that there is input to send.
GLOBALS HANDLE hInputEvent;
GLOBALS HANDLE hDesktopSwitch;
GLOBALS HANDLE hInputDoneEvent;
GLOBALS BOOLEAN InputIsAppCommand;
GLOBALS BOOLEAN InputIsChar;
GLOBALS UCHAR InputVKey;
GLOBALS SHORT InputDown;
GLOBALS USHORT InputAppCommand;
GLOBALS BOOL InputThreadEnabled;
GLOBALS DWORD InputThreadId;
GLOBALS DWORD MessagePumpThreadId;
GLOBALS ULONG InputSessionId;
GLOBALS BOOLEAN InputSessionLocked;
GLOBALS HINSTANCE WinStaDll;
GLOBALS WINSTATIONSENDWINDOWMESSAGE WinStaProc;

/*
            WinStationSendWindowMessage(
                SERVERNAME_CURRENT,        // global server handle
                InputSessionId,            // session id
                5,                         // wait in seconds
                NULL,                      // handle of destination window
                Down ? WM_KEYDOWN : WM_KEYUP,
                Vkey,                      // wParam
                1,                         // lParam - input is char
                NULL);                     // No response
*/
#define CrossSessionWindowMessage(m, w, l) \
    if (WinStaProc) { LONG response; \
    WinStaProc (NULL, InputSessionId, 5, HandleToUlong(hWndHidServ), (m), (w), (l), &response); }

#define OOC(_x_) OOC_State[_x_ - TIMERID_BASE]

////
/// Prototypes
//

//hidaudio.c

DWORD
WINAPI
HidServMain(
    HANDLE InitDoneEvent
    );

DWORD
WINAPI
ThreadMain(
    HWND hwnd,
    HINSTANCE hInst,
    LPSTR szCmd,
    int nShow
    );

BOOL
HidServInit(
    void
    );

void
HidServExit(
    void
    );

DWORD
WINAPI
HidThreadProc(
   PHID_DEVICE    HidDevice
   );

DWORD
WINAPI
HidThreadInputProc(
    PVOID Ignore
    );

DWORD
WINAPI
HidMessagePump(
    PVOID Ignore
    );

VOID
HidFreeDevice(PHID_DEVICE HidDevice);

BOOL
UsageInList(
    PUSAGE_AND_PAGE   pUsage,
    PUSAGE_AND_PAGE   pUsageList
    );

void
CustomUsageDispatch(
    USAGE   Collection,
    USAGE   Usage,
    LONG    Data
    );

void
HidServReportDispatch(
    PHID_DEVICE     HidDevice
    );

VOID
VolumeTimerHandler(
    WPARAM  TimerID
    );

void
HidServUpdate(
    DWORD   LongUsage,
    DWORD   Value
    );

BOOL
DeviceChangeHandler(
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT CALLBACK HidServProc(
    HWND            hwnd,
    UINT            msg,
    WPARAM          wparam,
    LPARAM          lparam
    );


//
// Media Types
#define CInput_MediaType_None           (0x00000000)      // actually ALL media types, but with low priority
#define CInput_MediaType_Software       (0x00000001)      // Virtual, or software devices (player does not use a hrdware medium)
#define CInput_MediaType_System         (0x00000002)      // The "system" device, Windows itself is a media type
#define CInput_MediaType_CD             (0x00000004)
#define CInput_MediaType_DVD            (0x00000008)
#define CInput_MediaType_TV             (0x00000010)
#define CInput_MediaType_WWW            (0x00000020)
#define CInput_MediaType_Telephone      (0x00000040)
#define CInput_MediaType_ProgramGuide   (0x00000080)
#define CInput_MediaType_VideoPhone     (0x00000100)
#define CInput_MediaType_Games          (0x00000200)
#define CInput_MediaType_Messages       (0x00000400)
#define CInput_MediaType_VCR            (0x00000800)
#define CInput_MediaType_Tuner          (0x00001000)
#define CInput_MediaType_Tape           (0x00002000)
#define CInput_MediaType_Cable          (0x00004000)
#define CInput_MediaType_Satellite      (0x00008000)
#define CInput_MediaType_Security       (0x00010000)
#define CInput_MediaType_Home           (0x00020000)
#define CInput_MediaType_Call           (0x00040000)
#define CInput_MediaType_Speakers       (0x00080000)
#define CInput_MediaType_All            (0xffffffff)

#define CInputUsage_NULL                ((USAGE) 0x0000)
#define CInputUsage_RANGE               ((USAGE) 0xFFFF)

//
// Collections
#define CInputCollection_Consumer_Control       ((USAGE) 0x0001)
#define CInputCollection_Numeric_Key_Pad        ((USAGE) 0x0002)
#define CInputCollection_Function_Buttons       ((USAGE) 0x0036)
#define CInputCollection_Selection              ((USAGE) 0x0080)
#define CInputCollection_Media_Selection        ((USAGE) 0x0087)
#define CInputCollection_Select_Disc            ((USAGE) 0x00BA)
#define CInputCollection_Playback_Speed         ((USAGE) 0x00F1)

//
// Media Selection
#define CInput_Media_Select_Computer       ((USAGE) 0x0088)
#define CInput_Media_Select_TV             ((USAGE) 0x0089)
#define CInput_Media_Select_WWW            ((USAGE) 0x008A)
#define CInput_Media_Select_DVD            ((USAGE) 0x008B)
#define CInput_Media_Select_Telephone      ((USAGE) 0x008C)
#define CInput_Media_Select_Program_Guide  ((USAGE) 0x008D)
#define CInput_Media_Select_Video_Phone    ((USAGE) 0x008E)
#define CInput_Media_Select_Games          ((USAGE) 0x008F)
#define CInput_Media_Select_Messages       ((USAGE) 0x0090)
#define CInput_Media_Select_CD             ((USAGE) 0x0091)
#define CInput_Media_Select_VCR            ((USAGE) 0x0092)
#define CInput_Media_Select_Tuner          ((USAGE) 0x0093)
#define CInput_Media_Select_Tape           ((USAGE) 0x0096)
#define CInput_Media_Select_Cable          ((USAGE) 0x0097)
#define CInput_Media_Select_Satellite      ((USAGE) 0x0098)
#define CInput_Media_Select_Security       ((USAGE) 0x0099)
#define CInput_Media_Select_Home           ((USAGE) 0x009A)
#define CInput_Media_Select_Call           ((USAGE) 0x009B)


////////////////////////////////////
// General Usages
//

#define CInputUsage_Plus_10                 ((USAGE) 0x0020)
#define CInputUsage_Plus_100                ((USAGE) 0x0021)
#define CInputUsage_AM_PM                   ((USAGE) 0x0022)

// device control
#define CInputUsage_Power                   ((USAGE) 0x0030)
#define CInputUsage_Reset                   ((USAGE) 0x0031)
#define CInputUsage_Sleep                   ((USAGE) 0x0032)
#define CInputUsage_Sleep_After             ((USAGE) 0x0033)
#define CInputUsage_Sleep_Mode              ((USAGE) 0x0034)
#define CInputUsage_Illumination            ((USAGE) 0x0035)

// menu
#define CInputUsage_Menu                    ((USAGE) 0x0040)
#define CInputUsage_Menu_Pick               ((USAGE) 0x0041)
#define CInputUsage_Menu_Up                 ((USAGE) 0x0042)
#define CInputUsage_Menu_Down               ((USAGE) 0x0043)
#define CInputUsage_Menu_Left               ((USAGE) 0x0044)
#define CInputUsage_Menu_Right              ((USAGE) 0x0045)
#define CInputUsage_Menu_Escape             ((USAGE) 0x0046)
#define CInputUsage_Menu_Value_Increase     ((USAGE) 0x0047)
#define CInputUsage_Menu_Value_Decrease     ((USAGE) 0x0048)

// video display
#define CInputUsage_Data_On_Screen          ((USAGE) 0x0060)
#define CInputUsage_Closed_Caption          ((USAGE) 0x0061)
#define CInputUsage_Closed_Caption_Select   ((USAGE) 0x0062)
#define CInputUsage_VCR_TV                  ((USAGE) 0x0063)
#define CInputUsage_Broadcast_Mode          ((USAGE) 0x0064)
#define CInputUsage_Snapshot                ((USAGE) 0x0065)
#define CInputUsage_Still                   ((USAGE) 0x0066)

// broadcast/cable
#define CInputUsage_Assign_Selection        ((USAGE) 0x0081)
#define CInputUsage_Mode_Step               ((USAGE) 0x0082)
#define CInputUsage_Recall_Last             ((USAGE) 0x0083)
#define CInputUsage_Enter_Channel           ((USAGE) 0x0084)
#define CInputUsage_Order_Movie             ((USAGE) 0x0085)
#define CInputUsage_Channel                 ((USAGE) 0x0086)

// app control
#define CInputUsage_Quit                    ((USAGE) 0x0094)
#define CInputUsage_Help                    ((USAGE) 0x0095)

// channel
#define CInputUsage_Channel_Increment       ((USAGE) 0x009C)
#define CInputUsage_Channel_Decrement       ((USAGE) 0x009D)

// vcr control
#define CInputUsage_VCR_Plus                ((USAGE) 0x00A0)
#define CInputUsage_Once                    ((USAGE) 0x00A1)
#define CInputUsage_Daily                   ((USAGE) 0x00A2)
#define CInputUsage_Weekly                  ((USAGE) 0x00A3)
#define CInputUsage_Monthly                 ((USAGE) 0x00A4)

// transport control
#define CInputUsage_Play                    ((USAGE) 0x00B0)
#define CInputUsage_Pause                   ((USAGE) 0x00B1)
#define CInputUsage_Record                  ((USAGE) 0x00B2)
#define CInputUsage_Fast_Forward            ((USAGE) 0x00B3)
#define CInputUsage_Rewind                  ((USAGE) 0x00B4)
#define CInputUsage_Scan_Next_Track         ((USAGE) 0x00B5)
#define CInputUsage_Scan_Previous_Track     ((USAGE) 0x00B6)
#define CInputUsage_Stop                    ((USAGE) 0x00B7)
#define CInputUsage_Eject                   ((USAGE) 0x00B8)
#define CInputUsage_Random_Play             ((USAGE) 0x00B9)

// advanced transport control
#define CInputUsage_Enter_Disc              ((USAGE) 0x00BB)
#define CInputUsage_Repeat                  ((USAGE) 0x00BC)
#define CInputUsage_Tracking                ((USAGE) 0x00BD)
#define CInputUsage_Track_Normal            ((USAGE) 0x00BE)
#define CInputUsage_Slow_Tracking           ((USAGE) 0x00BF)
#define CInputUsage_Frame_Forward           ((USAGE) 0x00C0)
#define CInputUsage_Frame_Back              ((USAGE) 0x00C1)
#define CInputUsage_Mark                    ((USAGE) 0x00C2)
#define CInputUsage_Clear_Mark              ((USAGE) 0x00C3)
#define CInputUsage_Repeat_From_Mark        ((USAGE) 0x00C4)
#define CInputUsage_Return_To_Mark          ((USAGE) 0x00C5)
#define CInputUsage_Search_Mark_Forward     ((USAGE) 0x00C6)
#define CInputUsage_Search_Mark_Backwards   ((USAGE) 0x00C7)
#define CInputUsage_Counter_Reset           ((USAGE) 0x00C8)
#define CInputUsage_Show_Counter            ((USAGE) 0x00C9)
#define CInputUsage_Tracking_Increment      ((USAGE) 0x00CA)
#define CInputUsage_Tracking_Decrement      ((USAGE) 0x00CB)
#define CInputUsage_Stop_Eject              ((USAGE) 0x00CC)
#define CInputUsage_Play_Pause              ((USAGE) 0x00CD)
#define CInputUsage_Play_Skip               ((USAGE) 0x00CE)

// audio
#define CInputUsage_Volume                  ((USAGE) 0x00E0)
#define CInputUsage_Balance                 ((USAGE) 0x00E1)
#define CInputUsage_Mute                    ((USAGE) 0x00E2)
#define CInputUsage_Bass                    ((USAGE) 0x00E3)
#define CInputUsage_Treble                  ((USAGE) 0x00E4)
#define CInputUsage_Bass_Boost              ((USAGE) 0x00E5)
#define CInputUsage_Surround_Mode           ((USAGE) 0x00E6)
#define CInputUsage_Loudness                ((USAGE) 0x00E7)
#define CInputUsage_MPX                     ((USAGE) 0x00E8)
#define CInputUsage_Volume_Increment        ((USAGE) 0x00E9)
#define CInputUsage_Volume_Decrement        ((USAGE) 0x00EA)

// advanced vcr control
#define CInputUsage_Speed_Select            ((USAGE) 0x00F0)

#define CInputUsage_Standard_Play           ((USAGE) 0x00F2)
#define CInputUsage_Long_Play               ((USAGE) 0x00F3)
#define CInputUsage_Extended_Play           ((USAGE) 0x00F4)
#define CInputUsage_Slow                    ((USAGE) 0x00F5)

// advanced device control
#define CInputUsage_Fan_Enable              ((USAGE) 0x0100)
#define CInputUsage_Fan_Speed               ((USAGE) 0x0101)
#define CInputUsage_Light_Enable            ((USAGE) 0x0102)
#define CInputUsage_Illumination_Level      ((USAGE) 0x0103)
#define CInputUsage_Climate_Control_Enable  ((USAGE) 0x0104)
#define CInputUsage_Room_Temperature        ((USAGE) 0x0105)
#define CInputUsage_Security_Enable         ((USAGE) 0x0106)
#define CInputUsage_Fire_Alarm              ((USAGE) 0x0107)
#define CInputUsage_Police_Alarm            ((USAGE) 0x0108)

// suppl. audio
#define CInputUsage_Balance_Right           ((USAGE) 0x0150)
#define CInputUsage_Balance_Left            ((USAGE) 0x0151)
#define CInputUsage_Bass_Increment          ((USAGE) 0x0152)
#define CInputUsage_Bass_Decrement          ((USAGE) 0x0153)
#define CInputUsage_Treble_Increment        ((USAGE) 0x0154)
#define CInputUsage_Treble_Decrement        ((USAGE) 0x0155)

#define CInputUsage_MS_Bass_Up              ((USAGE) 0x0169)
#define CInputUsage_MS_Bass_Down            ((USAGE) 0x0169)
#define CInputUsage_MS_Bass_Page            ((USAGE) 0xff00)

// App Launch
#define CInputUsage_Launch_Configuration    ((USAGE) 0x0183)
#define CInputUsage_Launch_Email            ((USAGE) 0x018A)
#define CInputUsage_Launch_Calculator       ((USAGE) 0x0192)
#define CInputUsage_Launch_Browser          ((USAGE) 0x0194)

// App Commands
#define CInputUsage_App_Help                ((USAGE) 0x0095)
#define CInputUsage_App_Spell_Check         ((USAGE) 0x01AB)
#define CInputUsage_App_New                 ((USAGE) 0x0201)
#define CInputUsage_App_Open                ((USAGE) 0x0202)
#define CInputUsage_App_Close               ((USAGE) 0x0203)
#define CInputUsage_App_Save                ((USAGE) 0x0207)
#define CInputUsage_App_Print               ((USAGE) 0x0208)
#define CInputUsage_App_Undo                ((USAGE) 0x021A)
#define CInputUsage_App_Copy                ((USAGE) 0x021B)
#define CInputUsage_App_Cut                 ((USAGE) 0x021C)
#define CInputUsage_App_Paste               ((USAGE) 0x021D)
#define CInputUsage_App_Find                ((USAGE) 0x021F)
#define CInputUsage_App_Search              ((USAGE) 0x0221)
#define CInputUsage_App_Home                ((USAGE) 0x0223)
#define CInputUsage_App_Back                ((USAGE) 0x0224)
#define CInputUsage_App_Forward             ((USAGE) 0x0225)
#define CInputUsage_App_Stop                ((USAGE) 0x0226)
#define CInputUsage_App_Refresh             ((USAGE) 0x0227)
#define CInputUsage_App_Previous            ((USAGE) 0x0228)
#define CInputUsage_App_Next                ((USAGE) 0x0229)
#define CInputUsage_App_Bookmarks           ((USAGE) 0x022A)
#define CInputUsage_App_Redo                ((USAGE) 0x0279)
#define CInputUsage_App_Reply_To_Mail       ((USAGE) 0x0289)
#define CInputUsage_App_Forward_Mail        ((USAGE) 0x028B)
#define CInputUsage_App_Send_Mail           ((USAGE) 0x028C)

// Keyboard/Keypad
#define CInputUsage_Keypad_Equals           ((USAGE) 0x0067)
#define CInputUsage_Keypad_LParen           ((USAGE) 0x00B6)
#define CInputUsage_Keypad_RParen           ((USAGE) 0x00B7)
#define CInputUsage_Keypad_At               ((USAGE) 0x00CE)



#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif // _HIDSERV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\filter\hidvalid\validate.h ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    VALIDATE.H

Abstract:

    This module contains the PRIVATE (driver-only) definitions for the
    code that implements the validate lower level filter driver.

Environment:

    Kernel mode

Revision History:

    Feb-97 : created by Kenneth Ray

--*/


#ifndef _VALIDATE_H
#define _VALIDATE_H

#define HIDV_POOL_TAG (ULONG) 'FdiH'
#undef ExAllocatePool
#define ExAllocatePool(type, size) \
            ExAllocatePoolWithTag (type, size, HIDV_POOL_TAG);
// ExAllocatePool is only called in the descript.c and hidparse.c code.
// all other modules are linked into the user DLL.  They cannot allocate any
// memory.


#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4705)   // Statement has no effect



#if DBG
#define HidV_KdPrint(_x_) \
               DbgPrint ("HidValidate.SYS: "); \
               DbgPrint _x_;

#define TRAP() DbgBreakPoint()

#else
#define HidV_KdPrint(_x_)
#define TRAP()

#endif

#define MIN(a,b) (((a) < (b)) ? (a) : (b))
#define MAX(a,b) (((a) < (b)) ? (b) : (a))

//
// A device extension for the controling device object
//
typedef struct _HIDV_CONTROL_DATA
{
    LIST_ENTRY          HidDevices; // A list of the Device device extensions
    ULONG               NumHidDevices;
    KSPIN_LOCK          Spin; // a sync spin lock for this data.
} HIDV_CONTROL_DATA, *PHIDV_CONTROL_DATA;


//
// A device extension for the device object placed into the attachment
// chain.
//

typedef struct _HIDV_HID_DATA
{
    BOOLEAN                 Started; // This device has been started
    BOOLEAN                 Removed; // This device has been removed
    UCHAR                   Reseved2[2];

    PDEVICE_OBJECT          Self; // a back pointer to the actual DeviceObject
    PDEVICE_OBJECT          PDO; // The PDO to which this filter is attached.
    PDEVICE_OBJECT          TopOfStack; // The top of the device stack just
                                    // beneath this filter device object.
    LIST_ENTRY              List; // A link point for a list of hid device extensions

    KEVENT                  StartEvent; // an event to sync the start IRP.
    KEVENT                  RemoveEvent; // an event to synch outstandIO to zero
    ULONG                   OutstandingIO; // 1 biased count of reasons why
                                           // this object should stick around

    PHIDP_PREPARSED_DATA    Ppd;
    HIDP_CAPS               Caps;   // The capabilities of this hid device
    PHIDP_BUTTON_CAPS       InputButtonCaps; // the array of button caps
    PHIDP_VALUE_CAPS        InputValueCaps;  // the array of value caps
    PHIDP_BUTTON_CAPS       OutputButtonCaps; // the array of button caps
    PHIDP_VALUE_CAPS        OutputValueCaps;  // the array of value caps
    PHIDP_BUTTON_CAPS       FeatureButtonCaps; // the array of button caps
    PHIDP_VALUE_CAPS        FeatureValueCaps;  // the array of value caps

}  HIDV_HID_DATA, *PHIDV_HID_DATA;

struct _HIDV_GLOBALS {
    PDEVICE_OBJECT          ControlObject;
};

extern struct _HIDV_GLOBALS Global;


NTSTATUS
HidV_CreateClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidV_Pass (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidV_Power (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidV_PnP (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidV_Ioctl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidV_Read (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidV_Write (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidV_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );


VOID
HidV_Unload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
HidV_StartDevice (
    IN PHIDV_HID_DATA   HidDevice
    );


NTSTATUS
HidV_StopDevice (
    IN PHIDV_HID_DATA HidDevice
    );


NTSTATUS
HidV_CallHidClass(
    IN      PDEVICE_OBJECT  DeviceObject,
    IN      ULONG           Ioctl,
    IN OUT  PVOID           InputBuffer,
    IN      ULONG           InputBufferLength,
    IN OUT  PVOID           OutputBuffer,
    IN      ULONG           OutputBufferLength
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\client\hidserv\report.c ===
/*++
 *
 *  Component:  hidserv.dll
 *  File:       hid.h
 *  Purpose:    routines to send and receive hid reports.
 * 
 *  Copyright (C) Microsoft Corporation 1997,1998. All rights reserved.
 *
 *  WGJ
--*/

#include "hidserv.h"

BOOL
UnpackReport (
   IN       PCHAR                ReportBuffer,
   IN       USHORT               ReportBufferLength,
   IN       HIDP_REPORT_TYPE     ReportType,
   IN OUT   PHID_DATA            Data,
   IN       ULONG                DataLength,
   IN       PHIDP_PREPARSED_DATA Ppd
   )
/*++
Routine Description:

--*/
{
   ULONG       numUsages; // Number of usages returned from GetUsages.
   ULONG       i;

    for (i = 0; i < DataLength; i++, Data++) {
        if (Data->IsButtonData) {
            numUsages = Data->ButtonData.MaxUsageLength;
            TRACE(("MaxUsageListLength (%d)", Data->ButtonData.MaxUsageLength));
            Data->Status = HidP_GetUsages (
                           ReportType,
                           Data->UsagePage,
                           Data->LinkCollection, 
                           (PUSAGE) Data->ButtonData.Usages,
                           &numUsages,
                           Ppd,
                           ReportBuffer,
                           ReportBufferLength);
            if (HIDP_STATUS_SUCCESS != Data->Status){
                TRACE(("HidP_GetUsages failed (%x)", Data->Status));
            }

             //
             // Get usages writes the list of usages into the buffer
             // Data->ButtonData.Usages newUsage is set to the number of usages
             // written into this array.
             // We assume that there will not be a usage of zero.
             // (None have been defined to date.)
             // So lets assume that a zero indicates an end of the list of usages.
             //

            TRACE(("numUsages (%d)", numUsages));
            if (numUsages < Data->ButtonData.MaxUsageLength) {
                Data->ButtonData.Usages[numUsages].Usage = 0;
                Data->ButtonData.Usages[numUsages].UsagePage = 0;
            }

        } else {
            Data->Status = HidP_GetUsageValue (
                              ReportType,
                              Data->UsagePage,
                              Data->LinkCollection, 
                              Data->ValueData.Usage,
                              &Data->ValueData.Value,
                              Ppd,
                              ReportBuffer,
                              ReportBufferLength);
            if (HIDP_STATUS_SUCCESS != Data->Status){
                TRACE(("HidP_GetUsageValue failed (%x)", Data->Status));
                TRACE(("Usage = %x", Data->ValueData.Usage));
            }
            
            Data->Status = HidP_GetScaledUsageValue (
                              ReportType,
                              Data->UsagePage,
                              Data->LinkCollection, 
                              Data->ValueData.Usage,
                              &Data->ValueData.ScaledValue,
                              Ppd,
                              ReportBuffer,
                              ReportBufferLength);
            if (HIDP_STATUS_SUCCESS != Data->Status){
                TRACE(("HidP_GetScaledUsageValue failed (%x)", Data->Status));
                TRACE(("Usage = %x", Data->ValueData.Usage));
            }

        }
    }
    return (HIDP_STATUS_SUCCESS);
}


BOOL
ParseReadReport (
   PHID_DEVICE    HidDevice
   )
/*++
RoutineDescription:
   Given a struct _HID_DEVICE, unpack the read report values
   into to InputData array.
--*/
{

   return UnpackReport (HidDevice->InputReportBuffer,
                        HidDevice->Caps.InputReportByteLength,
                        HidP_Input,
                        HidDevice->InputData,
                        HidDevice->InputDataLength,
                        HidDevice->Ppd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\filter\hidvalid\pnp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pnp.c

Abstract: Human Input Device (HID) lower filter driver
    This module contains the plug and play dispatch entries needed for this
    filter.

Author:

    Kenneth D. Ray

Environment:

    Kernel mode

Revision History:


--*/
#include <WDM.H>
#include "hidusage.h"
#include "hidpi.h"
#include "hidclass.h"
#include "validate.H"
#include "validio.h"

NTSTATUS
HidV_Power (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The power dispatch routine.
    This filter does not recognize power IRPS.  It merely sends them down,
    unmodified to the next device on the attachment stack.

    As this is a POWER irp, and therefore a special irp, special power irp
    handling is required.

    No completion routine is required.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PHIDV_HID_DATA  hidData;
    NTSTATUS        status;
    TRAP();

    hidData = (PHIDV_HID_DATA) DeviceObject->DeviceExtension;

    if (DeviceObject == Global.ControlObject) {
        //
        // This irp was sent to the control device object, which knows not
        // how to deal with this IRP.  It is therefore an error.
        //
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_NOT_SUPPORTED;

    }
    //
    // This IRP was sent to the filter driver.
    // Since we do not know what to do with the IRP, we should pass
    // it on along down the stack.
    //

    InterlockedIncrement (&hidData->OutstandingIO);

    HidV_KdPrint (("Passing unknown Power irp 0x%x",
                   IoGetCurrentIrpStackLocation(Irp)->MinorFunction));


    if (hidData->Removed) {
        status = STATUS_DELETE_PENDING;
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    } else {
        IoSkipCurrentIrpStackLocation (Irp);

        //
        // Power IRPS come synchronously; drivers must call
        // PoStartNextPowerIrp, when they are ready for the next power irp.
        // This can be called here, or in the completetion routine.
        //
        PoStartNextPowerIrp (Irp);

        //
        // NOTE!!! PoCallDriver NOT IoCallDriver.
        //
        status =  PoCallDriver (hidData->TopOfStack, Irp);
    }

    if (0 == InterlockedDecrement (&hidData->OutstandingIO)) {
        KeSetEvent (&hidData->RemoveEvent, 0, FALSE);
    }
    return status;
}



NTSTATUS
HidV_PnPComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );



NTSTATUS
HidV_PnP (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The plug and play dispatch routines.

    Most of these this filter driver will completely ignore.
    In all cases it must pass on the IRP to the lower driver.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PHIDV_HID_DATA      hidData;
    PIO_STACK_LOCATION  stack;
    NTSTATUS            status;
    TRAP ();

    hidData = (PHIDV_HID_DATA) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (Irp);

    if(DeviceObject == Global.ControlObject) {
        //
        // This irp was sent to the control device object, which knows not
        // how to deal with this IRP.  It is therefore an error.
        //
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_NOT_SUPPORTED;

    }

    HidV_KdPrint (("PlugPlay Irp irp 0x%x",
                   IoGetCurrentIrpStackLocation(Irp)->MinorFunction));

    InterlockedIncrement (&hidData->OutstandingIO);
    if (hidData->Removed) {

        //
        // Someone sent us another plug and play IRP after the remove IRP.
        // This should never happen.
        //
        ASSERT (FALSE);

        if (0 == InterlockedDecrement (&hidData->OutstandingIO)) {
            KeSetEvent (&hidData->RemoveEvent, 0, FALSE);
        }
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return STATUS_DELETE_PENDING;
    }

    switch (stack->MinorFunction) {
    case IRP_MN_START_DEVICE:

        //
        // The device is starting.
        //
        // We cannot touch the device (send it any non pnp irps) until a
        // start device has been passed down to the lower drivers.
        //
        IoCopyCurrentIrpStackLocationToNext (Irp);
        KeInitializeEvent(&hidData->StartEvent, NotificationEvent, FALSE);
        IoSetCompletionRoutine (Irp,
                                HidV_PnPComplete,
                                hidData,
                                TRUE,
                                FALSE,  // No need for Error
                                FALSE); // No need for Cancel
        status = IoCallDriver (hidData->TopOfStack, Irp);
        if (STATUS_PENDING == status) {
            KeWaitForSingleObject(
               &hidData->StartEvent,
               Executive, // Waiting for reason of a driver
               KernelMode, // Waiting in kernel mode
               FALSE, // No allert
               NULL); // No timeout
        } else if (!NT_SUCCESS (status)) {
            break; // In this case our completion routine did not fire.
        }

        //
        // As we are now back from our start device we can do work.
        //

        //
        // Remember, the resources can be found at
        // stack->Parameters.StartDevice.AllocatedResources.
        //

        status = HidV_StartDevice (hidData);
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        break;

    case IRP_MN_STOP_DEVICE:
        status = HidV_StopDevice (hidData);
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (hidData->TopOfStack, Irp);
        break;

    case IRP_MN_REMOVE_DEVICE:
        //
        // The PlugPlay system has dictacted the removal of this device.  We
        // have no choise but to detach and delete the device objecct.
        // (If we wanted to express and interest in preventing this removal,
        // we should have filtered the query remove and query stop routines.)
        //
        // Note! we might receive a remove WITHOUT first receiving a stop.
        // ASSERT (!hidData->Removed);

        //
        // We will no longer receive requests for this device as it has been
        // removed.
        //
        hidData->Removed = TRUE;

        if (hidData->Started) {
            ASSERT (NT_SUCCESS (status = HidV_StopDevice(hidData)));
        }

        //
        // Here if we had any outstanding requests in a personal queue we should
        // complete them all now.
        //
        // Note, the device is guarenteed stopped, so we cannot send it any non-
        // PNP IRPS.
        //

        //
        // Send on the remove IRP
        //

        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (hidData->TopOfStack, Irp);

        if (0 < InterlockedDecrement (&hidData->OutstandingIO)) {
            KeWaitForSingleObject (
                &hidData->RemoveEvent,
                Executive,
                KernelMode,
                FALSE,
                NULL);
        }

        IoDetachDevice (hidData->TopOfStack);

        //
        // Clean up memory
        //

        if (hidData->Ppd) {
            // The device could be removed without ever having been started.
            ExFreePool (hidData->Ppd);
            ExFreePool (hidData->InputButtonCaps);
            ExFreePool (hidData->InputValueCaps);
            ExFreePool (hidData->OutputButtonCaps);
            ExFreePool (hidData->OutputValueCaps);
            ExFreePool (hidData->FeatureButtonCaps);
            ExFreePool (hidData->FeatureValueCaps);
        }

        IoDeleteDevice (hidData->Self);
        return STATUS_SUCCESS;

    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
    case IRP_MN_QUERY_DEVICE_RELATIONS:
    case IRP_MN_QUERY_INTERFACE:
    case IRP_MN_QUERY_CAPABILITIES:
    case IRP_MN_QUERY_RESOURCES:
    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
    case IRP_MN_SET_RESOURCE_REQUIREMENTS:
    case IRP_MN_READ_CONFIG:
    case IRP_MN_WRITE_CONFIG:
    case IRP_MN_EJECT:
    case IRP_MN_SET_LOCK:
    case IRP_MN_QUERY_ID:
    case IRP_MN_QUERY_PNP_DEVICE_STATE:
    default:
        //
        // Here the filter driver might modify the behavior of these IRPS
        // Please see PlugPlay documentation for use of these IRPs.
        //
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (hidData->TopOfStack, Irp);
        break;
    }


    if (0 == InterlockedDecrement (&hidData->OutstandingIO)) {
        KeSetEvent (&hidData->RemoveEvent, 0, FALSE);
    }

    return status;
}


NTSTATUS
HidV_PnPComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:
    The pnp IRP is in the process of completing.
    signal

Arguments:
    Context set to the device object in question.

--*/
{
    PIO_STACK_LOCATION  stack;
    PHIDV_HID_DATA      hidData;
    NTSTATUS            status;

    UNREFERENCED_PARAMETER (DeviceObject);

    status = STATUS_SUCCESS;
    hidData = (PHIDV_HID_DATA) Context;
    stack = IoGetCurrentIrpStackLocation (Irp);

    switch (stack->MajorFunction) {
    case IRP_MJ_PNP:

        switch (stack->MinorFunction) {
        case IRP_MN_START_DEVICE:

            KeSetEvent (&hidData->StartEvent, 0, FALSE);
            return STATUS_MORE_PROCESSING_REQUIRED;

        default:
            break;
        }
        break;

    case IRP_MJ_POWER:
    default:
        break;
    }
    return status;
}

NTSTATUS
HidV_StartDevice (
    IN PHIDV_HID_DATA   HidData
    )
/*++

Routine Description:

Arguments:


--*/
{
    NTSTATUS                    status;
    HID_COLLECTION_INFORMATION  collectionInfo;

    ASSERT (!HidData->Removed);
    //
    // The PlugPlay system should not have started a removed device!
    //

    HidData->Ppd = NULL;
    HidData->InputButtonCaps = NULL;
    HidData->InputValueCaps = NULL;
    HidData->OutputButtonCaps = NULL;
    HidData->OutputValueCaps = NULL;
    HidData->FeatureButtonCaps = NULL;
    HidData->FeatureValueCaps = NULL;

    if (HidData->Started) {
        return STATUS_SUCCESS;
    }

    //
    // Find out about this HID device.
    //

    //
    // Retrieve the caps for this device.
    //
    status = HidV_CallHidClass (HidData->TopOfStack,
                                IOCTL_HID_GET_COLLECTION_INFORMATION,
                                &collectionInfo,
                                sizeof (collectionInfo),
                                NULL,
                                0);

    if (!NT_SUCCESS (status)) {
        goto HIDV_START_DEVICE_REJECT;
    }

    HidData->Ppd = ExAllocatePool (NonPagedPool,
                                   collectionInfo.DescriptorSize);
    if (NULL == HidData->Ppd) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto HIDV_START_DEVICE_REJECT;
    }

    //
    // Retrieve the Preparsed Data
    //
    status = HidV_CallHidClass (HidData->TopOfStack,
                                IOCTL_HID_GET_COLLECTION_DESCRIPTOR,
                                HidData->Ppd,
                                collectionInfo.DescriptorSize,
                                NULL,
                                0);

    if (!NT_SUCCESS (status)) {
        goto HIDV_START_DEVICE_REJECT;
    }

    //
    // Retrieve the Caps for the device.
    //
    status = HidP_GetCaps (HidData->Ppd, &HidData->Caps);
    if (!NT_SUCCESS (status)) {
        goto HIDV_START_DEVICE_REJECT;
    }

    //
    // Get all of the caps for the device.
    //

#define Alloc(type) HidData-> ## type = ExAllocatePool (                    \
                                            NonPagedPool,                   \
                                            HidData->Caps.Number ## type ); \
                    if (NULL == HidData-> ## type) {                        \
                        status = STATUS_INSUFFICIENT_RESOURCES;             \
                        goto HIDV_START_DEVICE_REJECT;                      \
                    }
    Alloc (InputButtonCaps);
    Alloc (InputValueCaps);
    Alloc (OutputButtonCaps);
    Alloc (OutputValueCaps);
    Alloc (FeatureButtonCaps);
    Alloc (FeatureValueCaps);
#undef Alloc

    HidP_GetButtonCaps (HidP_Input,
                        HidData->InputButtonCaps,
                        &HidData->Caps.NumberInputButtonCaps,
                        HidData->Ppd);
    HidP_GetButtonCaps (HidP_Output,
                        HidData->OutputButtonCaps,
                        &HidData->Caps.NumberOutputButtonCaps,
                        HidData->Ppd);
    HidP_GetButtonCaps (HidP_Feature,
                        HidData->FeatureButtonCaps,
                        &HidData->Caps.NumberFeatureButtonCaps,
                        HidData->Ppd);
    HidP_GetValueCaps  (HidP_Input,
                        HidData->InputValueCaps,
                        &HidData->Caps.NumberInputValueCaps,
                        HidData->Ppd);
    HidP_GetValueCaps  (HidP_Output,
                        HidData->OutputValueCaps,
                        &HidData->Caps.NumberOutputValueCaps,
                        HidData->Ppd);
    HidP_GetValueCaps  (HidP_Feature,
                        HidData->FeatureValueCaps,
                        &HidData->Caps.NumberFeatureValueCaps,
                        HidData->Ppd);


    HidData->Started = TRUE;
    status = STATUS_SUCCESS;

    return status;

HIDV_START_DEVICE_REJECT:

#define CondFree(addr) if ((addr)) ExFreePool ((addr))
    CondFree(HidData->Ppd);
    CondFree(HidData->InputButtonCaps);
    CondFree(HidData->InputValueCaps);
    CondFree(HidData->OutputButtonCaps);
    CondFree(HidData->OutputValueCaps);
    CondFree(HidData->FeatureButtonCaps);
    CondFree(HidData->FeatureValueCaps);
#undef CondFree

    return status;
}


NTSTATUS
HidV_StopDevice (
    IN PHIDV_HID_DATA HidData
    )
/*++

Routine Description:
    The PlugPlay system has dictacted the removal of this device.  We have
    no choise but to detach and delete the device objecct.
    (If we wanted to express and interest in preventing this removal,
    we should have filtered the query remove and query stop routines.)

    Note! we might receive a remove WITHOUT first receiving a stop.

Arguments:
    The HidDevice being started.

--*/
{
    NTSTATUS    status;

    ASSERT (!HidData->Removed);
    //
    // The PlugPlay system should not have started a removed device!
    //


    if (!HidData->Started) {
        return STATUS_SUCCESS;
    }

    //
    // Find out about this HID device.
    //


    HidData->Started = FALSE;
    status = STATUS_SUCCESS;

    return status;
}


NTSTATUS
HidV_CallHidClass(
    IN      PDEVICE_OBJECT  DeviceObject,
    IN      ULONG           Ioctl,
    IN OUT  PVOID           InputBuffer,
    IN      ULONG           InputBufferLength,
    IN OUT  PVOID           OutputBuffer,
    IN      ULONG           OutputBufferLength
    )
/*++

Routine Description:

    Makes a synchronous request to the HIDCLASS driver below.

Arguments:

    DeviceObject       - Device Object to send the Ioctl.

    Ioctl              - Value of the IOCTL request.

    InputBuffer        - Buffer to be sent to the HID class driver.

    InputBufferLength  - Size of buffer to be sent to the HID class driver.

    OutputBuffer       - Buffer for received data from the HID class driver.

    OutputBufferLength - Size of receive buffer from the HID class.

Return Value:

    NTSTATUS result code.

--*/
{
    KEVENT             event;
    IO_STATUS_BLOCK    ioStatus;
    PIRP               irp;
    PIO_STACK_LOCATION nextStack;
    NTSTATUS           status = STATUS_SUCCESS;

    HidV_KdPrint(("PNP-CallHidClass: Enter."));

    //
    // Prepare to issue a synchronous request.
    //
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Build an IRP.
    //
    irp = IoBuildDeviceIoControlRequest (
                            Ioctl,
                            DeviceObject,
                            InputBuffer,
                            InputBufferLength,
                            OutputBuffer,
                            OutputBufferLength,
                            FALSE,              // external IOCTL
                            &event,
                            &ioStatus);

    if (irp == NULL) {
       return STATUS_UNSUCCESSFUL;
    }

    nextStack = IoGetNextIrpStackLocation(irp);

    ASSERT(nextStack != NULL);

    //
    // Submit the request to the HID class driver.
    //
    status = IoCallDriver(DeviceObject, irp);

    if (status == STATUS_PENDING) {

       //
       // Request to HID class driver is still pending.  Wait for the request
       // to complete.
       //
       status = KeWaitForSingleObject(
                     &event,
                     Executive,    // wait reason
                     KernelMode,
                     FALSE,        // not alertable
                     NULL);        // no time out
    }

    status = ioStatus.Status;

    HidV_KdPrint(("PNP-CallHidClass: Exit (%x).", status ));

    //
    // We are done.  Return our status to the caller.
    //
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidclass\complete.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    complete.c

Abstract

    Completion routines for the major IRP functions.

Author:

    Ervin P.

Environment:

    Kernel mode only

Revision History:


--*/

#include "pch.h"



/*
 ********************************************************************************
 *  HidpSetMaxReportSize
 ********************************************************************************
 *
 *  Set the maxReportSize field in the HID device extension
 *
 */
ULONG HidpSetMaxReportSize(IN FDO_EXTENSION *fdoExtension)
{
    PHIDP_DEVICE_DESC deviceDesc = &fdoExtension->deviceDesc;
    ULONG i;

    /*
     *  For all reports (of all collections) for this device,
     *  find the length of the longest one.
     */
    fdoExtension->maxReportSize = 0;
    for (i = 0; i < deviceDesc->ReportIDsLength; i++){
        PHIDP_REPORT_IDS reportIdent = &deviceDesc->ReportIDs[i];
        PHIDCLASS_COLLECTION collection = GetHidclassCollection(fdoExtension, reportIdent->CollectionNumber);

        if (collection){
            if (reportIdent->InputLength > fdoExtension->maxReportSize){
                fdoExtension->maxReportSize = reportIdent->InputLength;
            }
        }
    }

    DBGASSERT(fdoExtension->maxReportSize, 
              ("Input length is zero for fdo %x.", fdoExtension->fdo), 
              FALSE)

    return fdoExtension->maxReportSize;
}



/*
 ********************************************************************************
 *  CompleteAllPendingReadsForFileExtension
 ********************************************************************************
 *
 *
 */
VOID CompleteAllPendingReadsForFileExtension(
                    PHIDCLASS_COLLECTION Collection,
                    PHIDCLASS_FILE_EXTENSION fileExtension)
{
    LIST_ENTRY irpsToComplete;
    PIRP irp;
    KIRQL oldIrql;

    ASSERT(fileExtension->Signature == HIDCLASS_FILE_EXTENSION_SIG);

    /*
     *  Move the IRPs to a private queue before completing so they don't
     *  get requeued on the completion thread, causing us to spin forever.
     */
    InitializeListHead(&irpsToComplete);
    LockFileExtension(fileExtension, &oldIrql);
    while (irp = DequeueInterruptReadIrp(Collection, fileExtension)){
        //
        // Irps are created from nonpaged pool, 
        // so this is ok to call at Dispatch level.
        //
        InsertTailList(&irpsToComplete, &irp->Tail.Overlay.ListEntry);
    }
    UnlockFileExtension(fileExtension, oldIrql);

    /*
     *  Complete all the dequeued read IRPs.
     */
    while (!IsListEmpty(&irpsToComplete)){
        PLIST_ENTRY listEntry = RemoveHeadList(&irpsToComplete);
        irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);
        irp->IoStatus.Status = STATUS_DEVICE_NOT_CONNECTED;
        DBGVERBOSE(("Aborting pending read with status=%xh.", irp->IoStatus.Status))
        DBG_RECORD_READ(irp, 0, 0, TRUE)
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }

}




/*
 ********************************************************************************
 *  CompleteAllPendingReadsForCollection
 ********************************************************************************
 *
 *
 */
VOID CompleteAllPendingReadsForCollection(PHIDCLASS_COLLECTION Collection)
{
    LIST_ENTRY tmpList;
    PLIST_ENTRY listEntry;
    KIRQL oldIrql;

    InitializeListHead(&tmpList);

    KeAcquireSpinLock(&Collection->FileExtensionListSpinLock, &oldIrql);

    /*
     *  We want to process each fileExtension in the list once.
     *  But we can't keep track of where to stop by just remembering
     *  the first item because fileExtensions can get closed while
     *  we're completing the reads.  So copy all the file extensions
     *  to a temporary list first.
     *
     *  This can all probably get removed, since this only gets called
     *  on a remove, when a create can not be received. In addition, 
     *  we would have received all close irps since remove only gets
     *  sent when all closes have come through.
     *
     */
    while (!IsListEmpty(&Collection->FileExtensionList)){
        listEntry = RemoveHeadList(&Collection->FileExtensionList);
        InsertTailList(&tmpList, listEntry);
    }


    /*
     *  Now put the fileExtensions back in the list 
     *  and cancel the reads on each file extension.
     */
    while (!IsListEmpty(&tmpList)){
        PHIDCLASS_FILE_EXTENSION fileExtension;

        listEntry = RemoveHeadList(&tmpList);

        /*
         *  Put the fileExtension back in FileExtensionList first
         *  so that it's there in case we get the close while
         *  completing the pending irps.
         */
        InsertTailList(&Collection->FileExtensionList, listEntry);

        fileExtension = CONTAINING_RECORD(listEntry, HIDCLASS_FILE_EXTENSION, FileList);

        /*
         *  We will be completing IRPs for this fileExtension.
         *  Always release all spinlocks before calling outside the driver.
         */
        KeReleaseSpinLock(&Collection->FileExtensionListSpinLock, oldIrql);
        CompleteAllPendingReadsForFileExtension(Collection, fileExtension);
        KeAcquireSpinLock(&Collection->FileExtensionListSpinLock, &oldIrql);
    }

    KeReleaseSpinLock(&Collection->FileExtensionListSpinLock, oldIrql);
}

/*
 ********************************************************************************
 *  CompleteAllPendingReadsForDevice
 ********************************************************************************
 *
 *
 */
VOID CompleteAllPendingReadsForDevice(FDO_EXTENSION *fdoExt)
{
    PHIDP_DEVICE_DESC deviceDesc = &fdoExt->deviceDesc;
    ULONG i;

    for (i = 0; i < deviceDesc->CollectionDescLength; i++){
        PHIDCLASS_COLLECTION collection = &fdoExt->classCollectionArray[i];
        CompleteAllPendingReadsForCollection(collection);
    }

}

/*
 ********************************************************************************
 *  HidpFreePowerEvent
 ********************************************************************************
 *
 *
 */
VOID
HidpFreePowerEventIrp(
    PHIDCLASS_COLLECTION Collection
    )
{
    PIRP powerEventIrpToComplete = NULL;
    KIRQL oldIrql;

    /*
     *  If a power event IRP is queued for this collection,
     *  fail it now.
     */
    KeAcquireSpinLock(&Collection->powerEventSpinLock, &oldIrql);
    if (ISPTR(Collection->powerEventIrp)){
        PDRIVER_CANCEL oldCancelRoutine;

        powerEventIrpToComplete = Collection->powerEventIrp;
        oldCancelRoutine = IoSetCancelRoutine(powerEventIrpToComplete, NULL);
        if (oldCancelRoutine){
            ASSERT(oldCancelRoutine == PowerEventCancelRoutine);
        }
        else {
            /*
             *  The IRP was cancelled and the cancel routine WAS called.
             *  The cancel routine will complete the IRP as soon as we drop the spinlock,
             *  so don't touch the IRP.
             */
            ASSERT(powerEventIrpToComplete->Cancel);
            powerEventIrpToComplete = NULL;
        }
        Collection->powerEventIrp = BAD_POINTER;
    }
    KeReleaseSpinLock(&Collection->powerEventSpinLock, oldIrql);
    if (powerEventIrpToComplete){
        powerEventIrpToComplete->IoStatus.Status = STATUS_DEVICE_NOT_CONNECTED;
        *(PULONG)powerEventIrpToComplete->AssociatedIrp.SystemBuffer = 0;
        powerEventIrpToComplete->IoStatus.Information = 0;
        IoCompleteRequest(powerEventIrpToComplete, IO_NO_INCREMENT);
    }
}

/*
 ********************************************************************************
 *  HidpDestroyCollection
 ********************************************************************************
 *
 *
 */
VOID HidpDestroyCollection(FDO_EXTENSION *fdoExt, PHIDCLASS_COLLECTION Collection)
{
    #if DBG
        static int reentrancyCounter = 0;
        if (reentrancyCounter++ != 0) TRAP;
        
        ASSERT(Collection->Signature == HIDCLASS_COLLECTION_SIG);
    #endif
    
    CompleteAllPendingReadsForCollection(Collection);

    if (Collection->hidCollectionInfo.Polled){
        StopPollingLoop(Collection, TRUE);
    }


    HidpFreePowerEventIrp(Collection);

    #if DBG
        Collection->Signature = ~HIDCLASS_COLLECTION_SIG;
        reentrancyCounter--;
    #endif
}






/*
 ********************************************************************************
 *  HidpQueryCapsCompletion
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpQueryCapsCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
{
    PKEVENT event = Context;

    DBG_COMMON_ENTRY()

    KeSetEvent(event, 1, FALSE);

    DBG_COMMON_EXIT()

    return STATUS_MORE_PROCESSING_REQUIRED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidclass\debug.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    debug.c

Abstract

                        Debug/performance routines

Author:

    Ervin P.

Environment:

    Kernel mode only

Revision History:


--*/

#include "pch.h"

#if DBG

    // can poke this in the debugger to trap for warnings
    BOOLEAN dbgTrapOnWarn = FALSE;

    BOOLEAN dbgTrapOnSS = FALSE;

    BOOLEAN dbgVerbose = FALSE;

    BOOLEAN dbgInfo = TRUE;

    BOOLEAN dbgSkipSecurity = FALSE;

    BOOLEAN dbgTrapOnHiccup = FALSE;

    ULONG dbgLastEntry = 0;
    ULONG dbgInHidclass = 0;
    VOID DbgCommonEntryExit(BOOLEAN isEntering)
    {
        if (isEntering){
            dbgInHidclass++;
            #ifdef _X86_
                _asm nop
                _asm mov eax, [ebp+4]   /*  <- set breakpt here */
                _asm mov dbgLastEntry, eax
            #endif
        }
        else {
            dbgInHidclass--;
        }
    }

    VOID InitFdoExtDebugInfo(PHIDCLASS_DEVICE_EXTENSION hidclassExt)
    {
        FDO_EXTENSION *fdoExt = &hidclassExt->fdoExt;
        NTSTATUS status;
        ULONG actualLen;

        status = IoGetDeviceProperty(   hidclassExt->hidExt.PhysicalDeviceObject,
                                        DevicePropertyDriverKeyName,
                                        sizeof(fdoExt->dbgDriverKeyName),
                                        fdoExt->dbgDriverKeyName,
                                        &actualLen);

        if (!NT_SUCCESS(status)) {
            //
            // We couldn't get the driver key name.  This will happen during
            // textmode setup on NT, for example, when we're loaded as part of
            // bootstrapping the system (long before the device installer/class
            // installer have run).
            //
            // Simply initialize the driver key name field to an empty string.
            //
            *(fdoExt->dbgDriverKeyName) = L'\0';
        }
    }


        ULONG dbgMinInterruptDelta = 0x0fffffff;
        ULONG dbgMaxInterruptsPerSecond = 0;
        ULONG dbgShortestInt = 0x0fffffff;
        ULONG dbgLongestInt = 0;
        LARGE_INTEGER dbgLastIntStart = {0};
        ULONG dbgAveIntTime = 0;

        VOID DbgLogIntStart()
        {
                static ULONG dbgInterruptsThisSecond = 0;
                static ULONG dbgThisSecondStartTime = 0;

                LARGE_INTEGER timeNow;
                ULONG lastTimeMilliSec, timeNowMilliSec;

                KeQuerySystemTime(&timeNow);

                // convert from usec to millisec
                timeNowMilliSec = timeNow.LowPart/10000;
                lastTimeMilliSec = dbgLastIntStart.LowPart/10000;

                if (timeNow.HighPart == dbgLastIntStart.HighPart){
                        ULONG delta = timeNowMilliSec - lastTimeMilliSec;

                        if (delta < dbgMinInterruptDelta){
                                dbgMinInterruptDelta = delta;
                        }

                        if (timeNowMilliSec - dbgThisSecondStartTime < 1000){
                                dbgInterruptsThisSecond++;
                                if (dbgInterruptsThisSecond > dbgMaxInterruptsPerSecond){
                                        dbgMaxInterruptsPerSecond = dbgInterruptsThisSecond;
                                }
                        }
                        else {
                                dbgThisSecondStartTime = timeNowMilliSec;
                                dbgInterruptsThisSecond = 0;
                        }
                }
                else {
                        // this case is harder so skip it
                        dbgThisSecondStartTime = timeNowMilliSec;
                        dbgInterruptsThisSecond = 0;
                }

                dbgLastIntStart = timeNow;
        }

        VOID DbgLogIntEnd()
        {
            LARGE_INTEGER timeNow;

            KeQuerySystemTime(&timeNow);

            if (timeNow.HighPart == dbgLastIntStart.HighPart){
                    ULONG timeNowMilliSec = timeNow.LowPart/10000;
                    ULONG intStartTimeMilliSec = dbgLastIntStart.LowPart/10000;
                    ULONG delta = timeNowMilliSec - intStartTimeMilliSec;

                    if (delta < dbgShortestInt){
                        dbgShortestInt = delta;
                    }
                    else if (delta > dbgLongestInt){
                        dbgLongestInt = delta;
                    }

                    {
                        static ULONG dbgIntCount = 0;
                        static ULONG dbgTimeLast1000Ints = 0;

                        if (dbgIntCount < 1000){
                                dbgIntCount++;
                                dbgTimeLast1000Ints += delta;
                        }
                        else {
                                dbgAveIntTime = dbgTimeLast1000Ints/1000;
                                dbgTimeLast1000Ints = 0;
                                dbgIntCount = 0;
                        }
                    }

            }
            else {
                // This is harder so we just skip it
            }

        }

    #define DBG_MAX_DEVOBJ_RECORDS 100
    dbgDevObjRecord dbgDevObjs[DBG_MAX_DEVOBJ_RECORDS] = {0};

    VOID DbgRecordDevObj(PDEVICE_OBJECT devObj, PCHAR str)
    {
        ULONG i;

        for (i = 0; i < DBG_MAX_DEVOBJ_RECORDS; i++){
            if (!ISPTR(dbgDevObjs[i].devObj)){
                break;
            }
            else if (dbgDevObjs[i].devObj == devObj){
                // already there
                break;
            }
        }

        if ((i < DBG_MAX_DEVOBJ_RECORDS) && !dbgDevObjs[i].devObj){
            ULONG j;
            dbgDevObjs[i].devObj = devObj;
            for (j = 0; str[j] && (j < dbgDevObjRecord_STRINGSIZE); j++){
                dbgDevObjs[i].str[j] = str[j];
            }
        }
    }

    #define DBG_MAX_FEATURE_RECORDS 0x1000
    dbgFeatureRecord dbgFeatures[DBG_MAX_FEATURE_RECORDS] = {0};
    ULONG dbgFeatureFirstFreeIndex = 0;
    VOID DbgRecordReport(ULONG reportId, ULONG controlCode, BOOLEAN isComplete)
    {
        ULONG typeId;

        switch (controlCode){
        case IOCTL_HID_GET_FEATURE: typeId = (ULONG)'fteG'; break;
        case IOCTL_HID_SET_FEATURE: typeId = (ULONG)'fteS'; break;
        case IOCTL_HID_GET_INPUT_REPORT: typeId = (ULONG)'iteG'; break;
        case IOCTL_HID_SET_OUTPUT_REPORT: typeId = (ULONG)'oteS'; break;
            default:                    typeId = (ULONG)'xxxx'; TRAP; break;
        }

        if (isComplete){
            LONG i;
            // step back to find the report that got completed
            // assumes no overlapped calls to same feature
            ASSERT(dbgFeatureFirstFreeIndex > 0);
            i = dbgFeatureFirstFreeIndex-1;
            while ((i >= 0) &&
                   ((dbgFeatures[i].reportId != reportId) ||
                    (dbgFeatures[i].type != typeId)       ||
                    dbgFeatures[i].completed)){
                i--;
            }
            ASSERT(i >= 0);
            if (i >= 0){
                dbgFeatures[i].completed = 1;
            }
        }
        else {
            if (dbgFeatureFirstFreeIndex >= DBG_MAX_FEATURE_RECORDS){
                RtlZeroMemory(dbgFeatures, sizeof(dbgFeatures));
                dbgFeatureFirstFreeIndex = 0;
            }

            dbgFeatures[dbgFeatureFirstFreeIndex].marker = (ULONG)'taeF';
            dbgFeatures[dbgFeatureFirstFreeIndex].reportId = reportId;
            dbgFeatures[dbgFeatureFirstFreeIndex].type = typeId;
            dbgFeatures[dbgFeatureFirstFreeIndex].completed = 0;
            dbgFeatureFirstFreeIndex++;
        }

    }


    #define DBG_MAX_READ_RECORDS 0x1000
    dbgReadRecord dbgReads[DBG_MAX_READ_RECORDS] = {0};
    VOID DbgRecordRead(PIRP irp, ULONG length, ULONG reportId, ULONG completed)
    {
        LONG i;

        for (i = 0;
            (i < DBG_MAX_READ_RECORDS) &&
            dbgReads[i].irpPtr &&
            ((dbgReads[i].irpPtr != (ULONG_PTR)irp) || dbgReads[i].completed);
             i++){
        }

        if (i < DBG_MAX_READ_RECORDS){
            if (dbgReads[i].irpPtr){
                ASSERT(dbgReads[i].irpPtr == (ULONG_PTR)irp);
                ASSERT(!dbgReads[i].completed);
                ASSERT(completed);
                dbgReads[i].length = length;
                dbgReads[i].reportId = reportId;
                dbgReads[i].completed = completed;
            }
            else {
                dbgReads[i].irpPtr = (ULONG_PTR)irp;
                dbgReads[i].length = length;
                dbgReads[i].reportId = reportId;
                dbgReads[i].completed = completed;
            }
        }

    }


    VOID DbgLogIrpMajor(ULONG_PTR irpPtr, ULONG majorFunc, ULONG isForCollectionPdo, ULONG isComplete, ULONG status)
    {

        if (dbgVerbose){
            char *funcName;

            switch (majorFunc){
                #undef MAKE_CASE
                #define MAKE_CASE(fnc) case fnc: funcName = #fnc; break;

                MAKE_CASE(IRP_MJ_CREATE)
                MAKE_CASE(IRP_MJ_CREATE_NAMED_PIPE)
                MAKE_CASE(IRP_MJ_CLOSE)
                MAKE_CASE(IRP_MJ_READ)
                MAKE_CASE(IRP_MJ_WRITE)
                MAKE_CASE(IRP_MJ_QUERY_INFORMATION)
                MAKE_CASE(IRP_MJ_SET_INFORMATION)
                MAKE_CASE(IRP_MJ_QUERY_EA)
                MAKE_CASE(IRP_MJ_SET_EA)
                MAKE_CASE(IRP_MJ_FLUSH_BUFFERS)
                MAKE_CASE(IRP_MJ_QUERY_VOLUME_INFORMATION)
                MAKE_CASE(IRP_MJ_SET_VOLUME_INFORMATION)
                MAKE_CASE(IRP_MJ_DIRECTORY_CONTROL)
                MAKE_CASE(IRP_MJ_FILE_SYSTEM_CONTROL)
                MAKE_CASE(IRP_MJ_DEVICE_CONTROL)
                MAKE_CASE(IRP_MJ_INTERNAL_DEVICE_CONTROL)
                MAKE_CASE(IRP_MJ_SHUTDOWN)
                MAKE_CASE(IRP_MJ_LOCK_CONTROL)
                MAKE_CASE(IRP_MJ_CLEANUP)
                MAKE_CASE(IRP_MJ_CREATE_MAILSLOT)
                MAKE_CASE(IRP_MJ_QUERY_SECURITY)
                MAKE_CASE(IRP_MJ_SET_SECURITY)
                MAKE_CASE(IRP_MJ_POWER)
                MAKE_CASE(IRP_MJ_SYSTEM_CONTROL)
                MAKE_CASE(IRP_MJ_DEVICE_CHANGE)
                MAKE_CASE(IRP_MJ_QUERY_QUOTA)
                MAKE_CASE(IRP_MJ_SET_QUOTA)
                MAKE_CASE(IRP_MJ_PNP)

                default: funcName = NULL;    break;
            }

            if (isComplete){
                if (funcName){
                    DBGOUT(("< %s for %s status=%xh (irp=%ph)",
                            funcName,
                            isForCollectionPdo ? "collection" : "device",
                            status,
                            irpPtr));
                }
                else {
                    DBGOUT(("< ????<majorFunc=%xh> for %s status=%xh (irp=%ph)",
                            majorFunc,
                            isForCollectionPdo ? "collection" : "device",
                            status,
                            irpPtr));
                }
            }
            else {
                if (funcName){
                    DBGOUT(("> %s (irp=%xh)", funcName, irpPtr));
                }
                else {
                    DBGOUT(("> ????<majorFunc=%xh> (irp=%xh)", majorFunc, irpPtr));
                }
            }
        }

    }



    #define DBG_MAX_PNP_IRP_RECORDS 0x1000
    dbgPnPIrpRecord dbgPnPIrps[DBG_MAX_PNP_IRP_RECORDS] = {0};

    VOID DbgLogPnpIrp(ULONG_PTR irpPtr, ULONG minorFunc, ULONG isForCollectionPdo, ULONG isComplete, ULONG status)
    {
        char *funcName;
        ULONG funcShortName;
        int i;

        switch (minorFunc){
            #undef MAKE_CASE
            #define MAKE_CASE(fnc) case fnc: funcName = #fnc; funcShortName = *(ULONG *)(funcName+7); break;

            MAKE_CASE(IRP_MN_START_DEVICE)
            MAKE_CASE(IRP_MN_QUERY_REMOVE_DEVICE)
            MAKE_CASE(IRP_MN_REMOVE_DEVICE)
            MAKE_CASE(IRP_MN_CANCEL_REMOVE_DEVICE)
            MAKE_CASE(IRP_MN_STOP_DEVICE)
            MAKE_CASE(IRP_MN_QUERY_STOP_DEVICE)
            MAKE_CASE(IRP_MN_CANCEL_STOP_DEVICE)
            MAKE_CASE(IRP_MN_QUERY_DEVICE_RELATIONS)
            MAKE_CASE(IRP_MN_QUERY_INTERFACE)
            MAKE_CASE(IRP_MN_QUERY_CAPABILITIES)
            MAKE_CASE(IRP_MN_QUERY_RESOURCES)
            MAKE_CASE(IRP_MN_QUERY_RESOURCE_REQUIREMENTS)
            MAKE_CASE(IRP_MN_QUERY_DEVICE_TEXT)
            MAKE_CASE(IRP_MN_READ_CONFIG)
            MAKE_CASE(IRP_MN_WRITE_CONFIG)
            MAKE_CASE(IRP_MN_EJECT)
            MAKE_CASE(IRP_MN_SET_LOCK)
            MAKE_CASE(IRP_MN_QUERY_ID)
            MAKE_CASE(IRP_MN_QUERY_PNP_DEVICE_STATE)
            MAKE_CASE(IRP_MN_QUERY_BUS_INFORMATION)
            MAKE_CASE(IRP_MN_DEVICE_USAGE_NOTIFICATION)
            MAKE_CASE(IRP_MN_SURPRISE_REMOVAL)

#ifndef IRP_MN_QUERY_LEGACY_BUS_INFORMATION
#define IRP_MN_QUERY_LEGACY_BUS_INFORMATION 0x18
#endif // IRP_MN_QUERY_LEGACY_BUS_INFORMATION
            MAKE_CASE(IRP_MN_QUERY_LEGACY_BUS_INFORMATION)

            default: funcName = NULL; funcShortName = (ULONG)'\?\?\?\?'; break;
        }

        if (dbgVerbose){
            if (isComplete){
                if (funcName){
                    DBGOUT((" < %s for %s status=%xh (irp=%ph)",
                            funcName,
                            isForCollectionPdo ? "collection" : "device",
                            status,
                            irpPtr));
                }
                else {
                    DBGOUT((" < ?? <minorFunc=%xh> for %s status=%xh (irp=%ph)",
                            minorFunc,
                            isForCollectionPdo ? "collection" : "device",
                            status,
                            irpPtr));
                }
            }
            else {
                if (funcName){
                    DBGOUT((" > %s for %s (irp=%xh)",
                            funcName,
                            isForCollectionPdo ? "collection" : "device",
                            irpPtr));
                }
                else {
                    DBGOUT((" > ?? <minorFunc=%xh> for %s (irp=%xh)",
                            minorFunc,
                            isForCollectionPdo ? "collection" : "device",
                            irpPtr));
                }
            }
        }

        if (isComplete){
            for (i = 0; (i < DBG_MAX_PNP_IRP_RECORDS) && dbgPnPIrps[i].irpPtr; i++){
                if ((dbgPnPIrps[i].irpPtr == irpPtr) &&
                    ((dbgPnPIrps[i].status == 0xFFFFFFFF) || (dbgPnPIrps[i].status == STATUS_PENDING))){
                    dbgPnPIrps[i].status = status;
                    break;
                }

            }
        }
        else {
            for (i = 0; i < DBG_MAX_PNP_IRP_RECORDS; i++){
                if (!dbgPnPIrps[i].irpPtr){
                    dbgPnPIrps[i].irpPtr = irpPtr;
                    dbgPnPIrps[i].func = funcShortName;
                    dbgPnPIrps[i].isForCollectionPdo = isForCollectionPdo;
                    dbgPnPIrps[i].status = 0xFFFFFFFF;
                    break;
                }
            }
        }


    }


    VOID DbgLogPowerIrp(PVOID devExt, UCHAR minorFunc, ULONG isClientPdo, ULONG isComplete, PCHAR type, ULONG powerState, ULONG status)
    {
        char *funcName;

        switch (minorFunc){
            #undef MAKE_CASE
            #define MAKE_CASE(fnc) case fnc: funcName = #fnc; break;

            MAKE_CASE(IRP_MN_WAIT_WAKE)
            MAKE_CASE(IRP_MN_POWER_SEQUENCE)
            MAKE_CASE(IRP_MN_SET_POWER)
            MAKE_CASE(IRP_MN_QUERY_POWER)

            default: funcName = "????"; break;
        }


        if (dbgVerbose){
            if (isComplete){
                DBGOUT((" < %s for %s(ext=%ph) status=%xh ",
                        funcName,
                        isClientPdo ? "collection" : "device",
                        devExt,
                        status));
            }
            else if (minorFunc == IRP_MN_SET_POWER){
                DBGOUT((" > %s for %s(ext=%ph) type=%s, powerState=%ph",
                        funcName,
                        isClientPdo ? "collection" : "device",
                        devExt,
                        type,
                        powerState));
            }
            else {
                DBGOUT((" > %s for %s(ext=%ph) ",
                        funcName,
                        isClientPdo ? "collection" : "device",
                        devExt));
            }
        }


    }



    #define DBG_MAX_REPORT_RECORDS 0x100
    dbgReportRecord dbgReportRecords[DBG_MAX_REPORT_RECORDS] = { 0 };
    ULONG dbgCurrentReportRecord = 0;

    VOID DbgLogReport(ULONG collectionNumber, ULONG numRecipients, ULONG numPending, ULONG numFailed, PUCHAR report, ULONG reportLength)
    {
        ASSERT(dbgCurrentReportRecord <= DBG_MAX_REPORT_RECORDS);

        if (dbgCurrentReportRecord == DBG_MAX_REPORT_RECORDS){
            RtlZeroMemory(dbgReportRecords, DBG_MAX_REPORT_RECORDS*sizeof(dbgReportRecord));
            dbgCurrentReportRecord = 0;
        }

        dbgReportRecords[dbgCurrentReportRecord].collectionNumber = (UCHAR)collectionNumber;
        dbgReportRecords[dbgCurrentReportRecord].numRecipients = (UCHAR)numRecipients;
        if (reportLength > sizeof(dbgReportRecords[dbgCurrentReportRecord].reportBytes)){
            reportLength = sizeof(dbgReportRecords[dbgCurrentReportRecord].reportBytes);
        }
        RtlCopyMemory((PUCHAR)dbgReportRecords[dbgCurrentReportRecord].reportBytes, report, reportLength);

        dbgCurrentReportRecord++;

        if (dbgVerbose){
            ULONG i;

            DBGOUT(("Report (cltn #%d, %d recipients; %d pending, %d failed):", collectionNumber, numRecipients, numPending, numFailed));
            DbgPrint("'\t report bytes: \t");
            for (i = 0; i < reportLength; i++){
                DbgPrint("%02x ", report[i]);
            }
            DbgPrint("\n");
        }
    }


    VOID DbgLogIoctl(ULONG_PTR fdo, ULONG ioControlCode, ULONG status)
    {
        if (dbgVerbose){
            PCHAR ioctlStr;

            switch (ioControlCode){
                #undef MAKE_CASE
                #define MAKE_CASE(ioctl) case ioctl: ioctlStr = #ioctl; break;

                MAKE_CASE(IOCTL_HID_GET_DRIVER_CONFIG)
                MAKE_CASE(IOCTL_HID_SET_DRIVER_CONFIG)
                MAKE_CASE(IOCTL_HID_GET_POLL_FREQUENCY_MSEC)
                MAKE_CASE(IOCTL_HID_SET_POLL_FREQUENCY_MSEC)
                MAKE_CASE(IOCTL_GET_NUM_DEVICE_INPUT_BUFFERS)
                MAKE_CASE(IOCTL_SET_NUM_DEVICE_INPUT_BUFFERS)
                MAKE_CASE(IOCTL_HID_GET_COLLECTION_INFORMATION)
                MAKE_CASE(IOCTL_HID_GET_COLLECTION_DESCRIPTOR)
                MAKE_CASE(IOCTL_HID_FLUSH_QUEUE)
                MAKE_CASE(IOCTL_HID_SET_FEATURE)
                MAKE_CASE(IOCTL_HID_GET_FEATURE)
                MAKE_CASE(IOCTL_GET_PHYSICAL_DESCRIPTOR)
                MAKE_CASE(IOCTL_HID_GET_HARDWARE_ID)
                MAKE_CASE(IOCTL_HID_GET_MANUFACTURER_STRING)
                MAKE_CASE(IOCTL_HID_GET_PRODUCT_STRING)
                MAKE_CASE(IOCTL_HID_GET_SERIALNUMBER_STRING)
                MAKE_CASE(IOCTL_HID_GET_INDEXED_STRING)
                
                default: ioctlStr = "???"; break;
            }

            DBGOUT(("IOCTL %s (%xh) status=%xh (fdo=%ph)",
                    ioctlStr, ioControlCode, status, fdo));
        }
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidclass\debug.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This file contains definitions related to debugging.

Author:

    Forrest Foltz (forrestf)
    Ervin P.

Revision History:

--*/


#define BAD_POINTER ((PVOID) (ULONG_PTR)-0x50)
#define ISPTR(ptr) ((ptr) && ((ptr) != BAD_POINTER))

#if DBG

    #define DBG_LEADCHAR '\''   // required for kd debugger routing on NT

    #define TRAP                                        \
        {                                               \
            DbgPrint("%cHIDCLASS> Code coverage trap: file %s, line %d \n",  DBG_LEADCHAR, __FILE__, __LINE__ ); \
            DbgBreakPoint();                            \
        }

    #define SS_TRAP                                        \
        {   \
            if (dbgTrapOnSS) {                                         \
                DbgPrint("%cHIDCLASS> Selective suspend trap: file %s, line %d \n",  DBG_LEADCHAR, __FILE__, __LINE__ ); \
                DbgBreakPoint();                            \
            }\
        }
    extern BOOLEAN dbgTrapOnWarn;
    extern BOOLEAN dbgTrapOnSS;
    extern BOOLEAN dbgInfo;
    extern BOOLEAN dbgVerbose;
    extern BOOLEAN dbgSkipSecurity;
    extern BOOLEAN dbgTrapOnHiccup;

    #define DBGWARN(args_in_parens)                                \
        {                                               \
            DbgPrint("%cHIDCLASS> *** WARNING *** (file %s, line %d)\n", DBG_LEADCHAR, __FILE__, __LINE__ ); \
            DbgPrint("%c    > ", DBG_LEADCHAR); \
            DbgPrint args_in_parens; \
            DbgPrint("\n"); \
            if (dbgTrapOnWarn){ \
                DbgBreakPoint();                            \
            } \
        }
    #define DBGERR(args_in_parens)                                \
        {                                               \
            DbgPrint("%cHIDCLASS> *** ERROR *** (file %s, line %d)\n", DBG_LEADCHAR, __FILE__, __LINE__ ); \
            DbgPrint("%c    > ", DBG_LEADCHAR); \
            DbgPrint args_in_parens; \
            DbgPrint("\n"); \
            DbgBreakPoint();                            \
        }
    #define DBGASSERT(check, args_in_parens, trap) \
        { \
            if (!(check)) { \
                if (trap) { \
                    DBGERR(args_in_parens); \
                } else { \
                    DBGWARN(args_in_parens); \
                } \
            } \
        }

    #define DBGSTATE(current, expected, trap) \
        DBGASSERT(current == expected, \
                  ("Expected state %d, got state %d", expected, current), \
                  trap) 
    
    #define DBGSUCCESS(status, trap) \
        DBGASSERT(NT_SUCCESS(status), \
                  ("Not STATUS_SUCCESS, actual status = %x", status), \
                  trap)
    #define DBGOUT(args_in_parens)                                \
        {                                               \
            DbgPrint("%cHIDCLASS> ", DBG_LEADCHAR); \
            DbgPrint args_in_parens; \
            DbgPrint("\n"); \
        }
    #define DBGVERBOSE(args_in_parens) if (dbgVerbose){ DBGOUT(args_in_parens); }
    #define DBGINFO(args_in_parens) if (dbgInfo){ DBGOUT(args_in_parens); }

    typedef struct {
            // exactly 16 bytes long for easy debugger viewing
            PDEVICE_OBJECT devObj;

            #define dbgDevObjRecord_STRINGSIZE 12
            CHAR str[dbgDevObjRecord_STRINGSIZE];
        } dbgDevObjRecord;

    typedef struct {
            // exactly 16 bytes long for easy debugger viewing
            ULONG marker;
            ULONG reportId;
            ULONG type;
            ULONG completed;
        } dbgFeatureRecord;

    typedef struct {
            // exactly 16 bytes long for easy debugger viewing
            ULONG_PTR irpPtr;
            ULONG length;
            ULONG reportId;
            ULONG completed;
        } dbgReadRecord;

    typedef struct {
            // exactly 16 bytes long for easy debugger viewing
            ULONG_PTR irpPtr;
            ULONG func;
            ULONG isForCollectionPdo;
            ULONG status;
        } dbgPnPIrpRecord;

    typedef struct {
            // exactly 16 bytes long for easy debugger viewing
        UCHAR collectionNumber;
        UCHAR numRecipients;
        UCHAR reportBytes[14];
    } dbgReportRecord;

    extern ULONG dbgLastEntry;
    VOID DbgCommonEntryExit(BOOLEAN isEntering);
    VOID DbgRecordDevObj(PDEVICE_OBJECT devObj, PCHAR str);
    VOID DbgRecordReport(ULONG reportId, ULONG controlCode, BOOLEAN isComplete);
    VOID DbgRecordRead(PIRP irp, ULONG length, ULONG reportId, ULONG completed);
    VOID DbgLogIrpMajor(ULONG_PTR irpPtr, ULONG majorFunc, ULONG isForCollectionPdo, ULONG isComplete, ULONG status);
    VOID DbgLogPnpIrp(ULONG_PTR irpPtr, ULONG minorFunc, ULONG isForCollectionPdo, ULONG isComplete, ULONG status);
    VOID DbgLogPowerIrp(PVOID devExt, UCHAR minorFunc, ULONG isClientPdo, ULONG isComplete, PCHAR type, ULONG powerState, ULONG status);
    VOID DbgLogReport(ULONG collectionNumber, ULONG numRecipients, ULONG numPending, ULONG numFailed, PUCHAR report, ULONG reportLength);
    VOID DbgLogIoctl(ULONG_PTR fdo, ULONG ioControlCode, ULONG status);

    #define DBG_COMMON_ENTRY() DbgCommonEntryExit(TRUE);
    #define DBG_COMMON_EXIT() DbgCommonEntryExit(FALSE);
    #define DBG_RECORD_DEVOBJ(devObj, str) DbgRecordDevObj(devObj, str);
    #define DBG_RECORD_REPORT(reportId, controlCode, isComplete) \
                DbgRecordReport(reportId, controlCode, isComplete);
    #define DBG_RECORD_READ(irp, length, reportId, completed) \
                DbgRecordRead(irp, length, reportId, completed);
    #define DBG_LOG_IRP_MAJOR(irp, majorFunc, isForCollectionPdo, isComplete, status) \
                DbgLogIrpMajor((ULONG_PTR)(irp), (ULONG)(majorFunc), (ULONG)(isForCollectionPdo), (ULONG)(isComplete), (ULONG)(status));
    #define DBG_LOG_PNP_IRP(irp, minorFunc, isForCollectionPdo, isComplete, status) \
                DbgLogPnpIrp((ULONG_PTR)(irp), (ULONG)(minorFunc), (ULONG)(isForCollectionPdo), (ULONG)(isComplete), (ULONG)(status));
    #define DBG_LOG_POWER_IRP(devExt, minorFunc, isClientPdo, isComplete, type, powerState, status) \
                DbgLogPowerIrp(devExt, minorFunc, isClientPdo, isComplete, type, powerState, status);
    #define DBG_LOG_REPORT(collectionNumber, numRecipients, numPending, numFailed, report, reportLength) \
                DbgLogReport(collectionNumber, numRecipients, numPending, numFailed, report, reportLength);
    #define DBG_LOG_IOCTL(fdo, ioControlCode, status) \
                DbgLogIoctl((ULONG_PTR)fdo, ioControlCode, status);
    #define RUNNING_DISPATCH() \
        if (KeGetCurrentIrql() != DISPATCH_LEVEL) { \
        KdPrint(( "EX: Pageable code called at IRQL %d\n", KeGetCurrentIrql() )); \
            ASSERT(FALSE); \
            }
#else
    #define DBGSTATE(current, expected, trap)
    #define DBGSUCCESS(status, trap)
    #define DBGASSERT(check, args_in_parens, trap)
    #define DBGWARN(args_in_parens)                               
    #define DBGERR(args_in_parens)                               
    #define DBGOUT(args_in_parens)                               
    #define DBGVERBOSE(args_in_parens) 
    #define DBGINFO(args_in_parens) 
    #define TRAP
    #define SS_TRAP
    #define DBG_COMMON_ENTRY() 
    #define DBG_COMMON_EXIT() 
    #define DBG_RECORD_DEVOBJ(devObj, str)
    #define DBG_RECORD_REPORT(reportId, controlCode, isComplete) 
    #define DBG_RECORD_READ(irp, length, reportId, completed)
    #define DBG_LOG_IRP_MAJOR(irp, majorFunc, isForCollectionPdo, isComplete, status)
    #define DBG_LOG_PNP_IRP(irp, minorFunc, isForCollectionPdo, isComplete, status)
    #define DBG_LOG_POWER_IRP(devExt, minorFunc, isClientPdo, isComplete, type, powerState, status)
    #define DBG_LOG_REPORT(collectionNumber, numRecipients, numPending, numFailed, report, reportLength) 
    #define DBG_LOG_IOCTL(fdo, ioControlCode, status)
    #define RUNNING_DISPATCH()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\filter\hidvalid\validate.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    validate.c

Abstract: Human Input Device (HID) lower filter driver

Author:

    Kenneth D. Ray

Environment:

    Kernel mode

Revision History:


--*/
#include <WDM.H>
#include "hidusage.h"
#include "hidpi.h"
#include "hidclass.h"
#include "validate.H"
#include "validio.h"

struct _HIDV_GLOBALS Global;

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    registryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_OBJECT      deviceObject;
    UNICODE_STRING      uniNtNameString;
    UNICODE_STRING      uniWin32NameString;
    PHIDV_CONTROL_DATA  deviceData;
    ULONG               i;
    PDRIVER_DISPATCH  * dispatch;

    UNREFERENCED_PARAMETER (RegistryPath);
    TRAP ();

    HidV_KdPrint (("Entered the Driver Entry\n"));
    RtlInitUnicodeString (&uniNtNameString, HIDV_FILTER_NTNAME);

    //
    // Create a controling device object.  All control commands to the
    // filter driver come via IOCTL's to this device object.  It lives
    // for the lifetime of the filter driver.
    //

    status = IoCreateDevice (
                 DriverObject,
                 sizeof (HIDV_CONTROL_DATA),
                 &uniNtNameString,
                 FILE_DEVICE_UNKNOWN,
                 0,                     // No standard device characteristics
                 FALSE,                 // This isn't an exclusive device
                 &deviceObject
                 );


    if(!NT_SUCCESS (status)) {
        HidV_KdPrint (("Couldn't create the device\n"));
        return status;
    }
    //
    // Create W32 symbolic link name
    //
    RtlInitUnicodeString (&uniWin32NameString, HIDV_FILTER_SYMNAME);
    status = IoCreateSymbolicLink (&uniWin32NameString, &uniNtNameString);

    if (!NT_SUCCESS(status)) {
        HidV_KdPrint (("Couldn't create the symbolic link\n"));
        IoDeleteDevice (DriverObject->DeviceObject);
        return status;
    }

    HidV_KdPrint (("Initializing\n"));

    deviceData = (PHIDV_CONTROL_DATA) deviceObject->DeviceExtension;
    InitializeListHead (&deviceData->HidDevices);
    KeInitializeSpinLock (&deviceData->Spin);
    deviceData->NumHidDevices = 0;

    Global.ControlObject = deviceObject;

    //
    // Create dispatch points
    //

    for (i=0, dispatch = DriverObject->MajorFunction;
         i <= IRP_MJ_MAXIMUM_FUNCTION;
         i++, dispatch++) {

        *dispatch = HidV_Pass;
    }

    DriverObject->MajorFunction[IRP_MJ_CREATE]         = HidV_CreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = HidV_CreateClose;
//    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = HidV_Ioctl;
//    DriverObject->MajorFunction[IRP_MJ_READ]           = HidV_Read;
//    DriverObject->MajorFunction[IRP_MJ_WRITE]          = HidV_Write;
    DriverObject->MajorFunction[IRP_MJ_PNP]            = HidV_PnP;
    DriverObject->MajorFunction[IRP_MJ_POWER]          = HidV_Power;
    DriverObject->DriverExtension->AddDevice           = HidV_AddDevice;
    DriverObject->DriverUnload                         = HidV_Unload;

    return status;
}


NTSTATUS
HidV_Pass (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The default dispatch routine.  If this filter does not recognize the
    IRP, then it should send it down, unmodified.
    No completion routine is required.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PHIDV_HID_DATA  hidData;
    NTSTATUS        status;

    hidData = (PHIDV_HID_DATA) DeviceObject->DeviceExtension;

    TRAP();

    if(DeviceObject == Global.ControlObject) {
        //
        // This irp was sent to the control device object, which knows not
        // how to deal with this IRP.  It is therefore an error.
        //
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_NOT_SUPPORTED;

    }

    //
    // This IRP was sent to the filter driver.
    // Since we do not know what to do with the IRP, we should pass
    // it on along down the stack.
    //

    HidV_KdPrint (("Passing unknown irp 0x%x, 0x%x",
                   IoGetCurrentIrpStackLocation(Irp)->MajorFunction,
                   IoGetCurrentIrpStackLocation(Irp)->MinorFunction));

    InterlockedIncrement (&hidData->OutstandingIO);
    if (hidData->Removed) {
        status = STATUS_DELETE_PENDING;
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);

    } else {
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (hidData->TopOfStack, Irp);
    }

    if (0 == InterlockedDecrement (&hidData->OutstandingIO)) {
        KeSetEvent (&hidData->RemoveEvent, 0, FALSE);
    }
    return status;
}

NTSTATUS
HidV_CreateClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

   Process the Create and close IRPs sent to this device.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PIO_STACK_LOCATION  stack;
    NTSTATUS            status = STATUS_SUCCESS;
    PHIDV_HID_DATA      hidData;

    HidV_KdPrint (("Create\n"));

    TRAP();

    stack = IoGetCurrentIrpStackLocation (Irp);
    hidData = (PHIDV_HID_DATA) DeviceObject->DeviceExtension;

    if (DeviceObject == Global.ControlObject) {
        //
        // We allow people to blindly access our control object.
        //
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

    }
    //
    // Call the next driver in the routine.  We have no value add
    // for start and stop.
    //
    InterlockedIncrement (&hidData->OutstandingIO);

    if (hidData->Removed) {
        status = (IRP_MJ_CREATE == stack->MajorFunction) ?
                    STATUS_DELETE_PENDING:
                    STATUS_SUCCESS; // aka a close

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);

    } else {
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (hidData->TopOfStack, Irp);
    }

    if (0 == InterlockedDecrement (&hidData->OutstandingIO)) {
        KeSetEvent (&hidData->RemoveEvent, 0, FALSE);
    }
    return status;
}

NTSTATUS
HidV_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Routine Description:

    The PlugPlay subsystem is handing us a brand new PDO, for which we
    (by means of INF registration) have been asked to filter.

    We need to determine if we should attach or not.
    Create a filter device object to attach to the stack
    Initialize that device object
    Return status success.

    Remember: we can NOT actually send ANY IRPS to the given driver stack,
    UNTIL we have received an IRP_MN_START_DEVICE.

Arguments:

    DeviceObject - pointer to a device object.

    PhysicalDeviceObject -  pointer to a device object pointer created by the
                            underlying bus driver.

Return Value:

    NT status code.

--*/
{
    NTSTATUS                status = STATUS_SUCCESS;
    PDEVICE_OBJECT          deviceObject = NULL;
    PHIDV_HID_DATA          hidData;
    PHIDV_CONTROL_DATA      controlData;
    KIRQL                   oldIrql;

#define IS_THIS_OUR_DEVICE(DO) TRUE

    TRAP();
    HidV_KdPrint (("AddDevice\n"));

    controlData = (PHIDV_CONTROL_DATA) Global.ControlObject->DeviceExtension;

    //
    // Inquire about this device to see if we really want to filter.
    // Usually this test will not be performed by filter drivers since
    // they will not have registered via INF to load unless they wanted
    // to actually filter the PDO.
    //
    // Remember that you CANNOT send an IRP to the PDO because it has not
    // been started as of yet, but you can make PlugPlay queries to find
    // out things like hardware, compatible ID's, etc.
    // (IoGetDeviceProperty)
    //
    if (!IS_THIS_OUR_DEVICE(deviceObject)) {
        //
        // This is not a device we want to filter.  (Maybe we placed a general
        // entry in the inf file and we are more picky here.)
        //
        // In this case we do not create a device object,
        // and we do not attach.
        //
        // We DO still return status success, otherwise the device node will
        // fail and the device being attached will not function.
        //
        // We must return STATUS_SUCCESS, otherwise this particular device
        // cannot be used by the system
        //

        return STATUS_SUCCESS;
    }

    //
    // Create a filter device object.
    //

    status = IoCreateDevice (DriverObject,
                             sizeof (HIDV_HID_DATA),
                             NULL, // No Name
                             FILE_DEVICE_UNKNOWN,
                             0,
                             FALSE,
                             &deviceObject);

    if (!NT_SUCCESS (status)) {
        //
        // returning failure here prevents the entire stack from functioning,
        // but most likely the rest of the stack will not be able to create
        // device objects either, so it is still OK.
        //
        return status;
    }

    //
    // Initialize the the device extension.
    //
    hidData = (PHIDV_HID_DATA) deviceObject->DeviceExtension;

    hidData->Started = hidData->Removed = FALSE;
    hidData->Self = deviceObject;
    hidData->PDO = PhysicalDeviceObject;
    hidData->TopOfStack = NULL;
    ExInterlockedInsertHeadList (&controlData->HidDevices,
                                 &hidData->List,
                                 &controlData->Spin);

    KeInitializeEvent(&hidData->RemoveEvent, SynchronizationEvent, FALSE);
    hidData->OutstandingIO = 1; // biassed to 1.  Transition to zero during
                                // remove device means IO is finished.

    hidData->Ppd = NULL;
    hidData->InputButtonCaps = NULL;
    hidData->InputValueCaps = NULL;
    hidData->OutputButtonCaps = NULL;
    hidData->OutputValueCaps = NULL;
    hidData->FeatureButtonCaps = NULL;
    hidData->FeatureValueCaps = NULL;

    //
    // Attach our filter driver to the device stack.
    // the return value of IoAttachDeviceToDeviceStack is the top of the
    // attachment chain.  This is where all the IRPs should be routed.
    //
    // Our filter will send IRPs to the top of the stack and use the PDO
    // for all PlugPlay functions.
    //
    hidData->TopOfStack = IoAttachDeviceToDeviceStack (deviceObject,
                                                       PhysicalDeviceObject);
    //
    // if this attachment fails then top of stack will be null.
    // failure for attachment is an indication of a broken plug play system.
    //
    ASSERT (NULL != hidData->TopOfStack);

    return STATUS_SUCCESS;

#undef IS_THIS_OUR_DEVICE
}



VOID
HidV_Unload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Free all the allocated resources, etc.

Arguments:

    DriverObject - pointer to a driver object.

Return Value:

    VOID.

--*/
{
    PHIDV_CONTROL_DATA  controlData;
    UNICODE_STRING      uniWin32NameString;

    //
    // We should not be unloaded until all the PDOs have been removed from
    // our queue.  The control device object should be the only thing left.
    //
    ASSERT (Global.ControlObject == DriverObject->DeviceObject);
    ASSERT (NULL == Global.ControlObject->NextDevice);
    HidV_KdPrint (("unload\n"));

    //
    // Get rid of our control device object.
    //
    RtlInitUnicodeString (&uniWin32NameString, HIDV_FILTER_SYMNAME);
    IoDeleteSymbolicLink (&uniWin32NameString);
    IoDeleteDevice (DriverObject->DeviceObject);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidclass\device.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    device.c

Abstract

        Resource management routines for devices and collections

Author:

    ervinp

Environment:

    Kernel mode only

Revision History:


--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, HidpStartDevice)
        #pragma alloc_text(PAGE, HidpStartCollectionPDO)
        #pragma alloc_text(PAGE, AllocDeviceResources)
        #pragma alloc_text(PAGE, FreeDeviceResources)
        #pragma alloc_text(PAGE, AllocCollectionResources)
        #pragma alloc_text(PAGE, FreeCollectionResources)
        #pragma alloc_text(PAGE, InitializeCollection)
        #pragma alloc_text(PAGE, HidpCleanUpFdo)
        #pragma alloc_text(PAGE, HidpRemoveDevice)
        #pragma alloc_text(PAGE, HidpRemoveCollection)
#endif

/*
 ********************************************************************************
 *  AllocDeviceResources
 ********************************************************************************
 *
 *
 */
NTSTATUS AllocDeviceResources(FDO_EXTENSION *fdoExt)
{
    ULONG numCollections;
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    /*
     *  This will allocate fdoExt->rawReportDescription
     */
    status = HidpGetDeviceDescriptor(fdoExt);
    if (NT_SUCCESS(status)){

        /*
         *  Ask HIDPARSE to fill in the HIDP_DEVICE_DESC for this device.
         */
        status = HidP_GetCollectionDescription(
                                fdoExt->rawReportDescription,
                                fdoExt->rawReportDescriptionLength,
                                NonPagedPool,
                                &fdoExt->deviceDesc);

        if (NT_SUCCESS(status)){
            fdoExt->devDescInitialized = TRUE;

            numCollections = fdoExt->deviceDesc.CollectionDescLength;
            ASSERT(numCollections);

            fdoExt->classCollectionArray = ALLOCATEPOOL(NonPagedPool, numCollections*sizeof(HIDCLASS_COLLECTION));
            if (!fdoExt->classCollectionArray){
                fdoExt->classCollectionArray = BAD_POINTER;
                status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                RtlZeroMemory(fdoExt->classCollectionArray, numCollections*sizeof(HIDCLASS_COLLECTION));
            }
        }
    }
    else {
        fdoExt->rawReportDescription = BAD_POINTER;
    }

    DBGSUCCESS(status, FALSE)
    return status;
}


/*
 ********************************************************************************
 *  FreeDeviceResources
 ********************************************************************************
 *
 *
 */
VOID FreeDeviceResources(FDO_EXTENSION *fdoExt)
{
    ULONG i;

    PAGED_CODE();

    for (i = 0; i < fdoExt->deviceDesc.CollectionDescLength; i++) {
        FreeCollectionResources(fdoExt, fdoExt->classCollectionArray[i].CollectionNumber);
    }

    /*
     *  Free the stuff returned by HIDPARSE's HidP_GetCollectionDescription.
     */
    if (fdoExt->devDescInitialized){
        HidP_FreeCollectionDescription(&fdoExt->deviceDesc);
        #if DBG
            fdoExt->deviceDesc.CollectionDesc = BAD_POINTER;
            fdoExt->deviceDesc.ReportIDs = BAD_POINTER;
        #endif
    }
    fdoExt->deviceDesc.CollectionDescLength = 0;

    /*
     *  Free the raw report descriptor allocated during START_DEVICE by HidpGetDeviceDescriptor().
     */
    if (ISPTR(fdoExt->rawReportDescription)){
        ExFreePool(fdoExt->rawReportDescription);
    }
    fdoExt->rawReportDescription = BAD_POINTER;

    if (ISPTR(fdoExt->classCollectionArray)){
        ExFreePool(fdoExt->classCollectionArray);
    }
    fdoExt->classCollectionArray = BAD_POINTER;

}


/*
 ********************************************************************************
 *  AllocCollectionResources
 ********************************************************************************
 *
 *
 */
NTSTATUS AllocCollectionResources(FDO_EXTENSION *fdoExt, ULONG collectionNum)
{
    PHIDCLASS_COLLECTION collection;
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    collection = GetHidclassCollection(fdoExt, collectionNum);
    if (collection){
        ULONG descriptorLen;

        descriptorLen = collection->hidCollectionInfo.DescriptorSize;
        if (descriptorLen){
            collection->phidDescriptor = ALLOCATEPOOL(NonPagedPool, descriptorLen);
            if (collection->phidDescriptor){
                status = HidpGetCollectionDescriptor(
                                        fdoExt,
                                        collection->CollectionNumber,
                                        collection->phidDescriptor,
                                        &descriptorLen);
            }
            else {
                collection->phidDescriptor = BAD_POINTER;
                status = STATUS_INSUFFICIENT_RESOURCES;
            }

            if (NT_SUCCESS(status)){
                ULONG i = collection->CollectionIndex;
                ULONG inputLength;

                ASSERT(fdoExt->devDescInitialized);
                inputLength = fdoExt->deviceDesc.CollectionDesc[i].InputLength;
                if (inputLength){
                    if (collection->hidCollectionInfo.Polled){
                        collection->cookedInterruptReportBuf = BAD_POINTER;
                    }
                    else {
                        collection->cookedInterruptReportBuf = ALLOCATEPOOL(NonPagedPool, inputLength);
                        if (!collection->cookedInterruptReportBuf){
                            status = STATUS_INSUFFICIENT_RESOURCES;
                        }
                    }
                    fdoExt->isOutputOnlyDevice = FALSE;
                }
                else {
                    /*
                     *  This is an output-only device (e.g. USB monitor)
                     */
                    DBGINFO(("Zero input length -> output-only device."))
                    collection->cookedInterruptReportBuf = BAD_POINTER;
                }
            }
        }
        else {
            ASSERT(descriptorLen > 0);
            status = STATUS_DEVICE_CONFIGURATION_ERROR;
        }
    }
    else {
        status = STATUS_DEVICE_DATA_ERROR;
    }

    DBGSUCCESS(status, TRUE)
    return status;
}


/*
 ********************************************************************************
 *  FreeCollectionResources
 ********************************************************************************
 *
 *
 */
VOID FreeCollectionResources(FDO_EXTENSION *fdoExt, ULONG collectionNum)
{
    PHIDCLASS_COLLECTION collection;

    PAGED_CODE();

    collection = GetHidclassCollection(fdoExt, collectionNum);
    if (collection){
        if (collection->hidCollectionInfo.Polled){
            if (ISPTR(collection->savedPolledReportBuf)){
                ExFreePool(collection->savedPolledReportBuf);
            }
            collection->savedPolledReportBuf = BAD_POINTER;
        }
        else {
            if (ISPTR(collection->cookedInterruptReportBuf)){
                ExFreePool(collection->cookedInterruptReportBuf);
            }
            else {
                // this is an output-only collection
            }
        }
        collection->cookedInterruptReportBuf = BAD_POINTER;

        if (ISPTR(collection->phidDescriptor)){
            ExFreePool(collection->phidDescriptor);
        }
        collection->phidDescriptor = BAD_POINTER;
    }
    else {
        TRAP;
    }
}


/*
 ********************************************************************************
 *  InitializeCollection
 ********************************************************************************
 *
 *
 */
NTSTATUS InitializeCollection(FDO_EXTENSION *fdoExt, ULONG collectionIndex)
{
    PHIDCLASS_COLLECTION collection;
    ULONG descriptorBufLen;
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT(ISPTR(fdoExt->classCollectionArray));

    collection = &fdoExt->classCollectionArray[collectionIndex];
    RtlZeroMemory(collection, sizeof(HIDCLASS_COLLECTION));

    ASSERT(fdoExt->devDescInitialized);
    collection->CollectionNumber = fdoExt->deviceDesc.CollectionDesc[collectionIndex].CollectionNumber;
    collection->CollectionIndex = collectionIndex;
    InitializeListHead(&collection->FileExtensionList);
    KeInitializeSpinLock(&collection->FileExtensionListSpinLock);
    KeInitializeSpinLock(&collection->powerEventSpinLock);
    KeInitializeSpinLock(&collection->secureReadLock);
    collection->secureReadMode = 0;

    descriptorBufLen = sizeof(HID_COLLECTION_INFORMATION);
    status = HidpGetCollectionInformation(  fdoExt,
                                            collection->CollectionNumber,
                                            &collection->hidCollectionInfo,
                                            &descriptorBufLen);

    DBGSUCCESS(status, TRUE)
    return status;
}


void
HidpGetRemoteWakeEnableState(
    PDO_EXTENSION *pdoExt
    )
{
    HANDLE hKey;
    NTSTATUS status;
    ULONG tmp;
    BOOLEAN wwEnableFound;

    hKey = NULL;
    wwEnableFound = FALSE;

    status = IoOpenDeviceRegistryKey (pdoExt->pdo,
                                      PLUGPLAY_REGKEY_DEVICE,
                                      STANDARD_RIGHTS_ALL,
                                      &hKey);

    if (NT_SUCCESS (status)) {
        UNICODE_STRING  valueName;
        ULONG           length;
        ULONG           value = 0;
        PKEY_VALUE_FULL_INFORMATION fullInfo;

        PAGED_CODE();

        RtlInitUnicodeString (&valueName, HIDCLASS_REMOTE_WAKE_ENABLE);

        length = sizeof (KEY_VALUE_FULL_INFORMATION)
               + valueName.MaximumLength
               + sizeof(value);

        fullInfo = ExAllocatePool (PagedPool, length);

        if (fullInfo) {
            status = ZwQueryValueKey (hKey,
                                      &valueName,
                                      KeyValueFullInformation,
                                      fullInfo,
                                      length,
                                      &length);

            if (NT_SUCCESS (status)) {
                DBGASSERT (sizeof(value) == fullInfo->DataLength,
                           ("Value data wrong length for REmote wake reg value."),
                           TRUE);
                RtlCopyMemory (&value,
                               ((PUCHAR) fullInfo) + fullInfo->DataOffset,
                               fullInfo->DataLength);
                pdoExt->remoteWakeEnabled = (value ? TRUE : FALSE);
            }

            ExFreePool (fullInfo);
        }

        ZwClose (hKey);
        hKey = NULL;
    }
}

WMIGUIDREGINFO HidClassWmiGuidList =
{
    &GUID_POWER_DEVICE_WAKE_ENABLE,
    1,
    0 // wait wake
};

WMIGUIDREGINFO HidClassFdoWmiGuidList = 
{
    &GUID_POWER_DEVICE_ENABLE,
    1,
    0
};

/*
 ********************************************************************************
 *  HidpStartCollectionPDO
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpStartCollectionPDO(FDO_EXTENSION *fdoExt, PDO_EXTENSION *pdoExt, PIRP Irp)
{
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    /*
     *  Initialize the collection only if it's not already initialized.
     *  This is so we don't destroy the FileExtensionList after a STOP/START.
     */
    if (pdoExt->state == COLLECTION_STATE_UNINITIALIZED){
        pdoExt->state = COLLECTION_STATE_INITIALIZED;
    }

    if (NT_SUCCESS(status)){

        PHIDCLASS_COLLECTION collection = GetHidclassCollection(fdoExt, pdoExt->collectionNum);
        if (collection){

            /*
             *  If all collection PDOs for this device FDO are initialized,
             *  figure out the maximum report size and finish starting the device.
             */
            if (AnyClientPDOsInitialized(fdoExt, TRUE)){

                DBGSTATE(fdoExt->state, DEVICE_STATE_START_SUCCESS, FALSE)

                /*
                 *  If this is a polled collection,
                 *  start the background polling loop FOR EACH COLLECTION.
                 *  Otherwise, if it's an ordinary interrupt collection,
                 *  start the ping-pong IRPs for it.
                 */
                if (collection->hidCollectionInfo.Polled){

                    if (HidpSetMaxReportSize(fdoExt)){

                        ULONG i;
                        for (i = 0; i < fdoExt->deviceDesc.CollectionDescLength; i++){
                            PHIDCLASS_COLLECTION ctn;
                            ctn = &fdoExt->classCollectionArray[i];

                            /*
                             *  If one of the collections is polled, they
                             *  should ALL be polled.
                             */
                            ASSERT(ctn->hidCollectionInfo.Polled);

                            ctn->PollInterval_msec = DEFAULT_POLL_INTERVAL_MSEC;

                            /*
                             *  Allocate the buffer for saving the polled device's
                             *  last report.  Allocate one more byte than the max
                             *  report size for the device in case we have to
                             *  prepend a report id byte.
                             */
                            ctn->savedPolledReportBuf = ALLOCATEPOOL(NonPagedPool, fdoExt->maxReportSize+1);
                            if (ctn->savedPolledReportBuf){
                                ctn->polledDataIsStale = TRUE;
                                StartPollingLoop(fdoExt, ctn, TRUE);
                                status = STATUS_SUCCESS;
                            }
                            else {
                                ASSERT(ctn->savedPolledReportBuf);
                                status = STATUS_INSUFFICIENT_RESOURCES;
                            }
                        }
                    }
                }
                else if (fdoExt->isOutputOnlyDevice){
                    /*
                     *  Don't start ping-pong IRPs.
                     */
                }
                else {
                    status = HidpStartAllPingPongs(fdoExt);
                }
            }

            if (NT_SUCCESS(status)) {
                pdoExt->state = COLLECTION_STATE_RUNNING;
                #if DBG
                    collection->Signature = HIDCLASS_COLLECTION_SIG;
                #endif

                /*
                 *  Create the 'file-name' used by clients to open this device.
                 */

                if (!pdoExt->MouseOrKeyboard) {
                    HidpCreateSymbolicLink(pdoExt, pdoExt->collectionNum, TRUE, pdoExt->pdo);
                }

                if (!pdoExt->MouseOrKeyboard &&
                    WAITWAKE_SUPPORTED(fdoExt)) {
                    //
                    // register for the wait wake guid as well
                    //
                    pdoExt->WmiLibInfo.GuidCount = sizeof (HidClassWmiGuidList) /
                                                 sizeof (WMIGUIDREGINFO);
                    ASSERT (1 == pdoExt->WmiLibInfo.GuidCount);

                    //
                    // See if the user has enabled remote wake for the device
                    // PRIOR to registering with WMI.
                    //
                    HidpGetRemoteWakeEnableState(pdoExt);

                    pdoExt->WmiLibInfo.GuidList = &HidClassWmiGuidList;
                    pdoExt->WmiLibInfo.QueryWmiRegInfo = HidpQueryWmiRegInfo;
                    pdoExt->WmiLibInfo.QueryWmiDataBlock = HidpQueryWmiDataBlock;
                    pdoExt->WmiLibInfo.SetWmiDataBlock = HidpSetWmiDataBlock;
                    pdoExt->WmiLibInfo.SetWmiDataItem = HidpSetWmiDataItem;
                    pdoExt->WmiLibInfo.ExecuteWmiMethod = NULL;
                    pdoExt->WmiLibInfo.WmiFunctionControl = NULL;

                    IoWMIRegistrationControl(pdoExt->pdo, WMIREG_ACTION_REGISTER);

                    if (SHOULD_SEND_WAITWAKE(pdoExt)) {
                        HidpCreateRemoteWakeIrp(pdoExt);
                    }
                }

                if (AllClientPDOsInitialized(fdoExt, TRUE)){
                    HidpStartIdleTimeout(fdoExt, TRUE);
                }
            }
        }
        else {
            status = STATUS_DEVICE_DATA_ERROR;
        }
    }

    DBGSUCCESS(status, FALSE)
    return status;
}





/*
 ********************************************************************************
 *  HidpStartDevice
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpStartDevice(PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, PIRP Irp)
{
    FDO_EXTENSION *fdoExt;
    enum deviceState previousState;
    NTSTATUS status;
    ULONG i;

    PAGED_CODE();

    ASSERT(!HidDeviceExtension->isClientPdo);
    fdoExt = &HidDeviceExtension->fdoExt;

    previousState = fdoExt->state;
    fdoExt->state = DEVICE_STATE_STARTING;

    /*
     *  Get the power-state conversion table
     */
    status = HidpQueryDeviceCapabilities(
                        HidDeviceExtension->hidExt.PhysicalDeviceObject,
                        &fdoExt->deviceCapabilities);
    if (NT_SUCCESS(status)){

        /*
         *  Alert the rest of the driver stack that the device is starting.
         */
        IoCopyCurrentIrpStackLocationToNext(Irp);
        status = HidpCallDriverSynchronous(fdoExt->fdo, Irp);

        if (NT_SUCCESS(status)){

            /*
             *  If we're just resuming from STOP,
             *  there's nothing else to do;
             *  otherwise, need to call down the USB stack
             *  for some info and allocate some resources.
             */
            if (previousState == DEVICE_STATE_INITIALIZED){

                status = AllocDeviceResources(fdoExt);
                if (NT_SUCCESS(status)){
                    /*
                     *  Assume this is an output-only device until we start
                     *  a collection-pdo which handles inputs.
                     *  Only set fdoExt->isOutputOnlyDevice on the first start
                     *  not on a subsequent start following a stop.
                     */
                    fdoExt->isOutputOnlyDevice = TRUE;

                    /*  
                     *  Initialize WMI stuff
                     */

                    fdoExt->WmiLibInfo.GuidCount = sizeof(HidClassFdoWmiGuidList) /
                                                   sizeof (WMIGUIDREGINFO);

                    fdoExt->WmiLibInfo.GuidList = &HidClassFdoWmiGuidList;
                    fdoExt->WmiLibInfo.QueryWmiRegInfo = HidpQueryWmiRegInfo;
                    fdoExt->WmiLibInfo.QueryWmiDataBlock = HidpQueryWmiDataBlock;
                    fdoExt->WmiLibInfo.SetWmiDataBlock = HidpSetWmiDataBlock;
                    fdoExt->WmiLibInfo.SetWmiDataItem = HidpSetWmiDataItem;
                    fdoExt->WmiLibInfo.ExecuteWmiMethod = NULL;
                    fdoExt->WmiLibInfo.WmiFunctionControl = NULL;



                    /*
                     *  Allocate all the collection resources before allocating
                     *  the pingpong irps, so that we can set a maximum report
                     *  size.
                     */
                    for (i = 0; i < fdoExt->deviceDesc.CollectionDescLength; i++) {

                        // If one of these fails, we will clean up properly
                        // in the remove routine, so there's no need to
                        // bother cleaning up here.

                        status = InitializeCollection(fdoExt, i);
                        if (!NT_SUCCESS(status)){
                            break;
                        }

                        status = AllocCollectionResources(fdoExt, fdoExt->deviceDesc.CollectionDesc[i].CollectionNumber);
                        if (!NT_SUCCESS(status)){
                            break;
                        }
                    }

                    /*
                     *  We need ot allocate the pingpongs in the fdo start
                     *  routine due to race conditions introduced by selective
                     *  suspend.
                     */
                    if (!fdoExt->isOutputOnlyDevice &&
                        !fdoExt->driverExt->DevicesArePolled) {
                        status = HidpReallocPingPongIrps(fdoExt, MIN_PINGPONG_IRPS);
                    }
                    if (NT_SUCCESS(status)){
                        /*
                         *  We will have to create an array of PDOs, one for each device class.
                         *  The following call will cause NTKERN to call us back with
                         *  IRP_MN_QUERY_DEVICE_RELATIONS and initialize its collection-PDOs.
                         */
                        IoInvalidateDeviceRelations(HidDeviceExtension->hidExt.PhysicalDeviceObject, BusRelations);
                    }
                }
            }
            else if (previousState == DEVICE_STATE_STOPPED){
                //
                // Any request that comes in when we are in low power will be
                // dealt with at that time
                //
                DBGSTATE(fdoExt->prevState, DEVICE_STATE_START_SUCCESS, TRUE)
            }
            else {
                TRAP;
                status = STATUS_DEVICE_CONFIGURATION_ERROR;
            }
        }
    }

    if (NT_SUCCESS(status)){
        fdoExt->state = DEVICE_STATE_START_SUCCESS;

        #if DBG
            {
                ULONG i;

                // Win98 doesn't have good debug extensions
                DBGVERBOSE(("Started fdoExt %ph with %d collections: ", fdoExt, fdoExt->deviceDesc.CollectionDescLength))
                for (i = 0; i < fdoExt->deviceDesc.CollectionDescLength; i++){
                    DBGVERBOSE(("   - collection #%d: (in=%xh,out=%xh,feature=%xh) usagePage %xh, usage %xh ",
                            fdoExt->deviceDesc.CollectionDesc[i].CollectionNumber,
                            fdoExt->deviceDesc.CollectionDesc[i].InputLength,
                            fdoExt->deviceDesc.CollectionDesc[i].OutputLength,
                            fdoExt->deviceDesc.CollectionDesc[i].FeatureLength,
                            fdoExt->deviceDesc.CollectionDesc[i].UsagePage,
                            fdoExt->deviceDesc.CollectionDesc[i].Usage))
                }
            }
        #endif

    }
    else {
        fdoExt->state = DEVICE_STATE_START_FAILURE;
    }

    DBGSUCCESS(status, FALSE)
    return status;
}


VOID
HidpCleanUpFdo(FDO_EXTENSION *fdoExt)
{
    PAGED_CODE();

    if (fdoExt->openCount == 0){
        /*
         *  This is the last CLOSE on an alreay-removed device.
         *
         *  Free resources and the FDO name
         *  (wPdoName that was allocated in HidpAddDevice);
         *
         */
        DequeueFdoExt(fdoExt);
        FreeDeviceResources(fdoExt);
        RtlFreeUnicodeString(&fdoExt->name);
        IoWMIRegistrationControl(fdoExt->fdo, WMIREG_ACTION_DEREGISTER);
        /*
         *  Delete the device-FDO and all collection-PDOs
         *  Don't touch fdoExt after this.
         */
        HidpDeleteDeviceObjects(fdoExt);
    }
}

/*
 ********************************************************************************
 *  HidpRemoveDevice
 ********************************************************************************
 *
 */
NTSTATUS HidpRemoveDevice(FDO_EXTENSION *fdoExt, IN PIRP Irp)
{
    BOOLEAN proceedWithRemove;
    NTSTATUS status;
    PIRP IdleIrp;

    PAGED_CODE();

    /*
     *  All collection-PDOs should have been removed by now,
     *  but we want to verify this.
     *  Only allow removal of this device-FDO if all the
     *  collection-PDOs are removed
     *  (or if they never got created in the first place).
     */
    if (fdoExt->prevState == DEVICE_STATE_START_FAILURE){
        proceedWithRemove = TRUE;
    }
    else if (fdoExt->prevState == DEVICE_STATE_STOPPED){
        /*
         *  If a device fails to initialize, it may get
         *  STOP_DEVICE before being removed, so we want to
         *  go ahead and remove it without calling
         *  AllClientPDOsInitialized, which accesses some
         *  data which may not have been initialized.
         *  In this case we're never checking for the
         *  case that the device was initialized successfully,
         *  then stopped, and then removed without its
         *  collection-PDOs being removed; but this is an
         *  illegal case, so we'll just punt on it.
         */
        proceedWithRemove = TRUE;
    }
    else if (AllClientPDOsInitialized(fdoExt, FALSE)){
        proceedWithRemove = TRUE;
    }
    else {
        /*
         *  This shouldn't happen -- all the collection-PDOs
         *  should have been removed before the device-FDO.
         */
        DBGERR(("State of fdo %x state is %d",fdoExt->fdo,fdoExt->state))
        TRAP;
        proceedWithRemove = FALSE;
    }

    if (proceedWithRemove){
        PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension =
            CONTAINING_RECORD(fdoExt, HIDCLASS_DEVICE_EXTENSION, fdoExt);

        DBGASSERT((fdoExt->state == DEVICE_STATE_REMOVING ||
                   fdoExt->state == DEVICE_STATE_INITIALIZED ||
                   fdoExt->state == DEVICE_STATE_START_FAILURE),
                  ("Device is in incorrect state: %x", fdoExt->state),
                  TRUE)

        if (ISPTR(fdoExt->waitWakeIrp)){
            IoCancelIrp(fdoExt->waitWakeIrp);
            fdoExt->waitWakeIrp = BAD_POINTER;
        }

        HidpCancelIdleNotification(fdoExt, TRUE);

        if (ISPTR(fdoExt->idleNotificationRequest)) {
            IoFreeIrp(fdoExt->idleNotificationRequest);
            fdoExt->idleNotificationRequest = BAD_POINTER;
        }

        while (IdleIrp = DequeuePowerDelayedIrp(fdoExt)) {
            IdleIrp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
            IoCompleteRequest(IdleIrp, IO_NO_INCREMENT);
        }

        DestroyPingPongs(fdoExt);

        /*
         *  Note: THE ORDER OF THESE ACTIONS IS VERY CRITICAL
         */

        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
        status = HidpCallDriver(fdoExt->fdo, Irp);

        fdoExt->state = DEVICE_STATE_REMOVED;

        DerefDriverExt(fdoExt->driverExt->MinidriverObject);
        fdoExt->driverExt = BAD_POINTER;

        /*
         *  After Detach we can no longer send IRPS to this device
         *  object as it will be GONE!
         */
        IoDetachDevice(HidDeviceExtension->hidExt.NextDeviceObject);

        /*
         *  If all client handles on this device have been closed,
         *  destroy the objects and our context for it;
         *  otherwise, we'll do this when the last client closes
         *  their handle.
         *
         * On NT we can only get here if all our creates have been closed, so
         * this is unnecessary, but on Win9x, a remove can be sent with valid
         * opens against the stack.
         *
         *  Don't touch fdoExt after this.
         */
        HidpCleanUpFdo(fdoExt);
    }
    else {
        status = STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    DBGSUCCESS(status, FALSE)
    return status;
}


/*
 ********************************************************************************
 *  HidpRemoveCollection
 ********************************************************************************
 *
 */
VOID HidpRemoveCollection(FDO_EXTENSION *fdoExt, PDO_EXTENSION *pdoExt, IN PIRP Irp)
{

    PAGED_CODE();

    //
    // This pdo is no longer available as it has been removed.
    // It should still be returned for each Query Device Relations
    // IRPS to the HID bus, but it itself should respond to all
    // IRPS with STATUS_DELETE_PENDING.
    //
    if (pdoExt->prevState == COLLECTION_STATE_UNINITIALIZED ||  // for started pdos
        pdoExt->state == COLLECTION_STATE_UNINITIALIZED){       // For unstarted pdos
        pdoExt->state = COLLECTION_STATE_UNINITIALIZED;
        DBGVERBOSE(("HidpRemoveCollection: collection uninitialized."))
    }
    else {
        ULONG ctnIndx = pdoExt->collectionIndex;
        PHIDCLASS_COLLECTION collection = &fdoExt->classCollectionArray[ctnIndx];
        ULONG numReportIDs = fdoExt->deviceDesc.ReportIDsLength;
        PIRP remoteWakeIrp;

        if (!pdoExt->MouseOrKeyboard &&
            WAITWAKE_SUPPORTED(fdoExt)) {
            //
            // Unregister for remote wakeup.
            //
            IoWMIRegistrationControl (pdoExt->pdo, WMIREG_ACTION_DEREGISTER);
        }

        remoteWakeIrp = (PIRP)
            InterlockedExchangePointer(&pdoExt->remoteWakeIrp, NULL);

        if (remoteWakeIrp) {
            IoCancelIrp(remoteWakeIrp);
        }

        pdoExt->state = COLLECTION_STATE_UNINITIALIZED;

         /*
         *  Destroy this collection.
         *  This will also abort all pending reads on this collection-PDO.
         */
        HidpDestroyCollection(fdoExt, collection);
    }

    DBGVERBOSE(("HidpRemoveCollection: removed pdo %ph (refCount=%xh)", pdoExt->pdo, (ULONG)(*(((PUCHAR)pdoExt->pdo)-0x18))))
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidclass\fdoext.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    fdoext.c

Abstract

   
Author:

    Ervin P.

Environment:

    Kernel mode only

Revision History:


--*/

#include "pch.h"

FDO_EXTENSION *allFdoExtensions = NULL;
KSPIN_LOCK allFdoExtensionsSpinLock;


/*
 ********************************************************************************
 *  EnqueueFdoExt
 ********************************************************************************
 *
 *  Note: this function cannot be pageable because it
 *        acquires a spinlock.
 */
VOID EnqueueFdoExt(FDO_EXTENSION *fdoExt)
{
    KIRQL oldIrql;
    static BOOLEAN firstCall = TRUE;

    if (firstCall){
        KeInitializeSpinLock(&allFdoExtensionsSpinLock);
        firstCall = FALSE;
    }

    KeAcquireSpinLock(&allFdoExtensionsSpinLock, &oldIrql);

    ASSERT(!fdoExt->nextFdoExt);
    fdoExt->nextFdoExt = allFdoExtensions;
    allFdoExtensions = fdoExt;

    KeReleaseSpinLock(&allFdoExtensionsSpinLock, oldIrql);
}


/*
 ********************************************************************************
 *  DequeueFdoExt
 ********************************************************************************
 *
 *  Note: this function cannot be pageable because it
 *        acquires a spinlock.
 *
 */
VOID DequeueFdoExt(FDO_EXTENSION *fdoExt)
{
    FDO_EXTENSION *thisFdoExt;
    KIRQL oldIrql;

    KeAcquireSpinLock(&allFdoExtensionsSpinLock, &oldIrql);

    if (fdoExt == allFdoExtensions){
        allFdoExtensions = fdoExt->nextFdoExt;
    }
    else {
        for (thisFdoExt = allFdoExtensions; thisFdoExt; thisFdoExt = thisFdoExt->nextFdoExt){
            if (thisFdoExt->nextFdoExt == fdoExt){
                thisFdoExt->nextFdoExt = fdoExt->nextFdoExt;
                break;
            }
        }
    }

    fdoExt->nextFdoExt = NULL;

    KeReleaseSpinLock(&allFdoExtensionsSpinLock, oldIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidclass\idle.c ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

    idle.c

Abstract

   
Author:

    Doron H.

Environment:

    Kernel mode only

Revision History:


--*/

#ifdef ALLOC_PRAGMA
#endif

#include "pch.h"

KSPIN_LOCK idleDeviceListSpinLock;
LIST_ENTRY idleDeviceList;
KTIMER idleTimer;
KDPC idleTimerDpc;
LONG numIdleDevices = 0;

#define HID_IDLE_SCAN_INTERVAL 1

typedef struct _HID_IDLE_DEVICE_INFO {
    LIST_ENTRY entry;
    ULONG idleCount;
    ULONG idleTime;
    PDEVICE_OBJECT device;
    BOOLEAN tryAgain;
} HID_IDLE_DEVICE_INFO, *PHID_IDLE_DEVICE_INFO;

VOID
HidpIdleTimerDpcProc(
                    IN PKDPC Dpc,
                    IN PDEVICE_OBJECT DeviceObject,
                    IN PVOID Context1,
                    IN PVOID Context2
                    );

NTSTATUS
HidpRegisterDeviceForIdleDetection(
                                  PDEVICE_OBJECT DeviceObject,
                                  ULONG IdleTime,
                                  PULONG *IdleTimeout
                                  )
{
    PHID_IDLE_DEVICE_INFO info = NULL;
    KIRQL irql;
    PLIST_ENTRY entry = NULL;
    static BOOLEAN firstCall = TRUE;
    BOOLEAN freeInfo = FALSE;
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    if (firstCall) {
        KeInitializeSpinLock(&idleDeviceListSpinLock);
        InitializeListHead(&idleDeviceList);
        KeInitializeTimerEx(&idleTimer, NotificationTimer);
        KeInitializeDpc(&idleTimerDpc, HidpIdleTimerDpcProc, NULL);
        firstCall = FALSE;
    }

    KeAcquireSpinLock(&idleDeviceListSpinLock, &irql);
    if (IdleTime == 0) {
        ASSERT(numIdleDevices >= 0);

        //
        // Remove the device from the list
        //
        for (entry = idleDeviceList.Flink;
            entry != &idleDeviceList;
            entry = entry->Flink) {

            info = CONTAINING_RECORD(entry, HID_IDLE_DEVICE_INFO, entry);
            if (info->device == DeviceObject) {
                DBGINFO(("Remove device idle on fdo 0x%x", DeviceObject));
                numIdleDevices--;
                ObDereferenceObject(DeviceObject);
                RemoveEntryList(entry);
                status = STATUS_SUCCESS;
                ExFreePool(info);
                *IdleTimeout = BAD_POINTER;
                break;
            }
        }

        if (NT_SUCCESS(status)) {
            //
            // If there are no more idle devices we can stop the timer
            //
            if (IsListEmpty(&idleDeviceList)) {
                ASSERT(numIdleDevices == 0);
                DBGINFO(("Idle detection list empty. Stopping timer."));
                KeCancelTimer(&idleTimer);
            }
        }
    } else {
        LARGE_INTEGER scanTime;
        BOOLEAN empty = FALSE;

        DBGINFO(("Register for device idle on fdo 0x%x", DeviceObject));
        
        //
        // Check if we've already started this.
        //
        status = STATUS_SUCCESS;
        for (entry = idleDeviceList.Flink;
            entry != &idleDeviceList;
            entry = entry->Flink) {

            info = CONTAINING_RECORD(entry, HID_IDLE_DEVICE_INFO, entry);
            if (info->device == DeviceObject) {
                DBGWARN(("Device already registered for idle detection. Ignoring."));
                ASSERT(*IdleTimeout == &(info->idleCount));
                status = STATUS_UNSUCCESSFUL;
            }
        }

        if (NT_SUCCESS(status)) {
            info = (PHID_IDLE_DEVICE_INFO)
            ALLOCATEPOOL(NonPagedPool, sizeof(HID_IDLE_DEVICE_INFO));

            if (info != NULL) {
                ObReferenceObject(DeviceObject);

                RtlZeroMemory(info, sizeof(HID_IDLE_DEVICE_INFO));
                info->device = DeviceObject;
                info->idleTime = IdleTime;

                if (IsListEmpty(&idleDeviceList)) {
                    empty = TRUE;
                }
                InsertTailList(&idleDeviceList, &info->entry);

                *IdleTimeout = &(info->idleCount);

                numIdleDevices++;

                if (empty) {
                    DBGINFO(("Starting idle detection timer for first time."));
                    //
                    // Turn on idle detection
                    //
                    scanTime = RtlConvertLongToLargeInteger(-10*1000*1000 * HID_IDLE_SCAN_INTERVAL);

                    KeSetTimerEx(&idleTimer,
                                 scanTime,
                                 HID_IDLE_SCAN_INTERVAL*1000,    // call wants milliseconds
                                 &idleTimerDpc);
                }
            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }
    
    KeReleaseSpinLock(&idleDeviceListSpinLock, irql);

    return status; 
}

VOID
HidpIdleTimerDpcProc(
                    IN PKDPC Dpc,
                    IN PDEVICE_OBJECT DeviceObject,
                    IN PVOID Context1,
                    IN PVOID Context2
                    )
{
    PLIST_ENTRY entry;
    PHID_IDLE_DEVICE_INFO info;
    ULONG oldCount;
    KIRQL irql1, irql2;
    BOOLEAN ok = FALSE;
    PFDO_EXTENSION fdoExt;
    LONG idleState;

    UNREFERENCED_PARAMETER(Context1);
    UNREFERENCED_PARAMETER(Context2);

    KeAcquireSpinLock(&idleDeviceListSpinLock, &irql1);

    entry = idleDeviceList.Flink;
    while (entry != &idleDeviceList) {
        info = CONTAINING_RECORD(entry, HID_IDLE_DEVICE_INFO, entry);
        fdoExt = &((PHIDCLASS_DEVICE_EXTENSION) info->device->DeviceExtension)->fdoExt;
        KeAcquireSpinLock(&fdoExt->idleNotificationSpinLock, &irql2);
        
        oldCount = InterlockedIncrement(&info->idleCount); 

        if (info->tryAgain || ((oldCount+1) == info->idleTime)) {
            PIO_WORKITEM item = IoAllocateWorkItem(info->device);
            
            if (item) {
                info->tryAgain = FALSE;
                
                SS_TRAP;
                KeResetEvent(&fdoExt->idleDoneEvent);
                
                ASSERT(fdoExt->idleState != IdleIrpSent);
                ASSERT(fdoExt->idleState != IdleCallbackReceived);
                ASSERT(fdoExt->idleState != IdleComplete);
                idleState = InterlockedCompareExchange(&fdoExt->idleState, 
                                                       IdleIrpSent,
                                                       IdleWaiting);
                if (fdoExt->idleState == IdleIrpSent) {
                    ok = TRUE;
                } else {
                    // We shouldn't get here if we're disabled.
                    ASSERT(idleState != IdleDisabled);
                    DBGWARN(("Resetting timer to zero for fdo %x in state %x",
                             info->device,fdoExt->idleState));
                    info->idleCount = 0;
                }
                
                if (ok) {
                    IoQueueWorkItem(item,
                                    HidpIdleTimeWorker,
                                    DelayedWorkQueue,
                                    item);
                } else {
                    IoFreeWorkItem(item);
                }
            } else {
                info->tryAgain = TRUE;
            }
        }
        KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql2);

        entry = entry->Flink;
    }

    KeReleaseSpinLock(&idleDeviceListSpinLock, irql1);
}

NTSTATUS
HidpIdleNotificationRequestComplete(
                                   PDEVICE_OBJECT DeviceObject,
                                   PIRP Irp,
                                   PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension
                                   )
{
    FDO_EXTENSION *fdoExt;
    PDO_EXTENSION *pdoExt;
    KIRQL irql;
    LONG prevIdleState = IdleWaiting;
    POWER_STATE powerState;
    NTSTATUS status = Irp->IoStatus.Status;
    ULONG count, i;
    PIRP delayedIrp;
    LIST_ENTRY dequeue, *entry;
    PIO_STACK_LOCATION stack;

    //
    // DeviceObject is NULL because we sent the irp
    //
    UNREFERENCED_PARAMETER(DeviceObject);

    fdoExt = &HidDeviceExtension->fdoExt;
    
    DBGVERBOSE(("Idle irp completed status 0x%x for fdo 0x%x",
                status, fdoExt->fdo)); 
    
    //
    // Cancel any outstanding WW irp we queued up for the exclusive purpose
    // of selective suspend.
    //
    KeAcquireSpinLock(&fdoExt->collectionWaitWakeIrpQueueSpinLock, &irql);
    if (IsListEmpty(&fdoExt->collectionWaitWakeIrpQueue) &&
        HidpIsWaitWakePending(fdoExt, FALSE)) {
        if (ISPTR(fdoExt->waitWakeIrp)) {
            DBGINFO(("Cancelling the WW irp that was queued for idle."))
            IoCancelIrp(fdoExt->waitWakeIrp);
        } else {
            TRAP;
        }
    }
    KeReleaseSpinLock(&fdoExt->collectionWaitWakeIrpQueueSpinLock, irql);
    
    switch (status) {
    case STATUS_SUCCESS:
        // we successfully idled the device we are either now back in D0, 
        // or will be very soon.
        KeAcquireSpinLock(&fdoExt->idleNotificationSpinLock, &irql);
        if (fdoExt->devicePowerState == PowerDeviceD0) {
            prevIdleState = InterlockedCompareExchange(&fdoExt->idleState,
                                                       IdleWaiting,
                                                       IdleComplete);
            DBGASSERT(fdoExt->idleState == IdleWaiting,
                      ("IdleCompletion, prev state not IdleWaiting, actually %x",prevIdleState),
                      TRUE);
            if (ISPTR(fdoExt->idleTimeoutValue)) {
                InterlockedExchange(fdoExt->idleTimeoutValue, 0);
            }
        }
        KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql);
        break;

    case STATUS_INVALID_DEVICE_REQUEST:
    case STATUS_NOT_SUPPORTED:
        // the bus below does not support idle timeouts, forget about it
        DBGINFO(("Bus does not support idle. Removing for fdo %x",
                 fdoExt->fdo));

        //
        // Call to cancel idle notification. 
        //
        ASSERT(fdoExt->idleState == IdleIrpSent);
        ASSERT(fdoExt->devicePowerState == PowerDeviceD0);
        fdoExt->idleState = IdleWaiting;
        HidpCancelIdleNotification(fdoExt, TRUE);
        KeSetEvent(&fdoExt->idleDoneEvent, 0, FALSE);

        break;

        // we cancelled the request
    case STATUS_CANCELLED:
        DBGINFO(("Idle Irp completed cancelled"));

        // transitioned into a power state where we could not idle out
    case STATUS_POWER_STATE_INVALID:

        // oops, there was already a request in the bus below us
    case STATUS_DEVICE_BUSY:

    default:
        //
        // We must reset ourselves.
        //
        
        KeAcquireSpinLock(&fdoExt->idleNotificationSpinLock, &irql);
        
        DBGASSERT((fdoExt->idleState != IdleWaiting),
                  ("Idle completion, previous state was already waiting."),
                  FALSE);
        
        prevIdleState = fdoExt->idleState;
        
        if (prevIdleState == IdleIrpSent) {
            ASSERT(fdoExt->devicePowerState == PowerDeviceD0);
            fdoExt->idleCancelling = FALSE;
            if (ISPTR(fdoExt->idleTimeoutValue) &&
                prevIdleState != IdleComplete) {
                InterlockedExchange(fdoExt->idleTimeoutValue, 0);
            }
            InterlockedExchange(&fdoExt->idleState, IdleWaiting);
        }
        
        KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql);

        if (prevIdleState == IdleComplete) {
            //
            // We now have to power up the stack.
            //
            DBGINFO(("Fully idled. Must power up stack."))
            powerState.DeviceState = PowerDeviceD0;
            PoRequestPowerIrp(((PHIDCLASS_DEVICE_EXTENSION) fdoExt->fdo->DeviceExtension)->hidExt.PhysicalDeviceObject,
                              IRP_MN_SET_POWER,
                              powerState,
                              HidpDelayedPowerPoRequestComplete,
                              fdoExt,
                              NULL);
        } else if (prevIdleState == IdleIrpSent) {
            //
            // Dequeue any enqueued irps and send them on their way.
            // This is for the case where we didn't make it to suspend, but 
            // enqueued irps anyways. I.e. using mouse, set caps lock on 
            // ps/2 keybd causing write to be sent to usb kbd.
            //
            if (fdoExt->devicePowerState == PowerDeviceD0) {
                for (i = 0; i < fdoExt->deviceRelations->Count; i++) {
                    pdoExt = &((PHIDCLASS_DEVICE_EXTENSION) fdoExt->deviceRelations->Objects[i]->DeviceExtension)->pdoExt;
                    //
                    // Resend all power delayed IRPs
                    //
                    count = DequeueAllPdoPowerDelayedIrps(pdoExt, &dequeue);
                    DBGVERBOSE(("dequeued %d requests\n", count));

                    while (!IsListEmpty(&dequeue)) {
                        entry = RemoveHeadList(&dequeue);
                        delayedIrp = CONTAINING_RECORD(entry, IRP, Tail.Overlay.ListEntry);
                        stack = IoGetCurrentIrpStackLocation(delayedIrp);

                        DBGINFO(("resending %x to pdo %x in idle completion.\n", delayedIrp, pdoExt->pdo));

                        pdoExt->pdo->DriverObject->
                            MajorFunction[stack->MajorFunction]
                                (pdoExt->pdo, delayedIrp);
                    }
                }
            }
            /*
             *  We cancelled this IRP.
             *  REGARDLESS of whether this IRP was actually completed by
             *  the cancel routine or not
             *  (i.e. regardless of the completion status)
             *  set this event so that stuff can exit.
             *  Don't touch the irp again.
             */
            DBGINFO(("Set done event."))
            KeSetEvent(&fdoExt->idleDoneEvent, 0, FALSE);
            return STATUS_MORE_PROCESSING_REQUIRED;
        }
        
        break;
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
HidpIdleTimeWorker(
                  PDEVICE_OBJECT DeviceObject,
                  PIO_WORKITEM Item
                  )
{
    FDO_EXTENSION *fdoExt;
    PIO_STACK_LOCATION stack;
    PIRP irp = NULL, irpToCancel = NULL;
    NTSTATUS status;
    KIRQL irql;

    fdoExt = &((PHIDCLASS_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->fdoExt;

    DBGINFO(("fdo 0x%x can idle out", fdoExt->fdo));

    irp = fdoExt->idleNotificationRequest;
    ASSERT(ISPTR(irp));

    if (ISPTR(irp)) {
        USHORT  PacketSize;
        CCHAR   StackSize;
        UCHAR   AllocationFlags;

        // Did anyone forget to pull their cancel routine?
        ASSERT(irp->CancelRoutine == NULL) ;

        AllocationFlags = irp->AllocationFlags;
        StackSize = irp->StackCount;
        PacketSize =  IoSizeOfIrp(StackSize);
        IoInitializeIrp(irp, PacketSize, StackSize);
        irp->AllocationFlags = AllocationFlags;
        
        irp->Cancel = FALSE;
        irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        
        stack = IoGetNextIrpStackLocation(irp);
        stack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        stack->Parameters.DeviceIoControl.IoControlCode = IOCTL_HID_SEND_IDLE_NOTIFICATION_REQUEST;
        stack->Parameters.DeviceIoControl.InputBufferLength = sizeof(fdoExt->idleCallbackInfo);
        stack->Parameters.DeviceIoControl.Type3InputBuffer = (PVOID) &(fdoExt->idleCallbackInfo); 

        //
        // Hook a completion routine for when the device completes.
        //
        IoSetCompletionRoutine(irp,
                               HidpIdleNotificationRequestComplete,
                               DeviceObject->DeviceExtension,
                               TRUE,
                               TRUE,
                               TRUE);

        //
        // The hub will fail this request if the hub doesn't support selective
        // suspend.  By returning FALSE we remove ourselves from the 
        //
        status = HidpCallDriver(fdoExt->fdo, irp);
        
        KeAcquireSpinLock(&fdoExt->idleNotificationSpinLock, &irql);

        if (status == STATUS_PENDING &&
            fdoExt->idleCancelling) {
            irpToCancel = irp;
        }

        KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql);

        if (irpToCancel) {
            IoCancelIrp(irpToCancel);
        }

    }

    IoFreeWorkItem(Item);
}

BOOLEAN HidpStartIdleTimeout(
    FDO_EXTENSION   *fdoExt,
    BOOLEAN         DeviceStart
    )
{
    DEVICE_POWER_STATE deviceWakeableState = PowerDeviceUnspecified;
    USHORT deviceUsagePage, deviceUsage;
    USHORT usagePage, usage;
    ULONG iList, iDesc, iPdo;
    HANDLE hKey;
    NTSTATUS status;
    ULONG enabled;
    ULONG length;
    UNICODE_STRING s;
    KEY_VALUE_PARTIAL_INFORMATION partial;
    PHID_IDLE_DEVICE_INFO info;
    PLIST_ENTRY entry = NULL;
    PULONG idleTimeoutAddress;

    if (fdoExt->idleState != IdleDisabled) {
        //
        // We're already registered for idle detection.
        //
        return TRUE;
    }
    
    //
    // If we can't wake the machine, forget about it
    //
    if (fdoExt->deviceCapabilities.SystemWake == PowerSystemUnspecified) {
        DBGVERBOSE(("Can't wake the system with these caps! Disabling SS."));
        return FALSE;
    }

    //
    // If D1Latency, D2Latency, D3Latency are ever filled in, perhaps we should
    // let these values help us determine which low power state to go to
    //
    deviceWakeableState = fdoExt->deviceCapabilities.DeviceWake;
    DBGVERBOSE(("DeviceWakeableState is D%d", deviceWakeableState-1));

    if (deviceWakeableState == PowerDeviceUnspecified) {
        DBGVERBOSE(("Due to devcaps, can't idle wake from any state! Disabling SS."));
        return FALSE;  
    }

    if (DeviceStart) {
        //
        // Open the registry and make sure that the 
        // SelectiveSuspendEnabled value is set to 1.
        //
        
        // predispose to failure.
        fdoExt->idleEnabledInRegistry = FALSE;
        if (!NT_SUCCESS(IoOpenDeviceRegistryKey(fdoExt->collectionPdoExtensions[0]->hidExt.PhysicalDeviceObject,
                                                PLUGPLAY_REGKEY_DEVICE,
                                                STANDARD_RIGHTS_READ,
                                                &hKey))) {
            DBGVERBOSE(("Couldn't open device key to check for idle timeout value. Disabling SS."));
            return FALSE;
        }

        RtlInitUnicodeString(&s, HIDCLASS_SELECTIVE_SUSPEND_ON);
        status = ZwQueryValueKey(hKey, 
                                 &s, 
                                 KeyValuePartialInformation,
                                 &partial,
                                 sizeof(KEY_VALUE_PARTIAL_INFORMATION),
                                 &length);
        if (!NT_SUCCESS(status)) {
            DBGVERBOSE(("ZwQueryValueKey failed for fdo %x. Default to SS turned on if enabled.", fdoExt->fdo));
            fdoExt->idleEnabled = TRUE;
            
        } else if (!partial.Data[0]) {
            DBGINFO(("Selective suspend is not turned on for this device."));
            fdoExt->idleEnabled = FALSE;
        } else {
            fdoExt->idleEnabled = TRUE;
        }

        RtlInitUnicodeString(&s, HIDCLASS_SELECTIVE_SUSPEND_ENABLED);
        status = ZwQueryValueKey(hKey, 
                                 &s, 
                                 KeyValuePartialInformation,
                                 &partial,
                                 sizeof(KEY_VALUE_PARTIAL_INFORMATION),
                                 &length);


        ZwClose(hKey);

        if (!NT_SUCCESS(status)) {
            DBGVERBOSE(("ZwQueryValueKey failed for fdo %x. Disabling SS.", fdoExt->fdo));
            return FALSE;
        }

       

        DBGASSERT(partial.Type == REG_BINARY, ("Registry key wrong type"), FALSE);

        if (!partial.Data[0]) {
            DBGINFO(("Selective suspend is not enabled for this device in the hive. Disabling SS."));
            return FALSE;
        }
        fdoExt->idleEnabledInRegistry = TRUE;

        status = IoWMIRegistrationControl(fdoExt->fdo,
                                          WMIREG_ACTION_REGISTER);                                                       
        
        ASSERT(NT_SUCCESS(status));
    }

    if (!fdoExt->idleEnabledInRegistry || !fdoExt->idleEnabled) {
        return FALSE;
    }

    DBGVERBOSE(("There are %d PDOs on FDO 0x%x",
                fdoExt->deviceDesc.CollectionDescLength,
                fdoExt));

    ASSERT(ISPTR(fdoExt->deviceRelations));
      
    //
    // OK, we can selectively suspend this device. 
    // Allocate and initialize everything, then register.
    //
    fdoExt->idleNotificationRequest = IoAllocateIrp(fdoExt->fdo->StackSize, FALSE);
    if (fdoExt->idleNotificationRequest == NULL) {
        DBGWARN(("Failed to allocate idle notification irp"))
        return FALSE;
    }

    status = HidpRegisterDeviceForIdleDetection(fdoExt->fdo, 
                                                HID_DEFAULT_IDLE_TIME,
                                                &fdoExt->idleTimeoutValue);
    if (STATUS_SUCCESS == status) {
        //
        // We have successfully registered all device for idle detection,
        // send a WW irp down the FDO stack
        //
        fdoExt->idleState = IdleWaiting;
        return TRUE;
    } else {
        //
        // We're already registered? Or did the alloc fail?
        //
        DBGSUCCESS(status, TRUE);
        return FALSE;
    }
}

NTSTATUS
HidpCheckIdleState(
    PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension,
    PIRP Irp
    )
{
    KIRQL irql;
    LONG idleState;
    PFDO_EXTENSION fdoExt = &HidDeviceExtension->pdoExt.deviceFdoExt->fdoExt;
    NTSTATUS status = STATUS_SUCCESS;
    BOOLEAN cancelIdleIrp = FALSE;
    
    ASSERT(HidDeviceExtension->isClientPdo);
    KeAcquireSpinLock(&fdoExt->idleNotificationSpinLock, &irql);

    if (fdoExt->idleState == IdleWaiting ||
        fdoExt->idleState == IdleDisabled) {
        //
        // Done.
        //
        if (ISPTR(fdoExt->idleTimeoutValue) &&
            fdoExt->idleState == IdleWaiting) {
            InterlockedExchange(fdoExt->idleTimeoutValue, 0);
        }
        KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql);
        return STATUS_SUCCESS;
    }

    DBGINFO(("CheckIdleState on fdo %x", fdoExt->fdo))

    status = EnqueuePowerDelayedIrp(HidDeviceExtension, Irp);
    
    if (STATUS_PENDING != status) {
        KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql);
        return status;
    }
    
    fdoExt->idleCancelling = TRUE;

    idleState = fdoExt->idleState;
    
    switch (idleState) {
    case IdleWaiting:
        // bugbug.
        // How'd this happen? We already tried this...
        TRAP;
        break;
    case IdleIrpSent:
    case IdleCallbackReceived:
    case IdleComplete:
        cancelIdleIrp = TRUE;
        break;

    case IdleDisabled:
        //
        // Shouldn't get here.
        //
        DBGERR(("Already disabled."));
    }

    KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql);

    if (cancelIdleIrp) {
        IoCancelIrp(fdoExt->idleNotificationRequest);
    }

    return status;
}

VOID
HidpSetDeviceBusy(PFDO_EXTENSION fdoExt)
{
    KIRQL irql;
    BOOLEAN cancelIdleIrp = FALSE;
    LONG idleState;

    KeAcquireSpinLock(&fdoExt->idleNotificationSpinLock, &irql);

    if (fdoExt->idleState == IdleWaiting ||
        fdoExt->idleState == IdleDisabled ||
        fdoExt->idleCancelling) {
        if (ISPTR(fdoExt->idleTimeoutValue) &&
            fdoExt->idleState == IdleWaiting) {
            InterlockedExchange(fdoExt->idleTimeoutValue, 0);
            fdoExt->idleCancelling = FALSE;
        }
        //
        // Done.
        //
        KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql);
        return;
    }

    fdoExt->idleCancelling = TRUE;

    DBGVERBOSE(("HidpSetDeviceBusy on fdo %x", fdoExt->fdo))
    
    idleState = fdoExt->idleState;
    
    switch (idleState) {
    case IdleWaiting:
        // bugbug.
        // How'd this happen? We already tried this...
        TRAP;
        break;
    case IdleIrpSent:
    case IdleCallbackReceived:
    case IdleComplete:
        cancelIdleIrp = TRUE;
        break;

    case IdleDisabled:
        //
        // Shouldn't get here.
        //
        DBGERR(("Already disabled."));
    }

    KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql);

    if (cancelIdleIrp) {
        IoCancelIrp(fdoExt->idleNotificationRequest);
    }
}

VOID
HidpCancelIdleNotification(
    PFDO_EXTENSION fdoExt,
    BOOLEAN removing            // Whether this is happening on a remove device
    )
{
    KIRQL irql;
    BOOLEAN cancelIdleIrp = FALSE;
    LONG idleState;
    NTSTATUS status;
    
    DBGVERBOSE(("Cancelling idle notification for fdo 0x%x", fdoExt->fdo));
    
    status = HidpRegisterDeviceForIdleDetection(fdoExt->fdo, 0, &fdoExt->idleTimeoutValue);
    
    KeAcquireSpinLock(&fdoExt->idleNotificationSpinLock, &irql);
    
    InterlockedCompareExchange(&fdoExt->idleState, 
                               IdleDisabled,
                               IdleWaiting);
    if (fdoExt->idleState == IdleDisabled) {
        DBGVERBOSE(("Was waiting or already disabled. Exitting."))
        //
        // Done.
        //
        KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql);
        return;
    }

    fdoExt->idleCancelling = TRUE;
    
    idleState = fdoExt->idleState;

    DBGINFO(("Wait routine..."))
    switch (idleState) {
    case IdleWaiting:
        // How'd this happen? We already tried this...
        TRAP;
        break;
    case IdleIrpSent:
    case IdleCallbackReceived:
        // FUlly idled.
    case IdleComplete:
        cancelIdleIrp = TRUE;
        break;

    case IdleDisabled:
        //
        // Shouldn't get here.
        //
        TRAP;
    }

    KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql);
    
    if (cancelIdleIrp) {
        
        // Don't need to check the return status of IoCancel, since we'll 
        // be waiting for the idleDoneEvent.
        IoCancelIrp(fdoExt->idleNotificationRequest);
    }
    
    if (removing) {
        DBGINFO(("Removing fdo %x. Must wait", fdoExt->fdo))
        /*
         *  Cancelling the IRP causes a lower driver to
         *  complete it (either in a cancel routine or when
         *  the driver checks Irp->Cancel just before queueing it).
         *  Wait for the IRP to actually get cancelled.
         */
        KeWaitForSingleObject(  &fdoExt->idleDoneEvent,
                                Executive,      // wait reason
                                KernelMode,
                                FALSE,          // not alertable
                                NULL );         // no timeout
    }
    
    DBGINFO(("Done cancelling idle notification on fdo %x", fdoExt->fdo))
    idleState = InterlockedExchange(&fdoExt->idleState, IdleDisabled);
    ASSERT(fdoExt->idleState == IdleDisabled);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidclass\name.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name: 

    name.c

Abstract

    Get-friendly-name handling routines

Author:

    Ervin P.

Environment:

    Kernel mode only

Revision History:


--*/

#include "pch.h"



/*
 ********************************************************************************
 *  HidpGetDeviceString
 ********************************************************************************
 *
 *  Note:  This function cannot be pageable because it is called
 *         from the IOCTL dispatch routine, which can get called
 *         at DISPATCH_LEVEL.
 *
 */
NTSTATUS HidpGetDeviceString(IN FDO_EXTENSION *fdoExt, 
                             IN OUT PIRP Irp, 
                             IN ULONG stringId,
                             IN ULONG languageId)
{
    BOOLEAN completeIrpHere = TRUE;
    NTSTATUS status;

    PIO_STACK_LOCATION          currentIrpSp, nextIrpSp;

    currentIrpSp = IoGetCurrentIrpStackLocation(Irp);
    nextIrpSp = IoGetNextIrpStackLocation(Irp);

    /*
     *  The Irp we got uses buffering type METHOD_OUT_DIRECT,
     *  which passes the buffer in the MDL.
     *  IOCTL_HID_GET_STRING uses buffering type METHOD_NEITHER, 
     *  which passes the buffer in Irp->UserBuffer.
     *  So we have to copy the pointer.
     */
    Irp->UserBuffer = HidpGetSystemAddressForMdlSafe(Irp->MdlAddress);

    if (Irp->UserBuffer) {

        /*
         *  Prepare the next (lower) IRP stack location.
         *  This will be the minidriver's (e.g. HIDUSB's) "current" stack location.
         */
        nextIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL; 
        nextIrpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_HID_GET_STRING;
        nextIrpSp->Parameters.DeviceIoControl.OutputBufferLength = 
        currentIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

        // Type3InputBuffer has string/lang IDs
        nextIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = 
        ULongToPtr((ULONG)((stringId & 0xffff) + (languageId << 16)));

        status = HidpCallDriver(fdoExt->fdo, Irp);

        /*
         *  Irp will be completed by lower driver
         */
        completeIrpHere = FALSE;
    } else {
        status = STATUS_INVALID_USER_BUFFER;
    }

    if (completeIrpHere) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    DBGSUCCESS(status, FALSE)
    return status;
}


/*
 ********************************************************************************
 *  HidpGetIndexedString
 ********************************************************************************
 *
 *
 *
 */
NTSTATUS HidpGetIndexedString(  IN FDO_EXTENSION *fdoExt, 
                                IN OUT PIRP Irp,
                                IN ULONG stringIndex,
                                IN ULONG languageId)
{
    NTSTATUS status;
    PIO_STACK_LOCATION currentIrpSp, nextIrpSp;

    currentIrpSp = IoGetCurrentIrpStackLocation(Irp);
    nextIrpSp = IoGetNextIrpStackLocation(Irp);

    /*
     *  The Irp we got uses buffering type METHOD_OUT_DIRECT,
     *  which passes the buffer in the MDL.
     *  The Irp we're sending down uses the same buffering method,
     *  so just let the lower driver derive the system address
     *  from the MDL.
     */

    /*
     *  Prepare the next (lower) IRP stack location.
     *  This will be the minidriver's (e.g. HIDUSB's) "current" stack location.
     */
    nextIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL; 
    nextIrpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_HID_GET_INDEXED_STRING;
    nextIrpSp->Parameters.DeviceIoControl.OutputBufferLength = currentIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    // Type3InputBuffer has string index/lang IDs
    nextIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = 
    ULongToPtr((ULONG)(stringIndex + (languageId << 16)));

    status = HidpCallDriver(fdoExt->fdo, Irp);

    DBGSUCCESS(status, FALSE)
    return status;
}


/*
 ********************************************************************************
 *  HidpGetMsGenreDescriptor
 ********************************************************************************
 *
 *
 *
 */
NTSTATUS HidpGetMsGenreDescriptor(
                                 IN FDO_EXTENSION *fdoExt, 
                                 IN OUT PIRP Irp)
{
    NTSTATUS status;
    PIO_STACK_LOCATION currentIrpSp, nextIrpSp;

    DBGOUT(("Received request for genre descriptor in hidclass"))
    currentIrpSp = IoGetCurrentIrpStackLocation(Irp);
    nextIrpSp = IoGetNextIrpStackLocation(Irp);

    /*
     *  The Irp we got uses buffering type METHOD_OUT_DIRECT,
     *  which passes the buffer in the MDL.
     *  The Irp we're sending down uses the same buffering method,
     *  so just let the lower driver derive the system address
     *  from the MDL.
     */

    /*
     *  Prepare the next (lower) IRP stack location.
     *  This will be the minidriver's (e.g. HIDUSB's) "current" stack location.
     */
    nextIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL; 
    nextIrpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_HID_GET_MS_GENRE_DESCRIPTOR;
    nextIrpSp->Parameters.DeviceIoControl.OutputBufferLength = currentIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    status = HidpCallDriver(fdoExt->fdo, Irp);

    DBGSUCCESS(status, FALSE)
    return status;
}

/*
 ********************************************************************************
 *  HidpGetSetReport
 ********************************************************************************
 *
 *  There are not many differences between reading and writing a
 *  report at this level, whether it be an input, output or feature
 *  report, so we have one function do all six.
 *
 *  controlCode is one of:
 *      IOCTL_HID_GET_INPUT_REPORT, IOCTL_HID_SET_INPUT_REPORT
 *      IOCTL_HID_GET_OUTPUT_REPORT, IOCTL_HID_SET_OUTPUT_REPORT
 *      IOCTL_HID_GET_FEATURE, IOCTL_HID_SET_FEATURE
 *
 *  Note:  This function cannot be pageable because it is called
 *         from the IOCTL dispatch routine, which can get called
 *         at DISPATCH_LEVEL.
 *
 */
NTSTATUS HidpGetSetReport ( IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension,
                            IN OUT PIRP Irp,
                            IN ULONG controlCode,
                            OUT BOOLEAN *sentIrp)
{
    FDO_EXTENSION   *fdoExt;
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION          currentIrpSp, nextIrpSp;
    PFILE_OBJECT                fileObject;
    PHIDCLASS_FILE_EXTENSION    fileExtension;
    PHIDP_COLLECTION_DESC       collectionDesc;

    DBG_COMMON_ENTRY()

    ASSERT(HidDeviceExtension->isClientPdo);
    fdoExt = &HidDeviceExtension->pdoExt.deviceFdoExt->fdoExt;
    currentIrpSp = IoGetCurrentIrpStackLocation(Irp);
    nextIrpSp = IoGetNextIrpStackLocation(Irp);

    *sentIrp = FALSE;

    /*
     *  Get the file extension.
     */
    ASSERT(currentIrpSp->FileObject);
    fileObject = currentIrpSp->FileObject;

    if (!fileObject->FsContext) {
        DBGWARN(("Attempted to get/set report with no file extension"))
        return STATUS_PRIVILEGE_NOT_HELD;
    }

    fileExtension = (PHIDCLASS_FILE_EXTENSION)fileObject->FsContext;
    ASSERT(fileExtension->Signature == HIDCLASS_FILE_EXTENSION_SIG);


    /*
     *  Get our collection  description.
     */
    collectionDesc = GetCollectionDesc(fdoExt, fileExtension->CollectionNumber);
    if (collectionDesc) {

        PUCHAR reportBuf;
        ULONG reportBufLen;
        BOOLEAN featureRequest = FALSE;

        switch (controlCode) {
        case IOCTL_HID_GET_INPUT_REPORT:
            // Make sure that there is an input report on this collection.
            if (collectionDesc->InputLength == 0) {
                DBGWARN(("No input report on collection %x", 
                         fileExtension->CollectionNumber))
                status = STATUS_INVALID_DEVICE_REQUEST;
            }
            break;

        case IOCTL_HID_SET_OUTPUT_REPORT:
            // Make sure that there is an output report on this collection.
            if (collectionDesc->OutputLength == 0) {
                DBGWARN(("No output report on collection %x", 
                         fileExtension->CollectionNumber))
                status = STATUS_INVALID_DEVICE_REQUEST;
            }
            break;

        case IOCTL_HID_GET_FEATURE:
        case IOCTL_HID_SET_FEATURE:
            featureRequest = TRUE;
            // Make sure that there is a feature report on this collection.
            if (collectionDesc->FeatureLength == 0) {
                DBGWARN(("No feature report on collection %x", 
                         fileExtension->CollectionNumber))
                status = STATUS_INVALID_DEVICE_REQUEST;
            }
            break;

        default:
            TRAP;
            status = STATUS_INVALID_DEVICE_REQUEST;
        }

        switch (controlCode) {
        case IOCTL_HID_GET_INPUT_REPORT:
        case IOCTL_HID_GET_FEATURE:
            reportBufLen = currentIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
            reportBuf = HidpGetSystemAddressForMdlSafe(Irp->MdlAddress);
            break;

        case IOCTL_HID_SET_OUTPUT_REPORT:
        case IOCTL_HID_SET_FEATURE:
            reportBuf = Irp->AssociatedIrp.SystemBuffer;
            reportBufLen = currentIrpSp->Parameters.DeviceIoControl.InputBufferLength;
            break;

        default:
            TRAP;
            status = STATUS_INVALID_PARAMETER;
            reportBuf = NULL;
            reportBufLen = 0;
        }

        if (reportBuf && reportBufLen && NT_SUCCESS(status)) {
            PHIDP_REPORT_IDS reportIdent;
            UCHAR reportId;

            /*
             *  The client includes the report id as the first byte of the report.
             *  We send down the report byte only if the device has multiple
             *  report IDs (i.e. the report id is not implicit).
             */
            reportId = reportBuf[0];
            if (fdoExt->deviceDesc.ReportIDs[0].ReportID == 0) {
                DBGASSERT((reportId == 0),
                          ("Report Id should be zero, acutal id = %d", reportId),
                          FALSE)
                reportBuf++;
                reportBufLen--;
            }

            /*
             *  Find a matching report identifier.
             */
            reportIdent = GetReportIdentifier(fdoExt, reportId);

            /*
             *  Check the buffer length against the
             *  report length in the report identifier.
             */
            if (reportIdent) {
                switch (controlCode) {
                case IOCTL_HID_GET_INPUT_REPORT:
                    /*
                     *  The buffer must be big enough for the report.
                     */
                    if (!reportIdent->InputLength ||
                        reportBufLen < reportIdent->InputLength) {
                        ASSERT(!(PVOID)"report buf must be at least report size for get-report.");
                        reportIdent = NULL;
                    }
                    break;
                case IOCTL_HID_GET_FEATURE:
                    /*
                     *  The buffer must be big enough for the report.
                     */
                    if (!reportIdent->FeatureLength ||
                        reportBufLen < reportIdent->FeatureLength) {
                        ASSERT(!(PVOID)"report buf must be at least report size for get-report.");
                        reportIdent = NULL;
                    }
                    break;
                case IOCTL_HID_SET_OUTPUT_REPORT:
                    /*
                     *  The buffer must be big enough for the report.
                     *  It CAN be larger, and it is up to us to use
                     *  the correct report size from the report identifier.
                     */
                    if (!reportIdent->OutputLength ||
                        reportBufLen < reportIdent->OutputLength) {
                        ASSERT(!(PVOID)"report buf must be exact size for set-report.");
                        reportIdent = NULL;
                    } else {
                        reportBufLen = reportIdent->OutputLength;
                    }
                    break;
                case IOCTL_HID_SET_FEATURE:
                    if (!reportIdent->FeatureLength ||
                        reportBufLen < reportIdent->FeatureLength) {
                        ASSERT(!(PVOID)"report buf must be exact size for set-report.");
                        reportIdent = NULL;
                    } else {
                        reportBufLen = reportIdent->FeatureLength;
                    }
                    break;
                default:
                    TRAP;
                }
            }

            if (reportIdent) {

                PHID_XFER_PACKET reportPacket = ALLOCATEPOOL(NonPagedPool, sizeof(HID_XFER_PACKET));

                if (reportPacket) {

                    reportPacket->reportBuffer = reportBuf;
                    reportPacket->reportBufferLen = reportBufLen;
                    reportPacket->reportId = reportId;

                    Irp->UserBuffer = reportPacket;

                    /*
                     *  Prepare the next (lower) IRP stack location.
                     *  This will be HIDUSB's "current" stack location.
                     */
                    nextIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
                    nextIrpSp->Parameters.DeviceIoControl.IoControlCode = controlCode;

                    /*
                     *  Note - input/output is relative to IOCTL servicer
                     */
                    switch (controlCode) {
                    case IOCTL_HID_GET_INPUT_REPORT:
                    case IOCTL_HID_GET_FEATURE:
                        nextIrpSp->Parameters.DeviceIoControl.OutputBufferLength = sizeof(HID_XFER_PACKET);
                        break;
                    case IOCTL_HID_SET_OUTPUT_REPORT:
                    case IOCTL_HID_SET_FEATURE:
                        nextIrpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(HID_XFER_PACKET);
                        break;
                    default:
                        TRAP;
                    }

                    DBG_RECORD_REPORT(reportId, controlCode, FALSE)

                    status = HidpCallDriverSynchronous(fdoExt->fdo, Irp);
                    if (!NT_SUCCESS(status)) {
                        DBGWARN(("HidpGetSetFeature: usb returned status %xh.", status))
                    }
                    DBG_RECORD_REPORT(reportId, controlCode, TRUE)
                    ExFreePool(reportPacket);
                    *sentIrp = FALSE; // needs to be completed again

                } else {
                    ASSERT(reportPacket);
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            } else {
                DBGASSERT(reportIdent, ("Some yahoo sent invalid data in ioctl %x", controlCode), FALSE)
                status = STATUS_DATA_ERROR;
            }
        } else if (NT_SUCCESS(status)) {
            DBGASSERT(reportBuf, ("Feature buffer is invalid"), FALSE)
            DBGASSERT(reportBufLen, ("Feature buffer length is invalid"), FALSE)
            status = STATUS_INVALID_BUFFER_SIZE;
        }
    } else {
        ASSERT(collectionDesc);
        status = STATUS_DEVICE_NOT_CONNECTED;
    }

    DBGSUCCESS(status, FALSE)

    DBG_COMMON_EXIT()

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidclass\pch.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pch.h

Abstract


Author:

    Forrest Foltz
    Ervin P.

Environment:

    Kernel mode only

Revision History:


--*/



#include <wdm.h>
#include <stdio.h>
#include <hidpddi.h>
#include <hidport.h>
#include <wmilib.h>
#include <wdmguid.h>
#include <wmistr.h>
#include <strsafe.h>
#include "local.h"
#include "debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidclass\local.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    local.h

Abstract

    Definitions that are private to the hid class driver code appear here.

Author:

    Ervin P.

Environment:

    Kernel mode only

Revision History:


--*/


typedef struct _HID_DESCRIPTOR            *PHID_DESCRIPTOR;
typedef struct _HIDCLASS_COLLECTION       *PHIDCLASS_COLLECTION;
typedef struct _HIDCLASS_DEVICE_EXTENSION *PHIDCLASS_DEVICE_EXTENSION;
typedef struct _HIDCLASS_DRIVER_EXTENSION *PHIDCLASS_DRIVER_EXTENSION;
typedef struct _HIDCLASS_FILE_EXTENSION   *PHIDCLASS_FILE_EXTENSION;
typedef struct _HIDCLASS_PINGPONG         *PHIDCLASS_PINGPONG;
typedef struct _HIDCLASS_REPORT           *PHIDCLASS_REPORT;
typedef struct _FDO_EXTENSION             *PFDO_EXTENSION;
typedef struct _PDO_EXTENSION             *PPDO_EXTENSION;


#if DBG
    #define LockFileExtension( f, i )                               \
        {                                                           \
            KeAcquireSpinLock( &(f)->ListSpinLock, (i) );           \
            (f)->ListSpinLockTaken = TRUE;                          \
        }

    #define UnlockFileExtension(f, i)                               \
        {                                                           \
            (f)->ListSpinLockTaken = FALSE;                         \
            KeReleaseSpinLock( &(f)->ListSpinLock, (i) );           \
        }

        VOID DbgLogIntStart();
        VOID DbgLogIntEnd();
        #define DBGLOG_INTSTART() DbgLogIntStart();
        #define DBGLOG_INTEND() DbgLogIntEnd();

#else
    #define LockFileExtension(f, i) KeAcquireSpinLock(&(f)->ListSpinLock, (i));
    #define UnlockFileExtension(f, i) KeReleaseSpinLock(&(f)->ListSpinLock, (i));

        #define DBGLOG_INTSTART()
        #define DBGLOG_INTEND()
#endif

#define HIDCLASS_POOL_TAG 'CdiH'
#define ALLOCATEPOOL(poolType, size) ExAllocatePoolWithTag((poolType), (size), HIDCLASS_POOL_TAG)
#define ALLOCATEQUOTAPOOL(poolType, size) ExAllocatePoolWithQuotaTag((poolType), (size), HIDCLASS_POOL_TAG)

//
// On some busses, we can power down the bus, but not the system, in this case
// we still need to allow the device to wake said bus, therefore
// waitwake-supported should not rely on systemstate.
//
#define WAITWAKE_SUPPORTED(fdoExt) ((fdoExt)->deviceCapabilities.DeviceWake > PowerDeviceD0 && \
                                    (fdoExt)->deviceCapabilities.SystemWake > PowerSystemWorking)

// #define WAITWAKE_ON(port)        ((port)->WaitWakeIrp != 0)
#define REMOTEWAKE_ON(port) \
       (InterlockedCompareExchangePointer(&(port)->remoteWakeIrp, NULL, NULL) != NULL)

BOOLEAN
HidpCheckRemoteWakeEnabled(
    IN PPDO_EXTENSION PdoExt
    );

#define SHOULD_SEND_WAITWAKE(pdoExt) (!(pdoExt)->MouseOrKeyboard && \
                                    WAITWAKE_SUPPORTED(&(pdoExt)->deviceFdoExt->fdoExt) && \
                                    !REMOTEWAKE_ON(pdoExt)       && \
                                    HidpCheckRemoteWakeEnabled(pdoExt))

/*
 *  String constants for use in compatible-id multi-string.
 */
//                                             0123456789 123456789 1234
#define HIDCLASS_COMPATIBLE_ID_STANDARD_NAME L"HID_DEVICE\0"
#define HIDCLASS_COMPATIBLE_ID_GENERIC_NAME  L"HID_DEVICE_UP:%04x_U:%04x\0"
#define HIDCLASS_COMPATIBLE_ID_PAGE_OFFSET  14
#define HIDCLASS_COMPATIBLE_ID_USAGE_OFFSET 21
#define HIDCLASS_COMPATIBLE_ID_STANDARD_LENGTH 11
#define HIDCLASS_COMPATIBLE_ID_GENERIC_LENGTH 26
//                                        0123456789 123456789 123456
#define HIDCLASS_SYSTEM_KEYBOARD        L"HID_DEVICE_SYSTEM_KEYBOARD\0"
#define HIDCLASS_SYSTEM_MOUSE           L"HID_DEVICE_SYSTEM_MOUSE\0"
#define HIDCLASS_SYSTEM_GAMING_DEVICE   L"HID_DEVICE_SYSTEM_GAME\0"
#define HIDCLASS_SYSTEM_CONTROL         L"HID_DEVICE_SYSTEM_CONTROL\0"
#define HIDCLASS_SYSTEM_CONSUMER_DEVICE L"HID_DEVICE_SYSTEM_CONSUMER\0"

//
// String constant used to find out if selective suspend
// is supported on this device.
//
#define HIDCLASS_SELECTIVE_SUSPEND_ENABLED L"SelectiveSuspendEnabled\0"
#define HIDCLASS_SELECTIVE_SUSPEND_ON L"SelectiveSuspendOn\0"
#define HIDCLASS_REMOTE_WAKE_ENABLE L"RemoteWakeEnabled"

#define NO_STATUS 0x80000000    // this will never be a STATUS_xxx constant in NTSTATUS.H

#define HID_DEFAULT_IDLE_TIME       5 // in seconds

//
// Valid values for HIDCLASS_DEVICE_EXTENSION.state
//
enum deviceState {
                    DEVICE_STATE_INITIALIZED = 1,
                    DEVICE_STATE_STARTING,
                    DEVICE_STATE_START_SUCCESS,
                    DEVICE_STATE_START_FAILURE,
                    DEVICE_STATE_STOPPING,
                    DEVICE_STATE_STOPPED,
                    DEVICE_STATE_REMOVING,
                    DEVICE_STATE_REMOVED
};

enum collectionState {
                        COLLECTION_STATE_UNINITIALIZED = 1,
                        COLLECTION_STATE_INITIALIZED,
                        COLLECTION_STATE_RUNNING,
                        COLLECTION_STATE_STOPPING,
                        COLLECTION_STATE_STOPPED,
                        COLLECTION_STATE_REMOVING
};


//
// _HIDCLASS_DRIVER_EXTENSION contains per-minidriver extension information
// for the class driver.  It is created upon a HidRegisterMinidriver() call.
//

typedef struct _HIDCLASS_DRIVER_EXTENSION {

    //
    // Pointer to the minidriver's driver object.
    //

    PDRIVER_OBJECT      MinidriverObject;

    //
    // RegistryPath is a copy of the minidriver's RegistryPath that it
    // received as a DriverEntry() parameter.
    //

    UNICODE_STRING      RegistryPath;

    //
    // DeviceExtensionSize is the size of the minidriver's per-device
    // extension.
    //

    ULONG               DeviceExtensionSize;

    //
    // Dispatch routines for the minidriver.  These are the only dispatch
    // routines that the minidriver should ever care about, no others will
    // be forwarded.
    //

    PDRIVER_DISPATCH    MajorFunction[ IRP_MJ_MAXIMUM_FUNCTION + 1 ];

    /*
     *  These are the minidriver's original entrypoints,
     *  to which we chain.
     */
    PDRIVER_ADD_DEVICE  AddDevice;
    PDRIVER_UNLOAD      DriverUnload;

    //
    // Number of pointers to this structure that we've handed out
    //

    LONG                ReferenceCount;

    //
    // Linkage onto our global list of driver extensions
    //

    LIST_ENTRY          ListEntry;


    /*
     *  Either all or none of the devices driven by a given minidriver are polled.
     */
    BOOLEAN             DevicesArePolled;


#if DBG

    ULONG               Signature;

#endif

} HIDCLASS_DRIVER_EXTENSION;

#if DBG
#define HID_DRIVER_EXTENSION_SIG 'EdiH'
#endif



#define MIN_POLL_INTERVAL_MSEC      1
#define MAX_POLL_INTERVAL_MSEC      10000
#define DEFAULT_POLL_INTERVAL_MSEC  5


//
// HIDCLASS_COLLECTION is where we keep our per-collection information.
//

typedef struct _HIDCLASS_COLLECTION {


    ULONG                       CollectionNumber;
    ULONG                       CollectionIndex;

    //
    // NumOpens is a count of open handles against this collection.
    //

    ULONG                       NumOpens;

    // Number of pending reads for all clients on this collection.
    ULONG                       numPendingReads;

    //
    // FileExtensionList is the head of a list of file extensions, i.e.
    // open instances against this collection.
    //

    LIST_ENTRY                  FileExtensionList;
    KSPIN_LOCK                  FileExtensionListSpinLock;

    /*
     *  For polled devices, we only read from the device
     *  once every poll interval.  We queue read IRPs
     *  here until the poll timer expiration.
     *
     *  Note:  for a polled device, we keep a separate background
     *         loop for each collection.  This way, queued-up read IRPs
     *         remain associated with the right collection.
     *         Also, this will keep the number of reads we do on each
     *         timer period roughly equal to the number of collections.
     */
    ULONG                       PollInterval_msec;
    KTIMER                      polledDeviceTimer;
    KDPC                        polledDeviceTimerDPC;
    LIST_ENTRY                  polledDeviceReadQueue;
    KSPIN_LOCK                  polledDeviceReadQueueSpinLock;

    /*
     *  We save old reports on polled devices for
     *  "opportunistic" readers who want to get a result right away.
     *  The polledDataIsStale flag indicates that the saved report
     *  is at least one poll interval old (so we should not use it).
     */
    PUCHAR                      savedPolledReportBuf;
    ULONG                       savedPolledReportLen;
    BOOLEAN                     polledDataIsStale;

    UNICODE_STRING              SymbolicLinkName;
    UNICODE_STRING              SymbolicLinkName_SystemControl;

    /*
     *  HID collection information descriptor for this collection.
     */
    HID_COLLECTION_INFORMATION  hidCollectionInfo;
    PHIDP_PREPARSED_DATA        phidDescriptor;

    /*
     *  This buffer is used to "cook" a raw report when it's been received.
     *  This is only used for non-polled (interrupt) devices.
     */
    PUCHAR                      cookedInterruptReportBuf;

    /*
     *  This is an IRP that we queue and complete
     *  when a read report contains a power event.
     *
     *  The powerEventIrp field retains an IRP
     *  so it needs a spinlock to synchronize cancellation.
     */
    PIRP                        powerEventIrp;
    KSPIN_LOCK                  powerEventSpinLock;

    ULONG                       secureReadMode;
    KSPIN_LOCK                  secureReadLock;



    #if DBG
        ULONG                   Signature;
    #endif

} HIDCLASS_COLLECTION;

#if DBG
#define HIDCLASS_COLLECTION_SIG 'EccH'
#endif

//
// For HID devices that have at least one interrupt-style collection, we
// try to keep a set of "ping-pong" report-read IRPs pending in the minidriver
// in the event we get a report.
//
// HIDCLASS_PINGPONG contains a pointer to an IRP as well as an event
// and status block.  Each device has a pointer to an array of these structures,
// the array size depending on the number of such IRPs we want to keep in
// motion.
//
// Right now the default number is 2.
//

#define MIN_PINGPONG_IRPS   2

//
// Flags to indicate whether read completed synchronously or asynchronously
//
#define PINGPONG_START_READ     0x01
#define PINGPONG_END_READ       0x02
#define PINGPONG_IMMEDIATE_READ 0x03

typedef struct _HIDCLASS_PINGPONG {

    #define PINGPONG_SIG (ULONG)'gnoP'
    ULONG           sig;

    //
    // Read interlock value to protect us from running out of stack space
    //
    ULONG               ReadInterlock;

    PIRP    irp;
    PUCHAR  reportBuffer;
    LONG    weAreCancelling;

    KEVENT sentEvent;       // When a read has been sent.
    KEVENT pumpDoneEvent;   // When the read loop is finally exitting.

    PFDO_EXTENSION   myFdoExt;

    /*
     *  Timeout context for back-off algorithm applied to broken devices.
     */
    KTIMER          backoffTimer;
    KDPC            backoffTimerDPC;
    LARGE_INTEGER   backoffTimerPeriod; // in negative 100-nsec units

} HIDCLASS_PINGPONG;

#if DBG
    #define HIDCLASS_REPORT_BUFFER_GUARD    'draG'
#endif

//
// All possible idle states.
//
#define IdleUninitialized       0x0
#define IdleDisabled            0x1
#define IdleWaiting             0x2
#define IdleIrpSent             0x3
#define IdleCallbackReceived    0x4
#define IdleComplete            0x5

/*
 *  Stores information about a Functional Device Object (FDO) which HIDCLASS attaches
 *  to the top of the Physical Device Object (PDO) that it get from the minidriver below.
 */
typedef struct _FDO_EXTENSION {

    //
    // Back pointer to the functional device object
    //
    PDEVICE_OBJECT          fdo;

    //
    // HidDriverExtension is a pointer to our driver extension for the
    // minidriver that gave us the PDO.
    //

    PHIDCLASS_DRIVER_EXTENSION driverExt;

    //
    // Hid descriptor that we get from the device.
    //

    HID_DESCRIPTOR          hidDescriptor;  // 9 bytes

    //
    // The attributes of this hid device.
    //

    HID_DEVICE_ATTRIBUTES   hidDeviceAttributes;  // 0x20 bytes

    //
    // Pointer to and length of the raw report descriptor.
    //

    PUCHAR                  rawReportDescription;
    ULONG                   rawReportDescriptionLength;

    //
    // This device has one or more collections.  We store the count and
    // pointer to an array of our HIDCLASS_COLLECTION structures (one per
    // collection) here.
    //

    PHIDCLASS_COLLECTION    classCollectionArray;

    /*
     *  This is initialized for us by HIDPARSE's HidP_GetCollectionDescription().
     *  It includes an array of HIDP_COLLECTION_DESC structs corresponding
     *  the classCollectionArray declared above.
     */
    HIDP_DEVICE_DESC        deviceDesc;     // 0x30 bytes
    BOOLEAN                 devDescInitialized;

    //
    // The maximum input size amongst ALL report types.
    //
    ULONG                   maxReportSize;

    //
    // For devices that have at least one interrupt collection, we keep
    // a couple of ping-pong IRPs and associated structures.
    // The ping-pong IRPs ferry data up from the USB hub.
    //
    ULONG                   numPingPongs;
    PHIDCLASS_PINGPONG      pingPongs;

    //
    // OpenCount represents the number of file objects aimed at this device
    //
    ULONG                   openCount;


    /*
     *  This is the number of IRPs still outstanding in the minidriver.
     */

    ULONG                   outstandingRequests;

    enum deviceState        prevState;
    enum deviceState        state;

    UNICODE_STRING          name;

    /*
     *  deviceRelations contains an array of client PDO pointers.
     *
     *  As the HID bus driver, HIDCLASS produces this data structure to report
     *  collection-PDOs to the system.
     */
    PDEVICE_RELATIONS       deviceRelations;

    /*
     *  This is an array of device extensions for the collection-PDOs of this
     *  device-FDO.
     */
    PHIDCLASS_DEVICE_EXTENSION   *collectionPdoExtensions;


    /*
     *  This includes a
     *  table mapping system power states to device power states.
     */
    DEVICE_CAPABILITIES deviceCapabilities;

    /*
     *  Track both current system and device power state
     */
    SYSTEM_POWER_STATE  systemPowerState;
    DEVICE_POWER_STATE  devicePowerState;

    /*
     *  Wait Wake Irp sent to parent PDO
     */
    PIRP        waitWakeIrp;
    KSPIN_LOCK  waitWakeSpinLock;
    BOOLEAN isWaitWakePending;

    /*
     * Queue of delayed requests due to the stack being in low power
     */
    KSPIN_LOCK collectionPowerDelayedIrpQueueSpinLock;
    LIST_ENTRY collectionPowerDelayedIrpQueue;
    ULONG numPendingPowerDelayedIrps;

    BOOLEAN isOutputOnlyDevice;

    //
    // Selective suspend idling context.
    //
    HID_SUBMIT_IDLE_NOTIFICATION_CALLBACK_INFO idleCallbackInfo;

    LONG        idleState;
    PULONG      idleTimeoutValue;
    KSPIN_LOCK  idleNotificationSpinLock;
    PIRP        idleNotificationRequest;
    BOOLEAN     idleCancelling;
    BOOLEAN     idleEnabledInRegistry;
    BOOLEAN     idleEnabled;
    KSPIN_LOCK  idleSpinLock;

    KEVENT idleDoneEvent;   // When the idle notification irp has been cancelled successfully.

    LONG numIdlePdos;

    /*
     *  This is a list of WaitWake IRPs sent to the collection-PDOs
     *  on this device, which we just save and complete when the
     *  base device's WaitWake IRP completes.
     */
    LIST_ENTRY  collectionWaitWakeIrpQueue;
    KSPIN_LOCK  collectionWaitWakeIrpQueueSpinLock;

    struct _FDO_EXTENSION       *nextFdoExt;

    /*
     *  Device-specific flags (DEVICE_FLAG_xxx).
     */
    ULONG deviceSpecificFlags;

        /*
         *  This is our storage space for the systemState IRP that we need to hold
         *  on to and complete in DevicePowerRequestCompletion.
         */
        PIRP currentSystemStateIrp;

    /*
     *  Unique number assigned to identify this HID bus.
     */
    ULONG BusNumber;

    //
    // WMI Information
    //
    WMILIB_CONTEXT WmiLibInfo;

    #if DBG
        WCHAR dbgDriverKeyName[64];
    #endif
    
    KSPIN_LOCK  presentSpinLock;
    BOOLEAN     isPresent;
    BOOLEAN     presentReported;


} FDO_EXTENSION;


/*
 *  Stores information about a Physical Device Object (PDO) which HIDCLASS creates
 *  for each HID device-collection.
 */
typedef struct _PDO_EXTENSION {

    enum collectionState        prevState;
    enum collectionState        state;

    ULONG                       collectionNum;
    ULONG                       collectionIndex;

    //
    // A remove lock to keep track of outstanding I/Os to prevent the device
    // object from leaving before such time as all I/O has been completed.
    //
    IO_REMOVE_LOCK              removeLock;

    // represents a collection on the HID "bus"
    PDEVICE_OBJECT              pdo;
    PUNICODE_STRING             name;

    /*
     *  This is a back-pointer to the original FDO's extension.
     */
    PHIDCLASS_DEVICE_EXTENSION  deviceFdoExt;

    /*
     *  Track both current system and device power state
     */
    SYSTEM_POWER_STATE          systemPowerState;
    DEVICE_POWER_STATE          devicePowerState;
    BOOLEAN                     remoteWakeEnabled;
    KSPIN_LOCK                  remoteWakeSpinLock;
    PIRP                        remoteWakeIrp;
    PIRP                        waitWakeIrp;

    /*
     *  The status change function that was registered thru query interface
     *  NOTE: Can currently only register one.
     */
    PHID_STATUS_CHANGE          StatusChangeFn;
    PVOID                       StatusChangeContext;

    /*
     *  Access protection information.
     *  We count the number of opens for read and write on the collection.
     *  We also count the number of opens which RESTRICT future
     *  read/write opens on the collection.
     *
     *  Note that desired access is independent of restriction.
     *  A client may, for example, do an open-for-read-only but
     *  (by not setting the FILE_SHARE_WRITE bit)
     *  restrict other clients from doing an open-for-write.
     */
    ULONG                       openCount;
    ULONG                       opensForRead;
    ULONG                       opensForWrite;
    ULONG                       restrictionsForRead;
    ULONG                       restrictionsForWrite;
    ULONG                       restrictionsForAnyOpen;
    BOOLEAN                     MouseOrKeyboard;

    //
    // WMI Information
    //
    WMILIB_CONTEXT WmiLibInfo;

} PDO_EXTENSION;


/*
 *  This contains info about either a device FDO or a device-collection PDO.
 *  Some of the same functions process both, so we need one structure.
 */
typedef struct _HIDCLASS_DEVICE_EXTENSION {

    /*
     *  This is the public part of a HID FDO device extension, and
     *  must be the first entry in this structure.
     */
    HID_DEVICE_EXTENSION    hidExt;     // size== 0x0C.

    /*
     *  Determines whether this is a device extension for a device-FDO or a
     *  device-collection-PDO; this resolves the following union.
     */
    BOOLEAN                 isClientPdo;

    /*
     *  Include this signature for both debug and retail --
     *  kenray's debug extensions look for this.
     */
    #define             HID_DEVICE_EXTENSION_SIG 'EddH'
    ULONG               Signature;

    union {
        FDO_EXTENSION       fdoExt;
        PDO_EXTENSION       pdoExt;
    };


} HIDCLASS_DEVICE_EXTENSION;



//
// HIDCLASS_FILE_EXTENSION is private data we keep per file object.
//

typedef struct _HIDCLASS_FILE_EXTENSION {

    //
    // CollectionNumber is the ordinal of the collection in the device
    //

    ULONG                       CollectionNumber;


    PFDO_EXTENSION              fdoExt;

    //
    // PendingIrpList is a list of READ IRPs currently waiting to be satisfied.
    //

    LIST_ENTRY                  PendingIrpList;

    //
    // ReportList is a list of reports waiting to be read on this handle.
    //

    LIST_ENTRY                  ReportList;

    //
    // FileList provides a way to link all of a collection's
    // file extensions together.
    //

    LIST_ENTRY                  FileList;

    //
    // Both PendingIrpList and ReportList are protected by the same spinlock,
    // ListSpinLock.
    //
    KSPIN_LOCK                  ListSpinLock;

    //
    // MaximumInputReportAge is only applicable for polled collections.
    // It represents the maximum acceptable input report age for this handle.
    // There is a value in the HIDCLASS_COLLECTION,
    // CurrentMaximumInputReportAge, that represents the current minimum value
    // of all of the file extensions open against the collection.
    //

    LARGE_INTEGER               MaximumInputReportAge;

    //
    // CurrentInputReportQueueSize is the current size of the report input
    // queue.
    //

    ULONG                       CurrentInputReportQueueSize;

    /*
     *  This is the maximum number of reports that will be queued for the file extension.
     *  This starts at a default value and can be adjusted (within a fixed range) by an IOCTL.
     */
    ULONG                       MaximumInputReportQueueSize;
    #define MIN_INPUT_REPORT_QUEUE_SIZE MIN_PINGPONG_IRPS
    #define MAX_INPUT_REPORT_QUEUE_SIZE (MIN_INPUT_REPORT_QUEUE_SIZE*256)
    #define DEFAULT_INPUT_REPORT_QUEUE_SIZE (MIN_INPUT_REPORT_QUEUE_SIZE*16)

    //
    // Back pointer to the file object that this extension is for
    //

    PFILE_OBJECT                FileObject;


    /*
     *  File-attributes passed in irpSp->Parameters.Create.FileAttributes
     *  when this open was made.
     */
    USHORT                      FileAttributes;
    ACCESS_MASK                 accessMask;
    USHORT                      shareMask;

    //
    // Closing is set when this file object is closing and will be removed
    // shortly.  Don't queue any more reports or IRPs to this object
    // when this flag is set.
    //

    BOOLEAN                     Closing;

    //
    // DWORD allignment
    //
    BOOLEAN                     Reserved [2];

    /*
     *  This flag indicates that this client does irregular, opportunistic
     *  reads on the device, which is a polled device.
     *  Instead of waiting for the background timer-driven read loop,
     *  this client should have his reads completed immediately.
     */
    BOOLEAN                     isOpportunisticPolledDeviceReader;


    BOOLEAN                     isSecureOpen;
    ULONG                       SecureReadMode;
    

        /*
         *  If a read fails, some clients reissue the read on the same thread.
         *  If this happens repeatedly, we can run out of stack space.
         *  So we keep track of the depth
         */
        #define INSIDE_READCOMPLETE_MAX 4
        ULONG                                           insideReadCompleteCount;

    #if DBG
        BOOLEAN                     ListSpinLockTaken;
        ULONG                       dbgNumReportsDroppedSinceLastRead;
        ULONG                       Signature;
    #endif

} HIDCLASS_FILE_EXTENSION;

#if DBG
        #define HIDCLASS_FILE_EXTENSION_SIG 'efcH'
#endif


typedef struct {

        #define ASYNC_COMPLETE_CONTEXT_SIG 'cnsA'
        ULONG sig;

        PIO_WORKITEM workItem;
        PIRP irp;

} ASYNC_COMPLETE_CONTEXT;


//
// HIDCLASS_REPORT is the structure we use to track a report returned from
// the minidriver.
//

typedef struct _HIDCLASS_REPORT {

    //
    // ListEntry queues this report onto a file extension.
    //

    LIST_ENTRY  ListEntry;

    ULONG reportLength;
    //
    // UnparsedReport is a data area for the unparsed report data as returned
    // from the minidriver.  The lengths of all input reports for a given
    // class are the same, so we don't need to store the length in each
    // report.
    //

    UCHAR       UnparsedReport[];

} HIDCLASS_REPORT;

typedef struct _HIDCLASS_WORK_ITEM_DATA {
    PIRP                Irp;
    PDO_EXTENSION       *PdoExt;
    PIO_WORKITEM        Item;
    BOOLEAN             RemoteWakeState;
} HIDCLASS_WORK_ITEM_DATA, *PHIDCLASS_WORK_ITEM_DATA;

//
// Internal shared function prototypes
//
NTSTATUS                    DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath);
NTSTATUS                    HidpAddDevice(IN PDRIVER_OBJECT DriverObject, IN PDEVICE_OBJECT PhysicalDeviceObject);
VOID                        HidpDriverUnload(IN struct _DRIVER_OBJECT *minidriverObject);
NTSTATUS                    HidpCallDriver(IN PDEVICE_OBJECT DeviceObject, IN OUT PIRP Irp);
NTSTATUS                    HidpCallDriverSynchronous(IN PDEVICE_OBJECT DeviceObject, IN OUT PIRP Irp);
NTSTATUS                    HidpCopyInputReportToUser(IN PHIDCLASS_FILE_EXTENSION fdoExtension, IN PUCHAR ReportData, IN OUT PULONG UserBufferLen, OUT PUCHAR UserBuffer);
NTSTATUS                    HidpCreateSymbolicLink(IN PDO_EXTENSION *pdoExtension, IN ULONG collectionNum, IN BOOLEAN Create, IN PDEVICE_OBJECT Pdo);
NTSTATUS                    HidpCreateClientPDOs(PHIDCLASS_DEVICE_EXTENSION hidClassExtension);
ULONG                       HidpSetMaxReportSize(IN FDO_EXTENSION *fdoExtension);
VOID                        EnqueueInterruptReport(PHIDCLASS_FILE_EXTENSION fileExtension, PHIDCLASS_REPORT report);
PHIDCLASS_REPORT            DequeueInterruptReport(PHIDCLASS_FILE_EXTENSION fileExtension, LONG maxLen);
VOID                        HidpDestroyFileExtension(PHIDCLASS_COLLECTION collection, PHIDCLASS_FILE_EXTENSION FileExtension);
VOID                        HidpFlushReportQueue(IN PHIDCLASS_FILE_EXTENSION FileExtension);
NTSTATUS                    HidpGetCollectionDescriptor(IN FDO_EXTENSION *fdoExtension, IN ULONG collectionId, IN PVOID Buffer, IN OUT PULONG BufferSize);
NTSTATUS                    HidpGetCollectionInformation(IN FDO_EXTENSION *fdoExtension, IN ULONG collectionNumber, IN PVOID Buffer, IN OUT PULONG BufferSize);
NTSTATUS                    HidpGetDeviceDescriptor(FDO_EXTENSION *fdoExtension);
BOOLEAN                     HidpStartIdleTimeout(FDO_EXTENSION *fdoExt, BOOLEAN DeviceStart);
VOID                        HidpCancelIdleNotification(FDO_EXTENSION *fdoExt, BOOLEAN removing);
VOID                        HidpIdleTimeWorker(PDEVICE_OBJECT DeviceObject, PIO_WORKITEM Item);
VOID                        HidpIdleNotificationCallback(PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension);
NTSTATUS                    HidpRegisterDeviceForIdleDetection(PDEVICE_OBJECT DeviceObject, ULONG IdleTime, PULONG *);
VOID                        HidpSetDeviceBusy(FDO_EXTENSION *fdoExt);
NTSTATUS                    HidpCheckIdleState(PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension,PIRP Irp);
NTSTATUS                    HidpGetRawDeviceDescriptor(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, OUT PULONG RawDeviceDescriptorLength, OUT PUCHAR *RawDeviceDescriptor);
NTSTATUS                    HidpInitializePingPongIrps(FDO_EXTENSION *fdoExtension);
NTSTATUS                    HidpReallocPingPongIrps(FDO_EXTENSION *fdoExtension, ULONG newNumBufs);
NTSTATUS                    HidpIrpMajorPnpComplete(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);
NTSTATUS                    HidpMajorHandler(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS                    HidpParseAndBuildLinks(FDO_EXTENSION *fdoExtension);
NTSTATUS                    HidpFdoPowerCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);
BOOLEAN                     EnqueueDriverExt(PHIDCLASS_DRIVER_EXTENSION driverExt);
PHIDCLASS_DRIVER_EXTENSION  RefDriverExt(IN PDRIVER_OBJECT MinidriverObject);
PHIDCLASS_DRIVER_EXTENSION  DerefDriverExt(IN PDRIVER_OBJECT MinidriverObject);
NTSTATUS                    HidpStartAllPingPongs(FDO_EXTENSION *fdoExtension);
ULONG                       HidiGetClassCollectionOrdinal(IN PHIDCLASS_COLLECTION ClassCollection);
PHIDP_COLLECTION_DESC       HidiGetHidCollectionByClassCollection(IN PHIDCLASS_COLLECTION ClassCollection);
PHIDP_REPORT_IDS            GetReportIdentifier(FDO_EXTENSION *fdoExtension, ULONG reportId);
PHIDP_COLLECTION_DESC       GetCollectionDesc(FDO_EXTENSION *fdoExtension, ULONG collectionId);
PHIDCLASS_COLLECTION        GetHidclassCollection(FDO_EXTENSION *fdoExtension, ULONG collectionId);
//NTSTATUS                    HidpGetSetFeature(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp, IN ULONG controlCode, OUT BOOLEAN *sentIrp);
NTSTATUS                    HidpGetSetReport(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp, IN ULONG controlCode, OUT BOOLEAN *sentIrp);
NTSTATUS                    HidpGetDeviceString(IN FDO_EXTENSION *fdoExt, IN OUT PIRP Irp, IN ULONG stringId, IN ULONG languageId);
NTSTATUS                    HidpGetPhysicalDescriptor(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp);
NTSTATUS                    HidpIrpMajorRead(IN PHIDCLASS_DEVICE_EXTENSION, IN OUT PIRP Irp);
NTSTATUS                    HidpIrpMajorCreate(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp);
NTSTATUS                    HidpIrpMajorWrite(IN PHIDCLASS_DEVICE_EXTENSION, IN OUT PIRP Irp);
NTSTATUS                    HidpIrpMajorPnp(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp);
NTSTATUS                    HidpPdoPnp(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp);
NTSTATUS                    HidpFdoPnp(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp);
NTSTATUS                    HidpIrpMajorPower(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp);
NTSTATUS                    HidpIrpMajorClose(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp);
NTSTATUS                    HidpIrpMajorDeviceControl(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp);
NTSTATUS                    HidpIrpMajorINTERNALDeviceControl(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp);
NTSTATUS                    HidpIrpMajorClose(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp);
NTSTATUS                    HidpIrpMajorDefault(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp);
NTSTATUS                    HidpInterruptReadComplete(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);
NTSTATUS                    HidpQueryDeviceRelations(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp);
NTSTATUS                    HidpQueryCollectionCapabilities(PDO_EXTENSION *pdoExt, IN OUT PIRP Irp);
NTSTATUS                    HidpQueryIdForClientPdo(IN PHIDCLASS_DEVICE_EXTENSION hidClassExtension, IN OUT PIRP Irp);
NTSTATUS                    HidpQueryInterface(IN PHIDCLASS_DEVICE_EXTENSION hidClassExtension, IN OUT PIRP Irp);
PVOID                       MemDup(POOL_TYPE PoolType, PVOID dataPtr, ULONG length);
BOOLEAN                     AllClientPDOsInitialized(FDO_EXTENSION *fdoExtension, BOOLEAN initialized);
BOOLEAN                     AnyClientPDOsInitialized(FDO_EXTENSION *fdoExtension, BOOLEAN initialized);
NTSTATUS                    ClientPdoCompletion(PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, PIRP Irp);
BOOLEAN                     HidpDeleteDeviceObjects(FDO_EXTENSION *fdoExt);
VOID                        HidpCancelReadIrp(PDEVICE_OBJECT DeviceObject, PIRP Irp);
VOID                        CancelAllPingPongIrps(FDO_EXTENSION *fdoExt);
VOID                        HidpCleanUpFdo(FDO_EXTENSION *fdoExt);
NTSTATUS                    HidpRemoveDevice(FDO_EXTENSION *fdoExt, IN PIRP Irp);
VOID                        HidpRemoveCollection(FDO_EXTENSION *fdoExt, PDO_EXTENSION *pdoExt, IN PIRP Irp);
VOID                        HidpDestroyCollection(FDO_EXTENSION *fdoExt, PHIDCLASS_COLLECTION Collection);
VOID                        CollectionPowerRequestCompletion(IN PDEVICE_OBJECT DeviceObject, IN UCHAR MinorFunction, IN POWER_STATE PowerState, IN PVOID Context, IN PIO_STATUS_BLOCK IoStatus);
VOID                        DevicePowerRequestCompletion(IN PDEVICE_OBJECT DeviceObject, IN UCHAR MinorFunction, IN POWER_STATE PowerState, IN PVOID Context, IN PIO_STATUS_BLOCK IoStatus);
NTSTATUS                    HidpQueryCapsCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);
NTSTATUS                    HidpQueryDeviceCapabilities(IN PDEVICE_OBJECT PdoDeviceObject, IN PDEVICE_CAPABILITIES DeviceCapabilities);
VOID                        DestroyPingPongs(FDO_EXTENSION *fdoExt);
VOID                        CheckReportPowerEvent(FDO_EXTENSION *fdoExt, PHIDCLASS_COLLECTION collection, PUCHAR report, ULONG reportLen);
BOOLEAN                     StartPollingLoop(FDO_EXTENSION *fdoExt, PHIDCLASS_COLLECTION hidCollection, BOOLEAN freshQueue);
VOID                        StopPollingLoop(PHIDCLASS_COLLECTION hidCollection, BOOLEAN flushQueue);
BOOLEAN                     ReadPolledDevice(PDO_EXTENSION *pdoExt, BOOLEAN isTimerDrivenRead);
VOID                        PolledReadCancelRoutine(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
VOID                        EnqueueFdoExt(FDO_EXTENSION *fdoExt);
VOID                        DequeueFdoExt(FDO_EXTENSION *fdoExt);
NTSTATUS                    AllocDeviceResources(FDO_EXTENSION *fdoExt);
VOID                        FreeDeviceResources(FDO_EXTENSION *fdoExt);
NTSTATUS                    AllocCollectionResources(FDO_EXTENSION *fdoExt, ULONG collectionNum);
VOID                        FreeCollectionResources(FDO_EXTENSION *fdoExt, ULONG collectionNum);
NTSTATUS                    InitializeCollection(FDO_EXTENSION *fdoExt, ULONG collectionIndex);
NTSTATUS                    HidpStartCollectionPDO(FDO_EXTENSION *fdoExt, PDO_EXTENSION *pdoExt, PIRP Irp);
NTSTATUS                    HidpStartDevice(PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, PIRP Irp);
PWCHAR                      SubstituteBusNames(PWCHAR oldIDs, FDO_EXTENSION *fdoExt, PDO_EXTENSION *pdoExt);
PWSTR                       BuildCompatibleID(PHIDCLASS_DEVICE_EXTENSION hidClassExtension);
PUNICODE_STRING             MakeClientPDOName(PUNICODE_STRING fdoName, ULONG collectionId);
VOID                        HidpPingpongBackoffTimerDpc(IN PKDPC Dpc, IN PVOID DeferredContext, IN PVOID SystemArgument1, IN PVOID SystemArgument2);
BOOLEAN                     WStrCompareN(PWCHAR str1, PWCHAR str2, ULONG maxChars);
NTSTATUS                    SubmitWaitWakeIrp(PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension);
BOOLEAN                     HidpIsWaitWakePending(FDO_EXTENSION *fdoExt, BOOLEAN setIfNotPending);
NTSTATUS                    HidpWaitWakeComplete(IN PDEVICE_OBJECT DeviceObject, IN UCHAR MinorFunction, IN POWER_STATE PowerState, IN PVOID Context, IN PIO_STATUS_BLOCK IoStatus);
NTSTATUS                    HidpGetIndexedString(IN FDO_EXTENSION *fdoExt, IN OUT PIRP Irp, IN ULONG stringIndex, IN ULONG languageId);
VOID                        CompleteAllPendingReadsForCollection(PHIDCLASS_COLLECTION Collection);
VOID                        CompleteAllPendingReadsForFileExtension(PHIDCLASS_COLLECTION Collection, PHIDCLASS_FILE_EXTENSION fileExtension);
VOID                        CompleteAllPendingReadsForDevice(FDO_EXTENSION *fdoExt);
BOOLEAN                     MyPrivilegeCheck(PIRP Irp);
NTSTATUS                    QueuePowerEventIrp(PHIDCLASS_COLLECTION hidCollection, PIRP Irp);
VOID                        PowerEventCancelRoutine(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS                    HidpPolledReadComplete(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);
NTSTATUS                    HidpPolledReadComplete_TimerDriven(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);
VOID                        CollectionWaitWakeIrpCancelRoutine(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
VOID                        CompleteAllCollectionWaitWakeIrps(FDO_EXTENSION *fdoExt, NTSTATUS status);
VOID                        PowerDelayedCancelRoutine(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS                    EnqueuePowerDelayedIrp(PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, PIRP Irp);
PIRP                        DequeuePowerDelayedIrp(FDO_EXTENSION *fdoExt);
ULONG                       DequeueAllPdoPowerDelayedIrps(PDO_EXTENSION *pdoExt, PLIST_ENTRY dequeue);
VOID                        ReadDeviceFlagsFromRegistry(FDO_EXTENSION *fdoExt, PDEVICE_OBJECT pdo);
LONG                        WStrNCmpI(PWCHAR s1, PWCHAR s2, ULONG n);
ULONG                       LAtoX(PWCHAR wHexString);
ULONG                       WStrNCpy(PWCHAR dest, PWCHAR src, ULONG n);
NTSTATUS                    OpenSubkey(OUT PHANDLE Handle, IN HANDLE BaseHandle, IN PUNICODE_STRING KeyName, IN ACCESS_MASK DesiredAccess);
void                        HidpNumberToString(PWCHAR String, USHORT Number, USHORT stringLen);
NTSTATUS                                        GetHIDRawReportDescriptor(FDO_EXTENSION *fdoExt, PIRP irp, ULONG descriptorLen);
VOID                        WorkItemCallback_CompleteIrpAsynchronously(PDEVICE_OBJECT DevObj,PVOID context);
NTSTATUS                    EnqueueInterruptReadIrp(PHIDCLASS_COLLECTION collection, PHIDCLASS_FILE_EXTENSION fileExtension, PIRP Irp);
PIRP                        DequeueInterruptReadIrp(PHIDCLASS_COLLECTION collection, PHIDCLASS_FILE_EXTENSION fileExtension);
NTSTATUS                    EnqueuePolledReadIrp(PHIDCLASS_COLLECTION collection, PIRP Irp);
PIRP                        DequeuePolledReadSystemIrp(PHIDCLASS_COLLECTION collection);
PIRP                        DequeuePolledReadIrp(PHIDCLASS_COLLECTION collection);
NTSTATUS                    HidpProcessInterruptReport(PHIDCLASS_COLLECTION collection, PHIDCLASS_FILE_EXTENSION FileExtension, PUCHAR Report, ULONG ReportLength, PIRP *irpToComplete);
VOID                        HidpFreePowerEventIrp(PHIDCLASS_COLLECTION Collection);
NTSTATUS                    HidpGetMsGenreDescriptor(IN FDO_EXTENSION *fdoExt, IN OUT PIRP Irp);
NTSTATUS                    DllUnload(VOID);
NTSTATUS                    DllInitialize (PUNICODE_STRING RegistryPath);
VOID                        HidpPowerUpPdos(IN PFDO_EXTENSION fdoExt);
NTSTATUS                    HidpDelayedPowerPoRequestComplete(IN PDEVICE_OBJECT DeviceObject, IN UCHAR MinorFunction, IN POWER_STATE PowerState, IN PVOID Context, IN PIO_STATUS_BLOCK IoStatus);
NTSTATUS                    HidpIrpMajorSystemControl(PHIDCLASS_DEVICE_EXTENSION DeviceObject, PIRP Irp);
NTSTATUS                    HidpSetWmiDataItem(PDEVICE_OBJECT DeviceObject, PIRP Irp, ULONG GuidIndex, ULONG InstanceIndex, ULONG DataItemId, ULONG BufferSize, PUCHAR Buffer);
NTSTATUS                    HidpSetWmiDataBlock(PDEVICE_OBJECT DeviceObject, PIRP Irp, ULONG GuidIndex, ULONG InstanceIndex, ULONG BufferSize, PUCHAR Buffer);
NTSTATUS                    HidpQueryWmiDataBlock( PDEVICE_OBJECT DeviceObject, PIRP Irp, ULONG GuidIndex, ULONG InstanceIndex, ULONG InstanceCount, OUT PULONG InstanceLengthArray, ULONG BufferAvail, PUCHAR Buffer);
NTSTATUS                    HidpQueryWmiRegInfo( PDEVICE_OBJECT DeviceObject, ULONG *RegFlags, PUNICODE_STRING InstanceName, PUNICODE_STRING *RegistryPath, PUNICODE_STRING MofResourceName, PDEVICE_OBJECT  *Pdo);
BOOLEAN                     HidpCreateRemoteWakeIrp (PDO_EXTENSION *PdoExt);
void                        HidpCreateRemoteWakeIrpWorker (PDEVICE_OBJECT DeviceObject, PHIDCLASS_WORK_ITEM_DATA  ItemData);
NTSTATUS                    HidpToggleRemoteWake(PDO_EXTENSION *PdoExt, BOOLEAN RemoteWakeState);


#if DBG
    VOID InitFdoExtDebugInfo(PHIDCLASS_DEVICE_EXTENSION hidclassExt);
#endif


extern ULONG HidpNextHidNumber;
extern FDO_EXTENSION *allFdoExtensions;
extern KSPIN_LOCK allFdoExtensionsSpinLock;

PVOID
HidpGetSystemAddressForMdlSafe(PMDL MdlAddress);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidclass\driverex.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    driverex.c

Abstract

    Driver extension list management.

Authors:

    Ervin P.

Environment:

    Kernel mode only

Revision History:


--*/

#include "pch.h"

/*
 *  Including initguid.h defines the INITGUID symbol, which causes
 *  GUID_CLASS_INPUT (in hidclass.h and poclass.h) 
 *  and GUID_DEVICE_SYS_BUTTON (in poclass.h) to get defined.
 */
#include <initguid.h>
#include <hidclass.h>   // hidclass.h only defines GUID_CLASS_INPUT 
#include <wdmguid.h>

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, DllInitialize)
    #pragma alloc_text(PAGE, DllUnload)
    #pragma alloc_text(PAGE, DriverEntry)
#endif


LIST_ENTRY driverExtList;
FAST_MUTEX driverExtListMutex;

//
// Global counter of HID FDOs used for device object naming, destined to go
// away once the device object naming issues are ironed out
//

ULONG HidpNextHidNumber = 0;

#define MAKEULONG(low, high)     ((ULONG)(((USHORT)(low)) | (((ULONG)((USHORT)(high))) << 16)))

/*
 ********************************************************************************
 *  EnqueueDriverExt
 ********************************************************************************
 *
 *
 */
BOOLEAN EnqueueDriverExt(PHIDCLASS_DRIVER_EXTENSION driverExt)
{
    PLIST_ENTRY listEntry;
    BOOLEAN result = TRUE;

    DBGVERBOSE(("Enqueue driver extension..."));
    ExAcquireFastMutex(&driverExtListMutex);

    /*
     *  Make sure this driver entry is not already in our list.
     */
    listEntry = &driverExtList;
    while ((listEntry = listEntry->Flink) != &driverExtList){
        PHIDCLASS_DRIVER_EXTENSION thisDriverExt;

        thisDriverExt = CONTAINING_RECORD(  listEntry,
                                            HIDCLASS_DRIVER_EXTENSION,
                                            ListEntry);
        if (thisDriverExt == driverExt){
            /*
             *  This driver extension is already in our list!
             */
            ASSERT(thisDriverExt != driverExt);
            result = FALSE;
            break;
        }
    }

    if (result){
        InsertHeadList(&driverExtList, &driverExt->ListEntry);
    }

    ExReleaseFastMutex(&driverExtListMutex);

    return result;
}

/*
 ********************************************************************************
 *  RefDriverExt
 ********************************************************************************
 *
 *
 */
PHIDCLASS_DRIVER_EXTENSION RefDriverExt(IN PDRIVER_OBJECT MinidriverObject)
{
    PLIST_ENTRY listEntry;
    PHIDCLASS_DRIVER_EXTENSION hidDriverExtension, result = NULL;

    DBGVERBOSE(("Ref driver extension..."));
    ExAcquireFastMutex(&driverExtListMutex);

    listEntry = &driverExtList;
    while ((listEntry = listEntry->Flink) != &driverExtList){

        hidDriverExtension = CONTAINING_RECORD( listEntry,
                                                HIDCLASS_DRIVER_EXTENSION,
                                                ListEntry );
        ASSERT(ISPTR(hidDriverExtension));
        if (hidDriverExtension->MinidriverObject == MinidriverObject){
            hidDriverExtension->ReferenceCount++;
            result = hidDriverExtension;
            break;
        }
    }

    ExReleaseFastMutex(&driverExtListMutex);

    ASSERT(result);
    return result;
}


/*
 ********************************************************************************
 *  DerefDriverExt
 ********************************************************************************
 *
 */
PHIDCLASS_DRIVER_EXTENSION DerefDriverExt(IN PDRIVER_OBJECT MinidriverObject)
{
    PLIST_ENTRY listEntry;
    PHIDCLASS_DRIVER_EXTENSION result = NULL;

    DBGVERBOSE(("Deref driver extension..."));
    ExAcquireFastMutex(&driverExtListMutex);

    listEntry = &driverExtList;
    while ((listEntry = listEntry->Flink) != &driverExtList){

        PHIDCLASS_DRIVER_EXTENSION hidDriverExtension = 
                CONTAINING_RECORD(  listEntry,
                                    HIDCLASS_DRIVER_EXTENSION,
                                    ListEntry);
        ASSERT(ISPTR(hidDriverExtension));

        if (hidDriverExtension->MinidriverObject == MinidriverObject){

            hidDriverExtension->ReferenceCount--;
            
            /*
             *  The extra dereference in HidpDriverUnload should
             *  cause this ReferenceCount to eventually go to -1;
             *  at that time, we can dequeue it.
             */
            if (hidDriverExtension->ReferenceCount < 0){
                /*
                 *  No need to free hidDriverExtension;
                 *  it gets freed when the driver object is freed.
                 */
                ASSERT(hidDriverExtension->ReferenceCount == -1);
                RemoveEntryList(listEntry);
                if (hidDriverExtension->RegistryPath.Buffer) {
                    ExFreePool(hidDriverExtension->RegistryPath.Buffer);
                }
            }

            result = hidDriverExtension; 
            break;
        }
    }

    ExReleaseFastMutex(&driverExtListMutex);

    ASSERT(result);
    return result;
}

/*
 ********************************************************************************
 *  DllUnload
 ********************************************************************************
 *
 *  We need this routine so that the driver can get unloaded when all 
 *  references have been dropped by the minidriver.
 *
 */
NTSTATUS 
DllUnload (VOID)
{
    PAGED_CODE();
    DBGVERBOSE(("Unloading..."));
    return STATUS_SUCCESS;
}

/*
 ********************************************************************************
 *  DllInitialize
 ********************************************************************************
 *
 *  This routine called instead of DriverEntry since we're loaded as a DLL. 
 *
 */
NTSTATUS 
DllInitialize (PUNICODE_STRING RegistryPath)
{
    PAGED_CODE();
    DBGVERBOSE(("Initializing hidclass dll..."));
    InitializeListHead(&driverExtList);
    ExInitializeFastMutex(&driverExtListMutex);

    HidpNextHidNumber = 0;
    
    return STATUS_SUCCESS;
}

/*
 ********************************************************************************
 *  DriverEntry
 ********************************************************************************
 *
 *  This routine is required by the linker, 
 *  but SHOULD NEVER BE CALLED since we're loaded as a DLL. 
 *
 */
NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
{
    UNREFERENCED_PARAMETER(DriverObject);
    UNREFERENCED_PARAMETER(RegistryPath);

    PAGED_CODE();
    ASSERT(!(PVOID)"DriverEntry should never get called!");

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidclass\dispatch.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dispatch.c

Abstract

    Dispatch routines for the HID class driver.

Author:

    Ervin P.

Environment:

    Kernel mode only

Revision History:


--*/

#include "pch.h"
#include <poclass.h>
#include <wdmguid.h>

#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, HidpCallDriverSynchronous)
        #pragma alloc_text(PAGE, HidpIrpMajorPnp)
        #pragma alloc_text(PAGE, HidpFdoPnp)
        #pragma alloc_text(PAGE, HidpPdoPnp)
#endif



/*
 ********************************************************************************
 *  HidpCallDriver
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpCallDriver(IN PDEVICE_OBJECT DeviceObject, IN OUT PIRP Irp)
{
    PHIDCLASS_DEVICE_EXTENSION hidDeviceExtension;
    PHIDCLASS_DRIVER_EXTENSION hidDriverExtension;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    #if DBG
        KIRQL saveIrql;
    #endif

    DBGASSERT((Irp->Type == IO_TYPE_IRP),
              ("Irp->Type != IO_TYPE_IRP, Irp->Type == %x", Irp->Type),
              TRUE)

    /*
     *  Update the IRP stack to point to the next location.
     */
    Irp->CurrentLocation--;

    if (Irp->CurrentLocation <= 0) {
        KeBugCheckEx( NO_MORE_IRP_STACK_LOCATIONS, (ULONG_PTR) Irp, 0, 0, 0 );
    }

    irpSp = IoGetNextIrpStackLocation( Irp );
    Irp->Tail.Overlay.CurrentStackLocation = irpSp;

    //
    // Save a pointer to the device object for this request so that it can
    // be used later in completion.
    //

    irpSp->DeviceObject = DeviceObject;

    //
    // Get a pointer to the class extension and verify it.
    //
    hidDeviceExtension = (PHIDCLASS_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    ASSERT(hidDeviceExtension->Signature == HID_DEVICE_EXTENSION_SIG);
    ASSERT(!hidDeviceExtension->isClientPdo);

    //
    // Ditto for the driver extension
    //

    hidDriverExtension = hidDeviceExtension->fdoExt.driverExt;
    ASSERT( hidDriverExtension->Signature == HID_DRIVER_EXTENSION_SIG );

    //
    // Invoke the driver at its dispatch routine entry point.
    //

    #if DBG
        saveIrql = KeGetCurrentIrql();
    #endif

    /*
     *  Call down to the minidriver
     */
    status = hidDriverExtension->MajorFunction[irpSp->MajorFunction](DeviceObject, Irp);

    #if DBG
        if (saveIrql != KeGetCurrentIrql()) {
            DbgPrint( "IO: HidpCallDriver( Driver ext: %x  Device object: %x  Irp: %x )\n",
                      hidDriverExtension,
                      DeviceObject,
                      Irp
                    );
            DbgPrint( "    Irql before: %x  != After: %x\n", saveIrql, KeGetCurrentIrql() );
            DbgBreakPoint();
        }
    #endif

    return status;
}



/*
 ********************************************************************************
 *  HidpSynchronousCallCompletion
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpSynchronousCallCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
{
    PKEVENT event = Context;

    DBG_COMMON_ENTRY()

    KeSetEvent(event, 0, FALSE);

    DBG_COMMON_EXIT()
    return STATUS_MORE_PROCESSING_REQUIRED;
}



/*
 ********************************************************************************
 *  HidpCallDriverSynchronous
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpCallDriverSynchronous(IN PDEVICE_OBJECT DeviceObject, IN OUT PIRP Irp)
{
    KEVENT event;
    NTSTATUS status;
    static LARGE_INTEGER timeout = {(ULONG) -50000000, 0xFFFFFFFF };

    PAGED_CODE();

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(Irp, HidpSynchronousCallCompletion, &event, TRUE, TRUE, TRUE);

    status = HidpCallDriver(DeviceObject, Irp);

    if (STATUS_PENDING == status) {
        //
        // Wait for 5 seconds. If we don't get a response within said amount
        // of time, the device is being unresponsive (happens with some UPS').
        // At that point, cancel the irp and return STATUS_IO_TIMEOUT.
        //
        status = KeWaitForSingleObject(&event,
                                       Executive,      // wait reason
                                       KernelMode,
                                       FALSE,          // not alertable
                                       &timeout );     // 5 second timeout

        if (status == STATUS_TIMEOUT) {
            #if DBG
                LARGE_INTEGER li;
                KeQueryTickCount(&li);
                DBGWARN(("Could not cancel irp. Will have to wait. Time %x.",Irp,li))
            #endif
            DBGWARN(("Device didn't respond for 5 seconds. Cancelling request. Irp %x",Irp))
            IoCancelIrp(Irp);
            KeWaitForSingleObject(&event,
                                  Executive,      // wait reason
                                  KernelMode,
                                  FALSE,          // not alertable
                                  NULL );         // no timeout
            #if DBG
                KeQueryTickCount(&li);
                DBGWARN(("Irp conpleted. Time %x.",li))
            #endif
            //
            // If we successfully cancelled the irp, then set the status to
            // STATUS_IO_TIMEOUT, otherwise, leave the status alone.
            //
            status = Irp->IoStatus.Status =
                (Irp->IoStatus.Status == STATUS_CANCELLED) ? STATUS_IO_TIMEOUT : Irp->IoStatus.Status;
        } else {
            //
            // The minidriver must always return STATUS_PENDING or STATUS_SUCCESS
            // (depending on async or sync completion) and set the real status
            // in the status block.  We're not expecting anything but success from
            // KeWaitForSingleObject, either.
            //
            status = Irp->IoStatus.Status;
        }
    }

    DBGSUCCESS(status, FALSE)

    return status;
}



/*
 ********************************************************************************
 *  HidpMajorHandler
 ********************************************************************************
 *
 *  Note: this function should not be pageable because
 *        reads can come in at dispatch level.
 *
 */
NTSTATUS HidpMajorHandler(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    PHIDCLASS_DEVICE_EXTENSION hidClassExtension;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS result;
    UCHAR majorFunction;
    BOOLEAN isClientPdo;

    DBG_COMMON_ENTRY()

    hidClassExtension = (PHIDCLASS_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    ASSERT(hidClassExtension->Signature == HID_DEVICE_EXTENSION_SIG);

    //
    // Get a pointer to the current stack location and dispatch to the
    // appropriate routine.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    /*
     *  Keep these privately so we still have it after the IRP completes
     *  or after the device extension is freed on a REMOVE_DEVICE
     */
    majorFunction = irpSp->MajorFunction;
    isClientPdo = hidClassExtension->isClientPdo;

    DBG_LOG_IRP_MAJOR(Irp, majorFunction, isClientPdo, FALSE, 0)

    switch (majorFunction){

    case IRP_MJ_CLOSE:
        result = HidpIrpMajorClose( hidClassExtension, Irp );
        break;

    case IRP_MJ_CREATE:
        result = HidpIrpMajorCreate( hidClassExtension, Irp );
        break;

    case IRP_MJ_DEVICE_CONTROL:
        result = HidpIrpMajorDeviceControl( hidClassExtension, Irp );
        break;

    case IRP_MJ_INTERNAL_DEVICE_CONTROL:
        result = HidpIrpMajorINTERNALDeviceControl( hidClassExtension, Irp );
        break;

    case IRP_MJ_PNP:
        result = HidpIrpMajorPnp( hidClassExtension, Irp );
        break;

    case IRP_MJ_POWER:
        result = HidpIrpMajorPower( hidClassExtension, Irp );
        break;

    case IRP_MJ_READ:
        result = HidpIrpMajorRead( hidClassExtension, Irp );
        break;

    case IRP_MJ_WRITE:
        result = HidpIrpMajorWrite( hidClassExtension, Irp );
        break;

    case IRP_MJ_SYSTEM_CONTROL:
        result = HidpIrpMajorSystemControl( hidClassExtension, Irp );
        break;

    default:
        result = HidpIrpMajorDefault( hidClassExtension, Irp );
        break;
    }

    DBG_LOG_IRP_MAJOR(Irp, majorFunction, isClientPdo, TRUE, result)

    DBG_COMMON_EXIT()

    return result;
}


/*
 ********************************************************************************
 *  HidpIrpMajorDefault
 ********************************************************************************
 *
 *  Handle IRPs with un-handled MAJOR function codes
 *
 */
NTSTATUS HidpIrpMajorDefault(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp)
{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    DBGVERBOSE(("Unhandled IRP, MJ function: %x", irpSp->MajorFunction))

    if (HidDeviceExtension->isClientPdo){
        /*
         *  This IRP is bound for the collection-PDO.
         *  Return the default status.
         */
        status = Irp->IoStatus.Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    else {
        /*
         *  This IRP is bound for the lower device.
         *  Pass it down the stack.
         */
        FDO_EXTENSION *fdoExt = &HidDeviceExtension->fdoExt;
        IoCopyCurrentIrpStackLocationToNext(Irp);
        status = HidpCallDriver(fdoExt->fdo, Irp);
    }

    DBGSUCCESS(status, FALSE)
    return status;
}


/*
 ********************************************************************************
 *  HidpIrpMajorClose
 ********************************************************************************
 *
 *  Note: this function cannot be pageable because it
 *        acquires a spinlock.
 *
 */
NTSTATUS HidpIrpMajorClose(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp)
{
    NTSTATUS                    result;

    ASSERT(HidDeviceExtension->Signature == HID_DEVICE_EXTENSION_SIG);

    if (HidDeviceExtension->isClientPdo){

        PIO_STACK_LOCATION          irpSp;
        PHIDCLASS_FILE_EXTENSION    fileExtension;
        PFILE_OBJECT                fileObject;
        KIRQL                       oldIrql;
        PDO_EXTENSION               *pdoExt;
        FDO_EXTENSION               *fdoExt;
        ULONG                       openCount;

        pdoExt = &HidDeviceExtension->pdoExt;
        fdoExt = &pdoExt->deviceFdoExt->fdoExt;

        ASSERT(fdoExt->openCount > 0);

        Irp->IoStatus.Information = 0;

        irpSp = IoGetCurrentIrpStackLocation( Irp );
        fileObject = irpSp->FileObject;
        fileExtension = (PHIDCLASS_FILE_EXTENSION)fileObject->FsContext;

        openCount = InterlockedDecrement(&fdoExt->openCount);

        if (fileExtension){
            PHIDCLASS_COLLECTION classCollection;

            ASSERT(fileExtension->Signature == HIDCLASS_FILE_EXTENSION_SIG);

            /*
             *  Get a pointer to the collection that our file extension is queued on.
             */
            classCollection = GetHidclassCollection(fdoExt, pdoExt->collectionNum);
            if (classCollection){

                DBGVERBOSE(("  HidpIrpMajorClose: closing collection w/ usagePage=%xh, usage=%xh.", fdoExt->deviceDesc.CollectionDesc[pdoExt->collectionIndex].UsagePage, fdoExt->deviceDesc.CollectionDesc[pdoExt->collectionIndex].Usage))

                if (fdoExt->state == DEVICE_STATE_REMOVED){

                    KeAcquireSpinLock( &classCollection->FileExtensionListSpinLock, &oldIrql );
                    RemoveEntryList(&fileExtension->FileList);
                    KeReleaseSpinLock( &classCollection->FileExtensionListSpinLock, oldIrql );

                    if (fileExtension->isSecureOpen) {
                        
                        KeAcquireSpinLock(&classCollection->secureReadLock,
                                          &oldIrql);

                        while(fileExtension->SecureReadMode--) {

                            classCollection->secureReadMode--;

                        }

                        KeReleaseSpinLock(&classCollection->secureReadLock,
                                          oldIrql);

                    }

                    HidpDestroyFileExtension(classCollection, fileExtension);

                    classCollection = BAD_POINTER;

                    /*
                     *  Delete the device-FDO and all collection-PDOs
                     *  Don't touch fdoExt after this.
                     */
                    HidpCleanUpFdo(fdoExt);

                    result = STATUS_SUCCESS;
                }
                else {
                    //
                    // Destroy the file object and everything on it
                    //
                    KeAcquireSpinLock(&classCollection->FileExtensionListSpinLock, &oldIrql);

                    /*
                     *  Update sharing information:
                     *  Decrement open counts and clear any exclusive holds of this file extension
                     *  on the device extension.
                     */
                    ASSERT(pdoExt->openCount > 0);
                    InterlockedDecrement(&pdoExt->openCount);
                    if (fileExtension->accessMask & FILE_READ_DATA){
                        ASSERT(pdoExt->opensForRead > 0);
                        pdoExt->opensForRead--;
                    }
                    if (fileExtension->accessMask & FILE_WRITE_DATA){
                        ASSERT(pdoExt->opensForWrite > 0);
                        pdoExt->opensForWrite--;
                    }
                    if (!(fileExtension->shareMask & FILE_SHARE_READ)){
                        ASSERT(pdoExt->restrictionsForRead > 0);
                        pdoExt->restrictionsForRead--;
                    }
                    if (!(fileExtension->shareMask & FILE_SHARE_WRITE)){
                        ASSERT(pdoExt->restrictionsForWrite > 0);
                        pdoExt->restrictionsForWrite--;
                    }
                    if (fileExtension->shareMask == 0){
                        ASSERT(pdoExt->restrictionsForAnyOpen > 0);
                        pdoExt->restrictionsForAnyOpen--;
                    }

                    RemoveEntryList(&fileExtension->FileList);

                    KeReleaseSpinLock(&classCollection->FileExtensionListSpinLock, oldIrql);

                    if (fileExtension->isSecureOpen) {
                        
                        KeAcquireSpinLock(&classCollection->secureReadLock,
                                          &oldIrql);

                        while(fileExtension->SecureReadMode--) {

                            classCollection->secureReadMode--;

                        }

                        KeReleaseSpinLock(&classCollection->secureReadLock,
                                          oldIrql);

                    }



                    HidpDestroyFileExtension(classCollection, fileExtension);



                    result = STATUS_SUCCESS;
                }

            }
            else {
                result = STATUS_DATA_ERROR;
            }
        }
        else {
            TRAP;
            result = STATUS_DEVICE_NOT_CONNECTED;
        }

        DBGVERBOSE(("  HidpIrpMajorClose: openCount decremented to %xh/%xh (pdo/fdo).", openCount, fdoExt->openCount))
    }
    else {
        DBGERR(("IRP_MJ_CLOSE was sent with a device-FDO extension for which an open never succeeded.  The OBJDIR test tool does this sometimes.  Hit 'g'."))
        result = STATUS_INVALID_PARAMETER_1;
    }

    Irp->IoStatus.Status = result;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGSUCCESS(result, FALSE)
    return result;
}



/*
 ********************************************************************************
 *  HidpIrpMajorCreate
 ********************************************************************************
 *
 *
 *   Routine Description:
 *
 *       We connect up to the interrupt for the create/open and initialize
 *       the structures needed to maintain an open for a device.
 *
 *  Arguments:
 *
 *       DeviceObject - Pointer to the device object for this device
 *
 *       Irp - Pointer to the IRP for the current request
 *
 *   Return Value:
 *
 *       The function value is the final status of the call
 *
 */
NTSTATUS HidpIrpMajorCreate(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp)
{
    NTSTATUS status = STATUS_SUCCESS;

    ASSERT(HidDeviceExtension->Signature == HID_DEVICE_EXTENSION_SIG);

    if (HidDeviceExtension->isClientPdo){
        PDO_EXTENSION *pdoExt = &HidDeviceExtension->pdoExt;
        FDO_EXTENSION *fdoExt = &pdoExt->deviceFdoExt->fdoExt;
        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
        PHIDCLASS_COLLECTION classCollection;

        Irp->IoStatus.Information = 0;

        classCollection = GetHidclassCollection(fdoExt, pdoExt->collectionNum);
        if (classCollection){
            BOOLEAN sharingOk = TRUE;
            KIRQL oldIrql;
            BOOLEAN secureOpen = FALSE;

            secureOpen = MyPrivilegeCheck(Irp);

            // This is now taken care of by the fact that we don't
            // enumerate mouse and keyboard collections as RAW.

            KeAcquireSpinLock(&classCollection->FileExtensionListSpinLock, &oldIrql);

            /*
             *  Enforce exclusive-open independently for exclusive-read and exclusive-write.
             */
            ASSERT(irpSp->Parameters.Create.SecurityContext);
            DBGVERBOSE(("  HidpIrpMajorCreate: DesiredAccess = %xh, ShareAccess = %xh.", (ULONG)irpSp->Parameters.Create.SecurityContext->DesiredAccess, (ULONG)irpSp->Parameters.Create.ShareAccess))

            DBGASSERT((irpSp->Parameters.Create.SecurityContext->DesiredAccess & (FILE_READ_DATA|FILE_WRITE_DATA)),
                      ("Neither FILE_READ_DATA|FILE_WRITE_DATA requested in HidpIrpMajorCreate. DesiredAccess = %xh.", (ULONG)irpSp->Parameters.Create.SecurityContext->DesiredAccess),
                      FALSE)
            if (pdoExt->restrictionsForAnyOpen){
                /*
                 *  Oops.  A previous open requested exclusive access.
                 *         Not even a client that requests only ioctl access
                 *         (does not request read nor write acess) is
                 *         allowed.
                 */
                DBGWARN(("HidpIrpMajorCreate failing open: previous open is non-shared (ShareAccess==0)."))
                sharingOk = FALSE;
            }
            else if (pdoExt->openCount &&
                     (irpSp->Parameters.Create.ShareAccess == 0)){
                /*
                 *  Oops.  This open does not allow any sharing
                 *         (not even with a client that has neither read nor write access),
                 *         but there exists a previous open.
                 */
                DBGWARN(("HidpIrpMajorCreate failing open: requesting non-shared (ShareAccess==0) while previous open exists."))
                sharingOk = FALSE;
            }
            else if ((irpSp->Parameters.Create.SecurityContext->DesiredAccess & FILE_READ_DATA) &&
                pdoExt->restrictionsForRead){
                /*
                 *  Oops. A previous open requested exclusive-read access.
                 */
                DBGWARN(("HidpIrpMajorCreate failing open: requesting read access while previous open does not share read access."))
                sharingOk = FALSE;
            }
            else if ((irpSp->Parameters.Create.SecurityContext->DesiredAccess & FILE_WRITE_DATA) &&
                pdoExt->restrictionsForWrite){
                /*
                 *  Oops. A previous open requested exclusive-write access.
                 */
                DBGWARN(("HidpIrpMajorCreate failing open: requesting write access while previous open does not share write access."))
                sharingOk = FALSE;
            }
            else if ((pdoExt->opensForRead > 0) &&
                !(irpSp->Parameters.Create.ShareAccess & FILE_SHARE_READ)){

                /*
                 *  Oops. The caller is requesting exclusive read access, but the device
                 *        is already open for read.
                 */
                DBGWARN(("HidpIrpMajorCreate failing open: this open request does not share read access; but collection already open for read."))
                sharingOk = FALSE;
            }
            else if ((pdoExt->opensForWrite > 0) &&
                !(irpSp->Parameters.Create.ShareAccess & FILE_SHARE_WRITE)){

                /*
                 *  Oops. The caller is requesting exclusive write access, but the device
                 *        is already open for write.
                 */
                DBGWARN(("HidpIrpMajorCreate failing open: this open request does not share write access; but collection already open for write."))
                sharingOk = FALSE;
            }


            if (!sharingOk){
                DBGWARN(("HidpIrpMajorCreate failing IRP_MJ_CREATE with STATUS_SHARING_VIOLATION."))
                status = STATUS_SHARING_VIOLATION;
            }
            
            else {
                if (irpSp->Parameters.Create.Options & FILE_DIRECTORY_FILE){
                    /*
                     *  Attempt to open this device as a directory
                     */
                    status = STATUS_NOT_A_DIRECTORY;
                } else {

                    /*
                     *  Make sure the device is started.
                     *  If it is temporarily stopped, we also succeed because a stop
                     *  is supposed to be transparent to the client.
                     */
                    if (((fdoExt->state == DEVICE_STATE_START_SUCCESS) ||
                         (fdoExt->state == DEVICE_STATE_STOPPING) ||
                         (fdoExt->state == DEVICE_STATE_STOPPED))
                                                                        &&
                        ((pdoExt->state == COLLECTION_STATE_RUNNING) ||
                         (pdoExt->state == COLLECTION_STATE_STOPPING) ||
                         (pdoExt->state == COLLECTION_STATE_STOPPED))){

                        PHIDCLASS_FILE_EXTENSION fileExtension;

                        /*
                         *  We have a valid collection.
                         *  Allocate a file object extension (which encapsulates an 'open' on the device).
                         */
                        try {

                            fileExtension = ALLOCATEQUOTAPOOL(NonPagedPool, 
                                                              sizeof(HIDCLASS_FILE_EXTENSION));
                            
                        } except (EXCEPTION_EXECUTE_HANDLER) {
                              
                              fileExtension = NULL;
                              status = GetExceptionCode();
                              
                        }
                        
                        if (fileExtension){
                            PHIDP_COLLECTION_DESC   hidCollectionDesc;

                            RtlZeroMemory(fileExtension, sizeof(HIDCLASS_FILE_EXTENSION));

                            fileExtension->CollectionNumber = pdoExt->collectionNum;
                            fileExtension->fdoExt = fdoExt;
                            fileExtension->FileObject = irpSp->FileObject;

                            fileExtension->isOpportunisticPolledDeviceReader = FALSE;
                            
                            InitializeListHead( &fileExtension->ReportList );
                            InitializeListHead( &fileExtension->PendingIrpList );
                            KeInitializeSpinLock( &fileExtension->ListSpinLock );
                            fileExtension->Closing = FALSE;

                            //
                            // Right now we'll set a default maximum input report queue size.
                            // This can be changed later with an IOCTL.
                            //

                            fileExtension->CurrentInputReportQueueSize = 0;
                            fileExtension->MaximumInputReportQueueSize = DEFAULT_INPUT_REPORT_QUEUE_SIZE;
                            fileExtension->insideReadCompleteCount = 0;

                            //
                            // Add this file extension to the list of file extensions for this
                            // collection.
                            //

                            InsertHeadList(&classCollection->FileExtensionList, &fileExtension->FileList);

                            #if DBG
                                fileExtension->Signature = HIDCLASS_FILE_EXTENSION_SIG;
                            #endif

                            /*
                             *  Store the file-open attribute flags.
                             */
                            fileExtension->FileAttributes = irpSp->Parameters.Create.FileAttributes;
                            fileExtension->accessMask = irpSp->Parameters.Create.SecurityContext->DesiredAccess;
                            fileExtension->shareMask = irpSp->Parameters.Create.ShareAccess;

                            // 
                            // Set up secure read mode
                            //
                            fileExtension->SecureReadMode = 0;
                            fileExtension->isSecureOpen = secureOpen;
                                                            
                            /*
                             *  Store a pointer to our file extension in the file object.
                             */
                            irpSp->FileObject->FsContext = fileExtension;

                            //
                            // KENRAY
                            // Only drivers can set the FsContext of file
                            // objects so this is not a security problem.
                            // However, there is only one file object for the entire
                            // PDO stack.  This means we have to share.  You cannot
                            // have both context pointers.  I need one for the
                            // keyboard and mouse class drivers.
                            //
                            // This information need go into the fileExtension.
                            //
                            
                            /*
                             *  Increment the device extension's open counts,
                             *  and set the exclusive-access fields.
                             */
                            InterlockedIncrement(&fdoExt->openCount);
                            InterlockedIncrement(&pdoExt->openCount);
                            if (irpSp->Parameters.Create.SecurityContext->DesiredAccess & FILE_READ_DATA){
                                pdoExt->opensForRead++;
                            }
                            if (irpSp->Parameters.Create.SecurityContext->DesiredAccess & FILE_WRITE_DATA){
                                pdoExt->opensForWrite++;
                            }

                            /*
                             *  NOTE:  Restrictions are independent of desired access.
                             *         For example, a client can do an open-for-read-only
                             *         AND prevent other clients from doing an open-for-write
                             *         (by not setting the FILE_SHARE_WRITE flag).
                             */
                            if (!(irpSp->Parameters.Create.ShareAccess & FILE_SHARE_READ)){
                                pdoExt->restrictionsForRead++;
                            }
                            if (!(irpSp->Parameters.Create.ShareAccess & FILE_SHARE_WRITE)){
                                pdoExt->restrictionsForWrite++;
                            }
                            if (irpSp->Parameters.Create.ShareAccess == 0){
                                /*
                                 *  ShareAccess==0 means that no other opens of any kind
                                 *  are allowed.
                                 */
                                pdoExt->restrictionsForAnyOpen++;
                            }

                            DBGVERBOSE(("  HidpIrpMajorCreate: opened collection w/ usagePage=%xh, usage=%xh.  openCount incremented to %xh/%xh (pdo/fdo).", fdoExt->deviceDesc.CollectionDesc[pdoExt->collectionIndex].UsagePage, fdoExt->deviceDesc.CollectionDesc[pdoExt->collectionIndex].Usage, pdoExt->openCount, fdoExt->openCount))
                        } else {
                            status = STATUS_INSUFFICIENT_RESOURCES;
                        }
                    } else {
                        status = STATUS_DEVICE_NOT_CONNECTED;
                    }
                }
            }

            KeReleaseSpinLock(&classCollection->FileExtensionListSpinLock, oldIrql);
        }
        else {
            DBGERR(("HidpIrpMajorCreate failing -- couldn't find collection"))
            status = STATUS_DEVICE_NOT_CONNECTED;
        }
    }
    else {
        /*
         *  We don't support opens on the device itself,
         *  only on the collections.
         */
        DBGWARN(("HidpIrpMajorCreate failing -- we don't support opens on the device itself; only on collections."))
        status = STATUS_UNSUCCESSFUL;
    }


    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    DBGSUCCESS(status, FALSE)
    return status;
}



/*
 ********************************************************************************
 *  HidpIrpMajorDeviceControl
 ********************************************************************************
 *
 *  Note:  This function cannot be pageable because IOCTLs
 *         can get sent at DISPATCH_LEVEL.
 *
 */
NTSTATUS HidpIrpMajorDeviceControl(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp)
{
    NTSTATUS        status;
    BOOLEAN         completeIrpHere = TRUE;
    PDO_EXTENSION   *pdoExt;
    FDO_EXTENSION   *fdoExt;
    ULONG           ioControlCode;
    KIRQL           irql;

    PIO_STACK_LOCATION irpSp;

    PHIDCLASS_COLLECTION        hidCollection;
    PHIDCLASS_FILE_EXTENSION    fileExtension;
    PFILE_OBJECT                fileObject;

    if (!HidDeviceExtension->isClientPdo){
        ASSERT(HidDeviceExtension->isClientPdo);
        status = STATUS_INVALID_PARAMETER_1;
        goto HidpIrpMajorDeviceControlDone;
    }

    pdoExt = &HidDeviceExtension->pdoExt;
    fdoExt = &pdoExt->deviceFdoExt->fdoExt;

    if (fdoExt->state != DEVICE_STATE_START_SUCCESS ||
        pdoExt->state != COLLECTION_STATE_RUNNING) {
        DBGSTATE (pdoExt->state, COLLECTION_STATE_RUNNING, FALSE)
        status = STATUS_DEVICE_NOT_CONNECTED;
        goto HidpIrpMajorDeviceControlDone;
    }

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    // Keep this privately so we still have it after the IRP is completed.
    ioControlCode = irpSp->Parameters.DeviceIoControl.IoControlCode;
    Irp->IoStatus.Information = 0;

    status = HidpCheckIdleState(HidDeviceExtension, Irp);
    if (status != STATUS_SUCCESS) {
        completeIrpHere = (status != STATUS_PENDING);
        goto HidpIrpMajorDeviceControlDone;
    }

    switch (ioControlCode){

    case IOCTL_HID_GET_DRIVER_CONFIG:
    case IOCTL_HID_SET_DRIVER_CONFIG:
        DBGWARN(("Unsupported ioctl received: %x", ioControlCode));
        status = STATUS_NOT_IMPLEMENTED;
        break;

    case IOCTL_HID_GET_COLLECTION_INFORMATION:
        /*
         *  This IRP is METHOD_BUFFERED, so the buffer
         *  is in the AssociatedIrp.
         */
        DBGASSERT((Irp->Flags & IRP_BUFFERED_IO),
                  ("Irp->Flags & IRP_BUFFERED_IO Irp->Type != IO_TYPE_IRP, Irp->Type == %x", Irp->Type),
                  FALSE)
        if (Irp->AssociatedIrp.SystemBuffer){
            ULONG bufLen = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
            status = HidpGetCollectionInformation(
                        fdoExt,
                        pdoExt->collectionNum,
                        Irp->AssociatedIrp.SystemBuffer,
                        &bufLen);
            Irp->IoStatus.Information = bufLen;
        }
        else {
            status = STATUS_INVALID_PARAMETER;
        }
        break;

    case IOCTL_HID_GET_COLLECTION_DESCRIPTOR:
        /*
         *  This IOCTL is METHOD_NEITHER, so the buffer is in UserBuffer.
         */
        if (Irp->UserBuffer){
            __try {
                ULONG bufLen = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

                if (Irp->RequestorMode != KernelMode){
                    /*
                     *  Ensure user-mode buffer is legal.
                     */
                    ProbeForWrite(Irp->UserBuffer, bufLen, sizeof(UCHAR));
                }

                status = HidpGetCollectionDescriptor(
                            fdoExt,
                            pdoExt->collectionNum,
                            Irp->UserBuffer,
                            &bufLen);
                Irp->IoStatus.Information = bufLen;
            }
            __except(EXCEPTION_EXECUTE_HANDLER) {
                DBGWARN(("Invalid user mode buffer in IOCTL_HID_DET_COLLECTION_DESCRIPTOR"));
                status = GetExceptionCode();
            }
        }
        else {
            status = STATUS_INVALID_BUFFER_SIZE;
        }
        break;

    case IOCTL_HID_FLUSH_QUEUE:

        //
        // Run the list of report descriptors hanging off of this
        // file object and free them all.
        //

        fileObject = irpSp->FileObject;
        fileExtension = (PHIDCLASS_FILE_EXTENSION)fileObject->FsContext;
        if(!fileExtension) {
            DBGWARN(("Attempted to flush queue with no file extension"))
            status = STATUS_PRIVILEGE_NOT_HELD;
            break;
        }
        ASSERT(fileExtension->Signature == HIDCLASS_FILE_EXTENSION_SIG);
        HidpFlushReportQueue(fileExtension);
        status = STATUS_SUCCESS;
        break;

    case IOCTL_HID_GET_POLL_FREQUENCY_MSEC:
        hidCollection = GetHidclassCollection(fdoExt, pdoExt->collectionNum);
        if (hidCollection && hidCollection->hidCollectionInfo.Polled){
            /*
             *  Get the current poll frequency.
             *  This IOCTL is METHOD_BUFFERED, so the result goes in the AssociatedIrp.
             */
            DBGASSERT((Irp->Flags & IRP_BUFFERED_IO),
                      ("Irp->Flags & IRP_BUFFERED_IO Irp->Type != IO_TYPE_IRP, Irp->Type == %x", Irp->Type),
                      FALSE)
            if (Irp->AssociatedIrp.SystemBuffer &&
                (irpSp->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(ULONG))){

                *(ULONG *)Irp->AssociatedIrp.SystemBuffer = hidCollection->PollInterval_msec;
                Irp->IoStatus.Information = sizeof (ULONG);
                status = STATUS_SUCCESS;
            }
            else {
                status = STATUS_INVALID_BUFFER_SIZE;
            }
        }
        else {
            status = STATUS_INVALID_DEVICE_REQUEST;
        }
        break;

    case IOCTL_HID_SET_POLL_FREQUENCY_MSEC:
        hidCollection = GetHidclassCollection(fdoExt, pdoExt->collectionNum);
        if (hidCollection && hidCollection->hidCollectionInfo.Polled){

            if (Irp->AssociatedIrp.SystemBuffer &&
                (irpSp->Parameters.DeviceIoControl.InputBufferLength >= sizeof(ULONG))){

                ULONG newPollInterval = *(ULONG *)Irp->AssociatedIrp.SystemBuffer;

                fileObject = irpSp->FileObject;
                fileExtension = (PHIDCLASS_FILE_EXTENSION)fileObject->FsContext;
                if(!fileExtension) {
                    DBGWARN(("Attempted to set poll frequency with no file extension"))
                    status = STATUS_PRIVILEGE_NOT_HELD;
                    break;
                }
                ASSERT(fileExtension->Signature == HIDCLASS_FILE_EXTENSION_SIG);

                if (newPollInterval == 0){
                    /*
                     *  Poll interval zero means that this client will
                     *  be doing irregular, opportunistic reads on the
                     *  polled device.  We will not change the polling
                     *  frequency of the device.  But when this client
                     *  does a read, we will immediately complete that read
                     *  with either the last report for this collection
                     *  (if the data is not stale) or by immediately issuing
                     *  a new read.
                     */
                    fileExtension->isOpportunisticPolledDeviceReader = TRUE;
                }
                else {
                    /*
                     *  Set the poll frequency AND tell the user what we really set it to
                     *  in case it's out of range.
                     */
                    if (newPollInterval < MIN_POLL_INTERVAL_MSEC){
                        newPollInterval = MIN_POLL_INTERVAL_MSEC;
                    }
                    else if (newPollInterval > MAX_POLL_INTERVAL_MSEC){
                        newPollInterval = MAX_POLL_INTERVAL_MSEC;
                    }
                    hidCollection->PollInterval_msec = newPollInterval;

                    /*
                     *  If this client was an 'opportunistic' reader before,
                     *  he's not anymore.
                     */
                    fileExtension->isOpportunisticPolledDeviceReader = FALSE;

                    /*
                     *  Stop and re-start the polling loop so that
                     *  the new polling interval takes effect right away.
                     */
                    StopPollingLoop(hidCollection, FALSE);
                    StartPollingLoop(fdoExt, hidCollection, FALSE);
                }

                status = STATUS_SUCCESS;
            }
            else {
                status = STATUS_INVALID_BUFFER_SIZE;
            }
        }
        else {
            status = STATUS_INVALID_DEVICE_REQUEST;
        }
        break;

    case IOCTL_HID_GET_FEATURE:
    case IOCTL_HID_SET_FEATURE:
    case IOCTL_HID_GET_INPUT_REPORT:
    case IOCTL_HID_SET_OUTPUT_REPORT:
        {
            BOOLEAN sentIrpToMinidriver;
            status = HidpGetSetReport ( HidDeviceExtension,
                                        Irp,
                                        irpSp->Parameters.DeviceIoControl.IoControlCode,
                                        &sentIrpToMinidriver);
            /*
             *  If we just passed this Irp to the minidriver, we don't want to
             *  complete the Irp; we're not even allowed to touch it since it may
             *  have already completed.
             */
            completeIrpHere = !sentIrpToMinidriver;
        }
        break;

    // NOTE - we currently only support English (langId=0x0409).
    //        route all collection-PDO string requests to device-FDO.
    case IOCTL_HID_GET_MANUFACTURER_STRING:
        status = HidpGetDeviceString(fdoExt, Irp, HID_STRING_ID_IMANUFACTURER, 0x0409);
        completeIrpHere = FALSE;
        break;

    case IOCTL_HID_GET_PRODUCT_STRING:
        status = HidpGetDeviceString(fdoExt, Irp, HID_STRING_ID_IPRODUCT, 0x0409);
        completeIrpHere = FALSE;
        break;

    case IOCTL_HID_GET_SERIALNUMBER_STRING:
        status = HidpGetDeviceString(fdoExt, Irp, HID_STRING_ID_ISERIALNUMBER, 0x0409);
        completeIrpHere = FALSE;
        break;

    case IOCTL_HID_GET_INDEXED_STRING:
        /*
         *  This IRP is METHOD_OUT_DIRECT, so the buffer is in the MDL.
         *  The second argument (string index) is in the AssociatedIrp;
         *  the InputBufferLength is the length of this second buffer.
         */
        if (Irp->AssociatedIrp.SystemBuffer &&
            (irpSp->Parameters.DeviceIoControl.InputBufferLength >= sizeof(ULONG))){

            ULONG stringIndex = *(ULONG *)Irp->AssociatedIrp.SystemBuffer;
            status = HidpGetIndexedString(fdoExt, Irp, stringIndex, 0x409);
            completeIrpHere = FALSE;
        }
        else {
            status = STATUS_INVALID_PARAMETER;
        }
        break;

    case IOCTL_HID_GET_MS_GENRE_DESCRIPTOR:
        /*
         *  This IRP is METHOD_OUT_DIRECT, so the buffer is in the MDL.
         */
        status = HidpGetMsGenreDescriptor(fdoExt, Irp);
        completeIrpHere = FALSE;
        break;

    case IOCTL_GET_NUM_DEVICE_INPUT_BUFFERS:

        /*
         *  This IRP is METHOD_BUFFERED, so the buffer
         *  is in the AssociatedIrp.SystemBuffer field.
         */
        DBGASSERT((Irp->Flags & IRP_BUFFERED_IO),
                  ("Irp->Flags & IRP_BUFFERED_IO Irp->Type != IO_TYPE_IRP, Irp->Type == %x", Irp->Type),
                  FALSE)
        if (Irp->AssociatedIrp.SystemBuffer &&
            (irpSp->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(ULONG))){

            fileObject = irpSp->FileObject;
            fileExtension = (PHIDCLASS_FILE_EXTENSION)fileObject->FsContext;
            if(!fileExtension) {
                DBGWARN(("Attempted to get number of input buffers with no file extension"))
                status = STATUS_PRIVILEGE_NOT_HELD;
                break;
            }
            ASSERT( fileExtension->Signature == HIDCLASS_FILE_EXTENSION_SIG );

            *(ULONG *)Irp->AssociatedIrp.SystemBuffer =
                fileExtension->MaximumInputReportQueueSize;
            Irp->IoStatus.Information = sizeof(ULONG);
            status = STATUS_SUCCESS;
        }
        else {
            status = STATUS_INVALID_PARAMETER;
        }
        break;

    case IOCTL_SET_NUM_DEVICE_INPUT_BUFFERS:

        /*
         *  This IRP is METHOD_BUFFERED, so the buffer
         *  is in the AssociatedIrp.SystemBuffer field.
         */
        DBGASSERT((Irp->Flags & IRP_BUFFERED_IO),
                  ("Irp->Flags & IRP_BUFFERED_IO Irp->Type != IO_TYPE_IRP, Irp->Type == %x", Irp->Type),
                  FALSE)
        if (Irp->AssociatedIrp.SystemBuffer &&
            (irpSp->Parameters.DeviceIoControl.InputBufferLength >= sizeof(ULONG))){

            ULONG newValue = *(ULONG *)Irp->AssociatedIrp.SystemBuffer;

            fileObject = irpSp->FileObject;
            fileExtension = (PHIDCLASS_FILE_EXTENSION)fileObject->FsContext;
            if(!fileExtension) {
                DBGWARN(("Attempted to set number of input buffers with no file extension"))
                status = STATUS_PRIVILEGE_NOT_HELD;
                break;
            }
            ASSERT( fileExtension->Signature == HIDCLASS_FILE_EXTENSION_SIG );

            if ((newValue >= MIN_INPUT_REPORT_QUEUE_SIZE) &&
                (newValue <= MAX_INPUT_REPORT_QUEUE_SIZE)){

                fileExtension->MaximumInputReportQueueSize = newValue;
                status = STATUS_SUCCESS;
            }
            else {
                status = STATUS_INVALID_PARAMETER;
            }
        }
        else {
            status = STATUS_INVALID_PARAMETER;
        }
        break;

    case IOCTL_GET_PHYSICAL_DESCRIPTOR:
        status = HidpGetPhysicalDescriptor(HidDeviceExtension, Irp);
        completeIrpHere = FALSE;
        break;

    case IOCTL_HID_GET_HARDWARE_ID:
        {
            PDEVICE_OBJECT pdo = pdoExt->deviceFdoExt->hidExt.PhysicalDeviceObject;
            ULONG bufLen = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
            PWSTR hwIdBuf;

            hwIdBuf = HidpGetSystemAddressForMdlSafe(Irp->MdlAddress);

            if (hwIdBuf && bufLen){
                ULONG actualLen;

                status = IoGetDeviceProperty(   pdo,
                                                DevicePropertyHardwareID,
                                                bufLen,
                                                hwIdBuf,
                                                &actualLen);
                if (NT_SUCCESS(status)){
                    Irp->IoStatus.Information = (ULONG)actualLen;
                }
            }
            else {
                status = STATUS_INVALID_USER_BUFFER;
            }
        }
        break;

    case IOCTL_GET_SYS_BUTTON_CAPS:
        hidCollection = GetHidclassCollection(fdoExt, pdoExt->collectionNum);
        if (hidCollection){
            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(ULONG)){
                ULONG buttonCaps;

                status = HidP_SysPowerCaps(hidCollection->phidDescriptor, &buttonCaps);
                if (NT_SUCCESS(status)){
                    *(PULONG)Irp->AssociatedIrp.SystemBuffer = buttonCaps;
                    Irp->IoStatus.Information = sizeof(ULONG);
                }
            }
            else {
                status = STATUS_INVALID_BUFFER_SIZE;
                Irp->IoStatus.Information = sizeof(ULONG);
            }
        }
        else {
            status = STATUS_DEVICE_NOT_CONNECTED;
        }
        break;

    case IOCTL_GET_SYS_BUTTON_EVENT:

        /*
         *  Hold onto this IRP and complete it when a power event occurs.
         */
        hidCollection = GetHidclassCollection(fdoExt, pdoExt->collectionNum);
        if (hidCollection){
            status = QueuePowerEventIrp(hidCollection, Irp);
            if (status == STATUS_PENDING){
                completeIrpHere = FALSE;
            }
        }
        else {
            status = STATUS_DEVICE_NOT_CONNECTED;
        }
        break;

    case IOCTL_HID_ENABLE_SECURE_READ:

        fileObject = irpSp->FileObject;
        fileExtension = (PHIDCLASS_FILE_EXTENSION)fileObject->FsContext;
        if(!fileExtension) {
            DBGWARN(("Attempted to get number of input buffers with no file extension"))
            status = STATUS_PRIVILEGE_NOT_HELD;
            break;
        }
        ASSERT( fileExtension->Signature == HIDCLASS_FILE_EXTENSION_SIG );

        hidCollection = GetHidclassCollection(fdoExt, pdoExt->collectionNum);

        if (!fileExtension->isSecureOpen) {

            status = STATUS_PRIVILEGE_NOT_HELD;
            break;

        }

        KeAcquireSpinLock(&hidCollection->secureReadLock,
                          &irql);
        fileExtension->SecureReadMode++;
        hidCollection->secureReadMode++;

        KeReleaseSpinLock(&hidCollection->secureReadLock,
                          irql);



        break;
    case IOCTL_HID_DISABLE_SECURE_READ:
        
        fileObject = irpSp->FileObject;
        fileExtension = (PHIDCLASS_FILE_EXTENSION)fileObject->FsContext;
        if(!fileExtension) {
            DBGWARN(("Attempted to get number of input buffers with no file extension"))
            status = STATUS_PRIVILEGE_NOT_HELD;
            break;
        }
        ASSERT( fileExtension->Signature == HIDCLASS_FILE_EXTENSION_SIG );

        hidCollection = GetHidclassCollection(fdoExt, pdoExt->collectionNum);

        if (!fileExtension->isSecureOpen) {

            status = STATUS_PRIVILEGE_NOT_HELD;
            break;

        }

        KeAcquireSpinLock(&hidCollection->secureReadLock,
                          &irql);
        if (fileExtension->SecureReadMode > 0) {
            fileExtension->SecureReadMode--;
            hidCollection->secureReadMode--;
        }

        KeReleaseSpinLock(&hidCollection->secureReadLock,
                          irql);

        break;


    default:
        /*
         *  'Fail' the Irp by returning the default status.
         */
        DBGWARN(("Unrecognized ioctl received: %x", ioControlCode));
        status = Irp->IoStatus.Status;
        break;
    }

    DBG_LOG_IOCTL(fdoExt->fdo, ioControlCode, status)

HidpIrpMajorDeviceControlDone:

    /*
     *  If we did not pass the Irp down to a lower driver, complete it here.
     */
    if (completeIrpHere){
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    DBGSUCCESS(status, FALSE)

    return status;
}


/*
 ********************************************************************************
 *  HidpIrpMajorINTERNALDeviceControl
 ********************************************************************************
 *
 *  Note:  This function cannot be pageable because IOCTLs
 *         can get sent at DISPATCH_LEVEL.
 *
 */
NTSTATUS HidpIrpMajorINTERNALDeviceControl(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp)
{
    NTSTATUS        status;

    if (HidDeviceExtension->isClientPdo){
        PDO_EXTENSION *pdoExt = &HidDeviceExtension->pdoExt;
        FDO_EXTENSION *fdoExt = &pdoExt->deviceFdoExt->fdoExt;

        Irp->IoStatus.Information = 0;

        //
        // If we ever support any other internal IOCTLs that are real and
        // require touching the hardware, then we need to break out the check
        // for fdoExt->devicePowerState and enqueue the irp until we get to full
        // power
        //
        if (fdoExt->state == DEVICE_STATE_START_SUCCESS) {
            PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

            switch (irpSp->Parameters.DeviceIoControl.IoControlCode){

            default:
                /*
                 *  'Fail' the Irp by returning the default status.
                 */
                DBGWARN(("HidpIrpMajorINTERNALDeviceControl - unsupported IOCTL %xh ", (ULONG)irpSp->Parameters.DeviceIoControl.IoControlCode))
                status = Irp->IoStatus.Status;
                break;
            }
        }
        else {
            status = STATUS_DEVICE_NOT_CONNECTED;
        }
    }
    else {
        ASSERT(HidDeviceExtension->isClientPdo);
        status = STATUS_INVALID_PARAMETER_1;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGSUCCESS(status, FALSE)
    return status;
}

/*
 ********************************************************************************
 *  HidpIrpMajorPnp
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpIrpMajorPnp(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp)
{
    NTSTATUS            status;
    PIO_STACK_LOCATION  irpSp;
    BOOLEAN             completeIrpHere;
    BOOLEAN             isClientPdo;
    UCHAR               minorFunction;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    /*
     *  Keep these fields privately so that we have them
     *  after the IRP is completed and in case we delete
     *  the device extension on a REMOVE_DEVICE.
     */
    isClientPdo = HidDeviceExtension->isClientPdo;
    minorFunction = irpSp->MinorFunction;

    DBG_LOG_PNP_IRP(Irp, minorFunction, isClientPdo, FALSE, 0)

    if (isClientPdo) {
        status = HidpPdoPnp(HidDeviceExtension, Irp);
    } else {
        status = HidpFdoPnp(HidDeviceExtension, Irp);
    }

    DBG_LOG_PNP_IRP(Irp, minorFunction, isClientPdo, TRUE, status)

    return status;
}


NTSTATUS HidpPdoPnp(
    IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension,
    IN OUT PIRP Irp
    )
{
    NTSTATUS            status = NO_STATUS;
    PIO_STACK_LOCATION  irpSp;
    FDO_EXTENSION       *fdoExt;
    PDO_EXTENSION       *pdoExt;
    UCHAR               minorFunction;     
    BOOLEAN             deleteDevice = FALSE;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    /*
     *  Keep these fields privately so that we have them
     *  after the IRP is completed and in case we delete
     *  the device extension on a REMOVE_DEVICE.
     */
    minorFunction = irpSp->MinorFunction;


    DBG_LOG_PNP_IRP(Irp, minorFunction, TRUE, FALSE, 0)

    pdoExt = &HidDeviceExtension->pdoExt;
    fdoExt = &pdoExt->deviceFdoExt->fdoExt;

    switch (minorFunction){

    case IRP_MN_START_DEVICE:
        status = HidpStartCollectionPDO(fdoExt, pdoExt, Irp);
        if (NT_SUCCESS(status) &&
            ISPTR(pdoExt->StatusChangeFn)) {
            pdoExt->StatusChangeFn(pdoExt->StatusChangeContext,
                                   DeviceObjectStarted);
        }
        break;

    case IRP_MN_QUERY_STOP_DEVICE:
        DBGSTATE(pdoExt->state, COLLECTION_STATE_RUNNING, FALSE)
        pdoExt->prevState = pdoExt->state;
        pdoExt->state = COLLECTION_STATE_STOPPING;
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:
        DBGSTATE(pdoExt->state, COLLECTION_STATE_STOPPING, TRUE)
        pdoExt->state = pdoExt->prevState;
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_STOP_DEVICE:
        DBGSTATE(pdoExt->state, COLLECTION_STATE_STOPPING, TRUE)
        if (pdoExt->prevState != COLLECTION_STATE_UNINITIALIZED){
            /*
             *  Destroy the symbolic link for this collection.
             */
            HidpCreateSymbolicLink(pdoExt, pdoExt->collectionNum, FALSE, pdoExt->pdo);
            HidpFreePowerEventIrp(&fdoExt->classCollectionArray[pdoExt->collectionIndex]);

            pdoExt->state = COLLECTION_STATE_STOPPED;
            if (ISPTR(pdoExt->StatusChangeFn)) {
                pdoExt->StatusChangeFn(pdoExt->StatusChangeContext,
                                       DeviceObjectStopped);
            }
        }

        status = STATUS_SUCCESS;
        break;

    case IRP_MN_SURPRISE_REMOVAL:
    case IRP_MN_QUERY_REMOVE_DEVICE:
        DBGASSERT(((pdoExt->state == COLLECTION_STATE_RUNNING) ||
                  (pdoExt->state == COLLECTION_STATE_STOPPED)),
                  ("Pdo is neither stopped nor started, but is getting removed, state=%d",pdoExt->state),    
                  FALSE)

        pdoExt->prevState = pdoExt->state;
        pdoExt->state = COLLECTION_STATE_REMOVING;

        if ((pdoExt->prevState == COLLECTION_STATE_RUNNING)) {

            /*
             *  Remove the symbolic link for this collection-PDO.
             *
             *  NOTE:  Do this BEFORE destroying the collection, because
             *         HidpDestroyCollection() may cause a client driver,
             *         whose pending read IRPs get cancelled when the collection
             *         is destroyed, to try to re-open the device.
             *         Deleting the symbolic link first eliminates this possibility.
             */
            HidpCreateSymbolicLink(pdoExt, pdoExt->collectionNum, FALSE, pdoExt->pdo);
        }

        if ((pdoExt->prevState == COLLECTION_STATE_RUNNING) ||
            (pdoExt->prevState == COLLECTION_STATE_STOPPED)){

            /*
             *  Flush all pending IO and deny any future io by setting
             *  the collection state to removing.
             *  Note: on NT, clients will receive the query remove
             *  first, but surprise removal must deny access to the
             *  device.
             *
             *  NOTE: There is a hole here that results in a read being
             *  queued even though we've blocked everything.
             *  1) Get read, check to see that our state is running
             *     or stopped in HidpIrpMajorRead.
             *  2) Set state to COLLECTION_STATE_REMOVING and complete
             *     all reads here.
             *  3) Enqueue read in HidpIrpMajorRead.
             *
             */
            ULONG ctnIndx = pdoExt->collectionIndex;
            PHIDCLASS_COLLECTION collection = &fdoExt->classCollectionArray[ctnIndx];
            LIST_ENTRY dequeue, *entry;
            PIRP irp;

            DBGVERBOSE(("Got QUERY/SURPRISE REMOVE for collection; completing all pending reads.  openCount=%d, pendingReads=%d.", pdoExt->openCount, collection->numPendingReads))

            CompleteAllPendingReadsForCollection(collection);

            DequeueAllPdoPowerDelayedIrps(pdoExt, &dequeue);
            while (!IsListEmpty(&dequeue)) {
                entry = RemoveHeadList(&dequeue);
                irp = CONTAINING_RECORD(entry, IRP, Tail.Overlay.ListEntry);

                irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
                IoCompleteRequest(irp, IO_NO_INCREMENT);
            }
        }

        status = STATUS_SUCCESS;
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:
        status = STATUS_SUCCESS;

        DBGSTATE(pdoExt->state, COLLECTION_STATE_REMOVING, TRUE)
        pdoExt->state = pdoExt->prevState;
        if (pdoExt->state == COLLECTION_STATE_RUNNING) {
            // Re-create the symbolic link, since we're no longer
            // deleting the device.
            HidpCreateSymbolicLink(pdoExt, pdoExt->collectionNum, TRUE, pdoExt->pdo);
        }
        break;

    case IRP_MN_REMOVE_DEVICE:

        /*
         *  REMOVE_DEVICE for the device-FDO should come after REMOVE_DEVICE for each
         *  of the collection-PDOs.
         */
        DBGASSERT((pdoExt->state == COLLECTION_STATE_UNINITIALIZED ||
                   pdoExt->state == COLLECTION_STATE_REMOVING),
                  ("On pnp remove, collection state is incorrect. Actual: %x", pdoExt->state),
                  TRUE)

        HidpRemoveCollection(fdoExt, pdoExt, Irp);
        if (ISPTR(pdoExt->StatusChangeFn)) {
            pdoExt->StatusChangeFn(pdoExt->StatusChangeContext,
                                   DeviceObjectRemoved);
        }

        if (!fdoExt->presentReported) {

            if (ISPTR(pdoExt->name)){
                RtlFreeUnicodeString(pdoExt->name);
                ExFreePool(pdoExt->name);
                pdoExt->name = BAD_POINTER;
            }
            deleteDevice = TRUE;


        }
        status = STATUS_SUCCESS; // Can't fail IRP_MN_REMOVE
        break;

    case IRP_MN_QUERY_CAPABILITIES:
        status = HidpQueryCollectionCapabilities(pdoExt, Irp);
        break;


    case IRP_MN_QUERY_DEVICE_RELATIONS:
        if (irpSp->Parameters.QueryDeviceRelations.Type == TargetDeviceRelation){
            /*
             *  Return a reference to this PDO
             */
            PDEVICE_RELATIONS devRel = ALLOCATEPOOL(PagedPool, sizeof(DEVICE_RELATIONS));
            if (devRel){
                /*
                 *  Add a reference to the PDO, since CONFIGMG will free it.
                 */
                ObReferenceObject(pdoExt->pdo);
                devRel->Objects[0] = pdoExt->pdo;
                devRel->Count = 1;
                Irp->IoStatus.Information = (ULONG_PTR)devRel;
                status = STATUS_SUCCESS;
            }
            else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else {
            /*
             *  Fail this Irp by returning the default
             *  status (typically STATUS_NOT_SUPPORTED).
             */
            status = Irp->IoStatus.Status;
        }
        break;

    case IRP_MN_QUERY_ID:
        status = HidpQueryIdForClientPdo(HidDeviceExtension, Irp);
        break;

    case IRP_MN_QUERY_PNP_DEVICE_STATE:
        //
        // Do not clear any flags that may have been set by drivers above
        // the PDO
        //
        // Irp->IoStatus.Information = 0;

        switch (pdoExt->state){
        case DEVICE_STATE_START_FAILURE:
            Irp->IoStatus.Information |= PNP_DEVICE_FAILED;
            break;
        case DEVICE_STATE_STOPPED:
            Irp->IoStatus.Information |= PNP_DEVICE_DISABLED;
            break;
        case DEVICE_STATE_REMOVING:
        case DEVICE_STATE_REMOVED:
            Irp->IoStatus.Information |= PNP_DEVICE_REMOVED;
            break;
        }
        status = STATUS_SUCCESS;
        break;
    case IRP_MN_QUERY_INTERFACE:
        status = HidpQueryInterface(HidDeviceExtension, Irp);
        break;

    case IRP_MN_QUERY_BUS_INFORMATION:
        {
        PPNP_BUS_INFORMATION busInfo = (PPNP_BUS_INFORMATION) ALLOCATEPOOL(NonPagedPool, sizeof(PNP_BUS_INFORMATION));
        if (busInfo) {
            busInfo->BusTypeGuid = GUID_BUS_TYPE_HID;
            busInfo->LegacyBusType = PNPBus;
            busInfo->BusNumber = fdoExt->BusNumber;
            Irp->IoStatus.Information = (ULONG_PTR) busInfo;
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
            Irp->IoStatus.Information = 0;
        }
        }
        break;

    default:
        /*
         *  In the default case for the collection-PDOs we complete the IRP
         *  without changing IoStatus.Status; we also return the preset IoStatus.Status.
         *  This allows an upper filter driver to set IoStatus.Status
         *  on the way down.  In the absence of a filter driver,
         *  IoStatus.Status will be STATUS_NOT_SUPPORTED.
         *
         *  In the default case for the FDO we send the Irp on and let
         *  the other drivers in the stack do their thing.
         */
        status = Irp->IoStatus.Status;
        break;
    }


    /*
     *  If this is a call for a collection-PDO, we complete it ourselves here.
     *  Otherwise, we pass it to the minidriver stack for more processing.
     */
    ASSERT(status != NO_STATUS);
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
                        
    if (deleteDevice) {
    
        /*
         *  Delete the client PDO.
         *  Don't touch the pdoExt after doing this.
         */

        ObDereferenceObject(pdoExt->pdo);
        IoDeleteDevice(pdoExt->pdo);

    }


    DBG_LOG_PNP_IRP(Irp, minorFunction, TRUE, TRUE, status)

    return status;
}


NTSTATUS HidpFdoPnp(
    IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension,
    IN OUT PIRP Irp
    )
{
    NTSTATUS            status = NO_STATUS;
    PIO_STACK_LOCATION  irpSp;
    FDO_EXTENSION       *fdoExt;
    BOOLEAN             completeIrpHere = FALSE; // general rule
    UCHAR               minorFunction;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    /*
     *  Keep these fields privately so that we have them
     *  after the IRP is completed and in case we delete
     *  the device extension on a REMOVE_DEVICE.
     */
    minorFunction = irpSp->MinorFunction;


    DBG_LOG_PNP_IRP(Irp, minorFunction, FALSE, FALSE, 0)

    fdoExt = &HidDeviceExtension->fdoExt;

    switch (minorFunction){

    case IRP_MN_START_DEVICE:

        status = HidpStartDevice(HidDeviceExtension, Irp);
        completeIrpHere = TRUE;
        break;

    case IRP_MN_QUERY_STOP_DEVICE:
        /*
         *  We will pass this IRP down the driver stack.
         *  However, we need to change the default status
         *  from STATUS_NOT_SUPPORTED to STATUS_SUCCESS.
         */
        Irp->IoStatus.Status = STATUS_SUCCESS;

        DBGSTATE(fdoExt->state, DEVICE_STATE_START_SUCCESS, FALSE)
        fdoExt->prevState = fdoExt->state;
        fdoExt->state = DEVICE_STATE_STOPPING;
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:
        /*
         *  We will pass this IRP down the driver stack.
         *  However, we need to change the default status
         *  from STATUS_NOT_SUPPORTED to STATUS_SUCCESS.
         */
        Irp->IoStatus.Status = STATUS_SUCCESS;

        DBGSTATE(fdoExt->state, DEVICE_STATE_STOPPING, TRUE)
        fdoExt->state = fdoExt->prevState;
        break;

    case IRP_MN_STOP_DEVICE:
        DBGSTATE(fdoExt->state, DEVICE_STATE_STOPPING, TRUE)
        if (fdoExt->prevState == DEVICE_STATE_START_SUCCESS){

            /*
             *  While it is stopped, the host controller may not be able
             *  to complete IRPs.  So cancel them before sending down the stop.
             */
            CancelAllPingPongIrps(fdoExt);
        }
        fdoExt->state = DEVICE_STATE_STOPPED;

        IoCopyCurrentIrpStackLocationToNext(Irp);
        status = HidpCallDriverSynchronous(fdoExt->fdo, Irp);

        completeIrpHere = TRUE;
        break;

    case IRP_MN_SURPRISE_REMOVAL:
        //
        // On surprise removal, we should stop accessing the device.
        // We do the same steps on IRP_MN_REMOVE_DEVICE for the query
        // removal case. Don't bother doing it during query remove,
        // itself, because we don't want to have to handle the
        // cancel case. NOTE: We only get away with this because all
        // of these steps can be repeated without dire consequences.
        //
        if (ISPTR(fdoExt->waitWakeIrp)){
            IoCancelIrp(fdoExt->waitWakeIrp);
            fdoExt->waitWakeIrp = BAD_POINTER;
        }

        HidpCancelIdleNotification(fdoExt, TRUE);

        if (ISPTR(fdoExt->idleNotificationRequest)) {
            IoFreeIrp(fdoExt->idleNotificationRequest);
            fdoExt->idleNotificationRequest = BAD_POINTER;
        }

        DestroyPingPongs(fdoExt);

        // fall thru to IRP_MN_QUERY_REMOVE_DEVICE

    case IRP_MN_QUERY_REMOVE_DEVICE:
        {
        PIRP idleIrp;

        while (idleIrp = DequeuePowerDelayedIrp(fdoExt)) {
            idleIrp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
            IoCompleteRequest(idleIrp, IO_NO_INCREMENT);
        }
        }

        /*
         *  We will pass this IRP down the driver stack.
         *  However, we need to change the default status
         *  from STATUS_NOT_SUPPORTED to STATUS_SUCCESS.
         */
        Irp->IoStatus.Status = STATUS_SUCCESS;

        DBGSTATE(fdoExt->state, DEVICE_STATE_START_SUCCESS, FALSE)
        DBGASSERT((fdoExt->state == DEVICE_STATE_START_SUCCESS ||
                   fdoExt->state == DEVICE_STATE_STOPPED),
                  ("Fdo is neither stopped nor started, but is getting removed, state=%d",fdoExt->state),
                  FALSE)
        fdoExt->prevState = fdoExt->state;
        fdoExt->state = DEVICE_STATE_REMOVING;
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:
        /*
         *  We will pass this IRP down the driver stack.
         *  However, we need to change the default status
         *  from STATUS_NOT_SUPPORTED to STATUS_SUCCESS.
         */
        Irp->IoStatus.Status = STATUS_SUCCESS;

        DBGSTATE(fdoExt->state, DEVICE_STATE_REMOVING, TRUE)
        fdoExt->state = fdoExt->prevState;
        break;

    case IRP_MN_REMOVE_DEVICE:

        /*
         *  REMOVE_DEVICE for the device-FDO should come after REMOVE_DEVICE
         *  for each of the collection-PDOs.
         *  Don't touch the device extension after this call.
         */
        DBGASSERT((fdoExt->state == DEVICE_STATE_REMOVING ||
                   fdoExt->state == DEVICE_STATE_START_FAILURE ||
                   fdoExt->state == DEVICE_STATE_INITIALIZED),
                  ("Incorrect device state: %x", fdoExt->state),
                 TRUE)
        status = HidpRemoveDevice(fdoExt, Irp);
        goto HidpFdoPnpDone;
        break;

    case IRP_MN_QUERY_DEVICE_RELATIONS:
        if (irpSp->Parameters.QueryDeviceRelations.Type == BusRelations){
            status = HidpQueryDeviceRelations(HidDeviceExtension, Irp);
            if (NT_SUCCESS(status)){
                /*
                 *  Although we have satisfied this PnP IRP,
                 *  we will still pass it down the stack.
                 *  First change the default status to our status.
                 */
                Irp->IoStatus.Status = status;
            }
            else {
                completeIrpHere = TRUE;
            }
        }
        break;

    default:
        /*
         *  In the default case for the collection-PDOs we complete the IRP
         *  without changing IoStatus.Status; we also return the preset IoStatus.Status.
         *  This allows an upper filter driver to set IoStatus.Status
         *  on the way down.  In the absence of a filter driver,
         *  IoStatus.Status will be STATUS_NOT_SUPPORTED.
         *
         *  In the default case for the FDO we send the Irp on and let
         *  the other drivers in the stack do their thing.
         */
        if (completeIrpHere){
            status = Irp->IoStatus.Status;
        }
        break;
    }


    /*
     *  If this is a call for a collection-PDO, we complete it ourselves here.
     *  Otherwise, we pass it to the minidriver stack for more processing.
     */
    if (completeIrpHere){
        ASSERT(status != NO_STATUS);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    else {
        /*
         *  Call the minidriver with this Irp.
         *  The rest of our processing will be done in our completion routine.
         *
         *  Note:  Don't touch the Irp after sending it down, since it may
         *         be completed immediately.
         */
        IoCopyCurrentIrpStackLocationToNext(Irp);
        status = HidpCallDriver(fdoExt->fdo, Irp);
    }

HidpFdoPnpDone:
    DBG_LOG_PNP_IRP(Irp, minorFunction, FALSE, TRUE, status)

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidclass\security.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    security.c

Abstract

    Security routines.

    Note: This file uses NTDDK.H, which is blocked out by WDM.H .
          So it does not include PCH.H et al.

Author:

    Ervin P.

Environment:

    Kernel mode only

Revision History:


--*/

#include "pch.h"


/*
 *  Copied from ntrtl.h, which won't compile here.
 */
__inline LUID RtlConvertLongToLuid(LONG Long)
{
    LUID TempLuid;
    LARGE_INTEGER TempLi;

    TempLi = RtlConvertLongToLargeInteger(Long);
    TempLuid.LowPart = TempLi.LowPart;
    TempLuid.HighPart = TempLi.HighPart;
    return(TempLuid);
}

NTKERNELAPI BOOLEAN SeSinglePrivilegeCheck(LUID PrivilegeValue, KPROCESSOR_MODE PreviousMode);




BOOLEAN MyPrivilegeCheck(PIRP Irp)
{
    BOOLEAN result;
    
    #if DBG
        if (dbgSkipSecurity){
            return TRUE;
        }
    #endif

    {
        #ifndef SE_TCB_PRIVILEGE
            #define SE_TCB_PRIVILEGE (7L)
        #endif
        LUID priv = RtlConvertLongToLuid(SE_TCB_PRIVILEGE);
        result = SeSinglePrivilegeCheck(priv, Irp->RequestorMode);
    }
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidclass\physdesc.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name: 

    physdesc.c

Abstract

    Get-friendly-name handling routines

Author:

    Ervin P.

Environment:

    Kernel mode only

Revision History:


--*/

#include "pch.h"



/*
 ********************************************************************************
 *  HidpGetPhysicalDescriptor
 ********************************************************************************
 *
 *  Note:  This function cannot be pageable because it is called
 *         from the IOCTL dispatch routine, which can get called
 *         at DISPATCH_LEVEL.
 *
 */
NTSTATUS HidpGetPhysicalDescriptor(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp)
{
    FDO_EXTENSION *fdoExt;
    NTSTATUS status;
    PIO_STACK_LOCATION  currentIrpSp, nextIrpSp;


    ASSERT(HidDeviceExtension->isClientPdo);
    fdoExt = &HidDeviceExtension->pdoExt.deviceFdoExt->fdoExt;

    /*
     *  IOCTL_GET_PHYSICAL_DESCRIPTOR uses buffering method
     *  METHOD_OUT_DIRECT, meaning that the buffer is in
     *  the MDL specified by Irp->MdlAddress.  We'll just
     *  pass this down and let the lower driver extract the 
     *  system address.
     */
    currentIrpSp = IoGetCurrentIrpStackLocation(Irp);
    nextIrpSp = IoGetNextIrpStackLocation(Irp);
    nextIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextIrpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_GET_PHYSICAL_DESCRIPTOR;
    nextIrpSp->Parameters.DeviceIoControl.OutputBufferLength = currentIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    status = HidpCallDriver(fdoExt->fdo, Irp);

    DBGSUCCESS(status, FALSE)
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidclass\read.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    read.c

Abstract

    Read handling routines

Author:

    Ervin P.

Environment:

    Kernel mode only

Revision History:


--*/

#include "pch.h"



/*
 ********************************************************************************
 *  HidpCancelReadIrp
 ********************************************************************************
 *
 *  If a queued read Irp gets cancelled by the user,
 *  this function removes it from our pending-read list.
 *
 */
VOID HidpCancelReadIrp(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
    PHIDCLASS_DEVICE_EXTENSION hidDeviceExtension = (PHIDCLASS_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    FDO_EXTENSION *fdoExt;
    PHIDCLASS_COLLECTION collection;
    ULONG collectionIndex;
    KIRQL oldIrql;
    PIO_STACK_LOCATION irpSp;
    PHIDCLASS_FILE_EXTENSION fileExtension;

    ASSERT(hidDeviceExtension->Signature == HID_DEVICE_EXTENSION_SIG);
    ASSERT(hidDeviceExtension->isClientPdo);
    fdoExt = &hidDeviceExtension->pdoExt.deviceFdoExt->fdoExt;

    collectionIndex = hidDeviceExtension->pdoExt.collectionIndex;
    collection = &fdoExt->classCollectionArray[collectionIndex];

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    ASSERT(irpSp->FileObject->Type == IO_TYPE_FILE);
    fileExtension = (PHIDCLASS_FILE_EXTENSION)irpSp->FileObject->FsContext;

    IoReleaseCancelSpinLock(Irp->CancelIrql);


    LockFileExtension(fileExtension, &oldIrql);

    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

    DBG_RECORD_READ(Irp, 0, 0, TRUE);
    ASSERT(collection->numPendingReads > 0);
    collection->numPendingReads--;

    UnlockFileExtension(fileExtension, oldIrql);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}


NTSTATUS EnqueueInterruptReadIrp(   PHIDCLASS_COLLECTION collection,
                                    PHIDCLASS_FILE_EXTENSION fileExtension,
                                    PIRP Irp)
{
    NTSTATUS status;
    PDRIVER_CANCEL oldCancelRoutine;

    RUNNING_DISPATCH();

    /*
     *  Must set a cancel routine before
     *  checking the Cancel flag.
     */
    oldCancelRoutine = IoSetCancelRoutine(Irp, HidpCancelReadIrp);
    ASSERT(!oldCancelRoutine);

    /*
     *  Make sure this Irp wasn't just cancelled.
     *  Note that there is NO RACE CONDITION here
     *  because we are holding the fileExtension lock.
     */
    if (Irp->Cancel) {
        /*
         *  This IRP was cancelled.
         */
        oldCancelRoutine = IoSetCancelRoutine(Irp, NULL);
        if (oldCancelRoutine) {
            /*
             *  The cancel routine was NOT called.
             *  Return error so that caller completes the IRP.
             */
            ASSERT(oldCancelRoutine == HidpCancelReadIrp);
            status = STATUS_CANCELLED;
        } else {
            /*
             *  The cancel routine was called.
             *  As soon as we drop the spinlock it will dequeue
             *  and complete the IRP.
             *  Initialize the IRP's listEntry so that the dequeue
             *  doesn't cause corruption.
             *  Then don't touch the irp.
             */
            InitializeListHead(&Irp->Tail.Overlay.ListEntry);
            collection->numPendingReads++;  // because cancel routine will decrement

            IoMarkIrpPending(Irp);
            status = STATUS_PENDING;
        }
    } else {
        DBG_RECORD_READ(Irp, IoGetCurrentIrpStackLocation(Irp)->Parameters.Read.Length, 0, FALSE)

        /*
         *  There are no reports waiting.
         *  Queue this irp onto the file extension's list of pending irps.
         */
        InsertTailList(&fileExtension->PendingIrpList, &Irp->Tail.Overlay.ListEntry);
        collection->numPendingReads++;

        IoMarkIrpPending(Irp);
        status = STATUS_PENDING;
    }

    return status;
}


PIRP DequeueInterruptReadIrp(   PHIDCLASS_COLLECTION collection,
                                PHIDCLASS_FILE_EXTENSION fileExtension)
{
    PIRP irp = NULL;

    RUNNING_DISPATCH();

    while (!irp && !IsListEmpty(&fileExtension->PendingIrpList)) {
        PDRIVER_CANCEL oldCancelRoutine;
        PLIST_ENTRY listEntry = RemoveHeadList(&fileExtension->PendingIrpList);

        irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);

        oldCancelRoutine = IoSetCancelRoutine(irp, NULL);

        if (oldCancelRoutine) {
            ASSERT(oldCancelRoutine == HidpCancelReadIrp);
            ASSERT(collection->numPendingReads > 0);
            collection->numPendingReads--;
        } else {
            /*
             *  IRP was cancelled and cancel routine was called.
             *  As soon as we drop the spinlock,
             *  the cancel routine will dequeue and complete this IRP.
             *  Initialize the IRP's listEntry so that the dequeue doesn't cause corruption.
             *  Then, don't touch the IRP.
             */
            ASSERT(irp->Cancel);
            InitializeListHead(&irp->Tail.Overlay.ListEntry);
            irp = NULL;
        }
    }

    return irp;
}


/*
 ********************************************************************************
 *  HidpIrpMajorRead
 ********************************************************************************
 *
 *  Note: this function should not be pageable because
 *        reads can come in at dispatch level.
 *
 */
NTSTATUS HidpIrpMajorRead(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp)
{
    NTSTATUS status = STATUS_SUCCESS;
    FDO_EXTENSION *fdoExt;
    PDO_EXTENSION *pdoExt;
    PIO_STACK_LOCATION          irpSp;
    PHIDCLASS_FILE_EXTENSION    fileExtension;
    KIRQL oldIrql;

    ASSERT(HidDeviceExtension->isClientPdo);
    pdoExt = &HidDeviceExtension->pdoExt;
    fdoExt = &pdoExt->deviceFdoExt->fdoExt;
    irpSp = IoGetCurrentIrpStackLocation(Irp);

    /*
     *  Get our file extension.
     */
    if (!irpSp->FileObject ||
        (irpSp->FileObject &&
         !irpSp->FileObject->FsContext)) {
        DBGWARN(("Attempted read with no file extension"))
        Irp->IoStatus.Status = status = STATUS_PRIVILEGE_NOT_HELD;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }
    ASSERT(irpSp->FileObject->Type == IO_TYPE_FILE);
    fileExtension = (PHIDCLASS_FILE_EXTENSION)irpSp->FileObject->FsContext;
    ASSERT(fileExtension->Signature == HIDCLASS_FILE_EXTENSION_SIG);



    if (((fdoExt->state == DEVICE_STATE_START_SUCCESS) ||
         (fdoExt->state == DEVICE_STATE_STOPPING) ||
         (fdoExt->state == DEVICE_STATE_STOPPED))           &&
        ((pdoExt->state == COLLECTION_STATE_RUNNING) ||
         (pdoExt->state == COLLECTION_STATE_STOPPING) ||
         (pdoExt->state == COLLECTION_STATE_STOPPED))) {

        ULONG                       collectionNum;
        PHIDCLASS_COLLECTION        classCollection;
        PHIDP_COLLECTION_DESC       collectionDesc;

            //
            // ISSUE: Is this safe to stop a polled collection like this?
            // interrupt driver collections have a restore read pump at power up
            // to D0, but I don't see any for polled collections...?
            //
        BOOLEAN isStopped = ((fdoExt->state == DEVICE_STATE_STOPPED)  ||
                             (fdoExt->state == DEVICE_STATE_STOPPING)  ||
                             (pdoExt->state == COLLECTION_STATE_STOPPING) ||
                             (pdoExt->state == COLLECTION_STATE_STOPPED));

        Irp->IoStatus.Information = 0;


            /*
             *  Get our collection and collection description.
             */
        collectionNum = HidDeviceExtension->pdoExt.collectionNum;
        classCollection = GetHidclassCollection(fdoExt, collectionNum);
        collectionDesc = GetCollectionDesc(fdoExt, collectionNum);

        if (classCollection && collectionDesc) {

                /*
                 *  Make sure the caller's read buffer is large enough to read at least one report.
                 */
            if (irpSp->Parameters.Read.Length >= collectionDesc->InputLength) {

                    /*
                     *  We know we're going to try to transfer something into the caller's
                     *  buffer, so get the global address.  This will also serve to create
                     *  a mapped system address in the MDL if necessary.
                     */

                if (classCollection->hidCollectionInfo.Polled) {

                        /*
                         *  This is a POLLED collection.
                         */


                    if (isStopped) {
                        status = EnqueuePolledReadIrp(classCollection, Irp);
                    } else if (fileExtension->isOpportunisticPolledDeviceReader &&
                               !classCollection->polledDataIsStale &&
                               (irpSp->Parameters.Read.Length >= classCollection->savedPolledReportLen)) {

                        PUCHAR callersBuffer;

                        callersBuffer = HidpGetSystemAddressForMdlSafe(Irp->MdlAddress);

                        if (callersBuffer) {
                            ULONG userReportLength;
                                /*
                                 *  Use the polledDeviceReadQueueSpinLock to protect
                                 *  the savedPolledReportBuf.
                                 */
                            KeAcquireSpinLock(&classCollection->polledDeviceReadQueueSpinLock, &oldIrql);

                                /*
                                 *  This is an "opportunistic" reader who
                                 *  wants a result right away.
                                 *  We have a recent report,
                                 *  so just copy the last saved report.
                                 */
                            RtlCopyMemory(  callersBuffer,
                                            classCollection->savedPolledReportBuf,
                                            classCollection->savedPolledReportLen);
                            Irp->IoStatus.Information = userReportLength = classCollection->savedPolledReportLen;

                            KeReleaseSpinLock(&classCollection->polledDeviceReadQueueSpinLock, oldIrql);

                            DBG_RECORD_READ(Irp, userReportLength, (ULONG)callersBuffer[0], TRUE)
                            status = STATUS_SUCCESS;
                        } else {
                            status = STATUS_INVALID_USER_BUFFER;
                        }
                    } else {

                        status = EnqueuePolledReadIrp(classCollection, Irp);

                            /*
                             *  If this is an "opportunistic" polled
                             *  device reader, and we queued the irp,
                             *  make the read happen right away.
                             *  Make sure ALL SPINLOCKS ARE RELEASED
                             *  before we call out of the driver.
                             */
                        if (NT_SUCCESS(status) && fileExtension->isOpportunisticPolledDeviceReader) {
                            ReadPolledDevice(pdoExt, FALSE);
                        }
                    }
                } else {

                        /*
                         *  This is an ordinary NON-POLLED collection.
                         *  We either:
                         *      1.  Satisfy this read with a queued report
                         *              or
                         *      2.  Queue this read IRP and satisfy it in the future
                         *          when a report comes in (on one of the ping-pong IRPs).
                         */

                        //
                        // We only stop interrupt devices when we power down.
                        //
                    if (fdoExt->devicePowerState != PowerDeviceD0) {
                        DBGINFO(("read report received in low power"));
                    }
                    isStopped |= (fdoExt->devicePowerState != PowerDeviceD0);

                    LockFileExtension(fileExtension, &oldIrql);
                    if (isStopped) {
                        status = EnqueueInterruptReadIrp(classCollection, fileExtension, Irp);
                    } else {
                        ULONG userBufferRemaining = irpSp->Parameters.Read.Length;
                        PUCHAR callersBuffer;

                        callersBuffer = HidpGetSystemAddressForMdlSafe(Irp->MdlAddress);

                        if (callersBuffer) {
                            PUCHAR nextReportBuffer = callersBuffer;

                                /*
                                 *  There are some reports waiting.
                                 *
                                 *  Spin in this loop, filling up the caller's buffer with reports,
                                 *  until either the buffer fills up or we run out of reports.
                                 */
                            ULONG reportsReturned = 0;

                            status = STATUS_SUCCESS;

                            while (userBufferRemaining > 0) {
                                PHIDCLASS_REPORT reportExtension;
                                ULONG reportSize = userBufferRemaining;

                                reportExtension = DequeueInterruptReport(fileExtension, userBufferRemaining);
                                if (reportExtension) {
                                    status = HidpCopyInputReportToUser( fileExtension,
                                                                        reportExtension->UnparsedReport,
                                                                        &reportSize,
                                                                        nextReportBuffer);

                                        /*
                                         *  Whether we succeeded or failed, free this report.
                                         *  (If we failed, there may be something wrong with
                                         *   the report, so we'll just throw it away).
                                         */
                                    ExFreePool(reportExtension);

                                    if (NT_SUCCESS(status)) {
                                        reportsReturned++;
                                        nextReportBuffer += reportSize;
                                        ASSERT(reportSize <= userBufferRemaining);
                                        userBufferRemaining -= reportSize;
                                    } else {
                                        DBGSUCCESS(status, TRUE)
                                        break;
                                    }
                                } else {
                                    break;
                                }
                            }

                            if (NT_SUCCESS(status)) {
                                if (!reportsReturned) {
                                        /*
                                         *  No reports are ready.  So queue the read IRP.
                                         */
                                    status = EnqueueInterruptReadIrp(classCollection, fileExtension, Irp);
                                } else {
                                        /*
                                         *  We've succesfully copied something into the user's buffer,
                                         *  calculate how much we've copied and return in the irp.
                                         */
                                    Irp->IoStatus.Information = (ULONG)(nextReportBuffer - callersBuffer);
                                    DBG_RECORD_READ(Irp, (ULONG)Irp->IoStatus.Information, (ULONG)callersBuffer[0], TRUE)
                                }
                            }
                        } else {
                            status = STATUS_INVALID_USER_BUFFER;
                        }
                    }
                    UnlockFileExtension(fileExtension, oldIrql);
                }
            } else {
                status = STATUS_INVALID_BUFFER_SIZE;
            }
        } else {
            status = STATUS_DEVICE_NOT_CONNECTED;
        }

        DBGSUCCESS(status, FALSE)
    } else {
            /*
             *  This can legitimately happen.
             *  The device was disconnected between the client's open and read;
             *  or between a read-complete and the next read.
             */
        status = STATUS_DEVICE_NOT_CONNECTED;
    }


    /*
     *  If we satisfied the read Irp (did not queue it),
     *  then complete it here.
     */
    if (status != STATUS_PENDING) {
        ULONG insideReadCompleteCount;

        Irp->IoStatus.Status = status;

        insideReadCompleteCount = InterlockedIncrement(&fileExtension->insideReadCompleteCount);
        if (insideReadCompleteCount <= INSIDE_READCOMPLETE_MAX) {
            IoCompleteRequest(Irp, IO_KEYBOARD_INCREMENT);
        } else {
            /*
             *  All these nested reads are _probably_ occuring on the same thread,
             *  and we are going to run out of stack and crash if we keep completing
             *  synchronously.  So return pending for this IRP and schedule a workItem
             *  to complete it asynchronously, just to give the stack a chance to unwind.
             */
            ASYNC_COMPLETE_CONTEXT *asyncCompleteContext = ALLOCATEPOOL(NonPagedPool, sizeof(ASYNC_COMPLETE_CONTEXT));
            if (asyncCompleteContext) {
                ASSERT(!Irp->CancelRoutine);
                DBGWARN(("HidpIrpMajorRead: CLIENT IS LOOPING ON READ COMPLETION -- scheduling workItem to complete IRP %ph (status=%xh) asynchronously", Irp, status))
                asyncCompleteContext->workItem = IoAllocateWorkItem(pdoExt->pdo);

                asyncCompleteContext->sig = ASYNC_COMPLETE_CONTEXT_SIG;
                asyncCompleteContext->irp = Irp;

                /*
                 *  Indicate that the irp has been queued
                 */
                IoMarkIrpPending(asyncCompleteContext->irp);

                IoQueueWorkItem(asyncCompleteContext->workItem,
                                WorkItemCallback_CompleteIrpAsynchronously,
                                DelayedWorkQueue,
                                asyncCompleteContext);

                status = STATUS_PENDING;
            } else {
                DBGERR(("HidpIrpMajorRead: completeIrpWorkItem alloc failed"))
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }
        }

        InterlockedDecrement(&fileExtension->insideReadCompleteCount);
    }

    DBGSUCCESS(status, FALSE)    
    return status;
}



VOID 
WorkItemCallback_CompleteIrpAsynchronously(PDEVICE_OBJECT DevObj,
                                           PVOID context)
{
    ASYNC_COMPLETE_CONTEXT *asyncCompleteContext = context;

    ASSERT(asyncCompleteContext->sig == ASYNC_COMPLETE_CONTEXT_SIG);
    DBGVERBOSE(("WorkItemCallback_CompleteIrpAsynchronously: completing irp %ph with status %xh.", asyncCompleteContext->irp, asyncCompleteContext->irp->IoStatus.Status))

    IoCompleteRequest(asyncCompleteContext->irp, IO_NO_INCREMENT);

    IoFreeWorkItem(asyncCompleteContext->workItem);
    ExFreePool(asyncCompleteContext);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidclass\pingpong.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pingpong.c

Abstract

    Interrupt style collections like to always have a read pending in case
    something happens.  This file contains routines to keep IRPs down
    in the miniport, and to complete client reads (if a client read IRP is
    pending) or queue them (if not).

Author:

    Ervin P.

Environment:

    Kernel mode only

Revision History:


--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, HidpInitializePingPongIrps)
    #pragma alloc_text(PAGE, HidpReallocPingPongIrps)
#endif



/*
 ********************************************************************************
 *  HidpInitializePingPongIrps
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpInitializePingPongIrps(FDO_EXTENSION *fdoExtension)
{
    NTSTATUS result = STATUS_SUCCESS;
    ULONG i;
    CCHAR numIrpStackLocations;

    PAGED_CODE();

    /*
     *  Note that our functional device object normally requires FDO->StackSize stack
     *  locations; but these IRPs will only be sent to the minidriver, so we need one less.
     *
     *  THIS MEANS THAT WE SHOULD NEVER TOUCH OUR OWN STACK LOCATION (we don't have one!)
     */
    numIrpStackLocations = fdoExtension->fdo->StackSize - 1;


    //
    // Next determine the size of each input HID report.  There
    // must be at least one collection of type interrupt, or we wouldn't
    // need the ping-pong stuff at all and therefore wouldn't be here.
    //

    ASSERT(fdoExtension->maxReportSize > 0);
    ASSERT(fdoExtension->numPingPongs > 0);

    fdoExtension->pingPongs = ALLOCATEPOOL(NonPagedPool, fdoExtension->numPingPongs*sizeof(HIDCLASS_PINGPONG));
    if (fdoExtension->pingPongs){
        ULONG reportBufferSize = fdoExtension->maxReportSize;

        RtlZeroMemory(fdoExtension->pingPongs, fdoExtension->numPingPongs*sizeof(HIDCLASS_PINGPONG));

        #if DBG
            // reserve space for guard word
            reportBufferSize += sizeof(ULONG);
        #endif


        for (i = 0; i < fdoExtension->numPingPongs; i++){

            fdoExtension->pingPongs[i].myFdoExt = fdoExtension;
            fdoExtension->pingPongs[i].weAreCancelling = 0;
            fdoExtension->pingPongs[i].sig = PINGPONG_SIG;

            /*
             *  Initialize backoff timeout to 1 second (in neg 100-nsec units)
             */
            fdoExtension->pingPongs[i].backoffTimerPeriod.HighPart = -1;
            fdoExtension->pingPongs[i].backoffTimerPeriod.LowPart = -10000000;
            KeInitializeTimer(&fdoExtension->pingPongs[i].backoffTimer);
            KeInitializeDpc(&fdoExtension->pingPongs[i].backoffTimerDPC,
                            HidpPingpongBackoffTimerDpc,
                            &fdoExtension->pingPongs[i]);

            fdoExtension->pingPongs[i].reportBuffer = ALLOCATEPOOL(NonPagedPool, reportBufferSize);
            if (fdoExtension->pingPongs[i].reportBuffer){
                PIRP irp;

                #if DBG
                    #ifdef _X86_
                        // this sets off alignment problems on Alpha
                        // place guard word
                        *(PULONG)(&fdoExtension->pingPongs[i].reportBuffer[fdoExtension->maxReportSize]) = HIDCLASS_REPORT_BUFFER_GUARD;
                    #endif
                #endif

                irp = IoAllocateIrp(numIrpStackLocations, FALSE);
                if (irp){
                    /*
                     *  Point the ping-pong IRP's UserBuffer to the corresponding
                     *  ping-pong object's report buffer.
                     */
                    irp->UserBuffer = fdoExtension->pingPongs[i].reportBuffer;
                    fdoExtension->pingPongs[i].irp = irp;
                    KeInitializeEvent(&fdoExtension->pingPongs[i].sentEvent,
                                      NotificationEvent,
                                      TRUE);    // Set to signaled
                    KeInitializeEvent(&fdoExtension->pingPongs[i].pumpDoneEvent,
                                      NotificationEvent,
                                      TRUE);    // Set to signaled
                }
                else {
                    result = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }
            }
            else {
                result = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
        }
    }
    else {
        result = STATUS_INSUFFICIENT_RESOURCES;
    }

    DBGSUCCESS(result, TRUE)
    return result;
}


/*
 ********************************************************************************
 *  HidpReallocPingPongIrps
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpReallocPingPongIrps(FDO_EXTENSION *fdoExtension, ULONG newNumBufs)
{
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    if (fdoExtension->driverExt->DevicesArePolled){
        /*
         * Polled devices don't _HAVE_ ping-pong IRPs.
         */
        DBGERR(("Minidriver devices polled fdo %x.", fdoExtension))
        fdoExtension->numPingPongs = 0;
        fdoExtension->pingPongs = BAD_POINTER;
        status = STATUS_SUCCESS;
    }
    else if (newNumBufs < MIN_PINGPONG_IRPS){
        DBGERR(("newNumBufs < MIN_PINGPONG_IRPS!"))
        status = STATUS_INVALID_DEVICE_REQUEST;
    }
    else {

        DestroyPingPongs(fdoExtension);

        if (HidpSetMaxReportSize(fdoExtension)){

            /*
             *  Initialize and restart the new ping-pong IRPs.
             *  If we can't allocate the desired number of buffers,
             *  keep reducing until we get some.
             */
            do {
                fdoExtension->numPingPongs = newNumBufs;
                status = HidpInitializePingPongIrps(fdoExtension);
                newNumBufs /= 2;
            } while (!NT_SUCCESS(status) && (newNumBufs >= MIN_PINGPONG_IRPS));

            if (!NT_SUCCESS(status)) {
                /*
                 * The device will no longer function !!!
                 */
                TRAP;
                fdoExtension->numPingPongs = 0;
            }
        }
    }

    DBGSUCCESS(status, TRUE)
    return status;
}



/*
 ********************************************************************************
 *  HidpSubmitInterruptRead
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpSubmitInterruptRead(
    IN FDO_EXTENSION *fdoExt,
    HIDCLASS_PINGPONG *pingPong,
    BOOLEAN *irpSent)
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpSp;
    KIRQL oldIrql;
    BOOLEAN proceed;
    LONG oldInterlock;
    PIRP irp = pingPong->irp;

    ASSERT(irp);

    *irpSent = FALSE;

    while (1) {
        if (NT_SUCCESS(status)) {
            HidpSetDeviceBusy(fdoExt);

            oldInterlock = InterlockedExchange(&pingPong->ReadInterlock,
                                               PINGPONG_START_READ);
            ASSERT(oldInterlock == PINGPONG_END_READ);

            irp->Cancel = FALSE;
            irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

            irpSp = IoGetNextIrpStackLocation(irp);
            irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
            irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_HID_READ_REPORT;
            irpSp->Parameters.DeviceIoControl.OutputBufferLength = fdoExt->maxReportSize;

            /*
             *  Indicate interrupt collection (default).
             *  We use .InputBufferLength for this
             */
            irpSp->Parameters.DeviceIoControl.InputBufferLength = 0;

            ASSERT(irp->UserBuffer == pingPong->reportBuffer);
            #ifdef _X86_
                // this sets off alignment problems on Alpha
                ASSERT(*(PULONG)(&pingPong->reportBuffer[fdoExt->maxReportSize]) == HIDCLASS_REPORT_BUFFER_GUARD);
            #endif

            /*
             *  Set the completion, passing the FDO extension as context.
             */
            IoSetCompletionRoutine( irp,
                                    HidpInterruptReadComplete,
                                    (PVOID)fdoExt,
                                    TRUE,
                                    TRUE,
                                    TRUE );


            /*
             *  Send down the read IRP.
             */
            KeResetEvent(&pingPong->sentEvent);
            if (pingPong->weAreCancelling) {
                //
                // Ordering of the next two instructions is crucial, since
                // CancelPingPongs will exit after pumpDoneEvent is set, and the
                // pingPongs could be deleted after that.
                //
                DBGVERBOSE(("Pingpong %x cancelled in submit before sending\n", pingPong))
                KeSetEvent (&pingPong->sentEvent, 0, FALSE);
                KeSetEvent(&pingPong->pumpDoneEvent, 0, FALSE);
                status = STATUS_CANCELLED;
                break;
            } else {
                InterlockedIncrement(&fdoExt->outstandingRequests);
                DBGVERBOSE(("Sending pingpong %x from Submit\n", pingPong))
                status = HidpCallDriver(fdoExt->fdo, irp);
                KeSetEvent (&pingPong->sentEvent, 0, FALSE);
                *irpSent = TRUE;
            }

            if (PINGPONG_IMMEDIATE_READ != InterlockedExchange(&pingPong->ReadInterlock,
                                                               PINGPONG_END_READ)) {
                //
                // The read is asynch, will call SubmitInterruptRead from the
                // completion routine
                //
                DBGVERBOSE(("read is pending\n"))
                break;
            } else {
                //
                // The read was synchronous (probably bytes in the buffer).  The
                // completion routine will not call SubmitInterruptRead, so we
                // just loop here.  This is to prevent us from running out of stack
                // space if always call StartRead from the completion routine
                //
                status = irp->IoStatus.Status;
                DBGVERBOSE(("read is looping with status %x\n", status))
            }
        } else {
            if (pingPong->weAreCancelling ){

                // We are stopping the read pump.
                // set this event and stop resending the pingpong IRP.
                DBGVERBOSE(("We are cancelling bit set for pingpong %x\n", pingPong))
                KeSetEvent(&pingPong->pumpDoneEvent, 0, FALSE);
            } else {
                /*
                 *  The device returned error.
                 *  In order to support slightly-broken devices which
                 *  "hiccup" occasionally, we implement a back-off timer
                 *  algorithm; this way, the device gets a second chance,
                 *  but if it spits back error each time, this doesn't
                 *  eat up all the available CPU.
                 */
                DBGVERBOSE(("Queuing backoff timer on pingpong %x\n", pingPong))
                ASSERT((LONG)pingPong->backoffTimerPeriod.HighPart == -1);
                ASSERT((LONG)pingPong->backoffTimerPeriod.LowPart < 0);
                KeSetTimer( &pingPong->backoffTimer,
                            pingPong->backoffTimerPeriod,
                            &pingPong->backoffTimerDPC);
            }
            break;
        }
    }

    DBGSUCCESS(status, FALSE)
    return status;
}



/*
 ********************************************************************************
 *  HidpProcessInterruptReport
 ********************************************************************************
 *
 *  Take the new interrupt read report and either:
 *      1.  If there is a pending read IRP, use it to satisfy that read IRP
 *          and complete the read IRP
 *
 *              or
 *
 *      2.  If there is no pending read IRP,
 *          queue the report for a future read.
 *
 */
NTSTATUS HidpProcessInterruptReport(
    PHIDCLASS_COLLECTION collection,
    PHIDCLASS_FILE_EXTENSION FileExtension,
    PUCHAR Report,
    ULONG ReportLength,
    PIRP *irpToComplete
    )
{
    KIRQL oldIrql;
    NTSTATUS result;
    PIRP readIrpToSatisfy;
    
    LockFileExtension(FileExtension, &oldIrql);

    /*
     *  Dequeue the next interrupt read.
     */
    readIrpToSatisfy = DequeueInterruptReadIrp(collection, FileExtension);

    if (readIrpToSatisfy){
        /*
         *  We have dequeued a pended read IRP
         *  which we will complete with this report.
         */
        ULONG userReportLength;
        PCHAR pDest;
        PIO_STACK_LOCATION irpSp;
        NTSTATUS status;

        ASSERT(IsListEmpty(&FileExtension->ReportList));

        irpSp = IoGetCurrentIrpStackLocation(readIrpToSatisfy);
        pDest = HidpGetSystemAddressForMdlSafe(readIrpToSatisfy->MdlAddress);
        if(pDest) {
            userReportLength = irpSp->Parameters.Read.Length;

            status = HidpCopyInputReportToUser( FileExtension,
                                                Report,
                                                &userReportLength,
                                                pDest);
            DBGASSERT(NT_SUCCESS(status),
                      ("HidpCopyInputReportToUser returned status = %x", status),
                      TRUE)
    
            readIrpToSatisfy->IoStatus.Status = status;
            readIrpToSatisfy->IoStatus.Information = userReportLength;

            DBG_RECORD_READ(readIrpToSatisfy, userReportLength, (ULONG)Report[0], TRUE)

            result = status;
        } else {
                result = STATUS_INVALID_USER_BUFFER;
                readIrpToSatisfy->IoStatus.Status = result;
        }
    } else {
        /*
         *  We don't have any pending read IRPs.
         *  So queue this report for the next read.
         */

        PHIDCLASS_REPORT report;
        ULONG reportSize;

        reportSize = FIELD_OFFSET(HIDCLASS_REPORT, UnparsedReport) + ReportLength;
        report = ALLOCATEPOOL(NonPagedPool, reportSize);
        if (report){
            report->reportLength = ReportLength;
            RtlCopyMemory(report->UnparsedReport, Report, ReportLength);
            EnqueueInterruptReport(FileExtension, report);
            result = STATUS_PENDING;
        } else {
                result = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    UnlockFileExtension(FileExtension, oldIrql);

    /*
     *  This function is called with the fileExtensionsList spinlock held.
     *  So we can't complete the IRP here.  Pass it back to the caller and it'll
     *  be completed as soon as we drop all the spinlocks.
     */
    *irpToComplete = readIrpToSatisfy;

    DBGSUCCESS(result, FALSE)
    return result;
}


/*
 ********************************************************************************
 *  HidpDistributeInterruptReport
 ********************************************************************************
 *
 *
 */
VOID HidpDistributeInterruptReport(
    IN PHIDCLASS_COLLECTION hidclassCollection,
    PUCHAR Report,
    ULONG ReportLength
    )
{
    PLIST_ENTRY listEntry;
    KIRQL oldIrql;
    LIST_ENTRY irpsToComplete;
    ULONG secureReadMode;

    #if DBG
        ULONG numRecipients = 0;
        ULONG numPending = 0;
        ULONG numFailed = 0;
    #endif

    InitializeListHead(&irpsToComplete);

    KeAcquireSpinLock(&hidclassCollection->FileExtensionListSpinLock, &oldIrql);

    listEntry = &hidclassCollection->FileExtensionList;
    secureReadMode = hidclassCollection->secureReadMode;

    while ((listEntry = listEntry->Flink) != &hidclassCollection->FileExtensionList){
        PIRP irpToComplete;
        PHIDCLASS_FILE_EXTENSION fileExtension = CONTAINING_RECORD(listEntry, HIDCLASS_FILE_EXTENSION, FileList);
        NTSTATUS status;
        
        //
        //  This is to enforce security for devices such as a digitizer on a 
        //  tablet PC at the logon screen
        //
        if (secureReadMode && !fileExtension->isSecureOpen) {
            continue;
        }
        
        #if DBG
            status =
        #endif
        
        HidpProcessInterruptReport(hidclassCollection, fileExtension, Report, ReportLength, &irpToComplete);

        if (irpToComplete){
           InsertTailList(&irpsToComplete, &irpToComplete->Tail.Overlay.ListEntry);
        }

        #if DBG
            if (status == STATUS_SUCCESS){
            }
            else if (status == STATUS_PENDING){
                numPending++;
            }
            else {
                DBGSUCCESS(status, FALSE)
                numFailed++;
            }
            numRecipients++;
        #endif
    }

    DBG_LOG_REPORT(hidclassCollection->CollectionNumber, numRecipients, numPending, numFailed, Report, ReportLength)

    KeReleaseSpinLock(&hidclassCollection->FileExtensionListSpinLock, oldIrql);

    /*
     *  Now that we've dropped all the spinlocks, complete all the dequeued read IRPs.
     */
    while (!IsListEmpty(&irpsToComplete)){
        PIRP irp;
        PLIST_ENTRY listEntry = RemoveHeadList(&irpsToComplete);
        irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);
        IoCompleteRequest(irp, IO_KEYBOARD_INCREMENT);
    }
}


/*
 ********************************************************************************
 *  GetPingPongFromIrp
 ********************************************************************************
 *
 *
 */
HIDCLASS_PINGPONG *GetPingPongFromIrp(FDO_EXTENSION *fdoExt, PIRP irp)
{
    HIDCLASS_PINGPONG *pingPong = NULL;
    ULONG i;

    for (i = 0; i < fdoExt->numPingPongs; i++){
        if (fdoExt->pingPongs[i].irp == irp){
            pingPong = &fdoExt->pingPongs[i];
            break;
        }
    }

    ASSERT(pingPong);
    return pingPong;
}


/*
 ********************************************************************************
 *  HidpInterruptReadComplete
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpInterruptReadComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    FDO_EXTENSION *fdoExt = (FDO_EXTENSION *)Context;
    HIDCLASS_PINGPONG *pingPong;
    KIRQL irql;
    BOOLEAN startRead;

    DBG_COMMON_ENTRY()

    DBGLOG_INTSTART()

    //
    // Track the number of outstanding requests to this device.
    //
    ASSERT(fdoExt->outstandingRequests > 0 );
    InterlockedDecrement(&fdoExt->outstandingRequests);

    pingPong = GetPingPongFromIrp(fdoExt, Irp);

    if (!pingPong) {
        //
        // Something is terribly wrong, but do nothing. Hopefully
        // just exiting will clear up this pimple.
        //
        DBGERR(("A pingPong structure could not be found!!! Have this looked at!"))
        goto InterruptReadCompleteExit;
    }

    //
    // If ReadInterlock is == START_READ, this func has been completed
    // synchronously.  Place IMMEDIATE_READ into the interlock to signify this
    // situation; this will notify StartRead to loop when IoCallDriver returns.
    // Otherwise, we have been completed async and it is safe to call StartRead()
    //
    startRead =
       (PINGPONG_START_READ !=
        InterlockedCompareExchange(&pingPong->ReadInterlock,
                                   PINGPONG_IMMEDIATE_READ,
                                   PINGPONG_START_READ));


    /*
     *  Take appropriate action based on the completion code of this pingpong irp.
     */
    if (NT_SUCCESS(Irp->IoStatus.Status)){

        /*
         *  We've read one or more input reports.
         *  They are sitting consecutively in Irp->UserBuffer.
         */
        PUCHAR reportStart = Irp->UserBuffer;
        LONG bytesRemaining = (LONG)Irp->IoStatus.Information;

        DBGASSERT(bytesRemaining > 0, ("BAD HARDWARE. Device returned zero bytes. If this happens repeatedly, remove device."), FALSE);

        /*
         *  Deliver each report separately.
         */
        while (bytesRemaining > 0){
            UCHAR reportId;
            PHIDP_REPORT_IDS reportIdentifier;

            /*
             *  If the first report ID is 0, then there is only one report id
             *  and it is known implicitly by the device, so it is not included
             *  in the reports sent to or from the device.
             *  Otherwise, there are multiple report ids and the report id is the
             *  first byte of the report.
             */
            if (fdoExt->deviceDesc.ReportIDs[0].ReportID == 0){
                /*
                 *  This device has only a single input report ID, so call it report id 0;
                 */
                reportId = 0;
            }
            else {
                /*
                 *  This device has multiple input report IDs, so each report
                 *  begins with a UCHAR report ID.
                 */
                reportId = *reportStart;
                DBGASSERT(reportId,
                          ("Bad Hardware. Not returning a report id although it has multiple ids."),
                          FALSE) // Bad hardware, bug 354829.
                reportStart += sizeof(UCHAR);
                bytesRemaining--;
            }


            /*
             *  Extract the report identifier with the given id from the HID device extension.
             */
            reportIdentifier = GetReportIdentifier(fdoExt, reportId);

            if (reportIdentifier){
                LONG reportDataLen =    (reportId ?
                                         reportIdentifier->InputLength-1 :
                                         reportIdentifier->InputLength);

                if ((reportDataLen > 0) && (reportDataLen <= bytesRemaining)){

                    PHIDCLASS_COLLECTION    collection;
                    PHIDP_COLLECTION_DESC   hidCollectionDesc;

                    /*
                     *  This report represents the state of some collection on the device.
                     *  Find that collection.
                     */
                    collection = GetHidclassCollection( fdoExt,
                                                        reportIdentifier->CollectionNumber);
                    hidCollectionDesc = GetCollectionDesc(  fdoExt,
                                                            reportIdentifier->CollectionNumber);
                    if (collection && hidCollectionDesc){
                        PDO_EXTENSION *pdoExt;

                        /*
                         *  The collection's inputLength is the size of the
                         *  largest report (including report id); so it should
                         *  be at least as big as this one.
                         */
                        ASSERT(hidCollectionDesc->InputLength >= reportDataLen+1);

                        /*
                         *  Make sure that the PDO for this collection has gotten
                         *  START_DEVICE before returning anything for it.
                         *  (collection-PDOs can get REMOVE_DEVICE/START_DEVICE intermittently).
                         */

                        if (ISPTR(fdoExt->collectionPdoExtensions)
                            && ISPTR(fdoExt->collectionPdoExtensions[collection->CollectionIndex])) {
                        
                            pdoExt = &fdoExt->collectionPdoExtensions[collection->CollectionIndex]->pdoExt;
                            ASSERT(ISPTR(pdoExt));
                            if (pdoExt->state == COLLECTION_STATE_RUNNING){        
                                /*
                                *  "Cook" the report
                                *  (if it doesn't already have a report id byte, add one).
                                */
                                ASSERT(ISPTR(collection->cookedInterruptReportBuf));
                                collection->cookedInterruptReportBuf[0] = reportId;
                                RtlCopyMemory(  collection->cookedInterruptReportBuf+1,
                                                reportStart,
                                                reportDataLen);

                                /*
                                 *  If this report contains a power-button event, alert this system.
                                 */
                                CheckReportPowerEvent(  fdoExt,
                                                        collection,
                                                        collection->cookedInterruptReportBuf,
                                                        hidCollectionDesc->InputLength);

                                /*
                                *  Distribute the report to all of the open file objects on this collection.
                                */
                                HidpDistributeInterruptReport(collection,
                                                            collection->cookedInterruptReportBuf,
                                                            hidCollectionDesc->InputLength);
                            }
                            else {
                                DBGVERBOSE(("Report dropped because collection-PDO not started (pdoExt->state = %d).", pdoExt->state))
                            }

                        }
                        else {

                            DBGVERBOSE(("Report dropped because collection-PDO doesn't exist"))

                        }
                    }
                    else {
                        // PDO hasn't been initialized yet.  Throw away data.
                        DBGVERBOSE(("Report dropped because collection-PDO not initialized."))

//                        TRAP;
                        break;
                    }
                }
                else {
                    DBGASSERT(reportDataLen > 0, ("Device returning report id with zero-length input report as part of input data."), FALSE)
                    if (reportDataLen > bytesRemaining) {
                        DBGVERBOSE(("Device has corrupt input report"));
                    }
                    break;
                }

                /*
                 *  Move to the next report in the buffer.
                 */
                bytesRemaining -= reportDataLen;
                reportStart += reportDataLen;
            }
            else {
                //
                // We have thrown away data because we couldn't find a report
                // identifier corresponding to this data that we've been
                // returned. Bad hardware, bug 354829.
                //
                break;
            }
        }

        /*
         *  The read succeeded.
         *  Reset the backoff timer stuff (for when reads fail)
         *  and re-submit this ping-pong IRP.
         */
        pingPong->backoffTimerPeriod.HighPart = -1;
        pingPong->backoffTimerPeriod.LowPart = -10000000;
    }

    //
    // Business as usual.
    //
    if (startRead) {
        if (pingPong->weAreCancelling ){

            // We are stopping the read pump.
            // Set this event and stop resending the pingpong IRP.
            DBGVERBOSE(("We are cancelling bit set for pingpong %x\n", pingPong))
            KeSetEvent(&pingPong->pumpDoneEvent, 0, FALSE);
        } else {
            if (NT_SUCCESS(Irp->IoStatus.Status)){
                BOOLEAN irpSent;
                DBGVERBOSE(("Submitting pingpong %x from completion routine\n", pingPong))
                HidpSubmitInterruptRead(fdoExt, pingPong, &irpSent);
            } else {
                /*
                 *  The device returned error.
                 *  In order to support slightly-broken devices which
                 *  "hiccup" occasionally, we implement a back-off timer
                 *  algorithm; this way, the device gets a second chance,
                 *  but if it spits back error each time, this doesn't
                 *  eat up all the available CPU.
                 */
                #if DBG
                    if (dbgTrapOnHiccup){
                        DBGERR(("Device 'hiccuped' (status=%xh); setting backoff timer (fdoExt=%ph)...", Irp->IoStatus.Status, fdoExt))
                    }
                #endif
                DBGVERBOSE(("Device returned error %x on pingpong %x\n", Irp->IoStatus.Status, pingPong))
                ASSERT((LONG)pingPong->backoffTimerPeriod.HighPart == -1);
                ASSERT((LONG)pingPong->backoffTimerPeriod.LowPart < 0);
                KeSetTimer( &pingPong->backoffTimer,
                            pingPong->backoffTimerPeriod,
                            &pingPong->backoffTimerDPC);
            }
        }
    }

InterruptReadCompleteExit:
    DBGLOG_INTEND()
    DBG_COMMON_EXIT()

    /*
    *  ALWAYS return STATUS_MORE_PROCESSING_REQUIRED;
    *  otherwise, the irp is required to have a thread.
    */
    return STATUS_MORE_PROCESSING_REQUIRED;
}



/*
 ********************************************************************************
 *  HidpStartAllPingPongs
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpStartAllPingPongs(FDO_EXTENSION *fdoExt)
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG i;

    ASSERT(fdoExt->numPingPongs > 0);

    for (i = 0; i < fdoExt->numPingPongs; i++){
        BOOLEAN irpSent;

        // Different threads may be trying to start this pump at the
        // same time due to idle notification. Must only start once.
        if (fdoExt->pingPongs[i].pumpDoneEvent.Header.SignalState) {
            fdoExt->pingPongs[i].ReadInterlock = PINGPONG_END_READ;
            KeResetEvent(&fdoExt->pingPongs[i].pumpDoneEvent);
            DBGVERBOSE(("Starting pingpong %x from HidpStartAllPingPongs\n", &fdoExt->pingPongs[i]))
            status = HidpSubmitInterruptRead(fdoExt, &fdoExt->pingPongs[i], &irpSent);
            if (!NT_SUCCESS(status)){
                if (irpSent){
                    DBGWARN(("Initial read failed with status %xh.", status))
                    #if DBG
                        if (dbgTrapOnHiccup){
                            DBGERR(("Device 'hiccuped' ?? (fdoExt=%ph).", fdoExt))
                        }
                    #endif

                    /*
                     *  We'll let the back-off logic in the completion
                     *  routine deal with this.
                     */
                    status = STATUS_SUCCESS;
                }
                else {
                    DBGERR(("Initial read failed, irp not sent, status = %xh.", status))
                    break;
                }
            }
        }
    }

    if (status == STATUS_PENDING){
        status = STATUS_SUCCESS;
    }

    DBGSUCCESS(status, TRUE)
    return status;
}


/*
 ********************************************************************************
 *  CancelAllPingPongIrps
 ********************************************************************************
 *
 *
 */
VOID CancelAllPingPongIrps(FDO_EXTENSION *fdoExt)
{
    ULONG i;

    for (i = 0; i < fdoExt->numPingPongs; i++){
        HIDCLASS_PINGPONG *pingPong = &fdoExt->pingPongs[i];

        DBGVERBOSE(("Cancelling pingpong %x\n", pingPong))
        ASSERT(pingPong->sig == PINGPONG_SIG);
        ASSERT(!pingPong->weAreCancelling);

        //
        // The order of the following instructions is crucial. We must set
        // the weAreCancelling bit before waiting on the sentEvent, and the
        // last thing that we should wait on is the pumpDoneEvent, which
        // indicates that the read loop has finished all reads and will never
        // run again.
        //
        // Note that we don't need spinlocks to guard since we only have two
        // threads touching pingpong structures; the read pump thread and the
        // pnp thread. PNP irps are synchronous, so those are safe. Using the
        // weAreCancelling bit and the two events, sentEvent and pumpDoneEvent,
        // the pnp irps are synchronized with the pnp routines. This insures
        // that this cancel routine doesn't exit until the read pump has
        // signalled the pumpDoneEvent and exited, hence the pingpong
        // structures aren't ripped out from underneath it.
        //
        // If we have a backoff timer queued, it will eventually fire and
        // call the submitinterruptread routine to restart reads. This will
        // exit eventually, because we have set the weAreCancelling bit.
        //
        InterlockedIncrement(&pingPong->weAreCancelling);

        {
        /*
         *  Synchronize with the irp's completion routine.
         */
        #if DBG
            UCHAR beforeIrql = KeGetCurrentIrql();
            UCHAR afterIrql;
            PVOID cancelRoutine = (PVOID)pingPong->irp->CancelRoutine;
        #endif

        KeWaitForSingleObject(&pingPong->sentEvent,
                              Executive,      // wait reason
                              KernelMode,
                              FALSE,          // not alertable
                              NULL );         // no timeout
        DBGVERBOSE(("Pingpong sent event set for pingpong %x\n", pingPong))
        IoCancelIrp(pingPong->irp);

        #if DBG
            afterIrql = KeGetCurrentIrql();
            if (afterIrql != beforeIrql){
                DBGERR(("CancelAllPingPongIrps: cancel routine at %ph changed irql from %d to %d.", cancelRoutine, beforeIrql, afterIrql))
            }
        #endif
        }

        /*
         *  Cancelling the IRP causes a lower driver to
         *  complete it (either in a cancel routine or when
         *  the driver checks Irp->Cancel just before queueing it).
         *  Wait for the IRP to actually get cancelled.
         */
        KeWaitForSingleObject(  &pingPong->pumpDoneEvent,
                                Executive,      // wait reason
                                KernelMode,
                                FALSE,          // not alertable
                                NULL );         // no timeout
        InterlockedDecrement(&pingPong->weAreCancelling);
        DBGVERBOSE(("Pingpong pump done event set for %x\n", pingPong))
    }
}


/*
 ********************************************************************************
 *  DestroyPingPongs
 ********************************************************************************
 *
 *
 */
VOID DestroyPingPongs(FDO_EXTENSION *fdoExt)
{
    if (ISPTR(fdoExt->pingPongs)){
        ULONG i;

        CancelAllPingPongIrps(fdoExt);

        for (i = 0; i < fdoExt->numPingPongs; i++){
            IoFreeIrp(fdoExt->pingPongs[i].irp);
            ExFreePool(fdoExt->pingPongs[i].reportBuffer);
            #if DBG
                fdoExt->pingPongs[i].sig = 0xDEADBEEF;
            #endif
        }

        ExFreePool(fdoExt->pingPongs);
        fdoExt->pingPongs = BAD_POINTER;
    }
}


/*
 ********************************************************************************
 *  HidpPingpongBackoffTimerDpc
 ********************************************************************************
 *
 *
 *
 */
VOID HidpPingpongBackoffTimerDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    HIDCLASS_PINGPONG *pingPong = (HIDCLASS_PINGPONG *)DeferredContext;
    BOOLEAN irpSent;

    ASSERT(pingPong->sig == PINGPONG_SIG);

    /*
     *  Increase the back-off time by 1 second, up to a max of 5 secs
     *  (in negative 100-nanosecond units).
     */
    ASSERT((LONG)pingPong->backoffTimerPeriod.HighPart == -1);
    ASSERT((LONG)pingPong->backoffTimerPeriod.LowPart < 0);

    if ((LONG)pingPong->backoffTimerPeriod.LowPart > -50000000){
        (LONG)pingPong->backoffTimerPeriod.LowPart -= 10000000;
    }

    DBGVERBOSE(("Submitting Pingpong %x from backoff\n", pingPong))
    //
    // If we are being removed, or the CancelAllPingPongIrps has been called,
    // this call will take care of things.
    //
    HidpSubmitInterruptRead(pingPong->myFdoExt, pingPong, &irpSent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidclass\polled.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    polled.c

Abstract

    Read handling routines

Author:

    Ervin P.

Environment:

    Kernel mode only

Revision History:


--*/


#include "pch.h"



/*
 ********************************************************************************
 *  CompleteQueuedIrpsForPolled
 ********************************************************************************
 *
 *  Complete all waiting client reads with the given report value.
 *
 *  Note: report is a 'cooked' report (i.e. it already has the report id added).
 *
 */
VOID CompleteQueuedIrpsForPolled(   FDO_EXTENSION *fdoExt,
                                    ULONG collectionNum,
                                    PUCHAR report,
                                    ULONG reportLen,
                                    NTSTATUS status)
{
    PHIDCLASS_COLLECTION hidCollection;

    hidCollection = GetHidclassCollection(fdoExt, collectionNum);

    if (hidCollection){
        PLIST_ENTRY listEntry;
        LIST_ENTRY irpsToComplete;
        PIRP irp;
        ULONG actualLen;

        /*
         *  Note: In order to avoid an infinite loop with a client that
         *        resubmits the read each in his completion routine,
         *        we must build a separate list of IRPs to be completed
         *        while holding the spinlock continuously.
         */
        InitializeListHead(&irpsToComplete);

        if (hidCollection->secureReadMode) {
            while (irp = DequeuePolledReadSystemIrp(hidCollection)){
                InsertTailList(&irpsToComplete, &irp->Tail.Overlay.ListEntry);
            }

        } else {
        
            while (irp = DequeuePolledReadIrp(hidCollection)){
                InsertTailList(&irpsToComplete, &irp->Tail.Overlay.ListEntry);
                
            }

        }

        while (!IsListEmpty(&irpsToComplete)){
            PIO_STACK_LOCATION stackPtr;
            PHIDCLASS_FILE_EXTENSION fileExtension;

            listEntry = RemoveHeadList(&irpsToComplete);
            irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);

            stackPtr = IoGetCurrentIrpStackLocation(irp);
            ASSERT(stackPtr);
            fileExtension = (PHIDCLASS_FILE_EXTENSION)stackPtr->FileObject->FsContext;
            ASSERT(fileExtension->Signature == HIDCLASS_FILE_EXTENSION_SIG);

            actualLen = 0;
            if (NT_SUCCESS(status)){
                PUCHAR callerBuf;

                callerBuf = HidpGetSystemAddressForMdlSafe(irp->MdlAddress);

                if (callerBuf && (stackPtr->Parameters.Read.Length >= reportLen)){
                    RtlCopyMemory(callerBuf, report, reportLen);
                    irp->IoStatus.Information = actualLen = reportLen;
                } else {
                    status = STATUS_INVALID_USER_BUFFER;
                }
            }

            DBG_RECORD_READ(irp, actualLen, (ULONG)report[0], TRUE)
            irp->IoStatus.Status = status;
            IoCompleteRequest(irp, IO_KEYBOARD_INCREMENT);
            
        }
    }
    else {
        TRAP;
    }
}

/*
 ********************************************************************************
 *  HidpPolledReadComplete
 ********************************************************************************
 *
 *  Note: the context passed to this callback is the PDO extension for
 *        the collection which initiated this read; however, the returned
 *        report may be for another collection.
 */
NTSTATUS HidpPolledReadComplete(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
{
    PDO_EXTENSION *pdoExt = (PDO_EXTENSION *)Context;
    FDO_EXTENSION *fdoExt = &pdoExt->deviceFdoExt->fdoExt;
    PIO_STACK_LOCATION nextStack = IoGetNextIrpStackLocation(Irp);
    ULONG reportId;
    PHIDP_REPORT_IDS reportIdent;

    DBG_COMMON_ENTRY()

    ASSERT(pdoExt->deviceFdoExt->Signature == HID_DEVICE_EXTENSION_SIG);
    ASSERT(ISPTR(Irp->UserBuffer));

    InterlockedIncrement(&fdoExt->outstandingRequests);

    if (fdoExt->deviceDesc.ReportIDs[0].ReportID == 0) {
        /*
         *  We previously incremented the UserBuffer to knock off the report id,
         *  so restore it now and set the default report id.
         */
        *(PUCHAR)(--(PUCHAR)Irp->UserBuffer) = (UCHAR)0;
        if (NT_SUCCESS(Irp->IoStatus.Status)){
            Irp->IoStatus.Information++;
        }
    }

    /*
     *  WHETHER OR NOT THE CALL SUCCEEDED,
     *  we'll complete the waiting client read IRPs with
     *  the result of this read.
     */
    reportId = (ULONG)(*(PUCHAR)Irp->UserBuffer);
    reportIdent = GetReportIdentifier(fdoExt, reportId);
    if (reportIdent){
        ULONG collectionNum = reportIdent->CollectionNumber;
        PHIDCLASS_COLLECTION hidpCollection = GetHidclassCollection(fdoExt, collectionNum);
        PHIDP_COLLECTION_DESC hidCollectionDesc = GetCollectionDesc(fdoExt, collectionNum);

        if (hidpCollection && hidCollectionDesc){
            ULONG reportLen = (ULONG)Irp->IoStatus.Information;

            ASSERT((reportLen == hidCollectionDesc->InputLength) || !NT_SUCCESS(Irp->IoStatus.Status));

            if (NT_SUCCESS(Irp->IoStatus.Status)){
                KIRQL oldIrql;

                /*
                 *  If this report contains a power-button event, alert the system.
                 */
                CheckReportPowerEvent(  fdoExt,
                                        hidpCollection,
                                        Irp->UserBuffer,
                                        reportLen);

                /*
                 *  Save this report for "opportunistic" polled device
                 *  readers who want a result right away.
                 *  Use the polledDeviceReadQueueSpinLock to protect
                 *  the savedPolledReportBuf.
                 */

                if (hidpCollection->secureReadMode) {

                    hidpCollection->polledDataIsStale = TRUE;

                } else {
                
                    KeAcquireSpinLock(&hidpCollection->polledDeviceReadQueueSpinLock, &oldIrql);
                    ASSERT(reportLen <= fdoExt->maxReportSize+1);
                    RtlCopyMemory(hidpCollection->savedPolledReportBuf, Irp->UserBuffer, reportLen);
                    hidpCollection->savedPolledReportLen = reportLen;
                    hidpCollection->polledDataIsStale = FALSE;
                    KeReleaseSpinLock(&hidpCollection->polledDeviceReadQueueSpinLock, oldIrql);

                }
            }

            /*
             *  Copy this report for all queued read IRPs on this polled device.
             *  Do this AFTER updating the savedPolledReport information
             *  because many clients will issue a read again immediately
             *  from the completion routine.
             */
            CompleteQueuedIrpsForPolled(    fdoExt,
                                            collectionNum,
                                            Irp->UserBuffer,
                                            reportLen,
                                            Irp->IoStatus.Status);

        }
        else {
            TRAP;
        }
    }
    else {
        TRAP;
    }


    /*
     *  This is an IRP we created to poll the device.
     *  Free the buffer we allocated for the read.
     */
    ExFreePool(Irp->UserBuffer);
    IoFreeIrp(Irp);

    /*
     *  MUST return STATUS_MORE_PROCESSING_REQUIRED here or
     *  NTKERN will touch the IRP.
     */
    DBG_COMMON_EXIT()
    return STATUS_MORE_PROCESSING_REQUIRED;
}


/*
 ********************************************************************************
 *  HidpPolledReadComplete_TimerDriven
 ********************************************************************************
 *
 */
NTSTATUS HidpPolledReadComplete_TimerDriven(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
{
    PDO_EXTENSION *pdoExt = (PDO_EXTENSION *)Context;
    FDO_EXTENSION *fdoExt = &pdoExt->deviceFdoExt->fdoExt;
    NTSTATUS status;

    /*
     *  Call the actual completion routine.
     */
    status = HidpPolledReadComplete(DeviceObject, Irp, Context);

    /*
     *  Reset the timer of the collection which initiated this read,
     *  (which may be different than the collection that returned the report).
     */
    if (pdoExt->state == COLLECTION_STATE_RUNNING){
        PHIDCLASS_COLLECTION originatorCollection =
            GetHidclassCollection(fdoExt, pdoExt->collectionNum);

        if (originatorCollection){
            LARGE_INTEGER timeout;
            timeout.HighPart = -1;
            timeout.LowPart = -(LONG)(originatorCollection->PollInterval_msec*10000);
            KeSetTimer( &originatorCollection->polledDeviceTimer,
                        timeout,
                        &originatorCollection->polledDeviceTimerDPC);
        }
        else {
            TRAP;
        }
    }

    return status;
}



/*
 *  ReadPolledDevice
 *
 *      Issue a read to the polled device on behalf of the
 *  top-level collection indicated by pdoExt.
 *  (Note that because we keep separate polling loops for
 *   each collection, we do reads on behalf of specific collections).
 *
 */
BOOLEAN ReadPolledDevice(PDO_EXTENSION *pdoExt, BOOLEAN isTimerDrivenRead)
{
    BOOLEAN didPollDevice = FALSE;
    FDO_EXTENSION *fdoExt;
    PHIDP_COLLECTION_DESC hidCollectionDesc;

    fdoExt = &pdoExt->deviceFdoExt->fdoExt;

    hidCollectionDesc = GetCollectionDesc(fdoExt, pdoExt->collectionNum);
    if (hidCollectionDesc){

        PIRP irp = IoAllocateIrp(fdoExt->fdo->StackSize, FALSE);
        if (irp){
            /*
             *  We cannot issue a read on a specific collection.
             *  But we'll allocate a buffer just large enough for a report
             *  on the collection we want.
             *  Note that hidCollectionDesc->InputLength includes
             *  the report id byte, which we may have to prepend ourselves.
             */
            ULONG reportLen = hidCollectionDesc->InputLength;

            irp->UserBuffer = ALLOCATEPOOL(NonPagedPool, reportLen);
            if (irp->UserBuffer){
                PIO_COMPLETION_ROUTINE completionRoutine;
                PIO_STACK_LOCATION nextStack = IoGetNextIrpStackLocation(irp);
                ASSERT(nextStack);

                if (fdoExt->deviceDesc.ReportIDs[0].ReportID == 0) {
                    /*
                     *  This device has only one report type,
                     *  so the minidriver will not include the 1-byte report id
                     *  (which is implicitly zero).
                     *  However, we still need to return a 'cooked' report,
                     *  with the report id, to the user; so bump the buffer
                     *  we pass down to make room for the report id.
                     */
                    *(((PUCHAR)irp->UserBuffer)++) = (UCHAR)0;
                    reportLen--;
                }

                nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
                nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_HID_READ_REPORT;
                nextStack->Parameters.DeviceIoControl.OutputBufferLength = reportLen;
                irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

                completionRoutine = (isTimerDrivenRead) ?
                                    HidpPolledReadComplete_TimerDriven :
                                    HidpPolledReadComplete;

                IoSetCompletionRoutine( irp,
                                        completionRoutine,
                                        (PVOID)pdoExt,  // context
                                        TRUE,
                                        TRUE,
                                        TRUE );
                InterlockedDecrement(&fdoExt->outstandingRequests);
                HidpCallDriver(fdoExt->fdo, irp);
                didPollDevice = TRUE;
            }
        }
    }
    else {
        ASSERT(hidCollectionDesc);
    }

    return didPollDevice;
}


/*
 ********************************************************************************
 *  HidpPolledTimerDpc
 ********************************************************************************
 *
 *
 *
 */
VOID HidpPolledTimerDpc(    IN PKDPC Dpc,
                            IN PVOID DeferredContext,
                            IN PVOID SystemArgument1,
                            IN PVOID SystemArgument2
                        )
{
    PDO_EXTENSION *pdoExt = (PDO_EXTENSION *)DeferredContext;
    FDO_EXTENSION *fdoExt = &pdoExt->deviceFdoExt->fdoExt;

    ASSERT(pdoExt->deviceFdoExt->Signature == HID_DEVICE_EXTENSION_SIG);

    if (pdoExt->state == COLLECTION_STATE_RUNNING){
        PHIDCLASS_COLLECTION hidCollection;

        hidCollection = GetHidclassCollection(fdoExt, pdoExt->collectionNum);

        if (hidCollection){
            KIRQL oldIrql;
            BOOLEAN haveReadIrpsQueued;
            BOOLEAN didPollDevice = FALSE;

            /*
             *  If there are reads pending on this collection,
             *  issue a read to the device.
             *
             *  Note:  we have no control over which collection we are reading.
             *         This read may end up returning a report for a different
             *         collection!  That's ok, since a report for this collection
             *         will eventually be returned.
             */
            KeAcquireSpinLock(&hidCollection->polledDeviceReadQueueSpinLock, &oldIrql);
            haveReadIrpsQueued = !IsListEmpty(&hidCollection->polledDeviceReadQueue);
            KeReleaseSpinLock(&hidCollection->polledDeviceReadQueueSpinLock, oldIrql);

            if (haveReadIrpsQueued){
                didPollDevice = ReadPolledDevice(pdoExt, TRUE);
            }
            else {
                /*
                 *  The timer period has expired, so any saved reports
                 *  are now stale.
                 */
                hidCollection->polledDataIsStale = TRUE;
            }

            /*
             *  If we actually polled the device, we'll reset the timer in the
             *  completion routine; otherwise, we do it here.
             */
            if (!didPollDevice){
                LARGE_INTEGER timeout;
                timeout.HighPart = -1;
                timeout.LowPart = -(LONG)(hidCollection->PollInterval_msec*10000);
                KeSetTimer( &hidCollection->polledDeviceTimer,
                            timeout,
                            &hidCollection->polledDeviceTimerDPC);
            }
        }
        else {
            TRAP;
        }
    }

}


/*
 ********************************************************************************
 *  StartPollingLoop
 ********************************************************************************
 *
 *  Start a polling loop for a particular collection.
 *
 */
BOOLEAN StartPollingLoop(   FDO_EXTENSION *fdoExt,
                            PHIDCLASS_COLLECTION hidCollection,
                            BOOLEAN freshQueue)
{
    ULONG ctnIndex = hidCollection->CollectionIndex;
    LARGE_INTEGER timeout;
    KIRQL oldIrql;

    if (freshQueue){
        InitializeListHead(&hidCollection->polledDeviceReadQueue);
        KeInitializeSpinLock(&hidCollection->polledDeviceReadQueueSpinLock);
        KeInitializeTimer(&hidCollection->polledDeviceTimer);
    }

    /*
     *  Use polledDeviceReadQueueSpinLock to protect the timer structures as well
     *  as the queue.
     */
    KeAcquireSpinLock(&hidCollection->polledDeviceReadQueueSpinLock, &oldIrql);

    KeInitializeDpc(    &hidCollection->polledDeviceTimerDPC,
                        HidpPolledTimerDpc,
                        &fdoExt->collectionPdoExtensions[ctnIndex]->pdoExt);
             
    KeReleaseSpinLock(&hidCollection->polledDeviceReadQueueSpinLock, oldIrql);

    timeout.HighPart = -1;
    timeout.LowPart = -(LONG)(hidCollection->PollInterval_msec*10000);
    KeSetTimer( &hidCollection->polledDeviceTimer,
                timeout,
                &hidCollection->polledDeviceTimerDPC);

    return TRUE;
}


/*
 ********************************************************************************
 *  StopPollingLoop
 ********************************************************************************
 *
 *
 *
 */
VOID StopPollingLoop(PHIDCLASS_COLLECTION hidCollection, BOOLEAN flushQueue)
{
    KIRQL oldIrql;

    /*
     *  Use polledDeviceReadQueueSpinLock to protect the timer structures as well
     *  as the queue.
     */
    KeAcquireSpinLock(&hidCollection->polledDeviceReadQueueSpinLock, &oldIrql);

    KeCancelTimer(&hidCollection->polledDeviceTimer);
    KeInitializeTimer(&hidCollection->polledDeviceTimer);

    KeReleaseSpinLock(&hidCollection->polledDeviceReadQueueSpinLock, oldIrql);

    /*
     *  Fail all the queued IRPs.
     */
    if (flushQueue){
        PIRP irp;
        LIST_ENTRY irpsToComplete;

        /*
         *  Move the IRPs to a temporary queue first so they don't get requeued
         *  on the completion thread and cause us to loop forever.
         */
        InitializeListHead(&irpsToComplete);
        while (irp = DequeuePolledReadIrp(hidCollection)){
            InsertTailList(&irpsToComplete, &irp->Tail.Overlay.ListEntry);
        }

        while (!IsListEmpty(&irpsToComplete)){
            PLIST_ENTRY listEntry = RemoveHeadList(&irpsToComplete);
            irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);
            DBG_RECORD_READ(irp, 0, 0, TRUE)
            irp->IoStatus.Status = STATUS_DEVICE_NOT_CONNECTED;
            irp->IoStatus.Information = 0;
            IoCompleteRequest(irp, IO_NO_INCREMENT);
        }
    }

}


/*
 ********************************************************************************
 *  PolledReadCancelRoutine
 ********************************************************************************
 *
 *  We need to set an IRP's cancel routine to non-NULL before
 *  we queue it; so just use a pointer this NULL function.
 *
 */
VOID PolledReadCancelRoutine(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    PHIDCLASS_DEVICE_EXTENSION hidDeviceExtension = (PHIDCLASS_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    FDO_EXTENSION *fdoExt;
    PHIDCLASS_COLLECTION hidCollection;
    ULONG collectionIndex;
    KIRQL oldIrql;

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    ASSERT(hidDeviceExtension->Signature == HID_DEVICE_EXTENSION_SIG);
    ASSERT(hidDeviceExtension->isClientPdo);
    fdoExt = &hidDeviceExtension->pdoExt.deviceFdoExt->fdoExt;

    collectionIndex = hidDeviceExtension->pdoExt.collectionIndex;
    hidCollection = &fdoExt->classCollectionArray[collectionIndex];

    KeAcquireSpinLock(&hidCollection->polledDeviceReadQueueSpinLock, &oldIrql);

    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

    ASSERT(hidCollection->numPendingReads > 0);
    hidCollection->numPendingReads--;

    KeReleaseSpinLock(&hidCollection->polledDeviceReadQueueSpinLock, oldIrql);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    DBG_RECORD_READ(Irp, 0, 0, TRUE)
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}


NTSTATUS EnqueuePolledReadIrp(PHIDCLASS_COLLECTION collection, PIRP Irp)
{
    NTSTATUS status;
    KIRQL oldIrql;
    PDRIVER_CANCEL oldCancelRoutine;

    KeAcquireSpinLock(&collection->polledDeviceReadQueueSpinLock, &oldIrql);

    /*
     *  Must set a cancel routine before
     *  checking the Cancel flag.
     */
    oldCancelRoutine = IoSetCancelRoutine(Irp, PolledReadCancelRoutine);
    ASSERT(!oldCancelRoutine);

    /*
     *  Make sure this Irp wasn't just cancelled.
     *  Note that there is NO RACE CONDITION here
     *  because we are holding the fileExtension lock.
     */
    if (Irp->Cancel){
        /*
         *  This IRP was cancelled.
         */
        oldCancelRoutine = IoSetCancelRoutine(Irp, NULL);
        if (oldCancelRoutine){
            /*
             *  The cancel routine was NOT called.
             *  Return error so that caller completes the IRP.
             */
            DBG_RECORD_READ(Irp, IoGetCurrentIrpStackLocation(Irp)->Parameters.Read.Length, 0, TRUE)
            ASSERT(oldCancelRoutine == PolledReadCancelRoutine);
            status = STATUS_CANCELLED;
        }
        else {
            /*
             *  The cancel routine was called.
             *  As soon as we drop the spinlock it will dequeue
             *  and complete the IRP.
             *  Initialize the IRP's listEntry so that the dequeue
             *  doesn't cause corruption.
             *  Then don't touch the irp.
             */
            InitializeListHead(&Irp->Tail.Overlay.ListEntry);
            collection->numPendingReads++;  // because cancel routine will decrement

            IoMarkIrpPending(Irp);
            status = STATUS_PENDING;
        }
    }
    else {
        DBG_RECORD_READ(Irp, IoGetCurrentIrpStackLocation(Irp)->Parameters.Read.Length, 0, FALSE)

        /*
         *  There are no reports waiting.
         *  Queue this irp onto the file extension's list of pending irps.
         */
        InsertTailList(&collection->polledDeviceReadQueue, &Irp->Tail.Overlay.ListEntry);
        collection->numPendingReads++;

        IoMarkIrpPending(Irp);
        status = STATUS_PENDING;
    }

    KeReleaseSpinLock(&collection->polledDeviceReadQueueSpinLock, oldIrql);

    DBGSUCCESS(status, TRUE)
    return status;
}

PIRP DequeuePolledReadSystemIrp(PHIDCLASS_COLLECTION collection)
{
    KIRQL oldIrql;
    PIRP irp = NULL;
    PLIST_ENTRY listEntry;
    PHIDCLASS_FILE_EXTENSION    fileExtension;
    PFILE_OBJECT                fileObject;
    PIO_STACK_LOCATION irpSp;




    KeAcquireSpinLock(&collection->polledDeviceReadQueueSpinLock, &oldIrql);

    listEntry = &collection->polledDeviceReadQueue;

    while (!irp && ((listEntry = listEntry->Flink) != &collection->polledDeviceReadQueue)) {
        PDRIVER_CANCEL oldCancelRoutine;

        irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);

        irpSp = IoGetCurrentIrpStackLocation(irp);

        fileObject = irpSp->FileObject;
        fileExtension = (PHIDCLASS_FILE_EXTENSION)fileObject->FsContext;

        if (!fileExtension->isSecureOpen) {
            irp = NULL;
            continue;
        }


        RemoveEntryList(listEntry);
        oldCancelRoutine = IoSetCancelRoutine(irp, NULL);

        if (oldCancelRoutine){
            ASSERT(oldCancelRoutine == PolledReadCancelRoutine);
            ASSERT(collection->numPendingReads > 0);
            collection->numPendingReads--;
        }
        else {
            /*
             *  IRP was cancelled and cancel routine was called.
             *  As soon as we drop the spinlock,
             *  the cancel routine will dequeue and complete this IRP.
             *  Initialize the IRP's listEntry so that the dequeue doesn't cause corruption.
             *  Then, don't touch the IRP.
             */
            ASSERT(irp->Cancel);
            InitializeListHead(&irp->Tail.Overlay.ListEntry);
            irp = NULL;
        }
    }

    KeReleaseSpinLock(&collection->polledDeviceReadQueueSpinLock, oldIrql);

    return irp;
}

PIRP DequeuePolledReadIrp(PHIDCLASS_COLLECTION collection)
{
    KIRQL oldIrql;
    PIRP irp = NULL;

    KeAcquireSpinLock(&collection->polledDeviceReadQueueSpinLock, &oldIrql);

    while (!irp && !IsListEmpty(&collection->polledDeviceReadQueue)){
        PDRIVER_CANCEL oldCancelRoutine;
        PLIST_ENTRY listEntry = RemoveHeadList(&collection->polledDeviceReadQueue);

        irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);

        oldCancelRoutine = IoSetCancelRoutine(irp, NULL);

        if (oldCancelRoutine){
            ASSERT(oldCancelRoutine == PolledReadCancelRoutine);
            ASSERT(collection->numPendingReads > 0);
            collection->numPendingReads--;
        }
        else {
            /*
             *  IRP was cancelled and cancel routine was called.
             *  As soon as we drop the spinlock,
             *  the cancel routine will dequeue and complete this IRP.
             *  Initialize the IRP's listEntry so that the dequeue doesn't cause corruption.
             *  Then, don't touch the IRP.
             */
            ASSERT(irp->Cancel);
            InitializeListHead(&irp->Tail.Overlay.ListEntry);
            irp = NULL;
        }
    }

    KeReleaseSpinLock(&collection->polledDeviceReadQueueSpinLock, oldIrql);

    return irp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidclass\remotewake.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name: 

    wmi.c

Abstract

    Power handling

Author:

    jsenior

Environment:

    Kernel mode only

Revision History:


--*/


#include "pch.h"

#define WMI_WAIT_WAKE                0
#define WMI_SEL_SUSP                 0

//
// WMI System Call back functions
//
NTSTATUS
HidpIrpMajorSystemControl (
    IN  PHIDCLASS_DEVICE_EXTENSION  HidClassExtension,
    IN  PIRP                        Irp
    )
/*++
Routine Description

    We have just received a System Control IRP.

    Assume that this is a WMI IRP and
    call into the WMI system library and let it handle this IRP for us.

--*/
{
    NTSTATUS            status;
    SYSCTL_IRP_DISPOSITION disposition;

    if (HidClassExtension->isClientPdo) {

        status = WmiSystemControl(&HidClassExtension->pdoExt.WmiLibInfo,
                                  HidClassExtension->pdoExt.pdo,
                                  Irp,
                                  &disposition);

    } else {
        
        status = WmiSystemControl(&HidClassExtension->fdoExt.WmiLibInfo,
                                  HidClassExtension->fdoExt.fdo,
                                  Irp,
                                  &disposition);
                
    }

    switch(disposition) {
    case IrpProcessed:
        //
        // This irp has been processed and may be completed or pending.
        //
        break;

    case IrpNotCompleted:
        //
        // This irp has not been completed, but has been fully processed.
        // we will complete it now
        //
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        break;

    case IrpForward:
    case IrpNotWmi:
        //
        // This irp is either not a WMI irp or is a WMI irp targetted
        // at a device lower in the stack.
        //
        status = HidpIrpMajorDefault(HidClassExtension, Irp);
        break;

    default:
        //
        // We really should never get here, but if we do just forward....
        //
        ASSERT(FALSE);
        status = HidpIrpMajorDefault(HidClassExtension, Irp);
        break;
    }

    return status;
}


VOID
HidpRemoteWakeComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:
    Catch the Wait wake Irp on its way back.

Return Value:

--*/
{
    PDO_EXTENSION           *pdoExt = Context;
    POWER_STATE             powerState;
    NTSTATUS                status;
    PHIDCLASS_WORK_ITEM_DATA    itemData;

    ASSERT (MinorFunction == IRP_MN_WAIT_WAKE);
    //
    // PowerState.SystemState is undefined when the WW irp has been completed
    //
    // ASSERT (PowerState.SystemState == PowerSystemWorking);

    InterlockedExchangePointer(&pdoExt->remoteWakeIrp, NULL);

    switch (IoStatus->Status) {
    case STATUS_SUCCESS:
        DBGVERBOSE(("HidClass: Remote Wake irp was completed successfully.\n"));

        //
        //  We do not need to request a set power to power up the device, since
        //  hidclass does this for us.
        //
/*        powerState.DeviceState = PowerDeviceD0;
        status = PoRequestPowerIrp(
                    pdoExt->PDO,
                    IRP_MN_SET_POWER,
                    powerState,
                    NULL,
                    NULL,
                    NULL);*/

        //
        // We do not notify the system that a user is present because:
        // 1  Win9x doesn't do this and we must maintain compatibility with it
        // 2  The USB PIX4 motherboards sends a wait wake event every time the
        //    machine wakes up, no matter if this device woke the machine or not
        // 
        // If we incorrectly notify the system a user is present, the following
        // will occur:
        // 1  The monitor will be turned on
        // 2  We will prevent the machine from transitioning from standby 
        //    (to PowerSystemWorking) to hibernate
        //
        // If a user is truly present, we will receive input in the service
        // callback and we will notify the system at that time.
        //
        // PoSetSystemState (ES_USER_PRESENT);

        if (pdoExt->remoteWakeEnabled) {
            //
            // We cannot call CreateWaitWake from this completion routine,
            // as it is a paged function.
            //
            itemData = (PHIDCLASS_WORK_ITEM_DATA)
                    ExAllocatePool (NonPagedPool, sizeof (HIDCLASS_WORK_ITEM_DATA));

            if (NULL != itemData) {
                itemData->Item = IoAllocateWorkItem(pdoExt->pdo);
                if (itemData->Item == NULL) {
                    ExFreePool(itemData);
                    DBGWARN (("Failed alloc work item -> no WW Irp."));
                } else {
                    itemData->PdoExt = pdoExt;
                    itemData->Irp = NULL;
                    status = IoAcquireRemoveLock (&pdoExt->removeLock, itemData);
                    if (NT_SUCCESS(status)) {
                        IoQueueWorkItem (itemData->Item,
                                         HidpCreateRemoteWakeIrpWorker,
                                         DelayedWorkQueue,
                                         itemData);
                    }
                    else {
                        //
                        // The device has been removed
                        //
                        IoFreeWorkItem (itemData->Item);
                        ExFreePool (itemData);
                    }
                }
            } else {
                //
                // Well, we dropped the WaitWake.
                //
                DBGWARN (("Failed alloc pool -> no WW Irp."));

            }
        }

        // fall through to the break

    //
    // We get a remove.  We will not (obviously) send another wait wake
    //
    case STATUS_CANCELLED:

    //
    // This status code will be returned if the device is put into a power state
    // in which we cannot wake the machine (hibernate is a good example).  When
    // the device power state is returned to D0, we will attempt to rearm wait wake
    //
    case STATUS_POWER_STATE_INVALID:
    case STATUS_ACPI_POWER_REQUEST_FAILED:

    //
    // We failed the Irp because we already had one queued, or a lower driver in
    // the stack failed it.  Either way, don't do anything.
    //
    case STATUS_INVALID_DEVICE_STATE:

    //
    // Somehow someway we got two WWs down to the lower stack.
    // Let's just don't worry about it.
    //
    case STATUS_DEVICE_BUSY:
        break;

    default:
        //
        // Something went wrong, disable the wait wake.
        //
        KdPrint(("KBDCLASS:  wait wake irp failed with %x\n", IoStatus->Status));
        HidpToggleRemoteWake (pdoExt, FALSE);
    }

}

BOOLEAN
HidpCheckRemoteWakeEnabled(
    IN PDO_EXTENSION *PdoExt
    )
{
    KIRQL irql;
    BOOLEAN enabled;

    KeAcquireSpinLock (&PdoExt->remoteWakeSpinLock, &irql);
    enabled = PdoExt->remoteWakeEnabled;
    KeReleaseSpinLock (&PdoExt->remoteWakeSpinLock, irql);

    return enabled;
}

void
HidpCreateRemoteWakeIrpWorker (
    IN PDEVICE_OBJECT DeviceObject,
    IN PHIDCLASS_WORK_ITEM_DATA  ItemData
    )
{
    PAGED_CODE ();

    HidpCreateRemoteWakeIrp (ItemData->PdoExt);
    IoReleaseRemoveLock (&ItemData->PdoExt->removeLock, ItemData);
    IoFreeWorkItem(ItemData->Item);
    ExFreePool (ItemData);
}

BOOLEAN
HidpCreateRemoteWakeIrp (
    IN PDO_EXTENSION *PdoExt
    )
/*++

Routine Description:
    Catch the Wait wake Irp on its way back.

Return Value:

--*/
{
    POWER_STATE powerState;
    BOOLEAN     success = TRUE;
    NTSTATUS    status;
    PIRP        remoteWakeIrp;

    PAGED_CODE ();

    powerState.SystemState = PdoExt->deviceFdoExt->fdoExt.deviceCapabilities.SystemWake;
    status = PoRequestPowerIrp (PdoExt->pdo,
                                IRP_MN_WAIT_WAKE,
                                powerState,
                                HidpRemoteWakeComplete,
                                PdoExt,
                                &PdoExt->remoteWakeIrp);

    if (status != STATUS_PENDING) {
        success = FALSE;
    }

    return success;
}

VOID
HidpToggleRemoteWakeWorker(
    IN PDEVICE_OBJECT DeviceObject,
    PHIDCLASS_WORK_ITEM_DATA ItemData
    )
/*++

Routine Description:

--*/
{
    PDO_EXTENSION       *pdoExt;
    PIRP                remoteWakeIrp = NULL;
    KIRQL               irql;
    BOOLEAN             wwState = ItemData->RemoteWakeState ? TRUE : FALSE;
    BOOLEAN             toggled = FALSE;

    //
    // Can't be paged b/c we are using spin locks
    //
    // PAGED_CODE ();

    pdoExt = ItemData->PdoExt;

    KeAcquireSpinLock (&pdoExt->remoteWakeSpinLock, &irql);

    if (wwState != pdoExt->remoteWakeEnabled) {
        toggled = TRUE;
        if (pdoExt->remoteWakeEnabled) {
            remoteWakeIrp = (PIRP)
                InterlockedExchangePointer (&pdoExt->remoteWakeIrp, NULL);
        }
        
        pdoExt->remoteWakeEnabled = wwState;
    }

    KeReleaseSpinLock (&pdoExt->remoteWakeSpinLock, irql);

    if (toggled) {
        UNICODE_STRING strEnable;
        HANDLE         devInstRegKey;
        ULONG          tmp = wwState;

        //
        // write the value out to the registry
        //
        if ((NT_SUCCESS(IoOpenDeviceRegistryKey (pdoExt->pdo,
                                                 PLUGPLAY_REGKEY_DEVICE,
                                                 STANDARD_RIGHTS_ALL,
                                                 &devInstRegKey)))) {
            RtlInitUnicodeString (&strEnable, HIDCLASS_REMOTE_WAKE_ENABLE);

            ZwSetValueKey (devInstRegKey,
                           &strEnable,
                           0,
                           REG_DWORD,
                           &tmp,
                           sizeof(tmp));

            ZwClose (devInstRegKey);
        }
    }

    if (toggled && wwState) {
        //
        // wwState is our new state, so WW was just turned on
        //
        HidpCreateRemoteWakeIrp (pdoExt);
    }

    //
    // If we have an IRP, then WW has been toggled off, otherwise, if toggled is
    // TRUE, we need to save this in the reg and, perhaps, send down a new WW irp
    //
    if (remoteWakeIrp) {
        IoCancelIrp (remoteWakeIrp);
    }

    IoReleaseRemoveLock (&pdoExt->removeLock, HidpToggleRemoteWakeWorker);
    IoFreeWorkItem (ItemData->Item);
    ExFreePool (ItemData);
}

NTSTATUS
HidpToggleRemoteWake(
    PDO_EXTENSION       *PdoExt,
    BOOLEAN             RemoteWakeState
    )
{
    NTSTATUS       status;
    PHIDCLASS_WORK_ITEM_DATA itemData;

    status = IoAcquireRemoveLock (&PdoExt->removeLock, HidpToggleRemoteWakeWorker);
    if (!NT_SUCCESS (status)) {
        //
        // Device has gone away, just silently exit
        //
        return status;
    }

    itemData = (PHIDCLASS_WORK_ITEM_DATA)
        ALLOCATEPOOL(NonPagedPool, sizeof(HIDCLASS_WORK_ITEM_DATA));
    if (itemData) {
        itemData->Item = IoAllocateWorkItem(PdoExt->pdo);
        if (itemData->Item == NULL) {
            IoReleaseRemoveLock (&PdoExt->removeLock, HidpToggleRemoteWakeWorker);
        }
        else {
            itemData->PdoExt = PdoExt;
            itemData->RemoteWakeState = RemoteWakeState;

            if (KeGetCurrentIrql() == PASSIVE_LEVEL) {
                //
                // We are safely at PASSIVE_LEVEL, call callback directly to perform
                // this operation immediately.
                //
                HidpToggleRemoteWakeWorker (PdoExt->pdo, itemData);

            } else {
                //
                // We are not at PASSIVE_LEVEL, so queue a workitem to handle this
                // at a later time.
                //
                IoQueueWorkItem (itemData->Item,
                                 HidpToggleRemoteWakeWorker,
                                 DelayedWorkQueue,
                                 itemData);
            }
        }
    }
    else {
        IoReleaseRemoveLock (&PdoExt->removeLock, HidpToggleRemoteWakeWorker);
    }

    return STATUS_SUCCESS;
}


VOID
HidpToggleSelSuspWorker(
    IN PDEVICE_OBJECT DeviceObject,
    PIO_WORKITEM WorkItem
    )
/*++

Routine Description:

--*/
{
    FDO_EXTENSION       *fdoExt;
    UNICODE_STRING strEnable;
    HANDLE         devInstRegKey;
    ULONG          tmp;

    fdoExt = &((PHIDCLASS_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->fdoExt;

    //
    // write the value out to the registry
    //

    tmp = fdoExt->idleEnabled ? TRUE : FALSE;

    if ((NT_SUCCESS(IoOpenDeviceRegistryKey (fdoExt->collectionPdoExtensions[0]->hidExt.PhysicalDeviceObject,
                                             PLUGPLAY_REGKEY_DEVICE,
                                             STANDARD_RIGHTS_ALL,
                                             &devInstRegKey)))) {

        RtlInitUnicodeString (&strEnable, HIDCLASS_SELECTIVE_SUSPEND_ON);

        ZwSetValueKey (devInstRegKey,
                       &strEnable,
                       0,
                       REG_DWORD,
                       &tmp,
                       sizeof(tmp));

        ZwClose (devInstRegKey);
        
    }

    IoFreeWorkItem (WorkItem);

}

NTSTATUS
HidpToggleSelSusp(
    FDO_EXTENSION       *FdoExt,
    BOOLEAN             SelSuspEnable
    )
{
    PIO_WORKITEM   workItem;
    BOOLEAN        oldState;
    KIRQL          oldIrql;
    

    KeAcquireSpinLock(&FdoExt->idleSpinLock,
                      &oldIrql);
    oldState = FdoExt->idleEnabled;
    FdoExt->idleEnabled = SelSuspEnable;

    KeReleaseSpinLock(&FdoExt->idleSpinLock,
                      oldIrql);

    if (oldState != SelSuspEnable) {

        if (!SelSuspEnable) {
            HidpCancelIdleNotification(FdoExt,
                                       FALSE);
        } else {
            HidpStartIdleTimeout(FdoExt,
                                 FALSE);
        }
    
        workItem = IoAllocateWorkItem(FdoExt->fdo);

        if(workItem) {

            if (KeGetCurrentIrql() == PASSIVE_LEVEL) {

                //
                // We are safely at PASSIVE_LEVEL, call callback directly to perform
                // this operation immediately.
                //
                HidpToggleSelSuspWorker (FdoExt->fdo, workItem);
                
            } else {
                //
                // We are not at PASSIVE_LEVEL, so queue a workitem to handle this
                // at a later time.
                //
                IoQueueWorkItem (workItem,
                                 HidpToggleSelSuspWorker,
                                 DelayedWorkQueue,
                                 workItem);

            }
            
        }
        
    }

    return STATUS_SUCCESS;
}


NTSTATUS
HidpSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    PHIDCLASS_DEVICE_EXTENSION classExt;
    NTSTATUS            status;
    ULONG               size = 0;

    PAGED_CODE ();

    classExt = (PHIDCLASS_DEVICE_EXTENSION) DeviceObject->DeviceExtension;
    
    if (classExt->isClientPdo) {
    
        switch(GuidIndex) {
        case WMI_WAIT_WAKE:

            size = sizeof(BOOLEAN);

            if (BufferSize < size) {
                status = STATUS_BUFFER_TOO_SMALL;
                break;
            } else if ((1 != DataItemId) || (0 != InstanceIndex)) {
                status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }

            status = HidpToggleRemoteWake (&classExt->pdoExt, *(PBOOLEAN) Buffer);
            break;

        default:
            status = STATUS_WMI_GUID_NOT_FOUND;
            
        }

    } else {
        
        switch(GuidIndex) {
        case WMI_SEL_SUSP:

            size = sizeof(BOOLEAN);

            if (BufferSize < size) {
                status = STATUS_BUFFER_TOO_SMALL;
                break;
            } else if ((1 != DataItemId) || (0 != InstanceIndex)) {
                status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }

            status = HidpToggleSelSusp (&classExt->fdoExt, *(PBOOLEAN) Buffer);
            break;

        default:
            status = STATUS_WMI_GUID_NOT_FOUND;
            
        }

    }

    status = WmiCompleteRequest (DeviceObject,
                                 Irp,
                                 status,
                                 size,
                                 IO_NO_INCREMENT);

    return status;
}

NTSTATUS
HidpSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    PHIDCLASS_DEVICE_EXTENSION classExt;
    NTSTATUS          status;
    ULONG             size = 0;

    PAGED_CODE ();

    classExt = (PHIDCLASS_DEVICE_EXTENSION) DeviceObject->DeviceExtension;

    if (classExt->isClientPdo) {
    
        switch(GuidIndex) {
        case WMI_WAIT_WAKE:

            size = sizeof(BOOLEAN);

            if (BufferSize < size) {
                status = STATUS_BUFFER_TOO_SMALL;
                break;
            } else if (0 != InstanceIndex) {
                status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }

            status = HidpToggleRemoteWake (&classExt->pdoExt, *(PBOOLEAN) Buffer);
            break;

        default:
            status = STATUS_WMI_GUID_NOT_FOUND;
            
        }

    } else {

        switch(GuidIndex) {
        case WMI_SEL_SUSP:

            size = sizeof(BOOLEAN);

            if (BufferSize < size) {
                status = STATUS_BUFFER_TOO_SMALL;
                break;
            } else if (0 != InstanceIndex) {
                status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }

            status = HidpToggleSelSusp (&classExt->fdoExt, *(PBOOLEAN) Buffer);
            break;

        default:
            status = STATUS_WMI_GUID_NOT_FOUND;
            
        }

    }

    status = WmiCompleteRequest (DeviceObject,
                                 Irp,
                                 status,
                                 size,
                                 IO_NO_INCREMENT);

    return status;
}

NTSTATUS
HidpQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG OutBufferSize,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    InstanceCount is the number of instnaces expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    PHIDCLASS_DEVICE_EXTENSION classExt;
    NTSTATUS          status;
    ULONG             size = 0;

    PAGED_CODE ();

    classExt = (PHIDCLASS_DEVICE_EXTENSION) DeviceObject->DeviceExtension;

    if (classExt->isClientPdo) {
    
        switch(GuidIndex) {
        case WMI_WAIT_WAKE:

            //
            // Only registers 1 instance for this guid
            //
            if ((0 != InstanceIndex) || (1 != InstanceCount)) {
                status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            size = sizeof(BOOLEAN);

            if (OutBufferSize < size) {
                status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            *(PBOOLEAN) Buffer = classExt->pdoExt.remoteWakeEnabled;
            *InstanceLengthArray = size;
            status = STATUS_SUCCESS;
            break;

        default:
            status = STATUS_WMI_GUID_NOT_FOUND;
            
        }

    } else {

        switch(GuidIndex) {
        case WMI_SEL_SUSP:

            //
            // Only registers 1 instance for this guid
            //
            if ((0 != InstanceIndex) || (1 != InstanceCount)) {
                status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            size = sizeof(BOOLEAN);

            if (OutBufferSize < size) {
                status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            *(PBOOLEAN) Buffer = classExt->fdoExt.idleEnabled;
            *InstanceLengthArray = size;
            status = STATUS_SUCCESS;
            break;

        default:
            status = STATUS_WMI_GUID_NOT_FOUND;
            
        }

    }

    status = WmiCompleteRequest (DeviceObject,
                                 Irp,
                                 status,
                                 size,
                                 IO_NO_INCREMENT);

    return status;

}

NTSTATUS
HidpQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered.

    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is
        required

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in
        *RegFlags.

Return Value:

    status

--*/
{

    PHIDCLASS_DEVICE_EXTENSION classExt;
    PHIDCLASS_DRIVER_EXTENSION hidDriverExtension;
    
    PAGED_CODE ();

    classExt = (PHIDCLASS_DEVICE_EXTENSION) DeviceObject->DeviceExtension;

    if (classExt->isClientPdo) {
    
        hidDriverExtension = (PHIDCLASS_DRIVER_EXTENSION) RefDriverExt(classExt->pdoExt.pdo->DriverObject);
        ASSERT(hidDriverExtension);

        *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
        *RegistryPath = &hidDriverExtension->RegistryPath;
        *Pdo = classExt->pdoExt.pdo;

        DerefDriverExt(classExt->pdoExt.pdo->DriverObject);
 
    } else {
  
        hidDriverExtension = classExt->fdoExt.driverExt;
        ASSERT(hidDriverExtension);

        *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
        *RegistryPath = &hidDriverExtension->RegistryPath;
        *Pdo = classExt->hidExt.PhysicalDeviceObject;    
        
    }
        
    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidclass\power.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    power.c

Abstract

    Power handling

Author:

    ervinp

Environment:

    Kernel mode only

Revision History:


--*/


#include "pch.h"


BOOLEAN HidpIsWaitWakePending(FDO_EXTENSION *fdoExt, BOOLEAN setIfNotPending)
{
    KIRQL irql;
    BOOLEAN isWaitWakePending;

    KeAcquireSpinLock(&fdoExt->waitWakeSpinLock, &irql);
    isWaitWakePending = fdoExt->isWaitWakePending;
    if (fdoExt->isWaitWakePending == FALSE) {
        if (setIfNotPending) {
            fdoExt->isWaitWakePending = TRUE;
        }
    }
    KeReleaseSpinLock(&fdoExt->waitWakeSpinLock, irql);

    return isWaitWakePending;
}

VOID
HidpPowerDownFdo(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension)
        {
    POWER_STATE powerState;
    FDO_EXTENSION *fdoExt;

    DBGVERBOSE(("powering down fdo 0x%x\n", HidDeviceExtension));

    fdoExt = &HidDeviceExtension->fdoExt;

    powerState.DeviceState = fdoExt->deviceCapabilities.DeviceWake;

    PoRequestPowerIrp(HidDeviceExtension->hidExt.PhysicalDeviceObject,
                      IRP_MN_SET_POWER,
                      powerState,
                      NULL,    // completion routine
                      NULL,    // completion routine context
                      NULL);
}

VOID HidpPowerUpPdos(IN PFDO_EXTENSION fdoExt)
{
    PDEVICE_OBJECT pdo;
    PDO_EXTENSION *pdoExt;
    POWER_STATE powerState;
    ULONG iPdo;

    iPdo = 0;

    powerState.DeviceState = PowerDeviceD0;

    for (iPdo = 0; iPdo < fdoExt->deviceRelations->Count; iPdo++) {
        pdoExt = &fdoExt->collectionPdoExtensions[iPdo]->pdoExt;
        pdo = pdoExt->pdo;

        DBGVERBOSE(("power up pdos, requesting D0 on pdo #%d %x\n", iPdo, pdo));

        //
        // We could check // pdoExt->devicePowerState != PowerDeviceD0
        // but, if the stack gets 2 D0 irps in a row, nothing bad should happen
        //
        PoRequestPowerIrp(pdo,
                          IRP_MN_SET_POWER,
                          powerState,
                          NULL,        // completion routine
                          NULL,        // context
                          NULL);
    }
    HidpSetDeviceBusy(fdoExt);
    KeSetEvent(&fdoExt->idleDoneEvent, 0, FALSE);
}

VOID
HidpPdoIdleOutComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    FDO_EXTENSION *fdoExt = &HidDeviceExtension->fdoExt;
    LONG prevIdleState;
    BOOLEAN idleCancelling = FALSE;
    KIRQL irql;

    DBGSUCCESS(IoStatus->Status, TRUE)

    if (InterlockedDecrement(&fdoExt->numIdlePdos) == 0) {
        HidpPowerDownFdo(HidDeviceExtension);

        KeAcquireSpinLock(&fdoExt->idleNotificationSpinLock, &irql);

        prevIdleState = InterlockedCompareExchange(&fdoExt->idleState,
                                                   IdleComplete,
                                                   IdleCallbackReceived);
        if (fdoExt->idleCancelling) {
            DBGINFO(("Cancelling idle in pdoidleoutcomplete on 0x%x\n", HidDeviceExtension));
            idleCancelling = TRUE;
        }

        DBGASSERT (prevIdleState == IdleCallbackReceived,
                   ("Race condition in HidpPdoIdleOutComplete. Prev state = %x",
                    prevIdleState),
                   TRUE);

        KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql);

        KeResetEvent(&fdoExt->idleDoneEvent);
        if (idleCancelling) {
            POWER_STATE powerState;
            powerState.DeviceState = PowerDeviceD0;
            DBGINFO(("Cancelling idle. Send power irp from pdo idle complete."))
            PoRequestPowerIrp(((PHIDCLASS_DEVICE_EXTENSION) fdoExt->fdo->DeviceExtension)->hidExt.PhysicalDeviceObject,
                              IRP_MN_SET_POWER,
                              powerState,
                              HidpDelayedPowerPoRequestComplete,
                              fdoExt,
                              NULL);
        }
    }
}

VOID HidpIdleNotificationCallback(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension)
{
    PDEVICE_OBJECT pdo;
    FDO_EXTENSION *fdoExt;
    POWER_STATE powerState;
    ULONG iPdo;
    BOOLEAN ok = TRUE;
    KIRQL irql;
    LONG idleState, prevIdleState;

    iPdo = 0;
    fdoExt = &HidDeviceExtension->fdoExt;

    DBGINFO(("------ IDLE NOTIFICATION on fdo 0x%x\n", fdoExt->fdo));

    KeAcquireSpinLock(&fdoExt->idleNotificationSpinLock, &irql);

    if (fdoExt->idleCancelling) {
        DBGINFO(("We are cancelling idle on fdo 0x%x", fdoExt->fdo));
        fdoExt->idleState = IdleWaiting;
        if (ISPTR(fdoExt->idleTimeoutValue)) {
            InterlockedExchange(fdoExt->idleTimeoutValue, 0);
        }
        fdoExt->idleCancelling = FALSE;
        KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql);

        IoCancelIrp(fdoExt->idleNotificationRequest);
        return;
    }
    prevIdleState = InterlockedCompareExchange(&fdoExt->idleState,
                                           IdleCallbackReceived,
                                           IdleIrpSent);
    DBGASSERT(prevIdleState == IdleIrpSent,
              ("Idle callback in wrong state %x for fdo %x. Exitting.",
               prevIdleState, fdoExt->fdo),
              FALSE);

    KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql);

    if (prevIdleState != IdleIrpSent) {
        return;
    }

    if (HidpIsWaitWakePending(fdoExt, TRUE) == FALSE) {
        SubmitWaitWakeIrp((HIDCLASS_DEVICE_EXTENSION *) fdoExt->fdo->DeviceExtension);
    }

    powerState.DeviceState = fdoExt->deviceCapabilities.DeviceWake;

    fdoExt->numIdlePdos = fdoExt->deviceRelations->Count+1;

    for (iPdo = 0; iPdo < fdoExt->deviceRelations->Count; iPdo++) {
        pdo = fdoExt->collectionPdoExtensions[iPdo]->pdoExt.pdo;

        DBGVERBOSE(("power down pdos, requesting D%d on pdo #%d %x\n",
                 powerState.DeviceState-1, iPdo, pdo));

        //
        // We could check // pdoExt->devicePowerState != PowerDeviceD0
        // but, if the stack gets 2 D0 irps in a row, nothing bad should happen
        //
        PoRequestPowerIrp(pdo,
                          IRP_MN_SET_POWER,
                          powerState,
                          HidpPdoIdleOutComplete,
                          HidDeviceExtension,
                          NULL);
    }

    if (InterlockedDecrement(&fdoExt->numIdlePdos) == 0) {
        BOOLEAN idleCancelling = FALSE;
        HidpPowerDownFdo(HidDeviceExtension);
        KeAcquireSpinLock(&fdoExt->idleNotificationSpinLock, &irql);

        prevIdleState = InterlockedCompareExchange(&fdoExt->idleState,
                                                   IdleComplete,
                                                   IdleCallbackReceived);
        idleCancelling = fdoExt->idleCancelling;

        DBGASSERT (prevIdleState == IdleCallbackReceived,
                   ("Race condition in HidpPdoIdleOutComplete. Prev state = %x",
                    prevIdleState),
                   FALSE);

        KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql);

        KeResetEvent(&fdoExt->idleDoneEvent);
        if (idleCancelling) {
            POWER_STATE powerState;
            powerState.DeviceState = PowerDeviceD0;
            DBGINFO(("Cancelling idle. Send power irp from idle callback."))
            PoRequestPowerIrp(((PHIDCLASS_DEVICE_EXTENSION) fdoExt->fdo->DeviceExtension)->hidExt.PhysicalDeviceObject,
                              IRP_MN_SET_POWER,
                              powerState,
                              HidpDelayedPowerPoRequestComplete,
                              fdoExt,
                              NULL);
        }
    }
}

/*
 ********************************************************************************
 *  EnqueueCollectionWaitWakeIrp
 ********************************************************************************
 *
 */
NTSTATUS
EnqueueCollectionWaitWakeIrp(
    IN FDO_EXTENSION *FdoExt,
    IN PDO_EXTENSION *PdoExt,
    IN PIRP WaitWakeIrp)
{
    PDRIVER_CANCEL oldCancelRoutine;
    KIRQL oldIrql;
    NTSTATUS status;
    PHIDCLASS_DEVICE_EXTENSION devExt = (PHIDCLASS_DEVICE_EXTENSION)FdoExt->fdo->DeviceExtension;

    KeAcquireSpinLock(&FdoExt->collectionWaitWakeIrpQueueSpinLock, &oldIrql);

    if (InterlockedCompareExchangePointer(&PdoExt->waitWakeIrp,
                                          WaitWakeIrp,
                                          NULL) != NULL) {
        //
        // More than one WW irp?  Unthinkable!
        //
        DBGWARN(("Another WW irp was already queued on pdoExt %x", PdoExt))
        status = STATUS_DEVICE_BUSY;
    } else {
        /*
         *  Must set a cancel routine before checking the Cancel flag
         *  (this makes the cancel code path for the IRP have to contend
         *  for our local spinlock).
         */
        oldCancelRoutine = IoSetCancelRoutine(WaitWakeIrp, CollectionWaitWakeIrpCancelRoutine);
        ASSERT(!oldCancelRoutine);

        if (WaitWakeIrp->Cancel){
            /*
             *  This IRP has already been cancelled.
             */
            oldCancelRoutine = IoSetCancelRoutine(WaitWakeIrp, NULL);
            if (oldCancelRoutine){
                /*
                 *  Cancel routine was NOT called, so complete the IRP here
                 *  (caller will do this when we return error).
                 */
                ASSERT(oldCancelRoutine == CollectionWaitWakeIrpCancelRoutine);
                status = STATUS_CANCELLED;
            }
            else {
                /*
                 *  Cancel routine was called, and it will dequeue and complete the IRP
                 *  as soon as we drop the spinlock.
                 *  Initialize the IRP's listEntry so the dequeue doesn't corrupt the list.
                 *  Then return STATUS_PENDING so we don't touch the IRP
                 */
                InitializeListHead(&WaitWakeIrp->Tail.Overlay.ListEntry);

                IoMarkIrpPending(WaitWakeIrp);
                status = STATUS_PENDING;
            }
        }
        else {
            /*
             *  IoMarkIrpPending sets a bit in the current stack location
             *  to indicate that the Irp may complete on a different thread.
             */
            InsertTailList(&FdoExt->collectionWaitWakeIrpQueue, &WaitWakeIrp->Tail.Overlay.ListEntry);

            IoMarkIrpPending(WaitWakeIrp);
            status = STATUS_PENDING;
        }
    }

    if (status != STATUS_PENDING) {
        //
        // The irp was cancelled. Remove it from the extension.
        //
        InterlockedExchangePointer(&PdoExt->waitWakeIrp, NULL);
    }

    KeReleaseSpinLock(&FdoExt->collectionWaitWakeIrpQueueSpinLock, oldIrql);

    if (status == STATUS_PENDING){
        if (!HidpIsWaitWakePending(FdoExt, TRUE)){
            DBGVERBOSE(("WW 5 %x\n", devExt))
            SubmitWaitWakeIrp(devExt);
        }

    }

    return status;
}

NTSTATUS
HidpPdoPower(
    IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status = NO_STATUS;
    PIO_STACK_LOCATION irpSp;
    FDO_EXTENSION *fdoExt;
    PDO_EXTENSION *pdoExt;
    KIRQL oldIrql;
    UCHAR minorFunction;
    LIST_ENTRY dequeue, *entry;
    PIO_STACK_LOCATION stack;
    PIRP irp;
    ULONG count;
    POWER_STATE powerState;
    SYSTEM_POWER_STATE systemState;
    BOOLEAN justReturnPending = FALSE;
    BOOLEAN runPowerCode;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    /*
     *  Keep these privately so we still have it after the IRP completes
     *  or after the device extension is freed on a REMOVE_DEVICE
     */
    minorFunction = irpSp->MinorFunction;

    pdoExt = &HidDeviceExtension->pdoExt;
    fdoExt = &HidDeviceExtension->pdoExt.deviceFdoExt->fdoExt;

    runPowerCode =
        (pdoExt->state == COLLECTION_STATE_RUNNING) ||
        (pdoExt->state == COLLECTION_STATE_STOPPED) ||
        (pdoExt->state == COLLECTION_STATE_STOPPING);

    if (runPowerCode) {
        switch (minorFunction){

        case IRP_MN_SET_POWER:
            PoSetPowerState(pdoExt->pdo,
                            irpSp->Parameters.Power.Type,
                            irpSp->Parameters.Power.State);

            switch (irpSp->Parameters.Power.Type) {

            case SystemPowerState:
                systemState = irpSp->Parameters.Power.State.SystemState;

                pdoExt->systemPowerState = systemState;

                if (systemState == PowerSystemWorking){
                    powerState.DeviceState = PowerDeviceD0;
                }
                else {
                    powerState.DeviceState = PowerDeviceD3;
                }

                DBGVERBOSE(("S irp, requesting D%d on pdo %x\n",
                         powerState.DeviceState-1, pdoExt->pdo));

                IoMarkIrpPending(Irp);
                PoRequestPowerIrp(pdoExt->pdo,
                                  IRP_MN_SET_POWER,
                                  powerState,
                                  CollectionPowerRequestCompletion,
                                  Irp,    // context
                                  NULL);

                /*
                 *  We want to complete the system-state power Irp
                 *  with the result of the device-state power Irp.
                 *  We'll complete the system-state power Irp when
                 *  the device-state power Irp completes.
                 *
                 *  Note: this may have ALREADY happened, so don't
                 *        touch the original Irp anymore.
                 */
                status = STATUS_PENDING;
                justReturnPending = TRUE;

                break;

            case DevicePowerState:
                switch (irpSp->Parameters.Power.State.DeviceState) {

                case PowerDeviceD0:
                    /*
                     *  Resume from APM Suspend
                     *
                     *  Do nothing here; Send down the read IRPs in the
                     *  completion routine for this (the power) IRP.
                     */
                    DBGVERBOSE(("pdo %x on fdo %x going to D0\n", pdoExt->pdo,
                             fdoExt->fdo));

                    pdoExt->devicePowerState =
                        irpSp->Parameters.Power.State.DeviceState;
                    status = STATUS_SUCCESS;

                    //
                    // Resend all power delayed IRPs
                    //
                    count = DequeueAllPdoPowerDelayedIrps(pdoExt, &dequeue);
                    DBGVERBOSE(("dequeued %d requests\n", count));

                    while (!IsListEmpty(&dequeue)) {
                        entry = RemoveHeadList(&dequeue);
                        irp = CONTAINING_RECORD(entry, IRP, Tail.Overlay.ListEntry);
                        stack = IoGetCurrentIrpStackLocation(irp);

                        DBGINFO(("resending %x to pdo %x in set D0 for pdo.\n", irp, pdoExt->pdo));

                        pdoExt->pdo->DriverObject->
                            MajorFunction[stack->MajorFunction]
                                (pdoExt->pdo, irp);
                    }
                    break;

                case PowerDeviceD1:
                case PowerDeviceD2:
                case PowerDeviceD3:
                    /*
                     *  Suspend
                     */

                    DBGVERBOSE(("pdo %x on fdo %x going to D%d\n", pdoExt->pdo,
                             fdoExt->fdo,
                             irpSp->Parameters.Power.State.DeviceState-1));

                    pdoExt->devicePowerState =
                        irpSp->Parameters.Power.State.DeviceState;
                    status = STATUS_SUCCESS;

                    //
                    // Only manually power down the PDO if the
                    // machine is not going into low power,
                    // the PDO is going into a D state we can
                    // wake out of, and we have idle time out
                    // enabled.
                    //
                    if (pdoExt->systemPowerState == PowerSystemWorking &&
                        pdoExt->devicePowerState <= fdoExt->deviceCapabilities.DeviceWake &&
                        fdoExt->idleState != IdleDisabled) {
                        DBGVERBOSE(("maybe powering down fdo\n"));

                        HidpPowerDownFdo(HidDeviceExtension->pdoExt.deviceFdoExt);
                    }

                    break;

                default:
                    /*
                     *  Do not return STATUS_NOT_SUPPORTED;
                     *  keep the default status
                     *  (this allows filter drivers to work).
                     */
                    status = Irp->IoStatus.Status;
                    break;
                }
                break;

            default:
                /*
                 *  Do not return STATUS_NOT_SUPPORTED;
                 *  keep the default status
                 *  (this allows filter drivers to work).
                 */
                status = Irp->IoStatus.Status;
                break;
            }
            break;

        case IRP_MN_WAIT_WAKE:
            /*
             *  WaitWake IRPs to the collection-PDO's
             *  just get queued in the base device's extension;
             *  when the base device's WaitWake IRP gets
             *  completed, we'll also complete these collection
             *  WaitWake IRPs.
             */

            if (fdoExt->systemPowerState > fdoExt->deviceCapabilities.SystemWake) {
                status = STATUS_POWER_STATE_INVALID;
            } else {
                status = EnqueueCollectionWaitWakeIrp(fdoExt, pdoExt, Irp);
                if (status == STATUS_PENDING){
                    justReturnPending = TRUE;
                }
            }

            break;

        case IRP_MN_POWER_SEQUENCE:
            TRAP;  // client-PDO should never get this
            status = Irp->IoStatus.Status;
            break;

        case IRP_MN_QUERY_POWER:
            /*
             *  We allow all power transitions.
             *  But make sure that there's no WW down that shouldn't be.
             */
            DBGVERBOSE(("Query power"));
            status = HidpCheckIdleState(HidDeviceExtension, Irp);
            if (status != STATUS_SUCCESS) {
                justReturnPending = TRUE;
            }
            break;

        default:
            /*
             *  'fail' the Irp by returning the default status.
             *  Do not return STATUS_NOT_SUPPORTED;
             *  keep the default status
             *  (this allows filter drivers to work).
             */
            status = Irp->IoStatus.Status;
            break;
        }
    } else {
        switch (minorFunction){
        case IRP_MN_SET_POWER:
        case IRP_MN_QUERY_POWER:
            status = STATUS_SUCCESS;
            break;
        default:
            status = Irp->IoStatus.Status;
            break;
        }
    }

    if (!justReturnPending) {
        /*
         *  Whether we are completing or relaying this power IRP,
         *  we must call PoStartNextPowerIrp on Windows NT.
         */
        PoStartNextPowerIrp(Irp);

        ASSERT(status != NO_STATUS);
        Irp->IoStatus.Status = status;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    DBGSUCCESS(status, FALSE)
    return status;
}

NTSTATUS
HidpFdoPower(
    IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status = NO_STATUS;
    PIO_STACK_LOCATION irpSp;
    FDO_EXTENSION *fdoExt;
    KIRQL oldIrql;
    BOOLEAN completeIrpHere = FALSE;
    BOOLEAN returnPending = FALSE;
    UCHAR minorFunction;
    SYSTEM_POWER_STATE systemState;
    BOOLEAN runPowerCode;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    /*
     *  Keep these privately so we still have it after the IRP completes
     *  or after the device extension is freed on a REMOVE_DEVICE
     */
    minorFunction = irpSp->MinorFunction;

    fdoExt = &HidDeviceExtension->fdoExt;

    runPowerCode =
        (fdoExt->state == DEVICE_STATE_START_SUCCESS) ||
        (fdoExt->state == DEVICE_STATE_STOPPING) ||
        (fdoExt->state == DEVICE_STATE_STOPPED);

    if (runPowerCode) {
        switch (minorFunction){

        case IRP_MN_SET_POWER:
            PoSetPowerState(fdoExt->fdo,
                            irpSp->Parameters.Power.Type,
                            irpSp->Parameters.Power.State);

            switch (irpSp->Parameters.Power.Type) {

            case SystemPowerState:

                systemState = irpSp->Parameters.Power.State.SystemState;

                if (systemState < PowerSystemMaximum) {
                    /*
                     *  For the 'regular' system power states,
                     *  we convert to a device power state
                     *  and request a callback with the device power state.
                     */
                    PDEVICE_OBJECT pdo = HidDeviceExtension->hidExt.PhysicalDeviceObject;
                    POWER_STATE powerState;
                    KIRQL oldIrql;
                    BOOLEAN isWaitWakePending;

                    if (systemState != PowerSystemWorking) {
                        //
                        // We don't want to be idling during regular system
                        // power stuff.
                        //
                        HidpCancelIdleNotification(fdoExt, FALSE);
                    }

                    fdoExt->systemPowerState = systemState;
                    isWaitWakePending = HidpIsWaitWakePending(fdoExt, FALSE);

                    if (isWaitWakePending &&
                        systemState > fdoExt->deviceCapabilities.SystemWake){
                        /*
                         *  We're transitioning to a system state from which
                         *  this device cannot perform a wake-up.
                         *  So fail all the WaitWake IRPs.
                         */
                        CompleteAllCollectionWaitWakeIrps(fdoExt, STATUS_POWER_STATE_INVALID);
                    }
                    returnPending = TRUE;
                }
                else {
                    TRAP;
                    /*
                     *  For the remaining system power states,
                     *  just pass down the IRP.
                     */
                    runPowerCode = FALSE;
                    Irp->IoStatus.Status = STATUS_SUCCESS;
                }

                break;

            case DevicePowerState:
                switch (irpSp->Parameters.Power.State.DeviceState) {

                case PowerDeviceD0:
                    /*
                     *  Resume from APM Suspend
                     *
                     *  Do nothing here; Send down the read IRPs in the
                     *  completion routine for this (the power) IRP.
                     */
                    DBGVERBOSE(("fdo powering up to D0\n"));
                    break;

                case PowerDeviceD1:
                case PowerDeviceD2:
                case PowerDeviceD3:
                    /*
                     *  Suspend
                     */

                    DBGVERBOSE(("fdo going down to D%d\n", fdoExt->devicePowerState-1));

                    if (fdoExt->state == DEVICE_STATE_START_SUCCESS &&
                        fdoExt->devicePowerState == PowerDeviceD0){
                        CancelAllPingPongIrps(fdoExt);
                    }
                    fdoExt->devicePowerState =
                        irpSp->Parameters.Power.State.DeviceState;

                    break;
                }
                break;
            }
            break;

        case IRP_MN_WAIT_WAKE:
            KeAcquireSpinLock(&fdoExt->waitWakeSpinLock, &oldIrql);
            if (fdoExt->waitWakeIrp == BAD_POINTER) {
                DBGVERBOSE(("new wait wake irp 0x%x\n", Irp));
                fdoExt->waitWakeIrp = Irp;
            } else {
                DBGVERBOSE(("1+ wait wake irps 0x%x\n", Irp));
                completeIrpHere = TRUE;
                status = STATUS_DEVICE_BUSY;
            }
            KeReleaseSpinLock(&fdoExt->waitWakeSpinLock, oldIrql);

            break;
        }
    } else {
        switch (minorFunction){
        case IRP_MN_SET_POWER:
        case IRP_MN_QUERY_POWER:
            Irp->IoStatus.Status = STATUS_SUCCESS;
            break;
        default:
            // nothing
            break;
        }
    }

    /*
     *  Whether we are completing or relaying this power IRP,
     *  we must call PoStartNextPowerIrp on Windows NT.
     */
    PoStartNextPowerIrp(Irp);

    /*
     *  If this is a call for a collection-PDO, we complete it ourselves here.
     *  Otherwise, we pass it to the minidriver stack for more processing.
     */
    if (completeIrpHere){

        /*
         *  Note:  Don't touch the Irp after completing it.
         */
        ASSERT(status != NO_STATUS);
        Irp->IoStatus.Status = status;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    else {
        /*
         *  Call the minidriver with this Irp.
         *  The rest of our processing will be done in our completion routine.
         *
         *  Note:  Don't touch the Irp after sending it down, since it may
         *         be completed immediately.
         */

        if (runPowerCode) {
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine(Irp, HidpFdoPowerCompletion, (PVOID)HidDeviceExtension, TRUE, TRUE, TRUE);
        } else {
            IoSkipCurrentIrpStackLocation(Irp);
        }

        /*
         *
         *  Want to use PoCallDriver here, but PoCallDriver
         *  uses IoCallDriver,
         *  which uses the driverObject->MajorFunction[] array
         *  instead of the hidDriverExtension->MajorFunction[] functions.
         *  SHOULD FIX THIS FOR NT -- should use PoCallDriver
         *
         */
        // status = PoCallDriver(HidDeviceExtension->hidExt.NextDeviceObject, Irp);
        // status = PoCallDriver(fdoExt->fdo, Irp);
        if (returnPending) {
            DBGASSERT(runPowerCode, ("We are returning pending, but not running completion routine.\n"), TRUE)
            IoMarkIrpPending(Irp);
            HidpCallDriver(fdoExt->fdo, Irp);
            status = STATUS_PENDING;
        } else {
            status = HidpCallDriver(fdoExt->fdo, Irp);
        }
    }

    DBGSUCCESS(status, FALSE)
    return status;
}

/*
 ********************************************************************************
 *  HidpIrpMajorPower
 ********************************************************************************
 *
 *
 *  Note:  This function cannot be pageable because (on Win98 anyway)
 *         NTKERN calls it back on the thread of the completion routine
 *         that returns the "Cntrl-Alt-Del" keystrokes.
 *         Also, we may or may not have set the DO_POWER_PAGABLE;
 *         so power IRPs may or may not come in at DISPATCH_LEVEL.
 *         So we must keep this code locked.
 */
NTSTATUS HidpIrpMajorPower(
    IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION irpSp;
    BOOLEAN isClientPdo;
    NTSTATUS status;
    UCHAR minorFunction;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    minorFunction = irpSp->MinorFunction;

    isClientPdo = HidDeviceExtension->isClientPdo;

    if (minorFunction != IRP_MN_SET_POWER){
        DBG_LOG_POWER_IRP(HidDeviceExtension, minorFunction, isClientPdo, FALSE, "", -1, -1)
    } else {
        switch (irpSp->Parameters.Power.Type) {
        case SystemPowerState:
            DBG_LOG_POWER_IRP(HidDeviceExtension, minorFunction, isClientPdo, FALSE, "SystemState", irpSp->Parameters.Power.State.SystemState, 0xffffffff);
        case DevicePowerState:
            DBG_LOG_POWER_IRP(HidDeviceExtension, minorFunction, isClientPdo, FALSE, "DeviceState", irpSp->Parameters.Power.State.DeviceState, 0xffffffff);
        }
    }

    if (isClientPdo){
        status = HidpPdoPower(HidDeviceExtension, Irp);
    } else {
        status = HidpFdoPower(HidDeviceExtension, Irp);
    }

    DBG_LOG_POWER_IRP(HidDeviceExtension, minorFunction, isClientPdo, TRUE, "", -1, status)

    return status;
}


/*
 ********************************************************************************
 *  SubmitWaitWakeIrp
 ********************************************************************************
 *
 *
 */
NTSTATUS SubmitWaitWakeIrp(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension)
{
    NTSTATUS status;
    POWER_STATE powerState;
    FDO_EXTENSION *fdoExt;

    ASSERT(!HidDeviceExtension->isClientPdo);
    fdoExt = &HidDeviceExtension->fdoExt;

    powerState.SystemState = fdoExt->deviceCapabilities.SystemWake;

    DBGVERBOSE(("SystemWake=%x, submitting waitwake irp.", fdoExt->deviceCapabilities.SystemWake))

    status = PoRequestPowerIrp( HidDeviceExtension->hidExt.PhysicalDeviceObject,
                                IRP_MN_WAIT_WAKE,
                                powerState,
                                HidpWaitWakeComplete,
                                HidDeviceExtension, // context
                                NULL);

    // if (status != STATUS_PENDING){
    //     fdoExt->waitWakeIrp = BAD_POINTER;
    // }

    DBGASSERT((status == STATUS_PENDING),
              ("Expected STATUS_PENDING when submitting WW, got %x", status),
              TRUE)
    return status;
}




/*
 ********************************************************************************
 *  HidpFdoPowerCompletion
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpFdoPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PIO_STACK_LOCATION irpSp;
    FDO_EXTENSION *fdoExt;
    NTSTATUS status = Irp->IoStatus.Status;
    PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension = (PHIDCLASS_DEVICE_EXTENSION)Context;
    SYSTEM_POWER_STATE systemState;

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    ASSERT(ISPTR(HidDeviceExtension));

    if (HidDeviceExtension->isClientPdo){
        fdoExt = &HidDeviceExtension->pdoExt.deviceFdoExt->fdoExt;
    }
    else {
        fdoExt = &HidDeviceExtension->fdoExt;
    }

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    ASSERT(irpSp->MajorFunction == IRP_MJ_POWER);

    if (NT_SUCCESS(status)) {
        switch (irpSp->MinorFunction) {

        case IRP_MN_SET_POWER:
            switch (irpSp->Parameters.Power.Type) {
            case DevicePowerState:
                switch (irpSp->Parameters.Power.State.DeviceState){
                case PowerDeviceD0:

                    if (fdoExt->devicePowerState != PowerDeviceD0) {
                        KIRQL irql;
                        LONG prevIdleState;

                        fdoExt->devicePowerState = irpSp->Parameters.Power.State.DeviceState;

                        ASSERT(!HidDeviceExtension->isClientPdo);

                        //
                        // Reset the idle stuff if it's not disabled.
                        //
                        KeAcquireSpinLock(&fdoExt->idleNotificationSpinLock, &irql);
                        if (fdoExt->idleState != IdleDisabled) {
                            prevIdleState = InterlockedExchange(&fdoExt->idleState, IdleWaiting);
                            DBGASSERT(prevIdleState == IdleComplete,
                                      ("Previous idle state while completing actually %x",
                                       prevIdleState),
                                      TRUE);
                            fdoExt->idleCancelling = FALSE;
                        }
                        KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql);

                        /*
                         *  On APM resume, restart the ping-pong IRPs
                         *  for interrupt devices.
                         */
                        if (!fdoExt->driverExt->DevicesArePolled &&
                            !fdoExt->isOutputOnlyDevice) {
                            NTSTATUS ntStatus = HidpStartAllPingPongs(fdoExt);
                            if (!NT_SUCCESS(ntStatus)) {
                                fdoExt->state = DEVICE_STATE_START_FAILURE;
                            }
                        }
                    }
                    break;
                }
                break;
            case SystemPowerState:
                ASSERT (!HidDeviceExtension->isClientPdo);

                systemState = irpSp->Parameters.Power.State.SystemState;

                ASSERT((ULONG)systemState < PowerSystemMaximum);

                if (systemState < PowerSystemMaximum){
                    /*
                     *  For the 'regular' system power states,
                     *  we convert to a device power state
                     *  and request a callback with the device power state.
                     */
                    PDEVICE_OBJECT pdo = HidDeviceExtension->hidExt.PhysicalDeviceObject;
                    POWER_STATE powerState;
                    KIRQL oldIrql;
                    BOOLEAN isWaitWakePending;

                    fdoExt->systemPowerState = systemState;
                    isWaitWakePending = HidpIsWaitWakePending(fdoExt, FALSE);

                    if (isWaitWakePending){
                        if (systemState == PowerSystemWorking){
                            powerState.DeviceState = PowerDeviceD0;
                        }
                        else {
                            powerState.DeviceState = fdoExt->deviceCapabilities.DeviceState[systemState];

                            /*
                             *  If the bus does not map the system state to
                             *  a defined device state, request PowerDeviceD3
                             *  and cancel the WaitWake IRP.
                             */
                            if (powerState.DeviceState == PowerDeviceUnspecified){
                                DBGERR(("IRP_MN_SET_POWER: systemState %d mapped not mapped so using device state PowerDeviceD3.", systemState))
                                powerState.DeviceState = PowerDeviceD3;
                            }
                        }
                    }
                    else {
                        /*
                         *  If we don't have a WaitWake IRP pending,
                         *  then every reduced-power system state
                         *  should get mapped to D3.
                         */
                        if (systemState == PowerSystemWorking){
                            powerState.DeviceState = PowerDeviceD0;
                        }
                        else {
                            DBGVERBOSE(("IRP_MN_SET_POWER: no waitWake IRP, so requesting PowerDeviceD3."))
                            powerState.DeviceState = PowerDeviceD3;
                        }
                    }

                    DBGVERBOSE(("IRP_MN_SET_POWER: mapped systemState %d to device state %d.", systemState, powerState.DeviceState))

                    IoMarkIrpPending(Irp);
                    fdoExt->currentSystemStateIrp = Irp;
                    PoRequestPowerIrp(  pdo,
                                        IRP_MN_SET_POWER,
                                        powerState,
                                        DevicePowerRequestCompletion,
                                        fdoExt,    // context
                                        NULL);

                    status = STATUS_MORE_PROCESSING_REQUIRED;
                }
                else {
                    TRAP;
                    /*
                     *  For the remaining system power states,
                     *  just pass down the IRP.
                     */
                }
                break;
            }
            break;
        }
    }
    else if (status == STATUS_CANCELLED){
        /*
         *  Client cancelled the power IRP, probably getting removed.
         */
    }
    else {
        DBGWARN(("HidpPowerCompletion: Power IRP %ph (minor function %xh) failed with status %xh.", Irp, irpSp->MinorFunction, Irp->IoStatus.Status))
    }

    return status;
}



/*
 ********************************************************************************
 *  DevicePowerRequestCompletion
 ********************************************************************************
 *
 *  Note: the DeviceObject here is the PDO (e.g. usbhub's PDO), not our FDO,
 *        so we cannot use its device context.
 */
VOID DevicePowerRequestCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    FDO_EXTENSION *fdoExt = (FDO_EXTENSION *)Context;
    PIRP systemStateIrp;

    DBG_COMMON_ENTRY()

    systemStateIrp = fdoExt->currentSystemStateIrp;
    fdoExt->currentSystemStateIrp = BAD_POINTER;
    ASSERT(systemStateIrp);

    DBGSUCCESS(IoStatus->Status, TRUE)
//  systemStateIrp->IoStatus.Status = IoStatus->Status;
    PoStartNextPowerIrp(systemStateIrp);

    /*
     *  Complete the system-state IRP.
     */
    IoCompleteRequest(systemStateIrp, IO_NO_INCREMENT);

    if (PowerState.DeviceState == PowerDeviceD0) {
        //
        // Powering up. Restart the idling.
        //
        HidpStartIdleTimeout(fdoExt, FALSE);
    }

    DBG_COMMON_EXIT()
}



/*
 ********************************************************************************
 *  CollectionPowerRequestCompletion
 ********************************************************************************
 *
 *
 */
VOID CollectionPowerRequestCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PIRP systemStateIrp = (PIRP)Context;
    PHIDCLASS_DEVICE_EXTENSION hidDeviceExtension;
    PDO_EXTENSION *pdoExt;
    IO_STACK_LOCATION *irpSp;
    SYSTEM_POWER_STATE systemState;

    DBG_COMMON_ENTRY()

    hidDeviceExtension = (PHIDCLASS_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    pdoExt = &hidDeviceExtension->pdoExt;

    ASSERT(systemStateIrp);

    /*
     *  This is the completion routine for the device-state power
     *  Irp which we've requested.  Complete the original system-state
     *  power Irp with the result of the device-state power Irp.
     */

    irpSp = IoGetCurrentIrpStackLocation(systemStateIrp);
    systemState = irpSp->Parameters.Power.State.SystemState;

    systemStateIrp->IoStatus.Status = IoStatus->Status;
    PoStartNextPowerIrp(systemStateIrp);

    IoCompleteRequest(systemStateIrp, IO_NO_INCREMENT);

    //
    // If we're powering up, check if we should have a WW irp pending.
    //
    if (systemState == PowerSystemWorking &&
        SHOULD_SEND_WAITWAKE(pdoExt)) {
        HidpCreateRemoteWakeIrp(pdoExt);
    }

    DBG_COMMON_EXIT()
}


/*
 ********************************************************************************
 *  HidpWaitWakePoRequestComplete
 ********************************************************************************
 *
 */
NTSTATUS HidpWaitWakePoRequestComplete(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
{
    PHIDCLASS_DEVICE_EXTENSION hidDevExt = (PHIDCLASS_DEVICE_EXTENSION)Context;
    FDO_EXTENSION *fdoExt;

    ASSERT(!hidDevExt->isClientPdo);
    fdoExt = &hidDevExt->fdoExt;

    DBGVERBOSE(("HidpWaitWakePoRequestComplete!, status == %xh", IoStatus->Status))


    /*
     *  Complete all the collections' WaitWake IRPs with this same status.
     */
    CompleteAllCollectionWaitWakeIrps(fdoExt, IoStatus->Status);

    if (NT_SUCCESS(IoStatus->Status) && fdoExt->idleState != IdleDisabled) {
        HidpPowerUpPdos(fdoExt);
    }

    return STATUS_SUCCESS;
}


/*
 ********************************************************************************
 *  HidpWaitWakeComplete
 ********************************************************************************
 *
 */
NTSTATUS HidpWaitWakeComplete(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
{
    PHIDCLASS_DEVICE_EXTENSION hidDevExt = (PHIDCLASS_DEVICE_EXTENSION)Context;
    FDO_EXTENSION *fdoExt;
    PDO_EXTENSION *pdoExt;
    NTSTATUS status;
    KIRQL oldIrql;

    ASSERT(!hidDevExt->isClientPdo);
    fdoExt = &hidDevExt->fdoExt;

    status = IoStatus->Status;
    DBGVERBOSE(("HidpWaitWakeComplete!, status == %xh", status))

    KeAcquireSpinLock(&fdoExt->waitWakeSpinLock, &oldIrql);
    fdoExt->waitWakeIrp = BAD_POINTER;
    fdoExt->isWaitWakePending = FALSE;
    KeReleaseSpinLock(&fdoExt->waitWakeSpinLock, oldIrql);

    /*
     *  Call HidpWaitWakePoRequestComplete (either directly or
     *  as a completion routine to the power IRP that we request
     *  to wake up the machine); it will complete the clients'
     *  WaitWake IRPs with the same status as this device WaitWake IRP.
     */
    PowerState.DeviceState = PowerDeviceD0;

    if (NT_SUCCESS(status)){
        /*
         *  Our device is waking up the machine.
         *  So request the D0 (working) power state.
         */
        // PowerState is undefined when a wait wake irp is completing
        // ASSERT(PowerState.DeviceState == PowerDeviceD0);

        DBGVERBOSE(("ww irp, requesting D0 on pdo %x\n", DeviceObject))

        PoRequestPowerIrp(  DeviceObject,
                            IRP_MN_SET_POWER,
                            PowerState,
                            HidpWaitWakePoRequestComplete,
                            Context,
                            NULL);
    } else if (status != STATUS_CANCELLED) {

        //
        // If the wait wake failed, then there is no way for us to wake the
        // device when we are in S0.  Turn off idle detection.
        //
        // This doesn't need to be guarded by a spin lock because the only
        // places we look at these values is in the power dispatch routine
        // and when an interrupt read completes...
        //
        // 1)  no interrupt read will be completing b/c the pingpong engine has
        //      been suspended and will not start until we power up the stack
        // 2)  I think we are still considered to be handling a power irp.  If
        //      not, then we need to guard the isIdleTimeoutEnabled field
        //
        // ISSUE! we should also only turn off idle detection if the WW fails in
        //        S0.  If we hiber, then the WW will fail, but we should not turn off
        //        idle detection in this case.  I think that checking
        //        systemPowerState is not PowerSystemWorking will do the trick,
        //        BUT THIS MUST BE CONFIRMED!!!!
        //
        if (fdoExt->idleState != IdleDisabled &&
            fdoExt->systemPowerState == PowerSystemWorking) {
            DBGWARN(("Turning off idle detection due to WW failure, status = %x\n", status))

            ASSERT(ISPTR(fdoExt->idleTimeoutValue));

            //
            // Don't set any state before calling because we may have to power
            // stuff up.
            //
            HidpCancelIdleNotification(fdoExt, FALSE);
        }

        HidpWaitWakePoRequestComplete(  DeviceObject,
                                        MinorFunction,
                                        PowerState,
                                        Context,
                                        IoStatus);
    }

    return STATUS_SUCCESS;
}




/*
 ********************************************************************************
 *  QueuePowerEventIrp
 ********************************************************************************
 *
 */
NTSTATUS QueuePowerEventIrp(
    IN PHIDCLASS_COLLECTION hidCollection,
    IN PIRP Irp
    )
{
    NTSTATUS status;
    KIRQL oldIrql;
    PDRIVER_CANCEL oldCancelRoutine;

    KeAcquireSpinLock(&hidCollection->powerEventSpinLock, &oldIrql);

    /*
     *  Must set a cancel routine before checking the Cancel flag.
     */
    oldCancelRoutine = IoSetCancelRoutine(Irp, PowerEventCancelRoutine);
    ASSERT(!oldCancelRoutine);

    if (Irp->Cancel){
        /*
         *  This IRP was cancelled.  Do not queue it.
         *  The calling function will complete the IRP with error.
         */
        oldCancelRoutine = IoSetCancelRoutine(Irp, NULL);
        if (oldCancelRoutine){
            /*
             *  Cancel routine was NOT called.
             *  Complete the IRP here.
             */
            ASSERT(oldCancelRoutine == PowerEventCancelRoutine);
            status = STATUS_CANCELLED;
        }
        else {
            /*
             *  The cancel routine was called,
             *  and it will complete this IRP as soon as we drop the spinlock.
             *  Return PENDING so the caller doesn't touch this IRP.
             */
            status = STATUS_PENDING;
        }
    }
    else if (ISPTR(hidCollection->powerEventIrp)){
        /*
         *  We already have a power event IRP queued.
         *  This shouldn't happen, but we'll handle it.
         */
        DBGWARN(("Already have a power event irp queued."));
        oldCancelRoutine = IoSetCancelRoutine(Irp, NULL);
        if (oldCancelRoutine){
            /*
             *  Cancel routine was NOT called.
             *  Complete the IRP here.
             */
            ASSERT(oldCancelRoutine == PowerEventCancelRoutine);
            status = STATUS_UNSUCCESSFUL;
        }
        else {
            /*
             *  The irp was cancelled and the cancel routine was called;
             *  it will complete this IRP as soon as we drop the spinlock.
             *  Return PENDING so the caller doesn't touch this IRP.
             */
            ASSERT(Irp->Cancel);
            status = STATUS_PENDING;
        }
    }
    else {
        /*
         *  Save a pointer to this power event IRP and return PENDING.
         *  This qualifies as "queuing" the IRP, so we must have
         *  a cancel routine.
         */
        hidCollection->powerEventIrp = Irp;
        IoMarkIrpPending(Irp);
        status = STATUS_PENDING;
    }

    KeReleaseSpinLock(&hidCollection->powerEventSpinLock, oldIrql);

    return status;
}


/*
 ********************************************************************************
 *  PowerEventCancelRoutine
 ********************************************************************************
 *
 */
VOID PowerEventCancelRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PHIDCLASS_DEVICE_EXTENSION hidDeviceExtension = (PHIDCLASS_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    FDO_EXTENSION *fdoExt;
    PHIDCLASS_COLLECTION hidCollection;
    ULONG collectionIndex;
    KIRQL oldIrql;

    ASSERT(hidDeviceExtension->Signature == HID_DEVICE_EXTENSION_SIG);
    ASSERT(hidDeviceExtension->isClientPdo);
    fdoExt = &hidDeviceExtension->pdoExt.deviceFdoExt->fdoExt;
    collectionIndex = hidDeviceExtension->pdoExt.collectionIndex;
    hidCollection = &fdoExt->classCollectionArray[collectionIndex];

    KeAcquireSpinLock(&hidCollection->powerEventSpinLock, &oldIrql);

    ASSERT(Irp == hidCollection->powerEventIrp);
    hidCollection->powerEventIrp = BAD_POINTER;

    KeReleaseSpinLock(&hidCollection->powerEventSpinLock, oldIrql);

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}


/*
 ********************************************************************************
 *  CollectionWaitWakeIrpCancelRoutine
 ********************************************************************************
 *
 */
VOID CollectionWaitWakeIrpCancelRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PHIDCLASS_DEVICE_EXTENSION hidDeviceExtension = (PHIDCLASS_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    KIRQL oldIrql, oldIrql2;
    PIRP deviceWaitWakeIrpToCancel = NULL;
    FDO_EXTENSION *fdoExt;
    PDO_EXTENSION *pdoExt;

    ASSERT(hidDeviceExtension->Signature == HID_DEVICE_EXTENSION_SIG);
    ASSERT(hidDeviceExtension->isClientPdo);
    pdoExt = &hidDeviceExtension->pdoExt;
    fdoExt = &pdoExt->deviceFdoExt->fdoExt;

    KeAcquireSpinLock(&fdoExt->collectionWaitWakeIrpQueueSpinLock, &oldIrql);

    /*
     *  Dequeue the client's WaitWake IRP.
     */
    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
    InterlockedExchangePointer(&pdoExt->waitWakeIrp, NULL);

    /*
     *  If the last collection WaitWake IRP just got cancelled,
     *  cancel our WaitWake IRP as well.
     *
     *  NOTE:  we only cancel the FDO wait wake irp if we are not doing idle
     *         detection, otherwise, there would be no way for the device to
     *         wake up when we put it into low power
     *
     */
    KeAcquireSpinLock(&fdoExt->waitWakeSpinLock, &oldIrql2);
    if (IsListEmpty(&fdoExt->collectionWaitWakeIrpQueue) &&
        fdoExt->isWaitWakePending                        &&
        fdoExt->idleState == IdleDisabled){
        ASSERT(ISPTR(fdoExt->waitWakeIrp));
        deviceWaitWakeIrpToCancel = fdoExt->waitWakeIrp;
        fdoExt->waitWakeIrp = BAD_POINTER;
        fdoExt->isWaitWakePending = FALSE;
    }
    KeReleaseSpinLock(&fdoExt->waitWakeSpinLock, oldIrql2);

    KeReleaseSpinLock(&fdoExt->collectionWaitWakeIrpQueueSpinLock, oldIrql);

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    /*
     *  Complete the cancelled IRP only if it was in the list.
     */
    Irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    if (ISPTR(deviceWaitWakeIrpToCancel)){
        IoCancelIrp(deviceWaitWakeIrpToCancel);
    }
}


/*
 ********************************************************************************
 *  CompleteAllCollectionWaitWakeIrps
 ********************************************************************************
 *
 *  Note:   this function cannot be pageable because it is called
 *          from a completion routine.
 */
VOID CompleteAllCollectionWaitWakeIrps(
    IN FDO_EXTENSION *fdoExt,
    IN NTSTATUS status
    )
{
    LIST_ENTRY irpsToComplete;
    KIRQL oldIrql;
    PLIST_ENTRY listEntry;
    PIRP irp;
    PDO_EXTENSION *pdoExt;
    PIO_STACK_LOCATION irpSp;

    InitializeListHead(&irpsToComplete);

    KeAcquireSpinLock(&fdoExt->collectionWaitWakeIrpQueueSpinLock, &oldIrql);

    while (!IsListEmpty(&fdoExt->collectionWaitWakeIrpQueue)){
        PDRIVER_CANCEL oldCancelRoutine;

        listEntry = RemoveHeadList(&fdoExt->collectionWaitWakeIrpQueue);
        InitializeListHead(listEntry);  // in case cancel routine tries to dequeue again

        irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);

        oldCancelRoutine = IoSetCancelRoutine(irp, NULL);
        if (oldCancelRoutine){
            ASSERT(oldCancelRoutine == CollectionWaitWakeIrpCancelRoutine);

            /*
             *  We can't complete an IRP while holding a spinlock.
             *  Also, we don't want to complete a WaitWake IRP while
             *  still processing collectionWaitWakeIrpQueue because a driver
             *  may resend an IRP on the same thread, causing us to loop forever.
             *  So just move the IRPs to a private queue and we'll complete them later.
             */
            InsertTailList(&irpsToComplete, listEntry);
            irpSp = IoGetCurrentIrpStackLocation(irp);
            pdoExt = &((PHIDCLASS_DEVICE_EXTENSION)irpSp->DeviceObject->DeviceExtension)->pdoExt;
            InterlockedExchangePointer(&pdoExt->waitWakeIrp, NULL);
        }
        else {
            /*
             *  This IRP was cancelled and the cancel routine WAS called.
             *  The cancel routine will complete the IRP as soon as we drop the spinlock.
             *  So don't touch the IRP.
             */
            ASSERT(irp->Cancel);
        }
    }

    KeReleaseSpinLock(&fdoExt->collectionWaitWakeIrpQueueSpinLock, oldIrql);

    while (!IsListEmpty(&irpsToComplete)){
        listEntry = RemoveHeadList(&irpsToComplete);
        irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);
        irp->IoStatus.Status = status;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }
}

VOID PowerDelayedCancelRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PHIDCLASS_DEVICE_EXTENSION hidDeviceExtension = (PHIDCLASS_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    FDO_EXTENSION *fdoExt;
    KIRQL oldIrql;

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    ASSERT(hidDeviceExtension->Signature == HID_DEVICE_EXTENSION_SIG);
    ASSERT(hidDeviceExtension->isClientPdo);
    fdoExt = &hidDeviceExtension->pdoExt.deviceFdoExt->fdoExt;

    KeAcquireSpinLock(&fdoExt->collectionPowerDelayedIrpQueueSpinLock, &oldIrql);

    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
    ASSERT(Irp->Tail.Overlay.DriverContext[0] == (PVOID) hidDeviceExtension);
    Irp->Tail.Overlay.DriverContext[0] = NULL;

    ASSERT(fdoExt->numPendingPowerDelayedIrps > 0);
    fdoExt->numPendingPowerDelayedIrps--;

    KeReleaseSpinLock(&fdoExt->collectionPowerDelayedIrpQueueSpinLock, oldIrql);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}


NTSTATUS HidpDelayedPowerPoRequestComplete(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus)
{
    KIRQL irql;
    LONG prevIdleState;
    PFDO_EXTENSION fdoExt = (PFDO_EXTENSION) Context;

    DBGINFO(("powering up all pdos due to delayed request, 0x%x\n", IoStatus->Status))

    DBGVERBOSE(("HidpDelayedPowerPoRequestComplete!, status == %xh", IoStatus->Status))

    if (NT_SUCCESS(IoStatus->Status)) {
        HidpPowerUpPdos(fdoExt);
    } else {
        //
        // All bets are off.
        //
        KeAcquireSpinLock(&fdoExt->idleNotificationSpinLock, &irql);
        prevIdleState = InterlockedExchange(&fdoExt->idleState, IdleDisabled);
        fdoExt->idleCancelling = FALSE;
        KeReleaseSpinLock(&fdoExt->idleNotificationSpinLock, irql);

        KeSetEvent(&fdoExt->idleDoneEvent, 0, FALSE);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
EnqueuePowerDelayedIrp(
    IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension,
    IN PIRP Irp
    )
{
    FDO_EXTENSION *fdoExt;
    NTSTATUS status;
    KIRQL oldIrql;
    PDRIVER_CANCEL oldCancelRoutine;

    ASSERT(HidDeviceExtension->isClientPdo);
    fdoExt = &HidDeviceExtension->pdoExt.deviceFdoExt->fdoExt;

    DBGINFO(("enqueuing irp %x (mj %x, mn %x)\n", Irp,
             (ULONG) IoGetCurrentIrpStackLocation(Irp)->MajorFunction,
             (ULONG) IoGetCurrentIrpStackLocation(Irp)->MinorFunction))

    KeAcquireSpinLock(&fdoExt->collectionPowerDelayedIrpQueueSpinLock, &oldIrql);

    /*
     *  Must set a cancel routine before
     *  checking the Cancel flag.
     */
    oldCancelRoutine = IoSetCancelRoutine(Irp, PowerDelayedCancelRoutine);
    ASSERT(!oldCancelRoutine);

    /*
     *  Make sure this Irp wasn't just cancelled.
     *  Note that there is NO RACE CONDITION here
     *  because we are holding the fileExtension lock.
     */
    if (Irp->Cancel){
        /*
         *  This IRP was cancelled.
         */
        oldCancelRoutine = IoSetCancelRoutine(Irp, NULL);
        if (oldCancelRoutine){
            /*
             *  The cancel routine was NOT called.
             *  Return error so that caller completes the IRP.
             */
            ASSERT(oldCancelRoutine == PowerDelayedCancelRoutine);
            status = STATUS_CANCELLED;
        }
        else {
            /*
             *  The cancel routine was called.
             *  As soon as we drop the spinlock it will dequeue
             *  and complete the IRP.
             *  Initialize the IRP's listEntry so that the dequeue
             *  doesn't cause corruption.
             *  Then don't touch the irp.
             */
            InitializeListHead(&Irp->Tail.Overlay.ListEntry);
            fdoExt->numPendingPowerDelayedIrps++;  // because cancel routine will decrement

            //
            // We assert that this value is set in the cancel routine
            //
            Irp->Tail.Overlay.DriverContext[0] = (PVOID) HidDeviceExtension;

            IoMarkIrpPending(Irp);
            status = Irp->IoStatus.Status = STATUS_PENDING;
        }
    }
    else {
        /*
         *  Queue this irp onto the fdo's power delayed queue
         */
        InsertTailList(&fdoExt->collectionPowerDelayedIrpQueue,
                       &Irp->Tail.Overlay.ListEntry);
        fdoExt->numPendingPowerDelayedIrps++;

        Irp->Tail.Overlay.DriverContext[0] = (PVOID) HidDeviceExtension;

        IoMarkIrpPending(Irp);
        status = Irp->IoStatus.Status = STATUS_PENDING;
    }

    KeReleaseSpinLock(&fdoExt->collectionPowerDelayedIrpQueueSpinLock, oldIrql);

    return status;
}

PIRP DequeuePowerDelayedIrp(FDO_EXTENSION *fdoExt)
{
    KIRQL oldIrql;
    PIRP irp = NULL;

    KeAcquireSpinLock(&fdoExt->collectionPowerDelayedIrpQueueSpinLock, &oldIrql);

    while (!irp && !IsListEmpty(&fdoExt->collectionPowerDelayedIrpQueue)){
        PDRIVER_CANCEL oldCancelRoutine;
        PLIST_ENTRY listEntry = RemoveHeadList(&fdoExt->collectionPowerDelayedIrpQueue);

        irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);

        oldCancelRoutine = IoSetCancelRoutine(irp, NULL);

        if (oldCancelRoutine){
            ASSERT(oldCancelRoutine == PowerDelayedCancelRoutine);
            ASSERT(fdoExt->numPendingPowerDelayedIrps > 0);
            fdoExt->numPendingPowerDelayedIrps--;
        }
        else {
            /*
             *  IRP was cancelled and cancel routine was called.
             *  As soon as we drop the spinlock,
             *  the cancel routine will dequeue and complete this IRP.
             *  Initialize the IRP's listEntry so that the dequeue doesn't cause corruption.
             *  Then, don't touch the IRP.
             */
            ASSERT(irp->Cancel);
            InitializeListHead(&irp->Tail.Overlay.ListEntry);
            irp = NULL;
        }
    }

    KeReleaseSpinLock(&fdoExt->collectionPowerDelayedIrpQueueSpinLock, oldIrql);

    return irp;
}

ULONG DequeueAllPdoPowerDelayedIrps(
    PDO_EXTENSION *pdoExt,
    PLIST_ENTRY dequeue
    )

{
    PDRIVER_CANCEL oldCancelRoutine;
    FDO_EXTENSION *fdoExt;
    PDO_EXTENSION *irpPdoExt;
    PLIST_ENTRY entry;
    KIRQL oldIrql;
    PIRP irp;
    ULONG count = 0;

    InitializeListHead(dequeue);

    fdoExt = &pdoExt->deviceFdoExt->fdoExt;

    KeAcquireSpinLock(&fdoExt->collectionPowerDelayedIrpQueueSpinLock, &oldIrql);

    for (entry = fdoExt->collectionPowerDelayedIrpQueue.Flink;
         entry != &fdoExt->collectionPowerDelayedIrpQueue;
          ) {

        irp = CONTAINING_RECORD(entry, IRP, Tail.Overlay.ListEntry);

        irpPdoExt =
            &((PHIDCLASS_DEVICE_EXTENSION) irp->Tail.Overlay.DriverContext[0])->pdoExt;

        entry = entry->Flink;

        if (irpPdoExt == pdoExt) {

            //
            // Remove the entry from the linked list and then either queue it
            // in the dequeue or init the entry so it is valid for the cancel
            // routine
            //
            RemoveEntryList(&irp->Tail.Overlay.ListEntry);

            oldCancelRoutine = IoSetCancelRoutine(irp, NULL);
            if (oldCancelRoutine != NULL) {
                InsertTailList(dequeue, &irp->Tail.Overlay.ListEntry);
                fdoExt->numPendingPowerDelayedIrps--;
                count++;
            }
            else {
                /*
                 *  This IRP was cancelled and the cancel routine WAS called.
                 *  The cancel routine will complete the IRP as soon as we drop the spinlock.
                 *  So don't touch the IRP.
                 */
                ASSERT(irp->Cancel);
                InitializeListHead(&irp->Tail.Overlay.ListEntry);  // in case cancel routine tries to dequeue again
            }
        }
    }

    KeReleaseSpinLock(&fdoExt->collectionPowerDelayedIrpQueueSpinLock, oldIrql);

    return count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hiddll\trnslate.c ===
#include "..\hidparse\trnslate.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hiddll\hiddll.h ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    HIDDLL.H

Abstract:

    This module contains the PRIVATE definitions for the
    code that implements the HID dll.

Environment:

    Kernel & user mode

Revision History:

    Aug-96 : created by Kenneth Ray

--*/


#ifndef _HIDDLL_H
#define _HIDDLL_H


#define malloc(size) LocalAlloc (LPTR, size)
#define ALLOCATION_SHIFT 4
#define RANDOM_DATA PtrToUlong(&HidD_Hello)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hiddll\query.c ===
#define HIDPARSE_USERMODE
#include "..\hidparse\query.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hiddll\hiddll.c ===
#include <stdlib.h>
#include <wtypes.h>
#include <strsafe.h>

#include "initguid.h"
#include "hidclass.h"

#include "hidsdi.h"
#include "hiddll.h"


#include <winioctl.h>

int HidD_Hello (char * buff, int len)
{
   CHAR ret[] = "Hello\n";
   ULONG length = (sizeof (ret) < len) ? sizeof (ret) : len;

   memcpy (buff, ret, length);
   return sizeof (ret);
}



void __stdcall
HidD_GetHidGuid (
   OUT   LPGUID      HidGuid
   )
/*++
Routine Description:
   Please see hidsdi.h for explination

Notes:
--*/
{
    memcpy (HidGuid, &(GUID_CLASS_INPUT), sizeof (struct _GUID));
   *HidGuid = (GUID_CLASS_INPUT);
}

BOOLEAN __stdcall
HidD_GetPreparsedData (
   IN    HANDLE                  HidDeviceObject,
   OUT   PHIDP_PREPARSED_DATA  * PreparsedData
   )
/*++
Routine Description:
   please see hidsdi.h for explination

Notes:
--*/
{
   HID_COLLECTION_INFORMATION info;
   ULONG                      bytes;
   PULONG                     buffer;

   if (! DeviceIoControl (HidDeviceObject,
                          IOCTL_HID_GET_COLLECTION_INFORMATION,
                          0, 0,
                          &info, sizeof (info),
                          &bytes, NULL)) {
      return FALSE;
   }

   buffer = (PULONG) malloc (  info.DescriptorSize
                             + (ALLOCATION_SHIFT * sizeof (ULONG)));
   if (!buffer)
   {
      SetLastError (ERROR_NOT_ENOUGH_MEMORY);
      return FALSE;
   }

   *buffer = RANDOM_DATA;
   *PreparsedData = (PHIDP_PREPARSED_DATA) (buffer + ALLOCATION_SHIFT);

   return DeviceIoControl (HidDeviceObject,
                           IOCTL_HID_GET_COLLECTION_DESCRIPTOR,
                           0, 0,
                           *PreparsedData, info.DescriptorSize,
                           &bytes, NULL) != FALSE;
}

BOOLEAN __stdcall
HidD_GetAttributes (
    IN  HANDLE              HidDeviceObject,
    OUT PHIDD_ATTRIBUTES    Attributes
    )
/*++
Routine Description:
    Please see hidsdi.h for explination

--*/
{
    HID_COLLECTION_INFORMATION  info;
    ULONG                       bytes;

    if (! DeviceIoControl (HidDeviceObject,
                           IOCTL_HID_GET_COLLECTION_INFORMATION,
                           0, 0,
                           &info, sizeof (info),
                           &bytes, NULL)) {
        return FALSE;
    }

    Attributes->Size = sizeof (HIDD_ATTRIBUTES);
    Attributes->VendorID = info.VendorID;
    Attributes->ProductID = info.ProductID;
    Attributes->VersionNumber = info.VersionNumber;

    return TRUE;
}

BOOLEAN __stdcall
HidD_FreePreparsedData (
   IN   PHIDP_PREPARSED_DATA  PreparsedData
   )
/*++
Routine Description:
   please see hidsdi.h for explination

Notes:
--*/
{
   PULONG buffer;

   buffer = (PULONG) PreparsedData - ALLOCATION_SHIFT;

   if (RANDOM_DATA != *buffer) {
      return FALSE;
   }

   LocalFree (buffer);
   return TRUE;
}


BOOLEAN __stdcall
HidD_FlushQueue (
   IN    HANDLE            HidDeviceObject
   )
/*++
Routine Description:
   Please see hidsdi.h for explination

Notes:
--*/
{
   ULONG bytes;
   return DeviceIoControl (HidDeviceObject,
                           IOCTL_HID_FLUSH_QUEUE,
                           0, 0,
                           0, 0,
                           &bytes, NULL) != FALSE;
}

BOOLEAN __stdcall
HidD_GetConfiguration (
   IN   HANDLE               HidDeviceObject,
   OUT  PHIDD_CONFIGURATION  Configuration,
   IN   ULONG                ConfigurationLength
   )
/*++
Routine Description:
   Please see hidsdi.h for explination

Notes:
   We place a goo at the top so that we can enforce the must get before set
   rule.
--*/
{
   ULONG       bytes;

   Configuration->cookie = &HidD_GetConfiguration;

   return DeviceIoControl (HidDeviceObject,
                           IOCTL_HID_GET_DRIVER_CONFIG,
                           0,0,
                           &Configuration->size,
                           (ConfigurationLength - 4),
                           &bytes, NULL) != FALSE;
}

BOOLEAN __stdcall
HidD_SetConfiguration (
   IN   HANDLE               HidDeviceObject,
   OUT  PHIDD_CONFIGURATION  Configuration,
   IN   ULONG                ConfigurationLength
   )
/*++
Routine Description:
   Please see hidsdi.h for explanation

Notes:
   We place a goo at the top so that we can enforce the must get before set
   rule.
--*/
{
   ULONG       bytes;

   if (Configuration->cookie != &HidD_GetConfiguration) {
       SetLastError(ERROR_INVALID_PARAMETER);
       return FALSE;
   }

   return DeviceIoControl (HidDeviceObject,
                           IOCTL_HID_SET_DRIVER_CONFIG,
                           0,0,
                           &Configuration->size, (ConfigurationLength - 4),
                           &bytes, NULL) != FALSE;
}

STDAPI_(BOOL)
Entry32(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason) {
        default: return TRUE;
        }
}

BOOLEAN __stdcall
DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
   switch (dwReason)
   {
      default: return TRUE;
   }
}

BOOLEAN __stdcall
HidD_GetNumInputBuffers (
    IN  HANDLE  HidDeviceObject,
    OUT PULONG  NumberBuffers) // Number of hid packets actually retained
{
    ULONG   bytes;

    return DeviceIoControl (HidDeviceObject,
                            IOCTL_GET_NUM_DEVICE_INPUT_BUFFERS,
                            NULL, 0,
                            NumberBuffers, sizeof (ULONG),
                            &bytes, NULL) != FALSE;
}

BOOLEAN __stdcall
HidD_SetNumInputBuffers (
    IN  HANDLE HidDeviceObject,
    OUT ULONG  NumberBuffers) // Number of hid packets actually retained
{
    ULONG   bytes;

    return DeviceIoControl (HidDeviceObject,
                            IOCTL_SET_NUM_DEVICE_INPUT_BUFFERS,
                            &NumberBuffers, sizeof (ULONG),
                            NULL, 0,
                            &bytes, NULL) != FALSE;
}

BOOLEAN __stdcall
HidD_GetSerialNumberString (
   IN    HANDLE   HidDeviceObject,
   OUT   PVOID    Buffer,
   IN    ULONG    BufferLength
   )
{
    ULONG   bytes;

    return DeviceIoControl (HidDeviceObject,
                            IOCTL_HID_GET_SERIALNUMBER_STRING,
                            0, 0,
                            Buffer, BufferLength,
                            &bytes, NULL) != FALSE;
}

BOOLEAN __stdcall
HidD_GetManufacturerString (
   IN    HANDLE   HidDeviceObject,
   OUT   PVOID    Buffer,
   IN    ULONG    BufferLength
   )
{
    ULONG   bytes;

    return DeviceIoControl (HidDeviceObject,
                            IOCTL_HID_GET_MANUFACTURER_STRING,
                            0, 0,
                            Buffer, BufferLength,
                            &bytes, NULL) != FALSE;
}

BOOLEAN __stdcall
HidD_GetProductString (
   IN    HANDLE   HidDeviceObject,
   OUT   PVOID    Buffer,
   IN    ULONG    BufferLength
   )
{
    ULONG   bytes;

    return DeviceIoControl (HidDeviceObject,
                            IOCTL_HID_GET_PRODUCT_STRING,
                            0, 0,
                            Buffer, BufferLength,
                            &bytes, NULL) != FALSE;
}

BOOLEAN __stdcall
HidD_GetIndexedString (
    IN  HANDLE  HidDeviceObject,
    IN  ULONG   StringIndex,
    OUT PVOID   Buffer,
    IN  ULONG   BufferLength
    )
{
    ULONG   bytes;

    return DeviceIoControl (HidDeviceObject,
                            IOCTL_HID_GET_INDEXED_STRING,
                            &StringIndex, sizeof (ULONG),
                            Buffer, BufferLength,
                            &bytes, NULL) != FALSE;
}

BOOLEAN __stdcall
HidD_GetPhysicalDescriptor (
   IN    HANDLE   HidDeviceObject,
   OUT   PVOID    ReportBuffer,
   IN    ULONG    ReportBufferLength
   )
{
    ULONG   bytes;

    return DeviceIoControl (HidDeviceObject,
                            IOCTL_GET_PHYSICAL_DESCRIPTOR,
                            0, 0,
                            ReportBuffer, ReportBufferLength,
                            &bytes, NULL) != FALSE;
}

BOOLEAN __stdcall
HidD_GetFeature (
   IN    HANDLE   HidDeviceObject,
   OUT   PVOID    ReportBuffer,
   IN    ULONG    ReportBufferLength
   )
{
    ULONG   bytes;

    return DeviceIoControl (HidDeviceObject,
                            IOCTL_HID_GET_FEATURE,
                            0, 0,
                            ReportBuffer, ReportBufferLength,
                            &bytes, NULL) != FALSE;
}

BOOLEAN __stdcall
HidD_SetFeature (
   IN    HANDLE   HidDeviceObject,
   IN    PVOID    ReportBuffer,
   IN    ULONG    ReportBufferLength
   )
{
    ULONG   bytes;

    return DeviceIoControl (HidDeviceObject,
                            IOCTL_HID_SET_FEATURE,
                            ReportBuffer, ReportBufferLength,
                            0, 0,
                            &bytes, NULL) != FALSE;
}

BOOLEAN __stdcall
HidD_GetInputReport (
   IN    HANDLE   HidDeviceObject,
   OUT   PVOID    ReportBuffer,
   IN    ULONG    ReportBufferLength
   )
{
    ULONG   bytes;

    return DeviceIoControl (HidDeviceObject,
                            IOCTL_HID_GET_INPUT_REPORT,
                            0, 0,
                            ReportBuffer, ReportBufferLength,
                            &bytes, NULL) != FALSE;
}

BOOLEAN __stdcall
HidD_SetOutputReport (
   IN    HANDLE   HidDeviceObject,
   IN    PVOID    ReportBuffer,
   IN    ULONG    ReportBufferLength
   )
{
    ULONG   bytes;

    return DeviceIoControl (HidDeviceObject,
                            IOCTL_HID_SET_OUTPUT_REPORT,
                            ReportBuffer, ReportBufferLength,
                            0, 0,
                            &bytes, NULL) != FALSE;
}


BOOLEAN __stdcall
HidD_GetMsGenreDescriptor (
   IN    HANDLE   HidDeviceObject,
   OUT   PVOID    ReportBuffer,
   IN    ULONG    ReportBufferLength
   )
{
    ULONG   bytes;

    return DeviceIoControl (HidDeviceObject,
                            IOCTL_HID_GET_MS_GENRE_DESCRIPTOR,
                            0, 0,
                            ReportBuffer, ReportBufferLength,
                            &bytes, NULL) != FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidir\dbg.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    dbg.c

Abstract:

    Debug functions and services

Environment:

    kernel mode only

Notes:

Revision History:

    12/12/2001 : created jsenior

--*/

#include "pch.h"
#include "stdarg.h"
#include "stdio.h"

// paged functions
#ifdef ALLOC_PRAGMA
#endif

#if DBG

/******
DEBUG
******/

#define  DEFAULT_DEBUG_LEVEL    2

ULONG HidIrDebug_Trace_Level = DEFAULT_DEBUG_LEVEL;


ULONG
_cdecl
HidIrKdPrintX(
    ULONG l,
    PCH Format,
    ...
    )
/*++

Routine Description:

    Debug Print function.

    Prints based on the value of the HidIrDEBUG_TRACE_LEVEL

    Also if HidIrW98_Debug_Trace is set then all debug messages
    with a level greater than one are modified to go in to the
    ntkern trace buffer.

    It is only valid to set HidIrW98_Debug_Trace on Win9x
    becuse the static data segments for drivers are marked read-only
    by the NT OS.

Arguments:

Return Value:


--*/
{
    va_list list;
    int i;
    int arg[6];

    if (HidIrDebug_Trace_Level >= l) {
        // dump line to debugger
        DbgPrint("'HIDIR.SYS: ");

        va_start(list, Format);
        for (i=0; i<6; i++)
            arg[i] = va_arg(list, int);

        DbgPrint(Format, arg[0], arg[1], arg[2], arg[3], arg[4], arg[5]);
        DbgPrint("\n");
    }

    return 0;
}

#endif /* DBG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidclass\write.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    write.c

Abstract

    Write handling routines

Author:

    Forrest Foltz
    Ervin P.

Environment:

    Kernel mode only

Revision History:


--*/

#include "pch.h"




/*
 ********************************************************************************
 *  HidpInterruptWriteComplete
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpInterruptWriteComplete(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
{
    PHIDCLASS_DEVICE_EXTENSION hidDeviceExtension = (PHIDCLASS_DEVICE_EXTENSION)Context;
    NTSTATUS status = Irp->IoStatus.Status;
    PHID_XFER_PACKET hidWritePacket;

    DBG_COMMON_ENTRY()

    ASSERT(hidDeviceExtension->isClientPdo);

    ASSERT(Irp->UserBuffer);
    hidWritePacket = Irp->UserBuffer;
    ExFreePool(hidWritePacket);
    Irp->UserBuffer = NULL;

    if (NT_SUCCESS(status)){
        FDO_EXTENSION *fdoExt = &hidDeviceExtension->pdoExt.deviceFdoExt->fdoExt;
        PHIDP_COLLECTION_DESC collectionDesc = GetCollectionDesc(fdoExt, hidDeviceExtension->pdoExt.collectionNum);

        if (collectionDesc){
            HidpSetDeviceBusy(fdoExt);

            Irp->IoStatus.Information = collectionDesc->OutputLength;
        } else {
            //
            // How could we get here? Had to get the collectionDesc in order 
            // to start the write!
            //
            TRAP;
        }

        DBGVERBOSE(("HidpInterruptWriteComplete: write irp %ph succeeded, wrote %xh bytes.", Irp, Irp->IoStatus.Information))
    }
    else {
        DBGWARN(("HidpInterruptWriteComplete: write irp %ph failed w/ status %xh.", Irp, status))
    }

    /*
     *  If the lower driver returned PENDING, mark our stack location as pending also.
     */
    if (Irp->PendingReturned){
        IoMarkIrpPending(Irp);
    }

    DBGSUCCESS(status, FALSE)
    DBG_COMMON_EXIT()
    return status;
}



/*
 ********************************************************************************
 *  HidpIrpMajorWrite
 ********************************************************************************
 *
 *  Note:  This function cannot be pageable code because
 *         writes can happen at dispatch level.
 *
 */
NTSTATUS HidpIrpMajorWrite(IN PHIDCLASS_DEVICE_EXTENSION HidDeviceExtension, IN OUT PIRP Irp)
{
    NTSTATUS status;
    PDO_EXTENSION *pdoExt;
    FDO_EXTENSION *fdoExt;
    PIO_STACK_LOCATION currentIrpSp, nextIrpSp;
    BOOLEAN securityCheckOk = FALSE;
    PUCHAR buffer;
    PHIDP_REPORT_IDS reportIdentifier;
    PHIDP_COLLECTION_DESC collectionDesc;
    PHID_XFER_PACKET hidWritePacket;


    DBG_COMMON_ENTRY()

    ASSERT(HidDeviceExtension->isClientPdo);
    pdoExt = &HidDeviceExtension->pdoExt;
    fdoExt = &HidDeviceExtension->pdoExt.deviceFdoExt->fdoExt;

    currentIrpSp = IoGetCurrentIrpStackLocation(Irp);
    nextIrpSp = IoGetNextIrpStackLocation(Irp);

    if (pdoExt->state != COLLECTION_STATE_RUNNING ||
        fdoExt->state != DEVICE_STATE_START_SUCCESS){
        status = STATUS_DEVICE_NOT_CONNECTED;
        goto HidpIrpMajorWriteDone;
    }

    /*
     *  Get the file extension.
     */
    if (currentIrpSp->FileObject){
        PHIDCLASS_FILE_EXTENSION fileExtension = (PHIDCLASS_FILE_EXTENSION)currentIrpSp->FileObject->FsContext;
        if (fileExtension) {
            ASSERT(fileExtension->Signature == HIDCLASS_FILE_EXTENSION_SIG);
            securityCheckOk = TRUE;
        }
        DBGASSERT(fileExtension, ("Attempted write with no file extension"), FALSE)
    }
    else {
        /*
         *  KBDCLASS can send a NULL FileObject to set LEDs on a keyboard
         *  (it may need to do this for a keyboard which was opened by
         *   the raw user input thread, for which kbdclass has no fileObj).
         *  A write with FileObject==NULL can only come from kernel space,
         *  so we treat this as a secure write.
         */
        securityCheckOk = TRUE;
    }

    /*
     *  Check security.
     */
    if (!securityCheckOk){
        status = STATUS_PRIVILEGE_NOT_HELD;
        goto HidpIrpMajorWriteDone;
    }

    status = HidpCheckIdleState(HidDeviceExtension, Irp);
    if (status != STATUS_SUCCESS) {
        Irp = (status != STATUS_PENDING) ? Irp : (PIRP) BAD_POINTER;
        goto HidpIrpMajorWriteDone;
    }

    buffer = HidpGetSystemAddressForMdlSafe(Irp->MdlAddress);
    if (!buffer) {
        status = STATUS_INVALID_USER_BUFFER;
        goto HidpIrpMajorWriteDone;
    }

    /*
     *  Extract the report identifier with the given id from 
     *  the HID device extension. The report id is the first 
     *  byte of the buffer.
     */
    reportIdentifier = GetReportIdentifier(fdoExt, buffer[0]);
    collectionDesc = GetCollectionDesc(fdoExt, HidDeviceExtension->pdoExt.collectionNum);
    if (!collectionDesc || 
        !reportIdentifier) {
        status = STATUS_INVALID_PARAMETER;
        goto HidpIrpMajorWriteDone;
    }
    if (!reportIdentifier->OutputLength){
        status = STATUS_INVALID_PARAMETER;
        goto HidpIrpMajorWriteDone;
    }

    /*
     *  Make sure the caller's buffer is the right size.
     */
    if (currentIrpSp->Parameters.Write.Length != collectionDesc->OutputLength){
        status = STATUS_INVALID_BUFFER_SIZE;
        goto HidpIrpMajorWriteDone;
    }

    /*
     *  All parameters are correct. Allocate the write packet and 
     *  send this puppy down.
     */
    try {

        hidWritePacket = ALLOCATEQUOTAPOOL(NonPagedPool, 
                                           sizeof(HID_XFER_PACKET));

    } except (EXCEPTION_EXECUTE_HANDLER) {

          hidWritePacket = NULL;
          status = GetExceptionCode();

    }

    if (!hidWritePacket){
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto HidpIrpMajorWriteDone;
    }
        
    /*
     *  Prepare write packet for minidriver.
     */
    hidWritePacket->reportBuffer = buffer;
    hidWritePacket->reportBufferLen = reportIdentifier->OutputLength;

    /*
     *  The client includes the report id as the first byte of the report.
     *  We send down the report byte only if the device has multiple
     *  report IDs (i.e. the report id is not implicit).
     */
    hidWritePacket->reportId = hidWritePacket->reportBuffer[0];
    if (fdoExt->deviceDesc.ReportIDs[0].ReportID == 0){
        ASSERT(hidWritePacket->reportId == 0);
        hidWritePacket->reportBuffer++;
    }

    Irp->UserBuffer = (PVOID)hidWritePacket;

    /*
     *  Prepare the next (lower) IRP stack location.
     *  This will be HIDUSB's "current" stack location.
     */
    nextIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextIrpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_HID_WRITE_REPORT;
    nextIrpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(HID_XFER_PACKET);

    IoSetCompletionRoutine( Irp,
                            HidpInterruptWriteComplete,
                            (PVOID)HidDeviceExtension,
                            TRUE,
                            TRUE,
                            TRUE );

    status = HidpCallDriver(fdoExt->fdo, Irp);

    /*
     *  The Irp no longer belongs to us, and it can be
     *  completed at any time; so don't touch it.
     */
    Irp = (PIRP)BAD_POINTER;

HidpIrpMajorWriteDone:
    if (ISPTR(Irp)){
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    DBGSUCCESS(status, FALSE)
    DBG_COMMON_EXIT();
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidclass\util.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    util.c

Abstract

    Internal utility functions for the HID class driver.

Authors:

    Ervin P.

Environment:

    Kernel mode only

Revision History:


--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, HidpAddDevice)
        #pragma alloc_text(PAGE, HidpDriverUnload)
        #pragma alloc_text(PAGE, HidpGetDeviceDescriptor)
        #pragma alloc_text(PAGE, HidpQueryDeviceCapabilities)
        #pragma alloc_text(PAGE, HidpQueryIdForClientPdo)
        #pragma alloc_text(PAGE, SubstituteBusNames)
        #pragma alloc_text(PAGE, BuildCompatibleID)
        #pragma alloc_text(PAGE, HidpQueryCollectionCapabilities)
        #pragma alloc_text(PAGE, HidpCreateClientPDOs)
        #pragma alloc_text(PAGE, MakeClientPDOName)
        #pragma alloc_text(PAGE, HidpCreateSymbolicLink)
        #pragma alloc_text(PAGE, HidpQueryInterface)
#endif



/*
 ********************************************************************************
 *  HidpCopyInputReportToUser
 ********************************************************************************
 *
 *  Copy a read report into a user's buffer.
 *
 *  Note:  ReportData is already "cooked" (already has report-id byte at start of report).
 *
 */
NTSTATUS HidpCopyInputReportToUser(
    IN PHIDCLASS_FILE_EXTENSION FileExtension,
    IN PUCHAR ReportData,
    IN OUT PULONG UserBufferLen,
    OUT PUCHAR UserBuffer
    )
{
    NTSTATUS result = STATUS_DEVICE_DATA_ERROR;
    ULONG reportId;
    PHIDP_REPORT_IDS reportIdentifier;
    FDO_EXTENSION *fdoExtension = FileExtension->fdoExt;

    RUNNING_DISPATCH();

    ASSERT(fdoExtension->deviceDesc.CollectionDescLength > 0);

    reportId = (ULONG)*ReportData;

    reportIdentifier = GetReportIdentifier(fdoExtension, reportId);
    if (reportIdentifier){
        PHIDP_COLLECTION_DESC collectionDesc;
        PHIDCLASS_COLLECTION hidpCollection;

        collectionDesc = GetCollectionDesc(fdoExtension, reportIdentifier->CollectionNumber);
        hidpCollection = GetHidclassCollection(fdoExtension, reportIdentifier->CollectionNumber);

        if (collectionDesc && hidpCollection){
            ULONG reportLength = collectionDesc->InputLength;

            if (*UserBufferLen >= reportLength){
                RtlCopyMemory(UserBuffer, ReportData, reportLength);
                result = STATUS_SUCCESS;
            }
            else {
                result = STATUS_INVALID_BUFFER_SIZE;
            }

            /*
             *  Return the actual length of the report (whether we copied or not).
             */
            *UserBufferLen = reportLength;
        }
    }

    ASSERT((result == STATUS_SUCCESS) || (result == STATUS_INVALID_BUFFER_SIZE));
    return result;
}





/*
 ********************************************************************************
 *  HidpAddDevice
 ********************************************************************************
 *
 *   Routine Description:
 *
 *       This routine is called by configmgr when a new PDO is dected.
 *       It creates an Functional Device Object (FDO) and attaches it to the
 *       PDO.
 *
 *   Arguments:
 *
 *       DriverObject - pointer to the minidriver's driver object.
 *
 *       PhysicalDeviceObject - pointer to the PDO that the minidriver got in it's
 *                              AddDevice() routine.
 *
 *   Return Value:
 *
 *      Standard NT return value.
 *
 */
NTSTATUS HidpAddDevice(IN PDRIVER_OBJECT DriverObject, IN PDEVICE_OBJECT PhysicalDeviceObject)
{
    PHIDCLASS_DRIVER_EXTENSION  hidDriverExtension;
    PHIDCLASS_DEVICE_EXTENSION  hidClassExtension;
    NTSTATUS                    status;
    UNICODE_STRING              uPdoName;
    PWSTR                       wPdoName;
    PVOID                       miniDeviceExtension;
    ULONG                       totalExtensionSize;
    ULONG                       thisHidId;
    PDEVICE_OBJECT              functionalDeviceObject;

    PAGED_CODE();

    DBG_COMMON_ENTRY()

    DBG_RECORD_DEVOBJ(PhysicalDeviceObject, "minidrvr PDO")


    //
    // Get a pointer to our per-driver extension, make sure it's one of ours.
    //

    hidDriverExtension = RefDriverExt(DriverObject);
    if (hidDriverExtension){

        ASSERT(DriverObject == hidDriverExtension->MinidriverObject);

        //
        // Construct a name for the FDO.  The only requirement, really, is
        // that it's unique.  For now we'll call them "_HIDx", where 'x' is some
        // unique number.
        //

        /*
         *  PDO name has form "\Device\_HIDx".
         */
        wPdoName = ALLOCATEPOOL(NonPagedPool, sizeof(L"\\Device\\_HID00000000"));
        if (wPdoName){

            //
            // Get the current value of NextHidId and increment it.  Since
            // InterlockedIncrement() returns the incremented value, subtract one to
            // get the pre-increment value of NextHidId;
            //
            thisHidId = InterlockedIncrement(&HidpNextHidNumber) - 1;
            StringCbPrintfW(wPdoName, 
                             sizeof(L"\\Device\\_HID00000000"), 
                             L"\\Device\\_HID%08x", thisHidId);
            RtlInitUnicodeString(&uPdoName, wPdoName);

            //
            // We've got a counted-string version of the device object name.  Calculate
            // the total size of the device extension and create the FDO.
            //
            totalExtensionSize = sizeof(HIDCLASS_DEVICE_EXTENSION) +
                                 hidDriverExtension->DeviceExtensionSize;

            status = IoCreateDevice( DriverObject,          // driver object
                                     totalExtensionSize,    // extension size
                                     &uPdoName,             // name of the FDO
                                     FILE_DEVICE_UNKNOWN,   // 
                                     0,                     // DeviceCharacteristics
                                     FALSE,                 // not exclusive
                                     &functionalDeviceObject );

            if (NT_SUCCESS(status)){

                DBG_RECORD_DEVOBJ(functionalDeviceObject, "device FDO")

                ObReferenceObject(functionalDeviceObject);

                ASSERT(DriverObject->DeviceObject == functionalDeviceObject);
                ASSERT(functionalDeviceObject->DriverObject == DriverObject);


                //
                // We've created the device object.  Fill in the minidriver's extension
                // pointer and attach this FDO to the PDO.
                //

                hidClassExtension = functionalDeviceObject->DeviceExtension;
                RtlZeroMemory(hidClassExtension, totalExtensionSize);

                hidClassExtension->isClientPdo = FALSE;

                //
                //  Assign the name of the minidriver's PDO to our FDO.
                //
                hidClassExtension->fdoExt.name = uPdoName;

                //
                // The minidriver extension lives in the device extension and starts
                // immediately after our HIDCLASS_DEVICE_EXTENSION structure.  Note
                // that the first structure in the HIDCLASS_DEVICE_EXTENSION is the
                // public HID_DEVICE_EXTENSION structure, which is where the pointer
                // to the minidriver's per-device extension area lives.
                //

                miniDeviceExtension = (PVOID)(hidClassExtension + 1);
                hidClassExtension->hidExt.MiniDeviceExtension = miniDeviceExtension;

                //
                // Get a pointer to the physical device object passed in.  This device
                // object should already have the DO_DEVICE_INITIALIZING flag cleared.
                //

                ASSERT( (PhysicalDeviceObject->Flags & DO_DEVICE_INITIALIZING) == 0 );

                //
                // Attach the FDO to the PDO, storing the device object at the top of the
                // stack in our device extension.
                //

                hidClassExtension->hidExt.NextDeviceObject =
                    IoAttachDeviceToDeviceStack( functionalDeviceObject,
                                                 PhysicalDeviceObject );


                ASSERT(DriverObject->DeviceObject == functionalDeviceObject);
                ASSERT(functionalDeviceObject->DriverObject == DriverObject);

                //
                // The functional device requires two stack locations: one for the class
                // driver, and one for the minidriver.
                //

                functionalDeviceObject->StackSize++;

                //
                // We'll need a pointer to the physical device object as well for PnP
                // purposes.  Note that it's a virtual certainty that NextDeviceObject
                // and PhysicalDeviceObject are identical.
                //

                hidClassExtension->hidExt.PhysicalDeviceObject = PhysicalDeviceObject;
                hidClassExtension->Signature = HID_DEVICE_EXTENSION_SIG;
                hidClassExtension->fdoExt.fdo = functionalDeviceObject;
                hidClassExtension->fdoExt.driverExt = hidDriverExtension;
                hidClassExtension->fdoExt.outstandingRequests = 0;
                hidClassExtension->fdoExt.openCount = 0;
                hidClassExtension->fdoExt.state = DEVICE_STATE_INITIALIZED;
                hidClassExtension->fdoExt.isPresent = TRUE;
                KeInitializeSpinLock(&hidClassExtension->fdoExt.presentSpinLock);
                hidClassExtension->fdoExt.presentReported = TRUE;

                //
                // Selective suspend portion.
                //
                hidClassExtension->fdoExt.idleState = IdleDisabled;
                hidClassExtension->fdoExt.idleTimeoutValue = BAD_POINTER;
                KeInitializeSpinLock(&hidClassExtension->fdoExt.idleNotificationSpinLock);
                KeInitializeEvent(&hidClassExtension->fdoExt.idleDoneEvent, NotificationEvent, TRUE);
                hidClassExtension->fdoExt.idleNotificationRequest = BAD_POINTER;
                hidClassExtension->fdoExt.idleCallbackInfo.IdleCallback = HidpIdleNotificationCallback;
                hidClassExtension->fdoExt.idleCallbackInfo.IdleContext = (PVOID) hidClassExtension;

                hidClassExtension->fdoExt.systemPowerState = PowerSystemWorking;
                hidClassExtension->fdoExt.devicePowerState = PowerDeviceD0;

                hidClassExtension->fdoExt.waitWakeIrp = BAD_POINTER;
                KeInitializeSpinLock(&hidClassExtension->fdoExt.waitWakeSpinLock);
                hidClassExtension->fdoExt.isWaitWakePending = FALSE;

                InitializeListHead(&hidClassExtension->fdoExt.collectionWaitWakeIrpQueue);
                KeInitializeSpinLock(&hidClassExtension->fdoExt.collectionWaitWakeIrpQueueSpinLock);

                InitializeListHead(&hidClassExtension->fdoExt.collectionPowerDelayedIrpQueue);
                KeInitializeSpinLock(&hidClassExtension->fdoExt.collectionPowerDelayedIrpQueueSpinLock);
                hidClassExtension->fdoExt.numPendingPowerDelayedIrps = 0;

                hidClassExtension->fdoExt.BusNumber = thisHidId;

                #if DBG
                    InitFdoExtDebugInfo(hidClassExtension);
                #endif

                EnqueueFdoExt(&hidClassExtension->fdoExt);

                /*
                 *  Indicate that this device object does direct I/O.
                 *
                 *  Set the flag that causes the IO subsystem to decrement the device
                 *  object's reference count *before* sending down IRP_MJ_CLOSEs.  We
                 *  need this because we delete the device object on the last close.
                 */
                functionalDeviceObject->Flags |= DO_DIRECT_IO;

                /*
                 *  The DO_POWER_PAGABLE bit of a device object
                 *  indicates to the kernel that the power-handling
                 *  code of the corresponding driver is pageable, and
                 *  so must be called at IRQL 0.
                 *  As a filter driver, we do not want to change the power
                 *  behavior of the driver stack in any way; therefore,
                 *  we copy this bit from the lower device object.
                 */
                functionalDeviceObject->Flags |= (PhysicalDeviceObject->Flags & DO_POWER_PAGABLE);

                /*
                 *  Must clear the initializing flag after initialization complete.
                 */
                functionalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

                //
                // Since we have NOT seen a start device, we CANNOT send any non
                // pnp irps to the device yet.  We need to do that in the start
                // device requests.
                //


                //
                // Call the minidriver to let it do any extension initialization
                //

                status = hidDriverExtension->AddDevice(DriverObject, functionalDeviceObject);

                if (!NT_SUCCESS(status)) {
                    DequeueFdoExt(&hidClassExtension->fdoExt);
                    IoDetachDevice(hidClassExtension->hidExt.NextDeviceObject);
                    ObDereferenceObject(functionalDeviceObject);
                    IoDeleteDevice(functionalDeviceObject);
                    ExFreePool( wPdoName );
                }
            }
            else {
                DBGWARN(("IoCreateDevice failed with status: %x", status));
                ExFreePool( wPdoName );
            }
        }
        else {
            DBGWARN(("Pool allocation for fdo name failed."));
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (!NT_SUCCESS(status)){
            DerefDriverExt(DriverObject);
        }
    }
    else {
        ASSERT(hidDriverExtension);
        status = STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    DBGSUCCESS(status, TRUE)
    DBG_COMMON_EXIT()
    return status;
}



/*
 ********************************************************************************
 *  HidpDriverUnload
 ********************************************************************************
 *
 *
 */
VOID HidpDriverUnload(IN struct _DRIVER_OBJECT *minidriverObject)
{
    PHIDCLASS_DRIVER_EXTENSION hidDriverExt;

    PAGED_CODE();

    DBG_COMMON_ENTRY()

    /*
     *  This extra de-reference will cause our hidDriverExtension's
     *  reference count to eventually go to -1; at that time, we'll
     *  dequeue it.
     */
    hidDriverExt = DerefDriverExt(minidriverObject);
    ASSERT(hidDriverExt);

    /*
     *  Chain the unload call to the minidriver.
     */
    hidDriverExt->DriverUnload(minidriverObject);

    DBG_COMMON_EXIT()
}


NTSTATUS GetHIDRawReportDescriptor(FDO_EXTENSION *fdoExt, PIRP irp, ULONG descriptorLen)
{
    NTSTATUS status;

    if (descriptorLen){
        PUCHAR rawReportDescriptor = ALLOCATEPOOL(NonPagedPool, descriptorLen);

        if (rawReportDescriptor){
            const ULONG retries = 3;
            ULONG i;

            for (i = 0; i < retries; i++){
                PIO_STACK_LOCATION irpSp;

                irp->UserBuffer = rawReportDescriptor;
                irpSp = IoGetNextIrpStackLocation(irp);

                ASSERT(irpSp->Parameters.DeviceIoControl.InputBufferLength == 0);
                ASSERT(irpSp->Parameters.DeviceIoControl.Type3InputBuffer == NULL);
                irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
                irpSp->Parameters.DeviceIoControl.OutputBufferLength = descriptorLen;
                irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_HID_GET_REPORT_DESCRIPTOR;

                //
                // Call the minidriver to get the report descriptor.
                //
                status = HidpCallDriverSynchronous(fdoExt->fdo, irp);
                if (NT_SUCCESS(status)){
                    if (irp->IoStatus.Information == descriptorLen){
                        fdoExt->rawReportDescriptionLength = descriptorLen;
                        fdoExt->rawReportDescription = rawReportDescriptor;
                        break;
                    } else {
                        DBGWARN(("GetHIDRawReportDescriptor (attempt #%d) returned %xh/%xh bytes", i, irp->IoStatus.Information, descriptorLen))
                        status = STATUS_DEVICE_DATA_ERROR;
                    }
                } else {
                    DBGWARN(("GetHIDRawReportDescriptor (attempt #%d) failed with status %xh.", i, status))
                }
            }

            if (!NT_SUCCESS(status)){
                DBGWARN(("GetHIDRawReportDescriptor failed %d times.", retries))
                ExFreePool(rawReportDescriptor);
            }

        } else {
            DBGWARN(("alloc failed in GetHIDRawReportDescriptor"))
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else {
        DBGWARN(("GetHIDRawReportDescriptor: descriptorLen is zero."))
        status = STATUS_DEVICE_DATA_ERROR;
    }

    DBGSUCCESS(status, FALSE)
    return status;
}



/*
 ********************************************************************************
 *  HidpGetDeviceDescriptor
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpGetDeviceDescriptor(FDO_EXTENSION *fdoExtension)
{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    PHID_DESCRIPTOR hidDescriptor;
    ULONG rawReportDescriptorLength;

    PAGED_CODE();


    /*
     *  Retrieve:
     *
     *      1. Device descriptor (fixed portion)
     *      2. Device attributes
     *      3. Report descriptor
     */

    hidDescriptor = &fdoExtension->hidDescriptor;

    irp = IoAllocateIrp(fdoExtension->fdo->StackSize, FALSE);
    if (irp){
        irpSp = IoGetNextIrpStackLocation(irp);
        irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_HID_GET_DEVICE_DESCRIPTOR;

        /*
         *  This IOCTL uses buffering type METHOD_NEITHER, so
         *  the buffer is simply passed in irp->UserBuffer.
         */
        irp->UserBuffer = hidDescriptor;
        irpSp->Parameters.DeviceIoControl.OutputBufferLength = sizeof(HID_DESCRIPTOR);
        irpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

        status = HidpCallDriverSynchronous(fdoExtension->fdo, irp);
        DBGASSERT((status == STATUS_SUCCESS),
                  ("STATUS_SUCCESS not returned, %x returned",status),
                  TRUE)

        if (status == STATUS_SUCCESS){

            if (irp->IoStatus.Information == sizeof(HID_DESCRIPTOR)){

                irpSp = IoGetNextIrpStackLocation(irp);

                ASSERT(irpSp->MajorFunction == IRP_MJ_INTERNAL_DEVICE_CONTROL);
                ASSERT(irpSp->Parameters.DeviceIoControl.InputBufferLength == 0);
                ASSERT(!irpSp->Parameters.DeviceIoControl.Type3InputBuffer);

                irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_HID_GET_DEVICE_ATTRIBUTES;

                irp->UserBuffer = &fdoExtension->hidDeviceAttributes;
                irpSp->Parameters.DeviceIoControl.OutputBufferLength = sizeof(HID_DEVICE_ATTRIBUTES);

                status = HidpCallDriverSynchronous(fdoExtension->fdo, irp);
                DBGASSERT((status == STATUS_SUCCESS),
                          ("STATUS_SUCCESS not returned, %x returned",status),
                          TRUE)

                if (NT_SUCCESS (status)) {
                    
                    /*
                     *  We've got a hid descriptor, now we need to read the report descriptor.
                     *
                     *  Find the descriptor describing the report.
                     */
                    rawReportDescriptorLength = 0;

                    /*
                     * We currently don't support Physical descriptors, and have never
                     * seen a device that implements them, so we only get the report descriptor
                     * which MUST be the first descriptor.  If physical descriptors are
                     * to be supported, must realloc the hidDescriptor to hold the data
                     * for the other descriptors and iterate over the descritpors.
                     */
                    if (hidDescriptor->DescriptorList[0].bReportType == HID_REPORT_DESCRIPTOR_TYPE){
                        rawReportDescriptorLength = (ULONG)hidDescriptor->DescriptorList[0].wReportLength;
                        status = GetHIDRawReportDescriptor(fdoExtension, irp, rawReportDescriptorLength);
                    }
                    else {
                        status = STATUS_DEVICE_DATA_ERROR;
                    }
                  
                }
                else {
                    status = STATUS_DEVICE_DATA_ERROR;
                }
            }
            else {
                status = STATUS_DEVICE_DATA_ERROR;
            }
        }
        else {
            status = STATUS_DEVICE_DATA_ERROR;
        }

        IoFreeIrp(irp);
    }
    else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    DBGSUCCESS(status, FALSE)
    return status;
}



/*
 ********************************************************************************
 *  HidpCreateSymbolicLink
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpCreateSymbolicLink(
    IN PDO_EXTENSION *pdoExt,
    IN ULONG collectionNum,
    IN BOOLEAN Create,
    IN PDEVICE_OBJECT Pdo
    )
{
    NTSTATUS status;
    PHIDCLASS_COLLECTION classCollection;

    PAGED_CODE();

    classCollection = GetHidclassCollection(&pdoExt->deviceFdoExt->fdoExt, collectionNum);
    if (classCollection){
        //
        // We've got a collection.  Figure out what it is and create a symbolic
        // link for it.  For now we assign the "input" guid to all hid devices.
        // The reference string is simply the collection number, zero-padded
        // to eight digits.
        //
        if (Create){

            /*
             *  Mark the PDO as initialized
             */
            Pdo->Flags |= DO_DIRECT_IO;
            Pdo->Flags &= ~DO_DEVICE_INITIALIZING;

            /*
             *  Create the symbolic link
             */
            status = IoRegisterDeviceInterface(
                        Pdo,
                        (LPGUID)&GUID_CLASS_INPUT,
                        NULL,
                        &classCollection->SymbolicLinkName );
            if (NT_SUCCESS(status)){

                /*
                 *  Now set the symbolic link for the association and store it..
                 */
                ASSERT(ISPTR(pdoExt->name));

                status = IoSetDeviceInterfaceState(&classCollection->SymbolicLinkName, TRUE);
            }
        }
        else {

            /*
             *  Disable the symbolic link
             */
            if (ISPTR(classCollection->SymbolicLinkName.Buffer)){
                status = IoSetDeviceInterfaceState(&classCollection->SymbolicLinkName, FALSE);
                ExFreePool( classCollection->SymbolicLinkName.Buffer );
                classCollection->SymbolicLinkName.Buffer = BAD_POINTER;
            }
            else {
                status = STATUS_SUCCESS;
            }
        }
    }
    else {
        status = STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    DBGSUCCESS(status, TRUE)
    return status;
}





/*
 ********************************************************************************
 *  EnqueueInterruptReport
 ********************************************************************************
 *
 *
 */
VOID EnqueueInterruptReport(PHIDCLASS_FILE_EXTENSION fileExtension,
                            PHIDCLASS_REPORT report)
{
    PHIDCLASS_REPORT reportToDrop = NULL;

    RUNNING_DISPATCH();

    /*
     *  If the queue is full, drop the oldest report.
     */
    if (fileExtension->CurrentInputReportQueueSize >= fileExtension->MaximumInputReportQueueSize){
        PLIST_ENTRY listEntry;

        #if DBG
            if (fileExtension->dbgNumReportsDroppedSinceLastRead++ == 0){
                DBGWARN(("HIDCLASS dropping input reports because report queue (size %xh) is full ...", fileExtension->MaximumInputReportQueueSize))
                DBGASSERT((fileExtension->CurrentInputReportQueueSize == fileExtension->MaximumInputReportQueueSize),
                          ("Current report queue size (%xh) is greater than maximum (%xh)",
                           fileExtension->CurrentInputReportQueueSize,
                           fileExtension->MaximumInputReportQueueSize),
                          FALSE);
            }
        #endif

        ASSERT(!IsListEmpty(&fileExtension->ReportList));

        listEntry = RemoveHeadList(&fileExtension->ReportList);
        reportToDrop = CONTAINING_RECORD(listEntry, HIDCLASS_REPORT, ListEntry);
        fileExtension->CurrentInputReportQueueSize--;
    }

    /*
     *  Now queue the current report
     */
    InsertTailList(&fileExtension->ReportList, &report->ListEntry);
    fileExtension->CurrentInputReportQueueSize++;

    /*
     *  We don't have to be running < DPC_LEVEL to release reports since they
     * are allocated using NonPagePool.
     */
    if (reportToDrop){
        ExFreePool(reportToDrop);
    }

}



/*
 ********************************************************************************
 *  DequeueInterruptReport
 ********************************************************************************
 *
 *      Return the next interrupt report in the queue.
 *      If maxLen is not -1, then only return the report if it is <= maxlen.
 */
PHIDCLASS_REPORT DequeueInterruptReport(PHIDCLASS_FILE_EXTENSION fileExtension,
                                        LONG maxLen)
{
    PHIDCLASS_REPORT report;

    RUNNING_DISPATCH();

    if (IsListEmpty(&fileExtension->ReportList)){
        report = NULL;
    }
    else {
        PLIST_ENTRY listEntry = RemoveHeadList(&fileExtension->ReportList);
        report = CONTAINING_RECORD(listEntry, HIDCLASS_REPORT, ListEntry);

        if ((maxLen > 0) && (report->reportLength > (ULONG)maxLen)){
            /*
             *  This report is too big for the caller.
             *  So put the report back in the queue and return NULL.
             */
            InsertHeadList(&fileExtension->ReportList, &report->ListEntry);
            report = NULL;
        }
        else {
            InitializeListHead(&report->ListEntry);
            ASSERT(fileExtension->CurrentInputReportQueueSize > 0);
            fileExtension->CurrentInputReportQueueSize--;

            #if DBG
                if (fileExtension->dbgNumReportsDroppedSinceLastRead > 0){
                    DBGWARN(("... successful read(/flush) after %d reports were dropped.", fileExtension->dbgNumReportsDroppedSinceLastRead));
                    fileExtension->dbgNumReportsDroppedSinceLastRead = 0;
                }
            #endif
        }
    }

    return report;
}



/*
 ********************************************************************************
 *  HidpDestroyFileExtension
 ********************************************************************************
 *
 *
 */
VOID HidpDestroyFileExtension(PHIDCLASS_COLLECTION collection, PHIDCLASS_FILE_EXTENSION FileExtension)
{
    PFILE_OBJECT fileObject;

    //
    // Flush all of the pending reports on the file extension
    //
    HidpFlushReportQueue(FileExtension);

    /*
     *  Fail all the pending reads
     *  (it would be nice if apps always cancelled all their reads
     *   before closing the device, but this is not always the case).
     */
    CompleteAllPendingReadsForFileExtension(collection, FileExtension);


    //
    // Indicate in the file object that this file extension has gone away.
    //

    fileObject = FileExtension->FileObject;
    #if DBG
        fileObject->FsContext = NULL;
    #endif

    //
    // Free our extension
    //
    #if DBG
        FileExtension->Signature = ~HIDCLASS_FILE_EXTENSION_SIG;
    #endif
    ExFreePool( FileExtension );
}



/*
 ********************************************************************************
 *  HidpFlushReportQueue
 ********************************************************************************
 *
 *
 */
VOID HidpFlushReportQueue(IN PHIDCLASS_FILE_EXTENSION fileExtension)
{
    PHIDCLASS_REPORT report;
    KIRQL oldIrql;

    LockFileExtension(fileExtension, &oldIrql);
    while (report = DequeueInterruptReport(fileExtension, -1)){
        //
        // Ok to call this at DISPATCH_LEVEL, since report is NonPagedPool
        //
        ExFreePool(report);
    }
    UnlockFileExtension(fileExtension, oldIrql);
}



/*
 ********************************************************************************
 *  HidpGetCollectionInformation
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpGetCollectionInformation(
    IN FDO_EXTENSION *fdoExtension,
    IN ULONG collectionNumber,
    IN PVOID Buffer,
    IN OUT PULONG BufferSize
    )
{
    HID_COLLECTION_INFORMATION  hidCollectionInfo;
    PHIDP_COLLECTION_DESC       hidCollectionDesc;
    ULONG                       bytesToCopy;
    NTSTATUS                    status;


    /*
     *  Get a pointer to the appropriate collection descriptor.
     */
    hidCollectionDesc = GetCollectionDesc(fdoExtension, collectionNumber);
    if (hidCollectionDesc){
        //
        // Fill in hidCollectionInfo
        //
        hidCollectionInfo.DescriptorSize = hidCollectionDesc->PreparsedDataLength;

        hidCollectionInfo.Polled = fdoExtension->driverExt->DevicesArePolled;

        hidCollectionInfo.VendorID = fdoExtension->hidDeviceAttributes.VendorID;
        hidCollectionInfo.ProductID = fdoExtension->hidDeviceAttributes.ProductID;
        hidCollectionInfo.VersionNumber = fdoExtension->hidDeviceAttributes.VersionNumber;

        //
        // Copy as much of hidCollectionInfo as will fit in the output buffer.
        //
        if (*BufferSize < sizeof( HID_COLLECTION_INFORMATION)){
            /*
             *  The user's buffer is not big enough.
             *  We'll return the size that the buffer needs to be.
             *  Must return this with a real error code (not a warning)
             *  so that IO post-processing does not copy into (and past)
             *  the user's buffer.
             */
            bytesToCopy = *BufferSize;
            status = STATUS_INVALID_BUFFER_SIZE;
        }
        else {
            bytesToCopy = sizeof( HID_COLLECTION_INFORMATION );
            status = STATUS_SUCCESS;
        }

        RtlCopyMemory(Buffer, &hidCollectionInfo, bytesToCopy);
        *BufferSize = sizeof (HID_COLLECTION_INFORMATION);
    }
    else {
        status = STATUS_DATA_ERROR;
    }

    DBGSUCCESS(status, FALSE)
    return status;
}


/*
 ********************************************************************************
 *  HidpGetCollectionDescriptor
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpGetCollectionDescriptor(   IN FDO_EXTENSION *fdoExtension,
                                        IN ULONG collectionId,
                                        IN PVOID Buffer,
                                        IN OUT PULONG BufferSize)
{
    PHIDP_COLLECTION_DESC       hidCollectionDesc;
    ULONG                       bytesToCopy;
    NTSTATUS                    status;

    hidCollectionDesc = GetCollectionDesc(fdoExtension, collectionId);
    if (hidCollectionDesc){

        /*
         *  Copy as much of the preparsed data as will fit in the output buffer.
         */
        if (*BufferSize < hidCollectionDesc->PreparsedDataLength){
            /*
             *  The user's buffer is not big enough for all the
             *  preparsed data.
             *  We'll return the size that the buffer needs to be.
             *  Must return this with a real error code (not a warning)
             *  so that IO post-processing does not copy into (and past)
             *  the user's buffer.
             */
            bytesToCopy = *BufferSize;
            status = STATUS_INVALID_BUFFER_SIZE;
        }
        else {
            bytesToCopy = hidCollectionDesc->PreparsedDataLength;
            status = STATUS_SUCCESS;
        }

        RtlCopyMemory(Buffer, hidCollectionDesc->PreparsedData, bytesToCopy);
        *BufferSize = hidCollectionDesc->PreparsedDataLength;
    }
    else {
        status = STATUS_DATA_ERROR;
    }

    DBGSUCCESS(status, FALSE)
    return status;
}



/*
 ********************************************************************************
 *  GetReportIdentifier
 ********************************************************************************
 *
 *
 */
PHIDP_REPORT_IDS GetReportIdentifier(FDO_EXTENSION *fdoExtension, ULONG reportId)
{
    PHIDP_REPORT_IDS result = NULL;
    PHIDP_DEVICE_DESC deviceDesc = &fdoExtension->deviceDesc;
    ULONG i;

    if (deviceDesc->ReportIDs){
        for (i = 0; i < deviceDesc->ReportIDsLength; i++){
            if (deviceDesc->ReportIDs[i].ReportID == reportId){
                result = &deviceDesc->ReportIDs[i];
                break;
            }
        }
    }

    DBGASSERT(result, ("Bogus report identifier requested %d", reportId), FALSE)

    return result;
}


/*
 ********************************************************************************
 *  GetCollectionDesc
 ********************************************************************************
 *
 *
 */
PHIDP_COLLECTION_DESC GetCollectionDesc(FDO_EXTENSION *fdoExtension, ULONG collectionId)
{
    PHIDP_COLLECTION_DESC result = NULL;
    PHIDP_DEVICE_DESC deviceDesc = &fdoExtension->deviceDesc;
    ULONG i;

    if (deviceDesc->CollectionDesc){
        for (i = 0; i < deviceDesc->CollectionDescLength; i++){
            if (deviceDesc->CollectionDesc[i].CollectionNumber == collectionId){
                result = &deviceDesc->CollectionDesc[i];
                break;
            }
        }
    }

    ASSERT(result);
    return result;
}

/*
 ********************************************************************************
 *  GetHidclassCollection
 ********************************************************************************
 *
 */
PHIDCLASS_COLLECTION GetHidclassCollection(FDO_EXTENSION *fdoExtension, ULONG collectionId)
{
    PHIDCLASS_COLLECTION result = NULL;
    PHIDP_DEVICE_DESC deviceDesc = &fdoExtension->deviceDesc;
    ULONG i;

    if (ISPTR(fdoExtension->classCollectionArray)){
        for (i = 0; i < deviceDesc->CollectionDescLength; i++){
            if (fdoExtension->classCollectionArray[i].CollectionNumber == collectionId){
                result = &fdoExtension->classCollectionArray[i];
                break;
            }
        }
    }

    return result;
}


/*
 ********************************************************************************
 *  MakeClientPDOName
 ********************************************************************************
 *
 *
 */
PUNICODE_STRING MakeClientPDOName(PUNICODE_STRING fdoName, ULONG collectionId)
{
    PUNICODE_STRING uPdoName;

    PAGED_CODE();

    uPdoName = (PUNICODE_STRING)ALLOCATEPOOL(NonPagedPool, sizeof(UNICODE_STRING));
    if (uPdoName){
        PWSTR wPdoName;

        wPdoName = (PWSTR)ALLOCATEPOOL(
                    PagedPool,
                    fdoName->Length+sizeof(L"#COLLECTION0000000x"));
        if (wPdoName){
            StringCchPrintfW(wPdoName,
                             fdoName->Length+sizeof(L"#COLLECTION0000000x"),
                             L"%s#COLLECTION%08x", 
                             fdoName->Buffer, 
                             collectionId);
            RtlInitUnicodeString(uPdoName, wPdoName);
        }
        else {
            ExFreePool(uPdoName);
            uPdoName = NULL;
        }
    }

    return uPdoName;
}


/*
 ********************************************************************************
 *  HidpCreateClientPDOs
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpCreateClientPDOs(PHIDCLASS_DEVICE_EXTENSION hidClassExtension)
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PHIDCLASS_DRIVER_EXTENSION  hidDriverExtension;
    FDO_EXTENSION *fdoExt;

    PAGED_CODE();

    ASSERT(!hidClassExtension->isClientPdo);

    fdoExt = &hidClassExtension->fdoExt;

    hidDriverExtension = RefDriverExt(fdoExt->driverExt->MinidriverObject);
    if (hidDriverExtension){

        /*
         *  We will create one PDO for each collection on this device.
         */
        ULONG numPDOs = fdoExt->deviceDesc.CollectionDescLength;

        if (numPDOs){

            if (!ISPTR(fdoExt->deviceRelations)) {
                fdoExt->deviceRelations = (PDEVICE_RELATIONS)
                    ALLOCATEPOOL(NonPagedPool, sizeof(DEVICE_RELATIONS) + (numPDOs*sizeof(PDEVICE_OBJECT)));
            }

            if (fdoExt->deviceRelations){

                if (!ISPTR(fdoExt->collectionPdoExtensions)) {
                    fdoExt->collectionPdoExtensions =
                        ALLOCATEPOOL(NonPagedPool, numPDOs*sizeof(PHIDCLASS_DEVICE_EXTENSION));

                }

                if (fdoExt->collectionPdoExtensions){

                    ULONG i;

                    fdoExt->deviceRelations->Count = numPDOs;

                    for (i = 0; i < numPDOs; i++){
                        PUNICODE_STRING uPdoName;
                        ULONG           totalExtensionSize;
                        ULONG collectionNum = fdoExt->deviceDesc.CollectionDesc[i].CollectionNumber;
                        PDEVICE_OBJECT  newClientPdo;

                        /*
                         *  Construct a name for the PDO we're about to create.
                         */
                        uPdoName = MakeClientPDOName(&fdoExt->name, collectionNum);
                        if (uPdoName){
                            /*
                             *  We use the same device extension for the client PDOs as for our FDO.
                             */
                            totalExtensionSize = sizeof(HIDCLASS_DEVICE_EXTENSION) +
                                             hidDriverExtension->DeviceExtensionSize;

                            /*
                             *  Create a PDO to represent this collection.
                             *  Since hidclass is not a real driver, it does not have a driver object;
                             *  so just use the minidriver's driver object.
                             *
                             *  NOTE - newClientPdo->NextDevice will point to this minidriver's NextDevice
                             */
                            ntStatus = IoCreateDevice(  hidDriverExtension->MinidriverObject, // driver object
                                                        totalExtensionSize,     // extension size
                                                        NULL,                   // name of the PDO
                                                        FILE_DEVICE_UNKNOWN,    // Device type
                                                        FILE_AUTOGENERATED_DEVICE_NAME, // DeviceCharacteristics
                                                        FALSE,                  // not exclusive
                                                        &newClientPdo);
                            if (NT_SUCCESS(ntStatus)){
                                PHIDCLASS_DEVICE_EXTENSION clientPdoExtension = newClientPdo->DeviceExtension;
                                USHORT usagePage = fdoExt->deviceDesc.CollectionDesc[i].UsagePage;
                                USHORT usage = fdoExt->deviceDesc.CollectionDesc[i].Usage;

                                DBG_RECORD_DEVOBJ(newClientPdo, "cltn PDO")

                                ObReferenceObject(newClientPdo);

                                /*
                                 *  We may pass Irps from the upper stack to the lower stack,
                                 *  so make sure there are enough stack locations for the IRPs
                                 *  we pass down.
                                 */
                                newClientPdo->StackSize = fdoExt->fdo->StackSize+1;


                                /*
                                 *  Initialize the PDO's extension
                                 */
                                RtlZeroMemory(clientPdoExtension, totalExtensionSize);

                                clientPdoExtension->hidExt = hidClassExtension->hidExt;
                                clientPdoExtension->isClientPdo = TRUE;
                                clientPdoExtension->Signature = HID_DEVICE_EXTENSION_SIG;

                                clientPdoExtension->pdoExt.collectionNum = collectionNum;
                                clientPdoExtension->pdoExt.collectionIndex = i;
                                clientPdoExtension->pdoExt.pdo = newClientPdo;
                                clientPdoExtension->pdoExt.state = COLLECTION_STATE_UNINITIALIZED;
                                clientPdoExtension->pdoExt.deviceFdoExt = hidClassExtension;
                                clientPdoExtension->pdoExt.StatusChangeFn = BAD_POINTER;

                                clientPdoExtension->pdoExt.name = uPdoName;

                                clientPdoExtension->pdoExt.devicePowerState = PowerDeviceD0;
                                clientPdoExtension->pdoExt.systemPowerState = fdoExt->systemPowerState;
                                clientPdoExtension->pdoExt.MouseOrKeyboard =
                                    ((usagePage == HID_USAGE_PAGE_GENERIC) &&
                                     ((usage == HID_USAGE_GENERIC_POINTER) ||
                                      (usage == HID_USAGE_GENERIC_MOUSE) ||
                                      (usage == HID_USAGE_GENERIC_KEYBOARD) ||
                                      (usage == HID_USAGE_GENERIC_KEYPAD)));

                                IoInitializeRemoveLock (&clientPdoExtension->pdoExt.removeLock, HIDCLASS_POOL_TAG, 0, 10);
                                KeInitializeSpinLock (&clientPdoExtension->pdoExt.remoteWakeSpinLock);
                                clientPdoExtension->pdoExt.remoteWakeIrp = NULL;

                                /*
                                 *  Store a pointer to the new PDO in the FDO extension's deviceRelations array.
                                 */
                                fdoExt->deviceRelations->Objects[i] = newClientPdo;

                                /*
                                 *  Store a pointer to the PDO's extension.
                                 */
                                fdoExt->collectionPdoExtensions[i] = clientPdoExtension;

                                newClientPdo->Flags |= DO_POWER_PAGABLE;
                                newClientPdo->Flags &= ~DO_DEVICE_INITIALIZING;
                            }
                            else {
                                break;
                            }
                        }
                        else {
                            ntStatus = STATUS_NO_MEMORY;
                        }
                    }

                    if (!NT_SUCCESS(ntStatus)){
                        ExFreePool(fdoExt->collectionPdoExtensions);
                        fdoExt->collectionPdoExtensions = BAD_POINTER;
                    }
                }
                else {
                    ntStatus = STATUS_NO_MEMORY;
                }

                if (!NT_SUCCESS(ntStatus)){
                    ExFreePool(fdoExt->deviceRelations);
                    fdoExt->deviceRelations = BAD_POINTER;
                }
            }
            else {
                ntStatus = STATUS_NO_MEMORY;
            }
        }
        else {
            ASSERT(numPDOs);
            ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
        }
        DerefDriverExt(fdoExt->driverExt->MinidriverObject);
    }
    else {
        ASSERT(hidDriverExtension);
        ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    DBGSUCCESS(ntStatus, TRUE)
    return ntStatus;
}


/*
 ********************************************************************************
 *  MemDup
 ********************************************************************************
 *
 *  Return a fresh copy of the argument.
 *
 */
PVOID MemDup(POOL_TYPE PoolType, PVOID dataPtr, ULONG length)
{
    PVOID newPtr;

    newPtr = (PVOID)ALLOCATEPOOL(PoolType, length);
    if (newPtr){
        RtlCopyMemory(newPtr, dataPtr, length);
    }

    ASSERT(newPtr);
    return newPtr;
}

/*
 ********************************************************************************
 *  WStrLen
 ********************************************************************************
 *
 */
ULONG WStrLen(PWCHAR str)
{
    ULONG result = 0;

    while (*str++ != UNICODE_NULL){
        result++;
    }

    return result;
}


/*
 ********************************************************************************
 *  WStrCpy
 ********************************************************************************
 *
 */
ULONG WStrCpy(PWCHAR dest, PWCHAR src)
{
    ULONG result = 0;

    while (*dest++ = *src++){
        result++;
    }

    return result;
}

BOOLEAN WStrCompareN(PWCHAR str1, PWCHAR str2, ULONG maxChars)
{
        while ((maxChars > 0) && *str1 && (*str1 == *str2)){
                maxChars--;
                str1++;
                str2++;
        }

        return (BOOLEAN)((maxChars == 0) || (!*str1 && !*str2));
}

/*
 ********************************************************************************
 *  HidpNumberToString
 ********************************************************************************
 *
 */
void HidpNumberToString(PWCHAR String, USHORT Number, USHORT stringLen)
{
    const static WCHAR map[] = L"0123456789ABCDEF";
    LONG         i      = 0;
    ULONG        nibble = 0;

    ASSERT(stringLen);

    for (i = stringLen-1; i >= 0; i--) {
        String[i] = map[Number & 0x0F];
        Number >>= 4;
    }
}


/*
 ********************************************************************************
 *  CopyDeviceRelations
 ********************************************************************************
 *
 *
 */
PDEVICE_RELATIONS CopyDeviceRelations(PDEVICE_RELATIONS deviceRelations)
{
    PDEVICE_RELATIONS newDeviceRelations;

    if (deviceRelations){
        ULONG size = sizeof(DEVICE_RELATIONS) + (deviceRelations->Count*sizeof(PDEVICE_OBJECT));
        newDeviceRelations = MemDup(PagedPool, deviceRelations, size);
    }
    else {
        newDeviceRelations = NULL;
    }

    return newDeviceRelations;
}


/*
 ********************************************************************************
 *  HidpQueryDeviceRelations
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpQueryDeviceRelations(IN PHIDCLASS_DEVICE_EXTENSION hidClassExtension, IN OUT PIRP Irp)
{
    PIO_STACK_LOCATION ioStack;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    KIRQL irql;

    ASSERT(!hidClassExtension->isClientPdo);

    ioStack = IoGetCurrentIrpStackLocation(Irp);

    if (ioStack->Parameters.QueryDeviceRelations.Type == BusRelations) {

        if (ISPTR(hidClassExtension->fdoExt.deviceRelations)){
            /*
             *  Don't call HidpCreateClientPDOs again if it's
             *  already been called for this device.
             */
            ntStatus = STATUS_SUCCESS;
        }
        else {

            ntStatus = HidpCreateClientPDOs(hidClassExtension);
        }

        if (NT_SUCCESS(ntStatus)){
            ULONG i;

            KeAcquireSpinLock(&hidClassExtension->fdoExt.presentSpinLock,
                              &irql);

            /*
             *  NTKERN expects a new pointer each time it calls QUERY_DEVICE_RELATIONS;
             *  it then FREES THE POINTER.
             *  So we have to return a new pointer each time, whether or not we actually
             *  created our copy of the device relations for this call.
             */

            if (!hidClassExtension->fdoExt.isPresent) {
                
                hidClassExtension->fdoExt.presentReported = FALSE;

                KeReleaseSpinLock(&hidClassExtension->fdoExt.presentSpinLock,
                                  irql);

                Irp->IoStatus.Information = (ULONG_PTR)ExAllocatePool(PagedPool, sizeof(DEVICE_RELATIONS));
                
                if (Irp->IoStatus.Information) {
                    PHIDCLASS_DEVICE_EXTENSION clientPdoExtension;
                
                    if (ISPTR(hidClassExtension->fdoExt.deviceRelations)) {
                        ExFreePool(hidClassExtension->fdoExt.deviceRelations);                             
                    }

                    hidClassExtension->fdoExt.deviceRelations = BAD_POINTER;
                    
                    ((PDEVICE_RELATIONS) (Irp->IoStatus.Information))->Count = 0;
                    ((PDEVICE_RELATIONS) (Irp->IoStatus.Information))->Objects[0] = NULL;
                                         
                } 
                
            } else {
            
                hidClassExtension->fdoExt.presentReported = TRUE;
                KeReleaseSpinLock(&hidClassExtension->fdoExt.presentSpinLock,
                                  irql);

                Irp->IoStatus.Information = (ULONG_PTR)CopyDeviceRelations(hidClassExtension->fdoExt.deviceRelations);

                if (Irp->IoStatus.Information) {

                    /*
                     *  PnP dereferences each device object
                     *  in the device relations list after each call.
                     *  So for each call, add an extra reference.
                     */
                    for (i = 0; i < hidClassExtension->fdoExt.deviceRelations->Count; i++){
                        ObReferenceObject(hidClassExtension->fdoExt.deviceRelations->Objects[i]);
                        hidClassExtension->fdoExt.deviceRelations->Objects[i]->Flags &= ~DO_DEVICE_INITIALIZING;
                    }

                }
            }

            if (!Irp->IoStatus.Information){
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
                
        }

        DBGSUCCESS(ntStatus, TRUE)
    }
    else {
        /*
         *  We don't support this option, so just maintain
         *  the current status (do not return STATUS_NOT_SUPPORTED).
         */
        ntStatus = Irp->IoStatus.Status;
    }

    return ntStatus;
}



/*
 ********************************************************************************
 *  HidpQueryCollectionCapabilities
 ********************************************************************************
 *
 *
 */
NTSTATUS HidpQueryCollectionCapabilities(   PDO_EXTENSION *pdoExt,
                                            IN OUT PIRP Irp)
{
    PDEVICE_CAPABILITIES deviceCapabilities;
    PIO_STACK_LOCATION ioStack;
    FDO_EXTENSION *fdoExt;
    NTSTATUS status;

    PAGED_CODE();

    ASSERT(pdoExt->deviceFdoExt->Signature == HID_DEVICE_EXTENSION_SIG);
    fdoExt = &pdoExt->deviceFdoExt->fdoExt;
    ioStack = IoGetCurrentIrpStackLocation(Irp);

    deviceCapabilities = ioStack->Parameters.DeviceCapabilities.Capabilities;
    if (deviceCapabilities){

        /*
         *  Set all fields for the collection-PDO as for the device-FDO
         *  by default.
         */
        *deviceCapabilities = fdoExt->deviceCapabilities;

        /*
         *  Now override the fields we care about.
         */
        deviceCapabilities->LockSupported = FALSE;
        deviceCapabilities->EjectSupported = FALSE;
        deviceCapabilities->Removable = FALSE;
        deviceCapabilities->DockDevice = FALSE;
        deviceCapabilities->UniqueID = FALSE;
        deviceCapabilities->SilentInstall = TRUE;

        /*
         *  This field is very important;
         *  it causes HIDCLASS to get the START_DEVICE IRP immediately,
         *  if the device is not a keyboard or mouse.
         */
        deviceCapabilities->RawDeviceOK = !pdoExt->MouseOrKeyboard;

        /*
         *  This bit indicates that the device may be removed on NT
         *  without running the 'hot-unplug' utility.
         */
        deviceCapabilities->SurpriseRemovalOK = TRUE;

        DBGVERBOSE(("WAKE info: sysWake=%d devWake=%d; wake from D0=%d D1=%d D2=%d D3=%d.",
                    deviceCapabilities->SystemWake,
                    deviceCapabilities->DeviceWake,
                    (ULONG)deviceCapabilities->WakeFromD0,
                    (ULONG)deviceCapabilities->WakeFromD1,
                    (ULONG)deviceCapabilities->WakeFromD2,
                    (ULONG)deviceCapabilities->WakeFromD3))

        status = STATUS_SUCCESS;
    }
    else {
        status = STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    Irp->IoStatus.Information = (ULONG_PTR)deviceCapabilities;

    DBGSUCCESS(status, TRUE)
    return status;
}



/*
 ********************************************************************************
 *  BuildCompatibleID
 ********************************************************************************
 *
 *  Return a multi-string consisting of compatibility id's for this device
 *  in increasingly generic order (ending with HID_GENERIC_DEVICE).
 *
 *  author: kenray
 *
 */
PWSTR BuildCompatibleID(PHIDCLASS_DEVICE_EXTENSION hidClassExtension)
{
    USHORT usage, usagePage;
    ULONG spLength;
    ULONG totLength;
    ULONG i;
    PWSTR specificId = NULL;
    PWSTR compatIdList;
    PWSTR genericId;
    FDO_EXTENSION *fdoExt;

    PAGED_CODE();

    ASSERT(hidClassExtension->isClientPdo);
    fdoExt = &hidClassExtension->pdoExt.deviceFdoExt->fdoExt;

    ASSERT(ISPTR(fdoExt->deviceDesc.CollectionDesc));

    i = hidClassExtension->pdoExt.collectionIndex;
    usagePage = fdoExt->deviceDesc.CollectionDesc[i].UsagePage;
    usage = fdoExt->deviceDesc.CollectionDesc[i].Usage;


    switch (usagePage) {
    case HID_USAGE_PAGE_GENERIC:
        switch (usage) {
        case HID_USAGE_GENERIC_POINTER:
        case HID_USAGE_GENERIC_MOUSE:
            specificId = HIDCLASS_SYSTEM_MOUSE;
            break;
        case HID_USAGE_GENERIC_KEYBOARD:
        case HID_USAGE_GENERIC_KEYPAD:
            specificId = HIDCLASS_SYSTEM_KEYBOARD;
            break;
        case HID_USAGE_GENERIC_JOYSTICK:
        case HID_USAGE_GENERIC_GAMEPAD:
            specificId = HIDCLASS_SYSTEM_GAMING_DEVICE;
            break;
        case HID_USAGE_GENERIC_SYSTEM_CTL:
            specificId = HIDCLASS_SYSTEM_CONTROL;
            break;
        }
        break;

    case HID_USAGE_PAGE_CONSUMER:
        specificId = HIDCLASS_SYSTEM_CONSUMER_DEVICE;
        break;

    default:
        break;
    }

    spLength = (specificId) ? (WStrLen(specificId)+1) : 0;

    totLength = spLength +
                HIDCLASS_COMPATIBLE_ID_GENERIC_LENGTH +
                HIDCLASS_COMPATIBLE_ID_STANDARD_LENGTH +
                1;

    compatIdList = ALLOCATEPOOL(NonPagedPool, totLength * sizeof(WCHAR));
    if (compatIdList) {

        RtlZeroMemory (compatIdList, totLength * sizeof(WCHAR));
        if (specificId) {
            RtlCopyMemory (compatIdList, specificId, spLength * sizeof (WCHAR));
        }

        genericId = compatIdList + spLength;
        totLength = HIDCLASS_COMPATIBLE_ID_GENERIC_LENGTH;
        RtlCopyMemory (genericId,
                       HIDCLASS_COMPATIBLE_ID_GENERIC_NAME,
                       totLength*sizeof(WCHAR));

        HidpNumberToString (genericId + HIDCLASS_COMPATIBLE_ID_PAGE_OFFSET,
                            usagePage,
                            4);

        HidpNumberToString (genericId + HIDCLASS_COMPATIBLE_ID_USAGE_OFFSET,
                            usage,
                            4);

        RtlCopyMemory (genericId + totLength,
                       HIDCLASS_COMPATIBLE_ID_STANDARD_NAME,
                       HIDCLASS_COMPATIBLE_ID_STANDARD_LENGTH * sizeof (WCHAR));
    }

    return compatIdList;
}


/*
 ********************************************************************************
 *  SubstituteBusNames
 ********************************************************************************
 *
 *  oldIDs is a multi-String of hardware IDs.
 *
 *  1. Return a new string with each "<busName>\" prefix replaced by "HID\".
 *
 *  2. If the device has multiple collections, append "&Colxx" to each id.
 *
 */
PWCHAR SubstituteBusNames(PWCHAR oldIDs, FDO_EXTENSION *fdoExt, PDO_EXTENSION *pdoExt)
{
    ULONG newIdLen;
    PWCHAR id, newIDs;
    ULONG numCollections;
    WCHAR colNumStr[] = L"&Colxx";

    PAGED_CODE();

    numCollections = fdoExt->deviceDesc.CollectionDescLength;
    ASSERT(numCollections > 0);

    for (id = oldIDs, newIdLen = 0; *id; ){
        ULONG thisIdLen = WStrLen(id);

        /*
         *  This is a little sloppy because we're actually going to chop
         *  off the other bus name; but better this than walking each string.
         */
        newIdLen += thisIdLen + 1 + sizeof("HID\\");

        if (numCollections > 1){
            newIdLen += sizeof(colNumStr)/sizeof(WCHAR);
        }

        id += thisIdLen + 1;
    }

    /*
     *  Add one for the extra NULL at the end of the multi-string.
     */
    newIdLen++;

    newIDs = ALLOCATEPOOL(NonPagedPool, newIdLen*sizeof(WCHAR));
    if (newIDs){
        ULONG oldIdOff, newIdOff;

        /*
         *  Copy each string in the multi-string, replacing the bus name.
         */
        for (oldIdOff = newIdOff = 0; oldIDs[oldIdOff]; ){
            ULONG thisIdLen = WStrLen(oldIDs+oldIdOff);
            ULONG devIdOff;

            /*
             *  Copy the new bus name to the new string.
             */
            newIdOff += WStrCpy(newIDs+newIdOff, L"HID\\");

            /*
             *  Go past the old bus name in the old string.
             */
            for (devIdOff = 0; oldIDs[oldIdOff+devIdOff]; devIdOff++){
                if (oldIDs[oldIdOff+devIdOff] == L'\\'){
                    break;
                }
            }

            /*
             *  Copy the rest of this device id.
             */
            if (oldIDs[oldIdOff+devIdOff] == L'\\'){
                devIdOff++;
            }
            else {
                /*
                 *  Strange -- no bus name in hardware id.
                 *             Just copy the entire id.
                 */
                devIdOff = 0;
            }
            newIdOff += WStrCpy(newIDs+newIdOff, oldIDs+oldIdOff+devIdOff);

            if (numCollections > 1){
                /*
                 *  If there is more than one collection,
                 *  then also append the collection number.
                 */
                HidpNumberToString(colNumStr+4, (USHORT)pdoExt->collectionNum, 2);
                newIdOff += WStrCpy(newIDs+newIdOff, colNumStr);
            }

            /*
             *  Go past the single string terminator.
             */
            newIdOff++;

            oldIdOff += thisIdLen + 1;
        }

        /*
         *  Add extra NULL to terminate multi-string.
         */
        newIDs[newIdOff] = UNICODE_NULL;
    }

    return newIDs;
}

NTSTATUS
HidpQueryInterface(
    IN PHIDCLASS_DEVICE_EXTENSION hidClassExtension,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION  irpSp;

    PAGED_CODE();

    ASSERT(hidClassExtension->isClientPdo);
    irpSp = IoGetCurrentIrpStackLocation(Irp);

    if (RtlEqualMemory(irpSp->Parameters.QueryInterface.InterfaceType,
                       &GUID_HID_INTERFACE_NOTIFY,
                       sizeof(GUID))) {
        PDO_EXTENSION       *pdoExt;
        PHID_INTERFACE_NOTIFY_PNP notify;

        notify = (PHID_INTERFACE_NOTIFY_PNP) irpSp->Parameters.QueryInterface.Interface;
        if (notify->Size != sizeof(HID_INTERFACE_NOTIFY_PNP) ||
            notify->Version < 1 ||
            notify->StatusChangeFn == NULL) {
            //
            // return STATUS_UNSUPPORTED probably
            //
            return Irp->IoStatus.Status;
        }

        pdoExt = &hidClassExtension->pdoExt;

        pdoExt->StatusChangeFn = notify->StatusChangeFn;
        pdoExt->StatusChangeContext = notify->CallbackContext;
        return STATUS_SUCCESS;
    }
    else if (RtlEqualMemory(irpSp->Parameters.QueryInterface.InterfaceType,
                       &GUID_HID_INTERFACE_HIDPARSE,
                       sizeof(GUID))) {
        //
        // Required for Generic Input, to remove the direct link
        // b/w win32k and hidparse.
        //
        PHID_INTERFACE_HIDPARSE hidparse;

        hidparse = (PHID_INTERFACE_HIDPARSE) irpSp->Parameters.QueryInterface.Interface;
        if (hidparse->Size != sizeof(HID_INTERFACE_HIDPARSE) ||
            hidparse->Version < 1) {
            //
            // return STATUS_UNSUPPORTED probably
            //
            return Irp->IoStatus.Status;
        }
        hidparse->HidpGetCaps = HidP_GetCaps;
        return STATUS_SUCCESS;
    }

    //
    // return STATUS_UNSUPPORTED probably
    //
    return Irp->IoStatus.Status;
}


/*
 ********************************************************************************
 *  HidpQueryIdForClientPdo
 ********************************************************************************
 *
 *
 *
 */
NTSTATUS HidpQueryIdForClientPdo (
    IN PHIDCLASS_DEVICE_EXTENSION hidClassExtension,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION  irpSp;
    NTSTATUS            status;
    PDO_EXTENSION       *pdoExt;
    FDO_EXTENSION       *fdoExt;

    PAGED_CODE();

    ASSERT(hidClassExtension->isClientPdo);
    pdoExt = &hidClassExtension->pdoExt;
    fdoExt = &pdoExt->deviceFdoExt->fdoExt;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    switch (irpSp->Parameters.QueryId.IdType) {

    case BusQueryHardwareIDs:

        /*
         *  Call down to get a multi-string of hardware ids for the PDO.
         */
        IoCopyCurrentIrpStackLocationToNext(Irp);
        status = HidpCallDriverSynchronous(fdoExt->fdo, Irp);
        if (NT_SUCCESS(status)){
            PWCHAR oldIDs, newIDs;
            /*
             *  Replace the bus names in the current hardware IDs list with "HID\".
             */
            oldIDs = (PWCHAR)Irp->IoStatus.Information;
            Irp->IoStatus.Information = (ULONG_PTR)BAD_POINTER;
            newIDs = SubstituteBusNames(oldIDs, fdoExt, pdoExt);
            ExFreePool(oldIDs);

            if (newIDs){

                /*
                 *  Now append the compatible ids to the end of the HardwareIDs list.
                 */
                PWCHAR compatIDs = BuildCompatibleID(hidClassExtension);
                if (compatIDs){
                    ULONG basicIDsLen, compatIDsLen;
                    PWCHAR allHwIDs;

                    /*
                     *  Find the lengths of the id multi-strings (not counting the extra NULL at end).
                     */
                    for (basicIDsLen = 0; newIDs[basicIDsLen]; basicIDsLen += WStrLen(newIDs+basicIDsLen)+1);
                    for (compatIDsLen = 0; compatIDs[compatIDsLen]; compatIDsLen += WStrLen(compatIDs+compatIDsLen)+1);

                    allHwIDs = ALLOCATEPOOL(PagedPool, (basicIDsLen+compatIDsLen+1)*sizeof(WCHAR));
                    if (allHwIDs){
                        RtlCopyMemory(allHwIDs, newIDs, basicIDsLen*sizeof(WCHAR));
                        RtlCopyMemory(  allHwIDs+basicIDsLen,
                                        compatIDs,
                                        (compatIDsLen+1)*sizeof(WCHAR));

                        Irp->IoStatus.Information = (ULONG_PTR)allHwIDs;
                    }
                    else {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                    }

                    ExFreePool(compatIDs);
                }
                else {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }

                ExFreePool(newIDs);
            }
            else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        DBGSUCCESS(status, TRUE)
        break;

    case BusQueryDeviceID:
        /*
         *  Call down to get a the device id for the device's PDO.
         */
        IoCopyCurrentIrpStackLocationToNext(Irp);
        status = HidpCallDriverSynchronous(fdoExt->fdo, Irp);
        if (NT_SUCCESS(status)){
            PWCHAR oldId, newId, tmpId;

            /*
             *  Replace the bus name (e.g. "USB\") with "HID\" in the device name.
             */

            /*
             *  First make this string into a multi-string.
             */
            oldId = (PWCHAR)Irp->IoStatus.Information;
            tmpId = ALLOCATEPOOL(PagedPool, (WStrLen(oldId)+2)*sizeof(WCHAR));
            if (tmpId){
                ULONG len = WStrCpy(tmpId, oldId);

                /*
                 *  Add the extra NULL to terminate the multi-string.
                 */
                tmpId[len+1] = UNICODE_NULL;

                /*
                 *  Change the bus name to "HID\"
                 */
                newId = SubstituteBusNames(tmpId, fdoExt, pdoExt);
                if (newId){
                    Irp->IoStatus.Information = (ULONG_PTR)newId;
                }
                else {
                    status = STATUS_DEVICE_DATA_ERROR;
                    Irp->IoStatus.Information = (ULONG_PTR)BAD_POINTER;
                }

                ExFreePool(tmpId);
            }
            else {
                status = STATUS_DEVICE_DATA_ERROR;
                Irp->IoStatus.Information = (ULONG_PTR)BAD_POINTER;
            }
            ExFreePool(oldId);
        }

        DBGSUCCESS(status, TRUE)
        break;

    case BusQueryInstanceID:

        /*
         *  Produce an instance-id for this collection-PDO.
         *
         *  Note: NTKERN frees the returned pointer, so we must provide a fresh pointer.
         */
        {
            PWSTR instanceId = MemDup(PagedPool, L"0000", sizeof(L"0000"));
            if (instanceId){
                ULONG i;

                /*
                 *  Find this collection-PDO in the device-relations array
                 *  and make the id be the PDO's index within that array.
                 */
                for (i = 0; i < fdoExt->deviceRelations->Count; i++){
                    if (fdoExt->deviceRelations->Objects[i] == pdoExt->pdo){
                        StringCbPrintfW(instanceId, 
                                        sizeof(L"0000"),
                                        L"%04x", i);
                        break;
                    }
                }
                ASSERT(i < fdoExt->deviceRelations->Count);

                Irp->IoStatus.Information = (ULONG_PTR)instanceId;
                status = STATUS_SUCCESS;
            }
            else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        DBGSUCCESS(status, TRUE)
        break;

    case BusQueryCompatibleIDs:

        //        we now return the compatible id's at the end of HardwareIDs
        //        so that there is no UI on plug-in for a compatible-id match
        //        for a class-PDO.
        // Irp->IoStatus.Information = (ULONG)BuildCompatibleID(hidClassExtension);
        Irp->IoStatus.Information = (ULONG_PTR)ALLOCATEPOOL(PagedPool, sizeof(L"\0"));
        if (Irp->IoStatus.Information) {
            *(ULONG *)Irp->IoStatus.Information = 0;  // double unicode-NULL.
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
            ASSERT(0);
        }
        break;

    default:
        /*
         *  Do not return STATUS_NOT_SUPPORTED;
         *  keep the default status
         *  (this allows filter drivers to work).
         */
        status = Irp->IoStatus.Status;
        break;
    }

    return status;
}



/*
 ********************************************************************************
 *  AllClientPDOsInitialized
 ********************************************************************************
 *
 *
 */
BOOLEAN AllClientPDOsInitialized(FDO_EXTENSION *fdoExtension, BOOLEAN initialized)
{
    BOOLEAN result = TRUE;
    ULONG i;

    if (ISPTR(fdoExtension->deviceRelations)){
        for (i = 0; i < fdoExtension->deviceRelations->Count; i++){
            PDEVICE_OBJECT pdo = fdoExtension->deviceRelations->Objects[i];
            PHIDCLASS_DEVICE_EXTENSION pdoDevExt = pdo->DeviceExtension;
                    PDO_EXTENSION *pdoExt = &pdoDevExt->pdoExt;

                    /*
                     *  Trick: compare !-results so that all TRUE values are equal
                     */
            if (!initialized == !(pdoExt->state == COLLECTION_STATE_UNINITIALIZED)){
                DBGVERBOSE(("AllClientPDOsInitialized is returning FALSE for pdo %x, state = %d",
                            pdo, pdoExt->state))
                result = FALSE;
                break;
            }
        }
    }
    else {
        result = !initialized;
    }

    return result;
}


/*
 ********************************************************************************
 *  AnyClientPDOsInitialized
 ********************************************************************************
 *
 *
 */
BOOLEAN AnyClientPDOsInitialized(FDO_EXTENSION *fdoExtension, BOOLEAN initialized)
{
    BOOLEAN result = TRUE;
    ULONG i;

    if (ISPTR(fdoExtension->deviceRelations)){
        for (i = 0; i < fdoExtension->deviceRelations->Count; i++){
            PDEVICE_OBJECT pdo = fdoExtension->deviceRelations->Objects[i];
            PHIDCLASS_DEVICE_EXTENSION pdoDevExt = pdo->DeviceExtension;
            PDO_EXTENSION *pdoExt = &pdoDevExt->pdoExt;

            if (!initialized != !(pdoExt->state == COLLECTION_STATE_UNINITIALIZED)){
                result = TRUE;
                break;
            }
        }
    }
    else {
        result = !initialized;
    }

    return result;
}



/*
 ********************************************************************************
 *  HidpDeleteDeviceObjects
 ********************************************************************************
 *
 *  Delete the device-FDO and collection-PDO's  IF POSSIBLE.
 *  (must wait for REMOVE_DEVICE completion AND the IRP_MJ_CLOSE.
 *  Otherwise, return FALSE and we'll try again later.
 *
 *
 */
BOOLEAN HidpDeleteDeviceObjects(FDO_EXTENSION *fdoExt)
{
    ULONG i;

    /*
     *  Do this switch-a-roo to thwart re-entrancy problems.
     */
    PDEVICE_OBJECT objToDelete = fdoExt->fdo;
    fdoExt->fdo = BAD_POINTER;

    if (ISPTR(fdoExt->deviceRelations)){

        for (i = 0; i < fdoExt->deviceRelations->Count; i++){
            PDO_EXTENSION *pdoExt = &fdoExt->collectionPdoExtensions[i]->pdoExt;

            ASSERT(ISPTR(fdoExt->deviceRelations->Objects[i]));

            if (ISPTR(pdoExt->name)){
                RtlFreeUnicodeString(pdoExt->name);
                ExFreePool(pdoExt->name);
                pdoExt->name = BAD_POINTER;
            }

                        /*
                         *  Delete the client PDO.
                         *  Don't touch the pdoExt after doing this.
                         */
            ObDereferenceObject(fdoExt->deviceRelations->Objects[i]);
            IoDeleteDevice(fdoExt->deviceRelations->Objects[i]);
        }

        ExFreePool(fdoExt->deviceRelations);
    }
    fdoExt->deviceRelations = BAD_POINTER;

    if (ISPTR(fdoExt->collectionPdoExtensions)){
        ExFreePool(fdoExt->collectionPdoExtensions);
    }
    fdoExt->collectionPdoExtensions = BAD_POINTER;

    ObDereferenceObject(objToDelete);
    IoDeleteDevice(objToDelete);

    return TRUE;
}


/*
 ********************************************************************************
 *  HidpQueryDeviceCapabilities
 ********************************************************************************
 *
 *
 *
 */
NTSTATUS HidpQueryDeviceCapabilities(   IN PDEVICE_OBJECT PdoDeviceObject,
                                        IN PDEVICE_CAPABILITIES DeviceCapabilities)
{
    PIRP irp;
    NTSTATUS status;

    PAGED_CODE();

    irp = IoAllocateIrp(PdoDeviceObject->StackSize, FALSE);
    if (irp) {
        PIO_STACK_LOCATION nextStack;
        KEVENT event;

        nextStack = IoGetNextIrpStackLocation(irp);
        ASSERT(nextStack);

        nextStack->MajorFunction= IRP_MJ_PNP;
        nextStack->MinorFunction= IRP_MN_QUERY_CAPABILITIES;
        irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        IoSetCompletionRoutine(irp,
                               HidpQueryCapsCompletion,
                               &event,
                               TRUE,
                               TRUE,
                               TRUE);

        RtlZeroMemory(DeviceCapabilities, sizeof(DEVICE_CAPABILITIES));

        /*
         *  Caller needs to initialize some fields
         */
        DeviceCapabilities->Size = sizeof(DEVICE_CAPABILITIES);
        DeviceCapabilities->Version = 1;
        DeviceCapabilities->Address = -1;
        DeviceCapabilities->UINumber = -1;

        nextStack->Parameters.DeviceCapabilities.Capabilities = DeviceCapabilities;

        status = IoCallDriver(PdoDeviceObject, irp);

        if (status == STATUS_PENDING) {
           KeWaitForSingleObject(
                &event,
                Suspended,
                KernelMode,
                FALSE,
                NULL);
        }

        /*
         *  Note: we still own the IRP after the IoCallDriver() call
         *        because the completion routine returned
         *        STATUS_MORE_PROCESSING_REQUIRED.
         */
        status = irp->IoStatus.Status;

        IoFreeIrp(irp);

    }
    else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}


/*
 ********************************************************************************
 *  CheckReportPowerEvent
 ********************************************************************************
 *
 *  Check whether the read report includes a power event.
 *  If it does, notify the system by completing the saved power-event Irp.
 *
 *  Note: report should point to a "cooked" report with the report-id byte
 *        included at the beginning of the report, whether or not the device
 *        included the report id.
 *
 */
VOID CheckReportPowerEvent( FDO_EXTENSION *fdoExt,
                            PHIDCLASS_COLLECTION collection,
                            PUCHAR report,
                            ULONG reportLen)
{
    ULONG powerMask;
    NTSTATUS status;

    ASSERT(ISPTR(fdoExt->collectionPdoExtensions));

    status = HidP_SysPowerEvent(    report,
                                    (USHORT)reportLen,
                                    collection->phidDescriptor,
                                    &powerMask);
    if (NT_SUCCESS(status)){

        if (powerMask){
            /*
             *  This report contains a power event!
             */

            PIRP irpToComplete = NULL;
            KIRQL oldIrql;

            KeAcquireSpinLock(&collection->powerEventSpinLock, &oldIrql);

            /*
             *  We should have gotten a IOCTL_GET_SYS_BUTTON_EVENT earlier and queued
             *  an IRP to return now.
             */
            if (ISPTR(collection->powerEventIrp)){
                PDRIVER_CANCEL oldCancelRoutine;

                /*
                 *  "Dequeue" the power event IRP.
                 */
                irpToComplete = collection->powerEventIrp;

                oldCancelRoutine = IoSetCancelRoutine(irpToComplete, NULL);
                if (oldCancelRoutine){
                    ASSERT(oldCancelRoutine == PowerEventCancelRoutine);
                }
                else {
                    /*
                     *  This IRP was cancelled and the cancel routine WAS called.
                     *  The cancel routine will complete this IRP
                     *  as soon as we drop the spinlock, so don't touch the IRP.
                     */
                    ASSERT(irpToComplete->Cancel);
                    irpToComplete = NULL;
                }

                collection->powerEventIrp = BAD_POINTER;
            }
            else {
                TRAP;
            }

            KeReleaseSpinLock(&collection->powerEventSpinLock, oldIrql);

            /*
             *  If completing the IRP,
             *  do so after releasing all spinlocks.
             */
            if (irpToComplete){
                /*
                 *  Complete the IRP with the power mask.
                 *
                 */
                ASSERT(irpToComplete->AssociatedIrp.SystemBuffer);
                *(PULONG)irpToComplete->AssociatedIrp.SystemBuffer = powerMask;
                irpToComplete->IoStatus.Information = sizeof(ULONG);
                irpToComplete->IoStatus.Status = STATUS_SUCCESS;
                IoCompleteRequest(irpToComplete, IO_NO_INCREMENT);
            }
        }
    }

}

LONG WStrNCmpI(PWCHAR s1, PWCHAR s2, ULONG n)
{
    ULONG result;

    while (n && *s1 && *s2 && ((*s1|0x20) == (*s2|0x20))){
        s1++, s2++;
        n--;
    }

    if (n){
        result = ((*s1|0x20) > (*s2|0x20)) ? 1 : ((*s1|0x20) < (*s2|0x20)) ? -1 : 0;
    }
    else {
        result = 0;
    }

    return result;
}


ULONG LAtoX(PWCHAR wHexString)
/*++

Routine Description:

      Convert a hex string (without the '0x' prefix) to a ULONG.

Arguments:

    wHexString - null-terminated wide-char hex string
                 (with no "0x" prefix)

Return Value:

    ULONG value

--*/
{
    ULONG i, result = 0;

    for (i = 0; wHexString[i]; i++){
        if ((wHexString[i] >= L'0') && (wHexString[i] <= L'9')){
            result *= 0x10;
            result += (wHexString[i] - L'0');
        }
        else if ((wHexString[i] >= L'a') && (wHexString[i] <= L'f')){
            result *= 0x10;
            result += (wHexString[i] - L'a' + 0x0a);
        }
        else if ((wHexString[i] >= L'A') && (wHexString[i] <= L'F')){
            result *= 0x10;
            result += (wHexString[i] - L'A' + 0x0a);
        }
        else {
            ASSERT(0);
            break;
        }
    }

    return result;
}


ULONG WStrNCpy(PWCHAR dest, PWCHAR src, ULONG n)
{
    ULONG result = 0;

    while (n && (*dest++ = *src++)){
        result++;
        n--;
    }

    return result;
}


NTSTATUS OpenSubkey(    OUT PHANDLE Handle,
                        IN HANDLE BaseHandle,
                        IN PUNICODE_STRING KeyName,
                        IN ACCESS_MASK DesiredAccess
                   )
{
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS status;

    PAGED_CODE();

    InitializeObjectAttributes( &objectAttributes,
                                KeyName,
                                OBJ_CASE_INSENSITIVE,
                                BaseHandle,
                                (PSECURITY_DESCRIPTOR) NULL );

    status = ZwOpenKey(Handle, DesiredAccess, &objectAttributes);

    return status;
}

PVOID
HidpGetSystemAddressForMdlSafe(PMDL MdlAddress)
{
    PVOID buf = NULL;
    /*
     *  Can't call MmGetSystemAddressForMdlSafe in a WDM driver,
     *  so set the MDL_MAPPING_CAN_FAIL bit and check the result
     *  of the mapping.
     */
    if (MdlAddress) {
        MdlAddress->MdlFlags |= MDL_MAPPING_CAN_FAIL;
        buf = MmGetSystemAddressForMdl(MdlAddress);
        MdlAddress->MdlFlags &= (~MDL_MAPPING_CAN_FAIL);
    }
    else {
        DBGASSERT(MdlAddress, ("MdlAddress passed into GetSystemAddress is NULL"), FALSE)
    }
    return buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidclass\services.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name: 

    services.c

Abstract

    Service entry points exposed by the HID class driver.

Author:

    Forrest Foltz
    Ervin P.

Environment:

    Kernel mode only

Revision History:


--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HidRegisterMinidriver)
#endif


/*
 ********************************************************************************
 *  HidRegisterMinidriver
 ********************************************************************************
 *
 *   Routine Description:
 *
 *       This public service is called by a HidOnXxx minidriver from its
 *       driverentry routine to register itself as a newly loaded HID minidriver.
 *
 *       It creates a HIDCLASS_DRIVER_EXTENSION and returns it as reference data
 *       to the minidriver.
 *
 *   Arguments:
 *
 *       MinidriverRegistration - pointer to a registration packet that must be
 *                                completely filled in by the minidriver.
 *
 *   Return Value:
 *
 *      Standard NT return value.
 *
 *
 */
NTSTATUS HidRegisterMinidriver(IN PHID_MINIDRIVER_REGISTRATION MinidriverRegistration)
{
    PHIDCLASS_DRIVER_EXTENSION hidDriverExtension;
    PDRIVER_EXTENSION driverExtension;
    PDRIVER_OBJECT minidriverObject;
    NTSTATUS status;
    PUNICODE_STRING regPath;

    PAGED_CODE();

    if (MinidriverRegistration->Revision > HID_REVISION){
        DBGERR(("Revision mismatch: HIDCLASS revision is %xh, minidriver requires hidclass revision %xh.", HID_REVISION, MinidriverRegistration->Revision))
        status = STATUS_REVISION_MISMATCH;
        goto HidRegisterMinidriverExit;
    }

    /*
     *  Allocate a driver extension for this driver object
     *  and associate it with the object.
     *  (By using this interface, we never have to free
     *   this context; it gets freed when the driver object
     *   is freed).
     */
    status = IoAllocateDriverObjectExtension(
                    MinidriverRegistration->DriverObject,
                    (PVOID)"HIDCLASS",
                    sizeof(HIDCLASS_DRIVER_EXTENSION),
                    &hidDriverExtension
                    );

    if (!NT_SUCCESS(status)){
        goto HidRegisterMinidriverExit;
    }

    RtlZeroMemory(hidDriverExtension, sizeof(HIDCLASS_DRIVER_EXTENSION)); 

    //
    // Fill in various fields in our per-minidriver extension.
    //
    hidDriverExtension->MinidriverObject = MinidriverRegistration->DriverObject;
    hidDriverExtension->DeviceExtensionSize = MinidriverRegistration->DeviceExtensionSize;
    #if DBG
        hidDriverExtension->Signature = HID_DRIVER_EXTENSION_SIG;
    #endif

    //
    // Copy the regpath.
    //
    regPath = &hidDriverExtension->RegistryPath;
    regPath->MaximumLength = MinidriverRegistration->RegistryPath->Length 
        + sizeof (UNICODE_NULL);
    regPath->Buffer = ALLOCATEPOOL(NonPagedPool, regPath->MaximumLength);
    if (!regPath->Buffer) {
        DBGWARN(("Failed unicode string alloc."))
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto HidRegisterMinidriverExit;
    }
    RtlCopyUnicodeString(regPath, MinidriverRegistration->RegistryPath);

    //
    // Make a copy of the minidriver's original dispatch table and AddDevice routine
    //
    minidriverObject = MinidriverRegistration->DriverObject;
    RtlCopyMemory( hidDriverExtension->MajorFunction,
                   minidriverObject->MajorFunction,
                   sizeof( PDRIVER_DISPATCH ) * (IRP_MJ_MAXIMUM_FUNCTION + 1) );

    driverExtension = minidriverObject->DriverExtension;

    hidDriverExtension->DevicesArePolled = MinidriverRegistration->DevicesArePolled;


    //
    // Now set the minidriver's major dispatch functions (the ones that
    // we care about) to our dispatch routine instead
    //

    minidriverObject->MajorFunction[ IRP_MJ_CLOSE ] =
    minidriverObject->MajorFunction[ IRP_MJ_CREATE ] =
    minidriverObject->MajorFunction[ IRP_MJ_DEVICE_CONTROL ] =
    minidriverObject->MajorFunction[ IRP_MJ_INTERNAL_DEVICE_CONTROL ] =
    minidriverObject->MajorFunction[ IRP_MJ_PNP ] =
    minidriverObject->MajorFunction[ IRP_MJ_POWER ] =
    minidriverObject->MajorFunction[ IRP_MJ_READ ] =
    minidriverObject->MajorFunction[ IRP_MJ_WRITE ] =
    minidriverObject->MajorFunction[ IRP_MJ_SYSTEM_CONTROL ] =
        HidpMajorHandler;

    /*
     *  Hook the lower driver's AddDevice;
     *  our HidpAddDevice will chain the call down to the
     *  miniport's handler.
     */
    ASSERT(driverExtension->AddDevice);
    hidDriverExtension->AddDevice = driverExtension->AddDevice;
    driverExtension->AddDevice = HidpAddDevice;

    /*
     *  Hook the lower driver's Unload
     */
    ASSERT(minidriverObject->DriverUnload);
    hidDriverExtension->DriverUnload = minidriverObject->DriverUnload;
    minidriverObject->DriverUnload = HidpDriverUnload;

    /*
     *  Initialize the ReferenceCount to zero.
     *  It will be incremented for each AddDevice and decremented for
     *  each REMOVE_DEVICE.
     */
    hidDriverExtension->ReferenceCount = 0;

    //
    // Place the hid driver extension on our global list so we can find
    // it later (given a pointer to the minidriver object for which it
    // was created
    //
    if (!EnqueueDriverExt(hidDriverExtension)){
        status = STATUS_DEVICE_CONFIGURATION_ERROR;
    }
    
HidRegisterMinidriverExit:
    DBGSUCCESS(status, TRUE)
    return status;
}



NTSTATUS 
HidNotifyPresence(PDEVICE_OBJECT DeviceObject,
                  BOOLEAN IsPresent)
{

    PHIDCLASS_DEVICE_EXTENSION hidClassExtension;
    KIRQL irql;
    
    hidClassExtension = (PHIDCLASS_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    ASSERT(hidClassExtension->Signature == HID_DEVICE_EXTENSION_SIG);
    ASSERT(!hidClassExtension->isClientPdo);

    KeAcquireSpinLock(&hidClassExtension->fdoExt.presentSpinLock,
                      &irql);
   
    if (hidClassExtension->fdoExt.isPresent != IsPresent) {
        hidClassExtension->fdoExt.isPresent = IsPresent;
    
        IoInvalidateDeviceRelations(hidClassExtension->hidExt.PhysicalDeviceObject,
                                    BusRelations);

    }

    KeReleaseSpinLock(&hidClassExtension->fdoExt.presentSpinLock,
                      irql);

    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidir\hidir.h ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    hidir.h

--*/
#ifndef __HIDIR_H__
#define __HIDIR_H__

#include <hidusage.h>

//
//  Declarations of HID descriptor formats
//

#include <PSHPACK1.H>

typedef UCHAR HID_REPORT_DESCRIPTOR, *PHID_REPORT_DESCRIPTOR;

typedef UCHAR HID_PHYSICAL_DESCRIPTOR, *PHID_PHYSICAL_DESCRIPTOR;

typedef struct _HIDIR_DESCRIPTOR
{
    UCHAR   bLength;
    UCHAR   bDescriptorType;
    USHORT  bcdHID;
    UCHAR   bCountry;
    UCHAR   bNumDescriptors;

    /*
     *  This is an array of one OR MORE descriptors.
     */
    struct _HIDIR_DESCRIPTOR_DESC_LIST {
       UCHAR   bDescriptorType;
       USHORT  wDescriptorLength;
    } DescriptorList [1];

} HIDIR_DESCRIPTOR, * PHIDIR_DESCRIPTOR;

#include <POPPACK.H>

// Pool
#define HIDIR_POOL_TAG 'IdiH'
#define ALLOCATEPOOL(poolType, size) ExAllocatePoolWithTag((poolType), (size), HIDIR_POOL_TAG)

//
//  Device Extension
//
//  This data structure is hooked onto HIDCLASS' device extension, so both drivers can
//  have their own private data on each device object.
//

#define HIDIR_REPORT_SIZE sizeof(ULONG)
#define HIDIR_TABLE_ENTRY_SIZE(rl) (sizeof(ULONG) + (((rl)+0x00000003)&(~0x00000003)))

typedef struct _USAGE_TABLE_ENTRY {
    ULONG IRString;
    UCHAR UsageString[1];
} USAGE_TABLE_ENTRY, *PUSAGE_TABLE_ENTRY;

typedef struct _HIDIR_EXTENSION
{
    // What state has pnp got me in?
    ULONG                           DeviceState;

    // Ref counting
    LONG                            NumPendingRequests;
    KEVENT                          AllRequestsCompleteEvent;

    // My hid bth device object.
    PDEVICE_OBJECT                  DeviceObject;

    // Descriptors: HID, report, and physical
    HIDIR_DESCRIPTOR                HidDescriptor;
    PHID_REPORT_DESCRIPTOR          ReportDescriptor;
    ULONG                           ReportLength;

    BOOLEAN                         QueryRemove;

    // VID, PID, and version
    USHORT                          VendorID;
    USHORT                          ProductID;
    USHORT                          VersionNumber;

    ULONG                           NumUsages;
    PUCHAR                          MappingTable;
    USAGE_TABLE_ENTRY               PreviousButton;
    BOOLEAN                         ValidUsageSentLastTime[3];

    BOOLEAN                         KeyboardReportIdValid;
    UCHAR                           KeyboardReportId;
    BOOLEAN                         StandbyReportIdValid;
    UCHAR                           StandbyReportId;

    DEVICE_POWER_STATE              DevicePowerState;
    KTIMER                          IgnoreStandbyTimer;
} HIDIR_EXTENSION, *PHIDIR_EXTENSION;

#define DEVICE_STATE_NONE           0
#define DEVICE_STATE_STARTING       1
#define DEVICE_STATE_RUNNING        2
#define DEVICE_STATE_STOPPING       3
#define DEVICE_STATE_STOPPED        4
#define DEVICE_STATE_REMOVING       5

//
// Device Extension Macros
//

#define GET_MINIDRIVER_HIDIR_EXTENSION(DO) ((PHIDIR_EXTENSION) (((PHID_DEVICE_EXTENSION)(DO)->DeviceExtension)->MiniDeviceExtension))

#define GET_NEXT_DEVICE_OBJECT(DO) (((PHID_DEVICE_EXTENSION)(DO)->DeviceExtension)->NextDeviceObject)

//
// Turn on debug printing and breaking, if appropriate
//

#if DBG
#define DBGPrint(arg) DbgPrint arg
#define DBGBREAK DbgBreakPoint()
#else
#define DBGPrint(arg)
#define DBGBREAK
#endif

//
// Function prototypes
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING registryPath
    );

NTSTATUS
HidIrIoctl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidIrPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidIrPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidIrAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT FunctionalDeviceObject
    );

VOID
HidIrUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
HidIrGetDeviceAttributes(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidIrGetHidDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN USHORT DescriptorType
    );

NTSTATUS
HidIrReadReport(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    OUT BOOLEAN *NeedsCompletion
    );

NTSTATUS
HidIrIncrementPendingRequestCount(
    IN PHIDIR_EXTENSION DeviceExtension
    );

VOID
HidIrDecrementPendingRequestCount(
    IN PHIDIR_EXTENSION DeviceExtension
    );

NTSTATUS
HidIrSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidIrSynchronousCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );

NTSTATUS
HidIrCallDriverSynchronous(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

extern ULONG RunningMediaCenter;

#endif // _HIDIR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidir\dbg.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    dbg.h

Abstract:

    debug macros

Environment:

    Kernel & user mode

Revision History:

    6-20-99 : created

--*/

#ifndef   __DBG_H__
#define   __DBG_H__

#define HIDIR_TAG          'BdiH'        //"HidB"


#if DBG
/**********
DUBUG
***********/

//
// This Breakpoint means we either need to test the code path
// somehow or the code is not implemented.  ie either case we
// should not have any of these when the driver is finished
// and tested
//

#define HIR_TRAP()          {\
                            DbgPrint("<HB TRAP> %s, line %d\n", __FILE__, __LINE__);\
                            DbgBreakPoint();\
                            }


ULONG
_cdecl
HidIrKdPrintX(
    ULONG l,
    PCH Format,
    ...
    );

#define   HidIrKdPrint(_x_) HidIrKdPrintX _x_

#else
/**********
RETAIL
***********/

// debug macros for retail build

#define HIR_TRAP()
#define HidIrKdPrint(_x_)

#endif /* DBG */

#endif /* __DBG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidir\hid.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    hid.c

Abstract: Human Input Device (HID) minidriver for Infrared (IR) devices

          The HID IR Minidriver (HidIr) provides an abstraction layer for the
          HID Class to talk to HID IR devices.

Author:
            jsenior

Environment:

    Kernel mode

Revision History:


--*/
#include "pch.h"

PVOID
HidIrGetSystemAddressForMdlSafe(PMDL MdlAddress)
{
    PVOID buf = NULL;
    /*
     *  Can't call MmGetSystemAddressForMdlSafe in a WDM driver,
     *  so set the MDL_MAPPING_CAN_FAIL bit and check the result
     *  of the mapping.
     */
    if (MdlAddress) {
        MdlAddress->MdlFlags |= MDL_MAPPING_CAN_FAIL;
        buf = MmGetSystemAddressForMdl(MdlAddress);
        MdlAddress->MdlFlags &= ~(MDL_MAPPING_CAN_FAIL);
    }
    return buf;
}

/*
 ********************************************************************************
 *  HidIrGetHidDescriptor
 ********************************************************************************
 *
 *   Routine Description:
 *
 *       Return the hid descriptor of the requested type. This ioctl can only 
 *       be sent from the HidClass driver. The hidclass driver always sends the
 *       irp with a userbuffer, so there is no need to check for its existence.
 *       But better safe then sorry...
 *
 *   Arguments:
 *
 *       DeviceObject - pointer to a device object.
 *
 *   Return Value:
 *
 *       NT status code.
 *
 */
NTSTATUS HidIrGetHidDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    USHORT DescriptorType
    )
{
    PHIDIR_EXTENSION devExt;
    PIO_STACK_LOCATION  irpStack;
    ULONG descLength = 0, bytesToCopy;
    PUCHAR descriptor = NULL;

    PAGED_CODE();

    HidIrKdPrint((3, "HidIrGetHidDescriptor type %x", DescriptorType));

    devExt = GET_MINIDRIVER_HIDIR_EXTENSION(DeviceObject);
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    bytesToCopy = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    switch (DescriptorType) {
    case HID_HID_DESCRIPTOR_TYPE:
        descLength = devExt->HidDescriptor.bLength;
        descriptor = (PUCHAR)&devExt->HidDescriptor;
        break;
    case HID_REPORT_DESCRIPTOR_TYPE:
        descLength = devExt->HidDescriptor.DescriptorList[0].wDescriptorLength;
        descriptor = devExt->ReportDescriptor;
        break;
    case HID_PHYSICAL_DESCRIPTOR_TYPE:
        // Not handled
        break;
    default:
        HIR_TRAP();
    }

    if (descLength == 0 ||
        descriptor == NULL) {
        return STATUS_UNSUCCESSFUL;
    }
    
    if (bytesToCopy > descLength) {
        bytesToCopy = descLength;
    }

    if (Irp->UserBuffer) {
        RtlCopyMemory((PUCHAR)Irp->UserBuffer, descriptor, bytesToCopy);
        Irp->IoStatus.Information = bytesToCopy;
    } else {
        HIR_TRAP();
        return STATUS_INVALID_USER_BUFFER;
    }

    return STATUS_SUCCESS;
}


/*
 ********************************************************************************
 *  HidIrGetDeviceAttributes
 ********************************************************************************
 *
 *   Routine Description:
 *
 *       Fill in the given struct _HID_DEVICE_ATTRIBUTES. This ioctl can only 
 *       be sent from the HidClass driver. The hidclass driver always sends the
 *       irp with a userbuffer, so there is no need to check for its existence.
 *       But better safe then sorry...
 *
 *   Arguments:
 *
 *       DeviceObject - pointer to a device object.
 *
 *   Return Value:
 *
 *       NT status code.
 *
 */
NTSTATUS HidIrGetDeviceAttributes(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS ntStatus;

    PAGED_CODE();

    HidIrKdPrint((3, "HidIrGetDeviceAttributes Enter"));

    if (Irp->UserBuffer) {

        PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
        PHID_DEVICE_ATTRIBUTES deviceAttributes = 
            (PHID_DEVICE_ATTRIBUTES) Irp->UserBuffer;

        if (irpStack->Parameters.DeviceIoControl.OutputBufferLength >=
            sizeof (HID_DEVICE_ATTRIBUTES)){

            PHIDIR_EXTENSION devExt = GET_MINIDRIVER_HIDIR_EXTENSION(DeviceObject);

            //
            // Report how many bytes were copied
            //
            Irp->IoStatus.Information = sizeof (HID_DEVICE_ATTRIBUTES);

            deviceAttributes->Size = sizeof (HID_DEVICE_ATTRIBUTES);
            // TODO: Get these values from the bth stack.
            deviceAttributes->VendorID = devExt->VendorID;
            deviceAttributes->ProductID = devExt->ProductID;
            deviceAttributes->VersionNumber = devExt->VersionNumber;
            ntStatus = STATUS_SUCCESS;
        } else {
            ntStatus = STATUS_INVALID_BUFFER_SIZE;
        }
    } else {
        HIR_TRAP();
        ntStatus = STATUS_INVALID_USER_BUFFER;
    }
                
    ASSERT(NT_SUCCESS(ntStatus));
    return ntStatus;
}


/*
 ********************************************************************************
 *  HidIrIncrementPendingRequestCount
 ********************************************************************************
 *
 *
 */
NTSTATUS HidIrIncrementPendingRequestCount(IN PHIDIR_EXTENSION DevExt)
{
    LONG newRequestCount;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    newRequestCount = InterlockedIncrement(&DevExt->NumPendingRequests);

    HidIrKdPrint((1, "Increment Pending Request Count to %x", newRequestCount));

    // Make sure that the device is capable of receiving new requests.
    if ((DevExt->DeviceState != DEVICE_STATE_RUNNING) &&
        (DevExt->DeviceState != DEVICE_STATE_STARTING)){

        HIR_TRAP();

        // Device cannot receive any more IOs, decrement back, fail the increment
        HidIrDecrementPendingRequestCount(DevExt);
        ntStatus = STATUS_NO_SUCH_DEVICE;
    }

    return ntStatus;
}


/*
 ********************************************************************************
 *  HidIrDecrementPendingRequestCount
 ********************************************************************************
 *
 *
 */
VOID HidIrDecrementPendingRequestCount(IN PHIDIR_EXTENSION DevExt)
{
    LONG PendingCount;

    ASSERT(DevExt->NumPendingRequests >= 0);

    PendingCount = InterlockedDecrement(&DevExt->NumPendingRequests);

    HidIrKdPrint((1, "Decrement Pending Request Count to %x", PendingCount));

    if (PendingCount < 0){

        ASSERT(DevExt->DeviceState != DEVICE_STATE_RUNNING);

        /*
         *  The device state is stopping, and the last outstanding request
         *  has just completed.
         *
         *  Note: RemoveDevice does an extra decrement, so we complete
         *        the REMOVE IRP on the transition to -1, whether this
         *        happens in RemoveDevice itself or subsequently while
         *        RemoveDevice is waiting for this event to fire.
         */

        KeSetEvent(&DevExt->AllRequestsCompleteEvent, 0, FALSE);
    }
}


/*
 ********************************************************************************
 *  HidIrReadCompletion
 ********************************************************************************
 *
 *
 */
NTSTATUS HidIrReadCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PHIDIR_EXTENSION DevExt
    )
{
    NTSTATUS ntStatus = Irp->IoStatus.Status;
    ULONG bytesRead;
    PUCHAR buffer;
    BOOLEAN resend = FALSE;
    PHIDIR_EXTENSION devExt;

    devExt = GET_MINIDRIVER_HIDIR_EXTENSION(DeviceObject);

    HidIrKdPrint((3, "HidIrReadCompletion status %x", ntStatus));

    ASSERT(Irp->MdlAddress);
    buffer = HidIrGetSystemAddressForMdlSafe(Irp->MdlAddress);

    if(!buffer) {
        // If this fails, we really should bugcheck, since someone 
        // in the kernel screwed up our MDL on us. I'll fail safely, but 
        // definitely trap on debug builds.
        HIR_TRAP();
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
    } else if (NT_SUCCESS(ntStatus)){
        
        // Get the bytes read from the status block
        bytesRead = (ULONG)Irp->IoStatus.Information;

        // Predispose to zero 
        Irp->IoStatus.Information = 0;
        
        if (bytesRead == sizeof(ULONG)) {
            ULONG value, i;

            RtlCopyMemory(&value, buffer, sizeof(ULONG));
            if (value == 0) {
                // Key up. Do we have a pending key down?
                if (devExt->PreviousButton.UsageString[0]) {
                    // We have a pending key down. Send key up.
                    PUCHAR destination;
    
                    // Send the ~usage.
                    HidIrKdPrint((2,"Sending ~usage"));
                    Irp->IoStatus.Information = devExt->ReportLength;
                    destination = (PUCHAR) Irp->UserBuffer;
                    RtlZeroMemory(Irp->UserBuffer, Irp->IoStatus.Information); // already checked that buffer is big enuf.
                    destination[0] = devExt->PreviousButton.UsageString[0]; // report ID
                    RtlZeroMemory(&devExt->PreviousButton, sizeof(devExt->PreviousButton));
                } else {
                    // No pending key down message for this key up. Fire it back.
                    resend = TRUE;
                }
            } else if (value == devExt->PreviousButton.IRString) {
                // Same thing as last time. Fire it back down.
                resend = TRUE;
            } else {
                // Something new. Hmmm...
                ULONG entrySize = HIDIR_TABLE_ENTRY_SIZE(devExt->ReportLength);
                PUSAGE_TABLE_ENTRY entry;
                
                // Predispose to bounce the irp back down if we don't find a match.
                resend = TRUE;
                for (i = 0; i < devExt->NumUsages; i++) {
                    entry = (PUSAGE_TABLE_ENTRY) (devExt->MappingTable+(entrySize*i));

                    if (entry->IRString == value) {
                        HidIrKdPrint((2,"Found usage %x!", value));

                        // New usage. Copy it and complete the irp.
                        Irp->IoStatus.Information = devExt->ReportLength;

                        RtlCopyMemory(Irp->UserBuffer, 
                                      entry->UsageString, 
                                      devExt->ReportLength);
                        RtlCopyMemory(&devExt->PreviousButton, 
                                      entry, 
                                      sizeof(devExt->PreviousButton));
                        
                        // Check if we are allowed to send up standby button presses yet.
                        if (KeReadStateTimer(&devExt->IgnoreStandbyTimer) ||
                            !devExt->StandbyReportIdValid ||
                            devExt->StandbyReportId != entry->UsageString[0]) {
                            resend = FALSE;
                        }
                        break;
                    }
                }
                if (resend) {
                    // This might be an OEM button. Check if it's within the approved range.
                    if (value >= 0x800F0400 && value <= 0x800F04FF) {

                        PUCHAR usageString = Irp->UserBuffer;
                        UCHAR oemValue = (UCHAR) (value & 0xFF);

                        // It's in the range!  
                        HidIrKdPrint((2,"OEM button %x", value));
                        RtlZeroMemory(usageString, devExt->ReportLength);
                        
                        // Check if this is the "flag" button. If so, and we are not running 
                        // media center, we want to eject the windows key instead.
                        if (oemValue == 0x0D && !RunningMediaCenter && devExt->KeyboardReportIdValid) {
                            HidIrKdPrint((2,"Change flag button to Windows key"));
                            usageString[0] = devExt->KeyboardReportId; 
                            usageString[1] = 0x8;
                            Irp->IoStatus.Information = devExt->ReportLength;
                        } else {
                            usageString[0] = 0x1;
                            usageString[1] = oemValue;
                            Irp->IoStatus.Information = 2;
                        }
                        
                        devExt->PreviousButton.IRString = value;
                        devExt->PreviousButton.UsageString[0] = usageString[0];
                        resend = FALSE;
                    }
                }
            }

            HidIrKdPrint((3, "HidIrReadCompletion buffer value 0x%x", value));

        } else {
            Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
        }

    } else if (ntStatus == STATUS_CANCELLED){
        /*
         *  The IRP was cancelled, which means that the device is probably getting removed.
         */
        HidIrKdPrint((1, "Read irp %p cancelled ...", Irp));
        ASSERT(!Irp->CancelRoutine);
    }

    // Balance the increment we did when we issued the read.
    HidIrDecrementPendingRequestCount(DevExt);

    //
    // Don't need the MDL and buffer anymore.
    //
    if (Irp->MdlAddress) {
        IoFreeMdl(Irp->MdlAddress);
        Irp->MdlAddress = NULL;
        if (buffer) {
            ExFreePool(buffer);
        }
    }

    // If we didn't get anything useful back, just poke it back down 
    // to the hardware.
    if (resend) {
        BOOLEAN needsCompletion = TRUE;
        ntStatus = HidIrReadReport(DeviceObject, Irp, &needsCompletion);
        if (!needsCompletion) {
            return STATUS_MORE_PROCESSING_REQUIRED;
        }
        Irp->IoStatus.Status = ntStatus; // fall thru and irp will complete.
    }
    
    /*
     *  If the lower driver returned PENDING, mark our stack location as
     *  pending also. This prevents the IRP's thread from being freed if
     *  the client's call returns pending.
     */
    if (Irp->PendingReturned){
        IoMarkIrpPending(Irp);
    }

    return STATUS_SUCCESS; // something other than SMPR
}

/*
 ********************************************************************************
 *  HidIrReadReport
 ********************************************************************************
 *
 *   Routine Description:
 *
 *
 *    Arguments:
 *
 *       DeviceObject - Pointer to class device object.
 *
 *      IrpStack     - Pointer to Interrupt Request Packet.
 *
 *
 *   Return Value:
 *
 *      STATUS_SUCCESS, STATUS_UNSUCCESSFUL.
 *
 *
 *  Note: this function cannot be pageable because reads/writes
 *        can be made at dispatch-level.
 */
NTSTATUS HidIrReadReport(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OUT BOOLEAN *NeedsCompletion)
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    PHIDIR_EXTENSION devExt;
    PUCHAR buffer;
    ULONG bufferLen;
    PIO_STACK_LOCATION irpStack;

    HidIrKdPrint((3, "HidIrReadReport Enter"));

    devExt = GET_MINIDRIVER_HIDIR_EXTENSION(DeviceObject);

    ASSERT(Irp->UserBuffer);

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    if (irpStack->Parameters.DeviceIoControl.OutputBufferLength < devExt->ReportLength) {
        return STATUS_INVALID_BUFFER_SIZE;
    }

    bufferLen = HIDIR_REPORT_SIZE;
    buffer = ALLOCATEPOOL(NonPagedPool, bufferLen);
    if (buffer) {
        ASSERT(!Irp->MdlAddress);
        if (IoAllocateMdl(buffer,
                          bufferLen,
                          FALSE,
                          FALSE,
                          Irp)) {
            MmBuildMdlForNonPagedPool(Irp->MdlAddress);

            irpStack = IoGetNextIrpStackLocation(Irp);

            irpStack->MajorFunction = IRP_MJ_READ;
            irpStack->DeviceObject = GET_NEXT_DEVICE_OBJECT(DeviceObject);
            irpStack->Parameters.Read.Length = bufferLen;

            IoSetCompletionRoutine( 
                        Irp,
                        HidIrReadCompletion,
                        devExt,
                        TRUE,
                        TRUE,
                        TRUE );

            //
            // We need to keep track of the number of pending requests
            // so that we can make sure they're all cancelled properly during
            // processing of a stop device request.
            //
            if (NT_SUCCESS(HidIrIncrementPendingRequestCount(devExt))){
                status = IoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);
                *NeedsCompletion = FALSE;
            } else {
                IoFreeMdl(Irp->MdlAddress);
                Irp->MdlAddress = NULL;
                ExFreePool(buffer);
                status = STATUS_NO_SUCH_DEVICE;
            }
        } else {
            ExFreePool(buffer);
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }


    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidir\hidir.c ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    hidir.c

Abstract: Human Input Device (HID) minidriver that creates an example
        device.

--*/
#include "pch.h"

VOID
HidIrCheckIfMediaCenter();

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(INIT,HidIrCheckIfMediaCenter)
#endif

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING registryPath
    )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    registryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    HID_MINIDRIVER_REGISTRATION HidIrdriverRegistration;

    HidIrKdPrint((3, "DriverEntry Enter"));

    HidIrKdPrint((3, "DriverObject (%lx)", DriverObject));

    //
    // Create dispatch points
    //
    // All of the other dispatch routines are handled by HIDCLASS, except for
    // IRP_MJ_POWER, which isn't implemented yet.
    //

    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = HidIrIoctl;
    DriverObject->MajorFunction[IRP_MJ_PNP]                     = HidIrPnP;
    DriverObject->MajorFunction[IRP_MJ_POWER]                   = HidIrPower;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]          = HidIrSystemControl;
    DriverObject->DriverExtension->AddDevice                    = HidIrAddDevice;
    DriverObject->DriverUnload                                  = HidIrUnload;

    //
    // Register Sample layer with HIDCLASS.SYS module
    //

    HidIrdriverRegistration.Revision              = HID_REVISION;
    HidIrdriverRegistration.DriverObject          = DriverObject;
    HidIrdriverRegistration.RegistryPath          = registryPath;
    HidIrdriverRegistration.DeviceExtensionSize   = sizeof(HIDIR_EXTENSION);

    //  HIDIR does not need to be polled.
    HidIrdriverRegistration.DevicesArePolled      = FALSE;

    HidIrKdPrint((3, "DeviceExtensionSize = %x", HidIrdriverRegistration.DeviceExtensionSize));

    HidIrKdPrint((3, "Registering with HIDCLASS.SYS"));

    HidIrCheckIfMediaCenter();

    //
    // After registering with HIDCLASS, it takes over control of the device, and sends
    // things our way if they need device specific processing.
    //
    status = HidRegisterMinidriver(&HidIrdriverRegistration);

    HidIrKdPrint((3, "DriverEntry Exit = %x", status));

    return status;
}

ULONG RunningMediaCenter;

VOID
HidIrCheckIfMediaCenter()
{
    OBJECT_ATTRIBUTES attributes;
    HANDLE skuRegKey;
    NTSTATUS status;
    ULONG resultLength;
    UNICODE_STRING regString;
    UCHAR buffer[sizeof( KEY_VALUE_PARTIAL_INFORMATION ) + sizeof( ULONG )];

    PAGED_CODE();
    
    RunningMediaCenter = 0;

    //
    //  Open the MediaCenter SKU registry key
    //

    RtlInitUnicodeString( &regString, L"\\REGISTRY\\MACHINE\\SYSTEM\\WPA\\MediaCenter" );
    InitializeObjectAttributes( &attributes,
                                &regString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    status = ZwOpenKey( &skuRegKey,
                        KEY_READ,
                        &attributes );

    if (!NT_SUCCESS( status )) {
        return;
    }

    //
    // Read the Installed value from the registry.
    //

    RtlInitUnicodeString( &regString, L"Installed" );

    status = ZwQueryValueKey( skuRegKey,
                              &regString,
                              KeyValuePartialInformation,
                              buffer,
                              sizeof(buffer),
                              &resultLength );


    if (NT_SUCCESS( status )) {
        PKEY_VALUE_PARTIAL_INFORMATION info = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
        if (info->DataLength == sizeof(ULONG)) {
            RunningMediaCenter = *((ULONG*) &((info)->Data));
        }
    } 

    //
    //  Close the registry entry
    //

    ZwClose(skuRegKey);
}

NTSTATUS
HidIrAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Process AddDevice.  Provides the opportunity to initialize the DeviceObject or the
    DriverObject.

Arguments:

    DriverObject - pointer to the driver object.

    DeviceObject - pointer to a device object.

Return Value:

    NT status code.

--*/
{
    NTSTATUS                status = STATUS_SUCCESS;
    PHIDIR_EXTENSION       deviceExtension;
    LARGE_INTEGER timeout;
    timeout.HighPart = -1;
    timeout.LowPart = -1;

    HidIrKdPrint((3, "HidIrAddDevice Entry"));

    deviceExtension = GET_MINIDRIVER_HIDIR_EXTENSION( DeviceObject );

    deviceExtension->NumPendingRequests = 0;
    KeInitializeEvent( &deviceExtension->AllRequestsCompleteEvent,
                       NotificationEvent,
                       FALSE);

    deviceExtension->DeviceState = DEVICE_STATE_NONE;
    deviceExtension->DeviceObject = DeviceObject;
    deviceExtension->VersionNumber = 0x110;
//    deviceExtension->VendorID = 0x045e;
//    deviceExtension->ProductID = 0x006d;

    // Predispose timer to signalled.
    KeInitializeTimer(&deviceExtension->IgnoreStandbyTimer);
    KeSetTimer(&deviceExtension->IgnoreStandbyTimer, timeout, NULL);

    HidIrKdPrint((3, "HidIrAddDevice Exit = %x", status));

    return status;
}



VOID
HidIrUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Free all the allocated resources, etc. in anticipation of this driver being unloaded.

Arguments:

    DriverObject - pointer to the driver object.

Return Value:

    VOID.

--*/
{
    HidIrKdPrint((3, "HidIrUnload Enter"));

    HidIrKdPrint((3, "Unloading DriverObject = %x", DriverObject));

    HidIrKdPrint((3, "Unloading Exit = VOID"));
}

NTSTATUS
HidIrSynchronousCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
{
    UNREFERENCED_PARAMETER (DeviceObject);

    KeSetEvent ((PKEVENT) Context, 1, FALSE);
    // No special priority
    // No Wait

    return STATUS_MORE_PROCESSING_REQUIRED; // Keep this IRP
}

NTSTATUS
HidIrCallDriverSynchronous(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
    KEVENT event;
    NTSTATUS status;

    // Set next stack location

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp,
                           HidIrSynchronousCompletion,
                           &event,    // context
                           TRUE,
                           TRUE,
                           TRUE );
    status = IoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);

    if (status == STATUS_PENDING) {
       // wait for it...
       KeWaitForSingleObject(&event,
                             Executive,
                             KernelMode,
                             FALSE,
                             NULL);
       status = Irp->IoStatus.Status;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidir\pch.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pch.h

Abstract


Author:

    Jay Senior

Environment:

    Kernel mode only

Revision History:


--*/



#include <wdm.h>
#include <hidport.h>
#include <hidpddi.h>
#include "hidir.h"
#include "dbg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidir\power.c ===
#include "pch.h"

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, HidIrPower)
#endif

/*
 ************************************************************
 *  HidIrPower 
 ************************************************************
 *
 *  Process Power IRPs sent to this device.
 *  Don't have to call PoStartNextPowerIrp, since hidclass does it for us.
 *
 */
NTSTATUS HidIrPower(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PHIDIR_EXTENSION deviceExtension;

    HidIrKdPrint((3, "HidIrPower Entry"));

    deviceExtension = GET_MINIDRIVER_HIDIR_EXTENSION( DeviceObject );

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (irpSp->MinorFunction) {
    case IRP_MN_SET_POWER:                        
        if (irpSp->Parameters.Power.Type == DevicePowerState) {
            if (deviceExtension->DevicePowerState != PowerDeviceD0 &&
                irpSp->Parameters.Power.State.DeviceState == PowerDeviceD0) {
                // We are returning from a low power state.
                // Set a timer that will cause hidir to ignore any standby buttons until it triggers
                LARGE_INTEGER timeout;
                timeout.HighPart = -1;
                timeout.LowPart = -50000000; // 5 seconds should be plenty
                KeSetTimer(&deviceExtension->IgnoreStandbyTimer, timeout, NULL);
            }
            deviceExtension->DevicePowerState = irpSp->Parameters.Power.State.DeviceState;
        }
    }

    IoSkipCurrentIrpStackLocation(Irp);
    status = PoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);

    HidIrKdPrint((3, "HidIrPower Exit: %x", status));
    
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidir\ioctl.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ioctl.c

Abstract: Human Input Device (HID) minidriver for Infrared (IR) devices

          The HID IR Minidriver (HidIr) provides an abstraction layer for the
          HID Class to talk to HID IR devices.

Author:
            jsenior

Environment:

    Kernel mode

Revision History:


--*/
#include "pch.h"


NTSTATUS
HidIrIoctl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

   Process the Control IRPs sent to this device.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    NTSTATUS            ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION  irpStack;
    BOOLEAN             needsCompletion = TRUE;

    HidIrKdPrint((3, "HidIrIoctl Enter"));

    //
    // Get a pointer to the current location in the Irp
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get a pointer to the device extension
    //

    switch(irpStack->Parameters.DeviceIoControl.IoControlCode)
    {

    case IOCTL_HID_GET_DEVICE_DESCRIPTOR:
        //
        //  Return the HID descriptor
        //

        HidIrKdPrint((3, "IOCTL_HID_GET_DEVICE_DESCRIPTOR"));
        ntStatus = HidIrGetHidDescriptor (DeviceObject, Irp, HID_HID_DESCRIPTOR_TYPE);
        break;

    case IOCTL_HID_GET_REPORT_DESCRIPTOR:
        //
        //  Return the Report descriptor
        //

        HidIrKdPrint((3, "IOCTL_HID_GET_REPORT_DESCRIPTOR"));
        ntStatus = HidIrGetHidDescriptor (DeviceObject, Irp, HID_REPORT_DESCRIPTOR_TYPE);
        break;

    case IOCTL_GET_PHYSICAL_DESCRIPTOR:
        //
        //  Return the Report descriptor
        //

        HidIrKdPrint((3, "IOCTL_HID_GET_REPORT_DESCRIPTOR"));
        ntStatus = HidIrGetHidDescriptor (DeviceObject, Irp, HID_PHYSICAL_DESCRIPTOR_TYPE);
        break;

    case IOCTL_HID_READ_REPORT:
        //
        //  Perform a read
        //

        HidIrKdPrint((3, "IOCTL_HID_READ_REPORT"));
        ntStatus = HidIrReadReport (DeviceObject, Irp, &needsCompletion);
        break;

    case IOCTL_HID_WRITE_REPORT:
        //
        //  Perform a write
        //

        HidIrKdPrint((3, "IOCTL_HID_WRITE_REPORT not supported for IR"));
        ntStatus = STATUS_UNSUCCESSFUL;
        break;

    case IOCTL_HID_ACTIVATE_DEVICE:
    case IOCTL_HID_DEACTIVATE_DEVICE:
        /*
         *  We don't do anything for these IOCTLs but some minidrivers might.
         */
        ntStatus = STATUS_SUCCESS;
        break;

    case IOCTL_HID_GET_DEVICE_ATTRIBUTES:
        HidIrKdPrint((3, "IOCTL_GET_DEVICE_ATTRIBUTES"));
        ntStatus = HidIrGetDeviceAttributes(DeviceObject, Irp);
        break;

    case IOCTL_HID_GET_FEATURE:
    case IOCTL_HID_GET_INPUT_REPORT:
    case IOCTL_HID_SET_FEATURE:
    case IOCTL_HID_SET_OUTPUT_REPORT:
    case IOCTL_HID_GET_MS_GENRE_DESCRIPTOR:
        /*
         *  This IOCTL uses buffering method METHOD_NEITHER,
         *  so the buffer is Irp->UserBuffer.
         *  If the IRP is coming to us from user space,
         *  we must validate the buffer.
         */

    case IOCTL_HID_GET_STRING:
    case IOCTL_HID_GET_INDEXED_STRING:
        // Strings.
    case IOCTL_HID_SEND_IDLE_NOTIFICATION_REQUEST:
        // ntStatus = HidIrSendIdleNotificationRequest(DeviceObject, Irp, &needsCompletion);
        // break;

    default:
        HidIrKdPrint((3, "Unknown or unsupported IOCTL (%x)", irpStack->Parameters.DeviceIoControl.IoControlCode));
        /*
         *  Note: do not return STATUS_NOT_SUPPORTED;
         *  Just keep the default status (this allows filter drivers to work).
         */
        ntStatus = Irp->IoStatus.Status;
        break;

    }


    //
    // Complete Irp
    //

    if (needsCompletion) {
        ASSERT(ntStatus != STATUS_PENDING);

        //
        // Set real return status in Irp
        //

        Irp->IoStatus.Status = ntStatus;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    } 

    HidIrKdPrint((3, "HidIrIoctl Exit = %x", ntStatus));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidir\sysctrl.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ioctl.c

Abstract: Human Input Device (HID) minidriver for Infrared (IR) devices

          The HID IR Minidriver (HidIr) provides an abstraction layer for the
          HID Class to talk to HID IR devices.

Author:
            jsenior

Environment:

    Kernel mode

Revision History:


--*/
#include "pch.h"


#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, HidIrSystemControl)
#endif


/*
 ************************************************************
 *  HidIrSystemControl
 ************************************************************
 *
 */
NTSTATUS HidIrSystemControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    NTSTATUS            status = STATUS_SUCCESS;
    PIO_STACK_LOCATION  thisStackLoc;

    PAGED_CODE();

    thisStackLoc = IoGetCurrentIrpStackLocation(Irp);

    switch(thisStackLoc->Parameters.DeviceIoControl.IoControlCode){

        default:
            /*
             *  Note: do not return STATUS_NOT_SUPPORTED;
             *  If completing the IRP here,
             *  just keep the default status
             *  (this allows filter drivers to work).
             */
            status = Irp->IoStatus.Status;
            break;
    }


    IoCopyCurrentIrpStackLocationToNext(Irp);

    status = IoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidparse\hidparse.c ===
#include "wdm.h"
#include "hidpddi.h"
#include "hidparse.h"

NTSTATUS
DriverEntry (
   IN    PDRIVER_OBJECT    DriverObject,
   OUT   PUNICODE_STRING   RegistryPath
   )
/*++
RoutineDescription:
   Driver Entry Point.
   This entry point is called by the I/O subsystem.

Arguments:
   DriverObject - pointer to the driver object

   RegistryPath - pointer to a unicode string representing the path
                  to driver-specific key in the registry

Return Value:
   NT status code

--*/
{
    UNREFERENCED_PARAMETER  (RegistryPath);
    UNREFERENCED_PARAMETER  (DriverObject);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidir\pnp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ioctl.c

Abstract: Human Input Device (HID) minidriver for Infrared (IR) devices

          The HID IR Minidriver (HidIr) provides an abstraction layer for the
          HID Class to talk to HID IR devices.

Author:
            jsenior

Environment:

    Kernel mode

Revision History:


--*/
#include "pch.h"

//
//  The HID descriptor has some basic device info and tells how long the report
//  descriptor is.
//

HIDIR_DESCRIPTOR HidIrHidDescriptor = {
        0x09,   // length of HID descriptor
        0x21,   // descriptor type == HID
        0x0100, // hid spec release
        0x00,   // country code == Not Specified
        0x01,   // number of HID class descriptors
        0x22,   // report descriptor type
        0       // total length of report descriptor (to be set)
};

//
//  The report descriptor completely lays out what read and write packets will 
//  look like and indicates what the semantics are for each field. This here is 
//  what the report descriptor looks like in a broken out format. This is 
//  actually retrieved from the registry (device key).
//
/*
HID_REPORT_DESCRIPTOR HidIrReportDescriptor[] = {
    // Keyboard
        0x05,   0x01,       // Usage Page (Generic Desktop),
        0x09,   0x06,       // Usage (Keyboard),
        0xA1,   0x01,       // Collection (Application),
        0x85,   0x01,       //  Report Id (1)
        
        0x05,   0x07,       //  usage page key codes
        0x19,   0xe0,       //  usage min left control
        0x29,   0xe7,       //  usage max keyboard right gui
        0x75,   0x01,       //  report size 1
        0x95,   0x08,       //  report count 8
        0x81,   0x02,       //  input (Variable)
        
        0x19,   0x00,       //  usage min 0
        0x29,   0x91,       //  usage max 91
        0x26,   0xff, 0x00, //  logical max 0xff
        0x75,   0x08,       //  report size 8
        0x95,   0x01,       //  report count 1
        0x81,   0x00,       //  Input (Data, Array),
        0xC0,               // End Collection

    // Consumer Controls
        0x05,   0x0c,       // Usage Page (Consumer Controls),
        0x09,   0x01,       // Usage (Consumer Control),
        0xA1,   0x01,       // Collection (Application),
        0x85,   0x02,       //  Report Id (2)
        0x19,   0x00,       //  Usage Minimum (0),
        0x2a,   0x3c, 0x02, //  Usage Maximum (23c)  
        0x15,   0x00,       //  Logical Minimum (0),
        0x26,   0x3c, 0x02, //  Logical Maximum (23c)  
        0x95,   0x01,       //  Report Count (1),
        0x75,   0x10,       //  Report Size (16),
        0x81,   0x00,       //  Input (Data, Array), 
        0xC0,               // End Collection

    // Standby button
        0x05, 0x01,         // Usage Page (Generic Desktop),
        0x09, 0x80,         // Usage (System Control),
        0xa1, 0x01,         // Collection (Application),
        0x85, 0x03,         //  Report Id (3)
        0x19, 0x81,         //  Usage Minimum (0x81),
        0x29, 0x83,         //  Usage Maximum (0x83),
        0x25, 0x01,         //  Logical Maximum(1),
        0x75, 0x01,         //  Report Size (1),
        0x95, 0x03,         //  Report Count (3),
        0x81, 0x02,         //  Input
        0x95, 0x05,         //  Report Count (5),
        0x81, 0x01,         //  Input (Constant),
        0xc0                // End Collection   
        };
          

//
//  The mapping table translates from what the irbus driver gives us into a 
//  HID report to return to hidclass. The hid report is of the correct length
//  according to what the registry told us (device key).
//
USAGE_TABLE_ENTRY HidIrMappingTable[] = {
    { 0x00001808, {0x01,0x00,0x1e}},  // 1
    { 0x00001828, {0x01,0x00,0x1f}},  // 2
    { 0x00001818, {0x01,0x00,0x20}},  // 3
    { 0x0000182b, {0x01,0x02,0x20}},  // # (shift+3)
    { 0x00001804, {0x01,0x00,0x21}},  // 4
    { 0x00001824, {0x01,0x00,0x22}},  // 5
    { 0x00001814, {0x01,0x00,0x23}},  // 6
    { 0x0000180c, {0x01,0x00,0x24}},  // 7
    { 0x0000182c, {0x01,0x00,0x25}},  // 8
    
    { 0x00000001, {0x01,0x00,0x55}},  // Numpad *
    
    { 0x0000181c, {0x01,0x00,0x26}},  // 9
    { 0x00001822, {0x01,0x00,0x27}},  // 0
    { 0x00001836, {0x01,0x00,0x28}},  // return
    
    { 0x0000000B, {0x01,0x04,0x29}},  // alt+escape
    
    { 0x0000182b, {0x01,0x00,0x2a}},  // delete (backspace)
    { 0x00001806, {0x01,0x00,0x2b}},  // tab
    { 0x0000180e, {0x01,0x02,0x2b}},  // shift+tab
    { 0x00001826, {0x01,0x00,0x4b}},  // page up
    { 0x0000182e, {0x01,0x00,0x4e}},  // page down
    { 0x0000181e, {0x01,0x00,0x51}},  // down
    { 0x00001816, {0x01,0x00,0x52}},  // up
    { 0x0000181a, {0x01,0x00,0x65}},  // context

    { 0x00001813, {0x02,0x09,0x02}},  // AC Properties
    { 0x00001800, {0x02,0x24,0x02}},  // AC Back
    { 0x0000180a, {0x02,0x2a,0x02}},  // AC favorites
    { 0x00001823, {0x02,0x30,0x02}},  // AC full screen

    { 0x00001830, {0x02,0xb0,0x00}},  // AC Media play
    { 0x00001830, {0x02,0xb1,0x00}},  // AC Media pause
    { 0x0000183e, {0x02,0xb2,0x00}},  // AC Media record
    { 0x00001829, {0x02,0xb3,0x00}},  // AC FF
    { 0x00001838, {0x02,0xb4,0x00}},  // AC RW
    { 0x00001831, {0x02,0xb5,0x00}},  // AC Media next track
    { 0x00001811, {0x02,0xb6,0x00}},  // AC Media previous track
    { 0x00001821, {0x02,0xb7,0x00}},  // AC Media Stop
    
    { 0x0000000B, {0x02,0xe9,0x00}},  // AC volume up
    { 0x0000000B, {0x02,0xea,0x00}},  // AC volume down
    { 0x0000000B, {0x02,0xe2,0x00}},  // AC volume mute
    
    { 0x00001803, {0x02,0x8d,0x00}},  // AC select program guide
    { 0x00001801, {0x02,0x9c,0x00}},  // AC channel up
    { 0x0000183c, {0x02,0x9d,0x00}}};  // AC channel down



*/

NTSTATUS
HidIrRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
HidIrCleanupDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
HidIrStopDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
HidIrStopCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HidIrStartCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HidIrInitDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
HidIrStartDevice(
    IN  PDEVICE_OBJECT DeviceObject
    );

#ifdef ALLOC_PRAGMA
// NOTE: Every single function in this file is pageable.
    #pragma alloc_text(PAGE, HidIrStartDevice)
    #pragma alloc_text(PAGE, HidIrPnP)
    #pragma alloc_text(PAGE, HidIrRemoveDevice)
    #pragma alloc_text(PAGE, HidIrCleanupDevice)
    #pragma alloc_text(PAGE, HidIrStopDevice)
    #pragma alloc_text(PAGE, HidIrStopCompletion)
    #pragma alloc_text(PAGE, HidIrStartCompletion)
    #pragma alloc_text(PAGE, HidIrInitDevice)
#endif

NTSTATUS
HidIrStartDevice(
    IN  PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Begins initialization a given instance of a HID device.  Work done here occurs before
    the parent node gets to do anything.

Arguments:

    DeviceObject - pointer to the device object for this instance.

Return Value:

    NT status code

--*/
{
    PHIDIR_EXTENSION devExt;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG oldDeviceState;

    PAGED_CODE();

    // Get a pointer to the device extension
    devExt = GET_MINIDRIVER_HIDIR_EXTENSION(DeviceObject);

    HidIrKdPrint((3, "HidIrStartDevice devExt = %x", devExt));

    // Start the device
    oldDeviceState = devExt->DeviceState;
    devExt->DeviceState = DEVICE_STATE_STARTING;

    KeResetEvent(&devExt->AllRequestsCompleteEvent);

    if ((oldDeviceState == DEVICE_STATE_STOPPING) ||
        (oldDeviceState == DEVICE_STATE_STOPPED)  ||
        (oldDeviceState == DEVICE_STATE_REMOVING)){

        /*
         *  We did an extra decrement when the device was stopped.
         *  Now that we're restarting, we need to bump it back to zero.
         */
        NTSTATUS incStat = HidIrIncrementPendingRequestCount(devExt);
        ASSERT(NT_SUCCESS(incStat));
        ASSERT(devExt->NumPendingRequests == 0);
        HidIrKdPrint((2, "Got start-after-stop; re-incremented pendingRequestCount"));
    }

    HidIrKdPrint((3, "HidIrStartDevice Exit = %x", ntStatus));

    return ntStatus;
}

NTSTATUS
HidIrQueryDeviceKey (
    IN  HANDLE  Handle,
    IN  PWCHAR  ValueNameString,
    OUT PVOID   *Data,
    OUT ULONG   *DataLength
    )
{
    NTSTATUS        status;
    UNICODE_STRING  valueName;
    ULONG           length;
    KEY_VALUE_FULL_INFORMATION info;

    ASSERT(Data);
    ASSERT(DataLength);

    // Init
    *Data = NULL;
    *DataLength = 0;

    RtlInitUnicodeString (&valueName, ValueNameString);

    status = ZwQueryValueKey (Handle,
                              &valueName,
                              KeyValueFullInformation,
                              &info,
                              sizeof(info),
                              &length);
    
    if (STATUS_BUFFER_TOO_SMALL == status ||
        STATUS_BUFFER_OVERFLOW == status) {
        PKEY_VALUE_FULL_INFORMATION fullInfo;

        fullInfo = ALLOCATEPOOL (PagedPool, length);

        if (fullInfo) {

            status = ZwQueryValueKey (Handle,
                                      &valueName,
                                      KeyValueFullInformation,
                                      fullInfo,
                                      length,
                                      &length);
            if (NT_SUCCESS(status)) {
                *DataLength = fullInfo->DataLength;
                *Data = ALLOCATEPOOL (NonPagedPool, fullInfo->DataLength);
                if (*Data) {
                    RtlCopyMemory (*Data,
                                   ((PUCHAR) fullInfo) + fullInfo->DataOffset,
                                   fullInfo->DataLength);
                } else {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
            
            ExFreePool (fullInfo);
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } else if (NT_SUCCESS(status)) {
        HIR_TRAP(); // we didn't alloc any space. This is bad.
        status = STATUS_UNSUCCESSFUL;
    }

    return status;
}

#define HIDIR_REPORT_LENGTH L"ReportLength"
#define HIDIR_REPORT_DESCRIPTOR L"ReportDescriptor"
#define HIDIR_MAPPING_TABLE L"ReportMappingTable"
#define HIDIR_VENDOR_ID L"VendorID"
#define HIDIR_PRODUCT_ID L"ProductID"

NTSTATUS
HidIrInitDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Get the device information and attempt to initialize a configuration
    for a device.  If we cannot identify this as a valid HID device or
    configure the device, our start device function is failed.

Arguments:

    DeviceObject - pointer to a device object.

Return Value:

    NT status code.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PHIDIR_EXTENSION devExt;
    PHID_DEVICE_EXTENSION hidExtension;
    HANDLE devInstRegKey = NULL;
    ULONG dataLen;

    PAGED_CODE();

    HidIrKdPrint((3, "HidIrInitDevice Entry"));

    hidExtension = DeviceObject->DeviceExtension;
    devExt = GET_MINIDRIVER_HIDIR_EXTENSION(DeviceObject);

    devExt->HidDescriptor = HidIrHidDescriptor;

    status = IoOpenDeviceRegistryKey (hidExtension->PhysicalDeviceObject,
                                      PLUGPLAY_REGKEY_DEVICE,
                                      STANDARD_RIGHTS_READ,
                                      &devInstRegKey);

    if (NT_SUCCESS (status)) {
        PULONG reportLength;
        status = HidIrQueryDeviceKey (devInstRegKey,
                                      HIDIR_REPORT_LENGTH,
                                      &reportLength,
                                      &dataLen);
        if (NT_SUCCESS (status)) {
            if (dataLen == sizeof(ULONG)) {
                devExt->ReportLength = *reportLength;
            } else {
                status = STATUS_INVALID_BUFFER_SIZE;
            }
            ExFreePool(reportLength);
        }
    }
  
    if (NT_SUCCESS(status)) {
        status = HidIrQueryDeviceKey (devInstRegKey,
                                      HIDIR_REPORT_DESCRIPTOR,
                                      &devExt->ReportDescriptor,
                                      &dataLen);
        if (NT_SUCCESS(status)) {
            ASSERT(dataLen);
            devExt->HidDescriptor.DescriptorList[0].wDescriptorLength = (USHORT)dataLen;
        }
    }

    if (NT_SUCCESS(status)) {
        PULONG vendorID;
        status = HidIrQueryDeviceKey (devInstRegKey,
                                      HIDIR_VENDOR_ID,
                                      &vendorID,
                                      &dataLen);
        if (NT_SUCCESS (status)) {
            if (dataLen == sizeof(ULONG)) {
                devExt->VendorID = (USHORT)*vendorID;
            } else {
                status = STATUS_INVALID_BUFFER_SIZE;
            }
            ExFreePool(vendorID);
        }
    }

    if (NT_SUCCESS(status)) {
        PULONG productID;
        status = HidIrQueryDeviceKey (devInstRegKey,
                                      HIDIR_PRODUCT_ID,
                                      &productID,
                                      &dataLen);
        if (NT_SUCCESS (status)) {
            if (dataLen == sizeof(ULONG)) {
                devExt->ProductID = (USHORT)*productID;
            } else {
                status = STATUS_INVALID_BUFFER_SIZE;
            }
            ExFreePool(productID);
        }
    }

    if (NT_SUCCESS (status)) {
        PUCHAR mappingTable;
        status = HidIrQueryDeviceKey (devInstRegKey,
                                      HIDIR_MAPPING_TABLE,
                                      &mappingTable,
                                      &dataLen);
        if (NT_SUCCESS(status)) {
            ULONG i;
            ULONG entrySize = HIDIR_TABLE_ENTRY_SIZE(devExt->ReportLength);

            ASSERT(dataLen > sizeof(ULONG)+devExt->ReportLength); // at least one entry
            ASSERT((dataLen % (sizeof(ULONG)+devExt->ReportLength)) == 0); // not malformed data

            // This will round down for malformed data.
            devExt->NumUsages = dataLen / (sizeof(ULONG)+devExt->ReportLength);
            // I have to do all this for 64-bit.
            devExt->MappingTable = ALLOCATEPOOL(NonPagedPool, devExt->NumUsages*entrySize);

            if (devExt->MappingTable) {

                // Fill in the table
                for (i = 0; i < devExt->NumUsages; i++) {
                    RtlCopyMemory(devExt->MappingTable+(entrySize*i), 
                                  mappingTable+((sizeof(ULONG)+devExt->ReportLength)*i),
                                  sizeof(ULONG));
                    RtlCopyMemory(devExt->MappingTable+(entrySize*i)+sizeof(ULONG), 
                                  mappingTable+((sizeof(ULONG)+devExt->ReportLength)*i)+sizeof(ULONG),
                                  devExt->ReportLength);
                }
            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
            ExFreePool(mappingTable);
        }
    }

    if (devInstRegKey) {
        ZwClose(devInstRegKey);
    }

    if (NT_SUCCESS(status)) {
        HIDP_DEVICE_DESC deviceDesc;     // 0x30 bytes

        // Find the keyboard and standby button collections and their associated report IDs.
        ASSERT(!devExt->KeyboardReportIdValid);
        if (NT_SUCCESS(HidP_GetCollectionDescription(
                        devExt->ReportDescriptor,
                        devExt->HidDescriptor.DescriptorList[0].wDescriptorLength,
                        NonPagedPool,
                        &deviceDesc))) {
            ULONG i,j;
            UCHAR nCollectionKbd, nCollectionStandby;
            BOOLEAN foundKbd = FALSE, foundStandby = FALSE;
            for (i = 0; i < deviceDesc.CollectionDescLength; i++) {
                PHIDP_COLLECTION_DESC collection = &deviceDesc.CollectionDesc[i];
                
                if (collection->UsagePage == HID_USAGE_PAGE_GENERIC &&
                    (collection->Usage == HID_USAGE_GENERIC_KEYBOARD ||
                     collection->Usage == HID_USAGE_GENERIC_KEYPAD)) {
                    
                    // Found the collection, onto the report id!
                    nCollectionKbd = collection->CollectionNumber;
                    foundKbd = TRUE;
                } else if (collection->UsagePage == HID_USAGE_PAGE_GENERIC &&
                           collection->Usage == HID_USAGE_GENERIC_SYSTEM_CTL) {
                    nCollectionStandby = collection->CollectionNumber;
                    foundStandby = TRUE;
                }
            }
            for (j = 0; j < deviceDesc.ReportIDsLength; j++) {
                if (foundKbd && deviceDesc.ReportIDs[j].CollectionNumber == nCollectionKbd) {

                    // I make the assumption that there is only one report id on this collection.
                    devExt->KeyboardReportId = deviceDesc.ReportIDs[j].ReportID;
                    devExt->KeyboardReportIdValid = TRUE;
                } else if (foundStandby && deviceDesc.ReportIDs[j].CollectionNumber == nCollectionStandby) {

                    // I make the assumption that there is only one report id on this collection.
                    devExt->StandbyReportId = deviceDesc.ReportIDs[j].ReportID;
                    devExt->StandbyReportIdValid = TRUE;
                }
            }

            HidP_FreeCollectionDescription(&deviceDesc);
        }                                        
    }

    return status;
}

NTSTATUS
HidIrStartCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Completes initialization a given instance of a HID device.  Work done here occurs
    after the parent node has done its StartDevice.

Arguments:

    DeviceObject - pointer to the device object for this instance.

Return Value:

    NT status code

--*/
{
    PHIDIR_EXTENSION devExt;
    NTSTATUS ntStatus;

    PAGED_CODE();

    HidIrKdPrint((3, "HidIrStartCompletion Enter"));

    //
    // Get a pointer to the device extension
    //

    devExt = GET_MINIDRIVER_HIDIR_EXTENSION(DeviceObject);

    devExt->DeviceState = DEVICE_STATE_RUNNING;

    HidIrKdPrint((3, "DeviceObject (%x) was started!", DeviceObject));

    ntStatus = HidIrInitDevice(DeviceObject);

    if(NT_SUCCESS(ntStatus)) {
        HidIrKdPrint((3, "DeviceObject (%x) was configured!", DeviceObject));
    } else {
        HidIrKdPrint((1, "'HIDIR.SYS: DeviceObject (%x) configuration failed!", DeviceObject));
        devExt->DeviceState = DEVICE_STATE_STOPPING;
    }

    HidIrKdPrint((3, "HidIrStartCompletion Exit = %x", ntStatus));

    return ntStatus;
}


NTSTATUS
HidIrStopDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Stops a given instance of a device.  Work done here occurs before the parent
    does its stop device.

Arguments:

    DeviceObject - pointer to the device object.

Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PHIDIR_EXTENSION devExt;

    PAGED_CODE();

    HidIrKdPrint((3, "HidIrStopDevice Enter"));

    //
    // Get a pointer to the device extension
    //

    devExt = GET_MINIDRIVER_HIDIR_EXTENSION(DeviceObject);

    HidIrKdPrint((3, "DeviceExtension = %x", devExt));

    devExt->DeviceState = DEVICE_STATE_STOPPING;

    HidIrDecrementPendingRequestCount(devExt);
    KeWaitForSingleObject( &devExt->AllRequestsCompleteEvent,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );

    //
    // Stop the device
    //

    HidIrKdPrint((3, "HidIrStopDevice = %x", ntStatus));

    return ntStatus;
}

VOID
HidIrFreeResources(
    PHIDIR_EXTENSION DevExt
    )
{
    PAGED_CODE();

    if (DevExt->ReportDescriptor) {
        ExFreePool(DevExt->ReportDescriptor);
        DevExt->ReportDescriptor = NULL;
    }
    
    if (DevExt->MappingTable) {
        ExFreePool(DevExt->MappingTable);
        DevExt->MappingTable = NULL;
    }

    DevExt->KeyboardReportIdValid = FALSE;
    DevExt->StandbyReportIdValid = FALSE;
}

NTSTATUS
HidIrStopCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++

Routine Description:

    Stops a given instance of a device.  Work done here occurs after the parent
    has done its stop device.

Arguments:

    DeviceObject - pointer to the device object.

Return Value:

    NT status code

--*/
{
    PHIDIR_EXTENSION devExt;
    NTSTATUS ntStatus;

    PAGED_CODE();

    HidIrKdPrint((3, "HidIrStopCompletion Enter"));

    //
    // Get a pointer to the device extension
    //

    devExt = GET_MINIDRIVER_HIDIR_EXTENSION(DeviceObject);

    HidIrKdPrint((3, "DeviceExtension = %x", devExt));

    ntStatus = Irp->IoStatus.Status;

    if(NT_SUCCESS(ntStatus)) {

        HidIrKdPrint((3, "DeviceObject (%x) was stopped!", DeviceObject));

    } else {
        //
        // The PnP call failed!
        //

        HidIrKdPrint((3, "DeviceObject (%x) failed to stop!", DeviceObject));
    }

    HidIrFreeResources(devExt);

    devExt->DeviceState = DEVICE_STATE_STOPPED;

    HidIrKdPrint((3, "HidIrStopCompletion Exit = %x", ntStatus));

    return ntStatus;
}

NTSTATUS
HidIrCleanupDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PHIDIR_EXTENSION devExt;
    ULONG oldDeviceState;

    PAGED_CODE();

    HidIrKdPrint((3, "HidIrCleanupDevice Enter"));

    devExt = GET_MINIDRIVER_HIDIR_EXTENSION(DeviceObject);

    oldDeviceState = devExt->DeviceState;
    devExt->DeviceState = DEVICE_STATE_REMOVING;

    if (devExt->QueryRemove) {
        // We are severing our relationship with this device
        // through a disable/uninstall in device manager.
        // If the device is virtually cabled, we must "unplug"
        // that device so that it can go elsewhere.
    }

    if (oldDeviceState == DEVICE_STATE_RUNNING) {
        HidIrDecrementPendingRequestCount(devExt);
    } else {
        ASSERT( devExt->NumPendingRequests == -1 );
    }

    return STATUS_SUCCESS;
}

NTSTATUS
HidIrRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Removes a given instance of a device.

Arguments:

    DeviceObject - pointer to the device object.

Return Value:

    NT status code

--*/
{
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    PHIDIR_EXTENSION devExt;

    PAGED_CODE();

    HidIrKdPrint((3, "HidIrRemoveDevice Enter"));

    //
    // Get a pointer to the device extension
    //

    devExt = GET_MINIDRIVER_HIDIR_EXTENSION(DeviceObject);

    HidIrKdPrint((3, "DeviceExtension = %x", devExt));

    HidIrCleanupDevice(DeviceObject);

    KeWaitForSingleObject( &devExt->AllRequestsCompleteEvent,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );

    KeCancelTimer( &devExt->IgnoreStandbyTimer );

    HidIrFreeResources(devExt);

    ASSERT(devExt->NumPendingRequests == -1);

    HidIrKdPrint((3, "HidIrRemoveDevice = %x", ntStatus));

    return ntStatus;
}

NTSTATUS
HidIrPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++

Routine Description:

    Process the PnP IRPs sent to this device.

Arguments:

    DeviceObject - pointer to a device object.

    Irp - pointer to an I/O Request Packet.

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpStack;
    PIO_STACK_LOCATION NextStack;
    PHIDIR_EXTENSION devExt;

    PAGED_CODE();

    //
    // Get a pointer to the device extension
    //

    devExt = GET_MINIDRIVER_HIDIR_EXTENSION(DeviceObject);

    //
    // Get a pointer to the current location in the Irp
    //

    IrpStack = IoGetCurrentIrpStackLocation (Irp);

    HidIrKdPrint((3, "HidIrPnP fn %x DeviceObject = %x DeviceExtension = %x", IrpStack->MinorFunction, DeviceObject, devExt));

    switch(IrpStack->MinorFunction)
    {
    case IRP_MN_START_DEVICE:
        ntStatus = HidIrStartDevice(DeviceObject);
        break;

    case IRP_MN_STOP_DEVICE:
        ntStatus = HidIrStopDevice(DeviceObject);
        break;

    case IRP_MN_SURPRISE_REMOVAL:
        ntStatus = HidIrCleanupDevice(DeviceObject);
        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:
        devExt->QueryRemove = TRUE;
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:
        devExt->QueryRemove = FALSE;
        break;

    case IRP_MN_REMOVE_DEVICE:
        ntStatus = HidIrRemoveDevice(DeviceObject);
        break;

    }

    if (NT_SUCCESS(ntStatus)) {

        ntStatus = HidIrCallDriverSynchronous(DeviceObject, Irp);

        switch(IrpStack->MinorFunction)
        {
        case IRP_MN_START_DEVICE:
            if (NT_SUCCESS(ntStatus)) {
                ntStatus = HidIrStartCompletion(DeviceObject, Irp);
                Irp->IoStatus.Status = ntStatus;

            }
            if (!NT_SUCCESS(ntStatus)) {
                HidIrDecrementPendingRequestCount(devExt);
            }
            break;

        case IRP_MN_STOP_DEVICE:
            ntStatus = HidIrStopCompletion(DeviceObject, Irp);
            break;

        default:
            break;
        }
    }

    // Set the status of the Irp
    Irp->IoStatus.Status = ntStatus;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    HidIrKdPrint((3, "HidIrPnP Exit status %x", ntStatus));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidparse\descript.c ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    descript.c

Abstract:
    This module contains the code for parsing HID descriptors.

Environment:

    Kernel & user mode

Revision History:

    Aug-96 : created by Kenneth Ray

--*/

#include "wdm.h"
#include "hidpddi.h"
#include "hidusage.h"

#define FAR
#include "poclass.h"
#include "hidparse.h"

#define HIDP_LINK_COLLECTION_NODE use internal "private" only
#define PHIDP_LINK_COLLECTION_NODE use internal "private" only


typedef struct _HIDP_COLLECTION_DESC_LIST
{
   struct _HIDP_COLLECTION_DESC;
   struct _HIDP_COLLECTION_DESC_LIST * NextCollection;
} HIDP_COLLECTION_DESC_LIST, *PHIDP_COLLECTION_DESC_LIST;

typedef struct _HIDP_PARSE_GLOBAL_PUSH
{
   USHORT UsagePage;
   USHORT ReportSize,    ReportCount;
   USHORT NumGlobalUnknowns;

   LONG   LogicalMin,    LogicalMax;
   LONG   PhysicalMin,   PhysicalMax;
   ULONG  UnitExp,       Unit;
   HIDP_UNKNOWN_TOKEN    GlobalUnknowns [HIDP_MAX_UNKNOWN_ITEMS];

   struct _HIDP_REPORT_IDS        * ReportIDs;
   struct _HIDP_PARSE_GLOBAL_PUSH * Pop;
} HIDP_PARSE_GLOBAL_PUSH, *PHIDP_PARSE_GLOBAL_PUSH;


typedef struct _HIDP_PARSE_LOCAL_RANGE
{
   BOOLEAN  Range;
   BOOLEAN  IsAlias;
   // This usage is an alias (as declaired with a delimiter)
   // An alias of the next LOCAL_RANGE on the LOCAL_RANGE stack
   USHORT   UsagePage;
   USHORT   Value,  Min,  Max;
} HIDP_PARSE_LOCAL_RANGE, *PHIDP_PARSE_LOCAL_RANGE;

typedef struct _HIDP_PARSE_LOCAL_RANGE_LIST
{
   HIDP_PARSE_LOCAL_RANGE;
   UCHAR       Depth;
   UCHAR       Reserved2[1];
   struct _HIDP_PARSE_LOCAL_RANGE_LIST * Next;
} HIDP_PARSE_LOCAL_RANGE_LIST, *PHIDP_PARSE_LOCAL_RANGE_LIST;

NTSTATUS HidP_AllocateCollections (PHIDP_REPORT_DESCRIPTOR, ULONG, POOL_TYPE, PHIDP_COLLECTION_DESC_LIST *, PULONG, PHIDP_GETCOLDESC_DBG, PHIDP_DEVICE_DESC);
NTSTATUS HidP_ParseCollections (PHIDP_REPORT_DESCRIPTOR, ULONG, POOL_TYPE, PHIDP_COLLECTION_DESC_LIST, ULONG, PHIDP_GETCOLDESC_DBG, PHIDP_DEVICE_DESC);
void HidP_AssignDataIndices (PHIDP_PREPARSED_DATA, PHIDP_GETCOLDESC_DBG);
PHIDP_PARSE_LOCAL_RANGE_LIST HidP_FreeUsageList (PHIDP_PARSE_LOCAL_RANGE_LIST);
PHIDP_PARSE_LOCAL_RANGE_LIST HidP_PushUsageList (PHIDP_PARSE_LOCAL_RANGE_LIST, POOL_TYPE, BOOLEAN);
PHIDP_PARSE_LOCAL_RANGE_LIST HidP_PopUsageList (PHIDP_PARSE_LOCAL_RANGE_LIST);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HidP_AllocateCollections)
#pragma alloc_text(PAGE, HidP_ParseCollections)
#pragma alloc_text(PAGE, HidP_AssignDataIndices)
#pragma alloc_text(PAGE, HidP_GetCollectionDescription)
#pragma alloc_text(PAGE, HidP_FreeUsageList)
#pragma alloc_text(PAGE, HidP_PushUsageList)
#pragma alloc_text(PAGE, HidP_PopUsageList)
#endif


NTSTATUS
HidP_GetCollectionDescription(
   IN     PHIDP_REPORT_DESCRIPTOR   ReportDesc,
   IN     ULONG                     DescLength,
   IN     POOL_TYPE                 PoolType,
   OUT    PHIDP_DEVICE_DESC         DeviceDesc
   )
/*++
Routine Description:
   see hidpi.h for a description of this function.

    GetCollectionDescription is a one time cost.
    The following function and its support functions were put together
    in as straight forward (as HID will allow) manner.
    Not major opt. has been made.

--*/
{
   NTSTATUS                   status = STATUS_SUCCESS;
   PHIDP_COLLECTION_DESC_LIST collectDesc = 0;
   PHIDP_COLLECTION_DESC_LIST nextCollectDesc = 0;
   ULONG                      numCols = 0;
   ULONG                      collectionDescLength = 0;

// First Pass allocate memory for the collections.

   DeviceDesc->Dbg.ErrorCode = HIDP_GETCOLDESC_SUCCESS;

   RtlZeroMemory (DeviceDesc, sizeof (HIDP_DEVICE_DESC));

   HidP_KdPrint(0, ("'Preparing to Allocate memory\n"));
   status = HidP_AllocateCollections (ReportDesc,
                                      DescLength,
                                      PoolType,
                                      &collectDesc,
                                      &numCols,
                                      &DeviceDesc->Dbg,
                                      DeviceDesc);
   if (0 == numCols)
   {
      // No collections were reported.  That means that this device did not
      // report any top level collections in its report descriptor.
      // This is most bad.
      status = STATUS_NO_DATA_DETECTED;
      goto HIDP_GETCOLLECTIONS_REJECT;
   }
   if (!NT_SUCCESS(status))
   {
      // Something went wrong in the allocation of the memory.
      goto HIDP_GETCOLLECTIONS_REJECT;
   }

   // Second Pass fill in the data.

   HidP_KdPrint(0, ("'Starting Parsing Pass\n"));
   status = HidP_ParseCollections(ReportDesc,
                                  DescLength,
                                  PoolType,
                                  collectDesc,
                                  numCols,
                                  &DeviceDesc->Dbg,
                                  DeviceDesc);


   if (NT_SUCCESS (status))
   {
      DeviceDesc->CollectionDesc =
          (PHIDP_COLLECTION_DESC)
          ExAllocatePool (PoolType, numCols * sizeof (HIDP_COLLECTION_DESC));

       if (! (DeviceDesc->CollectionDesc))
       {
          status = STATUS_INSUFFICIENT_RESOURCES;
          HidP_KdPrint(2, ("Insufficitent Resources at VERY END\n"));
          DeviceDesc->Dbg.BreakOffset = DescLength;
          DeviceDesc->Dbg.ErrorCode =   HIDP_GETCOLDESC_RESOURCES;
          goto HIDP_GETCOLLECTIONS_REJECT;
       }

       //
       // Here we flatten out the collection descriptions but we never
       // flatten the PHIDP_PREPARSED_DATA data.  We could (should) do that as
       // well if we ever optimize.
       //
       DeviceDesc->CollectionDescLength = numCols;
       numCols = 0;
       while (collectDesc)
       {
          nextCollectDesc = collectDesc->NextCollection;
          RtlCopyMemory (DeviceDesc->CollectionDesc + (numCols++),
                         collectDesc,
                         sizeof (HIDP_COLLECTION_DESC));
          HidP_AssignDataIndices (collectDesc->PreparsedData, &DeviceDesc->Dbg);
          ExFreePool (collectDesc);
          collectDesc = nextCollectDesc;
       }

       return STATUS_SUCCESS;
   }

HIDP_GETCOLLECTIONS_REJECT:
   while (collectDesc)
   {
      nextCollectDesc = collectDesc->NextCollection;
      if (collectDesc->PreparsedData)
      {
         ExFreePool (collectDesc->PreparsedData);
      }
      ExFreePool (collectDesc);
      collectDesc = nextCollectDesc;
   }

   if (DeviceDesc->ReportIDs)
   {
      ExFreePool (DeviceDesc->ReportIDs);
   }
   return status;
}

#define MORE_DATA(_pos_, _len_) \
      if (!((_pos_) < (_len_))) \
      { \
        DeviceDesc->Dbg.BreakOffset = descIndex; \
        DeviceDesc->Dbg.ErrorCode = HIDP_GETCOLDESC_BUFFER; \
        return STATUS_BUFFER_TOO_SMALL; \
      }

NTSTATUS
HidP_AllocateCollections (
   IN  PHIDP_REPORT_DESCRIPTOR      RepDesc,
   IN  ULONG                        RepDescLen,
   IN  POOL_TYPE                    PoolType,
   OUT PHIDP_COLLECTION_DESC_LIST * ColsRet,
   OUT PULONG                       NumCols,
   OUT PHIDP_GETCOLDESC_DBG         Dbg,
   OUT PHIDP_DEVICE_DESC            DeviceDesc)
/*++
Routine Description:
   Allocate a link list of Collection descriptors for use by the preparser.
   Each collection descriptor represents a top level app collection found
   in the given report descriptor, and contains enough memory (scratch space)
   into which to write the preparsed data.
   Return a linked list of such collections.

   In each collection also allocate enough space for the preparsed data, based
   on the number of channels required.

   Also allocate memory for the three report ID structures.

Parameters:
   Rep      The given raw report descriptor.
   RepLen   Length of this said descriptor.
   ColsRet  The head of the list of collection descriptors.
   NumCols  Then number of collection descriptors in said list.
--*/
{
   PHIDP_COLLECTION_DESC_LIST preCol    = 0;
   PHIDP_COLLECTION_DESC_LIST curCol    = 0;
   PHIDP_PREPARSED_DATA       preparsed = 0;

   HIDP_ITEM    item;
   ULONG        descIndex       = 0;
   LONG         colDepth        = 0; // nested collections
   SHORT        usageDepth      = 0; // How many usages for each main item

   USHORT       inputChannels   = 0;
   USHORT       outputChannels  = 0;
   USHORT       featureChannels = 0;
   USHORT       length;
   USHORT       numLinkCollections = 0;
   // Link Collections within a top level collection.
   UCHAR        tmpBitField     = 0;

   BOOLEAN      newReportID = FALSE;
   UCHAR        numReports = 0;
   BOOLEAN      defaultReportIDUsed = FALSE;
   BOOLEAN      noDefaultReportIDAllowed = FALSE;
   //
   // numReports indicates the number of HIDP_REPORT_IDS structures needed
   // to describe this device.  If the device has only one top level collection
   // then the report descriptor need not contain a report id declaration, and
   // the given device will not prepend a report ID to the input report packets.
   // newReportID indicates the parser has found no report id declaration thus
   // far in the report descriptor.
   //
   // newReportID is set to TRUE with each entrance of a top level collection,
   // this allocation routine sets this to FALSE when it see a report ID
   // declaration.
   //
   // We start newReportID as FALSE so that we can test for TRUE on entering
   // a top level collection.  If, for some reason, we enter an additional top
   // level collection and newReportID is still set to TRUE then we have a
   // violation of the HID spec.  `No report may span a top level collection.'
   //
   // Also a report ID of zero is not allowed.  If there is no declaration
   // of a report id then (1) all channels will have there report id field set
   // to zero (aka none) (2) only one top level collection may be encountered.
   // We track this with the defaultReportIDUsed noDefaultReportIDAllowed
   // locals.
   //

   *NumCols = 0;
   // currentTopCollection = 1;
   //
   // each collection returned from the preparser has a unique collection number
   // associated with it.  The preparser only concerns itself with top-level
   // collections.  This number DOES NOT in any way correspond with the
   // accessor functions, used by the client, described in hidpi.h.  The client
   // receives only one collection at a time, and within each top level
   // collection there are subcollections (link collections) which are
   // given another set of numberings.
   // We track the current collection number by the number of collections,
   // argument passed in by the caller.
   //


   while (descIndex < RepDescLen)
   {
      item = *(RepDesc + descIndex++);
      switch (item)
      {
      case HIDP_MAIN_COLLECTION:
         MORE_DATA (descIndex, RepDescLen);
         item = *(RepDesc + descIndex++);
         if (1 == ++colDepth)
         {  // We will regard any top level collection as an application
            // collection.
            // We will regard second level collections as a linked collection
            // (or sub collection defined by the HIDP_PRIVATE_LINK_COLLECTION_NODE)
            //

            inputChannels = outputChannels = featureChannels = 0;
            numLinkCollections = 1;
            // Link collection zero is understood to be the top level
            // collection so we need to start out with at least one node
            // allocated.

            if (0 == usageDepth) {
                HidP_KdPrint (2, ("No usage for top level collection: %d!\n",
                               *NumCols));
                Dbg->BreakOffset = descIndex;
                Dbg->ErrorCode = HIDP_GETCOLDESC_TOP_COLLECTION_USAGE;
                Dbg->Args[0] = *NumCols;
                return STATUS_COULD_NOT_INTERPRET;
            } else if (1 < usageDepth) {
                HidP_KdPrint (2, ("Multiple usages for top level collection: %d\n",
                               *NumCols));
                Dbg->BreakOffset = descIndex;
                Dbg->ErrorCode = HIDP_GETCOLDESC_TOP_COLLECTION_USAGE;
                Dbg->Args[0] = *NumCols;
                return STATUS_COULD_NOT_INTERPRET;
            }

            if (newReportID) {
               // This is not the first top collection since this variable is
               // initialized to false.
               // Seeing this set means we have parsed an entire top level
               // collection without seing a report id.  This is bad.
               // A device with more than one top level colletion must have
               // more than one report.  And the last top level collection
               // declared no such report.
               HidP_KdPrint (2, ("No report ID for collection: %d\n", *NumCols));
               Dbg->BreakOffset = descIndex;
               Dbg->ErrorCode = HIDP_GETCOLDESC_NO_REPORT_ID;
               Dbg->Args[0] = *NumCols;
               return STATUS_COULD_NOT_INTERPRET;

            } else if (defaultReportIDUsed) {
               // This is not the first top collection since this variable is
               // initialized to FALSE;
               // So if ever we see this as true we are starting a new top
               // level collection which means there must be report ID from the
               // device and therefore there cannot exist a single channel
               // that has no declared report ID.
               HidP_KdPrint (2, ("Default report ID used inappropriately\n"));
               Dbg->BreakOffset = descIndex;
               Dbg->ErrorCode = HIDP_GETCOLDESC_DEFAULT_ID_ERROR;
               Dbg->Args[0] = *NumCols;
               return STATUS_COULD_NOT_INTERPRET;

            }

            numReports++;
            newReportID = TRUE;

            (*NumCols)++; // One more top level collection found.
            HidP_KdPrint(2, ("'Top Level Collection %d found\n", *NumCols));
            preCol = curCol;
            curCol = (PHIDP_COLLECTION_DESC_LIST)
               ExAllocatePool (PoolType, sizeof (HIDP_COLLECTION_DESC_LIST));
            if (!curCol) {
               HidP_KdPrint(2, ("No Resources to make Top level collection\n"));
               Dbg->BreakOffset = descIndex;
               Dbg->ErrorCode = HIDP_GETCOLDESC_LINK_RESOURCES;
               return STATUS_INSUFFICIENT_RESOURCES;

            }
            RtlZeroMemory (curCol, sizeof (HIDP_COLLECTION_DESC_LIST));

            if (preCol) {
               preCol->NextCollection = curCol;

            } else {
               *ColsRet = curCol;
            }
         } else if (1 < colDepth) {  // a linked collection

            HidP_KdPrint(0, ("'Enter Link Collection\n"));
            if (0 == usageDepth) {
                HidP_KdPrint (1, ("***************************************\n"));
                HidP_KdPrint (1, ("Warning! Link collection without usage \n"));
                HidP_KdPrint (1, ("Pos (%d), depth (%d)\n", descIndex, colDepth));
                HidP_KdPrint (1, ("***************************************\n"));
                usageDepth = 1;
            } else if (1 < usageDepth) {
                HidP_KdPrint (1, ("Link Collection with multiple usage decls\n"));
            }
            numLinkCollections += usageDepth;
         }
         usageDepth = 0;
         break;

      case HIDP_MAIN_ENDCOLLECTION:
         usageDepth = 0;
         if (--colDepth < 0) {
            HidP_KdPrint(2, ("Extra End Collection\n"));
            Dbg->BreakOffset = descIndex;
            Dbg->ErrorCode = HIDP_GETCOLDESC_UNEXP_END_COL;

            return STATUS_COULD_NOT_INTERPRET;
         }
         if (0 < colDepth) {
            HidP_KdPrint(0, ("'Exit Link Collection\n"));
            continue;
         }
         HidP_KdPrint (0, ("'Collection %d exit\n", *NumCols));
         curCol->CollectionNumber = (UCHAR) *NumCols;
         length = sizeof (HIDP_PREPARSED_DATA)
                           + (sizeof (HIDP_CHANNEL_DESC)
                              * (inputChannels
                                 + outputChannels
                                 + featureChannels))
                           + (sizeof (HIDP_PRIVATE_LINK_COLLECTION_NODE))
                              * numLinkCollections;

         curCol->PreparsedDataLength = length;
         curCol->PreparsedData =
               (PHIDP_PREPARSED_DATA) ExAllocatePool (PoolType, length);

         if (!curCol->PreparsedData) {
            HidP_KdPrint(2, ("Could not allocate space for PreparsedData\n"));
            Dbg->BreakOffset = descIndex;
            Dbg->ErrorCode = HIDP_GETCOLDESC_PREPARSE_RESOURCES;
            return STATUS_INSUFFICIENT_RESOURCES;
         }

         RtlZeroMemory (curCol->PreparsedData, curCol->PreparsedDataLength);
         // Set the offsets
         preparsed = curCol->PreparsedData;

         preparsed->Signature1 = HIDP_PREPARSED_DATA_SIGNATURE1;
         preparsed->Signature2 = HIDP_PREPARSED_DATA_SIGNATURE2;
         preparsed->Input.Index = (UCHAR) preparsed->Input.Offset = 0;
         length = preparsed->Input.Size = inputChannels;

         preparsed->Output.Index = preparsed->Output.Offset = (UCHAR) length;
         length += (preparsed->Output.Size = outputChannels);

         preparsed->Feature.Index = preparsed->Feature.Offset = (UCHAR) length;
         length += (preparsed->Feature.Size = featureChannels);

         preparsed->LinkCollectionArrayOffset =
                  length * sizeof (HIDP_CHANNEL_DESC);
         preparsed->LinkCollectionArrayLength = numLinkCollections;

         break;

      case HIDP_LOCAL_USAGE_4:
      case HIDP_LOCAL_USAGE_MIN_4:
         descIndex += 2;

      case HIDP_LOCAL_USAGE_2:
      case HIDP_LOCAL_USAGE_MIN_2:
         descIndex++;

      case HIDP_LOCAL_USAGE_1:
      case HIDP_LOCAL_USAGE_MIN_1:
         MORE_DATA (descIndex++, RepDescLen);
         usageDepth++;
         break;

      case HIDP_LOCAL_DELIMITER:
          if (1 != (item = *(RepDesc + descIndex))) {
              HidP_KdPrint (2, ("Delimiter not start %x\n", item));
              Dbg->BreakOffset = descIndex;
              Dbg->ErrorCode = HIDP_GETCOLDESC_MISMATCH_OC_DELIMITER;
              Dbg->Args[0] = item;
              return STATUS_COULD_NOT_INTERPRET;
          }

          MORE_DATA (descIndex++, RepDescLen);
          while (TRUE) {
              if (descIndex >= RepDescLen) {
                  HidP_KdPrint (2, ("End delimiter NOT found!\n"));
                  Dbg->BreakOffset = descIndex;
                  Dbg->ErrorCode = HIDP_GETCOLDESC_NO_CLOSE_DELIMITER;
                  return STATUS_COULD_NOT_INTERPRET;
              }
              item = *(RepDesc + descIndex++);

              if (HIDP_LOCAL_DELIMITER == item) {
                  if (0 != (item = *(RepDesc + descIndex))) {
                      HidP_KdPrint (2, ("Delimiter not stop %x\n", item));
                      Dbg->BreakOffset = descIndex;
                      Dbg->ErrorCode = HIDP_GETCOLDESC_MISMATCH_OC_DELIMITER;
                      Dbg->Args[0] = item;
                      return STATUS_COULD_NOT_INTERPRET;
                  }
                  MORE_DATA (descIndex++, RepDescLen);
                  break;
              }

              switch (item) {
//
// TODO: kenray
//
// Usage Min / Max not yet supported within delimiter.
//
//            case HIDP_LOCAL_USAGE_MAX_4:
//               descIndex += 2;
//            case HIDP_LOCAL_USAGE_MAX_2:
//               descIndex++;
//            case HIDP_LOCAL_USAGE_MAX_1:
//               descIndex++;
//               break;

              case HIDP_LOCAL_USAGE_4:
//            case HIDP_LOCAL_USAGE_MIN_4:
                  descIndex += 2;
              case HIDP_LOCAL_USAGE_2:
//            case HIDP_LOCAL_USAGE_MIN_2:
                  descIndex++;
              case HIDP_LOCAL_USAGE_1:
//            case HIDP_LOCAL_USAGE_MIN_1:
                  MORE_DATA (descIndex++, RepDescLen);
                  usageDepth++;
                  break;

              default:
                HidP_KdPrint (2, ("Invalid token found within delimiter!\n"));
                HidP_KdPrint (2, ("Only Usages are allowed within a delimiter\n"));
//               HidP_KdPrint (("IE: Only Usage, UsageMin, UsageMax tokens\n"));
                HidP_KdPrint (2, ("IE: Only Usage token allowes (no min or max)\n"));
                Dbg->BreakOffset = descIndex;
                Dbg->ErrorCode = HIDP_GETCOLDESC_NOT_VALID_DELIMITER;
                Dbg->Args[0] = item;
                return STATUS_COULD_NOT_INTERPRET;
              }
          }
          break;

      case HIDP_MAIN_INPUT_2:
         MORE_DATA (descIndex + 1, RepDescLen);
         tmpBitField = *(RepDesc + descIndex++);
         descIndex++;
         goto HIDP_ALLOC_MAIN_INPUT;

      case HIDP_MAIN_INPUT_1:
         MORE_DATA (descIndex, RepDescLen);
         tmpBitField = *(RepDesc + descIndex++);

HIDP_ALLOC_MAIN_INPUT:
         if (0 == usageDepth) {
             if (HIDP_ISCONST(tmpBitField)) {
                 break;
             }
             HidP_KdPrint (2, ("Non constant main item found without usage decl\n"));
             Dbg->BreakOffset = descIndex;
             Dbg->ErrorCode = HIDP_GETCOLDESC_MAIN_ITEM_NO_USAGE;
             return STATUS_COULD_NOT_INTERPRET;
         }

         inputChannels += (usageDepth ? usageDepth : 1);
         if (newReportID) {
            if (noDefaultReportIDAllowed) {
               // A report ID declaration was found somewhere earlier in this
               // report descriptor.  This means that ALL main items must
               // have a declared report ID.
               HidP_KdPrint (2, ("Default report ID used inappropriately\n"));
               Dbg->BreakOffset = descIndex;
               Dbg->ErrorCode = HIDP_GETCOLDESC_DEFAULT_ID_ERROR;
               Dbg->Args[0] = *NumCols;
               return STATUS_COULD_NOT_INTERPRET;
            }
            defaultReportIDUsed = TRUE;
         }
         if (0 == colDepth) {
            HidP_KdPrint (2, ("Main item found not in top level collection\n"));
            Dbg->BreakOffset = descIndex;
            Dbg->ErrorCode = HIDP_GETCOLDESC_INVALID_MAIN_ITEM;
            return STATUS_COULD_NOT_INTERPRET;
         }
         usageDepth = 0;
         break;

      case HIDP_MAIN_OUTPUT_2:
         MORE_DATA (descIndex + 1, RepDescLen);
         tmpBitField = *(RepDesc + descIndex++);
         descIndex++;
         goto HIDP_ALLOC_MAIN_OUTPUT;

      case HIDP_MAIN_OUTPUT_1:
         MORE_DATA (descIndex, RepDescLen);
         tmpBitField = *(RepDesc + descIndex++);

HIDP_ALLOC_MAIN_OUTPUT:
         if (0 == usageDepth) {
             if (HIDP_ISCONST(tmpBitField)) {
                 break;
             }
             HidP_KdPrint (2, ("Non constant main item found without usage decl\n"));
             Dbg->BreakOffset = descIndex;
             Dbg->ErrorCode = HIDP_GETCOLDESC_MAIN_ITEM_NO_USAGE;
             return STATUS_COULD_NOT_INTERPRET;
         }

         outputChannels += (usageDepth ? usageDepth : 1);
         if (newReportID) {
            if (noDefaultReportIDAllowed) {
               // A report ID declaration was found somewhere earlier in this
               // report descriptor.  This means that ALL main items must
               // have a declared report ID.
               HidP_KdPrint (2, ("Default report ID used inappropriately\n"));
               Dbg->BreakOffset = descIndex;
               Dbg->ErrorCode = HIDP_GETCOLDESC_DEFAULT_ID_ERROR;
               Dbg->Args[0] = *NumCols;
               return STATUS_COULD_NOT_INTERPRET;
            }
            defaultReportIDUsed = TRUE;
         }
         if (0 == colDepth) {
            HidP_KdPrint (2, ("Main item found not in top level collection\n"));
            Dbg->BreakOffset = descIndex;
            Dbg->ErrorCode = HIDP_GETCOLDESC_INVALID_MAIN_ITEM;
            return STATUS_COULD_NOT_INTERPRET;
         }
         usageDepth = 0;
         break;

      case HIDP_MAIN_FEATURE_2:
         MORE_DATA (descIndex + 1, RepDescLen);
         tmpBitField = *(RepDesc + descIndex++);
         descIndex++;
         goto HIDP_ALLOC_MAIN_FEATURE;

      case HIDP_MAIN_FEATURE_1:
         MORE_DATA (descIndex, RepDescLen);
         tmpBitField = *(RepDesc + descIndex++);

HIDP_ALLOC_MAIN_FEATURE:
         if (0 == usageDepth) {
             if (HIDP_ISCONST(tmpBitField)) {
                 break;
             }
             HidP_KdPrint (2, ("Non constant main item found without usage decl\n"));
             Dbg->BreakOffset = descIndex;
             Dbg->ErrorCode = HIDP_GETCOLDESC_MAIN_ITEM_NO_USAGE;
             return STATUS_COULD_NOT_INTERPRET;
         }

         featureChannels += (usageDepth ? usageDepth : 1);
         if (newReportID) {
            if (noDefaultReportIDAllowed) {
               // A report ID declaration was found somewhere earlier in this
               // report descriptor.  This means that ALL main items must
               // have a declared report ID.
               HidP_KdPrint (2, ("Default report ID used inappropriately\n"));
               Dbg->BreakOffset = descIndex;
               Dbg->ErrorCode = HIDP_GETCOLDESC_DEFAULT_ID_ERROR;
               Dbg->Args[0] = *NumCols;
               return STATUS_COULD_NOT_INTERPRET;
            }
            defaultReportIDUsed = TRUE;
         }
         if (0 == colDepth) {
            HidP_KdPrint (2, ("Main item found not in top level collection\n"));
            Dbg->BreakOffset = descIndex;
            Dbg->ErrorCode = HIDP_GETCOLDESC_INVALID_MAIN_ITEM;
            return STATUS_COULD_NOT_INTERPRET;
         }
         usageDepth = 0;
         break;

      case HIDP_GLOBAL_REPORT_ID:
         MORE_DATA (descIndex, RepDescLen);
         item = *(RepDesc + descIndex++);

         if (0 < colDepth) {
            ASSERT (curCol);
         } else {
            HidP_KdPrint(2, ("Report ID outside of Top level collection\n"));
            HidP_KdPrint(2, ("Reports cannot span more than one top level \n"));
            HidP_KdPrint(2, ("Report ID found: %d", (ULONG) item));
            Dbg->BreakOffset = descIndex;
            Dbg->ErrorCode = HIDP_GETCOLDESC_REPORT_ID;
            Dbg->Args[0] = item;
            return STATUS_COULD_NOT_INTERPRET;
         }

         if (newReportID) {
            newReportID = FALSE;
         } else {
            numReports++;
         }

         noDefaultReportIDAllowed = TRUE;
         if (defaultReportIDUsed) {
            // A report ID declaration was found somewhere earlier in this
            // report descriptor.  This means that ALL main items must
            // have a declared report ID.
            HidP_KdPrint (2, ("Default report ID used inappropriately\n"));
            Dbg->BreakOffset = descIndex;
            Dbg->ErrorCode = HIDP_GETCOLDESC_DEFAULT_ID_ERROR;
            Dbg->Args[0] = *NumCols;
            return STATUS_COULD_NOT_INTERPRET;
         }
         break;

      case HIDP_ITEM_LONG:
         HidP_KdPrint (2, ("Long Items not supported %x\n", item));
         Dbg->BreakOffset = descIndex;
         Dbg->ErrorCode = HIDP_GETCOLDESC_ITEM_UNKNOWN;
         Dbg->Args[0] = item;
         return STATUS_COULD_NOT_INTERPRET;

      default:
         // Bump past the data bytes in the descriptor.
         length = (item & HIDP_ITEM_LENGTH_DATA);
         length = (3 == length) ? 4 : length;
         if (!((descIndex + length) <= RepDescLen)) {
            // OK the lower 2 bits in the item represent the length of the
            // data if this is 3 then there are 4 data bytes following this
            // item.  DescPos already points to the next data item.
            Dbg->BreakOffset = descIndex;
            Dbg->ErrorCode = HIDP_GETCOLDESC_ONE_BYTE;
            return STATUS_BUFFER_TOO_SMALL;
         }
         descIndex += length;
         break;
      }
   }

   //
   // According to the HID spec no report id may span a top level collection.
   // which means that each collection must have at least one report, and there
   // should be at least as many report IDs as collections.  Unless there is
   // only one report (therefore only one collection).  In this case no report
   // ID will be sent from the device.  But in this case we return saying there
   // was indeed one report anyway.  The ReportID decsriptor was of length one.
   // Therefore numReports must always be greater than or equal to the number
   // of collections.
   //
   // For output and feature reports, report ids are sent as an extra argument
   // so they will always be present even if they are zero.  (Zero means that
   // the device did not list a report ID in the descriptor.)
   //
   // However with input packets the report ID is part of the packet itself:
   // the first byte.  UNLESS there is only one report, and then it is not
   // present.
   //
   // __For input packets___
   // the device can have a report ID even if it has only one
   // report.  This is odd, as it wastes a byte, but then again who knows the
   // mind of an IHV.  For this reason, hidparse must check to see if the
   // reportID  list is of length one and the report id itself (in the one and
   // only one space) is zero in order to determine if the device sends no
   // reports ids.
   // If it is zero (the device is not allowed to send report ids of zero)
   // than that report id was simulated meaning the number of bytes in the
   // packet from the device is one less than the number of byte given to the
   // user.
   // If is is non-zero, then the number of bytes from the device is the same
   // as the number of bytes given to the user.
   //

   if (numReports < *NumCols) {
      HidP_KdPrint (2, ("Report IDS cannot span collections.\n"));
      HidP_KdPrint (2, ("This means that you must have at least one report ID\n"));
      HidP_KdPrint (2, ("For each TOP level collection, unless you have only\n"));
      HidP_KdPrint (2, ("report.\n"));
      Dbg->BreakOffset = descIndex;
      Dbg->ErrorCode = HIDP_GETCOLDESC_NO_REPORT_ID;
      return STATUS_COULD_NOT_INTERPRET;
   }

   if (0 < colDepth) {
      HidP_KdPrint(2, ("End Collection not found\n"));
      Dbg->BreakOffset = descIndex;
      Dbg->ErrorCode = HIDP_GETCOLDESC_UNEXP_END_COL;
      return STATUS_COULD_NOT_INTERPRET;
   }

   //
   // Now that we have seen the entire structure, allocate the structure for
   // holding the report id switch table.
   //

   if (0 == numReports) {
      HidP_KdPrint (2, ("No top level collections were found! \n"));
      Dbg->BreakOffset = descIndex;
      Dbg->ErrorCode = HIDP_GETCOLDESC_NO_DATA;
      return STATUS_NO_DATA_DETECTED;
   }

   DeviceDesc->ReportIDsLength = numReports;
   DeviceDesc->ReportIDs = (PHIDP_REPORT_IDS)
      ExAllocatePool (PoolType, numReports * sizeof (HIDP_REPORT_IDS));

   if (!DeviceDesc->ReportIDs) {
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory (DeviceDesc->ReportIDs, numReports * sizeof (HIDP_REPORT_IDS));

   return STATUS_SUCCESS;
}


PHIDP_PARSE_LOCAL_RANGE_LIST
HidP_FreeUsageList (
   PHIDP_PARSE_LOCAL_RANGE_LIST  Usage
   )
/*++
RoutineDescription:
   clear off all the usages in the linked list
   But do not free the first element in the list.
--*/
{
   PHIDP_PARSE_LOCAL_RANGE_LIST curUsage;
   while (Usage->Next) {
       curUsage = Usage;
       Usage = curUsage->Next;
       ExFreePool (curUsage);
   }
   RtlZeroMemory (Usage, sizeof (HIDP_PARSE_LOCAL_RANGE_LIST));
   return Usage;
}

PHIDP_PARSE_LOCAL_RANGE_LIST
HidP_PushUsageList (
   PHIDP_PARSE_LOCAL_RANGE_LIST  Usage,
   POOL_TYPE                     PoolType,
   BOOLEAN                       WithinDelimiter
   )
/*++
RoutineDescription:
   allocate another Usage node and add it to the top O the list.
--*/
{
   PHIDP_PARSE_LOCAL_RANGE_LIST newUsage;

   newUsage = (PHIDP_PARSE_LOCAL_RANGE_LIST)
            ExAllocatePool (PoolType, sizeof (HIDP_PARSE_LOCAL_RANGE_LIST));
   if (newUsage) {
       RtlZeroMemory (newUsage, sizeof (HIDP_PARSE_LOCAL_RANGE_LIST));
       newUsage->Next = Usage;
       if (!WithinDelimiter) {
           newUsage->Depth = Usage->Depth
                           + (Usage->Range ? (Usage->Max - Usage->Min + 1) : 1);
       } else {
           newUsage->Depth = Usage->Depth;
           //
           // Note ranges are not allowed in delimiters therefore we know
           // that all entries in the delimiter are equal and are length 1
           //
       }
   } else {
       HidP_FreeUsageList (Usage);
   }
   return newUsage;
}

PHIDP_PARSE_LOCAL_RANGE_LIST
HidP_PopUsageList (
   PHIDP_PARSE_LOCAL_RANGE_LIST  Usage
   )
{
    PHIDP_PARSE_LOCAL_RANGE_LIST  newUsage;

    if (Usage->Next) {
        newUsage = Usage->Next;
        ExFreePool (Usage);
    } else {
        newUsage = Usage;
#if DBG
        RtlFillMemory (newUsage, sizeof (HIDP_PARSE_LOCAL_RANGE_LIST), 0xDB);
        newUsage->Depth = 0;
#endif
    }
    return newUsage;
}


#define ONE_BYTE_DATA(_data_, _pos_, _dbg_)    \
         if (!((_pos_) < RepDescLen)) { \
               status = STATUS_BUFFER_TOO_SMALL; \
               KdPrint(("More Data Expected\n")); \
               _dbg_->ErrorCode = HIDP_GETCOLDESC_ONE_BYTE; \
               _dbg_->BreakOffset = descIndex; \
               goto HIDP_PARSE_REJECT; \
            } \
         (_data_) = *(RepDesc + (_pos_)++);

#define TWO_BYTE_DATA(_data_, _pos_, _dbg_)      \
         if (!((_pos_) + 1 < RepDescLen)) { \
               status = STATUS_BUFFER_TOO_SMALL; \
               KdPrint(("More Data Expected\n")); \
               _dbg_->ErrorCode = HIDP_GETCOLDESC_TWO_BYTE; \
               _dbg_->BreakOffset = descIndex; \
               goto HIDP_PARSE_REJECT; \
            } \
         (_data_) = *(RepDesc + (_pos_)++);        \
         (_data_) |= *(RepDesc + (_pos_)++) << 8;


#define FOUR_BYTE_DATA(_data_, _pos_, _dbg_)     \
         if (!((_pos_) + 3 < RepDescLen)) { \
               status = STATUS_BUFFER_TOO_SMALL; \
               KdPrint(("More Data Expected\n")); \
               _dbg_->ErrorCode = HIDP_GETCOLDESC_FOUR_BYTE; \
               _dbg_->BreakOffset = descIndex; \
               goto HIDP_PARSE_REJECT; \
            } \
         (_data_) = *(RepDesc + (_pos_)++);        \
         (_data_) |= *(RepDesc + (_pos_)++) << 8;  \
         (_data_) |= *(RepDesc + (_pos_)++) << 16; \
         (_data_) |= *(RepDesc + (_pos_)++) << 24;

#define BIT_EXTEND_1(_data_) \
         (_data_) = ((_data_) & 0xFF) \
                  | (((_data_) & 0x80) ? 0xFFFFFF00 : 0)

#define BIT_EXTEND_2(_data_) \
         (_data_) = ((_data_) & 0xFFFF) \
                  | (((_data_) & 0x8000) ? 0xFFFF0000 : 0)


NTSTATUS
HidP_ParseCollections (
   IN     PHIDP_REPORT_DESCRIPTOR      RepDesc,
   IN     ULONG                        RepDescLen,
   IN     POOL_TYPE                    PoolType,
   IN OUT PHIDP_COLLECTION_DESC_LIST   Cols,
   IN     ULONG                        NumCols,
   OUT    PHIDP_GETCOLDESC_DBG         Dbg,
   IN OUT PHIDP_DEVICE_DESC            DeviceDesc)
/*++
Routine Description:
   Given a nice linked list of collection descriptors parse into those
   descriptors the information descerned from the Raw Report Descriptor.
   Each given CollectionDescriptor already has the proper amount of memory
   in the PreparsedData field.

Parameters:
   Rep      The given raw report descriptor.
   RepLen   Length of this said descriptor.
   ColsRet  The head of the list of collection descriptors.
   NumCols  Then number of collection descriptors in said list.
--*/
{
   HIDP_PREPARSED_DATA           safeData;
   HIDP_PARSE_GLOBAL_PUSH        firstPush  = {0,0,0,0,0,0,0,0,0,0,0};
   HIDP_PARSE_LOCAL_RANGE_LIST   firstUsage = {0,0,0,0,0};
   HIDP_PARSE_LOCAL_RANGE        designator = {0,0,0,0};
   HIDP_PARSE_LOCAL_RANGE        string     = {0,0,0,0};
   HIDP_PARSE_LOCAL_RANGE        zeroLocal  = {0,0,0,0};

   PHIDP_COLLECTION_DESC_LIST    appCol        = 0;
   PHIDP_PREPARSED_DATA          preparsed     = &safeData;
   PHIDP_PARSE_GLOBAL_PUSH       push          = &firstPush;
   PHIDP_PARSE_GLOBAL_PUSH       tmpPush       = 0;
   PHIDP_PARSE_LOCAL_RANGE_LIST  usage         = &firstUsage;
   PHIDP_PARSE_LOCAL_RANGE_LIST  tmpUsage      = 0;
   PHIDP_CHANNEL_DESC            channel       = 0;
   PHIDP_PRIVATE_LINK_COLLECTION_NODE    linkNodeArray = 0;
   PHIDP_PRIVATE_LINK_COLLECTION_NODE    parentLCNode  = 0;
   PHIDP_PRIVATE_LINK_COLLECTION_NODE    currentLCNode = 0;
   struct _HIDP_UNKNOWN_TOKEN *  unknownToken;
   USHORT                        linkNodeIndex = 0;

   ULONG        descIndex    = 0;
   ULONG        colDepth     = 0;
   NTSTATUS     status       = STATUS_SUCCESS;
   USHORT       bitPos;
   HIDP_ITEM    item;
   USHORT       tmpBitField      = 0;
   USHORT       tmpCount         = 0;
   USHORT       i;
   PUSHORT      channelIndex     = 0;

   PHIDP_REPORT_IDS              currentReportIDs = DeviceDesc->ReportIDs;
   PHIDP_REPORT_IDS              tmpReportIDs;
   BOOLEAN                       isFirstReportID = TRUE;
   BOOLEAN                       withinDelimiter = FALSE;
   BOOLEAN                       firstUsageWithinDelimiter = TRUE;
   BOOLEAN                       isAlias = FALSE;
   UCHAR                         collectionType;
   UCHAR                         tmpID;

   UNREFERENCED_PARAMETER (NumCols);

   while (descIndex < RepDescLen)
   {
      item = *(RepDesc + descIndex++);
      switch (item)
      {
      case HIDP_MAIN_COLLECTION:
         ONE_BYTE_DATA (collectionType, descIndex, Dbg);
         if (1 == ++colDepth)
         {
            //
            // We will regard any top level collection as an application
            // collection as approved by the HID committee
            //
            // we will regard second level collections as a link collection.
            //

            if (appCol)
            {
               appCol = appCol->NextCollection;
            } else
            {
               appCol = Cols;
            }
            ASSERT (appCol);

            HidP_KdPrint(0, ("'Parse Collection %d \n", appCol->CollectionNumber));

            preparsed = appCol->PreparsedData;
            ASSERT (preparsed);

            //
            // Set up the report IDs for this collection
            // There is one report ID array for all top level collections
            //
            push->ReportIDs = currentReportIDs;
            isFirstReportID = TRUE;
            // Make room for the Report ID as the first byte.
            currentReportIDs->InputLength = 8;
            currentReportIDs->OutputLength = 8;
            currentReportIDs->FeatureLength = 8;
            currentReportIDs->ReportID = 0;
            currentReportIDs->CollectionNumber = appCol->CollectionNumber;
            currentReportIDs++;

            preparsed->UsagePage = appCol->UsagePage = usage->UsagePage ?
                                                       usage->UsagePage :
                                                       push->UsagePage;
            if (usage->Range){
               preparsed->Usage = appCol->Usage = usage->Min;
            } else {
               preparsed->Usage = appCol->Usage = usage->Value;
            }
            designator = string = zeroLocal;
            usage = HidP_FreeUsageList (usage);
            if (0 == appCol->Usage) {
                //
                // Explicitly check for Usage ID (0) which is reserved
                //
                HidP_KdPrint(2, ("Top Level Collection %x defined with Report ID 0! (UP: %x)\n",
                                 appCol->CollectionNumber,
                                 appCol->UsagePage));
#if 0
                Dbg->BreakOffset = descIndex;
                Dbg->ErrorCode = HIDP_GETCOLDESC_TOP_COLLECTION_USAGE;
                Dbg->Args[0] = appCol->CollectionNumber;
                status = STATUS_COULD_NOT_INTERPRET;
                goto HIDP_PARSE_REJECT;
#endif
            }

            //
            // Initialize the Link node array for this top level collection.
            // There is a link node array for each top level collection
            //
            linkNodeArray = (PHIDP_PRIVATE_LINK_COLLECTION_NODE)
                            (preparsed->RawBytes +
                             preparsed->LinkCollectionArrayOffset);

            ASSERT (0 < preparsed->LinkCollectionArrayLength);
            parentLCNode   = &(linkNodeArray[0]);
            currentLCNode  = &(linkNodeArray[0]);
            linkNodeIndex = 0;

            parentLCNode->LinkUsagePage = appCol->UsagePage;
            parentLCNode->LinkUsage = appCol->Usage;
            parentLCNode->Parent = 0;
            parentLCNode->NumberOfChildren = 0;
            parentLCNode->NextSibling = 0;
            parentLCNode->FirstChild = 0;
            parentLCNode->CollectionType = collectionType;

         } else if (1 < colDepth)
         {
            linkNodeIndex++;
            parentLCNode = currentLCNode;
            ASSERT (linkNodeIndex < preparsed->LinkCollectionArrayLength);
            currentLCNode = &linkNodeArray[linkNodeIndex];

            //
            // Pop of the usage stack all the usages which are aliases, and
            // create a link collection node for each one.
            // Each allias link collection node has the IsAlias bit set.
            // The last one does not have the bit set, and becomes the
            // collection number for all controls list within this aliased
            // link collection.
            //
            //

            while (TRUE) {
                currentLCNode->LinkUsagePage = usage->UsagePage ?
                                               usage->UsagePage :
                                               push->UsagePage;
                currentLCNode->LinkUsage = usage->Range ?
                                           usage->Min :
                                           usage->Value;
                currentLCNode->Parent = (USHORT)(parentLCNode - linkNodeArray);
                ASSERT (currentLCNode->Parent < preparsed->LinkCollectionArrayLength);
                currentLCNode->NumberOfChildren = 0;
                currentLCNode->FirstChild = 0;
                currentLCNode->NextSibling = parentLCNode->FirstChild;
                parentLCNode->FirstChild = linkNodeIndex;
                parentLCNode->NumberOfChildren++;
                currentLCNode->CollectionType = collectionType;

                if (usage->IsAlias) {
                    currentLCNode->IsAlias = TRUE;
                    linkNodeIndex++;
                    ASSERT (linkNodeIndex < preparsed->LinkCollectionArrayLength);
                    currentLCNode = &linkNodeArray[linkNodeIndex];
                } else {
                    break;
                }
            }
            designator = string = zeroLocal;
            usage = HidP_FreeUsageList (usage);
         }
         break;

      case HIDP_MAIN_ENDCOLLECTION:
         if (0 == colDepth--) {
             status = STATUS_COULD_NOT_INTERPRET;
             goto HIDP_PARSE_REJECT;

         } else if (0 < colDepth) {
            ASSERT ((parentLCNode - linkNodeArray) == currentLCNode->Parent);
            currentLCNode = parentLCNode;
            ASSERT (currentLCNode->Parent < preparsed->LinkCollectionArrayLength);
            parentLCNode = &linkNodeArray[currentLCNode->Parent];
            break;
         }

         HidP_KdPrint(0, ("'X Parse Collection %d \n", appCol->CollectionNumber));


         //
         // Walk the report IDs for this collection
         //
         for (tmpReportIDs = currentReportIDs - 1;
              tmpReportIDs != DeviceDesc->ReportIDs - 1;
              tmpReportIDs--)
         {
            if (tmpReportIDs->CollectionNumber != appCol->CollectionNumber)
            {
               continue;
            }
            if ((0 != (tmpReportIDs->InputLength & 7)) ||
                (0 != (tmpReportIDs->OutputLength & 7)) ||
                (0 != (tmpReportIDs->FeatureLength & 7)))
            {
               HidP_KdPrint(2, ("Col %x Report %x NOT byte alligned!! %x %x %x\n",
                             appCol->CollectionNumber,
                             tmpReportIDs->ReportID,
                             tmpReportIDs->InputLength,
                             tmpReportIDs->OutputLength,
                             tmpReportIDs->FeatureLength));
               Dbg->BreakOffset = descIndex;
               Dbg->ErrorCode = HIDP_GETCOLDESC_BYTE_ALLIGN;
               Dbg->Args[0] = appCol->CollectionNumber,
               Dbg->Args[1] = tmpReportIDs->ReportID,
               Dbg->Args[2] = tmpReportIDs->InputLength;
               Dbg->Args[3] = tmpReportIDs->OutputLength;
               Dbg->Args[4] = tmpReportIDs->FeatureLength;
               status = STATUS_COULD_NOT_INTERPRET;
               goto HIDP_PARSE_REJECT;
            }

            preparsed->Input.ByteLen = MAX (preparsed->Input.ByteLen,
                                            tmpReportIDs->InputLength >> 3);
            preparsed->Output.ByteLen = MAX (preparsed->Output.ByteLen,
                                             tmpReportIDs->OutputLength >> 3);
            preparsed->Feature.ByteLen = MAX (preparsed->Feature.ByteLen,
                                              tmpReportIDs->FeatureLength >> 3);

            //
            // We are now done with this report so convert the length to
            // bytes instead of bits, and remove the report id, if the
            // device will not send one.
            //

            if (0 == tmpReportIDs->ReportID)
            {
               // The report ID was never set; therefore, for input the device
               // will not send a report id.
               tmpReportIDs->InputLength = (tmpReportIDs->InputLength >> 3) - 1;
               tmpReportIDs->OutputLength = (tmpReportIDs->OutputLength >> 3) -1;
               tmpReportIDs->FeatureLength = (tmpReportIDs->FeatureLength >> 3) -1;
            } else
            {
               tmpReportIDs->InputLength = (8 == tmpReportIDs->InputLength)
                                         ? 0
                                         : tmpReportIDs->InputLength >> 3;
               tmpReportIDs->OutputLength = (8 == tmpReportIDs->OutputLength)
                                          ? 0
                                          : tmpReportIDs->OutputLength >> 3;
               tmpReportIDs->FeatureLength = (8 == tmpReportIDs->FeatureLength)
                                           ? 0
                                           : tmpReportIDs->FeatureLength >> 3;
            }
         }

         //
         // This field is adjusted and always accounts for a space for the
         // included report ID, even if the device itslef has only one report
         // and therefore sends no report ids.  (The input report is one byte
         // smaller.)
         //
         // BUT if the length is one, then only the report ID exists.
         // This means that the device has no data to send for that field.
         // Therefore return zero.
         //
         // Remember that the BitLen fields were spiked earlier with values
         // of 8 (one byte).
         //
         // appCol->XXXLength is the length expected from/by the client
         // currentReportID->XxLength == the length expected from/by the device
         //
         if (1 == (appCol->InputLength = preparsed->Input.ByteLen))
         {
            appCol->InputLength = preparsed->Input.ByteLen = 0;
         }
         if (1 == (appCol->OutputLength = preparsed->Output.ByteLen))
         {
            appCol->OutputLength = preparsed->Output.ByteLen = 0;
         }
         if (1 == (appCol->FeatureLength = preparsed->Feature.ByteLen))
         {
            appCol->FeatureLength = preparsed->Feature.ByteLen = 0;
         }

         break;

      case HIDP_GLOBAL_USAGE_PAGE_1:
         ONE_BYTE_DATA (push->UsagePage, descIndex, Dbg);
         break;

      case HIDP_GLOBAL_USAGE_PAGE_2:
         TWO_BYTE_DATA (push->UsagePage, descIndex, Dbg);
         break;

//
// 16 bits allowed only.
//      case HIDP_GLOBAL_USAGE_PAGE_4:
//         FOUR_BYTE_DATA (push->UsagePage, descIndex, Dbg);
//         break;
//

      case HIDP_GLOBAL_LOG_MIN_1:
         ONE_BYTE_DATA (push->LogicalMin, descIndex, Dbg);
         BIT_EXTEND_1 (push->LogicalMin);
         break;

      case HIDP_GLOBAL_LOG_MIN_2:
         TWO_BYTE_DATA (push->LogicalMin, descIndex, Dbg);
         BIT_EXTEND_2 (push->LogicalMin);
         break;

      case HIDP_GLOBAL_LOG_MIN_4:
         FOUR_BYTE_DATA (push->LogicalMin, descIndex, Dbg);
         break;

      case HIDP_GLOBAL_LOG_MAX_1:
         ONE_BYTE_DATA (push->LogicalMax, descIndex, Dbg);
         BIT_EXTEND_1 (push->LogicalMax);
         break;

      case HIDP_GLOBAL_LOG_MAX_2:
         TWO_BYTE_DATA (push->LogicalMax, descIndex, Dbg);
         BIT_EXTEND_2 (push->LogicalMax);
         break;

      case HIDP_GLOBAL_LOG_MAX_4:
         FOUR_BYTE_DATA (push->LogicalMax, descIndex, Dbg);
         break;

      case HIDP_GLOBAL_PHY_MIN_1:
         ONE_BYTE_DATA (push->PhysicalMin, descIndex, Dbg);
         BIT_EXTEND_1 (push->PhysicalMin);
         break;

      case HIDP_GLOBAL_PHY_MIN_2:
         TWO_BYTE_DATA (push->PhysicalMin, descIndex, Dbg);
         BIT_EXTEND_2 (push->PhysicalMin);
         break;

      case HIDP_GLOBAL_PHY_MIN_4:
         FOUR_BYTE_DATA (push->PhysicalMin, descIndex, Dbg);
         break;

      case HIDP_GLOBAL_PHY_MAX_1:
         ONE_BYTE_DATA (push->PhysicalMax, descIndex, Dbg);
         BIT_EXTEND_1 (push->PhysicalMax);
         break;

      case HIDP_GLOBAL_PHY_MAX_2:
         TWO_BYTE_DATA (push->PhysicalMax, descIndex, Dbg);
         BIT_EXTEND_2 (push->PhysicalMax);
         break;

      case HIDP_GLOBAL_PHY_MAX_4:
         FOUR_BYTE_DATA (push->PhysicalMax, descIndex, Dbg);
         break;

      case HIDP_GLOBAL_UNIT_EXP_1:
         ONE_BYTE_DATA (push->UnitExp, descIndex, Dbg);
         BIT_EXTEND_1 (push->UnitExp);
         break;

      case HIDP_GLOBAL_UNIT_EXP_2:
         TWO_BYTE_DATA (push->UnitExp, descIndex, Dbg);
         BIT_EXTEND_2 (push->UnitExp);
         break;

      case HIDP_GLOBAL_UNIT_EXP_4:
         FOUR_BYTE_DATA (push->UnitExp, descIndex, Dbg);
         break;

      case HIDP_GLOBAL_UNIT_1:
          ONE_BYTE_DATA (push->Unit, descIndex, Dbg);
          break;

      case HIDP_GLOBAL_UNIT_2:
          TWO_BYTE_DATA (push->Unit, descIndex, Dbg);
          break;

      case HIDP_GLOBAL_UNIT_4:
          FOUR_BYTE_DATA (push->Unit, descIndex, Dbg);
          break;

      case HIDP_GLOBAL_REPORT_SIZE:
         ONE_BYTE_DATA (push->ReportSize, descIndex, Dbg);
         break;

      case HIDP_GLOBAL_REPORT_COUNT_1:
         ONE_BYTE_DATA (push->ReportCount, descIndex, Dbg);
         break;

      case HIDP_GLOBAL_REPORT_COUNT_2:
         TWO_BYTE_DATA (push->ReportCount, descIndex, Dbg);
         break;

      case HIDP_GLOBAL_REPORT_ID:
         //
         // If a device has no report GLOBAL_REPORT_ID token in its descriptor
         // then it will never transmit a report ID in its input reports,
         // and the report ID for each channel will be set to zero.
         //
         // But, if anywhere in the report, a device declares a report ID
         // that device must always transmit a report ID with input reports,
         // AND more importantly that report ID MUST NOT BE ZERO.
         //
         // This means that if we find a report id token, that we can just
         // overwrite the first report ID structure with the given report ID
         // because we know that the first ID structure (initialized to zero
         // and therefore not valid) will not be used for any of the channels.
         //
         ONE_BYTE_DATA (tmpID, descIndex, Dbg);

         //
         // Search to see if this report id has been used before.
         //
         for (tmpReportIDs = DeviceDesc->ReportIDs;
              tmpReportIDs != currentReportIDs;
              tmpReportIDs++) {

            if (tmpReportIDs->ReportID == tmpID) {
               //
               // A duplicate!
               // Make sure that it is for this same collection
               //
               if (tmpReportIDs->CollectionNumber != appCol->CollectionNumber) {
                  HidP_KdPrint(2, ("Reports cannot span more than one top level \n"));
                  HidP_KdPrint(2, ("Report ID %d found in collections [%d %d]",
                                   (ULONG) tmpID,
                                   (ULONG) tmpReportIDs->CollectionNumber,
                                   (ULONG) appCol->CollectionNumber));
                  Dbg->BreakOffset = descIndex;
                  Dbg->ErrorCode = HIDP_GETCOLDESC_REPORT_ID;
                  Dbg->Args[0] = item;
                  status = HIDP_STATUS_INVALID_REPORT_TYPE;
                  goto HIDP_PARSE_REJECT;
               }
               //
               // Use this report ID.
               //
               push->ReportIDs = tmpReportIDs;
               break;
            }
         } // continue looking.

         if (isFirstReportID) {
            isFirstReportID = FALSE;
         } else if (tmpReportIDs == currentReportIDs) {
               //
               // We have not seen this report ID before.
               // make a new container.
               //
               push->ReportIDs = currentReportIDs;
               // Make room for the Report ID as the first byte.
               currentReportIDs->InputLength = 8;
               currentReportIDs->OutputLength = 8;
               currentReportIDs->FeatureLength = 8;
               currentReportIDs->CollectionNumber = appCol->CollectionNumber;
               currentReportIDs++;
         }

         push->ReportIDs->ReportID = tmpID;

         if (0 == push->ReportIDs->ReportID) {
            status = HIDP_STATUS_INVALID_REPORT_TYPE;
            HidP_KdPrint(2, ("Report IDs cannot be zero (0)\n"));
            Dbg->ErrorCode = HIDP_GETCOLDESC_BAD_REPORT_ID;
            Dbg->BreakOffset = descIndex;
            goto HIDP_PARSE_REJECT;
         }
         break;

      case HIDP_GLOBAL_PUSH:
         tmpPush = (PHIDP_PARSE_GLOBAL_PUSH)
                   ExAllocatePool (PoolType, sizeof (HIDP_PARSE_GLOBAL_PUSH));
         if (!tmpPush)
         {
            status = STATUS_INSUFFICIENT_RESOURCES;
            HidP_KdPrint(2, ("No Resources to Push global stack\n"));
            Dbg->BreakOffset = descIndex;
            Dbg->ErrorCode = HIDP_GETCOLDESC_PUSH_RESOURCES;
            goto HIDP_PARSE_REJECT;
         }
         HidP_KdPrint(0, ("Push Global Stack\n"));
         *tmpPush = *push;
         tmpPush->Pop = push;
         push = tmpPush;
         break;

      case HIDP_GLOBAL_POP:
         tmpPush = push->Pop;
         ExFreePool (push);
         push = tmpPush;
         HidP_KdPrint(0, ("Pop Global Stack\n"));

         break;

//
// Local Items
//

      //
      // We already verified that only "approved" tokens will be within
      // the open / close of the following delimiter.  This simplifies
      // our parsing here tremendously.
      //
      case HIDP_LOCAL_DELIMITER:
          ONE_BYTE_DATA (item, descIndex, Dbg);
          if (1 == item) {
              withinDelimiter = TRUE;
              firstUsageWithinDelimiter = TRUE;
          } else if (0 == item) {
              withinDelimiter = FALSE;
          } else {
              TRAP ();
          }
          break;

      case HIDP_LOCAL_USAGE_1:
      case HIDP_LOCAL_USAGE_2:
      case HIDP_LOCAL_USAGE_4:
         if ((&firstUsage == usage) || usage->Value || usage->Max || usage->Min) {
            usage = HidP_PushUsageList (usage, PoolType, withinDelimiter);
            if (!usage) {
               status = STATUS_INSUFFICIENT_RESOURCES;
               HidP_KdPrint(2, ("No Resources to Push Usage stack\n"));
               Dbg->BreakOffset = descIndex;
               Dbg->ErrorCode = HIDP_GETCOLDESC_PUSH_RESOURCES;
               goto HIDP_PARSE_REJECT;
            }
         }
         usage->Range = FALSE;
         if (HIDP_LOCAL_USAGE_1 == item) {
            ONE_BYTE_DATA (usage->Value, descIndex, Dbg);
         } else if (HIDP_LOCAL_USAGE_2 == item) {
            TWO_BYTE_DATA (usage->Value, descIndex, Dbg);
         } else {
            TWO_BYTE_DATA (usage->Value, descIndex, Dbg);
            TWO_BYTE_DATA (usage->UsagePage, descIndex, Dbg);
            // upper 16 bits overwrite the default usage page.
         }

         if (withinDelimiter) {
             usage->IsAlias = !firstUsageWithinDelimiter;
             firstUsageWithinDelimiter = FALSE;
         }
         if (0 == usage->Value) {
             //
             // Test to see if they have used Usage ID (0) which is reserved.
             // But instead of breaking just print an error
             //
             HidP_KdPrint(2, ("Usage ID (0) explicitly usaged!  This usage is reserved.  Offset (%x)\n",
                              descIndex));
         }
         break;

      //
      // NB: before we can add delimiters to usage ranges we must insure
      // that the range is identical for all entries within the delimiter.
      //

      case HIDP_LOCAL_USAGE_MIN_1:
      case HIDP_LOCAL_USAGE_MIN_2:
      case HIDP_LOCAL_USAGE_MIN_4:
         if ((&firstUsage == usage) || (usage->Min) || (usage->Value)) {
            usage = HidP_PushUsageList (usage, PoolType, FALSE);
            if (!usage) {
               status = STATUS_INSUFFICIENT_RESOURCES;
               HidP_KdPrint(2, ("No Resources to Push Usage stack\n"));
               Dbg->BreakOffset = descIndex;
               Dbg->ErrorCode = HIDP_GETCOLDESC_PUSH_RESOURCES;
               goto HIDP_PARSE_REJECT;
            }
         }
         usage->Range = TRUE;
         if (HIDP_LOCAL_USAGE_MIN_1 == item) {
            ONE_BYTE_DATA (usage->Min, descIndex, Dbg);
         } else if (HIDP_LOCAL_USAGE_MIN_2 == item) {
            TWO_BYTE_DATA (usage->Min, descIndex, Dbg);
         } else {
            TWO_BYTE_DATA (usage->Min, descIndex, Dbg);
            TWO_BYTE_DATA (usage->UsagePage, descIndex, Dbg);
            // upper 16 bits overwrite the default usage page.
         }
         break;

      case HIDP_LOCAL_USAGE_MAX_1:
      case HIDP_LOCAL_USAGE_MAX_2:
      case HIDP_LOCAL_USAGE_MAX_4:
         if ((&firstUsage == usage) || (usage->Max) || (usage->Value)) {
            usage = HidP_PushUsageList (usage, PoolType, FALSE);
            if (!usage) {
               status = STATUS_INSUFFICIENT_RESOURCES;
               HidP_KdPrint(2, ("No Resources to Push Usage stack\n"));
               Dbg->BreakOffset = descIndex;
               Dbg->ErrorCode = HIDP_GETCOLDESC_PUSH_RESOURCES;
               goto HIDP_PARSE_REJECT;
            }
         }
         usage->Range = TRUE;
         if (HIDP_LOCAL_USAGE_MAX_1 == item) {
            ONE_BYTE_DATA (usage->Max, descIndex, Dbg);
         } else if (HIDP_LOCAL_USAGE_MAX_2 == item) {
            TWO_BYTE_DATA (usage->Max, descIndex, Dbg);
         } else {
            TWO_BYTE_DATA (usage->Max, descIndex, Dbg);
            TWO_BYTE_DATA (usage->UsagePage, descIndex, Dbg);
            // upper 16 bits overwrite the default usage page.
         }
         break;

      case HIDP_LOCAL_DESIG_INDEX:
         designator.Range = FALSE;
         ONE_BYTE_DATA (designator.Value, descIndex, Dbg);
         break;

      case HIDP_LOCAL_DESIG_MIN:
         designator.Range = TRUE;
         ONE_BYTE_DATA (designator.Min, descIndex, Dbg);
         break;

      case HIDP_LOCAL_DESIG_MAX:
         designator.Range = TRUE;
         ONE_BYTE_DATA (designator.Max, descIndex, Dbg);
         break;

      case HIDP_LOCAL_STRING_INDEX:
         string.Range = FALSE;
         ONE_BYTE_DATA (string.Value, descIndex, Dbg);
         break;

      case HIDP_LOCAL_STRING_MIN:
         string.Range = TRUE;
         ONE_BYTE_DATA (string.Min, descIndex, Dbg);
         break;

      case HIDP_LOCAL_STRING_MAX:
         string.Range = TRUE;
         ONE_BYTE_DATA (string.Max, descIndex, Dbg);
         break;

      case HIDP_MAIN_INPUT_1:
         tmpReportIDs = push->ReportIDs;
         bitPos = tmpReportIDs->InputLength; // The distance into the report
         HidP_KdPrint(0, ("'Main Offset:%x \n", bitPos));
         tmpReportIDs->InputLength += push->ReportSize * push->ReportCount;
         channelIndex = &(preparsed->Input.Index);
         ONE_BYTE_DATA (tmpBitField, descIndex, Dbg);
         goto HIDP_PARSE_MAIN_ITEM;

      case HIDP_MAIN_INPUT_2:
         tmpReportIDs = push->ReportIDs;
         bitPos = tmpReportIDs->InputLength; // The distance into the report
         HidP_KdPrint(0, ("'Main2 offset:%x \n", bitPos));
         tmpReportIDs->InputLength += push->ReportSize * push->ReportCount;
         channelIndex = &(preparsed->Input.Index);
         TWO_BYTE_DATA (tmpBitField, descIndex, Dbg);
         goto HIDP_PARSE_MAIN_ITEM;

      case HIDP_MAIN_OUTPUT_1:
         tmpReportIDs = push->ReportIDs;
         bitPos = tmpReportIDs->OutputLength; // The distance into the report
         HidP_KdPrint(0, ("'Out offset:%x \n", bitPos));
         tmpReportIDs->OutputLength += push->ReportSize * push->ReportCount;
         channelIndex = &(preparsed->Output.Index);
         ONE_BYTE_DATA (tmpBitField, descIndex, Dbg);
         goto HIDP_PARSE_MAIN_ITEM;

      case HIDP_MAIN_OUTPUT_2:
         tmpReportIDs = push->ReportIDs;
         bitPos = tmpReportIDs->OutputLength; // The distance into the report
         HidP_KdPrint(0, ("'Out2 offset:%x \n", bitPos));
         tmpReportIDs->OutputLength += push->ReportSize * push->ReportCount;
         channelIndex = &(preparsed->Output.Index);
         TWO_BYTE_DATA (tmpBitField, descIndex, Dbg);
         goto HIDP_PARSE_MAIN_ITEM;

      case HIDP_MAIN_FEATURE_1:
         tmpReportIDs = push->ReportIDs;
         bitPos = tmpReportIDs->FeatureLength; // The distance into the report
         HidP_KdPrint(0, ("'Feature offset:%x \n", bitPos));
         tmpReportIDs->FeatureLength += push->ReportSize * push->ReportCount;
         channelIndex = &(preparsed->Feature.Index);
         ONE_BYTE_DATA (tmpBitField, descIndex, Dbg);
         goto HIDP_PARSE_MAIN_ITEM;

      case HIDP_MAIN_FEATURE_2:
         tmpReportIDs = push->ReportIDs;
         bitPos = tmpReportIDs->FeatureLength; // The distance into the report
         HidP_KdPrint(0, ("'Feature2 offset:%x \n", bitPos));
         tmpReportIDs->FeatureLength += push->ReportSize * push->ReportCount;
         channelIndex = &(preparsed->Feature.Index);
         TWO_BYTE_DATA (tmpBitField, descIndex, Dbg);

      HIDP_PARSE_MAIN_ITEM:

          // You can have a constant field that does return data.
          // so we probably shouldn't skip it.
          // BUT it should NOT be an array style button field.
         if (HIDP_ISARRAY (tmpBitField)) {
             if (HIDP_ISCONST(tmpBitField)) {
                 break;
             }
             //
             // Here we have a list of indices that refer to the usages
             // described prior.  For each of the prior usages, up to the depth
             // found, we allocate a channel structure to describe the given
             // usages.  These channels are linked so that we will later know
             // that they all describe the same filled.
             //

             //
             // We do no support delimiteres in array declairations.
             // To do so would require a large change to Index2Usage which
             // instead of returning only one usage would have to return
             // several.
             //

             if (usage->IsAlias) {
                 status = STATUS_COULD_NOT_INTERPRET;
                 HidP_KdPrint(2, ("Currently this parser does not support\n"));
                 HidP_KdPrint(2, ("Delimiters for array declairations\n"));
                 Dbg->BreakOffset = descIndex;
                 Dbg->ErrorCode = HIDP_GETCOLDESC_UNSUPPORTED;
                 goto HIDP_PARSE_REJECT;
             }

             for ( ;
                  usage != &firstUsage;
                  (*channelIndex)++,
                  usage = HidP_PopUsageList (usage)) {

                 channel = &(preparsed->Data[*channelIndex]);

                 channel->BitField = tmpBitField;

                 // field that says this channel is linked
                 channel->MoreChannels = TRUE;

                 // say what link collection number we are in.
                 channel->LinkCollection = (USHORT)(currentLCNode - linkNodeArray);
                 channel->LinkUsage = currentLCNode->LinkUsage;
                 channel->LinkUsagePage = currentLCNode->LinkUsagePage;

                 if (usage->UsagePage) {
                     // The default usage page been overwritten.
                     channel->UsagePage = usage->UsagePage;
                 } else {
                     channel->UsagePage = push->UsagePage;
                 }

                 channel->BitOffset = (UCHAR) bitPos & 7;
                 channel->ByteOffset = (USHORT) bitPos >> 3;
                 channel->ReportSize = push->ReportSize;
                 channel->ReportCount = push->ReportCount;

                 channel->BitLength = push->ReportSize * push->ReportCount;
                 channel->ByteEnd = (channel->BitOffset + channel->BitLength);
                 channel->ByteEnd = (channel->ByteEnd >> 3)
                                  + ((channel->ByteEnd & 7) ? 1 : 0)
                                  + channel->ByteOffset;


                 channel->ReportID = push->ReportIDs->ReportID;
                 channel->Units = push->Unit;
                 channel->UnitExp = push->UnitExp;

                 channel->IsConst = FALSE;

                 channel->IsButton = TRUE;
                 channel->IsAbsolute = HIDP_ISABSOLUTE(tmpBitField);
                 channel->button.LogicalMin = push->LogicalMin;
                 channel->button.LogicalMax = push->LogicalMax;

                 channel->IsRange = usage->Range;
                 channel->IsDesignatorRange = designator.Range;
                 channel->IsStringRange = string.Range;

                 if (usage->Range) {
                     channel->Range.UsageMin = usage->Min;
                     channel->Range.UsageMax = usage->Max;
                 } else {
                     channel->Range.UsageMin =
                         channel->Range.UsageMax = usage->Value;
                 }
                 if (designator.Range) {
                     channel->Range.DesignatorMin = designator.Min;
                     channel->Range.DesignatorMax = designator.Max;
                 } else {
                     channel->Range.DesignatorMin =
                         channel->Range.DesignatorMax = designator.Value;
                 }

                 if (string.Range) {
                     channel->Range.StringMin = string.Min;
                     channel->Range.StringMax = string.Max;
                 } else {
                     channel->Range.StringMin =
                         channel->Range.StringMax = string.Value;
                 }

                 channel->NumGlobalUnknowns = push->NumGlobalUnknowns;

                 if (push->NumGlobalUnknowns) {
                     RtlCopyMemory (channel->GlobalUnknowns,
                                    push->GlobalUnknowns,
                                    push->NumGlobalUnknowns
                                    * sizeof (HIDP_UNKNOWN_TOKEN));
                 }

                 //
                 // Check for power buttons
                 //
                 if (HIDP_USAGE_SYSCTL_PAGE == channel->UsagePage) {
                     if ((channel->Range.UsageMin <= HIDP_USAGE_SYSCTL_POWER) &&
                         (HIDP_USAGE_SYSCTL_POWER <= channel->Range.UsageMax)) {
                         preparsed->PowerButtonMask |= SYS_BUTTON_POWER;
                     }
                     if ((channel->Range.UsageMin <= HIDP_USAGE_SYSCTL_SLEEP) &&
                         (HIDP_USAGE_SYSCTL_SLEEP <= channel->Range.UsageMax)) {
                         preparsed->PowerButtonMask |= SYS_BUTTON_SLEEP;
                     }
                     if ((channel->Range.UsageMin <= HIDP_USAGE_SYSCTL_WAKE) &&
                         (HIDP_USAGE_SYSCTL_WAKE <= channel->Range.UsageMax)) {
                         preparsed->PowerButtonMask |= SYS_BUTTON_WAKE;
                     }
                 }

             }

             ASSERT (0 == usage->Depth);

             channel->MoreChannels = FALSE;
             designator = string = zeroLocal;
             break;
         } // end array style channel


         channel = &(preparsed->Data[*channelIndex]);
         if (HIDP_ISCONST(tmpBitField)) {
             if ((0 == usage->Depth) ||
                 ((0 == usage->Value) && (0 == usage->Min)
                                      && (0 == usage->Max))) {
                 //
                 // A constant channel with no usage.  Skip it.
                 //

                 usage = HidP_FreeUsageList (usage);
                 ASSERT (usage == &firstUsage);
                 ASSERT (0 == usage->Depth);
                 break;
             }
             channel->IsConst = TRUE;
         } else {
             channel->IsConst = FALSE;
         }

         tmpCount = usage->Depth // - 1
                  + (usage->Range ? (usage->Max - usage->Min) : 0);  // + 1

#if 0
         while (tmpCount > push->ReportCount) {
             // Get rid of excess usages.
             tmpCount = usage->Depth - 1;
             usage = HidP_PopUsageList (usage);

             ASSERT (tmpCount == (usage->Depth +
                                  (usage->Range ? (usage->Max - usage->Min) : 0)));
         }
#else
         while (tmpCount > push->ReportCount) {
             // Get rid of excess usages.

             if (tmpCount <= usage->Depth) {
                 // We've got enough in the linked usages to fulfill this request
                 tmpCount = usage->Depth - 1;
                 usage = HidP_PopUsageList (usage);

                 ASSERT (tmpCount ==
                         (usage->Depth +
                          (usage->Range ? (usage->Max - usage->Min) : 0)));
             } else {
                 // We don't have enough in the linked usages, but we've too
                 // much in this range.  So, adjust the max value of the
                 // range so that it won't be too many usages.

                 ASSERT (usage->Range);
                 usage->Max = push->ReportCount - usage->Depth + usage->Min;

                 tmpCount = usage->Depth + (usage->Max - usage->Min);
             }
         }
         ASSERT (tmpCount <= push->ReportCount);
         // Now we should no longer have too many usages.
         //
#endif
         //
         // The last value in the link (aka the top) must be
         // repeated if there are less usages than there are
         // report counts.  That particular usage applies to all
         // field in this main item not yet accounted for.  In this
         // case a single channel descriptor is allocated and
         // report count is set to the number of fields referenced
         // by this usage.
         //
         // Not the usages are listed in reverse order of there appearence
         // in the report descriptor, so the first usage found in this list
         // is the one that should be repeated.
         //
         // tmpCount is the number of field to which this first usage applies.
         //

         tmpCount = 1 + push->ReportCount - tmpCount
                  + usage->Max - usage->Min;

         //
         // The following loop assigns the usage to the fields in this main
         // item in reverse order.
         //
         bitPos += push->ReportSize * (push->ReportCount - tmpCount);
         for (i = 0;
              i < push->ReportCount;

              i += tmpCount, // Bump i by the number of fields for this channel
              tmpCount = 1 + (usage->Range ? (usage->Max - usage->Min) : 0),
              bitPos -= (push->ReportSize * tmpCount)) {

             do { // do for all the aliases.
                 channel = &(preparsed->Data[(*channelIndex)++]);

                 // set the IsAlias flag now and then clear the last one
                 // at the close of this Do while loop.
                 channel->IsAlias = TRUE;

                 channel->BitField = tmpBitField;
                 channel->MoreChannels = FALSE; // only valid for arrays
                 channel->LinkCollection = (USHORT)(currentLCNode - linkNodeArray);
                 channel->LinkUsage = currentLCNode->LinkUsage;
                 channel->LinkUsagePage = currentLCNode->LinkUsagePage;

                 if (usage->UsagePage) {
                     // The default usage page been overwritten.
                     channel->UsagePage = usage->UsagePage;
                 } else {
                     channel->UsagePage = push->UsagePage;
                 }

                 channel->BitOffset = (UCHAR) bitPos & 7;
                 channel->ByteOffset = (USHORT) bitPos >> 3;
                 channel->ReportSize = push->ReportSize;
                 channel->ReportCount = tmpCount;

                 channel->BitLength = push->ReportSize * tmpCount;
                 channel->ByteEnd = (channel->BitOffset + channel->BitLength);
                 channel->ByteEnd = (channel->ByteEnd >> 3)
                                  + ((channel->ByteEnd & 7) ? 1 : 0)
                                  + channel->ByteOffset;

                 channel->ReportID = push->ReportIDs->ReportID;

                 channel->IsAbsolute = HIDP_ISABSOLUTE(tmpBitField);

                 channel->Units = push->Unit;
                 channel->UnitExp = push->UnitExp;

                 if (1 == push->ReportSize) {
                     channel->IsButton = TRUE;
                 } else {
                     channel->IsButton = FALSE;
                     channel->Data.HasNull = HIDP_HASNULL(channel->BitField);
                     channel->Data.LogicalMin = push->LogicalMin;
                     channel->Data.LogicalMax = push->LogicalMax;
                     channel->Data.PhysicalMin = push->PhysicalMin;
                     channel->Data.PhysicalMax = push->PhysicalMax;
                 }

                 channel->IsDesignatorRange = designator.Range;
                 channel->IsStringRange = string.Range;
                 channel->IsRange = usage->Range;
                 if (usage->Range) {
                     channel->Range.UsageMin = usage->Min;
                     channel->Range.UsageMax = usage->Max;
                 } else {
                     channel->Range.UsageMin =
                         channel->Range.UsageMax = usage->Value;
                 }

                 if (designator.Range) {
                     channel->Range.DesignatorMin = designator.Min;
                     channel->Range.DesignatorMax = designator.Max;
                 } else {
                     channel->Range.DesignatorMin =
                         channel->Range.DesignatorMax = designator.Value;
                 }

                 if (string.Range) {
                     channel->Range.StringMin = string.Min;
                     channel->Range.StringMax = string.Max;
                 } else {
                     channel->Range.StringMin =
                         channel->Range.StringMax = string.Value;
                 }
                 isAlias = usage->IsAlias;
                 usage   = HidP_PopUsageList (usage); // discard used usage

                 channel->NumGlobalUnknowns = push->NumGlobalUnknowns;
                 if (push->NumGlobalUnknowns) {
                     RtlCopyMemory (channel->GlobalUnknowns,
                                    push->GlobalUnknowns,
                                    push->NumGlobalUnknowns
                                    * sizeof (HIDP_UNKNOWN_TOKEN));
                 }

                 //
                 // Check for power buttons
                 //
                 if (HIDP_USAGE_SYSCTL_PAGE == channel->UsagePage) {
                     if ((channel->Range.UsageMin <= HIDP_USAGE_SYSCTL_POWER) &&
                         (HIDP_USAGE_SYSCTL_POWER <= channel->Range.UsageMax)) {
                         preparsed->PowerButtonMask |= SYS_BUTTON_POWER;
                     }
                     if ((channel->Range.UsageMin <= HIDP_USAGE_SYSCTL_SLEEP) &&
                         (HIDP_USAGE_SYSCTL_SLEEP <= channel->Range.UsageMax)) {
                         preparsed->PowerButtonMask |= SYS_BUTTON_SLEEP;
                     }
                     if ((channel->Range.UsageMin <= HIDP_USAGE_SYSCTL_WAKE) &&
                         (HIDP_USAGE_SYSCTL_WAKE <= channel->Range.UsageMax)) {
                         preparsed->PowerButtonMask |= SYS_BUTTON_WAKE;
                     }
                 }

             } while (isAlias);

             channel->IsAlias = FALSE;
         } // for all channels in this main item

         // Zero out the locals.
         designator = string = zeroLocal;

         // Hopefully we have used all the local usages now
         ASSERT (usage == &firstUsage);
         break;

      default:
#ifdef HIDP_REJECT_UNDEFINED
         HidP_KdPrint (2, ("Item Unknown %x\n", item));
         Dbg->BreakOffset = descIndex;
         Dbg->ErrorCode = HIDP_GETCOLDESC_ITEM_UNKNOWN;
         Dbg->Args[0] = item;
         status = STATUS_ILLEGAL_INSTRUCTION;
         goto HIDP_PARSE_REJECT;
#else
         if (HIDP_IS_MAIN_ITEM (item)) {
             HidP_KdPrint (2, ("Unknown MAIN item: %x\n", item));
             Dbg->BreakOffset = descIndex;
             Dbg->ErrorCode = HIDP_GETCOLDESC_ITEM_UNKNOWN;
             Dbg->Args[0] = item;
             status = STATUS_ILLEGAL_INSTRUCTION;
             goto HIDP_PARSE_REJECT;

         } else if (HIDP_IS_GLOBAL_ITEM (item)) {
             if (HIDP_MAX_UNKNOWN_ITEMS == push->NumGlobalUnknowns) {
                 push->NumGlobalUnknowns--;
                 // overwrite the last entry;
             }
             unknownToken = &push->GlobalUnknowns[push->NumGlobalUnknowns];
             unknownToken->Token = item;
             switch (item & HIDP_ITEM_LENGTH_DATA) {
             case 0:
                 break;
             case 1:
                 ONE_BYTE_DATA (unknownToken->BitField, descIndex, Dbg);
                 break;
             case 2:
                 TWO_BYTE_DATA (unknownToken->BitField, descIndex, Dbg);
                 break;
             case 3:
                 FOUR_BYTE_DATA (unknownToken->BitField, descIndex, Dbg);
                 break;
             }
             push->NumGlobalUnknowns++;

         } else if (HIDP_IS_LOCAL_ITEM (item)) {
             HidP_KdPrint (2, ("Unknown LOCAL item: %x\n", item));
             Dbg->BreakOffset = descIndex;
             Dbg->ErrorCode = HIDP_GETCOLDESC_ITEM_UNKNOWN;
             Dbg->Args[0] = item;
             status = STATUS_ILLEGAL_INSTRUCTION;
             goto HIDP_PARSE_REJECT;

         } else if (HIDP_IS_RESERVED_ITEM (item)) {
             HidP_KdPrint (2, ("Unknown RESERVED item: %x\n", item));
             Dbg->BreakOffset = descIndex;
             Dbg->ErrorCode = HIDP_GETCOLDESC_ITEM_UNKNOWN;
             Dbg->Args[0] = item;
             status = STATUS_ILLEGAL_INSTRUCTION;
             goto HIDP_PARSE_REJECT;
         }

#endif

         break;
      }
   }

   HidP_FreeUsageList (usage);
   //
   // Since the number of report IDs could be less than the total allocated,
   // due to the fact that some might be repeated, reset the length of the
   // array to reflect the total amount which we found.
   //
   DeviceDesc->ReportIDsLength =
       (ULONG)(currentReportIDs - DeviceDesc->ReportIDs);

   return status;

HIDP_PARSE_REJECT:
   while (push != &firstPush)
   {
      tmpPush = push;
      push = push->Pop;
      ExFreePool (tmpPush);
   }
   if (NULL != usage) {
       //
       // If usage is null, that means that something went wrong. (probably
       // in the push usage routine).  In this case the usage memory should
       // have already been freed.
       //
       HidP_FreeUsageList (usage);
   }
   return status;
}

VOID
HidP_FreeCollectionDescription (
    IN  PHIDP_DEVICE_DESC   Desc
    )
{
    ULONG i;

    for (i=0; i < Desc->CollectionDescLength; i++) {
        ExFreePool (Desc->CollectionDesc[i].PreparsedData);
    }
    ExFreePool (Desc->CollectionDesc);
    ExFreePool (Desc->ReportIDs);

    //
    // Do NOT free Desc itself.
    //
}

#define PHIDP_SYS_POWER_EVENT_BUTTON_LENGTH 0x20
NTSTATUS
HidP_SysPowerEvent (
    IN  PCHAR                   HidPacket,
    IN  USHORT                  HidPacketLength,
    IN  PHIDP_PREPARSED_DATA    Ppd,
    OUT PULONG                  OutputBuffer
    )
{
    USAGE       buttonList [PHIDP_SYS_POWER_EVENT_BUTTON_LENGTH];
    ULONG       length = PHIDP_SYS_POWER_EVENT_BUTTON_LENGTH;
    NTSTATUS    status = STATUS_NOT_SUPPORTED;
    ULONG       i;

    *OutputBuffer = 0;

    if (Ppd->PowerButtonMask) {

        status = HidP_GetUsages (HidP_Input,
                                 HIDP_USAGE_SYSCTL_PAGE,
                                 0,
                                 buttonList,
                                 &length,
                                 Ppd,
                                 HidPacket,
                                 HidPacketLength);

        if (NT_SUCCESS (status)) {
            for (i = 0; i < length; i++) {

                switch (buttonList[i]) {
                case HIDP_USAGE_SYSCTL_POWER:
                    *OutputBuffer |= SYS_BUTTON_POWER;
                    break;

                case HIDP_USAGE_SYSCTL_WAKE:
                    *OutputBuffer |= SYS_BUTTON_WAKE;
                    break;


                case HIDP_USAGE_SYSCTL_SLEEP:
                    *OutputBuffer |= SYS_BUTTON_SLEEP;
                    break;
                }
            }
        }
    }
    return status;
}

NTSTATUS
HidP_SysPowerCaps (
    IN  PHIDP_PREPARSED_DATA    Ppd,
    OUT PULONG                  OutputBuffer
    )
{
    *OutputBuffer = Ppd->PowerButtonMask;
    return STATUS_SUCCESS;
}

void
HidP_AssignDataIndices (
    PHIDP_PREPARSED_DATA Ppd,
    PHIDP_GETCOLDESC_DBG Dbg
    )
{
    struct _CHANNEL_REPORT_HEADER * iof;
    PHIDP_CHANNEL_DESC   channel;
    PHIDP_CHANNEL_DESC   scan;
    PHIDP_CHANNEL_DESC   end;
    USHORT i;
    USHORT dataIndex;

    PAGED_CODE();
    UNREFERENCED_PARAMETER (Dbg);

    iof = &Ppd->Input;

    while (TRUE) {
        dataIndex = 0;

        for (i = iof->Offset, channel = &Ppd->Data[iof->Offset];
             i < iof->Index ;
             i++, channel++) {

            if (!channel->MoreChannels) {
                channel->Range.DataIndexMin = dataIndex;
                dataIndex += channel->Range.UsageMax - channel->Range.UsageMin;
                channel->Range.DataIndexMax = dataIndex;
                dataIndex++;
            } else {
                //
                // An array channel.  We must number these backwards.
                //

                scan = channel;

                while (scan->MoreChannels) {
                    scan++;
                    i++;
                }
                end = scan;

                do {
                    scan->Range.DataIndexMin = dataIndex;
                    dataIndex += scan->Range.UsageMax
                               - scan->Range.UsageMin;

                    scan->Range.DataIndexMax = dataIndex;
                    dataIndex++;
                    scan--;

                } while ( channel <= scan );
                channel = end;
            }
        }

        if (&Ppd->Input == iof) {
            iof = &Ppd->Output;
        } else if (&Ppd->Output == iof) {
            iof = &Ppd->Feature;
        } else {
            ASSERT (&Ppd->Feature == iof);
            break;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidparse\hidparse.h ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    HIDPARSE.H

Abstract:

    This module contains the PRIVATE (driver-only) definitions for the
    code that implements the usbd driver.

Environment:

    Kernel & user mode

Revision History:

    Aug-96 : created by Kenneth Ray

--*/


#ifndef _HIDPARSE_H
#define _HIDPARSE_H

#include "hidtoken.h"

#define HIDP_POOL_TAG (ULONG) 'PdiH'
#undef ExAllocatePool
#define ExAllocatePool(type, size) \
            ExAllocatePoolWithTag (type, size, HIDP_POOL_TAG);
// ExAllocatePool is only called in the descript.c and hidparse.c code.
// all other modules are linked into the user DLL.  They cannot allocate any
// memory.

#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4705)   // Statement has no effect

#define DEFAULT_DBG_LEVEL 1 // errors AND warnings

#if DBG
#define HidP_KdPrint(_level_,_x_) \
            if (DEFAULT_DBG_LEVEL <= _level_) { \
               DbgPrint ("'HidParse.SYS: "); \
               DbgPrint _x_; \
            }

#define TRAP() DbgBreakPoint()

#else
#define HidP_KdPrint(_level_,_x_)
#define TRAP()

#endif

#define MIN(a,b) (((a) < (b)) ? (a) : (b))
#define MAX(a,b) (((a) < (b)) ? (b) : (a))

#define HIDP_ISCONST(x)    ((BOOLEAN) ((  (x) & 0x01)  ? TRUE : FALSE))
#define HIDP_ISARRAY(x)    ((BOOLEAN) ((!((x) & 0x02)) ? TRUE : FALSE))
#define HIDP_ISABSOLUTE(x) ((BOOLEAN) ((!((x) & 0x04)) ? TRUE : FALSE))
#define HIDP_HASNULL(x)    ((BOOLEAN) ((  (x) & 0x40)  ? TRUE : FALSE))

#define HIDP_MAX_UNKNOWN_ITEMS 4

typedef struct _HIDP_CHANNEL_DESC
{
   USHORT   UsagePage;
   UCHAR    ReportID;
   UCHAR    BitOffset;    // 0 to 8 value describing bit alignment

   USHORT   ReportSize;   // HID defined report size
   USHORT   ReportCount;  // HID defined report count
   USHORT   ByteOffset;   // byte position of start of field in report packet
   USHORT   BitLength;    // total bit length of this channel

   ULONG    BitField;   // The 8 (plus extra) bits associated with a main item

   USHORT   ByteEnd;      // First byte not containing bits of this channel.
   USHORT   LinkCollection;  // A unique internal index pointer
   USHORT   LinkUsagePage;
   USHORT   LinkUsage;

   ULONG  MoreChannels: 1; // Are there more channel desc associated with
                              // this array.  This happens if there is a
                              // several usages for one main item.
   ULONG  IsConst: 1; // Does this channel represent filler
   ULONG  IsButton: 1; // Is this a channel of binary usages, not value usages.
   ULONG  IsAbsolute: 1; // As apposed to relative
   ULONG  IsRange: 1;
   ULONG  IsAlias: 1; // a usage described in a delimiter
   ULONG  IsStringRange: 1;
   ULONG  IsDesignatorRange: 1;
   ULONG  Reserved: 20;
   ULONG  NumGlobalUnknowns: 4;

   struct _HIDP_UNKNOWN_TOKEN GlobalUnknowns [HIDP_MAX_UNKNOWN_ITEMS];

   union {
      struct {
         USHORT   UsageMin,         UsageMax;
         USHORT   StringMin,        StringMax;
         USHORT   DesignatorMin,    DesignatorMax;
         USHORT   DataIndexMin,     DataIndexMax;
      } Range;
      struct {
         USHORT   Usage,            Reserved1;
         USHORT   StringIndex,      Reserved2;
         USHORT   DesignatorIndex,  Reserved3;
         USHORT   DataIndex,        Reserved4;
      } NotRange;
   };

   union {
      struct {
         LONG     LogicalMin,       LogicalMax;
      } button;
      struct {
         BOOLEAN  HasNull;  // Does this channel have a null report
         UCHAR    Reserved[3];
         LONG     LogicalMin,       LogicalMax;
         LONG     PhysicalMin,      PhysicalMax;
      } Data;
   };

   ULONG    Units;
   ULONG    UnitExp;

} HIDP_CHANNEL_DESC, *PHIDP_CHANNEL_DESC;

struct _CHANNEL_REPORT_HEADER
{
   USHORT Offset;  // Position in the _CHANNEL_ITEM array
   USHORT Size;    // Length in said array
   USHORT Index;
   USHORT ByteLen; // The length of the data including reportID.
                   // This is the longest such report that might be received
                   // for the given collection.
};

#define HIDP_PREPARSED_DATA_SIGNATURE1 'PdiH'
#define HIDP_PREPARSED_DATA_SIGNATURE2 'RDK '

typedef struct _HIDP_SYS_POWER_INFO {
    ULONG   PowerButtonMask;

} HIDP_SYS_POWER_INFO, *PHIDP_SYS_POWER_INFO;

typedef struct _HIDP_PREPARSED_DATA
{
    LONG   Signature1, Signature2;
    USHORT Usage;
    USHORT UsagePage;

    HIDP_SYS_POWER_INFO;

    // The following channel report headers point to data within
    // the Data field below using array indices.
    struct _CHANNEL_REPORT_HEADER Input;
    struct _CHANNEL_REPORT_HEADER Output;
    struct _CHANNEL_REPORT_HEADER Feature;

    // After the CANNEL_DESC array the follows a LinkCollection array nodes.
    // LinkCollectionArrayOffset is the index given to RawBytes to find
    // the first location of the _HIDP_LINK_COLLECTION_NODE structure array
    // (index zero) and LinkCollectionArrayLength is the number of array
    // elements in that array.
    USHORT LinkCollectionArrayOffset;
    USHORT LinkCollectionArrayLength;

    union {
        HIDP_CHANNEL_DESC    Data[];
        UCHAR                RawBytes[];
    };
} HIDP_PREPARSED_DATA;

typedef struct _HIDP_PRIVATE_LINK_COLLECTION_NODE
{
    USAGE    LinkUsage;
    USAGE    LinkUsagePage;
    USHORT   Parent;
    USHORT   NumberOfChildren;
    USHORT   NextSibling;
    USHORT   FirstChild;
    ULONG    CollectionType: 8;  // As defined in 6.2.2.6 of HID spec
    ULONG    IsAlias : 1; // This link node is an allias of the next link node.
    ULONG    Reserved: 23;
} HIDP_PRIVATE_LINK_COLLECTION_NODE, *PHIDP_PRIVATE_LINK_COLLECTION_NODE;



// +++++++++++++++++++++++++++++++++++
// The ITEMS supported by this Parser
// +++++++++++++++++++++++++++++++++++

typedef UCHAR HIDP_ITEM;


//
// Power buttons supported by this parser
//
#define HIDP_USAGE_SYSCTL_PAGE HID_USAGE_PAGE_GENERIC
#define HIDP_USAGE_SYSCTL_POWER HID_USAGE_GENERIC_SYSCTL_POWER
#define HIDP_USAGE_SYSCTL_SLEEP HID_USAGE_GENERIC_SYSCTL_SLEEP
#define HIDP_USAGE_SYSCTL_WAKE  HID_USAGE_GENERIC_SYSCTL_WAKE


//
//
// Keyboard Translation
// translation tables from usages to i8042 scan codes.
//

typedef ULONG HIDP_LOOKUP_TABLE_PROC (
                  IN  PULONG    Table,
                  IN  ULONG     Usage
                  );
typedef HIDP_LOOKUP_TABLE_PROC * PHIDP_LOOKUP_TABLE_PROC;

typedef BOOLEAN HIDP_SCANCODE_SUBTRANSLATION (
                  IN     ULONG                         * Table,
                  IN     UCHAR                           Index,
                  IN     PHIDP_INSERT_SCANCODES          Insert,
                  IN     PVOID                           Context,
                  IN     HIDP_KEYBOARD_DIRECTION         KeyAction,
                  IN OUT PHIDP_KEYBOARD_MODIFIER_STATE   ModifierState
                  );
typedef HIDP_SCANCODE_SUBTRANSLATION * PHIDP_SCANCODE_SUBTRANSLATION;

typedef struct _HIDP_SCANCODE_SUBTABLE {
   PHIDP_SCANCODE_SUBTRANSLATION ScanCodeFcn;
   PULONG                        Table;
} HIDP_SCANCODE_SUBTABLE, *PHIDP_SCANCODE_SUBTABLE;


NTSTATUS HidP_TranslateUsage (
             USAGE                         Usage,
             HIDP_KEYBOARD_DIRECTION       KeyAction,
             PHIDP_KEYBOARD_MODIFIER_STATE ModifierState,
             PHIDP_LOOKUP_TABLE_PROC       LookupTableProc,
             PULONG                        TranslationTable,
             PHIDP_SCANCODE_SUBTABLE       SubTranslationTable,
             PHIDP_INSERT_SCANCODES        InsertCodesProcedure,
             PVOID                         InsertCodesContext
             );

HIDP_LOOKUP_TABLE_PROC HidP_StraightLookup;
HIDP_LOOKUP_TABLE_PROC HidP_AssociativeLookup;

HIDP_SCANCODE_SUBTRANSLATION HidP_KeyboardKeypadCode;
HIDP_SCANCODE_SUBTRANSLATION HidP_ModifierCode;
HIDP_SCANCODE_SUBTRANSLATION HidP_VendorBreakCodesAsMakeCodes;
HIDP_SCANCODE_SUBTRANSLATION HidP_PrintScreenCode;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidparse\query.c ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    query.c

Abstract:

    This module contains the code for querying HID report packets.

Environment:

    Kernel & user mode

Revision History:

    Aug-96 : created by Kenneth Ray

--*/

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

#include <wtypes.h>
#include "hidsdi.h"
#include "hidparse.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HidP_GetCaps)
#pragma alloc_text(PAGE, HidP_GetLinkCollectionNodes)
#pragma alloc_text(PAGE, HidP_GetButtonCaps)
#pragma alloc_text(PAGE, HidP_GetSpecificButtonCaps)
#pragma alloc_text(PAGE, HidP_GetValueCaps)
#pragma alloc_text(PAGE, HidP_GetSpecificValueCaps)
#pragma alloc_text(PAGE, HidP_MaxUsageListLength)
#pragma alloc_text(PAGE, HidP_InitializeReportForID)
#pragma alloc_text(PAGE, HidP_GetExtendedAttributes)
#endif


#define PAGED_CODE()
#ifndef HIDPARSE_USERMODE
#if DBG
    typedef UCHAR KIRQL;
    KIRQL KeGetCurrentIrql();
    #define APC_LEVEL 0x1

    ULONG _cdecl DbgPrint (PCH Format, ...);
    NTSYSAPI VOID NTAPI RtlAssert(PVOID, PVOID, ULONG, PCHAR);

    #define ASSERT( exp ) \
            if (!(exp)) RtlAssert( #exp, __FILE__, __LINE__, NULL )

    #undef PAGED_CODE
    #define PAGED_CODE() \
    if (KeGetCurrentIrql() > APC_LEVEL) { \
        HidP_KdPrint(2, ( "EX: Pageable code called at IRQL %d\n", KeGetCurrentIrql() )); \
        ASSERT(FALSE); \
        }
#else // DBG
    #define ASSERT(x)
#endif // DBG
#else // HIDPARSE_USERMODE
    #define ASSERT(x)
#endif // HIDPARSE_USERMODE

#define CHECK_PPD(_x_) \
   if ((HIDP_PREPARSED_DATA_SIGNATURE1 != (_x_)->Signature1) ||\
       (HIDP_PREPARSED_DATA_SIGNATURE2 != (_x_)->Signature2)) \
   { return HIDP_STATUS_INVALID_PREPARSED_DATA; }

ULONG
HidP_ExtractData (
   IN    USHORT   ByteOffset,
   IN    USHORT   BitOffset,
   IN    USHORT   BitLength,
   IN    PUCHAR   Report
   )
/*++
Routine Description:
   Given a HID report a byte offset, bit offset and bitlength extract the
   bits from the report in little endian BIT order.
--*/
{
   ULONG    inspect = 0;
   USHORT   tmpByte = 0;
   USHORT   tmpBit  = 0;

   // Start with the high bits and work our way down.
   //
   // Little endian (by bit)
   // Byte 2  |Byte 1 |Byte 0
   // 765432107654321076543210  (bits)
   //
   // Get low byte first.  (need the higher bits)
   // Offset is from bit zero.
   //

   tmpByte = (ByteOffset << 3) + BitOffset + BitLength;
   tmpBit = tmpByte & 7;
   tmpByte >>= 3;

   if (BitLength < tmpBit) {
       inspect = (UCHAR) Report [tmpByte] & ((1 << tmpBit) - 1);
       inspect >>= BitOffset;
       return inspect;
   }

   if (tmpBit)
   {  // Not Byte alligned!

      inspect = (UCHAR) Report [tmpByte] & ((1 << tmpBit) - 1);
      BitLength -= tmpBit;
   }
   tmpByte--;

   while (BitLength >= 8)
   {
      inspect <<= 8;
      inspect |= (UCHAR) Report[tmpByte];
      BitLength -= 8;
      tmpByte--;
   }

   if (BitLength)
   {
      inspect <<= BitLength;
      inspect |= (UCHAR) (  (Report [tmpByte] >> (8 - BitLength))
                          & ((1 << BitLength) - 1));
   }
   return inspect;
}

void
HidP_InsertData (
   IN       USHORT   ByteOffset,
   IN       USHORT   BitOffset,
   IN       USHORT   BitLength, // Length of the value set in bits.
   IN OUT   PUCHAR   Report,
   IN       ULONG    Value
   )
/*++
Routine Description:
   Given a HID report a byte offset, bit offset and bitlength set those bits
   in little endian BIT order to the value provided.
--*/
{
    ULONG   mask;
    ULONG   tmpBit;
    //
    // Little endian (by bit)
    // Byte 2  |Byte 1 |Byte 0
    // 765432107654321076543210  (bits)
    //
    // Get low byte first.  (need the higher bits)
    // Offset is from bit zero.
    //

    tmpBit = BitLength + BitOffset;
    if (tmpBit < 8) {
        mask = (1 << tmpBit) - (1 << BitOffset);
        Report [ByteOffset] &= ~mask;
        Report [ByteOffset] |= (UCHAR) ((Value << BitOffset) & mask);
        return;
    }

    if (BitOffset)
    {  // Not byte aligned, deal with the last partial byte.

        Report [ByteOffset] &= ((1 << BitOffset) - 1); // Zap upper bits
        Report [ByteOffset] |= (UCHAR) (Value << BitOffset);
        BitLength -= (8 - BitOffset);
        Value >>= (8 - BitOffset);
        ByteOffset++;
    }

    while (BitLength >= 8)
    {
        Report [ByteOffset] = (UCHAR) Value;
        Value >>= 8;
        BitLength -= 8;
        ByteOffset++;
    }

    if (BitLength)
    {
        Report [ByteOffset] &= ((UCHAR) 0 - (UCHAR) (1 << BitLength));
        // Zap lower bits.
        Report [ByteOffset] |= (Value & ((1 << BitLength) - 1));
    }
}


HidP_DeleteArrayEntry (
   IN       ULONG    BitPos,
   IN       USHORT   BitLength, // Length of the value set in bits.
   IN       USHORT   ReportCount,
   IN       ULONG    Value, // Value to delete.
   IN OUT   PUCHAR   Report
   )
/*++
Routine Description:
   Given a HID report a byte offset, bit offset and bitlength
   remove that data item from the report, by shifting all data items
   left until the last item finally setting that one to zero.
   In otherwards clear the given entry from the hid array.

   NOTE: If there are two such values set we only eliminate the first one.
--*/
{
    ULONG   tmpValue;
    ULONG   localBitPos; // for debugging only. Compiler should kill this line.
    ULONG   localRemaining;
    ULONG   nextBitPos;

    localBitPos = BitPos;
    tmpValue = 0;
    localRemaining = ReportCount;

    ASSERT (0 < ReportCount);
    ASSERT (0 != Value);

    //
    // Find the data.
    //

    while (0 < localRemaining) {
        tmpValue = HidP_ExtractData ((USHORT) (localBitPos >> 3),
                                     (USHORT) (localBitPos & 7),
                                     BitLength,
                                     Report);

        if (Value == tmpValue) {
            break;
        }

        localBitPos += BitLength;
        localRemaining--;
    }

    if (Value != tmpValue) {
        return HIDP_STATUS_BUTTON_NOT_PRESSED;
    }

    while (1 < localRemaining) {
        nextBitPos = localBitPos + BitLength;

        tmpValue = HidP_ExtractData ((USHORT) (nextBitPos >> 3),
                                     (USHORT) (nextBitPos & 7),
                                     BitLength,
                                     Report);

        HidP_InsertData ((USHORT) (localBitPos >> 3),
                         (USHORT) (localBitPos & 7),
                         BitLength,
                         Report,
                         tmpValue);

        localBitPos = nextBitPos;
        localRemaining--;
    }

    HidP_InsertData ((USHORT) (localBitPos >> 3),
                     (USHORT) (localBitPos & 7),
                     BitLength,
                     Report,
                     0);

    return HIDP_STATUS_SUCCESS;
}


NTSTATUS __stdcall
HidP_GetCaps (
   IN   PHIDP_PREPARSED_DATA      PreparsedData,
   OUT  PHIDP_CAPS                Capabilities
   )
/*++
Routine Description:
   Please see Hidpi.h for routine description

Notes:
--*/
{
   ULONG               i;
   HIDP_CHANNEL_DESC * data;

   PAGED_CODE();
   CHECK_PPD (PreparsedData);

   RtlZeroMemory (Capabilities, sizeof(HIDP_CAPS));

   Capabilities->UsagePage = PreparsedData->UsagePage;
   Capabilities->Usage = PreparsedData->Usage;
   Capabilities->InputReportByteLength = PreparsedData->Input.ByteLen;
   Capabilities->OutputReportByteLength = PreparsedData->Output.ByteLen;
   Capabilities->FeatureReportByteLength = PreparsedData->Feature.ByteLen;

    // Reserved fields go here

   Capabilities->NumberLinkCollectionNodes =
       PreparsedData->LinkCollectionArrayLength;

   Capabilities->NumberInputButtonCaps = 0;
   Capabilities->NumberInputValueCaps = 0;
   Capabilities->NumberOutputButtonCaps = 0;
   Capabilities->NumberOutputValueCaps = 0;
   Capabilities->NumberFeatureButtonCaps = 0;
   Capabilities->NumberFeatureValueCaps = 0;

   i=PreparsedData->Input.Offset;
   data = &PreparsedData->Data[i];
   Capabilities->NumberInputDataIndices = 0;
   for (; i < PreparsedData->Input.Index; i++, data++)
   {
      if (data->IsButton)
      {
         Capabilities->NumberInputButtonCaps++;
      } else
      {
         Capabilities->NumberInputValueCaps++;
      }
      Capabilities->NumberInputDataIndices += data->Range.DataIndexMax
                                            - data->Range.DataIndexMin
                                            + 1;
   }

   i=PreparsedData->Output.Offset;
   data = &PreparsedData->Data[i];
   Capabilities->NumberOutputDataIndices = 0;
   for (; i < PreparsedData->Output.Index; i++, data++)
   {
      if (data->IsButton)
      {
         Capabilities->NumberOutputButtonCaps++;
      } else
      {
         Capabilities->NumberOutputValueCaps++;
      }

      Capabilities->NumberOutputDataIndices += data->Range.DataIndexMax
                                             - data->Range.DataIndexMin
                                             + 1;
   }

   i=PreparsedData->Feature.Offset;
   data = &PreparsedData->Data[i];
   Capabilities->NumberFeatureDataIndices = 0;
   for (; i < PreparsedData->Feature.Index; i++, data++)
   {
      if (data->IsButton)
      {
         Capabilities->NumberFeatureButtonCaps++;
      } else
      {
         Capabilities->NumberFeatureValueCaps++;
      }

      Capabilities->NumberFeatureDataIndices += data->Range.DataIndexMax
                                              - data->Range.DataIndexMin
                                              + 1;
   }

   return HIDP_STATUS_SUCCESS;
}

NTSTATUS __stdcall
HidP_GetLinkCollectionNodes (
   OUT      PHIDP_LINK_COLLECTION_NODE LinkCollectionNodes,
   IN OUT   PULONG                     LinkCollectionNodesLength,
   IN       PHIDP_PREPARSED_DATA       PreparsedData
   )
/*++
Routine Description:
   Please see Hidpi.h for routine description

--*/
{
   PHIDP_PRIVATE_LINK_COLLECTION_NODE nodeArray;
   ULONG                      length;
   ULONG                      i;
   NTSTATUS                   status = HIDP_STATUS_SUCCESS;

   PAGED_CODE();
   CHECK_PPD (PreparsedData);

   if (*LinkCollectionNodesLength < PreparsedData->LinkCollectionArrayLength) {
      length = *LinkCollectionNodesLength;
      status = HIDP_STATUS_BUFFER_TOO_SMALL;
   } else {
      length = PreparsedData->LinkCollectionArrayLength;
   }
   *LinkCollectionNodesLength = PreparsedData->LinkCollectionArrayLength;

   nodeArray = (PHIDP_PRIVATE_LINK_COLLECTION_NODE)
               (PreparsedData->RawBytes +
                PreparsedData->LinkCollectionArrayOffset);

   for (i = 0;
        i < length;
        i++, LinkCollectionNodes++, nodeArray++ ) {
       // *LinkCollectionNodes = *nodeArray;

       LinkCollectionNodes->LinkUsage = nodeArray->LinkUsage;
       LinkCollectionNodes->LinkUsagePage = nodeArray->LinkUsagePage;
       LinkCollectionNodes->Parent = nodeArray->Parent;
       LinkCollectionNodes->NumberOfChildren = nodeArray->NumberOfChildren;
       LinkCollectionNodes->NextSibling = nodeArray->NextSibling;
       LinkCollectionNodes->FirstChild = nodeArray->FirstChild;
       LinkCollectionNodes->CollectionType = nodeArray->CollectionType;
       LinkCollectionNodes->IsAlias = nodeArray->IsAlias;

   }
   return status;
}

#undef HidP_GetButtonCaps
NTSTATUS __stdcall
HidP_GetButtonCaps (
   IN       HIDP_REPORT_TYPE     ReportType,
   OUT      PHIDP_BUTTON_CAPS    ButtonCaps,
   IN OUT   PUSHORT              ButtonCapsLength,
   IN       PHIDP_PREPARSED_DATA PreparsedData
   )
/*++
Routine Description:
   Please see Hidpi.h for routine description

Notes:
--*/
{
   return HidP_GetSpecificButtonCaps (ReportType,
                                      0,
                                      0,
                                      0,
                                      ButtonCaps,
                                      ButtonCapsLength,
                                      PreparsedData);
}

NTSTATUS __stdcall
HidP_GetSpecificButtonCaps (
   IN       HIDP_REPORT_TYPE     ReportType,
   IN       USAGE                UsagePage,      // Optional (0 => ignore)
   IN       USHORT               LinkCollection, // Optional (0 => ignore)
   IN       USAGE                Usage,          // Optional (0 => ignore)
   OUT      PHIDP_BUTTON_CAPS    ButtonCaps,
   IN OUT   PUSHORT              ButtonCapsLength,
   IN       PHIDP_PREPARSED_DATA PreparsedData
   )
/*++
Routine Description:
   Please see Hidpi.h for routine description

Notes:
--*/
{
   struct _CHANNEL_REPORT_HEADER * iof;
   PHIDP_CHANNEL_DESC   channel;
   NTSTATUS             status = HIDP_STATUS_USAGE_NOT_FOUND;
   USHORT i, j;

   PAGED_CODE();
   CHECK_PPD (PreparsedData);

   switch (ReportType) {
   case HidP_Input:
       iof = &PreparsedData->Input;
       break;

   case HidP_Output:
       iof = &PreparsedData->Output;
       break;

   case HidP_Feature:
       iof = &PreparsedData->Feature;
       break;

   default:
       return HIDP_STATUS_INVALID_REPORT_TYPE;
   }

   for (i = iof->Offset, j = 0; i < iof->Index ; i++)
   {
      channel = &PreparsedData->Data[i];
      if ((channel->IsButton) &&
          ((!UsagePage || (UsagePage == channel->UsagePage)) &&
           (!LinkCollection || (LinkCollection == channel->LinkCollection)
                            || ((HIDP_LINK_COLLECTION_ROOT == LinkCollection) &&
                                (0 == channel->LinkCollection))) &&
           (!Usage || ((channel->Range.UsageMin <= Usage) &&
                       (Usage <= channel->Range.UsageMax)))))
      {
         status = HIDP_STATUS_SUCCESS;

         if (j < *ButtonCapsLength)
         {
            ButtonCaps[j].UsagePage = channel->UsagePage;
            ButtonCaps[j].LinkCollection = channel->LinkCollection;
            ButtonCaps[j].LinkUsagePage = channel->LinkUsagePage;
            ButtonCaps[j].LinkUsage = channel->LinkUsage;
            ButtonCaps[j].IsRange = (BOOLEAN) channel->IsRange;
            ButtonCaps[j].IsStringRange = (BOOLEAN) channel->IsStringRange;
            ButtonCaps[j].IsDesignatorRange=(BOOLEAN)channel->IsDesignatorRange;
            ButtonCaps[j].ReportID = channel->ReportID;
            ButtonCaps[j].BitField = (USHORT) channel->BitField;
            ButtonCaps[j].IsAbsolute = (BOOLEAN) channel->IsAbsolute;
            ButtonCaps[j].IsAlias = (BOOLEAN) channel->IsAlias;
//            if (channel->IsRange)
//            {
            ButtonCaps[j].Range.UsageMin = channel->Range.UsageMin;
            ButtonCaps[j].Range.UsageMax = channel->Range.UsageMax;
            ButtonCaps[j].Range.DataIndexMin = channel->Range.DataIndexMin;
            ButtonCaps[j].Range.DataIndexMax = channel->Range.DataIndexMax;
//            } else
//            {
//               ButtonCaps[j].NotRange.Usage = channel->NotRange.Usage;
//            }
//            if (channel->IsStringRange)
//            {
            ButtonCaps[j].Range.StringMin = channel->Range.StringMin;
            ButtonCaps[j].Range.StringMax = channel->Range.StringMax;
//            } else
//            {
//               ButtonCaps[j].NotRange.StringIndex
//                  = channel->NotRange.StringIndex;
//            }
//            if (channel->IsDesignatorRange)
//            {
            ButtonCaps[j].Range.DesignatorMin = channel->Range.DesignatorMin;
            ButtonCaps[j].Range.DesignatorMax = channel->Range.DesignatorMax;
//            } else
//            {
//               ButtonCaps[j].NotRange.DesignatorIndex
//                  = channel->NotRange.DesignatorIndex;
//            }
         } else {
             status = HIDP_STATUS_BUFFER_TOO_SMALL;
         }
         j++;
      }
   }
   *ButtonCapsLength = j;
   return status;
}

#undef HidP_GetValueCaps
NTSTATUS __stdcall
HidP_GetValueCaps (
   IN       HIDP_REPORT_TYPE     ReportType,
   OUT      PHIDP_VALUE_CAPS     ValueCaps,
   IN OUT   PUSHORT              ValueCapsLength,
   IN       PHIDP_PREPARSED_DATA PreparsedData
   )
/*++
Routine Description:
   Please see Hidpi.h for routine description

Notes:
--*/
{
   return HidP_GetSpecificValueCaps (ReportType,
                                    0,
                                    0,
                                    0,
                                    ValueCaps,
                                    ValueCapsLength,
                                    PreparsedData);
}

NTSTATUS __stdcall
HidP_GetSpecificValueCaps (
   IN       HIDP_REPORT_TYPE     ReportType,
   IN       USAGE                UsagePage,      // Optional (0 => ignore)
   IN       USHORT               LinkCollection, // Optional (0 => ignore)
   IN       USAGE                Usage,          // Optional (0 => ignore)
   OUT      PHIDP_VALUE_CAPS     ValueCaps,
   IN OUT   PUSHORT              ValueCapsLength,
   IN       PHIDP_PREPARSED_DATA PreparsedData
   )
/*++
Routine Description:
   Please see Hidpi.h for routine description

Notes:
--*/
{
   struct _CHANNEL_REPORT_HEADER * iof;
   PHIDP_CHANNEL_DESC   channel;
   NTSTATUS             status = HIDP_STATUS_USAGE_NOT_FOUND;
   USHORT   i, j;

   CHECK_PPD (PreparsedData);
   PAGED_CODE ();

   switch (ReportType) {
   case HidP_Input:
       iof = &PreparsedData->Input;
       break;

   case HidP_Output:
       iof = &PreparsedData->Output;
       break;

   case HidP_Feature:
       iof = &PreparsedData->Feature;
       break;

   default:
       return HIDP_STATUS_INVALID_REPORT_TYPE;
   }

   for (i = iof->Offset, j = 0; i < iof->Index ; i++)
   {
      channel = &PreparsedData->Data[i];
      if ((!channel->IsButton) &&
          ((!UsagePage || (UsagePage == channel->UsagePage)) &&
           (!LinkCollection || (LinkCollection == channel->LinkCollection)
                            || ((HIDP_LINK_COLLECTION_ROOT == LinkCollection) &&
                                (0 == channel->LinkCollection))) &&
           (!Usage || ((channel->Range.UsageMin <= Usage) &&
                       (Usage <= channel->Range.UsageMax)))))
      {
         status = HIDP_STATUS_SUCCESS;

         if (j < *ValueCapsLength)
         {
            ValueCaps[j].UsagePage = channel->UsagePage;
            ValueCaps[j].LinkCollection = channel->LinkCollection;
            ValueCaps[j].LinkUsagePage = channel->LinkUsagePage;
            ValueCaps[j].LinkUsage = channel->LinkUsage;
            ValueCaps[j].IsRange = (BOOLEAN) channel->IsRange;
            ValueCaps[j].IsStringRange = (BOOLEAN) channel->IsStringRange;
            ValueCaps[j].IsDesignatorRange =(BOOLEAN)channel->IsDesignatorRange;
            ValueCaps[j].ReportID = channel->ReportID;
            ValueCaps[j].BitField = (USHORT) channel->BitField;
            ValueCaps[j].BitSize = channel->ReportSize;
            ValueCaps[j].IsAbsolute = (BOOLEAN) channel->IsAbsolute;
            ValueCaps[j].HasNull = channel->Data.HasNull;
            ValueCaps[j].Units = channel->Units;
            ValueCaps[j].UnitsExp = channel->UnitExp;
            ValueCaps[j].LogicalMin = channel->Data.LogicalMin;
            ValueCaps[j].LogicalMax = channel->Data.LogicalMax;
            ValueCaps[j].PhysicalMin = channel->Data.PhysicalMin;
            ValueCaps[j].PhysicalMax = channel->Data.PhysicalMax;
            ValueCaps[j].IsAlias = (BOOLEAN) channel->IsAlias;
//            if (channel->IsRange)
//            {
            ValueCaps[j].Range.UsageMin = channel->Range.UsageMin;
            ValueCaps[j].Range.UsageMax = channel->Range.UsageMax;
            ValueCaps[j].Range.DataIndexMin = channel->Range.DataIndexMin;
            ValueCaps[j].Range.DataIndexMax = channel->Range.DataIndexMax;
//            } else
//            {
//               ValueCaps[j].NotRange.Usage = channel->NotRange.Usage;
//            }
//            if (channel->IsStringRange)
//            {
            ValueCaps[j].Range.StringMin = channel->Range.StringMin;
            ValueCaps[j].Range.StringMax = channel->Range.StringMax;
//            } else
//            {
//               ValueCaps[j].NotRange.StringIndex
//                  = channel->NotRange.StringIndex;
//            }
//            if (channel->IsDesignatorRange)
//            {
            ValueCaps[j].Range.DesignatorMin = channel->Range.DesignatorMin;
            ValueCaps[j].Range.DesignatorMax = channel->Range.DesignatorMax;
//            } else
//            {
//               ValueCaps[j].NotRange.DesignatorIndex
//                  = channel->NotRange.DesignatorIndex;
//            }


            ValueCaps[j].ReportCount = (channel->IsRange)
                                     ? 1
                                     : channel->ReportCount;

         } else {
             status = HIDP_STATUS_BUFFER_TOO_SMALL;
         }
         j++;
      }
   }
   *ValueCapsLength = j;
   return status;
}

NTSTATUS __stdcall
HidP_GetExtendedAttributes (
    IN      HIDP_REPORT_TYPE            ReportType,
    IN      USHORT                      DataIndex,
    IN      PHIDP_PREPARSED_DATA        PreparsedData,
    OUT     PHIDP_EXTENDED_ATTRIBUTES   Attributes,
    IN OUT  PULONG                      LengthAttributes
    )
/*++

Routine Description:

   Please See hidpi.h for description.

--*/
{
    struct _CHANNEL_REPORT_HEADER * iof;
    PHIDP_CHANNEL_DESC              channel;
    HIDP_EXTENDED_ATTRIBUTES        buffer;
    ULONG       channelIndex    = 0;
    NTSTATUS    status = HIDP_STATUS_DATA_INDEX_NOT_FOUND;
    ULONG       i;
    ULONG       actualLen, copyLen = 0;

    CHECK_PPD (PreparsedData);

    PAGED_CODE ();

    switch (ReportType) {
    case HidP_Input:
        iof = &PreparsedData->Input;
        break;
    case HidP_Output:
        iof = &PreparsedData->Output;
        break;
    case HidP_Feature:
        iof = &PreparsedData->Feature;
        break;
    default:
        return HIDP_STATUS_INVALID_REPORT_TYPE;
    }

    for (channelIndex = iof->Offset, channel = PreparsedData->Data;
         channelIndex < iof->Index;
         channelIndex++, channel++) {

        if ((channel->Range.DataIndexMin <= DataIndex) &&
            (DataIndex <= channel->Range.DataIndexMax)) {

            RtlZeroMemory (Attributes, *LengthAttributes);
            RtlZeroMemory (&buffer, sizeof (buffer));

            //
            // Set the fixed parameters
            //
            buffer.NumGlobalUnknowns = (UCHAR) channel->NumGlobalUnknowns;
            // buffer.GlobalUnknowns = channel->GlobalUnknowns;

            //
            // Set the length
            //
            actualLen = FIELD_OFFSET (HIDP_EXTENDED_ATTRIBUTES, Data)
                      + (buffer.NumGlobalUnknowns * sizeof(HIDP_UNKNOWN_TOKEN));

            //
            // Copy over the fixed paramters
            //
            copyLen = MIN (*LengthAttributes, sizeof (buffer));
            RtlCopyMemory (Attributes, &buffer, copyLen);

            //
            // Copy over the data.
            //
            copyLen = MIN (*LengthAttributes, actualLen)
                    - FIELD_OFFSET (HIDP_EXTENDED_ATTRIBUTES, Data);

            if (copyLen && copyLen <= (MIN(*LengthAttributes, actualLen))) {
                RtlCopyMemory ((PVOID) Attributes->Data,
                               (PVOID) channel->GlobalUnknowns,
                               copyLen);
            }

            if (*LengthAttributes < actualLen) {
                status = HIDP_STATUS_BUFFER_TOO_SMALL;
            } else {
                status = HIDP_STATUS_SUCCESS;
            }

            break;
        }
    }

    return status;
}

NTSTATUS __stdcall
HidP_InitializeReportForID (
   IN       HIDP_REPORT_TYPE      ReportType,
   IN       UCHAR                 ReportID,
   IN       PHIDP_PREPARSED_DATA  PreparsedData,
   IN OUT   PCHAR                 Report,
   IN       ULONG                 ReportLength
   )
/*++

Routine Description:

   Please See hidpi.h for description.

--*/
{
    struct _CHANNEL_REPORT_HEADER * iof;
    PHIDP_CHANNEL_DESC              channel;
    NTSTATUS  status          = HIDP_STATUS_REPORT_DOES_NOT_EXIST;
    ULONG     channelIndex    = 0;
    ULONG     reportBitIndex  = 0;
    ULONG     nullMask        = 0;
    LONG      nullValue       = 0;
    ULONG     i;

    CHECK_PPD (PreparsedData);

    PAGED_CODE ();

    switch (ReportType) {
    case HidP_Input:
        iof = &PreparsedData->Input;
        break;
    case HidP_Output:
        iof = &PreparsedData->Output;
        break;
    case HidP_Feature:
        iof = &PreparsedData->Feature;
        break;
    default:
        return HIDP_STATUS_INVALID_REPORT_TYPE;
    }

    if ((USHORT) ReportLength != iof->ByteLen) {
        return HIDP_STATUS_INVALID_REPORT_LENGTH;
    }

    if (0 == iof->ByteLen) {
        return HIDP_STATUS_REPORT_DOES_NOT_EXIST;
    }

    RtlZeroMemory (Report, ReportLength);
    // Set the report ID for this report
    Report[0] = ReportID;

    for (channelIndex = iof->Offset, channel = PreparsedData->Data;
         channelIndex < iof->Index;
         channelIndex++, channel++) {
        //
        // Walk the list of channels looking for fields that need initialization
        //

        if (channel->ReportID != ReportID) {
            continue;
        }
        status = HIDP_STATUS_SUCCESS;

        if ((channel->IsButton) || (channel->IsConst) || (channel->IsAlias)) {
            //
            // Buttons are initialized to zero
            // Constants cannot be set
            // Aliases are referenced by their first entries
            //
            continue;
        }


        if (channel->Data.HasNull) {

            if (32 == channel->ReportSize) {
                nullMask = -1;
            } else {
                nullMask = (1 << channel->ReportSize) - 1;
            }
            //
            // Note logical values are always unsigned.
            // (Not to be confused with physical values which are signed.)
            //
            if (channel->Data.LogicalMax < channel->Data.LogicalMin) {
                //
                // This is really an error.  I'm not sure what I should do here.
                //
                nullValue = 0;

            } else {
                nullValue = (channel->Data.LogicalMin - 1) & nullMask;
            }


            if ((channel->Data.LogicalMin <= nullValue) &&
                (nullValue <= channel->Data.LogicalMax)) {
                //
                //
                //
                // Now what?
                //
                nullValue = 0;
            }

        } else {
            //
            // I don't know what I should do in this case: the device has no
            // reported nul state.
            //
            // For now let's just leave it zero
            //
            nullValue = 0;
        }

        if (0 == nullValue) {
            //
            // Nothing to do on this pass
            //
            continue;
        }

        if (channel->IsRange) {
            for (i = 0, reportBitIndex = (channel->ByteOffset << 3)
                                       + (channel->BitOffset);

                 i < channel->ReportCount;

                 i++, reportBitIndex += channel->ReportSize) {
                //
                // Set all the fields in the range
                //
                HidP_InsertData ((USHORT) (reportBitIndex >> 3),
                                 (USHORT) (reportBitIndex & 7),
                                 channel->ReportSize,
                                 Report,
                                 nullValue);
            }
        } else {

            HidP_InsertData (channel->ByteOffset,
                             channel->BitOffset,
                             channel->ReportSize,
                             Report,
                             nullValue);
        }
    }
    return status;
}

USAGE
HidP_Index2Usage (
   PHIDP_CHANNEL_DESC   Channels,
   ULONG                Index
   )
/*++
   Routine Description:
      Given an array of channels convert an index (the likes of which you might
      find in an array field of a HID report) into a usage value.
--*/
{
   USHORT               len;
   PHIDP_CHANNEL_DESC   startChannel = Channels;
   USAGE                usageMin;
   USAGE                usageMax;

   if (!Index) {
       return 0;
   }

   while (Channels->MoreChannels) {
       // The channels are listed in reverse order.
       Channels++;
   }

   while (Index) {
       if (Channels->IsRange) {
           usageMin = Channels->Range.UsageMin;
           usageMin = (usageMin ? usageMin : 1);
           // Index is 1 based (an index of zero is no usage at all)
           // But a UsageMin of zero means that UsageMin is exclusive.
           // That means that if the index is 1 and UsageMin is non-zero,
           // than this function should return UsageMin

           usageMax = Channels->Range.UsageMax;
           len = (usageMax + 1) - usageMin;
           //               ^^^ Usage Max is inclusive.

           if (Index <= len) {
               return ((USAGE) Index) + usageMin - 1;
           } else {
               Index -= len;
           }
       } else if (1 == Index) {
               return Channels->NotRange.Usage;
       } else {
           Index--;
       }

       if (startChannel != Channels) {
           Channels--;
           continue;
       }
       return 0;
   }
   return 0;
}

ULONG
HidP_Usage2Index (
   PHIDP_CHANNEL_DESC   Channels,
   USAGE                Usage
   )
/*++
   Routine Description:
      Given an usage convert it into an index suitable for placement into an
      array main item.
--*/
{
   PHIDP_CHANNEL_DESC   startChannel;
   ULONG                index = 0;
   USAGE                UsageMin;
   USAGE                UsageMax;

   startChannel = Channels;

   while (Channels->MoreChannels) {
      Channels++;
   }

   for (; startChannel <= Channels; Channels--) {
       if (Channels->IsRange) {
           UsageMin = Channels->Range.UsageMin;
           UsageMin = (UsageMin ? UsageMin : 1);
           // Index is 1 based (an index of zero is no usage at all)
           // But a UsageMin of zero means that UsageMin is exclusive.
           // That means that if the index is 1 and UsageMin is non-zero,
           // than this function should return UsageMin
           UsageMax = Channels->Range.UsageMax;
           if ((UsageMin <= Usage) && (Usage <= UsageMax)) {
               return (index + 1 + Usage - UsageMin);
           }
           index += 1 + (UsageMax - UsageMin);
       } else {
           index++;
           if (Usage == Channels->NotRange.Usage) {
               return index;
           }
       }
   }
   return 0;
}


NTSTATUS __stdcall
HidP_SetUnsetOneUsage (
   struct _CHANNEL_REPORT_HEADER *,
   USAGE,
   USHORT,
   USAGE,
   PHIDP_PREPARSED_DATA,
   PCHAR,
   BOOLEAN);

NTSTATUS __stdcall
HidP_SetUsages (
   IN       HIDP_REPORT_TYPE      ReportType,
   IN       USAGE                 UsagePage,
   IN       USHORT                LinkCollection,
   IN       PUSAGE                UsageList,
   IN OUT   PULONG                UsageLength,
   IN       PHIDP_PREPARSED_DATA  PreparsedData,
   IN OUT   PCHAR                 Report,
   IN       ULONG                 ReportLength
   )
/*++

Routine Description:
   Please See hidpi.h for description.

Notes:
--*/
{
   struct _CHANNEL_REPORT_HEADER * iof;
   NTSTATUS  status      = HIDP_STATUS_SUCCESS;
   ULONG     usageIndex  = 0;

   CHECK_PPD (PreparsedData);

   switch (ReportType) {
   case HidP_Input:
       iof = &PreparsedData->Input;
       break;
   case HidP_Output:
       iof = &PreparsedData->Output;
       break;
   case HidP_Feature:
       iof = &PreparsedData->Feature;
       break;
   default:
       return HIDP_STATUS_INVALID_REPORT_TYPE;
   }

   if ((USHORT) ReportLength != iof->ByteLen) {
      return HIDP_STATUS_INVALID_REPORT_LENGTH;
   }

   if (0 == iof->ByteLen) {
       return HIDP_STATUS_REPORT_DOES_NOT_EXIST;
   }

   for (usageIndex = 0; usageIndex < *UsageLength; usageIndex++) {

       if (0 == UsageList [usageIndex]) {
           continue;
       }

       status = HidP_SetUnsetOneUsage (iof,
                                       UsagePage,
                                       LinkCollection,
                                       UsageList [usageIndex],
                                       PreparsedData,
                                       Report,
                                       TRUE);
       if (!NT_SUCCESS(status)) {
           break;
       }
   }
   *UsageLength = usageIndex;
   return status;
}

NTSTATUS __stdcall
HidP_UnsetUsages (
   IN       HIDP_REPORT_TYPE      ReportType,
   IN       USAGE                 UsagePage,
   IN       USHORT                LinkCollection,
   IN       PUSAGE                UsageList,
   IN OUT   PULONG                UsageLength,
   IN       PHIDP_PREPARSED_DATA  PreparsedData,
   IN OUT   PCHAR                 Report,
   IN       ULONG                 ReportLength
   )
/*++

Routine Description:
   Please See hidpi.h for description.

Notes:
--*/
{
   struct _CHANNEL_REPORT_HEADER * iof;
   NTSTATUS  status      = HIDP_STATUS_SUCCESS;
   ULONG     usageIndex  = 0;

   CHECK_PPD (PreparsedData);

   switch (ReportType) {
   case HidP_Input:
      iof = &PreparsedData->Input;
      break;
   case HidP_Output:
      iof = &PreparsedData->Output;
      break;
   case HidP_Feature:
      iof = &PreparsedData->Feature;
      break;
   default:
      return HIDP_STATUS_INVALID_REPORT_TYPE;
   }

   if ((USHORT) ReportLength != iof->ByteLen) {
      return HIDP_STATUS_INVALID_REPORT_LENGTH;
   }

   if (0 == iof->ByteLen) {
       return HIDP_STATUS_REPORT_DOES_NOT_EXIST;
   }

   for (usageIndex = 0; usageIndex < *UsageLength; usageIndex++) {

       if (0 == UsageList [usageIndex]) {
           continue;
       }

       status = HidP_SetUnsetOneUsage (iof,
                                       UsagePage,
                                       LinkCollection,
                                       UsageList [usageIndex],
                                       PreparsedData,
                                       Report,
                                       FALSE);
       if (!NT_SUCCESS(status)) {
           break;
       }
   }
   *UsageLength = usageIndex;
   return status;
}

NTSTATUS __stdcall
HidP_SetUnsetOneUsage (
   struct _CHANNEL_REPORT_HEADER * IOF,
   USAGE                           UsagePage,
   USHORT                          LinkCollection,
   USAGE                           Usage,
   PHIDP_PREPARSED_DATA            PreparsedData,
   PCHAR                           Report,
   BOOLEAN                         Set
   )
/*++
Routine Description:
   Perform the work of SetUsage one usage at a time.
   Yes this is slow but it works.

Notes:
   This function assumes the report length has already been verified.
--*/
{
   PHIDP_CHANNEL_DESC   channel         = 0;
   PHIDP_CHANNEL_DESC   priChannel      = 0;
   PHIDP_CHANNEL_DESC   firstChannel    = 0;
   // the channel where the array starts

   ULONG                channelIndex    = 0;
   ULONG                reportByteIndex = 0;
   ULONG                inspect         = 0;
   USHORT               reportBitIndex  = 0;
   BOOLEAN              wrongReportID   = FALSE;
   BOOLEAN              noArraySpace    = FALSE;
   BOOLEAN              notPressed      = FALSE;
   NTSTATUS             status          = HIDP_STATUS_SUCCESS;

   for (channelIndex = IOF->Offset; channelIndex < IOF->Index; channelIndex++) {
      channel = (PreparsedData->Data + channelIndex);
      if (priChannel) {
         if (!priChannel->MoreChannels) {
            firstChannel = channel;
         }
      } else {
         firstChannel = channel;
      }
      priChannel = channel;

      if ((!channel->IsButton) ||
          (channel->UsagePage != UsagePage)) {
          continue;
      }

      //
      // If LinkCollection is zero we will not filter by link collections
      // If channel->LinkCollection is zero this is the root collection.
      // Therefore if LinkCollection == channel->LinkCollection then this is OK
      //
      if ((!LinkCollection) ||
          (LinkCollection == channel->LinkCollection) ||
          ((HIDP_LINK_COLLECTION_ROOT == LinkCollection) &&
           (0 == channel->LinkCollection))) {
          ;

      } else {
          continue;
      }

      if (   ((channel->IsRange)  && (channel->Range.UsageMin <= Usage)
                                  && (Usage <= channel->Range.UsageMax))
          || ((!channel->IsRange) && (channel->NotRange.Usage == Usage))) {
          //
          // Test the report ID to see if it is compatible.
          //
         if ((0 != Report[0]) && (channel->ReportID != (UCHAR) Report[0])) {
             //
             // Distinguish between the errors HIDP_USAGE_NOT_FOUND and
             // HIDP_INCOMPATIBLE_REPORT_ID.
             wrongReportID = TRUE;
             continue;
         }

         Report[0] = (CHAR) channel->ReportID;
         //
         // Set the report ID for this report
         //

         if (1 == channel->ReportSize) {
            reportBitIndex = (channel->ByteOffset << 3)
                           + channel->BitOffset
                           + (USHORT) (Usage - channel->Range.UsageMin);

            if (Set) {
                Report [reportBitIndex >> 3] |= (1 << (reportBitIndex & 7));
            } else if (Report [reportBitIndex >> 3] & (1 << (reportBitIndex & 7))) {
                Report [reportBitIndex >> 3] &= ~(1 << (reportBitIndex & 7));
            } else {
                return HIDP_STATUS_BUTTON_NOT_PRESSED;
            }

            return HIDP_STATUS_SUCCESS;
         } else if (Set) {  // usage array


            for (reportBitIndex = channel->BitOffset;
                 reportBitIndex < (channel->BitOffset + channel->BitLength);
                 reportBitIndex += channel->ReportSize) {

               inspect = HidP_ExtractData (
                     (USHORT) ((reportBitIndex >> 3) + channel->ByteOffset),
                     (USHORT) (reportBitIndex & 7),
                     channel->ReportSize,
                     Report);

               if (inspect) {
                  //
                  // Distinguish between errors HIDP_USAGE_NOT_FOUND and
                  // HIDP_BUFFER_TOO_SMALL
                  //
                  noArraySpace = TRUE;
                  continue;
               }

               inspect = HidP_Usage2Index (firstChannel, Usage);
               if (!inspect) {
                  //
                  // Gads!  We should NEVER get here!
                  // We already know that the given usage falls into the
                  // current channel, so it should translate into an index.
                  //
                  return HIDP_STATUS_INTERNAL_ERROR;
               }

               HidP_InsertData (
                   (USHORT) ((reportBitIndex >> 3) + channel->ByteOffset),
                   (USHORT) (reportBitIndex & 7),
                   channel->ReportSize,
                   Report,
                   inspect);
               return HIDP_STATUS_SUCCESS;
            }
            // If we got to this point then there was no room to add this
            // usage into the given array.  However there might be another
            // array later into which the given usage might fit.  Let's continue
            // looking.

            while (channel->MoreChannels) {
               // Skip by all the additional channels that describe this
               // same data field.
               channelIndex++;
               channel = (PreparsedData->Data + channelIndex);
            }
            priChannel = channel;

         } else { // Set a Usage Array

             inspect = HidP_Usage2Index (firstChannel, Usage);

             reportBitIndex += channel->ByteOffset << 3;
             status = HidP_DeleteArrayEntry (reportBitIndex,
                                             channel->ReportSize,
                                             channel->ReportCount,
                                             inspect,
                                             Report);

             if (HIDP_STATUS_BUTTON_NOT_PRESSED == status) {
                 notPressed = TRUE;
                 continue;
             }

             if (NT_SUCCESS (status)) {
                 return status;
             } else {
                 ASSERT (0 == status);
             }
         }  // end byte aray
      }
   }
   if (wrongReportID) {
      return HIDP_STATUS_INCOMPATIBLE_REPORT_ID;
   }
   if (notPressed) {
       return HIDP_STATUS_BUTTON_NOT_PRESSED;
   }
   if (noArraySpace) {
      return HIDP_STATUS_BUFFER_TOO_SMALL;
   }
   return HIDP_STATUS_USAGE_NOT_FOUND;
}

NTSTATUS __stdcall
HidP_GetUsagesEx (
    IN       HIDP_REPORT_TYPE     ReportType,
    IN       USHORT               LinkCollection, // Optional
    OUT      PUSAGE_AND_PAGE      ButtonList,
    IN OUT   ULONG *              UsageLength,
    IN       PHIDP_PREPARSED_DATA PreparsedData,
    IN       PCHAR                Report,
    IN       ULONG                ReportLength
    )
/*++
Routine Description:
    Please see hidpi.h for description.

--*/
{
    return HidP_GetUsages (ReportType,
                           0,
                           LinkCollection,
                           (PUSAGE) ButtonList,
                           UsageLength,
                           PreparsedData,
                           Report,
                           ReportLength);
}

NTSTATUS __stdcall
HidP_GetUsages (
   IN       HIDP_REPORT_TYPE     ReportType,
   IN       USAGE                UsagePage,
   IN       USHORT               LinkCollection,
   OUT      USAGE *              UsageList,
   IN OUT   ULONG *              UsageLength,
   IN       PHIDP_PREPARSED_DATA PreparsedData,
   IN       PCHAR                Report,
   IN       ULONG                ReportLength
   )
/*++

Routine Description:
   Please see hidpi.h for description.

Notes:
--*/
{
    struct _CHANNEL_REPORT_HEADER * iof;
    PHIDP_CHANNEL_DESC  channel;
    USHORT              channelIndex   = 0;
    USHORT              usageListIndex = 0;
    USHORT              reportBitIndex = 0;
    USHORT              tmpBitIndex;
    NTSTATUS            status         = HIDP_STATUS_SUCCESS;
    ULONG               data           = 0;
    USHORT              inspect        = 0;
    BOOLEAN             wrongReportID  = FALSE;
    BOOLEAN             found          = FALSE;
    PUSAGE_AND_PAGE     usageAndPage   = (PUSAGE_AND_PAGE) UsageList;

    CHECK_PPD (PreparsedData);

    memset (UsageList, '\0', *UsageLength * sizeof (USAGE));

    switch (ReportType) {
    case HidP_Input:
        iof = &PreparsedData->Input;
        break;
    case HidP_Output:
        iof = &PreparsedData->Output;
        break;
    case HidP_Feature:
        iof = &PreparsedData->Feature;
        break;
    default:
        return HIDP_STATUS_INVALID_REPORT_TYPE;
    }

    if ((USHORT) ReportLength != iof->ByteLen) {
        return HIDP_STATUS_INVALID_REPORT_LENGTH;
    }

    if (0 == iof->ByteLen) {
        return HIDP_STATUS_REPORT_DOES_NOT_EXIST;
    }

    for (channelIndex = iof->Offset; channelIndex < iof->Index; channelIndex++){
        channel = (PreparsedData->Data + channelIndex);
        if ((!channel->IsButton) ||
            ((UsagePage) && (channel->UsagePage != UsagePage))) {

            continue;
        }

        //
        // If LinkCollection is zero we will not filter by link collections
        // If channel->LinkCollection is zero this is the root collection.
        // Therefore if LinkCollection == channel->LinkCollection then this is OK
        //
        if ((!LinkCollection) ||
            (LinkCollection == channel->LinkCollection) ||
            ((HIDP_LINK_COLLECTION_ROOT == LinkCollection) &&
             (0 == channel->LinkCollection))) {
            ;

        } else {
            continue;
        }

        // Test the report ID to see if it is compatible.
        if ((0 != Report[0]) && (channel->ReportID != (UCHAR) Report[0])) {
            // Distinguish between the errors HIDP_USAGE_NOT_FOUND and
            // HIDP_INCOMPATIBLE_REPORT_ID.
            wrongReportID = TRUE;
            continue;
        }

        found = TRUE;

        if (1 == channel->ReportSize) {
            // A bitfield
            //
            // Little endian (by bit)
            // Byte 2  |Byte 1 |Byte 0
            // 765432107654321076543210  (bits)
            //
            // Get low byte first.  (need the higher bits)
            // Offset is from bit zero.
            //

            for (reportBitIndex = channel->BitOffset;
                 reportBitIndex < (channel->BitLength + channel->BitOffset);
                 reportBitIndex++) {
                 // Check it one bit at a time.
                tmpBitIndex = reportBitIndex + (channel->ByteOffset << 3);
                inspect = Report [tmpBitIndex >> 3] & (1 << (tmpBitIndex & 7));
                tmpBitIndex = reportBitIndex - channel->BitOffset;
                if (inspect) {
                    if (channel->IsRange) {
                        inspect = channel->Range.UsageMin + tmpBitIndex;
                    } else {
                        inspect = channel->NotRange.Usage;
                    }

                    if (usageListIndex < *UsageLength) {
                        if (0 == UsagePage) {
                            usageAndPage[usageListIndex].UsagePage
                                = channel->UsagePage;
                            usageAndPage[usageListIndex].Usage = inspect;
                        } else {
                            UsageList[usageListIndex] = inspect;
                        }
                    }
                    usageListIndex++;
                }
            }
            continue;
        }

        for (reportBitIndex = channel->BitOffset;
             reportBitIndex < (channel->BitOffset + channel->BitLength);
             reportBitIndex += channel->ReportSize) {
             // an array of usages.
            data = HidP_ExtractData (
                     (USHORT) ((reportBitIndex >> 3) + channel->ByteOffset),
                     (USHORT) (reportBitIndex & 7),
                     channel->ReportSize,
                     Report);

            if (data) {
                inspect = HidP_Index2Usage (channel, data);
                if (!inspect) {
                    // We found an invalid index.  I'm not quite sure what
                    // we should do with it.  But lets just ignore it since
                    // we cannot convert it into a real usage.
                    continue;
                }
                if (usageListIndex < *UsageLength) {
                    if (0 == UsagePage) {
                        usageAndPage[usageListIndex].UsagePage
                            = channel->UsagePage;
                        usageAndPage[usageListIndex].Usage = inspect;
                    } else {
                        UsageList[usageListIndex] = inspect;
                    }
                }
                usageListIndex++;
            }
        }

        while (channel->MoreChannels) {
            // Skip by all the additional channels that describe this
            // same data field.
            channelIndex++;
            channel = (PreparsedData->Data + channelIndex);
        }

    } // end for channel

    if (*UsageLength < usageListIndex) {
        status = HIDP_STATUS_BUFFER_TOO_SMALL;
    }

    *UsageLength = usageListIndex;
    if (!found) {
        if (wrongReportID) {
            status = HIDP_STATUS_INCOMPATIBLE_REPORT_ID;
        } else {
            status = HIDP_STATUS_USAGE_NOT_FOUND;
        }
    }

    return status;
}

ULONG __stdcall
HidP_MaxUsageListLength (
   IN HIDP_REPORT_TYPE      ReportType,
   IN USAGE                 UsagePage,
   IN PHIDP_PREPARSED_DATA  PreparsedData
   )
/*++
Routine Description:
   Please see hidpi.h for description.

Notes:
--*/
{
    struct _CHANNEL_REPORT_HEADER * iof;
    PHIDP_CHANNEL_DESC  channel;
    USHORT              channelIndex   = 0;
    ULONG               len = 0;

    PAGED_CODE ();

    if ((HIDP_PREPARSED_DATA_SIGNATURE1 != PreparsedData->Signature1) &&
        (HIDP_PREPARSED_DATA_SIGNATURE2 != PreparsedData->Signature2)) {
        return 0;
    }


    switch (ReportType) {
    case HidP_Input:
        iof = &PreparsedData->Input;
        break;
    case HidP_Output:
        iof = &PreparsedData->Output;
        break;
    case HidP_Feature:
        iof = &PreparsedData->Feature;
        break;
    default:
        return 0;
    }

    for (channelIndex = iof->Offset; channelIndex < iof->Index; channelIndex++){
        channel = (PreparsedData->Data + channelIndex);
        if (channel->IsButton &&
            ((!UsagePage) || (channel->UsagePage == UsagePage))) {

            // How many buttons can show up in this device?
            // If this is a bitmap then the max number of buttons is the length
            // aka the count, if this is an array then the max number of buttons
            // is the number of array positions aka the count.
            len += channel->ReportCount;
        }
    }
    return len;
}

ULONG __stdcall
HidP_MaxDataListLength (
   IN HIDP_REPORT_TYPE      ReportType,
   IN PHIDP_PREPARSED_DATA  PreparsedData
   )
/*++
Routine Description:
   Please see hidpi.h for description.

Notes:
--*/
{
    struct _CHANNEL_REPORT_HEADER * iof;
    PHIDP_CHANNEL_DESC  channel;
    USHORT              channelIndex   = 0;
    ULONG               len = 0;

    PAGED_CODE ();

    if ((HIDP_PREPARSED_DATA_SIGNATURE1 != PreparsedData->Signature1) &&
        (HIDP_PREPARSED_DATA_SIGNATURE2 != PreparsedData->Signature2)) {
        return 0;
    }


    switch (ReportType) {
    case HidP_Input:
        iof = &PreparsedData->Input;
        break;
    case HidP_Output:
        iof = &PreparsedData->Output;
        break;
    case HidP_Feature:
        iof = &PreparsedData->Feature;
        break;
    default:
        return 0;
    }

    for (channelIndex = iof->Offset; channelIndex < iof->Index; channelIndex++){
        channel = (PreparsedData->Data + channelIndex);

        if (channel->IsButton) {
            // How many buttons can show up in this device?
            // If this is a bitmap then the max number of buttons is the length
            // aka the count, if this is an array then the max number of buttons
            // is the number of array positions aka the count.
            len += channel->ReportCount;
        } else if (channel->IsRange) {
            len += channel->ReportCount;
        } else {
            len += 1;
        }
    }
    return len;
}


NTSTATUS __stdcall
HidP_SetUsageValue (
   IN       HIDP_REPORT_TYPE     ReportType,
   IN       USAGE                UsagePage,
   IN       USHORT               LinkCollection, // Optional
   IN       USAGE                Usage,
   IN       ULONG                UsageValue,
   IN       PHIDP_PREPARSED_DATA PreparsedData,
   IN OUT   PCHAR                Report,
   IN       ULONG                ReportLength
   )
/*++
Routine Description:
   Please see hidpi.h for description

Notes:

--*/
{
   struct _CHANNEL_REPORT_HEADER * iof;
   PHIDP_CHANNEL_DESC              channel;
   ULONG     channelIndex    = 0;
   ULONG     reportBitIndex  = 0;
   NTSTATUS  status          = HIDP_STATUS_SUCCESS;
   BOOLEAN   wrongReportID   = FALSE;




   CHECK_PPD (PreparsedData);

   switch (ReportType) {
   case HidP_Input:
      iof = &PreparsedData->Input;
      break;
   case HidP_Output:
      iof = &PreparsedData->Output;
      break;
   case HidP_Feature:
      iof = &PreparsedData->Feature;
      break;
   default:
      return HIDP_STATUS_INVALID_REPORT_TYPE;
   }

   if ((USHORT) ReportLength != iof->ByteLen) {
      return HIDP_STATUS_INVALID_REPORT_LENGTH;
   }

   if (0 == iof->ByteLen) {
       return HIDP_STATUS_REPORT_DOES_NOT_EXIST;
   }

   for (channelIndex = iof->Offset; channelIndex < iof->Index; channelIndex++) {
      channel = (PreparsedData->Data + channelIndex);

      if ((channel->IsButton) ||
          (channel->UsagePage != UsagePage)) {
          continue;
      }

      //
      // If LinkCollection is zero we will not filter by link collections
      // If channel->LinkCollection is zero this is the root collection.
      // Therefore if LinkCollection == channel->LinkCollection then this is OK
      //
      if ((!LinkCollection) ||
          (LinkCollection == channel->LinkCollection) ||
          ((HIDP_LINK_COLLECTION_ROOT == LinkCollection) &&
           (0 == channel->LinkCollection))) {
          ;

      } else {
          continue;
      }

      if (channel->IsRange) {
         if ((channel->Range.UsageMin <= Usage) &&
             (Usage <= channel->Range.UsageMax)) {

            reportBitIndex = (channel->ByteOffset << 3)
                           + channel->BitOffset
                           + (  (Usage - channel->Range.UsageMin)
                              * channel->ReportSize);
         } else {
            continue;
         }
      } else {
         if (channel->NotRange.Usage == Usage) {
            reportBitIndex = (channel->ByteOffset << 3)
                           + channel->BitOffset;
         } else {
            continue;
         }
      }
      // Test the report ID to see if it is compatible.
      if ((0 != Report[0]) && (channel->ReportID != (UCHAR) Report[0])) {
         // Distinguish between the errors HIDP_USAGE_NOT_FOUND and
         // HIDP_INCOMPATIBLE_REPORT_ID.
         wrongReportID = TRUE;
         continue;
      }
      Report[0] = (CHAR) channel->ReportID;
      // Set the report ID for this report


      HidP_InsertData ((USHORT) (reportBitIndex >> 3),
                    (USHORT) (reportBitIndex & 7),
                    channel->ReportSize,
                    Report,
                    UsageValue);

      return HIDP_STATUS_SUCCESS;
   }
   if (wrongReportID) {
      return HIDP_STATUS_INCOMPATIBLE_REPORT_ID;
   }
   return HIDP_STATUS_USAGE_NOT_FOUND;
}


NTSTATUS __stdcall
HidP_SetUsageValueArray (
    IN    HIDP_REPORT_TYPE     ReportType,
    IN    USAGE                UsagePage,
    IN    USHORT               LinkCollection, // Optional
    IN    USAGE                Usage,
    OUT   PCHAR                UsageValue,
    IN    USHORT               UsageValueByteLength,
    IN    PHIDP_PREPARSED_DATA PreparsedData,
    IN    PCHAR                Report,
    IN    ULONG                ReportLength
    )
/*++
Routine Description:
   Please see hidpi.h for description

Notes:

--*/
{
    struct _CHANNEL_REPORT_HEADER * iof;
    PHIDP_CHANNEL_DESC              channel;
    ULONG       channelIndex    = 0;
    ULONG       reportBitIndex;
    ULONG       i,j;
    NTSTATUS    status          = HIDP_STATUS_SUCCESS;
    BOOLEAN     wrongReportID   = FALSE;

    CHECK_PPD (PreparsedData);

    switch (ReportType) {
    case HidP_Input:
        iof = &PreparsedData->Input;
        break;
    case HidP_Output:
        iof = &PreparsedData->Output;
        break;
    case HidP_Feature:
        iof = &PreparsedData->Feature;
        break;
    default:
        return HIDP_STATUS_INVALID_REPORT_TYPE;
    }

    if ((USHORT) ReportLength != iof->ByteLen) {
        return HIDP_STATUS_INVALID_REPORT_LENGTH;
    }

    if (0 == iof->ByteLen) {
        return HIDP_STATUS_REPORT_DOES_NOT_EXIST;
    }

    for (channelIndex = iof->Offset; channelIndex < iof->Index; channelIndex++){
        channel = (PreparsedData->Data + channelIndex);

        if ((channel->IsButton) ||
            (channel->UsagePage != UsagePage)) {
            continue;
        }

        //
        // If LinkCollection is zero we will not filter by link collections
        // If channel->LinkCollection is zero this is the root collection.
        // Therefore if LinkCollection == channel->LinkCollection then this is OK
        //
        if ((!LinkCollection) ||
            (LinkCollection == channel->LinkCollection) ||
            ((HIDP_LINK_COLLECTION_ROOT == LinkCollection) &&
             (0 == channel->LinkCollection))) {
            ;

        } else {
            continue;
        }

        if (channel->IsRange) {
            if ((channel->Range.UsageMin <= Usage) &&
                (Usage <= channel->Range.UsageMax)) {
                return HIDP_STATUS_NOT_VALUE_ARRAY;
            } else {
                continue;
            }
        } else {
            if (channel->NotRange.Usage == Usage) {
                if (1 == channel->ReportCount) {
                    return HIDP_STATUS_NOT_VALUE_ARRAY;
                }
                reportBitIndex =(channel->ByteOffset << 3) + channel->BitOffset;
            } else {
                continue;
            }
        }

        // Test the report ID to see if it is compatible.
        if ((0 != Report[0]) && (channel->ReportID != (UCHAR) Report[0])) {
            // Distinguish between the errors HIDP_USAGE_NOT_FOUND and
            // HIDP_INCOMPATIBLE_REPORT_ID.
            wrongReportID = TRUE;
            continue;
        }
        Report[0] = (CHAR) channel->ReportID;
        // Set the report ID for this report

        if ((UsageValueByteLength * 8) <
            (channel->ReportCount * channel->ReportSize)) {
            return HIDP_STATUS_BUFFER_TOO_SMALL;
        }

        if (0 == (channel->ReportSize % 8)) {
            //
            // set the data the easy way: one byte at a time.
            //
            for (i = 0; i < channel->ReportCount; i++) {
                for (j = 0; j < (UCHAR) (channel->ReportSize / 8); j++) {
                    HidP_InsertData ((USHORT) (reportBitIndex >> 3),
                                  (USHORT) (reportBitIndex & 7),
                                  8,
                                  Report,
                                  *UsageValue);
                    reportBitIndex += 8;
                    UsageValue++;
                }
            }
        } else {
            //
            // Do it the hard way: one bit at a time.
            //
            return HIDP_STATUS_NOT_IMPLEMENTED;
        }

        return HIDP_STATUS_SUCCESS;
    }
    if (wrongReportID) {
        return HIDP_STATUS_INCOMPATIBLE_REPORT_ID;
    }
    return HIDP_STATUS_USAGE_NOT_FOUND;
}


NTSTATUS __stdcall
HidP_SetScaledUsageValue (
   IN       HIDP_REPORT_TYPE     ReportType,
   IN       USAGE                UsagePage,
   IN       USHORT               LinkCollection, // Optional
   IN       USAGE                Usage,
   IN       LONG                 UsageValue,
   IN       PHIDP_PREPARSED_DATA PreparsedData,
   IN OUT   PCHAR                Report,
   IN       ULONG                ReportLength
   )
/*++
Routine Description:
   Please see hidpi.h for description

Notes:

--*/
{
   struct _CHANNEL_REPORT_HEADER * iof;
   PHIDP_CHANNEL_DESC              channel;
   ULONG     channelIndex    = 0;
   ULONG     reportBitIndex  = 0;
   NTSTATUS  status          = HIDP_STATUS_USAGE_NOT_FOUND;
   LONG      logicalMin, logicalMax;
   LONG      physicalMin, physicalMax;
   LONG      value;
   BOOLEAN   wrongReportID   = FALSE;

   CHECK_PPD (PreparsedData);

   switch (ReportType) {
   case HidP_Input:
      iof = &PreparsedData->Input;
      break;
   case HidP_Output:
      iof = &PreparsedData->Output;
      break;
   case HidP_Feature:
      iof = &PreparsedData->Feature;
      break;
   default:
      return HIDP_STATUS_INVALID_REPORT_TYPE;
   }

   if ((USHORT) ReportLength != iof->ByteLen) {
      return HIDP_STATUS_INVALID_REPORT_LENGTH;
   }

   if (0 == iof->ByteLen) {
       return HIDP_STATUS_REPORT_DOES_NOT_EXIST;
   }

   for (channelIndex = iof->Offset; channelIndex < iof->Index; channelIndex++) {
      channel = (PreparsedData->Data + channelIndex);

      if ((channel->IsButton) ||
          (channel->UsagePage != UsagePage)) {
          continue;
      }

      //
      // If LinkCollection is zero we will not filter by link collections
      // If channel->LinkCollection is zero this is the root collection.
      // Therefore if LinkCollection == channel->LinkCollection then this is OK
      //
      if ((!LinkCollection) ||
          (LinkCollection == channel->LinkCollection) ||
          ((HIDP_LINK_COLLECTION_ROOT == LinkCollection) &&
           (0 == channel->LinkCollection))) {
          ;

      } else {
          continue;
      }

      if (channel->IsRange) {
         if ((channel->Range.UsageMin <= Usage) &&
             (Usage <= channel->Range.UsageMax)) {

             reportBitIndex = (channel->ByteOffset << 3)
                           + channel->BitOffset
                           + (  (Usage - channel->Range.UsageMin)
                              * channel->ReportSize);
         } else {
            continue;
         }
      } else {
         if (channel->NotRange.Usage == Usage) {
            reportBitIndex = (channel->ByteOffset << 3)
                           + channel->BitOffset;
         } else {
            continue;
         }
      }
      // Test the report ID to see if it is compatible.
      if ((0 != Report[0]) && (channel->ReportID != (UCHAR) Report[0])) {
         // Distinguish between the errors HIDP_USAGE_NOT_FOUND and
         // HIDP_INCOMPATIBLE_REPORT_ID.
         wrongReportID = TRUE;
         continue;
      }
      Report[0] = (CHAR) channel->ReportID;
      // Set the report ID for this report

      logicalMin = channel->Data.LogicalMin;
      logicalMax = channel->Data.LogicalMax;
      physicalMin = channel->Data.PhysicalMin;
      physicalMax = channel->Data.PhysicalMax;

      //
      // The code path here is ALWAYS the same, we should test it once
      // and then use some sort of switch statement to do the calculation.
      //

      if ((0 == physicalMin) &&
          (0 == physicalMax) &&
          (logicalMin != logicalMax)) {
          //
          // The device did not set the physical min and max values
          //
          if ((logicalMin <= UsageValue) && (UsageValue <= logicalMax)) {
              value = UsageValue;

              //
              // fix the sign bit
              // I should store away the sign bit somewhere so I don't
              // have to calculate it all the time.
              //
              if (value & 0x80000000) {
                  value |= (1 << (channel->ReportSize - 1));
              } else {
                  value &= ((1 << (channel->ReportSize - 1)) - 1);
              }
          } else {
              if (channel->Data.HasNull) {
                  value = (1 << (channel->ReportSize - 1));// Most negitive value
                  status = HIDP_STATUS_NULL;
              } else {
                  return HIDP_STATUS_VALUE_OUT_OF_RANGE;
              }
          }


      } else {
          //
          // The device has physical descriptors.
          //

          if ((logicalMax <= logicalMin) || (physicalMax <= physicalMin)) {
              return HIDP_STATUS_BAD_LOG_PHY_VALUES;
          }

          if ((physicalMin <= UsageValue) && (UsageValue <= physicalMax)) {
              value = logicalMin + ((UsageValue - physicalMin) *
                                    (logicalMax - logicalMin + 1) /
                                    (physicalMax - physicalMin + 1));
          } else {
              if (channel->Data.HasNull) {
                  value = (1 << (channel->ReportSize - 1));// Most negitive value
                  status = HIDP_STATUS_NULL;
              } else {
                  return HIDP_STATUS_VALUE_OUT_OF_RANGE;
              }
          }
      }
      HidP_InsertData ((USHORT) (reportBitIndex >> 3),
                       (USHORT) (reportBitIndex & 7),
                       channel->ReportSize,
                       Report,
                       (ULONG) value);

      return HIDP_STATUS_SUCCESS;
   }
   if (wrongReportID) {
      return HIDP_STATUS_INCOMPATIBLE_REPORT_ID;
   }
   return status;
}



NTSTATUS __stdcall
HidP_GetUsageValue (
   IN       HIDP_REPORT_TYPE     ReportType,
   IN       USAGE                UsagePage,
   IN       USHORT               LinkCollection, // Optional
   IN       USAGE                Usage,
   OUT      PULONG               UsageValue,
   IN       PHIDP_PREPARSED_DATA PreparsedData,
   IN       PCHAR                Report,
   IN       ULONG                ReportLength
   )
/*++
Routine Description:
   Please see hidpi.h for description

Notes:

--*/
{
   struct _CHANNEL_REPORT_HEADER * iof;
   PHIDP_CHANNEL_DESC              channel;
   ULONG     channelIndex    = 0;
   ULONG     reportBitIndex  = 0;
   ULONG     reportByteIndex = 0;
   NTSTATUS  status          = HIDP_STATUS_SUCCESS;
   ULONG     inspect         = 0;
   BOOLEAN   wrongReportID   = FALSE;

   CHECK_PPD (PreparsedData);

   switch (ReportType)
   {
   case HidP_Input:
      iof = &PreparsedData->Input;
      break;
   case HidP_Output:
      iof = &PreparsedData->Output;
      break;
   case HidP_Feature:
      iof = &PreparsedData->Feature;
      break;
   default:
      return HIDP_STATUS_INVALID_REPORT_TYPE;
   }

   if ((USHORT) ReportLength != iof->ByteLen) {
       return HIDP_STATUS_INVALID_REPORT_LENGTH;
   }

   if (0 == iof->ByteLen) {
       return HIDP_STATUS_REPORT_DOES_NOT_EXIST;
   }

   for (channelIndex = iof->Offset; channelIndex < iof->Index; channelIndex++)
   {
      channel = (PreparsedData->Data + channelIndex);

      if ((channel->IsButton) ||
          (channel->UsagePage != UsagePage)) {
          continue;
      }

      //
      // If LinkCollection is zero we will not filter by link collections
      // If channel->LinkCollection is zero this is the root collection.
      // Therefore if LinkCollection == channel->LinkCollection then this is OK
      //
      if ((!LinkCollection) ||
          (LinkCollection == channel->LinkCollection) ||
          ((HIDP_LINK_COLLECTION_ROOT == LinkCollection) &&
           (0 == channel->LinkCollection))) {
          ;

      } else {
          continue;
      }

      if (channel->IsRange) {

         if ((channel->Range.UsageMin <= Usage) &&
             (Usage <= channel->Range.UsageMax))
         {
            reportBitIndex = (channel->ByteOffset << 3)
                           + channel->BitOffset
                           + (  (Usage - channel->Range.UsageMin)
                              * channel->ReportSize);
         } else
         {
            continue;
         }
      } else
      {
         if (channel->NotRange.Usage == Usage)
         {
            reportBitIndex = (channel->ByteOffset << 3)
                           + channel->BitOffset;
         } else
         {
            continue;
         }
      }

      // Test the report ID to see if it is compatible.
      if ((0 != Report[0]) && (channel->ReportID != (UCHAR) Report[0])) {
         // Distinguish between the errors HIDP_USAGE_NOT_FOUND and
         // HIDP_INCOMPATIBLE_REPORT_ID.
         wrongReportID = TRUE;
         continue;
      }

      inspect = HidP_ExtractData ((USHORT) (reportBitIndex >> 3),
                              (USHORT) (reportBitIndex & 7),
                              channel->ReportSize,
                              Report);

      *UsageValue = inspect;
      return HIDP_STATUS_SUCCESS;
   }
   if (wrongReportID) {
      return HIDP_STATUS_INCOMPATIBLE_REPORT_ID;
   }
   return HIDP_STATUS_USAGE_NOT_FOUND;
}


NTSTATUS __stdcall
HidP_GetUsageValueArray (
    IN    HIDP_REPORT_TYPE     ReportType,
    IN    USAGE                UsagePage,
    IN    USHORT               LinkCollection, // Optional
    IN    USAGE                Usage,
    OUT   PCHAR                UsageValue,
    IN    USHORT               UsageValueByteLength,
    IN    PHIDP_PREPARSED_DATA PreparsedData,
    IN    PCHAR                Report,
    IN    ULONG                ReportLength
    )
/*++
Routine Description:
   Please see hidpi.h for description

Notes:

--*/
{
    struct _CHANNEL_REPORT_HEADER * iof;
    PHIDP_CHANNEL_DESC              channel;
    ULONG       channelIndex    = 0;
    ULONG       reportBitIndex;
    ULONG       i,j;
    NTSTATUS    status          = HIDP_STATUS_SUCCESS;
    ULONG       inspect         = 0;
    BOOLEAN     wrongReportID   = FALSE;

    CHECK_PPD (PreparsedData);

    switch (ReportType) {
    case HidP_Input:
        iof = &PreparsedData->Input;
        break;
    case HidP_Output:
        iof = &PreparsedData->Output;
        break;
    case HidP_Feature:
        iof = &PreparsedData->Feature;
        break;
    default:
        return HIDP_STATUS_INVALID_REPORT_TYPE;
    }

    if ((USHORT) ReportLength != iof->ByteLen) {
        return HIDP_STATUS_INVALID_REPORT_LENGTH;
    }

    if (0 == iof->ByteLen) {
        return HIDP_STATUS_REPORT_DOES_NOT_EXIST;
    }

    for (channelIndex = iof->Offset; channelIndex < iof->Index; channelIndex++){
        channel = (PreparsedData->Data + channelIndex);

        if ((channel->IsButton) ||
            (channel->UsagePage != UsagePage)) {
            continue;
        }

        //
        // If LinkCollection is zero we will not filter by link collections
        // If channel->LinkCollection is zero this is the root collection.
        // Therefore if LinkCollection == channel->LinkCollection then this is OK
        //
        if ((!LinkCollection) ||
            (LinkCollection == channel->LinkCollection) ||
            ((HIDP_LINK_COLLECTION_ROOT == LinkCollection) &&
             (0 == channel->LinkCollection))) {
            ;

        } else {
            continue;
        }

        if (channel->IsRange) {
            if ((channel->Range.UsageMin <= Usage) &&
                (Usage <= channel->Range.UsageMax)) {

                return HIDP_STATUS_NOT_VALUE_ARRAY;
            } else {
                continue;
            }
        } else {
            if (channel->NotRange.Usage == Usage) {
                if (1 == channel->ReportCount) {
                    return HIDP_STATUS_NOT_VALUE_ARRAY;
                }
                reportBitIndex =(channel->ByteOffset << 3) + channel->BitOffset;
            } else {
                continue;
            }
        }

        // Test the report ID to see if it is compatible.
        if ((0 != Report[0]) && (channel->ReportID != (UCHAR) Report[0])) {
            // Distinguish between the errors HIDP_USAGE_NOT_FOUND and
            // HIDP_INCOMPATIBLE_REPORT_ID.
            wrongReportID = TRUE;
            continue;
        }

        if ((UsageValueByteLength * 8) <
            (channel->ReportCount * channel->ReportSize)) {
            return HIDP_STATUS_BUFFER_TOO_SMALL;
        }

        if (0 == (channel->ReportSize % 8)) {
            //
            // Retrieve the data the easy way
            //
            for (i = 0; i < channel->ReportCount; i++) {
                for (j = 0; j < (USHORT) (channel->ReportSize / 8); j++) {
                    *UsageValue = (CHAR) HidP_ExtractData (
                                                (USHORT) (reportBitIndex >> 3),
                                                (USHORT) (reportBitIndex & 7),
                                                8,
                                                Report);
                    reportBitIndex += 8;
                    UsageValue++;
                }
            }
        } else {
            //
            // Do it the hard way
            //
            return HIDP_STATUS_NOT_IMPLEMENTED;
        }

        return HIDP_STATUS_SUCCESS;
    }
    if (wrongReportID) {
        return HIDP_STATUS_INCOMPATIBLE_REPORT_ID;
    }
    return HIDP_STATUS_USAGE_NOT_FOUND;
}


NTSTATUS __stdcall
HidP_GetScaledUsageValue (
   IN       HIDP_REPORT_TYPE     ReportType,
   IN       USAGE                UsagePage,
   IN       USHORT               LinkCollection, // Optional
   IN       USAGE                Usage,
   OUT      PLONG                UsageValue,
   IN       PHIDP_PREPARSED_DATA PreparsedData,
   IN       PCHAR                Report,
   IN       ULONG                ReportLength
   )
/*++
Routine Description:
   Please see hidpi.h for description

Notes:

--*/
{
   struct _CHANNEL_REPORT_HEADER * iof;
   PHIDP_CHANNEL_DESC              channel;
   ULONG     channelIndex    = 0;
   ULONG     reportBitIndex  = 0;
   ULONG     reportByteIndex = 0;
   NTSTATUS  status          = HIDP_STATUS_SUCCESS;
   ULONG     inspect         = 0;
   LONG      logicalMin, logicalMax;
   LONG      physicalMin, physicalMax;
   LONG      value;
   BOOLEAN   wrongReportID   = FALSE;

   CHECK_PPD (PreparsedData);

   switch (ReportType) {
   case HidP_Input:
      iof = &PreparsedData->Input;
      break;
   case HidP_Output:
      iof = &PreparsedData->Output;
      break;
   case HidP_Feature:
      iof = &PreparsedData->Feature;
      break;
   default:
      return HIDP_STATUS_INVALID_REPORT_TYPE;
   }

   if ((USHORT) ReportLength != iof->ByteLen) {
      return HIDP_STATUS_INVALID_REPORT_LENGTH;
   }

   if (0 == iof->ByteLen) {
       return HIDP_STATUS_REPORT_DOES_NOT_EXIST;
   }

   for (channelIndex = iof->Offset; channelIndex < iof->Index; channelIndex++) {
      channel = (PreparsedData->Data + channelIndex);

      if ((channel->IsButton) ||
          (channel->UsagePage != UsagePage)) {
          continue;
      }

      //
      // If LinkCollection is zero we will not filter by link collections
      // If channel->LinkCollection is zero this is the root collection.
      // Therefore if LinkCollection == channel->LinkCollection then this is OK
      //
      if ((!LinkCollection) ||
          (LinkCollection == channel->LinkCollection) ||
          ((HIDP_LINK_COLLECTION_ROOT == LinkCollection) &&
           (0 == channel->LinkCollection))) {
          ;

      } else {
          continue;
      }

      if (channel->IsRange) {
         if ((channel->Range.UsageMin <= Usage) &&
             (Usage <= channel->Range.UsageMax)) {
            reportBitIndex = (channel->ByteOffset << 3)
                           + channel->BitOffset
                           + (  (Usage - channel->Range.UsageMin)
                              * channel->ReportSize);
         } else {
            continue;
         }
      } else {
         if (channel->NotRange.Usage == Usage) {
            reportBitIndex = (channel->ByteOffset << 3)
                           + channel->BitOffset;
         } else {
            continue;
         }
      }

      // Test the report ID to see if it is compatible.
      if ((0 != Report[0]) && (channel->ReportID != (UCHAR) Report[0])) {
         // Distinguish between the errors HIDP_USAGE_NOT_FOUND and
         // HIDP_INCOMPATIBLE_REPORT_ID.
         wrongReportID = TRUE;
         continue;
      }

      logicalMin = channel->Data.LogicalMin;
      logicalMax = channel->Data.LogicalMax;
      physicalMin = channel->Data.PhysicalMin;
      physicalMax = channel->Data.PhysicalMax;

      inspect = HidP_ExtractData ((USHORT) (reportBitIndex >> 3),
                              (USHORT) (reportBitIndex & 7),
                              channel->ReportSize,
                              Report);

      //
      // Sign extend the value;
      // Find the top most bit of the field.
      // (logical and with 1 shifted by bit length minus one)
      // based on that, set the upper most bits.
      //
      value = (LONG) (inspect | ((inspect & (1 << (channel->ReportSize - 1))) ?
                                 ((~(1 << (channel->ReportSize - 1))) + 1) :
                                 0));

      //
      // the code path here is ALWAYS the same, we should test it once
      // and then use some sort of switch statement to do the calculation.
      //

      if ((0 == physicalMin) &&
          (0 == physicalMax) &&
          (logicalMin != logicalMax)) {
          //
          // The Device did not set the physical Min and Max Values
          //
          *UsageValue = value;

      } else if ((logicalMax <= logicalMin) || (physicalMax <= physicalMin)) {
          *UsageValue = 0;
          return HIDP_STATUS_BAD_LOG_PHY_VALUES;

      } else {
          // the Min and Max are both inclusive.
          // The value is in range
          // *UsageValue = physicalMin + (((value - logicalMin) *
          //                               (physicalMax - physicalMin)) /
          //                              (logicalMax - logicalMin));
          // not enough accuracy.
          //
          *UsageValue = physicalMin
                      + (LONG)(((LONGLONG)(value - logicalMin) *
                                (LONGLONG)(physicalMax - physicalMin)) /
                               (LONGLONG)(logicalMax - logicalMin));
      }

      if ((logicalMin <= value) && (value <= logicalMax)) {
          return HIDP_STATUS_SUCCESS;

      } else {
          // The value is not in range
          *UsageValue = 0;

          if (channel->Data.HasNull) {
              return HIDP_STATUS_NULL;
          } else {
              return HIDP_STATUS_VALUE_OUT_OF_RANGE;
          }
      }

   }
   if (wrongReportID) {
      return HIDP_STATUS_INCOMPATIBLE_REPORT_ID;
   }
   return HIDP_STATUS_USAGE_NOT_FOUND;
}


NTSTATUS __stdcall
HidP_SetOneData (
   struct _CHANNEL_REPORT_HEADER * Iof,
   IN       PHIDP_DATA            Data,
   IN       PHIDP_PREPARSED_DATA  PreparsedData,
   IN OUT   PCHAR                 Report
   )
/*++
Routine Description:
   Please see hidpi.h for description

Notes:

--*/
{
    PHIDP_CHANNEL_DESC   channel;
    ULONG     inspect;
    NTSTATUS  status          = HIDP_STATUS_SUCCESS;
    USHORT    channelIndex    = 0;
    USHORT    dataListIndex   = 0;
    USHORT    reportBitIndex;
    BOOLEAN   wrongReportID   = FALSE;
    BOOLEAN   noArraySpace    = FALSE;
    BOOLEAN   notPressed      = FALSE;

    for (channelIndex = Iof->Offset; channelIndex < Iof->Index; channelIndex++){
        channel = (PreparsedData->Data + channelIndex);

        if ((channel->Range.DataIndexMin <= Data->DataIndex) &&
            (Data->DataIndex <= channel->Range.DataIndexMax)) {

            if ((!channel->IsRange) && (1 != channel->ReportCount)) {
                //
                // This value array.  We cannot access this here.
                //
                return HIDP_STATUS_IS_VALUE_ARRAY;
            }

            // Test the report ID to see if it is compatible.
            if (0 != Report[0]) {
                if (channel->ReportID != (UCHAR) Report[0]) {
                    wrongReportID = TRUE;
                    continue;
                }
            } else {
                Report[0] = (CHAR) channel->ReportID;
            }

            if (channel->IsButton) {

                if (1 == channel->ReportSize) {
                    // A bitfield
                    //
                    // Little endian (by bit)
                    // Byte 2  |Byte 1 |Byte 0
                    // 765432107654321076543210  (bits)
                    //
                    // Get low byte first.  (need the higher bits)
                    // Offset is from bit zero.
                    //
                    reportBitIndex = (channel->ByteOffset << 3)
                                   + channel->BitOffset
                                   + (USHORT) (Data->DataIndex -
                                               channel->Range.DataIndexMin);

                    if (Data->On) {
                        Report [reportBitIndex >> 3] |= (1 << (reportBitIndex & 7));
                    } else if (Report [reportBitIndex >> 3] &
                               (1 << (reportBitIndex & 7))) {

                        Report [reportBitIndex >> 3] &= ~(1 << (reportBitIndex & 7));
                    } else {
                        return HIDP_STATUS_BUTTON_NOT_PRESSED;
                    }

                    return HIDP_STATUS_SUCCESS;
                }

                //
                // Not a bit field
                // an array of usages then.
                //

                //
                // Are we clearing a usage from this array?
                //
                if (FALSE == Data->On) {
                    //
                    // NB Wizard Time (tm)
                    //
                    // We know that data indices are assigned consecutively
                    // for every control, and that the array channels
                    // are reversed in the channel array.
                    //
                    // inspect is the index (1 based not zero based) into the
                    // channel array.
                    //
                    // Skip to the last channel that describes this same data
                    // fild;
                    //
                    while (channel->MoreChannels) {
                        channelIndex++;
                        channel++;
                    }
                    inspect = Data->DataIndex - channel->Range.DataIndexMin + 1;

                    if (0 == channel->Range.UsageMin) {
                        inspect--;
                    }

                    // Clear the value of inspect which is the usage translated
                    // to the index in the array.

                    reportBitIndex = channel->BitOffset
                                   + (channel->ByteOffset << 3);

                    status = HidP_DeleteArrayEntry (reportBitIndex,
                                                    channel->ReportSize,
                                                    channel->ReportCount,
                                                    inspect,
                                                    Report);

                    if (HIDP_STATUS_BUTTON_NOT_PRESSED == status) {
                        notPressed = TRUE;
                        continue;
                    }

                    if (NT_SUCCESS (status)) {
                        return status;
                    } else {
                        ASSERT (0 == status);
                    }
                }

                //
                // We are clearly setting a usage into an array.
                //
                for (reportBitIndex = channel->BitOffset;
                     reportBitIndex < (channel->BitOffset + channel->BitLength);
                     reportBitIndex += channel->ReportSize) {
                    // Search for an empty entry in this array

                    inspect = (USHORT) HidP_ExtractData (
                        (USHORT) ((reportBitIndex >> 3) + channel->ByteOffset),
                        (USHORT) (reportBitIndex & 7),
                        channel->ReportSize,
                        Report);

                    if (inspect) {
                        //
                        // Distinguish between errors HIDP_INDEX_NOT_FOUND and
                        // HIDP_BUFFER_TOO_SMALL
                        //
                        noArraySpace = TRUE;
                        continue;
                    }

                    //
                    // NB Wizard Time (tm)
                    //
                    // We know that data indices are assigned consecutively
                    // for every control, and that the array channels
                    // are reversed in the channel array.
                    //
                    // inspect is the index (1 based not zero based) into the
                    // channel array.
                    //
                    // Skip to the last channel that describes this same data
                    // fild;
                    //
                    while (channel->MoreChannels) {
                        channelIndex++;
                        channel++;
                    }
                    inspect = Data->DataIndex - channel->Range.DataIndexMin + 1;

                    if (0 == channel->Range.UsageMin) {
                        inspect--;
                    }

                    HidP_InsertData (
                        (USHORT) ((reportBitIndex >> 3) + channel->ByteOffset),
                        (USHORT) (reportBitIndex & 7),
                        channel->ReportSize,
                        Report,
                        inspect);
                    return HIDP_STATUS_SUCCESS;
                } // end of search for entry

                continue;
            }

            //
            // Not a button therefore a value.
            //

            reportBitIndex = (channel->ByteOffset << 3)
                           + channel->BitOffset
                           + (  (Data->DataIndex - channel->Range.DataIndexMin)
                              * channel->ReportSize);

            HidP_InsertData ((USHORT) (reportBitIndex >> 3),
                             (USHORT) (reportBitIndex & 7),
                             channel->ReportSize,
                             Report,
                             Data->RawValue);

            return HIDP_STATUS_SUCCESS;

        } // end matched data index
    } // end for loop

    if (wrongReportID) {
        return HIDP_STATUS_INCOMPATIBLE_REPORT_ID;
    }
    if (notPressed) {
        return HIDP_STATUS_BUTTON_NOT_PRESSED;
    }
    if (noArraySpace) {
        return HIDP_STATUS_BUFFER_TOO_SMALL;
    }
    return HIDP_STATUS_DATA_INDEX_NOT_FOUND;
}

NTSTATUS
HidP_SetData (
   IN       HIDP_REPORT_TYPE      ReportType,
   IN       PHIDP_DATA            DataList,
   IN OUT   PULONG                DataLength,
   IN       PHIDP_PREPARSED_DATA  PreparsedData,
   IN OUT   PCHAR                 Report,
   IN       ULONG                 ReportLength
   )
{
    ULONG       dataIndex;
    NTSTATUS    status;
    struct _CHANNEL_REPORT_HEADER * iof;

    CHECK_PPD (PreparsedData);

    switch (ReportType) {
    case HidP_Input:
       iof = &PreparsedData->Input;
       break;
    case HidP_Output:
       iof = &PreparsedData->Output;
       break;
    case HidP_Feature:
       iof = &PreparsedData->Feature;
       break;
    default:
       return HIDP_STATUS_INVALID_REPORT_TYPE;
    }

    if ((USHORT) ReportLength != iof->ByteLen) {
        return HIDP_STATUS_INVALID_REPORT_LENGTH;
    }

    if (0 == iof->ByteLen) {
        return HIDP_STATUS_REPORT_DOES_NOT_EXIST;
    }

    for (dataIndex = 0; dataIndex < *DataLength; dataIndex++, DataList++) {
        status = HidP_SetOneData (iof, DataList, PreparsedData, Report);

        if (!NT_SUCCESS (status)) {
            break;
        }
    }
    *DataLength = dataIndex;
    return status;
}

NTSTATUS __stdcall
HidP_GetData (
   IN       HIDP_REPORT_TYPE      ReportType,
   OUT      PHIDP_DATA            DataList,
   IN OUT   PULONG                DataLength,
   IN       PHIDP_PREPARSED_DATA  PreparsedData,
   IN       PCHAR                 Report,
   IN       ULONG                 ReportLength
   )
{
    struct _CHANNEL_REPORT_HEADER * iof;
    PHIDP_CHANNEL_DESC              channel;
    ULONG     inspect;
    USHORT    channelIndex  = 0;
    USHORT    dataListIndex = 0;
    USHORT    reportBitIndex;
    USHORT    tmpBitIndex;
     USHORT    tmpDataIndex;
    NTSTATUS  status          = HIDP_STATUS_SUCCESS;

    CHECK_PPD (PreparsedData);

    switch (ReportType) {
    case HidP_Input:
        iof = &PreparsedData->Input;
       break;
    case HidP_Output:
       iof = &PreparsedData->Output;
       break;
    case HidP_Feature:
       iof = &PreparsedData->Feature;
       break;
    default:
       return HIDP_STATUS_INVALID_REPORT_TYPE;
    }

    if ((USHORT) ReportLength != iof->ByteLen) {
        return HIDP_STATUS_INVALID_REPORT_LENGTH;
    }

    if (0 == iof->ByteLen) {
        return HIDP_STATUS_REPORT_DOES_NOT_EXIST;
    }

    for (channelIndex = iof->Offset; channelIndex < iof->Index; channelIndex++) {
        channel = (PreparsedData->Data + channelIndex);

        if ((!channel->IsRange) && (1 != channel->ReportCount)) {
            //
            // This value array.  We cannot access this here.
            //
            continue;
        }

        // Test the report ID to see if it is compatible.
        if ((0 != Report[0]) && (channel->ReportID != (UCHAR) Report[0])) {
            continue;
        }

        if (channel->IsButton) {
            if (1 == channel->ReportSize) {
                // A bitfield
                //
                // Little endian (by bit)
                // Byte 2  |Byte 1 |Byte 0
                // 765432107654321076543210  (bits)
                //
                // Get low byte first.  (need the higher bits)
                // Offset is from bit zero.
                //

                for (reportBitIndex = channel->BitOffset;
                     reportBitIndex < (channel->BitLength + channel->BitOffset);
                     reportBitIndex++) {
                    // Check it one bit at a time.
                    tmpBitIndex = reportBitIndex + (channel->ByteOffset << 3);
                    inspect = Report [tmpBitIndex >> 3] & (1 << (tmpBitIndex & 7));
                    tmpBitIndex = reportBitIndex - channel->BitOffset;
                    if (inspect) {
                        if (channel->IsRange) {
                            inspect = channel->Range.DataIndexMin + tmpBitIndex;
                        } else {
                            inspect = channel->NotRange.DataIndex;
                        }

                        if (dataListIndex < *DataLength) {
                            DataList[dataListIndex].On = TRUE;
                            DataList[dataListIndex].DataIndex = (USHORT)inspect;
                        }
                        dataListIndex++;
                    }
                }
                continue;
            }

            //
            // Not a bit field
            // an array of usages.
            //

            for (reportBitIndex = channel->BitOffset;
                 reportBitIndex < (channel->BitOffset + channel->BitLength);
                 reportBitIndex += channel->ReportSize) {

                inspect = (USHORT) HidP_ExtractData (
                        (USHORT) ((reportBitIndex >> 3) + channel->ByteOffset),
                        (USHORT) (reportBitIndex & 7),
                        channel->ReportSize,
                        Report);

                if (inspect) {
                    //
                    // NB Wizard Time (tm)
                    //
                    // We know that data indices are assigned consecutively
                    // for every control, and that the array channels
                    // are reversed in the channel array.
                    //
                    // inspect is the index (1 based not zero based) into the
                    // channel array.
                    //
                    if (0 == inspect) {
                        continue;
                    }

                    //
                    // Skip to the last channel that describes this same data
                    // fild;
                    //
                    while (channel->MoreChannels) {
                        channelIndex++;
                        channel++;
                    }
                    inspect += channel->Range.DataIndexMin - 1;
                    if (0 == channel->Range.UsageMin) {
                        inspect++;
                    }

                    if (dataListIndex < *DataLength) {
                        DataList [dataListIndex].On = TRUE;
                        DataList [dataListIndex].DataIndex = (USHORT) inspect;
                    }
                    dataListIndex++;
                }
            }
            continue;
        }
        //
        // Not a button so therefore a value.
        //

        for (reportBitIndex = channel->BitOffset, tmpDataIndex = 0;
             reportBitIndex < (channel->BitOffset + channel->BitLength);
             reportBitIndex += channel->ReportSize, tmpDataIndex++) {

            inspect = HidP_ExtractData (
                        (USHORT) ((reportBitIndex >> 3) + channel->ByteOffset),
                        (USHORT) (reportBitIndex & 7),
                        channel->ReportSize,
                        Report);

            if (dataListIndex < *DataLength) {

                ASSERT(tmpDataIndex + channel->Range.DataIndexMin <=
                        channel->Range.DataIndexMax);
                DataList [dataListIndex].RawValue = inspect;
                DataList [dataListIndex].DataIndex =
                    channel->Range.DataIndexMin + tmpDataIndex;
            }
            dataListIndex++;
        }
    }

    if (*DataLength < dataListIndex) {
        status = HIDP_STATUS_BUFFER_TOO_SMALL;
    }

    *DataLength = dataListIndex;

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidparse\trnslate.c ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    query.c

Abstract:

    This module contains the code for Translating HID report packets.

Environment:

    Kernel & user mode

Revision History:

    Nov-96 : created by Kenneth Ray

--*/

#include <wtypes.h>

#include "hidsdi.h"
#include "hidparse.h"


NTSTATUS __stdcall
HidP_UsageListDifference (
   IN    PUSAGE  PreviousUsageList,
   IN    PUSAGE  CurrentUsageList,
   OUT   PUSAGE  BreakUsageList,
   OUT   PUSAGE  MakeUsageList,
   IN    ULONG    UsageListLength
   )
/*++
Routine Description:
   Please see hidpi.h for description

Notes:

--*/
{
   ULONG    i,j;
   ULONG    test;
   ULONG    b; // an index into MakeUsageList
   ULONG    m; // an index into BreakUsageList
   USHORT   usage;
   BOOLEAN  found;

   b = m = 0;

   //
   // This assumes that UsageListLength will be a small number.
   // No keyboard today can generate more than 14 keys in one packet, and
   // there is no anticipation for other devices with greater than 14 usages
   // at once.  For this reason the straight forward naive approach follows...
   //
   // These lists are not sorted.
   //

   //
   // Find the Old usages.
   //
   for (i=0; i<UsageListLength; i++) {
      usage = PreviousUsageList[i];

      if (0 == usage) {
         break;  // Zeros Only at the end.
      }

      found = FALSE;
      for (j=0; j<UsageListLength; j++) {
         test = CurrentUsageList [j];

         if (0 == test) {
            break; // Zeros only at the end.
         }
         if (test == usage) {
            found = TRUE;
            break;
         }
      }

      if (!found) {
         BreakUsageList [b++] = usage;
      }
   }


   //
   // Find the New usages.
   //
   for (i=0; i<UsageListLength; i++) {
      usage = CurrentUsageList[i];

      if (0 == usage) {
         break;  // Zeros Only at the end.
      }

      found = FALSE;
      for (j=0; j<UsageListLength; j++) {
         test = PreviousUsageList [j];

         if (0 == test) {
            break; // Zeros only at the end.
         }
         if (test == usage) {
            found = TRUE;
            break;
         }
      }

      if (!found) {
         MakeUsageList [m++] = usage;
      }
   }

   while (b < UsageListLength) {
      BreakUsageList [b++] = 0;
   }

   while (m < UsageListLength) {
      MakeUsageList [m++] = 0;
   }

   return HIDP_STATUS_SUCCESS;
}

NTSTATUS __stdcall
HidP_UsageAndPageListDifference (
   IN    PUSAGE_AND_PAGE PreviousUsageList,
   IN    PUSAGE_AND_PAGE CurrentUsageList,
   OUT   PUSAGE_AND_PAGE BreakUsageList,
   OUT   PUSAGE_AND_PAGE MakeUsageList,
   IN    ULONG           UsageListLength
   )
/*++
Routine Description:
   Please see hidpi.h for description

Notes:

--*/
{
   ULONG    i,j;
   ULONG    b; // an index into MakeUsageList
   ULONG    m; // an index into BreakUsageList
   BOOLEAN          found;
   USAGE_AND_PAGE   usage;
   USAGE_AND_PAGE   test;
   USAGE_AND_PAGE   zero = {0,0};

   b = m = 0;

   //
   // This assumes that UsageListLength will be a small number.
   // No keyboard today can generate more than 14 keys in one packet, and
   // there is no anticipation for other devices with greater than 14 usages
   // at once.  For this reason the straight forward naive approach follows...
   //
   // These lists are not sorted.
   //

   //
   // Find the Old usages.
   //
   for (i=0; i<UsageListLength; i++) {
      usage = PreviousUsageList[i];

      if (HidP_IsSameUsageAndPage (zero, usage)) {
         break;  // Zeros Only at the end.
      }

      found = FALSE;
      for (j=0; j<UsageListLength; j++) {
         test = CurrentUsageList [j];

         if (HidP_IsSameUsageAndPage (zero, test)) {
            break; // Zeros only at the end.
         }
         if (HidP_IsSameUsageAndPage (test, usage)) {
            found = TRUE;
            break;
         }
      }

      if (!found) {
         BreakUsageList [b++] = usage;
      }
   }


   //
   // Find the New usages.
   //
   for (i=0; i<UsageListLength; i++) {
      usage = CurrentUsageList[i];

      if (HidP_IsSameUsageAndPage (zero, usage)) {
         break;  // Zeros Only at the end.
      }

      found = FALSE;
      for (j=0; j<UsageListLength; j++) {
         test = PreviousUsageList [j];

         if (HidP_IsSameUsageAndPage (zero, test)) {
            break; // Zeros only at the end.
         }
         if (HidP_IsSameUsageAndPage (test, usage)) {
            found = TRUE;
            break;
         }
      }

      if (!found) {
         MakeUsageList [m++] = usage;
      }
   }

   while (b < UsageListLength) {
      BreakUsageList [b++] = zero;
   }

   while (m < UsageListLength) {
      MakeUsageList [m++] = zero;
   }

   return HIDP_STATUS_SUCCESS;
}

#define KPAD(_X_) 0x ## _X_ ## F0
#define SHFT(_X_) 0x ## _X_ ## F1
#define VEND(_X_) 0x ## _X_ ## F2
#define PTSC(_X_) 0x ## _X_ ## F3

#define NONE 0xFF

//
// A table to convert a Hid Keyboard usage into a scan code.
// The scan codes from F0 ~ FF are special, they are used to indicate that
// a secondary translation is required.
// This secondary translation is done by way of the secondary translation
// function found in the ScanCodeSubTable structure array below.
//
ULONG HidP_KeyboardToScanCodeTable [0x100] = {
//
// This is a straight lookup table
//
//       + 00     + 01     + 02     + 03     + 04     + 05     + 06    + 07
//       + 08     + 09     + 0A     + 0B     + 0C     + 0D     + 0E    + OF
/*0x00*/ NONE,    NONE,    NONE,    NONE,    0x1E,    0x30,    0x2E,   0x20,
/*0x08*/ 0x12,    0x21,    0x22,    0x23,    0x17,    0x24,    0x25,   0x26,
/*0x10*/ 0x32,    0x31,    0x18,    0x19,    0x10,    0x13,    0x1F,   0x14,
/*0x18*/ 0x16,    0x2F,    0x11,    0x2D,    0x15,    0x2C,    0x02,   0x03,
/*0x20*/ 0x04,    0x05,    0x06,    0x07,    0x08,    0x09,    0x0A,   0x0B,
/*0x28*/ 0x1C,    0x01,    0x0E,    0x0F,    0x39,    0x0C,    0x0D,   0x1A,
/*0x30*/ 0x1B,    0x2B,    0x2B,    0x27,    0x28,    0x29,    0x33,   0x34,
/*0x38*/ 0x35,    SHFT(8), 0x3B,    0x3C,    0x3D,    0x3E,    0x3F,   0x40,
/*0x40*/ 0x41,    0x42,    0x43,    0x44,    0x57,    0x58,    PTSC(0),SHFT(9),
/*0x48*/ 0x451DE1,KPAD(0), KPAD(1), KPAD(2), KPAD(3), KPAD(4), KPAD(5),KPAD(6),
/*0x50*/ KPAD(7), KPAD(8), KPAD(9), SHFT(A), 0x35E0,  0x37,    0x4A,   0x4E,
/*0x58*/ 0x1CE0,  0x4F,    0x50,    0x51,    0x4B,    0x4C,    0x4D,   0x47,
/*0x60*/ 0x48,    0x49,    0x52,    0x53,    0x56,    0x5DE0,  0x5EE0, 0x59,
/*0x68*/ 0x64,    0x65,    0x66,    0x67,    0x68,    0x69,    0x6A,   0x6B,
/*0x70*/ 0x6C,    0x6D,    0x6E,    0x76,    NONE,    NONE,    NONE,   NONE,
/*0x78*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
/*0x80*/ NONE,    NONE,    NONE,    NONE,    NONE,    0x7E,    NONE,   0x73,
/*0x88*/ 0x70,    0x7D,    0x79,    0x7B,    0x5C,    NONE,    NONE,   NONE,
/*0x90*/ VEND(0), VEND(1), 0x78,    0x77,    0x76,    NONE,    NONE,   NONE,
/*0x98*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
/*0xA0*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
/*0xA8*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
/*0xB0*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
/*0xB8*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
/*0xC0*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
/*0xC8*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
/*0xD0*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
/*0xD8*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
/*0xE0*/ SHFT(0), SHFT(1), SHFT(2), SHFT(3), SHFT(4), SHFT(5), SHFT(6),SHFT(7),
/*0xE8*/ NONE,    0x5EE0,  0x5FE0,  0x63E0,  NONE,    NONE,    NONE,   NONE,
/*KPAD*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
/*0xF8*/ NONE,    NONE,    NONE,    NONE,    NONE,    NONE,    NONE,   NONE,
};

ULONG HidP_XlateKbdPadCodesSubTable[] = {
   /*     + 00    + 01    + 02     + 03    + 04    + 05    + 06     + 07 */
   /*     + 08    + 09    + 0A     + 0B    + 0C    + 0D    + 0E     + OF */
   /*0x48*/         0x52E0, 0x47E0, 0x49E0,  0x53E0, 0x4FE0, 0x51E0,  0x4DE0,
   /*0x50*/ 0x4BE0, 0x50E0, 0x48E0
};


ULONG HidP_XlateModifierCodesSubTable[] = {
   //
   // NOTE These modifier codes in this table are in a VERY SPECIAL order.
   // that is: they are in the order of appearence in the
   // _HIDP_KEYBOARD_SHIFT_STATE union.
   //
   //     + 00   + 01   + 02   + 03    + 04    + 05   + 06    + 07
   //     + 08   + 09   + 0A   + 0B    + 0C    + 0D   + 0E    + OF
   //       LCtrl  LShft  LAlt   LGUI    RCtrl   RShft  RAlt    RGUI
   /*0xE0*/ 0x1D,  0x2A,  0x38,  0x5BE0, 0x1DE0, 0x36,  0x38E0, 0x5CE0,
   /*0x39 CAPS_LOCK*/     0x3A,
   /*0x47 SCROLL_LOCK*/   0x46,
   /*0x53 NUM_LOCK*/      0x45
   // This table is set up so that indices into this table greater than 7
   // are sticky.  HidP_ModifierCode uses this as an optimization for
   // updating the Modifier state table.
   //
};

ULONG HidP_BreakCodesAsMakeCodesTable[] = {
    //
    // Vendor scan codes that have the high bit set and are technically
    // break codes, but are sent as make codes.  No break code will be sent.
    //
    //       + 00  + 01  + 02  + 03  + 04  + 05  + 06  + 07
    //       + 08  + 09  + 0A  + 0B  + 0C  + 0D  + 0E  + OF
    /*0x90*/  0xF2, 0xF1
    //
};

ULONG HidP_XlatePrtScrCodesSubTable[] = {
   /*     + 00    + 01    + 02     + 03    + 04    + 05    + 06     + 07 */
   /*     + 08    + 09    + 0A     + 0B    + 0C    + 0D    + 0E     + OF */
   /*0x40*/                                                  0x37E0
};

HIDP_SCANCODE_SUBTABLE HidP_KeyboardSubTables[0x10] = {
   /* F0 */     {HidP_KeyboardKeypadCode, HidP_XlateKbdPadCodesSubTable},
   /* F1 */     {HidP_ModifierCode, HidP_XlateModifierCodesSubTable},
   /* F2 */     {HidP_VendorBreakCodesAsMakeCodes, HidP_BreakCodesAsMakeCodesTable},
   /* F3 */     {HidP_PrintScreenCode, HidP_XlatePrtScrCodesSubTable},
   /* F4 */     {NULL, NULL},
   /* F5 */     {NULL, NULL},
   /* F6 */     {NULL, NULL},
   /* F7 */     {NULL, NULL},
   /* F8 */     {NULL, NULL},
   /* F9 */     {NULL, NULL},
   /* FA */     {NULL, NULL},
   /* FB */     {NULL, NULL},
   /* FC */     {NULL, NULL},
   /* FD */     {NULL, NULL},
   /* FE */     {NULL, NULL},
   /* FF */     {NULL, NULL}
};

#define HIDP_CONSUMER_TABLE_SIZE 16
ULONG HidP_ConsumerToScanCodeTable [HIDP_CONSUMER_TABLE_SIZE] = {
//
// This is an association table
//
// Usage -> Scancode
//
    0x0224, 0x6AE0, // WWW Back
    0x0225, 0x69E0, // WWW Forward
    0x0226, 0x68E0, // WWW Stop
    0x0227, 0x67E0, // WWW Refresh
    0x0221, 0x65E0, // WWW Search
    0x022A, 0x66E0, // WWW Favorites
    0x0223, 0x32E0, // WWW Home
    0x018A, 0x6CE0  // Mail
};

HIDP_SCANCODE_SUBTABLE HidP_ConsumerSubTables [1] = {
    {NULL, NULL}
};

//
//BOOLEAN
//HidP_KbdPutKey (
//   ULONG                   Code,
//   HIDP_KEYBOARD_DIRECTION KeyAction,
//   PHIDP_INSERT_SCANCODES  Insert,
//   PVOID                   Context)
//
// Add the scan codes to the callers buffer using the callback routine
// Insert.
//
// If we find a zero in the list then we are done with no error
// If we find a invalid code (anything that starts with an F, then
// we have a problem.  No where in current published i8042 specs is there
// a scan code of F0 ~ FF.
//
// If we are breaking then we need to set the high byte.
//

BOOLEAN
HidP_KbdPutKey (
    ULONG                   PassedCode,
    HIDP_KEYBOARD_DIRECTION KeyAction,
    PHIDP_INSERT_SCANCODES  Insert,
    PVOID                   Context)
{
   PUCHAR pCode = (PCHAR)&PassedCode;
   ULONG i;

   for (i = 0; i < sizeof(ULONG); i++) {
       //
       // Some swell keyboard vendors have added Fx charaters to their
       // keyboards which we now have to emulate.
       //
       // if ((0xF0 & *pCode) == 0xF0) {
       //     return FALSE;
       // }
       if (0 == pCode[i]) {
           break;
       }
       if (HidP_Keyboard_Break == KeyAction) {
           pCode[i] |= 0x80;
       }
   }
   if (i) {
       (*Insert)(Context, pCode, i);
   }
   return TRUE;
}

NTSTATUS
HidP_TranslateUsagesToI8042ScanCodes (
    PUSAGE                        ChangedUsageList, // Those usages that changed
    ULONG                         UsageListLength,
    HIDP_KEYBOARD_DIRECTION       KeyAction,
    PHIDP_KEYBOARD_MODIFIER_STATE ModifierState,
    PHIDP_INSERT_SCANCODES        InsertCodesProcedure,
    PVOID                         InsertCodesContext
    )
/*++
Routine Description:
   Please see hidpi.h for description

Notes:

--*/
{
    PUSAGE      usage;
    ULONG       i;
    NTSTATUS    status = HIDP_STATUS_SUCCESS;

    for (i = 0, usage = ChangedUsageList;
         i < UsageListLength;
         i++, usage++) {

        if (0 == *usage) {
            // No more interesting usages.  Zero terminated if not max length.
            break;
        }
        status = HidP_TranslateUsage (*usage,
                                      KeyAction,
                                      ModifierState,
                                      HidP_StraightLookup,
                                      HidP_KeyboardToScanCodeTable,
                                      HidP_KeyboardSubTables,
                                      InsertCodesProcedure,
                                      InsertCodesContext);

        if (HIDP_STATUS_SUCCESS != status) {
            break;
        }
    }

    return status;
}

NTSTATUS __stdcall
HidP_TranslateUsageAndPagesToI8042ScanCodes (
    PUSAGE_AND_PAGE               ChangedUsageList, // Those usages that changed
    ULONG                         UsageListLength,
    HIDP_KEYBOARD_DIRECTION       KeyAction,
    PHIDP_KEYBOARD_MODIFIER_STATE ModifierState,
    PHIDP_INSERT_SCANCODES        InsertCodesProcedure,
    PVOID                         InsertCodesContext
    )
/*++
Routine Description:
   Please see hidpi.h for description

Notes:

--*/
{
    PUSAGE_AND_PAGE usage;
    ULONG           i;
    NTSTATUS        status = HIDP_STATUS_SUCCESS;

    for (i = 0, usage = ChangedUsageList;
         i < UsageListLength;
         i++, usage++) {

        if (0 == usage->Usage) {
            break;
        }

        switch (usage->UsagePage) {
        case HID_USAGE_PAGE_KEYBOARD:

            status = HidP_TranslateUsage (usage->Usage,
                                          KeyAction,
                                          ModifierState,
                                          HidP_StraightLookup,
                                          HidP_KeyboardToScanCodeTable,
                                          HidP_KeyboardSubTables,
                                          InsertCodesProcedure,
                                          InsertCodesContext);
            break;

        case HID_USAGE_PAGE_CONSUMER:

            status = HidP_TranslateUsage (usage->Usage,
                                          KeyAction,
                                          ModifierState,
                                          HidP_AssociativeLookup,
                                          HidP_ConsumerToScanCodeTable,
                                          HidP_ConsumerSubTables,
                                          InsertCodesProcedure,
                                          InsertCodesContext);
            break;

        default:
            status = HIDP_STATUS_I8042_TRANS_UNKNOWN;
        }

        if (HIDP_STATUS_SUCCESS != status) {
            break;
        }
    }

    return status;
}

NTSTATUS __stdcall
HidP_TranslateUsage (
    USAGE                         Usage,
    HIDP_KEYBOARD_DIRECTION       KeyAction,
    PHIDP_KEYBOARD_MODIFIER_STATE ModifierState,
    PHIDP_LOOKUP_TABLE_PROC       LookupTableProc,
    PULONG                        TranslationTable,
    PHIDP_SCANCODE_SUBTABLE       SubTranslationTable,
    PHIDP_INSERT_SCANCODES        InsertCodesProcedure,
    PVOID                         InsertCodesContext
    )
/*++
Routine Description:

Notes:

--*/
{
   ULONG                    scancode;
   PHIDP_SCANCODE_SUBTABLE  table;
   NTSTATUS                 status;

   scancode = (* LookupTableProc) (TranslationTable, Usage);

   if (0 == scancode) {
       return HIDP_STATUS_I8042_TRANS_UNKNOWN;
   }

   if ((ModifierState->LeftControl || ModifierState->RightControl) &&
       (scancode == 0x451DE1)) {
       //
       // The scancode of the pause key completely changes
       // if the control key is down.
       //
       scancode = 0x46E0;
   } 

   if ((0xF0 & scancode) == 0xF0) {
       // Use a secondary table
       table = &SubTranslationTable [scancode & 0xF];
       if (table->ScanCodeFcn) {
           if ((*table->ScanCodeFcn)  (table->Table,
                                       (UCHAR) ((scancode & 0xFF00) >> 8),
                                       InsertCodesProcedure,
                                       InsertCodesContext,
                                       KeyAction,
                                       ModifierState)) {
               ;
           } else {
               return HIDP_STATUS_I8042_TRANS_UNKNOWN;
           }
       } else {
           return HIDP_STATUS_I8042_TRANS_UNKNOWN;
       }
   } else {
       HidP_KbdPutKey (scancode,
                       KeyAction,
                       InsertCodesProcedure,
                       InsertCodesContext);
   }
   return HIDP_STATUS_SUCCESS;
}

BOOLEAN
HidP_KeyboardKeypadCode (
   IN     ULONG                         * Table,
   IN     UCHAR                           Index,
   IN     PHIDP_INSERT_SCANCODES          Insert,
   IN     PVOID                           Context,
   IN     HIDP_KEYBOARD_DIRECTION         KeyAction,
   IN OUT PHIDP_KEYBOARD_MODIFIER_STATE   ModifierState
   )
/*++
Routine Description:

Notes:

--*/
{
   //
   // The num lock key (if set then we add even more scan codes for these
   // keys)
   //
   ULONG DarrylRis_Magic_Code = 0x2AE0;
   BOOLEAN  status = TRUE;

   if ((ModifierState->NumLock) && (HidP_Keyboard_Make == KeyAction) ) {
       status = HidP_KbdPutKey (DarrylRis_Magic_Code, KeyAction, Insert, Context);
   } 

   if (!status) {
       return status;
   }

   status = HidP_KbdPutKey (Table[Index], KeyAction, Insert, Context);

   if (!status) {
       return status;
   }

   if ((ModifierState->NumLock) && (HidP_Keyboard_Break == KeyAction) ) {
       status = HidP_KbdPutKey (DarrylRis_Magic_Code, KeyAction, Insert, Context);
   }

   return status;
}

BOOLEAN
HidP_ModifierCode (
   IN     ULONG                         * Table,
   IN     UCHAR                           Index,
   IN     PHIDP_INSERT_SCANCODES          Insert,
   IN     PVOID                           Context,
   IN     HIDP_KEYBOARD_DIRECTION         KeyAction,
   IN OUT PHIDP_KEYBOARD_MODIFIER_STATE   ModifierState
   )
/*++
Routine Description:

Notes:

--*/
{
   if (Index >> 3) {
      //
      // Indices greater than 8 are sticky.
      //
      switch (KeyAction) {
      case HidP_Keyboard_Make:
         if (!(ModifierState->ul & (1 << (Index+16)))) {
             //
             // Mark this as the first make.
             //
             ModifierState->ul |= (1 << (Index+16));
             //
             // Only toggle the state when this is the first make sent.
             //
             ModifierState->ul ^= (1 << Index);
         }
         break;
      case HidP_Keyboard_Break:
         //
         // Clear the fist make field.
         //
         ModifierState->ul &= ~(1 << (Index+16));
         break;
      }

   } else {
      switch (KeyAction) {
      case HidP_Keyboard_Make:
         // The key is now on
         ModifierState->ul |= (1 << Index);
         break;
      case HidP_Keyboard_Break:
         // The key is now off
         ModifierState->ul &= ~(1 << Index);
         break;
      }
   }
   return HidP_KbdPutKey (Table[Index], KeyAction, Insert, Context);
}

BOOLEAN
HidP_VendorBreakCodesAsMakeCodes (
   IN     ULONG                         * Table,
   IN     UCHAR                           Index,
   IN     PHIDP_INSERT_SCANCODES          Insert,
   IN     PVOID                           Context,
   IN     HIDP_KEYBOARD_DIRECTION         KeyAction,
   IN OUT PHIDP_KEYBOARD_MODIFIER_STATE   ModifierState
   )
{
    //
    // Vendor scan codes that have the high bit set and are technically
    // break codes, but are sent as make codes.  No break code will be sent.
    //
    UNREFERENCED_PARAMETER (ModifierState);

    switch (KeyAction) {
    case HidP_Keyboard_Make:
        return HidP_KbdPutKey (Table[Index], KeyAction, Insert, Context);

    case HidP_Keyboard_Break:
        // do Nothing
        return TRUE;

    default:
        return FALSE;
    }
}

BOOLEAN
HidP_PrintScreenCode (
   IN     ULONG                         * Table,
   IN     UCHAR                           Index,
   IN     PHIDP_INSERT_SCANCODES          Insert,
   IN     PVOID                           Context,
   IN     HIDP_KEYBOARD_DIRECTION         KeyAction,
   IN OUT PHIDP_KEYBOARD_MODIFIER_STATE   ModifierState
   )
/*++
Routine Description:

Notes:

--*/
{
   BOOLEAN  status = TRUE;

   //
   // Special casing for the printscreen key.
   //
   if (ModifierState->LeftAlt || ModifierState->RightAlt) {
       //
       // Alt key down.
       //
       status = HidP_KbdPutKey (0x54, KeyAction, Insert, Context);
   } else if (ModifierState->LeftShift || ModifierState->RightShift ||
              ModifierState->LeftControl  || ModifierState->RightControl) {
       //
       // Shift or ctrl keys down.
       //
       status = HidP_KbdPutKey (Table[Index], KeyAction, Insert, Context);
   } else {
       //
       // No modifier keys down. Add some extra "padding" to the make and break.
       //
       ULONG DarrylRis_Magic_Code = 0x2AE0;
       
       if (HidP_Keyboard_Make == KeyAction) {
           status = HidP_KbdPutKey (DarrylRis_Magic_Code, KeyAction, Insert, Context);
       } 
    
       if (!status) {
           return status;
       }
    
       status = HidP_KbdPutKey (Table[Index], KeyAction, Insert, Context);
    
       if (!status) {
           return status;
       }
    
       if (HidP_Keyboard_Break == KeyAction) {
           status = HidP_KbdPutKey (DarrylRis_Magic_Code, KeyAction, Insert, Context);
       }
   }

   return status;
}

ULONG
HidP_StraightLookup (
    IN  PULONG   Table,
    IN  ULONG    Usage
    )
{
    if (Usage > 0xFF) {
        // We have
        // have no translation for this usage.
        return 0;
    }

    return Table[Usage];
}

ULONG
HidP_AssociativeLookup (
    IN  PULONG   Table,
    IN  ULONG    Usage
    )
{
    ULONG   i;

    for (i = 0; i < (HIDP_CONSUMER_TABLE_SIZE - 1); i+=2) {
        if (Usage == Table[i]) {
            return Table[i+1];
        }
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidusb\pch.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pch.h

Abstract


Author:

    Jay Senior

Environment:

    Kernel mode only

Revision History:


--*/



#include <wdm.h>
#include <usbdrivr.h>
#include <hidport.h>
#include <hidusb.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidusb\hid.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ioctl.c

Abstract: Human Input Device (HID) minidriver for Universal Serial Bus (USB) devices

          The HID USB Minidriver (HUM, Hum) provides an abstraction layer for the
          HID Class so that future HID devices whic are not USB devices can be supported.

Author:
            forrestf
            ervinp
            jdunn

Environment:

    Kernel mode

Revision History:


--*/
#include "pch.h"


#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, HumGetHidDescriptor)
    #pragma alloc_text(PAGE, HumGetReportDescriptor)
    #pragma alloc_text(PAGE, HumGetStringDescriptor)
    #pragma alloc_text(PAGE, HumGetPhysicalDescriptor)
    #pragma alloc_text(PAGE, HumGetDeviceAttributes)
    #pragma alloc_text(PAGE, HumGetMsGenreDescriptor)
#endif




resetWorkItemContext *resetWorkItemsList = NULL;
KSPIN_LOCK resetWorkItemsListSpinLock;

PVOID
HumGetSystemAddressForMdlSafe(PMDL MdlAddress)
{
    PVOID buf = NULL;
    /*
     *  Can't call MmGetSystemAddressForMdlSafe in a WDM driver,
     *  so set the MDL_MAPPING_CAN_FAIL bit and check the result
     *  of the mapping.
     */
    if (MdlAddress) {
        MdlAddress->MdlFlags |= MDL_MAPPING_CAN_FAIL;
        buf = MmGetSystemAddressForMdl(MdlAddress);
        MdlAddress->MdlFlags &= ~(MDL_MAPPING_CAN_FAIL);
    }
    return buf;
}

/*
 ********************************************************************************
 *  GetInterruptInputPipeForDevice
 ********************************************************************************
 *
 *
 *  For composite devices, a device interface can be identified by the unique endpoint
 *  (i.e. pipe) that it uses for interrupt input.
 *  This function returns information about that pipe.
 *
 */
PUSBD_PIPE_INFORMATION GetInterruptInputPipeForDevice(PDEVICE_EXTENSION DeviceExtension)
{
    ULONG i;
    PUSBD_PIPE_INFORMATION pipeInfo = NULL;

    for (i = 0; i < DeviceExtension->Interface->NumberOfPipes; i++){
        UCHAR endPtAddr = DeviceExtension->Interface->Pipes[i].EndpointAddress;
        USBD_PIPE_TYPE pipeType = DeviceExtension->Interface->Pipes[i].PipeType;

        if ((endPtAddr & USB_ENDPOINT_DIRECTION_MASK) && (pipeType == UsbdPipeTypeInterrupt)){
            pipeInfo = &DeviceExtension->Interface->Pipes[i];
            break;
        }
    }

    return pipeInfo;
}


/*
 ********************************************************************************
 *  GetInterruptOutputPipeForDevice
 ********************************************************************************
 *
 *
 *  For composite devices, a device interface can be identified by the unique endpoint
 *  (i.e. pipe) that it uses for interrupt input.
 *  This function returns information about that pipe.
 *
 */
PUSBD_PIPE_INFORMATION GetInterruptOutputPipeForDevice(PDEVICE_EXTENSION DeviceExtension)
{
    ULONG i;
    PUSBD_PIPE_INFORMATION pipeInfo = NULL;

    for (i = 0; i < DeviceExtension->Interface->NumberOfPipes; i++){
        UCHAR endPtAddr = DeviceExtension->Interface->Pipes[i].EndpointAddress;
        USBD_PIPE_TYPE pipeType = DeviceExtension->Interface->Pipes[i].PipeType;

        if (!(endPtAddr & USB_ENDPOINT_DIRECTION_MASK) && (pipeType == UsbdPipeTypeInterrupt)){
            pipeInfo = &DeviceExtension->Interface->Pipes[i];
            break;
        }
    }

    return pipeInfo;
}


/*
 ********************************************************************************
 *  HumGetHidDescriptor
 ********************************************************************************
 *
 *   Routine Description:
 *
 *       Free all the allocated resources, etc.
 *
 *   Arguments:
 *
 *       DeviceObject - pointer to a device object.
 *
 *   Return Value:
 *
 *       NT status code.
 *
 */
NTSTATUS HumGetHidDescriptor(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION   DeviceExtension;
    PIO_STACK_LOCATION  IrpStack;

    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    if (DeviceExtension->HidDescriptor.bLength > 0) {

        ULONG bytesToCopy = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
        if (bytesToCopy > DeviceExtension->HidDescriptor.bLength) {
            bytesToCopy = DeviceExtension->HidDescriptor.bLength;
        }

        ASSERT(Irp->UserBuffer);
        RtlCopyMemory((PUCHAR)Irp->UserBuffer, (PUCHAR)&DeviceExtension->HidDescriptor, bytesToCopy);
        Irp->IoStatus.Information = bytesToCopy;
        ntStatus = STATUS_SUCCESS;
    }
    else {
        ASSERT(DeviceExtension->HidDescriptor.bLength > 0);
        Irp->IoStatus.Information = 0;
        ntStatus = STATUS_UNSUCCESSFUL;
    }


    ASSERT(NT_SUCCESS(ntStatus));
    return ntStatus;
}


/*
 ********************************************************************************
 *  HumGetDeviceAttributes
 ********************************************************************************
 *
 *   Routine Description:
 *
 *       Fill in the given struct _HID_DEVICE_ATTRIBUTES
 *
 *   Arguments:
 *
 *       DeviceObject - pointer to a device object.
 *
 *   Return Value:
 *
 *       NT status code.
 *
 */
NTSTATUS HumGetDeviceAttributes(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;
    PHID_DEVICE_ATTRIBUTES deviceAttributes;

    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);
    deviceAttributes = (PHID_DEVICE_ATTRIBUTES) Irp->UserBuffer;

    if (irpStack->Parameters.DeviceIoControl.OutputBufferLength >=
        sizeof (HID_DEVICE_ATTRIBUTES)){

        //
        // Report how many bytes were copied
        //
        Irp->IoStatus.Information = sizeof (HID_DEVICE_ATTRIBUTES);

        deviceAttributes->Size = sizeof (HID_DEVICE_ATTRIBUTES);
        deviceAttributes->VendorID = deviceExtension->DeviceDescriptor->idVendor;
        deviceAttributes->ProductID = deviceExtension->DeviceDescriptor->idProduct;
        deviceAttributes->VersionNumber = deviceExtension->DeviceDescriptor->bcdDevice;
        ntStatus = STATUS_SUCCESS;
    }
    else {
        ntStatus = STATUS_INVALID_BUFFER_SIZE;
    }

    ASSERT(NT_SUCCESS(ntStatus));
    return ntStatus;
}

/*
 ********************************************************************************
 *  HumGetReportDescriptor
 ********************************************************************************
 *
 *
 */
NTSTATUS HumGetReportDescriptor(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, BOOLEAN *NeedsCompletion)
{
    PDEVICE_EXTENSION       DeviceExtension;
    PIO_STACK_LOCATION      IrpStack;
    NTSTATUS                ntStatus = STATUS_SUCCESS;
    PVOID                   Report = NULL;
    ULONG                   ReportLength;
    ULONG                   bytesToCopy;

    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    ReportLength = DeviceExtension->HidDescriptor.wReportLength + 64;

    if (DeviceExtension->DeviceFlags & DEVICE_FLAGS_HID_1_0_D3_COMPAT_DEVICE) {
        PUSBD_PIPE_INFORMATION pipeInfo;

        pipeInfo = GetInterruptInputPipeForDevice(DeviceExtension);
        if (pipeInfo){
            UCHAR deviceInputEndpoint = pipeInfo->EndpointAddress & ~USB_ENDPOINT_DIRECTION_MASK;

            ntStatus = HumGetDescriptorRequest(
                           DeviceObject,
                           URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT,
                           DeviceExtension->HidDescriptor.bReportType,  // better be HID_REPORT_DESCRIPTOR_TYPE
                           &Report,
                           &ReportLength,
                           sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                           0,   // Specify zero for all hid class descriptors except physical
                           deviceInputEndpoint);
        }
        else {
            ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
        }
    }
    else {
        ntStatus = HumGetDescriptorRequest(
                        DeviceObject,
                        URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE,
                        DeviceExtension->HidDescriptor.bReportType, // better be HID_REPORT_DESCRIPTOR_TYPE
                        &Report,
                        &ReportLength,
                        sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                        0,      // Specify zero for all hid class descriptors except physical
                        DeviceExtension->Interface->InterfaceNumber); // Interface number when not requesting string descriptor
    }

    if (NT_SUCCESS(ntStatus)) {

        ASSERT(Report);

        bytesToCopy = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

        if (bytesToCopy > DeviceExtension->HidDescriptor.wReportLength) {
            bytesToCopy = DeviceExtension->HidDescriptor.wReportLength;
        }

        if (bytesToCopy > ReportLength) {
            bytesToCopy = ReportLength;
        }

        ASSERT(Irp->UserBuffer);
        RtlCopyMemory((PUCHAR)Irp->UserBuffer, (PUCHAR)Report, bytesToCopy);

        //
        // Report how many bytes were copied
        //
        Irp->IoStatus.Information = bytesToCopy;

        ExFreePool(Report);
    } else if (ntStatus != STATUS_DEVICE_NOT_CONNECTED) {

        DBGWARN(("Get Descriptor request %ph failed with status %xh -- scheduling RESET ...", Irp, ntStatus));

        Irp->IoStatus.Status = ntStatus;
        if (STATUS_MORE_PROCESSING_REQUIRED == HumQueueResetWorkItem(DeviceObject, Irp)) {
            IoMarkIrpPending(Irp);
            *NeedsCompletion = FALSE;
            ntStatus = STATUS_PENDING;
        }
    }

    return ntStatus;
}


/*
 ********************************************************************************
 *  HumIncrementPendingRequestCount
 ********************************************************************************
 *
 *
 */
NTSTATUS HumIncrementPendingRequestCount(IN PDEVICE_EXTENSION DeviceExtension)
{
    LONG newRequestCount;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    newRequestCount = InterlockedIncrement(&DeviceExtension->NumPendingRequests);

    //
    // Make sure that the device is capable of receiving new requests.
    //
    if ((DeviceExtension->DeviceState != DEVICE_STATE_RUNNING) &&
        (DeviceExtension->DeviceState != DEVICE_STATE_STARTING)){

        //
        // Device cannot receive any more IOs, decrement back, fail the increment
        //
        HumDecrementPendingRequestCount(DeviceExtension);
        ntStatus = STATUS_NO_SUCH_DEVICE;
    }

    return ntStatus;
}



/*
 ********************************************************************************
 *  HumDecrementPendingRequestCount
 ********************************************************************************
 *
 *
 */
VOID HumDecrementPendingRequestCount(IN PDEVICE_EXTENSION DeviceExtension)
{
    LONG PendingCount;

    ASSERT(DeviceExtension->NumPendingRequests >= 0);

    PendingCount = InterlockedDecrement(&DeviceExtension->NumPendingRequests);
    if (PendingCount < 0){

        ASSERT(DeviceExtension->DeviceState != DEVICE_STATE_RUNNING);

        /*
         *  The device state is stopping, and the last outstanding request
         *  has just completed.
         *
         *  Note: RemoveDevice does an extra decrement, so we complete
         *        the REMOVE IRP on the transition to -1, whether this
         *        happens in RemoveDevice itself or subsequently while
         *        RemoveDevice is waiting for this event to fire.
         */

        KeSetEvent(&DeviceExtension->AllRequestsCompleteEvent, 0, FALSE);
    }
}




/*
 ********************************************************************************
 *  HumReadReport
 ********************************************************************************
 *
 *   Routine Description:
 *
 *
 *    Arguments:
 *
 *       DeviceObject - Pointer to class device object.
 *
 *      IrpStack     - Pointer to Interrupt Request Packet.
 *
 *
 *   Return Value:
 *
 *      STATUS_SUCCESS, STATUS_UNSUCCESSFUL.
 *
 *
 *  Note: this function cannot be pageable because reads/writes
 *        can be made at dispatch-level.
 */
NTSTATUS HumReadReport(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, BOOLEAN *NeedsCompletion)
{
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    PDEVICE_EXTENSION DeviceExtension;
    PIO_STACK_LOCATION IrpStack;
    PVOID ReportBuffer;
    ULONG ReportTotalSize;
    PIO_STACK_LOCATION NextStack;
    PURB Urb;

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);
    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    ASSERT(Irp->UserBuffer);

    ReportBuffer = Irp->UserBuffer;
    ReportTotalSize = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    if (ReportTotalSize && ReportBuffer){
        PUSBD_PIPE_INFORMATION inputInterruptPipe;

        inputInterruptPipe = GetInterruptInputPipeForDevice(DeviceExtension);
        if (inputInterruptPipe){

            /*
             *  Allocate a request block for the USB stack.
             *  (It will be freed by the completion routine).
             */
            Urb = ExAllocatePoolWithTag( NonPagedPool, sizeof(URB), HIDUSB_TAG);
            if (Urb){
                //
                //  Initialize the URB
                //
                RtlZeroMemory(Urb, sizeof(URB));

                Urb->UrbBulkOrInterruptTransfer.Hdr.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
                Urb->UrbBulkOrInterruptTransfer.Hdr.Length = sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );

                Urb->UrbBulkOrInterruptTransfer.PipeHandle = inputInterruptPipe->PipeHandle;
                ASSERT (Urb->UrbBulkOrInterruptTransfer.PipeHandle != NULL);

                Urb->UrbBulkOrInterruptTransfer.TransferBufferLength = ReportTotalSize;
                Urb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;
                Urb->UrbBulkOrInterruptTransfer.TransferBuffer = ReportBuffer;
                Urb->UrbBulkOrInterruptTransfer.TransferFlags = USBD_SHORT_TRANSFER_OK | USBD_TRANSFER_DIRECTION_IN;
                Urb->UrbBulkOrInterruptTransfer.UrbLink = NULL;

                IoSetCompletionRoutine( Irp,
                                        HumReadCompletion,
                                        Urb,    // context
                                        TRUE,
                                        TRUE,
                                        TRUE );

                NextStack = IoGetNextIrpStackLocation(Irp);

                ASSERT(NextStack);

                NextStack->Parameters.Others.Argument1 = Urb;
                NextStack->MajorFunction = IrpStack->MajorFunction;

                NextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

                NextStack->DeviceObject = GET_NEXT_DEVICE_OBJECT(DeviceObject);


                //
                // We need to keep track of the number of pending requests
                // so that we can make sure they're all cancelled properly during
                // processing of a stop device request.
                //
                if (NT_SUCCESS(HumIncrementPendingRequestCount(DeviceExtension))){
                    ntStatus = IoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);
                    *NeedsCompletion = FALSE;
                }
                else {
                    ExFreePool(Urb);
                    ntStatus = STATUS_NO_SUCH_DEVICE;
                }
            }
            else {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else {
            ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
        }
    }
    else {
        ntStatus = STATUS_INVALID_PARAMETER;
    }

    return ntStatus;
}



/*
 ********************************************************************************
 *  HumResetInterruptPipe
 ********************************************************************************
 *
 *  Reset The usb interrupt pipe.
 *
 */
NTSTATUS HumResetInterruptPipe(IN PDEVICE_OBJECT DeviceObject)
{
    NTSTATUS ntStatus;
    PURB urb;
    PDEVICE_EXTENSION DeviceExtension;
    PUSBD_PIPE_INFORMATION pipeInfo;

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    urb = ExAllocatePoolWithTag(NonPagedPool, sizeof(struct _URB_PIPE_REQUEST), HIDUSB_TAG);

    if (urb) {
        urb->UrbHeader.Length = (USHORT) sizeof (struct _URB_PIPE_REQUEST);
        urb->UrbHeader.Function = URB_FUNCTION_SYNC_RESET_PIPE_AND_CLEAR_STALL;
        pipeInfo = GetInterruptInputPipeForDevice(DeviceExtension);
        if (pipeInfo) {
            urb->UrbPipeRequest.PipeHandle = pipeInfo->PipeHandle;

            ntStatus = HumCallUSB(DeviceObject, urb);
        } else {
            //
            // This device doesn't have an interrupt IN pipe.
            // Odd, but possible. I.e. USB monitor
            //
            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
        }

        ExFreePool(urb);
    }
    else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}



/*
 ********************************************************************************
 *  HumGetPortStatus
 ********************************************************************************
 *
 *  Passes a URB to the USBD class driver
 *
 */
NTSTATUS HumGetPortStatus(IN PDEVICE_OBJECT DeviceObject, IN PULONG PortStatus)
{
    NTSTATUS ntStatus;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION nextStack;


    *PortStatus = 0;

    //
    // issue a synchronous request
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(
                IOCTL_INTERNAL_USB_GET_PORT_STATUS,
                GET_NEXT_DEVICE_OBJECT(DeviceObject),
                NULL,
                0,
                NULL,
                0,
                TRUE, /* INTERNAL */
                &event,
                &ioStatus);

    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);

    nextStack->Parameters.Others.Argument1 = PortStatus;


    ntStatus = IoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), irp);
    if (ntStatus == STATUS_PENDING) {
        ntStatus = KeWaitForSingleObject(
                       &event,
                       Suspended,
                       KernelMode,
                       FALSE,
                       NULL);
    }
    else {
        ioStatus.Status = ntStatus;
    }


    //
    // USBD maps the error code for us
    //
    ntStatus = ioStatus.Status;

    return ntStatus;
}



/*
 ********************************************************************************
 *  HumResetParentPort
 ********************************************************************************
 *
 *  Sends a RESET_PORT request to our USB PDO.
 *
 */
NTSTATUS HumResetParentPort(IN PDEVICE_OBJECT DeviceObject)
{
    NTSTATUS ntStatus;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;

    //
    // issue a synchronous request
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(
                IOCTL_INTERNAL_USB_RESET_PORT,
                GET_NEXT_DEVICE_OBJECT(DeviceObject),
                NULL,
                0,
                NULL,
                0,
                TRUE, /* INTERNAL */
                &event,
                &ioStatus);

    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    ntStatus = IoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), irp);
    if (ntStatus == STATUS_PENDING) {
        ntStatus = KeWaitForSingleObject(
                       &event,
                       Suspended,
                       KernelMode,
                       FALSE,
                       NULL);
    }
    else {
        ioStatus.Status = ntStatus;
    }

    //
    // USBD maps the error code for us
    //
    ntStatus = ioStatus.Status;

    return ntStatus;
}


/*
 ********************************************************************************
 *  HumResetWorkItem
 ********************************************************************************
 *
 *  Resets the interrupt pipe after a read error is encountered.
 *
 */
NTSTATUS HumResetWorkItem(IN PDEVICE_OBJECT deviceObject, IN PVOID Context)
{
    resetWorkItemContext *resetWorkItemObj;
    PDEVICE_EXTENSION DeviceExtension;
    NTSTATUS ntStatus;
    ULONG portStatus;

    /*
     *  Get the information out of the resetWorkItemContext and free it.
     */
    resetWorkItemObj = (resetWorkItemContext *)Context;
    ASSERT(resetWorkItemObj);
    ASSERT(resetWorkItemObj->sig == RESET_WORK_ITEM_CONTEXT_SIG);

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(resetWorkItemObj->deviceObject);

    ntStatus = HumIncrementPendingRequestCount(DeviceExtension);
    if (NT_SUCCESS(ntStatus)){

        //
        // Check the port state. Only if there's something connected will we
        // perform the reset.
        //
        ntStatus = HumGetPortStatus(resetWorkItemObj->deviceObject, &portStatus);

        if (NT_SUCCESS(ntStatus)){

            if (portStatus & USBD_PORT_CONNECTED){
                /*
                 *  Device is still present, attempt reset.
                 *
                 *  Note: Resetting the port will close the endpoint(s).
                 *        So before resetting the port, we must make sure
                 *        that there is no pending IO.
                 */
                DBGPRINT(1,("Attempting port reset"));
                ntStatus = HumAbortPendingRequests(resetWorkItemObj->deviceObject);

                if (NT_SUCCESS(ntStatus)){
                    HumResetParentPort(resetWorkItemObj->deviceObject);
                }
                else {
                    DBGWARN(("HumResetWorkItem: HumAbortPendingRequests failed with status %xh.", ntStatus));
                }

                /*
                 *  Now attempt to reset the stalled pipe. This will clear the
                 *  stall on the device as well.
                 *
                 *  Note: This call does not close the endpoint, so it should
                 *        be ok to make this call whether or not we succeeded
                 *        in aborting all pending IO.
                 */
                if (NT_SUCCESS(ntStatus)) {
                    ntStatus = HumResetInterruptPipe(resetWorkItemObj->deviceObject);
                }
            }
        }
        else {
            DBGWARN(("HumResetWorkItem: HumGetPortStatus failed with status %xh.", ntStatus));
        }

        HumDecrementPendingRequestCount(DeviceExtension);
    }

    /*
     *  Clear the ResetWorkItem ptr in the device extension
     *  AFTER resetting the pipe so we don't end up with
     *  two threads resetting the same pipe at the same time.
     */
    (VOID)InterlockedExchange((PVOID) &DeviceExtension->ResetWorkItem, 0);

    /*
     *  The IRP that returned the error which prompted us to do this reset
     *  is still owned by HIDUSB because we returned
     *  STATUS_MORE_PROCESSING_REQUIRED in the completion routine.
     *  Now that the hub is reset, complete this failed IRP.
     */
    DBGPRINT(1,("Completing IRP %ph following port reset", resetWorkItemObj->irpToComplete));
    IoCompleteRequest(resetWorkItemObj->irpToComplete, IO_NO_INCREMENT);

    IoFreeWorkItem(resetWorkItemObj->ioWorkItem);
    ExFreePool(resetWorkItemObj);

    /*
     *  Balance the increment from when we queued the workItem.
     */
    HumDecrementPendingRequestCount(DeviceExtension);

    return ntStatus;
}

NTSTATUS
HumQueueResetWorkItem(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp)
{
    NTSTATUS result = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    if (NT_SUCCESS(HumIncrementPendingRequestCount(deviceExtension))){
        resetWorkItemContext *resetWorkItemObj;

        resetWorkItemObj = ExAllocatePoolWithTag(NonPagedPool, sizeof(resetWorkItemContext), HIDUSB_TAG);
        if (resetWorkItemObj){
            PVOID comperand = NULL;

            resetWorkItemObj->ioWorkItem = IoAllocateWorkItem(deviceExtension->functionalDeviceObject);
            if (resetWorkItemObj->ioWorkItem){

                comperand = InterlockedCompareExchangePointer (
                                  &deviceExtension->ResetWorkItem,  // dest
                                  &resetWorkItemObj->ioWorkItem,    // exchange
                                  comperand);                       // comperand

                if (!comperand){

                    resetWorkItemObj->sig = RESET_WORK_ITEM_CONTEXT_SIG;
                    resetWorkItemObj->irpToComplete = Irp;
                    resetWorkItemObj->deviceObject = DeviceObject;

                    IoQueueWorkItem(    resetWorkItemObj->ioWorkItem,
                                        HumResetWorkItem,
                                        DelayedWorkQueue,
                                        resetWorkItemObj);

                    /*
                     *  Return STATUS_MORE_PROCESSING_REQUIRED so NTKERN doesn't
                     *  keep processing the IRP.
                     */
                    result = STATUS_MORE_PROCESSING_REQUIRED;
                }
                else {
                    //
                    // We already have a reset op queued.
                    //
                    IoFreeWorkItem(resetWorkItemObj->ioWorkItem);
                    ExFreePool(resetWorkItemObj);
                    HumDecrementPendingRequestCount(deviceExtension);
                }
            }
            else {
                ExFreePool(resetWorkItemObj);
                HumDecrementPendingRequestCount(deviceExtension);
            }
        }
        else {
            HumDecrementPendingRequestCount(deviceExtension);
        }
    }
    return result;
}

/*
 ********************************************************************************
 *  HumReadCompletion
 ********************************************************************************
 *
 *
 */
NTSTATUS HumReadCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
{
    NTSTATUS ntStatus;
    NTSTATUS result = STATUS_SUCCESS;
    PURB urb;
    ULONG bytesRead;
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    //
    // We passed a pointer to the URB as our context, get it now.
    //
    urb = (PURB)Context;
    ASSERT(urb);

    ntStatus = Irp->IoStatus.Status;
    if (NT_SUCCESS(ntStatus)){
        //
        // Get the bytes read and store in the status block
        //

        bytesRead = urb->UrbBulkOrInterruptTransfer.TransferBufferLength;
        Irp->IoStatus.Information = bytesRead;
    }
    else if (ntStatus == STATUS_CANCELLED){
        /*
         *  The IRP was cancelled, which means that the device is probably getting removed.
         */
        DBGPRINT(2,("Read irp %p cancelled ...", Irp));
        ASSERT(!Irp->CancelRoutine);
    }
    else if (ntStatus != STATUS_DEVICE_NOT_CONNECTED) {

        DBGWARN(("Read irp %ph failed with status %xh -- scheduling RESET ...", Irp, ntStatus));

        result = HumQueueResetWorkItem(DeviceObject, Irp);
    }

    //
    // Don't need the URB anymore
    //
    ExFreePool(urb);

    /*
     *  Balance the increment we did when we issued the read.
     */
    HumDecrementPendingRequestCount(deviceExtension);

    /*
     *  If the lower driver returned PENDING, mark our stack location as
     *  pending also. This prevents the IRP's thread from being freed if
     *  the client's call returns pending.
     */
    if (Irp->PendingReturned){
        IoMarkIrpPending(Irp);
    }
    return result;
}



/*
 ********************************************************************************
 *  HumWriteReport
 ********************************************************************************
 *
 *    Routine Description:
 *
 *
 *   Arguments:
 *
 *      DeviceObject - Pointer to class device object.
 *
 *      IrpStack     - Pointer to Interrupt Request Packet.
 *
 *
 *   Return Value:
 *
 *   STATUS_SUCCESS, STATUS_UNSUCCESSFUL.
 *
 *
 *  Note: this function cannot be pageable because reads/writes
 *        can be made at dispatch-level.
 */
NTSTATUS HumWriteReport(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, BOOLEAN *NeedsCompletion)
{
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    PDEVICE_EXTENSION DeviceExtension;
    PIO_STACK_LOCATION currentIrpStack, nextIrpStack;
    PURB Urb;

    PHID_XFER_PACKET hidWritePacket;

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);
    currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    nextIrpStack = IoGetNextIrpStackLocation(Irp);

    hidWritePacket = (PHID_XFER_PACKET)Irp->UserBuffer;
    if (hidWritePacket){

        if (hidWritePacket->reportBuffer && hidWritePacket->reportBufferLen){
            PUSBD_PIPE_INFORMATION interruptPipe;

            Urb = ExAllocatePoolWithTag(NonPagedPool, sizeof(URB), HIDUSB_TAG);
            if (Urb){

                RtlZeroMemory(Urb, sizeof( URB ));

                if (DeviceExtension->DeviceFlags & DEVICE_FLAGS_HID_1_0_D3_COMPAT_DEVICE) {

                    /*
                     *  This is an old device which follows the pre-final spec.
                     *  We use the endpoint address of the input pipe
                     *  with the direction bit cleared.
                     */

                    #if DBG
                        interruptPipe = GetInterruptOutputPipeForDevice(DeviceExtension);
                        ASSERT(!interruptPipe);
                    #endif

                    interruptPipe = GetInterruptInputPipeForDevice(DeviceExtension);
                    if (interruptPipe){
                        UCHAR deviceInputEndpoint = interruptPipe->EndpointAddress & ~USB_ENDPOINT_DIRECTION_MASK;

                        /*
                         *   A control operation consists of 3 stages: setup, data, and status.
                         *   In the setup stage the device receives an 8-byte frame comprised of
                         *   the following fields of a _URB_CONTROL_VENDOR_OR_CLASS_REQUEST structure:
                         *   See section 7.2 in the USB HID specification for how to fill out these fields.
                         *
                         *      UCHAR RequestTypeReservedBits;
                         *      UCHAR Request;
                         *      USHORT Value;
                         *      USHORT Index;
                         *
                         */
                        HumBuildClassRequest(
                                                Urb,
                                                URB_FUNCTION_CLASS_ENDPOINT,
                                                0,                  // transferFlags,
                                                hidWritePacket->reportBuffer,
                                                hidWritePacket->reportBufferLen,
                                                0x22,               // requestType= Set_Report Request,
                                                0x09,               // request=SET_REPORT,
                                                (0x0200 + hidWritePacket->reportId), // value= reportType 'output' &reportId,
                                                deviceInputEndpoint, // index= interrupt input endpoint for this device
                                                hidWritePacket->reportBufferLen    // reqLength (not used)
                                               );
                    }
                    else {
                        ntStatus = STATUS_DATA_ERROR;
                    }
                }
                else {

                    interruptPipe = GetInterruptOutputPipeForDevice(DeviceExtension);
                    if (interruptPipe){
                        /*
                         *  This device has an interrupt output pipe.
                         */

                        Urb->UrbBulkOrInterruptTransfer.Hdr.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
                        Urb->UrbBulkOrInterruptTransfer.Hdr.Length = sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );

                        ASSERT(interruptPipe->PipeHandle);
                        Urb->UrbBulkOrInterruptTransfer.PipeHandle = interruptPipe->PipeHandle;

                        Urb->UrbBulkOrInterruptTransfer.TransferBufferLength = hidWritePacket->reportBufferLen;
                        Urb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;
                        Urb->UrbBulkOrInterruptTransfer.TransferBuffer = hidWritePacket->reportBuffer;
                        Urb->UrbBulkOrInterruptTransfer.TransferFlags = USBD_SHORT_TRANSFER_OK | USBD_TRANSFER_DIRECTION_OUT;
                        Urb->UrbBulkOrInterruptTransfer.UrbLink = NULL;
                    }
                    else {
                        /*
                         *  This device does not have an interrupt output pipe.
                         *  Send the report on the control pipe.
                         */

                        /*
                         *   A control operation consists of 3 stages: setup, data, and status.
                         *   In the setup stage the device receives an 8-byte frame comprised of
                         *   the following fields of a _URB_CONTROL_VENDOR_OR_CLASS_REQUEST structure:
                         *   See section 7.2 in the USB HID specification for how to fill out these fields.
                         *
                         *      UCHAR RequestTypeReservedBits;
                         *      UCHAR Request;
                         *      USHORT Value;
                         *      USHORT Index;
                         *
                         */
                        HumBuildClassRequest(
                                                Urb,
                                                URB_FUNCTION_CLASS_INTERFACE,
                                                0,                  // transferFlags,
                                                hidWritePacket->reportBuffer,
                                                hidWritePacket->reportBufferLen,
                                                0x22,               // requestType= Set_Report Request,
                                                0x09,               // request=SET_REPORT,
                                                (0x0200 + hidWritePacket->reportId), // value= reportType 'output' &reportId,
                                                DeviceExtension->Interface->InterfaceNumber, // index= interrupt input interface for this device
                                                hidWritePacket->reportBufferLen    // reqLength (not used)
                                               );
                    }
                }

                if (ntStatus == STATUS_UNSUCCESSFUL) {
                    IoSetCompletionRoutine(Irp, HumWriteCompletion, Urb, TRUE, TRUE, TRUE);

                    nextIrpStack->Parameters.Others.Argument1 = Urb;
                    nextIrpStack->MajorFunction = currentIrpStack->MajorFunction;
                    nextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;
                    nextIrpStack->DeviceObject = GET_NEXT_DEVICE_OBJECT(DeviceObject);

                    //
                    // We need to keep track of the number of pending requests
                    // so that we can make sure they're all cancelled properly during
                    // processing of a stop device request.
                    //

                    if (NT_SUCCESS(HumIncrementPendingRequestCount( DeviceExtension )) ) {

                        ntStatus = IoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);

                        *NeedsCompletion = FALSE;

                    } else {
                        ExFreePool(Urb);

                        ntStatus = STATUS_NO_SUCH_DEVICE;
                    }

                } else {
                    ExFreePool(Urb);
                }
            }
            else {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {
            ntStatus = STATUS_DATA_ERROR;
        }
    }
    else {
        ntStatus = STATUS_DATA_ERROR;
    }

    return ntStatus;
}



/*
 ********************************************************************************
 *  HumWriteCompletion
 ********************************************************************************
 *
 *
 */
NTSTATUS HumWriteCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
{
    PURB urb = (PURB)Context;
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    ASSERT(urb);

    if (NT_SUCCESS(Irp->IoStatus.Status)){
        //
        //  Record the number of bytes written.
        //
        Irp->IoStatus.Information = (ULONG)urb->UrbBulkOrInterruptTransfer.TransferBufferLength;
    }

    ExFreePool(urb);

    /*
     *  If the lower driver returned PENDING, mark our stack location as
     *  pending also. This prevents the IRP's thread from being freed if
     *  the client's call returns pending.
     */
    if (Irp->PendingReturned){
        IoMarkIrpPending(Irp);
    }

    /*
     *  Balance the increment we did when we issued the write.
     */
    HumDecrementPendingRequestCount(deviceExtension);

    return STATUS_SUCCESS;
}



/*
 ********************************************************************************
 *  HumGetPhysicalDescriptor
 ********************************************************************************
 *
 *
 */
NTSTATUS HumGetPhysicalDescriptor(  IN PDEVICE_OBJECT DeviceObject,
                                    IN PIRP Irp,
                                    BOOLEAN *NeedsCompletion)
{
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION IrpStack;
    ULONG bufferSize;

    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation(Irp);


    /*
     *  Check buffer size before trying to use Irp->MdlAddress.
     */
    bufferSize = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    if (bufferSize){

        PVOID buffer = HumGetSystemAddressForMdlSafe(Irp->MdlAddress);
        if (buffer){
            ntStatus = HumGetDescriptorRequest(DeviceObject,
                                               URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE,
                                               HID_PHYSICAL_DESCRIPTOR_TYPE,
                                               &buffer,
                                               &bufferSize,
                                               sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                               0, // Index. NOTE: will only get first physical descriptor set
                                               0);
        }
        else {
            ntStatus = STATUS_INVALID_USER_BUFFER;
        }
    }
    else {
        ntStatus = STATUS_INVALID_USER_BUFFER;
    }

    return ntStatus;
}


/*
 ********************************************************************************
 *  HumGetStringDescriptor
 ********************************************************************************
 *
 *
 */
NTSTATUS HumGetStringDescriptor(    IN PDEVICE_OBJECT DeviceObject,
                                    IN PIRP Irp)
{
    NTSTATUS ntStatus = STATUS_PENDING;
    PDEVICE_EXTENSION DeviceExtension;
    PIO_STACK_LOCATION IrpStack;
    PVOID buffer;
    ULONG bufferSize;
    BOOLEAN isIndexedString;

    PAGED_CODE();

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    switch (IrpStack->Parameters.DeviceIoControl.IoControlCode){
        case IOCTL_HID_GET_INDEXED_STRING:
            /*
             *  IOCTL_HID_GET_INDEXED_STRING uses buffering method
             *  METHOD_OUT_DIRECT, which passes the buffer in the MDL.
             *
             *  The MDL is built by the kernel for any non-zero-length
             *  buffer passed in by the client.  So we don't need to
             *  verify the integrity of the MDL, but we do have to check
             *  that it's non-NULL.
             */
            buffer = HumGetSystemAddressForMdlSafe(Irp->MdlAddress);
            isIndexedString = TRUE;
            break;

        case IOCTL_HID_GET_STRING:
            /*
             *  IOCTL_HID_GET_STRING uses buffering method
             *  METHOD_NEITHER, which passes the buffer in Irp->UserBuffer.
             */
            buffer = Irp->UserBuffer;
            isIndexedString = FALSE;
            break;

        default:
            ASSERT(0);
            buffer = NULL;
            break;
    }

    bufferSize = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    if (buffer && (bufferSize >= sizeof(WCHAR) )){

        /*
         *  String id and language id are in Type3InputBuffer field
         *  of IRP stack location.
         *
         *  Note: the string ID should be identical to the string's
         *        field offset given in Chapter 9 of the USB spec.
         */
        ULONG languageId = (PtrToUlong(IrpStack->Parameters.DeviceIoControl.Type3InputBuffer)) >> 16;
        ULONG stringIndex;

        if (isIndexedString){
            stringIndex = (PtrToUlong(IrpStack->Parameters.DeviceIoControl.Type3InputBuffer) & 0x0ffff);
        }
        else {
            ULONG stringId = (PtrToUlong(IrpStack->Parameters.DeviceIoControl.Type3InputBuffer) & 0x0ffff);

            switch (stringId){
                case HID_STRING_ID_IMANUFACTURER:
                    stringIndex = DeviceExtension->DeviceDescriptor->iManufacturer;
                    break;
                case HID_STRING_ID_IPRODUCT:
                    stringIndex = DeviceExtension->DeviceDescriptor->iProduct;
                    break;
                case HID_STRING_ID_ISERIALNUMBER:
                    stringIndex = DeviceExtension->DeviceDescriptor->iSerialNumber;
                    break;
                default:
                    stringIndex = -1;
                    break;
            }
        }

        if (stringIndex == -1){
            ntStatus = STATUS_INVALID_PARAMETER;
        }
        else {
            PWCHAR tmpDescPtr;
            ULONG tmpDescPtrLen;

            /*
             *  USB descriptors begin with an extra two bytes for length and type.
             *  So we need to allocate a slightly larger buffer.
             */
            tmpDescPtrLen = bufferSize + 2;
            tmpDescPtr = ExAllocatePoolWithTag(NonPagedPool, tmpDescPtrLen, HIDUSB_TAG);
            if (tmpDescPtr){
                ntStatus = HumGetDescriptorRequest(DeviceObject,
                                                   URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE,
                                                   USB_STRING_DESCRIPTOR_TYPE,
                                                   &tmpDescPtr,
                                                   &tmpDescPtrLen,
                                                   sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                                   stringIndex,
                                                   languageId); // LanguageID,

                if (NT_SUCCESS(ntStatus)){
                    /*
                     *  USB descriptors always begin with two bytes for the length
                     *  and type.  Remove these.
                     */

                    // Could be unaligned, so cast to PCHAR instead of PWCHAR
                    PCHAR descPtr = (PCHAR)buffer;
                    // String is not null terminated. Length is
                    // calculated by subtracting 2 from value of
                    // the first byte of the descriptor.
                    ULONG descLen = ((ULONG)(((PCHAR)tmpDescPtr)[0]))-2;

                    WCHAR unicodeNULL = UNICODE_NULL;

                    if (descLen > tmpDescPtrLen) {
                        descLen = tmpDescPtrLen;
                    }

                    // Some firmware incorrectly reports an odd string length,
                    // so we round down to the nearest even number to prevent
                    // extra characters from being displayed

                    descLen &= ~1;

                    if (descLen <= bufferSize-sizeof(WCHAR)){
                        RtlCopyMemory(descPtr, &tmpDescPtr[1], descLen);
                        RtlCopyMemory(&descPtr[descLen], &unicodeNULL, sizeof(WCHAR));
                    }
                    else {
                        /*
                         *  Compensate for a device bug which causes
                         *  a partial string to be returned if the buffer is too small.
                         */
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                    }
                }

                ExFreePool(tmpDescPtr);
            }
            else {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }
    else {
        ntStatus = STATUS_INVALID_USER_BUFFER;
    }

    return ntStatus;
}



/*
 ********************************************************************************
 *  HumGetSetReportCompletion
 ********************************************************************************
 *
 *
 */
NTSTATUS HumGetSetReportCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
{
    PURB urb = (PURB)Context;
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    if (NT_SUCCESS(Irp->IoStatus.Status)){
        /*
         *  Record the number of bytes written.
         */
        Irp->IoStatus.Information = (ULONG)urb->UrbBulkOrInterruptTransfer.TransferBufferLength;
    }

    ExFreePool(urb);

    /*
     *  If the lower driver returned PENDING, mark our stack location as
     *  pending also. This prevents the IRP's thread from being freed if
     *  the client's call returns pending.
     */
    if (Irp->PendingReturned){
        IoMarkIrpPending(Irp);
    }

    /*
     *  Balance the increment we did when we issued this IRP.
     */
    HumDecrementPendingRequestCount(deviceExtension);

    return STATUS_SUCCESS;
}


/*
 ********************************************************************************
 *  HumGetSetReport
 ********************************************************************************
 *
 *
 */
NTSTATUS HumGetSetReport(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, BOOLEAN *NeedsCompletion)
{
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    PDEVICE_EXTENSION DeviceExtension;
    PIO_STACK_LOCATION currentIrpStack, nextIrpStack;
    PHID_XFER_PACKET reportPacket;

    ULONG transferFlags;
    UCHAR request;
    USHORT value;

    PIO_STACK_LOCATION  irpSp;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode){
    case IOCTL_HID_GET_INPUT_REPORT:
        transferFlags = USBD_TRANSFER_DIRECTION_IN;
        request = 0x01;
        value = 0x0100;
        break;
    case IOCTL_HID_SET_OUTPUT_REPORT:
        transferFlags = USBD_TRANSFER_DIRECTION_OUT;
        request = 0x09;
        value = 0x0200;
        break;
    case IOCTL_HID_SET_FEATURE:
        transferFlags = USBD_TRANSFER_DIRECTION_OUT;
        request = 0x09;
        value = 0x0300;
        break;
    case IOCTL_HID_GET_FEATURE:
        transferFlags = USBD_TRANSFER_DIRECTION_IN;
        request = 0x01;
        value = 0x0300;
        break;
    default:
        DBGBREAK;
    }

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);
    currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    nextIrpStack = IoGetNextIrpStackLocation(Irp);

    reportPacket = Irp->UserBuffer;
    if (reportPacket && reportPacket->reportBuffer && reportPacket->reportBufferLen){
        PURB Urb = ExAllocatePoolWithTag(NonPagedPool, sizeof(URB), HIDUSB_TAG);

        if (Urb){

            RtlZeroMemory(Urb, sizeof( URB ));

            value += reportPacket->reportId;

            /*
             *   A control operation consists of 3 stages: setup, data, and status.
             *   In the setup stage the device receives an 8-byte frame comprised of
             *   the following fields of a _URB_CONTROL_VENDOR_OR_CLASS_REQUEST structure:
             *   See section 7.2 in the USB HID specification for how to fill out these fields.
             *
             *      UCHAR RequestTypeReservedBits;
             *      UCHAR Request;
             *      USHORT Value;
             *      USHORT Index;
             *
             */
            if (DeviceExtension->DeviceFlags & DEVICE_FLAGS_HID_1_0_D3_COMPAT_DEVICE) {
                HumBuildClassRequest(
                                        Urb,
                                        URB_FUNCTION_CLASS_ENDPOINT,
                                        transferFlags,
                                        reportPacket->reportBuffer,
                                        reportPacket->reportBufferLen,
                                        0x22, // requestType= Set_Report Request,
                                        request,
                                        value, // value= reportType 'report' &reportId,
                                        1,                  // index= endpoint 1,
                                        hidWritePacket->reportBufferLen    // reqLength (not used)
                                       );
            }
            else {
                HumBuildClassRequest(
                                        Urb,
                                        URB_FUNCTION_CLASS_INTERFACE,
                                        transferFlags,
                                        reportPacket->reportBuffer,
                                        reportPacket->reportBufferLen,
                                        0x22, // requestType= Set_Report Request,
                                        request,
                                        value, // value= reportType 'report' &reportId,
                                        DeviceExtension->Interface->InterfaceNumber, // index= interface,
                                        hidWritePacket->reportBufferLen    // reqLength (not used)
                                       );
            }

            IoSetCompletionRoutine(Irp, HumGetSetReportCompletion, Urb, TRUE, TRUE, TRUE);

            nextIrpStack->Parameters.Others.Argument1 = Urb;
            nextIrpStack->MajorFunction = currentIrpStack->MajorFunction;
            nextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;
            nextIrpStack->DeviceObject = GET_NEXT_DEVICE_OBJECT(DeviceObject);

            //
            // We need to keep track of the number of pending requests
            // so that we can make sure they're all cancelled properly during
            // processing of a stop device request.
            //

            if (NT_SUCCESS(HumIncrementPendingRequestCount( DeviceExtension )) ) {

                ntStatus = IoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);

                *NeedsCompletion = FALSE;

            } else {
                ExFreePool(Urb);

                ntStatus = STATUS_NO_SUCH_DEVICE;
            }

        }
        else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else {
        ntStatus = STATUS_DATA_ERROR;
    }

    return ntStatus;
}


/*
 ********************************************************************************
 *  HumGetMsGenreDescriptor
 ********************************************************************************
 *
 *
 */
NTSTATUS HumGetMsGenreDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp)
{
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION IrpStack;
    ULONG bufferSize;
    PDEVICE_EXTENSION DeviceExtension;

    PAGED_CODE();

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);
    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    DBGOUT(("Received request for genre descriptor in hidusb"))

    /*
     *  Check buffer size before trying to use Irp->MdlAddress.
     */
    bufferSize = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    if (bufferSize){

        PVOID buffer = HumGetSystemAddressForMdlSafe(Irp->MdlAddress);
        if (buffer){
            PURB Urb;

            //
            // Allocate Descriptor buffer
            //
            Urb = ExAllocatePoolWithTag(NonPagedPool,
                                        sizeof(struct _URB_OS_FEATURE_DESCRIPTOR_REQUEST),
                                        HIDUSB_TAG);
            if (!Urb){
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            RtlZeroMemory(Urb, sizeof(struct _URB_OS_FEATURE_DESCRIPTOR_REQUEST));

            RtlZeroMemory(buffer, bufferSize);
            HumBuildOsFeatureDescriptorRequest(Urb,
                              sizeof(struct _URB_OS_FEATURE_DESCRIPTOR_REQUEST),
                              DeviceExtension->Interface->InterfaceNumber,
                              MS_GENRE_DESCRIPTOR_INDEX,
                              buffer,
                              NULL,
                              bufferSize,
                              NULL);
            DBGOUT(("Sending os feature request to usbhub"))
            ntStatus = HumCallUSB(DeviceObject, Urb);
            if (NT_SUCCESS(ntStatus)){
                if (USBD_SUCCESS(Urb->UrbHeader.Status)){
                    DBGOUT(("Genre descriptor request successful!"))
                    Irp->IoStatus.Information = Urb->UrbOSFeatureDescriptorRequest.TransferBufferLength;
                    ntStatus = STATUS_SUCCESS;
                } else {
                    DBGOUT(("Genre descriptor request unsuccessful"))
                    ntStatus = STATUS_UNSUCCESSFUL;
                }
            }

            ExFreePool(Urb);
        }
        else {
            ntStatus = STATUS_INVALID_USER_BUFFER;
        }
    }
    else {
        ntStatus = STATUS_INVALID_USER_BUFFER;
    }

    return ntStatus;
}

NTSTATUS
HumSendIdleNotificationRequest(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    BOOLEAN *NeedsCompletion
    )
{
    PIO_STACK_LOCATION current, next;

    current = IoGetCurrentIrpStackLocation(Irp);
    next = IoGetNextIrpStackLocation(Irp);

    if (current->Parameters.DeviceIoControl.InputBufferLength < sizeof(HID_SUBMIT_IDLE_NOTIFICATION_CALLBACK_INFO)) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    ASSERT(sizeof(HID_SUBMIT_IDLE_NOTIFICATION_CALLBACK_INFO) == sizeof(USB_IDLE_CALLBACK_INFO));

    if (sizeof(HID_SUBMIT_IDLE_NOTIFICATION_CALLBACK_INFO) != sizeof(USB_IDLE_CALLBACK_INFO)) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    *NeedsCompletion = FALSE;
    next->MajorFunction = current->MajorFunction;
    next->Parameters.DeviceIoControl.InputBufferLength =
        current->Parameters.DeviceIoControl.InputBufferLength;
    next->Parameters.DeviceIoControl.Type3InputBuffer =
        current->Parameters.DeviceIoControl.Type3InputBuffer;
    next->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION;
    next->DeviceObject = GET_NEXT_DEVICE_OBJECT(DeviceObject);

    return IoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidusb\hidusb.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    hidusb.c

Abstract: Human Input Device (HID) minidriver for Universal Serial Bus (USB) devices

          The HID USB Minidriver (HUM, Hum) provides an abstraction layer for the
          HID Class so that future HID devices whic are not USB devices can be supported.

Author:

    Daniel Dean, Mercury Engineering.

Environment:

    Kernel mode

Revision History:


--*/
#include "pch.h"

#if DBG
    ULONG HIDUSB_DebugLevel = 0;    // 1 is lowest debug level
    BOOLEAN dbgTrapOnWarn = FALSE;
#endif 


NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING registryPath)
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    registryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    HID_MINIDRIVER_REGISTRATION hidMinidriverRegistration;

    DBGPRINT(1,("DriverEntry Enter"));

    DBGPRINT(1,("DriverObject (%lx)", DriverObject));

    
    //
    // Create dispatch points
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE]                  =
    DriverObject->MajorFunction[IRP_MJ_CLOSE]                   = HumCreateClose;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = HumInternalIoctl;
    DriverObject->MajorFunction[IRP_MJ_PNP]                     = HumPnP;
    DriverObject->MajorFunction[IRP_MJ_POWER]                   = HumPower;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]          = HumSystemControl;
    DriverObject->DriverExtension->AddDevice                    = HumAddDevice;
    DriverObject->DriverUnload                                  = HumUnload;


    //
    // Register USB layer with HID.SYS module
    //

    hidMinidriverRegistration.Revision              = HID_REVISION;
    hidMinidriverRegistration.DriverObject          = DriverObject;
    hidMinidriverRegistration.RegistryPath          = registryPath;
    hidMinidriverRegistration.DeviceExtensionSize   = sizeof(DEVICE_EXTENSION);

    /*
     *  HIDUSB is a minidriver for USB devices, which do not need to be polled.
     */
    hidMinidriverRegistration.DevicesArePolled      = FALSE;

    DBGPRINT(1,("DeviceExtensionSize = %x", hidMinidriverRegistration.DeviceExtensionSize));

    DBGPRINT(1,("Registering with HID.SYS"));

    ntStatus = HidRegisterMinidriver(&hidMinidriverRegistration);

    KeInitializeSpinLock(&resetWorkItemsListSpinLock);

    DBGPRINT(1,("DriverEntry Exit = %x", ntStatus));

    return ntStatus;
}


NTSTATUS HumCreateClose(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++

Routine Description:

   Process the Create and close IRPs sent to this device.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PIO_STACK_LOCATION   IrpStack;
    NTSTATUS             ntStatus = STATUS_SUCCESS;

    DBGPRINT(1,("HumCreateClose Enter"));

    DBGBREAK;

    //
    // Get a pointer to the current location in the Irp.
    //
    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    switch(IrpStack->MajorFunction)
    {
        case IRP_MJ_CREATE:
            DBGPRINT(1,("IRP_MJ_CREATE"));
            Irp->IoStatus.Information = 0;
            break;

        case IRP_MJ_CLOSE:
            DBGPRINT(1,("IRP_MJ_CLOSE"));
            Irp->IoStatus.Information = 0;
            break;

        default:
            DBGPRINT(1,("Invalid CreateClose Parameter"));
            ntStatus = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Save Status for return and complete Irp
    //

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(1,("HumCreateClose Exit = %x", ntStatus));

    return ntStatus;
}


NTSTATUS HumAddDevice(IN PDRIVER_OBJECT DriverObject, IN PDEVICE_OBJECT FunctionalDeviceObject)
/*++

Routine Description:

    Process the IRPs sent to this device.

Arguments:

    DeviceObject - pointer to a device object.

    PhysicalDeviceObject - pointer to a device object pointer created by the bus

Return Value:

    NT status code.

--*/
{
    NTSTATUS                ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION       deviceExtension;

    DBGPRINT(1,("HumAddDevice Entry"));

    deviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(FunctionalDeviceObject);

    deviceExtension->DeviceFlags = 0;
    
    deviceExtension->NumPendingRequests = 0;
    KeInitializeEvent( &deviceExtension->AllRequestsCompleteEvent,
                       NotificationEvent,
                       FALSE);

    deviceExtension->ResetWorkItem = NULL;
    deviceExtension->DeviceState = DEVICE_STATE_NONE;
    deviceExtension->functionalDeviceObject = FunctionalDeviceObject;

    DBGPRINT(1,("HumAddDevice Exit = %x", ntStatus));

    return ntStatus;
}



VOID HumUnload(IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Free all the allocated resources, etc.

Arguments:

    DriverObject - pointer to a driver object.

Return Value:

    VOID.

--*/
{
    DBGPRINT(1,("HumUnload Enter"));

    DBGPRINT(1,("Unloading DriverObject = %x", DriverObject));

    ASSERT (NULL == DriverObject->DeviceObject);

    DBGPRINT(1,("Unloading Exit = VOID"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidusb\ioctl.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ioctl.c

Abstract: Human Input Device (HID) minidriver for Universal Serial Bus (USB) devices

          The HID USB Minidriver (HUM, Hum) provides an abstraction layer for the
          HID Class so that future HID devices whic are not USB devices can be supported.

Author:
            forrestf
            ervinp
            jdunn

Environment:

    Kernel mode

Revision History:


--*/
#include "pch.h"


/*
 ************************************************************
 *  HumInternalIoctl
 ************************************************************
 *
 *
 *  Note: this function cannot be pageable because reads/writes
 *        can be made at dispatch-level.
 *
 *  Note:  this is an INTERNAL IOCTL handler, so no buffer
 *         validation is required.
 */
NTSTATUS HumInternalIoctl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    NTSTATUS            ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION   DeviceExtension;
    PIO_STACK_LOCATION  irpSp;
    BOOLEAN             NeedsCompletion = TRUE;

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode){

    case IOCTL_HID_GET_DEVICE_DESCRIPTOR:
        /*
         *  This IOCTL uses buffering method METHOD_NEITHER,
         *  so the buffer is Irp->UserBuffer.
         */
        ntStatus = HumGetHidDescriptor(DeviceObject, Irp);
        break;

    case IOCTL_HID_GET_REPORT_DESCRIPTOR:
        /*
         *  This IOCTL uses buffering method METHOD_NEITHER,
         *  so the buffer is Irp->UserBuffer.
         */
        ntStatus = HumGetReportDescriptor(DeviceObject, Irp, &NeedsCompletion);
        break;

    case IOCTL_HID_READ_REPORT:
        /*
         *  This IOCTL uses buffering method METHOD_NEITHER,
         *  so the buffer is Irp->UserBuffer.
         */
        ntStatus = HumReadReport(DeviceObject, Irp, &NeedsCompletion);
        break;

    case IOCTL_HID_WRITE_REPORT:
        /*
         *  This IOCTL uses buffering method METHOD_NEITHER,
         *  so the buffer is Irp->UserBuffer.
         */
        ntStatus = HumWriteReport (DeviceObject, Irp, &NeedsCompletion);
        break;

    case IOCTL_HID_GET_STRING:
        /*
         *  Get the friendly name for the device.
         *
         *  This IOCTL uses buffering method METHOD_NEITHER,
         *  so the buffer is Irp->UserBuffer.
         */
        ntStatus = HumGetStringDescriptor(DeviceObject, Irp);
        break;

    case IOCTL_HID_GET_INDEXED_STRING:
        ntStatus = HumGetStringDescriptor(DeviceObject, Irp);
        break;

    case IOCTL_HID_SET_FEATURE:
    case IOCTL_HID_GET_FEATURE:
    case IOCTL_HID_GET_INPUT_REPORT:
    case IOCTL_HID_SET_OUTPUT_REPORT:
        ntStatus = HumGetSetReport(DeviceObject, Irp, &NeedsCompletion);
        break;

    case IOCTL_HID_ACTIVATE_DEVICE:
    case IOCTL_HID_DEACTIVATE_DEVICE:
        /*
         *  We don't do anything for these IOCTLs but some minidrivers might.
         */
        ntStatus = STATUS_SUCCESS;
        break;

    case IOCTL_GET_PHYSICAL_DESCRIPTOR:
        /*
         *  This IOCTL gets information related to the human body part used
         *  to control a device control.
         */
        ntStatus = HumGetPhysicalDescriptor(DeviceObject, Irp, &NeedsCompletion);
        break;

    case IOCTL_HID_GET_DEVICE_ATTRIBUTES:
        /*
         *  This IOCTL uses buffering method METHOD_NEITHER,
         *  so the buffer is Irp->UserBuffer.
         *  If the IRP is coming to us from user space,
         *  we must validate the buffer.
         */
        ntStatus = HumGetDeviceAttributes(DeviceObject, Irp);
        break;

    case IOCTL_HID_GET_MS_GENRE_DESCRIPTOR:
        /*
         *  This IOCTL uses buffering method METHOD_NEITHER,
         *  so the buffer is Irp->UserBuffer.
         *  If the IRP is coming to us from user space,
         *  we must validate the buffer.
         */
        ntStatus = HumGetMsGenreDescriptor(DeviceObject, Irp);
        break;

    case IOCTL_HID_SEND_IDLE_NOTIFICATION_REQUEST:
        ntStatus = HumSendIdleNotificationRequest(DeviceObject, Irp, &NeedsCompletion);
        break;

    default:
        /*
         *  Note: do not return STATUS_NOT_SUPPORTED;
         *  Just keep the default status (this allows filter drivers to work).
         */
        ntStatus = Irp->IoStatus.Status;
        break;
    }

    /*
     *  Complete the IRP only if we did not pass it to a lower driver.
     */
    if (NeedsCompletion) {
        ASSERT(ntStatus != STATUS_PENDING);
        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidusb\sysctrl.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    sysctrl.c

Abstract: Human Input Device (HID) minidriver for Universal Serial Bus (USB) devices

          The HID USB Minidriver (HUM, Hum) provides an abstraction layer for the
          HID Class so that future HID devices whic are not USB devices can be supported.

Author:
            ervinp

Environment:

    Kernel mode

Revision History:


--*/
#include "pch.h"


#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, HumSystemControl)
#endif


/*
 ************************************************************
 *  HumSystemControl
 ************************************************************
 *
 */
NTSTATUS HumSystemControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    NTSTATUS            status = STATUS_SUCCESS;
    PIO_STACK_LOCATION  thisStackLoc;

    PAGED_CODE();

    thisStackLoc = IoGetCurrentIrpStackLocation(Irp);

    switch(thisStackLoc->Parameters.DeviceIoControl.IoControlCode){

        default:
            /*
             *  Note: do not return STATUS_NOT_SUPPORTED;
             *  If completing the IRP here,
             *  just keep the default status 
             *  (this allows filter drivers to work).
             */
            status = Irp->IoStatus.Status;
            break;
    }


    IoCopyCurrentIrpStackLocationToNext(Irp);

    status = IoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidusb\hidusb.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    hidusb.h

Abstract:


Author:

    Daniel Dean.

Environment:

    Kernel & user mode

Revision History:



--*/
#ifndef __HIDUSB_H__
#define __HIDUSB_H__


#include <PSHPACK1.H>

typedef struct _USB_HID_DESCRIPTOR
{
    UCHAR   bLength;
    UCHAR   bDescriptorType;
    USHORT  bcdHID;
    UCHAR   bCountry;
    UCHAR   bNumDescriptors;
    UCHAR   bReportType;
    USHORT  wReportLength;

} USB_HID_DESCRIPTOR, * PUSB_HID_DESCRIPTOR;

#include <POPPACK.H>


//
// Device Class Constants for HID
//
#define HID_GET_REPORT      0x01
#define HID_GET_IDLE        0x02
#define HID_GET_PROTOCOL    0x03

#define HID_SET_REPORT      0x09
#define HID_SET_IDLE        0x0A
#define HID_SET_PROTOCOL    0x0B

//
// USB Constants that should be defined in a USB header...
//
#define USB_INTERFACE_CLASS_HID     0x03

#define USB_DESCRIPTOR_TYPE_HID         0x21

typedef struct _DEVICE_EXTENSION
{
    ULONG                           DeviceState;

    PUSB_DEVICE_DESCRIPTOR          DeviceDescriptor;

    PUSBD_INTERFACE_INFORMATION     Interface;
    USBD_CONFIGURATION_HANDLE       ConfigurationHandle;

    LONG                            NumPendingRequests;
    KEVENT                          AllRequestsCompleteEvent;

    ULONG                           DeviceFlags;

    PIO_WORKITEM                    ResetWorkItem;
    USB_HID_DESCRIPTOR              HidDescriptor;

    PDEVICE_OBJECT                  functionalDeviceObject;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


/*
 *  This structure is used to pass information to the
 *  resetWorkItem callback.
 */
typedef struct tag_resetWorkItemContext {
                    #define RESET_WORK_ITEM_CONTEXT_SIG 'tesR'
                    ULONG sig;
                    PIO_WORKITEM ioWorkItem;
                    PDEVICE_OBJECT deviceObject;
                    PIRP irpToComplete;

                    struct tag_resetWorkItemContext *next;
} resetWorkItemContext;

#define DEVICE_STATE_NONE           0
#define DEVICE_STATE_STARTING       1
#define DEVICE_STATE_RUNNING        2
#define DEVICE_STATE_STOPPING       3
#define DEVICE_STATE_STOPPED        4
#define DEVICE_STATE_REMOVING       5
#define DEVICE_STATE_START_FAILED   6

#define DEVICE_FLAGS_HID_1_0_D3_COMPAT_DEVICE   0x00000001

//
// Interface slection options
//
#define HUM_SELECT_DEFAULT_INTERFACE    0
#define HUM_SELECT_SPECIFIED_INTERFACE  1

//
// Device Extension Macros
//

#define GET_MINIDRIVER_DEVICE_EXTENSION(DO) ((PDEVICE_EXTENSION) (((PHID_DEVICE_EXTENSION)(DO)->DeviceExtension)->MiniDeviceExtension))

#define GET_HIDCLASS_DEVICE_EXTENSION(DO) ((PHID_DEVICE_EXTENSION)(DO)->DeviceExtension)

#define GET_NEXT_DEVICE_OBJECT(DO) (((PHID_DEVICE_EXTENSION)(DO)->DeviceExtension)->NextDeviceObject)


#if DBG
    extern ULONG HIDUSB_DebugLevel;
    extern BOOLEAN dbgTrapOnWarn;

    #define DBGBREAK                                        \
        {                                               \
            DbgPrint("'HIDUSB> Code coverage trap: file %s, line %d \n",  __FILE__, __LINE__ ); \
            DbgBreakPoint();                            \
        }
    #define DBGWARN(args_in_parens)                                \
        {                                               \
            DbgPrint("'HIDUSB> *** WARNING *** (file %s, line %d)\n", __FILE__, __LINE__ ); \
            DbgPrint("'    > "); \
            DbgPrint args_in_parens; \
            DbgPrint("\n"); \
            if (dbgTrapOnWarn){ \
                DbgBreakPoint();                            \
            } \
        }
    #define DBGERR(args_in_parens)                                \
        {                                               \
            DbgPrint("'HIDUSB> *** ERROR *** (file %s, line %d)\n", __FILE__, __LINE__ ); \
            DbgPrint("'    > "); \
            DbgPrint args_in_parens; \
            DbgPrint("\n"); \
            DbgBreakPoint();                            \
        }
    #define DBGOUT(args_in_parens)                                \
        {                                               \
            DbgPrint("'HIDUSB> "); \
            DbgPrint args_in_parens; \
            DbgPrint("\n"); \
        }
    #define DBGPRINT(lvl, args_in_parens) \
                if (lvl <= HIDUSB_DebugLevel){ \
                    DBGOUT(args_in_parens); \
                }
#else // DBG
    #define DBGPRINT(lvl, arg)
    #define DBGBREAK
    #define DBGWARN(args_in_parens)
    #define DBGERR(args_in_parens)
    #define DBGOUT(args_in_parens)
#endif // DBG



#define HumBuildGetDescriptorRequest(urb, \
                                     function, \
                                     length, \
                                     descriptorType, \
                                     index, \
                                     languageId, \
                                     transferBuffer, \
                                     transferBufferMDL, \
                                     transferBufferLength, \
                                     link) { \
            (urb)->UrbHeader.Function =  (function); \
            (urb)->UrbHeader.Length = (length); \
            (urb)->UrbControlDescriptorRequest.TransferBufferLength = (transferBufferLength); \
            (urb)->UrbControlDescriptorRequest.TransferBufferMDL = (transferBufferMDL); \
            (urb)->UrbControlDescriptorRequest.TransferBuffer = (transferBuffer); \
            (urb)->UrbControlDescriptorRequest.DescriptorType = (descriptorType); \
            (urb)->UrbControlDescriptorRequest.Index = (index); \
            (urb)->UrbControlDescriptorRequest.LanguageId = (languageId); \
            (urb)->UrbControlDescriptorRequest.UrbLink = (link); }


#define HumBuildClassRequest(urb, \
                                       function, \
                                       transferFlags, \
                                       transferBuffer, \
                                       transferBufferLength, \
                                       requestType, \
                                       request, \
                                       value, \
                                       index, \
                                       reqLength){ \
            (urb)->UrbHeader.Length = (USHORT) sizeof( struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST); \
            (urb)->UrbHeader.Function = function; \
            (urb)->UrbControlVendorClassRequest.Index = (index); \
            (urb)->UrbControlVendorClassRequest.RequestTypeReservedBits = (requestType); \
            (urb)->UrbControlVendorClassRequest.Request = (request); \
            (urb)->UrbControlVendorClassRequest.Value = (value); \
            (urb)->UrbControlVendorClassRequest.TransferFlags = (transferFlags); \
            (urb)->UrbControlVendorClassRequest.TransferBuffer = (transferBuffer); \
            (urb)->UrbControlVendorClassRequest.TransferBufferLength = (transferBufferLength); }

#define HumBuildSelectConfigurationRequest(urb, \
                                         length, \
                                         configurationDescriptor) { \
            (urb)->UrbHeader.Function =  URB_FUNCTION_SELECT_CONFIGURATION; \
            (urb)->UrbHeader.Length = (length); \
            (urb)->UrbSelectConfiguration.ConfigurationDescriptor = (configurationDescriptor);    }

#define HumBuildOsFeatureDescriptorRequest(urb, \
                              length, \
                              interface, \
                              index, \
                              transferBuffer, \
                              transferBufferMDL, \
                              transferBufferLength, \
                              link) { \
            (urb)->UrbHeader.Function = URB_FUNCTION_GET_MS_FEATURE_DESCRIPTOR; \
            (urb)->UrbHeader.Length = (length); \
            (urb)->UrbOSFeatureDescriptorRequest.Recipient = 1; \
            (urb)->UrbOSFeatureDescriptorRequest.TransferBufferLength = (transferBufferLength); \
            (urb)->UrbOSFeatureDescriptorRequest.TransferBufferMDL = (transferBufferMDL); \
            (urb)->UrbOSFeatureDescriptorRequest.TransferBuffer = (transferBuffer); \
            (urb)->UrbOSFeatureDescriptorRequest.InterfaceNumber = (interface); \
            (urb)->UrbOSFeatureDescriptorRequest.MS_FeatureDescriptorIndex = (index); \
            (urb)->UrbOSFeatureDescriptorRequest.UrbLink = (link); }

#define BAD_POINTER ((PVOID)0xFFFFFFFE)

/*
 *  HIDUSB signature tag for memory allocations
 */
#define HIDUSB_TAG (ULONG)'UdiH'

//
// Function prototypes
//

NTSTATUS    DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING registryPath);
NTSTATUS    HumAbortPendingRequests(IN PDEVICE_OBJECT DeviceObject);
NTSTATUS    HumCreateClose(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    HumInternalIoctl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    HumPnP(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    HumPower(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    HumCreateDevice(IN PDRIVER_OBJECT DriverObject, IN OUT PDEVICE_OBJECT *DeviceObject);
NTSTATUS    HumAddDevice(IN PDRIVER_OBJECT DriverObject, IN PDEVICE_OBJECT FunctionalDeviceObject);
NTSTATUS    HumStartDevice(IN PDEVICE_OBJECT DeviceObject);
NTSTATUS    HumPnpCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);
NTSTATUS    HumInitDevice(IN PDEVICE_OBJECT DeviceObject);
NTSTATUS    HumStopDevice(IN PDEVICE_OBJECT DeviceObject);
NTSTATUS    HumRemoveDevice(IN PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS    HumCallUSB(IN PDEVICE_OBJECT DeviceObject, IN PURB Urb);
VOID        HumUnload(IN PDRIVER_OBJECT DriverObject);
NTSTATUS    HumGetHidDescriptor(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    HumGetReportDescriptor(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, BOOLEAN *NeedsCompletion);
NTSTATUS    HumReadReport(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, OUT BOOLEAN *NeedsCompletion);
NTSTATUS    HumReadCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);
NTSTATUS    HumWriteReport(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, OUT BOOLEAN *NeedsCompletion);
NTSTATUS    HumGetSetReport(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, OUT BOOLEAN *NeedsCompletion);
NTSTATUS    HumWriteCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);
NTSTATUS    HumGetString(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, OUT BOOLEAN *NeedsCompletion);
NTSTATUS    HumGetDeviceAttributes(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    HumGetDescriptorRequest(IN PDEVICE_OBJECT DeviceObject, IN USHORT Function, IN ULONG DescriptorType, IN OUT PVOID *Descriptor, IN OUT ULONG *DescSize, IN ULONG TypeSize, IN ULONG Index, IN ULONG LangID);
NTSTATUS    HumSetIdle(IN PDEVICE_OBJECT DeviceObject);
NTSTATUS    HumSelectConfiguration(IN PDEVICE_OBJECT DeviceObject, IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor);
NTSTATUS    HumParseHidInterface(IN PDEVICE_EXTENSION DeviceExtension, IN PUSB_INTERFACE_DESCRIPTOR InterfaceDesc, IN ULONG InterfaceLength, OUT PUSB_HID_DESCRIPTOR *HidDescriptor);
NTSTATUS    HumGetDeviceDescriptor(IN PDEVICE_OBJECT, IN PDEVICE_EXTENSION);
NTSTATUS    HumGetConfigDescriptor(IN PDEVICE_OBJECT DeviceObject, OUT PUSB_CONFIGURATION_DESCRIPTOR *ConfigurationDesc, OUT PULONG ConfigurationDescLength);
NTSTATUS    HumGetHidInfo(IN PDEVICE_OBJECT DeviceObject, IN PUSB_CONFIGURATION_DESCRIPTOR ConfigDesc, IN ULONG DescriptorLength);
NTSTATUS    DumpConfigDescriptor(IN PUSB_CONFIGURATION_DESCRIPTOR ConfigDesc, IN ULONG DescriptorLength);
VOID        HumDecrementPendingRequestCount(IN PDEVICE_EXTENSION DeviceExtension);
NTSTATUS    HumIncrementPendingRequestCount(IN PDEVICE_EXTENSION DeviceExtension);
NTSTATUS    HumResetWorkItem(IN PDEVICE_OBJECT deviceObject, IN PVOID Context);
NTSTATUS    HumResetParentPort(IN PDEVICE_OBJECT DeviceObject);
NTSTATUS    HumGetPortStatus(IN PDEVICE_OBJECT DeviceObject, IN PULONG PortStatus);
NTSTATUS    HumResetInterruptPipe(IN PDEVICE_OBJECT DeviceObject);
NTSTATUS    HumSystemControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    HumGetStringDescriptor(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    HumGetPhysicalDescriptor(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, BOOLEAN *NeedsCompletion);
NTSTATUS    HumGetMsGenreDescriptor(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    HumSendIdleNotificationRequest(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, BOOLEAN *NeedsCompletion);
NTSTATUS    HumQueueResetWorkItem(PDEVICE_OBJECT DeviceObject, PIRP Irp);

extern KSPIN_LOCK resetWorkItemsListSpinLock;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidusb\pnp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pnp.c

Abstract: Human Input Device (HID) minidriver for Universal Serial Bus (USB) devices

          The HID USB Minidriver (HUM, Hum) provides an abstraction layer for the
          HID Class so that future HID devices whic are not USB devices can be supported.

Author:

Environment:

    Kernel mode

Revision History:


--*/
#include "pch.h"

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, HumPnP)
    #pragma alloc_text(PAGE, HumStartDevice)
    #pragma alloc_text(PAGE, HumStopDevice)
    #pragma alloc_text(PAGE, HumRemoveDevice)
    #pragma alloc_text(PAGE, HumAbortPendingRequests)
#endif


/*
 ************************************************************
 *  HumPnP
 ************************************************************
 *
 *  Process PnP IRPs sent to this device.
 *
 */
NTSTATUS HumPnP(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_EXTENSION DeviceExtension;
    KEVENT event;

    PAGED_CODE();

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);
    irpSp = IoGetCurrentIrpStackLocation (Irp);

    switch(irpSp->MinorFunction){

    case IRP_MN_START_DEVICE:
        ntStatus = HumStartDevice(DeviceObject);
        break;

    case IRP_MN_STOP_DEVICE:
        if (DeviceExtension->DeviceState == DEVICE_STATE_RUNNING) {
            ntStatus = HumStopDevice(DeviceObject);
        } else {
            ntStatus = STATUS_SUCCESS;
        }
        break;

    case IRP_MN_REMOVE_DEVICE:
        return HumRemoveDevice(DeviceObject, Irp);
        break;
    }
    
    if (NT_SUCCESS(ntStatus)){
        /*
         *  Our processing has succeeded.
         *  So pass this IRP down to the next driver.
         */

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp,
                               HumPnpCompletion,
                               &event,    // context
                               TRUE,                       
                               TRUE,
                               TRUE );                     
        ntStatus = IoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);
     
        if (ntStatus == STATUS_PENDING) {
           // wait for it...
           KeWaitForSingleObject(&event, 
                                 Executive, 
                                 KernelMode, 
                                 FALSE,
                                 NULL);
        }
        
        ntStatus = Irp->IoStatus.Status;
    
        switch(irpSp->MinorFunction) {
        case IRP_MN_START_DEVICE:
            if (NT_SUCCESS(ntStatus)) {
                DeviceExtension->DeviceState = DEVICE_STATE_RUNNING;

                ntStatus = HumInitDevice(DeviceObject);

                if (!NT_SUCCESS(ntStatus)) {
                    DBGWARN(("HumInitDevice failed; failing IRP_MN_START_DEVICE."));
                    DeviceExtension->DeviceState = DEVICE_STATE_START_FAILED;
                    Irp->IoStatus.Status = ntStatus;
                }
            }
            else {
                DBGWARN(("Pdo failed start irp with status %x", ntStatus));
                DeviceExtension->DeviceState = DEVICE_STATE_START_FAILED;
            }
            break;

        case IRP_MN_STOP_DEVICE:

            DeviceExtension->DeviceState = DEVICE_STATE_STOPPED;

            /*
             *  Release resources
             */
            if (DeviceExtension->Interface) {
                ExFreePool(DeviceExtension->Interface);
                DeviceExtension->Interface = NULL;
            }
            if (DeviceExtension->DeviceDescriptor) {
                ExFreePool(DeviceExtension->DeviceDescriptor);
                DeviceExtension->DeviceDescriptor = NULL;
            }
            break;

        case IRP_MN_QUERY_CAPABILITIES:
            /*
             *  The lower driver set the capabilities flags for this device.
             *  Since all USB devices are hot-unpluggable,
             *  add the SurpriseRemovalOK bit.
             */
            if (NT_SUCCESS(ntStatus)){
                irpSp->Parameters.DeviceCapabilities.Capabilities->SurpriseRemovalOK = TRUE;
            }
            break;
        }
    } else {
        DBGWARN(("A PnP irp is going to be failed. Status = %x.", ntStatus));
    }
    
    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return ntStatus;
}



NTSTATUS HumPowerCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
{
    NTSTATUS status;
   
    ASSERT(DeviceObject);

    status = Irp->IoStatus.Status;

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    if (NT_SUCCESS(status)){
        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

        switch (irpSp->MinorFunction){

        case IRP_MN_SET_POWER:

            switch (irpSp->Parameters.Power.Type){
            case DevicePowerState:
                switch (irpSp->Parameters.Power.State.DeviceState) {
                case PowerDeviceD0:
                    /*
                     *  We just resumed from SUSPEND.
                     *  Send down a SET_IDLE to prevent keyboards
                     *  from chattering after the resume.
                     */
                    status = HumSetIdle(DeviceObject);
/*                    if (!NT_SUCCESS(status)){
                        DBGWARN(("HumPowerCompletion: SET_IDLE failed with %xh (only matters for keyboard).", status));
                    }*/
                    break;
                }
                break;
            }

            break;
        }
    }

    return STATUS_SUCCESS;
}


/*
 ************************************************************
 *  HumPower 
 ************************************************************
 *
 *  Process Power IRPs sent to this device.
 *
 */
NTSTATUS HumPower(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    NTSTATUS status;

    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp, HumPowerCompletion, NULL, TRUE, TRUE, TRUE);
    status = PoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);

    return status;
}


/*
 ************************************************************
 *  HumStartDevice
 ************************************************************
 *
 *  Initializes a given instance of the UTB device on the USB.
 *
 */
NTSTATUS HumStartDevice(IN PDEVICE_OBJECT DeviceObject)
{
    PDEVICE_EXTENSION DeviceExtension;
    ULONG oldDeviceState;
    PAGED_CODE();

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    oldDeviceState = DeviceExtension->DeviceState;
    DeviceExtension->DeviceState = DEVICE_STATE_STARTING;

    /*
     *  We may have been previously stopped, in which case the AllRequestsCompleteEvent
     *  is still in the signalled state.  It's very important that we reset it to
     *  the non-signalled state so that we wait on it properly on the next stop/remove.
     */
    KeResetEvent(&DeviceExtension->AllRequestsCompleteEvent);

    ASSERT(oldDeviceState != DEVICE_STATE_REMOVING);

    if ((oldDeviceState == DEVICE_STATE_STOPPING) ||
        (oldDeviceState == DEVICE_STATE_STOPPED)  ||
        (oldDeviceState == DEVICE_STATE_REMOVING)){

        /*
         *  We did an extra decrement when the device was stopped.
         *  Now that we're restarting, we need to bump it back to zero.
         */
        NTSTATUS incStat = HumIncrementPendingRequestCount(DeviceExtension);
        ASSERT(NT_SUCCESS(incStat));
        ASSERT(DeviceExtension->NumPendingRequests == 0);
        DBGWARN(("Got start-after-stop; re-incremented pendingRequestCount"));
    }

    DeviceExtension->Interface = NULL;

    return STATUS_SUCCESS;
}




/*
 ************************************************************
 *  HumInitDevice 
 ************************************************************
 *
 *   Get the device information and attempt to initialize a configuration
 *   for a device.  If we cannot identify this as a valid HID device or
 *   configure the device, our start device function is failed.
 *
 *   Note:  This function is called from the PnP completion routine,
 *          so it cannot be pageable.
 */
NTSTATUS HumInitDevice(IN PDEVICE_OBJECT DeviceObject)
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION   DeviceExtension;
    PUSB_CONFIGURATION_DESCRIPTOR ConfigDesc = NULL;
    ULONG DescriptorLength;

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    /*
     *  Get the Device descriptor and store it in the device extension
     */
    ntStatus = HumGetDeviceDescriptor(DeviceObject, DeviceExtension);
    if (NT_SUCCESS(ntStatus)){

        /*
         *  Get config descriptor
         */
        ntStatus = HumGetConfigDescriptor(DeviceObject, &ConfigDesc, &DescriptorLength);
        if (NT_SUCCESS(ntStatus)) {

            ASSERT(ConfigDesc);

            #if DBG
                // NOTE:    This debug function is currently confused
                //          by power descriptors.  Restore when fixed.
                // DumpConfigDescriptor(ConfigDesc, DescriptorLength);
            #endif

            ntStatus = HumGetHidInfo(DeviceObject, ConfigDesc, DescriptorLength);
            if (NT_SUCCESS(ntStatus)) {

                ntStatus = HumSelectConfiguration(DeviceObject, ConfigDesc);
                if (NT_SUCCESS(ntStatus)) {
                    HumSetIdle(DeviceObject);
                }
            }

            ExFreePool(ConfigDesc);
        }

    }

    return ntStatus;
}


/*
 ************************************************************
 *  HumStopDevice
 ************************************************************
 *
 *  Stops a given instance of a device on the USB.
 *
 */
NTSTATUS HumStopDevice(IN PDEVICE_OBJECT DeviceObject)
{
    PURB        Urb;
    ULONG       Size;
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION DeviceExtension;

    PAGED_CODE();

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);
    DeviceExtension->DeviceState = DEVICE_STATE_STOPPING;

    /*
     *  Abort all pending IO on the device.
     *  We do an extra decrement here, which causes the
     *  NumPendingRequests to eventually go to -1, which causes
     *  AllRequestsCompleteEvent to get set.
     *  NumPendingRequests will get reset to 0 when we re-start.
     */
    HumAbortPendingRequests(DeviceObject);
    HumDecrementPendingRequestCount(DeviceExtension);
    KeWaitForSingleObject( &DeviceExtension->AllRequestsCompleteEvent,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );

    /*
     *  Submit an open configuration Urb to the USB stack
     *  (with a NULL pointer for the configuration handle).
     */
    Size = sizeof(struct _URB_SELECT_CONFIGURATION);
    Urb = ExAllocatePoolWithTag(NonPagedPool, Size, HIDUSB_TAG);
    if (Urb){
        UsbBuildSelectConfigurationRequest(Urb, (USHORT) Size, NULL);

        ntStatus = HumCallUSB(DeviceObject, Urb);
        ASSERT(NT_SUCCESS(ntStatus));

        ExFreePool(Urb);
    } 
    else {
        ntStatus = STATUS_UNSUCCESSFUL;
    }

    if (!NT_SUCCESS(ntStatus)){
        /*
         *  We will not pass this IRP down, 
         *  so our completion routine will not set the device's
         *  state to DEVICE_STATE_STOPPED; so set it here.
         */
        ASSERT(NT_SUCCESS(ntStatus));
        DeviceExtension->DeviceState = DEVICE_STATE_STOPPED;
    }

    return ntStatus;
}



/*
 ************************************************************
 *  HumAbortPendingRequests
 ************************************************************
 *
 *
 */
NTSTATUS HumAbortPendingRequests(IN PDEVICE_OBJECT DeviceObject)
{
    PDEVICE_EXTENSION deviceExtension;
    PURB urb;
    PVOID pipeHandle;
    ULONG urbSize;
    NTSTATUS status;

    PAGED_CODE();

    deviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION( DeviceObject );

    /*
     *  Create and send down an abort pipe request.
     */
    urbSize = sizeof(struct _URB_PIPE_REQUEST);
    urb = ExAllocatePoolWithTag(NonPagedPool, urbSize, HIDUSB_TAG);
    if (urb){
   
        if (deviceExtension->Interface &&
            (deviceExtension->Interface->NumberOfPipes != 0)){

            pipeHandle = deviceExtension->Interface->Pipes[0].PipeHandle;
            if (pipeHandle) {
                urb->UrbHeader.Length = (USHORT)urbSize;
                urb->UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;
                urb->UrbPipeRequest.PipeHandle = pipeHandle;

                status = HumCallUSB(DeviceObject, urb);
                if (!NT_SUCCESS(status)){
                    DBGWARN(("URB_FUNCTION_ABORT_PIPE returned %xh in HumAbortPendingRequests", status));
                }
            }
            else {
                ASSERT(pipeHandle);
                status = STATUS_NO_SUCH_DEVICE;
            }
        }
        else {
            DBGERR(("No such device in HumAbortPendingRequests"));
            status = STATUS_NO_SUCH_DEVICE;
        }

        ExFreePool(urb);
    }
    else {
        ASSERT(urb);
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}


/*
 ************************************************************
 *  HumPnpCompletion
 ************************************************************
 *
 */
NTSTATUS HumPnpCompletion(  IN PDEVICE_OBJECT DeviceObject,
                            IN PIRP           Irp,
                            IN PVOID          Context)
{
    UNREFERENCED_PARAMETER (DeviceObject);

    if (Irp->PendingReturned) {
        IoMarkIrpPending( Irp );
    }

    KeSetEvent ((PKEVENT) Context, 1, FALSE);
    // No special priority
    // No Wait

    return STATUS_MORE_PROCESSING_REQUIRED; // Keep this IRP
}


/*
 ************************************************************
 *  HumRemoveDevice
 ************************************************************
 *
 *  Removes a given instance of a device on the USB.
 *
 */
NTSTATUS HumRemoveDevice(IN PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION DeviceExtension;
    ULONG oldDeviceState;

    PAGED_CODE();

    //
    // Get a pointer to the device extension
    //

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    //
    //  Set device state, this prevents new IOs from starting
    //

    oldDeviceState = DeviceExtension->DeviceState;
    DeviceExtension->DeviceState = DEVICE_STATE_REMOVING;


    /*
     *  Note: RemoveDevice does an extra decrement, so we complete 
     *        the REMOVE IRP on the transition to -1, whether this 
     *        happens in RemoveDevice itself or subsequently while
     *        RemoveDevice is waiting for this event to fire.
     */
    if ((oldDeviceState == DEVICE_STATE_STOPPING) || 
        (oldDeviceState == DEVICE_STATE_STOPPED)){
        /*
         *  HumStopDevice did the extra decrement and aborted the 
         *  pending requests.
         */
    }
    else {
        HumDecrementPendingRequestCount(DeviceExtension);
    }

    //
    // Cancel any outstanding IRPs if the device was running
    //
    if (oldDeviceState == DEVICE_STATE_RUNNING){
        HumAbortPendingRequests(DeviceObject);
    } 
    else if (oldDeviceState == DEVICE_STATE_STOPPING){
        ASSERT(!(PVOID)"PnP IRPs are not synchronized! -- got REMOVE_DEVICE before STOP_DEVICE completed!");
    }

    KeWaitForSingleObject( &DeviceExtension->AllRequestsCompleteEvent,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );

    ASSERT(DeviceExtension->NumPendingRequests == -1);

    //
    // Fire and forget
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);

    //
    //  Release any resources
    //

    if (DeviceExtension->Interface) {
        ExFreePool(DeviceExtension->Interface);
        DeviceExtension->Interface = NULL;
    }
    
    if (DeviceExtension->DeviceDescriptor) {
        ExFreePool(DeviceExtension->DeviceDescriptor);
        DeviceExtension->DeviceDescriptor = NULL;
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\inc\hidtoken.h ===
/*++

Copyright (c) 1996      Microsoft Corporation

Module Name:

        HIDPI.H

Abstract:

   Public Definitions of HID USAGES.

Environment:

    Kernel & user mode

Revision History:

    Aug-1996 : created Kenneth D. Ray

--*/

#ifndef _HIDTOKEN_H
#define _HIDTOKEN_H

#define HIDP_ITEM_LONG           0xFE
#define HIDP_ITEM_LENGTH_DATA    0x03

#define HIDP_IS_MAIN_ITEM(item)  (((item) & 0xC) == 0x0)
#define HIDP_IS_GLOBAL_ITEM(item) (((item) & 0xC) == 0x4)
#define HIDP_IS_LOCAL_ITEM(item)  (((item) & 0xC) == 0x8)
#define HIDP_IS_RESERVED_ITEM(item) (((item) & 0xC) == 0xC)

// Main Items
// Only main items with one byte data (bSize = 1) are supported.
#define HIDP_MAIN_INPUT_1        0x81
#define HIDP_MAIN_INPUT_2        0x82
#define HIDP_MAIN_OUTPUT_1       0x91
#define HIDP_MAIN_OUTPUT_2       0x92
#define HIDP_MAIN_FEATURE_1      0xB1
#define HIDP_MAIN_FEATURE_2      0xB2
#define HIDP_MAIN_COLLECTION     0xA1
#define HIDP_MAIN_ENDCOLLECTION  0xC0
#define HIDP_ISMAIN(x) (0 == ((x) & 0x0C))
#define HIDP_MAIN_COLLECTION_LINK 0x00
#define HIDP_MAIN_COLLECTION_APP  0x01

// Global Items
#define HIDP_GLOBAL_USAGE_PAGE_1   0x05  // UsagePage of 1 byte
#define HIDP_GLOBAL_USAGE_PAGE_2   0x06  // UsagePage of 2 bytes
#define HIDP_GLOBAL_USAGE_PAGE_4   0x07  // UsagePage of 4 bytes
#define HIDP_GLOBAL_LOG_MIN_1      0x15  // minimum value of size 1 byte.
#define HIDP_GLOBAL_LOG_MIN_2      0x16  // minimum value of size 2 bytes.
#define HIDP_GLOBAL_LOG_MIN_4      0x17  // minimum value of size 4 bytes.
#define HIDP_GLOBAL_LOG_MAX_1      0X25  // maximum of size 1 byte.
#define HIDP_GLOBAL_LOG_MAX_2      0X26  // maximum of size 2 bytes.
#define HIDP_GLOBAL_LOG_MAX_4      0X27  // maximum of size 4 bytes.

#define HIDP_GLOBAL_PHY_MIN_1      0x35  // minimum value of size 1 byte.
#define HIDP_GLOBAL_PHY_MIN_2      0x36  // minimum value of size 2 bytes.
#define HIDP_GLOBAL_PHY_MIN_4      0x37  // minimum value of size 4 bytes.
#define HIDP_GLOBAL_PHY_MAX_1      0X45  // maximum of size 1 byte.
#define HIDP_GLOBAL_PHY_MAX_2      0X46  // maximum of size 2 bytes.
#define HIDP_GLOBAL_PHY_MAX_4      0X47  // maximum of size 4 bytes.

#define HIDP_GLOBAL_UNIT_EXP_1     0x55  // Exponent of size 1 byte.
#define HIDP_GLOBAL_UNIT_EXP_2     0x56  // Exponent of size 2 bytes.
#define HIDP_GLOBAL_UNIT_EXP_4     0x57  // Exponent of size 4 bytes.
#define HIDP_GLOBAL_UNIT_1         0x65  // UNIT of size 1 byte.
#define HIDP_GLOBAL_UNIT_2         0x66  // UNIT of size 2 bytes.
#define HIDP_GLOBAL_UNIT_4         0x67  // UNIT of size 4 bytes.

#define HIDP_GLOBAL_REPORT_SIZE    0x75  // Report size in bits
#define HIDP_GLOBAL_REPORT_ID      0x85  // ID only size 1 byte supported
#define HIDP_GLOBAL_REPORT_COUNT_1 0x95  // Number of data fields 1 byte
#define HIDP_GLOBAL_REPORT_COUNT_2 0x96  // Number of data fields 2 bytes
#define HIDP_GLOBAL_PUSH           0xA4  // The dreaded PUSH command
#define HIDP_GLOBAL_POP            0xB4  // And the dreaded POP command

// Local Items
#define HIDP_LOCAL_USAGE_1         0x09  //
#define HIDP_LOCAL_USAGE_2         0x0A  //
#define HIDP_LOCAL_USAGE_4         0x0B  //
#define HIDP_LOCAL_USAGE_MIN_1     0x19
#define HIDP_LOCAL_USAGE_MIN_2     0x1A
#define HIDP_LOCAL_USAGE_MIN_4     0x1B
#define HIDP_LOCAL_USAGE_MAX_1     0x29
#define HIDP_LOCAL_USAGE_MAX_2     0x2A
#define HIDP_LOCAL_USAGE_MAX_4     0x2B
#define HIDP_LOCAL_DESIG_INDEX     0x39  // Designators of byte size supported
#define HIDP_LOCAL_DESIG_MIN       0x49
#define HIDP_LOCAL_DESIG_MAX       0x59
#define HIDP_LOCAL_STRING_INDEX    0x79  // String indices of size byte supported
#define HIDP_LOCAL_STRING_MIN      0x89
#define HIDP_LOCAL_STRING_MAX      0x99
#define HIDP_LOCAL_DELIMITER       0xA9

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\inc\bluescrn.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    bluescrn.h

Abstract

    Private IOCTL definition for keyboard driver to use during blue screen

Author:

    Darryl Richman

Environment:

    Kernel mode only

Revision History:


--*/

#ifndef __BLUESCRN_H__
#define __BLUESCRN_H__

#include <hidclass.h>

#define IOCTL_INTERNAL_HID_SET_BLUESCREEN                   HID_IN_CTL_CODE(99)

    // Blue Screen definitions

typedef VOID (t_BluescreenFunction)(PVOID Context, PCHAR Buffer);

    // Blue Screen IOCTL struct
typedef struct _BlueScreen {
    PVOID Context;                          // Context to pass to processing routine
    t_BluescreenFunction *BluescreenFunction;// Processing routine
    ULONG *IsBluescreenTime;                // Non zero -> blue screen happening
} BLUESCREEN, *PBLUESCREEN;


#endif  // __BLUESCRN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\hidusb\usb.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    usb.c

Abstract: Human Input Device (HID) minidriver for Universal Serial Bus (USB) devices

          The HID USB Minidriver (HUM, Hum) provides an abstraction layer for the
          HID Class so that future HID devices whic are not USB devices can be supported.

Author:

Environment:

    Kernel mode

Revision History:


--*/
#include "pch.h"
#include <USBDLIB.H>


NTSTATUS
HumGetHidInfo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigDesc,
    IN ULONG DescriptorLength
    )
/*++

Routine Description:

    Given a config descriptor for a device, finds whether the device has a valid
    HID interface and a valid HID descriptor in that interface.  Saves this to
    our device extension for later.

Arguments:

    DeviceObject - pointer to a device object.

    ConfigDesc - pointer to USB configuration descriptor

    DescriptorLength - length of valid data in config descriptor

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION   DeviceExtension;
    PUSB_INTERFACE_DESCRIPTOR InterfaceDesc;

    DBGPRINT(1,("HumGetHidInfo Entry"));

    /*
     *  Get a pointer to the device extension
     */
    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    /*
     *  Init our HID descriptor
     */
    RtlZeroMemory((PUCHAR) &DeviceExtension->HidDescriptor, sizeof(USB_HID_DESCRIPTOR));

    /*
     *  Walk the interfaces
     */
    InterfaceDesc = USBD_ParseConfigurationDescriptorEx(
                                ConfigDesc,
                                ConfigDesc,
                                -1,
                                -1,
                                USB_INTERFACE_CLASS_HID,
                                -1,
                                -1);
    if (InterfaceDesc){
        PUSB_HID_DESCRIPTOR pHidDescriptor = NULL;

        ASSERT(InterfaceDesc->bLength >= sizeof(USB_INTERFACE_DESCRIPTOR));

        /*
         *  If this is a HID interface, look for a HID descriptor.
         */
        if (InterfaceDesc->bInterfaceClass == USB_INTERFACE_CLASS_HID) {
            HumParseHidInterface(DeviceExtension, InterfaceDesc, 0, &pHidDescriptor);
        }
        else {
            ASSERT(!(PVOID)"USBD_ParseConfigurationDescriptorEx returned non-HID iface descriptor!");
        }

        //
        // Did we find a HID descriptor?
        //

        if (pHidDescriptor) {

            //
            // Yes, copy HID descriptor to our private storage
            //

            DBGPRINT(1,("Copying device descriptor to DeviceExtension->HidDescriptor"));

            RtlCopyMemory((PUCHAR) &DeviceExtension->HidDescriptor, (PUCHAR) pHidDescriptor, sizeof(USB_HID_DESCRIPTOR));
        }
        else {
            DBGWARN(("Failed to find a HID Descriptor!"));
            ntStatus = STATUS_UNSUCCESSFUL;
        }
    }
    else {
        DBGWARN(("USBD_ParseConfigurationDescriptorEx() failed!"));
        ntStatus = STATUS_UNSUCCESSFUL;
    }

    DBGPRINT(1,("HumGetHidInfo Exit = 0x%x", ntStatus));

    return ntStatus;
}


NTSTATUS
HumGetDeviceDescriptor(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PDEVICE_EXTENSION DeviceData
    )
/*++

Routine Description:

    Returns a configuration descriptor for the device

Arguments:

    DeviceObject - pointer to a device object.

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG DescriptorLength = sizeof (USB_DEVICE_DESCRIPTOR);

    DBGPRINT(1,("HumGetDeviceDescriptor Entry"));

    //
    // Get config descriptor
    //

    ntStatus = HumGetDescriptorRequest(
                        DeviceObject,
                        URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE,
                        USB_DEVICE_DESCRIPTOR_TYPE,
                        (PVOID *) &DeviceData->DeviceDescriptor,
                        &DescriptorLength,
                        sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                        0,
                        0);

    if (NT_SUCCESS(ntStatus)){
        //
        // Dump device descriptor
        //
        ASSERT (sizeof(USB_DEVICE_DESCRIPTOR) == DescriptorLength);
        DBGPRINT(2,("Device->bLength              = 0x%x", DeviceData->DeviceDescriptor->bLength));
        DBGPRINT(2,("Device->bDescriptorType      = 0x%x", DeviceData->DeviceDescriptor->bDescriptorType));
        DBGPRINT(2,("Device->bDeviceClass         = 0x%x", DeviceData->DeviceDescriptor->bDeviceClass));
        DBGPRINT(2,("Device->bDeviceSubClass      = 0x%x", DeviceData->DeviceDescriptor->bDeviceSubClass));
        DBGPRINT(2,("Device->bDeviceProtocol      = 0x%x", DeviceData->DeviceDescriptor->bDeviceProtocol));
        DBGPRINT(2,("Device->idVendor             = 0x%x", DeviceData->DeviceDescriptor->idVendor));
        DBGPRINT(2,("Device->idProduct            = 0x%x", DeviceData->DeviceDescriptor->idProduct));
        DBGPRINT(2,("Device->bcdDevice            = 0x%x", DeviceData->DeviceDescriptor->bcdDevice));
    }
    else {
        DBGWARN(("HumGetDescriptorRequest failed w/ %xh in HumGetDeviceDescriptor", (ULONG)ntStatus));
    }

    DBGPRINT(1,("HumGetDeviceDescriptor Exit = 0x%x", ntStatus));

    return ntStatus;
}

NTSTATUS
HumGetConfigDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PUSB_CONFIGURATION_DESCRIPTOR *ConfigurationDesc,
    OUT PULONG ConfigurationDescLength
    )
/*++

Routine Description:

    Returns a configuration descriptor for the device

Arguments:

    DeviceObject - pointer to a device object.

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG DescriptorLength;
    PUSB_CONFIGURATION_DESCRIPTOR ConfigDesc = NULL;

    DescriptorLength = sizeof(USB_CONFIGURATION_DESCRIPTOR);

    //
    // Just get the base config descriptor, so that we can figure out the size,
    // then allocate enough space for the entire descriptor.
    //
    ntStatus = HumGetDescriptorRequest(DeviceObject,
                                       URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE,
                                       USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                       (PVOID *) &ConfigDesc,
                                       &DescriptorLength,
                                       sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                       0,
                                       0);

    if (NT_SUCCESS(ntStatus)){

        ASSERT(DescriptorLength >= sizeof(USB_CONFIGURATION_DESCRIPTOR));
        if (DescriptorLength < sizeof(USB_CONFIGURATION_DESCRIPTOR)) {

            return STATUS_DEVICE_DATA_ERROR;

        }

        DescriptorLength = ConfigDesc->wTotalLength;

        ExFreePool(ConfigDesc);

        if (!DescriptorLength) {
            //
            // The config descriptor is bad. Outta here.
            //
            return STATUS_DEVICE_DATA_ERROR;
        }

        //
        // Set this to NULL so we know to allocate a new buffer
        //
        ConfigDesc = NULL;

        ntStatus = HumGetDescriptorRequest(DeviceObject,
                                           URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE,
                                           USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                           (PVOID *) &ConfigDesc,
                                           &DescriptorLength,
                                           sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                           0,
                                           0);

        if (NT_SUCCESS(ntStatus)) {

            //
            // Dump config descriptor
            //

            DBGPRINT(1,("Config = 0x%x", ConfigDesc));

            DBGPRINT(2,("Config->bLength              = 0x%x", ConfigDesc->bLength));
            DBGPRINT(2,("Config->bDescriptorType      = 0x%x", ConfigDesc->bDescriptorType));
            DBGPRINT(2,("Config->wTotalLength         = 0x%x", ConfigDesc->wTotalLength));
            DBGPRINT(2,("Config->bNumInterfaces       = 0x%x", ConfigDesc->bNumInterfaces));
            DBGPRINT(2,("Config->bConfigurationValue  = 0x%x", ConfigDesc->bConfigurationValue));
            DBGPRINT(2,("Config->iConfiguration       = 0x%x", ConfigDesc->iConfiguration));
            DBGPRINT(2,("Config->bmAttributes         = 0x%x", ConfigDesc->bmAttributes));
            DBGPRINT(2,("Config->MaxPower             = 0x%x", ConfigDesc->MaxPower));

            ASSERT (ConfigDesc->bLength >= sizeof(USB_CONFIGURATION_DESCRIPTOR));

            #ifndef STRICT_COMPLIANCE
                if (ConfigDesc->bLength < sizeof(USB_CONFIGURATION_DESCRIPTOR)) {
                    DBGPRINT(1,("WARINING -- Correcting bad Config->bLength"));
                    ConfigDesc->bLength = sizeof(USB_CONFIGURATION_DESCRIPTOR);
                }
            #endif
        }
        else {
            DBGWARN(("HumGetDescriptorRequest failed in HumGetConfigDescriptor (#1)"));
        }
    }
    else {
        DBGWARN(("HumGetDescriptorRequest failed in HumGetConfigDescriptor (#2)"));
    }

    *ConfigurationDesc = ConfigDesc;
    *ConfigurationDescLength = DescriptorLength;

    return ntStatus;
}

NTSTATUS
HumParseHidInterface(
    IN  PDEVICE_EXTENSION DeviceExtension,
    IN  PUSB_INTERFACE_DESCRIPTOR InterfaceDesc,
    IN  ULONG InterfaceLength,
    OUT PUSB_HID_DESCRIPTOR *HidDescriptor
    )
/*++

Routine Description:

    Find a valid HID descriptor in a HID Interface

Arguments:

    DeviceObject - pointer to a device object.

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG iEndpoint;
    PUSB_ENDPOINT_DESCRIPTOR EndpointDesc;
    PUSB_COMMON_DESCRIPTOR CommonDesc;

    DBGPRINT(1,("HumParseHidInterface Entry"));

    //
    // Set to null until we find the HidDescriptor
    //

    *HidDescriptor = NULL;

    //
    // This routine should only be called on HID interface class interfaces.
    //

    ASSERT (InterfaceDesc->bInterfaceClass == USB_INTERFACE_CLASS_HID);

    //
    // Check for valid length
    //

    if (InterfaceDesc->bLength < sizeof(USB_INTERFACE_DESCRIPTOR)) {

        DBGWARN(("Interface->bLength (%d) is invalid", InterfaceDesc->bLength));
        goto Bail;
    }


    //
    // For HID 1.0 draft 4 compliance, the next descriptor is HID.  However, for earlier
    // drafts, endpoints come first and then HID.  We're trying to support both.
    //

    DeviceExtension->DeviceFlags &= ~DEVICE_FLAGS_HID_1_0_D3_COMPAT_DEVICE;

    //
    // What draft of HID 1.0 are we looking at?
    //

    CommonDesc = (PUSB_COMMON_DESCRIPTOR) ((ULONG_PTR)InterfaceDesc + InterfaceDesc->bLength);

    if (CommonDesc->bLength < sizeof (USB_COMMON_DESCRIPTOR)) {
        DBGWARN(("Descriptor->bLength (%d) is invalid", CommonDesc->bLength));
        goto Bail;
    }

    if (CommonDesc->bDescriptorType != USB_DESCRIPTOR_TYPE_HID) {

        DeviceExtension->DeviceFlags |= DEVICE_FLAGS_HID_1_0_D3_COMPAT_DEVICE;

    }
    else {
        //
        // Validate the length
        //

        if (CommonDesc->bLength == sizeof(USB_HID_DESCRIPTOR)) {

            *HidDescriptor = (PUSB_HID_DESCRIPTOR) CommonDesc;

            CommonDesc = (PUSB_COMMON_DESCRIPTOR)((ULONG_PTR)*HidDescriptor +
                                (*HidDescriptor)->bLength);

        }
        else {
            DBGWARN(("HID descriptor length (%d) is invalid!", CommonDesc->bLength));
            goto Bail;
        }
    }

    //
    // Walk endpoints
    //

    EndpointDesc = (PUSB_ENDPOINT_DESCRIPTOR) CommonDesc;

    for (iEndpoint = 0; iEndpoint < InterfaceDesc->bNumEndpoints; iEndpoint++) {

        if (EndpointDesc->bLength < sizeof(USB_ENDPOINT_DESCRIPTOR)) {

            DBGWARN(("Endpoint->bLength (%d) is invalid", EndpointDesc->bLength));
            goto Bail;
        }

        EndpointDesc = (PUSB_ENDPOINT_DESCRIPTOR) ((ULONG_PTR)EndpointDesc + EndpointDesc->bLength);
    }

    if (DeviceExtension->DeviceFlags & DEVICE_FLAGS_HID_1_0_D3_COMPAT_DEVICE) {
        CommonDesc = (PUSB_COMMON_DESCRIPTOR) EndpointDesc;

        if (CommonDesc->bDescriptorType == USB_DESCRIPTOR_TYPE_HID) {

            *HidDescriptor = (PUSB_HID_DESCRIPTOR) CommonDesc;

        }
        else {
            //
            // This is either an unknown type of descriptor or the device is
            // reporting back a bad descriptor type.
            //
            DBGWARN(("Unknown descriptor in HID interface"));

            #ifndef STRICT_COMPLIANCE
                if (CommonDesc->bLength == sizeof(USB_HID_DESCRIPTOR)) {
                    DBGWARN(("WARINING -- Guessing descriptor of length %d is actually HID!", sizeof(USB_HID_DESCRIPTOR)));
                    *HidDescriptor = (PUSB_HID_DESCRIPTOR) CommonDesc;
                }
            #endif
        }
    }

    //
    //  End of endpoint/hid descriptor parsing.
    //

    if (*HidDescriptor) {

        DBGPRINT(1,("HidDescriptor = 0x%x", *HidDescriptor));

        DBGPRINT(2,("HidDescriptor->bLength          = 0x%x", (*HidDescriptor)->bLength));
        DBGPRINT(2,("HidDescriptor->bDescriptorType  = 0x%x", (*HidDescriptor)->bDescriptorType));
        DBGPRINT(2,("HidDescriptor->bcdHID           = 0x%x", (*HidDescriptor)->bcdHID));
        DBGPRINT(2,("HidDescriptor->bCountryCode     = 0x%x", (*HidDescriptor)->bCountry));
        DBGPRINT(2,("HidDescriptor->bNumDescriptors  = 0x%x", (*HidDescriptor)->bNumDescriptors));
        DBGPRINT(2,("HidDescriptor->bReportType      = 0x%x", (*HidDescriptor)->bReportType));
        DBGPRINT(2,("HidDescriptor->wReportLength    = 0x%x", (*HidDescriptor)->wReportLength));
     }

Bail:

    if (*HidDescriptor == NULL) {

        //
        // We did not find a HID descriptor in this interface!
        //

        DBGWARN(("Failed to find a valid HID descriptor in interface!"));
        DBGBREAK;

        ntStatus = STATUS_UNSUCCESSFUL;
    }


    DBGPRINT(1,("HumParseHidInterface Exit = 0x%x", ntStatus));

    return ntStatus;
}


NTSTATUS
HumSelectConfiguration(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    )
/*++

Routine Description:

    Initializes an USB device which may have multiple interfaces

Arguments:

    DeviceObject - pointer to the device object

    ConfigurationDescriptor - pointer to the USB configuration
                    descriptor containing the interface and endpoint
                    descriptors.

Return Value:

    NT status code

--*/
{
    PDEVICE_EXTENSION DeviceExtension;
    NTSTATUS ntStatus;
    PURB urb = NULL;
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor = NULL;
    USBD_INTERFACE_LIST_ENTRY interfaceList[2];
    PUSBD_INTERFACE_INFORMATION usbInterface;

    DBGPRINT(1,("HumSelectConfiguration Entry"));

    //
    // Get a pointer to the device extension
    //

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    interfaceList[0].InterfaceDescriptor =
        USBD_ParseConfigurationDescriptorEx(
                        ConfigurationDescriptor,
                        ConfigurationDescriptor,
                        -1,
                        -1,
                        USB_INTERFACE_CLASS_HID,
                        -1,
                        -1);

    // terminate the list
    interfaceList[1].InterfaceDescriptor =
        NULL;

    if (interfaceList[0].InterfaceDescriptor) {

        urb = USBD_CreateConfigurationRequestEx(ConfigurationDescriptor,
                &interfaceList[0]);

        if (urb) {

            ntStatus = HumCallUSB(DeviceObject, urb);

            //
            // If the device is configured, save the configuration handle
            //
            if (NT_SUCCESS(ntStatus)) {
                DeviceExtension->ConfigurationHandle = urb->UrbSelectConfiguration.ConfigurationHandle;


                //
                // Now we need to find the HID interface and save the pointer to it
                //

                usbInterface = &urb->UrbSelectConfiguration.Interface;

                ASSERT(usbInterface->Class == USB_INTERFACE_CLASS_HID);

                DBGPRINT(1,("USBD Interface = 0x%x", usbInterface));

            }
            else {
                DBGWARN(("HumCallUSB failed in HumSelectConfiguration"));
                DeviceExtension->ConfigurationHandle = NULL;
            }

        }
        else {
            DBGWARN(("USBD_CreateConfigurationRequestEx failed in HumSelectConfiguration"));
            ntStatus = STATUS_NO_MEMORY;
        }
    }
    else {
        DBGWARN(("Bad interface descriptor in HumSelectConfiguration"));
        ntStatus = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(ntStatus)) {

        DeviceExtension->Interface = ExAllocatePoolWithTag(NonPagedPool, usbInterface->Length, HIDUSB_TAG);

        if (DeviceExtension->Interface) {

            //
            // save a copy of the interface information returned
            //

            RtlCopyMemory(DeviceExtension->Interface, usbInterface, usbInterface->Length);

            #if DBG
                {
                    ULONG j;
                    //
                    // Dump the interface to the debugger
                    //
                    DBGPRINT (2,("---------"));
                    DBGPRINT (2,("NumberOfPipes 0x%x", DeviceExtension->Interface->NumberOfPipes));
                    DBGPRINT (2,("Length 0x%x", DeviceExtension->Interface->Length));
                    DBGPRINT (2,("Alt Setting 0x%x", DeviceExtension->Interface->AlternateSetting));
                    DBGPRINT (2,("Interface Number 0x%x", DeviceExtension->Interface->InterfaceNumber));
                    DBGPRINT (2,("Class, subclass, protocol 0x%x 0x%x 0x%x",
                        DeviceExtension->Interface->Class,
                        DeviceExtension->Interface->SubClass,
                        DeviceExtension->Interface->Protocol));

                    // Dump the pipe info

                    for (j=0; j<DeviceExtension->Interface->NumberOfPipes; j++) {
                        PUSBD_PIPE_INFORMATION pipeInformation;

                        pipeInformation = &DeviceExtension->Interface->Pipes[j];

                        DBGPRINT (2,("---------"));
                        DBGPRINT (2,("PipeType 0x%x", pipeInformation->PipeType));
                        DBGPRINT (2,("EndpointAddress 0x%x", pipeInformation->EndpointAddress));
                        DBGPRINT (2,("MaxPacketSize 0x%x", pipeInformation->MaximumPacketSize));
                        DBGPRINT (2,("Interval 0x%x", pipeInformation->Interval));
                        DBGPRINT (2,("Handle 0x%x", pipeInformation->PipeHandle));
                        DBGPRINT (2,("MaximumTransferSize 0x%x", pipeInformation->MaximumTransferSize));
                    }

                    DBGPRINT (2,("---------"));
                }
            #endif

        }
    }

    if (urb) {
        ExFreePool(urb);
    }

    DBGPRINT(1,("HumSelectConfiguration Exit = %x", ntStatus));

    return ntStatus;
}


NTSTATUS HumSetIdle(IN PDEVICE_OBJECT DeviceObject)
/*++

Routine Description:

    Initializes the idle timeout value for a HID device

Arguments:

    DeviceObject - pointer to the device object for this instance of a UTB

Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus;
    PURB Urb;
    ULONG TypeSize;
    PDEVICE_EXTENSION DeviceExtension;

    DBGPRINT(1,("HumSetIdle Enter"));

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    if (DeviceExtension) {
        //
        // Allocate buffer
        //

        TypeSize = (USHORT) sizeof( struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);

        Urb = ExAllocatePoolWithTag(NonPagedPool, TypeSize, HIDUSB_TAG);

        if(Urb) {
            RtlZeroMemory(Urb, TypeSize);

            if (DeviceExtension->DeviceFlags & DEVICE_FLAGS_HID_1_0_D3_COMPAT_DEVICE) {
                HumBuildClassRequest(Urb,
                                    URB_FUNCTION_CLASS_ENDPOINT,   // function
                                    0,              // transferFlags
                                    NULL,           // transferBuffer
                                    0,              // transferBufferLength
                                    0x22,           // requestTypeFlags
                                    HID_SET_IDLE,   // request
                                    0,              // value
                                    0,              // index
                                    0);             // reqLength
            } else {
                HumBuildClassRequest(Urb,
                                    URB_FUNCTION_CLASS_INTERFACE,   // function
                                    0,                                  // transferFlags
                                    NULL,                               // transferBuffer
                                    0,                                  // transferBufferLength
                                    0x22,                               // requestTypeFlags
                                    HID_SET_IDLE,                       // request
                                    0,                                  // value
                                    DeviceExtension->Interface->InterfaceNumber,    // index
                                    0);                                 // reqLength
            }

            ntStatus = HumCallUSB(DeviceObject, Urb);

            ExFreePool(Urb);
        }
        else {
            ntStatus = STATUS_NO_MEMORY;
        }
    }
    else {
        ntStatus = STATUS_NOT_FOUND;
    }

    DBGPRINT(1,("HumSetIdle Exit = %x", ntStatus));

    return ntStatus;
}


NTSTATUS
HumGetDescriptorRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN USHORT Function,
    IN ULONG DescriptorType,
    IN OUT PVOID *Descriptor,
    IN OUT ULONG *DescSize,
    IN ULONG TypeSize,
    IN ULONG Index,
    IN ULONG LangID
    )
/*++

Routine Description:

    Retrieves the specified descriptor for this device. Allocates buffer, if
    necessary.

Arguments:

    DeviceObject - pointer to the device object
    Function -


Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PURB Urb;
    BOOLEAN AllocOnBehalf = FALSE;

    DBGPRINT(1,("HumGetDescriptorRequest Enter"));
    DBGPRINT(1,("DeviceObject = %x", DeviceObject));

    //
    // Allocate Descriptor buffer
    //
    Urb = ExAllocatePoolWithTag(NonPagedPool, TypeSize, HIDUSB_TAG);
    if (Urb){

        RtlZeroMemory(Urb, TypeSize);

        //
        // Allocate Buffer for Caller if wanted
        //

        if (!*Descriptor){
            ASSERT(*DescSize > 0);
            *Descriptor = ExAllocatePoolWithTag(NonPagedPool, *DescSize, HIDUSB_TAG);
            AllocOnBehalf = TRUE;
        }

        if (*Descriptor){
            RtlZeroMemory(*Descriptor, *DescSize);
            HumBuildGetDescriptorRequest(Urb,
                                         (USHORT) Function,
                                         (SHORT)TypeSize,
                                         (UCHAR) DescriptorType,
                                         (UCHAR) Index,
                                         (USHORT) LangID,
                                         *Descriptor,
                                         NULL,
                                         *DescSize,
                                         NULL);

            ntStatus = HumCallUSB(DeviceObject, Urb);
            if (NT_SUCCESS(ntStatus)){
                DBGPRINT(1,("Descriptor = %x, length = %x, status = %x", *Descriptor, Urb->UrbControlDescriptorRequest.TransferBufferLength, Urb->UrbHeader.Status));

                if (USBD_SUCCESS(Urb->UrbHeader.Status)){
                    ntStatus = STATUS_SUCCESS;
                    *DescSize = Urb->UrbControlDescriptorRequest.TransferBufferLength;
                }
                else {
                    ntStatus = STATUS_UNSUCCESSFUL;
                    goto HumGetDescriptorRequestFailure;
                }
            }
            else {
HumGetDescriptorRequestFailure:
                if (AllocOnBehalf) {
                    ExFreePool(*Descriptor);
                    *Descriptor = NULL;
                }
                *DescSize = 0;
            }
        }
        else {
            ntStatus = STATUS_NO_MEMORY;
        }

        ExFreePool(Urb);
    }
    else {
        ntStatus = STATUS_NO_MEMORY;
    }

    DBGPRINT(1,("HumGetDescriptorRequest Exit = %x", ntStatus));

    return ntStatus;
}

NTSTATUS HumCallUsbComplete(IN PDEVICE_OBJECT DeviceObject,
                            IN PIRP Irp,
                            IN PKEVENT Event)
{
    ASSERT(Event);
    KeSetEvent(Event, 0, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS HumCallUSB(IN PDEVICE_OBJECT DeviceObject, IN PURB Urb)
/*++

Routine Description:

    Passes a URB to the USBD class driver

Arguments:

    DeviceObject - pointer to the device object for this instance of a UTB

    Urb - pointer to Urb request block

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION DeviceExtension;
    PIRP Irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION NextStack;

    DBGPRINT(2,("HumCallUSB Entry"));

    DBGPRINT(2,("DeviceObject = %x", DeviceObject));

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    DBGPRINT(2,("DeviceExtension = %x", DeviceExtension));

    //
    // issue a synchronous request to read the UTB
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    Irp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_USB_SUBMIT_URB,
                                        GET_NEXT_DEVICE_OBJECT(DeviceObject),
                                        NULL,
                                        0,
                                        NULL,
                                        0,
                                        TRUE, /* INTERNAL */
                                        &event,
                                        &ioStatus);

    if (Irp){
        DBGPRINT(2,("Irp = %x", Irp));

        DBGPRINT(2,("PDO = %x", GET_NEXT_DEVICE_OBJECT(DeviceObject)));

        //
        // Set a completion routine so that we can avoid this race condition:
        // 1) Wait times out.
        // 2) Irp completes and gets freed
        // 3) We call IoCancelIrp (boom!)
        //
        IoSetCompletionRoutine(
            Irp,
            HumCallUsbComplete,
            &event,
            TRUE,
            TRUE,
            TRUE
            );

        //
        // pass the URB to the USB 'class driver'
        //

        NextStack = IoGetNextIrpStackLocation(Irp);
        ASSERT(NextStack != NULL);

        DBGPRINT(2,("NextStack = %x", NextStack));

        NextStack->Parameters.Others.Argument1 = Urb;

        DBGPRINT(2,("Calling USBD"));

        ntStatus = IoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);

        DBGPRINT(2,("IoCallDriver(USBD) = %x", ntStatus));

        if (ntStatus == STATUS_PENDING) {
            NTSTATUS waitStatus;

            /*
             *  Specify a timeout of 5 seconds for this call to complete.
             */
            static LARGE_INTEGER timeout = {(ULONG) -50000000, 0xFFFFFFFF };

            DBGPRINT(2,("Wait for single object"));
            waitStatus = KeWaitForSingleObject(&event, Suspended, KernelMode, FALSE, &timeout);
            if (waitStatus == STATUS_TIMEOUT){

                DBGWARN(("URB timed out after 5 seconds in HumCallUSB() !!"));

                //
                //  Cancel the Irp we just sent.
                //
                IoCancelIrp(Irp);

                //
                //  Now wait for the Irp to be cancelled/completed below
                //
                waitStatus = KeWaitForSingleObject(&event, Suspended, KernelMode, FALSE, NULL);

                /*
                 *  Note - Return STATUS_IO_TIMEOUT, not STATUS_TIMEOUT.
                 *  STATUS_IO_TIMEOUT is an NT error status, STATUS_TIMEOUT is not.
                 */
                ioStatus.Status = STATUS_IO_TIMEOUT;
            }

            DBGPRINT(2,("Wait for single object returned %x", waitStatus));

        }

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        if (ntStatus == STATUS_PENDING) {
            //
            // If the request was asynchronous, the iostatus field has
            // our real status.
            //
            ntStatus = ioStatus.Status;
        }

        DBGPRINT(2,("URB status = %x status = %x", Urb->UrbHeader.Status, ntStatus));
    }
    else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    DBGPRINT(2,("HumCallUSB Exit = %x", ntStatus));

    return ntStatus;
}



#if DBG
    NTSTATUS DumpConfigDescriptor(  IN PUSB_CONFIGURATION_DESCRIPTOR ConfigDesc,
                                    IN ULONG DescriptorLength)
    /*++

    Routine Description:

        Dumps a given config descriptor

    Arguments:

        ConfigDesc - pointer to the USB configuration descriptor

        DescriptorLength - length of config descriptor

    Return Value:

        NT status code.

    --*/
    {
        NTSTATUS ntStatus = STATUS_SUCCESS;
        ULONG iInterface;
        ULONG iEndpoint;
        ULONG iCommon;
        PUSB_INTERFACE_DESCRIPTOR InterfaceDesc;
        PUSB_ENDPOINT_DESCRIPTOR EndpointDesc;
        PUSB_COMMON_DESCRIPTOR CommonDesc;
        PUSB_HID_DESCRIPTOR pHidDescriptor = NULL;
        PVOID EndOfDescriptor;

        //
        // Determine end of valid data
        //

        if (ConfigDesc->wTotalLength > DescriptorLength) {
            EndOfDescriptor = (PVOID)((ULONG_PTR)ConfigDesc + DescriptorLength);
        }
        else {
            EndOfDescriptor = (PVOID)((ULONG_PTR)ConfigDesc + ConfigDesc->wTotalLength);
        }

        DBGPRINT(2,("EndOfDescriptor = 0x%x", EndOfDescriptor));


        //
        // Begin parsing config descriptor
        //

        DBGPRINT(2,("Config = 0x%x", ConfigDesc));

        DBGPRINT(2,("Config->bLength              = 0x%x", ConfigDesc->bLength));
        DBGPRINT(2,("Config->bDescriptorType      = 0x%x", ConfigDesc->bDescriptorType));
        DBGPRINT(2,("Config->wTotalLength         = 0x%x", ConfigDesc->wTotalLength));
        DBGPRINT(2,("Config->bNumInterfaces       = 0x%x", ConfigDesc->bNumInterfaces));
        DBGPRINT(2,("Config->bConfigurationValue  = 0x%x", ConfigDesc->bConfigurationValue));
        DBGPRINT(2,("Config->iConfiguration       = 0x%x", ConfigDesc->iConfiguration));
        DBGPRINT(2,("Config->bmAttributes         = 0x%x", ConfigDesc->bmAttributes));
        DBGPRINT(2,("Config->MaxPower             = 0x%x", ConfigDesc->MaxPower));

        ASSERT (ConfigDesc->bLength >= sizeof(USB_CONFIGURATION_DESCRIPTOR));

        #ifndef STRICT_COMPLIANCE
            if (ConfigDesc->bLength < sizeof(USB_CONFIGURATION_DESCRIPTOR)) {
                DBGPRINT(2,("WARINING -- Correcting bad Config->bLength"));
                ConfigDesc->bLength = sizeof(USB_CONFIGURATION_DESCRIPTOR);
            }
        #endif

        //
        // Walk interfaces
        //

        InterfaceDesc = (PUSB_INTERFACE_DESCRIPTOR) ((ULONG_PTR)ConfigDesc + ConfigDesc->bLength);

        for (iInterface = 0; iInterface < ConfigDesc->bNumInterfaces; iInterface++) {

            DBGPRINT(2,("Interface[%d] = 0x%x", iInterface, InterfaceDesc));

            DBGPRINT(2,("Interface[%d]->bLength             = 0x%x", iInterface, InterfaceDesc->bLength));
            DBGPRINT(2,("Interface[%d]->bDescriptorType     = 0x%x", iInterface, InterfaceDesc->bDescriptorType));
            DBGPRINT(2,("Interface[%d]->bInterfaceNumber    = 0x%x", iInterface, InterfaceDesc->bNumEndpoints));
            DBGPRINT(2,("Interface[%d]->bAlternateSetting   = 0x%x", iInterface, InterfaceDesc->bAlternateSetting));
            DBGPRINT(2,("Interface[%d]->bNumEndpoints       = 0x%x", iInterface, InterfaceDesc->bNumEndpoints));
            DBGPRINT(2,("Interface[%d]->bInterfaceClass     = 0x%x", iInterface, InterfaceDesc->bInterfaceClass));
            DBGPRINT(2,("Interface[%d]->bInterfaceSubClass  = 0x%x", iInterface, InterfaceDesc->bInterfaceSubClass));
            DBGPRINT(2,("Interface[%d]->bInterfaceProtocol  = 0x%x", iInterface, InterfaceDesc->bInterfaceProtocol));
            DBGPRINT(2,("Interface[%d]->iInterface          = 0x%x", iInterface, InterfaceDesc->iInterface));

            ASSERT (InterfaceDesc->bLength >= sizeof(USB_INTERFACE_DESCRIPTOR));

            CommonDesc = (PUSB_COMMON_DESCRIPTOR) ((ULONG_PTR)InterfaceDesc + InterfaceDesc->bLength);

            if (CommonDesc->bDescriptorType == USB_ENDPOINT_DESCRIPTOR_TYPE) {
                DBGPRINT(2,("HID Device < HID 1.0 Draft 4 spec compliant"));

                //
                // Walk endpoints for old style device
                //

                EndpointDesc = (PUSB_ENDPOINT_DESCRIPTOR) CommonDesc;

                for (iEndpoint = 0; iEndpoint < InterfaceDesc->bNumEndpoints; iEndpoint++) {

                    DBGPRINT(2,("Endpoint[%d] = 0x%x", iEndpoint, EndpointDesc));

                    DBGPRINT(2,("Endpoint[%d]->bLength           = 0x%x", iEndpoint, EndpointDesc->bLength));
                    DBGPRINT(2,("Endpoint[%d]->bDescriptorType   = 0x%x", iEndpoint, EndpointDesc->bDescriptorType));
                    DBGPRINT(2,("Endpoint[%d]->bEndpointAddress  = 0x%x", iEndpoint, EndpointDesc->bEndpointAddress));

                    ASSERT (EndpointDesc->bLength >= sizeof(USB_ENDPOINT_DESCRIPTOR));

                    EndpointDesc = (PUSB_ENDPOINT_DESCRIPTOR) ((ULONG_PTR)EndpointDesc + EndpointDesc->bLength);
                }

                CommonDesc = (PUSB_COMMON_DESCRIPTOR) EndpointDesc;

            }
            else {
                DBGPRINT(2,("HID Device is HID 1.0 Draft 4 compliant"));
            }

            //
            // Walk misc/common descriptors
            //

            iCommon = 0;

            while (((PVOID)CommonDesc < EndOfDescriptor) &&
                    (CommonDesc->bDescriptorType != USB_ENDPOINT_DESCRIPTOR_TYPE) &&
                    (CommonDesc->bDescriptorType != USB_INTERFACE_DESCRIPTOR_TYPE)) {

                DBGPRINT(2,("Common[%d] = 0x%x", iCommon, CommonDesc));

                DBGPRINT(2,("Common[%d]->bLength          = 0x%x", iCommon, CommonDesc->bLength));
                DBGPRINT(2,("Common[%d]->bDescriptorType  = 0x%x", iCommon, CommonDesc->bDescriptorType));

                ASSERT (CommonDesc->bLength >= sizeof(USB_COMMON_DESCRIPTOR));


                if (CommonDesc->bLength == 0) {
                    DBGPRINT(2,("WARNING: Common[%d]->bLength          = 0x%x", iCommon, CommonDesc->bLength));
                    break;
                }

                //
                // Is this a HID Interface?
                //

                if (InterfaceDesc->bInterfaceClass == USB_INTERFACE_CLASS_HID) {

                    //
                    // Is this the HID Descriptor?
                    //

                    if (CommonDesc->bDescriptorType == USB_DESCRIPTOR_TYPE_HID) {

                        pHidDescriptor = (PUSB_HID_DESCRIPTOR) CommonDesc;

                    }
                    else {
                        //
                        // This is either an unknown type of descriptor or the device is
                        // reporting back a bad descriptor type.
                        //
                        DBGPRINT(2,("WARINING -- Unknown descriptor in HID interface"));

                        #ifndef STRICT_COMPLIANCE
                            if (CommonDesc->bLength == sizeof(USB_HID_DESCRIPTOR)) {
                                DBGPRINT(2,("WARINING -- Guessing descriptor of length %d is actually HID!", sizeof(USB_HID_DESCRIPTOR)));
                                pHidDescriptor = (PUSB_HID_DESCRIPTOR) CommonDesc;
                                break;
                            }
                        #endif
                    }
                }

                CommonDesc = (PUSB_COMMON_DESCRIPTOR) ((ULONG_PTR)CommonDesc + CommonDesc->bLength);
                iCommon++;
            }


            if (CommonDesc->bDescriptorType == USB_ENDPOINT_DESCRIPTOR_TYPE) {
                //
                // Walk endpoints for full draft 4 HID 1.0 device
                //

                EndpointDesc = (PUSB_ENDPOINT_DESCRIPTOR) CommonDesc;

                for (iEndpoint = 0; iEndpoint < InterfaceDesc->bNumEndpoints; iEndpoint++) {

                    DBGPRINT(2,("Endpoint[%d] = 0x%x", iEndpoint, EndpointDesc));

                    DBGPRINT(2,("Endpoint[%d]->bLength           = 0x%x", iEndpoint, EndpointDesc->bLength));
                    DBGPRINT(2,("Endpoint[%d]->bDescriptorType   = 0x%x", iEndpoint, EndpointDesc->bDescriptorType));
                    DBGPRINT(2,("Endpoint[%d]->bEndpointAddress  = 0x%x", iEndpoint, EndpointDesc->bEndpointAddress));

                    ASSERT (EndpointDesc->bLength >= sizeof(USB_ENDPOINT_DESCRIPTOR));

                    EndpointDesc = (PUSB_ENDPOINT_DESCRIPTOR) ((ULONG_PTR)EndpointDesc + EndpointDesc->bLength);
                }

                CommonDesc = (PUSB_COMMON_DESCRIPTOR) EndpointDesc;
            }

            //
            // If we have found the HID descriptor, we don't need to look at the
            // rest of the interfaces for this device.
            //

            if (pHidDescriptor) {
                break;
            }

            InterfaceDesc = (PUSB_INTERFACE_DESCRIPTOR) CommonDesc;
        }

        if (pHidDescriptor) {

            ASSERT (pHidDescriptor->bLength >= sizeof(USB_HID_DESCRIPTOR));


            DBGPRINT(2,("pHidDescriptor = 0x%x", pHidDescriptor));

            DBGPRINT(2,("pHidDescriptor->bLength          = 0x%x", pHidDescriptor->bLength));
            DBGPRINT(2,("pHidDescriptor->bDescriptorType  = 0x%x", pHidDescriptor->bDescriptorType));
            DBGPRINT(2,("pHidDescriptor->bcdHID           = 0x%x", pHidDescriptor->bcdHID));
            DBGPRINT(2,("pHidDescriptor->bCountryCode     = 0x%x", pHidDescriptor->bCountry));
            DBGPRINT(2,("pHidDescriptor->bNumDescriptors  = 0x%x", pHidDescriptor->bNumDescriptors));
            DBGPRINT(2,("pHidDescriptor->bReportType      = 0x%x", pHidDescriptor->bReportType));
            DBGPRINT(2,("pHidDescriptor->wReportLength    = 0x%x", pHidDescriptor->wReportLength));

        }
        else {

            //
            // We did not find a HID interface or HID descriptor!
            //

            DBGPRINT(2,("Failed to find a HID Descriptor!"));
            DBGBREAK;

            ntStatus = STATUS_UNSUCCESSFUL;

        }

        return ntStatus;
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\gameenum\sys\gameenum.c ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    GAMEENUM.C

Abstract:

    This module contains contains the entry points for a standard bus
    PNP / WDM driver.

@@BEGIN_DDKSPLIT

Author:

    Kenneth D. Ray
    Doron J. Holan

@@END_DDKSPLIT

Environment:

    kernel mode only

Notes:


Revision History:


--*/

#include <wdm.h>
#include <initguid.h>
#include "gameport.h"
#include "gameenum.h"
#include "stdio.h"

//
// Global Debug Level
//

#if DBG
ULONG GameEnumDebugLevel = GAME_DEFAULT_DEBUG_OUTPUT_LEVEL;
#endif

//
// Declare some entry functions as pageable, and make DriverEntry
// discardable
//

NTSTATUS DriverEntry (PDRIVER_OBJECT, PUNICODE_STRING);

#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text (PAGE, Game_DriverUnload)
#pragma alloc_text (PAGE, Game_PortParameters)
#pragma alloc_text (PAGE, Game_CreateClose)
#pragma alloc_text (PAGE, Game_IoCtl)
#pragma alloc_text (PAGE, Game_InternIoCtl)
#endif

NTSTATUS
DriverEntry (
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING UniRegistryPath
    )
/*++
Routine Description:

    Initialize the entry points of the driver.

--*/
{
    PDEVICE_OBJECT  device;

    UNREFERENCED_PARAMETER (UniRegistryPath);

    Game_KdPrint_Def (GAME_DBG_SS_TRACE, ("Driver Entry\n"));

    DriverObject->MajorFunction [IRP_MJ_CREATE] =
    DriverObject->MajorFunction [IRP_MJ_CLOSE] = Game_CreateClose;
    DriverObject->MajorFunction [IRP_MJ_SYSTEM_CONTROL] = Game_SystemControl;
    DriverObject->MajorFunction [IRP_MJ_PNP] = Game_PnP;
    DriverObject->MajorFunction [IRP_MJ_POWER] = Game_Power;
    DriverObject->MajorFunction [IRP_MJ_DEVICE_CONTROL] = Game_IoCtl;
    DriverObject->MajorFunction [IRP_MJ_INTERNAL_DEVICE_CONTROL]
        = Game_InternIoCtl;

    DriverObject->DriverUnload = Game_DriverUnload;
    DriverObject->DriverExtension->AddDevice = Game_AddDevice;

    return STATUS_SUCCESS;
}

NTSTATUS
Game_CreateClose (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++
Routine Description:
    Some outside source is trying to create a file against us.

    If this is for the FDO (the bus itself) then the caller is trying to
    open the propriatary conection to tell us which game port to enumerate.

    If this is for the PDO (an object on the bus) then this is a client that
    wishes to use the game port.
--*/
{
    PIO_STACK_LOCATION  irpStack;
    NTSTATUS            status;
    KEVENT              event;
    PFDO_DEVICE_DATA    data;

    PAGED_CODE ();

    data = (PFDO_DEVICE_DATA) DeviceObject->DeviceExtension;

    status = Game_IncIoCount (data);
    if (!NT_SUCCESS (status)) {
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }
    
    status = STATUS_SUCCESS;
    irpStack = IoGetCurrentIrpStackLocation (Irp);

    switch (irpStack->MajorFunction) {
    case IRP_MJ_CREATE:

        Game_KdPrint_Def (GAME_DBG_SS_TRACE, ("Create \n"));

        if (0 != irpStack->FileObject->FileName.Length) {
            //
            // The caller is trying to open a subdirectory off the device
            // object name.  This is not allowed.
            //
            status = STATUS_ACCESS_DENIED;
        }
        break;

    case IRP_MJ_CLOSE:
        Game_KdPrint_Def (GAME_DBG_SS_TRACE, ("Close \n"));
        ;
    }

    Game_DecIoCount (data);

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
Game_IoCtl (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++
Routine Description:

    Handle user mode expose, remove, and device description requests.
    
--*/
{
    PIO_STACK_LOCATION      irpStack;
    NTSTATUS                status;
    ULONG                   inlen;
    ULONG                   outlen;
    PCOMMON_DEVICE_DATA     commonData;
    PFDO_DEVICE_DATA        fdoData;
    PVOID                   buffer;

    PAGED_CODE ();

    status = STATUS_SUCCESS;
    irpStack = IoGetCurrentIrpStackLocation (Irp);
    ASSERT (IRP_MJ_DEVICE_CONTROL == irpStack->MajorFunction);

    commonData = (PCOMMON_DEVICE_DATA) DeviceObject->DeviceExtension;
    fdoData = (PFDO_DEVICE_DATA) DeviceObject->DeviceExtension;
    buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    // We only take Device Control requests for the FDO.
    // That is the bus itself.
    //
    // The request is one of the propriatary Ioctls for
    //
    // NB we are not a filter driver, so we do not pass on the irp.
    //

    inlen = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outlen = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    if (!commonData->IsFDO) {
        //
        // These commands are only allowed to go to the FDO.
        //
        status = STATUS_ACCESS_DENIED;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;

    }

    if (!fdoData->Started) {
        status = STATUS_DEVICE_NOT_READY;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    status = Game_IncIoCount (fdoData);
    if (!NT_SUCCESS (status)) {
        //
        // This bus has received the PlugPlay remove IRP.  It will no longer
        // resond to external requests.
        //
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_GAMEENUM_EXPOSE_HARDWARE:
        if ((inlen == outlen) &&
            //
            // Make sure it is at least two nulls (ie, an empty multi sz)
            // and the size field is set to the declared size of the struct
            //
            ((sizeof (GAMEENUM_EXPOSE_HARDWARE) + sizeof(UNICODE_NULL) * 2) <=
             inlen) &&

            //
            // The size field should be set to the sizeof the struct as declared
            // and *not* the size of the struct plus the multi sz
            //
            (sizeof (GAMEENUM_EXPOSE_HARDWARE) ==
             ((PGAMEENUM_EXPOSE_HARDWARE) buffer)->Size)) {

            Game_KdPrint(fdoData, GAME_DBG_IOCTL_TRACE, ("Expose called\n"));

            status= Game_Expose((PGAMEENUM_EXPOSE_HARDWARE)buffer,
                                inlen,
                                fdoData);
            Irp->IoStatus.Information = outlen;

        } else {
            status = STATUS_INVALID_PARAMETER;
        }
        break;

    case IOCTL_GAMEENUM_REMOVE_HARDWARE:

        if ((sizeof (GAMEENUM_REMOVE_HARDWARE) == inlen) &&
            (inlen == outlen) &&
            (((PGAMEENUM_REMOVE_HARDWARE)buffer)->Size == inlen)) {

            Game_KdPrint(fdoData, GAME_DBG_IOCTL_TRACE, ("Remove called\n"));

            status= Game_Remove((PGAMEENUM_REMOVE_HARDWARE)buffer, fdoData);
            Irp->IoStatus.Information = outlen;

        } else {
            status = STATUS_INVALID_PARAMETER;
        }
        break;

    case IOCTL_GAMEENUM_PORT_DESC:

        if ((sizeof (GAMEENUM_PORT_DESC) == inlen) &&
            (inlen == outlen) &&
            (((PGAMEENUM_PORT_DESC)buffer)->Size == inlen)) {

            Game_KdPrint(fdoData, GAME_DBG_IOCTL_TRACE, ("Port desc called\n"));

            //
            // Fill in the information first.  If there is a lower driver, it
            // will change replace the values that gameenum has placed in the
            // buffer.  We don't care if the call down succeeds or not
            //
            status = Game_ListPorts ((PGAMEENUM_PORT_DESC) buffer, fdoData);

            Game_SendIrpSynchronously (fdoData->TopOfStack,
                                       Irp,
                                       FALSE,
                                       TRUE); 

            Irp->IoStatus.Information = outlen;

        } else {
            status = STATUS_INVALID_PARAMETER;
        }
       break;

    default:
        status = STATUS_INVALID_PARAMETER;
    }

    Game_DecIoCount (fdoData);

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
Game_InternIoCtl (
    PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++
Routine Description:

--*/
{
    PIO_STACK_LOCATION          irpStack, next;
    NTSTATUS                    status;
    PCOMMON_DEVICE_DATA         commonData;
    PPDO_DEVICE_DATA            pdoData;
    PVOID                       buffer;
    BOOLEAN                     validAccessors;
    ULONG                       inlen;
    ULONG                       outlen;

    PAGED_CODE ();

    status = STATUS_SUCCESS;
    irpStack = IoGetCurrentIrpStackLocation (Irp);
    ASSERT (IRP_MJ_INTERNAL_DEVICE_CONTROL == irpStack->MajorFunction);

    commonData = (PCOMMON_DEVICE_DATA) DeviceObject->DeviceExtension;
    pdoData = (PPDO_DEVICE_DATA) DeviceObject->DeviceExtension;

    inlen = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outlen = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // We only take Internal Device Control requests for the PDO.
    // That is the objects on the bus (representing the game ports)
    //
    // The request is from a FDO driver attached to this game port device object
    // inquiring about the port itself.
    //
    // NB we are not a filter driver, so we do not pass on the irp.
    //

    if (commonData->IsFDO) {
        Game_KdPrint(((PFDO_DEVICE_DATA) commonData), GAME_DBG_IOCTL_ERROR,
                     ("internal ioctl called on fdo!\n"))

        status = STATUS_ACCESS_DENIED;

    } else if (!pdoData->Started) {
        //
        // The bus has not been started yet
        //
        status = STATUS_DEVICE_NOT_READY;

    } else if (pdoData->Removed) {
        //
        // This bus has received the PlugPlay remove IRP.  It will no longer
        // resond to external requests.
        //
        status = STATUS_DELETE_PENDING;

    } else {
        buffer = Irp->UserBuffer;

        switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {
        case IOCTL_GAMEENUM_PORT_PARAMETERS:
            if ((inlen == outlen) &&
                (outlen == ((PGAMEENUM_PORT_PARAMETERS) buffer)->Size)) {
                Game_KdPrint(pdoData, GAME_DBG_IOCTL_TRACE,
                             ("Port parameters called\n"));
    
                status = Game_PortParameters ((PGAMEENUM_PORT_PARAMETERS) buffer,
                                              pdoData);
            }
            else {
                Game_KdPrint(pdoData, GAME_DBG_IOCTL_ERROR,
                             ("InBufLen:  %d, OutBufLen:  %d, Size:  %d\n",
                              inlen, outlen,
                             ((PGAMEENUM_PORT_PARAMETERS) buffer)->Size));
                status = STATUS_INVALID_PARAMETER;
            }

            break;

        case IOCTL_GAMEENUM_EXPOSE_SIBLING:
            if ((inlen == outlen) &&
                //
                // Make sure that the buffer passed in is of the correct size
                //
                (sizeof (GAMEENUM_EXPOSE_SIBLING) == inlen) &&
    
                //
                // The size field should be set to the sizeof the struct 
                //
                (sizeof (GAMEENUM_EXPOSE_SIBLING) ==
                 ((PGAMEENUM_EXPOSE_SIBLING) buffer)->Size)) {
                
                Game_KdPrint(pdoData, GAME_DBG_IOCTL_TRACE, ("Expose sibling"));
            
                status = Game_ExposeSibling ((PGAMEENUM_EXPOSE_SIBLING) buffer,
                                              pdoData);
            }
            else {
                Game_KdPrint(pdoData, GAME_DBG_IOCTL_ERROR, 
                             ("Expected an input and output buffer lengths to be equal (in = %d, out %d)\n"
                              "Expected an input buffer length of %d, received %d\n"
                              "Expected GAME_EXPOSE_SIBLING.Size == %d, received %d\n",
                              inlen, outlen,
                              sizeof (GAMEENUM_EXPOSE_SIBLING), inlen,
                              sizeof (GAMEENUM_EXPOSE_SIBLING), 
                              ((PGAMEENUM_EXPOSE_SIBLING) buffer)->Size));

                status = STATUS_INVALID_PARAMETER;
            }

            break;

        case IOCTL_GAMEENUM_REMOVE_SELF:
            Game_KdPrint(pdoData, GAME_DBG_IOCTL_TRACE, ("Remove self\n"));

            status = Game_RemoveSelf (pdoData);
            break;

        default:
            status = STATUS_INVALID_PARAMETER;
        }
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return status;
}


VOID
Game_DriverUnload (
    IN PDRIVER_OBJECT Driver
    )
/*++
Routine Description:
    Clean up everything we did in driver entry.

--*/
{
    #if (!DBG)
    UNREFERENCED_PARAMETER (Driver);
    #endif

    PAGED_CODE ();

    //
    // All the device objects should be gone.
    //

    ASSERT (NULL == Driver->DeviceObject);

    //
    // Here we free any resources allocated in DriverEntry
    //
    return;
}


NTSTATUS
Game_PortParameters (
    PGAMEENUM_PORT_PARAMETERS   Parameters,
    PPDO_DEVICE_DATA            PdoData
    )
{
    PFDO_DEVICE_DATA            fdoData;
    GAMEENUM_ACQUIRE_ACCESSORS  gameAccessors;
    PIO_STACK_LOCATION          next;
    NTSTATUS                    status;
    IO_STATUS_BLOCK             iosb;
    KEVENT                      event;
    PIRP                        accessorIrp;

    PAGED_CODE ();

    if (sizeof (GAMEENUM_PORT_PARAMETERS) != Parameters->Size) {
        Game_KdPrint(PdoData, GAME_DBG_IOCTL_ERROR,
                     ("Wanted %d, got %d for size of buffer\n",
                      sizeof(GAMEENUM_PORT_PARAMETERS), Parameters->Size));
        
        return STATUS_INVALID_PARAMETER;
    }

    fdoData = FDO_FROM_PDO (PdoData);

    KeInitializeEvent (&event, NotificationEvent, FALSE);

    RtlZeroMemory(&gameAccessors, sizeof(GAMEENUM_ACQUIRE_ACCESSORS));
    gameAccessors.Size = sizeof(GAMEENUM_ACQUIRE_ACCESSORS);

    accessorIrp =
        IoBuildDeviceIoControlRequest (IOCTL_GAMEENUM_ACQUIRE_ACCESSORS,
                                       fdoData->TopOfStack,
                                       NULL,
                                       0,
                                       &gameAccessors,
                                       sizeof (GAMEENUM_PORT_PARAMETERS),
                                       TRUE,
                                       &event,
                                       &iosb);
    if (!accessorIrp) {
        goto Game_NoCustomAccessors;
    }

    status = IoCallDriver(fdoData->TopOfStack, accessorIrp);

    //
    // Wait for lower drivers to be done with the Irp
    //
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject (&event,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);
        status = iosb.Status;
    }

    if (!NT_SUCCESS(status) ||
        !(gameAccessors.GameContext   &&
          gameAccessors.WriteAccessor && gameAccessors.ReadAccessor)) {

        //
        // If TopOfStack or below does not handle this IOCTL, we better have
        // received the necessary resources to allow our children to read and
        // write to their devices
        //
        ASSERT (fdoData->GamePortAddress != NULL);
        ASSERT (fdoData->ReadPort != NULL);
        ASSERT (fdoData->WritePort != NULL);

Game_NoCustomAccessors:
        //
        // No filter below us (either the IOCTL failed, or not all of the req. 
        // fields were filled in) ... fill in w/standard values
        //
        Parameters->ReadAccessor = fdoData->ReadPort;
        Parameters->WriteAccessor = fdoData->WritePort;
        Parameters->ReadAccessorDigital = NULL;
        Parameters->GameContext = fdoData->GamePortAddress; 
    }
    else {
        //
        // There is a filter below us, fill in w/the appropriate values
        //
        Parameters->ReadAccessor = gameAccessors.ReadAccessor;
        Parameters->WriteAccessor = gameAccessors.WriteAccessor;
        Parameters->ReadAccessorDigital = gameAccessors.ReadAccessorDigital;
        Parameters->GameContext = gameAccessors.GameContext;

        if (gameAccessors.PortContext) {
            fdoData->LowerAcquirePort = gameAccessors.AcquirePort;
            fdoData->LowerReleasePort = gameAccessors.ReleasePort;
            fdoData->LowerPortContext = gameAccessors.PortContext;
        }
    }

    //
    // Acquire/release always goes through the gameenum even if a lower
    // filter exists
    //
    Parameters->AcquirePort = (PGAMEENUM_ACQUIRE_PORT) Game_AcquirePort;
    Parameters->ReleasePort = (PGAMEENUM_RELEASE_PORT) Game_ReleasePort;
    Parameters->PortContext = fdoData;

    Parameters->Portion = PdoData->Portion;
    Parameters->NumberAxis = PdoData->NumberAxis;
    Parameters->NumberButtons = PdoData->NumberButtons;
    RtlCopyMemory (&Parameters->OemData,
                   &PdoData->OemData,
                   sizeof(GAMEENUM_OEM_DATA));

    return STATUS_SUCCESS;
}

NTSTATUS
Game_IncIoCount (
    PFDO_DEVICE_DATA Data
    )
{
    InterlockedIncrement (&Data->OutstandingIO);
    if (Data->Removed) {

        if (0 == InterlockedDecrement (&Data->OutstandingIO)) {
            KeSetEvent (&Data->RemoveEvent, 0, FALSE);
        }
        return STATUS_DELETE_PENDING;
    }
    return STATUS_SUCCESS;
}

VOID
Game_DecIoCount (
    PFDO_DEVICE_DATA Data
    )
{
    if (0 == InterlockedDecrement (&Data->OutstandingIO)) {
        KeSetEvent (&Data->RemoveEvent, 0, FALSE);
    }
}

NTSTATUS
Game_AcquirePort(
    PFDO_DEVICE_DATA fdoData
    )
{
    if (fdoData->Removed) {
        Game_KdPrint(fdoData, GAME_DBG_ACQUIRE_ERROR,
                     ("Acquire failed!  Gameport associated with (0x%x) was removed....\n", fdoData));
        return STATUS_NO_SUCH_DEVICE;
    }
    else if (!fdoData->Started) {
        Game_KdPrint(fdoData, GAME_DBG_ACQUIRE_ERROR,
                     ("Acquire failed!  Gameport associated with (0x%x) is not started....\n", fdoData));
        return STATUS_NO_SUCH_DEVICE;
    }
    else if (!fdoData->NumPDOs) {
        Game_KdPrint(fdoData, GAME_DBG_ACQUIRE_ERROR,
                     ("Acquire failed!  Gameport associated with (0x%x) has no devices attached....\n", fdoData));
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // If fdoData->Acquired is TRUE, then no exchange will take place and the
    // value of fdoData->Acquired (TRUE) will be returned
    //
    if (InterlockedCompareExchange(&fdoData->Acquired, TRUE, FALSE)) {
        Game_KdPrint(fdoData, GAME_DBG_ACQUIRE_ERROR,
                     ("Acquire failed!  Gameport associated with (0x%x) was already acquired....\n", fdoData));
        return STATUS_DEVICE_BUSY;
    }
    
    if (fdoData->LowerPortContext) {
        return (*fdoData->LowerAcquirePort)(fdoData->LowerPortContext);
    }
    else {
        return STATUS_SUCCESS;
    }
}

VOID
Game_ReleasePort(
    PFDO_DEVICE_DATA fdoData
    )
{
    ASSERT(fdoData->Acquired);

    InterlockedExchange(&fdoData->Acquired, FALSE);

    if (fdoData->LowerPortContext) {
        (*fdoData->LowerReleasePort)(fdoData->LowerPortContext);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\gameenum\sys\gameenum.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    GAMEENUM.H

Abstract:

    This module contains the common private declarations for the game port
    enumerator.

@@BEGIN_DDKSPLIT

Author:

    Kenneth Ray
    
@@END_DDKSPLIT

Environment:

    kernel mode only

Notes:


Revision History:


--*/

#ifndef GAMEENUM_H
#define GAMEENUM_H

#define GAMEENUM_COMPATIBLE_IDS L"GamePort\\GameDevice\0\0"
#define GAMEENUM_COMPATIBLE_IDS_LENGTH 21 // NB wide characters.

#define GAMEENUM_UNIQUEID_START (-1)

#define GAMEENUM_POOL_TAG (ULONG) 'emaG'
#undef ExAllocatePool
#define ExAllocatePool(type, size) \
            ExAllocatePoolWithTag (type, size, GAMEENUM_POOL_TAG)


#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4705)   // Statement has no effect


//
// Debugging Output Levels
//

#define GAME_DBG_ALWAYS                 0x00000000

#define GAME_DBG_STARTUP_SHUTDOWN_MASK  0x0000000F
#define GAME_DBG_SS_NOISE               0x00000001
#define GAME_DBG_SS_TRACE               0x00000002
#define GAME_DBG_SS_INFO                0x00000004
#define GAME_DBG_SS_ERROR               0x00000008

#define GAME_DBG_PNP_MASK               0x000000F0
#define GAME_DBG_PNP_NOISE              0x00000010
#define GAME_DBG_PNP_TRACE              0x00000020
#define GAME_DBG_PNP_INFO               0x00000040
#define GAME_DBG_PNP_ERROR              0x00000080

#define GAME_DBG_IOCTL_MASK             0x00000F00
#define GAME_DBG_IOCTL_NOISE            0x00000100
#define GAME_DBG_IOCTL_TRACE            0x00000200
#define GAME_DBG_IOCTL_INFO             0x00000400
#define GAME_DBG_IOCTL_ERROR            0x00000800

#define GAME_DBG_ACQUIRE_ERROR          0x00001000
#define GAME_DBG_ACQUIRE_NOISE          0x00002000
#define GAME_DBG_RELEASE_ERROR          0x00004000
#define GAME_DBG_RELEASE_NOISE          0x00008000

#if DBG
extern ULONG GameEnumDebugLevel;
#define GAME_DEFAULT_DEBUG_OUTPUT_LEVEL 0x00005888

#define Game_KdPrint(_d_,_l_, _x_) \
            if (!(_l_) || (_d_)->DebugLevel & (_l_)) { \
               DbgPrint ("GameEnum.SYS: "); \
               DbgPrint _x_; \
            }

#define Game_KdPrint_Cont(_d_,_l_, _x_) \
            if (!(_l_) || (_d_)->DebugLevel & (_l_)) { \
               DbgPrint _x_; \
            }

#define Game_KdPrint_Def(_l_, _x_) \
            if (!(_l_) || GameEnumDebugLevel & (_l_)) { \
               DbgPrint ("GameEnum.SYS: "); \
               DbgPrint _x_; \
            }

#define TRAP() DbgBreakPoint()
#define DbgRaiseIrql(_x_,_y_) KeRaiseIrql(_x_,_y_)
#define DbgLowerIrql(_x_) KeLowerIrql(_x_)
#else

#define GAME_DEFAULT_DEBUG_OUTPUT_LEVEL 0x0
#define Game_KdPrint(_d_, _l_, _x_)
#define Game_KdPrint_Cont(_d_, _l_, _x_)
#define Game_KdPrint_Def(_l_, _x_)
#define TRAP()
#define DbgRaiseIrql(_x_,_y_)
#define DbgLowerIrql(_x_)

#endif


//
// A common header for the device extensions of the PDOs and FDO
//

typedef struct _COMMON_DEVICE_DATA
{
    PDEVICE_OBJECT  Self;
    // A backpointer to the device object for which this is the extension

    CHAR            Reserved[2];
    BOOLEAN         SurpriseRemoved;
    BOOLEAN         IsFDO;

    // A boolean to distringuish between PDO and FDO.

    ULONG           DebugLevel;

    GAMEENUM_OEM_DATA  OemData;
    USHORT             UnitID;
    USHORT             _Unused;
    // user supplied data

    SYSTEM_POWER_STATE  SystemState;
    DEVICE_POWER_STATE  DeviceState;

    
} COMMON_DEVICE_DATA, *PCOMMON_DEVICE_DATA;

//
// The device extension for the PDOs.
// That is the game ports of which this bus driver enumerates.
//
typedef struct _PDO_DEVICE_DATA
{
    COMMON_DEVICE_DATA;

    PDEVICE_OBJECT  ParrentFdo;
    // A back pointer to the bus

    PWCHAR      HardwareIDs;
    // An array of (zero terminated wide character strings).
    // The array itself also null terminated

    ULONG UniqueID;
    // Globally unique id in the system

    BOOLEAN     AnalogCompatible;
    // TRUE if the device can be supported by the analog joystick driver

    BOOLEAN     Started;
    BOOLEAN     Attached;
    BOOLEAN     Removed;
    // When a device (PDO) is found on a bus and presented as a device relation
    // to the PlugPlay system, Attached is set to TRUE, and Removed to FALSE.
    // When the bus driver determines that this PDO is no longer valid, because
    // the device has gone away, it informs the PlugPlay system of the new
    // device relastions, but it does not delete the device object at that time.
    // The PDO is deleted only when the PlugPlay system has sent a remove IRP,
    // and there is no longer a device on the bus.
    //
    // If the PlugPlay system sends a remove IRP then the Removed field is set
    // to true, and all client (non PlugPlay system) accesses are failed.
    // If the device is removed from the bus Attached is set to FALSE.
    //
    // Durring a query relations Irp Minor call, only the PDOs that are
    // attached to the bus (and all that are attached to the bus) are returned
    // (even if they have been removed).
    //
    // Durring a remove device Irp Minor call, if and only if, attached is set
    // to FALSE, the PDO is deleted.
    //


    // For legacy joysticks only
    USHORT      NumberAxis;
    USHORT      NumberButtons;
    GAMEENUM_PORTION Portion;

    LIST_ENTRY  Link;
    // the link point to hold all the PDOs for a single bus together
} PDO_DEVICE_DATA, *PPDO_DEVICE_DATA;


//
// The device extension of the bus itself.  From whence the PDO's are born.
//

typedef struct _FDO_DEVICE_DATA
{
    COMMON_DEVICE_DATA;

    BOOLEAN         MappedPorts;
    // Were the ports mapped with MmMapIoSpace?
    BOOLEAN         PowerQueryLock;
    // Are we currently in a query power state?
    BOOLEAN         Started;
    // Are we on, have resources, etc?
    BOOLEAN         Removed;
    // Has this device been removed?  Should we fail any requests?

    PDEVICE_OBJECT  UnderlyingPDO;
    PDEVICE_OBJECT  TopOfStack;
    // the underlying bus PDO and the actual device object to which our
    // FDO is attached

    LIST_ENTRY      PDOs;
    ULONG           NumPDOs;
    // The PDOs currently enumerated.

    FAST_MUTEX      Mutex;
    // A syncronization for access to the device extension.

    ULONG           OutstandingIO;
    // the number of IRPs sent from the bus to the underlying device object
    // can't use NT RtlRemoveLocks b/c win 9x does not have them

    KEVENT          RemoveEvent;
    // On remove device plugplay request we must wait until all outstanding
    // requests have been completed before we can actually delete the device
    // object.

    UNICODE_STRING DevClassAssocName;
    // The name returned from IoRegisterDeviceClass Association,
    // which is used as a handle for IoSetDev... and friends.

    PHYSICAL_ADDRESS    PhysicalAddress;
    PGAMEENUM_READPORT  ReadPort;
    PGAMEENUM_WRITEPORT WritePort;
    PVOID               GamePortAddress;
    ULONG               GamePortAddressLength;

    //
    // If there is a bus lower filter these will be used after sanity checks
    //
    PVOID                  LowerPortContext;
    PGAMEENUM_ACQUIRE_PORT LowerAcquirePort;
    PGAMEENUM_RELEASE_PORT LowerReleasePort;

    LONG                UniqueIDCount;

    KEVENT              PoweredDownEvent;
    LONG                PoweredDownDevices;

    LONG             Acquired;
} FDO_DEVICE_DATA, *PFDO_DEVICE_DATA;

#define FDO_FROM_PDO(pdoData) ((PFDO_DEVICE_DATA) (pdoData)->ParrentFdo->DeviceExtension)


//
// Prototypes
//

NTSTATUS
Game_CreateClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Game_IoCtl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Game_InternIoCtl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Game_SystemControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
Game_DriverUnload (
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
Game_CompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Pirp,
    IN PVOID            Context
    );

NTSTATUS
Game_SendIrpSynchronously (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN BOOLEAN NotImplementedIsValid,
    IN BOOLEAN CopyToNext   
    );

NTSTATUS
Game_PnP (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Game_Power (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Game_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT BusDeviceObject
    );

VOID
Game_InitializePdo (
    PDEVICE_OBJECT      Pdo,
    PFDO_DEVICE_DATA    FdoData
    );

NTSTATUS
Game_CheckHardwareIDs (
    PWCHAR                      pwszTestId,
    PULONG                      puLenLimit,
    PFDO_DEVICE_DATA            FdoData
    );

NTSTATUS
Game_Expose (
    PGAMEENUM_EXPOSE_HARDWARE   Expose,
    ULONG                       ExposeLength,
    PFDO_DEVICE_DATA            DeviceData
    );

NTSTATUS
Game_ExposeSibling (
    PGAMEENUM_EXPOSE_SIBLING    ExposeSibling,
    PPDO_DEVICE_DATA            SiblingPdo
    );

NTSTATUS
Game_Remove (
    PGAMEENUM_REMOVE_HARDWARE   Remove,
    PFDO_DEVICE_DATA            DeviceData
    );

NTSTATUS
Game_RemoveSelf (
    PPDO_DEVICE_DATA            DeviceData
    );

NTSTATUS
Game_RemoveEx (
    PDEVICE_OBJECT              RemoveDO,
    PFDO_DEVICE_DATA            DeviceData
    );

void 
Game_RemoveFdo (
    PFDO_DEVICE_DATA    FdoData
    );

NTSTATUS
Game_RemovePdo (
    PDEVICE_OBJECT      Device,
    PPDO_DEVICE_DATA    PdoData
    );

NTSTATUS
Game_ListPorts (
    PGAMEENUM_PORT_DESC Desc,
    PFDO_DEVICE_DATA    DeviceData
    );

NTSTATUS
Game_PortParameters (
    PGAMEENUM_PORT_PARAMETERS   Parameters,
    PPDO_DEVICE_DATA            PdoDeviceData
    );

NTSTATUS
Game_FDO_PnP (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpStack,
    IN PFDO_DEVICE_DATA     DeviceData
    );

NTSTATUS
Game_PDO_PnP (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpStack,
    IN PPDO_DEVICE_DATA     DeviceData
    );

NTSTATUS
Game_StartFdo (
    IN  PFDO_DEVICE_DATA            FdoData,
    IN  PCM_PARTIAL_RESOURCE_LIST   partialResourceList,
    IN  PCM_PARTIAL_RESOURCE_LIST   partialResourceListTranslated
    );

NTSTATUS
Game_IncIoCount (
    PFDO_DEVICE_DATA   Data
    );

VOID
Game_DecIoCount (
    PFDO_DEVICE_DATA   Data
    );

NTSTATUS
Game_FDO_Power (
    PFDO_DEVICE_DATA    FdoData,
    PIRP                Irp
    );

NTSTATUS
Game_PDO_Power (
    PPDO_DEVICE_DATA    PdoData,
    PIRP                Irp
    );

NTSTATUS
Game_AcquirePort (
    PFDO_DEVICE_DATA    FdoData
    );

VOID
Game_ReleasePort (
    PFDO_DEVICE_DATA    FdoData
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\hidgame\hidgame.h ===
/*++

Copyright (c) 1998 - 1999  Microsoft Corporation

Module Name:

    hidgame.h

Abstract:  Contains definitions of all constants and
           data types for the joystick driver.


Environment:

    Kernel mode

@@BEGIN_DDKSPLIT
Author:

    Eliyas Yakub (Mar, 10, 1997)

Revision History:

    Updated by Eliyas on Feb 5 1998
    OmSharma ( April 12, 1998)
    MarcAnd     02-Jul-98   Quick tidy for DDK

@@END_DDKSPLIT

--*/
/*****************************************************************************
 * @doc     EXTERNAL
 *
 * @module  HidGame | Analog WDM/HID Joystick driver.
 *
 *          HidGame is the HID minidriver for analog joysticks.
 *          This driver registers with the HID class driver and
 *          responds to IRPs put out by HIDclass. It informs HIDClass
 *          about the capabilities of the joystick and polls the joystick
 *          in response to a read IOCTL.
 *
 *          This driver is loaded in reponse to a "New hardware Found"
 *          PnP event, and consequently must have an entry in an inf file
 *          that binds a PnP hardware ID to this driver.
 *
 *          Gameport joysticks are not true PnP devices, so the user has to
 *          inform the system about the joystick that was added to the 
 *          gameport by using the Game Controllers CPL "Add" a joystick.
 *          An example of how a new joystick type can be created is provided 
 *          in the accompanying inf file.
 *
 *          Once a user selects a joystick and gameport, the GameCPL passes 
 *          this information to DirectInput which sends an IOCTL to the 
 *          gameport bus driver (GameEnum), specifying the number of axes, 
 *          buttons and a PnPHardware ID for the joystick. The Gameport Bus 
 *          informs PnP of a new device arrival. PnP searches the system for 
 *          a match for the hardwareID and loads the appropriate driver.
 *
 *
 *          The following files are part of this driver.
 *
 *          <nl>HidGame.c
 *              <nl>DriverEntry, CreateClose, AddDevice and Unload Routines.
 *              This code performs functions required for any device driver 
 *              and so can probably be used without changes for any game 
 *              other game device.
 *
 *          <nl>PnP.c
 *              <nl>Support routines for PnP IOCTLs.
 *              
 *          <nl>Ioctl.c
 *              <nl>Support routines for Non PnP IOCTLs
 *              These deal with all the HID IOCTLs required for an ordinary 
 *              game device and so could be used without change as there is 
 *              no analog specific funtionality in these routines.  
 *              Drivers for some devices may need to add code to support more 
 *              complex devices.
 *
 *          <nl>HidJoy.c
 *              <nl>Support routines to translate legacy joystick flags and 
 *              data into HID descriptors.  The majority of this code is 
 *              needed to support the wide variety of analog joysticks 
 *              available so is not relevant to drivers written for specific 
 *              devices.
 *
 *          <nl>Poll.c
 *              <nl>Support routines to read analog joystick data from a 
 *              gameport.  These functions are likely to be of little use 
 *              in a digital joystick driver.
 *
 *          <nl>i386\timing.c
 *              <nl>Support routines to use x86 Time Stamp Counter.
 *              Includes code to check for the presence of, calibrate and 
 *              read the high speed CPU timer.
 *
 *          <nl>Hidgame.h
 *              <nl>Common include file.
 *              The general definitions are likely to be of use in most 
 *              drivers for game devices but some customization will be needed.
 *
 *          <nl>Debug.h
 *              <nl>Definitions to aid debugging.
 *              This contains the tag for the driver name used in debug output 
 *              which must be changed.
 *
 *          <nl>Analog.h
 *              <nl>Specific include file.
 *              Definitions specific to analog joystick devices.
 *
 *          <nl>OemSetup.inf
 *              <nl>Sample inf file.
 *              See comments in this file for how to install devices.
 *
 *          <nl>Source
 *              <nl> Source file for the NT build utility
 *
 *          <nl>Makefile
 *              <nl> Used as part of the build process
 *
 *****************************************************************************/
#ifndef __HIDGAME_H__
    #define __HIDGAME_H__

/* @@BEGIN_DDKSPLIT
 *
 *  Only define CHANGE_DEVICE in DDK sample
 */
#if 0
/* @@END_DDKSPLIT */
/*
 *  When CHANGE_DEVICE is defined it turns on code to use expose sibling and
 *  remove self to allow the driver to change its capabilities on-the-fly.
 *  This code is not used in the retail version of HIDGame.
 */
    #define CHANGE_DEVICE
/* @@BEGIN_DDKSPLIT */
#endif
/* @@END_DDKSPLIT */

/* @@BEGIN_DDKSPLIT  Disable common benign warnings for W4 testing */
    #pragma warning( disable:4514 ) /* unreferenced inline function has been removed */
    #pragma warning( disable:4214 ) /* nonstandard extension used : bit field types other than int */
/* @@END_DDKSPLIT */

/*
 *  Include Files
 */
    #include "wdm.h"
    #include "hidtoken.h"
    #include "hidusage.h"
    #include "hidport.h"
    #include "gameport.h"
    #include "debug.h"
    #include "analog.h"

/*
 *  A value guaranteed to be considered a timeout
 */
    #define AXIS_TIMEOUT            ( 0xffffffffL )




/* 
 *  Define a tag to mark memory allocations made by this driver 
 *  so they can be recognized.  This is for illustration only as 
 *  this driver does not make any explicite memory allocations.
 */
    #define HGM_POOL_TAG              ('maGH')

    #define ExAllocPool( Type, Size ) \
            ExAllocatePoolWithTag( Type, Size, HGM_POOL_TAG )

/*
 *  Defines for hidgame
 */

    #define HIDGAME_VERSION_NUMBER  ((USHORT) 1)

    #define JOY_START_TIMERS        ( 0 )


    #define MAXBYTES_GAME_REPORT    ( 256 )

    #define BUTTON_1   0x10
    #define BUTTON_2   0x20
    #define BUTTON_3   0x40
    #define BUTTON_4   0x80

    #define AXIS_X     0x01
    #define AXIS_Y     0x02
    #define AXIS_R     0x04
    #define AXIS_Z     0x08

    #define BUTTON_BIT 0
    #define BUTTON_ON ( 1 << BUTTON_BIT )


/*
 *  Function type used for timing.  
 *  MUST be compatible with KeQueryPerformanceCounter 
 */
typedef
LARGE_INTEGER
(*COUNTER_FUNCTION) (
    PLARGE_INTEGER  pDummy
    );



/*
 *  Typedef the structs we need
 */

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @struct HIDGAME_GLOBAL |
 *
 *          Global struct to store driver wide data.
 *          Stuff we need to share across multiple instances of this driver.
 *
 *  @field  FAST_MUTEX | Mutex |
 *
 *          Mutex to synchronize access to the following list entry
 *
 *  @field  LIST_ENTRY | DeviceListHead |
 *
 *          Keeps a list of all devices.
 *
 *  @field  KSPIN_LOCK | SpinLock | 
 *
 *          Spinlock used to stop multiple processors polling gameports at 
 *          once.  It would be better to keep a list of spinlocks, one for 
 *          each gameport but then processors could contend for IO access 
 *          and we'd have to maintain another list.
 *
 *  @field  COUNTER_FUNCTION | ReadCounter | 
 *
 *          Function to retrieve clock time
 *
 *  @field  ULONG | CounterScale | 
 *
 *          The scale to be used.
 *
 *****************************************************************************/
typedef struct _HIDGAME_GLOBAL
{
    FAST_MUTEX          Mutex;          /* A syncronization for access to list */
    LIST_ENTRY          DeviceListHead; /* Keeps list of all the devices */
    KSPIN_LOCK          SpinLock;       /* Lock so that only one port is accessed */
    COUNTER_FUNCTION    ReadCounter;    /* Function to retrieve clock time */
    ULONG               CounterScale;   /* Clock scale factor */
} HIDGAME_GLOBAL;



/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @struct DEVICE_EXTENSION |
 *
 *          Device specific data.
 *
 *  @field  PGAMEENUM_READPORT | ReadAccessor |
 *
 *          Read Accessor function for the gameport. Obtained in the return from
 *          IOCTL to the gameport.
 *
 *  @field  PGAMEENUM_WRITEPORT | WriteAccessor |
 *
 *          Write Accessor function for the gameport. Obtained in the return from
 *          IOCTL to the gameport.
 *
 *  @field  PGAMEENUM_READPORT_DIGITAL | ReadAccessorDigital |
 *
 *          Digital read accessor for the gameport. Obtained as part of return from
 *          IOCTL to the gameport
 *
 *  @field  PGAMEENUM_ACQUIRE_PORT | AcquirePort |
 *
 *          Function to call before reading/writing to the port. Obtained as 
 *          part of return from IOCTL to the gameport
 *
 *  @field  PGAMEENUM_RELEASE_PORT | ReleasePort |
 *
 *          Function to call when done reading/writing to the port. Obtained as 
 *          part of return from IOCTL to the gameport
 *
 *  @field  PVOID    | GameContext |
 *
 *          Token to read this game port. Obtained as part of the return from
 *          IOCTL to the gameport.
 *
 *  @field  PVOID    | PortContext |
 *
 *          Context to pass to AcquirePort and ReleasePort. Obtained as part 
 *          of the return from IOCTL to the gameport.
 *
 *  @field  LIST_ENTRY  | Link |
 *
 *          Link to other hidgame devices on the system.
 *
 *  @field  KEVENT | RemoveEvent |
 *
 *          The remove plugplay request must use this event to make sure all 
 *          other requests have completed before it deletes the device object.
 *
 *  @field  LONG | RequestCount |
 *
 *          Number of IRPs underway.
 *
 *  @field  PDEVICE_OBJECT | NextDeviceObject |
 *
 *          NOTE: Only present if CHANGE_DEVICE is defined
 *
 *          DeviceObject to send self created IRPs down to
 *
 *  @field  ANALOG_DEVICE | unnamed structure see ANALOG_DEVICE |
 *          
 *          Structure containing analog device specific information.
 *
 *          NOTE: this structure is placed after the DWORD aligned elements.
 *
 *  @xref   <t ANALOG_DEVICE>.
 *
 *  @field  BOOLEAN | fRemoved |
 *
 *          Set to true if the device has been removed => all requests should be failed
 *
 *  @field  BOOLEAN | fStarted |
 *
 *          Set to true is device has started.
 *
 *  @field  BOOLEAN | fSurpriseRemoved |
 *
 *          Set to true if the device has been surprise removed by PnPs device has started.
 *
 *****************************************************************************/
typedef struct _DEVICE_EXTENSION
{
    /*
     *  read accessor for the game port
     */
    PGAMEENUM_READPORT          ReadAccessor;

    /*
     *  write the game port
     */
    PGAMEENUM_WRITEPORT         WriteAccessor;

    /*
     *  Digital read accessor for the gameport
     */
    PGAMEENUM_READPORT_DIGITAL  ReadAccessorDigital;

    /*
     * Function to call before reading/writing to the port
     */
    PGAMEENUM_ACQUIRE_PORT      AcquirePort;

    /*
     * Function to call when done reading/writing to the port
     */
    PGAMEENUM_RELEASE_PORT      ReleasePort;
    
    /*
     *  token to read this game port
     */
    PVOID                       GameContext;

    /* 
     * Context to pass to AcquirePort and ReleasePort
     */
    PVOID                       PortContext;

    /*
     *  List of other joystick devices
     */
    LIST_ENTRY                  Link;

    /*
     *  The remove plugplay request must use this event to make sure all 
     *  other requests have completed before it deletes the device object.
     */
    KEVENT                      RemoveEvent;

    /*
     *  Number of IRPs underway.
     */
    LONG                        RequestCount;


#ifdef CHANGE_DEVICE 
    /*
     *  DeviceObject to send self created IRPs down to.
     */
    PDEVICE_OBJECT              NextDeviceObject;

#endif /* CHANGE_DEVICE */

    /*
     *  Structure containing analog device specific information.
     */
    ANALOG_DEVICE;

    /*
     *  Set to true if the device has been removed => all requests should be failed
     */
    BOOLEAN                     fRemoved;

    /*
     *  Set to true if the device has started
     */
    BOOLEAN                     fStarted;

    /*
     *  Set to true if the device has been surprise removed by PnPs device has started.
     */
    BOOLEAN                     fSurpriseRemoved;

#ifdef CHANGE_DEVICE
    /*
     *  Indicates that a replacement sibling is being started
     */
    BOOLEAN                     fReplaced;
#endif /* CHANGE_DEVICE */

}  DEVICE_EXTENSION, *PDEVICE_EXTENSION;

    #define GET_MINIDRIVER_DEVICE_EXTENSION(DO)  \
    ((PDEVICE_EXTENSION) (((PHID_DEVICE_EXTENSION)(DO)->DeviceExtension)->MiniDeviceExtension))

    #define GET_NEXT_DEVICE_OBJECT(DO) \
    (((PHID_DEVICE_EXTENSION)(DO)->DeviceExtension)->NextDeviceObject)



/*
 *  Globals
 */
extern HIDGAME_GLOBAL Global;

/*
 * Function prototypes
 */

    #define INTERNAL   /* Called only within a translation unit */
    #define EXTERNAL   /* Called from other translation units */


/*
 *  hidgame.c
 */
NTSTATUS EXTERNAL
    DriverEntry
    (
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING registryPath
    );

NTSTATUS EXTERNAL
    HGM_CreateClose
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS EXTERNAL
    HGM_SystemControl
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS  EXTERNAL
    HGM_AddDevice
    (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT FunctionalDeviceObject
    );

VOID EXTERNAL
    HGM_Unload
    (
    IN PDRIVER_OBJECT DriverObject
    );

/*
 *  ioctl.c
 */


NTSTATUS EXTERNAL
    HGM_InternalIoctl
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS EXTERNAL
    HGM_GetDeviceDescriptor
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS INTERNAL
    HGM_GetReportDescriptor
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS INTERNAL
    HGM_ReadReport
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS INTERNAL
    HGM_GetAttributes
    (
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

/*
 *  pnp.c
 */

NTSTATUS INTERNAL
    HGM_IncRequestCount
    (
    PDEVICE_EXTENSION DeviceExtension
    );

VOID INTERNAL
    HGM_DecRequestCount
    (
    PDEVICE_EXTENSION DeviceExtension
    );

VOID INTERNAL
    HGM_RemoveDevice
    (
    PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS  EXTERNAL
    HGM_PnP
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS INTERNAL
    HGM_InitDevice
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS INTERNAL
    HGM_Power
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp
    );

NTSTATUS INTERNAL
    HGM_GetResources
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS INTERNAL
    HGM_PnPComplete
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


/*
 *  hidjoy.c
 */
NTSTATUS EXTERNAL
    HGM_DriverInit
    (
    VOID
    );

NTSTATUS INTERNAL
    HGM_SetupButtons
    (
    IN OUT PDEVICE_EXTENSION DeviceExtension 
    );

NTSTATUS INTERNAL
    HGM_MapAxesFromDevExt
    (
    IN OUT PDEVICE_EXTENSION DeviceExtension 
    );

NTSTATUS INTERNAL
    HGM_GenerateReport
    (
    IN PDEVICE_OBJECT   DeviceObject,
    OUT UCHAR           rgGameReport[MAXBYTES_GAME_REPORT],
    OUT PUSHORT         pCbReport
    );


NTSTATUS INTERNAL
    HGM_JoystickConfig
    (
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS EXTERNAL
    HGM_InitAnalog
    (
    IN PDEVICE_OBJECT         DeviceObject
    );

/*
 *  Sample only code for changing the device
 */
#ifdef CHANGE_DEVICE 

VOID
    HGM_ChangeHandler
    ( 
    IN PDEVICE_OBJECT               DeviceObject,
    PIO_WORKITEM                    WorkItem
    );

VOID
    HGM_DeviceChanged
    ( 
    IN      PDEVICE_OBJECT          DeviceObject,
    IN  OUT PDEVICE_EXTENSION       DeviceExtension
    );

VOID 
    HGM_Game2HID
    (
    IN      PDEVICE_OBJECT          DeviceObject,
    IN      PDEVICE_EXTENSION       DeviceExtension,
    IN  OUT PUHIDGAME_INPUT_DATA    pHIDData
    );
 
#else

VOID 
    HGM_Game2HID
    (
    IN      PDEVICE_EXTENSION       DeviceExtension,
    IN  OUT PUHIDGAME_INPUT_DATA    pHIDData
    );

#endif /* CHANGE_DEVICE */
 
/*
 *  poll.c
 */

NTSTATUS  INTERNAL
    HGM_AnalogPoll
    (
    IN PDEVICE_EXTENSION    DeviceExtension,
    IN UCHAR                resistiveInputMask,
    IN BOOLEAN              bApproximate,
    IN OUT ULONG            Axis[MAX_AXES],
    OUT UCHAR               Buttons[PORT_BUTTONS]
    );

NTSTATUS
    HGM_UpdateLatestPollData
    ( 
    IN  OUT PDEVICE_EXTENSION   DeviceExtension
    );

/*
 * <CPU>\timing.c (or macro equivalents for external functions)
 */


#ifdef _X86_
BOOLEAN INTERNAL
    HGM_x86IsClockAvailable
    (
    VOID
    );

LARGE_INTEGER INTERNAL
    HGM_x86ReadCounter
    (
    IN      PLARGE_INTEGER      Dummy
    );

VOID INTERNAL
    HGM_x86SampleClocks
    (
    OUT PULONGLONG  pTSC,
    OUT PULONGLONG  pQPC
    );

BOOLEAN EXTERNAL
    HGM_x86CounterInit();
#define HGM_CPUCounterInit HGM_x86CounterInit

#else

/*
 *  For all other processors a value to cause the default timing to be used
 */

#define HGM_CPUCounterInit() FALSE

#endif /* _X86_ */


#endif  /* __HIDGAME_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\hidgame\hidgame.c ===
/*++

Copyright (c) 1998 - 1999  Microsoft Corporation

Module Name:

    hidgame.c

Abstract: Human Interface Device (HID) Gameport driver

Environment:

    Kernel mode

@@BEGIN_DDKSPLIT
Author:

    Eliyas Yakub (Mar, 10, 1997)

Revision History:

    Updated by Eliyas on Feb 5 1998
    OmSharma ( April 12, 1998 )
    MarcAnd     02-Jul-98   Quick tidy for DDK

@@END_DDKSPLIT

--*/


#include "hidgame.h"

#ifdef ALLOC_PRAGMA
    #pragma alloc_text( INIT, DriverEntry )
    #pragma alloc_text( PAGE, HGM_CreateClose)
    #pragma alloc_text( PAGE, HGM_AddDevice)
    #pragma alloc_text( PAGE, HGM_Unload)
    #pragma alloc_text( PAGE, HGM_SystemControl)
#endif /* ALLOC_PRAGMA */

HIDGAME_GLOBAL Global;
ULONG          debugLevel;

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | DriverEntry |
 *
 *          Installable driver initialization entry point.
 *          <nl>This entry point is called directly by the I/O system.
 *
 *  @parm   IN PDRIVER_OBJECT | DriverObject |
 *
 *          Pointer to the driver object
 *
 *  @parm   IN PUNICODE_STRING | RegistryPath |
 *
 *          Pointer to a unicode string representing the path,
 *          to driver-specific key in the registry.
 *
 *  @rvalue   STATUS_SUCCESS | success
 *  @rvalue   ???            | returned HidRegisterMinidriver()
 *
 *****************************************************************************/
NTSTATUS EXTERNAL
    DriverEntry
    (
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    NTSTATUS                        ntStatus;
    HID_MINIDRIVER_REGISTRATION     hidMinidriverRegistration;

    debugLevel = HGM_DEFAULT_DEBUGLEVEL;

    HGM_DBGPRINT(FILE_HIDGAME| HGM_WARN, \
                   ("Hidgame.sys: Built %s at %s\n", __DATE__, __TIME__));

    HGM_DBGPRINT( FILE_HIDGAME | HGM_FENTRY,
                    ("DriverEntry(DriverObject=0x%x,RegistryPath=0x%x)",
                     DriverObject, RegistryPath)
                  );

    C_ASSERT(sizeof( OEMDATA[2] ) == sizeof(GAMEENUM_OEM_DATA) );


    ntStatus = HGM_DriverInit();

    if( NT_SUCCESS(ntStatus) )
    {
        DriverObject->MajorFunction[IRP_MJ_CREATE]    =
            DriverObject->MajorFunction[IRP_MJ_CLOSE] = HGM_CreateClose;
        DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] =
            HGM_InternalIoctl;
        DriverObject->MajorFunction[IRP_MJ_PNP]   = HGM_PnP;
        DriverObject->MajorFunction[IRP_MJ_POWER] = HGM_Power;
        DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = HGM_SystemControl;
        DriverObject->DriverUnload                = HGM_Unload;
        DriverObject->DriverExtension->AddDevice  = HGM_AddDevice;

        /*
         * Register  with HID.SYS module
         */
        RtlZeroMemory(&hidMinidriverRegistration, sizeof(hidMinidriverRegistration));

        hidMinidriverRegistration.Revision            = HID_REVISION;
        hidMinidriverRegistration.DriverObject        = DriverObject;
        hidMinidriverRegistration.RegistryPath        = RegistryPath;
        hidMinidriverRegistration.DeviceExtensionSize = sizeof(DEVICE_EXTENSION);
        hidMinidriverRegistration.DevicesArePolled    = TRUE;


        HGM_DBGPRINT( FILE_HIDGAME |  HGM_BABBLE2,
                        ("DeviceExtensionSize = %d",
                         hidMinidriverRegistration.DeviceExtensionSize)
                      );

        ntStatus = HidRegisterMinidriver(&hidMinidriverRegistration);


        HGM_DBGPRINT(FILE_HIDGAME | HGM_BABBLE2,
                       ("Registered with HID.SYS, returnCode=%x",
                        ntStatus)
                      );

        if( NT_SUCCESS(ntStatus) )
        {
            /*
             *  Protect the list with a Mutex
             */
            ExInitializeFastMutex (&Global.Mutex);

            /*
             *  Initialize the device list head
             */
            InitializeListHead(&Global.DeviceListHead);

            /*
             *  Initialize gameport access spinlock
             */
            KeInitializeSpinLock(&Global.SpinLock);
        }
        else
        {
            HGM_DBGPRINT(FILE_HIDGAME | HGM_ERROR,
                           ("Failed to registered with HID.SYS, returnCode=%x",
                            ntStatus)
                          );
        }
    }
    else
    {
        HGM_DBGPRINT(FILE_HIDGAME | HGM_ERROR,
                       ("Failed to initialize a timer")
                      );
    }


    HGM_EXITPROC(FILE_HIDGAME | HGM_FEXIT_STATUSOK , "DriverEntry", ntStatus);

    return ntStatus;
} /* DriverEntry */


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_CreateClose |
 *
 *          Process the create and close IRPs sent to this device.
 *
 *  @parm   IN PDEVICE_OBJECT | DeviceObject |
 *
 *          Pointer to the device object
 *
 *  @parm   IN PIRP | Irp |
 *
 *          Pointer to an I/O Request Packet.
 *
 *  @rvalue   STATUS_SUCCESS | success
 *  @rvalue   STATUS_INVALID_PARAMETER  | Irp not handled
 *
 *****************************************************************************/
NTSTATUS EXTERNAL
    HGM_CreateClose
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION   IrpStack;
    NTSTATUS             ntStatus = STATUS_SUCCESS;

    PAGED_CODE ();

    HGM_DBGPRINT(FILE_HIDGAME | HGM_FENTRY,
                   ("HGM_CreateClose(DeviceObject=0x%x,Irp=0x%x)",
                    DeviceObject, Irp) );

    /*
     * Get a pointer to the current location in the Irp.
     */
    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    switch(IrpStack->MajorFunction)
    {
        case IRP_MJ_CREATE:
            HGM_DBGPRINT(FILE_HIDGAME | HGM_BABBLE,
                           ("HGM_CreateClose:IRP_MJ_CREATE") );
            Irp->IoStatus.Information = 0;
            break;

        case IRP_MJ_CLOSE:
            HGM_DBGPRINT(FILE_HIDGAME | HGM_BABBLE,
                           ("HGM_CreateClose:IRP_MJ_CLOSE") );
            Irp->IoStatus.Information = 0;
            break;

        default:
            HGM_DBGPRINT(FILE_HIDGAME | HGM_WARN,
                           ("HGM_CreateClose:Not handled IrpStack->MajorFunction 0x%x",
                            IrpStack->MajorFunction) );
            ntStatus = STATUS_INVALID_PARAMETER;
            break;
    }

    /*
     * Save Status for return and complete Irp
     */

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    HGM_EXITPROC(FILE_HIDGAME | HGM_FEXIT_STATUSOK, "HGM_CreateClose", ntStatus);
    return ntStatus;
} /* HGM_CreateClose */


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_AddDevice |
 *
 *          Called by hidclass, allows us to initialize our device extensions.
 *
 *  @parm   IN PDRIVER_OBJECT | DriverObject |
 *
 *          Pointer to the driver object
 *
 *  @parm   IN PDEVICE_OBJECT | FunctionalDeviceObject |
 *
 *          Pointer to a functional device object created by hidclass.
 *
 *  @rvalue   STATUS_SUCCESS | success
 *
 *****************************************************************************/
NTSTATUS  EXTERNAL
    HGM_AddDevice
    (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT FunctionalDeviceObject
    )
{
    NTSTATUS                ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT          DeviceObject;
    PDEVICE_EXTENSION       DeviceExtension;

    PAGED_CODE ();

    HGM_DBGPRINT( FILE_HIDGAME | HGM_FENTRY,
                    ("HGM_AddDevice(DriverObject=0x%x,FunctionalDeviceObject=0x%x)",
                     DriverObject, FunctionalDeviceObject) );

    ASSERTMSG("HGM_AddDevice:", FunctionalDeviceObject != NULL);
    DeviceObject = FunctionalDeviceObject;

    /*
     * Initialize the device extension.
     */
    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION (DeviceObject);

    DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    /*
     * Initialize the list
     */
    InitializeListHead(&DeviceExtension->Link);

    /*
     *  Acquire mutex before modifying the Global Linked list of devices
     */
    ExAcquireFastMutex (&Global.Mutex);

    /*
     * Add this device to the linked list of devices
     */
    InsertTailList(&Global.DeviceListHead, &DeviceExtension->Link);

    /*
     *  Release the mutex
     */
    ExReleaseFastMutex (&Global.Mutex);

    /*
     * Initialize the remove lock 
     */
    DeviceExtension->RequestCount = 1;
    KeInitializeEvent(&DeviceExtension->RemoveEvent,
                      SynchronizationEvent,
                      FALSE);

    HGM_EXITPROC(FILE_HIDGAME | HGM_FEXIT_STATUSOK, "HGM_AddDevice", ntStatus);

    return ntStatus;
} /* HGM_AddDevice */


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_SystemControl |
 *
 *          Process the WMI IRPs sent to this device.
 *
 *  @parm   IN PDEVICE_OBJECT | DeviceObject |
 *
 *          Pointer to the device object
 *
 *  @parm   IN PIRP | Irp |
 *
 *          Pointer to an I/O Request Packet.
 *
 *  @rvalue   STATUS_SUCCESS | success
 *  @rvalue   STATUS_INVALID_PARAMETER  | Irp not handled
 *
 *****************************************************************************/
NTSTATUS EXTERNAL
    HGM_SystemControl
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PAGED_CODE ();

    HGM_DBGPRINT(FILE_HIDGAME | HGM_FENTRY,
                   ("HGM_SystemControl(DeviceObject=0x%x,Irp=0x%x)",
                    DeviceObject, Irp) );

    IoSkipCurrentIrpStackLocation(Irp);

    return IoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);
} /* HGM_SystemControl */

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   void  | HGM_Unload |
 *
 *          Free all the allocated resources, etc.
 *
 *  @parm   IN PDRIVER_OBJECT | DeviceObject |
 *
 *          Pointer to the driver object
 *
 *
 *****************************************************************************/
VOID EXTERNAL
    HGM_Unload
    (
    IN PDRIVER_OBJECT DriverObject
    )
{
    PAGED_CODE();
    HGM_DBGPRINT(FILE_HIDGAME | HGM_FENTRY,
                   ("HGM_Unload Enter"));


    /*
     * All the device objects should be gone
     */

    ASSERT ( NULL == DriverObject->DeviceObject);

    HGM_EXITPROC(FILE_HIDGAME | HGM_FEXIT_STATUSOK, "HGM_Unload:", STATUS_SUCCESS );
    return;
} /* HGM_Unload */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\gameenum\sys\pnp.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    PNP.C

Abstract:

    This module contains contains the plugplay calls
    PNP / WDM BUS driver.

@@BEGIN_DDKSPLIT

Author:

    Kenneth D. Ray
    Doron J. Holan
    
@@END_DDKSPLIT

Environment:

    kernel mode only

Notes:


Revision History:


--*/

#include <wdm.h>
#include "gameport.h"
#include "gameenum.h"
#include "stdio.h"

#define HWID_TEMPLATE L"gameport"
#define HWID_TEMPLATE_LENGTH 8
#define LOWERCASE(_x_) (_x_|0x20)
#define MAX_DEVICE_ID_LEN     300

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, Game_AddDevice)
#pragma alloc_text (PAGE, Game_SystemControl)
#pragma alloc_text (PAGE, Game_PnP)
#pragma alloc_text (PAGE, Game_Power)
#pragma alloc_text (PAGE, Game_FDO_Power)
#pragma alloc_text (PAGE, Game_PDO_Power)
#pragma alloc_text (PAGE, Game_InitializePdo)
#pragma alloc_text (PAGE, Game_CheckHardwareIDs)
#pragma alloc_text (PAGE, Game_Expose)
#pragma alloc_text (PAGE, Game_ExposeSibling)
#pragma alloc_text (PAGE, Game_Remove)
#pragma alloc_text (PAGE, Game_RemoveSelf)
#pragma alloc_text (PAGE, Game_RemoveEx)
#pragma alloc_text (PAGE, Game_RemovePdo)
#pragma alloc_text (PAGE, Game_RemoveFdo)
#pragma alloc_text (PAGE, Game_ListPorts)
#pragma alloc_text (PAGE, Game_FDO_PnP)
#pragma alloc_text (PAGE, Game_PDO_PnP)
#endif

NTSTATUS
Game_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT BusPhysicalDeviceObject
    )
/*++
Routine Description.
    A bus has been found.  Attach our FDO to it.
    Allocate any required resources.  Set things up.  And be prepared for the
    first ``start device.''

Arguments:
    BusPhysicalDeviceObject - Device object representing the bus.  That to which we
                      attach a new FDO.

    DriverObject - This very self referenced driver.

--*/
{
    NTSTATUS            status;
    PDEVICE_OBJECT      deviceObject;
    PFDO_DEVICE_DATA    deviceData;

#if DBG
    ULONG               nameLength;
    PWCHAR              deviceName;
#endif

    PAGED_CODE ();

    Game_KdPrint_Def (GAME_DBG_SS_TRACE, ("Add Device: 0x%x\n",
                                          BusPhysicalDeviceObject));

    status = IoCreateDevice (
                    DriverObject,  // our driver object
                    sizeof (FDO_DEVICE_DATA), // device object extension size
                    NULL, // FDOs do not have names
                    FILE_DEVICE_BUS_EXTENDER,
                    FILE_DEVICE_SECURE_OPEN, // No special characteristics
                    TRUE, // our FDO is exclusive
                    &deviceObject); // The device object created

    if (NT_SUCCESS (status)) {
        deviceData = (PFDO_DEVICE_DATA) deviceObject->DeviceExtension;
        RtlFillMemory (deviceData, sizeof (FDO_DEVICE_DATA), 0);

#if DBG
        deviceData->DebugLevel = GameEnumDebugLevel;
#endif
        deviceData->IsFDO = TRUE;
        deviceData->Self = deviceObject;
        ExInitializeFastMutex (&deviceData->Mutex);

        deviceData->Removed = FALSE;
        InitializeListHead (&deviceData->PDOs);

        // Set the PDO for use with PlugPlay functions
        deviceData->UnderlyingPDO = BusPhysicalDeviceObject;

        //
        // Will get preincremented everytime a new PDO is created ... want the
        // first ID to be zero
        //
        deviceData->UniqueIDCount = GAMEENUM_UNIQUEID_START;

        //
        // Attach our filter driver to the device stack.
        // the return value of IoAttachDeviceToDeviceStack is the top of the
        // attachment chain.  This is where all the IRPs should be routed.
        //
        // Our filter will send IRPs to the top of the stack and use the PDO
        // for all PlugPlay functions.
        //
        deviceData->TopOfStack = IoAttachDeviceToDeviceStack (
                                        deviceObject,
                                        BusPhysicalDeviceObject);

        if (deviceData->TopOfStack == NULL) {
            IoDeleteDevice(deviceObject);
            return STATUS_DEVICE_NOT_CONNECTED; 
        }
        
        // Bias outstanding request to 1 so that we can look for a
        // transition to zero when processing the remove device PlugPlay IRP.
        deviceData->OutstandingIO = 1;

        KeInitializeEvent(&deviceData->RemoveEvent,
                          SynchronizationEvent,
                          FALSE); // initialized to not signalled

        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
        deviceObject->Flags |= DO_POWER_PAGABLE;

        //
        // Tell the PlugPlay system that this device will need an interface
        // device class shingle.
        //
        // It may be that the driver cannot hang the shingle until it starts
        // the device itself, so that it can query some of its properties.
        // (Aka the shingles guid (or ref string) is based on the properties
        // of the device.)
        //
        status = IoRegisterDeviceInterface (
                    BusPhysicalDeviceObject,
                    (LPGUID) &GUID_GAMEENUM_BUS_ENUMERATOR,
                    NULL, // No ref string
                    &deviceData->DevClassAssocName);

        if (!NT_SUCCESS (status)) {
            Game_KdPrint (deviceData, GAME_DBG_SS_ERROR,
                          ("AddDevice: IoRegisterDeviceInterface failed (%x)", status));
            IoDeleteDevice (deviceObject);
            return status;
        }

        //
        // If for any reason you need to save values in a safe location that
        // clients of this DeviceInterface might be interested in reading
        // here is the time to do so, with the function
        // IoOpenDeviceClassRegistryKey
        // the symbolic link name used is was returned in
        // deviceData->DevClassAssocName (the same name which is returned by
        // IoGetDeviceClassAssociations and the SetupAPI equivs.
        //

#if DBG
        nameLength = 0;
        status = IoGetDeviceProperty (BusPhysicalDeviceObject,
                                      DevicePropertyPhysicalDeviceObjectName,
                                      0,
                                      NULL,
                                      &nameLength);

        // 
        // Proceed only if the PDO has a name
        //
        if (status == STATUS_BUFFER_TOO_SMALL && nameLength != 0) {
    
            deviceName = ExAllocatePool (NonPagedPool, nameLength);
    
            if (NULL == deviceName) {
                IoDeleteDevice (deviceObject);
                Game_KdPrint (deviceData, GAME_DBG_SS_ERROR,
                              ("AddDevice: no memory to alloc DeviceName (0x%x)",
                               nameLength));
                return STATUS_INSUFFICIENT_RESOURCES;
            }
    
            IoGetDeviceProperty (BusPhysicalDeviceObject,
                                 DevicePropertyPhysicalDeviceObjectName,
                                 nameLength,
                                 deviceName,
                                 &nameLength);
    
            Game_KdPrint (deviceData, GAME_DBG_SS_TRACE,
                          ("AddDevice: %x to %x->%x (%ws) \n",
                           deviceObject,
                           deviceData->TopOfStack,
                           BusPhysicalDeviceObject,
                           deviceName));
    
            ExFreePool(deviceName);
        }

        status = STATUS_SUCCESS;
#endif

        if (!NT_SUCCESS (status)) {
            Game_KdPrint (deviceData, GAME_DBG_SS_ERROR,
                          ("AddDevice: IoGetDeviceClass failed (%x)", status));
            return status;
        }
    }

    return status;
}

NTSTATUS
Game_SystemControl (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PCOMMON_DEVICE_DATA commonData;

    PAGED_CODE ();

    commonData = (PCOMMON_DEVICE_DATA) DeviceObject->DeviceExtension;

    if (commonData->IsFDO) {
        IoSkipCurrentIrpStackLocation (Irp);
        return IoCallDriver (((PFDO_DEVICE_DATA) commonData)->TopOfStack, Irp);
    }
    else {
        //
        // The PDO, just complete the request with the current status
        //
        NTSTATUS status = Irp->IoStatus.Status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }
}

NTSTATUS
Game_PnP (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++
Routine Description:
    Answer the plithera of Irp Major PnP IRPS.
--*/
{
    PIO_STACK_LOCATION      irpStack;
    NTSTATUS                status;
    PCOMMON_DEVICE_DATA     commonData;
    KIRQL                   oldIrq;

    PAGED_CODE ();

    status = STATUS_SUCCESS;
    irpStack = IoGetCurrentIrpStackLocation (Irp);
    ASSERT (IRP_MJ_PNP == irpStack->MajorFunction);

    commonData = (PCOMMON_DEVICE_DATA) DeviceObject->DeviceExtension;

    if (commonData->IsFDO) {
        Game_KdPrint (commonData, GAME_DBG_PNP_TRACE,
                      ("PNP: Functional DO: %x IRP: %x\n", DeviceObject, Irp));

        status = Game_FDO_PnP (
                    DeviceObject,
                    Irp,
                    irpStack,
                    (PFDO_DEVICE_DATA) commonData);
    } else {
        Game_KdPrint (commonData, GAME_DBG_PNP_TRACE,
                      ("PNP: Physical DO: %x IRP: %x\n", DeviceObject, Irp));

        status = Game_PDO_PnP (
                    DeviceObject,
                    Irp,
                    irpStack,
                    (PPDO_DEVICE_DATA) commonData);
    }

    return status;
}

NTSTATUS
Game_FDO_PnP (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpStack,
    IN PFDO_DEVICE_DATA     DeviceData
    )
/*++
Routine Description:
    Handle requests from the PlugPlay system for the BUS itself

    NB: the various Minor functions of the PlugPlay system will not be
    overlapped and do not have to be reentrant

--*/
{
    NTSTATUS    status;
    KEVENT      event;
    ULONG       length;
    ULONG       i;
    PLIST_ENTRY entry;
    PPDO_DEVICE_DATA    pdoData;
    PDEVICE_RELATIONS   relations, oldRelations;
    PIO_STACK_LOCATION  stack;

    PAGED_CODE ();

    status = Game_IncIoCount (DeviceData);
    if (!NT_SUCCESS (status)) {
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    stack = IoGetCurrentIrpStackLocation (Irp);

    switch (IrpStack->MinorFunction) {
    case IRP_MN_START_DEVICE:
        //
        // BEFORE you are allowed to ``touch'' the device object to which
        // the FDO is attached (that send an irp from the bus to the Device
        // object to which the bus is attached).   You must first pass down
        // the start IRP.  It might not be powered on, or able to access or
        // something.
        //

        if (DeviceData->Started) {
            status = STATUS_SUCCESS;
            break;
        }

        Game_KdPrint (DeviceData, GAME_DBG_PNP_TRACE, ("Start Device\n"));
        status = Game_SendIrpSynchronously (DeviceData->TopOfStack, Irp, TRUE, TRUE);

        if (NT_SUCCESS(status)) {

            //
            // Now we can touch the lower device object as it is now started.
            //
            if ((NULL == stack->Parameters.StartDevice.AllocatedResources) ||
                (NULL == stack->Parameters.StartDevice.AllocatedResourcesTranslated)) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            status = Game_StartFdo (DeviceData,
                                    &stack->Parameters.StartDevice.AllocatedResources->List[0].PartialResourceList,
                                    &stack->Parameters.StartDevice.AllocatedResourcesTranslated->List[0].PartialResourceList);

            //
            // find the translated resources and store them someplace
            // safe for given out for the PDOs.
            //
            if (NT_SUCCESS (status)) {
                //
                // Turn on the shingle and point it to the given device object.
                //
                DeviceData->Started = TRUE;
                IoSetDeviceInterfaceState(&DeviceData->DevClassAssocName, TRUE);
            }
        }

        //
        // We must now complete the IRP, since we stopped it in the
        // completetion routine with MORE_PROCESSING_REQUIRED.
        //

        Irp->IoStatus.Information = 0;
        break;

    case IRP_MN_QUERY_STOP_DEVICE:
        Game_KdPrint (DeviceData, GAME_DBG_PNP_TRACE, ("Query Stop Device\n"));

        //
        // Test to see if there are any PDO created as children of this FDO
        // If there are then conclude the device is busy and fail the
        // query stop.
        //
        // ISSUE
        // We could do better, by seing if the children PDOs are actually
        // currently open.  If they are not then we could stop, get new
        // resouces, fill in the new resouce values, and then when a new client
        // opens the PDO use the new resources.  But this works for now.
        //
        if (DeviceData->NumPDOs) {
            status = STATUS_UNSUCCESSFUL;
            Irp->IoStatus.Status = status;
            IoCompleteRequest (Irp, IO_NO_INCREMENT);
        } else {
            status = STATUS_SUCCESS;

            Irp->IoStatus.Status = status;
            IoSkipCurrentIrpStackLocation (Irp);
            status = IoCallDriver (DeviceData->TopOfStack, Irp);
        }

        Game_DecIoCount (DeviceData);
        return status;

    case IRP_MN_STOP_DEVICE:
        Game_KdPrint (DeviceData, GAME_DBG_PNP_TRACE, ("Stop Device\n"));

        //
        // After the start IRP has been sent to the lower driver object, the
        // bus may NOT send any more IRPS down ``touch'' until another START
        // has occured.
        // What ever access is required must be done before the Irp is passed
        // on.
        //
        // Stop device means that the resources given durring Start device
        // are no revoked.  So we need to stop using them
        //
        if (DeviceData->Started) {
            DeviceData->Started = FALSE;

            //
            // Free resources given by start device.
            //
            if (DeviceData->MappedPorts) {
                MmUnmapIoSpace (DeviceData->GamePortAddress,
                                DeviceData->GamePortAddressLength);
            }
        }

        //
        // We don't need a completion routine so fire and forget.
        //
        // Set the current stack location to the next stack location and
        // call the next device object.
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (DeviceData->TopOfStack, Irp);

        Game_DecIoCount (DeviceData);
        return status;

    case IRP_MN_SURPRISE_REMOVAL:
        ASSERT(!DeviceData->Acquired);

        Game_RemoveFdo(DeviceData);
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (DeviceData->TopOfStack, Irp);

        Game_DecIoCount (DeviceData);
        return status;

    case IRP_MN_REMOVE_DEVICE:
        Game_KdPrint (DeviceData, GAME_DBG_PNP_TRACE, ("Remove Device\n"));

        //
        // We should assert this because Game_IncIoCount will not succeed if a
        // remove has already been sent down.
        //
        ASSERT(!DeviceData->Removed);
        ASSERT(!DeviceData->Acquired);

        //
        // The PlugPlay system has detected the removal of this device.  We
        // have no choise but to detach and delete the device objecct.
        // (If we wanted to express and interest in preventing this removal,
        // we should have filtered the query remove and query stop routines.)
        //
        // Note! we might receive a remove WITHOUT first receiving a stop.
        // ASSERT (!DeviceData->Removed);
        //
        // We will accept no new requests
        //
        DeviceData->Removed = TRUE;
        
        //
        // Complete any outstanding IRPs queued by the driver here.
        //

        // Perform (surpise) remove code
        Game_RemoveFdo(DeviceData);

        //
        // Here if we had any outstanding requests in a personal queue we should
        // complete them all now.
        //
        // Note, the device is guarenteed stopped, so we cannot send it any non-
        // PNP IRPS.
        //

        //
        // Fire and forget
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (DeviceData->TopOfStack, Irp);

        //
        // Wait for all outstanding requests to complete
        //
        i = InterlockedDecrement (&DeviceData->OutstandingIO);

        ASSERT (0 < i);

        if (0 != InterlockedDecrement (&DeviceData->OutstandingIO)) {
            NTSTATUS waitStatus;

            Game_KdPrint (DeviceData, GAME_DBG_PNP_INFO,
                          ("Remove Device waiting for request to complete\n"));

            waitStatus = KeWaitForSingleObject (&DeviceData->RemoveEvent,
                                                Executive,
                                                KernelMode,
                                                FALSE, // Not Alertable
                                                NULL); // No timeout
            ASSERT (waitStatus == STATUS_SUCCESS);
        }

        //
        // Free the associated resources
        //

        //
        // Detatch from the undelying devices.
        //
        Game_KdPrint(DeviceData, GAME_DBG_PNP_INFO,
                        ("IoDetachDevice: 0x%x\n", DeviceData->TopOfStack));
        IoDetachDevice (DeviceData->TopOfStack);

        Game_KdPrint(DeviceData, GAME_DBG_PNP_INFO,
                        ("IoDeleteDevice1: 0x%x\n", DeviceObject));

        ExAcquireFastMutex (&DeviceData->Mutex);
    
        for (entry = DeviceData->PDOs.Flink;
             entry != &DeviceData->PDOs;
             ) {
    
            pdoData = CONTAINING_RECORD (entry, PDO_DEVICE_DATA, Link);

            ASSERT (pdoData->Removed);
            ASSERT (pdoData->Attached);

            //
            // We set this to false so that Game_RemovePdo will delete the DO
            // and free any of the allocated memory associated with the PDO.
            //
            pdoData->Attached = FALSE;

            //
            // Go to the next link in the list.  Once the pdo is deleted, entry
            // is no longer a valid pointer.
            //
            entry = entry->Flink;

            //
            // Once Game_RemovePdo is called, pdoData and the pdo itself cannot
            // be touched becuase they will have been deleted.   RemoveEntryList
            // does not modify the value Link->Flink, so the state after this 
            // one is safe
            //
            RemoveEntryList (&pdoData->Link);

            Game_RemovePdo (pdoData->Self, pdoData);

            DeviceData->NumPDOs--;
        }

        ASSERT(DeviceData->NumPDOs == 0);

        ExReleaseFastMutex (&DeviceData->Mutex);
    
        IoDeleteDevice (DeviceObject);

        return status;

    case IRP_MN_QUERY_DEVICE_RELATIONS:

        if (BusRelations != IrpStack->Parameters.QueryDeviceRelations.Type) {
            //
            // We don't support this
            //
            goto GAME_FDO_PNP_DEFAULT;
        }

        Game_KdPrint (DeviceData, GAME_DBG_PNP_TRACE, ("Query Relations "));

        //
        // Tell the plug and play system about all the PDOs.
        //
        // There might also be device relations below and above this FDO,
        // so, be sure to propagate the relations from the upper drivers.
        //
        // No Completion routine is needed so long as the status is preset
        // to success.  (PDOs complete plug and play irps with the current
        // IoStatus.Status and IoStatus.Information as the default.)
        //
        ExAcquireFastMutex (&DeviceData->Mutex);

        oldRelations = (PDEVICE_RELATIONS) Irp->IoStatus.Information;
        if (oldRelations) {
            i = oldRelations->Count; 
            if (!DeviceData->NumPDOs) {
                //
                // There is a device relations struct already present and we have
                // nothing to add to it, so just call IoSkip and IoCall
                //
                ExReleaseFastMutex (&DeviceData->Mutex);
                goto GAME_FDO_PNP_DEFAULT;
            }
        }
        else  {
            i = 0;
        }

        // The current number of PDOs
        Game_KdPrint_Cont (DeviceData, GAME_DBG_PNP_TRACE,
                           ("#PDOS = %d + %d\n", i, DeviceData->NumPDOs));

        //
        // Need to allocate a new relations structure and add our
        // PDOs to it.
        //
        length = sizeof(DEVICE_RELATIONS) +
                ((DeviceData->NumPDOs + i) * sizeof (PDEVICE_OBJECT));

        relations = (PDEVICE_RELATIONS) ExAllocatePool (PagedPool, length);

        if (NULL == relations) {
            ExReleaseFastMutex (&DeviceData->Mutex);
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        //
        // Copy in the device objects so far
        //
        if (i) {
            RtlCopyMemory (
                  relations->Objects,
                  oldRelations->Objects,
                  i * sizeof (PDEVICE_OBJECT));
        }
        relations->Count = DeviceData->NumPDOs + i;

        //
        // For each PDO on this bus add a pointer to the device relations
        // buffer, being sure to take out a reference to that object.
        // The PlugPlay system will dereference the object when it is done with
        // it and free the device relations buffer.
        //
        for (entry = DeviceData->PDOs.Flink;
             entry != &DeviceData->PDOs;
             entry = entry->Flink, i++) {

            pdoData = CONTAINING_RECORD (entry, PDO_DEVICE_DATA, Link);
            ASSERT (pdoData->Attached);
            relations->Objects[i] = pdoData->Self;
            ObReferenceObject (pdoData->Self);
        }

        //
        // Replace the relations structure in the IRP with the new
        // one.
        //
        if (oldRelations) {
            ExFreePool (oldRelations);
        }
        Irp->IoStatus.Information = (ULONG_PTR) relations;

        ExReleaseFastMutex (&DeviceData->Mutex);

        //
        // Set up and pass the IRP further down the stack
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;

        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (DeviceData->TopOfStack, Irp);

        Game_DecIoCount (DeviceData);
        return status;

    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
    case IRP_MN_QUERY_REMOVE_DEVICE:
        //
        // For query remove, if we were to fail this call then we would need to
        // complete the IRP here.  Since we are not, set the status to SUCCESS
        // and call the next driver.
        //
        // For the cancel(s), we must set the status to notify the PnP subsystem
        // that the irp was correctly handled
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (DeviceData->TopOfStack, Irp);
        Game_DecIoCount (DeviceData);
        return status;

GAME_FDO_PNP_DEFAULT:
    default:
        //
        // In the default case we merely call the next driver since
        // we don't know what to do.
        //

        //
        // Fire and Forget
        //
        IoSkipCurrentIrpStackLocation (Irp);

        //
        // Done, do NOT complete the IRP, it will be processed by the lower
        // device object, which will complete the IRP
        //

        status = IoCallDriver (DeviceData->TopOfStack, Irp);
        Game_DecIoCount (DeviceData);
        return status;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    Game_DecIoCount (DeviceData);

    return status;
}

UCHAR
Game_ReadPortUchar (
    IN  UCHAR * x
    )
{
    return READ_PORT_UCHAR (x);
}

VOID
Game_WritePortUchar (
    IN  UCHAR * x,
    IN  UCHAR   y
    )
{
    WRITE_PORT_UCHAR (x,y);
}

UCHAR
Game_ReadRegisterUchar (
    IN  UCHAR * x
    )
{
    return READ_REGISTER_UCHAR (x);
}

VOID
Game_WriteRegisterUchar (
    IN  UCHAR * x,
    IN  UCHAR   y
    )
{
    WRITE_REGISTER_UCHAR (x,y);
}

NTSTATUS
Game_StartFdo (
    IN  PFDO_DEVICE_DATA            FdoData,
    IN  PCM_PARTIAL_RESOURCE_LIST   PartialResourceList,
    IN  PCM_PARTIAL_RESOURCE_LIST   PartialResourceListTranslated
    )
/*++

Routine Description:

    Parses the resource lists to see what type of accessors to use. 
    
Arguments:

    DeviceObject - Pointer to the device object.
    PartialResourceList - untranslated resources
    PartialResourceListTranslated - translated resources

Return Value:

    Status is returned.

--*/
{
    ULONG i;
    NTSTATUS status = STATUS_SUCCESS;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR resource;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR resourceTrans;

    Game_KdPrint (FdoData, GAME_DBG_PNP_TRACE, ("StartFdo\n"));

    for (i = 0,
         resource = &PartialResourceList->PartialDescriptors[0],
         resourceTrans = &PartialResourceListTranslated->PartialDescriptors[0];

         i < PartialResourceList->Count && NT_SUCCESS(status);
         i++, resource++, resourceTrans++) {

        switch (resource->Type) {
        case CmResourceTypePort:

#if _X86_
            FdoData->ReadPort = READ_PORT_UCHAR; 
            FdoData->WritePort = WRITE_PORT_UCHAR;
#else
            FdoData->ReadPort = Game_ReadPortUchar;
            FdoData->WritePort = Game_WritePortUchar;
#endif
            FdoData->PhysicalAddress = resource->u.Port.Start;
            Game_KdPrint (FdoData, GAME_DBG_PNP_INFO,
                          ("HardwareResource: Port (%x) -> ",
                           FdoData->PhysicalAddress.LowPart));

            switch (resourceTrans->Type) {
            case CmResourceTypePort:


                // Nothing to do here but note the address;
//@@BEGIN_DDKSPLIT
                // On Win9x, VJoyD.VxD handles the resources for gameports.
                // It only uses ports and it assumes that the first range is 
                // always the gameport.  It uses a second range of a devnode 
                // only if the second range is within the original standard 
                // range of 200-20f.  All other ports are assumed to be audio 
                // ports on the hosting sound card.
//@@END_DDKSPLIT
                // For better compatibility with Win9x, always use only the 
                // first port range.

                if( FdoData->GamePortAddress == 0 ) {
                    FdoData->GamePortAddress =
                        (PVOID)(ULONG_PTR) resourceTrans->u.Port.Start.QuadPart;

                    ASSERT (resourceTrans->u.Port.Length == resource->u.Port.Length);
                    FdoData->GamePortAddressLength = resourceTrans->u.Port.Length;

                    Game_KdPrint_Cont (FdoData, GAME_DBG_PNP_INFO,
                                       ("Port: (%x)\n", FdoData->GamePortAddress));
                } else {
                    Game_KdPrint_Cont (FdoData, GAME_DBG_PNP_INFO,
                                       ("Ignoring additional port: (%x)\n", FdoData->GamePortAddress));
                }
                break;

            case CmResourceTypeMemory:
                //
                // We need to map the memory
                //

                FdoData->GamePortAddress =
                    MmMapIoSpace (resourceTrans->u.Memory.Start,
                                  resourceTrans->u.Memory.Length,
                                  MmNonCached);

                ASSERT (resourceTrans->u.Port.Length == resource->u.Port.Length);
                FdoData->GamePortAddressLength = resourceTrans->u.Memory.Length;

                FdoData->MappedPorts = TRUE;

                Game_KdPrint_Cont (FdoData, GAME_DBG_PNP_INFO,
                                   ("Mem: (%x)\n", FdoData->GamePortAddress));
                break;

            default:
                Game_KdPrint_Cont (FdoData, GAME_DBG_PNP_INFO,
                                   ("Unknown \n", FdoData->GamePortAddress));
                TRAP ();
            }

            break;

        case CmResourceTypeMemory:

            ASSERT (CmResourceTypeMemory == resourceTrans->Type);

#if _X86_
            FdoData->ReadPort = READ_REGISTER_UCHAR; 
            FdoData->WritePort = WRITE_REGISTER_UCHAR;
#else
            FdoData->ReadPort = Game_ReadRegisterUchar; 
            FdoData->WritePort = Game_WriteRegisterUchar; 
#endif
            FdoData->PhysicalAddress = resource->u.Memory.Start;
            FdoData->GamePortAddress =
                MmMapIoSpace (resourceTrans->u.Memory.Start,
                              resourceTrans->u.Memory.Length,
                              MmNonCached);

            FdoData->MappedPorts = TRUE;

            Game_KdPrint (FdoData, GAME_DBG_PNP_INFO,
                          ("HardwareResource: Memory (%x) -> Mem (%x)",
                           FdoData->PhysicalAddress.LowPart,
                           FdoData->GamePortAddress));

            break;

        case CmResourceTypeInterrupt:
        default:
            // Hun?  Allow this to succeed...perhaps whomever enumerated the PDO
            // below us needs this resource for the game port
            Game_KdPrint (FdoData, GAME_DBG_PNP_ERROR,
                          ("Unhandled resource type (0x%x)\n",
                           resource->Type));
            // status = STATUS_UNSUCCESSFUL;
        }
    }
    return status;
}

void
Game_RemoveFdo (
    IN PFDO_DEVICE_DATA FdoData
    ) 
/*++
Routine Description:
    
    Frees any memory allocated by the FDO and unmaps any IO mapped as well.
    
--*/
{
    PAGED_CODE ();

    if (FdoData->SurpriseRemoved) {
        return;
    }

    //
    // We set this b/c if we get called twice, that means a surprise removal
    // called this function first
    //
    FdoData->SurpriseRemoved =  TRUE;

    //
    // Clean up any resources here
    //
    if (FdoData->Started) {
        FdoData->Started = FALSE;

        //
        // Free resources given by start device.
        //
        if (FdoData->MappedPorts) {
            MmUnmapIoSpace (FdoData->GamePortAddress, 1);
            // Here we are assuming that joysticks only use on port.
            // This is the way it has always been, and might always
            // continue to be.  This assumption is everywhere in this stack.
        }

        IoSetDeviceInterfaceState (&FdoData->DevClassAssocName, FALSE);
    }

    //
    // Make the DI go away.  Some drivers may choose to remove the DCA
    // when they receive a stop or even a query stop.  We just don't care.
    //
    if (FdoData->DevClassAssocName.Buffer != NULL) {
        ExFreePool (FdoData->DevClassAssocName.Buffer);
        RtlZeroMemory (&FdoData->DevClassAssocName,
                       sizeof (UNICODE_STRING)); 
    }
}

NTSTATUS
Game_SendIrpSynchronously (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN BOOLEAN NotImplementedIsValid,
    IN BOOLEAN CopyToNext   
    )
{
    KEVENT   event;
    NTSTATUS status;

    PAGED_CODE();

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    if (CopyToNext) {
        IoCopyCurrentIrpStackLocationToNext(Irp);
    }

    IoSetCompletionRoutine(Irp,
                           Game_CompletionRoutine,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE
                           );

    status = IoCallDriver(DeviceObject, Irp);

    //
    // Wait for lower drivers to be done with the Irp
    //
    if (status == STATUS_PENDING) {
       KeWaitForSingleObject(&event,
                             Executive,
                             KernelMode,
                             FALSE,
                             NULL
                             );
       status = Irp->IoStatus.Status;
    }

    if (NotImplementedIsValid && (status == STATUS_NOT_IMPLEMENTED ||
                                  status == STATUS_INVALID_DEVICE_REQUEST)) {
        status = STATUS_SUCCESS;
    }

    return status;
}

NTSTATUS
Game_CompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++
Routine Description:
    A completion routine for use when calling the lower device objects to
    which our bus (FDO) is attached.

--*/
{
    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (Irp);

    // if (Irp->PendingReturned) {
    //     IoMarkIrpPending( Irp );
    // }

    KeSetEvent ((PKEVENT) Context, 1, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED; // Keep this IRP
}

NTSTATUS
Game_PDO_PnP (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpStack,
    IN PPDO_DEVICE_DATA     DeviceData
    )
/*++
Routine Description:
    Handle requests from the PlugPlay system for the devices on the BUS

--*/
{ 
    PDEVICE_CAPABILITIES    deviceCapabilities;
    ULONG                   information;
    PWCHAR                  buffer, buffer2;
    ULONG                   length, length2, i, j;
    NTSTATUS                status;

    PAGED_CODE ();

    status = Irp->IoStatus.Status;

    //
    // NB: since we are a bus enumerator, we have no one to whom we could
    // defer these irps.  Therefore we do not pass them down but merely
    // return them.
    //

    switch (IrpStack->MinorFunction) {
    case IRP_MN_QUERY_CAPABILITIES:

        Game_KdPrint (DeviceData, GAME_DBG_PNP_TRACE, ("Query Caps \n"));

        //
        // Get the packet.
        //
        deviceCapabilities=IrpStack->Parameters.DeviceCapabilities.Capabilities;

        //
        // Set the capabilities.
        //

        deviceCapabilities->Version = 1;
        deviceCapabilities->Size = sizeof (DEVICE_CAPABILITIES);

        // We cannot wake the system.
        deviceCapabilities->SystemWake = PowerSystemUnspecified;
        deviceCapabilities->DeviceWake = PowerDeviceUnspecified;

        // We have no latencies
        deviceCapabilities->D1Latency = 0;
        deviceCapabilities->D2Latency = 0;
        deviceCapabilities->D3Latency = 0;

        // No locking or ejection
        deviceCapabilities->LockSupported = FALSE;
        deviceCapabilities->EjectSupported = FALSE;

        // Device can be physically removed.
        // Technically there is no physical device to remove, but this bus
        // driver can yank the PDO from the PlugPlay system, when ever it
        // receives an IOCTL_GAMEENUM_REMOVE_PORT device control command.
        deviceCapabilities->Removable = FALSE;
        deviceCapabilities->SurpriseRemovalOK = TRUE;

        // not Docking device
        deviceCapabilities->DockDevice = FALSE;

        deviceCapabilities->UniqueID = FALSE;
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_ID:
        // Query the IDs of the device
        Game_KdPrint (DeviceData, GAME_DBG_PNP_TRACE,
                      ("QueryID: 0x%x\n", IrpStack->Parameters.QueryId.IdType));

        //
        // If the query requires having a hardware ID, check we have one
        // 
#if DBG
        if (( IrpStack->Parameters.QueryId.IdType == BusQueryDeviceID ) 
         || ( IrpStack->Parameters.QueryId.IdType == BusQueryHardwareIDs ) 
         || ( IrpStack->Parameters.QueryId.IdType == BusQueryInstanceID )) {
            if (DeviceData->HardwareIDs) {
                ULONG tmplength = 1024;  // No reason to be as long as this
                ASSERT( NT_SUCCESS( Game_CheckHardwareIDs (DeviceData->HardwareIDs,
                                    &tmplength, FDO_FROM_PDO (DeviceData) ) ) );
            } else {
                ASSERT( !"No hardware ID for QueryId" );
            }

        }
#endif

        switch (IrpStack->Parameters.QueryId.IdType) {

        case BusQueryDeviceID:
            // this can be the same as the hardware ids (which requires a multi
            // sz) ... we are just allocating more than enough memory
        case BusQueryHardwareIDs:
            // return a multi WCHAR (null terminated) string (null terminated)
            // array for use in matching hardare ids in inf files;
            //

            buffer = DeviceData->HardwareIDs;

            while (*(buffer++)) {
                while (*(buffer++)) {
                    ;
                }
            }
            length = (ULONG)(buffer - DeviceData->HardwareIDs) * sizeof (WCHAR);
          
            buffer = ExAllocatePool (PagedPool, length);
            if (buffer) {
                RtlCopyMemory (buffer, DeviceData->HardwareIDs, length);
                status = STATUS_SUCCESS;
            }
            else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }

            Irp->IoStatus.Information = (ULONG_PTR) buffer;
            break;

        case BusQueryInstanceID:
            //
            // Take the first hardware id and append an underscore and number
            // to it
            // total length = 
            // length of hw id + underscore + number (11 digits to be safe) +
            // null 
            //
            buffer = buffer2 = DeviceData->HardwareIDs;

            while (*(buffer++)) {
                while (*(buffer++)) {
                    ;
                }
            }
            while ('\\' != *(buffer2++)) {
                ;
            }
            length = (ULONG)(buffer - buffer2) * sizeof (WCHAR);

            length += 1 + 11 + 1;

            buffer = ExAllocatePool (PagedPool, length);
            if (buffer) {
                swprintf(buffer, L"%ws_%02d", buffer2, DeviceData->UniqueID);
                Game_KdPrint (DeviceData, GAME_DBG_PNP_INFO,
                             ("UniqueID: %ws\n", buffer));
                status = STATUS_SUCCESS;
            }
            else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }

            Irp->IoStatus.Information = (ULONG_PTR) buffer;
            break;


        case BusQueryCompatibleIDs:
            // The generic ids for installation of this pdo.
            if (DeviceData->AnalogCompatible) {
                // Only applicable for analog devices

                length = GAMEENUM_COMPATIBLE_IDS_LENGTH * sizeof (WCHAR);
                buffer = ExAllocatePool (PagedPool, length);
                if (buffer) {
                    RtlCopyMemory (buffer, GAMEENUM_COMPATIBLE_IDS, length);
                    status = STATUS_SUCCESS;
                }
                else {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
                Irp->IoStatus.Information = (ULONG_PTR) buffer;
            }
            else {
                // For incompatible devices report an empty list
                buffer = ExAllocatePool (PagedPool, sizeof(L"\0"));
                if (buffer) {
                    *(ULONG *)buffer = 0;  // double unicode-NULL.
                    status = STATUS_SUCCESS;
                } else {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
                Irp->IoStatus.Information = (ULONG_PTR) buffer;
            }
            break;
        }
        break;

    case IRP_MN_START_DEVICE:
        Game_KdPrint (DeviceData, GAME_DBG_PNP_TRACE, ("Start Device \n"));
        // Here we do what ever initialization and ``turning on'' that is
        // required to allow others to access this device.
        DeviceData->Started = TRUE;
        DeviceData->Removed = FALSE;
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_STOP_DEVICE:
        Game_KdPrint (DeviceData, GAME_DBG_PNP_TRACE, ("Stop Device \n"));
        // Here we shut down the device.  The opposite of start.
        DeviceData->Started = FALSE;
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_SURPRISE_REMOVAL:
        // just mark that it happened, cleaning up the device extension will
        // occur later
        ASSERT(!(FDO_FROM_PDO (DeviceData))->Acquired);
        DeviceData->SurpriseRemoved = TRUE;
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_REMOVE_DEVICE:
        Game_KdPrint (DeviceData, GAME_DBG_PNP_TRACE, ("Remove Device \n"));

        ASSERT(!(FDO_FROM_PDO (DeviceData))->Acquired);

        //
        // The remove IRP code for a PDO uses the following steps:
        //
        //  Complete any requests queued in the driver
        //  If the device is still attached to the system,
        //   then complete the request and return.
        //  Otherwise, cleanup device specific allocations, memory, events...
        //  Call IoDeleteDevice
        //  Return from the dispatch routine.
        //
        status = Game_RemovePdo(DeviceObject, DeviceData);
        break;

    case IRP_MN_QUERY_STOP_DEVICE:
        Game_KdPrint (DeviceData, GAME_DBG_PNP_TRACE, ("Q Stop Device \n"));
        // No reason here why we can't stop the device.
        // If there were a reason we should speak now for answering success
        // here may result in a stop device irp.
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:
        Game_KdPrint (DeviceData, GAME_DBG_PNP_TRACE, ("Cancel Stop Device \n"));
        //
        // The stop was canceled.  Whatever state we set, or resources we put
        // on hold in anticipation of the forcoming STOP device IRP should be
        // put back to normal.  Someone, in the long list of concerned parties,
        // has failed the stop device query.
        //
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:
        Game_KdPrint (DeviceData, GAME_DBG_PNP_TRACE, ("Q Remove Device \n"));
        //
        // Just like Query Stop only now the impending doom is the remove irp
        //
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:
        Game_KdPrint (DeviceData, GAME_DBG_PNP_TRACE, ("Can Remove Device \n"));
        //
        // Clean up a remove that did not go through, just like cancel STOP.
        //
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_DEVICE_RELATIONS:

        if (TargetDeviceRelation ==
            IrpStack->Parameters.QueryDeviceRelations.Type) {
            PDEVICE_RELATIONS deviceRelations;

            deviceRelations = (PDEVICE_RELATIONS) Irp->IoStatus.Information; 
            if (!deviceRelations) {
                deviceRelations = (PDEVICE_RELATIONS)
                    ExAllocatePool(PagedPool, sizeof(DEVICE_RELATIONS));

                if (!deviceRelations) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }
            }
            else if (deviceRelations->Count != 0) {
                //
                // Nobody but the PDO should be setting this value!
                //
                ASSERT(deviceRelations->Count == 0);

                //
                // Deref any objects that were previously in the list
                //
                for (i = 0; i < deviceRelations->Count; i++) {
                    ObDereferenceObject(deviceRelations->Objects[i]);
                    deviceRelations->Objects[i] = NULL;
                }
            }

            deviceRelations->Count = 1;
            deviceRelations->Objects[0] = DeviceData->Self;
            ObReferenceObject(DeviceData->Self);

            status = STATUS_SUCCESS;
            Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;

            break;
        }

        // fall through

    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
    case IRP_MN_READ_CONFIG:
    case IRP_MN_WRITE_CONFIG: // we have no config space
    case IRP_MN_EJECT:
    case IRP_MN_SET_LOCK:
    case IRP_MN_QUERY_INTERFACE: // We do not have any non IRP based interfaces.
    default:
        Game_KdPrint (DeviceData, GAME_DBG_PNP_TRACE,
                      ("PNP Not handled 0x%x\n", IrpStack->MinorFunction));
        // this is a leaf node
        // status = STATUS_NOT_IMPLEMENTED
        // For PnP requests to the PDO that we do not understand we should
        // return the IRP WITHOUT setting the status or information fields.
        // They may have already been set by a filter (eg acpi).
        break;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
Game_RemovePdo (
    PDEVICE_OBJECT      Device,
    PPDO_DEVICE_DATA    PdoData
    )
/*++
Routine Description:
    The PlugPlay subsystem has instructed that this PDO should be removed.

    We should therefore
     Complete any requests queued in the driver
     If the device is still attached to the system,
      then complete the request and return.
     Otherwise, cleanup device specific allocations, memory, events...
     Call IoDeleteDevice
     Return from the dispatch routine.

    Note that if the device is still connected to the bus (IE in this case
    the control panel has not yet told us that the game device has disappeared)
    then the PDO must remain around, and must be returned during any
    query Device relaions IRPS.

--*/

{
    PAGED_CODE ();

    PdoData->Removed = TRUE;

    //
    // Complete any outsanding requests with STATUS_DELETE_PENDING.
    //
    // Game enum does not queue any irps at this time so we have nothing to do.
    //
    // Attached is set to true when the pdo is exposed via one of the IOCTLs.
    // It is set to FALSE when a remove IOCTL is received.  This means that we
    // can get a remove on a device that still exists, so we don't delete it.
    //
    if (PdoData->Attached) {
        return STATUS_SUCCESS;
    }

    //
    // Free any resources.
    //
    if (PdoData->HardwareIDs) {
        ExFreePool (PdoData->HardwareIDs);
        PdoData->HardwareIDs = NULL;
    }

    Game_KdPrint(PdoData, GAME_DBG_PNP_INFO,
                        ("IoDeleteDevice2: 0x%x\n", Device));
    IoDeleteDevice (Device);
    return STATUS_SUCCESS;
}


VOID
Game_InitializePdo (
    PDEVICE_OBJECT      Pdo,
    PFDO_DEVICE_DATA    FdoData
    )
/*++
Routine Description:
    Set the PDO into a known good starting state
    
--*/
{
    PPDO_DEVICE_DATA pdoData;

    PAGED_CODE ();

    pdoData = (PPDO_DEVICE_DATA)  Pdo->DeviceExtension;

    Game_KdPrint(pdoData, GAME_DBG_SS_NOISE, 
                 ("pdo 0x%x, extension 0x%x\n", Pdo, pdoData));

    //
    // Initialize the rest
    //
    pdoData->IsFDO = FALSE;
    pdoData->Self =  Pdo;
#if DBG
    pdoData->DebugLevel = GameEnumDebugLevel;
#endif

    pdoData->ParrentFdo = FdoData->Self;

    pdoData->Started = FALSE; // irp_mn_start has yet to be received
    pdoData->Attached = TRUE; // attached to the bus
    pdoData->Removed = FALSE; // no irp_mn_remove as of yet

    pdoData->UniqueID = InterlockedIncrement(&FdoData->UniqueIDCount);

    Pdo->Flags &= ~DO_DEVICE_INITIALIZING;
    Pdo->Flags |= DO_POWER_PAGABLE;

    ExAcquireFastMutex (&FdoData->Mutex);
    InsertTailList(&FdoData->PDOs, &pdoData->Link);
    FdoData->NumPDOs++;
    ExReleaseFastMutex (&FdoData->Mutex);
}

NTSTATUS
Game_CheckHardwareIDs (
    PWCHAR                      pwszOrgId,
    PULONG                      puLenLimit,
    PFDO_DEVICE_DATA            FdoData
    )
/*++
Routine Description:
    Check that the hardware ID we've been given is matches format "Gameport\XXX" where XXX must
    be between 0x20 and 0x7f inclusive but not be a ',' or '\'. We also have to make sure that we 
    do not overrun our buffer length. The length of the total buffer must be less than MAX_DEVICE_ID_LEN
    and each individual entry must be less than 64 characters
--*/
{
    PWCHAR                      pwszId;
    ULONG                       total_length=0;
    UCHAR                       ucEntries = 0;
#if DBG
    PWCHAR                      pwszLastId;
#else
    UNREFERENCED_PARAMETER (FdoData);
#endif

    PAGED_CODE ();

    Game_KdPrint (FdoData, GAME_DBG_PNP_TRACE, ("Game_CheckHardwareIDs - given ID string %.64lS length %d \n",pwszOrgId,*puLenLimit));
    pwszId = pwszOrgId;

    //
    // Trivial rejection first  - null string
    if (*pwszId == UNICODE_NULL)
    {
        Game_KdPrint (FdoData, GAME_DBG_PNP_ERROR,("hardware ID invalid - buffer NULL\n"));
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Loop through at most 2 hardware IDs until the NULL terminator or end of buffer 
    //
    
    while (*pwszId != UNICODE_NULL && total_length<=*puLenLimit) 
    {
        PWCHAR                      pwszTemplate = HWID_TEMPLATE;
        ULONG                       length=0;

#if DBG
        //
        // Keep track of the beginning of each ID for debug messages
        //
        pwszLastId = pwszId;
#endif
        //
        // Limit us to 2 entries
        //
        if (++ucEntries>2)
            break;
        
        //
        // Length remaining must be long enough for an completion entry
        // Which is template + 4 characters (slash,char,null,null)
        //
        if (HWID_TEMPLATE_LENGTH + 4 > (*puLenLimit)-total_length)
        {
                Game_KdPrint (FdoData, GAME_DBG_PNP_ERROR, 
                          ("hardware ID \"%.64lS\" invalid - entry too short\n",pwszLastId));
                return STATUS_INVALID_PARAMETER;
        }

        
        //
        // Hardware ID must start with HWID_TEMPLATE
        //
        while (++length <= HWID_TEMPLATE_LENGTH)
        {
            if (LOWERCASE(*(pwszId++)) != *(pwszTemplate++))
            {
                Game_KdPrint (FdoData, GAME_DBG_PNP_ERROR, 
                          ("hardware ID \"%.64lS\" invalid - does not match template\n",pwszLastId));
                return STATUS_INVALID_PARAMETER;
            }
        }
        //
        // Must have a separator
        //
        if ((*(pwszId++) != OBJ_NAME_PATH_SEPARATOR)) 
        {
            Game_KdPrint (FdoData, GAME_DBG_PNP_ERROR, 
                      ("hardware ID \"%.64lS\" invalid - no separator\n",pwszLastId));
            return STATUS_INVALID_PARAMETER;
        }
        //
        // We have a successful match of HWID_TEMPLATE_LENGTH + 1 characters
        // Now our Id string check - check for NULL case first
        //
        if (*pwszId == UNICODE_NULL)
        {
            Game_KdPrint (FdoData, GAME_DBG_PNP_ERROR, 
                      ("hardware ID \"%.64lS\" invalid format\n",pwszLastId));
            return STATUS_INVALID_PARAMETER;
        }
        //
        // Otherwise we loop until we overrun or hit NULL
        while ((++length + total_length < *puLenLimit) && (*pwszId != UNICODE_NULL))
        {
            if ((*pwszId == OBJ_NAME_PATH_SEPARATOR) ||
                (*pwszId < 0x20) ||
                (*pwszId > 0x7f) ||
                (*pwszId == L','))
            {
                Game_KdPrint (FdoData, GAME_DBG_PNP_ERROR, 
                          ("hardware ID \"%.64lS\" invalid - bad character at length=%d\n",pwszLastId,length));
                return STATUS_INVALID_PARAMETER;
            }
            if (length > 64)
            {
                Game_KdPrint (FdoData, GAME_DBG_PNP_ERROR, 
                          ("hardware ID \"%.64lS\" invalid - ID %d too long at length=%d\n",pwszLastId,ucEntries,length));
                return STATUS_INVALID_PARAMETER;
            }
            pwszId++;
        }

        //
        // We need to increment to either the second NULL or next string
        // If we had a null we test for either another entry or final NULL
        // in the while loop
        // If we ran too far we will pick it up in the while loop test and break 
        // out of the loop.
        //
        total_length += length;
        pwszId++;
    }

    // 
    // If we have run off the end of the buffer return an error
    //
    if (total_length > *puLenLimit) 
    {
        Game_KdPrint (FdoData, GAME_DBG_PNP_ERROR, 
                      ("hardware ID \"%.64lS\" invalid - length > buffer limit\n",pwszLastId));
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Copy the actual (maybe truncated) length back to the caller
    //
    *puLenLimit = ++total_length;

    Game_KdPrint (FdoData, GAME_DBG_PNP_TRACE, ("Game_CheckHardwareIDs - succeeded. Final ID string \"%.64lS\" length %d \n",pwszOrgId,*puLenLimit));

    return STATUS_SUCCESS;
}

NTSTATUS
Game_Expose (
    PGAMEENUM_EXPOSE_HARDWARE   Expose,
    ULONG                       ExposeSize,
    PFDO_DEVICE_DATA            FdoData
    )
/*++
Routine Description:
    This driver has just detected a new device on the bus.  (Actually the
    control panels has just told us that something has arived, but who is
    counting?)

    We therefore need to create a new PDO, initialize it, add it to the list
    of PDOs for this FDO bus, and then tell Plug and Play that all of this
    happened so that it will start sending prodding IRPs.
--*/
{
    PDEVICE_OBJECT      pdo, firstPdo = NULL;
    PLIST_ENTRY         entry;
    PPDO_DEVICE_DATA    pdoData;
    NTSTATUS            status;
    ULONG               length;
    KIRQL               irql;
    BOOLEAN             first = TRUE;
    UCHAR               i;

    PAGED_CODE ();

    if (FdoData->Self != Expose->PortHandle) {
        return STATUS_INVALID_PARAMETER;
    }
    else if (FdoData->NumPDOs != 0) {
        //
        // Only one valid expose per PDO ... a remove hardware will decrement
        //  NumPDOs to 0
        //
        return STATUS_INVALID_DEVICE_REQUEST;
    }
    else if (Expose->NumberJoysticks > 2 || Expose->NumberJoysticks < 0) {
        return STATUS_INVALID_PARAMETER;
    }

    length = (ExposeSize - sizeof (GAMEENUM_EXPOSE_HARDWARE))/sizeof(WCHAR);
    if (length >MAX_DEVICE_ID_LEN) {
     Game_KdPrint (FdoData, GAME_DBG_PNP_ERROR, 
                  ("Expose failed because length of Hardware ID too long at %d\n",length));
       return STATUS_INVALID_PARAMETER;
    }
    Game_KdPrint (FdoData, GAME_DBG_PNP_INFO, 
                  ("Exposing PDO\n"
                   "======PortHandle:     0x%x\n"
                   "======NumJoysticks:   %d\n"
                   "======NumAxis:        %d\n"
                   "======NumButtons:     %d\n"
                   "======HardwareId:     %ws\n"
                   "======Length:         %d\n",
                   Expose->PortHandle,
                   Expose->NumberJoysticks,
                   Expose->NumberAxis,
                   Expose->NumberButtons,
                   Expose->HardwareIDs,
                   length));

#if DBG
    for (i = 0; i < SIZE_GAMEENUM_OEM_DATA; i++) {
        Game_KdPrint (FdoData, GAME_DBG_PNP_INFO,
                      ("=====OemData[%d] = 0x%x\n",
                       i,
                       Expose->OemData[i]
                       ));
    }
#endif

    status = Game_CheckHardwareIDs (Expose->HardwareIDs, &length, FdoData);
            
    if (!NT_SUCCESS (status)) {
        return status;
    }

    //
    // Create the PDOs
    //
    length *= sizeof(WCHAR);
    
    Game_KdPrint(FdoData, GAME_DBG_PNP_NOISE,
                 ("GAME:  Expose->HardwareHandle = 0x%x\n", FdoData->TopOfStack));

    Expose->HardwareHandle = FdoData->TopOfStack;

    for (i = 0; i < Expose->NumberJoysticks; i++) {
        status = IoCreateDevice(FdoData->Self->DriverObject,
                                sizeof (PDO_DEVICE_DATA),
                                NULL,
                                FILE_DEVICE_BUS_EXTENDER,
                                0,
                                FALSE,
                                &pdo);

        if (!NT_SUCCESS (status)) {
            pdo = NULL;
            goto GameExposeError;
        }

        ASSERT (pdo != NULL);

        if (!firstPdo) {
            firstPdo = pdo;
        }

        pdoData = (PPDO_DEVICE_DATA) pdo->DeviceExtension;

        //
        // Copy the hardware IDs
        //
        if (NULL == (pdoData->HardwareIDs = ExAllocatePool(NonPagedPool, length))) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto GameExposeError;
        }
        RtlCopyMemory (pdoData->HardwareIDs, Expose->HardwareIDs, length);

        //
        // If there are more than two IDs, the check returns the length for 
        // the first two.  In case there were more than two, zero out the 
        // last WCHAR of the copy in order to double NULL terminate.
        //
        pdoData->HardwareIDs[(length/sizeof(WCHAR))-1] = UNICODE_NULL;

        if (1 == Expose->NumberJoysticks) {
            pdoData->Portion = GameenumWhole;
        }
        else if (2 == Expose->NumberJoysticks) {
            if (first) {
                pdoData->Portion = GameenumFirstHalf;
                first = FALSE;
            }
            else {
                pdoData->Portion = GameenumSecondHalf;
            }
        }


        pdoData->UnitID = Expose->UnitID;
        pdoData->NumberAxis = Expose->NumberAxis;
        pdoData->NumberButtons = Expose->NumberButtons;

        
#ifndef GAMEENUM_FLAG_COMPATIDCTRL
        //
        // The flags to control the exposing of a compatible ID were not 
        // implemented in Windows 2000.  If the flags are not defined,
        // assume this is being built in a Windows 2000 environment.  The 
        // driver will work either way but if analog compatility is assumed, 
        // unsigned joystick drivers will always be outranked by the signed 
        // generic driver even if the generic driver does not work.
        // 
        pdoData->AnalogCompatible = TRUE;
#else
        pdoData->AnalogCompatible = ( Expose->Flags & ( GAMEENUM_FLAG_COMPATIDCTRL | GAMEENUM_FLAG_NOCOMPATID ) )
                                    != ( GAMEENUM_FLAG_COMPATIDCTRL | GAMEENUM_FLAG_NOCOMPATID );
#endif

        RtlCopyMemory (&pdoData->OemData,
                       &Expose->OemData,
                       sizeof(GAMEENUM_OEM_DATA));

        Game_InitializePdo (pdo,
                            FdoData);
    }

    IoInvalidateDeviceRelations (FdoData->UnderlyingPDO, BusRelations);

GameExposeError:
    if (!NT_SUCCESS(status)) {

        //
        // Clean up the current pdo.  
        //
        if (pdo) {
            IoDeleteDevice(pdo);
        }

        //
        // delete the first PDO if it exists.  More to do here b/c it was
        // actually fully initialized
        //
        if (!first) {
            ASSERT(firstPdo != NULL);

            pdoData = (PPDO_DEVICE_DATA) firstPdo->DeviceExtension;

            ASSERT (pdoData->Portion == GameenumFirstHalf);
            ExFreePool (pdoData->HardwareIDs);
            pdoData->HardwareIDs = NULL;

            IoDeleteDevice (firstPdo);
        }

        //
        // remove all pdos from our linked list
        //
        for (entry = FdoData->PDOs.Flink;
             entry != &FdoData->PDOs;
             entry = entry->Flink) {
            pdoData = CONTAINING_RECORD (entry, PDO_DEVICE_DATA, Link);
            RemoveEntryList (&pdoData->Link);
        }

        FdoData->NumPDOs = 0;
        FdoData->UniqueIDCount = GAMEENUM_UNIQUEID_START;
        Expose->HardwareHandle = NULL;
    }

    return status;
}

NTSTATUS
Game_ExposeSibling (
    PGAMEENUM_EXPOSE_SIBLING    ExposeSibling,
    PPDO_DEVICE_DATA            SiblingPdo
    )
/*++
Routine Description:
    This driver has just detected a new device on the bus.  (Actually the
    control panels has just told us that something has arived, but who is
    counting?)

    We therefore need to create a new PDO, initialize it, add it to the list
    of PDOs for this FDO bus, and then tell Plug and Play that all of this
    happened so that it will start sending prodding IRPs.
--*/
{
    UCHAR               i;
    PDEVICE_OBJECT      pdo;
    PPDO_DEVICE_DATA    pdoData;
    PFDO_DEVICE_DATA    fdoData;
    ULONG               length;
    PWCHAR              buffer;

    NTSTATUS            status;

    PAGED_CODE ();

    fdoData = FDO_FROM_PDO (SiblingPdo);

    //
    // Check to make sure we have a valid multi sz string before we allocate
    // device objects and other assorted items
    //
    if (ExposeSibling->HardwareIDs) {
        //
        // We don't know how long the hardware IDs are but the value 
        // of MAX_DEVICE_ID_LEN is the most allowed.
        //
        length = MAX_DEVICE_ID_LEN;
        status = Game_CheckHardwareIDs (ExposeSibling->HardwareIDs, &length, fdoData);
    }
    else {
        length = 0;
        status = STATUS_SUCCESS;
    }

    Game_KdPrint (SiblingPdo, GAME_DBG_PNP_INFO, 
                  ("Exposing Sibling PDO\n"
                   "======HardwareHandle: 0x%x\n"
                   "======UnitID:         %d\n"
                   "======Sting Length:   %d\n",
                   ExposeSibling->HardwareHandle,
                   (ULONG) ExposeSibling->UnitID,
                   length
                   ));

#if DBG
    for (i = 0; i < SIZE_GAMEENUM_OEM_DATA; i++) {
        Game_KdPrint (SiblingPdo, GAME_DBG_PNP_INFO,
                      ("=====OemData[%d] = 0x%x\n",
                       i,
                       ExposeSibling->OemData[i]
                       ));
    }
#endif


    if (!NT_SUCCESS (status)) {
        return status;
    }

    status = IoCreateDevice(fdoData->Self->DriverObject,
                            sizeof (PDO_DEVICE_DATA),
                            NULL,
                            FILE_DEVICE_BUS_EXTENDER,
                            0,
                            FALSE,
                            &pdo);

    if (!NT_SUCCESS (status)) {
        return status;
    } 

    ASSERT (pdo != NULL);

    Game_KdPrint (fdoData, GAME_DBG_PNP_NOISE,
                  ("ExposeSibling->HardwareHandle = 0x%x\n", pdo));

    ExposeSibling->HardwareHandle = pdo;

    pdoData = (PPDO_DEVICE_DATA) pdo->DeviceExtension;
    pdoData->UnitID = ExposeSibling->UnitID;
    RtlCopyMemory (&pdoData->OemData,
                   &ExposeSibling->OemData,
                   sizeof(GAMEENUM_OEM_DATA));

    //
    // Check to see if the multi sz was supplied
    //
    if (length) {
        //
        // Another hardware ID was given ... use it!
        //
        Game_KdPrint (fdoData, GAME_DBG_PNP_INFO,
                      ("Using IDs from struct\n"));

        //
        // Length now represents the actual size of memory to copy instead of 
        // the number of chars in the array
        //
        length *= sizeof(WCHAR);
        buffer = ExposeSibling->HardwareIDs;
    }
    else {
        //
        // No hardware ID was given, use the siblings ID
        //
        Game_KdPrint (fdoData, GAME_DBG_PNP_INFO,
                      ("Using IDs from sibling\n"));

        buffer = SiblingPdo->HardwareIDs;
    
        while (*(buffer++)) {
            while (*(buffer++)) {
                ;
            }
        }
 
        length = (ULONG) (buffer - SiblingPdo->HardwareIDs) * sizeof (WCHAR);
        buffer = SiblingPdo->HardwareIDs;
    }

    pdoData->HardwareIDs = ExAllocatePool(NonPagedPool, length);
    if (NULL == pdoData->HardwareIDs) {
        IoDeleteDevice (pdo);

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory (pdoData->HardwareIDs, buffer, length);

    //
    // If there are more than two IDs, the check returns the length for the 
    // first two.  In case there were more than two, zero out the last WCHAR 
    // of the copy in order to double NULL terminate.
    //
    pdoData->HardwareIDs[(length/sizeof(WCHAR))-1] = UNICODE_NULL;

    pdoData->AnalogCompatible = SiblingPdo->AnalogCompatible;

    Game_InitializePdo (pdo,
                        fdoData);

    IoInvalidateDeviceRelations (fdoData->UnderlyingPDO, BusRelations);

    return status;
}

NTSTATUS
Game_Remove (
    PGAMEENUM_REMOVE_HARDWARE   Remove,
    PFDO_DEVICE_DATA            FdoData
    )
{
    PAGED_CODE ();

    ASSERT (Remove->Size == sizeof(GAMEENUM_REMOVE_HARDWARE));

    if (Remove->HardwareHandle != FdoData->TopOfStack) {
        Game_KdPrint(FdoData, GAME_DBG_PNP_NOISE,
                     ("GAME:  Remove->HardwareHandle = 0x%x, expecting 0x%x\n",
                      Remove->HardwareHandle, FdoData->TopOfStack));
    
        return STATUS_INVALID_PARAMETER;
    }

    return Game_RemoveEx (NULL, FdoData);
}

NTSTATUS
Game_RemoveSelf (
    PPDO_DEVICE_DATA            PdoData
    )
{
    PAGED_CODE ();

    return Game_RemoveEx (PdoData->Self, FDO_FROM_PDO (PdoData) );
}

NTSTATUS
Game_RemoveEx (
    PDEVICE_OBJECT              RemoveDO,
    PFDO_DEVICE_DATA            FdoData
    )
/*++
Routine Description:
    This driver has just detected that a device has departed from the bus.
    (Atcually either the control panel has just told us that somehting has
    departed or a PDO has removed itself)
    
    We therefore need to flag the PDO as no longer attached, remove it from
    the linked list of PDOs for this bus, and then tell Plug and Play about it.
    
Parameters

    RemoveDO - if NULL, then remove all the items in the list, otherwise
               it is the PDO to remove from the list

    FdoData - contains the list to iterate over                    
                    
Returns:

    STATUS_SUCCESS upon successful removal from the list
    STATUS_INVALID_PARAMETER if the removal was unsuccessful
    
--*/
{
    PLIST_ENTRY         entry;
    PPDO_DEVICE_DATA    pdoData;
    BOOLEAN             found = FALSE, removeAll = (RemoveDO == NULL);
    PVOID               handle = NULL;

    PAGED_CODE ();

    ExAcquireFastMutex (&FdoData->Mutex);

    if (removeAll) {
        Game_KdPrint (FdoData, GAME_DBG_IOCTL_NOISE,
                      ("removing all the pdos!\n"));
    }
    else {
        Game_KdPrint (FdoData, GAME_DBG_IOCTL_NOISE,
                      ("removing 0x%x\n", RemoveDO));
    }

    if (FdoData->NumPDOs == 0) {
        //
        // We got a 2nd remove...somebody in user space isn't playing nice!!!
        //
        Game_KdPrint (FdoData, GAME_DBG_IOCTL_ERROR,
                      ("BAD BAD BAD...2 removes!!! Send only one!\n"));
        ExReleaseFastMutex (&FdoData->Mutex);
        return STATUS_NO_SUCH_DEVICE;
    }

    for (entry = FdoData->PDOs.Flink;
         entry != &FdoData->PDOs;
         entry = entry->Flink) {

        pdoData = CONTAINING_RECORD (entry, PDO_DEVICE_DATA, Link);
        handle = pdoData->Self;

        Game_KdPrint (FdoData, GAME_DBG_IOCTL_NOISE,
                      ("found DO 0x%x\n", handle));

        if (removeAll || handle == RemoveDO) {
            Game_KdPrint (FdoData, GAME_DBG_IOCTL_INFO,
                          ("removed 0x%x\n", handle));

            pdoData->Attached = FALSE;
            RemoveEntryList (&pdoData->Link);
            FdoData->NumPDOs--;
            found = TRUE;
            if (!removeAll) {
                break;
            }
        }
    }
    ExReleaseFastMutex (&FdoData->Mutex);

    if (FdoData->NumPDOs == 0) {
        FdoData->UniqueIDCount = GAMEENUM_UNIQUEID_START;
    }
    
    if (found) {
        IoInvalidateDeviceRelations (FdoData->UnderlyingPDO, BusRelations);
        return STATUS_SUCCESS;
    }

    Game_KdPrint (FdoData, GAME_DBG_IOCTL_ERROR,
                  ("0x%x was not removed (not in list)\n", RemoveDO));
    return STATUS_INVALID_PARAMETER;
}


NTSTATUS
Game_ListPorts (
    PGAMEENUM_PORT_DESC Desc,
    PFDO_DEVICE_DATA    FdoData
    )
/*++
Routine Description:
    This driver has just detected that a device has departed from the bus.
    (Actually the control panels has just told us that something has departed,
    but who is counting?

    We therefore need to flag the PDO as no longer attached, remove it from
    the linked list of PDOs for this bus, and then tell Plug and Play about it.
--*/
{
    PAGED_CODE ();

    Desc->PortHandle = FdoData->Self;
    Desc->PortAddress = FdoData->PhysicalAddress;

    return STATUS_SUCCESS;
}

NTSTATUS
Game_Power (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
    We do nothing special for power;

--*/
{
    PIO_STACK_LOCATION  irpStack;
    NTSTATUS            status;
    PCOMMON_DEVICE_DATA commonData;

    PAGED_CODE ();

    status = STATUS_SUCCESS;
    irpStack = IoGetCurrentIrpStackLocation (Irp);
    ASSERT (IRP_MJ_POWER == irpStack->MajorFunction);

    commonData = (PCOMMON_DEVICE_DATA) DeviceObject->DeviceExtension;

    if (commonData->IsFDO) {
        status = Game_FDO_Power ((PFDO_DEVICE_DATA) DeviceObject->DeviceExtension,
                                Irp);
    } else {
        status = Game_PDO_Power ((PPDO_DEVICE_DATA) DeviceObject->DeviceExtension,
                                Irp);
    }

    return status;
}

NTSTATUS
Game_PowerComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
Game_FdoPowerTransitionPoRequestComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE DevicePowerState,
    IN PIRP SystemStateIrp, 
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PIO_STACK_LOCATION  stack;
    PFDO_DEVICE_DATA fdoData;

    UNREFERENCED_PARAMETER (MinorFunction);
    UNREFERENCED_PARAMETER (IoStatus);

    fdoData = (PFDO_DEVICE_DATA) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (SystemStateIrp);

    if (DevicePowerState.DeviceState == PowerDeviceD0) {
        //
        // We are powering up (the D0 Irp just completed).  Since we sent the
        // S irp down the stack and requested the D irp on the way back up the
        // stack, just complete the S irp now
        //

        PoSetPowerState (DeviceObject,
                         stack->Parameters.Power.Type,
                         stack->Parameters.Power.State);
    
        fdoData->SystemState = stack->Parameters.Power.State.SystemState;

        SystemStateIrp->IoStatus.Status = IoStatus->Status;
        PoStartNextPowerIrp (SystemStateIrp);
        IoCompleteRequest (SystemStateIrp, IO_NO_INCREMENT);

        //
        // From Game_FDO_Power when we originally received the IRP
        //
        Game_DecIoCount (fdoData);
    }
    else {
        //
        // We are powering down (the D3 Irp just completed).  Since we requested
        // the D irp before sending the S irp down the stack, we must send it 
        // down now.  We will catch the S irp on the way back up to record the 
        // S state
        //
        ASSERT (DevicePowerState.DeviceState == PowerDeviceD3);
    
        IoCopyCurrentIrpStackLocationToNext (SystemStateIrp);

        IoSetCompletionRoutine (SystemStateIrp,
                                Game_PowerComplete,
                                NULL,
                                TRUE,
                                TRUE,
                                TRUE);
    
        PoCallDriver (fdoData->TopOfStack, SystemStateIrp);
    }
}

VOID
Game_PdoPowerDownComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PFDO_DEVICE_DATA data = (PFDO_DEVICE_DATA) Context;

    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (MinorFunction);
    UNREFERENCED_PARAMETER (PowerState);

#if !DBG
    UNREFERENCED_PARAMETER (IoStatus);
#endif

    ASSERT( NT_SUCCESS (IoStatus->Status));

    if (0 == InterlockedDecrement (&data->PoweredDownDevices)) {
        KeSetEvent (&data->PoweredDownEvent, 1, FALSE);
    }
}

NTSTATUS
Game_PowerComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;
    PIO_STACK_LOCATION  stack;
    PFDO_DEVICE_DATA    data;
    NTSTATUS            status;

    UNREFERENCED_PARAMETER (Context);

    data = (PFDO_DEVICE_DATA) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (Irp);
    powerType = stack->Parameters.Power.Type;
    powerState = stack->Parameters.Power.State;
    status = STATUS_SUCCESS; 

    switch (stack->MinorFunction) {
    case IRP_MN_SET_POWER:
        switch (powerType) {
        case DevicePowerState:

            //
            // Power up complete
            //
            ASSERT (powerState.DeviceState < data->DeviceState);
            data->DeviceState = powerState.DeviceState;
            PoSetPowerState (data->Self, powerType, powerState);
            break;

        case SystemPowerState:
            //
            // Ususally the work of requesting the Device Power IRP on
            // behalf of the SystemPower Irp is work done by the Function
            // (FDO) driver.  In order, however that Joystick function drivers
            // have a more simplified power code path (AKA they merely need
            // pass on ALL power IRPS) will will do this work for them in the
            // PDO.
            //
            // NB: This assumes that we will never have any "clever" power
            // management for a gaming device attached through a legacy
            // gaming port.  By which I mean that the HIDGame driver will not
            // be able to select a "D" state based on the "S" state; as it is
            // done for the HidGame driver.
            //
            // Any yahoo putting wakeup capabilities into a legacy joystick
            // should be shot.  It will require special hardware.  If you are
            // adding extra hardware then you should not be doing so to this
            // nasty RC circuit.
            //

            if (powerState.SystemState > data->SystemState) {
                //
                // Powering Down...
                //
                // We are on the completion end of an S irp.  (The D3 power irp
                // has already been sent and completed down this stack.)  The
                // remaining thing to do is set the state in the extension, then
                // decrement the IoCount that was incremented when we first got
                // the irp (this is done at the end of this function).
                //
                data->SystemState = powerState.SystemState;

                PoSetPowerState (data->Self,
                                 stack->Parameters.Power.Type,
                                 stack->Parameters.Power.State);
            }
            else {
                //
                // Powering Up...
                //
                // Request a D power irp for ourself.  Do not complete this S irp
                // until the D irp has been completed.  (Completion of the S irp
                // is done in Game_FdoPowerTransitionPoRequestComplete). 
                // Decrementing the IO count will happen in the same function.
                //
                ASSERT (powerState.SystemState < data->SystemState);
    
                powerState.DeviceState = PowerDeviceD0;
                status =
                    PoRequestPowerIrp (data->Self,
                                       IRP_MN_SET_POWER,
                                       powerState,
                                       Game_FdoPowerTransitionPoRequestComplete,
                                       Irp, 
                                       NULL); // no return Irp
    
                if (status != STATUS_PENDING) {
                    ASSERT (!NT_SUCCESS (status));
    
                    Irp->IoStatus.Status = status;
                    PoStartNextPowerIrp (Irp);
    
                    Game_DecIoCount (data);
                }
                else {
                    //
                    // We need to:
                    // Start next power irp, release the removelock, and complete
                    // the irp in the PoRequestComplete routine.
                    //
                    //
                    // The irp might completed by the time we get here, so call
                    // PoStartNextPowerIrp in the PO irp completion function.
                    //
                    status = STATUS_MORE_PROCESSING_REQUIRED; 
                }
    
                return status;
            }
            break;
        }
        break;

    default:
        #define GAME_UNHANDLED_MN_POWER 0x0
        ASSERT (0xBADBAD == GAME_UNHANDLED_MN_POWER);
        #undef GAME_UNHANDLED_MN_POWER 
        
        status = STATUS_NOT_SUPPORTED;
        break;
    }

    if (NT_SUCCESS(status)) {
        PoStartNextPowerIrp (Irp);
        Game_DecIoCount (data);
    }

    return status;
}

NTSTATUS
Game_FDO_Power (
    PFDO_DEVICE_DATA    Data,
    PIRP                Irp
    )
{
    NTSTATUS            status;
    BOOLEAN             hookit = FALSE, wait = FALSE;
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;
    PIO_STACK_LOCATION  stack;
    PLIST_ENTRY         entry;
    PPDO_DEVICE_DATA    pdoData;

    stack = IoGetCurrentIrpStackLocation (Irp);
    powerType = stack->Parameters.Power.Type;
    powerState = stack->Parameters.Power.State;

    PAGED_CODE ();

    status = Game_IncIoCount (Data);
    if (!NT_SUCCESS (status)) {
        PoStartNextPowerIrp (Irp);
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    switch (stack->MinorFunction) {
    case IRP_MN_SET_POWER:
        Game_KdPrint(Data,
                     GAME_DBG_PNP_TRACE,
                     ("Game-PnP Setting %s state to %d\n",
                      ((powerType == SystemPowerState) ?  "System" : "Device"),
                      powerState.SystemState));

        switch (powerType) {
        case DevicePowerState:

            status = Irp->IoStatus.Status = STATUS_SUCCESS;

            if (Data->DeviceState == powerState.DeviceState) {
                break;

            } else if (Data->DeviceState < powerState.DeviceState) {
                //
                // Powering down
                //

                //
                // Iterate through the PDOs and make sure that they are all
                // powered down.
                //
                // Initially set PoweredDownDevices to the number of PDOs.  If
                // a pdo is not powered down, PoweredDownDevices will be
                // decremented upon completion of the power down irp sent to 
                // that particular PDO.  Otherwise, the PDO is already powered
                // down so just decrement the count.
                //
                Data->PoweredDownDevices = Data->NumPDOs;
                KeInitializeEvent (&Data->PoweredDownEvent,
                                   SynchronizationEvent,
                                   FALSE);

                for (entry = Data->PDOs.Flink;
                     entry != &Data->PDOs;
                     entry = entry->Flink) {
            
                    pdoData = CONTAINING_RECORD (entry, PDO_DEVICE_DATA, Link);
                    if (pdoData->DeviceState == PowerDeviceD0) {
                        wait = TRUE;

                        powerState.DeviceState = PowerDeviceD3;
                        PoRequestPowerIrp (pdoData->Self,
                                           IRP_MN_SET_POWER,
                                           powerState,
                                           Game_PdoPowerDownComplete, 
                                           Data, 
                                           NULL);
                    }
                    else {
                        //
                        // All the power down irps to the PDOs can complete 
                        // before we get to this already powered down PDO, so
                        // set the event if it is the last and we have a PDO 
                        // that needed powering down.
                        //
                        if (InterlockedDecrement(&Data->PoweredDownDevices) == 0
                            && wait) {
                            KeSetEvent (&Data->PoweredDownEvent, 1, FALSE);
                        }

                    }

                }

                if (wait) {
                    KeWaitForSingleObject (&Data->PoweredDownEvent,
                                                    Executive,
                                                    KernelMode,
                                                    FALSE, 
                                                    NULL); 

#if DBG
                    ///
                    // Make SURE that all the PDOs are trully powered down
                    //
                    for (entry = Data->PDOs.Flink;
                         entry != &Data->PDOs;
                         entry = entry->Flink) {
                        pdoData = CONTAINING_RECORD (entry, PDO_DEVICE_DATA, Link);
                        ASSERT(pdoData->DeviceState != PowerDeviceD0);
                    }
#endif
                }

                ASSERT(Data->PoweredDownDevices == 0);

                //
                // Make sure powerState is the one sent down to us, not the 
                // modified version above
                //
                powerState = stack->Parameters.Power.State;
                PoSetPowerState (Data->Self, powerType, powerState);
                Data->DeviceState = powerState.DeviceState;

            } else {
                //
                // Powering Up
                //
                hookit = TRUE;
            }

            break;

        case SystemPowerState:

            if (Data->SystemState == powerState.SystemState) {
                status = STATUS_SUCCESS;

            } else if (Data->SystemState < powerState.SystemState) {
                //
                // Powering down
                //

                //
                // Request a D3 irp in response to this S irp.  The D3 irp must
                // completed before send this S irp down the stack.  We will send
                // the S irp down the stack when
                // Game_FdoPowerTransitionPoRequestComplete is called.
                //

                //
                // We don't need to increment our IO count b/c we incremented it
                // at the beginning of this function and won't decrement it until
                // the S Irp completes
                // 
                IoMarkIrpPending (Irp);
                powerState.DeviceState = PowerDeviceD3;
                PoRequestPowerIrp (Data->Self,
                                   IRP_MN_SET_POWER,
                                   powerState,
                                   Game_FdoPowerTransitionPoRequestComplete,
                                   Irp,
                                   NULL);  // no IRP
                
                return STATUS_PENDING;

            } else {
                //
                // Powering Up
                //
                
                // 
                // We must request a D irp for this S irp, but only after the S
                // irp has come back up the stack.  Hook the return of the irp
                // and request the D irp in Game_PowerComplete
                //
                hookit = TRUE;
            }
            break;
        }

        break;

    case IRP_MN_QUERY_POWER:
        status = Irp->IoStatus.Status = STATUS_SUCCESS;
        break;

    default:
        break;
    }

    IoCopyCurrentIrpStackLocationToNext (Irp);

    if (hookit) {
        ASSERT (STATUS_SUCCESS == status);
        //
        // If we are returning STATUS_PENDING, the irp must marked as such as well
        //
        IoMarkIrpPending (Irp);

        IoSetCompletionRoutine (Irp,
                                Game_PowerComplete,
                                NULL,
                                TRUE,
                                TRUE,
                                TRUE);

        //
        // NOTE!!! PoCallDriver NOT IoCallDriver.
        //
        PoCallDriver (Data->TopOfStack, Irp);

        //
        // We are returning pending instead of the result from PoCallDriver becuase:
        // 1  we are changing the status in the completion routine
        // 2  we will not be completing this irp in the completion routine
        //
        status = STATUS_PENDING;
    } else {
        //
        // Power IRPS come synchronously; drivers must call
        // PoStartNextPowerIrp, when they are ready for the next power
        // irp.  This can be called here, or in the completetion
        // routine, but never the less must be called.
        //
        PoStartNextPowerIrp (Irp);

        status =  PoCallDriver (Data->TopOfStack, Irp);

        Game_DecIoCount (Data);
    }

    return status;
}

VOID
Game_PdoPoRequestComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE DevicePowerState,
    IN PIRP SystemStateIrp, 
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PIO_STACK_LOCATION  stack;
    PPDO_DEVICE_DATA    pdoData;

    UNREFERENCED_PARAMETER (MinorFunction);
    UNREFERENCED_PARAMETER (DevicePowerState);
    UNREFERENCED_PARAMETER (IoStatus);

    pdoData = (PPDO_DEVICE_DATA) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (SystemStateIrp);

    PoSetPowerState (DeviceObject,
                     stack->Parameters.Power.Type,
                     stack->Parameters.Power.State);

    pdoData->SystemState = stack->Parameters.Power.State.SystemState;
    
    //
    // Set the S irp's status to the status of the D irp
    //
    SystemStateIrp->IoStatus.Status = IoStatus->Status;
    PoStartNextPowerIrp (SystemStateIrp);
    IoCompleteRequest (SystemStateIrp, IO_NO_INCREMENT);
}

NTSTATUS
Game_PDO_Power (
    PPDO_DEVICE_DATA    PdoData,
    PIRP                Irp
    )
{
    KIRQL               irql;
    NTSTATUS            status = STATUS_SUCCESS;
    PIO_STACK_LOCATION  stack;
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;

    PAGED_CODE();

    stack = IoGetCurrentIrpStackLocation (Irp);
    powerType = stack->Parameters.Power.Type;
    powerState = stack->Parameters.Power.State;

    switch (stack->MinorFunction) {
    case IRP_MN_SET_POWER:
        switch (powerType) {
        case DevicePowerState:
            PoSetPowerState (PdoData->Self, powerType, powerState);
            PdoData->DeviceState = powerState.DeviceState;
            break;

        case SystemPowerState:

            //
            // Make the IRP pending and request a D irp for this stack.  When
            // the D irp completes, Game_PdoPoRequestComplete will be called.  In
            // that function, we complete this S irp
            //
            IoMarkIrpPending(Irp);

            if (PowerSystemWorking == powerState.SystemState) {
                powerState.DeviceState = PowerDeviceD0;
            } else {
                powerState.DeviceState = PowerDeviceD3;
            }

            status = PoRequestPowerIrp (PdoData->Self,
                                        IRP_MN_SET_POWER,
                                        powerState,
                                        Game_PdoPoRequestComplete, 
                                        Irp, 
                                        NULL); // no return IRP

            if (status != STATUS_PENDING) {
                ASSERT (!NT_SUCCESS (status));
                break;
            }

            return status;

        default:
            TRAP ();
            status = STATUS_NOT_IMPLEMENTED;
            break;
        }
        break;

    case IRP_MN_QUERY_POWER:
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_WAIT_WAKE:
    case IRP_MN_POWER_SEQUENCE:
    default:
        status = STATUS_NOT_SUPPORTED;
        break;
    }

    PoStartNextPowerIrp (Irp);
    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\hidgame\hidjoy.c ===
/*++

Copyright (c) 1998 - 1999  Microsoft Corporation

Module Name:

    hidjoy.c

Abstract: This module contains routines Generate the HID report and
    configure the joystick.

Environment:

    Kernel mode

@@BEGIN_DDKSPLIT
  Author:

    Eliyas Yakub (Mar, 11, 1997)

Revision History:

    Updated by Eliyas on Feb 5 1998

@@END_DDKSPLIT

--*/

#include "hidgame.h"


#ifdef ALLOC_PRAGMA
    #pragma alloc_text (INIT, HGM_DriverInit)
    #pragma alloc_text (PAGE, HGM_SetupButtons)
    #pragma alloc_text (PAGE, HGM_MapAxesFromDevExt)
    #pragma alloc_text (PAGE, HGM_GenerateReport)
    #pragma alloc_text (PAGE, HGM_JoystickConfig)
    #pragma alloc_text (PAGE, HGM_InitAnalog)
/*  Sample only functions */
#ifdef CHANGE_DEVICE 
    #pragma alloc_text (PAGE, HGM_ChangeHandler)
    #pragma alloc_text (PAGE, HGM_DeviceChanged)
#endif /* CHANGE_DEVICE */
#endif





/*
 *  A few look up tables to translate the JOY_HWS_* flags into axis masks.
 *  These flags allow any axis to be polled on any of the four axis bits in 
 *  the gameport.  For example, the X axis on a standard joystick is found on 
 *  bit 0 (LSB) and the Y axis is on bit 1; however many steering wheel/pedal 
 *  controllers have X on bit 0 but Y on bit 2.  Although very few of these
 *  combinations are known to be used, supporting all the flags only causes a 
 *  little extra work on setup.  For each axis, there are three flags, one for 
 *  each of the possible non-standard bit masks.  Since it is possible that 
 *  more than one of these may be set the invalid combinations are marked so 
 *  that they can be refused.
 */



#define NA ( 0x80 )

/*
 *  Short versions of bit masks for axes
 */
#define X1 AXIS_X
#define Y1 AXIS_Y
#define X2 AXIS_R
#define Y2 AXIS_Z

/*
 *  Per axis flag masks and look up tables.
 *  In each case, combinations with more than one bit set are invalid
 */
#define XMAPBITS    (JOY_HWS_XISJ2Y |   JOY_HWS_XISJ2X |   JOY_HWS_XISJ1Y)
/*
 *                          0                   0                   0           0001
 *                          0                   0                   1           0010
 *                          0                   1                   0           0100
 *                          1                   0                   0           1000
 */
static const unsigned char XLU[8] = { X1,Y1,X2,NA,Y2,NA,NA,NA };
#define XMAPSHFT 7

#define YMAPBITS    (JOY_HWS_YISJ2Y |   JOY_HWS_YISJ2X |   JOY_HWS_YISJ1X)
/*                          0                   0                   0           0010
 *                          0                   0                   1           0001
 *                          0                   1                   0           0100
 *                          1                   0                   0           1000
 */
static const unsigned char YLU[8] = { Y1,X1,X2,NA,Y2,NA,NA,NA };
#define YMAPSHFT 10

#define RMAPBITS    (JOY_HWS_RISJ2Y |   JOY_HWS_RISJ1X |   JOY_HWS_RISJ1Y)
/*                          0                   0                   0           0100
 *                          0                   0                   1           0010
 *                          0                   1                   0           0001
 *                          1                   0                   0           1000
 */
static const unsigned char RLU[8] = { X2,Y1,X1,NA,Y2,NA,NA,NA };
#define RMAPSHFT 20

#define ZMAPBITS    (JOY_HWS_ZISJ2X |   JOY_HWS_ZISJ1X |   JOY_HWS_ZISJ1Y)
/*                          0                   0                   0           1000
 *                          0                   0                   1           0010
 *                          0                   1                   0           0001
 *                          1                   0                   0           0100
 */
static const unsigned char ZLU[8] = { Y2,Y1,X1,NA,X2,NA,NA,NA };
#define ZMAPSHFT 13
#define POVMAPBITS  (JOY_HWS_POVISJ2X | JOY_HWS_POVISJ1X | JOY_HWS_POVISJ1Y)
/*
 *  POV is the same as Z but with a larger shift
 */
#define POVMAPSHFT 16

#undef X1
#undef Y1
#undef X2
#undef Y2

/*
 *  This translates from an axis bitmask to an axis value index.  The elements 
 *  used should be as follows (X marks unsed)   { X, 0, 1, X, 2, X, X, X, 3 }.
 */
static const unsigned char cAxisIndexTable[9] = { 0, 0, 1, 0, 2, 0, 0, 0, 3 };


typedef enum _POV1
{
    P1_NULL = 0x80,
    P1_0,
    P1_90,
    P1_180,
    P1_270    
} POV1;

typedef enum _POV2
{
    P2_NULL = 0xc0,
    P2_0,
    P2_90,
    P2_180,
    P2_270    
} POV2;

#define POV_MASK ((unsigned char)(~(P1_NULL | P2_NULL)))
/*
 *  Look up tables for button combos
 *  Buttons are zero based so use P1_NULL for a zero input so we don't have to 
 *  special case it as a do nothing button.
 *  The 7th Button can be mapped either from it's unique combination or as 
 *  foreward on a second POV being read as buttons 7 - 10.
 */
static const unsigned char c1PComboLU[] =   {   P1_NULL,0,      1,      P1_270,
                                                2,      4,      8,      P1_180,
                                                3,      5,      7,      P1_90,
                                                9,      6,      6,      P1_0 };

static const unsigned char c2PComboLU[] =   {   P1_NULL,0,      1,      P1_270,
                                                2,      4,      P2_180, P1_180,
                                                3,      5,      P2_90,  P1_90,
                                                P2_270, 6,      P2_0,   P1_0 };


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS | HGM_DriverInit |
 *
 *          Perform global initialization.
 *          <nl>This is called from DriverEntry.  Try to initialize a CPU 
 *          specific timer but if it fails set up default
 *
 *  @rvalue   STATUS_SUCCESS | success
 *  @rvalue   STATUS_UNSUCCESSFUL | not success
 *
 *****************************************************************************/
NTSTATUS EXTERNAL
    HGM_DriverInit( void )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    if( !HGM_CPUCounterInit() )
    {
        LARGE_INTEGER QPCFrequency;

        KeQueryPerformanceCounter( &QPCFrequency );

        if( ( QPCFrequency.HighPart == 0 )
         && ( QPCFrequency.LowPart <= 10000 ) )
        {
            ntStatus = STATUS_UNSUCCESSFUL;

            HGM_DBGPRINT(FILE_HIDJOY | HGM_ERROR,\
                           ("QPC at %I64u Hz is unusable", 
                           QPCFrequency.QuadPart ));
        }
        else
        {
            Global.CounterScale = CALCULATE_SCALE( QPCFrequency.QuadPart );
            Global.ReadCounter = (COUNTER_FUNCTION)&KeQueryPerformanceCounter;

            HGM_DBGPRINT(FILE_HIDJOY | HGM_BABBLE,\
                           ("QPC at %I64u Hz used with scale %d", 
                           QPCFrequency.QuadPart, Global.CounterScale ));
        }
    }

    return ntStatus;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS | HGM_SetupButtons |
 *
 *          Use the flags in the DeviceExtension to check and set up buttons.
 *          <nl>This is called both from HGM_JoystickConfig to validate the 
 *          configuration and HGM_GenerateReport to prepare for polling.
 *
 *  @parm   IN OUT PDEVICE_EXTENSION | DeviceExtension |
 *
 *          Pointer to the minidriver device extension
 *
 *  @rvalue   STATUS_SUCCESS | success
 *  @rvalue   STATUS_DEVICE_CONFIGURATION_ERROR | The configuration is invalid
 *
 *****************************************************************************/
NTSTATUS INTERNAL
    HGM_SetupButtons
    (
    IN OUT PDEVICE_EXTENSION DeviceExtension 
    )
{
    NTSTATUS    ntStatus = STATUS_SUCCESS;

    if( DeviceExtension->fSiblingFound )
    {
        if( DeviceExtension->nButtons > 2 )
        {
            ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
            HGM_DBGPRINT( FILE_HIDJOY | HGM_ERROR,\
                            ("HGM_SetupButtons: failing config of sibling device with %u buttons",\
                             DeviceExtension->nButtons));
        }
        if( DeviceExtension->HidGameOemData.OemData[1].joy_hws_dwFlags & JOY_HWS_POVISBUTTONCOMBOS )
        {
            ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
            HGM_DBGPRINT( FILE_HIDJOY | HGM_ERROR,\
                            ("HGM_SetupButtons: failing config of sibling device with combo buttons" ));
        }
    }
    else
    {
        if( DeviceExtension->HidGameOemData.OemData[0].joy_hws_dwFlags & JOY_HWS_POVISBUTTONCOMBOS )
        {
            if( DeviceExtension->nButtons > MAX_BUTTONS )
            {
                ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
                HGM_DBGPRINT( FILE_HIDJOY | HGM_ERROR,\
                                ("HGM_SetupButtons: failing config of button combo device with %u buttons",\
                                 DeviceExtension->nButtons));
            }
        }
        else
        {
            if( DeviceExtension->nButtons > 4 )
            {
                if( DeviceExtension->resistiveInputMask & AXIS_R )
                {
                    ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
                    HGM_DBGPRINT( FILE_HIDJOY | HGM_ERROR,\
                                    ("HGM_SetupButtons: failing config of device with R axis and %u buttons",\
                                     DeviceExtension->nButtons));
                }
                else
                {
                    /*
                     *  5th button always read from R axis.
                     *  Set the inital on/off boundary low
                     */
                    DeviceExtension->resistiveInputMask |= AXIS_R;
                    DeviceExtension->button5limit = 2;
                }

                if( DeviceExtension->nButtons > 5 )
                {
                    if( DeviceExtension->resistiveInputMask & AXIS_Z )
                    {
                        ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
                        HGM_DBGPRINT( FILE_HIDJOY | HGM_ERROR,\
                                        ("HGM_SetupButtons: failing config of device with Z axis and %u buttons",\
                                         DeviceExtension->nButtons));
                    }
                    else
                    {
                        /*
                         *  6th button always read from Z axis.
                         *  Set the inital on/off boundary low
                         */
                        DeviceExtension->resistiveInputMask |= AXIS_Z;
                        DeviceExtension->button6limit = 2;
                    }

                    if( DeviceExtension->nButtons > 6 )
                    {
                        ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
                        HGM_DBGPRINT( FILE_HIDJOY | HGM_ERROR,\
                                        ("HGM_SetupButtons: failing config of device with %u buttons",\
                                         DeviceExtension->nButtons));
                    }
                }
            }
        }
    }

    return( ntStatus );
} /* HGM_SetupButtons */



/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_MapAxesFromDevExt |
 *
 *          Use the flags in the DeviceExtension to generate mappings for each 
 *          axis.  
 *          <nl>This is called both from HGM_JoystickConfig to validate the 
 *          configuration and HGM_GenerateReport to use the axis maps.
 *          
 *
 *  @parm   IN OUT PDEVICE_EXTENSION | DeviceExtension |
 *
 *          Pointer to the minidriver device extension
 *
 *  @rvalue   STATUS_SUCCESS | success
 *  @rvalue   STATUS_DEVICE_CONFIGURATION_ERROR | The configuration is invalid
 *
 *****************************************************************************/
NTSTATUS EXTERNAL
    HGM_MapAxesFromDevExt
    (
    IN OUT PDEVICE_EXTENSION DeviceExtension 
    )
{
    NTSTATUS    ntStatus;
    ULONG       dwFlags;
    int         nAxis;
    UCHAR       AxisMask;

    ntStatus = STATUS_SUCCESS;



    dwFlags = DeviceExtension->HidGameOemData.OemData[(DeviceExtension->fSiblingFound!=0)].joy_hws_dwFlags;  

    HGM_DBGPRINT( FILE_HIDJOY | HGM_BABBLE2,\
                    ("HGM_MapAxesFromDevExt: - - - dwFlags=0x%x - - -", dwFlags));

#define XIS (0)
#define YIS (1)
#define ZIS (2)
#define RIS (3)

    /* 
     *  Check X and Y last as Z, R and POV must not overlap
     *  The are no flags to indicate the presence of X or Y so if they 
     *  overlap, this indicates that they are not used,
     */

    DeviceExtension->resistiveInputMask = 0;
    for( nAxis=MAX_AXES; nAxis>=0; nAxis-- )
    {
        DeviceExtension->AxisMap[nAxis] = INVALID_INDEX;
    }
    nAxis = 0;
    DeviceExtension->povMap = INVALID_INDEX;

    if( dwFlags & JOY_HWS_HASZ )
    {
        AxisMask = ZLU[(dwFlags & ZMAPBITS) >> ZMAPSHFT];
        if( AxisMask >= NA )
        {
            HGM_DBGPRINT( FILE_HIDJOY | HGM_ERROR,\
                            ("HGM_MapAxesFromDevExt: Z axis mapping error dwFlags=0x%x",\
                             dwFlags));
            ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR; 
        }
        else
        {
            nAxis = 1;
            DeviceExtension->resistiveInputMask = AxisMask;
            DeviceExtension->AxisMap[ZIS] = cAxisIndexTable[AxisMask];
        }
    }


    if( dwFlags & JOY_HWS_HASR )
    {
        AxisMask = RLU[(dwFlags & RMAPBITS) >> RMAPSHFT];
        if( AxisMask >= NA )
        {
            HGM_DBGPRINT( FILE_HIDJOY | HGM_ERROR,\
                            ("HGM_MapAxesFromDevExt: R axis mapping error dwFlags=0x%x",\
                             dwFlags));
            ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR; 
        }
        else
        {
            if( DeviceExtension->resistiveInputMask & AxisMask )
            {
                HGM_DBGPRINT( FILE_HIDJOY | HGM_ERROR, \
                                ("HGM_MapAxesFromDevExt: R axis mapped to same as Z axis"));
                ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR ; 
            }
            else
            {
                nAxis++;
                DeviceExtension->resistiveInputMask |= AxisMask;
                DeviceExtension->AxisMap[RIS] = cAxisIndexTable[AxisMask];
            }
        }
    }


    if( dwFlags & JOY_HWS_HASPOV )
    {
        switch( dwFlags & ( JOY_HWS_POVISPOLL | JOY_HWS_POVISBUTTONCOMBOS ) )
        {
        case 0:
            HGM_DBGPRINT(FILE_HIDJOY | HGM_ERROR,\
                           ("HGM_MapAxesFromDevExt: POV is not polled or button combo"));
            ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
            break;

        case JOY_HWS_POVISBUTTONCOMBOS:
            break;

        case JOY_HWS_POVISPOLL:
            AxisMask = ZLU[(dwFlags & POVMAPBITS) >> POVMAPSHFT];
            if( AxisMask >= NA )
            {
                HGM_DBGPRINT( FILE_HIDJOY | HGM_ERROR,\
                                ("HGM_MapAxesFromDevExt: POV axis mapping error dwFlags=0x%x",\
                                 dwFlags));
                ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR ; 
            }
            else
            {
                if( DeviceExtension->resistiveInputMask & AxisMask )
                {
                    HGM_DBGPRINT( FILE_HIDJOY | HGM_ERROR,\
                                    ("HGM_MapAxesFromDevExt: POV axis mapped to same as Z or R axis") );
                    ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR ; 
                }
                else
                {
                    DeviceExtension->resistiveInputMask |= AxisMask;
                    DeviceExtension->povMap = cAxisIndexTable[AxisMask];
                }
            }
            break;

        case JOY_HWS_POVISPOLL | JOY_HWS_POVISBUTTONCOMBOS:
            HGM_DBGPRINT(FILE_HIDJOY | HGM_ERROR,\
                           ("HGM_MapAxesFromDevExt: POV reports button combo and polled"));
            ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
            break;
        }
    }
    else if( dwFlags & ( JOY_HWS_POVISPOLL | JOY_HWS_POVISBUTTONCOMBOS ) )
    {
        HGM_DBGPRINT(FILE_HIDJOY | HGM_ERROR,\
                       ("HGM_MapAxesFromDevExt: non-existant POV is polled or button combo"));
        ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR ;
    }


    AxisMask = XLU[( dwFlags & XMAPBITS ) >> XMAPSHFT];
    if( AxisMask >= NA )
    {
        HGM_DBGPRINT( FILE_HIDJOY | HGM_ERROR,\
                        ("HGM_MapAxesFromDevExt: X axis mapping error dwFlags=0x%x",\
                         dwFlags));
        ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR ; 
    }
    else
    {
        if( DeviceExtension->resistiveInputMask & AxisMask )
        {
            HGM_DBGPRINT( FILE_HIDJOY | HGM_WARN,\
                            ("HGM_MapAxesFromDevExt: X axis mapped to same as another axis") );
        }
        else
        {
            nAxis++;
            DeviceExtension->resistiveInputMask |= AxisMask;
            DeviceExtension->AxisMap[XIS] = cAxisIndexTable[AxisMask];
        }
    }


    AxisMask = YLU[( dwFlags & YMAPBITS ) >> YMAPSHFT];
    if( AxisMask >= NA )
    {
        HGM_DBGPRINT( FILE_HIDJOY | HGM_ERROR,\
                        ("HGM_MapAxesFromDevExt: Y axis mapping error dwFlags=0x%x",\
                         dwFlags));
        ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR ; 
    }
    else
    {
        if( DeviceExtension->resistiveInputMask & AxisMask )
        {
            HGM_DBGPRINT( FILE_HIDJOY | HGM_WARN,\
                            ("HGM_MapAxesFromDevExt: Y axis mapped to same as another axis") );
        }
        else
        {
            nAxis++;
            DeviceExtension->resistiveInputMask |= AxisMask;
            DeviceExtension->AxisMap[YIS] = cAxisIndexTable[AxisMask];
        }
    }

#undef XIS
#undef YIS
#undef ZIS
#undef RIS

#undef NA

    /*
     *  Don't fail for this if CHANGE_DEVICE is defined because an exposed 
     *  sibling will always have an nAxis of zero.
     */
#ifdef CHANGE_DEVICE
    if( DeviceExtension->nAxes )
    {
#endif /* CHANGE_DEVICE */
        if( nAxis != DeviceExtension->nAxes )
        {
            ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR ;
            HGM_DBGPRINT(FILE_HIDJOY | HGM_ERROR,\
                           ("HGM_MapAxesFromDevExt: nAxis(%d) != DeviceExtension->nAxes(%d)", \
                            nAxis, (int) DeviceExtension->nAxes));
        }
#ifdef CHANGE_DEVICE
    }
    else
    {
        /*
         *  This must be an exposed sibling so store the calculated nAxis and 
         *  a nButton just to look different.
         */
        DeviceExtension->nAxes = (USHORT)nAxis;
        DeviceExtension->nButtons = MAX_BUTTONS;
    }
#endif /* CHANGE_DEVICE */


    HGM_DBGPRINT( FILE_HIDJOY | HGM_BABBLE,\
                    ("HGM_MapAxesFromDevExt:  uResistiveInputMask=0x%x",\
                     DeviceExtension->resistiveInputMask) );


    if( NT_SUCCESS(ntStatus) )
    {
        ntStatus = HGM_SetupButtons( DeviceExtension );
    }

    return( ntStatus );
} /* HGM_MapAxesFromDevExt */


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_GenerateReport |
 *
 *          Generates a hid report descriptor for a n-axis, m-button joystick,
 *          depending on number of buttons and joy_hws_flags field.
 *
 *  @parm   IN PDEVICE_OBJECT | DeviceObject |
 *
 *          Pointer to the device object
 *
 *  @parm   IN OUT UCHAR * | rgGameReport[MAXBYTES_GAME_REPORT] |
 *
 *          Array that receives the HID report descriptor
 *
 *  @parm   OUT PUSHORT | pCbReport |
 *          
 *          Address of a short integer that receives size of 
 *          HID report descriptor. 
 *
 *  @rvalue   STATUS_SUCCESS  | success
 *  @rvalue   STATUS_BUFFER_TOO_SMALL  | Need more memory for HID descriptor
 *
 *****************************************************************************/
NTSTATUS INTERNAL
    HGM_GenerateReport
    (
    IN PDEVICE_OBJECT       DeviceObject, 
    OUT UCHAR               rgGameReport[MAXBYTES_GAME_REPORT],
    OUT PUSHORT             pCbReport
    )
{
    NTSTATUS    ntStatus;
    PDEVICE_EXTENSION DeviceExtension;
    UCHAR       *pucReport; 
    int         Idx;
    int         UsageIdx;
    ULONG       dwFlags; 

    int         InitialAxisMappings[MAX_AXES];


    typedef struct _USAGES
    {
        UCHAR UsagePage;
        UCHAR Usage;
    } USAGES, *PUSAGE;

    typedef struct _JOYCLASSPARAMS
    {
        UCHAR   TopLevelUsage;
        USAGES  Usages[MAX_AXES];
    } JOYCLASSPARAMS, *PJOYCLASSPARAMS;
    
    PJOYCLASSPARAMS pJoyParams;

    /* 
     *  Canned parameters for devices
     *  The top-level usage must be either HID_USAGE_GENERIC_JOYSTICK or 
     *  HID_USAGE_GENERIC_GAMEPAD in order for the device to be treated as a 
     *  game controller.
     *  The poll limits are specified in uSecs so the value stored here is 1000000/x
     */

    JOYCLASSPARAMS JoystickParams =
    {   
        HID_USAGE_GENERIC_JOYSTICK,
        {   { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_X} , 
            { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_Y} , 
            { HID_USAGE_PAGE_SIMULATION, HID_USAGE_SIMULATION_THROTTLE} ,
            { HID_USAGE_PAGE_SIMULATION, HID_USAGE_SIMULATION_RUDDER} }
    };

    JOYCLASSPARAMS GamepadParams =
    {   
        HID_USAGE_GENERIC_GAMEPAD,
        {   { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_X} , 
            { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_Y} , 
            { HID_USAGE_PAGE_SIMULATION, HID_USAGE_SIMULATION_THROTTLE} ,
            { HID_USAGE_PAGE_SIMULATION, HID_USAGE_SIMULATION_RUDDER} }
    };

    JOYCLASSPARAMS CarCtrlParams =
    {   
        HID_USAGE_GENERIC_JOYSTICK,
        {   { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_X} , 
            { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_Y} , 
            { HID_USAGE_PAGE_SIMULATION, HID_USAGE_SIMULATION_THROTTLE} ,
            { HID_USAGE_PAGE_SIMULATION, HID_USAGE_SIMULATION_RUDDER} }
    };

    JOYCLASSPARAMS FlightYokeParams =
    {   
        HID_USAGE_GENERIC_JOYSTICK,
        {   { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_X} , 
            { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_Y} , 
            { HID_USAGE_PAGE_SIMULATION, HID_USAGE_SIMULATION_THROTTLE} ,
            { HID_USAGE_PAGE_SIMULATION, HID_USAGE_SIMULATION_RUDDER} }
    };


    PAGED_CODE();

    HGM_DBGPRINT( FILE_HIDJOY | HGM_FENTRY,\
                    ("HGM_GenerateReport(ucIn=0x%x,DeviceObject=0x%x)",\
                     rgGameReport, DeviceObject) );

    /*
     *  Get a pointer to the device extension
     */

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    /*
     *  Although the axes have already been validated and mapped in 
     *  HGM_JoystickConfig this function destroys the mapping when it compacts 
     *  the axes towards the start of the descriptor report.  Since this 
     *  function will be called once to find the descriptor length and then 
     *  again to read the report, the mappings are regenerated again each 
     *  time through.  Although this results in the parameters being 
     *  interpreted three times (for validation, descriptor size and 
     *  descriptor content) it avoids the possibility of a discrepancy in 
     *  implementation of separate functions.
     */

    ntStatus = HGM_MapAxesFromDevExt( DeviceExtension );
    ASSERTMSG( "HGM_GenerateReport:", ntStatus == STATUS_SUCCESS );

    pucReport = rgGameReport;

    dwFlags = DeviceExtension->HidGameOemData.OemData[(DeviceExtension->fSiblingFound!=0)].joy_hws_dwFlags;  


    /* 
     *  What manner of beast have we ?
     */
    if( dwFlags & JOY_HWS_ISGAMEPAD )
    {
        pJoyParams = &GamepadParams;
    }
    else if( dwFlags & JOY_HWS_ISYOKE )
    {
        pJoyParams = &FlightYokeParams;
    }
    else if( dwFlags & JOY_HWS_ISCARCTRL )
    {
        pJoyParams = &CarCtrlParams;
    }
    else
    {
        pJoyParams = &JoystickParams;
    }

#define NEXT_BYTE( pReport, Data )   \
            ASSERTMSG( "HGM_GenerateReport:", pReport+sizeof(UCHAR)-rgGameReport < MAXBYTES_GAME_REPORT );  \
            *pReport++ = Data;    

#define NEXT_LONG( pReport, Data )   \
            ASSERTMSG( "HGM_GenerateReport:", pReport+sizeof(ULONG)-rgGameReport < MAXBYTES_GAME_REPORT);   \
            *(((LONG UNALIGNED*)(pReport))++) = Data;

#define ITEM_DEFAULT        0x00 /* Data, Array, Absolute, No Wrap, Linear, Preferred State, Has no NULL */
#define ITEM_VARIABLE       0x02 /* as ITEM_DEFAULT but value is a variable, not an array */
#define ITEM_HASNULL        0x40 /* as ITEM_DEFAULT but values out of range are considered NULL */
#define ITEM_ANALOG_AXIS    ITEM_VARIABLE
#define ITEM_DIGITAL_POV    (ITEM_VARIABLE|ITEM_HASNULL)
#define ITEM_BUTTON         ITEM_VARIABLE
#define ITEM_PADDING        0x01 /* Constant (nothing else applies) */


    /* USAGE_PAGE (Generic Desktop) */
    NEXT_BYTE(pucReport,    HIDP_GLOBAL_USAGE_PAGE_1);
    NEXT_BYTE(pucReport,    HID_USAGE_PAGE_GENERIC);

    /* USAGE (Joystick | GamePad ) */
    NEXT_BYTE(pucReport,    HIDP_LOCAL_USAGE_1);
    NEXT_BYTE(pucReport,    pJoyParams->TopLevelUsage);

    /* Logical Min is the smallest value that could be produced by a poll */
    NEXT_BYTE(pucReport,    HIDP_GLOBAL_LOG_MIN_4);
    NEXT_LONG(pucReport,    0 );

    /* Logical Max is the largest value that could be produced by a poll */
    NEXT_BYTE(pucReport,    HIDP_GLOBAL_LOG_MAX_4);
    NEXT_LONG(pucReport,    AXIS_FULL_SCALE );

    /* Start a Linked collection */
    /*
     *  Since this is a generic driver we know knothing about the physical 
     *  distribution of controls on the device so we put everything in a 
     *  single collection.  If, for instance, we knew that some buttons were 
     *  on the base and some on the stick we could better describe them by 
     *  reporting them in separate collections.
     */
    NEXT_BYTE(pucReport,    HIDP_MAIN_COLLECTION); 
    NEXT_BYTE(pucReport,    0x0 ); 

    /* Define one axis at a time */
    NEXT_BYTE(pucReport,    HIDP_GLOBAL_REPORT_COUNT_1);
    NEXT_BYTE(pucReport,    0x1);  

    /* Each axis is a 32 bits value */
    NEXT_BYTE(pucReport,    HIDP_GLOBAL_REPORT_SIZE);
    NEXT_BYTE(pucReport,    8 * sizeof(ULONG) );

    /* 
     *  Do the axis 
     *  Although HID could cope with the "active" axes being mixed with the 
     *  dummy ones, it makes life simpler to move them to the start.
     *  Pass through all the axis maps generated by HGM_JoystickConfig 
     *  and map all the active ones into the descriptor, copying the usages 
     *  appropriate for the type of device.
     *  Since a polled POV is nothing more than a different interpretation 
     *  of axis data, this is added after any axes.
     */
    C_ASSERT( sizeof( InitialAxisMappings ) == sizeof( DeviceExtension->AxisMap ) );
    RtlCopyMemory( InitialAxisMappings, DeviceExtension->AxisMap, sizeof( InitialAxisMappings ) );



    Idx = 0;
    for( UsageIdx = 0; UsageIdx < MAX_AXES; UsageIdx++ )
    {
        if( InitialAxisMappings[UsageIdx] >= INVALID_INDEX )
        {
            continue;
        }

        DeviceExtension->AxisMap[Idx] = InitialAxisMappings[UsageIdx];

        NEXT_BYTE(pucReport,    HIDP_LOCAL_USAGE_4);
        NEXT_BYTE(pucReport,    pJoyParams->Usages[UsageIdx].Usage);
        NEXT_BYTE(pucReport,    0x0);
        NEXT_BYTE(pucReport,    pJoyParams->Usages[UsageIdx].UsagePage);
        NEXT_BYTE(pucReport,    0x0);

        /* Data Field */
        NEXT_BYTE(pucReport,    HIDP_MAIN_INPUT_1);
        NEXT_BYTE(pucReport,    ITEM_ANALOG_AXIS);

        HGM_DBGPRINT( FILE_HIDJOY |  HGM_GEN_REPORT, \
                        ("HGM_GenerateReport:Idx=%d, UsageIdx=%d, Mapping=%d, Usage=%02x, Page=%02x",\
                         Idx, UsageIdx, DeviceExtension->AxisMap[UsageIdx], \
                         pJoyParams->Usages[UsageIdx].Usage, pJoyParams->Usages[UsageIdx].UsagePage ) ) ;
        Idx++;
    }

    if( dwFlags & JOY_HWS_POVISPOLL )
    {
        /*
         *  A polled POV is just the same as an axis.
         *  Note, we have already checked that there is an axis for use as the POV.
         *  Also, this type of POV can be distinguished from a digital POV by it's 
         *  lack of a NULL value.
         */
        NEXT_BYTE(pucReport,    HIDP_LOCAL_USAGE_4);
        NEXT_BYTE(pucReport,    HID_USAGE_GENERIC_HATSWITCH);
        NEXT_BYTE(pucReport,    0x0);
        NEXT_BYTE(pucReport,    HID_USAGE_PAGE_GENERIC);
        NEXT_BYTE(pucReport,    0x0);

        /* Data Field */
        NEXT_BYTE(pucReport,    HIDP_MAIN_INPUT_1);
        NEXT_BYTE(pucReport,    ITEM_ANALOG_AXIS);

        HGM_DBGPRINT( FILE_HIDJOY |  HGM_GEN_REPORT, \
                        ("HGM_GenerateReport:Idx=%d, Set to polled POV", Idx ) ) ;
        Idx++;
    }

    /*
     *  Now fill in any remaining axis values as dummys
     */
    while( Idx < MAX_AXES )
    {
        /* Constant Field */
        NEXT_BYTE(pucReport,    HIDP_MAIN_INPUT_1);
        NEXT_BYTE(pucReport,    ITEM_PADDING);

        HGM_DBGPRINT( FILE_HIDJOY |  HGM_GEN_REPORT, \
                        ("HGM_GenerateReport:Idx=%d, Set to constant field", Idx ) ) ;
        Idx++;
    }
        

    /*
     *  Now move on to the byte sized fields
     */


    if( dwFlags & JOY_HWS_POVISBUTTONCOMBOS )
    {
        /*
         *  Redefine the logical and physical ranges from now on 
         *  A digital POV has a NULL value (a value outside the logical range) 
         *  when the POV is centered.  To make life easier call the NULL value 
         *  zero, so the logical range is from 1 to 4.

        /* Logical Min */
        NEXT_BYTE(pucReport,    HIDP_GLOBAL_LOG_MIN_1);
        NEXT_BYTE(pucReport,    1 );

        /* Logical Max */
        NEXT_BYTE(pucReport,    HIDP_GLOBAL_LOG_MAX_1);
        NEXT_BYTE(pucReport,    4 );

        /* 
         *  report for digital POV is 3 bits data plus 5 constant bits to fill 
         *  the byte.  
         */
        NEXT_BYTE(pucReport,    HIDP_LOCAL_USAGE_4);
        NEXT_BYTE(pucReport,    HID_USAGE_GENERIC_HATSWITCH);
        NEXT_BYTE(pucReport,    0x0);
        NEXT_BYTE(pucReport,    HID_USAGE_PAGE_GENERIC);
        NEXT_BYTE(pucReport,    0x0);

        /* Data Field */
        NEXT_BYTE(pucReport,    HIDP_GLOBAL_REPORT_SIZE);
        NEXT_BYTE(pucReport,    0x3);
        NEXT_BYTE(pucReport,    HIDP_MAIN_INPUT_1);
        NEXT_BYTE(pucReport,    ITEM_DIGITAL_POV);

        /* top 5 bits constant */
        NEXT_BYTE(pucReport,    HIDP_GLOBAL_REPORT_SIZE);
        NEXT_BYTE(pucReport,    0x5);
        NEXT_BYTE(pucReport,    HIDP_MAIN_INPUT_1);
        NEXT_BYTE(pucReport,    ITEM_PADDING);

        HGM_DBGPRINT( FILE_HIDJOY |  HGM_GEN_REPORT, \
                        ("HGM_GenerateReport:First button combo POV is on" ) ) ;

        if( dwFlags & JOY_HWS_HASPOV2 )
        {
            NEXT_BYTE(pucReport,    HIDP_LOCAL_USAGE_4);
            NEXT_BYTE(pucReport,    HID_USAGE_GENERIC_HATSWITCH);
            NEXT_BYTE(pucReport,    0x0);
            NEXT_BYTE(pucReport,    HID_USAGE_PAGE_GENERIC);
            NEXT_BYTE(pucReport,    0x0);

            /* Data Field */
            NEXT_BYTE(pucReport,    HIDP_GLOBAL_REPORT_SIZE);
            NEXT_BYTE(pucReport,    0x3);
            NEXT_BYTE(pucReport,    HIDP_MAIN_INPUT_1);
            NEXT_BYTE(pucReport,    ITEM_DIGITAL_POV);

            /* top 5 bits constant */
            NEXT_BYTE(pucReport,    HIDP_GLOBAL_REPORT_SIZE);
            NEXT_BYTE(pucReport,    0x5);
            NEXT_BYTE(pucReport,    HIDP_MAIN_INPUT_1);
            NEXT_BYTE(pucReport,    ITEM_PADDING);

            HGM_DBGPRINT( FILE_HIDJOY |  HGM_GEN_REPORT, \
                            ("HGM_GenerateReport:Second button combo POV is on" ) ) ;
        }
        else
        {
            /* 8 bits of constant data instead of second POV */
            NEXT_BYTE(pucReport,    HIDP_GLOBAL_REPORT_SIZE);
            NEXT_BYTE(pucReport,    0x8);

            /* Constant Field */
            NEXT_BYTE(pucReport,    HIDP_MAIN_INPUT_1);
            NEXT_BYTE(pucReport,    ITEM_PADDING);

            HGM_DBGPRINT( FILE_HIDJOY |  HGM_GEN_REPORT, \
                            ("HGM_GenerateReport:No second button combo POV" ) ) ;
        }
    } 
    else
    {
        /* 16 bits of constant data instead of button combo POVs */
        NEXT_BYTE(pucReport,    HIDP_GLOBAL_REPORT_SIZE);
        NEXT_BYTE(pucReport,    0x10);

        /* Constant Field */
        NEXT_BYTE(pucReport,    HIDP_MAIN_INPUT_1);
        NEXT_BYTE(pucReport,    ITEM_PADDING);

        HGM_DBGPRINT( FILE_HIDJOY |  HGM_GEN_REPORT, \
                        ("HGM_GenerateReport:Button combo POV are off" ) ) ;
    }


    /* 
     * Now the buttons 
     */
    for( Idx = 0x0; Idx < DeviceExtension->nButtons; Idx++ )
    {
        /* Report size is 1 bit for button */
        NEXT_BYTE(pucReport,    HIDP_GLOBAL_REPORT_SIZE);
        NEXT_BYTE(pucReport,    0x1);

        NEXT_BYTE(pucReport,    HIDP_LOCAL_USAGE_4);
        NEXT_BYTE(pucReport,    (UCHAR)(Idx + 1) );
        NEXT_BYTE(pucReport,    0x0);
        NEXT_BYTE(pucReport,    HID_USAGE_PAGE_BUTTON);
        NEXT_BYTE(pucReport,    0x0);

        /* Data field */
        NEXT_BYTE(pucReport,    HIDP_MAIN_INPUT_1);
        NEXT_BYTE(pucReport,    ITEM_BUTTON);

        /* 7 bits of constant data */
        NEXT_BYTE(pucReport,    HIDP_GLOBAL_REPORT_SIZE);
        NEXT_BYTE(pucReport,    0x7);
        NEXT_BYTE(pucReport,    HIDP_MAIN_INPUT_1);
        NEXT_BYTE(pucReport,    ITEM_PADDING);

        HGM_DBGPRINT( FILE_HIDJOY | HGM_GEN_REPORT, \
                        ("HGM_GenerateReport:Button %u on",Idx ) ) ;
    } 

    if( Idx < MAX_BUTTONS )
    {
        /* Constant report for 8 * unused buttons bits */
        NEXT_BYTE(pucReport,    HIDP_GLOBAL_REPORT_SIZE);
        NEXT_BYTE(pucReport,    (UCHAR)((MAX_BUTTONS-Idx)*8) );

        /* Constant Field */
        NEXT_BYTE(pucReport,    HIDP_MAIN_INPUT_1);
        NEXT_BYTE(pucReport,    ITEM_PADDING);

        HGM_DBGPRINT( FILE_HIDJOY | HGM_GEN_REPORT, \
                        ("HGM_GenerateReport:Last %u buttons off",MAX_BUTTONS-Idx ) ) ;
    }

    /* End of collection,  We're done ! */
    NEXT_BYTE(pucReport,  HIDP_MAIN_ENDCOLLECTION); 


#undef NEXT_BYTE
#undef NEXT_LONG

    if( pucReport - rgGameReport > MAXBYTES_GAME_REPORT)
    {
        ntStatus   = STATUS_BUFFER_TOO_SMALL;
        *pCbReport = 0x0;
        RtlZeroMemory(rgGameReport, sizeof(rgGameReport));
    } else
    {
        *pCbReport = (USHORT) (pucReport - rgGameReport);
        ntStatus = STATUS_SUCCESS;
    }

    HGM_DBGPRINT( FILE_HIDJOY | HGM_GEN_REPORT,\
                    ("HGM_GenerateReport: ReportSize=0x%x",\
                     *pCbReport) );

    HGM_EXITPROC(FILE_HIDJOY | HGM_FEXIT_STATUSOK, "HGM_GenerateReport", ntStatus);

    return ( ntStatus );
} /* HGM_GenerateReport */



/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_JoystickConfig |
 *
 *          Check that the configuration is valid whilst there is still time 
 *          to refuse it.
 *          <nl>HGM_GenerateReport uses the results generated here if the 
 *          settings are OK.
 *
 *  @parm   IN PDEVICE_OBJECT | DeviceObject |
 *
 *          Pointer to the device object
 *
 *  @rvalue   STATUS_SUCCESS  | success
 *  @rvalue   STATUS_DEVICE_CONFIGURATION_ERROR  | Invalid configuration specified
 *
 *****************************************************************************/
NTSTATUS INTERNAL
    HGM_JoystickConfig 
    (
    IN PDEVICE_OBJECT         DeviceObject
    )
{
    PDEVICE_EXTENSION   DeviceExtension;
    NTSTATUS            ntStatus;
    int                 Idx;

    PAGED_CODE();

    HGM_DBGPRINT( FILE_HIDJOY | HGM_FENTRY,\
                    ("HGM_JoystickConfig(DeviceObject=0x%x)",\
                     DeviceObject) );


    /*
     * Get a pointer to the device extension
     */

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    ntStatus = HGM_MapAxesFromDevExt( DeviceExtension );

    if( DeviceExtension->ReadAccessorDigital )
    {
        DeviceExtension->ScaledTimeout = AXIS_TIMEOUT;
    }
    else
    {
        /*
         * Calculate time thresholds for analog device
         */
        if( ( DeviceExtension->HidGameOemData.OemData[0].Timeout < ANALOG_POLL_TIMEOUT_MIN )
          ||( DeviceExtension->HidGameOemData.OemData[0].Timeout > ANALOG_POLL_TIMEOUT_MAX ) )
        {
            HGM_DBGPRINT(FILE_HIDJOY | HGM_BABBLE,\
                           ("Ignoring out of range timeout: %u uSecs",\
                            DeviceExtension->HidGameOemData.OemData[0].Timeout));

            DeviceExtension->ScaledTimeout = (ULONG)( ( (ULONGLONG)ANALOG_POLL_TIMEOUT_DFT
                                                      * (ULONGLONG)(AXIS_FULL_SCALE<<SCALE_SHIFT) )
                                                    / (ULONGLONG)ANALOG_POLL_TIMEOUT_MAX );
        }
        else
        {
            DeviceExtension->ScaledTimeout = (ULONG)( ( (ULONGLONG)DeviceExtension->HidGameOemData.OemData[0].Timeout
                                                      * (ULONGLONG)(AXIS_FULL_SCALE<<SCALE_SHIFT) )
                                                    / (ULONGLONG)ANALOG_POLL_TIMEOUT_MAX );
        }

        HGM_DBGPRINT(FILE_HIDJOY | HGM_BABBLE,\
                       ("ScaledTimeout: %u",\
                        DeviceExtension->ScaledTimeout));

        /*
         *  Use one quarter of the minimum poll timeout as a starting value 
         *  for the time between two polls which will be considered to have 
         *  been interrupted.
         */
        DeviceExtension->ScaledThreshold = (ULONG)( ( (ULONGLONG)ANALOG_POLL_TIMEOUT_MIN
                                                    * (ULONGLONG)AXIS_FULL_SCALE )
                                                  / (ULONGLONG)ANALOG_POLL_TIMEOUT_MAX )>>2;
    }


    /*
     *  Set initial values of LastGoodAxis so that the device will not show
     *  up as present until we get at least one valid poll.
     */
    for( Idx = MAX_AXES; Idx >= 0; Idx-- )
    {
        DeviceExtension->LastGoodAxis[Idx] = AXIS_TIMEOUT;
    }

    HGM_EXITPROC(FILE_HIDJOY | HGM_FEXIT_STATUSOK, "HGM_JoystickConfig", ntStatus);

    return ntStatus;
} /* HGM_JoystickConfig */


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_InitAnalog |
 *
 *          Check that the configuration is valid whilst there is still time 
 *          to refuse it.  
 *          <nl>Detect and validate sibling relationships and call 
 *          HGM_JoystickConfig for the rest of the work.
 *
 *  @parm   IN PDEVICE_OBJECT | DeviceObject |
 *
 *          Pointer to the device object
 *
 *  @rvalue   STATUS_SUCCESS  | success
 *  @rvalue   STATUS_DEVICE_CONFIGURATION_ERROR  | Invalid configuration specified
 *
 *****************************************************************************/
/*
 *  Disable warning for variable used before set as it is hard for a compiler 
 *  to see that the use of DeviceExtension_Sibling is gated by a flag which 
 *  can only be set after DeviceExtension_Sibling is initialized.
 */
#pragma warning( disable:4701 )
NTSTATUS EXTERNAL
    HGM_InitAnalog
    (
    IN PDEVICE_OBJECT         DeviceObject
    )
{
    NTSTATUS            ntStatus;
    PDEVICE_EXTENSION   DeviceExtension;
    PDEVICE_EXTENSION   DeviceExtension_Sibling;
    PLIST_ENTRY         pEntry;

#define ARE_WE_RELATED(_x_, _y_)                                \
    (                                                           \
        (_x_)->GameContext     == (_y_)->GameContext      &&    \
        (_x_)->WriteAccessor   == (_y_)->WriteAccessor    &&    \
        (_x_)->ReadAccessor    == (_y_)->ReadAccessor           \
    )

    PAGED_CODE ();
    
    /*
     * Get a pointer to the device extension
     */
    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);
    

    /*
     *  No modifications to the Global List while we are looking at it
     */
    ExAcquireFastMutex (&Global.Mutex);

    /*
     *  For two joysticks interface two fdos are created to service them 
     *  but physically they both share the same port.
     *  For the second sibling certain extra rules must be applied so we 
     *  search our list of devices for another device using the same port 
     *  and if we find one mark this one as a sibling.
     */
    for(pEntry = Global.DeviceListHead.Flink;
       pEntry != &Global.DeviceListHead;
       pEntry = pEntry->Flink)
    {

        /*
         * Obtain the device Extension of the Sibling
         */
        DeviceExtension_Sibling = CONTAINING_RECORD(pEntry, DEVICE_EXTENSION, Link);

        if(       DeviceExtension_Sibling != DeviceExtension
               && TRUE == ARE_WE_RELATED(DeviceExtension, DeviceExtension_Sibling)
               && TRUE == DeviceExtension_Sibling->fStarted )
        {
#ifdef CHANGE_DEVICE
            if( DeviceExtension_Sibling->fReplaced )
            {
                HGM_DBGPRINT(FILE_HIDJOY | HGM_BABBLE, ("Outgoing Sibling found (0x%x)", DeviceExtension_Sibling));
            }
            else
            {
#endif /* CHANGE_DEVICE */
                HGM_DBGPRINT(FILE_HIDJOY | HGM_BABBLE, ("Sibling found (0x%x)", DeviceExtension_Sibling));

                DeviceExtension->fSiblingFound = TRUE;
#ifdef CHANGE_DEVICE
            }
#endif /* CHANGE_DEVICE */
            break;
        }
    }

    /*
     *  We are done, release the Mutex
     */
    ExReleaseFastMutex (&Global.Mutex);

    /*
     * check the axis and button configuration for the joystick
     */
    ntStatus = HGM_JoystickConfig(DeviceObject);

    if( NT_SUCCESS( ntStatus ) )
    {
        /*
         *  Make sure that sibling axes are not overlapped
         */
        if(  DeviceExtension->fSiblingFound &&
             (DeviceExtension_Sibling->resistiveInputMask & DeviceExtension->resistiveInputMask) != 0x0 )
        {

            HGM_DBGPRINT(FILE_HIDJOY |HGM_ERROR,\
                           ("HGM_InitDevice: OverLapping Resources ResisitiveInputMask(0x%x) Sibling(0x%x)",\
                            DeviceExtension->resistiveInputMask,DeviceExtension_Sibling->resistiveInputMask ));
            ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;

        }
    }
    else
    {
        HGM_DBGPRINT(FILE_HIDJOY | HGM_ERROR,\
                       ("HGM_InitDevice: JoystickConfig Failed"));
    }

    return( ntStatus );

} /* HGM_InitAnalog */



/*
 *  Change device sample only code
 */
#ifdef CHANGE_DEVICE

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   VOID  | HGM_ChangeHandler |
 *
 *          Use IOCTL_GAMEENUM_EXPOSE_SIBLING and IOCTL_GAMEENUM_REMOVE_SELF 
 *          to change the attributes of the device.
 *
 *  @parm   IN PDEVICE_OBJECT | DeviceObject |
 *
 *          Pointer to the device object
 *
 *  @parm   PIO_WORKITEM | WorkItem |
 *
 *          The work item that this call is being processed under.
 *
 *****************************************************************************/
VOID
    HGM_ChangeHandler
    ( 
    IN PDEVICE_OBJECT           DeviceObject,
    PIO_WORKITEM                WorkItem
    )
{
    NTSTATUS                ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION       DeviceExtension;
    KEVENT                  IoctlCompleteEvent;
    IO_STATUS_BLOCK         IoStatus;
    PIO_STACK_LOCATION      irpStack, nextStack;
    PIRP                    pIrp;
    PVOID                   SiblingHandle;

    GAMEENUM_EXPOSE_SIBLING ExposeSibling;

    PAGED_CODE ();

    /*
     * Get a pointer to the device extension
     */
    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    HGM_DBGPRINT(FILE_HIDJOY | HGM_FENTRY,\
                   ("HGM_ChangeHandler(DeviceExtension=0x%x)", DeviceExtension));
    
    KeInitializeEvent(&IoctlCompleteEvent, NotificationEvent, FALSE);

	pIrp = IoBuildDeviceIoControlRequest (
					IOCTL_GAMEENUM_EXPOSE_SIBLING,
					DeviceExtension->NextDeviceObject,
					&ExposeSibling,
					sizeof( ExposeSibling ),
					&ExposeSibling,
					sizeof( ExposeSibling ),
					TRUE,
					&IoctlCompleteEvent,
					&IoStatus);

    if( pIrp )
    {
        /*
         *  For demonstration purposes only, we don't actually change the 
         *  device, we just re-expose the same one.  If the device really 
         *  needs to be changed, this would be signalled either by a 
         *  change in the OemData on the newly exposed device or by using 
         *  a specific HardwareID string.
         *  Note the nAxis and nButton fields will always be zero for an 
         *  exposed sibling.
         */
        RtlZeroMemory( &ExposeSibling, sizeof( ExposeSibling ) );
        ExposeSibling.Size = sizeof( ExposeSibling );
        ExposeSibling.HardwareHandle = &SiblingHandle;

        C_ASSERT( sizeof( ExposeSibling.OemData ) == sizeof( DeviceExtension->HidGameOemData.Game_Oem_Data ) );
        RtlCopyMemory(ExposeSibling.OemData, DeviceExtension->HidGameOemData.Game_Oem_Data, sizeof(ExposeSibling.OemData));
        ASSERT( ExposeSibling.UnitID == 0 );
        
        /*
         *  Setting a NULL pointer causes the HardwareID of this sibling to be used
         */
        ExposeSibling.HardwareIDs = NULL;


        /*
         *  issue a synchronous request to GameEnum to expose this new sibling
         */
	    ntStatus = IoCallDriver( DeviceExtension->NextDeviceObject, pIrp );

	    if( ntStatus == STATUS_PENDING )
	    {	
		    ntStatus = KeWaitForSingleObject (&IoctlCompleteEvent, Executive, KernelMode, FALSE, NULL);
	    }
        
        if( NT_SUCCESS(ntStatus) )
        {
            /*
             *  All went well so remove self
             */
            HGM_DBGPRINT(FILE_HIDJOY | HGM_BABBLE, ("Sibling exposed!"));

	        pIrp = IoBuildDeviceIoControlRequest (
					        IOCTL_GAMEENUM_REMOVE_SELF,
					        DeviceExtension->NextDeviceObject,
					        NULL,
					        0,
					        NULL,
					        0,
					        TRUE,
					        &IoctlCompleteEvent,
					        &IoStatus);

            if( pIrp )
            {
                /*
                 *  issue a synchronous request to GameEnum to remove self
                 */
	            ntStatus = IoCallDriver( DeviceExtension->NextDeviceObject, pIrp );

	            if( ntStatus == STATUS_PENDING )
	            {	
		            ntStatus = KeWaitForSingleObject( &IoctlCompleteEvent, Executive, KernelMode, FALSE, NULL );
	            }
        
                if( NT_SUCCESS(ntStatus) )
                {
                    /*
                     *  All done
                     */
                    HGM_DBGPRINT(FILE_HIDJOY | HGM_BABBLE, ("Removed self!"));
                }
                else
                {
                    /*
                     *  Something bad happened but there's little we can do
                     */
                    HGM_DBGPRINT(FILE_HIDJOY | HGM_ERROR,\
                        ("Failed to remove self with GameEnum error: 0x%08x", \
                        ntStatus));
                }
            }
            else
            {
                ntStatus = STATUS_NO_MEMORY;
                HGM_DBGPRINT(FILE_HIDJOY | HGM_ERROR, \
                    ("Failed to create IRP for remove self") );
            }
        }
        else
        {
            /*
             *  Something bad happened so reset the flag and carry on
             */
            DeviceExtension->fReplaced = FALSE;
            HGM_DBGPRINT(FILE_HIDJOY | HGM_WARN,\
                ("Failed to expose sibling with GameEnum error: 0x%08x", ntStatus));
        }
    }
    else
    {
        ntStatus = STATUS_NO_MEMORY;
        DeviceExtension->fReplaced = FALSE;
        HGM_DBGPRINT(FILE_HIDJOY | HGM_ERROR, \
            ("Failed to create IRP for expose sibling") );
    }
        
    /*
     *  The work is done, so free the resources
     */
    IoFreeWorkItem( WorkItem );

    /*
     *  We've finished touching the DeviceExtension now.
     */
    HGM_DecRequestCount( DeviceExtension );

    HGM_EXITPROC(FILE_HIDJOY|HGM_FEXIT_STATUSOK, "HGM_ChangeHandler", ntStatus);

    return;
} /* HGM_ChangeHandler */


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   VOID  | HGM_DeviceChanged |
 *
 *          Start the process of changing the device attributes by stashing 
 *          away all the data needed and then initializing and queuing a work 
 *          item to call the IOCTL at the required PASSIVE_LEVEL.
 *
 *  @parm   IN PDEVICE_OBJECT | DeviceObject |
 *
 *          Pointer to the device object
 *
 *  @parm   IN  OUT PDEVICE_EXTENSION | DeviceExtension | 
 *
 *          Pointer to the mini-driver device extension.
 *
 *****************************************************************************/
VOID
    HGM_DeviceChanged
    ( 
    IN      PDEVICE_OBJECT          DeviceObject,
    IN  OUT PDEVICE_EXTENSION       DeviceExtension
    )
{
    NTSTATUS        ntStatus;
    PIO_WORKITEM    WorkItem;

    /*
     *  Since the work item will use the device extension, bump the usage 
     *  count up one in case anyone tries to remove the device between 
     *  now and when the work item gets to run.  If that fails, forget it.
     */
    ntStatus = HGM_IncRequestCount( DeviceExtension );

    if( NT_SUCCESS(ntStatus) )
    {
        WorkItem = IoAllocateWorkItem( DeviceObject );
        if( WorkItem )
        {
            DeviceExtension->fReplaced = TRUE;
            IoQueueWorkItem( WorkItem, (PIO_WORKITEM_ROUTINE)HGM_ChangeHandler, 
                DelayedWorkQueue, WorkItem );
        }
        else
        {
            HGM_DecRequestCount( DeviceExtension );
            HGM_DBGPRINT(FILE_HIDJOY | HGM_WARN, ("Failed to allocate work item to change device") );
        }
    }
    else
    {
        HGM_DBGPRINT(FILE_HIDJOY | HGM_WARN, ("Failed to change device as device is being removed") );
    }
} /* HGM_DeviceChanged */

#endif /* CHANGE_DEVICE */


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   VOID  | HGM_Game2HID |
 *
 *          Process the data returned from polling the gameport into values 
 *          and buttons for returning to HID.
 *          <nl>The meaning of the data is interpreted according to the 
 *          characteristics of the device described in the hardware settings
 *          flags.
 *
 *  @parm   IN PDEVICE_OBJECT | DeviceObject |
 *
 *          Pointer to the device object
 *
 *  @parm   IN      PDEVICE_EXTENSION | DeviceExtension | 
 *
 *          Pointer to the mini-driver device extension.
 *
 *  @parm   IN  OUT PUHIDGAME_INPUT_DATA | pHIDData | 
 *
 *          Pointer to the buffer into which the HID report should be written.
 *          This buffer must be assumed to be unaligned.
 *
 *****************************************************************************/
VOID 
    HGM_Game2HID
    (
#ifdef CHANGE_DEVICE
    IN PDEVICE_OBJECT               DeviceObject,
#endif /* CHANGE_DEVICE */
    IN      PDEVICE_EXTENSION       DeviceExtension,
    IN  OUT PUHIDGAME_INPUT_DATA    pHIDData
    )
{
    LONG    Idx;

    /*
     *  Use a local buffer to assemble the report as the real buffer may not 
     *  be aligned.
     */
    HIDGAME_INPUT_DATA  LocalBuffer;

    RtlZeroMemory( &LocalBuffer, sizeof( LocalBuffer ) );

    /*
     * Remap axis
     */
    for(Idx = 0x0; Idx < DeviceExtension->nAxes; Idx++ )
    {
        LocalBuffer.Axis[Idx] = DeviceExtension->LastGoodAxis[DeviceExtension->AxisMap[Idx]];
    }

    /*
     * Copy buttons and remap any POVs
     */

    if( DeviceExtension->fSiblingFound )
    {
        /*
         *  Simplest case, 2nd half poll must be 2A 2B
         */
        LocalBuffer.Button[0] = DeviceExtension->LastGoodButton[2];
        LocalBuffer.Button[1] = DeviceExtension->LastGoodButton[3];
    }
    else if( DeviceExtension->HidGameOemData.OemData[0].joy_hws_dwFlags & JOY_HWS_POVISBUTTONCOMBOS )
    {
        UCHAR Buttons = 0;

        for( Idx = 3; Idx >=0; Idx-- )
        {
            Buttons <<= 1;
            Buttons = (UCHAR)(Buttons + (UCHAR)(DeviceExtension->LastGoodButton[Idx] >> BUTTON_BIT));
        }

        if( DeviceExtension->HidGameOemData.OemData[0].joy_hws_dwFlags & JOY_HWS_HASPOV2 )
        {
            Idx = c2PComboLU[Buttons];
        }
        else
        {
            Idx = c1PComboLU[Buttons];
        }

        if( Idx >= P1_NULL )
        {
            if( Idx < P2_NULL )
            {
                LocalBuffer.hatswitch[0] = (UCHAR)(Idx & POV_MASK);
            }
            else
            {
                LocalBuffer.hatswitch[1] = (UCHAR)(Idx & POV_MASK);
            }
        }
        else
        {
#ifdef CHANGE_DEVICE
            if( ( Idx >= DeviceExtension->nButtons ) && ( !DeviceExtension->fReplaced ) )
            {
                /*
                 *  If a higher button was pressed than expected, use 
                 *  remove_self/expose_sibling to change expectations.
                 */
                HGM_DeviceChanged( DeviceObject, DeviceExtension );
            }
#endif /* CHANGE_DEVICE */
            LocalBuffer.Button[Idx] = BUTTON_ON;
        }
    }
    else
    {
        if( DeviceExtension->HidGameOemData.OemData[0].joy_hws_dwFlags & JOY_HWS_POVISPOLL )
        {
            /*
             *  Following the axis mapping loop, Idx is one larger than 
             *  DeviceExtension->nAxes which is the correct index for a 
             *  polled POV.
             */
            LocalBuffer.Axis[Idx] = DeviceExtension->LastGoodAxis[DeviceExtension->povMap];
        }

        
        /*
         *  Check buttons on R and Z axes
         */
        if( DeviceExtension->nButtons > 5 )
        {
            if( DeviceExtension->LastGoodAxis[3] > DeviceExtension->button6limit )
            {
                /*
                 *  New max found so button is off
                 */
                HGM_DBGPRINT( FILE_HIDJOY |  HGM_BABBLE2, \
                                ("HGM_Game2HID: Changing button 6 limit from %u to %u", \
                                DeviceExtension->button6limit, DeviceExtension->LastGoodAxis[3] ) ) ;
                DeviceExtension->button6limit = DeviceExtension->LastGoodAxis[3];
            }
            else if( DeviceExtension->LastGoodAxis[3] < (DeviceExtension->button6limit>>1) )
            {
                LocalBuffer.Button[5] = BUTTON_ON;
            }
        }
        if( DeviceExtension->nButtons > 4 )
        {
            Idx = 4;

            if( DeviceExtension->LastGoodAxis[2] > DeviceExtension->button5limit )
            {
                /*
                 *  New max found so button is off
                 */
                HGM_DBGPRINT( FILE_HIDJOY |  HGM_BABBLE2, \
                                ("HGM_Game2HID: Changing button 5 limit from %u to %u", \
                                DeviceExtension->button5limit, DeviceExtension->LastGoodAxis[2] ) ) ;
                DeviceExtension->button5limit = DeviceExtension->LastGoodAxis[2];
            }
            else if( DeviceExtension->LastGoodAxis[2] < (DeviceExtension->button5limit>>1) )
            {
                LocalBuffer.Button[4] = BUTTON_ON;
            }
        }
        else
        {
            Idx = DeviceExtension->nButtons;
        }


        /*
         *  Copy all standard buttons
         */
        while( Idx-- )
        {
            LocalBuffer.Button[Idx] = DeviceExtension->LastGoodButton[Idx];
        }

    }

    C_ASSERT( sizeof( *pHIDData ) == sizeof( LocalBuffer ) );
    RtlCopyMemory( pHIDData, &LocalBuffer, sizeof( LocalBuffer ) );

    HGM_DBGPRINT( FILE_HIDJOY |  HGM_BABBLE2, \
                    ("HGM_Game2HID: Axes: X: %08x   Y: %08x   Z: %08x   R: %08x", \
                    LocalBuffer.Axis[0], LocalBuffer.Axis[1], LocalBuffer.Axis[2], LocalBuffer.Axis[3] ) ) ;
    HGM_DBGPRINT( FILE_HIDJOY |  HGM_BABBLE2, \
                    ("HGM_Game2HID: P1: %d   P2: %d   Buttons %d, %d,  %d, %d,  %d, %d,  %d, %d,  %d, %d", \
                    LocalBuffer.hatswitch[0], LocalBuffer.hatswitch[1], \
                    LocalBuffer.Button[0], LocalBuffer.Button[1], LocalBuffer.Button[2], LocalBuffer.Button[3], LocalBuffer.Button[4], \
                    LocalBuffer.Button[5], LocalBuffer.Button[6], LocalBuffer.Button[7], LocalBuffer.Button[8], LocalBuffer.Button[9] ) ) ;
} /* HGM_Game2HID */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\hidgame\analog.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    analog.h

Abstract:  Contains definitions specific to analog joysticks.


Environment:

    Kernel mode

@@BEGIN_DDKSPLIT
Author:

    MarcAnd     03-Jan-99   Split from hidgame.h and hidjoy.c

Revision History:


@@END_DDKSPLIT

--*/
#ifndef __ANALOG_H__
    #define __ANALOG_H__

/*
 *  If you change any of the scaling or timeout values you have to check
 *  that overflows are still avoided under reasonable circumstances.
 */

/*
 *  The timeout value should be passed in DEVICE_EXTENSION.oemData.Timeout
 *  so these limits are a sanity check and default value
 *  The largest expected value is 8mS, use 10 for safety
 */
    #define ANALOG_POLL_TIMEOUT_MIN     (   100L )
    #define ANALOG_POLL_TIMEOUT_DFT     ( 10000L )
    #define ANALOG_POLL_TIMEOUT_MAX     ( 20000L )


/*
 *  Slowest CPU frequency considered when calibrating the CPU timer 
 *  against the performance counter.
 */

    #define HIDGAME_SLOWEST_X86_HZ      ( 45000000 )

/*
 *  Valid axis values are scaled such that a poll of exactly 
 *  ANALOG_POLL_TIMEOUT_MAX mS should return this value
 *  Any analog value greater than this is a timeout
 */
    #define AXIS_FULL_SCALE         ( ANALOG_POLL_TIMEOUT_MAX )

/*
 *  Number of bits to shift left to get a scaled value
 *  This is used so that we can always use an integer multiply of the 
 *  number of counter ticks the poll took to scale the value.
 */
    #define SCALE_SHIFT             16

/*
 *  Macro to calculate a scaling factor from a (ULONGLONG)frequency
 */
#if AXIS_FULL_SCALE == ANALOG_POLL_TIMEOUT_MAX
    #define CALCULATE_SCALE( _Freq_ ) \
        (ULONG)( ( (ULONGLONG)( 1000000 ) << SCALE_SHIFT ) \
               / _Freq_ )
#else
    #define CALCULATE_SCALE( _Freq_ ) \
        (ULONG)( ( (ULONGLONG)AXIS_FULL_SCALE \
                 * ( (ULONGLONG)( 1000000 ) << SCALE_SHIFT ) ) \
                   / ANALOG_POLL_TIMEOUT_MAX ) \
               / _Freq_ )
#endif



    #define HGM_NUMBER_DESCRIPTORS      ( 1 )


    #define MAX_AXES                    ( 4 )
    #define PORT_BUTTONS                ( 4 )
    #define MAX_BUTTONS                 ( 10 )

    #define INVALID_INDEX               ( 0x80 )


/* Specific settings for joystick hardware */
    #define JOY_HWS_HASZ                ( 0x00000001l )     /* has Z info? */
    #define JOY_HWS_HASPOV              ( 0x00000002l )     /* point of view hat present */
    #define JOY_HWS_POVISBUTTONCOMBOS   ( 0x00000004l )     /* pov done through combo of buttons */
    #define JOY_HWS_POVISPOLL           ( 0x00000008l )     /* pov done through polling */

    #define JOY_HWS_ISYOKE              ( 0x00000010l )     /* joystick is a flight yoke */
    #define JOY_HWS_ISGAMEPAD           ( 0x00000020l )     /* joystick is a game pad */
    #define JOY_HWS_ISCARCTRL           ( 0x00000040l )     /* joystick is a car controller */
    
    #define JOY_HWS_HASR                ( 0x00080000l )     /* has R (4th axis) info */
    #define JOY_HWS_HASU                ( 0x00800000l )     /* has U (5th axis) info */
    #define JOY_HWS_HASV                ( 0x01000000l )     /* has V (6th axis) info */

/*
 *  The following flags are for changing which gameport bit should be polled 
 *  for an axis.  These are only interpreted by the analog driver and could 
 *  therefore be safely reinterpreted in other ways by other drivers.
 */

/* X defaults to J1 X axis */
    #define JOY_HWS_XISJ1Y              ( 0x00000080l )     /* X is on J1 Y axis */
    #define JOY_HWS_XISJ2X              ( 0x00000100l )     /* X is on J2 X axis */
    #define JOY_HWS_XISJ2Y              ( 0x00000200l )     /* X is on J2 Y axis */
/* Y defaults to J1 Y axis */
    #define JOY_HWS_YISJ1X              ( 0x00000400l )     /* Y is on J1 X axis */
    #define JOY_HWS_YISJ2X              ( 0x00000800l )     /* Y is on J2 X axis */
    #define JOY_HWS_YISJ2Y              ( 0x00001000l )     /* Y is on J2 Y axis */
/* Z defaults to J2 Y axis */
    #define JOY_HWS_ZISJ1X              ( 0x00002000l )     /* Z is on J1 X axis */
    #define JOY_HWS_ZISJ1Y              ( 0x00004000l )     /* Z is on J1 Y axis */
    #define JOY_HWS_ZISJ2X              ( 0x00008000l )     /* Z is on J2 X axis */
/* POV defaults to J2 Y axis, if it is not button based */
    #define JOY_HWS_POVISJ1X            ( 0x00010000l )     /* pov done through J1 X axis */
    #define JOY_HWS_POVISJ1Y            ( 0x00020000l )     /* pov done through J1 Y axis */
    #define JOY_HWS_POVISJ2X            ( 0x00040000l )     /* pov done through J2 X axis */
/* R defaults to J2 X axis */
    #define JOY_HWS_RISJ1X              ( 0x00100000l )     /* R done through J1 X axis */
    #define JOY_HWS_RISJ1Y              ( 0x00200000l )     /* R done through J1 Y axis */
    #define JOY_HWS_RISJ2Y              ( 0x00400000l )     /* R done through J2 X axis */


/*
 *  If POV is button-combo we overload this meaningless axis selection bit
 *  to indicate a second POV.
 */
    #define JOY_HWS_HASPOV2             JOY_HWS_POVISJ2X


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @struct HIDGAME_INPUT_DATA |
 *
 *          Our HID reports always have 4 axis values (one of which may be a 
 *          polled POV), 2 digital POVs and 10 buttons.
 *          Depending on the HWS flags and number of buttons some of the 
 *          fields will report constant data.
 *
 *          Note, this structure should be byte aligned so that the 
 *          sizeof(it) is the same as HID will calculate given the report 
 *          descriptor.  (In this case it happens to be aligned anyway.)
 *
 *  @field  ULONG | Axis[MAX_AXES] |
 *
 *          Axes data values.
 *
 *  @field  UCHAR | hatswitch[2] |
 *
 *          digital POVs (derived from button combos)
 *
 *  @field  UCHAR | Button[MAX_BUTTONS] |
 *
 *          Button data values.
 *
 *****************************************************************************/
#include <pshpack1.h>

typedef struct _HIDGAME_INPUT_DATA
{
    ULONG   Axis[MAX_AXES];
    UCHAR   hatswitch[2];
    UCHAR   Button[MAX_BUTTONS];
} HIDGAME_INPUT_DATA, *PHIDGAME_INPUT_DATA;
typedef struct _HIDGAME_INPUT_DATA UNALIGNED *PUHIDGAME_INPUT_DATA;

#include <poppack.h>




/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @struct OEMDATA |
 *
 *          OEMData is send to gameEnum as a parameter to IOCTL_EXPOSE_HARDWARE.
 *          Defined as 8 DWORDS. We interpert them here
 *
 *  @field  USHORT | VID |
 *
 *          Vendor ID
 *
 *  @field  USHORT | PID |
 *
 *          Product ID
 *
 *  @field  ULONG | joy_hws_dwFlags |
 *
 *          The dwFlags fields for the device ( Usually read from the registry )
 *
 *  @field  ULONG   | Timeout |
 *
 *          Global timeout for device polling in micro seconds
 *
 *  @field  ULONG   | Reserved |
 *
 *          Reserved for future use.
 *
 *
 *****************************************************************************/
typedef struct _OEMDATA
{
    USHORT  VID;
    USHORT  PID;
    ULONG   joy_hws_dwFlags;
    ULONG   Timeout;
    ULONG   Reserved;

} OEMDATA, *POEMDATA;


typedef struct _HIDGAME_OEM_DATA
{
    union
    {
        OEMDATA OemData[2];
        GAMEENUM_OEM_DATA   Game_Oem_Data;
    };
} HIDGAME_OEM_DATA, *PHIDGAME_OEM_DATA;




/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @struct ANALOG_DEVICE |
 *
 *          Analog Device specific data.
 *
 *  @field  USHORT | nAxes |
 *
 *          Number of axis this device has.
 *
 *  @field  USHORT | nButtons|
 *
 *          Number of buttons this device has.
 *
 *  @field  HIDGAME_OEM_DATA | HidGameOemData |
 *
 *          The OEM Data field ( Contains joy_hws_dwFlags, vid & pid )
 *
 *  @field  ULONG | ScaledTimeout |
 *          The number value at which an axis is considered to be not present.
 *
 *  @field  ULONG | ScaledThreshold |
 *
 *          The minimum resolution of a polling cycle.
 *          This is used to detect if we've been
 *          pre-empted or interrupted during a polling loop.
 *
 *  @field  ULONG | LastGoodAxis[MAX_AXES] | 
 *
 *          Value of the axes on last good poll.
 *
 *  @field  UCHAR | LastGoodButton[PORT_BUTTONS] | 
 *
 *          Value of the buttons on last good poll.
 *
 *  @field  int | AxisMap[MAX_AXES] |
 *
 *          Index of axes remapping.
 *
 *  @field  int | povMap |
 *
 *          Index of axis where POV is mapped.
 *
 *  @field  UCHAR | resistiveInputMask |
 *
 *          Resisitive Input mask.
 *
 *  @field  UCHAR | bSiblingState |
 *
 *          Indicates the state of an expose sibling\remove self transition
 *
 *  @field  BOOLEAN | fSiblingFound |
 *
 *          Set to true if this device has a sibling.
 *
 *****************************************************************************/

typedef struct _ANALOG_DEVICE
{
    /*
     *  Number of axis
     */
    USHORT                      nAxes;

    /*
     *  Number of buttons
     */
    USHORT                      nButtons;

    /*
     *  Oem Data Field
     */
    HIDGAME_OEM_DATA            HidGameOemData;

    /*  
     *  The value at which an axis in considered not present. 
     */
    ULONG                       ScaledTimeout;

    /*
     *  The minimum resolution of a polling cycle.
     *  This is used to detect if we've been pre-empted or interrupted 
     *  during a polling loop.
     */
    ULONG                       ScaledThreshold;

    /*
     *  Last known good values.  Returned if an axis result is corrupted 
     */
    ULONG                       LastGoodAxis[4];
    UCHAR                       LastGoodButton[4];

    /*
     *  Indexes used to map the data returned from a poll to the axes values 
     *  declared by the device.
     */
    int                         AxisMap[MAX_AXES];

    /*  
     *  Index of polled POV axis in the poll results
     */
    int                         povMap;

    /*
     *  Cutoff poll value between on and off for axes treated as buttons
     */
    ULONG                       button5limit;
    ULONG                       button6limit;
    
    /* 
     *  Resisitive Input mask
     */
    UCHAR                       resistiveInputMask;

    /*
     *  Set to true if the device has siblings
     */
    BOOLEAN                     fSiblingFound;

} ANALOG_DEVICE, *PANALOG_DEVICE;


#endif /* __ANALOG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\hidgame\debug.h ===
/*++

Copyright (c) 1998 - 1999  Microsoft Corporation

Module Name:

    debug.h

Abstract:  Contains definitions and macros to aid debugging
           data types for the joystick driver.


Environment:

    Kernel mode

@@BEGIN_DDKSPLIT
Author:

    MarcAnd     15-Oct-98   Pulled out of hidgame.h

Revision History:

@@END_DDKSPLIT

--*/
/*
 *  Debugging macros
 */
    #undef  C_ASSERT
    #define C_ASSERT(e) switch(0) case(e): case(0):

    #define FILE_HIDGAME                0x00010000
    #define FILE_PNP                    0x00020000
    #define FILE_POLL                   0x00040000
    #define FILE_IOCTL                  0x00080000
    #define FILE_HIDJOY                 0x00100000
    #define FILE_TIMING                 0x00200000

    #define HGM_ERROR                 0x00000001
    #define HGM_WARN                  0x00000002
    #define HGM_BABBLE                0x00000004
    #define HGM_BABBLE2               0x00000008
    #define HGM_FENTRY                0x00000010
    #define HGM_FEXIT                 0x00000020
    #define HGM_GEN_REPORT            0x00008000
/*
 *  Squak if the return status is not SUCCEESS
 */
    #define HGM_FEXIT_STATUSOK        0x00001000

    #define HGM_DEFAULT_DEBUGLEVEL    0x0000001

/* @@BEGIN_DDKSPLIT */
/* Use set USER_C_FLAGS=/DDEBUGLEVEL=0x0000803f for full internal debug */
#ifdef DEBUGLEVEL
    #undef  HGM_DEFAULT_DEBUGLEVEL
    #define HGM_DEFAULT_DEBUGLEVEL    DEBUGLEVEL
#endif
/* @@END_DDKSPLIT */

    /* WDM.H defines DBG.  Make sure DBG is both defined and non-zero  */
    #ifdef DBG
        #if DBG
            #define TRAP()  DbgBreakPoint()
        #endif
    #endif

    #ifdef TRAP
        extern ULONG debugLevel;
        #define HGM_DBGPRINT( _debugMask_,  _x_) \
            if( (((_debugMask_) & debugLevel)) ){ \
                DbgPrint("HIDGAME.SYS: ");\
                DbgPrint _x_  ; \
                DbgPrint("\n"); \
            }
        #define HGM_EXITPROC(_debugMask_, _x_, ntStatus) \
            if( ((_debugMask_)&HGM_FEXIT_STATUSOK) && !NT_SUCCESS(ntStatus) ) {\
                HGM_DBGPRINT( (_debugMask_|HGM_ERROR), (_x_ "  ntStatus(0x%x)", ntStatus) ); }\
            else { HGM_DBGPRINT((_debugMask_), (_x_ " ntStatus(0x%x)", ntStatus));}

    #else

        #define HGM_DBGPRINT(_x_,_y_)
        #define HGM_EXITPROC(_x_,_y_,_z_)
        #define TRAP()
    #endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\hidgame\poll.c ===
/*---
Copyright (c) 1998 - 1999  Microsoft Corporation

Module Name:

    poll.c

Abstract: This module contains the routines to poll an analog gameport device

Environment:

    Kernel mode

@@BEGIN_DDKSPLIT
Author:

    Eliyas Yakub (Mar, 11, 1997)

Revision History:

    Updated by Eliyas on Feb 5 1998
    MarcAnd     02-Jul-98   Quick tidy for DDK
    MarcAnd     04-Oct-98   Re-org

@@END_DDKSPLIT

--*/

#include "hidgame.h"


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HidAnalogPoll |
 *
 *          Polling routine for analog joysticks. 
 *  <nl>Polls the analog device for position and button information.
 *  The position  information in analog devices is conveyed by the
 *  duration of a pulse width. Each axis occupies one bit position.
 *  The read operation is started by writing a value to the joystick
 *  io address. Immediately thereafter we begin examing the values
 *  returned and the elapsed time.
 *
 *  This sort of device has a few limitations:
 *
 *  First, button information is not latched by the device, so if a
 *  button press which occurrs in between polls it will be lost.
 *  There is really no way to prevent this short of devoting
 *  the entire cpu to polling.  In reality this does not cause a problem.
 *
 *  Second, since it is necessary to measure the duration of the axis pulse, 
 *  the most accurate results would be obtained using the smallest possible 
 *  sense loop and no interruptions of this loop.   
 *  The typical range of pulse lengths is from around 10 uSecs to 1500 uSecs 
 *  but depending on the joystick and gameport, this could extend to at least 
 *  8000 uSecs.  Keeping interrupts disabled for this length of time causes 
 *  many problems, like modems losing connections to sound break ups.
 *
 *  Third, because each iteration of the poll loop requires an port read, the 
 *  speed of the loop is largely constrained by the speed of the IO bus.  
 *  This also means that when there is contention for the IO bus, the loop 
 *  will be slowed down.  IO contention is usually caused by DMAs (or FDMAs)
 *  which result in a significant slow down.
 *
 *  Forth, because of the previous two problems, the poll loop may be slowed 
 *  down or interrupted at any time so an external time source is needed to 
 *  measure the pulse width for each axis.  The only cross-platform high 
 *  resolution timer is the read with KeQueryPerformanceCounter.  
 *  Unfortunately the implementation of this often uses a 1.18MHz 8253 timer 
 *  which requires 3 IO accesses to read, compounding the third problem and 
 *  even then, the result may need to be reread if the counters were in the 
 *  wrong state.  Current CPUs have on board counters that can be used to 
 *  provide very accurate timing and more recent HAL implementations tend to 
 *  use these to implement KeQueryPerformanceCounter so this will be a problem 
 *  on less systems as time goes on.  In the majority of cases, a poor 
 *  KeQueryPerformanceCounter implementation is made irrelevant by testing 
 *  for the availability of a CPU time stamp counter on Intel architechtures 
 *  and using it directly if it is available.
 *
 *  The algorithm implemented here is not the most obvious but works as 
 *  follows:
 *  
 *  Once started, the axes read a value of one until the completion of their 
 *  pulse.  The axes are the four lower bits in the byte read from the port.
 *  The state of the axes in each iteration of the poll loop is therefore 
 *  represented as a value between 0 and 15.  The important time for each 
 *  axis is the time at which it changes from 1 to 0.  This is done by using 
 *  the value representing the state of the axes to index an array into which 
 *  time values are stored.  For each axis, the duration of its pulse width is 
 *  the latest time stored in the array at an index with the bit for that axis 
 *  set.  However since interrupts can occur at any time, it is not possible 
 *  to simultaneously read the port value and record that time in an atomic 
 *  operation the in each iteration, the current time is stored in two arrays, 
 *  one using the index before the time was recorded and the other using the 
 *  index after the time was recorded.
 *  Once all the axes being monitored have become 0, or a timeout value is 
 *  reached, the data left in the arrays is analysed to find the best 
 *  estimate for the transition time for each axis.  If the times before and 
 *  after the transition differ by too much, it is judged that an interrupt 
 *  must have occured so the last known good axis value is returned unless 
 *  that falls outside the range in which it is known that the transition 
 *  occured.
 *          
 *  This routine cannot be pageable as HID can make reads at dispatch-level.
 *
 *  @parm   IN PDEVICE_EXTENSION | DeviceExtension | 
 *
 *          Pointer to the device extension. 
 *
 *  @parm   IN UCHAR | resisitiveInputMask |
 *      
 *          Mask that describes the axes lines that are to be polled
 * 
 *  @parm   IN BOOLEAN | fApproximate |
 *
 *          Boolean value indicating if it is OK to approximate some
 *          value of the current axis state with the last axis state
 *          if polling was not successful (we took an interrput during polling) 
 *
 *  @parm   IN OUT ULONG | Axis[MAX_AXES] |
 *          
 *          The state of the axes. On entry the last axis state is passed
 *          into this routine. If the fApproximate flag is turned on, we can
 *          make use of the last axis state to "guess" the current axis state.
 *
 *  @parm   OUT UCHAR | Button[PORT_BUTTONS]|
 *
 *          Receives the state of the buttons. 0x0 specifies the button is not
 *          pressed and 0x1 indicates an armed button state.  
 *
 *  @rvalue   STATUS_SUCCESS  | success
 *  @rvalue   STATUS_DEVICE_NOT_CONNECTED | Device Failed to Quiesce 
 *          ( not connected ) This is a failure code.
 *  @rvalue   STATUS_TIMEOUT  | Could not determine exact transition time for 
 *          one or more axis.  This is a success code.
 *
 *****************************************************************************/
/*
 *  Tell a compiler that we "a" won't use any aliasing and "t" want fast code
 */
#pragma optimize( "at", on )

/*
 *  Disable warning for variable used before set as it is hard for a compiler 
 *  to see that TimeNow is always initialized before it is used.
 */
#pragma warning( disable:4701 )

NTSTATUS  INTERNAL
    HGM_AnalogPoll
    (
    IN      PDEVICE_EXTENSION   DeviceExtension,
    IN      UCHAR               resistiveInputMask,
    IN      BOOLEAN             fApproximate,
    IN  OUT ULONG               Axis[MAX_AXES],
        OUT UCHAR               Button[PORT_BUTTONS]
    )

{
    ULONG               BeforeTimes[MAX_AXES*MAX_AXES];
    ULONG               AfterTimes[MAX_AXES*MAX_AXES];
    PUCHAR              GameContext;
    NTSTATUS            ntStatus = STATUS_SUCCESS;


    /*  
     *  To improve compiler optimization, we cast the ReadAccessor function to 
     *  return a ULONG instead of a UCHAR.  This means that the result must 
     *  always be masked before use but this would be done anyway to remove 
     *  the parts of the UCHAR we are not interested in.  
     */
typedef ULONG (*PHIDGAME_READPORT) ( PVOID  GameContext );

    PHIDGAME_READPORT   ReadPort;
    ULONG               portLast, portMask;

    
    HGM_DBGPRINT( FILE_POLL | HGM_FENTRY, \
                    ("HGM_AnalogPoll DeviceExtension=0x%x, resistiveInputMask=0x%x",\
                     DeviceExtension, resistiveInputMask ));
    

    portMask = (ULONG)(resistiveInputMask & 0xf);

    /*
     *  Initialize Times to recognizable values
     */
    RtlZeroMemory( (PVOID)BeforeTimes, sizeof( BeforeTimes ) );
    RtlZeroMemory( (PVOID)AfterTimes, sizeof( AfterTimes ) );

    /*
     *  Find where our port and data area are, and related parameters
     */
    GameContext = DeviceExtension->GameContext;
    ReadPort = (PHIDGAME_READPORT)(*DeviceExtension->ReadAccessor);

    /*
     *  get the buttons (not forgetting that the top 3 bytes are garbage)
     */
    portLast = ReadPort(GameContext);
    Button[0] = (UCHAR)(( portLast & 0x10 ) == 0x0);
    Button[1] = (UCHAR)(( portLast & 0x20 ) == 0x0);
    Button[2] = (UCHAR)(( portLast & 0x40 ) == 0x0);
    Button[3] = (UCHAR)(( portLast & 0x80 ) == 0x0);

    portLast = portMask;

    /*
     *  Start the pots 
     *  (any debug output from here until the completion of the 
     *  while( portLast ) loop will destroy the axis data)
     */
    (*DeviceExtension->WriteAccessor)(GameContext, JOY_START_TIMERS);

    /*
     *  Keep reading until all the pots we care about are zero or we time out
     */

    {
        ULONG   TimeNow;
        ULONG   TimeStart;
        ULONG   TimeOut = DeviceExtension->ScaledTimeout/Global.CounterScale;
        ULONG   portVal = portMask;
        
        TimeStart = Global.ReadCounter(NULL).LowPart;
        
        while( portLast )
        {
            TimeNow = Global.ReadCounter(NULL).LowPart - TimeStart;
            AfterTimes[portLast] = TimeNow;
            portLast = portVal;
            portVal  = ReadPort(GameContext) & portMask;
            BeforeTimes[portVal] = TimeNow;

            if( TimeNow >= TimeOut ) break;
        } 

        if( portLast && ( TimeNow >= TimeOut ) )
        {
            HGM_DBGPRINT( FILE_POLL |  HGM_BABBLE, \
                ("HGM_AnalogPoll: TimeNow: 0x%08x TimeOut: 0x%08x", TimeNow, TimeOut ) );
        }
    }

    {
        LONG    axisIdx;

        for( axisIdx = 3; axisIdx>=0; axisIdx-- )
        {
            ULONG   axisMask;

            axisMask = 1 << axisIdx;
            if( axisMask & portMask )
            {
                if( axisMask & portLast )
                {
                    /*
                     *  Whether or not a hit was taken, this axis did not 
                     *  quiesce.  So update the axis time so that next poll 
                     *  the last value will be a timeout in case a hit is 
                     *  taken over both the transition and the timeout.  
                     */
                    Axis[axisIdx] = AXIS_TIMEOUT;
                    ntStatus = STATUS_DEVICE_NOT_CONNECTED;

                    HGM_DBGPRINT( FILE_POLL |  HGM_WARN, \
                                    ("HGM_AnalogPoll: axis %x still set at timeout", axisMask ) );
                }
                else
                {
                    ULONG       timeIdx;
                    ULONG       beforeThresholdTime;
                    ULONG       afterThresholdTime;
                    ULONG       delta;

                    afterThresholdTime = beforeThresholdTime = 0;
                    for( timeIdx = axisMask; timeIdx<= portMask; timeIdx=(timeIdx+1) | axisMask )
                    {
                        if( BeforeTimes[timeIdx] > beforeThresholdTime )
                        {
                            beforeThresholdTime = BeforeTimes[timeIdx];
                            afterThresholdTime  = AfterTimes[timeIdx];
                        }
                    }


                    /*
                     *  Convert the CPU specific timing values into 'wall clock' 
                     *  values so that they can be compared with the previous 
                     *  poll values and so that the range will be dependent on 
                     *  the gamecard/joystick characteristics, not the CPU 
                     *  and counter implementation.
                     *  Use a ULONGLONG temp to avoid overflow.
                     */
                    {
                        ULONGLONG   u64Temp;

                        u64Temp = beforeThresholdTime * Global.CounterScale;
                        beforeThresholdTime = (ULONG)(u64Temp >> SCALE_SHIFT);
                        u64Temp = afterThresholdTime * Global.CounterScale;
                        afterThresholdTime = (ULONG)(u64Temp >> SCALE_SHIFT);
                    }

                    delta = afterThresholdTime - beforeThresholdTime;
                    if( delta > DeviceExtension->ScaledThreshold )
                    {
                        /*
                         *  We took an unacceptable hit so only change the value
                         *  if we know the last value is no longer correct
                         *  Since the real time is somewhere between the before and
                         *  after, take the value closer to the last value.
                         */
                        if( fApproximate )
                        {
                            /* 
                             *  Be careful not to turn a failure into a success 
                             */
                            if( NT_SUCCESS(ntStatus) )
                            {
                                ntStatus = STATUS_TIMEOUT;
                            }
                        } 
                        else
                        {
                            ntStatus = STATUS_DEVICE_NOT_CONNECTED;
                        }
                
                        if( Axis[axisIdx] >= AXIS_FULL_SCALE )
                        {
                            /*
                             *  The previous poll was a timeout
                             */
                            if( afterThresholdTime < AXIS_FULL_SCALE )
                            {
                                /*
                                 *  This poll is not a timeout so split the 
                                 *  difference since there is nothing else
                                 *  to use for an estimate.
                                 *  Since these values are scaled, it would 
                                 *  be perfectly legitimate for their sum to 
                                 *  be greater than 32 bits.
                                 */
                                Axis[axisIdx] = (beforeThresholdTime>>1)
                                              + (afterThresholdTime>>1);
                                HGM_DBGPRINT( FILE_POLL |  HGM_BABBLE2, \
                                                ("HGM_AnalogPoll:Axis=%d, using glitch average           %04x",\
                                                 axisIdx, Axis[axisIdx] ) ) ;
                            }
                            else
                            {
                                /*
                                 *  Since the previous poll was a timeout and 
                                 *  there is no evidence that this is not, call 
                                 *  this a timeout.
                                 */
                                ntStatus = STATUS_DEVICE_NOT_CONNECTED;

                                HGM_DBGPRINT( FILE_POLL |  HGM_BABBLE2, \
                                                ("HGM_AnalogPoll:Axis=%d, repeating timeout on glitch",\
                                                 axisIdx ) ) ;
                            }
                        }
                        else if( beforeThresholdTime > Axis[axisIdx] )
                        {
                            Axis[axisIdx] = beforeThresholdTime;

                            HGM_DBGPRINT( FILE_POLL |  HGM_BABBLE2, \
                                            ("HGM_AnalogPoll:Axis=%d, using smaller glitch limit     %04x",\
                                             axisIdx, Axis[axisIdx] ) ) ;
                        } 
                        else if( afterThresholdTime < Axis[axisIdx] )
                        {
                            Axis[axisIdx] = afterThresholdTime;

                            HGM_DBGPRINT( FILE_POLL |  HGM_BABBLE2, \
                                            ("HGM_AnalogPoll:Axis=%d, using larger glitch limit      %04x",\
                                             axisIdx, Axis[axisIdx] ) ) ;
                        }
                        else 
                        {
                            HGM_DBGPRINT( FILE_POLL |  HGM_BABBLE2, \
                                            ("HGM_AnalogPoll:Axis=%d, repeating previous on glitch   %04x",\
                                             axisIdx, Axis[axisIdx] ) ) ;
                        }
                    } 
                    else
                    {
                        if( (delta <<= 1) < DeviceExtension->ScaledThreshold )
                        {
                            HGM_DBGPRINT( FILE_POLL |  HGM_BABBLE2, \
                                            ("HGM_AnalogPoll:  Updating ScaledThreshold from %d to %d",\
                                             DeviceExtension->ScaledThreshold, delta ) ) ;

                            /* 
                             *  Fastest change yet, update 
                             */
                            DeviceExtension->ScaledThreshold = delta;
                        }

                        /*
                         *  It is possible that afterThresholdTime is greater 
                         *  than the timeout limit but since the purpose of 
                         *  the timeout is to prevent excessive sampling of 
                         *  the gameport, the success or failure of an 
                         *  uninterrupted poll around this limit is not 
                         *  important. 
                         *  Since these values are scaled, it would be 
                         *  perfectly legitimate for their sum to be greater 
                         *  than 32 bits and the 1 bit of lost resolution is
                         *  utterly negligable.
                         */
                        Axis[axisIdx] = (beforeThresholdTime>>1)
                                      + (afterThresholdTime>>1);
                    }
                }
            }
        }
    }

    HGM_DBGPRINT( FILE_POLL |  HGM_BABBLE2, \
                    ("HGM_AnalogPoll:X=%d, Y=%d, R=%d, Z=%d Buttons=%d,%d,%d,%d",\
                     Axis[0], Axis[1], Axis[2], Axis[3],\
                     Button[0],Button[1],Button[2],Button[3] ) ) ;

    HGM_EXITPROC(FILE_POLL|HGM_FEXIT, "HGM_AnalogPoll", ntStatus);

    return ntStatus;
} /* HGM_AnalogPoll */
#pragma warning( default:4701 )
#pragma optimize( "", on )




/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS | HGM_UpdateLatestPollData |
 *
 *          Do whatever polling is required and possible to update the 
 *          LastGoodAxis and LastGoodButton arrays in the DeviceExtension.  
 *          Handles synchronization and non-fatal errors.
 *          <nl>This routine cannot be pageable as HID can make reads at 
 *          dispatch-level.
 *
 *  @parm   IN  OUT PDEVICE_EXTENSION | DeviceExtension |
 *
 *          Pointer to the device extension containing the data to be updated 
 *          and the functions and to use.
 *
 *  @rvalue   STATUS_SUCCESS  | success
 *  @rvalue   STATUS_DEVICE_CONFIGURATION_ERROR  | Invalid configuration specified
 *
 *****************************************************************************/
#define APPROXIMATE_FAILS TRUE

NTSTATUS
    HGM_UpdateLatestPollData
    ( 
    IN  OUT PDEVICE_EXTENSION   DeviceExtension
    )
{
    NTSTATUS            ntStatus;
    KIRQL               oldIrql;
    LONG                axisIdx;

    /*
     *  Acquire the global spinlock
     *  Read / Writes are made at dispatch level.
     */
    KeAcquireSpinLock(&Global.SpinLock, &oldIrql );

    /*
     *  First gain exclusive access to the hardware
     */
    ntStatus = (*DeviceExtension->AcquirePort)( DeviceExtension->PortContext );
    if( NT_SUCCESS(ntStatus) )
    {
        /*
         *  If it's available, let the hardware do the work
         */
        if( DeviceExtension->ReadAccessorDigital )
        {
            ntStatus = (*DeviceExtension->ReadAccessorDigital)(DeviceExtension->GameContext,
                                    DeviceExtension->resistiveInputMask,
                                    APPROXIMATE_FAILS,
                                    &DeviceExtension->LastGoodAxis[0],
                                    &DeviceExtension->LastGoodButton[0]);
        } 
        else
        {
            ntStatus = HGM_AnalogPoll(DeviceExtension,
                                      DeviceExtension->resistiveInputMask,
                                      APPROXIMATE_FAILS,
                                      &DeviceExtension->LastGoodAxis[0],
                                      &DeviceExtension->LastGoodButton[0]);
        }

        /*
         *  Either way, release the hardware ASAP
         */
        (*DeviceExtension->ReleasePort)( DeviceExtension->PortContext );

    }

    /*
     * Release the global spinlock and return to previous IRQL
     */
    KeReleaseSpinLock(&Global.SpinLock, oldIrql);

    if( ( ntStatus == STATUS_DEVICE_BUSY ) && APPROXIMATE_FAILS )
    {
        /*
         *  Clashed trying to access the gameport.  So work with the same 
         *  data as last time unless all failures must be reported or the 
         *  last data was a failure for these axes.
         */
        for( axisIdx=3; axisIdx>=0; axisIdx-- )
        {
            if( ( ( 1 << axisIdx ) & DeviceExtension->resistiveInputMask )
              &&( DeviceExtension->LastGoodAxis[axisIdx] 
                  >= DeviceExtension->ScaledTimeout ) )
            {
                break;
            }
        }
        if( axisIdx<0 )
        {
            ntStatus = STATUS_TIMEOUT;
        }
    }


    if( !NT_SUCCESS( ntStatus ) )
    {
        HGM_DBGPRINT(FILE_IOCTL | HGM_WARN,\
                       ("HGM_UpdateLatestPollData Failed 0x%x", ntStatus));
    }

    return( ntStatus );
} /* HGM_UpdateLatestPollData */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\hidgame\ioctl.c ===
/*++

Copyright (c) 1998 - 1999  Microsoft Corporation

Module Name:

    ioctl.c

Abstract: Contains routines to support HIDCLASS internal
          ioctl queries for game devices.

Environment:

    Kernel mode

@@BEGIN_DDKSPLIT
Author:
          Eliyas Yakub (Mar, 10, 1997)

Revision History:

        Updated by Eliyas on Feb 5 1998
    MarcAnd     02-Jul-98   Quick tidy for DDK

@@END_DDKSPLIT

--*/

#include "hidgame.h"

#ifdef ALLOC_PRAGMA
    #pragma alloc_text (PAGE, HGM_GetDeviceDescriptor)
    #pragma alloc_text (PAGE, HGM_GetReportDescriptor)
    #pragma alloc_text (PAGE, HGM_GetAttributes      )
#endif



/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_InternalIoctl |
 *
 *          Process the Control IRPs sent to this device.
 *          <nl>This function cannot be pageable because reads/writes
 *          can be made at dispatch-level
 *
 *  @parm   IN PDRIVER_OBJECT | DeviceObject |
 *
 *          Pointer to the driver object
 *
 *  @parm   IN PIRP | Irp |
 *
 *          Pointer to an I/O Request Packet.
 *
 *  @rvalue   STATUS_SUCCESS | success
 *  @rvalue   STATUS_NOT_SUPPORT | Irp function not supported
 *  @rvalue   ???            | ???
 *
 *****************************************************************************/
NTSTATUS EXTERNAL
    HGM_InternalIoctl
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS            ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION   DeviceExtension;
    PIO_STACK_LOCATION  IrpStack;

    HGM_DBGPRINT(FILE_IOCTL | HGM_FENTRY,   \
                   ("HGM_InternalIoctl(DeviceObject=0x%x,Irp=0x%x)", \
                    DeviceObject, Irp));

    /*
     *  Get a pointer to the current location in the Irp
     */

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    /*
     *  Get a pointer to the device extension
     */

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION (DeviceObject);


    ntStatus = HGM_IncRequestCount( DeviceExtension );
    if (!NT_SUCCESS (ntStatus))
    {
        /*
         *  Someone sent us another plug and play IRP after removed
         */

        HGM_DBGPRINT(FILE_PNP | HGM_ERROR,\
                       ("HGM_InternalIoctl: PnP IRP after device was removed\n"));
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = ntStatus;
    } else
    {
        switch(IrpStack->Parameters.DeviceIoControl.IoControlCode)
        {
            case IOCTL_HID_GET_DEVICE_DESCRIPTOR:
                HGM_DBGPRINT(FILE_IOCTL | HGM_BABBLE, \
                               ("IOCTL_HID_GET_DEVICE_DESCRIPTOR"));
                ntStatus = HGM_GetDeviceDescriptor(DeviceObject, Irp);
                break;

            case IOCTL_HID_GET_REPORT_DESCRIPTOR:
                HGM_DBGPRINT(FILE_IOCTL | HGM_BABBLE, \
                               ("IOCTL_HID_GET_REPORT_DESCRIPTOR"));
                ntStatus = HGM_GetReportDescriptor(DeviceObject, Irp);
                break;

            case IOCTL_HID_READ_REPORT:
                HGM_DBGPRINT(FILE_IOCTL | HGM_BABBLE,\
                               ("IOCTL_HID_READ_REPORT"));
                ntStatus = HGM_ReadReport(DeviceObject, Irp);
                break;

            case IOCTL_HID_GET_DEVICE_ATTRIBUTES:
                HGM_DBGPRINT(FILE_IOCTL | HGM_BABBLE,\
                               ("IOCTL_HID_GET_DEVICE_ATTRIBUTES"));
                ntStatus = HGM_GetAttributes(DeviceObject, Irp);
                break;

            default:
                HGM_DBGPRINT(FILE_IOCTL | HGM_WARN,\
                               ("Unknown or unsupported IOCTL (%x)",
                                IrpStack->Parameters.DeviceIoControl.IoControlCode));
                ntStatus = STATUS_NOT_SUPPORTED;
                break;
        }


        /*
         * Set real return status in Irp
         */
        Irp->IoStatus.Status = ntStatus;

        HGM_DecRequestCount( DeviceExtension );
    }


    if(ntStatus != STATUS_PENDING)
    {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        /*
         * NOTE: Real return status set in Irp->IoStatus.Status
         */
        ntStatus = STATUS_SUCCESS;
    } else
    {
        /*
         * No reason why there should be a status pending
         */
        HGM_DBGPRINT(FILE_IOCTL | HGM_ERROR, \
                       ("HGM_InternalIoctl: Pending Status !"));
        IoMarkIrpPending( Irp );
    }

    HGM_EXITPROC(FILE_IOCTL | HGM_FEXIT_STATUSOK, "HGM_InternalIoctl", ntStatus);

    return ntStatus;
} /* HGM_InternalIoctl */



/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_GetDeviceDescriptor |
 *
 *          Respond to HIDCLASS IOCTL_HID_GET_DEVICE_DESCRIPTOR
 *          by returning a device descriptor
 *
 *  @parm   IN PDRIVER_OBJECT | DeviceObject |
 *
 *          Pointer to the driver object
 *
 *  @parm   IN PIRP | Irp |
 *
 *          Pointer to an I/O Request Packet.
 *
 *  @rvalue   STATUS_SUCCESS | success
 *  @rvalue   STATUS_BUFFER_TOO_SMALL |  need more memory
 *
 *****************************************************************************/
NTSTATUS INTERNAL
    HGM_GetDeviceDescriptor
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PHID_DESCRIPTOR pHidDescriptor;        /* Hid descriptor for this device */
    USHORT   cbReport;
    UCHAR               rgGameReport[MAXBYTES_GAME_REPORT] ;
    NTSTATUS            ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION   DeviceExtension;
    PIO_STACK_LOCATION  IrpStack;

    PAGED_CODE ();

    HGM_DBGPRINT(FILE_IOCTL | HGM_FENTRY,\
                   ("HGM_GetDeviceDescriptor(DeviceObject=0x%x,Irp=0x%x)",
                    DeviceObject, Irp));

    /*
     * Get a pointer to the current location in the Irp
     */

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    /*
     * Get a pointer to the device extension
     */

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION (DeviceObject);

    if( IrpStack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(*pHidDescriptor)  )
    {

        HGM_DBGPRINT(FILE_IOCTL | HGM_ERROR,\
                       ("HGM_GetDeviceDescriptor: OutBufferLength(0x%x) < sizeof(HID_DESCRIPTOR)(0x%x)", \
                        IrpStack->Parameters.DeviceIoControl.OutputBufferLength, sizeof(*pHidDescriptor)));


        ntStatus = STATUS_BUFFER_TOO_SMALL;
    } else
    {
        /*
         * Generate the report
         */
        ntStatus =  HGM_GenerateReport(DeviceObject, rgGameReport, &cbReport);

        if( NT_SUCCESS(ntStatus) )
        {
            /*
             *  Get a pointer to the HID_DESCRIPTOR
             *  HIDCLASS is trusted to pass a valid pointer.
             */
            pHidDescriptor =  (PHID_DESCRIPTOR) Irp->UserBuffer;

            RtlZeroMemory( pHidDescriptor, sizeof(*pHidDescriptor) );
            /*
             * Copy device descriptor to HIDCLASS buffer
             */
            pHidDescriptor->bLength                         = sizeof(*pHidDescriptor);
            pHidDescriptor->bDescriptorType                 = HID_HID_DESCRIPTOR_TYPE;
            pHidDescriptor->bcdHID                          = HID_REVISION;
            pHidDescriptor->bCountry                        = 0; /*not localized*/
            pHidDescriptor->bNumDescriptors                 = HGM_NUMBER_DESCRIPTORS;
            pHidDescriptor->DescriptorList[0].bReportType   = HID_REPORT_DESCRIPTOR_TYPE ;
            pHidDescriptor->DescriptorList[0].wReportLength = cbReport;

            /*
             * Report how many bytes were copied
             */
            Irp->IoStatus.Information = sizeof(*pHidDescriptor);
        } else
        {
            Irp->IoStatus.Information = 0x0;
        }
    }

    HGM_EXITPROC(FILE_IOCTL |HGM_FEXIT_STATUSOK, "HGM_GetDeviceDescriptor", ntStatus);

    return ntStatus;
} /* HGM_GetDeviceDescriptor */


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_GetReportDescriptor |
 *
 *          Respond to HIDCLASS IOCTL_HID_GET_REPORT_DESCRIPTOR
 *          by returning appropriate the report descriptor
 *
 *  @parm   IN PDRIVER_OBJECT | DeviceObject |
 *
 *          Pointer to the driver object
 *
 *  @parm   IN PIRP | Irp |
 *
 *          Pointer to an I/O Request Packet.
 *
 *  @rvalue   STATUS_SUCCESS | success
 *  @rvalue   ???            | ???
 *
 *****************************************************************************/
NTSTATUS INTERNAL
    HGM_GetReportDescriptor
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION     DeviceExtension;
    PIO_STACK_LOCATION    IrpStack;
    NTSTATUS              ntStatus;
    UCHAR                 rgGameReport[MAXBYTES_GAME_REPORT] ;
    USHORT                cbReport;

    PAGED_CODE ();

    HGM_DBGPRINT(FILE_IOCTL | HGM_FENTRY,\
                   ("HGM_GetReportDescriptor(DeviceObject=0x%x,Irp=0x%x)",\
                    DeviceObject, Irp));

    /*
     * Get a pointer to the current location in the Irp
     */

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    /*
     * Get a pointer to the device extension
     */

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION (DeviceObject);


    /*
     * Generate the report
     */
    ntStatus =  HGM_GenerateReport(DeviceObject, rgGameReport, &cbReport);

    if( NT_SUCCESS(ntStatus) )
    {
        if( cbReport >  (USHORT) IrpStack->Parameters.DeviceIoControl.OutputBufferLength )
        {
            ntStatus = STATUS_BUFFER_TOO_SMALL;

            HGM_DBGPRINT(FILE_IOCTL | HGM_ERROR,\
                           ("HGM_GetReportDescriptor: cbReport(0x%x) OutputBufferLength(0x%x)",\
                            cbReport, IrpStack->Parameters.DeviceIoControl.OutputBufferLength));

        } else
        {
            RtlCopyMemory( Irp->UserBuffer, rgGameReport, cbReport );
            /*
             * Report how many bytes were copied
             */
            Irp->IoStatus.Information = cbReport;
            ntStatus = STATUS_SUCCESS;
        }
    }

    HGM_EXITPROC(FILE_IOCTL |HGM_FEXIT_STATUSOK, "HGM_GetReportDescriptor", ntStatus);

    return ntStatus;
} /* HGM_GetReportDescriptor */



/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_ReadReport |
 *
 *          Poll the gameport, remap the axis and button data and package
 *          into the defined HID report field.
 *          <nl>This routine cannot be pageable as HID can make reads at 
 *          dispatch-level.
 *
 *  @parm   IN PDRIVER_OBJECT | DeviceObject |
 *
 *          Pointer to the driver object
 *
 *  @parm   IN PIRP | Irp |
 *
 *          Pointer to an I/O Request Packet.
 *
 *  @rvalue   STATUS_SUCCESS  | success
 *  @rvalue   STATUS_DEVICE_NOT_CONNECTED | Device Failed to Quiesce 
 *                                          ( not connected )
 *  @rvalue   STATUS_TIMEOUT  | Could not determine exact transition time for 
 *                              one or more axis but not a failure.
 *
 *****************************************************************************/
NTSTATUS  INTERNAL
    HGM_ReadReport
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS            ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION   DeviceExtension;
    PIO_STACK_LOCATION  IrpStack;

    HGM_DBGPRINT(FILE_IOCTL | HGM_FENTRY,\
                   ("HGM_ReadReport(DeviceObject=0x%x,Irp=0x%x)", \
                    DeviceObject, Irp));

    /*
     * Get a pointer to the device extension.
     */

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION (DeviceObject);

    /*
     * Get Stack location.
     */

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    /*
     * First check the size of the output buffer (there is no input buffer)
     */

    if( IrpStack->Parameters.DeviceIoControl.OutputBufferLength <  sizeof(HIDGAME_INPUT_DATA) )
    {
        HGM_DBGPRINT(FILE_IOCTL | HGM_WARN,\
                       ("HGM_ReadReport: Buffer too small, output=0x%x need=0x%x", \
                        IrpStack->Parameters.DeviceIoControl.OutputBufferLength, 
                        sizeof(HIDGAME_INPUT_DATA) ) );

        ntStatus = STATUS_BUFFER_TOO_SMALL;
    }

    if( DeviceExtension->fStarted == FALSE )
    {
        ntStatus = STATUS_DEVICE_NOT_READY ;
    }


    /*
     *  All the checking done so do device specific polling
     */
    if( NT_SUCCESS(ntStatus) )
    {
        ntStatus = HGM_UpdateLatestPollData( DeviceExtension );
    }

    /*
     *  If all's well, translate device specific data to HID report
     */
    if( NT_SUCCESS(ntStatus) )
    {
#ifdef CHANGE_DEVICE
        HGM_Game2HID( DeviceObject, DeviceExtension, (PHIDGAME_INPUT_DATA)Irp->UserBuffer );
#else
        HGM_Game2HID( DeviceExtension, (PHIDGAME_INPUT_DATA)Irp->UserBuffer );
#endif

        Irp->IoStatus.Information = sizeof(HIDGAME_INPUT_DATA);
    } 
    else
    {
        Irp->IoStatus.Information = 0x0;
    }

    Irp->IoStatus.Status = ntStatus;


    HGM_EXITPROC(FILE_IOCTL|HGM_FEXIT,  "HGM_ReadReport", ntStatus);

    return ntStatus;
} /* HGM_ReadReport */



/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_GetAttributes |
 *
 *          Respond to IOCTL_HID_GET_ATTRIBUTES, by filling
 *          the HID_DEVICE_ATTRIBUTES struct
 *
 *  @parm   IN PDRIVER_OBJECT | DeviceObject |
 *
 *          Pointer to the driver object
 *
 *  @parm   IN PIRP | Irp |
 *
 *          Pointer to an I/O Request Packet.
 *
 *  @rvalue   STATUS_SUCCESS | success
 *  @rvalue   ???            | ???
 *
 *****************************************************************************/
NTSTATUS INTERNAL
    HGM_GetAttributes
    (
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION  IrpStack;

    PAGED_CODE();

    HGM_DBGPRINT(FILE_IOCTL | HGM_FENTRY,\
                   ("HGM_GetAttributes(DeviceObject=0x%x,Irp=0x%x)",\
                    DeviceObject, Irp));

    /*
     * Get a pointer to the current location in the Irp
     */

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    if( IrpStack->Parameters.DeviceIoControl.OutputBufferLength < sizeof (HID_DEVICE_ATTRIBUTES)   )
    {
        ntStatus = STATUS_BUFFER_TOO_SMALL;

        HGM_DBGPRINT(FILE_IOCTL | HGM_ERROR,\
                       ("HGM_GetAttributes: cbReport(0x%x) OutputBufferLength(0x%x)",\
                        sizeof (HID_DEVICE_ATTRIBUTES), IrpStack->Parameters.DeviceIoControl.OutputBufferLength));
    } else
    {
        PDEVICE_EXTENSION       DeviceExtension;
        PHID_DEVICE_ATTRIBUTES  DeviceAttributes;
        POEMDATA    OemData;

        /*
         * Get a pointer to the device extension
         */
        DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);
        DeviceAttributes = (PHID_DEVICE_ATTRIBUTES) Irp->UserBuffer;


        OemData = &DeviceExtension->HidGameOemData.OemData[0];
        if( DeviceExtension->fSiblingFound)
        {
            OemData = &DeviceExtension->HidGameOemData.OemData[1];
        }

        RtlZeroMemory( DeviceAttributes, sizeof(*DeviceAttributes));

        /*
         * Report how many bytes were copied
         */

        Irp->IoStatus.Information   = sizeof(*DeviceAttributes);

        DeviceAttributes->Size          = sizeof (*DeviceAttributes);
        DeviceAttributes->VendorID      = OemData->VID;
        DeviceAttributes->ProductID     = OemData->PID;
        DeviceAttributes->VersionNumber = HIDGAME_VERSION_NUMBER;

    }

    HGM_EXITPROC(FILE_IOCTL|HGM_FEXIT_STATUSOK, "HGM_GetAttributes", ntStatus);

    return ntStatus;
} /* HGM_GetAttributes */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\actions.cpp ===
#define __DEBUG_MODULE_IN_USE__ CIC_ACTIONS_CPP
#include "stdhdrs.h"
#include "actions.h"

//	@doc
/**********************************************************************
*
*	@module	Actions.cpp	|
*
*	Implementation of accessor functions for action objects.
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	Actions	|
*	Contains the implementation of the accessor functions for the
*	EVENT, TIMED_EVENT, TIMED_MACRO, and related structures.
*
**********************************************************************/

/***********************************************************************************
**
**	@mfunc	Get an event in a TIMED_MACRO structure, given an index
**
**	@rdesc	Pointer to next event in TIMED_MACRO
**	@rdesc	NULL if index too big.
**
*************************************************************************************/
PTIMED_EVENT 
TIMED_MACRO::GetEvent
(
	ULONG uEventNum	//@parm [in] One based index of event to get.
)
{
	ASSERT( 0 != uEventNum && "GetEvent uses 1 based index of events!");
	//
	// Implement in terms of GetNextEvent
	//	
	PTIMED_EVENT pResult = NULL;
	ULONG uEventIndex=0;
	do
	{
		pResult = GetNextEvent(pResult, uEventIndex);
	}while(pResult && uEventIndex!=uEventNum);
	return pResult;
}

/***********************************************************************************
**
**	@mfunc	Get next TIMED_EVENT in a TIMED_MACRO structure.
**
**	@rdesc	Pointer to next TIMED_EVENT in TIMED_MACRO
**
*************************************************************************************/
PTIMED_EVENT
TIMED_MACRO::GetNextEvent
(
	PTIMED_EVENT pCurrentEvent,	// @parm [in] Pointer to current event.
	ULONG& rulCurrentEvent	// @parm [in\out] Current event before and after call.
)
{
	//
	//	Range check, is there even a next event.
	//
	if( ++rulCurrentEvent > ulEventCount )
	{
		return NULL;
	}

	//
	// Check if this is the first
	//
	if(rulCurrentEvent == 1)
	{
		return rgEvents;
	}

	//
	//	Otherwise skip to next
	//
	PCHAR pcBytePointer = reinterpret_cast<PCHAR>(pCurrentEvent);
	pcBytePointer += TIMED_EVENT::RequiredByteSize(pCurrentEvent->Event.ulNumXfers);
	
	//
	//	Sanity check on debug to make sure we haven't stepped over the edge.
	//
	ASSERT(pcBytePointer <= (reinterpret_cast<PCHAR>(this)+this->AssignmentBlock.CommandHeader.ulByteSize));
	
	//
	// Cast back to proper type
	//
	return reinterpret_cast<PTIMED_EVENT>(pcBytePointer);
}

/***********************************************************************************
**
**	@mfunc	Creates a TIMED_MACRO in an empty buffer.
**
**	@rdesc	Pointer to TIMED_MACRO (start of buffer), or NULL if buffer is too small
**
*************************************************************************************/
PTIMED_MACRO TIMED_MACRO::Init
(
	ULONG	ulVidPid,				// @parm [in] Vid/Pid for macro
	ULONG	ulFlagsParm,			// @parm [in] Flags for macro.
	PCHAR	pcBuffer,				// @parm [in] Pointer to raw buffer
	ULONG&	rulRemainingBuffer		// @parm [in\out] Size of buffer on entry, remaining buffer on exit
)
{
	//
	//	Make sure buffer is large enough
	//
	if( rulRemainingBuffer < sizeof(TIMED_MACRO))
	{
		return NULL;
	}

	
	PTIMED_MACRO pThis = reinterpret_cast<PTIMED_MACRO>(pcBuffer);
	
	//
	//	Copy flags
	//
	pThis->ulFlags = ulFlagsParm;

	//
	//	Calculate remaining buffer
	//
	rulRemainingBuffer -= (sizeof(TIMED_MACRO) - sizeof(TIMED_EVENT));

	//
	//	Fill out AssignmentBlock
	//
	pThis->AssignmentBlock.CommandHeader.eID = eTimedMacro;
	pThis->AssignmentBlock.CommandHeader.ulByteSize = (sizeof(TIMED_MACRO) - sizeof(TIMED_EVENT));
	pThis->AssignmentBlock.ulVidPid = ulVidPid;

	// Set no events as of yet
	pThis->ulEventCount=0;

	return pThis;
}

/***********************************************************************************
**
**	HRESULT AddEvent(PTIMED_EVENT pTimedEvent, PTIMED_MACRO pTimedMacro, ULONG& rulRemainingBuffer)
**
**	@mfunc	Adds an event to a TIMED_MACRO and recalulates remaining buffer.
**
**	@rdesc	S_OK on Success, E_OUTOFMEMORY if buffer is too small
**
*************************************************************************************/
HRESULT TIMED_MACRO::AddEvent
(
	PTIMED_EVENT pTimedEvent,	// @parm [in] Pointer to TIMED_EVENT to add
	ULONG& rulRemainingBuffer	// @parm [in\out] Remaining buffer before and after call.
)
{
	//
	//	Make sure buffer is large enough
	//
	ULONG ulEventLength = TIMED_EVENT::RequiredByteSize(pTimedEvent->Event.ulNumXfers);
	if( ulEventLength > rulRemainingBuffer)
	{
		return E_OUTOFMEMORY;
	}

	//
	//	Skip to end of TIMED_MACRO as is.
	//
	PCHAR pcBuffer = reinterpret_cast<PCHAR>(this) + AssignmentBlock.CommandHeader.ulByteSize;

	//
	//	Copy event
	//
	DualMode::BufferCopy
	( 
		reinterpret_cast<PVOID>(pcBuffer),
		reinterpret_cast<PVOID>(pTimedEvent),
		ulEventLength
	);

	//
	//	Fix up size in COMMAND_HEADER
	//
	AssignmentBlock.CommandHeader.ulByteSize += ulEventLength;
	
	//
	//	Increment number of Events
	//
	ulEventCount++;

	//
	//	Recalculate remaining buffer
	//
	rulRemainingBuffer -= ulEventLength;

	return S_OK;
}

/************************* MULTI_MACRO Functions **************************/

/***********************************************************************************
**
**	@mfunc	Get an event in a MULTI_MACRO structure, given an index
**
**	@rdesc	Pointer to next event in MULTI_MACRO
**	@rdesc	NULL if index too big.
**
*************************************************************************************/
EVENT* 
MULTI_MACRO::GetEvent
(
	ULONG uEventNum	//@parm [in] One based index of event to get.
)
{
	ASSERT( 0 != uEventNum && "GetEvent uses 1 based index of events!");
	//
	// Implement in terms of GetNextEvent
	//	
	EVENT* pResult = NULL;
	ULONG uEventIndex=0;
	do
	{
		pResult = GetNextEvent(pResult, uEventIndex);
	}while(pResult && uEventIndex!=uEventNum);
	return pResult;
}

/***********************************************************************************
**
**	@mfunc	Get next EVENT in a MULTI_MACRO structure.
**
**	@rdesc	Pointer to next EVENT in MULTI_MACRO
**
*************************************************************************************/
EVENT*
MULTI_MACRO::GetNextEvent
(
	EVENT* pCurrentEvent,	// @parm [in] Pointer to current event.
	ULONG& rulCurrentEvent	// @parm [in\out] Current event before and after call.
)
{
	//
	//	Range check, is there even a next event.
	//
	if( ++rulCurrentEvent > ulEventCount )
	{
		return NULL;
	}

	//
	// Check if this is the first
	//
	if(rulCurrentEvent == 1)
	{
		return rgEvents;
	}

	//
	//	Otherwise skip to next
	//
	PCHAR pcBytePointer = reinterpret_cast<PCHAR>(pCurrentEvent);
	pcBytePointer += EVENT::RequiredByteSize(pCurrentEvent->ulNumXfers);
	
	//
	//	Sanity check on debug to make sure we haven't stepped over the edge.
	//
	ASSERT(pcBytePointer <= (reinterpret_cast<PCHAR>(this)+this->AssignmentBlock.CommandHeader.ulByteSize));
	
	//
	// Cast back to proper type
	//
	return reinterpret_cast<EVENT*>(pcBytePointer);
}

/***********************************************************************************
**
**	@mfunc	Creates a MULTI_MACRO in an empty buffer.
**
**	@rdesc	Pointer to MULTI_MACRO (start of buffer), or NULL if buffer is too small
**
*************************************************************************************/
MULTI_MACRO* MULTI_MACRO::Init
(
	ULONG	ulVidPid,				// @parm [in] Vid/Pid for macro
	ULONG	ulFlagsParm,			// @parm [in] Flags for macro.
	PCHAR	pcBuffer,				// @parm [in] Pointer to raw buffer
	ULONG&	rulRemainingBuffer		// @parm [in\out] Size of buffer on entry, remaining buffer on exit
)
{
	//
	//	Make sure buffer is large enough
	//
	if( rulRemainingBuffer < sizeof(MULTI_MACRO))
	{
		return NULL;
	}

	
	MULTI_MACRO* pThis = reinterpret_cast<MULTI_MACRO*>(pcBuffer);
	
	//
	//	Copy flags
	//
	pThis->ulFlags = ulFlagsParm;

	//
	//	Calculate remaining buffer
	//
	rulRemainingBuffer -= (sizeof(MULTI_MACRO) - sizeof(EVENT));

	//
	//	Fill out AssignmentBlock
	//
	pThis->AssignmentBlock.CommandHeader.eID = eTimedMacro;
	pThis->AssignmentBlock.CommandHeader.ulByteSize = (sizeof(MULTI_MACRO) - sizeof(EVENT));
	pThis->AssignmentBlock.ulVidPid = ulVidPid;

	// Set no events as of yet
	pThis->ulEventCount=0;

	return pThis;
}

/***********************************************************************************
**
**	HRESULT AddEvent(EVENT* pTimedEvent, MULTI_MACRO* pTimedMacro, ULONG& rulRemainingBuffer)
**
**	@mfunc	Adds an event to a MULTI_MACRO and recalulates remaining buffer.
**
**	@rdesc	S_OK on Success, E_OUTOFMEMORY if buffer is too small
**
*************************************************************************************/
HRESULT MULTI_MACRO::AddEvent
(
	EVENT* pEvent,				// @parm [in] Pointer to EVENT to add
	ULONG& rulRemainingBuffer	// @parm [in\out] Remaining buffer before and after call.
)
{
	//
	//	Make sure buffer is large enough
	//
	ULONG ulEventLength = EVENT::RequiredByteSize(pEvent->ulNumXfers);
	if( ulEventLength > rulRemainingBuffer)
	{
		return E_OUTOFMEMORY;
	}

	//
	//	Skip to end of TIMED_MACRO as is.
	//
	PCHAR pcBuffer = reinterpret_cast<PCHAR>(this) + AssignmentBlock.CommandHeader.ulByteSize;

	//
	//	Copy event
	//
	DualMode::BufferCopy
	( 
		reinterpret_cast<PVOID>(pcBuffer),
		reinterpret_cast<PVOID>(pEvent),
		ulEventLength
	);

	//
	//	Fix up size in COMMAND_HEADER
	//
	AssignmentBlock.CommandHeader.ulByteSize += ulEventLength;
	
	//
	//	Increment number of Events
	//
	ulEventCount++;

	//
	//	Recalculate remaining buffer
	//
	rulRemainingBuffer -= ulEventLength;

	return S_OK;
}


/************************* MAP_LIST Functions (also CYCLE_MAP, KEYSTRING_MAP) **************************/


/***********************************************************************************
**
**	@mfunc	Creates a MAP_LIST in an empty buffer. The assignment block will be set
**			as eKeyString be sure to change it if you have other preferences
**
**	@rdesc	Pointer to MAP_LIST (start of buffer), or NULL if buffer is too small
**
*************************************************************************************/
MAP_LIST* MAP_LIST::Init
(
	ULONG	ulVidPid,				// @parm [in] Vid/Pid for macro
	ULONG	ulFlagsParm,			// @parm [in] Flags for macro.
	PCHAR	pcBuffer,				// @parm [in] Pointer to raw buffer
	ULONG&	rulRemainingBuffer		// @parm [in\out] Size of buffer on entry, remaining buffer on exit
)
{
	//
	//	Make sure buffer is large enough
	//
	if( rulRemainingBuffer < sizeof(MAP_LIST))
	{
		return NULL;
	}

	
	MAP_LIST* pThis = reinterpret_cast<MAP_LIST*>(pcBuffer);

	//
	//	Copy flags
	//
	pThis->ulFlags = ulFlagsParm;

	//
	//	Calculate remaining buffer
	//
	rulRemainingBuffer -= (sizeof(MAP_LIST) - sizeof(EVENT));

	//
	//	Fill out AssignmentBlock
	//
	pThis->AssignmentBlock.CommandHeader.eID = eKeyString;
	pThis->AssignmentBlock.CommandHeader.ulByteSize = (sizeof(MAP_LIST) - sizeof(EVENT));
	pThis->AssignmentBlock.ulVidPid = ulVidPid;

	//Init event count to zero
	pThis->ulEventCount=0;

	return pThis;
}

/***********************************************************************************
**
**	@mfunc	Get next EVENT in a MAP_LIST structure.
**
**	@rdesc	Pointer to requested EVENT in MAP_LIST, or NULL if index too big
**
*************************************************************************************/
PEVENT MAP_LIST::GetEvent
(
	ULONG uEventNum	//@parm [in] One based index of event to get.
)
{
	ASSERT( 0 != uEventNum && "GetEvent uses 1 based index of events!");
	//
	// Implement in terms of GetNextEvent
	//	
	PEVENT pResult = NULL;
	ULONG uEventIndex=0;
	do
	{
		pResult = GetNextEvent(pResult, uEventIndex);
	}while(pResult && uEventIndex!=uEventNum);
	return pResult;
}

/***********************************************************************************
**
**	PEVENT MAP_LIST::GetNextEvent(PEVENT pCurrentEvent, ULONG& rulCurrentEvent)
**
**	@mfunc	Gets the next event in a MAP_LIST
**
**	@rdesc	Pointer to next EVENT on success, NULL if no more EVENTs
**
*************************************************************************************/
PEVENT MAP_LIST::GetNextEvent
(
	PEVENT pCurrentEvent,	// @parm Pointer to current EVENT
	ULONG& rulCurrentEvent	// @parm [in/out] Event number before and after call.
)
{
	//
	//	Range check, is there even a next event.
	//
	if( ++rulCurrentEvent > ulEventCount )
	{
		return NULL;
	}

	//
	// Check if this is the first
	//
	if(rulCurrentEvent == 1)
	{
		return rgEvents;
	}

	//
	//	Otherwise skip to next
	//
	PCHAR pcBytePointer = reinterpret_cast<PCHAR>(pCurrentEvent);
	pcBytePointer += EVENT::RequiredByteSize(pCurrentEvent->ulNumXfers);
	
	//
	//	Sanity check on debug to make sure we haven't stepped over the edge.
	//
	ASSERT(pcBytePointer <= (reinterpret_cast<PCHAR>(this)+this->AssignmentBlock.CommandHeader.ulByteSize));
	
	//
	// Cast back to proper type
	//
	return reinterpret_cast<PEVENT>(pcBytePointer);
}

/***********************************************************************************
**
**	HRESULT AddEvent(PTIMED_EVENT pTimedEvent, PTIMED_MACRO pTimedMacro, ULONG& rulRemainingBuffer)
**
**	@mfunc	Adds an event to a TIMED_MACRO and recalulates remaining buffer.
**
**	@rdesc	S_OK on Success, E_OUTOFMEMORY if buffer is too small
**
*************************************************************************************/
HRESULT MAP_LIST::AddEvent
(
	EVENT* pEvent,				// @parm [in] Pointer to EVENT to add
	ULONG& rulRemainingBuffer	// @parm [in\out] Remaining buffer before and after call.
)
{
	//
	//	Make sure buffer is large enough
	//
	ULONG ulEventLength = EVENT::RequiredByteSize(pEvent->ulNumXfers);
	if( ulEventLength > rulRemainingBuffer)
	{
		return E_OUTOFMEMORY;
	}

	//
	//	Skip to end of MAP_LIST as is.
	//
	PCHAR pcBuffer = reinterpret_cast<PCHAR>(this) + AssignmentBlock.CommandHeader.ulByteSize;

	//
	//	Copy event
	//
	DualMode::BufferCopy
	( 
		reinterpret_cast<PVOID>(pcBuffer),
		reinterpret_cast<PVOID>(pEvent),
		ulEventLength
	);

	//
	//	Fix up size in COMMAND_HEADER
	//
	AssignmentBlock.CommandHeader.ulByteSize += ulEventLength;

	//
	//	Increment number of Events
	//
	ulEventCount++;

	//
	//	Recalculate remaining buffer
	//
	rulRemainingBuffer -= ulEventLength;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\actions.h ===
#ifndef __ACTIONS_H__
#define __ACTIONS_H__
//	@doc
/**********************************************************************
*
*	@module	Actions.h	|
*
*	Definitions of data structures for representing Actions and Events
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*	Jeffrey A. Davis	Modifications.
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@index	Actions | ACTIONS
*
*	@topic	Actions	|
*	Contains definitions of structures, constants, and macros
*	for building up and working with Actions and their constituent Events
*
**********************************************************************/
#include "controlitems.h"
#include "profile.h"		// legacy data structures.
#define	CF_RAWSCHEME	(0x201)


#pragma pack(push, actions_previous_alignment)
#pragma pack(1)

//
//	Flags included as part of commands type.
//	used to define different properties of some commands

#define	COMMAND_TYPE_FLAG_ASSIGNMENT	0x8000


//
//	Different types of command that can be sent to GcKernel
//
#define COMMAND_TYPE_ASSIGNMENT_TARGET	0x0001
#define COMMAND_TYPE_RECORDABLE			(0x0002 | COMMAND_TYPE_FLAG_ASSIGNMENT)
#define COMMAND_TYPE_BEHAVIOR			(0x0003 | COMMAND_TYPE_FLAG_ASSIGNMENT)
#define COMMAND_TYPE_FEEDBACK			(0x0004 | COMMAND_TYPE_FLAG_ASSIGNMENT)
#define COMMAND_TYPE_TRANSLATE			0x0005
#define COMMAND_TYPE_QUEUE				0x0006
#define COMMAND_TYPE_GENERAL			0x0007


//
//	@enum COMMAND_ID |
//	a.k.a ACTION_OBJECT_ID, and BEHAVIOR_OBJECT_ID
//	defines the sepcific command.
//	
typedef enum COMMAND_ID
{
	eDirectory = 0,											//@field Directory.

	//
	// Assignment Targets IDs
	//
	eAssignmentTargetPlaceTag = (COMMAND_TYPE_ASSIGNMENT_TARGET << 16),	//Beginning of Assignment Targets
	eRecordableAction,										//@field Recordable Action
	eBehaviorAction,										//@field Behavior Action
	eFeedbackAction,										//@field Feedback Action

	//
	// Recordable Assignment IDs
	//
	eAssignmentPlaceTag = (COMMAND_TYPE_RECORDABLE << 16),	//Beginning of assignments
	eTimedMacro,											//@field A timed macro
	eKeyString,												//@field An untimed string of keys
	eButtonMap,												//@field A single button mapped (or direction)
	eKeyMap,												//@field A single keyboard key mapped
	eCycleMap,												//@field A single keyboard key mapped
	eNone,													//@field Was eAxisMap used as NONE

	//
	// Mouse Input Assignment IDs - use with eRecordableAction assignment targets.
	// These are mutually exclusive with Macors and other recordable assignments.
	// The ones with FX (all except eMouseButtonMap) do nothing unless eMouseFXModel is sent to the device(below)
	eMouseButtonMap,										//@field Maps a mouse button
	eMouseFXAxisMap,										//@field Maps a mouse axis
	eMouseFXClutchMap,										//@field Maps the button to turn clutch on in Mouse FX model
	eMouseFXDampenMap,										//@field Maps the button to turn dampen on in Mouse FX model
	eMouseFXZoneIndicator,									//@field Maps an an input to indicate zone in Mouse FX model
	//
	// Axis IDs
	//
	eAxisMap,												//@field A mapping of one axis to another
    eAxisToKeyMap,                                          //@field A mapping of an axis to key (Used in Attila)

	// Atilla Macro (MultiMap?)
	eMultiMap,												//@field Maps to keys, delays, and mouse clicks

    //
	// Behavior Assignment IDs
	//
	eBehaviorPlaceTag = (COMMAND_TYPE_BEHAVIOR << 16),		//Beginning of Behaviors
	eStandardBehaviorCurve,									//@field A behavior curve assigned to and axes

	
    //
	// Feedback Assignment IDs
	//
	eFeedbackPlaceTag = (COMMAND_TYPE_FEEDBACK << 16),		//Beginning of Feedback types
    eForceMap,                                              //MapYToX, RTC, Gain (Driver Should Ignore) Sparky Zep Additions

	//
	// Translation IDs
	//
	eTranslatePlaceTag = (COMMAND_TYPE_TRANSLATE << 16),	//Beginning of Translate types
	eAtlasProfile,											//@field ATLAS entire Profile.
	eXenaProfile,											//@field XENA entire profile.
	eAtlasKeyboardMacro,									//@field ATLAS macro.
	eXenaKeyboardMacro,										//@field XENA macro.
	eAtlasTimedMacro,										//@field ATLAS macro.
	eXenaTimedMacro,										//@field XENA macro.
	eAtlasSetting,											//@field ATLAS Settings flags							
	eXenaSetting,											//@field XENA Settings flags							
	
	//
	// Queue Command IDs
	//
	eQueuePlaceTag = (COMMAND_TYPE_QUEUE << 16),			//Beginning of Queue
	eSetQueueInterruptMode,									//@field Cause one macro to interupt another
	eSetQueueOverlayMode,									//@field Causes macros to overlay each other
	eSetQueueSequenceMode,									//@field Causes macros to play in sequence

	//
	// General Command IDs
	//
	eGeneralCommandsPlaceTag = (COMMAND_TYPE_GENERAL << 16),//Beginning of General Commands
	eResetScheme,				//@field Resets all the settings of a scheme
} ACTION_OBJECT_ID, BEHAVIOR_OBJECT_ID;


// There are the different type of proportional axes
typedef enum AXIS_ID
{
    eX = 0,
    eY,
    eZ,
    eRX,
    eRY,
    eRZ
};


//
//	@struct COMMAND_HEADER |
//	Each command begins with a COMMAND_HEADER
typedef struct 
{
	COMMAND_ID	eID;			//@field ID of command
	ULONG		ulByteSize;		//@field Length of command including this header
} COMMAND_HEADER, *PCOMMAND_HEADER;

//
//	@struct COMMAND_DIRECTORY |
//	Dirtectory block that lists one or more sets of commands.
typedef struct tagCOMMAND_DIRECTORY
{
	COMMAND_HEADER CommandHeader;	//@field Command header
	USHORT	usNumEntries;			//@field Number of IDs that follow.
	ULONG	ulEntireSize;	
}	COMMAND_DIRECTORY, 
	*PCOMMAND_DIRECTORY;

//
//	@struct ASSIGNMENT_BLOCK |
//	Assignment blocks are any block with a
//	COMMAND_ID that has the COMMAND_TYPE_FLAG_ASSIGNMENT
//	set.  You can assume that these blocks start
//	with this structure as an extension of the COMMAND_HEADER
//	structure.
typedef struct ASSIGNMENT_BLOCK
{
	COMMAND_HEADER CommandHeader;	//@field Command header
	ULONG			ulVidPid;		//@field VIDPID.
} *PASSIGNMENT_BLOCK;

//
//	@func Get the type of command from a COMMAND_ID., 
//	
//	@rdesc COMMAND_TYPE_ASSIGNMENT	Command is an action assignment.
//	@rdesc COMMAND_TYPE_BEHAVIOR	Command is a behavior assignment.
//	@rdesc COMMAND_TYPE_QUEUE		Command changes properties of Action queue.
//	@rdesc COMMAND_TYPE_GENERAL		Command modifies a general property of the filter.
//
#ifdef __cplusplus
inline ULONG
CommandType
(
	COMMAND_ID eID  //@parm COMMAND_ID to get type of
)
{
	return static_cast<ULONG>(eID >> 16) & 0x0000FFFF;
}
#else //if not __cplusplus, define as macro instead
#define CommandType(__ID__) ((ULONG)(__ID__ >> 16) & 0x0000FFFF)
#endif //__cplusplus


//
//	@struct EVENT | Describes a single untimed event which may contain
//			device data or keystrokes.
//
//	@field ULONG | ulNumXfers | Number CONTROL_ITEM_XFER's in EVENT
//	@field CONTROL_ITEM_XFER | rgXfers[] | Array of events
typedef struct tagEVENT
{	
	ULONG			  ulNumXfers;	
	CONTROL_ITEM_XFER rgXfers[1];	

	//
	//	@mfunc static ULONG | EVENT | RequiredByteSize |
	//	Calculates the bytes required for an event given the number
	//	CONTROL_ITEM_XFER's.
	//
#ifdef __cplusplus
	static ULONG RequiredByteSize(
						ULONG ulNumXfers //@parm Number of CONTROL_ITEM_XFERs
						)
	{
		ASSERT(0!=ulNumXfers);
		return (ulNumXfers-1)*sizeof(CONTROL_ITEM_XFER)+sizeof(tagEVENT);
	}

	// Simple accessor for retrieval of Xfers by index
	CONTROL_ITEM_XFER& GetControlItemXfer(ULONG ulXferIndex)
	{
		ASSERT(ulXferIndex < ulNumXfers); // && TEXT("Requested Xfer is greater than the number of xfers"));
		return rgXfers[ulXferIndex];
	}

	// Assumes XFers are in the same order!!
	bool operator==(const tagEVENT& rhs)
	{
		if (ulNumXfers != rhs.ulNumXfers)
		{
			return false;
		}
		for (UINT i = 0; i < ulNumXfers; i++)
		{
			if (rgXfers[i] != rhs.rgXfers[i])
			{
				return false;
			}
		}

		// If we got this far all matched
		return true;
	}

	bool operator!=(const tagEVENT& rhs)
	{
		return !(operator==(rhs));
	}
#endif	__cplusplus
} EVENT, *PEVENT;

//
//	@struct TIMED_EVENT | Describes a single timed event which may contain
//			device data or keystrokes.
//
//	@field ULONG | ulDuration |	Duration of timed event.
//	@field EVENT | Event | Untimed EVENT
typedef struct tagTIMED_EVENT
{
	ULONG	ulDuration;		
	EVENT	Event;			
	
	//
	//	@mfunc static ULONG | TIMED_EVENT | RequiredByteSize |
	//	Calculates the bytes required for an event given the number
	//	CONTROL_ITEM_XFER's.
	//
#ifdef __cplusplus
	static ULONG RequiredByteSize(
					ULONG ulNumXfers //@parm Number of CONTROL_ITEM_XFERs
				)
	{
//		ASSERT(0!=ulNumXfers);
		return (ulNumXfers-1)*sizeof(CONTROL_ITEM_XFER)+sizeof(tagTIMED_EVENT);
	}
#endif
} TIMED_EVENT, *PTIMED_EVENT;


const ULONG ACTION_FLAG_AUTO_REPEAT			= 0x00000001;
const ULONG ACTION_FLAG_BLEED_THROUGH		= 0x00000002;
const ULONG ACTION_FLAG_PREVENT_INTERRUPT	= 0x00000004;

//
//	@struct TIMED_MACRO | Structure to represent a timed macro.
//	@field	COMMAND_HEADER	|	CmdHeader	|	Command header must have eID = eTimedMacro.
//	@field	ULONG	|	ulFlags	|	Flags modify the properties of the macro.<nl>
//									ACTION_FLAG_AUTO_REPEAT - Macro repeats as long as trigger is held.<nl>
//									ACTION_FLAG_BLEED_THROUGH - Allows bleed-through and coexisting macros <nl>
//									ACTION_FLAG_PREVENT_INTERRUPT - Prevents a macro from being interrupted by another.<nl>
//	@field ULONG	| ulEventCount	| Number of events in Macro.
//	@field TIMED_EVENT | rgEvents[1] | Events in macro - do not access directly, use accessors
//	@xref TIMED_MACRO::GetEvent
//	@xref TIMED_MACRO::GetNextEvent
typedef struct tagTIMED_MACRO
{
		//
		//	Data for TIMED_MACROS
		//
		ASSIGNMENT_BLOCK		AssignmentBlock;
		ULONG					ulFlags;
		ULONG					ulEventCount;

	#ifdef __cplusplus
		
		//
		// Accessor functions for events which are variable length,
		// so do not access private item directly
		PTIMED_EVENT GetEvent(ULONG uEventNum);
		PTIMED_EVENT GetNextEvent(PTIMED_EVENT pCurrentEvent, ULONG& ulCurrentEvent);
		static tagTIMED_MACRO *Init(ULONG ulVidPid,ULONG ulFlagsParm, PCHAR pcBuffer, ULONG& rulRemainingBuffer);
		HRESULT AddEvent(PTIMED_EVENT pTimedEvent, ULONG& rulRemainingBuffer);
	
	 private:
	#endif //__cplusplus
		TIMED_EVENT			rgEvents[1];
	
} TIMED_MACRO, *PTIMED_MACRO; 

typedef struct tagMULTI_MACRO
{
		//
		//	Data for MULTI_MACRO
		//
		ASSIGNMENT_BLOCK		AssignmentBlock;
		ULONG					ulFlags;
		ULONG					ulEventCount;

	#ifdef __cplusplus
		
		//
		// Accessor functions for events which are variable length,
		// so do not access private item directly
		PEVENT GetEvent(ULONG uEventNum);
		PEVENT GetNextEvent(EVENT* pCurrentEvent, ULONG& ulCurrentEvent);
		static tagMULTI_MACRO *Init(ULONG ulVidPid, ULONG ulFlagsParm, PCHAR pcBuffer, ULONG& rulRemainingBuffer);
		HRESULT AddEvent(EVENT* pEvent, ULONG& rulRemainingBuffer);
	
	 private:
	#endif //__cplusplus
		EVENT	rgEvents[1];
	
} MULTI_MACRO, *PMULTI_MACRO; 


typedef struct
{
	ASSIGNMENT_BLOCK	AssignmentBlock;
	MACRO				Macro;
} XENA_MACRO_BLOCK, *PXENA_MACRO_BLOCK;

typedef struct
{
	ASSIGNMENT_BLOCK	AssignmentBlock;
	ATLAS_MACRO			Macro;
} ATLAS_MACRO_BLOCK, *PATLAS_MACRO_BLOCK;

typedef struct
{
	ASSIGNMENT_BLOCK	AssignmentBlock;
	SETTING				Setting;
} XENA_SETTING_BLOCK, *PXENA_SETTING_BLOCK;


typedef struct
{
	ASSIGNMENT_BLOCK	AssignmentBlock;
	ATLAS_SETTING		Setting;
} ATLAS_SETTING_BLOCK, *PATLAS_SETTING_BLOCK;



typedef struct tagMAP_LIST
{
	ASSIGNMENT_BLOCK		AssignmentBlock;
	ULONG					ulFlags;
	ULONG					ulEventCount;
#ifdef __cplusplus
	//
	// Accessor functions for events which are variable length,
	// so do not access private item directly
	PEVENT GetEvent(ULONG uEventNum);
	PEVENT GetNextEvent(PEVENT pCurrentEvent, ULONG& ulCurrentEvent);

	static tagMAP_LIST* Init(ULONG ulVidPid,ULONG ulFlagsParm, PCHAR pcBuffer, ULONG& rulRemainingBuffer);
	HRESULT AddEvent(EVENT* pTimedEvent, ULONG& rulRemainingBuffer);

	private:
#endif
	EVENT					rgEvents[1];
} MAP_LIST, *PMAP_LIST, CYCLE_MAP, *PCYCLE_MAP, KEYSTRING_MAP, *PKEYSTRING_MAP;

typedef struct tagX_MAP
{
	ASSIGNMENT_BLOCK		AssignmentBlock;
	ULONG					ulFlags;
	ULONG					ulEventCount;	// Not gauranteeing, but should always be 1
	EVENT					Event;
} KEY_MAP, *PKEY_MAP, BUTTON_MAP, *PBUTTON_MAP;

/*
*	BUGBUG	This structure is only useful for mapping axes of type CGenericItem or derivatives.
*	BUGBUG	This is due to limitations in GcKernel.  For example the Y-Z axis swap for
*	BUGBUG	for joysticks is currently broken.  See the comment in the declaration of CAxisMap
*	BUGBUG	in filter.h in the GcKernel.sys project for details.
*/
typedef struct tagAXIS_MAP
{
	ASSIGNMENT_BLOCK	AssignmentBlock;	//eAxisMap is the type
	LONG				lCoefficient1024x;	//A mapping coeffiecient times 1024 (should be between -1024 and 1024)
	CONTROL_ITEM_XFER	cixDestinationAxis; //Axis to map to.
} AXIS_MAP, *PAXIS_MAP;

typedef struct 
{
	short sX;
	short sY;
}CURVE_POINT;

typedef struct tagBEHAVIOR_CURVE
{
	ASSIGNMENT_BLOCK	AssignmentBlock;
	BOOLEAN				fDigital;			//This flag is only flag for PROPDPads that are software programmable.
	ULONG			ulRange;
	USHORT			usPointCount;
	CURVE_POINT		rgPoints[1];
#ifdef __cplusplus
	static ULONG RequiredByteSize(USHORT usNumPoints)
	{
		return (usNumPoints-1)*sizeof(CURVE_POINT)+sizeof(tagBEHAVIOR_CURVE);
	}
#endif
} BEHAVIOR_CURVE, *PBEHAVIOR_CURVE;


typedef struct
{
	COMMAND_HEADER		CommandHeader;
	CONTROL_ITEM_XFER	cixAssignment;
} ASSIGNMENT_TARGET, *PASSIGNMENT_TARGET;

typedef struct
{
	ASSIGNMENT_BLOCK	AssignmentBlock;
	UCHAR				ucButtonNumber;
} MOUSE_BUTTON_MAP, *PMOUSE_BUTTON_MAP;

typedef struct tagMOUSE_MODEL_FX_PARAMETERS
{
	ULONG				ulAbsZoneSense;
	ULONG				ulContZoneMaxRate;
	ULONG				ulPulseWidth;
	ULONG				ulPulsePeriod;
	ULONG				ulInertiaTime;
	ULONG				ulAcceleration;
	BOOLEAN				fAccelerate;
	BOOLEAN				fPulse;
	USHORT				usReserved;
}	MOUSE_MODEL_PARAMETERS, *PMOUSE_MODEL_PARAMETERS;

typedef struct
{
	ASSIGNMENT_BLOCK		AssignmentBlock;
	BOOLEAN					fIsX; //TRUE = x; FALSE = y
	MOUSE_MODEL_PARAMETERS	AxisModelParameters;
} MOUSE_FX_AXIS_MAP, *PMOUSE_FX_AXIS_MAP;

typedef struct
{
	ASSIGNMENT_BLOCK	AssignmentBlock;
} MOUSE_FX_CLUTCH_MAP, *PMOUSE_FX_CLUTCH_MAP;

typedef struct
{
	ASSIGNMENT_BLOCK	AssignmentBlock;
} MOUSE_FX_DAMPEN_MAP, *PMOUSE_FX_DAMPEN_MAP;

typedef struct
{
	ASSIGNMENT_BLOCK	AssignmentBlock;
	UCHAR				ucAxis;	//0 = X, 1=Y, 2=Z
} MOUSE_FX_ZONE_INDICATOR, *PMOUSE_FX_ZONE_INDICATOR; 

typedef struct
{
	ASSIGNMENT_BLOCK	AssignmentBlock;
    UCHAR               bMapYToX;            //@field Bool value 
    USHORT              usRTC;               //@field return to center force (0-10000)
    USHORT              usGain;              //@field gain for the device
} *PFORCE_BLOCK, FORCE_BLOCK;

typedef struct tagAXISTOKEYMAPMODEL
{
	//
	//	Data for AXISTOKEYMAPMODEL
	//
	ASSIGNMENT_BLOCK		AssignmentBlock;
	ULONG					ulActiveAxes;		//@field Which axes have mappings
	ULONG					ulEventCount;		//@field How many axis have mappings

#ifdef __cplusplus
	
	//
	// Accessor functions for events which are variable length,
	// so do not access private item directly
//	PEVENT GetEvent(ULONG uEventNum);
//	PEVENT GetNextEvent(EVENT* pCurrentEvent, ULONG& ulCurrentEvent);
//	static tagMULTI_MACRO *Init(ULONG ulVidPid, ULONG ulFlagsParm, PCHAR pcBuffer, ULONG& rulRemainingBuffer);
//	HRESULT AddEvent(EVENT* pEvent, ULONG& rulRemainingBuffer);

 private:
#endif //__cplusplus
	EVENT	rgEvents[1];						//@field Variable size array of events for mappings
} *PAXISTOKEYMAPMODEL_BLOCK, AXISTOKEYMAPMODEL_BLOCK;

#pragma pack(pop, actions_previous_alignment)

#endif //__ACTIONS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\controlitemcollection.cpp ===
#define __DEBUG_MODULE_IN_USE__ CIC_CONTROLITEMCOLLECTION_CPP
#include "stdhdrs.h"
//	@doc
/**********************************************************************
*
*	@module	ControlItemCollection.cpp	|
*
*	Implementation of CControlItemCollection implementation functions
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	ControlItemCollection	|
*	This library encapsulates HID parsing and driver packet code.  It is
*   used it both the driver and the control panel applet.
*
**********************************************************************/



/***********************************************************************************
**
**	CControlItemCollectionImpl::Init
**
**	@mfunc	Initialize collection by calling factory to get items
**
**	@rdesc	S_OK on success, S_FALSE if factory failed to support one or
**			 more of the items, E_FAIL if device not supported or error from factory
**
*************************************************************************************/
HRESULT CControlItemCollectionImpl::Init(
		ULONG			  ulVidPid,				//@parm [in] Vid in the high word, Pid in the low word
		PFNGENERICFACTORY pfnFactory,			//@parm	[in] pointer to function which acts
												//			on pFactoryHandle
		PFNGENERICDELETEFUNC pfnDeleteFunc		//@parm [in] delete function to used for control items
		)
{
	CIC_DBG_ENTRY_PRINT(("CControlItemCollectionImpl::Init(0x%0.8x, 0x%0.8x)\n", ulVidPid, pfnFactory));
	
	
	HRESULT hr = S_OK;
	
	//
	//	Walk the table devices and find a matching VidPid
	//
	ULONG ulDeviceIndex=0;
	
	//
	// Endless loop, you get out by breaking, or returning from the function.
	//
	while(1)
	{
		//
		//	If we have reached the end of the table
		//
		if(0 == DeviceControlsDescList[ulDeviceIndex].ulVidPid )
		{
			ASSERT(FALSE); //Should never get here.
			return E_FAIL; //BUGBUGBUG need more descriptive error code here
		}
		if(DeviceControlsDescList[ulDeviceIndex].ulVidPid == ulVidPid)
		{
			break;
		}
		ulDeviceIndex++;
	}
	m_ulDeviceIndex = ulDeviceIndex;

	//
	//	Use the size argument to pre-allocate space for the list
	//
	hr = m_ObjectList.SetAllocSize(DeviceControlsDescList[m_ulDeviceIndex].ulControlItemCount, NonPagedPool);
	if( FAILED(hr) )
	{
		return hr;
	}

	//
	//	Set the delete function for the class
	//
	m_ObjectList.SetDeleteFunc(pfnDeleteFunc);
	
	//
	//	Walk through the control item list and call the factory for each one
	//
	CONTROL_ITEM_DESC		*pControlItems = reinterpret_cast<CONTROL_ITEM_DESC *>(DeviceControlsDescList[m_ulDeviceIndex].pControlItems);
	PVOID					pNewControlItem;
	HRESULT hrFactory;
	m_ulMaxXfers = 0;
	for(
			ULONG ulControlIndex = 0;
			ulControlIndex < DeviceControlsDescList[m_ulDeviceIndex].ulControlItemCount;
			ulControlIndex++
	)
	{
		//
		//	Call factory to get new control item
		//
		hrFactory = pfnFactory(pControlItems[ulControlIndex].usType, &pControlItems[ulControlIndex], &pNewControlItem);
		
		//
		//  If the factory fails mark an error
		//
		if( FAILED(hrFactory) )
		{
			hr = hrFactory;
			continue;
		}

		//
		//	If the factory does not support that control add a null to the list
		//	to hold the index as taken 
		//
		if( S_FALSE == hrFactory )
		{
			pNewControlItem = NULL;
		}
		else
		//an Xfer would be needed to get the state.
		{
			m_ulMaxXfers++;
		}

		//
		//	Add item (or NULL) to list of items in collection
		//
		hrFactory = m_ObjectList.Add(pNewControlItem);
		if( FAILED(hrFactory) )
		{
			hr = hrFactory;
		}
	}

	//
	//	Return error code
	//
	return hr;

}


/***********************************************************************************
**
**	HRESULT CControlItemCollectionImpl::GetNext
**
**	@mfunc	Gets the next item in list
**
**	@rdesc	S_OK on success, S_FALSE if no more items
**
************************************************************************************/
HRESULT CControlItemCollectionImpl::GetNext
(
	PVOID *ppControlItem,		//@parm pointer to receive control item
	ULONG& rulCookie			//@parm cookie to keep track of enumeration
) const
{
	CIC_DBG_RT_ENTRY_PRINT(("CControlItemCollectionImpl::GetNext(0x%0.8x, 0x%0.8x)\n", ppControlItem, rulCookie));
	
	if(	rulCookie >= m_ObjectList.GetItemCount() )
	{
		*ppControlItem = NULL;
		CIC_DBG_EXIT_PRINT(("Exit GetNext - no more items\n"));
		return S_FALSE;
	}
	else
	{
		*ppControlItem = m_ObjectList.Get( rulCookie );
		rulCookie += 1;
		if(!*ppControlItem)
		{
			CIC_DBG_EXIT_PRINT(("Calling GetNext recursively\n"));
			return GetNext(ppControlItem, rulCookie);
		}
		CIC_DBG_RT_EXIT_PRINT(("Exit GetNext - *ppControlItem = 0x%0.8x\n", *ppControlItem));
		return S_OK;
	}
}

/***********************************************************************************
**
**	PVOID CControlItemCollectionImpl::GetFromControlItemXfer
**
**	@mfunc	Returns item given CONTROL_ITEM_XFER
**
**	@rdesc	Pointer to item on success, NULL if not
**
************************************************************************************/
PVOID CControlItemCollectionImpl::GetFromControlItemXfer(
		const CONTROL_ITEM_XFER& crControlItemXfer	//@parm [in] report selector to get object for
)
{
	CIC_DBG_RT_ENTRY_PRINT(("CControlItemCollectionImpl::GetFromControlItemXfer\n"));
	
	ULONG ulListIndex = crControlItemXfer.ulItemIndex - 1;
	
	ASSERT( m_ObjectList.GetItemCount() > ulListIndex);
	if( m_ObjectList.GetItemCount() <= ulListIndex)
	{
		return NULL;
	}
	
	CIC_DBG_RT_EXIT_PRINT(("Exiting CControlItemCollectionImpl::GetFromControlItemXfer\n"));	
	return m_ObjectList.Get(ulListIndex);
}

/***********************************************************************************
**
**	NTSTATUS CControlItemCollectionImpl::ReadFromReport
**
**	@mfunc	Recurses collection and asks each item to read its state.
**
**	@rdesc	Use NT_SUCCESS, NT_ERROR, SUCCEEDED, FAILED macros to parse.
**
************************************************************************************/
NTSTATUS CControlItemCollectionImpl::ReadFromReport
(
	PHIDP_PREPARSED_DATA pHidPPreparsedData,	//@parm hid preparsed data
	PCHAR pcReport,								//@parm report buffer
	LONG lReportLength,							//@parm length of report buffer
	PFNGETCONTROLITEM	GetControlFromPtr		//@parm pointer to function to get CControlItem *
)
{
	NTSTATUS NtStatus;
	NtStatus = ControlItemsFuncs::ReadModifiersFromReport(
					DeviceControlsDescList[m_ulDeviceIndex].pModifierDescTable,
					m_ulModifiers,
					pHidPPreparsedData,
					pcReport,
					lReportLength
					);
	if( NT_ERROR(NtStatus) )
	{
		CIC_DBG_ERROR_PRINT(("ReadModifiersFromReport returned 0x%0.8x\n", NtStatus));
				
		//
		//	Instead of returning, let's go on, the modifiers are important, but
		//	not important enough to cripple everything else.
		NtStatus = S_OK;
	}

	//
	//	Loop over all items and read them
	//
	ULONG ulCookie = 0;
	PVOID pvControlItem = NULL;
	CControlItem *pControlItem;

	HRESULT hr;
	hr = GetNext(&pvControlItem, ulCookie);
	while(S_OK == hr)
	{
		pControlItem = GetControlFromPtr(pvControlItem);
		NtStatus= pControlItem->ReadFromReport(
						pHidPPreparsedData,
						pcReport,
						lReportLength
						);
		if( NT_ERROR(NtStatus) )
		{
			CIC_DBG_ERROR_PRINT(("pControlItem->ReadFromReport returned 0x%0.8x, ulCookie = 0x%0.8x\n", NtStatus, ulCookie));
			return NtStatus;
		}
		pControlItem->SetModifiers(m_ulModifiers);
		hr = GetNext(&pvControlItem, ulCookie);
	}
	return NtStatus;
}


/***********************************************************************************
**
**	NTSTATUS CControlItemCollectionImpl::WriteToReport
**
**	@mfunc	Recurses collection and asks each item to write its state to the report.
**
**	@rdesc	Use NT_SUCCESS, NT_ERROR, SUCCEEDED, FAILED macros to parse.
**
************************************************************************************/
NTSTATUS CControlItemCollectionImpl::WriteToReport
(
	PHIDP_PREPARSED_DATA pHidPPreparsedData,	//@parm hid preparsed data
	PCHAR pcReport,								//@parm report buffer
	LONG lReportLength,							//@parm length of report buffer
	PFNGETCONTROLITEM	GetControlFromPtr		//@parm pointer to function to get CControlItem *
) const
{
	//
	//	Loop over all items and write to them
	//
	NTSTATUS NtStatus;
	ULONG ulCookie = 0;
	PVOID pvControlItem = NULL;
	CControlItem *pControlItem;
	HRESULT hr;
	hr = GetNext(&pvControlItem, ulCookie);
	while(S_OK == hr)
	{
		pControlItem = GetControlFromPtr(pvControlItem);
		NtStatus= pControlItem->WriteToReport(
						pHidPPreparsedData,
						pcReport,
						lReportLength
						);
		if( NT_ERROR(NtStatus) )
		{
			CIC_DBG_ERROR_PRINT(("pControlItem->WriteToReport returned 0x%0.8x, ulCookie = 0x%0.8x\n", NtStatus, ulCookie));
			return NtStatus;
		}
		hr = GetNext(&pvControlItem, ulCookie);
	}
	if( FAILED(hr) )
	{
		ASSERT(SUCCEEDED(hr));
		return hr;
	}

	NtStatus = ControlItemsFuncs::WriteModifiersToReport(
					DeviceControlsDescList[m_ulDeviceIndex].pModifierDescTable,
					m_ulModifiers,
					pHidPPreparsedData,
					pcReport,
					lReportLength
					);

	return NtStatus;
}


/***********************************************************************************
**
**	NTSTATUS CControlItemCollectionImpl::WriteToReport
**
**	@mfunc	Recurses collection and asks each item to set its self to its default state.
**
**	@rdesc	Use NT_SUCCESS, NT_ERROR, SUCCEEDED, FAILED macros to parse.
**
************************************************************************************/
void CControlItemCollectionImpl::SetDefaultState
(
	PFNGETCONTROLITEM	GetControlFromPtr //@parm pointer to function to get CControlItem *
)
{
	ULONG ulCookie = 0;
	PVOID pvControlItem = NULL;
	CControlItem *pControlItem;
	HRESULT hr;
	hr = GetNext(&pvControlItem, ulCookie);
	while(S_OK == hr)
	{
		pControlItem = GetControlFromPtr(pvControlItem);
		pControlItem->SetDefaultState();
		hr = GetNext(&pvControlItem, ulCookie);
	}
	m_ulModifiers=0;
}


/***********************************************************************************
**
**	HRESULT CControlItemCollectionImpl::GetState
**
**	@mfunc	Gets the state of each item in the collection and return it in the caller
**
**	@rdesc	S_OK on success, E_OUTOFMEMORY if buffer is not large enough
**
*************************************************************************************/
HRESULT CControlItemCollectionImpl::GetState
(
	ULONG& ulXferCount,						// @parm [in\out] specifies length of array on entry
											// and items used on exit
	PCONTROL_ITEM_XFER pControlItemXfers,	// @parm [out] caller allocated buffer to hold packets
	PFNGETCONTROLITEM	GetControlFromPtr	// @parm [in] function to get CControlItem *
)
{
	HRESULT hr = S_OK;

	ULONG ulCookie = 0;
	ULONG ulXferMax = ulXferCount;
	PVOID pvControlItem = NULL;
	CControlItem *pControlItem;
	
	ulXferCount = 0;
	hr = GetNext(&pvControlItem, ulCookie);
	while(S_OK == hr)
	{
		pControlItem = GetControlFromPtr(pvControlItem);
		
		if( !pControlItem->IsDefaultState() )
		{
				if(ulXferCount >= ulXferMax)
				{
					hr = E_OUTOFMEMORY;
				}
				else
				{
					pControlItem->GetItemState(pControlItemXfers[ulXferCount]);
					pControlItemXfers[ulXferCount++].ulModifiers = m_ulModifiers;
				}
		}
		hr = GetNext(&pvControlItem, ulCookie);
	}
	return hr;	
}
		
HRESULT CControlItemCollectionImpl::SetState
(
	ULONG ulXferCount,						// @parm [in\out] specifies length of array on entry
											// and items used on exit
	PCONTROL_ITEM_XFER pControlItemXfers,	// @parm [out] caller allocated buffer to hold packets
	PFNGETCONTROLITEM	GetControlFromPtr	// @parm [in] function to get CControlItem *
)
{
	PVOID pvControlItem = NULL;
	CControlItem *pControlItem;
	while(ulXferCount--)
	{
		//
		// It is legit, that someone may have a keyboard Xfer mixed up in the
		// array, in which case we need to dismiss it.  If someone further down
		// gets it, they will ASSERT.
		//
		if( NonGameDeviceXfer::IsKeyboardXfer(pControlItemXfers[ulXferCount]) )
		{
			continue;
		}
		pvControlItem = GetFromControlItemXfer( pControlItemXfers[ulXferCount]);
		if(NULL == pvControlItem) continue;
		m_ulModifiers |= pControlItemXfers[ulXferCount].ulModifiers;
		pControlItem = GetControlFromPtr(pvControlItem);
		pControlItem->SetModifiers(pControlItemXfers[ulXferCount].ulModifiers);
		pControlItem->SetItemState( pControlItemXfers[ulXferCount]);
	}
	return S_OK;	
}

void CControlItemCollectionImpl::SetStateOverlayMode(
			PFNGETCONTROLITEM	GetControlFromPtr,
			BOOLEAN fEnable
			)
{
	ULONG ulCookie = 0;
	PVOID pvControlItem = NULL;
	CControlItem *pControlItem;
	HRESULT hr;
	hr = GetNext(&pvControlItem, ulCookie);
	while(S_OK == hr)
	{
		pControlItem = GetControlFromPtr(pvControlItem);
		pControlItem->SetStateOverlayMode(fEnable);
		hr = GetNext(&pvControlItem, ulCookie);
	}
}
			
/***********************************************************************************
**
**	HRESULT ControlItemDefaultFactory
**
**	@func	Factory for a default collection
**
**	@rdesc	S_OK if successful, S_FALSE if not supported, E_FAIL for any failure.
**
************************************************************************************/
HRESULT ControlItemDefaultFactory
(
	USHORT usType,									//@parm [in] Type of object to create
	const CONTROL_ITEM_DESC* cpControlItemDesc,		//@parm [in] Item descriptor data
	CControlItem				**ppControlItem		//@parm [out] CControlItem we created
)
{
	HRESULT hr = S_OK;
	switch(usType)
	{
		case ControlItemConst::usAxes:
			*ppControlItem = new WDM_NON_PAGED_POOL CAxesItem(cpControlItemDesc);
			break;
		case ControlItemConst::usDPAD:
			*ppControlItem = new WDM_NON_PAGED_POOL CDPADItem(cpControlItemDesc);
			break;
		case ControlItemConst::usPropDPAD:
			*ppControlItem = new WDM_NON_PAGED_POOL CPropDPADItem(cpControlItemDesc);
			break;
		case ControlItemConst::usWheel:
			*ppControlItem= new WDM_NON_PAGED_POOL CWheelItem(cpControlItemDesc);
			break;
		case ControlItemConst::usPOV:
			*ppControlItem = new WDM_NON_PAGED_POOL CPOVItem(cpControlItemDesc);
			break;
		case ControlItemConst::usThrottle:
			*ppControlItem = new WDM_NON_PAGED_POOL CThrottleItem(cpControlItemDesc);
			break;
		case ControlItemConst::usRudder:
			*ppControlItem = new WDM_NON_PAGED_POOL CRudderItem(cpControlItemDesc);
			break;
		case ControlItemConst::usPedal:
			*ppControlItem = new WDM_NON_PAGED_POOL CPedalItem(cpControlItemDesc);
			break;
		case ControlItemConst::usButton:
			*ppControlItem = new WDM_NON_PAGED_POOL CButtonsItem(cpControlItemDesc);
			break;
		case ControlItemConst::usZoneIndicator:
			*ppControlItem = new WDM_NON_PAGED_POOL CZoneIndicatorItem(cpControlItemDesc);
			break;
        case ControlItemConst::usForceMap:
			*ppControlItem = new WDM_NON_PAGED_POOL CForceMapItem(cpControlItemDesc);
            break;
        case ControlItemConst::usDualZoneIndicator:
			*ppControlItem = new WDM_NON_PAGED_POOL CDualZoneIndicatorItem(cpControlItemDesc);
            break;
		default:
			*ppControlItem = NULL;
			return S_FALSE;
	}
	if(!*ppControlItem)
	{
		return E_FAIL;
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\hidgame\pnp.c ===
/*++

Copyright (c) 1998 - 1999  Microsoft Corporation

Module Name:

    pnp.c

Abstract: This module contains PnP Start, Stop, Remove,
          Power dispatch routines and IRP cancel routine.

Environment:

    Kernel mode

@@BEGIN_DDKSPLIT
  Author:

    Eliyas Yakub (Mar, 11, 1997)
Revision History:

    Updated by Eliyas on Feb 5 1998
    Om Sharma    ( April 15, 1998)
    MarcAnd     02-Jul-98   Quick tidy for DDK

@@END_DDKSPLIT
--*/

#include "hidgame.h"

#ifdef ALLOC_PRAGMA
    #pragma alloc_text (PAGE, HGM_RemoveDevice)
    #pragma alloc_text (PAGE, HGM_PnP)
    #pragma alloc_text (PAGE, HGM_InitDevice)
    #pragma alloc_text (PAGE, HGM_GetResources)
    #pragma alloc_text (PAGE, HGM_Power)
#endif


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   NTSTATUS  | HGM_IncRequestCount |
 *
 *          Try to increment the request count but fail if the device is 
 *          being removed.
 *
 *  @parm   IN PDEVICE_EXTENSION | DeviceExtension |
 *
 *          Pointer to the device extension.
 *
 *  @rvalue STATUS_SUCCESS | success
 *  @rvalue STATUS_DELETE_PENDING | PnP IRP received after device was removed
 *
 *****************************************************************************/
NTSTATUS  EXTERNAL
    HGM_IncRequestCount
    (
    IN PDEVICE_EXTENSION DeviceExtension
    )
{
    NTSTATUS    ntStatus;

    InterlockedIncrement( &DeviceExtension->RequestCount );
    ASSERT( DeviceExtension->RequestCount > 0 );
    
    if( DeviceExtension->fRemoved )
    {
        /*
         *  PnP has already told us to remove the device so fail and make 
         *  sure that the event has been set.
         */
        if( 0 == InterlockedDecrement( &DeviceExtension->RequestCount ) ) 
        {
            KeSetEvent( &DeviceExtension->RemoveEvent, IO_NO_INCREMENT, FALSE );
        }
        ntStatus = STATUS_DELETE_PENDING;
    }
    else
    {
        ntStatus = STATUS_SUCCESS;
    }

    return ntStatus;
}
    



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   VOID  | HGM_DecRequestCount |
 *
 *          Decrement the request count and set event if this is the last.
 *
 *  @parm   IN PDEVICE_EXTENSION | DeviceExtension |
 *
 *          Pointer to the device extension.
 *
 *****************************************************************************/
VOID EXTERNAL
    HGM_DecRequestCount
    (
    IN PDEVICE_EXTENSION DeviceExtension
    )
{
    LONG        LocalCount;

    LocalCount = InterlockedDecrement( &DeviceExtension->RequestCount );

    ASSERT( DeviceExtension->RequestCount >= 0 );
    
    if( LocalCount == 0 )
    {
        /*
         *  PnP has already told us to remove the device so the PnP remove 
         *  code should have set device as removed and should be waiting on
         *  the event.
         */
        ASSERT( DeviceExtension->fRemoved );
        KeSetEvent( &DeviceExtension->RemoveEvent, IO_NO_INCREMENT, FALSE );
    }

    return;
}
    

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   VOID  | HGM_RemoveDevice |
 *
 *          FDO Remove routine 
 *
 *  @parm   IN PDEVICE_EXTENSION | DeviceExtension |
 *
 *          Pointer to the device extension.
 *
 *****************************************************************************/
VOID INTERNAL
    HGM_RemoveDevice
    (
    PDEVICE_EXTENSION DeviceExtension
    )
{
    if (DeviceExtension->fSurpriseRemoved) {
        return;
    }

    DeviceExtension->fSurpriseRemoved = TRUE;

    /*
     *  Acquire mutex before modifying the Global Linked list of devices
     */
    ExAcquireFastMutex (&Global.Mutex);
    
    /*
     * Remove this device from the linked list of devices
     */
    RemoveEntryList(&DeviceExtension->Link);
    
    /*
     *  Release the mutex
     */
    ExReleaseFastMutex (&Global.Mutex);
} /* HGM_RemoveDevice */

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_PnP |
 *
 *          Plug and Play dispatch routine for this driver.
 *
 *  @parm   IN PDEVICE_OBJECT | DeviceObject |
 *
 *          Pointer to the device object.
 *
 *  @parm   IN PIRP | Irp |
 *
 *          Pointer to an I/O request packet.
 *
 *  @rvalue   STATUS_SUCCESS | success
 *  @rvalue   STATUS_DELETE_PENDING | PnP IRP received after device was removed
 *  @rvalue   ???   | Return from IoCallDriver() or HGM_InitDevice()
 *
 *****************************************************************************/
NTSTATUS  EXTERNAL
    HGM_PnP
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION DeviceExtension;
    KEVENT            StartEvent;

    PAGED_CODE();

    HGM_DBGPRINT(FILE_PNP | HGM_FENTRY,\
                   ("HGM_PnP(DeviceObject=0x%x,Irp=0x%x)",\
                    DeviceObject, Irp ));
    /*
     * Get a pointer to the device extension
     */
    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    ntStatus = HGM_IncRequestCount( DeviceExtension );
    if (!NT_SUCCESS (ntStatus))
    {
        /*
         * Someone sent us another plug and play IRP after removed
         */

        HGM_DBGPRINT(FILE_PNP | HGM_ERROR,\
                       ("HGM_PnP: PnP IRP after device was removed\n"));
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    } else
    {
        PIO_STACK_LOCATION IrpStack;

        /*
         * Get a pointer to the current location in the Irp
         */
        IrpStack = IoGetCurrentIrpStackLocation (Irp);

        switch(IrpStack->MinorFunction)
        {
            case IRP_MN_START_DEVICE:

                HGM_DBGPRINT(FILE_PNP | HGM_BABBLE,\
                               ("HGM_Pnp: IRP_MN_START_DEVICE"));
                /*
                 * We cannot touch the device (send it any non pnp irps) until a
                 * start device has been passed down to the lower drivers.
                 */
                KeInitializeEvent(&StartEvent, NotificationEvent, FALSE);

                IoCopyCurrentIrpStackLocationToNext (Irp);
                IoSetCompletionRoutine (Irp, HGM_PnPComplete, &StartEvent, TRUE, TRUE, TRUE);
                ntStatus = IoCallDriver (GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);

                if( NT_SUCCESS(ntStatus ) )
                {
                    ntStatus = KeWaitForSingleObject
                               (
                               &StartEvent,
                               Executive,   /* Waiting for reason of a driver */
                               KernelMode,  /* Waiting in kernel mode         */
                               FALSE,       /* No allert                      */
                               NULL         /* No timeout                     */
                               );
                }

                if(NT_SUCCESS(ntStatus))
                {
                    ntStatus = Irp->IoStatus.Status;
                }

                if(NT_SUCCESS (ntStatus))
                {
                    /*
                     * As we are now back from our start device we can do work.
                     */
                    ntStatus = HGM_InitDevice (DeviceObject, Irp);
                } else
                {
                    HGM_DBGPRINT(FILE_PNP | HGM_ERROR,\
                                   ("HGM_Pnp: IRP_MN_START_DEVICE ntStatus =0x%x",\
                                    ntStatus));
                }


                DeviceExtension->fStarted = TRUE;

                /*
                 *      Return Status
                 */
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = ntStatus;
                IoCompleteRequest (Irp, IO_NO_INCREMENT);

                break;

            case IRP_MN_STOP_DEVICE:

                HGM_DBGPRINT(FILE_PNP | HGM_BABBLE,\
                               ("HGM_Pnp: IRP_MN_STOP_DEVICE"));
                /*
                 * After the start IRP has been sent to the lower driver object, the bus may
                 * NOT send any more IRPS down ``touch'' until another START has occured.
                 * Whatever access is required must be done before Irp passed on.
                 */

                DeviceExtension->fStarted = FALSE;

                /*
                 * We don't need a completion routine so fire and forget.
                 * Set the current stack location to the next stack location and
                 * call the next device object.
                 */

                IoSkipCurrentIrpStackLocation (Irp);
                ntStatus = IoCallDriver (GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);
                break;

            case IRP_MN_SURPRISE_REMOVAL:
                HGM_DBGPRINT(FILE_PNP | HGM_BABBLE,\
                               ("HGM_Pnp: IRP_MN_SURPRISE_REMOVAL"));

                HGM_RemoveDevice(DeviceExtension);

                Irp->IoStatus.Status = STATUS_SUCCESS;
                IoSkipCurrentIrpStackLocation(Irp);
                ntStatus = IoCallDriver (GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);

                break;

            case IRP_MN_REMOVE_DEVICE:
                HGM_DBGPRINT(FILE_PNP | HGM_BABBLE,\
                               ("HGM_Pnp: IRP_MN_REMOVE_DEVICE"));

                /*
                 * The PlugPlay system has dictacted the removal of this device. We
                 * have no choice but to detach and delete the device object.
                 * (If we wanted to express an interest in preventing this removal,
                 * we should have filtered the query remove and query stop routines.)
                 * Note: we might receive a remove WITHOUT first receiving a stop.
                 */

                /*
                 *  Make sure we do not allow more IRPs to start touching the device
                 */
                DeviceExtension->fRemoved = TRUE;

                /*
                 * Stop the device without touching the hardware.
                 */
                HGM_RemoveDevice(DeviceExtension);

                /*
                 * Send on the remove IRP
                 */
                IoSkipCurrentIrpStackLocation (Irp);
                ntStatus = IoCallDriver (GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);


                /*
                 *  Remove this IRPs hold which should leave the initial 1 plus 
                 *  any other IRP holds.
                 */
                {
                    LONG RequestCount = InterlockedDecrement( &DeviceExtension->RequestCount );
                    ASSERT( RequestCount > 0 );
                }

                /*
                 *  If someone has already started, wait for them to finish
                 */
                if( InterlockedDecrement( &DeviceExtension->RequestCount ) > 0 )
                {
                    KeWaitForSingleObject( &DeviceExtension->RemoveEvent,
                        Executive, KernelMode, FALSE, NULL );
                }

                ntStatus = STATUS_SUCCESS;

                HGM_EXITPROC(FILE_IOCTL|HGM_FEXIT_STATUSOK, "HGM_PnP Exit 1", ntStatus);

                return ntStatus;

            default:
                HGM_DBGPRINT(FILE_PNP | HGM_WARN,\
                               ("HGM_PnP: IrpStack->MinorFunction Not handled 0x%x", \
                                IrpStack->MinorFunction));

                IoSkipCurrentIrpStackLocation (Irp);

                ntStatus = IoCallDriver(GET_NEXT_DEVICE_OBJECT(DeviceObject), Irp);
                break;
        }

        HGM_DecRequestCount( DeviceExtension );
    }

    HGM_EXITPROC(FILE_IOCTL|HGM_FEXIT, "HGM_PnP", ntStatus);

    return ntStatus;
} /* HGM_PnP */


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_InitDevice |
 *
 *          Get the device information and attempt to initialize a configuration
 *          for a device.  If we cannot identify this as a valid HID device or
 *          configure the device, our start device function is failed.
 *
 *  @parm   IN PDEVICE_OBJECT | DeviceObject |
 *
 *          Pointer to the device object.
 *
 *  @parm   IN PIRP | Irp |
 *
 *          Pointer to an I/O request packet.
 *
 *  @rvalue   STATUS_SUCCESS | success
 *  @rvalue   STATUS_DEVICE_CONFIGURATION_ERROR | Resources overlap
 *  @rvalue   ???            | Return from HGM_GetResources() or HGM_JoystickConfig()
 *
 *
 *****************************************************************************/
NTSTATUS INTERNAL
    HGM_InitDevice
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION   DeviceExtension;

    PAGED_CODE();

    HGM_DBGPRINT(FILE_PNP | HGM_FENTRY,\
                   ("HGM_InitDevice(DeviceObject=0x%x,Irp=0x%x)", \
                    DeviceObject,Irp));

    /*
     * Get a pointer to the device extension
     */
    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);

    /*
     * Get resource information from GameEnum and store it in the device extension
     */
    ntStatus = HGM_GetResources(DeviceObject,Irp);
    if( NT_SUCCESS(ntStatus) )
    {
        ntStatus = HGM_InitAnalog(DeviceObject);
    }
    else
    {
        HGM_DBGPRINT(FILE_PNP | HGM_ERROR,\
                       ("HGM_InitDevice: HGM_GetResources Failed"));
    }

    if( !NT_SUCCESS(ntStatus) )
    {
        /*
         *  Acquire mutex before modifying the Global Linked list of devices
         */
        ExAcquireFastMutex (&Global.Mutex);

        /*
         * Remove this device from the linked list of devices
         */
        RemoveEntryList(&DeviceExtension->Link);

        /*
         *  Release the mutex
         */
        ExReleaseFastMutex (&Global.Mutex);
    }

    HGM_EXITPROC(FILE_IOCTL|HGM_FEXIT_STATUSOK, "HGM_InitDevice", ntStatus);

    return ntStatus;
} /* HGM_InitDevice */



/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_GetResources |
 *
 *          Gets gameport resource information from the GameEnum driver
 *
 *  @parm   IN PDEVICE_OBJECT | DeviceObject |
 *
 *          Pointer to the device object.
 *
 *  @parm   IN PIRP | Irp |
 *
 *          Pointer to an I/O request packet.
 *
 *  @rvalue   STATUS_SUCCESS | success
 *  @rvalue   ???            | Return from IoCallDriver()
 *
 *****************************************************************************/
NTSTATUS INTERNAL
    HGM_GetResources
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS            ntStatus = STATUS_SUCCESS;
    GAMEENUM_PORT_PARAMETERS    PortInfo;
    PDEVICE_EXTENSION   DeviceExtension;
    KEVENT              IoctlCompleteEvent;
    PIO_STACK_LOCATION  irpStack, nextStack;
    int                 i;
    PAGED_CODE ();

    HGM_DBGPRINT(FILE_PNP | HGM_FENTRY,\
                   ("HGM_GetResources(DeviceObject=0x%x,Irp=0x%x)",\
                    DeviceObject, Irp));

    /*
     * Get a pointer to the device extension
     */

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION(DeviceObject);


    /*
     * issue a synchronous request to get the resources info from GameEnum
     */

    KeInitializeEvent(&IoctlCompleteEvent, NotificationEvent, FALSE);

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    nextStack = IoGetNextIrpStackLocation(Irp);
    ASSERTMSG("HGM_GetResources:",nextStack != NULL);

    /*
     * pass the Portinfo buffer of the DeviceExtension
     */

    nextStack->MajorFunction                                    =
        IRP_MJ_INTERNAL_DEVICE_CONTROL;

    nextStack->Parameters.DeviceIoControl.IoControlCode         =
        IOCTL_GAMEENUM_PORT_PARAMETERS;

    PortInfo.Size                                                   =
        nextStack->Parameters.DeviceIoControl.InputBufferLength     =
        nextStack->Parameters.DeviceIoControl.OutputBufferLength    =
        sizeof (PortInfo);

    Irp->UserBuffer =   &PortInfo;

    IoSetCompletionRoutine (Irp, HGM_PnPComplete,
                            &IoctlCompleteEvent, TRUE, TRUE, TRUE);

    HGM_DBGPRINT(FILE_PNP | HGM_BABBLE,\
                   ("calling GameEnum"));

    ntStatus = IoCallDriver(GET_NEXT_DEVICE_OBJECT (DeviceObject), Irp);

    if( NT_SUCCESS(ntStatus) )
    {
        ntStatus = KeWaitForSingleObject(
                                        &IoctlCompleteEvent,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL);

    }

    if( NT_SUCCESS(ntStatus) )
    {
        ntStatus = Irp->IoStatus.Status;
    }
    DeviceExtension->GameContext        = PortInfo.GameContext;
    DeviceExtension->ReadAccessor       = PortInfo.ReadAccessor;
    DeviceExtension->WriteAccessor      = PortInfo.WriteAccessor;
    DeviceExtension->ReadAccessorDigital= PortInfo.ReadAccessorDigital;
    DeviceExtension->AcquirePort        = PortInfo.AcquirePort;
    DeviceExtension->ReleasePort        = PortInfo.ReleasePort;
    DeviceExtension->PortContext        = PortInfo.PortContext;
    DeviceExtension->nAxes              = PortInfo.NumberAxis;
    DeviceExtension->nButtons           = PortInfo.NumberButtons;

#ifdef CHANGE_DEVICE
    /*
     *  Stash the NextDeviceObject in the device extension so that we can
     *  call GameEnum IRPs when we're not responding to an IRP
     */
    DeviceExtension->NextDeviceObject = GET_NEXT_DEVICE_OBJECT(DeviceObject);
#endif /* CHANGE_DEVICE */

    RtlCopyMemory(DeviceExtension->HidGameOemData.Game_Oem_Data, PortInfo.OemData, sizeof(PortInfo.OemData));

    for(i=0x0;
       i < sizeof(PortInfo.OemData)/sizeof(PortInfo.OemData[0]);
       i++)
    {
        HGM_DBGPRINT( FILE_PNP | HGM_BABBLE2,\
                        ("JoystickConfig:  PortInfo.OemData[%d]=0x%x",\
                         i, PortInfo.OemData[i]) );
    }


    HGM_EXITPROC(FILE_IOCTL|HGM_FEXIT_STATUSOK, "HGM_GetResources", Irp->IoStatus.Status);

    return Irp->IoStatus.Status;
} /* HGM_GetResources */


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_PnPComplete |
 *
 *          Completion routine for PnP IRPs.  
 *          Not pageable because it is a completion routine.
 *
 *  @parm   IN PDEVICE_OBJECT | DeviceObject |
 *
 *          Pointer to the device object.
 *
 *  @parm   IN PIRP | Irp |
 *
 *          Pointer to an I/O request packet.
 *
 *  @rvalue STATUS_MORE_PROCESSING_REQUIRED | We want the IRP back
 *
 *****************************************************************************/
NTSTATUS INTERNAL
    HGM_PnPComplete
    (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    NTSTATUS ntStatus = STATUS_MORE_PROCESSING_REQUIRED;

    HGM_DBGPRINT(FILE_PNP | HGM_FENTRY,\
                   ("HGM_PnPComplete(DeviceObject=0x%x,Irp=0x%x,Context=0x%x)", \
                    DeviceObject, Irp, Context));

    UNREFERENCED_PARAMETER (DeviceObject);
    KeSetEvent ((PKEVENT) Context, 0, FALSE);

    HGM_EXITPROC(FILE_IOCTL|HGM_FEXIT, "HGM_PnpComplete", ntStatus);

    return ntStatus;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   NTSTATUS  | HGM_Power |
 *
 *          The power dispatch routine.
 *          <nl>This driver does not recognize power IRPS.  It merely sends them down,
 *          unmodified to the next device on the attachment stack.
 *          As this is a POWER irp, and therefore a special irp, special power irp
 *          handling is required. No completion routine is required.
 *
 *  @parm   IN PDEVICE_OBJECT | DeviceObject |
 *
 *          Pointer to the device object.
 *
 *  @parm   IN PIRP | Irp |
 *
 *          Pointer to an I/O request packet.
 *
 *
 *  @rvalue   STATUS_SUCCESS | success
 *  @rvalue   ???            | Return from PoCallDriver()
 *
 *****************************************************************************/
NTSTATUS INTERNAL
    HGM_Power
    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION  DeviceExtension;
    NTSTATUS           ntStatus;

    PAGED_CODE ();

    HGM_DBGPRINT(FILE_PNP | HGM_FENTRY,\
                   ("Enter HGM_Power(DeviceObject=0x%x,Irp=0x%x)",DeviceObject, Irp));

    DeviceExtension = GET_MINIDRIVER_DEVICE_EXTENSION (DeviceObject);

    /*
     * Since we do not know what to do with the IRP, we should pass
     * it on along down the stack.
     */

    ntStatus = HGM_IncRequestCount( DeviceExtension );
    if (!NT_SUCCESS (ntStatus))
    {
        /*
         * Someone sent us another plug and play IRP after removed
         */

        HGM_DBGPRINT(FILE_PNP | HGM_ERROR,\
                       ("HGM_Power: PnP IRP after device was removed\n"));
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    } else
    {
        IoSkipCurrentIrpStackLocation (Irp);

        /*
         * Power IRPS come synchronously; drivers must call
         * PoStartNextPowerIrp, when they are ready for the next power irp.
         * This can be called here, or in the completetion routine.
         */
        PoStartNextPowerIrp (Irp);

        /*
         * NOTE!!! PoCallDriver NOT IoCallDriver.
         */
        ntStatus =  PoCallDriver (GET_NEXT_DEVICE_OBJECT (DeviceObject), Irp);

        HGM_DecRequestCount( DeviceExtension );
    }


    HGM_EXITPROC(FILE_IOCTL | HGM_FEXIT, "HGM_Power", ntStatus);
    return ntStatus;
} /* HGM_Power */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\hidgame\i386\timing.c ===
/*++

Copyright (c) 1998 - 1999  Microsoft Corporation

Module Name:

    timing.c

Abstract: This module contains routines to perform X86 specific timing functions

Environment:

    Kernel mode

@@BEGIN_DDKSPLIT
  Author:

    MarcAnd     12-Oct-1998

Revision History:


@@END_DDKSPLIT

--*/

#include "hidgame.h"

#ifdef ALLOC_PRAGMA
    #pragma alloc_text (PAGE, HGM_x86IsClockAvailable)
    #pragma alloc_text (PAGE, HGM_x86SampleClocks)
    #pragma alloc_text (PAGE, HGM_x86CounterInit)
#endif



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LARGE_INTEGER | HGM_x86ReadCounter |
 *
 *          Read the x86 CPU Time Stamp Counter
 *          This function is not pageable as it is called from DISPATCH_LEVEL
 *
 *  @parm   IN PLARGE_INTEGER | Dummy |
 *
 *          Unused parameter to match KeQueryPerformanceCounter
 *
 *  @returns LARGE_INTEGER Counter value
 *
 *****************************************************************************/
_declspec( naked ) LARGE_INTEGER EXTERNAL
    HGM_x86ReadCounter
    (
    IN      PLARGE_INTEGER      Dummy
    )
{
#define RDTSC __asm _emit 0x0f __asm _emit 0x31
    __asm RDTSC
    __asm ret SIZE Dummy
}



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOLEAN | HGM_x86IsClockAvailable |
 *
 *          Use direct processor interogation to see if the current CPU
 *          supports the RDTSC instruction.
 *
 *  @rvalue   TRUE | instruction supported
 *  @rvalue   FALSE | instruction not supported
 *
 *****************************************************************************/

BOOLEAN INTERNAL
    HGM_x86IsClockAvailable
    (
    VOID
    )
{
#define CPU_ID __asm _emit 0x0f __asm _emit 0xa2

    BOOLEAN rc = FALSE;

    __asm
    {
        pushfd                      // Store original EFLAGS on stack
        pop     eax                 // Get original EFLAGS in EAX
        mov     ecx, eax            // Duplicate original EFLAGS in ECX for toggle check
        xor     eax, 0x00200000L    // Flip ID bit in EFLAGS
        push    eax                 // Save new EFLAGS value on stack
        popfd                       // Replace current EFLAGS value
        pushfd                      // Store new EFLAGS on stack
        pop     eax                 // Get new EFLAGS in EAX
        xor     eax, ecx            // Can we toggle ID bit?
        jz      Done                // Jump if no, Processor is older than a Pentium so CPU_ID is not supported
        mov     eax, 1              // Set EAX to tell the CPUID instruction what to return
        push    ebx                 // Don't corrupt EBX
        CPU_ID                      // Get family/model/stepping/features
        pop     ebx
        test    edx, 0x00000010L    // Check if RDTSC is available
        jz      Done                // Jump if no
    }

    rc = TRUE;
Done:
    return( rc );
} /* HGM_IsRDTSCAvailable */



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   VOID | HGM_x86SampleClocks |
 *
 *          Sample the CPU time stamp counter and KeQueryPerformanceCounter
 *          and retry until the time between samples does not improve for
 *          three consecutive loops.  This should ensure that the sampling is
 *          done without interruption on the fastest time.  It does not
 *          mattter that the timing is not the same for all iterations as
 *          any interruption should cause a much larger delay than small
 *          differences in loop logic.
 *          NOTE: Do not put any debug output in this routine as the counter
 *          reported by KeQueryPerformanceCounter, depending on implementation,
 *          may 'slip' relative to the CPU counter.
 *
 *  @parm   OUT PULONGLONG | pTSC |
 *
 *          Pointer to a ULONGLONG into which sampled CPU time is stored.
 *
 *  @parm   OUT PULONGLONG | pQPC |
 *
 *          Pointer to a ULONGLONG into which sampled performance counter is
 *          stored.
 *
 *****************************************************************************/
VOID INTERNAL
    HGM_x86SampleClocks
    (
    OUT PULONGLONG  pTSC,
    OUT PULONGLONG  pQPC
    )
{
    ULONGLONG   TestQPC;
    ULONGLONG   TestTSC;
    ULONGLONG   LastQPC;
    ULONGLONG   Delta = (ULONGLONG)-1;
    int         Retries = 3;
                /*
                 *  The first iteration of the loop below should always be 
                 *  the best so far but just in case there's a timer glitch 
                 *  set Retries anyway.  If a timer is ever found to fail 
                 *  by decrementing by 1 three times in a row Delta could be 
                 *  tested and an abort return code added.
                 */

    TestQPC = KeQueryPerformanceCounter( NULL ).QuadPart;

    do
    {
        LastQPC = TestQPC;
        /*
         *  Keep the sampling as close together as we can
         */
        TestTSC = HGM_x86ReadCounter( NULL ).QuadPart;
        TestQPC = KeQueryPerformanceCounter( NULL ).QuadPart;

        /*
         *  See if this is the quickest sample yet.
         *  If it is, give it three more loops to get better still.
         */
        if( TestQPC - LastQPC < Delta )
        {
            Delta = TestQPC - LastQPC;
            Retries = 3;
            *pQPC = TestQPC;
            *pTSC = TestTSC;
        }
        else
        {
            Retries--;
        }
    } while( Retries );


} /* HGM_x86SampleClocks */



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOLEAN | HGM_x86CounterInit |
 *
 *          Detect and, if present, calibrate an x86 Time Stamp Counter.
 *
 *          Windows 98 ntkern does not export KeNumberProcessors (even though
 *          it is in wdm.h) so there is no really simple run-time test for
 *          multiple processors.  Given the remote chance of finding a system
 *          with processors that do not symetrically support RDTSC assume that
 *          the worst that can happen is very jittery axis data.
 *          Better almost-symetric-multi-processor support could be added most
 *          easily by dropping Windows 98 support and using non-WDM functions.
 *
 *  @rvalue   TRUE | specific counter function has been set up
 *  @rvalue   FALSE | no specific counter function set up, default needed
 *
 *****************************************************************************/

BOOLEAN EXTERNAL
    HGM_x86CounterInit()
{
    LARGE_INTEGER   QPCFreq;
    BOOLEAN         rf = FALSE;

    KeQueryPerformanceCounter( &QPCFreq );

    if( ( QPCFreq.HighPart == 0 )
     && ( QPCFreq.LowPart <= 10000 ) )
    {
        /*
         *  If the performance counter is too slow to use, bail as there's
         *  probably something more serious wrong.  This is only a warning 
         *  as the caller will try again to use QPC for the default and will 
         *  make more fuss then if it fails there as well.
         */
        HGM_DBGPRINT(FILE_TIMING | HGM_WARN,\
                       ("QPC unusable at reported %I64u Hz", QPCFreq.QuadPart ));
    }
    else if( !HGM_x86IsClockAvailable() )
    {
        HGM_DBGPRINT(FILE_TIMING | HGM_BABBLE,\
                       ("No RDTSC available, using %I64u Hz QPC", QPCFreq.QuadPart ));
    }
    else if( QPCFreq.HighPart )
    {
        /*
         *  If the query performance counter runs at at least 4GHz then it is
         *  probably CPU based and this is plenty fast enough.
         *  Use the QPC to reduce the risk of an extended delay causing an
         *  overflow in the scale calculations.
         */
        HGM_DBGPRINT(FILE_TIMING | HGM_BABBLE,\
                       ("QPC too fast not to use at %I64u Hz", QPCFreq.QuadPart ));
    }
    else
    {
        ULONGLONG       QPCStart;
        ULONGLONG       TSCStart;
        ULONGLONG       QPCEnd;
        ULONGLONG       TSCEnd;

        {
            LARGE_INTEGER Delay;

            Delay.QuadPart = -50000;

            /*
             *  Trivial rejections are now out of the way.  Get a pair of start
             *  time samples, then delay for long enough to allow both timers to 
             *  increase by a significant amount, then get a pair of end samples. 
             *  KeDelayExecutionThread is used to delay 5ms but if the actual 
             *  delay is longer this is taken into account in the calculation.
             *  see NOTE in HGM_x86SampleClocks about debug output.
             */
            HGM_x86SampleClocks( &TSCStart, &QPCStart );

            KeDelayExecutionThread(KernelMode, FALSE, &Delay);

            HGM_x86SampleClocks( &TSCEnd, &QPCEnd );
        }

        {
            LARGE_INTEGER TSCFreq;

            HGM_DBGPRINT(FILE_TIMING | HGM_BABBLE,\
                           ("RDTSC:  Start: %I64u  End: %I64u  delta: %I64u",
                           TSCStart, TSCEnd, TSCEnd - TSCStart ));

            HGM_DBGPRINT(FILE_TIMING | HGM_BABBLE,\
                           ("QPC:  Start: %I64u  End: %I64u  delta: %I64u",
                           QPCStart, QPCEnd, QPCEnd - QPCStart ));


            TSCFreq.QuadPart = (TSCEnd - TSCStart);

            if( TSCFreq.HighPart )
            {
                /*
                 *  Somehow the delay allowed the TSC to tick more than 2^32
                 *  times so bail as that would indicate a calibration error.
                 */
                HGM_DBGPRINT(FILE_TIMING | HGM_BABBLE,\
                           ("Clock sample failed, using %I64u Hz QPC", 
                           QPCFreq.QuadPart ));
            }
            else
            {
                /*
                 *  QPC_freq / QPC_sampled = TSC_freq / TSC_sampled
                 *  so
                 *  TSC_sampled * QPC_freq / QPC_sampled = TSC_freq
                 */

                TSCFreq.QuadPart *= QPCFreq.QuadPart;

                HGM_DBGPRINT(FILE_TIMING | HGM_BABBLE,\
                               ("TSC_sampled * QPC_freq: %I64u", TSCFreq.QuadPart ));

                TSCFreq.QuadPart /= QPCEnd - QPCStart;

                if( TSCFreq.LowPart < HIDGAME_SLOWEST_X86_HZ )
                {
                    /*
                     *  If the value for TSC is less than the slowest CPU we 
                     *  allow something probably went wrong in the calibration.
                     */
                    HGM_DBGPRINT(FILE_TIMING | HGM_ERROR,\
                               ("TSC calibrated at %I64u Hz is too slow to be believed", 
                               TSCFreq.QuadPart ));
                }
                else
                {
                    /*
                     *  The TSC looks usable so set up the global variables.
                     */
                    rf = TRUE;

                    Global.ReadCounter = (COUNTER_FUNCTION)&HGM_x86ReadCounter;

                    /*
                     *  There's no point in calibrating the TSC against QPC if QPC
                     *  is just returning TSC.  So if the reported QPC frequency
                     *  is large enough to be a CPU counter and the sampled QPC is
                     *  very marginally larger than the TSC both before and after
                     *  the poll then just use the QPCFreq.
                     */

                    /*
                     *  HGM_x86SampleClocks always sets QPC last so it must be larger.
                     *  The QPC frequency divided by 2^20 is a little less than 1ms
                     *  worth of ticks which should be a reasonable test.
                     */
                    if( ( QPCFreq.LowPart > HIDGAME_SLOWEST_X86_HZ )
                      &&( QPCStart > TSCStart )
                      &&( QPCEnd   > TSCEnd )
                      &&( TSCEnd   > QPCStart )
                      &&( TSCStart + (QPCFreq.LowPart>>20) > QPCStart )
                      &&( TSCEnd   + (QPCFreq.LowPart>>20) > QPCEnd ) )
                    {
                        Global.CounterScale = CALCULATE_SCALE( QPCFreq.QuadPart );
                        HGM_DBGPRINT(FILE_TIMING | HGM_BABBLE,\
                                       ("RDTSC at %I64u Hz assumed from QPC at %I64u Hz with scale %d",
                                       TSCFreq.QuadPart, QPCFreq.QuadPart, Global.CounterScale ));
                    }
                    else
                    {
                        Global.CounterScale = CALCULATE_SCALE( TSCFreq.QuadPart );
                        HGM_DBGPRINT(FILE_TIMING | HGM_BABBLE,\
                                       ("RDTSC calibrated at %I64u Hz from QPC at %I64u Hz with scale %d",
                                       TSCFreq.QuadPart, QPCFreq.QuadPart, Global.CounterScale ));
                    }
                }
            }
        }
    }

    return rf;
} /* HGM_x86CounterInit */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\dualmode.cpp ===
#define __DEBUG_MODULE_IN_USE__ CIC_DUALMODE_CPP
#include "stdhdrs.h"

//@doc
//	@doc
/**********************************************************************
*
*	@module	DualMode.cpp	|
*
*	Implements functions that differ in USER and KERNEL modes.
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	DualMode	|
*
**********************************************************************/

#ifdef COMPILE_FOR_WDM_KERNEL_MODE

//
//	@topic Overriding global new and delete |
//			The global new and delete are overriden to require
//			a placement argument specify the pool memory comes from.
//			The POOL_TYPE structure is defined in the NTDDK specifying
//			the page.<nl>
//			The user mode version ignores the POOL_TYPE (but must typedef it)
//			and uses the global new and delete.
//
//			The debug version of new uses ExAllocatePoolWithTag (the tag is CICN),
//			the release version uses ExAllocatePool

#if (DBG==1)
void * __cdecl operator new(unsigned int uSize, POOL_TYPE poolType, LPSTR lpszFile, unsigned int uLine)
{
	void *pvRet;
	pvRet = ExAllocatePoolWithTag(poolType, uSize, 'NCIC');
	DbgPrint("CIC: new allocating %d bytes at 0x%0.8x, called from file: %s, line:%d\n", uSize, pvRet, lpszFile, uLine);
	return pvRet;
}
#else
void * __cdecl operator new(unsigned int uSize, POOL_TYPE poolType)
{
	return ExAllocatePool(poolType, uSize);
}
#endif

void __cdecl operator delete (void * pvRawMemory)
{
#if (DBG==1)
	DbgPrint("CIC: delete called for 0x%0.8x\n", pvRawMemory);
#endif
	if( NULL == pvRawMemory ) return;
	ExFreePool( pvRawMemory );
	return;
}


#else //END WDM KERNEL MODE SECTION




#endif	//END USER MODE SECTION
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\dualmode.h ===
#ifndef __DUALMODE_H__
#define __DUALMODE_H__
//	@doc
/**********************************************************************
*
*	@module	DualMode.h	|
*
*	Contains functions/variables etc. for writing components that can
*	be run in user or kernel mode.
*	
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	DualMode	|
*			Provides special services for drivers that differ from
*			those of Ring3.  Particularly memory allocation.
*			This file should be included for any component library that
*			must be source compatible for WDM kernel, VxD ring 0, or
*			Win32 User mode.  Two compile time constants control the
*			compilation.<nl>
*			COMPILE_FOR_WDM_KERNEL_MODE is defined if the WDM version is needed.
*			COMPILE_FOR_VXD_RING0_MODE is defined if the VxD version is needed.<nl>
*			NOTIMPL<nl>
*			NOTIMPL - VxD version will only be done as a contigency<nl>
*			NOTIMPL<nl>

*			Neither is defined for user mode.<nl>
**********************************************************************/

#ifdef COMPILE_FOR_WDM_KERNEL_MODE

//
//	@topic Overriding global new and delete |
//			The global new and delete are overriden to require
//			a placement argument specify the pool memory comes from.
//			The POOL_TYPE structure is defined in the NTDDK specifying
//			the page.<nl>
//			The user mode version ignores the POOL_TYPE (but must typedef it)
//			and uses the global new and delete.
//
#if (DBG==1)
extern void * __cdecl operator new(unsigned int uSize, POOL_TYPE poolType, LPSTR lpszFile, unsigned int uLine);
#define EXTRANEWPARAMS ,__FILE__,__LINE__
#else
extern void * __cdecl operator new(unsigned int uSize, POOL_TYPE poolType);
#define EXTRANEWPARAMS
#endif

extern void __cdecl operator delete (void * pvRawMemory);

namespace DualMode
{
	template<class Type>
	Type *Allocate(POOL_TYPE poolType)
	{
		return new (poolType EXTRANEWPARAMS) Type;

	}
	template<class Type>
	void Deallocate(Type *pMemory)
	{
		delete pMemory;
	}

	template<class Type>
	Type *AllocateArray(POOL_TYPE poolType, ULONG ulLength)
	{
		return new (poolType EXTRANEWPARAMS) Type[ulLength];
	}
	template<class Type>
	void DeallocateArray(Type *pMemory)
	{
		delete [] pMemory;
	}

	inline void BufferCopy(PVOID pvDest, PVOID pvSrc, ULONG ulByteCount)
	{
		RtlCopyMemory(pvDest, pvSrc, ulByteCount);
	}
};



#if (DBG==1)

#define WDM_NON_PAGED_POOL (NonPagedPool, __FILE__, __LINE__)
#define WDM_PAGED_POOL (PagedPool, __FILE__, __LINE__)

#else

#define WDM_NON_PAGED_POOL (NonPagedPool)
#define WDM_PAGED_POOL (PagedPool)

#endif

#else //END WDM KERNEL MODE SECTION

typedef int POOL_TYPE;
#define NonPagedPool					0
#define NonPagedPoolMustSucceed			0
#define	NonPagedPoolCacheAligned		0
#define NonPagedPoolCacheAlignedMustS	0
#define PagedPool						0
#define	PagedPoolCacheAligned			0

namespace DualMode
{
	template<class Type>
	Type *Allocate(POOL_TYPE)
	{
		return new Type;
	}
	
	template<class Type>
	void Deallocate(Type *pMemory)
	{
		delete pMemory;
	}
	template<class Type>
	Type *AllocateArray(POOL_TYPE, ULONG ulLength)
	{
		return new Type[ulLength];
	}
	template<class Type>
	void DeallocateArray(Type *pMemory)
	{
		delete [] pMemory;
	}
	
	inline void BufferCopy(PVOID pvDest, PVOID pvSrc, ULONG ulByteCount)
	{
		memcpy(pvDest, pvSrc, ulByteCount);
	}
};


//
//	Macros for interpreting NTSTATUS codes
//
#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
#define NT_INFORMATION(Status) ((ULONG)(Status) >> 30 == 1)
#define NT_WARNING(Status) ((ULONG)(Status) >> 30 == 2)
#define NT_ERROR(Status) ((ULONG)(Status) >> 30 == 3)
#define WDM_NON_PAGED_POOL
//
//	Debug macro definitions
//
#ifndef ASSERT
#define ASSERT _ASSERTE
#endif

#endif	//END USER MODE SECTION

#endif //__DUALMODE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\devicedescriptions.cpp ===
#define __DEBUG_MODULE_IN_USE__ CIC_DEVICEDESCRIPTIONS_CPP
#include "stdhdrs.h"
//	@doc
/**********************************************************************
*
*	@module	DeviceDescriptions.cpp	|
*
*	Tables for parsing HID on specific devices
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*
**********************************************************************/
using namespace ControlItemConst;

#define HID_USAGE_RESERVED (static_cast<USAGE>(0))

//
//	Freestyle Pro - Modifier Table
//
MODIFIER_ITEM_DESC	rgFSModifierItems[] =
	{
		{ HID_USAGE_PAGE_BUTTON, (USAGE)10, 0, HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC,	6, ControlItemConst::ucReportTypeInput, 0},
		{ ControlItemConst::HID_VENDOR_PAGE, ControlItemConst::HID_VENDOR_TILT_SENSOR, 0, HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC,	0, ControlItemConst::ucReportTypeInput, 0}
	};

MODIFIER_DESC_TABLE FSModifierDescTable = { 2, 1, rgFSModifierItems};

//
//	Freestyle Pro - Axes range table
//
AXES_RANGE_TABLE FSAxesRangeTable = { -512L, 0L, 511L, -512L, 0L, 511L, -256L, 256L, -256L, 256L};  

//
//	Freestyle Pro - List of ControlItemDesc
//
RAW_CONTROL_ITEM_DESC rgFSControlItems[] =
	{
		{1L, usButton,		HID_USAGE_PAGE_BUTTON,		1,	HID_USAGE_GENERIC_POINTER,	HID_USAGE_PAGE_GENERIC,	
			1,	4,	&FSModifierDescTable, (USAGE)1,						(USAGE)4,				0L, 0L},
		{2L, usButton,		HID_USAGE_PAGE_BUTTON,		0,	HID_USAGE_GENERIC_JOYSTICK,	HID_USAGE_PAGE_GENERIC,	
			1,	6,	&FSModifierDescTable, (USAGE)5,						(USAGE)9,				0L,	0L},
		{3L, usPOV,			HID_USAGE_PAGE_GENERIC,		1,	HID_USAGE_GENERIC_POINTER,	HID_USAGE_PAGE_GENERIC,
			4,	1,	&FSModifierDescTable, HID_USAGE_GENERIC_HATSWITCH,	HID_USAGE_RESERVED,		0L,	7L},
		{4L, usPropDPAD,	HID_USAGE_PAGE_GENERIC,		1,	HID_USAGE_GENERIC_POINTER,	HID_USAGE_PAGE_GENERIC,
		    10,	1,	&FSModifierDescTable, HID_USAGE_GENERIC_X,			HID_USAGE_GENERIC_Y, (LONG)&FSAxesRangeTable, 0L},
		{5L, usThrottle,	HID_USAGE_PAGE_GENERIC,		0,	HID_USAGE_GENERIC_JOYSTICK,	HID_USAGE_PAGE_GENERIC,
			6,	1,	&FSModifierDescTable, HID_USAGE_GENERIC_SLIDER,		HID_USAGE_RESERVED,		-32L,	31L}
	};

//
//	Precision Pro - Modifier Table
//
MODIFIER_ITEM_DESC	rgPPModifierItems[] =
	{
		{ HID_USAGE_PAGE_BUTTON, (USAGE)9, 0, HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC,	5, ControlItemConst::ucReportTypeInput, 0}
	};

MODIFIER_DESC_TABLE PPModifierDescTable = { 1, 1, rgPPModifierItems};

//
//	Precision Pro - Axes range table
//
AXES_RANGE_TABLE PPAxesRangeTable = { -512L, 0L, 511L, -512L, 0L, 511L, -256L, 256L, -256L, 256L};  

//
//	Precision Pro - List of ControlItemDesc
//
RAW_CONTROL_ITEM_DESC rgPPControlItems[] =
	{
		{1L, usButton,		HID_USAGE_PAGE_BUTTON,		1,	HID_USAGE_GENERIC_POINTER,	HID_USAGE_PAGE_GENERIC,	
			1,	4,	&PPModifierDescTable, (USAGE)1,						(USAGE)4,				0L,	0L},
		{2L, usButton,		HID_USAGE_PAGE_BUTTON,		0,	HID_USAGE_GENERIC_JOYSTICK,	HID_USAGE_PAGE_GENERIC,	
			1,	5,	&PPModifierDescTable, (USAGE)5,						(USAGE)8,				0L,	0L},
		{3L, usPOV,			HID_USAGE_PAGE_GENERIC,		1,	HID_USAGE_GENERIC_POINTER,	HID_USAGE_PAGE_GENERIC,
			4,	1,	&PPModifierDescTable, HID_USAGE_GENERIC_HATSWITCH,	HID_USAGE_RESERVED,		0L,	7L},
		{4L, usAxes,		HID_USAGE_PAGE_GENERIC,		1,	HID_USAGE_GENERIC_POINTER,	HID_USAGE_PAGE_GENERIC,
		   10,	1,	&PPModifierDescTable, HID_USAGE_GENERIC_X,			HID_USAGE_GENERIC_Y,	(LONG)&PPAxesRangeTable, 0L},
		{5L, usRudder,		HID_USAGE_PAGE_GENERIC,		1,	HID_USAGE_GENERIC_POINTER,	HID_USAGE_PAGE_GENERIC,
		   6,	1,	&PPModifierDescTable, HID_USAGE_GENERIC_RZ,			HID_USAGE_RESERVED,		-32L,	31L},
		{6L, usThrottle,	HID_USAGE_PAGE_GENERIC,		0,	HID_USAGE_GENERIC_JOYSTICK,	HID_USAGE_PAGE_GENERIC,
		   7,	1,	&PPModifierDescTable, HID_USAGE_GENERIC_SLIDER,		HID_USAGE_RESERVED,		-64L,	63L}
	};

//
//	Zorro - Modifier Table
//
MODIFIER_ITEM_DESC	rgZRModifierItems[] =
	{
		{ HID_USAGE_PAGE_BUTTON, (USAGE)9, 0, HID_USAGE_GENERIC_GAMEPAD, HID_USAGE_PAGE_GENERIC,	9, ControlItemConst::ucReportTypeInput, 0},
		{ ControlItemConst::HID_VENDOR_PAGE, ControlItemConst::HID_VENDOR_PROPDPAD_MODE, 0, HID_USAGE_GENERIC_GAMEPAD, HID_USAGE_PAGE_GENERIC,	1, ControlItemConst::ucReportTypeInput, 0},
		{ ControlItemConst::HID_VENDOR_PAGE, ControlItemConst::HID_VENDOR_PROPDPAD_SWITCH, 2, 0, ControlItemConst::HID_VENDOR_PAGE, 1, ControlItemConst::ucReportTypeFeatureRW, 0}
	};

MODIFIER_DESC_TABLE ZRModifierDescTable = { 3, 1, rgZRModifierItems};

//
//	Zorro - Axes range table
//
AXES_RANGE_TABLE ZRAxesRangeTable = { -128L, 0L, 127L, -128L, 0L, 127L, -64L, 64L, -64L, 64L};  

//
//	Zorro - List of ControlItemDesc
//
RAW_CONTROL_ITEM_DESC rgZRControlItems[] =
	{
		{1L, usButton,		HID_USAGE_PAGE_BUTTON,		0,	HID_USAGE_GENERIC_GAMEPAD,	HID_USAGE_PAGE_GENERIC,	
			1,	9,	&ZRModifierDescTable, (USAGE)1,						(USAGE)8,				0L,	0L},
		{2L, usPropDPAD,		HID_USAGE_PAGE_GENERIC,		1,	HID_USAGE_GENERIC_POINTER,	HID_USAGE_PAGE_GENERIC,
		    8,	1,	&ZRModifierDescTable, HID_USAGE_GENERIC_X,			HID_USAGE_GENERIC_Y,	(LONG)&ZRAxesRangeTable, 0L}
	};


//
//	Zulu - Modifier Table
//
MODIFIER_ITEM_DESC	rgZLModifierItems[] =
	{
		{ HID_USAGE_PAGE_BUTTON, (USAGE)9, 0, HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC,	9, ControlItemConst::ucReportTypeInput, 0}
	};

MODIFIER_DESC_TABLE ZLModifierDescTable = { 1, 1, rgZLModifierItems};

//
//	Zulu - Axes range table
//
AXES_RANGE_TABLE ZLAxesRangeTable = { -512L, 0L, 511L, -512L, 0L, 511L, -256L, 256L, -256L, 256L};  

//
//	Zulu - List of ControlItemDesc
//
RAW_CONTROL_ITEM_DESC rgZLControlItems[] =
	{
		{1L, usButton,	HID_USAGE_PAGE_BUTTON,		0,	HID_USAGE_GENERIC_JOYSTICK,	HID_USAGE_PAGE_GENERIC,	
			1,	9,	&ZLModifierDescTable, (USAGE)1,	(USAGE)8,	0L,	0L},
		{2L, usPOV,		HID_USAGE_PAGE_GENERIC,		0,	HID_USAGE_GENERIC_JOYSTICK,	HID_USAGE_PAGE_GENERIC,
			4,	1,	&ZLModifierDescTable, HID_USAGE_GENERIC_HATSWITCH,	HID_USAGE_RESERVED,		0L,	7L},
		{3L, usAxes,	HID_USAGE_PAGE_GENERIC,		1,	HID_USAGE_GENERIC_POINTER,	HID_USAGE_PAGE_GENERIC,
		   10,	1,	&ZLModifierDescTable, HID_USAGE_GENERIC_X,			HID_USAGE_GENERIC_Y,	(LONG)&ZLAxesRangeTable, 0L},
		{4L, usZoneIndicator,	ControlItemConst::HID_VENDOR_PAGE,		0,	HID_USAGE_GENERIC_JOYSTICK,	HID_USAGE_PAGE_GENERIC,
			1,	2,	&ZLModifierDescTable, HID_VENDOR_ZONE_INDICATOR_X,	HID_USAGE_RESERVED,	0x00000003,	0L}
	};

//
//	ZepLite - Modifier Table
//
MODIFIER_ITEM_DESC	rgZPLModifierItems[] =
	{
		{ ControlItemConst::HID_VENDOR_PAGE, ControlItemConst::HID_VENDOR_PEDALS_PRESENT, 0, HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 1, ControlItemConst::ucReportTypeInput, 0}
	};
MODIFIER_DESC_TABLE ZPLModifierDescTable = { 1, 0, rgZPLModifierItems};

//
//	ZepLite - List of ControlItemDesc
//
RAW_CONTROL_ITEM_DESC rgZPLControlItems[] =
	{
		{1L, usButton,	HID_USAGE_PAGE_BUTTON,		0,	HID_USAGE_GENERIC_JOYSTICK,	HID_USAGE_PAGE_GENERIC,	
			1,	8,	&ZPLModifierDescTable, (USAGE)1,	(USAGE)8,	0L,	0L},
		{2L, usPedal,	HID_USAGE_PAGE_GENERIC,		0,	HID_USAGE_GENERIC_JOYSTICK,	HID_USAGE_PAGE_GENERIC,
			6,	1,	&ZPLModifierDescTable, HID_USAGE_GENERIC_Y,	HID_USAGE_RESERVED,		0L,	63L},
		{3L, usPedal,	HID_USAGE_PAGE_GENERIC,		0,	HID_USAGE_GENERIC_JOYSTICK,	HID_USAGE_PAGE_GENERIC,
		    6,	1,	&ZPLModifierDescTable, HID_USAGE_GENERIC_RZ,	HID_USAGE_RESERVED,		0L, 63L},
		{4L, usWheel,	HID_USAGE_PAGE_GENERIC,		0,	HID_USAGE_GENERIC_JOYSTICK,	HID_USAGE_PAGE_GENERIC,
		   10,	1,	&ZPLModifierDescTable, HID_USAGE_GENERIC_X,	HID_USAGE_RESERVED,		-512L, 511L},
	};

//
//	SparkyZep - Modifier Table
//
MODIFIER_ITEM_DESC	rgSZPModifierItems[] =
	{
		{ ControlItemConst::HID_VENDOR_PAGE, ControlItemConst::HID_VENDOR_PEDALS_PRESENT, 0, HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 1, ControlItemConst::ucReportTypeInput, 1}
	};

MODIFIER_DESC_TABLE SZPModifierDescTable = { 1, 0, rgSZPModifierItems};

//
//	SparkyZep - List of ControlItemDesc
//
RAW_CONTROL_ITEM_DESC rgSZPControlItems[] =
	{
		{1L, usButton,	HID_USAGE_PAGE_BUTTON,		0,	HID_USAGE_GENERIC_JOYSTICK,	HID_USAGE_PAGE_GENERIC,	
			1,	8,	&SZPModifierDescTable, (USAGE)1,	(USAGE)8,	0L,	0L},
		{2L, usPedal,	HID_USAGE_PAGE_GENERIC,		0,	HID_USAGE_GENERIC_JOYSTICK,	HID_USAGE_PAGE_GENERIC,
			6,	1,	&SZPModifierDescTable, HID_USAGE_GENERIC_Y,	HID_USAGE_RESERVED,		0L,	63L},
		{3L, usPedal,	HID_USAGE_PAGE_GENERIC,		0,	HID_USAGE_GENERIC_JOYSTICK,	HID_USAGE_PAGE_GENERIC,
		    6,	1,	&SZPModifierDescTable, HID_USAGE_GENERIC_RZ,	HID_USAGE_RESERVED,		0L, 63L},
		{4L, usWheel,	HID_USAGE_PAGE_GENERIC,		0,	HID_USAGE_GENERIC_JOYSTICK,	HID_USAGE_PAGE_GENERIC,
		   10,	1,	&SZPModifierDescTable, HID_USAGE_GENERIC_X,	HID_USAGE_RESERVED,		-512L, 511L},
        {5L, usForceMap,HID_USAGE_PAGE_GENERIC,     0,  HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC,
        0,   0,  &SZPModifierDescTable, 0, 0, 0L, 10000L}
	};

//
// Tilt 2.0 TT2
//

//
// Mothra MOH
//
//
//	Mothra - Axes range table
//
AXES_RANGE_TABLE MOHAxesRangeTable = { 0L, 128L, 255L, 0L, 128L, 255L, 64L, 192L, 64L, 192L};  

//
//  Mothra - List of ControlItemDesc
//
RAW_CONTROL_ITEM_DESC rgMOHControlItems[] =
{
    {1L, usButton,   HID_USAGE_PAGE_BUTTON,  0,  HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 1, 8, NULL, (USAGE)1,                    (USAGE)8,            0L,                       0L},
    {2L, usAxes,     HID_USAGE_PAGE_GENERIC, 1,  HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 8, 2, NULL, HID_USAGE_GENERIC_X,         HID_USAGE_GENERIC_Y, (LONG)&MOHAxesRangeTable, 0L},
    {3L, usRudder,   HID_USAGE_PAGE_GENERIC, 0,  HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 8, 1, NULL, HID_USAGE_GENERIC_RZ,        HID_USAGE_RESERVED,  0L,                       255L},
    {4L, usPOV,      HID_USAGE_PAGE_GENERIC, 0,  HID_USAGE_GENERIC_POINTER,  HID_USAGE_PAGE_GENERIC, 4, 1, NULL, HID_USAGE_GENERIC_HATSWITCH, HID_USAGE_RESERVED,  0L,                       7L},
    {5L, usThrottle, HID_USAGE_PAGE_GENERIC, 0,  HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 7, 1, NULL, HID_USAGE_GENERIC_SLIDER,    HID_USAGE_RESERVED,  0L,                       255L}
};

//
// Godzilla GOD
// Ungraciously ripped from Mothra!
// TODO: The force feedback stuff needs to be added by MCOILL
//
//	Godzilla - Axes range table
//
AXES_RANGE_TABLE GODAxesRangeTable = { -512L, 0L, 511L, -512L, 0L, 511L, -256L, 256L, -256L, 256L};  

//
//  Godzilla - List of ControlItemDesc
//
RAW_CONTROL_ITEM_DESC rgGODControlItems[] =
{
    {1L, usButton,		HID_USAGE_PAGE_BUTTON,  0, HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 1, 8, NULL, (USAGE)1,                    (USAGE)8,            0L,                       0L},
    {2L, usAxes,		HID_USAGE_PAGE_GENERIC, 1, HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 10, 2, NULL, HID_USAGE_GENERIC_X,         HID_USAGE_GENERIC_Y, (LONG)&GODAxesRangeTable, 0L},
    {3L, usRudder,		HID_USAGE_PAGE_GENERIC, 0, HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 6, 1, NULL, HID_USAGE_GENERIC_RZ,        HID_USAGE_RESERVED,  -32L, 31L},
    {4L, usPOV,			HID_USAGE_PAGE_GENERIC, 0, HID_USAGE_GENERIC_POINTER,  HID_USAGE_PAGE_GENERIC, 4, 1, NULL, HID_USAGE_GENERIC_HATSWITCH,	HID_USAGE_RESERVED,  0L, 7L},
    {5L, usThrottle,	HID_USAGE_PAGE_GENERIC, 0, HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 7, 1, NULL, HID_USAGE_GENERIC_SLIDER,    HID_USAGE_RESERVED,  0L, 127L},
	{6L, usForceMap,	HID_USAGE_PAGE_GENERIC, 0, HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 0, 0, NULL, 0, 0, 0L, 10000L }
};

//
//	Attila - Modifier Table ATT
//
// There are three shift buttons.
MODIFIER_ITEM_DESC	rgATTModifierItems[] =
	{
		{ HID_USAGE_PAGE_BUTTON, (USAGE) 9, 0, HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 15, ControlItemConst::ucReportTypeInput, 0},
		{ HID_USAGE_PAGE_BUTTON, (USAGE)10, 0, HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 15, ControlItemConst::ucReportTypeInput, 0},
		{ HID_USAGE_PAGE_BUTTON, (USAGE)11, 0, HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 15, ControlItemConst::ucReportTypeInput, 0}
	};

MODIFIER_DESC_TABLE ATTModifierDescTable = { 3, 3, rgATTModifierItems};

//
//	Attila - Axes range table
//
//  These may need changes.  I found this in the control panel calibration window.
DUALZONE_RANGE_TABLE	ATTXYZoneRangeTable = { { -512L, -512L }, { 0L, 0L }, { 511L, 511L}, {70L, 70L} };
DUALZONE_RANGE_TABLE	ATTRudderZoneRangeTable = { {-512L, 0L}, { 0L, 0L}, { 511L, 0L }, {70L, 0L} };

//
//  Attila - List of ControlItemDesc
//
RAW_CONTROL_ITEM_DESC rgATTControlItems[] =
    {
        {1L, usButton,  HID_USAGE_PAGE_BUTTON,      0,  HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 
            1,  15, &ATTModifierDescTable, (USAGE)1,    (USAGE)6,   0L, 0L},
        {2L, usButton,  HID_USAGE_PAGE_BUTTON,      0,  HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 
            1,  15, NULL, (USAGE)7,    (USAGE)8,   0L, 0L},
        {3L, usButton,  HID_USAGE_PAGE_BUTTON,      0,  HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC, 
            1,  15, NULL, (USAGE)0xC,    (USAGE)0xC,   0L, 0L},
		{4L, usDualZoneIndicator, HID_USAGE_PAGE_GENERIC, 1, HID_USAGE_GENERIC_POINTER, HID_USAGE_PAGE_GENERIC,
			10,  1, 0, HID_USAGE_GENERIC_X, HID_USAGE_GENERIC_Y, (LONG)&ATTXYZoneRangeTable, 8L},
  		{5L, usDualZoneIndicator, HID_USAGE_PAGE_GENERIC, 1, HID_USAGE_GENERIC_POINTER,	HID_USAGE_PAGE_GENERIC,
			10, 1,	0, HID_USAGE_GENERIC_RZ, 0, (LONG)&ATTRudderZoneRangeTable, 2L},
  		{6L, usButtonLED,	HID_USAGE_PAGE_LED,	0,	HID_USAGE_GENERIC_JOYSTICK,	HID_USAGE_PAGE_GENERIC,
		   2,	6,	&ATTModifierDescTable, USAGE(1), USAGE(ucReportTypeFeatureRW),
					ULONG((0 << 24) | (1 << 16) | (ControlItemConst::LED_DEFAULT_MODE_CORRESPOND_ON << 8) | (0)),
					0
		},
		{7L, usProfileSelectors, HID_USAGE_PAGE_BUTTON, 0, HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC,
			1,	15,	NULL, (USAGE)0xD, (USAGE)0xF, (ULONG)2, (ULONG)0
		}
    };

#undef HID_USAGE_RESERVED

//
//	List of supported devices
//
//NEWDEVICE
DEVICE_CONTROLS_DESC DeviceControlsDescList[] =
	{
		{0x045E000E, 5, rgFSControlItems, &FSModifierDescTable},	//Freestyle Pro (USB)
		{0x045E0008, 6, rgPPControlItems, &PPModifierDescTable},	//Precision Pro (USB)
		{0x045E0026, 2, rgZRControlItems, &ZRModifierDescTable},	//Zorro
		{0x045E0028, 4, rgZLControlItems, &ZLModifierDescTable},	//Zulu
		{0x045E001A, 4, rgZPLControlItems, &ZPLModifierDescTable},	//Zep Lite
		{0x045E0034, 5, rgSZPControlItems, &SZPModifierDescTable},	//SparkyZep


//		{0x045Effff, 0, NULL, NULL},                                //Tilt2    Dev11 TT2
		{0x045E0038, 5, rgMOHControlItems, NULL},                   //Mothra   Dev12 MOH
		{0x045E001B, 6, rgGODControlItems, NULL},                   //Godzilla Dev13 GOD
		{0x045E0033, 7, rgATTControlItems, &ATTModifierDescTable},  //Attila   Dev14 ATT
		{0x00000000, 0, 0x00000000}
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\controlitemcollection\controlitems.cpp ===
#define __DEBUG_MODULE_IN_USE__ CIC_CONTROLITEM_CPP
#include "stdhdrs.h"
//	@doc
/**********************************************************************
*
*	@module	ControlItems.cpp	|
*
*	Implementation of CControlItem and derivative member functions,
*	 and non-member help functions.
*
*	History
*	----------------------------------------------------------
*	Mitchell S. Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
**********************************************************************/

const LONG c_lM1X = 1;
const LONG c_lM1Y = 2;
const LONG c_lM2X = 2;
const LONG c_lM2Y = 1;


long SignExtend(long lVal, ULONG ulNumValidBits)
{
	ULONG ulMask = 1 << (ulNumValidBits-1);
	if( ulMask & lVal )
	{
		return (~(ulMask-1))|lVal;
	}
	else
	{
		return (ulMask-1)&lVal;
	}
}
long ClearSignExtension(long lVal, ULONG ulNumValidBits)
{
	ULONG ulMask = 1 << ulNumValidBits;
	return lVal&(ulMask-1);
}

void ControlItemsFuncs::Direction2XY(LONG& rlValX, LONG& rlValY, LONG lDirection, const CONTROL_ITEM_DESC& crControlItemDesc)
{
	// Check East
	if( (lDirection >= ControlItemConst::lNorthEast) && (lDirection <= ControlItemConst::lSouthEast) )
	{
		rlValX = crControlItemDesc.DPAD.pRangeTable->lMaxX;
	}
	//	Check West
	else if( (lDirection >= ControlItemConst::lSouthWest) 