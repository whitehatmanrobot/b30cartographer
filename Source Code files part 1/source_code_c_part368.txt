ica of NC %ws is hosted at the local "
                "site, but no writeable sources exist.\n",
                GetNCDN()->StringName);
        LogEvent(
            DS_EVENT_CAT_KCC,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_KCC_NO_WRITEABLE_SOURCE_FOR_GC_TOPOLOGY,
            szInsertDN(GetNCDN()),
            szInsertDN(pLocalSite->GetObjectDN()),                        
            NULL
            ); 
    }
}

    
KCC_CR_CATEGORY
KCC_CROSSREF::GetCategory()
/*++

Routine Description:

    This function examines a crossref-and-sitearrays entry and returns
    the crossref's category.
    
Returns:

    1 - Domain Crossrefs which are writeable at the local site
    2 - NDNC Crossrefs which are writeable at the local site
    3 - Domain Crossrefs which are readonly at the local site
    4 - Crossrefs which are not hosted at the local site
    5 - Schema
    6 - Config
    
--*/
{
    KCC_NC_TYPE     ncType;
     
    ASSERT_VALID(this);

    if( KCC_CR_CAT_INVALID!=m_crCategory ) {
        return m_crCategory;
    }

    ncType = GetNCType();
    
    if (KCC_NC_TYPE_CONFIG == ncType) {

        // Config comes last
        m_crCategory = KCC_CR_CAT_CONFIG;

    } else if (KCC_NC_TYPE_SCHEMA == ncType) {
        
        // Schema is penultimate
        m_crCategory = KCC_CR_CAT_SCHEMA;

    } else {
        KCC_SITE       *pLocalSite = gpDSCache->GetLocalSite();
        BOOL            fWriteableExists=FALSE, fPartialExists=FALSE;

        InitSiteArrays();

        // Determine if this NC is writeable or not in the local site.
        if( m_writeableSites.IsElementOf(pLocalSite) ) {
            fWriteableExists = TRUE;
        }
        if( m_partialSites.IsElementOf(pLocalSite) ) {
            Assert( !fWriteableExists );
            fPartialExists = TRUE;
        }

        if(!fWriteableExists && !fPartialExists) {
    
            // This crossref is not hosted in local site
            m_crCategory = KCC_CR_CAT_UNHOSTED;
    
        } else if(!fWriteableExists) {
            
            // Only a partial copy is hosted in local site.
            Assert(fPartialExists);
            
            m_crCategory = KCC_CR_CAT_PARTIAL_DOMAIN;
    
        } else if(KCC_NC_TYPE_NONDOMAIN == ncType) {
    
            m_crCategory = KCC_CR_CAT_NDNC;

        } else {
            
            // A writeable copy is hosted in local site.
            Assert(!fPartialExists);
            m_crCategory = KCC_CR_CAT_WRITEABLE_DOMAIN;
        
        }
    }
    
    return m_crCategory;
}


void
KCC_CROSSREF::BuildLinkList()
//
// Build a link-list object containing all replication links
// for this NC (cross-ref).
//
{
    // We should only build this list once, so assert if one exists already
    Assert( m_pLinkList==NULL );

    m_pLinkList = new KCC_LINK_LIST;

    if( ! m_pLinkList->Init( this->GetNCDN(), ATT_REPS_FROM ) ) {
        // If we fail to initialize the link list, just delete the list
        delete m_pLinkList;
        m_pLinkList = NULL;
    }
}

void
KCC_CROSSREF_LIST::Reset()
//
// Reset member variables to their pre-Init() state.
//
{
    m_fIsInitialized  = FALSE;
    m_ccref           = 0;
    m_pcref           = NULL;
    // Default to the lowest version we support
    m_dwForestVersion = DS_BEHAVIOR_VERSION_MIN;
}

BOOL
KCC_CROSSREF_LIST::IsValid()
//
// Is this object internally consistent?
//
{
    return m_fIsInitialized;
}


int __cdecl
KCC_CROSSREF_LIST::CompareCrossrefs(
    const void *p1,
    const void *p2
    )
/*++

Routine Description:

    This function takes two crossref objects and compares them.
    We want to sort the crossrefs by (category,GUID). For a definition
    of crossref category, see kcccref.hxx.
    
Returns:

    <0  If p1 should come first
    0   Never (only if there are duplicates)
    >0  If p2 should come first
    
--*/
{
    KCC_CROSSREF    *pcr1, *pcr2;
    int              category1, category2, result;

    pcr1 = (KCC_CROSSREF*) p1;
    pcr2 = (KCC_CROSSREF*) p2;
    ASSERT_VALID(pcr1);
    ASSERT_VALID(pcr2);

    category1 = pcr1->GetCategory();
    category2 = pcr2->GetCategory();

    if( category1 < category2 ) {
        return -1;
    } else if( category1 > category2 ) {
        return 1;
    }

    result = CompareCrossRefIndirectByNCDN(&pcr1,&pcr2);
    if(0==result) {
        Assert(p1==p2 && "Duplicate Crossref Detected!" );
    }

    return result;
}


BOOL
KCC_CROSSREF_LIST::Init()
//
// Initialize the collection from the set of Cross-Ref DS objects
// that are direct children of the CN=Partitions,CN=Configuration,...
// container.
//
// Only enabled crossRefs (i.e. ones with the Enabled attribute either
// missing or TRUE) are acceptable.
//
{
    ATTR      rgPartAttrs[] =
    {
        { ATT_MS_DS_BEHAVIOR_VERSION,  { 0, NULL } }
    };
    ATTR      rgAttrs[] =
    {
        { ATT_NC_NAME,  { 0, NULL } },
        { ATT_SYSTEM_FLAGS,  { 0, NULL } },
        { ATT_MS_DS_NC_REPLICA_LOCATIONS,  { 0, NULL } },
    };

    ENTINFSEL PartSel =
    {
        EN_ATTSET_LIST,
        { sizeof( rgPartAttrs )/sizeof( rgPartAttrs[ 0 ] ), rgPartAttrs },
        EN_INFOTYPES_TYPES_VALS
    };
    ENTINFSEL Sel =
    {
        EN_ATTSET_LIST,
        { sizeof( rgAttrs )/sizeof( rgAttrs[ 0 ] ), rgAttrs },
        EN_INFOTYPES_TYPES_VALS
    };


    ULONG               dirError;
    FILTER              FilterTop, FilterCref, FilterNotDisabled, FilterDisabled;
    SEARCHRES *         pResults;
    ENTINFLIST *        pEntInfList;
    NTSTATUS            status;
    DWORD               cbName = 0;
    DSNAME             *pdnPartitions = NULL, *pdnCrossrefCat = NULL;
    READRES *           pPartResults;
    ATTRBLOCK *         pAttrBlock;
    BOOL                bDisabled = 0;


    status = GetConfigurationName(
                        DSCONFIGNAME_PARTITIONS,
                        &cbName,
                        pdnPartitions);
    Assert(STATUS_BUFFER_TOO_SMALL == status);
    pdnPartitions = (DSNAME *) new BYTE[ cbName ];
    status = GetConfigurationName(
                        DSCONFIGNAME_PARTITIONS,
                        &cbName,
                        pdnPartitions);
    Assert(STATUS_SUCCESS == status);

    Reset();

    pdnCrossrefCat = DsGetDefaultObjCategory(CLASS_CROSS_REF);
    ASSERT( NULL!=pdnCrossrefCat );

    // Read info off of the partitions container
    // It is permissible for this attribute to be absent.
    dirError = KccRead(
        pdnPartitions,
        &PartSel,
        &pPartResults
        );
    if ( 0 == dirError )
    {
        pAttrBlock = &pPartResults->entry.AttrBlock;
        Assert(1 == pAttrBlock->attrCount);
        Assert(ATT_MS_DS_BEHAVIOR_VERSION == pAttrBlock->pAttr->attrTyp);
        Assert(1 == pAttrBlock->pAttr->AttrVal.valCount);
        Assert(pAttrBlock->pAttr->AttrVal.pAVal->valLen == sizeof( m_dwForestVersion ));

        m_dwForestVersion = *((DWORD *) pAttrBlock->pAttr->AttrVal.pAVal->pVal);
    }

    // Construct the search filter to find enabled cross-refs
    // Note that cross-refs without an 'Enabled' attribute are considered to be enabled.
    // In LDAP syntax, the filter is: (&(objectCategory=<crossref category>)(!(enabled=FALSE)))
    memset( &FilterTop, 0, sizeof( FilterTop ) );
    FilterTop.choice                       = FILTER_CHOICE_AND;
    FilterTop.FilterTypes.And.count        = 2;
    FilterTop.FilterTypes.And.pFirstFilter = &FilterCref;

    memset( &FilterCref, 0, sizeof( FilterCref ) );
    FilterCref.choice               = FILTER_CHOICE_ITEM;
    FilterCref.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    FilterCref.FilterTypes.Item.FilTypes.ava.type         = ATT_OBJECT_CATEGORY;
    FilterCref.FilterTypes.Item.FilTypes.ava.Value.valLen = pdnCrossrefCat->structLen;
    FilterCref.FilterTypes.Item.FilTypes.ava.Value.pVal   = (BYTE *) pdnCrossrefCat;
    FilterCref.pNextFilter = &FilterNotDisabled;
    
    memset( &FilterNotDisabled, 0, sizeof( FilterNotDisabled ) );
    FilterNotDisabled.choice           = FILTER_CHOICE_NOT;
    FilterNotDisabled.FilterTypes.pNot = &FilterDisabled;

    memset( &FilterDisabled, 0, sizeof( FilterDisabled ) );
    FilterDisabled.choice               = FILTER_CHOICE_ITEM;
    FilterDisabled.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    FilterDisabled.FilterTypes.Item.FilTypes.ava.type         = ATT_ENABLED;
    FilterDisabled.FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof(BOOL);
    FilterDisabled.FilterTypes.Item.FilTypes.ava.Value.pVal   = (BYTE *) &bDisabled;

    dirError = KccSearch(
        pdnPartitions,
        SE_CHOICE_IMMED_CHLDRN,
        &FilterTop,
        &Sel,
        &pResults
        );

    if ( 0 != dirError ) {
        KCC_LOG_SEARCH_FAILURE( pdnPartitions, dirError );
    } else {
        if ( 0 == pResults->count ) {
            DPRINT( 0, "No cross-ref objects found!\n" );
            KCC_EXCEPT( ERROR_DS_NCNAME_MISSING_CR_REF, 0);
        } else {
            m_pcref = new KCC_CROSSREF[ pResults->count ];

            m_ccref = 0;
            for ( pEntInfList = &pResults->FirstEntInf;
                  NULL != pEntInfList;
                  pEntInfList = pEntInfList->pNextEntInf
                )
            {
                KCC_CROSSREF * pcref;
                
                // Verify the count of search results matches the number of
                // entries in the list
                if( m_ccref>=pResults->count ) {
                    Assert( !"Inconsistent search results!" );
                    KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
                }

                pcref = &(m_pcref)[ m_ccref ];
                if ( pcref->Init( &pEntInfList->Entinf ) ) {
                    m_ccref++;
                }
            }
        }

        m_fIsInitialized = TRUE;
    }

    delete[] pdnPartitions;
    return m_fIsInitialized;
}

    
VOID
KCC_CROSSREF_LIST::Sort()
//
// Sort crossrefs by (Category,GUID)
//  
{
    ASSERT_VALID( this );
    qsort( m_pcref, m_ccref, sizeof(KCC_CROSSREF), CompareCrossrefs );
}


KCC_CROSSREF *
KCC_CROSSREF_LIST::GetCrossRefForNC(
    IN  DSNAME *    pdnNC
    )
//
// Retrieve the KCC_CROSSREF object associated with the given NC.
//
{
    KCC_CROSSREF * pcref = NULL;

    ASSERT_VALID( this );

    for ( DWORD icref = 0; icref < m_ccref; icref++ )
    {
        if ( NameMatched( pdnNC, m_pcref[ icref ].GetNCDN() ) )
        {
            pcref = &m_pcref[ icref ];
            break;
        }
    }

    return pcref;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\kccduapi.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kccduapi.cxx

ABSTRACT:

    Wrappers for NTDSA.DLL Dir* calls.

DETAILS:


CREATED:

    01/21/97    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <NTDSpchx.h>
#include "kcc.hxx"
#include "kccduapi.hxx"

#define FILENO FILENO_KCC_KCCDUAPI
#define KCC_PAGED_SEARCH_LIMIT      1000
#define KCC_PAGED_SEARCH_LIMIT_DBG  2
#define MASK_BYTE                       0xFF

// Global flag to control whether we assert on unexpected directory failures
DWORD gfKccAssertOnDirFailure = FALSE;

void
KccBuildStdCommArg(
    OUT COMMARG *   pCommArg
    )
{
    InitCommarg(pCommArg);

    pCommArg->Svccntl.SecurityDescriptorFlags = 0;
// Allow removal of non-existant values and addition of already-present values.
    pCommArg->Svccntl.fPermissiveModify       = TRUE;
}


#if DBG

#define CHECK_ENTINF(x)     CheckEntInf(x)
#define CHECK_SEARCHRES(x)  CheckSearchRes(x)

VOID
CheckEntInf(
    IN ENTINF *pEntInf
    )
//
// CheckEntInf (debug only)
// Check that an ENTINF is valid and assert otherwise.
//
{
    DWORD               iAttr, cAttr;
    ATTR                *pAttr;
    DWORD               iAttrVal;
    PVOID               pVal;

    Assert( NULL!=pEntInf );
    Assert( NULL!=pEntInf->pName );

    cAttr = pEntInf->AttrBlock.attrCount;        
    for ( iAttr=0; iAttr<cAttr; iAttr++ )
    {
        pAttr = &pEntInf->AttrBlock.pAttr[ iAttr ];
        Assert( NULL!=pAttr );

        for ( iAttrVal=0; iAttrVal<pAttr->AttrVal.valCount; iAttrVal++ )
        {
            pVal = pAttr->AttrVal.pAVal[ iAttrVal ].pVal;
            Assert( NULL!=pVal );
        }
    }
}

VOID
CheckSearchRes(
    IN SEARCHRES* pResults
    )
//
// CheckSearchRes (debug only)
// Check that a SEARCHRES is valid and assert otherwise.
//
{
    ENTINFLIST          *pEntInfList;
    DWORD               cEntInfs=0;

    // Special case: No results
    if( 0==pResults->count ) {
        return;
    }

    // Walk through the entries in the list counting them
    // and checking them
    for ( pEntInfList = &pResults->FirstEntInf;
          NULL != pEntInfList;
          pEntInfList = pEntInfList->pNextEntInf )
    {
        cEntInfs++;    
        CheckEntInf( &pEntInfList->Entinf );
    }

    // Verify that the number of entries in the list
    // is what we expect
    Assert( cEntInfs == pResults->count );
}

#else

// Do not perform the checks on free builds because these structures
// should not have errors in a customer environment.
#define CHECK_ENTINF(x)
#define CHECK_SEARCHRES(x)

#endif


ULONG
KccRead(
    IN  DSNAME *            pDN,
    IN  ENTINFSEL *         pSel,
    OUT READRES **          ppReadRes,
    IN  KCC_INCLUDE_DELETED eIncludeDeleted
    )
//
// Wrapper for DirRead().
//
{
    ULONG       dirError;
    READARG     ReadArg;

    *ppReadRes = NULL;

    RtlZeroMemory(&ReadArg, sizeof(READARG));
    ReadArg.pObject = pDN;
    ReadArg.pSel    = pSel;
    KccBuildStdCommArg( &ReadArg.CommArg );

    if ( KCC_INCLUDE_DELETED_OBJECTS == eIncludeDeleted )
    {
        ReadArg.CommArg.Svccntl.makeDeletionsAvail = TRUE;
    }

    THClearErrors();
    SampSetDsa( TRUE );
    dirError = DirRead( &ReadArg, ppReadRes );
    if( !dirError ) {
        CHECK_ENTINF( &(ppReadRes[0]->entry) );
    }

    return dirError;
}


ULONG
KccSearch(
    IN  DSNAME *            pRootDN,
    IN  UCHAR               uchScope,
    IN  FILTER *            pFilter,
    IN  ENTINFSEL *         pSel,
    OUT SEARCHRES **        ppResults,
    IN  KCC_INCLUDE_DELETED eIncludeDeleted
    )
//
// Wrapper for DirSearch().
//
{
    ULONG       dirError;
    SEARCHARG   SearchArg;

    *ppResults = NULL;

    memset(&SearchArg, 0, sizeof(SEARCHARG));
    SearchArg.pObject       = pRootDN;
    SearchArg.choice        = uchScope;     /* Base, One-Level, or SubTree */
    SearchArg.bOneNC        = TRUE;         /* KCC never needs cross-NC searches */
    SearchArg.pFilter       = pFilter;      /* pFilter describes desired objects */
    SearchArg.searchAliases = FALSE;        /* Not currently used; always FALSE */
    SearchArg.pSelection    = pSel;         /* pSel describes selected attributes */
    KccBuildStdCommArg( &SearchArg.CommArg );

    if ( KCC_INCLUDE_DELETED_OBJECTS == eIncludeDeleted )
    {
        SearchArg.CommArg.Svccntl.makeDeletionsAvail = TRUE;
    }

    THClearErrors();
    SampSetDsa( TRUE );
    dirError = DirSearch( &SearchArg, ppResults );
    if( !dirError ) {
        CHECK_SEARCHRES(*ppResults);
    }

    return dirError;
}


KCC_PAGED_SEARCH::KCC_PAGED_SEARCH(
    IN      DSNAME             *pRootDN,
    IN      UCHAR               uchScope,
    IN      FILTER             *pFilter,
    IN      ENTINFSEL          *pSel
    )
{
    // Setup the SEARCHARG structure
    this->pRootDN    = pRootDN;
    this->uchScope   = uchScope;
    this->pFilter    = pFilter;
    this->pSel       = pSel;

    // Setup the restart structure
    pRestart = NULL;
    fSearchFinished = FALSE;
}


ULONG
KCC_PAGED_SEARCH::GetResults(
    OUT SEARCHRES         **ppResults
    )
//
// Retrieve some (but possibly not all) results from a paged search.
// The caller should use IsFinished() to determine if the search is
// complete or not. If the search is already complete when this function
// is called, *ppResults is set to NULL and 0 is returned.
// The caller should call DirFreeSearchRes() on the ppResults.
//
{
    SEARCHARG   SearchArg;
    ULONG       dirError;

    // We start off with no results.
    *ppResults = NULL;

    // If the search is already finished, just return the NULL results.
    if( fSearchFinished ) {
        return 0;
    }

    // Setup the SEARCHARG structure
    memset(&SearchArg, 0, sizeof(SEARCHARG));

    SearchArg.pObject       = pRootDN;
    SearchArg.choice        = uchScope;
    SearchArg.bOneNC        = TRUE;
    SearchArg.pFilter       = pFilter;
    SearchArg.searchAliases = FALSE;        
    SearchArg.pSelection    = pSel;

    // Set up the paged-result data
    KccBuildStdCommArg( &SearchArg.CommArg );
    SearchArg.CommArg.PagedResult.fPresent = TRUE;
    SearchArg.CommArg.PagedResult.pRestart = pRestart;
#ifdef DBG
    // Use the paging code more aggresively on debug builds
    SearchArg.CommArg.ulSizeLimit = KCC_PAGED_SEARCH_LIMIT_DBG;
#else
    SearchArg.CommArg.ulSizeLimit = KCC_PAGED_SEARCH_LIMIT;
#endif
    
    THClearErrors();
    SampSetDsa( TRUE );

    // Perform the actual search operation
    dirError = DirSearch( &SearchArg, ppResults );
    if( dirError ) {
        return dirError;
    }
    CHECK_SEARCHRES(*ppResults);

    // Check if the search has finished
    if(   (NULL != ppResults[0]->PagedResult.pRestart)
       && (ppResults[0]->PagedResult.fPresent) )
    {
        pRestart = ppResults[0]->PagedResult.pRestart;
    } else {
        fSearchFinished = TRUE;
    }

    return 0;
}


ULONG
KccAddEntry(
    IN  DSNAME *    pDN,
    IN  ATTRBLOCK * pAttrBlock
    )
//
// Wrapper for DirAddEntry().
//
{
    ULONG       dirError;
    ADDARG      AddArg;
    ADDRES *    pAddRes;

    memset( &AddArg, 0, sizeof( AddArg ) );
    AddArg.pObject = pDN;
    memcpy( &AddArg.AttrBlock, pAttrBlock, sizeof( AddArg.AttrBlock ) );
    KccBuildStdCommArg( &AddArg.CommArg );

    THClearErrors();
    SampSetDsa( TRUE );
    dirError = DirAddEntry( &AddArg, &pAddRes );

    return dirError;
}


ULONG
KccRemoveEntry(
    IN  DSNAME *    pDN
    )
//
// Wrapper for DirRemoveEntry().
//
{
    ULONG       dirError;
    REMOVEARG   RemoveArg;
    REMOVERES * pRemoveRes;

    memset( &RemoveArg, 0, sizeof( RemoveArg ) );
    RemoveArg.pObject = pDN;
    KccBuildStdCommArg( &RemoveArg.CommArg );

    THClearErrors();
    SampSetDsa( TRUE );
    dirError = DirRemoveEntry( &RemoveArg, &pRemoveRes );

    return dirError;
}


ULONG
KccModifyEntry(
    IN  DSNAME *        pDN,
    IN  USHORT          cMods,
    IN  ATTRMODLIST *   pModList
    )
//
// Wrapper for DirModifyEntry().
//
{
    ULONG       dirError, waitStatus;
    MODIFYARG   ModifyArg;
    MODIFYRES * pModifyRes;

    memset(&ModifyArg, 0, sizeof(ModifyArg));
    ModifyArg.pObject = pDN;
    ModifyArg.count = cMods;
    memcpy(&ModifyArg.FirstMod, pModList, sizeof(ModifyArg.FirstMod));
    KccBuildStdCommArg(&ModifyArg.CommArg);

    SampSetDsa(TRUE);
    THClearErrors();

    dirError = DirModifyEntry(&ModifyArg, &pModifyRes);

    // Retry with exponential backoff for up to 30 seconds

    for( DWORD count = 0, timeout = 1; count < 6; count++, timeout <<= 1 ) {

        if ( (dirError != serviceError) ||
             (pModifyRes == NULL) ||
             (pModifyRes->CommRes.pErrInfo == NULL) ||
             (pModifyRes->CommRes.pErrInfo->SvcErr.problem != SV_PROBLEM_BUSY) ) {
            break;
        }
        DPRINT3( 0, "Modify #%d of %ws was BUSY, waiting %d seconds...\n",
                count, pDN->StringName, timeout );
        waitStatus = WaitForSingleObject( ghKccShutdownEvent, timeout * 1000 );
        if (waitStatus != WAIT_TIMEOUT) {
            break;
        }

        THClearErrors();
        
        dirError = DirModifyEntry(&ModifyArg, &pModifyRes);
    }

    return dirError;
}


VOID
KccLogDirOperationFailure(
    LPWSTR OperationName,
    DSNAME *ObjectDn,
    DWORD DirError,
    DWORD DsId
    )

/*++

Routine Description:

    General routine to log unexpected directory service failures

Arguments:

    OperationName - 
    ObjectDn - 
    DirError - 
    FileNumber - 
    LineNumber - 

Return Value:

    None

--*/

{
    LPSTR pszError = THGetErrorString();
    CHAR szNumber[30];

    // Put in a default error string if GetErrorString fails
    if (!pszError) {
        sprintf( szNumber, "Dir error %d\n", DirError );
        pszError = szNumber;
    }

    DPRINT4(0,
            "Unexpected %ws error on %ws @ dsid %x: %s",
            OperationName, ObjectDn->StringName, DsId, pszError);

    LogEvent8(
        DS_EVENT_CAT_KCC,
        DS_EVENT_SEV_ALWAYS,
        DIRLOG_KCC_DIR_OP_FAILURE,
        szInsertWC(OperationName),
        szInsertDN(ObjectDn),
        szInsertInt(DirError),
        szInsertHex(DsId),
        szInsertSz(pszError),
        NULL, NULL, NULL
        ); 

    if (gfKccAssertOnDirFailure) {
        Assert( !"Unexpected KCC Directory Service failure\ned ntdskcc!gfKccAssertOnDirFailure 0 and continue to disable these asserts" );
    }

} /* KccLogDirOperationFailure */

VOID
MaskAndFree(
    IN void *pData,
    IN size_t cbData,
    IN BOOL fMaskOnly
    )
/*++

Routine Description:

    Mask and free an allocation from the thread heap.
    
    If the fMaskOnly parameter is false, the allocation will be
    zeroed and freed.

    If the fMaskOnly parameter is true, the data in the allocation
    will be masked with a reversible pattern and not freed.

Arguments:

    pData       - A pointer to the data to be masked / freed
    cbData      - The length of the data to be masked / freed
    fMaskOnly   - Should the data be destroyed or just masked?

Return Value:

    None

--*/
{
    size_t i;
    unsigned char *pUchar = (unsigned char*) pData;
    
    if( fMaskOnly ) {
        for( i=0; i<cbData; i++ ) {
            pUchar[i] ^= MASK_BYTE;
        }
    } else {
        memset( pData, 0, cbData );
        THFree( pData );
    }
}

VOID
freeEntInf(
    IN ENTINF *pEntInf,
    IN BOOL fMaskOnly
    )

/*++

Routine Description:

    Free the contents of an Entinf (but not the structure itself)

Arguments:

    pEntInf     - The structure to be destroyed
    fMaskOnly   - Should the data be destroyed or just masked?

Return Value:

    None

--*/

{
    DWORD iAttr, iValue;

    Assert( pEntInf );

    if( pEntInf->pName ) {
        MaskAndFree(
            pEntInf->pName,
            pEntInf->pName->structLen,
            fMaskOnly);
    }

    for( iAttr = 0; iAttr < pEntInf->AttrBlock.attrCount; iAttr++ ) {
        ATTR *pAttr = &( pEntInf->AttrBlock.pAttr[iAttr] );
        for( iValue = 0; iValue < pAttr->AttrVal.valCount; iValue++ ) {
            ATTRVAL pAVal = pAttr->AttrVal.pAVal[iValue];
            MaskAndFree( pAVal.pVal, pAVal.valLen, fMaskOnly );
        }
        if (pAttr->AttrVal.valCount) {
            MaskAndFree( pAttr->AttrVal.pAVal, sizeof(ATTRVAL), fMaskOnly );
        }
    }
    if (pEntInf->AttrBlock.attrCount) {
        MaskAndFree( pEntInf->AttrBlock.pAttr, sizeof(ATTR), fMaskOnly );
    }
} /* KccFreeEntInf */


VOID
freeRangeInf(
    IN RANGEINF *pRangeInf,
    IN BOOL fMaskOnly
    )

/*++

Routine Description:

    Free the contents of a RangeInf

Arguments:

    pRangeInf   - The RangeInf to be destroyed
    fMaskOnly   - Should the data be destroyed or just masked?

Return Value:

    None

--*/

{
    if (pRangeInf->count) {
        MaskAndFree(
            pRangeInf->pRanges,
            sizeof(RANGEINFOITEM),
            fMaskOnly);
    }
} /* freeRangeInf */


VOID
DirFreeSearchRes(
    IN SEARCHRES    *pSearchRes,
    IN BOOL         fMaskOnly
    )

/*++

Routine Description:

BUGBUG - move into NTDSA

    Release the memory used by a SearchRes.
    SearchRes returns results allocated using the thread-heap.
    Best-effort basis.

    

Arguments:

    pSearchRes  - SEARCHRES to free
    
    fMaskOnly   - If this flag is set to true, the search results
                are not freed but rather masked so that they
                appear to be garbage to the application but the
                original contents can be recovered in the debugger.

Return Value:

    None

--*/

{
    ENTINFLIST *pEntInfList, *pNextEntInfList;
    RANGEINFLIST *pRangeInfList, *pNextRangeInfList;

    if( NULL!=pSearchRes->pBase ) {
        MaskAndFree(
            pSearchRes->pBase,
            pSearchRes->pBase->structLen,
            fMaskOnly );
    }

    if (pSearchRes->count) {
        pEntInfList = &pSearchRes->FirstEntInf;
        freeEntInf( &(pEntInfList->Entinf), fMaskOnly );

        // Do not free the first pEntInfList since it is embedded

        pNextEntInfList = pEntInfList->pNextEntInf;
        while ( NULL != pNextEntInfList ) {
            pEntInfList = pNextEntInfList;

            freeEntInf( &(pEntInfList->Entinf), fMaskOnly );

            pNextEntInfList = pEntInfList->pNextEntInf;
            MaskAndFree( pEntInfList, sizeof(ENTINFLIST), fMaskOnly );
        }
    }

    pRangeInfList = &pSearchRes->FirstRangeInf;
    freeRangeInf( &(pRangeInfList->RangeInf), fMaskOnly );
    // Do not free the first pRangeInfList since it is embedded

    pNextRangeInfList = pRangeInfList->pNext;
    while ( NULL != pNextRangeInfList ) {
        pRangeInfList = pNextRangeInfList;
        
        freeRangeInf( &(pRangeInfList->RangeInf), fMaskOnly );
            
        pNextRangeInfList = pRangeInfList->pNext;
        MaskAndFree( pRangeInfList, sizeof(RANGEINFLIST), fMaskOnly );
    }

    // Clear and free the search res itself
    MaskAndFree( pSearchRes, sizeof(SEARCHRES), fMaskOnly );

} /* KccFreeSearchRes */


VOID
DirFreeReadRes(
    IN READRES *pReadRes
    )

/*++

Routine Description:

BUGBUG - move into NTDSA

    Release the memory used by a SearchRes.
    ReadRes returns results allocated using the thread-heap.
    Best-effort basis.

Arguments:

    None

Return Value:

    None

--*/

{
    freeEntInf( &(pReadRes->entry), FALSE );
    THFree( pReadRes );

} /* KccFreeReadRes */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\kccdsa.cxx ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kccdsa.cxx

ABSTRACT:

    KCC_DSA class.

DETAILS:

    This class represents an NTDS-DSA DS object.

    NTDS-DSA DS objects hold DC-specific DS configuration information;
    e.g., which NCs are instantiated on that NC.

CREATED:

    01/21/97    Jeff Parham (jeffparh)

REVISION HISTORY:

    03/37/97    Colin Brace (ColinBr)
        
        Added the notion of a list of dsa objects

--*/

#include <ntdspchx.h>
#include <winsock.h>
#include "kcc.hxx"
#include "kcctools.hxx"
#include "kcctrans.hxx"
#include "kccdsa.hxx"
#include "kccduapi.hxx"
#include "kccsite.hxx"
#include "ismapi.h"
#include "kccconn.hxx"
#include "kccsconn.hxx"
#include "kccdynar.hxx"

#define FILENO FILENO_KCC_KCCDSA


// List of interesting attributes on DSA objects.
static ATTR AttrList[] = {
    { ATT_OBJ_DIST_NAME,              { 0, NULL } },
    { ATT_HAS_MASTER_NCS,             { 0, NULL } },
    { ATT_HAS_PARTIAL_REPLICA_NCS,    { 0, NULL } },
    { ATT_OPTIONS,                    { 0, NULL } },
    { ATT_MS_DS_BEHAVIOR_VERSION,     { 0, NULL } },
    { ATT_MS_DS_HAS_INSTANTIATED_NCS, { 0, NULL } },
    { ATT_MS_DS_HAS_MASTER_NCS,       { 0, NULL } },
    { ATT_INVOCATION_ID,              { 0, NULL } }
};

void
KCC_DSA::Reset()
//
// Set member variables to their pre-Init() state.
//
{
    m_fIsInitialized     = FALSE;
    m_pdnDSA             = NULL;
    m_cMasterNCs         = 0;
    m_ppdnMasterNCs      = NULL;
    m_cFullReplicaNCs    = 0;
    m_ppdnFullReplicaNCs = NULL;
    m_cInstantiatedNCs   = 0;
    m_pInstantiatedNCs   = NULL;
    m_pmtxRpcAddress     = NULL;
    m_pszRpcAddress      = NULL;
    m_dwOptions          = 0;
    m_pdnSite            = NULL;
    m_cNumAddrs          = 0;
    m_pAddrs             = NULL;
    m_fAddrsRead         = FALSE;
    m_pIntraSiteCnList   = NULL;
    m_pInterSiteCnList   = NULL;
    m_dwBehaviorVersion  = 0;
    memset(&m_invocationId, 0, sizeof(UUID));
}

VOID
KCC_DSA::StoreAttrIntoMasterNCList(
    IN  ATTR *         pattr
    )
//
// There are two attributes that may need to be stored in the m_ppdnMasterNCs
// list: ATT_HAS_MASTER_NCS and ATT_MS_DS_HAS_MASTER_NCS. This function does the
// actual work of storing the individual values in the list.
//
{
    DWORD       iAttrVal;
    DSNAME      *pdn;

    Assert( NULL==m_ppdnMasterNCs );
    Assert( 0==m_cMasterNCs );

    m_ppdnMasterNCs = new DSNAME*[ pattr->AttrVal.valCount ];
    m_cMasterNCs = pattr->AttrVal.valCount;
    for ( iAttrVal = 0; iAttrVal < m_cMasterNCs; iAttrVal++ )
    {
        pdn = (DSNAME *) pattr->AttrVal.pAVal[ iAttrVal ].pVal;
        m_ppdnMasterNCs[ iAttrVal ] = (DSNAME *) new BYTE [pdn->structLen];
        memcpy( m_ppdnMasterNCs[ iAttrVal ], pdn, pdn->structLen );
        // Validation: DN not semantically validated
    }
}

BOOL
KCC_DSA::InitDsa(
    IN  ATTRBLOCK*    pAttrBlock
    )
// Initialize the internal object from the ds information 
// passed in.
{
    ATTR                    *pattr;
    SYNTAX_DISTNAME_BINARY  *pdnb;
    SYNTAX_ADDRESS          *psa;
    KCC_SITE                *pSite;
    DSNAME                  *pdn, *pdnFrom, *pdnSite;
    DWORD                   iAttrVal, dwTemp, dwIT;

    Reset();

    Assert( pAttrBlock->attrCount>0 );
    Assert( NULL==m_ppdnMasterNCs );
    Assert( 0==m_cMasterNCs );

    
    for ( DWORD iAttr = 0; iAttr < pAttrBlock->attrCount; iAttr++ ) {
        pattr = &pAttrBlock->pAttr[ iAttr ];

        switch ( pattr->attrTyp )
        {
        // The ATT_HAS_MASTER_NCS and ATT_MS_DS_HAS_MASTER_NCS are treated in an
        // unusual way. If the ATT_MS_DS_HAS_MASTER_NCS attribute exists, it
        // is assumed to be more accurate than the ATT_HAS_MASTER_NCS attribute.
        
        case ATT_HAS_MASTER_NCS:
            if( NULL!=m_ppdnMasterNCs ) {
                // The list m_ppdnMasterNCs has already been initialized, meaning that
                // the ATT_MS_DS_HAS_MASTER_NCS attribute has already been stored in
                // the list. ATT_MS_DS_HAS_MASTER_NCS always trumps ATT_HAS_MASTER_NCS
                // so we just ignore this attribute.
                Assert( m_cMasterNCs>0 );
            } else {
                // The list m_ppdnMasterNCs is null. We don't know if this DSA has
                // an ATT_MS_DS_HAS_MASTER_NCS attribute. We will store ATT_HAS_MASTER_NCS
                // in the list but it might later be trumped by ATT_MS_DS_HAS_MASTER_NCS.
                StoreAttrIntoMasterNCList( pattr );
            }
            break;

        case ATT_MS_DS_HAS_MASTER_NCS:
            if( NULL!=m_ppdnMasterNCs ) {
                // The list m_ppdnMasterNCs has already been initialized, meaning that
                // the ATT_HAS_MASTER_NCS attribute has already been stored in the list.
                // ATT_MS_DS_HAS_MASTER_NCS always trumps ATT_HAS_MASTER_NCS so we 
                // delete the existing list.
                Assert( m_cMasterNCs>0 );
                delete[] m_ppdnMasterNCs;
                m_ppdnMasterNCs = NULL;
                m_cMasterNCs = 0;
            }
            StoreAttrIntoMasterNCList( pattr );

            break;

        case ATT_HAS_PARTIAL_REPLICA_NCS:
            m_ppdnFullReplicaNCs = new DSNAME* [ pattr->AttrVal.valCount ];
            m_cFullReplicaNCs = pattr->AttrVal.valCount;
            for ( iAttrVal = 0; iAttrVal < m_cFullReplicaNCs; iAttrVal++ )
            {
                pdn = (DSNAME *) pattr->AttrVal.pAVal[ iAttrVal ].pVal;
                m_ppdnFullReplicaNCs[ iAttrVal ] = (DSNAME *) new BYTE [pdn->structLen];
                memcpy( m_ppdnFullReplicaNCs[ iAttrVal ], pdn, pdn->structLen );
                // Validation: DN not semantically validated
            }
            break;

        case ATT_MS_DS_HAS_INSTANTIATED_NCS:
            m_pInstantiatedNCs = new DN_AND_INSTANCETYPE[ pattr->AttrVal.valCount ];
            m_cInstantiatedNCs = pattr->AttrVal.valCount;
            for ( iAttrVal = 0; iAttrVal < m_cInstantiatedNCs; iAttrVal++ )
            {
                pdnb = (SYNTAX_DISTNAME_BINARY *) pattr->AttrVal.pAVal[ iAttrVal ].pVal;

                // Retrieve the dsname part.
                pdn = NAMEPTR(pdnb);
                m_pInstantiatedNCs[ iAttrVal ].dn = (DSNAME *) new BYTE [pdn->structLen];
                memcpy( m_pInstantiatedNCs[ iAttrVal ].dn, pdn, pdn->structLen );
                // Validation: DN not semantically validated

                // Extract the binary blob part                
                psa = DATAPTR(pdnb);
                
                // Validation: Binary data is syntactically validated but not
                // semantically validated.
                // First check that the length of the blob is what we expect.
                Assert(psa->structLen>=2*sizeof(DWORD)); // Length + Data DWORD
                if( psa->structLen<2*sizeof(DWORD) ) {
                    KCC_EXCEPT(ERROR_DS_INTERNAL_FAILURE, 0);
                }
                
                // Copy the data to a temp variable to avoid alignment problems,
                // then convert to 'host' byte-ordering.
                memcpy(&dwTemp, &psa->byteVal[0], sizeof(DWORD));
                dwIT = (DWORD) ntohl(dwTemp);

                m_pInstantiatedNCs[ iAttrVal ].instanceType = dwIT;
            }
            break;

        case ATT_OPTIONS:
            Assert( 1 == pattr->AttrVal.valCount );
            Assert( sizeof( DWORD ) == pattr->AttrVal.pAVal->valLen );
            m_dwOptions = *( (DWORD *) pattr->AttrVal.pAVal->pVal );
            // Validation: Bitmap not semantically validated
            break;

        case ATT_OBJ_DIST_NAME:
            pdnFrom = (DSNAME *) pattr->AttrVal.pAVal->pVal;
            Assert(1 == pattr->AttrVal.valCount);
            m_pdnDSA = (DSNAME *) new BYTE [pdnFrom->structLen];
            memcpy( m_pdnDSA, pdnFrom, pdnFrom->structLen );
            // Validation: This DN should have at least 4 parts because
            // we will trim it later to get the site name.
            break;

        case ATT_MS_DS_BEHAVIOR_VERSION:
            Assert(1 == pattr->AttrVal.valCount);
            Assert(sizeof(DWORD) == pattr->AttrVal.pAVal->valLen);
            m_dwBehaviorVersion = *((DWORD *) pattr->AttrVal.pAVal->pVal);
            // Validation: DWORD not semantically validated. Any value
            // should be acceptable.
            break;

        case ATT_INVOCATION_ID:
            Assert(1 == pattr->AttrVal.valCount);
            Assert(sizeof(UUID) == pattr->AttrVal.pAVal->valLen);
            memcpy(&m_invocationId, pattr->AttrVal.pAVal->pVal, sizeof(UUID));
            // Validation: Checked for null below.
            break;

        default:
            DPRINT1( 0, "Received unrequested attribute 0x%X.\n", pattr->attrTyp );
            break;
        }
    }

    /* Check that we received the required attributes */
    if( NULL==m_pdnDSA ) {
        Assert( !"InitDsa did not receive a DN for this DSA" );
        return FALSE;
    }
    if( fNullUuid(&m_invocationId) ) {
        Assert( !"InitDsa did not receive an invocation ID for this DSA" );
        return FALSE;
    }

    /* All DSAs host must host writeable copies of Config, Schema and a Domain NC.
     * In Whistler with LVR, it is possible to have a non-local DSA with not all
     * values present yet. Other parts of the KCC require a DSA to have Config and
     * Schema so we cannot successfully initialize the KCC_DSA object. */
    if ( m_cMasterNCs < 3 ) {
        // Linked attributes do not replicate atomically. Not enough values have
        // arrived yet?
        LogEvent(
            DS_EVENT_CAT_KCC,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_KCC_OBJECT_INCOMPLETE,
            szInsertDN(m_pdnDSA),
            szInsertWC(L"hasMasterNCs"),
            0);
        m_fIsInitialized=FALSE;
        return FALSE;
    }

    /* Build this DSA's site DN */
    m_pdnSite = GetSiteDNSyntacticNoGuid( m_pdnDSA );
    pSite = gpDSCache->GetUnpopulatedSiteList()->GetSite( m_pdnSite );
    if( NULL==pSite ) {
        /* Failed to find the site by name */
        m_fIsInitialized=FALSE;
        return FALSE;
    }
    pdnSite = pSite->GetObjectDN();
    memcpy( m_pdnSite, pdnSite, pdnSite->structLen );
    Assert(NULL != m_pdnSite);
    Assert(!fNullUuid(&m_pdnSite->Guid));

    m_fIsInitialized = TRUE;
    return m_fIsInitialized;
}

DSNAME *
KCC_DSA::GetNC(
    IN  DWORD   iNC,
    OUT BOOL *  pfIsMaster
    )
//
// Get the instantiated NC at the given index (regardless of type).
//
{
    DSNAME *    pdnNC=NULL;

    ASSERT_VALID( this );

    if ( iNC < m_cMasterNCs )
    {
        pdnNC = m_ppdnMasterNCs[ iNC ];
        Assert( NULL != pdnNC );

        if ( NULL != pfIsMaster )
        {
            *pfIsMaster = TRUE;
        }
    }
    else if ( iNC - m_cMasterNCs < m_cFullReplicaNCs )
    {
        pdnNC = m_ppdnFullReplicaNCs[ iNC - m_cMasterNCs ];
        Assert( NULL != pdnNC );

        if ( NULL != pfIsMaster )
        {
            *pfIsMaster = FALSE;
        }
    }
    
    if( NULL==pdnNC )
    {
        KCC_EXCEPT(ERROR_DS_INTERNAL_FAILURE, 0);
    }

    return pdnNC;
}

BOOL
KCC_DSA::IsValid()
//
// Is this object internally consistent?
//
{
    return m_fIsInitialized;
}

MTX_ADDR *
KCC_DSA::GetMtxAddr(
    IN  KCC_TRANSPORT * pTransport
    )
//
// Get the mail or RPC network address of this server.
//
{
    ATTRTYP     att;
    MTX_ADDR *  pmtx = NULL;
    DWORD       iAddr;

    ASSERT_VALID( this );

    if (NULL == pTransport) {
        att = ATT_DNS_HOST_NAME;
    }
    else {
        att = pTransport->GetAddressType();
    }

    if (ATT_DNS_HOST_NAME == att) {
        // Easy -- return the cached DNS name.
        if (NULL == m_pmtxRpcAddress) {
            m_pmtxRpcAddress = GetMtxAddr(&m_pdnDSA->Guid);
        }
        
        pmtx = m_pmtxRpcAddress;
    }
    else {
        if (!m_fAddrsRead) {
            // Transport-specific addrs not yet cached.
            GetTransportSpecificAddrs();
            Assert(m_fAddrsRead);
        }

        for (iAddr = 0; iAddr < m_cNumAddrs; iAddr++) {
            if (att == m_pAddrs[iAddr].attrType) {
                // Found entry for this transport.
                pmtx = m_pAddrs[iAddr].pmtxAddr;
                Assert(NULL != pmtx);
                break;
            }
        }
    }

    return pmtx;
}

MTX_ADDR *
KCC_DSA::GetMtxAddr(
    IN  UUID *  puuidDSA
    )
//
// Get the DNS name of a server with the given UUID.
//
{
    MTX_ADDR * pmtx;

    Assert(NULL != puuidDSA);

    pmtx = MtxAddrFromTransportAddr(GetTransportAddr(puuidDSA));

    // Should fail only if out of memory.
    Assert(NULL != pmtx);
    if (NULL == pmtx) {
        KCC_MEM_EXCEPT(100);
    }

    return pmtx;
}

void
KCC_DSA::GetTransportSpecificAddrs()
//
// Read non-RPC transport-specific address(es) of the server.
//
{
    ULONG                 dirError;
    READRES *             pReadRes = NULL;
    ATTR *                pAttr;
    DWORD                 cNumAttrs;
    DWORD                 iAttr;
    ENTINFSEL             Sel;
    DSNAME *              pdnServer;
    KCC_TRANSPORT_LIST *  pTransportList = gpDSCache->GetTransportList();
    DWORD                 cNumTransports = pTransportList->GetCount();
    DWORD                 iTransport;
    DWORD                 attrType;
    ATTRBLOCK *           pAttrBlock;

    ASSERT_VALID(this);
    Assert(!m_fAddrsRead);
    Assert(0 == m_cNumAddrs);
    Assert(NULL == m_pAddrs);

    // The server object is the parent of the ntdsDSA object.
    pdnServer = (DSNAME *) new BYTE[ m_pdnDSA->structLen ];
    TrimDSNameBy(m_pdnDSA, 1, pdnServer);

    // Construct attribute selection list.  We read all server attributes
    // that are defined as a transport-specific attribute of an intersite
    // transport object, with the exception of ATT_DNS_HOST_NAME, which we
    // derive from the DSA guid.
    Assert(cNumTransports > 0);
    cNumAttrs = cNumTransports - 1;
    pAttr = new ATTR[cNumAttrs];
    
    iAttr = 0;
    for (iTransport = 0; iTransport < cNumTransports; iTransport++) {
        attrType = pTransportList->GetTransport(iTransport)->GetAddressType();
        if (ATT_DNS_HOST_NAME != attrType) {
            // We derive the DNS host name from the DSA guid -- don't need
            // to read the "real" DNS host name attribute.
            pAttr[iAttr].attrTyp = attrType;
            iAttr++;
        }
    }
    Assert(iAttr == cNumAttrs);

    Sel.attSel                 = EN_ATTSET_LIST;
    Sel.AttrTypBlock.attrCount = cNumAttrs;
    Sel.AttrTypBlock.pAttr     = pAttr;
    Sel.infoTypes              = EN_INFOTYPES_TYPES_VALS;

    dirError = KccRead(pdnServer, &Sel, &pReadRes);

    delete [] pAttr;

    if (0 != dirError) {
        if (attributeError == dirError) {
            INTFORMPROB * pprob = &pReadRes->CommRes.pErrInfo->AtrErr.FirstProblem.intprob;

            if ((PR_PROBLEM_NO_ATTRIBUTE_OR_VAL == pprob->problem)
                && (DIRERR_NO_REQUESTED_ATTS_FOUND == pprob->extendedErr)) {
                // No value for this attribute; return NULL.
                dirError = 0;
            }
        }

        if (0 != dirError) {
            // Other error; bail.
            KCC_LOG_READ_FAILURE(pdnServer, dirError);
            KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
        }
    }
    else {
        pAttrBlock = &pReadRes->entry.AttrBlock;
        Assert(pAttrBlock->attrCount <= cNumAttrs);
        
        m_pAddrs = new KCC_DSA_ADDR[pAttrBlock->attrCount];
        
        for (iAttr = 0; iAttr < pAttrBlock->attrCount; iAttr++) {
            WCHAR *     pwchAddress;    // wide, not null-terminated
            DWORD       cwchAddress;    // wide char count, excl null
            DWORD       cachAddress;    // ansi char count, excl null
            LPWSTR      pwszAddress;    // wide, null-terminated
            MTX_ADDR *  pmtxAddress;    // counted UTF8 string

            pAttr = &pAttrBlock->pAttr[iAttr];
            
            pwchAddress = (WCHAR *) pAttr->AttrVal.pAVal[0].pVal;
            cwchAddress = pAttr->AttrVal.pAVal[0].valLen / sizeof(WCHAR);
        
            Assert(0 != cwchAddress);
            // The simulator stores some strings in the directory with the null-terminator
            // Assert(L'\0' != pwchAddress[cwchAddress - 1]); // not already null-terminated

            // Convert transport-specific address (which is assumed to be a
            // Unicode string) to UTF8 (suitable for use as an MTX address).

            // ISSUE-nickhar-03/05/02: Must check for error here
            cachAddress = WideCharToMultiByte(CP_UTF8, 0L, pwchAddress,
                                              cwchAddress, NULL, 0, NULL, NULL);
    
            pmtxAddress = (MTX_ADDR *) new BYTE[MTX_TSIZE_FROM_LEN(cachAddress)];
            pmtxAddress->mtx_namelen = cachAddress + 1; // includes null-term
            WideCharToMultiByte(CP_UTF8, 0L, pwchAddress, cwchAddress,
                                (CHAR *) &pmtxAddress->mtx_name[0], cachAddress,
                                NULL, NULL);
            pmtxAddress->mtx_name[cachAddress] = '\0';

            // Null-terminate pwchAddress so it can be used as the transport address.
            pwszAddress = (LPWSTR) THReAlloc(pwchAddress,
                                             sizeof(WCHAR) * (1 + cwchAddress));
            if (NULL == pwszAddress) {
                KCC_MEM_EXCEPT(sizeof(WCHAR) * (cwchAddress + 1));
            }
            
            m_pAddrs[m_cNumAddrs].attrType = pAttr->attrTyp;
            m_pAddrs[m_cNumAddrs].pmtxAddr = pmtxAddress;
            m_pAddrs[m_cNumAddrs].pszAddr  = pwszAddress;
            m_cNumAddrs++;
        }
    }

    m_fAddrsRead = TRUE;
    delete[] pdnServer;
}

LPWSTR
KCC_DSA::GetTransportAddr(
    IN  KCC_TRANSPORT * pTransport
    )
//
// Get the mail or RPC network address of this server.
//
{
    ATTRTYP att;
    LPWSTR  pszTransportAddr = NULL;
    DWORD   iAddr;

    ASSERT_VALID( this );

    if (NULL == pTransport) {
        att = ATT_DNS_HOST_NAME;
    }
    else {
        att = pTransport->GetAddressType();
    }

    if (ATT_DNS_HOST_NAME == att) {
        // Easy -- return the cached DNS name.
        if (NULL == m_pszRpcAddress) {
            m_pszRpcAddress = GetTransportAddr(&m_pdnDSA->Guid);
        }
        pszTransportAddr = m_pszRpcAddress;
    }
    else {
        if (!m_fAddrsRead) {
            // Transport-specific addrs not yet cached.
            GetTransportSpecificAddrs();
            Assert(m_fAddrsRead);
        }

        for (iAddr = 0; iAddr < m_cNumAddrs; iAddr++) {
            if (att == m_pAddrs[iAddr].attrType) {
                // Found entry for this transport.
                pszTransportAddr = m_pAddrs[iAddr].pszAddr;
                Assert(NULL != pszTransportAddr);
                break;
            }
        }
    }

    return pszTransportAddr;
}

LPWSTR
KCC_DSA::GetTransportAddr(
    IN  UUID *  puuidDSA
    )
//
// Get the DNS name of a server with the given UUID.
//
{
    LPWSTR      pszTransportAddr;
    DSNAME      DN = {0};

    Assert(NULL != puuidDSA);
    Assert(!fNullUuid(puuidDSA));

    DN.Guid = *puuidDSA;
    DN.structLen = DSNameSizeFromLen(0);

    pszTransportAddr = GuidBasedDNSNameFromDSName(&DN);
    
    // Should fail only if out of memory.
    Assert(NULL != pszTransportAddr);
    if (NULL == pszTransportAddr) {
        KCC_MEM_EXCEPT(100);
    }

    return pszTransportAddr;
}

BOOL
KCC_DSA::IsNCInstantiated(
    IN  DSNAME *                        pdnNC,
    OUT BOOL *                          pfIsMaster OPTIONAL,
    OUT KCC_NC_COMING_TYPE *            pIsComing OPTIONAL
    )
//
// Is the given NC instantiated on this DSA?
//
// If the NC is instantiated and it is a master copy, pfIsMaster is set to
// TRUE. If it is a partial copy, pfIsMaster is set to FALSE. If the NC is
// not instantiated, pfIsMaster is unmodified.
//
// If the 'mS-DS-Has-Instantiated-NCs' attribute is present on this DSA, we
// can determine if the NC is in the process of being removed or being added.
// If the NC is in the process of being removed from this DSA ('going') then the
// NC is considered to be not instantiated at the DSA because it will be gone
// soon.
//
// If the NC is 'going' or is truly not instantiated, 'pIsComing' is set to
// KCC_NC_NOT_INSTANTIATED. If the 'mS-DS-Has-Instantiated-NCs' attribute is there,
// 'pIsComing' will be set to either KCC_NC_IS_COMING or KCC_NC_IS_NOT_COMING.
// If the attribute is not there, then we don't know, so 'pIsComing' is set to
// KCC_NC_MIGHT_BE_COMING.
//
{
    BOOL                    fFoundIt = FALSE, fIsInstantiated, fIsMaster;
    KCC_NC_COMING_TYPE      isComing = KCC_NC_MIGHT_BE_COMING;
    DWORD                   iNC, instanceType;

    ASSERT_VALID( this );

    // The list of instantiated NCs is not guaranteed to be present.
    // However, this list is our preferred method of determining if an NC
    // is instantiated because we can also use it to determine when an NC
    // is in the process of being removed or added.
    for( iNC=0; iNC<m_cInstantiatedNCs; iNC++ ) {
    
        if( !NameMatched(pdnNC, m_pInstantiatedNCs[iNC].dn) ) {
            // Wrong NC. Try the next one
            continue;
        }
        
        instanceType = m_pInstantiatedNCs[iNC].instanceType;    
        if( IT_NC_GOING & instanceType ) {
        
            // 'Going' NCs are immediately considered to be uninstantiated.
            fIsInstantiated = FALSE;

        } else {

            // Determine if the NC is still coming or completely instantiated.
            if( IT_NC_COMING & instanceType ) {
                isComing = KCC_NC_IS_COMING;
            } else {
                isComing = KCC_NC_IS_NOT_COMING;
            }

            fIsInstantiated = TRUE;
            fIsMaster = !! (instanceType & IT_WRITE);
        }
        
        fFoundIt = TRUE;
        break;
    }

    if( !fFoundIt ) {
    
        // Haven't found it yet. Look through the list of master NCs that
        // should be hosted at this DSA.
        for( iNC=0; iNC<m_cMasterNCs; iNC++ ) {       
            if( NameMatched(pdnNC, m_ppdnMasterNCs[iNC]) ) {
                fIsInstantiated = TRUE;
                fIsMaster = TRUE;
                fFoundIt = TRUE;
                break;
            }
        }

    }
    

    if( !fFoundIt ) {
    
        // No luck yet. Look through the list of partial NCs that should
        // be hosted at this DSA.
        for( iNC=0; iNC<m_cFullReplicaNCs; iNC++ ) {            
            if( NameMatched( pdnNC, m_ppdnFullReplicaNCs[iNC]) ) {
                fIsInstantiated = TRUE;
                fIsMaster = FALSE;
                fFoundIt = TRUE;
                break;
            }
        }

    }

    if( !fFoundIt ) {
        // We never found it. The NC must not be instantiated.
        fIsInstantiated = FALSE;    
    }

    // Set optional parameter pfIsComing. If the NC is not instantiated,
    // this parameter is set to KCC_NC_NOT_INSTANTIATED.
    if( NULL!=pIsComing ) {
        if( fIsInstantiated ) {
            *pIsComing = isComing;
        } else {
            *pIsComing = KCC_NC_NOT_INSTANTIATED;
        }
    }

    // Set optional parameter pfIsMaster only if the NC is instantiated.
    if( fIsInstantiated && (NULL!=pfIsMaster) ) {
        *pfIsMaster = fIsMaster;
    }

    return fIsInstantiated;
}


BOOL
KCC_DSA::IsNCHost(
    IN  KCC_CROSSREF *  pCrossRef,
    IN  BOOL            fIsLocal,
    OUT BOOL *          pfIsMaster
    )
//
// Should this DSA be included in the topology for the given NC?
//
{
    // Note that "should this DSA be included in the topology for this NC" is
    // a different question than "is this NC instantiated on this DSA."  An
    // NC may be instantiated on a DSA that should not be included in the
    // topology (e.g., a DC that was recently un-GCed but has not yet
    // completed tearing down its read-only NCs), and an NC may not yet
    // be instantiated on a DSA that should be included in the topology
    // (e.g., a recently promoted GC that has not yet instantiated read-only
    // replicas of other domains' NCs).
    //
    // Ideally for replication sources this routine should return true if and
    // only if the DSA can currently support outbound replication of the NC.
    // We deviate form the ideal for demoted & quickly re-promoted GCs, as
    // based on the contents of the config NC we cannot differentiate between
    // "normal" GCs and those GCs that can't yet support outbound GC replication
    // because they have not yet completely removed the old instantiation of
    // that NC.
    //
    // The NC instantiation requirements for local DSAs are somewhat relaxed
    // compared to those for remote DSAs, where "local" is defined as "is in the
    // same site" for inter-site topologies and "is the local DSA" for
    // intra-site topologies.  This is to allow the KCC to seed the
    // instantiation of local NCs that we allow to be instantiated after DCPROMO
    // -- e.g., so we can replicate in a read-only NC to a local GC to allow the
    // NC to be instantiated.

    BOOL fIsHost = FALSE;
    BOOL fIsMaster = FALSE;
    BOOL fIsInstantiated = IsNCInstantiated(pCrossRef->GetNCDN(), &fIsMaster);
    BOOL fWillBeInstantiated = FALSE;
    BOOL fWillBeMaster = FALSE;

    // Based on the current information in the config NC, does our policy
    // indicate that the DSA should ultimately host a writeable replica of this
    // NC?  (This is somewhat orthogonal to the question of "does this DSA
    // already host a replica of this NC," which we have already determined by
    // calling IsNCInstantiated() above.)

    // NOTE: If you change the logic here you may also need to change the logic
    // in KCC_TASK_UPDATE_REPL_TOPOLOGY::UpdateLinks to correctly infer why we
    // might have an existing replica of an NC but IsNCHost() returns FALSE.
    // (I.e., so we can log an appropriate event.)

    switch (pCrossRef->GetNCType()) {
    case KCC_NC_TYPE_SCHEMA:
    case KCC_NC_TYPE_CONFIG:
    case KCC_NC_TYPE_DOMAIN:
        // All DCs host (and have already instantiated) the config and schema
        // NCs.  DCs in the domain host (and have already instantiated) writable
        // replicas of their domain NC.
        if (fIsInstantiated && fIsMaster) {
            fWillBeInstantiated = fWillBeMaster = TRUE;
        }
        break;

    case KCC_NC_TYPE_NONDOMAIN:
        // Non-domain NC.  Hosted only by those DSAs explicitly enumerated in
        // the NC replica locations attribute of the crossRef.
        if (pCrossRef->IsDSAPresentInNCReplicaLocations(this)) {
            fWillBeInstantiated = fWillBeMaster = TRUE;
        }
        break;
    }

    // If the policy does not indicate the DSA should ultimately hold a
    // writeable replica, how about a read-only replica?
    if (!fWillBeInstantiated
        && IsGC()
        && pCrossRef->IsReplicatedToGCs()) {
        // The DSA should ultimately hold a read-only replica of the NC.
        fWillBeInstantiated = TRUE;
        fWillBeMaster = FALSE;
    }

    if (fIsInstantiated
        && fWillBeInstantiated
        && (!!fIsMaster == !!fWillBeMaster)) {
        // The DSA has already instantiated a replica of this NC of the
        // correct type, as the policy currently dictates it should.
        // It is a viable member of the topology.
        fIsHost = TRUE;
    } else if (fWillBeInstantiated
               && fIsLocal) {
        // This is a local DSA which has not yet had the opportunity to
        // instantiate a replica of the NC, although the policy dictates it
        // should.  Allow it to be added to the topology.
        fIsHost = TRUE;
    }

    // All DSAs host writeable config and schema.
    Assert(((KCC_NC_TYPE_SCHEMA != pCrossRef->GetNCType())
            && (KCC_NC_TYPE_CONFIG != pCrossRef->GetNCType()))
           || (fIsHost && fIsMaster));

    // Although the code above is designed to handle otherwise, currently only
    // domain NCs should ever be read-only replicas.
    Assert(!(fIsHost
             && !fWillBeMaster
             && (KCC_NC_TYPE_DOMAIN != pCrossRef->GetNCType())));

    if (fIsHost) {
        *pfIsMaster = fWillBeMaster;
    }

    return fIsHost;
}


BOOL
KCC_DSA::IsConnectionObjectTranslationDisabled()
//
// Is NTDS-Connection object-to-REPLICA_LINK translation disabled?
//
{
    ASSERT_VALID( this );

    if (gpDSCache->AmRunningUnderAltID()) {
        // Not running as local DSA; do not translate!
        DPRINT(0, "Using alternate identity; connection object translation disabled!\n");
        return TRUE;
    }

    return !!( m_dwOptions & NTDSDSA_OPT_DISABLE_NTDSCONN_XLATE );
}


DSNAME *
KCC_DSA::GetSiteDN()
//
// Retrieve the site name for this DSA.
//
{
    ASSERT_VALID(this);

    Assert(NULL != m_pdnSite);
    Assert(!fNullUuid(&m_pdnSite->Guid));

    return m_pdnSite;
}

DSNAME *
KCC_DSA::GetSiteDNSyntacticNoGuid(
    IN  DSNAME *  pdnDSA
    )
//
// Retrieve the site name for a given DSA.
// pdnDsa should not be NULL.
//
{
    DSNAME * pdnSite;

    Assert(NULL != pdnDSA);

    pdnSite = (DSNAME *) new BYTE[ pdnDSA->structLen ];
    TrimDSNameBy(pdnDSA, 3, pdnSite);

    return pdnSite;
}

KCC_INTRASITE_CONNECTION_LIST *
KCC_DSA::GetIntraSiteCnList()
//
// Retrieve the list of intra-site connections inbound to this DSA.
//
{
    if (NULL == m_pIntraSiteCnList) {
        // Not yet cached; read now.
        m_pIntraSiteCnList = new KCC_INTRASITE_CONNECTION_LIST;

        if (!m_pIntraSiteCnList->Init(m_pdnDSA)) {
            // Search for connection objects failed.  Likely either out of
            // resources or the DSA object has been renamed since we read it.
            delete m_pIntraSiteCnList;
            m_pIntraSiteCnList = NULL;
            KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
        }
    }

    return m_pIntraSiteCnList;
}

KCC_INTERSITE_CONNECTION_LIST *
KCC_DSA::GetInterSiteCnList()
//
// Retrieve the list of inter-site connections inbound to this DSA.
//
{
    if (NULL == m_pInterSiteCnList) {
        // Not yet cached; read now.
        m_pInterSiteCnList = new KCC_INTERSITE_CONNECTION_LIST;

        if (!m_pInterSiteCnList->Init(m_pdnDSA)) {
            // Search for connection objects failed.  Likely either out of
            // resources or the DSA object has been renamed since we read it.
            delete m_pInterSiteCnList;
            m_pInterSiteCnList = NULL;
            KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
        }
    }

    return m_pInterSiteCnList;
}

BOOL
KCC_DSA::InitForKey(
    IN  DSNAME   *    pdnDSA
    )
//
// Init a KCC_DSA object for use as a key (i.e., solely for comparison use
// by bsearch()).
//
// WARNING: The DSNAME argument pdnDSA must be valid for the lifetime of this
// object!
//
{
    Reset();

    m_pdnDSA = pdnDSA;

    m_fIsInitialized = TRUE;

    return TRUE;
}

int __cdecl
KCC_DSA::CompareIndirectBySiteGuid(
    IN  const void * ppvDsa1,
    IN  const void * ppvDsa2
    )
//
// Compare two KCC_DSA objects for sorting purposes.
// Note that this is used for indirect comparisons (e.g., to sort an
// array of *pointers* to KCC_DSA objects).
//
{
    KCC_DSA * pDsa1 = (KCC_DSA *) *((void **) ppvDsa1);
    KCC_DSA * pDsa2 = (KCC_DSA *) *((void **) ppvDsa2);

    ASSERT_VALID(pDsa1);
    ASSERT_VALID(pDsa2);

    Assert(!fNullUuid(&pDsa1->GetSiteDN()->Guid));
    Assert(!fNullUuid(&pDsa2->GetSiteDN()->Guid));

    return memcmp(&pDsa1->GetSiteDN()->Guid,
                  &pDsa2->GetSiteDN()->Guid,
                  sizeof(GUID));
}

int __cdecl
KCC_DSA::CompareIndirectByNtdsDsaGuid(
    IN  const void * ppvDsa1,
    IN  const void * ppvDsa2
    )
//
// Compare two KCC_DSA objects for sorting purposes.
// Note that this is used for indirect comparisons (e.g., to sort an
// array of *pointers* to KCC_DSA objects).
//
{
    KCC_DSA * pDsa1 = (KCC_DSA *) *((void **) ppvDsa1);
    KCC_DSA * pDsa2 = (KCC_DSA *) *((void **) ppvDsa2);

    ASSERT_VALID(pDsa1);
    ASSERT_VALID(pDsa2);

    Assert(!fNullUuid(&pDsa1->GetDsName()->Guid));
    Assert(!fNullUuid(&pDsa2->GetDsName()->Guid));

    return memcmp(&pDsa1->GetDsName()->Guid,
                  &pDsa2->GetDsName()->Guid,
                  sizeof(GUID));
}

int __cdecl
KCC_DSA::CompareIndirectByNtdsDsaString(
    IN  const void * ppvDsa1,
    IN  const void * ppvDsa2
    )
//
// Compare two KCC_DSA objects for sorting purposes.
// Note that this is used for indirect comparisons (e.g., to sort an
// array of *pointers* to KCC_DSA objects).
//
{
    KCC_DSA * pDsa1 = (KCC_DSA *) *((void **) ppvDsa1);
    KCC_DSA * pDsa2 = (KCC_DSA *) *((void **) ppvDsa2);

    ASSERT_VALID(pDsa1);
    ASSERT_VALID(pDsa2);

    Assert(0!=pDsa1->GetDsName()->NameLen);
    Assert(0!=pDsa2->GetDsName()->NameLen);
    
    return wcscmp(pDsa1->GetDsName()->StringName,
                  pDsa2->GetDsName()->StringName);
}

int __cdecl
KCC_DSA::CompareIndirectGcGuid(
    IN  const void * ppvDsa1,
    IN  const void * ppvDsa2
    )
//
// Compare two KCC_DSA objects for sorting purposes.
// Sort by decending Gc-ness first, then ascending guid next
// Note that this is used for indirect comparisons (e.g., to sort an
// array of *pointers* to KCC_DSA objects).
//
{
    KCC_DSA * pDsa1 = (KCC_DSA *) *((void **) ppvDsa1);
    KCC_DSA * pDsa2 = (KCC_DSA *) *((void **) ppvDsa2);

    ASSERT_VALID(pDsa1);
    ASSERT_VALID(pDsa2);

    Assert(!fNullUuid(&pDsa1->GetDsName()->Guid));
    Assert(!fNullUuid(&pDsa2->GetDsName()->Guid));

    if (pDsa1->IsGC() == pDsa2->IsGC()) {
        return memcmp(&pDsa1->GetDsName()->Guid,
                      &pDsa2->GetDsName()->Guid,
                      sizeof(GUID));
    } else if (pDsa1->IsGC()) {
        // GC-ness sorts before non-GC-ness
        return -1;
    } else {
        return 1;
    }
}

KCC_DSA_LIST::~KCC_DSA_LIST()
{
    if( m_ppdsa ) {
        // This function cannot free the pointed-to objects because there may be
        // many lists sharing a set of pointers to these objects. The copy
        // constructor and sublist generating functions all assume that the pointers
        // to DSA objects can be shared.
        delete [] m_ppdsa;
    }

    Reset();
}

KCC_DSA_LIST::KCC_DSA_LIST( const KCC_DSA_LIST &copy )
//
// copy constructor
// Note: A new copy of the array of pointers is made, not new copies
// of the DSA's themselves
//
{
    Reset();
    m_fIsInitialized   = TRUE;
    m_cdsa             = copy.m_cdsa;
    m_ppdsa            = new KCC_DSA*[ m_cdsa ];
    memcpy( m_ppdsa, copy.m_ppdsa, m_cdsa*sizeof(KCC_DSA *) );
    m_pfnSortedBy      = copy.m_pfnSortedBy;
}

void
KCC_DSA_LIST::Reset()
//
// Reset member variables to their pre-Init() state.
//
{
    m_fIsInitialized = FALSE;
    m_cdsa           = 0;
    m_ppdsa          = NULL;
    m_pfnSortedBy    = NULL;
}

KCC_DSA *
KCC_DSA_LIST::GetDsa(
    IN  DWORD   iDsa
    )
//
// Retrieve the KCC_DSA object at the given index.
//
{
    KCC_DSA * pdsa;

    ASSERT_VALID( this );

    if ( iDsa < m_cdsa )
    {
        pdsa = m_ppdsa[ iDsa ];
        ASSERT_VALID( pdsa );
    }
    else
    {
        pdsa = NULL;
    }

    return pdsa;
}


DWORD
KCC_DSA_LIST::GetCount()
//
// Retrieve the number of KCC_DSA objects in the collection.
//
{
    ASSERT_VALID( this );
    return m_cdsa;
}

BOOL
KCC_DSA_LIST::IsValid()
//
// Is the collection initialized and internally consistent?
//
{
    return m_fIsInitialized;
}


BOOL
KCC_DSA_LIST::InitSubsequence(
    IN  KCC_DSA_LIST   *pDsaList,
    IN  DWORD           left,
    IN  DWORD           right
    )
// Initialize a list of DSAs which is a contiguous subsequence
// of the list 'pDsaList'. The leftmost index of this subsequence
// is 'left' and the rightmost is 'right'.
{
    KCC_DSA        *pDsa;
    DWORD           iDSA, cTotalDSAs;

    ASSERT_VALID( pDsaList );
    Assert( left<=right );

    // Allocate memory for the new DSA list
    cTotalDSAs = right-left+1;
    m_ppdsa = new KCC_DSA*[ cTotalDSAs ];
    memset( m_ppdsa, 0, sizeof(KCC_DSA*)*cTotalDSAs ); 

    for( iDSA=left; iDSA<=right; iDSA++ ) {
        pDsa = pDsaList->GetDsa( iDSA );
        ASSERT_VALID( pDsa );
        
        // Check that the DSA objects has its DN setup properly
        Assert(!fNullUuid(&pDsa->GetDsName()->Guid));

        Assert( iDSA-left<cTotalDSAs );
        m_ppdsa[ iDSA-left ] = pDsa;
    }

    // Sort the list of DSAs by DSA GUID
    m_pfnSortedBy = KCC_DSA::CompareIndirectByNtdsDsaGuid;
    qsort( m_ppdsa, cTotalDSAs, sizeof(KCC_DSA*), m_pfnSortedBy );
    
    // Setup all members of this KCC_DSA_LIST object
    m_cdsa = cTotalDSAs;
    m_fIsInitialized = TRUE;

    return TRUE;
}


BOOL
KCC_DSA_LIST::InitAllDSAs(
	VOID
	)
// Initialize the collection from all NTDS-DSA objects in the
// Sites container. The DSAs will be ordered by site name.
{
    ENTINFSEL Sel =
    {
        EN_ATTSET_LIST,
        { ARRAY_SIZE(AttrList), AttrList },
        EN_INFOTYPES_TYPES_VALS
    };

    DSNAME             *pdnConfigNC = gpDSCache->GetConfigNC();
    ULONG               cbSitesContainer;
    DSNAME             *pdnSitesContainer;
    WCHAR               szSitesRDN[] = L"Sites";
    DWORD               cchSitesRDN  = ARRAY_SIZE(szSitesRDN) - 1;
    DSNAME             *pdnDsaObjCat;
    KCC_DSA             *pdsa;
    ULONG               dirError;
    FILTER              Filter;
    SEARCHRES          *pResults;
    ENTINFLIST         *pEntInfList;
    DWORD               iDsa, cDsaNew;

    // Clear the member variables
    Reset();
    Assert( NULL==m_ppdsa );

    // Set up the root search dn
    cbSitesContainer  = pdnConfigNC->structLen +
                        (MAX_RDN_SIZE+MAX_RDN_KEY_SIZE) * sizeof(WCHAR);
    pdnSitesContainer = (DSNAME*) new BYTE[cbSitesContainer];
    AppendRDN(pdnConfigNC, pdnSitesContainer, cbSitesContainer,
              szSitesRDN, cchSitesRDN, ATT_COMMON_NAME);
    
    // Set up the search filter
    memset( &Filter, 0, sizeof( Filter ) );
    Filter.choice                  = FILTER_CHOICE_ITEM;
    Filter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;

    pdnDsaObjCat = DsGetDefaultObjCategory(CLASS_NTDS_DSA);
    if( NULL==pdnDsaObjCat ) {
        Assert( !"DsGetDefaultObjCategory() returned NULL" );
        KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
    }

    Filter.FilterTypes.Item.FilTypes.ava.type         = ATT_OBJECT_CATEGORY;
    Filter.FilterTypes.Item.FilTypes.ava.Value.valLen = pdnDsaObjCat->structLen;
    Filter.FilterTypes.Item.FilTypes.ava.Value.pVal   = (BYTE *) pdnDsaObjCat;

    // Create an object to perform a paged search.
    KCC_PAGED_SEARCH    pagedSearch( pdnSitesContainer,
                                     SE_CHOICE_WHOLE_SUBTREE,
                                    &Filter,
                                    &Sel);
    do {
        dirError = pagedSearch.GetResults( &pResults );

        if( dirError ) {
            // Handle DirSearch() errors
            if( nameError==dirError ) {
                NAMERR * pnamerr = &pResults->CommRes.pErrInfo->NamErr;
        
                if(    ( NA_PROBLEM_NO_OBJECT == pnamerr->problem )
                    && ( DIRERR_OBJ_NOT_FOUND == pnamerr->extendedErr ))
                {
                    DPRINT(3, "No sites container!\n");
                }
            }
            
            DPRINT1( 0, "KccSearch() failed with error %d.\n", dirError );
            KCC_LOG_SEARCH_FAILURE( pdnSitesContainer, dirError );
            KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);            
        }

        // DirSearch() succeeded

        if( pResults->count>0 ) {

            // Allocate space in the array for the new DSAs.
            cDsaNew = m_cdsa + pResults->count;
            if(m_ppdsa) {
                m_ppdsa = (KCC_DSA**) THReAlloc( m_ppdsa, cDsaNew*sizeof(KCC_DSA*) );
            } else {
                m_ppdsa = (KCC_DSA**) THAlloc( cDsaNew*sizeof(KCC_DSA*) );
            }
            if(!m_ppdsa) {
                KCC_MEM_EXCEPT( cDsaNew*sizeof(KCC_DSA*) );
            }

            // Copy the newly-found DSAs into the array
            for( pEntInfList=&pResults->FirstEntInf, iDsa=m_cdsa;
                 NULL!=pEntInfList;
                 pEntInfList=pEntInfList->pNextEntInf )
            {
                pdsa = new KCC_DSA;

                if( iDsa>=cDsaNew ) {
                    Assert( !"DirSearch returned inconsistent results" );
                    KCC_EXCEPT( ERROR_DS_DATABASE_ERROR, 0 );
                }

                // Initialize the DSA with the attributes that we have loaded.
                if( pdsa->InitDsa(&pEntInfList->Entinf.AttrBlock) ) {
                    // Add the DSA to our array.
                    m_ppdsa[ iDsa++ ] = pdsa;
                } else {
                    // Failed to initialize the DSA.
                    KCC_EXCEPT( ERROR_DS_DATABASE_ERROR, 0 );
                }
            }

            m_cdsa = iDsa;      // Note: can be less than cNewDsaArray
        } else {
            Assert( pagedSearch.IsFinished() );
        }

        // On debug builds we hold on to the search results in order to
        // make debugging DirSearch problems easier
        #if DBG
            m_dbgSearchResults = pResults;
            DirFreeSearchRes( pResults, TRUE );
        #else
            DirFreeSearchRes( pResults, FALSE );
        #endif
            
    } while( !pagedSearch.IsFinished() );

    // Handle no search results
    if( 0 == m_cdsa ) {
        DPRINT( 3, "No dsa objects found in any site!\n" );
        KCC_LOG_SEARCH_FAILURE( pdnSitesContainer, dirError );
        KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
    }

    // Now sort the DSAs by ascending ntdsDsa objectGuid.
    m_pfnSortedBy = KCC_DSA::CompareIndirectBySiteGuid;
    qsort(m_ppdsa, m_cdsa, sizeof(*m_ppdsa), m_pfnSortedBy);

    m_fIsInitialized = TRUE;
    return m_fIsInitialized;
}


VOID
KCC_DSA_LIST::InitUnionOfSites(
    IN  KCC_SITE_LIST *pSiteList,
    IN  KCC_DSA_SORTFN *pfnSortFunction
    )
/*++

Routine Description:

    Given a list of sites, create a list of DSAs contained in all of those
    sites and sort with the given sort function.
    
Arguments:

    pSiteList - A list of sites whose DSAs we want to store in the new list
    pfnSortFunction - The comparison function that will be used to sort the
        entries in the new list.

Return Value:

    None

--*/
{
    KCC_DSA_LIST   *pSiteDsaList;
    KCC_DSA        *pDsa;
    DWORD           iSite, cSite, cTotalDSAs=0;
    DWORD           iDSA=0, iSiteDSA, cSiteDSAs; 

    // Count how many DSAs there are in all the sites
    cSite = pSiteList->GetCount();
    for( iSite=0; iSite<cSite; iSite++ ) {
        pSiteDsaList = pSiteList->GetSite(iSite)->GetDsaList();

        // GetDsaList raises an exception on failure, so pSiteDsaList
        // should always be valid.
        Assert( pSiteDsaList->IsValid() );
        
        cTotalDSAs += pSiteDsaList->GetCount();
    }

    // Allocate memory for the new DSA list
    m_ppdsa = new KCC_DSA*[ cTotalDSAs ];
    memset( m_ppdsa, 0, sizeof(KCC_DSA*)*cTotalDSAs ); 

    // Fill in the new DSA list
    for( iSite=0; iSite<cSite; iSite++ ) {
        pSiteDsaList = pSiteList->GetSite(iSite)->GetDsaList();
        Assert( pSiteDsaList->IsValid() );

        cSiteDSAs = pSiteDsaList->GetCount();
        for( iSiteDSA=0; iSiteDSA<cSiteDSAs; iSiteDSA++ ) {
            pDsa = pSiteDsaList->GetDsa( iSiteDSA );
            
            // Check that the DSA objects have their DNs setup properly
            if( KCC_DSA::CompareIndirectByNtdsDsaGuid==pfnSortFunction ) {
                Assert(!fNullUuid(&pDsa->GetDsName()->Guid));
            } else if( KCC_DSA::CompareIndirectByNtdsDsaString==pfnSortFunction ) {
                Assert(0 != pDsa->GetDsName()->NameLen);
            }

            Assert( iDSA<cTotalDSAs );
            Assert( NULL==m_ppdsa[iDSA] );
            m_ppdsa[ iDSA++ ] = pDsa;
        }
    }

    // Sort the list of DSAs by the requested sort function
    qsort( m_ppdsa, cTotalDSAs, sizeof(KCC_DSA*), pfnSortFunction );
    
    // Setup all members of this KCC_DSA_LIST object
    m_fIsInitialized = TRUE;
    m_cdsa = cTotalDSAs;
    m_pfnSortedBy = pfnSortFunction;

    // Check that every DSA can be found in the new list
    #ifdef DBG
        for( iSite=0; iSite<cSite; iSite++ ) {
            pSiteDsaList = pSiteList->GetSite(iSite)->GetDsaList();
            Assert( pSiteDsaList->IsValid() );
        
            cSiteDSAs = pSiteDsaList->GetCount();
            for( iSiteDSA=0; iSiteDSA<cSiteDSAs; iSiteDSA++ ) {
                pDsa = pSiteDsaList->GetDsa( iSiteDSA );
                Assert( pDsa == this->GetDsa(pDsa->GetDsName(),NULL) );
            }
        }
    #endif // DBG
}


BOOL
KCC_DSA_LIST::InitBridgeheads(
    IN  KCC_SITE *      Site,
    IN  KCC_TRANSPORT * Transport,
    OUT BOOL *          pfExplicitBridgeheadsDefined    OPTIONAL
    )
/*++

Routine Description:

    Initialize a collection of DSA objects from the list of transport servers
    returned by the ISM for a particular site and transport.
    
Arguments:

    Site - 
    Transport - 

Return Value:

    BOOL - False if object was not initialized

--*/
{
    KCC_DSA_LIST * pAllDsaList;
    DWORD cAllDsas;
    DWORD iDsa;
    KCC_DSNAME_ARRAY * pBridgeheadArray = NULL;

    ASSERT_VALID( Site );
    ASSERT_VALID( Transport );

    Reset();

    // This list is all DSAs in the site -- a superset of the transport servers.
    // Rather than re-reading the DSA objects, we will construct our DSA list
    // using the pre-read, pre-parsed objects here.
    pAllDsaList = Site->GetDsaList();

    // GetDsaList() excepts if it fails to Init the list so 'pAllDsaList'
    // is never NULL.
    Assert( pAllDsaList );

    pBridgeheadArray = Transport->GetExplicitBridgeheadsForSite( Site );

    if (NULL != pfExplicitBridgeheadsDefined) {
        *pfExplicitBridgeheadsDefined = (NULL != pBridgeheadArray);
    }

    // Allocate space for the new (indirected) list of KCC_DSA objects.
    cAllDsas = pAllDsaList->GetCount();
    m_ppdsa = new KCC_DSA * [ pBridgeheadArray ? pBridgeheadArray->GetCount()
                                               : cAllDsas ];
    Assert(0 == m_cdsa);

    // For each DSA in the site (bridgehead or not)...
    for (iDsa = 0; iDsa < cAllDsas; iDsa++) {
        KCC_DSA * pDsa = pAllDsaList->GetDsa(iDsa);

        if ((NULL == pBridgeheadArray)
            || pBridgeheadArray->IsElementOf(pDsa->GetDsName())) {
            // This KCC_DSA object corresponds to a potential bridgehead.
            m_ppdsa[m_cdsa] = pDsa;
            m_cdsa++;
        }
    }

    if (NULL != pBridgeheadArray) {
        delete pBridgeheadArray;
    }

    // Initialized the array; now sort the DSAs by descending bridgehead
    // preference.  (GCs are more favored, otherwise sorted by
    // objectGuid.)
    m_pfnSortedBy = KCC_DSA::CompareIndirectGcGuid;
    qsort(m_ppdsa, m_cdsa, sizeof(*m_ppdsa), m_pfnSortedBy);

    m_fIsInitialized = TRUE;

    return m_fIsInitialized;
} /* KCC_DSA_LIST::InitBridgeheads */

KCC_DSA *
KCC_DSA_LIST::GetDsa(
    IN  DSNAME *pdn,
    OUT DWORD * piDsa
    )
//
// Retrieve the KCC_DSA object with the given dsname.
//
{
    KCC_DSA *   pDsa = NULL;
    KCC_DSA     DsaKey;
    KCC_DSA *   pDsaKey = &DsaKey;
    KCC_DSA **  ppDsa;

    ASSERT_VALID( this );

    if ( !pdn || !m_cdsa)
    {
        return NULL;
    }

    Assert(NULL != m_pfnSortedBy);

    // Check if we are able to use binary search to retrieve the DSA object.
    if(    ( // Guid present in key and DSAs sorted by guid
                (!fNullUuid(&pdn->Guid))
                && (m_pfnSortedBy == KCC_DSA::CompareIndirectByNtdsDsaGuid)
           )
        || ( // String present in key and DSAs sorted by string name
                (0 != pdn->NameLen)
             && (m_pfnSortedBy == KCC_DSA::CompareIndirectByNtdsDsaString)
           )
      )
    {
        // NOTE: The DSNAME argument pdn must be valid for the lifetime of
        // DsaKey.
        DsaKey.InitForKey(pdn);
    
        ppDsa = (KCC_DSA **) bsearch(&pDsaKey,
                                     &m_ppdsa[0],
                                     m_cdsa,
                                     sizeof(m_ppdsa[0]),
                                     m_pfnSortedBy);
        if (NULL != ppDsa) {
            pDsa = *ppDsa;
            ASSERT_VALID(pDsa);
    
            if (NULL != piDsa) {
                *piDsa = (DWORD)(ppDsa - m_ppdsa);
                Assert(pDsa == GetDsa(*piDsa));
            }
        }
    }
    else {
        // No guid present in key or DSAs not sorted by guid -- must use linear
        // search.
        for (DWORD iDsa = 0; iDsa < m_cdsa; iDsa++) {
            DSNAME *pdnCurrent = m_ppdsa[ iDsa ]->GetDsName();

            if (NameMatched(pdn, pdnCurrent)) {
                pDsa = m_ppdsa[ iDsa ];
                if (NULL != piDsa) {
                    *piDsa = iDsa;
                    Assert(pDsa == GetDsa(*piDsa));
                }
                break;
            }
        }
    }

    return pDsa;
}

KCC_DSA *
KCC_DSA_LIST::Remove(
    IN  DSNAME *pdn
    )
//
// Remove the given dsa from the list
//
{
    DWORD idsa;
    KCC_DSA *pdsa;

    // CODE.IMPROVEMENT: Note that this does not use binary search when the list is
    // sorted by SiteGuid or GcGuid. Provide a new version of this function that
    // accepts a pDsa pointer instead of a pDN.

    pdsa = GetDsa( pdn, &idsa );
    if (!pdsa) {
        return NULL;
    }

    Assert(idsa < m_cdsa);

    // Remove this dsa from the array
    memmove(&m_ppdsa[idsa],
            &m_ppdsa[idsa+1],
            (m_cdsa - idsa - 1) * sizeof(*m_ppdsa));
    m_cdsa--;

    return pdsa;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\kcclink.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kcclink.cxx

ABSTRACT:

    KCC_LINK and KCC_LINK_LIST classes.

DETAILS:

    These classes represent a single REPLICA_LINK and a collection thereof,
    resp.

    REPLICA_LINKs are the core structures associated with DS replication.
    They are found as the values of Reps-From, Reps-To, and Reps-To-Ext
    properties on NC heads.  Reps-From dictates that the local DSA replicates
    the NC from the server described in the link.  Reps-To dictates that the
    NC is replicated to the server described in the link via RPC.  Reps-To-Ext
    similarly dictates that the NC is replicated to the described server, but
    via mail instead of RPC.

CREATED:

    01/21/97    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <ntdspchx.h>
#include "kcc.hxx"
#include "kcclink.hxx"
#include "kccduapi.hxx"
#include "kccconn.hxx"
#include "kccstale.hxx"
#include "kcctools.hxx"

#define FILENO FILENO_KCC_KCCLINK
#define KCC_REPLICATION_PARTNER_LIMIT       500

///////////////////////////////////////////////////////////////////////////////
//
//  KCC_LINK METHODS
//

void
KCC_LINK::Reset()
//
// Set member variables to their pre-Init() state.
//
{
    m_fIsInitialized = FALSE;
    m_prl            = NULL;
    m_ulModifyFields = 0;
}

void
KCC_LINK::FixupRepsFrom(
    REPLICA_LINK *prl
    )
/*++

Routine Description:

    Converts REPLICA_LINK structures as read from disk (in repsFrom attribute)
    to current version.

Arguments:

    prl-- In repsFrom as read from disk to convert

Return Value:
    Success: modified (& possible re-allocated) RL
    Error: Raises exception

Remarks:
    Taken from ntdsa\dra\drautil.c
    TODO: implement a single conversion routine

--*/
{

    if (prl->V1.cbOtherDraOffset < offsetof(REPLICA_LINK, V1.rgb)) {
        // The REPLICA_LINK structure has been extended since this value
        // was created.  Specifically, it's possible to add new fields to
        // the structure before the dynamically sized rgb field.  In this
        // case, we shift the contents of what was the rgb field to the
        // new offset of the rgb field, then zero out the intervening
        // elements.
        DWORD cbNewFieldsSize = offsetof(REPLICA_LINK, V1.rgb) - prl->V1.cbOtherDraOffset;

        // old formats:
        //  -  missing the uuidTransportObj field (realy old).
        //  -  w/out what used to be dwDrsExt (now dwReserved1)
        Assert(prl->V1.cbOtherDraOffset == offsetof(REPLICA_LINK, V1.uuidTransportObj) ||
               prl->V1.cbOtherDraOffset == offsetof(REPLICA_LINK, V1.dwReserved1) );

        DPRINT1(0, "Converting repsFrom %s from old REPLICA_LINK format.\n",
                RL_POTHERDRA(prl)->mtx_name);

        // Allocate Expand the structure and shift the contents of what what was the
        // rgb field in the old format to where the rgb field is in the new
        // format.

        m_prl = (REPLICA_LINK*)new BYTE[prl->V1.cb + cbNewFieldsSize];
        // copy mutual fields
        CopyMemory(m_prl, prl, prl->V1.cb);

        // and the rest
        CopyMemory(m_prl->V1.rgb, prl->V1.rgb - cbNewFieldsSize,
                   prl->V1.cb - prl->V1.cbOtherDraOffset);

        // Zero out the new fields.
        memset(((BYTE *)m_prl) + m_prl->V1.cbOtherDraOffset, 0, cbNewFieldsSize);

        // And reset the embedded offsets and structure size.
        m_prl->V1.cbOtherDraOffset = offsetof(REPLICA_LINK, V1.rgb);
        m_prl->V1.cb += cbNewFieldsSize;
        if ( 0 != m_prl->V1.cbPASDataOffset ) {
            // struct was extended while there's PAS data in it.
            m_prl->V1.cbPASDataOffset += cbNewFieldsSize;
        }

    }
    else if ( prl->V1.cbOtherDraOffset != offsetof(REPLICA_LINK, V1.rgb) ) {
            Assert(prl->V1.cbOtherDraOffset == offsetof(REPLICA_LINK, V1.rgb));
            KCC_EXCEPT( DRAERR_InternalError, 0 );
    }
    else {
        // simply alloc & copy
        VALIDATE_REPLICA_LINK_SIZE(prl);
        m_prl = (REPLICA_LINK*)new BYTE[prl->V1.cb];
        CopyMemory(m_prl, prl, prl->V1.cb);
    }

    VALIDATE_REPLICA_LINK_VERSION(m_prl);
    VALIDATE_REPLICA_LINK_SIZE(m_prl);
}



BOOL
KCC_LINK::Init(
    IN  REPLICA_LINK *  prl
    )
//
// Initialize internal object from given REPLICA_LINK structure.
// Note: This is copied code from FixupRepsFrom(). Until it is available,
// we must ensure they're in sync.
//
{
    Reset();

    Assert( prl );
    if(!prl) {
        return FALSE;
    }

    // optionally fix offsets, always allocate mem & assign m_prl
    FixupRepsFrom(prl);

    m_fIsInitialized = TRUE;

    return m_fIsInitialized;
}

UUID *
KCC_LINK::GetDSAUUID()
//
// Retrieve immutable UUID associated with source DSA.
//
{
    ASSERT_VALID( this );
    return &m_prl->V1.uuidDsaObj;
}

MTX_ADDR *
KCC_LINK::GetDSAAddr()
//
// Retrieve transport address associated with the source DSA.
//
{
    ASSERT_VALID( this );
    return RL_POTHERDRA( m_prl );
}

BOOL
KCC_LINK::IsEnabled()
//
// Is this link enabled?
//
{
    ASSERT_VALID( this );
    return !( m_prl->V1.ulReplicaFlags & ( DRS_DISABLE_AUTO_SYNC | DRS_DISABLE_PERIODIC_SYNC ) );
}

KCC_LINK &
KCC_LINK::SetEnabled(
    IN  BOOL    fIsEnabled
    )
//
// Set is-enabled flag to the given value.
//
{
    ASSERT_VALID( this );

    if ( fIsEnabled )
    {
        m_prl->V1.ulReplicaFlags &= ~( DRS_DISABLE_AUTO_SYNC | DRS_DISABLE_PERIODIC_SYNC );
    }
    else
    {
        m_prl->V1.ulReplicaFlags |= ( DRS_DISABLE_AUTO_SYNC | DRS_DISABLE_PERIODIC_SYNC );
    }

    m_ulModifyFields |= DRS_UPDATE_FLAGS;

    return *this;
}

REPLTIMES *
KCC_LINK::GetSchedule()
//
// Retrieve periodic replication schedule.
//
{
    ASSERT_VALID( this );
    return &m_prl->V1.rtSchedule;
}

KCC_LINK &
KCC_LINK::SetSchedule(
    IN  REPLTIMES * prt
    )
//
// Set periodic replication schedule.
//
{
    ASSERT_VALID( this );
    memcpy( &m_prl->V1.rtSchedule, prt, sizeof( *prt ) );

    m_ulModifyFields |= DRS_UPDATE_SCHEDULE;

    return *this;
}

BOOL
KCC_LINK::IsDSRPCReplica()
//
// Is replication across this link performed via DS RPC (as opposed to
// via an ISM plug-in transport's send/receive functions)?
//
{
    ASSERT_VALID( this );
    return !(m_prl->V1.ulReplicaFlags & DRS_MAIL_REP);
}

KCC_LINK &
KCC_LINK::SetDSRPCReplica(
    IN  BOOL    fIsDSRPCReplica
    )
//
// Set the IsDSRPCReplica flag to the given value.
//
{
    ASSERT_VALID( this );

    if ( !fIsDSRPCReplica )
    {
        m_prl->V1.ulReplicaFlags |= DRS_MAIL_REP;
    }
    else
    {
        m_prl->V1.ulReplicaFlags &= ~DRS_MAIL_REP;
    }

    m_ulModifyFields |= DRS_UPDATE_FLAGS;

    return *this;
}

BOOL
KCC_LINK::UsesCompression()
//
// Is compression used for replication data?
//
{
    ASSERT_VALID(this);
    return !!(m_prl->V1.ulReplicaFlags & DRS_USE_COMPRESSION);
}

KCC_LINK &
KCC_LINK::SetCompression(
    IN  BOOL    fUseCompression
    )
//
// Set the use-compression flag to the given value.
//
{
    ASSERT_VALID(this);

    if (fUseCompression) {
        m_prl->V1.ulReplicaFlags |= DRS_USE_COMPRESSION;
    }
    else {
        m_prl->V1.ulReplicaFlags &= ~DRS_USE_COMPRESSION;
    }

    m_ulModifyFields |= DRS_UPDATE_FLAGS;

    return *this;
}

BOOL
KCC_LINK::IsNeverNotified()
//
// Are replication notifications never used for this link?
//
{
    ASSERT_VALID(this);
    return !!(m_prl->V1.ulReplicaFlags & DRS_NEVER_NOTIFY);
}

KCC_LINK &
KCC_LINK::SetNeverNotified(
    IN  BOOL    fIsNeverNotified
    )
//
// Set the is-never-notified flag to the given value.
//
{
    ASSERT_VALID(this);

    if (fIsNeverNotified) {
        m_prl->V1.ulReplicaFlags |= DRS_NEVER_NOTIFY;
    }
    else {
        m_prl->V1.ulReplicaFlags &= ~DRS_NEVER_NOTIFY;
    }

    m_ulModifyFields |= DRS_UPDATE_FLAGS;

    return *this;
}

BOOL
KCC_LINK::IsPeriodicSynced()
//
// Is replication across this link performed on a schedule (psossibly in
// addition to notification-based replication)?
//
{
    ASSERT_VALID( this );
    return !!( m_prl->V1.ulReplicaFlags & DRS_PER_SYNC );
}

KCC_LINK &
KCC_LINK::SetPeriodicSync(
    IN  BOOL    fIsPeriodicSync
    )
//
// Set the is-periodically-synced flag to the given value.
//
{
    ASSERT_VALID( this );

    if ( fIsPeriodicSync )
    {
        m_prl->V1.ulReplicaFlags |= DRS_PER_SYNC;
    }
    else
    {
        m_prl->V1.ulReplicaFlags &= ~DRS_PER_SYNC;
    }

    m_ulModifyFields |= DRS_UPDATE_FLAGS;

    return *this;
}

BOOL
KCC_LINK::IsInitSynced()
//
// Is replication across this link performed on DS startup?
//
{
    ASSERT_VALID( this );
    return !!( m_prl->V1.ulReplicaFlags & DRS_INIT_SYNC );
}

// Set the is-init-synced flag to the given value.
KCC_LINK &
KCC_LINK::SetInitSync(
    IN  BOOL    fIsInitSync
    )
{
    ASSERT_VALID( this );

    if ( fIsInitSync )
    {
        m_prl->V1.ulReplicaFlags |= DRS_INIT_SYNC;
    }
    else
    {
        m_prl->V1.ulReplicaFlags &= ~DRS_INIT_SYNC;
    }

    m_ulModifyFields |= DRS_UPDATE_FLAGS;

    return *this;
}

// Does completion of a sync of this NC trigger a sync in the opposite
// direction?
BOOL
KCC_LINK::IsTwoWaySynced()
{
    ASSERT_VALID(this);
    return !!(m_prl->V1.ulReplicaFlags & DRS_TWOWAY_SYNC);
}

// Set the is-two-way-synced flag to the given value.
KCC_LINK &
KCC_LINK::SetTwoWaySync(
    IN  BOOL    fIsTwoWaySynced
    )
{
    ASSERT_VALID(this);

    if (fIsTwoWaySynced) {
        m_prl->V1.ulReplicaFlags |= DRS_TWOWAY_SYNC;
    }
    else {
        m_prl->V1.ulReplicaFlags &= ~DRS_TWOWAY_SYNC;
    }

    m_ulModifyFields |= DRS_UPDATE_FLAGS;

    return *this;
}

// Retrieve the UUID associated with the transport.
UUID *
KCC_LINK::GetTransportUUID()
{
    ASSERT_VALID( this );
    return &m_prl->V1.uuidTransportObj;
}

// Set the transport to that with the given UUID as its objectGuid.
KCC_LINK &
KCC_LINK::SetTransportUUID(
    IN  UUID *  puuidTransportObj
    )
{
    ASSERT_VALID( this );

    m_prl->V1.uuidTransportObj = *puuidTransportObj;

    m_ulModifyFields |= DRS_UPDATE_TRANSPORT;

    return *this;
}

// Is the local NC writeable?
BOOL
KCC_LINK::IsLocalNCWriteable()
{
    ASSERT_VALID( this );
    return !!(m_prl->V1.ulReplicaFlags & DRS_WRIT_REP);
}

DSTIME
KCC_LINK::GetTimeOfLastSuccess()
//
// Get the time of the last successful operation across this link.  For
// Reps-From, this is the time of the last successful inbound replication.
// For Reps-To, this is the time of the last successful notification.
//
{
    ASSERT_VALID( this );
    return m_prl->V1.timeLastSuccess;
}

DSTIME
KCC_LINK::GetTimeOfLastAttempt()
//
// Get the time of the last attempt at an operation across this link.  For
// Reps-From, this is the time of the last attempt to do inbound replication.
// For Reps-To, this is the last time an attempt was made to send a
// notification.
//
{
    ASSERT_VALID( this );
    return m_prl->V1.timeLastAttempt;
}

ULONG
KCC_LINK::GetConnectFailureCount()
// Return the number consecutive times a replication attempt has
// failed
{
    ASSERT_VALID( this );

    return m_prl->V1.cConsecutiveFailures;

}

ULONG
KCC_LINK::GetLastResult()
// Return last result status
{
    ASSERT_VALID( this );

    return m_prl->V1.ulResultLastAttempt;

}

KCC_LINK &
KCC_LINK::SetDSAAddr(
    IN  MTX_ADDR *  pmtx
    )
//
// Set transport address of the source DSA.
//
{

    ASSERT_VALID( this );

    INT diff = MTX_TSIZE( pmtx ) - MTX_TSIZE( RL_POTHERDRA(m_prl) );


    // Realloc if necessary.
    // Note: even if there's enough space (diff < 0), we would go ahead & clean
    // the blob up. We assume this op doesn't happen too frequently so the cost is minimal
    if ( diff )
    {
        REPLICA_LINK *poldprl = m_prl;
        DWORD cb = (DWORD)((INT)m_prl->V1.cb + diff);

        // allocate & copy old to new (so that we get all fixed fields)
        // (add DWORD for potential alignment fixup).
        m_prl = (REPLICA_LINK *)new BYTE[cb + sizeof(DWORD)] ;
        CopyMemory(m_prl, poldprl, offsetof(REPLICA_LINK, V1.rgb));
        // set new struct size
        m_prl->V1.cb = cb;

        // dynamic field offsets
        //   - mtx size
        //   - PAS data
        m_prl->V1.cbOtherDra += diff;

        // PAS Data
        if ( poldprl->V1.cbPASDataOffset ) {
            //  We have PAS data:
            //  - fix offsets
            //  - copy over
            //

            // assert: size must be non-zero if offset is set
            Assert(RL_PPAS_DATA(poldprl)->size);
            // assert: invalid PAS data
            Assert(RL_PPAS_DATA(poldprl)->PAS.V1.cAttrs != 0);

            // set new offset
            m_prl->V1.cbPASDataOffset += diff;
            // ensure & fix alignment offsets
            RL_ALIGN_PAS_DATA(m_prl);

            // move data to new location
            CopyMemory(RL_PPAS_DATA(m_prl),
                       (PBYTE)poldprl + poldprl->V1.cbPASDataOffset,
                       RL_PPAS_DATA(poldprl)->size);
        }

        // reset new dra offset
        Assert((INT)(m_prl->V1.cbOtherDraOffset) > diff);

        delete poldprl;
    }

    // Copy new mtx addr.
    memcpy( RL_POTHERDRA( m_prl ), pmtx, MTX_TSIZE( pmtx ) );

    VALIDATE_REPLICA_LINK_SIZE(m_prl);

    m_ulModifyFields |= DRS_UPDATE_ADDRESS;

    return *this;
}

DWORD
KCC_LINK::Delete(
    IN KCC_LINK *           plink,
    IN DSNAME *             pdnNC,
    IN KCC_LINK_DEL_REASON  DeleteReason,
    IN ATTRTYP              attid,
    IN DWORD                dwOptions,
    IN DSNAME *             pdnDSA
    )
//
// Delete the given link from the local DSA.
//
{
    // Map reasons to event log messages.
    // -1 => Condition should never occur.
    //  0 => Do not log an event under this condition.
    static struct {
        KCC_LINK_DEL_REASON Reason;
	DWORD dwMsgCategory;
        struct { 
            DWORD dwMsgSuccess;
            DWORD dwMsgFailure;
        } OnRemoveSource;
        struct {
            DWORD dwMsgSuccess;
            DWORD dwMsgFailure;
        } OnRemoveNC;
    } rgMsgTable[] = {
        // Placeholder only.
        { KCC_LINK_DEL_REASON_NONE,
	    DS_EVENT_CAT_KCC,
          { -1,
            -1 },
          { -1,
            -1 } },

        // Remove source of a read-only NC, as the NC is that of a domain that
        // has been removed from the forest.
        { KCC_LINK_DEL_REASON_READONLY_DOMAIN_REMOVED,
	    DS_EVENT_CAT_KCC,
          { DIRLOG_CHK_LINK_DEL_DOMDEL_SUCCESS,
            DIRLOG_CHK_LINK_DEL_DOMDEL_FAILURE },
          { DIRLOG_CHK_LINK_DEL_DOMDEL_TEARDOWN_SUCCESS,
            DIRLOG_CHK_LINK_DEL_DOMDEL_TEARDOWN_FAILURE } },

        // Remove source of a read-only NC, as the local DSA is no longer
        // configured to be a GC. 

        { KCC_LINK_DEL_REASON_READONLY_NOT_GC,
	    DS_EVENT_CAT_GLOBAL_CATALOG,
          { DIRLOG_CHK_LINK_DEL_NOTGC_SUCCESS,
            DIRLOG_CHK_LINK_DEL_NOTGC_FAILURE },
          { DIRLOG_CHK_LINK_DEL_NOTGC_TEARDOWN_SUCCESS,
            DIRLOG_CHK_LINK_DEL_NOTGC_TEARDOWN_FAILURE } },

        // Remove non-domain source/NC, as the corresponding cross ref dictates
        // the local DSA is no longer a host for the NC.
        { KCC_LINK_DEL_REASON_NDNC_NOT_REPLICA_HOST,
	    DS_EVENT_CAT_KCC,
          { DIRLOG_CHK_LINK_DEL_NDNC_NOTREPLICA_RMSOURCE_SUCCESS,
            DIRLOG_CHK_LINK_DEL_NDNC_NOTREPLICA_RMSOURCE_FAILURE },
          { -1,     // these two cases should go through KCC_LINK::Demote
            -1 } }, // instead

        // Remove source/NC, as we have a writeable replica but need a read-only
        // replica.
        { KCC_LINK_DEL_REASON_HAVE_WRITEABLE_NEED_READONLY,
	    DS_EVENT_CAT_KCC,
          { DIRLOG_CHK_LINK_DEL_HAVE_WRITEABLE_NEED_READONLY_RMSOURCE_SUCCESS,
            DIRLOG_CHK_LINK_DEL_HAVE_WRITEABLE_NEED_READONLY_RMSOURCE_FAILURE },
          { DIRLOG_CHK_LINK_DEL_HAVE_WRITEABLE_NEED_READONLY_TEARDOWN_SUCCESS,
            DIRLOG_CHK_LINK_DEL_HAVE_WRITEABLE_NEED_READONLY_TEARDOWN_FAILURE } },

        // Remove source/NC, as we have a read-only replica but need a writeable
        // replica.
        { KCC_LINK_DEL_REASON_HAVE_READONLY_NEED_WRITEABLE,
	    DS_EVENT_CAT_KCC,
          { DIRLOG_CHK_LINK_DEL_HAVE_READONLY_NEED_WRITEABLE_RMSOURCE_SUCCESS,
            DIRLOG_CHK_LINK_DEL_HAVE_READONLY_NEED_WRITEABLE_RMSOURCE_FAILURE },
          { DIRLOG_CHK_LINK_DEL_HAVE_READONLY_NEED_WRITEABLE_TEARDOWN_SUCCESS,
            DIRLOG_CHK_LINK_DEL_HAVE_READONLY_NEED_WRITEABLE_TEARDOWN_FAILURE } },

        // Remove source, as there is no longer a connection object dictating
        // that we should replicate from it.
        { KCC_LINK_DEL_REASON_NO_CONNECTION,
	    DS_EVENT_CAT_KCC,
          { DIRLOG_CHK_LINK_DEL_NOCONN_SUCCESS,
            DIRLOG_CHK_LINK_DEL_NOCONN_FAILURE },
          { -1,
            -1 } },

        // Remove source, as the source DSA no longer hosts this NC.
        { KCC_LINK_DEL_REASON_SOURCE_NOT_HOST,
	    DS_EVENT_CAT_KCC,
          { DIRLOG_CHK_LINK_DEL_NONC_SUCCESS,
            DIRLOG_CHK_LINK_DEL_NONC_FAILURE },
          { -1,
            -1 } },

        // Remove source, as the source DSA host a read-only replica but the
        // local DSA hosts a writeable replica.
        { KCC_LINK_DEL_REASON_SOURCE_READONLY,
	    DS_EVENT_CAT_KCC,
          { DIRLOG_CHK_LINK_DEL_SOURCE_READONLY_SUCCESS,
            DIRLOG_CHK_LINK_DEL_SOURCE_READONLY_FAILURE },
          { -1,
            -1 } },

        // Remove repsTo, as the local DSA has no ntdsDsa object corresponding
        // to the destination DSA and the usual grace period has expired.
        { KCC_LINK_DEL_REASON_DANGLING_REPS_TO,
	    DS_EVENT_CAT_KCC,
          { DIRLOG_CHK_REPSTO_DEL_SUCCESS,
            DIRLOG_CHK_REPSTO_DEL_FAILURE },
          { -1,
            -1 } },

        // Remove non-domain source/NC, as the corresponding crossRef has been
        // deleted (signalling the partition es kaput).
        { KCC_LINK_DEL_REASON_NDNC_NO_CROSSREF,
	    DS_EVENT_CAT_KCC,
          { DIRLOG_CHK_LINK_DEL_NDNC_NOCROSSREF_RMSOURCE_SUCCESS,
            DIRLOG_CHK_LINK_DEL_NDNC_NOCROSSREF_RMSOURCE_FAILURE },
          { DIRLOG_CHK_LINK_DEL_NDNC_NOCROSSREF_TEARDOWN_SUCCESS,
            DIRLOG_CHK_LINK_DEL_NDNC_NOCROSSREF_TEARDOWN_FAILURE } },

        // Remove read-only source/NC, as the crossRef says this NC is not to
        // be hosted on GCs.

        { KCC_LINK_DEL_REASON_READONLY_NOT_HOSTED_BY_GCS,
	    DS_EVENT_CAT_GLOBAL_CATALOG,
          { DIRLOG_CHK_LINK_DEL_READONLY_NOTGCHOSTED_RMSOURCE_SUCCESS,
            DIRLOG_CHK_LINK_DEL_READONLY_NOTGCHOSTED_RMSOURCE_FAILURE },
          { DIRLOG_CHK_LINK_DEL_READONLY_NOTGCHOSTED_TEARDOWN_SUCCESS,
            DIRLOG_CHK_LINK_DEL_READONLY_NOTGCHOSTED_TEARDOWN_FAILURE } },
    };

    DWORD   draError;
    LPWSTR  pszDSA = L"";
    DWORD   dwMsgCategory;
    DWORD   dwMsgSuccess;
    DWORD   dwMsgFailure;

    Assert(KCC_LINK_DEL_REASON_MAX == ARRAY_SIZE(rgMsgTable));
    Assert(KCC_LINK_DEL_REASON_NONE != DeleteReason);
    Assert(rgMsgTable[DeleteReason].Reason == DeleteReason);

    if (NULL == plink) {
        dwOptions |= DRS_NO_SOURCE;
       
        dwMsgSuccess = rgMsgTable[DeleteReason].OnRemoveNC.dwMsgSuccess;
        dwMsgFailure = rgMsgTable[DeleteReason].OnRemoveNC.dwMsgFailure;
    } else {
        ASSERT_VALID(plink);

        pszDSA = TransportAddrFromMtxAddr(RL_POTHERDRA(plink->m_prl));

        if (NULL == pdnDSA) {
            pdnDSA = KccGetDSNameFromGuid(plink->GetDSAUUID());
            // pdnDSA may still be NULL
        }

        dwMsgSuccess = rgMsgTable[DeleteReason].OnRemoveSource.dwMsgSuccess;
        dwMsgFailure = rgMsgTable[DeleteReason].OnRemoveSource.dwMsgFailure;
    }
    dwMsgCategory = rgMsgTable[DeleteReason].dwMsgCategory;

    if ((-1 == dwMsgSuccess) || (-1 == dwMsgFailure)) {
        Assert(!"NC deletion logic error!");
        LogUnhandledError(DeleteReason);
        return ERROR_DS_INTERNAL_FAILURE;
    }

    if (ATT_REPS_FROM == attid) {
        // If we have to tear down the NC, do that part asynchronously.
        dwOptions |= DRS_ASYNC_REP;

        draError = DirReplicaDelete(pdnNC, pszDSA, dwOptions);

        // Remove the from server from the link failure cache
        if (!draError && plink) {
            gLinkFailureCache.Remove( plink->GetDSAUUID() );
        }
    } else {
        Assert(ATT_REPS_TO == attid);
        Assert(NULL != plink);

        dwOptions |= DRS_DEL_REF;
        dwOptions |= (plink->m_prl->V1.ulReplicaFlags & DRS_WRIT_REP);

        draError = DirReplicaReferenceUpdate(pdnNC,
                                             pszDSA,
                                             &plink->m_prl->V1.uuidDsaObj,
                                             dwOptions);
    }

    // The code below assumes we always log errors.
    Assert(0 != dwMsgFailure);

    if (draError) {
        LogEvent8(dwMsgCategory,
                  DS_EVENT_SEV_ALWAYS,
                  dwMsgFailure,
                  szInsertDN(pdnNC),
                  szInsertWC(pszDSA),
                  szInsertWin32Msg(draError),
                  pdnDSA ? szInsertDN(pdnDSA): szInsertSz(""),
                  szInsertWin32ErrCode(draError),
                  NULL,
                  NULL,
                  NULL );
    } else if (0 != dwMsgSuccess) {
        LogEvent(dwMsgCategory,
                 DS_EVENT_SEV_ALWAYS,
                 dwMsgSuccess,
                 szInsertDN(pdnNC),
                 szInsertWC(pszDSA),
                 pdnDSA ? szInsertDN(pdnDSA)
                        : szInsertSz(""));
    }

    return draError;
}

DWORD
KCC_LINK::Update(
    IN DSNAME * pdnNC,
    IN ATTRTYP  attid
    )
//
// Update the link in the DS.
//
{
    DWORD   draError;
    LPWSTR  pszDSA;

    Assert( 0 != m_ulModifyFields );

    pszDSA = TransportAddrFromMtxAddr(RL_POTHERDRA(m_prl));

    if ( ATT_REPS_FROM == attid )
    {
        draError = DirReplicaModify(
                        pdnNC,
                        &m_prl->V1.uuidDsaObj,
                        &m_prl->V1.uuidTransportObj,
                        pszDSA,
                        &m_prl->V1.rtSchedule,
                        m_prl->V1.ulReplicaFlags,
                        m_ulModifyFields,
                        0
                        );
    }
    else
    {
        Assert( ATT_REPS_TO == attid );

        draError = DirReplicaReferenceUpdate(
                        pdnNC,
                        pszDSA,
                        &m_prl->V1.uuidDsaObj,
                        (DRS_WRIT_REP & m_prl->V1.ulReplicaFlags)
                            | DRS_DEL_REF | DRS_ADD_REF );
    }

    if ( DRAERR_Success == draError )
    {
        m_ulModifyFields = 0;
    }

    return draError;
}

BOOL
KCC_LINK::IsValid()
//
// Is this object internally consistent?
//
{
    return m_fIsInitialized;
}

ULONG
KCC_LINK::Demote(
    IN  KCC_CROSSREF *  pCrossRef
    )
/*++

Routine Description:

    Demote the local replica of this NC by first transferring any remaining
    updates or FSMO roles to another replica and then tearing down the NC.

Arguments:

    pCrossRef (IN) - cross ref for the NC being demoted.

Return Values:

    0 or Win32 error.

--*/
{
    DRS_DEMOTE_TARGET_SEARCH_INFO DTSInfo = {0};
    DSNAME * pDemoteTargetDSADN = NULL;
    LPWSTR pszDemoteTargetDNSName = NULL;
    DWORD cNumAttempts = 0;
    DSNAME * pNC = pCrossRef->GetNCDN();
    ULONG err = ERROR_DS_CANT_FIND_DSA_OBJ;
    BOOL fSuccess = FALSE;

    // Currently the KCC should demote only NDNC replicas.
    Assert(KCC_NC_TYPE_NONDOMAIN == pCrossRef->GetNCType());

    while (!fSuccess
           && (0 == DirReplicaGetDemoteTarget(pNC, &DTSInfo,
                                              &pszDemoteTargetDNSName,
                                              &pDemoteTargetDSADN))) {
        cNumAttempts++;
        err = DirReplicaDemote(pNC, pszDemoteTargetDNSName, pDemoteTargetDSADN,
                               DRS_NO_SOURCE);
        
        if (err) {
            // Failure.
            DPRINT3(0, "Failed to demote NC %ls to target %ls, error %d.\n",
                    pNC->StringName, pDemoteTargetDSADN->StringName, err);
            
            LogEvent8(DS_EVENT_CAT_KCC,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_CHK_LINK_DEL_NDNC_NOTREPLICA_TEARDOWN_FAILURE,
                      szInsertDN(pNC),
                      szInsertDN(pDemoteTargetDSADN),
                      szInsertWin32Msg(err),
                      szInsertWin32ErrCode(err),
                      NULL, NULL, NULL, NULL );
        } else {
            // Success!
            LogEvent(DS_EVENT_CAT_KCC,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_CHK_LINK_DEL_NDNC_NOTREPLICA_TEARDOWN_SUCCESS,
                     szInsertDN(pNC),
                     szInsertDN(pDemoteTargetDSADN),
                     NULL);
            fSuccess = TRUE;
        }
            
        THFree(pDemoteTargetDSADN);
        pDemoteTargetDSADN = NULL;

        THFree(pszDemoteTargetDNSName);
        pszDemoteTargetDNSName = NULL;
    }

    if (0 == cNumAttempts) {
        // Didn't find any potential demotion targets.
        DPRINT1(0, "Failed to find demote target for NC %ls.\n",
                pNC->StringName);
        
        // Are there any other replicas configured?
        if (0 == pCrossRef->GetNCReplicaLocations()->GetCount()) {
            // No replicas are configured.  Likely a configuration error of some
            // sort -- e.g., meant to delete crossRef to remove partition
            // permanently, forgot to configure a new replica, etc.
            LogEvent(DS_EVENT_CAT_KCC,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_CHK_LINK_DEL_NDNC_NOTREPLICA_TEARDOWN_NOREPLICACFG,
                     szInsertDN(pNC),
                     NULL,
                     NULL);
        } else {
            // One or more replicas are configured, but none could be found by
            // the locator.
            LogEvent(DS_EVENT_CAT_KCC,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_CHK_LINK_DEL_NDNC_NOTREPLICA_TEARDOWN_NOREPLICAADVERTISING,
                     szInsertDN(pNC),
                     NULL,
                     NULL);
        }
        
        Assert(err);
    }

    return err;
}


///////////////////////////////////////////////////////////////////////////////
//
//  KCC_LINK_LIST METHODS
//

BOOL
KCC_LINK_LIST::IsValid()
//
// Is this object internally consistent?
//
{
    return m_fIsInitialized;
}

KCC_LINK *
KCC_LINK_LIST::GetLink(
    IN  DWORD   iLink
    )
//
// Retrieve link at the given index.
//
{
    KCC_LINK *  plink;

    ASSERT_VALID( this );

    if ( iLink < m_cLinks )
    {
        plink = &m_plink[ iLink ];
        ASSERT_VALID( plink );
    }
    else
    {
        plink = NULL;
    }

    return plink;
}

VOID
KCC_LINK_LIST::RemoveLink(
    IN  DWORD   iLink
    )
//
// Remove link at the given index.
// Not very efficient. Hopefully this happens rarely.
//
{
    ASSERT_VALID( this );
    Assert( iLink<m_cLinks );
    memmove( &m_plink[iLink], &m_plink[iLink+1], (m_cLinks-iLink-1)*sizeof(KCC_LINK) );
    m_cLinks--;
}

DWORD
KCC_LINK_LIST::GetCount()
//
// Get number of links in the collection.
//
{
    ASSERT_VALID( this );
    return m_cLinks;
}

BOOL
KCC_LINK_LIST::Init(
    IN  DSNAME *    pdnNC,
    IN  ATTRTYP     attid
    )
//
// Initialize collection of links from the set of REPLICA_LINKs of the given
// attribute type on the specified NC head.
//
{
    Reset();

    Assert((ATT_REPS_FROM == attid) || (ATT_REPS_TO == attid));

    if (gpDSCache->GetLocalDSA()->IsNCInstantiated(pdnNC)) {
        ATTR rgAttrs[] = {
            { 0, { 0, NULL } },
            { ATT_INSTANCE_TYPE, { 0, NULL } }
        };
    
        ENTINFSEL Sel = {
            EN_ATTSET_LIST,
            { ARRAY_SIZE(rgAttrs), rgAttrs },
            EN_INFOTYPES_TYPES_VALS
        };
    
        ULONG       dirError;
        READRES *   pReadRes = NULL;
    
        rgAttrs[0].attrTyp = attid;
        
        dirError = KccRead(pdnNC, &Sel, &pReadRes);
    
        if (0 != dirError) {
            if (nameError == dirError) {
                NAMERR * pnamerr = &pReadRes->CommRes.pErrInfo->NamErr;
    
                if ((NA_PROBLEM_NO_OBJECT == pnamerr->problem)
                    && (DIRERR_OBJ_NOT_FOUND == pnamerr->extendedErr)) {
                    // 'salright; NC head is not yet instantiated
                    m_cLinks = 0;
                    m_InstanceType = IT_UNINSTANT;
                    m_fIsInitialized = TRUE;
                }
            } else if (referralError == dirError) {
                // 'salright; NC head is not yet instantiated
                m_cLinks = 0;
                m_InstanceType = IT_UNINSTANT;
                m_fIsInitialized = TRUE;
            }
    
            if (!m_fIsInitialized) {
                // other error; bail
                KCC_LOG_READ_FAILURE(pdnNC, dirError);
                KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
            }
        } else {
            // found links; create corresponding KCC_LINKs
            m_InstanceType = IT_UNINSTANT;
    
            for (DWORD iAttr = 0;
                 iAttr < pReadRes->entry.AttrBlock.attrCount;
                 iAttr++) {
                ATTR * pattr = &pReadRes->entry.AttrBlock.pAttr[iAttr];
    
                switch (pattr->attrTyp) {
                case ATT_INSTANCE_TYPE:
                    Assert(1 == pattr->AttrVal.valCount);
                    Assert(sizeof(m_InstanceType) == pattr->AttrVal.pAVal->valLen);
                    m_InstanceType = *((SYNTAX_INTEGER *) pattr->AttrVal.pAVal->pVal);
                    break;
    
                case ATT_REPS_FROM:
                case ATT_REPS_TO:
                    Assert(attid == pattr->attrTyp);
    
                    m_plink = new KCC_LINK[pattr->AttrVal.valCount];
                    m_cLinks = 0;
                    for (DWORD iAttrVal = 0;
                         iAttrVal < pattr->AttrVal.valCount;
                         iAttrVal++) {
                        Assert( pattr->AttrVal.pAVal[iAttrVal].pVal );
                        if (m_plink[m_cLinks].Init(
                                (REPLICA_LINK *) pattr->AttrVal.pAVal[iAttrVal].pVal)) {
                            m_cLinks++;
                        }
                    }
    
                    Assert(m_cLinks == pattr->AttrVal.valCount);
                    break;
    
                default:
                    Assert(!"Received unrequested attribute!");
                    DPRINT1(0, "Received unrequested attribute 0x%X.\n",
                            pattr->attrTyp);
                    break;
                }
            }
    
            Assert(ISVALIDINSTANCETYPE(m_InstanceType));
            Assert(!(IT_UNINSTANT & m_InstanceType));
    
            m_fIsInitialized = TRUE;
        }
    } else {
        // NC is not present -- no need to perform the read.
        m_cLinks = 0;
        m_InstanceType = IT_UNINSTANT;
        m_fIsInitialized = TRUE;
    }

    // Check that we don't have too many replication partners for this NC
    if( m_cLinks > KCC_REPLICATION_PARTNER_LIMIT ) {
        LogEvent(
            DS_EVENT_CAT_KCC,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_KCC_TOO_MANY_PARTNERS,
            szInsertUL(m_cLinks),
            szInsertDN(pdnNC),
            szInsertUL(KCC_REPLICATION_PARTNER_LIMIT)
            );
    }

    return m_fIsInitialized;
}

void
KCC_LINK_LIST::Reset()
//
// Set member variables to their pre-Init() values.
//
{
    m_fIsInitialized = FALSE;
    m_cLinks         = 0;
    m_plink          = NULL;
    m_InstanceType   = 0;
}

KCC_LINK *
KCC_LINK_LIST::GetLinkFromSourceDSAAddr(
    IN  MTX_ADDR *  pmtx
    )
//
// Retrieve link with the given transport address.  Returns NULL if none found.
//
{
    KCC_LINK * plink = NULL;

    ASSERT_VALID( this );

    for ( DWORD iLink = 0; iLink < m_cLinks; iLink++ )
    {
        if ( MtxSame( pmtx, GetLink( iLink )->GetDSAAddr() ) )
        {
            plink = GetLink( iLink );
            break;
        }
    }

    return plink;
}

KCC_LINK *
KCC_LINK_LIST::GetLinkFromSourceDSAObjGuid(
    IN  GUID *  pObjGuid
    )
//
// Retrieve the link with the specified source ntdsDsa objectGuid.
// Returns NULL if none found.
//
{
    KCC_LINK * plink = NULL;

    ASSERT_VALID(this);

    for (DWORD iLink = 0; iLink < m_cLinks; iLink++) {
        if (0 == memcmp(pObjGuid, GetLink(iLink)->GetDSAUUID(), sizeof(GUID))) {
            plink = GetLink( iLink );
            break;
        }
    }

    return plink;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\kcccache.cxx ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kcccache.cxx

ABSTRACT:

    KCC_DS_CACHE

DETAILS:

    This class acts as a cache for configuration information from the DS.

CREATED:

    04/28/99    JeffParh

REVISION HISTORY:

--*/

#include <ntdspchx.h>
extern "C" {
#include <ntsam.h>
#include <lsarpc.h>
#include <lsaisrv.h>
}
#include <dsconfig.h>
#include "kcc.hxx"
#include "kcctask.hxx"
#include "kccconn.hxx"
#include "kcctopl.hxx"
#include "kcccref.hxx"
#include "kccdsa.hxx"
#include "kcctools.hxx"
#include "kcctrans.hxx"
#include "kccsconn.hxx"
#include "kccdynar.hxx"
#include "kccsite.hxx"
#include "kccduapi.hxx"

#define FILENO FILENO_KCC_KCCCACHE

BOOL
KCC_DS_CACHE::Init()
{
    BOOL                        fSuccess = FALSE;
    NTSTATUS                    ntStatus = 0;
    LSAPR_POLICY_INFORMATION *  pPolicyInfo = NULL;
    DSNAME                     *pdnLocalSite;
    ULONG                       cBytes;
    DWORD                       i, dsid = 0;

    Reset();

    __try {
        //////////////////////////////////////////////////////////////////////
        // Stage 0 Initialization Begins

        // Cache the DNS name of the root domain.
        ntStatus = LsaIQueryInformationPolicyTrusted(
                        PolicyDnsDomainInformation,
                        &pPolicyInfo);

        if (!NT_SUCCESS(ntStatus)) {
            // LsaIQueryInformationPolicyTrusted() failed.
            dsid = DSID(FILENO_KCC_KCCCACHE, __LINE__);
            __leave;
        }

        // NULL-terminate the root domain DNS name.
        // Note: We depend on memory from new being zeroed here
        m_pszForestDnsName = (WCHAR *)
            new BYTE[pPolicyInfo->PolicyDnsDomainInfo.DnsForestName.Length + 2];

        memcpy(m_pszForestDnsName,
               pPolicyInfo->PolicyDnsDomainInfo.DnsForestName.Buffer,
               pPolicyInfo->PolicyDnsDomainInfo.DnsForestName.Length);

        // Get the system partition and ntdsDsa DNs.
        cBytes = 0;
        ntStatus = GetConfigurationName(DSCONFIGNAME_CONFIGURATION,
                                        &cBytes,
                                        m_pdnConfiguration);

        if (STATUS_BUFFER_TOO_SMALL == ntStatus) {
            m_pdnConfiguration = (DSNAME *) new BYTE[cBytes];

            ntStatus = GetConfigurationName(DSCONFIGNAME_CONFIGURATION,
                                            &cBytes,
                                            m_pdnConfiguration);
        }

        if (NT_SUCCESS(ntStatus)) {
            cBytes = 0;
            ntStatus = GetConfigurationName(DSCONFIGNAME_DMD,
                                            &cBytes,
                                            m_pdnSchema);

            if (STATUS_BUFFER_TOO_SMALL == ntStatus) {
                m_pdnSchema = (DSNAME *) new BYTE[cBytes];

                ntStatus = GetConfigurationName(DSCONFIGNAME_DMD,
                                                &cBytes,
                                                m_pdnSchema);
            }
        }

        if (NT_SUCCESS(ntStatus)) {
#if DBG
            m_fRunningUnderAltID = GetAltIdentity(&m_pdnLocalDSA);
#else
            m_fRunningUnderAltID = FALSE;
#endif
            if (!m_fRunningUnderAltID) {
                cBytes = 0;
                ntStatus = GetConfigurationName(DSCONFIGNAME_DSA,
                                                &cBytes,
                                                m_pdnLocalDSA);

                if (STATUS_BUFFER_TOO_SMALL == ntStatus) {
                    m_pdnLocalDSA = (DSNAME *) new BYTE[cBytes];

                    ntStatus = GetConfigurationName(DSCONFIGNAME_DSA,
                                                    &cBytes,
                                                    m_pdnLocalDSA);
                }
            }
        }

        if (!NT_SUCCESS(ntStatus)) {
            dsid = DSID(FILENO_KCC_KCCCACHE, __LINE__);
            __leave;
        }

        //////////////////////////////////////////////////////////////////////
        // Stage 0 Initialization Complete. Stage 1 Initialization Begins
        m_initializationStage = KCC_CACHE_STAGE_0_COMPLETE;

        // Initialize the schedule cache
        if (!(m_hScheduleCache = ToplScheduleCacheCreate())) {
            dsid = DSID(FILENO_KCC_KCCCACHE, __LINE__);
            __leave;
        }

        // Read the interSiteTransport objects.
        if (!m_TransportList.Init()) {
            dsid = DSID(FILENO_KCC_KCCCACHE, __LINE__);
            __leave;
        }

        // Find the IP transport.
        for (i = 0; i < m_TransportList.GetCount(); i++) {
            KCC_TRANSPORT * pTransport = m_TransportList.GetTransport(i);
            if (pTransport->IsIntersiteIP()) {
                m_pdnIpTransport = pTransport->GetDN();
                break;
            }
        }

        if (NULL == m_pdnIpTransport) {
            dsid = DSID(FILENO_KCC_KCCCACHE, __LINE__);
            __leave;
        }

        //////////////////////////////////////////////////////////////////////
        // Stage 1 Initialization Complete. Stage 2 Initialization Begins
        m_initializationStage = KCC_CACHE_STAGE_1_COMPLETE;

        // Initialize all site objects here. However, none of the sites
        // will contain any DSA objects yet.
        if (!m_SiteList.InitAllSites()) {
            // Failed to initialize site / DSA objects
            dsid = DSID(FILENO_KCC_KCCCACHE, __LINE__);
            __leave;
        }

        //////////////////////////////////////////////////////////////////////
        // Stage 2 Initialization Complete. Stage 3 Initialization Begins
        m_initializationStage = KCC_CACHE_STAGE_2_COMPLETE;

        // Add all the DSA objects to their sites.
        m_SiteList.PopulateDSAs();

        // Read the crossRef objects.
        if (!m_CrossRefList.Init()) {
            dsid = DSID(FILENO_KCC_KCCCACHE, __LINE__);
            __leave;
        }

        // Check that the crossRef for the Config NC could be loaded.
        if( !m_CrossRefList.GetCrossRefForNC(m_pdnConfiguration) ) {
            dsid = DSID(FILENO_KCC_KCCCACHE, __LINE__);
            __leave;
        }

        //////////////////////////////////////////////////////////////////////
        // Stage 3 Initialization Complete. Stage 4 Initialization Begins
        m_initializationStage = KCC_CACHE_STAGE_3_COMPLETE;

        // Find KCC_SITE object for local site
        pdnLocalSite = KCC_DSA::GetSiteDNSyntacticNoGuid( m_pdnLocalDSA );
        m_pLocalSite = m_SiteList.GetSite( pdnLocalSite );
        if( ! m_pLocalSite ) {
            // A match for the local site was not read.  This can occur if
            // the site was renamed or deleted while the KCC was running.
            // Abort this KCC run.
            KCC_EXCEPT(ERROR_DS_OBJ_NOT_FOUND, 0);
        }

        //////////////////////////////////////////////////////////////////////
        // Stage 4 Initialization Complete. Stage 5 Initialization Begins
        m_initializationStage = KCC_CACHE_STAGE_4_COMPLETE;

        // Find KCC_DSA object for local DSA
        m_pLocalDSA = m_pLocalSite->GetDsaList()->GetDsa( m_pdnLocalDSA );
        if( ! m_pLocalDSA ) {
            KCC_EXCEPT(ERROR_DS_OBJ_NOT_FOUND, 0);
        }

        //////////////////////////////////////////////////////////////////////
        // All Initialization Complete
        m_initializationStage = KCC_CACHE_INITIALIZATION_COMPLETE;

        fSuccess = TRUE;
    }
    __finally {
        if (NULL != pPolicyInfo) {
            LsaIFree_LSAPR_POLICY_INFORMATION(PolicyDnsDomainInformation,
                                              pPolicyInfo);
        }
    }

    if (!fSuccess) {
        DPRINT(0, "KCC_DS_CACHE::Init() failed!\n");
        LogEvent(DS_EVENT_CAT_KCC,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_KCC_CACHE_INIT_FAILED,
                 szInsertHex(dsid),
                 0,
                 0);
    }

    return fSuccess;
}

void
KCC_DS_CACHE::Reset()
{
    m_initializationStage    = KCC_CACHE_NOT_INITIALIZED;
    m_fRunningUnderAltID     = FALSE;

    m_pdnLocalDSA       = NULL;
    m_pLocalDSA         = NULL;
    m_pLocalSite        = NULL;
    m_pdnConfiguration  = NULL;
    m_pdnSchema         = NULL;
    m_pdnIpTransport    = NULL;
    m_pszForestDnsName  = NULL;
    m_hScheduleCache    = NULL;
    m_dwStayOfExecution = 0;
    m_fReadStayOfExecution = FALSE;

    m_globalDSAListByGUID   = NULL;
    m_globalDSAListByString = NULL;

    m_CrossRefList.Reset();
    m_TransportList.Reset();
    m_SiteList.Reset();

    m_fReachableMarkingComplete = FALSE;
    m_fAnySiteUnreachable = FALSE;
}

// Check that the cache finished up to 'initStage' of its initialization.
BOOL
KCC_DS_CACHE::IsValid( KCC_CACHE_INIT_STAGE initStage )
{
    Assert(NULL != this);

    if( m_initializationStage < initStage ) {
        Assert("KCC Cache initialization not complete");
        return FALSE;
    }
    
    if( m_initializationStage>=KCC_CACHE_STAGE_0_COMPLETE ) {
        Assert(NULL != m_pszForestDnsName);
        Assert(NULL != m_pdnConfiguration);
        Assert(NULL != m_pdnSchema);
        Assert(NULL != m_pdnLocalDSA);
    }

    if( m_initializationStage>=KCC_CACHE_STAGE_1_COMPLETE ) {
        Assert(NULL != m_hScheduleCache);
        ASSERT_VALID(&m_TransportList);
        Assert(NULL != m_pdnIpTransport);

        Assert(1 <= m_TransportList.GetCount());
    }

    if( m_initializationStage>=KCC_CACHE_STAGE_2_COMPLETE ) {
        ASSERT_VALID(&m_SiteList);
        Assert(1 <= m_SiteList.GetCount());
    }

    if( m_initializationStage>=KCC_CACHE_STAGE_3_COMPLETE ) {
        ASSERT_VALID(&m_CrossRefList);
        Assert(3 <= m_CrossRefList.GetCount());
    }

    if( m_initializationStage>=KCC_CACHE_STAGE_4_COMPLETE ) {
        ASSERT_VALID(m_pLocalSite);
    }

    if( m_initializationStage>=KCC_CACHE_INITIALIZATION_COMPLETE ) {
        ASSERT_VALID(m_pLocalDSA);
    }

    // The cache is valid up to the requested stage.
    return TRUE;
}

ULONG
KCC_DS_CACHE::GetStayOfExecution()
//
// Retrieve the length of time (in seconds) between when a server object is
// deleted and when we declare that it's dead forever.
//
// (This period allows the deletion to propagate to the server corresponding
// to the deleted server object and for that server to revive the object and
// propagate it back to the rest of the enterprise.)
//
{
    ATTR      rgAttrs[] =
    {
        { ATT_TOMBSTONE_LIFETIME, { 0, NULL } },
        { ATT_REPL_TOPOLOGY_STAY_OF_EXECUTION, { 0, NULL } }
    };

    ENTINFSEL Sel =
    {
        EN_ATTSET_LIST,
        { sizeof( rgAttrs )/sizeof( rgAttrs[ 0 ] ), rgAttrs },
        EN_INFOTYPES_TYPES_VALS
    };

    ULONG       dirError;
    READRES *   pReadRes = NULL;
    NTSTATUS    status;
    DWORD       cBytes = 0;
    DSNAME *    pdnDirectoryService = NULL;
    ULONG       ulTombstoneLifetimeDays;
    ULONG       ulStayOfExecutionDays, ulStayOfExecutionDaysMax;
    ULONG       ulStayOfExecutionSecs;
    BOOL        fSkipRangeCheck = FALSE;

    ASSERT_VALID(this);

    // If the stay of execution length is stored in the cache, we
    // don't bother to read it from the directory again.
    if( m_fReadStayOfExecution ) {
        return m_dwStayOfExecution;
    }

    status = GetConfigurationName(
                        DSCONFIGNAME_DS_SVC_CONFIG,
                        &cBytes,
                        pdnDirectoryService);
    Assert(STATUS_BUFFER_TOO_SMALL == status);
    pdnDirectoryService = (DSNAME *) new BYTE[ cBytes ];
    status = GetConfigurationName(
                        DSCONFIGNAME_DS_SVC_CONFIG,
                        &cBytes,
                        pdnDirectoryService);

    if ( STATUS_SUCCESS != status )
    {
        // Name derivation failed.
        LogUnhandledError( DIRERR_NAME_TOO_LONG );
        KCC_EXCEPT( DIRERR_NAME_TOO_LONG, status );
    }
    
    ulStayOfExecutionDays = 0;
    ulTombstoneLifetimeDays = DEFAULT_TOMBSTONE_LIFETIME;
    dirError = KccRead( pdnDirectoryService, &Sel, &pReadRes );

    if ( 0 != dirError )
    {
        if ( attributeError == dirError )
        {
            INTFORMPROB * pprob = &pReadRes->CommRes.pErrInfo->AtrErr.FirstProblem.intprob;

            if (    ( PR_PROBLEM_NO_ATTRIBUTE_OR_VAL == pprob->problem )
                 && ( DIRERR_NO_REQUESTED_ATTS_FOUND == pprob->extendedErr )
               )
            {
                // No value; use default (as set above).
                dirError = 0;
            }
        }

        if ( 0 != dirError )
        {
            KCC_LOG_READ_FAILURE( pdnDirectoryService, dirError );
            // Other error; bail.
            KCC_EXCEPT( DIRERR_MISSING_EXPECTED_ATT, dirError );
        }
    }
    else
    {
        // Read succeeded; parse returned attributes.
        for ( DWORD iAttr = 0; iAttr < pReadRes->entry.AttrBlock.attrCount; iAttr++ )
        {
            ATTR *  pattr = &pReadRes->entry.AttrBlock.pAttr[ iAttr ];

            switch ( pattr->attrTyp )
            {
            case ATT_TOMBSTONE_LIFETIME:
                Assert( 1 == pattr->AttrVal.valCount );
                Assert( sizeof( ULONG ) == pattr->AttrVal.pAVal->valLen );
                ulTombstoneLifetimeDays = *( (ULONG *) pattr->AttrVal.pAVal->pVal );
                break;
            
            case ATT_REPL_TOPOLOGY_STAY_OF_EXECUTION:
                Assert( 1 == pattr->AttrVal.valCount );
                Assert( sizeof( ULONG ) == pattr->AttrVal.pAVal->valLen );
                ulStayOfExecutionDays = *( (ULONG *) pattr->AttrVal.pAVal->pVal );
                if( 0 == ulStayOfExecutionDays ) {
                    DPRINT( 3, "Stay of Execution Disabled\n" );
                    fSkipRangeCheck = TRUE;
                }                    
                break;

            default:
                DPRINT1( 0, "Received unrequested attribute 0x%X.\n", pattr->attrTyp );
                break;
            }
        }

        if ( ulTombstoneLifetimeDays < DRA_TOMBSTONE_LIFE_MIN )
        {
            // Invalid value; use default.
            ulTombstoneLifetimeDays = DEFAULT_TOMBSTONE_LIFETIME;
        }
    }

    if( ! fSkipRangeCheck ) {
    
        // Calculate max stay of execution based on runtime value of tombstone life
        // DRA_TOMBSTONE_LIFE_MIN/2 <= DEFAULT_STAY_OF_EXECUTION <= tombstone-lifetime/2
    
        ulStayOfExecutionDaysMax = (ulTombstoneLifetimeDays / 2);

        // If stay is not specified, or is too small or too large
        if ( (ulStayOfExecutionDays < (DRA_TOMBSTONE_LIFE_MIN / 2) ) ||
             (ulStayOfExecutionDays > ulStayOfExecutionDaysMax) ) {
            
            // Use the default stay, unless that, too, is too large
            if ( DEFAULT_STAY_OF_EXECUTION <= ulStayOfExecutionDaysMax ) {
                 Assert( DEFAULT_STAY_OF_EXECUTION >= (DRA_TOMBSTONE_LIFE_MIN / 2) );
                 ulStayOfExecutionDays = DEFAULT_STAY_OF_EXECUTION;
            } else {
                ulStayOfExecutionDays = ulStayOfExecutionDaysMax;
            }
        }
    
        Assert( ulStayOfExecutionDays );
    
        DPRINT1( 5, "Stay of Execution days = %d\n", ulStayOfExecutionDays );
        
    }

    // Calculate number of seconds and store in cache
    m_fReadStayOfExecution = TRUE;
    m_dwStayOfExecution = ( ulStayOfExecutionDays * 24 * 60 * 60 );

    delete[] pdnDirectoryService;
    return m_dwStayOfExecution;
}

KCC_DSA_LIST*
KCC_DS_CACHE::GetGlobalDSAListByGUID()
// Retrieves a list of all DSAs in the enterprise, sorted by GUID
{
    Assert(IsValid());
    if(!m_globalDSAListByGUID) {
        m_globalDSAListByGUID = new KCC_DSA_LIST;
        m_globalDSAListByGUID->InitUnionOfSites(
                                    GetSiteList(),
                                    KCC_DSA::CompareIndirectByNtdsDsaGuid );

    }
    return m_globalDSAListByGUID;
}

KCC_DSA_LIST*
KCC_DS_CACHE::GetGlobalDSAListByString()
// Retrieves a list of all DSAs in the enterprise, sorted by string-name
{
    Assert(IsValid());
    if(!m_globalDSAListByString) {
        m_globalDSAListByString = new KCC_DSA_LIST;
        m_globalDSAListByString->InitUnionOfSites(
                                   GetSiteList(),
                                   KCC_DSA::CompareIndirectByNtdsDsaString );
    }
    return m_globalDSAListByString;
}

KCC_DSA*
KCC_DS_CACHE::GetDSAByGUID(
    GUID       *pDsaGuid
    )
//
// Find the KCC_DSA object matching 'pDsaGuid'. If the object is in the
// cache, we return it. If the object is not found, return NULL.
//
{
    KCC_DSA    *pDsa;
    DSNAME      DN = {0};

    Assert(IsValid());
    Assert(!fNullUuid(pDsaGuid));
    DN.Guid = *pDsaGuid;
    DN.structLen = DSNameSizeFromLen(0);

    // Do an in-memory search of all DSA objects.
    pDsa = GetGlobalDSAListByGUID()->GetDsa( &DN, NULL );

    // Note: pDsa may be NULL if the server was not found.
    return pDsa;
}

// Indicates that all sites have been marked as reachable / unreachable.
VOID
KCC_DS_CACHE::SetReachableMarkingComplete()
{
    m_fReachableMarkingComplete = TRUE;
}

// Checks if the KCC has finished marking all sites as reachable / unreachable
BOOL
KCC_DS_CACHE::IsReachableMarkingComplete()
{
    return m_fReachableMarkingComplete;
}


// Indicates that atleast one site found unreachable
VOID
KCC_DS_CACHE::SetAnySiteUnreachable()
{
    m_fAnySiteUnreachable = TRUE;
}

// Checks if atleast one site found unreachable
// Reachability marking may not be complete yet.
BOOL
KCC_DS_CACHE::IsAnySiteUnreachable()
{
    return m_fAnySiteUnreachable;
}


#if DBG
BOOL
KCC_DS_CACHE::GetAltIdentity(
    OUT DSNAME ** ppAltDsa
    )
//
// Hook to allow KCC to be run as if it were on a different DC.
// This is primarily here to support CDermody's scalability testing.
//
{
    ATTR rgAttrs[] = {
        { ATT_OBJ_DIST_NAME, {0, NULL} }
    };

    ENTINFSEL Sel = {
        EN_ATTSET_LIST,
        { sizeof(rgAttrs)/sizeof(rgAttrs[0]), rgAttrs },
        EN_INFOTYPES_TYPES_VALS
    };

    DWORD         winError;
    DSNAME *      pAltDsa;
    ULONG         dirError;
    READRES *     pResults;
    ATTRBLOCK *   pAttrBlock;

    pAltDsa = GetConfigDsName(MAKE_WIDE(KCC_RUN_AS_NTDSDSA_DN));
    if (!pAltDsa) {
        DPRINT(5, "No alternate identity defined.\n");
        return FALSE;
    }

    Assert(0 == pAltDsa->SidLen);
    Assert(fNullUuid(&pAltDsa->Guid));

    dirError = KccRead(pAltDsa, &Sel, &pResults);
    if (0 != dirError) {
        DPRINT2(0, "Error %d reading %ls; alternate identity will be ignored.\n",
                dirError, pAltDsa->StringName);
        KCC_LOG_READ_FAILURE( pAltDsa, dirError );
        THFree(pAltDsa);
        return FALSE;
    }

    pAttrBlock = &pResults->entry.AttrBlock;
    Assert(1 == pAttrBlock->attrCount);
    Assert(ATT_OBJ_DIST_NAME == pAttrBlock->pAttr->attrTyp);
    Assert(1 == pAttrBlock->pAttr->AttrVal.valCount);

    *ppAltDsa = (DSNAME *) pAttrBlock->pAttr->AttrVal.pAVal->pVal;

    Assert(pAttrBlock->pAttr->AttrVal.pAVal->valLen == (*ppAltDsa)->structLen);

    DPRINT1(0, "KCC running under alternate identity %ls.\n", (*ppAltDsa)->StringName);

    //
    // Cleanup
    //
    THFree(pAltDsa);

    return TRUE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\kccdynar.cxx ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kccdynar.cxx

ABSTRACT:

    This file defines some dynamic array classes           

DETAILS:


CREATED:

    03/27/97    Colin Brace (ColinBr)

REVISION HISTORY:

--*/

#include <NTDSpchx.h>
#include <dsconfig.h>
#include "kcc.hxx"
#include "kcctools.hxx"
#include "kccdsa.hxx"
#include "kccconn.hxx"
#include "kccsite.hxx"
#include "kccsitelink.hxx"
#include "kccbridge.hxx"
#include "kcctrans.hxx"
#include "kccsconn.hxx"
#include "kccdynar.hxx"

#define FILENO FILENO_KCC_KCCDYNAR

int __cdecl
CompareDsName(
    const void *elem1, 
    const void *elem2
    )
//
// elem1 and elem2 are POINTERS to POINTERS to DSNAME's
//
// WARNING: Since elem1 and elem2 are void*'s, the compiler will
// not type-check any parameters that are passed in. You must check
// that they are DSNAME**'s.
//
{
    PDSNAME DsName1 =  *(PDSNAME*)elem1;
    PDSNAME DsName2 =  *(PDSNAME*)elem2;

    Assert(DsName1);
    Assert(DsName2);

    Assert(!fNullUuid(&DsName1->Guid));
    Assert(!fNullUuid(&DsName2->Guid));

    return memcmp(&DsName1->Guid, &DsName2->Guid, sizeof(GUID));
}

int __cdecl
CompareDsNameSortElement(
    const void *elem1, 
    const void *elem2
    )
//
// elem1 and elem2 are pointers DSNAME_SORT_ELEMENTS
//
//
{
    PKCC_DSNAME_SORT_ELEMENT pElem1 =  (PKCC_DSNAME_SORT_ELEMENT)elem1;
    PKCC_DSNAME_SORT_ELEMENT pElem2 =  (PKCC_DSNAME_SORT_ELEMENT)elem2;

    Assert(pElem1);
    Assert(pElem2);

    return strcmp( pElem1->pszStringKey, pElem2->pszStringKey );
}

int __cdecl
CompareDsNameSiteElement(
    const void *elem1, 
    const void *elem2
    )
//
// elem1 and elem2 are pointers DSNAME_SITE_ELEMENTS
//
//
{
    PKCC_DSNAME_SITE_ELEMENT pElem1 =  (PKCC_DSNAME_SITE_ELEMENT)elem1;
    PKCC_DSNAME_SITE_ELEMENT pElem2 =  (PKCC_DSNAME_SITE_ELEMENT)elem2;

    Assert(pElem1);
    Assert(pElem2);

    return strcmp( pElem1->pszStringKey, pElem2->pszStringKey );
}

int __cdecl
CompareDsa(
    const void *elem1, 
    const void *elem2
    )
//
// elem1 and elem2 are pointers to pointers to KCC_DSA objects
//
//
{
    KCC_DSA* Dsa1 =  *(KCC_DSA**)elem1;
    KCC_DSA* Dsa2 =  *(KCC_DSA**)elem2;

    Assert(Dsa1);
    Assert(Dsa2);

    PDSNAME  DsName1 = Dsa1->GetDsName();
    PDSNAME  DsName2 = Dsa2->GetDsName();

    Assert(DsName1);
    Assert(DsName2);

    return CompareDsName(&DsName1, &DsName2);

}

int __cdecl
CompareConnection(
    const void *elem1, 
    const void *elem2
    )
//
// elem1 and elem2 are pointers to pointers to KCC_CONNECTION objects
//
{
    KCC_CONNECTION* pcn1 =  *(KCC_CONNECTION**)elem1;
    KCC_CONNECTION* pcn2 =  *(KCC_CONNECTION**)elem2;

    Assert( pcn1 );
    Assert( pcn2 );

    PDSNAME  pdn1 = pcn1->GetConnectionDN();
    PDSNAME  pdn2 = pcn2->GetConnectionDN();

    Assert( pdn1 );
    Assert( pdn2 );

    return CompareDsName( &pdn1, &pdn2 );

}

int __cdecl
CompareSiteAndSettings(
    const void *elem1, 
    const void *elem2
    )
//
// elem1 and elem2 are pointers to pointers to KCC_SITE objects
//
{

    KCC_SITE* psite1 =  *(KCC_SITE**)elem1;
    KCC_SITE* psite2 =  *(KCC_SITE**)elem2;

    Assert( psite1 );
    Assert( psite2 );

    // NTDS Sites Settings objectGuid originally chosen for sort order because
    // it was the only one at the time that had the objectGuid filled in.  The
    // NTDS Site Settings object may be absent or deleted in some degenerate
    // cases, however, so in which case we use the objectGuid of the site
    // object.  (If it weren't for backwards compatibility we'd just sort by
    // site objectGuid unilaterally.)

    PDSNAME pdn1 = psite1->GetNtdsSettingsDN();
    if (NULL == pdn1) {
        pdn1 = psite1->GetObjectDN();
    }

    PDSNAME pdn2 = psite2->GetNtdsSettingsDN();
    if (NULL == pdn2) {
        pdn2 = psite2->GetObjectDN();
    }

    Assert( pdn1 );
    Assert( pdn2 );

    return CompareDsName( &pdn1, &pdn2 );
}


int __cdecl
CompareIndirectSiteGuid(
    const void *elem1, 
    const void *elem2
    )
//
// elem1 and elem2 are pointers to pointers to KCC_SITE objects
//
{

    KCC_SITE* psite1 =  *(KCC_SITE**)elem1;
    KCC_SITE* psite2 =  *(KCC_SITE**)elem2;

    Assert( psite1 );
    Assert( psite2 );

    // Sort by site object guid in all cases

    PDSNAME pdn1 = psite1->GetObjectDN();
    PDSNAME pdn2 = psite2->GetObjectDN();

    Assert( pdn1 );
    Assert( pdn2 );

    return CompareDsName( &pdn1, &pdn2 );
}

int __cdecl
CompareSiteLink(
    const void *elem1, 
    const void *elem2
    )
//
// elem1 and elem2 are pointers to pointers to KCC_SITE_LINK objects
//
{

    KCC_SITE_LINK* psite1 =  *(KCC_SITE_LINK**)elem1;
    KCC_SITE_LINK* psite2 =  *(KCC_SITE_LINK**)elem2;

    Assert( psite1 );
    Assert( psite2 );

    // Sort by site object guid in all cases

    PDSNAME pdn1 = psite1->GetObjectDN();
    PDSNAME pdn2 = psite2->GetObjectDN();

    Assert( pdn1 );
    Assert( pdn2 );

    return CompareDsName( &pdn1, &pdn2 );
}

int __cdecl
CompareBridge(
    const void *elem1, 
    const void *elem2
    )
//
// elem1 and elem2 are pointers to pointers to KCC_SITE_LINK objects
//
{

    KCC_BRIDGE* pBridge1 =  *(KCC_BRIDGE**)elem1;
    KCC_BRIDGE* pBridge2 =  *(KCC_BRIDGE**)elem2;

    Assert( pBridge1 );
    Assert( pBridge2 );

    // Sort by site object guid in all cases

    PDSNAME pdn1 = pBridge1->GetObjectDN();
    PDSNAME pdn2 = pBridge2->GetObjectDN();

    Assert( pdn1 );
    Assert( pdn2 );

    return CompareDsName( &pdn1, &pdn2 );
}


int __cdecl
CompareSiteConnections(
    const void *elem1, 
    const void *elem2
    )
{

    KCC_SITE_CONNECTION* psconn1 =  *(KCC_SITE_CONNECTION**)elem1;
    KCC_SITE_CONNECTION* psconn2 =  *(KCC_SITE_CONNECTION**)elem2;

    Assert( psconn1 );
    Assert( psconn2 );

    //
    // The ordering is not really important since these are just in memory
    // objects
    //

    if ( psconn1 == psconn2 )
    {
        return 0;
    }
    else if ( psconn1 < psconn2 )
    {
        return -1;
    }
    else
    {
        return 1;
    }

}

int __cdecl
CompareCrossRefIndirectByNCDN(
    const void *elem1,
    const void *elem2
    )
{
    KCC_CROSSREF * pCR1 = *((KCC_CROSSREF **) elem1);
    KCC_CROSSREF * pCR2 = *((KCC_CROSSREF **) elem2);

    ASSERT_VALID(pCR1);
    ASSERT_VALID(pCR2);

    DSNAME * pdn1 = pCR1->GetNCDN();
    DSNAME * pdn2 = pCR2->GetNCDN();

    return CompareDsName(&pdn1, &pdn2);
}

VOID
KCC_DYNAMIC_ARRAY::Add(
    VOID* pElement
    )
{
    Assert(pElement);
    Assert( m_Count <= m_ElementsAllocated );

    if (m_Count == m_ElementsAllocated) {
        //
        // Allocate some more memory
        //
        BYTE* NewArray;
        // Exponential growth
        if (m_ElementsAllocated) {
            m_ElementsAllocated *= 2;
        } else {
            m_ElementsAllocated = m_InitialElements;
        }
        NewArray = new BYTE[m_ElementsAllocated*KccDwordAlignUlong(m_SizeOfElement)];

        //
        // Allocator should throw an exception if allocation failed
        // Allocator will initialize elements to zero.
        //

        //
        // Copy over existing elements
        //
        if (m_Count > 0) {
            Assert(m_Array);
            memcpy(NewArray, m_Array, m_Count*KccDwordAlignUlong(m_SizeOfElement));
        }

        //
        // Remove the old one and replace
        //
        if (m_Array) {
            delete [] m_Array;
        }
        m_Array = NewArray;
    }

    memcpy(&m_Array[m_Count*KccDwordAlignUlong(m_SizeOfElement)], pElement, m_SizeOfElement);
    m_Count++;

    m_fIsSorted = FALSE;
}


VOID
KCC_DYNAMIC_ARRAY::Remove(
    VOID* pElement
    )
{
    DWORD i = -1;
    
    Find(pElement, &i);
    Assert((-1 != i) && "pElement must be in the array!");

    Remove(i);
}


VOID
KCC_DYNAMIC_ARRAY::Remove(
    DWORD i
    )
{
    DWORD cbElement = KccDwordAlignUlong(m_SizeOfElement);

    Assert(i < m_Count);

    memmove(&m_Array[i * cbElement],
            &m_Array[(i+1) * cbElement],
            (m_Count - i - 1) * cbElement);
    m_Count--;
}


VOID *
KCC_DYNAMIC_ARRAY::Find(
    IN  VOID *  pElement,
    OUT DWORD * piElementIndex
    )
{
    VOID * pReturn = NULL;

    Assert(pElement);
    
    if (m_fIsSorted) {
        pReturn = bsearch(pElement,
                          m_Array,
                          m_Count,
                          KccDwordAlignUlong(m_SizeOfElement),
                          m_CompareFunction);
        if (NULL != piElementIndex) {
            *piElementIndex =
                ((DWORD)(((BYTE *) pReturn) - ((BYTE *) m_Array))) /
                KccDwordAlignUlong(m_SizeOfElement);
        }
    }
    else {
        for (ULONG i = 0; i < m_Count; i++) {
            VOID * pCurrent = Get(i);

            if (0 == m_CompareFunction(pElement, pCurrent)) {
                pReturn = pCurrent;
                if (NULL != piElementIndex) {
                    *piElementIndex = i;
                }
                break;
            }
        }
    }
    
    return pReturn;
}


VOID
KCC_DSA_ARRAY::GetLocalDsasHoldingNC(
    IN     KCC_CROSSREF        *pCrossRef,
    IN     BOOL                 fMasterOnly
    )
/*++

Routine Description:

    Given the crossref for an NC, find all DSAs in the local site
    hosting the NC. If 'fMasterOnly' is true, we only accept
    DSAs which host a master copy. The previous contents of this
    DSA array are removed.

Parameters:

    pCrossRef        - The Crossref for the NC we're searching on
    fMasterOnly      - If this is true, we only accept DSAs holding a
                       master copy
                       
Returns:

    None - the only errors are unexpected errors - so an exception is thrown
    
--*/
{
    KCC_DSA_LIST   *pDsaList = gpDSCache->GetLocalSite()->GetDsaList();
    KCC_DSA        *pDsa, *pLocalDsa = gpDSCache->GetLocalDSA();
    BOOL            fIsMaster;
    DWORD           idsa, cdsa;

    ASSERT_VALID( this );
    ASSERT_VALID( pDsaList );
    ASSERT_VALID( pCrossRef );

    this->RemoveAll();

    cdsa = pDsaList->GetCount();
    for( idsa=0; idsa<cdsa; idsa++ ) {
        pDsa = pDsaList->GetDsa(idsa);
        ASSERT_VALID(pDsa);

        if(    pDsa->IsNCHost(pCrossRef, (pDsa==pLocalDsa), &fIsMaster)
           && (!fMasterOnly || fIsMaster) )
        {
            this->Add(pDsa);
        }
    }
}

VOID
KCC_DSA_ARRAY::GetLocalGCs(
    VOID
    )
/*++

Routine Description:

    Find all GCs in the local site and add them this DSA Array.
    All previous contents of this array are removed.

Parameters:

    None

Return values:

    None
    
--*/
{
    KCC_DSA_LIST   *pDsaList = gpDSCache->GetLocalSite()->GetDsaList();
    KCC_DSA        *pDsa;
    DWORD           idsa, cdsa;

    ASSERT_VALID( this );
    ASSERT_VALID( pDsaList );

    this->RemoveAll();

    cdsa = pDsaList->GetCount();
    for( idsa=0; idsa<cdsa; idsa++ )
    {
        pDsa = pDsaList->GetDsa(idsa);
        ASSERT_VALID(pDsa);
        
        if(pDsa->IsGC()) {
            this->Add(pDsa);
        }
    }
}


VOID
KCC_DSA_ARRAY::GetViableISTGs(
    VOID
    )
/*++

Routine Description:

    Find all DCs in the local site which are acceptable ISTGs.
    All previous contents of the array are removed.

Parameters:

    None

Return values:

    None

--*/
{
    KCC_DSA_LIST   *pDsaList = gpDSCache->GetLocalSite()->GetDsaList();
    KCC_DSA        *pDsa, *pLocalDSA = gpDSCache->GetLocalDSA();
    DWORD           idsa, cdsa;

    ASSERT_VALID( this );
    ASSERT_VALID( pDsaList );
    Assert( 0 != pDsaList->GetCount() );
    Assert( pLocalDSA == pDsaList->GetDsa(pLocalDSA->GetDsName()) );
    Assert( pLocalDSA->IsViableSiteGenerator() );

    this->RemoveAll();

    // Of the DSAs in this site, which are viable ISTGs?
    cdsa = pDsaList->GetCount();
    for( idsa=0; idsa<cdsa; idsa++ ) {
        pDsa = pDsaList->GetDsa(idsa);
        if( pDsa->IsViableSiteGenerator() ) {
            this->Add(pDsa);
        }
    }

    // At minimum the local DSA should be in this list.
    Assert(0 != this->GetCount());
    Assert(NULL != this->Find(pLocalDSA->GetDsName()));
}


KCC_DSA *
KCC_DSA_ARRAY::Find(
    IN  DSNAME *  pDsName,
    OUT DWORD *   piElementIndex
    )
{
    Assert(pDsName);

    KCC_DSA     DsaKey;
    KCC_DSA *   pDsaKey = &DsaKey;
    KCC_DSA **  ppDsaFound;
    KCC_DSA *   pDsaFound = NULL;

    DsaKey.InitForKey(pDsName);

    ppDsaFound = (KCC_DSA **) KCC_DYNAMIC_ARRAY::Find(&pDsaKey, piElementIndex);

    if (NULL != ppDsaFound) {
        pDsaFound = *ppDsaFound;
    }

    return pDsaFound;
}


KCC_SITE *
KCC_SITE_ARRAY::Find(
    IN  DSNAME *  pDsName
    )
{
    Assert(pDsName);

    KCC_SITE     SiteKey;
    KCC_SITE *   pSiteKey = &SiteKey;
    KCC_SITE **  ppSiteFound;
    KCC_SITE *   pSiteFound = NULL;

    Assert( m_fIsSorted );

    // This routine only initialzes the site object dn part of the key.
    // It only works with a sorting scheme that is based on the site
    // object dn only. Thus it cannot be used with the legacy CompareSite
    // sorting function.
    Assert( m_CompareFunction != CompareSiteAndSettings );

    SiteKey.InitForKey(pDsName);

    ppSiteFound = (KCC_SITE **) KCC_DYNAMIC_ARRAY::Find(&pSiteKey);

    if (NULL != ppSiteFound) {
        pSiteFound = *ppSiteFound;
    }

    return pSiteFound;
}

KCC_SITE_LINK *
KCC_SITE_LINK_ARRAY::Find(
    IN  DSNAME *  pDsName
    )
{
    Assert(pDsName);

    KCC_SITE_LINK     SiteKey;
    KCC_SITE_LINK *   pSiteKey = &SiteKey;
    KCC_SITE_LINK **  ppSiteFound;
    KCC_SITE_LINK *   pSiteFound = NULL;

    Assert( m_fIsSorted );

    SiteKey.InitForKey(pDsName);

    ppSiteFound = (KCC_SITE_LINK **) KCC_DYNAMIC_ARRAY::Find(&pSiteKey);

    if (NULL != ppSiteFound) {
        pSiteFound = *ppSiteFound;
    }

    return pSiteFound;
}

KCC_BRIDGE *
KCC_BRIDGE_ARRAY::Find(
    IN  DSNAME *  pDsName
    )
{
    Assert(pDsName);

    KCC_BRIDGE     BridgeKey;
    KCC_BRIDGE *   pBridgeKey = &BridgeKey;
    KCC_BRIDGE **  ppBridgeFound;
    KCC_BRIDGE *   pBridgeFound = NULL;

    Assert( m_fIsSorted );

    BridgeKey.InitForKey(pDsName);

    ppBridgeFound = (KCC_BRIDGE **) KCC_DYNAMIC_ARRAY::Find(&pBridgeKey);

    if (NULL != ppBridgeFound) {
        pBridgeFound = *ppBridgeFound;
    }

    return pBridgeFound;
}



VOID
KCC_DSNAME_ARRAY::Add(
    IN DSNAME * pdn
    )
{
    KCC_DSNAME_SORT_ELEMENT dse;

    Assert( NULL!=pdn );

    dse.pszStringKey = DSNAMEToMappedStrExternal( pdn );
    dse.pDn = pdn;

    if( NULL==dse.pszStringKey ) {
        KCC_MEM_EXCEPT(0);
    }

    KCC_DYNAMIC_ARRAY::Add(&dse);
}

BOOL
KCC_DSNAME_ARRAY::IsElementOf(
    IN DSNAME * pdn
    )
{
    KCC_DSNAME_SORT_ELEMENT dse;
    VOID *pvElement;

    Assert( NULL!=pdn );

    // This is a dummy search key
    dse.pszStringKey = DSNAMEToMappedStrExternal( pdn );
    dse.pDn = NULL;

    if( NULL==dse.pszStringKey ) {
        KCC_MEM_EXCEPT(0);
    }

    pvElement = KCC_DYNAMIC_ARRAY::Find(&dse);

    THFree( dse.pszStringKey );

    return pvElement != NULL;
}





VOID
KCC_DSNAME_SITE_ARRAY::Add(
    IN DSNAME * pdn,
    IN KCC_SITE *pSite
    )
{
    KCC_DSNAME_SITE_ELEMENT dse;

    Assert( NULL!=pdn );
    Assert( NULL!=pSite );

    dse.pszStringKey = DSNAMEToMappedStrExternal( pdn );
    dse.pSite = pSite;

    if( NULL==dse.pszStringKey ) {
        KCC_MEM_EXCEPT(0);
    }

    KCC_DYNAMIC_ARRAY::Add(&dse);
}

KCC_SITE *
KCC_DSNAME_SITE_ARRAY::Find(
    IN DSNAME * pdn
    )
{
    KCC_DSNAME_SITE_ELEMENT dse;
    VOID *pvElement;

    Assert( NULL!=pdn );

    // This is a dummy search key
    dse.pszStringKey = DSNAMEToMappedStrExternal( pdn );
    dse.pSite = NULL;

    if( NULL==dse.pszStringKey ) {
        KCC_MEM_EXCEPT(0);
    }

    pvElement = KCC_DYNAMIC_ARRAY::Find(&dse);

    THFree( dse.pszStringKey );

    if (pvElement) {
        return ((KCC_DSNAME_SITE_ELEMENT *) pvElement)->pSite;
    } else {
        return NULL;
    }
}

BOOL
KCC_DSNAME_SITE_ARRAY::IsElementOf(
    IN DSNAME * pdn
    )
{
    return (Find( pdn ) != NULL);
}





KCC_REPLICATED_NC *
KCC_REPLICATED_NC_ARRAY::Find(
    IN DSNAME * pNC
    )
{
    KCC_REPLICATED_NC keybase;
    KCC_REPLICATED_NC *key = &keybase;
    VOID *pvElement;

    keybase.pNC = pNC;
    keybase.fReadOnly = FALSE; // ignored

    pvElement = KCC_DYNAMIC_ARRAY::Find(&key);

    if (pvElement) {
        return *((KCC_REPLICATED_NC **) pvElement);
    } else {
        return NULL;
    }
}

int __cdecl
KCC_REPLICATED_NC_ARRAY::CompareIndirect(
    IN const void *elem1,
    IN const void *elem2
    )
{
    KCC_REPLICATED_NC * p1 = *(KCC_REPLICATED_NC **) elem1;
    KCC_REPLICATED_NC * p2 = *(KCC_REPLICATED_NC **) elem2;
    int nDiff;

    Assert(!fNullUuid(&p1->pNC->Guid));
    Assert(!fNullUuid(&p2->pNC->Guid));

    nDiff = CompareDsName(&p1->pNC, &p2->pNC);
    
    return nDiff;
}

BOOL
KCC_NC_TRANSPORT_BRIDGEHEAD_ARRAY::Find(
     IN  DSNAME *        pNC,
     IN  KCC_TRANSPORT * pTransport,
     IN  BOOL            fGCTopology,
     OUT KCC_DSA **      ppDSA
     )
{
    KCC_NC_TRANSPORT_BRIDGEHEAD_ENTRY Key = {pNC, pTransport, fGCTopology, NULL};
    KCC_NC_TRANSPORT_BRIDGEHEAD_ENTRY * pFound;

    pFound = (KCC_NC_TRANSPORT_BRIDGEHEAD_ENTRY *) KCC_DYNAMIC_ARRAY::Find(&Key);
    if (NULL != pFound) {
        *ppDSA = pFound->pDSA;
    }

    return (NULL != pFound);
}

int __cdecl
KCC_NC_TRANSPORT_BRIDGEHEAD_ARRAY::Compare(
    const void *elem1, 
    const void *elem2
    )
{
    KCC_NC_TRANSPORT_BRIDGEHEAD_ENTRY * p1 = (KCC_NC_TRANSPORT_BRIDGEHEAD_ENTRY *) elem1;
    KCC_NC_TRANSPORT_BRIDGEHEAD_ENTRY * p2 = (KCC_NC_TRANSPORT_BRIDGEHEAD_ENTRY *) elem2;
    int nDiff;

    nDiff = p1->fGCTopology - p2->fGCTopology;

    if (0 == nDiff) {
        if (p1->pTransport > p2->pTransport) {
            nDiff = 1;
        } else if (p1->pTransport < p2->pTransport) {
            nDiff = -1;
        } else {
            nDiff = 0;
        }
    }
    
    if (0 == nDiff) {
        nDiff = CompareDsName(&p1->pNC, &p2->pNC);
    }

    return nDiff;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\kccmain.cxx ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kccmain.cxx

ABSTRACT:

    The KCC serves as an automated administrator.  It performs directory
    management tasks both periodically and based upon notifications.

    It is designed to live in-process with NTDSA.DLL (i.e., inside
    the LSA process).

DETAILS:

    All KCC tasks are performed indirectly by the task queue, and thus are
    processed one at a time.  Periodic tasks are registered at KCC
    initialization and reschedule themselves when they complete.
    Notifications similarly cause tasks to be added to the task queue
    (which do not automatically reschedule themselves).

CREATED:

    01/13/97    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <NTDSpchx.h>
#pragma  hdrstop

#include <limits.h>
#include <dsconfig.h>

#include "kcc.hxx"
#include "kcctask.hxx"
#include "kccconn.hxx"
#include "kcctopl.hxx"
#include "kccsite.hxx"
#include "kccstale.hxx"
#include "kcctools.hxx"

#define  FILENO FILENO_KCC_KCCMAIN



//
// KCC global variables
//

KCC_STATE   geKccState                  = KCC_STOPPED;
HANDLE      ghKccShutdownEvent          = NULL;
BOOL        gfRunningUnderAltID         = FALSE;


// A bitmask specifying all valid flags which may be passed
// in a DRS_MSG_KCC_EXECUTE message.
#define ALL_DS_KCC_FLAGS_MASK           (  DS_KCC_FLAG_ASYNC_OP \
                                         | DS_KCC_FLAG_DAMPED   \
                                        )

// Time after boot of first replication topology update and the interval between
// subsequent executions of this task.
#define KCC_DEFAULT_UPDATE_TOPL_DELAY   (5 * MINS_IN_SECS)          // Seconds.
#define KCC_MIN_UPDATE_TOPL_DELAY       (20)                        // Seconds.
#define KCC_MAX_UPDATE_TOPL_DELAY       (ULONG_MAX)                 // Seconds.

#define KCC_DEFAULT_UPDATE_TOPL_PERIOD  (15 * MINS_IN_SECS)         // Seconds.
#define KCC_MIN_UPDATE_TOPL_PERIOD      (20)                        // Seconds.
#define KCC_MAX_UPDATE_TOPL_PERIOD      (ULONG_MAX)                 // Seconds.

DWORD gcSecsUntilFirstTopologyUpdate  = 0;
DWORD gcSecsBetweenTopologyUpdates    = 0;


// These global values are the thresholds by which servers necessary for the
// ring topology and servers needed for gc topology are measured against when
// determing if they are valid source servers.
#define KCC_DEFAULT_CRIT_FAILOVER_TRIES     (0)
#define KCC_MIN_CRIT_FAILOVER_TRIES         (0)
#define KCC_MAX_CRIT_FAILOVER_TRIES         (ULONG_MAX)

#define KCC_DEFAULT_CRIT_FAILOVER_TIME      (2 * HOURS_IN_SECS)     // Seconds.
#define KCC_MIN_CRIT_FAILOVER_TIME          (0)                     // Seconds.
#define KCC_MAX_CRIT_FAILOVER_TIME          (ULONG_MAX)             // Seconds.

#define KCC_DEFAULT_NONCRIT_FAILOVER_TRIES  (1)
#define KCC_MIN_NONCRIT_FAILOVER_TRIES      (0)
#define KCC_MAX_NONCRIT_FAILOVER_TRIES      (ULONG_MAX)

#define KCC_DEFAULT_NONCRIT_FAILOVER_TIME   (12 * HOURS_IN_SECS)    // Seconds.
#define KCC_MIN_NONCRIT_FAILOVER_TIME       (0)                     // Seconds.
#define KCC_MAX_NONCRIT_FAILOVER_TIME       (ULONG_MAX)             // Seconds.

#define KCC_DEFAULT_INTERSITE_FAILOVER_TRIES  (1)
#define KCC_MIN_INTERSITE_FAILOVER_TRIES      (0)
#define KCC_MAX_INTERSITE_FAILOVER_TRIES      (ULONG_MAX)

#define KCC_DEFAULT_INTERSITE_FAILOVER_TIME   (2 * HOURS_IN_SECS)   // Seconds.
#define KCC_MIN_INTERSITE_FAILOVER_TIME       (0)                   // Seconds.
#define KCC_MAX_INTERSITE_FAILOVER_TIME       (ULONG_MAX)           // Seconds.

#define KCC_DEFAULT_CONNECTION_PROBATION_TIME (8 * HOURS_IN_SECS)   // Seconds.
#define KCC_MIN_CONNECTION_PROBATION_TIME     (0)                   // Seconds.
#define KCC_MAX_CONNECTION_PROBATION_TIME     (ULONG_MAX)           // Seconds.

#define KCC_DEFAULT_CONNECTION_RETENTION_TIME (7 * 24 * HOURS_IN_SECS)   // Seconds.
#define KCC_MIN_CONNECTION_RETENTION_TIME     (0)                   // Seconds.
#define KCC_MAX_CONNECTION_RETENTION_TIME     (ULONG_MAX)           // Seconds.

#define KCC_DEFAULT_CONN_REPEAT_DEL_TOLERANCE (3)   // Occurrences
#define KCC_MIN_CONN_REPEAT_DEL_TOLERANCE     (1)                   // Occurrences.
#define KCC_MAX_CONN_REPEAT_DEL_TOLERANCE     (ULONG_MAX)           // Occurrences.

DWORD gcCriticalLinkFailuresAllowed     = 0;
DWORD gcSecsUntilCriticalLinkFailure    = 0;
DWORD gcNonCriticalLinkFailuresAllowed  = 0;
DWORD gcSecsUntilNonCriticalLinkFailure = 0;
DWORD gcIntersiteLinkFailuresAllowed    = 0;
DWORD gcSecsUntilIntersiteLinkFailure   = 0;
DWORD gcConnectionProbationSecs         = 0;
DWORD gcConnectionRetentionSecs         = 0;
DWORD gcConnectionRepeatedDeletionTolerance = 0;

// Do we allow asynchronous replication (e.g., over SMTP) of writeable domain
// NC info?  We currently inhibit this, ostensibly to reduce our test matrix.

#define KCC_DEFAULT_ALLOW_MBR_BETWEEN_DCS_OF_SAME_DOMAIN    (FALSE)
#define KCC_MIN_ALLOW_MBR_BETWEEN_DCS_OF_SAME_DOMAIN        (0)
#define KCC_MAX_ALLOW_MBR_BETWEEN_DCS_OF_SAME_DOMAIN        (ULONG_MAX)

BOOL gfAllowMbrBetweenDCsOfSameDomain = FALSE;


// What priority does the topology generation thread run at? The thread priorities
// are values in the range (-2,..,2), but the registry can only store DWORDs, so
// we bias the stored priority values with KCC_THREAD_PRIORITY_BIAS.
#define KCC_DEFAULT_THREAD_PRIORITY 2
#define KCC_MIN_THREAD_PRIORITY     0
#define KCC_MAX_THREAD_PRIORITY     4
DWORD gdwKccThreadPriority;


// How long should a repsTo fail before it is considered stale.
#define KCC_DEFAULT_REPSTO_FAILURE_TIME (24 * HOURS_IN_SECS)   // Seconds.
#define KCC_MIN_REPSTO_FAILURE_TIME     (1)                   // Seconds.
#define KCC_MAX_REPSTO_FAILURE_TIME     (ULONG_MAX)           // Seconds.
DWORD gcSecsUntilRepsToFailure;

// How many seconds into the future do we look for duplicate
// entries in the task queue.
#define KCC_DEFAULT_TASK_DAMPENING_TIME       (20)                  // Seconds.
#define KCC_MIN_TASK_DAMPENING_TIME           (0)                   // Seconds.
#define KCC_MAX_TASK_DAMPENING_TIME           (ULONG_MAX)           // Seconds.
DWORD gcTaskDampeningSecs = KCC_DEFAULT_TASK_DAMPENING_TIME;


// Registry key and event to track changes to our registry parameters.
HKEY    ghkParameters = NULL;
HANDLE  ghevParametersChange = NULL;
        

// Default Intra-site schedule.  This determines the polling interval that
// destinations use to ask for changes from their sources.
// Since notifications are the perferred mechanism to disseminating changes,
// make the interval relatively infrequent.
//
// Note:- If you change this, please make sure to change the
//        g_defaultSchedDBData[] defined in dsamain\boot\addobj.cxx
//        which defines the intrasite schedule in global NT schedule format.

const DWORD rgdwDefaultIntrasiteSchedule[] = {
    sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES,       // Size (in bytes)
    0,                                              // Bandwidth
    1,                                              // NumberOfSchedules
    SCHEDULE_INTERVAL,                              // Schedules[0].Type
    sizeof(SCHEDULE),                               // Schedules[0].Offset
    0x01010101, 0x01010101, 0x01010101, 0x01010101, // Schedule 0 data
    0x01010101, 0x01010101, 0x01010101, 0x01010101, //   (once an hour)
    0x01010101, 0x01010101, 0x01010101, 0x01010101, // 4 DWORDs * 4 bytes/DWORD
    0x01010101, 0x01010101, 0x01010101, 0x01010101, //   * 10.5 rows
                                                    //   = 168 bytes
    0x01010101, 0x01010101, 0x01010101, 0x01010101, //   = SCHEDULE_DATA_ENTRIES
    0x01010101, 0x01010101, 0x01010101, 0x01010101,
    0x01010101, 0x01010101, 0x01010101, 0x01010101,
    0x01010101, 0x01010101, 0x01010101, 0x01010101,
    
    0x01010101, 0x01010101, 0x01010101, 0x01010101,
    0x01010101, 0x01010101, 0x01010101, 0x01010101,
    0x01010101, 0x01010101
};
const SCHEDULE * gpDefaultIntrasiteSchedule = (SCHEDULE *) rgdwDefaultIntrasiteSchedule;

// The intrasite schedule object is first created when we read the local
// NTDS Site Settings object, which always precedes its use. 
TOPL_SCHEDULE gpIntrasiteSchedule = NULL;
BOOLEAN       gfIntrasiteSchedInited = FALSE;


KCC_TASK_UPDATE_REPL_TOPOLOGY   gtaskUpdateReplTopology;
KCC_CONNECTION_FAILURE_CACHE    gConnectionFailureCache;
KCC_LINK_FAILURE_CACHE          gLinkFailureCache;
KCC_DS_CACHE *                  gpDSCache = NULL;
KCC_CONNECTION_DELETION_CACHE   gConnectionDeletionCache;

//
// For efficiency sake, don't start refreshing until we have at least
// seven servers, since we typically won't have any optimizing edges
// to refresh.
//
BOOL  gfLastServerCountSet = FALSE;
ULONG gLastServerCount = 0;

#ifdef ANALYZE_STATE_SERVER
BOOL                            gfDumpStaleServerCaches = FALSE;
BOOL                            gfDumpConnectionReason  = FALSE;
#endif

// Event logging config (as exported from ntdsa.dll).
DS_EVENT_CONFIG * gpDsEventConfig = NULL;

void KccLoadParameters();


DWORD
KccInitialize()
{
    DWORD         dwWin32Status = ERROR_SUCCESS;
    SPAREFN_INFO  rgSpareInfo[1];
    DWORD         cSpares = sizeof(rgSpareInfo) / sizeof(rgSpareInfo[0]);
    DWORD         winError;

    if ( KCC_STOPPED != geKccState )
    {
        Assert( !"Attempt to reinitialize KCC while it's running!" );
        dwWin32Status = ERROR_DS_INTERNAL_FAILURE;
    }
    else
    {
        // initialize KCC state
        ghKccShutdownEvent = NULL;

        // Initialize logging (as exported from ntdsa.dll).
        gpDsEventConfig = DsGetEventConfig();

        // Open parameters reg key.
        winError = RegOpenKey(HKEY_LOCAL_MACHINE,
                              DSA_CONFIG_SECTION,
                              &ghkParameters);
        if (0 != winError) {
            LogUnhandledError(winError);
        }
            
        // Create an event to signal changes in the parameters reg key.
        ghevParametersChange = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (NULL == ghevParametersChange) {
            winError = GetLastError();
            LogUnhandledError(winError);
        }
        
        // Watch for changes in the parameters reg key.
        rgSpareInfo[0].hevSpare = ghevParametersChange;
        rgSpareInfo[0].pfSpare  = KccLoadParameters;

        // Get our current config parameters from the registry.
        KccLoadParameters();

        ghKccShutdownEvent = CreateEvent(
                                NULL,   // no security descriptor
                                TRUE,   // is manual-reset
                                FALSE,  // !is initially signalled
                                NULL    // no name
                                );

        if ( NULL == ghKccShutdownEvent )
        {
            dwWin32Status = GetLastError();
            LogUnhandledErrorAnonymous( dwWin32Status );
        }
        else
        {
            if (!InitTaskScheduler(cSpares, rgSpareInfo, TRUE)) {
                dwWin32Status = ERROR_NOT_ENOUGH_MEMORY;

                LogUnhandledErrorAnonymous( dwWin32Status );
            }
            else
            {
                // initialize global ConnectionFailureCache
                if ( !gConnectionFailureCache.Init() ) {
                    // don't bail out
                    DPRINT( 0, "gConnectionFailureCache.Init failed\n" );
                }
                
                // initialize global ConnectionFailureCache
                if ( !gLinkFailureCache.Init() ) {
                    // don't bail out
                    DPRINT( 0, "gLinkFailureCache.Init failed\n" );
                }
                    
                // register periodic tasks
                if ( !gtaskUpdateReplTopology.Init() ) {
                    dwWin32Status = ERROR_NOT_ENOUGH_MEMORY;
                    LogUnhandledErrorAnonymous( dwWin32Status );
                }
            }
        }

        if ( dwWin32Status == ERROR_SUCCESS )
        {
            LogEvent(
                DS_EVENT_CAT_KCC,
                DS_EVENT_SEV_EXTENSIVE,
                DIRLOG_CHK_INIT_SUCCESS,
                0,
                0,
                0
                );

            geKccState = KCC_STARTED;
        }
        else
        {
            LogEvent(
                DS_EVENT_CAT_KCC,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_CHK_INIT_FAILURE,
                szInsertWin32ErrCode( dwWin32Status ),
                szInsertWin32Msg( dwWin32Status ),
                0
                );

            // initialization failed; shut down
            Assert( !"KCC could not be initialized!" );
            KccUnInitializeTrigger( );
            KccUnInitializeWait( INFINITE );
        }
    }

    return dwWin32Status;
}


void
KccUnInitializeTrigger( )
{
    if (NULL != ghKccShutdownEvent)
    {
        // KCC was started -- trigger shutdown.
        geKccState = KCC_STOPPING;
        
        // signal logging change monitor to shut down
        SetEvent( ghKccShutdownEvent );
        ShutdownTaskSchedulerTrigger( );
    }
    else
    {
        // KCC was never started.  Don't log events, as eventing (specifically
        // ntdskcc!gpDsEventConfig) has not been initialized.
        Assert(KCC_STOPPED == geKccState);
    }
}


DWORD
KccUnInitializeWait(
    DWORD   dwMaxWaitInMsec
    )
{
    DWORD       dwWin32Status = ERROR_SUCCESS;
    DWORD       waitStatus;

    if (NULL != ghKccShutdownEvent)
    {
        // KCC was started -- wait for shutdown, if it hasn't completed yet.
        if (KCC_STOPPED != geKccState)
        {
    
            if ( !ShutdownTaskSchedulerWait( dwMaxWaitInMsec ) )
            {
                dwWin32Status = ERROR_INVALID_FUNCTION;
            }
            else
            {
                CloseHandle( ghKccShutdownEvent );
    
                ghKccShutdownEvent = NULL;
                geKccState         = KCC_STOPPED;
            }
        }
    
        if ( dwWin32Status == ERROR_SUCCESS )
        {
            LogEvent(
                DS_EVENT_CAT_KCC,
                DS_EVENT_SEV_EXTENSIVE,
                DIRLOG_CHK_STOP_SUCCESS,
                0,
                0,
                0
                );
        }
        else
        {
            LogEvent(
                DS_EVENT_CAT_KCC,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_CHK_STOP_FAILURE,
                szInsertWin32ErrCode( dwWin32Status ),
                szInsertWin32Msg( dwWin32Status ),
                0
                );
    
            Assert( !"KCC could not be stopped!" );
        }
    }
    else
    {
        // KCC was never started.  Don't log events, as eventing (specifically
        // ntdskcc!gpDsEventConfig) has not been initialized.
        Assert(KCC_STOPPED == geKccState);
    }

    return dwWin32Status;
}


#ifdef INCLUDE_UNIT_TESTS

void
KccBOTest()
{
    // WARNING: DELIBERATE BUFFER OVERFLOW TO TEST /GS SUPPORT
    char pStackBuffer[10], *pHeapBuffer;
    DWORD err, dwBufferSize;
    
    err = GetConfigParamAllocA( KCC_BO_TEST, (PVOID*) &pHeapBuffer, &dwBufferSize );
    if( !err && pHeapBuffer ) {
        DPRINT1( 0, "BO Test: %s\n", pHeapBuffer );
        memcpy( pStackBuffer, pHeapBuffer, dwBufferSize );
        free( pHeapBuffer );
        Beep( 440, 1000 );
    } else {
        Beep( 880, 250 );
    }
}

#endif


void
KccLoadParameters()
/*++

Routine Description:

    Refreshes intenal globals derived from our registry config.

Arguments:

    None.

Return Values:

    None.

--*/
{
    const struct {
        LPSTR   pszValueName;
        DWORD   dwDefaultValue;
        DWORD   dwMinValue;
        DWORD   dwMaxValue;
        DWORD   dwMultiplier;
        DWORD * pdwMultipliedValue;
    } rgValues[] =  {   { KCC_UPDATE_TOPL_DELAY,
                          KCC_DEFAULT_UPDATE_TOPL_DELAY,
                          KCC_MIN_UPDATE_TOPL_DELAY,
                          KCC_MAX_UPDATE_TOPL_DELAY,
                          SECS_IN_SECS,
                          &gcSecsUntilFirstTopologyUpdate },
                        
                        { KCC_UPDATE_TOPL_PERIOD,
                          KCC_DEFAULT_UPDATE_TOPL_PERIOD,
                          KCC_MIN_UPDATE_TOPL_PERIOD,
                          KCC_MAX_UPDATE_TOPL_PERIOD,
                          SECS_IN_SECS,
                          &gcSecsBetweenTopologyUpdates },
                        
                        { KCC_CRIT_FAILOVER_TRIES,
                          KCC_DEFAULT_CRIT_FAILOVER_TRIES,
                          KCC_MIN_CRIT_FAILOVER_TRIES,
                          KCC_MAX_CRIT_FAILOVER_TRIES,
                          1,
                          &gcCriticalLinkFailuresAllowed },

                        { KCC_CRIT_FAILOVER_TIME,
                          KCC_DEFAULT_CRIT_FAILOVER_TIME,
                          KCC_MIN_CRIT_FAILOVER_TIME,
                          KCC_MAX_CRIT_FAILOVER_TIME,
                          SECS_IN_SECS,
                          &gcSecsUntilCriticalLinkFailure },

                        { KCC_NONCRIT_FAILOVER_TRIES,
                          KCC_DEFAULT_NONCRIT_FAILOVER_TRIES,
                          KCC_MIN_NONCRIT_FAILOVER_TRIES,
                          KCC_MAX_NONCRIT_FAILOVER_TRIES,
                          1,
                          &gcNonCriticalLinkFailuresAllowed },

                        { KCC_NONCRIT_FAILOVER_TIME,
                          KCC_DEFAULT_NONCRIT_FAILOVER_TIME,
                          KCC_MIN_NONCRIT_FAILOVER_TIME,
                          KCC_MAX_NONCRIT_FAILOVER_TIME,
                          SECS_IN_SECS,
                          &gcSecsUntilNonCriticalLinkFailure },

                        { KCC_INTERSITE_FAILOVER_TRIES,
                          KCC_DEFAULT_INTERSITE_FAILOVER_TRIES,
                          KCC_MIN_INTERSITE_FAILOVER_TRIES,
                          KCC_MAX_INTERSITE_FAILOVER_TRIES,
                          1,
                          &gcIntersiteLinkFailuresAllowed },

                        { KCC_INTERSITE_FAILOVER_TIME,
                          KCC_DEFAULT_INTERSITE_FAILOVER_TIME,
                          KCC_MIN_INTERSITE_FAILOVER_TIME,
                          KCC_MAX_INTERSITE_FAILOVER_TIME,
                          SECS_IN_SECS,
                          &gcSecsUntilIntersiteLinkFailure },

#ifdef ALLOW_MBR_BETWEEN_DCS_OF_SAME_DOMAIN_IF_REGKEY_SET
                        { KCC_ALLOW_MBR_BETWEEN_DCS_OF_SAME_DOMAIN,
                          KCC_DEFAULT_ALLOW_MBR_BETWEEN_DCS_OF_SAME_DOMAIN,
                          KCC_MIN_ALLOW_MBR_BETWEEN_DCS_OF_SAME_DOMAIN,
                          KCC_MAX_ALLOW_MBR_BETWEEN_DCS_OF_SAME_DOMAIN,
                          1,
                          (DWORD *) &gfAllowMbrBetweenDCsOfSameDomain },
#endif

                        { KCC_THREAD_PRIORITY,
                          KCC_DEFAULT_THREAD_PRIORITY,
                          KCC_MIN_THREAD_PRIORITY,
                          KCC_MAX_THREAD_PRIORITY,
                          1,
                          &gdwKccThreadPriority },
                          
                        { KCC_CONNECTION_PROBATION_TIME,
                          KCC_DEFAULT_CONNECTION_PROBATION_TIME,
                          KCC_MIN_CONNECTION_PROBATION_TIME,
                          KCC_MAX_CONNECTION_PROBATION_TIME,
                          SECS_IN_SECS,
                          &gcConnectionProbationSecs },

                        { KCC_CONNECTION_RETENTION_TIME,
                          KCC_DEFAULT_CONNECTION_RETENTION_TIME,
                          KCC_MIN_CONNECTION_RETENTION_TIME,
                          KCC_MAX_CONNECTION_RETENTION_TIME,
                          SECS_IN_SECS,
                          &gcConnectionRetentionSecs },

                        { KCC_CONN_REPEAT_DEL_TOLERANCE,
                          KCC_DEFAULT_CONN_REPEAT_DEL_TOLERANCE,
                          KCC_MIN_CONN_REPEAT_DEL_TOLERANCE,
                          KCC_MAX_CONN_REPEAT_DEL_TOLERANCE,
                          1,
                          &gcConnectionRepeatedDeletionTolerance },

                        { KCC_REPSTO_FAILURE_TIME,
                          KCC_DEFAULT_REPSTO_FAILURE_TIME,
                          KCC_MIN_REPSTO_FAILURE_TIME,
                          KCC_MAX_REPSTO_FAILURE_TIME,
                          SECS_IN_SECS,
                          &gcSecsUntilRepsToFailure },

                        { KCC_TASK_DAMPENING_TIME,
                          KCC_DEFAULT_TASK_DAMPENING_TIME,
                          KCC_MIN_TASK_DAMPENING_TIME,
                          KCC_MAX_TASK_DAMPENING_TIME,
                          SECS_IN_SECS,
                          &gcTaskDampeningSecs },
                    };
    const DWORD cValues = sizeof(rgValues) / sizeof(rgValues[0]);

    DWORD dwValue;
    DWORD err;
    
    Assert(NULL != ghkParameters);
    Assert(NULL != ghevParametersChange);

    err = RegNotifyChangeKeyValue(ghkParameters,
                                  TRUE,
                                  REG_NOTIFY_CHANGE_LAST_SET,
                                  ghevParametersChange,
                                  TRUE);
    Assert(0 == err);
    
    for (DWORD i = 0; i < cValues; i++) {
        if (GetConfigParam(rgValues[i].pszValueName, &dwValue, sizeof(dwValue))) {
            dwValue = rgValues[i].dwDefaultValue;
            Assert(dwValue >= rgValues[i].dwMinValue);
            Assert(dwValue <= rgValues[i].dwMaxValue);
        }
        else if (dwValue < rgValues[i].dwMinValue) {
            LogEvent(DS_EVENT_CAT_KCC,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_CHK_CONFIG_PARAM_TOO_LOW,
                     szInsertWC(rgValues[i].pszValueName),
                     szInsertUL(dwValue),
                     szInsertUL(rgValues[i].dwMinValue));
            dwValue = rgValues[i].dwMinValue;
        }
        else if (dwValue > rgValues[i].dwMaxValue) {
            LogEvent(DS_EVENT_CAT_KCC,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_CHK_CONFIG_PARAM_TOO_HIGH,
                     szInsertWC(rgValues[i].pszValueName),
                     szInsertUL(dwValue),
                     szInsertUL(rgValues[i].dwMaxValue));
            dwValue = rgValues[i].dwMaxValue;
        }
        
        *(rgValues[i].pdwMultipliedValue) = dwValue * rgValues[i].dwMultiplier;
    }

    #ifdef INCLUDE_UNIT_TESTS
        // WARNING: Buffer overflow to test /GS support
        KccBOTest();
    #endif
}


DWORD
KccExecuteTask(
    IN  DWORD                   dwInVersion,
    IN  DRS_MSG_KCC_EXECUTE *   pMsgIn
    )
{
    DWORD dwFlags;

    // Check parameters
    Assert( NULL!=pMsgIn );
    if(    (1 != dwInVersion)
        || (NULL==pMsgIn)
        || (DS_KCC_TASKID_UPDATE_TOPOLOGY != pMsgIn->V1.dwTaskID) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Kcc cannot be executed until the task queue is up and running
    if ( !gfIsTqRunning ) {
        return ERROR_DS_NOT_INSTALLED;
    }

    // Clear any unexpected flags
    dwFlags = pMsgIn->V1.dwFlags & ALL_DS_KCC_FLAGS_MASK;
    
    return gtaskUpdateReplTopology.Trigger(dwFlags, gcTaskDampeningSecs);
}


DWORD
KccGetFailureCache(
    IN  DWORD                         InfoType,
    OUT DS_REPL_KCC_DSA_FAILURESW **  ppFailures
    )
/*++

Routine Description:

    Returns the contents of the connection or link failure cache.

Arguments:

    InfoType (IN) - Identifies the cache to return -- either
        DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES or
        DS_REPL_INFO_KCC_DSA_LINK_FAILURES.
    
    ppFailures (OUT) - On successful return, holds the contents of the cache.
    
Return Values:

    Win32 error code.

--*/
{
    DWORD                   winError;
    KCC_CACHE_LINKED_LIST * pFailureCache;

    // Check parameters
    if( NULL==ppFailures ) {
        return ERROR_INVALID_PARAMETER;
    }

    if (DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES == InfoType) {
        winError = gConnectionFailureCache.Extract(ppFailures);
    }
    else if (DS_REPL_INFO_KCC_DSA_LINK_FAILURES == InfoType) {
        winError = gLinkFailureCache.Extract(ppFailures);
    }
    else {
        winError = ERROR_INVALID_PARAMETER;
    }
    
    return winError;
}


// Override global new and delete to use the thread-heap
// and raise an exception on failure

void *
__cdecl
operator new(
    size_t  cb
    )
{
    void * pv;

    pv = THAlloc( cb );
    if ( NULL == pv )
    {
        DPRINT1( 0, "Failed to allocate %d bytes\n", cb );
        KCC_MEM_EXCEPT( cb );
    }

    return pv;
}


void
__cdecl
operator delete(
    void *   pv
    )
{
    THFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\kccsitelink.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kccsitelink.cxx

ABSTRACT:

    KCC_SITE_LINK class.

DETAILS:

    This class represents the DS notion of site links.

CREATED:

    03/12/97    Jeff Parham (jeffparh)

REVISION HISTORY:

    06/21/00    Will Lees (wlees)

--*/

#include <ntdspchx.h>
#include "kcc.hxx"
#include "kccdynar.hxx"
#include "kccsite.hxx"
#include "kccsitelink.hxx"
#include "kccduapi.hxx"
#include "kcctools.hxx"
#include "kccdsa.hxx"
#include "kcctrans.hxx"
#include "kccconn.hxx"
#include "kccsconn.hxx"
#include "dsconfig.h"
#include "dsutil.h"

#define FILENO FILENO_KCC_KCCSITELINK


///////////////////////////////////////////////////////////////////////////////
//
//  KCC_SITE methods
//

void
KCC_SITE_LINK::Reset()
//
// Set member variables to their pre-Init() state.
//
{
    m_fIsInitialized        = FALSE;
    m_pdnSiteLinkObject     = NULL;
    m_dwOptions             = 0;
    m_dwCost                = 0;
    m_dwReplInterval        = 0;
    m_hSchedule             = NULL;
    m_pEdge                 = NULL;
    m_SiteArray.RemoveAll();
}

BOOL
KCC_SITE_LINK::Init(
    IN  ENTINF *    pEntInf
    )
// Init the object given its ds properties
// Note, do not store any pointers to the memory in the pEntInf.
// It will be deallocated shortly.
{
    TOPL_SCHEDULE_CACHE scheduleCache;
    DWORD   iAttr, cAttr, iAttrVal;
    ATTR *  pAttr;
    DWORD   cbVal;
    BYTE *  pbVal;
    BOOL    fValidSchedule=FALSE;

    Reset();

    m_pdnSiteLinkObject = (DSNAME *) new BYTE [pEntInf->pName->structLen];
    memcpy( m_pdnSiteLinkObject, pEntInf->pName, pEntInf->pName->structLen );

    for ( iAttr = 0, cAttr = pEntInf->AttrBlock.attrCount; 
            iAttr < cAttr; 
                iAttr++ )
    {
        pAttr = &pEntInf->AttrBlock.pAttr[ iAttr ];
        cbVal = pAttr->AttrVal.pAVal->valLen;
        pbVal = pAttr->AttrVal.pAVal->pVal;

        Assert( pAttr->attrTyp == ATT_SITE_LIST || 1 == pAttr->AttrVal.valCount ); // all should be single-valued
        Assert( pbVal );

        switch ( pAttr->attrTyp )
        {
        case ATT_SITE_LIST:
            for ( iAttrVal = 0; iAttrVal < pAttr->AttrVal.valCount; iAttrVal++ )
            {
                DSNAME *pdnSite = (DSNAME *) pAttr->AttrVal.pAVal[ iAttrVal ].pVal;
                KCC_SITE *pSite = gpDSCache->GetSiteList()->GetSite( pdnSite );

                // Validation: Find a KCC_SITE object for every entry in the site list.
                if (pSite) {
                    m_SiteArray.Add( pSite );
                } else {
                    DPRINT2(0, "Site link %ls references site %ls, but not found in site list.\n",
                            m_pdnSiteLinkObject->StringName,
                            pdnSite->StringName );
                    LogEvent(DS_EVENT_CAT_KCC,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_KCC_SITE_LINK_SITE_NOT_IN_SITE_LIST,
                             szInsertDN(m_pdnSiteLinkObject),
                             szInsertDN(pdnSite),
                             0); 
                    // keep going
                }
            }
            // This does not need to be sorted
            break;

        case ATT_SCHEDULE:
            scheduleCache = gpDSCache->GetScheduleCache();
            Assert( scheduleCache );
            fValidSchedule = FALSE;
            __try {
                if( IS_VALID_SCHEDULE((PSCHEDULE) pbVal, cbVal) ) {
                    m_hSchedule = ToplScheduleImport( scheduleCache,
                                                (SCHEDULE *) pbVal );
                    fValidSchedule = TRUE;
                }
                // Note that 'never' schedules are not considered valid here.
            } __except( EXCEPTION_EXECUTE_HANDLER ) {
                // Out-of-memory exceptions from W32TOPL will make the KCC
                // behave as though the site-link had an invalid schedule.
                fValidSchedule = FALSE;
            }
            
            if( ! fValidSchedule ) {
                // Bad schedule.
                DPRINT1(0, "Invalid schedule on %ls!\n",
                        m_pdnSiteLinkObject->StringName);
                LogEvent(DS_EVENT_CAT_KCC,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_CHK_BAD_SCHEDULE,
                         szInsertDN(m_pdnSiteLinkObject),
                         0, 0);
                m_hSchedule = ToplGetAlwaysSchedule( scheduleCache );
            }
            break;

        case ATT_OPTIONS:
            Assert( cbVal == sizeof(DWORD) );
            m_dwOptions = *((DWORD *) pbVal);

            // Validation: Any bitmap is considered valid
            break;

        case ATT_COST:
            Assert( cbVal == sizeof(DWORD) );
            m_dwCost = *((DWORD *) pbVal);

            // Validation: Any DWORD value is considered valid
            break;

        case ATT_REPL_INTERVAL:
            Assert( cbVal == sizeof(DWORD) );
            m_dwReplInterval = *((DWORD *) pbVal);

            // Validation: Any DWORD value is considered valid
            break;

        default:
            DPRINT1( 0, "Received unrequested attribute 0x%X.\n", pAttr->attrTyp );
            break;
        }
    }

    if (m_SiteArray.GetCount() >= 2) {
        m_fIsInitialized = TRUE;
    } else if( gpDSCache->GetSiteList()->GetCount()>1 ) {
    	// This site link contains only 1 site (or less), but there are
    	// 2 or more sites in the forest. Give a warning.
        DPRINT1(0, "Site link %ls does not have enough sites.\n",
                m_pdnSiteLinkObject->StringName );
        LogEvent(DS_EVENT_CAT_KCC,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_KCC_SITE_LINK_TOO_SMALL,
                 szInsertDN(m_pdnSiteLinkObject),
                 0,
                 0); 

        delete [] m_pdnSiteLinkObject;
        m_pdnSiteLinkObject = NULL;
    }
       
    return m_fIsInitialized;
}

BOOL
KCC_SITE_LINK::InitForKey(
    IN  DSNAME   *    pdnSiteLink
    )
//
// Init a KCC_SITE_LINK object for use as a key (i.e., solely for comparison use
// by bsearch()).
//
// WARNING: The DSNAME argument pdnSite must be valid for the lifetime of this
// object!
//
{
    Reset();

    m_pdnSiteLinkObject = pdnSiteLink;

    m_fIsInitialized = TRUE;

    return TRUE;
}


BOOL
KCC_SITE_LINK::IsValid()
//
// Is this object internally consistent?
//
{
    return m_fIsInitialized;
}

PDSNAME
KCC_SITE_LINK::GetObjectDN()
{
    ASSERT_VALID( this );

    return m_pdnSiteLinkObject;
}


///////////////////////////////////////////////////////////////////////////////
//
//  KCC_SITE_LINK_LIST methods
//

BOOL
KCC_SITE_LINK_LIST::IsValid()
//
// Is this object internally consistent?
//
{
    return m_fIsInitialized;
}

BOOL
KCC_SITE_LINK_LIST::Init(
    IN KCC_TRANSPORT *pTransport
    )
{

    ATTR      rgAttrs[] =
    {
        { ATT_SITE_LIST, { 0, NULL } },
        { ATT_COST, { 0, NULL } },
        { ATT_OPTIONS, { 0, NULL } },
        { ATT_REPL_INTERVAL, { 0, NULL } },
        { ATT_SCHEDULE, { 0, NULL } }
    };

    ENTINFSEL Sel =
    {
        EN_ATTSET_LIST,
        { sizeof( rgAttrs )/sizeof( rgAttrs[ 0 ] ), rgAttrs },
        EN_INFOTYPES_TYPES_VALS
    };

    // Find all the site objects.
    DSNAME * pdnSiteLinkCat = DsGetDefaultObjCategory(CLASS_SITE_LINK);

    ULONG               dirError;
    FILTER              filtObjCat;
    SEARCHRES *         pResults;
    ENTINFLIST *        pEntInfList;

    // Clear the member variables
    Reset();

    Assert(NULL != pdnSiteLinkCat);

    // Set up the search filter
    memset( &filtObjCat, 0, sizeof( filtObjCat ) );
    filtObjCat.choice                  = FILTER_CHOICE_ITEM;
    filtObjCat.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    filtObjCat.FilterTypes.Item.FilTypes.ava.type         = ATT_OBJECT_CATEGORY;
    filtObjCat.FilterTypes.Item.FilTypes.ava.Value.valLen = pdnSiteLinkCat->structLen;
    filtObjCat.FilterTypes.Item.FilTypes.ava.Value.pVal   = (BYTE *) pdnSiteLinkCat;

    dirError = KccSearch(
        pTransport->GetDN(),
        SE_CHOICE_IMMED_CHLDRN,
        &filtObjCat,
        &Sel,
        &pResults
        );

    if ( 0 != dirError )
    {
        KCC_LOG_SEARCH_FAILURE( pTransport->GetDN(), dirError );

        return FALSE;
    }
    else
    {
        if ( 0 == pResults->count )
        {
           DPRINT1( 1, "No site link objects found for transport %ls.\n",
               pTransport->GetDN()->StringName );
        }
        else
        {
            for ( pEntInfList = &pResults->FirstEntInf;
                  NULL != pEntInfList;
                  pEntInfList = pEntInfList->pNextEntInf
                )
            {
                KCC_SITE_LINK * pSiteLink = new KCC_SITE_LINK;

                if ( pSiteLink->Init( &pEntInfList->Entinf ) )
                {
                    m_SiteLinkArray.Add( pSiteLink );
                } else {
                    delete pSiteLink;
                    // Error already logged
                    // Keep going
                }
            }
        }

        // On debug builds we hold on to the search results in order to
        // make debugging DirSearch problems easier
        #if DBG
            m_dbgSearchResults = pResults;
            DirFreeSearchRes( pResults, TRUE );
        #else
            DirFreeSearchRes( pResults, FALSE );
        #endif
        
        // Sort the array
        m_SiteLinkArray.Sort();

        m_fIsInitialized = TRUE;
    }

    return m_fIsInitialized;
}

ULONG
KCC_SITE_LINK_LIST::GetCount()
//
// Get the number of site.
//
{
    return m_SiteLinkArray.GetCount();
}

KCC_SITE_LINK *
KCC_SITE_LINK_LIST::GetSiteLink(
        IN  DWORD   iSite
        )
//
// Get the site requested
//
{
    ASSERT_VALID( this );

    return m_SiteLinkArray[iSite];
}

KCC_SITE_LINK *
KCC_SITE_LINK_LIST::GetSiteLink(
    IN  DSNAME *  pdnSite
    )
//
// Retrieve the KCC_SITE object with the given DSNAME.
//
{
    ASSERT_VALID(this);

    return m_SiteLinkArray.Find( pdnSite );
}

void
KCC_SITE_LINK_LIST::Reset()
//
// Set member variables to their pre-Init() state.
//
{
    m_fIsInitialized = FALSE;
    m_SiteLinkArray.RemoveAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\kccsite.cxx ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kccsite.cxx

ABSTRACT:

    KCC_SITE class.

DETAILS:

    This class represents the DS notion of sites -- specifically,
    NTDS-Site-Settings DS objects (and perhaps later also properties from 
    their parent Site DS objects).

    NTDS-Site-Settings DS objects hold site-specific DS configuration 
    information; e.g., whether automatic generation of connection objects 
    is enabled for the site.

CREATED:

    03/12/97    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <ntdspchx.h>
#include "kcc.hxx"
#include "kccdynar.hxx"
#include "kccsite.hxx"
#include "kccduapi.hxx"
#include "kcctools.hxx"
#include "kccdsa.hxx"
#include "kcctrans.hxx"
#include "kccconn.hxx"
#include "kccsconn.hxx"
#include "dsconfig.h"
#include "dsutil.h"

#define FILENO FILENO_KCC_KCCSITE


/*++

Inline Logging Functions

Below are a list of macros which log information using the debugging facilities
and the event log functions. The use of these functions helps to keep the
actual code more readable.

--*/

#define InlineLogWhistlerElectionAlgorithm \
    DPRINT( 3, "KCC is using the Whistler ISTG Election Algorithm\n" ); \
    LogEvent(DS_EVENT_CAT_KCC, \
             DS_EVENT_SEV_INTERNAL, \
             DIRLOG_KCC_WHISTLER_ELECTION_ALG, \
             0, 0, 0);

#define InlineLogISTGNotViable \
    DPRINT1(0, "Site generator %ls is not in the local site or does not" \
               " understand NDNCs.\n", \
            m_pdnSiteGenerator->StringName); \
    LogEvent(DS_EVENT_CAT_KCC, \
             DS_EVENT_SEV_EXTENSIVE, \
             DIRLOG_KCC_SITE_GENERATOR_NOT_VIABLE, \
             szInsertDN(m_pdnSiteGenerator), 0, 0);      

#define InlineLogLocalDSAIsISTG \
    DPRINT1(3, "The local DSA is still the site generator.\n", \
        m_pdnSiteGenerator->StringName);

#define InlineLogISTGNotInUTD \
    DPRINT1(0, "No up-to-dateness information for site generator %ls\n", \
            m_pdnSiteGenerator->StringName); \
    LogEvent(DS_EVENT_CAT_KCC, \
             DS_EVENT_SEV_EXTENSIVE, \
             DIRLOG_KCC_SITE_GENERATOR_NO_UTD, \
             szInsertDN(m_pdnSiteGenerator), 0, 0);

#define InlineLogISTGReplicatedInFuture \
    {   CHAR szTime[SZDSTIME_LEN]; \
        DSTimeToDisplayString(m_timeSiteGenSet, szTime); \
        DPRINT2(0, "We replicated from the site generator %ls in " \
                   "the future at %s!\n", \
                   pDsa->GetDsName()->StringName, szTime ); \
    }

#define InlineLogISTGClaimValid \
    {   CHAR szTime[SZDSTIME_LEN]; \
        DSTimeToDisplayString(m_timeSiteGenSet, szTime); \
        DPRINT2(2, "The site generator claim by %ls was last " \
                   "updated at %s. This claim is still valid.\n", \
                   m_pdnSiteGenerator->StringName, szTime); \
        LogEvent(DS_EVENT_CAT_KCC, \
                 DS_EVENT_SEV_EXTENSIVE, \
                 DIRLOG_KCC_SITE_GENERATOR_CLAIM_VALID, \
                 szInsertDN(m_pdnSiteGenerator), \
                 szInsertSz(szTime), 0); \
    }

#define InlineLogISTGClaimExpired \
    {   CHAR szTime[SZDSTIME_LEN]; \
        DSTimeToDisplayString(m_timeSiteGenSet, szTime); \
        DPRINT2(0, "The site generator claim by %ls has expired; " \
                   "last claim update was at %s.\n", \
                m_pdnSiteGenerator->StringName, szTime); \
        LogEvent(DS_EVENT_CAT_KCC, \
                 DS_EVENT_SEV_EXTENSIVE, \
                 DIRLOG_KCC_SITE_GENERATOR_CLAIM_EXPIRED, \
                 szInsertDN(m_pdnSiteGenerator), \
                 szInsertSz(szTime), 0); \
    }

#define InlineLogClaimedISTGRole \
    DPRINT(2, "Assumed site generator role.\n"); \
    LogEvent(DS_EVENT_CAT_KCC, \
             DS_EVENT_SEV_ALWAYS, \
             DIRLOG_CHK_CLAIMED_SITE_GENERATOR_ROLE, \
             0, 0, 0);

#define InlineLogISTGFailOver \
    DPRINT1(2, "Site generator should fail-over to %ls.\n", \
            pDsa->GetDsName()->StringName); \
    LogEvent(DS_EVENT_CAT_KCC, \
             DS_EVENT_SEV_EXTENSIVE, \
             DIRLOG_KCC_ISTG_FAIL_OVER, \
             szInsertDN(pDsa->GetDsName()), 0, 0);

#define InlineLogUTDVecWrongVersion \
    DPRINT1(0, "The Uptodate Vector has version %d (expected 2)!.\n", \
             pUTDVec->dwVersion ); \
    LogEvent(DS_EVENT_CAT_KCC, \
             DS_EVENT_SEV_ALWAYS, \
             DIRLOG_KCC_UTD_VEC_WRONG_VERSION, \
             szInsertUL( pUTDVec->dwVersion ), 0, 0);

#define InlineLogBadSchedule \
    DPRINT1(0, "Invalid schedule on %ls!\n", \
            m_pdnNtdsSiteSettings->StringName); \
    LogEvent(DS_EVENT_CAT_KCC, \
             DS_EVENT_SEV_ALWAYS, \
             DIRLOG_CHK_BAD_SCHEDULE, \
             szInsertDN(m_pdnNtdsSiteSettings), \
             0, 0);

#define InlineLogIntrasiteUnavailable \
    LogEvent(DS_EVENT_CAT_KCC, \
             DS_EVENT_SEV_ALWAYS, \
             DIRLOG_KCC_INTRASITE_UNAVAILABLE, \
             szInsertDN(m_pdnSiteObject), \
             szInsertUL(maxUnavail), \
             szInsertUL(cSuggestedFailOver));


typedef struct _KCC_ENTINFLIST_AND_DSA {
    ENTINFLIST *  pEntInfList;
    KCC_DSA *     pDSA;
} KCC_ENTINFLIST_AND_DSA;

int __cdecl
CompareEntInfListAndDsaByDsaGuid(
    IN  const void *  pv1,
    IN  const void *  pv2
    )
{
    DSNAME * pDSADN1 = ((KCC_ENTINFLIST_AND_DSA *) pv1)->pDSA->GetDsName();
    DSNAME * pDSADN2 = ((KCC_ENTINFLIST_AND_DSA *) pv2)->pDSA->GetDsName();

    return CompareDsName(&pDSADN1, &pDSADN2);
}

int __cdecl
CompareIndirectEntinfDsnameString(
    IN  const void *  pv1,
    IN  const void *  pv2
    )
{
    ENTINF *pEntinf1 = *((ENTINF **) pv1);
    ENTINF *pEntinf2 = *((ENTINF **) pv2);

    return wcscmp( pEntinf1->pName->StringName, pEntinf2->pName->StringName );
}

///////////////////////////////////////////////////////////////////////////////
//
//  KCC_SITE methods
//

void
KCC_SITE::Reset()
//
// Set member variables to their pre-Init() state.
//
{
    m_fIsInitialized                = FALSE;
    m_dwOptions                     = 0;
    m_pdnSiteObject                 = NULL;
    m_pdnNtdsSiteSettings           = NULL;
    m_pSiteGeneratorDSA             = NULL;
    m_pdnSiteGenerator              = NULL;
    m_timeSiteGenSet                = 0;
    m_pDsaList                      = NULL;
    m_pTransportDsaLists            = NULL;
    m_cNumTransportDsaLists         = 0;
    m_pDestSiteConnMap              = NULL;
    m_destSiteConnMapSize           = 0;
    m_siteLinkBitmap                = 0;
    m_cSecsUntilSiteGenFailOver     = 0;
    m_cSecsUntilSiteGenRenew        = 0;
    m_fUnreachable                  = FALSE;
    
    m_NCTransportBridgeheadList.RemoveAll();
}

BOOL
KCC_SITE::InitForKey(
    IN  DSNAME   *    pdnSite
    )
//
// Init a KCC_SITE object for use as a key (i.e., solely for comparison use
// by bsearch()).
//
// WARNING: The DSNAME argument pdnSite must be valid for the lifetime of this
// object!
//
{
    Reset();

    m_pdnSiteObject = pdnSite;

    m_fIsInitialized = TRUE;

    return TRUE;
}


BOOL
KCC_SITE::InitSite(
    IN  DSNAME * pdnSite,
    IN  ENTINF * pSettingsEntInf
    )
// Initialize the object from an entinf
//
// Note, when called from KCC_SITE_LIST::Init, pSettingsEntinf->pName may have
// been changed to a different name for sorting purposes. Avoid this field.
{
    const PROPERTY_META_DATA    MetaDataKey = {ATT_INTER_SITE_TOPOLOGY_GENERATOR};
    
    PROPERTY_META_DATA_VECTOR  *pMetaDataVec = NULL;
    SCHEDULE                   *pSchedule = NULL;
    DWORD                       cbSchedule = 0;
    DWORD                       cMinsUntilSiteGenRenew    = 0;
    DWORD                       cMinsUntilSiteGenFailOver = 0;

    DSNAME                     *pdnLocalDSA = gpDSCache->GetLocalDSADN();

    Assert(NULL != pdnSite);
    Assert(!fNullUuid(&pdnSite->Guid));
    Reset();

    m_pdnSiteObject = (DSNAME *) new BYTE [pdnSite->structLen];
    memcpy( m_pdnSiteObject, pdnSite, pdnSite->structLen );

    if (NULL != pSettingsEntInf) {
        // Iterate through the returned atttributes
        for ( DWORD iAttr = 0; iAttr < pSettingsEntInf->AttrBlock.attrCount; iAttr++ )
        {
            ATTR *  pattr = &pSettingsEntInf->AttrBlock.pAttr[ iAttr ];
    
            switch ( pattr->attrTyp )
            {
            case ATT_OPTIONS:
                Assert( 1 == pattr->AttrVal.valCount );
                Assert( sizeof( DWORD ) == pattr->AttrVal.pAVal->valLen );
                m_dwOptions = *( (DWORD *) pattr->AttrVal.pAVal->pVal );

                // Validation: Not semantically validated
                break;
    
            case ATT_OBJ_DIST_NAME:
            {
                DSNAME *pDn = (DSNAME *) pattr->AttrVal.pAVal->pVal;
                Assert( 1 == pattr->AttrVal.valCount );

                m_pdnNtdsSiteSettings = (DSNAME *) new BYTE [pDn->structLen];
                memcpy( m_pdnNtdsSiteSettings, pDn, pDn->structLen );

                // Validation: Not semantically validated
                break;
            }
            case ATT_INTER_SITE_TOPOLOGY_GENERATOR:
            {
                DSNAME *pDn = (DSNAME *) pattr->AttrVal.pAVal->pVal;
                Assert(1 == pattr->AttrVal.valCount);

                m_pdnSiteGenerator = (DSNAME *) new BYTE [pDn->structLen];
                memcpy( m_pdnSiteGenerator, pDn, pDn->structLen );

                // Validation: Invalid values are corrected in GetSiteGenerator().                
                break;
            }
            case ATT_INTER_SITE_TOPOLOGY_RENEW:
                Assert(1 == pattr->AttrVal.valCount);
                cMinsUntilSiteGenRenew = *(DWORD *) pattr->AttrVal.pAVal->pVal;

                // Validation: Any DWORD value is acceptable
                break;
    
            case ATT_INTER_SITE_TOPOLOGY_FAILOVER:
                Assert(1 == pattr->AttrVal.valCount);
                cMinsUntilSiteGenFailOver = *(DWORD *) pattr->AttrVal.pAVal->pVal;

                // Validation: Any DWORD value is acceptable
                break;
    
            case ATT_REPL_PROPERTY_META_DATA:
                Assert(1 == pattr->AttrVal.valCount);
                pMetaDataVec = (PROPERTY_META_DATA_VECTOR *) pattr->AttrVal.pAVal->pVal;
                Assert(1 == pMetaDataVec->dwVersion);

                // Validation: The metadata is managed by the replication engine and
                // therefore assumed to be correct.
                break;
    
            case ATT_SCHEDULE:
                Assert(1 == pattr->AttrVal.valCount);
                pSchedule = (SCHEDULE *) pattr->AttrVal.pAVal->pVal;
                cbSchedule = pattr->AttrVal.pAVal->valLen;

                // Validation: Validated below by IS_VALID_SCHEDULE(). 
                break;
    
            default:
                DPRINT1( 0, "Received unrequested attribute 0x%X.\n", pattr->attrTyp );
                break;
            }
        }
    }

    // Search the meta-data to find out when the ISTG attribute was last set.
    if (m_pdnNtdsSiteSettings) {
        Assert(NULL != pMetaDataVec);
        if (NULL!=pMetaDataVec && NULL!=m_pdnSiteGenerator) {
            // A site generator has been specified -- when was it last set?
            PROPERTY_META_DATA * pMetaData;
            
            pMetaData = (PROPERTY_META_DATA *)
                            bsearch(&MetaDataKey,
                                    &pMetaDataVec->V1.rgMetaData[0],
                                    pMetaDataVec->V1.cNumProps,
                                    sizeof(*pMetaData),
                                    KccCompareMetaData);
            Assert(NULL != pMetaData);

            m_timeSiteGenSet = pMetaData->timeChanged;
        }
    }

    // We retrieve the local DSA's DN from the cache to determine if this
    // site is the local site. It would be preferable to load the local site
    // from the cache to avoid the call to NamePrefix(), but we cannot do so
    // because we're in the middle of initializing the sites right now.
    if( NamePrefix(m_pdnSiteObject, pdnLocalDSA) ) {

        // Update our failover config.
        m_cSecsUntilSiteGenRenew    = MINS_IN_SECS * cMinsUntilSiteGenRenew;
        m_cSecsUntilSiteGenFailOver = MINS_IN_SECS * cMinsUntilSiteGenFailOver;

        // Note that NULL schedules are valid but 'never' schedules
        // are considered invalid here.
        if( NULL!=pSchedule && !IS_VALID_SCHEDULE(pSchedule,cbSchedule) ) {
            InlineLogBadSchedule;
            pSchedule = NULL;
        }
        SetIntrasiteSchedule( pSchedule );
    }

    m_fIsInitialized = TRUE;
    return m_fIsInitialized;
}


VOID
KCC_SITE::SetIntrasiteSchedule(
    IN  PSCHEDULE   pSchedule
    )
// 
// Set the intra-site schedule for use in the local site.
// The parameter may be NULL but must have been validated for consistency.
//
{
    DSNAME *pdnLocalDSA = gpDSCache->GetLocalDSADN();

    // This must be the local site.
    Assert( NamePrefix(m_pdnSiteObject, pdnLocalDSA) );
    Assert( NULL==pSchedule || ToplPScheduleValid(pSchedule) );

    if( pSchedule ) {
        // Update our cached intrasite schedule.
        gpIntrasiteSchedule = ToplScheduleImport(
            gpDSCache->GetScheduleCache(),
            pSchedule );
    } else {
        // Use default intra-site schedule.
        gpIntrasiteSchedule = ToplScheduleImport(
            gpDSCache->GetScheduleCache(),
            (PSCHEDULE) gpDefaultIntrasiteSchedule );
    }

    if( ToplScheduleDuration(gpIntrasiteSchedule)==0 ) {
        // If the site is configured to use an never schedule,
        // use the always schedule instead.
        gpIntrasiteSchedule = ToplGetAlwaysSchedule(
            gpDSCache->GetScheduleCache() );
    }

    gfIntrasiteSchedInited = TRUE;
}


VOID
KCC_SITE::CheckIntrasiteSchedule()
{
    DSNAME *pdnLocalDSA = gpDSCache->GetLocalDSADN();
    DWORD   maxUnavail, cMinsUntilSiteGenFailOver, cSuggestedFailOver;

    // This must be the local site.
    Assert( NamePrefix(m_pdnSiteObject, pdnLocalDSA) );

    // If we're using the Whistler ISTG Election algorithm, ensure that
    // the intra-site replication schedule won't cause the ISTG role
    // to fail-over unnecessarily.
    if( UseWhistlerElectionAlg() )
    {

        // Find out the longest contiguous number of minutes for which this
        // schedule in unavailable. From this value, compute a suggested
        // value for the ISTG failover period. If the actual ISTG failover
        // period is less than the suggested value, log an event.
        maxUnavail = ToplScheduleMaxUnavailable(gpIntrasiteSchedule);
        cSuggestedFailOver = maxUnavail + KCC_ISTG_FAILOVER_PADDING;
        cMinsUntilSiteGenFailOver = GetSecsUntilSiteGenFailOver() / 60;

        if( cMinsUntilSiteGenFailOver < cSuggestedFailOver ) {
            InlineLogIntrasiteUnavailable;
        }
    }
}


BOOL
KCC_SITE::IsValid()
//
// Is this object internally consistent?
//
{
    return m_fIsInitialized;
}

BOOL
KCC_SITE::IsAutoTopologyEnabled()
//
// Is the automatic generation of connection objects (intra-site)
// currently enabled?
//
{
    ASSERT_VALID( this );

    return !( m_dwOptions & NTDSSETTINGS_OPT_IS_AUTO_TOPOLOGY_DISABLED );
}

BOOL
KCC_SITE::IsInterSiteAutoTopologyEnabled()
//
// Is the automatic generation of inter site connection objects
// currently enabled?
//
{
    ASSERT_VALID( this );

    return !( m_dwOptions & NTDSSETTINGS_OPT_IS_INTER_SITE_AUTO_TOPOLOGY_DISABLED );
}

BOOL
KCC_SITE::ForceWhistlerBehavior()
//
// Should we force the KCC to run in Whistler mode at this site?
//
{
    return !!( m_dwOptions & NTDSSETTINGS_OPT_FORCE_KCC_WHISTLER_BEHAVIOR );
}

BOOL
KCC_SITE::ForceW2KElection()
{
    return !!( m_dwOptions & NTDSSETTINGS_OPT_FORCE_KCC_W2K_ELECTION );
}

BOOL
KCC_SITE::IsRandomBHSelectionEnabled()
{
    return !( m_dwOptions & NTDSSETTINGS_OPT_IS_RAND_BH_SELECTION_DISABLED );
}

BOOL
KCC_SITE::IsScheduleStaggeringEnabled()
{
    return !!( m_dwOptions & NTDSSETTINGS_OPT_IS_SCHEDULE_HASHING_ENABLED );
}

BOOL
KCC_SITE::IsRedundantServerTopologyEnabled()
{
    return !!( m_dwOptions & NTDSSETTINGS_OPT_IS_REDUNDANT_SERVER_TOPOLOGY_ENABLED );
}

BOOL
KCC_SITE::BuildRedundantServerTopology()
//
// Check prerequisites for building redundant server topologies:
// 1. Need > W2K mode because of different automatic schedules
// 2. Need redundant server topology option
// 3. Dynamic failover is mutually exclusive with redundant server topology
//
{
    return (
        (gpDSCache->GetForestVersion() >= DS_BEHAVIOR_WIN_DOT_NET_WITH_MIXED_DOMAINS) &&
        (IsRedundantServerTopologyEnabled()) &&
        (IsDetectStaleServersDisabled())
        );

}

BOOL
KCC_SITE::UseWhistlerElectionAlg() {
    return gpDSCache->GetForestVersion() >= DS_BEHAVIOR_WIN_DOT_NET_WITH_MIXED_DOMAINS
        && !ForceW2KElection();
}

DWORD
KCC_SITE::GetSecsUntilSiteGenRenew() {
    if( 0==m_cSecsUntilSiteGenRenew ) {
        m_cSecsUntilSiteGenRenew = MINS_IN_SECS * KCC_DEFAULT_SITEGEN_RENEW;
    }
    Assert( 0!=m_cSecsUntilSiteGenRenew );
    return m_cSecsUntilSiteGenRenew;
}

DWORD
KCC_SITE::GetSecsUntilSiteGenFailOver() {
    if( 0==m_cSecsUntilSiteGenFailOver ) {
        m_cSecsUntilSiteGenFailOver =
              ( UseWhistlerElectionAlg() )
            ? ( MINS_IN_SECS * KCC_DEFAULT_SITEGEN_FAILOVER_WHISTLER )
            : ( MINS_IN_SECS * KCC_DEFAULT_SITEGEN_FAILOVER );
    }
    Assert( 0!=m_cSecsUntilSiteGenFailOver );
    return m_cSecsUntilSiteGenFailOver;
}

BOOL
KCC_SITE::IsRemoveConnectionsDisabled()
//
// Is the remove dead connections disabled?
//
{
    ASSERT_VALID( this );

    return !!( m_dwOptions & NTDSSETTINGS_OPT_IS_TOPL_CLEANUP_DISABLED );
}

BOOL
KCC_SITE::IsMinimizeHopsDisabled()
//
// Is the create creations to minimize hops disabled?
//
{
    ASSERT_VALID( this );

    return !!( m_dwOptions & NTDSSETTINGS_OPT_IS_TOPL_MIN_HOPS_DISABLED );
}

BOOL
KCC_SITE::IsDetectStaleServersDisabled()
//
// Is the detection of stale server disabled?
//
{
    ASSERT_VALID( this );
                             
    return !!( m_dwOptions & NTDSSETTINGS_OPT_IS_TOPL_DETECT_STALE_DISABLED );
}


PDSNAME
KCC_SITE::GetObjectDN()
{
    ASSERT_VALID( this );

    return m_pdnSiteObject;
}

PDSNAME
KCC_SITE::GetNtdsSettingsDN()
{
    ASSERT_VALID( this );

    return m_pdnNtdsSiteSettings;
}


int __cdecl
CompareCursorUUID(
    const void *p1,
    const void *p2
    )
/*++

Routine Description:

    Compare two Up-To-Date Cursors by the GUID of the DSA that
    they correspond to.

Parameters:

    Pointers to the two cursors.   

Return Values:

    <0  If Cursor1's DSA's GUID is less than Cursor2's DSA's GUID
    0   If the GUIDs are the same
    >0  If Cursor1's DSA's GUID is greater than Cursor2's DSA's GUID
    
--*/
{
    UPTODATE_CURSOR_V1 *pCursor1 = (UPTODATE_CURSOR_V1*) p1;
    UPTODATE_CURSOR_V1 *pCursor2 = (UPTODATE_CURSOR_V1*) p2;
    RPC_STATUS          rpcStatus;
    int                 result;
    
    result = UuidCompare( &pCursor1->uuidDsa,
                          &pCursor2->uuidDsa,
                          &rpcStatus );
    Assert( RPC_S_OK==rpcStatus );

    return result;
}


UPTODATE_VECTOR_V2*
KCC_SITE::GetUTDVector(
    VOID
    )
/*++

Routine Description:

    Load the Up-To-Date Vector from Config NC and return it to
    the caller.

Parameters:

    None

Return Values:

    If we successfully read the Up-To-Dateness vector we return a
    pointer to it. If we could not read it, we return NULL.

--*/
{
    READRES            *pReadRes = NULL;
    ATTR               *pAttr;
    UPTODATE_VECTOR    *pUTDVec = NULL;
    ULONG               dirError;

    ATTR                rgAttrs[] = {
                            { ATT_REPL_UPTODATE_VECTOR, {0, NULL} }
                        };    
    ENTINFSEL           Sel = {
                            EN_ATTSET_LIST,
                            { ARRAY_SIZE(rgAttrs), rgAttrs },
                            EN_INFOTYPES_TYPES_VALS
                        };
        
    // Search for the Up-To-Date Vector on the Config NC Head
    dirError = KccRead(gpDSCache->GetConfigNC(), &Sel, &pReadRes);
    if( 0 != dirError ) {
        if( attributeError==dirError ) {
            INTFORMPROB * pprob = &pReadRes->CommRes.pErrInfo->
                                        AtrErr.FirstProblem.intprob;

            if(   (PR_PROBLEM_NO_ATTRIBUTE_OR_VAL==pprob->problem)
               && (DIRERR_NO_REQUESTED_ATTS_FOUND==pprob->extendedErr))
            {
                // No value for this attribute; return 0.
                return NULL;
            }
        }

        KCC_LOG_READ_FAILURE(gpDSCache->GetConfigNC(), dirError);
        KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
    }

    // Check that the search results are reasonably consistent.
    Assert( pReadRes->entry.AttrBlock.attrCount==1 );
    if( pReadRes->entry.AttrBlock.attrCount!=1 ) {
        return NULL;
    }
    pAttr = &pReadRes->entry.AttrBlock.pAttr[0];
    Assert( pAttr->attrTyp==ATT_REPL_UPTODATE_VECTOR );
    Assert( 1==pAttr->AttrVal.valCount );
    if( pAttr->AttrVal.valCount!=1 ) {
        return NULL;
    }
        
    // Check that we have a Version 2 Up-To-Dateness Vector. 
    pUTDVec = (UPTODATE_VECTOR*) pAttr->AttrVal.pAVal[0].pVal;
    Assert( NULL!=pUTDVec );                
    Assert( 2==pUTDVec->dwVersion );
    if( 2!=pUTDVec->dwVersion ) {
        InlineLogUTDVecWrongVersion;
        return NULL;
    }
    return &pUTDVec->V2;
}


BOOL
AssertNoISTG(
    UPTODATE_CURSOR_V2  *istgKey,
    UPTODATE_CURSOR_V2  *rgCursor,
    DWORD                cNumCursors
    )
/*++

Routine Description:

    Verify with a linear-search that an entry for the ISTG does _not_
    exist in the array of cursors. This is for checking an assertion.

--*/
{
    for( DWORD i=0; i<cNumCursors; i++ ) {
        if( 0==CompareCursorUUID(istgKey, &rgCursor[i]) ) {
            // The assertion is false -- the ISTG _does_ exist.
            return FALSE;
        }
    }

    // The assertion is true -- the ISTG did _not_ exist.
    return TRUE;
}


DSTIME
KCC_SITE::GetLastISTGSyncTime(
    VOID
    )
/*++

Routine Description:

    Load the Up-To-Date Vector from Config NC and find out when the
    last time we synced with the ISTG was.

    If the current ISTG is NULL we return 0. If we have never synced
    with the current ISTG we return 0.

Parameters:

    None

Return Values:

    If the current ISTG is NULL we return 0. If we have never synced
    with the current ISTG we return 0. Otherwise we return the time
    of the last sync.

--*/
{    
    KCC_DSA            *pDsaISTG;
    UPTODATE_VECTOR_V2 *pUTDVec2 = NULL;
    UPTODATE_CURSOR_V2  istgKey, *pIstg;
    GUID               *pISTGInvId;

    // If there is no current ISTG, return 0
    if( NULL==m_pdnSiteGenerator ) {
        // No current ISTG. This could happen if the attribute were deleted.
        // Later an event will be logged stating that the DSA was not viable.
        return 0;
    }

    // Find the invocation ID of the current ISTG
    pDsaISTG = gpDSCache->GetGlobalDSAListByGUID()->GetDsa( m_pdnSiteGenerator );
    if( NULL==pDsaISTG ) {
        // Did not find the current ISTG in the cache. This could happen if 
        // the DSA were deleted. Later an event will be logged stating that 
        // the DSA was not viable.
        return 0;
    }
    pISTGInvId = pDsaISTG->GetInvocationId();
    Assert( !fNullUuid(pISTGInvId) );

    // Load the Up-To-Dateness Vector from the Config NC.
    pUTDVec2 = GetUTDVector();
    if( NULL==pUTDVec2 ) {
        // No Up-To-Dateness Vector therefore we haven't synced from ISTG.
        return 0;
    }

    // Now find the ISTG in the Up-To-Date Vector
    memcpy( &istgKey.uuidDsa, pISTGInvId, sizeof(GUID) );
    pIstg = (UPTODATE_CURSOR_V2*) bsearch( &istgKey, pUTDVec2->rgCursors,
        pUTDVec2->cNumCursors, sizeof(UPTODATE_CURSOR_V2), CompareCursorUUID );

    if( pIstg ) {
        // Found it: return the last successful sync time
        return pIstg->timeLastSyncSuccess;
    } else {
        Assert( AssertNoISTG(&istgKey, pUTDVec2->rgCursors, pUTDVec2->cNumCursors) );
    }

    return 0;
}


VOID
KCC_SITE::GetLastGeneratorWhistler(
    IN  KCC_DSA_ARRAY  *pViableISTGs,
    IN  DSTIME          timeNow,
    OUT KCC_DSA       **ppLastGenerator,
    OUT BOOL           *pfStillValid
    )
/*++

Routine Description:


    Look at the 'm_pdnSiteGenerator' member to determine which DSA last
    staked the ISTG claim. This member comes from the attribute 
    ATT_INTER_SITE_TOPOLOGY_GENERATOR on the NTDS Settings object.
    Then, look at the up-to-dateness vector on the Config NC to determine
    the last time we synced with that server.

    Using the two variables mentioned above, we can determine who the
    last ISTG claim was made by and also determine if the claim is still
    valid. If the last claim was staked by a viable DSA, and we have
    replicated the Config NC with that DSA within the past
    GetSecsUntilSiteGenFailOver() seconds then it is still a valid claim.
    
    Note: The only class member altered by this function is m_timeSiteGenSet.
    This is because, with the Whistler behavior, we are not interested in the
    last time the ISTG attribute was written, we're interested in the last time
    we replicated with the ISTG. 

Parameters:

    pViableISTGs      - The list of viable ISTGs for this site
    timeNow           - The current time

Return Values:

    ppLastGenerator   - The last DSA to stake the ISTG claim
    fStillValid       - Set to TRUE if the claim is still valid;
                        otherwise set to FALSE.
                        
--*/
{
    KCC_DSA    *pDsa;
    KCC_DSA    *pLocalDsa = gpDSCache->GetLocalDSA();

    // Check parameters
    ASSERT_VALID( pViableISTGs );
    Assert( NULL!=ppLastGenerator );
    Assert( NULL!=pfStillValid );

    InlineLogWhistlerElectionAlgorithm;
    
    // Default return values.
    *ppLastGenerator = NULL;
    *pfStillValid = FALSE;
    
    if( NULL!=m_pdnSiteGenerator ) {

        // The NTDS Site Settings object indicates a DSA has laid claim to
        // the ISTG role at some point in the past.
        pDsa = pViableISTGs->Find(m_pdnSiteGenerator, NULL);
        m_timeSiteGenSet = GetLastISTGSyncTime();

        if( NULL==pDsa ) {
            
            // Previous site generator has been moved out of the site or is
            // not a viable site generator (e.g., because it does not understand
            // non-domain NCs).
            // This claim is not valid.
            InlineLogISTGNotViable;

        } else if( pDsa==pLocalDsa ) {

            // Local DSA is the ISTG. No need to do anything. In particular,
            // we do not update our claim as is done in GetLastGenerator().
            InlineLogLocalDSAIsISTG;
            *ppLastGenerator = pLocalDsa;
            *pfStillValid = TRUE;            

        } else if( 0==m_timeSiteGenSet ) {

            // No Up-To-Dateness vector or never replicated from the current ISTG
            InlineLogISTGNotInUTD;          
            ASSERT_VALID( pDsa );
            *ppLastGenerator = pDsa;
            *pfStillValid = FALSE;

        } else {
        
            // A site generator was specified and it's viable.
            // Is the claim still valid?
            Assert(0 != m_timeSiteGenSet);
            ASSERT_VALID( pDsa );
            Assert( pDsa!=pLocalDsa );  // (This case is handled above)
            
            if (m_timeSiteGenSet > timeNow + GetSecsUntilSiteGenFailOver()) {
                
                // We replicated from the ISTG in the future! Reject the claim.
                // ISSUE-2001/01/23-nickhar Is it really necessary to reject this
                // claim here? This should only happen if the clock moves
                // backward (as it may do if the clocks are adjusted), and
                // doesn't necessarily indicate a problem.
                InlineLogISTGReplicatedInFuture;

            } else if (m_timeSiteGenSet > timeNow - GetSecsUntilSiteGenFailOver()) {

                // We have replicated from the current ISTG recently, so it
                // must still be alive. Its claim is therefore valid.
                InlineLogISTGClaimValid;
                *ppLastGenerator = pDsa;
                *pfStillValid = TRUE;

            } else {

                // We have not replicated from the current ISTG in such a long
                // time that we must assume it is dead. 
                InlineLogISTGClaimExpired;
                *ppLastGenerator = pDsa;
                *pfStillValid = FALSE;

            }
        }
    } else {
        // No site generator is set for this site.
        DPRINT(0, "No site generator is set for local site.\n");
    }
}

VOID
KCC_SITE::GetLastGenerator(
    IN  KCC_DSA_ARRAY  *pViableISTGs,
    IN  DSTIME          timeNow,
    OUT KCC_DSA       **ppLastGenerator,
    OUT BOOL           *pfStillValid
    )
/*++

Routine Description:

    Look at the 'm_pdnSiteGenerator' member to determine which DSA last
    staked the ISTG claim. This member comes from the attribute 
    ATT_INTER_SITE_TOPOLOGY_GENERATOR on the NTDS Settings object.
    The other relevant member 'm_timeSiteGenSet' gives the time at which
    the last claim was staked, as determined by reading the metadata on
    the NTDS Settings object.

    Using the two data members mentioned above, we can determine who the
    last ISTG claim was made by and also determine if the claim is still
    valid. If the last claim was staked by a viable DSA within the past
    GetSecsUntilSiteGenFailOver() seconds then it is still a valid claim.
    If the local DSA is the ISTG and GetSecsUntilSiteGenRenew() seconds have
    elapsed since our last claim then we re-stake our claim.

    This function does not modify any members of the KCC_SITE object.
    
Parameters:

    pViableISTGs      - The list of viable ISTGs for this site
    timeNow           - The current time

Return Values:

    ppLastGenerator   - The last DSA to stake the ISTG claim
    fStillValid       - Set to TRUE if the claim is still valid;
                        otherwise set to FALSE.

--*/
{
    KCC_DSA    *pDsa;
    KCC_DSA    *pLocalDsa = gpDSCache->GetLocalDSA();

    // Check parameters
    ASSERT_VALID( pViableISTGs );
    Assert( NULL!=ppLastGenerator );
    Assert( NULL!=pfStillValid );

    // Default return values.
    *ppLastGenerator = NULL;
    *pfStillValid = FALSE;
    
    if (NULL != m_pdnSiteGenerator) {
        // The NTDS Site Settings object indicates a DSA has laid claim to
        // the ISTG role at some point in the past.
        pDsa = pViableISTGs->Find(m_pdnSiteGenerator, NULL);

        if (NULL == pDsa) {
            
            // Previous site generator has been moved out of the site or is
            // not a viable site generator (e.g., because it does not understand
            // non-domain NCs).
            InlineLogISTGNotViable;
            
        } else {
            // A site generator was specified and it's in this site and viable.
            // Is the claim still valid?
            Assert(0 != m_timeSiteGenSet);
            ASSERT_VALID( pDsa );
            
            if (m_timeSiteGenSet > timeNow + GetSecsUntilSiteGenFailOver()) {
            
                // Claim was made in the future! This claim is not valid.
                InlineLogISTGReplicatedInFuture;
                        
            } else if (m_timeSiteGenSet > timeNow - GetSecsUntilSiteGenFailOver()) {
            
                // Claim was (re-)made recently and is still valid.
                InlineLogISTGClaimValid;
                *ppLastGenerator = pDsa;
                *pfStillValid = TRUE;
                
                if(   (pDsa == pLocalDsa)
                   && (   (timeNow < m_timeSiteGenSet)
                       || (timeNow-m_timeSiteGenSet > GetSecsUntilSiteGenRenew()) ) )
                {
                    // We are the site generator for this site and it is time to
                    // renew our claim.
                    m_pSiteGeneratorDSA = pDsa;
                    UpdateSiteGenerator();
                    DPRINT(1, "Renewed claim to site generator role.\n");
                }

            } else {
            
                // Claim was made so far in the past that it has expired.
                InlineLogISTGClaimExpired;
                *ppLastGenerator = pDsa;
                *pfStillValid = FALSE;
                
            }
        }
    } else {
        // No site generator is set for this site.
        DPRINT(0, "No site generator is set for local site.\n");
    }
}


KCC_DSA *
KCC_SITE::GetSiteGenerator(
    VOID
    )
/*++

Routine Description:

    Return the current site generator for this site -- i.e., the machine
    responsible for creating and maintaining the inbound intersite replication
    connections for this site.
    
    The algorithm is fairly simple: if the last designated site generator
    is no longer deemed to be alive or acceptable, the next DSA in the
    site (ordered by increasing objectGuid) is considered to be the site
    generator.
    
    If this next machine is the local DSA, the site generator
    designation on the NTDS Site Settings object is updated such that the
    remaining DSAs in the site know that this machine has claimed the role and
    is alive and well.
    
    If the next DSA is other than the local DSA, and if this next DSA fails to
    claim the role within the timeout interval, the designation roles over to
    the next-next DSA, and so on.
    
    Typically, (1) each DSA will have the same notion of what the other DSAs in
    the site are, (2) each DSA that is currently alive and well will be
    replicating with the other DSAs in the site, and thus will have the same
    value and timestamp for the "last site generator" claim, and (3) the clocks
    on each running DSA will be approximately the same, thanks to the time
    service.  The factors combine such that typically each DSA will agree on
    which DSA should be the current site generator, even if that DSA is not
    currently available.  Thus it is rare for there to be more than one DSA in
    the site to believe it is the site generator.
    
    Multiple site generators are a distinct possibility, however.  This
    situation causes no real harm.  The implications are (1) more than one DSA
    is spinning cycles doing the same job, and (2) duplicate intersite
    connection objects can be generated.  Duplicate connections will be cleaned
    up (i.e., all but one deleted) when the various DSAs once again agree on who
    the site generator is.  Agreement is reached once the various machines are
    replicating with each other in a timely fashion.

Arguments:

    None.    

Return Values:

    The current site generator, or NULL if none could be determined.

--*/
{
    KCC_DSA_ARRAY   ViableISTGs;
    KCC_DSA        *pLastGenerator, *pDsa;
    KCC_DSA        *pLocalDSA = gpDSCache->GetLocalDSA();
    DSTIME          timeNow = GetSecondsSince1601();
    BOOL            fStillValid=FALSE;
    DWORD           iDsa, cSecsUntilSiteGenFailOver;

    // Check parameters
    ASSERT_VALID(this);
    Assert(this == gpDSCache->GetLocalSite());

    if (NULL == m_pdnNtdsSiteSettings) {
        // No site settings, no place to read/set the site generator.
        return NULL;
    }

    // Check for cached answer
    if (NULL != m_pSiteGeneratorDSA) {
        // We've already figured out who the site generator is; return it.
        return m_pSiteGeneratorDSA;
    }
        
    // Get the list of all DSAs in the site which are viable ISTGs.
    // At the moment, this means all DSAs which understand NDNCs.
    ViableISTGs.GetViableISTGs();

    // Call a helper function to find who the last generator was. If the
    // last claim is still valid, the 'fStillValid' flag is set accordingly.
    if( !UseWhistlerElectionAlg() ) {
        GetLastGenerator( &ViableISTGs, timeNow,
                          &pLastGenerator, &fStillValid );
    } else {
        GetLastGeneratorWhistler( &ViableISTGs, timeNow,
                                  &pLastGenerator, &fStillValid );
    }

    // Now we have one of the following cases:
    // (1) We know who the current site generator is and the claim is valid.
    // (2) We know who the last site generator was, but the claim is no
    //     longer valid.
    // (3) We have no idea who the last site generator was (if there was one).

    if( fStillValid ) {

        // Case (1) -- The last ISTG is still valid
        ASSERT_VALID( pLastGenerator );
        m_pSiteGeneratorDSA = pLastGenerator;

    } else {
    
        // Cases (2) and (3) are handled here
        
        if( pLastGenerator ) {

            // Case (2) -- We found the last ISTG, but it's not valid.
            ASSERT_VALID( pLastGenerator );
            
            // Find the index of pLastGenerator in the list of viable ISTGs.
            // This will be used down below.
            for( iDsa=0; iDsa<ViableISTGs.GetCount(); iDsa++ ) {
                if( ViableISTGs[iDsa]==pLastGenerator ) {
                    break;
                }
            }            
            Assert( iDsa<ViableISTGs.GetCount() && "pLastGenerator not found" );
            
        } else {
        
            // Case (3) -- We have no idea who the last valid site generator was
            // (if there was one).  In this case we assume the first DSA in the
            // list was designated as site generator at time 0.
            m_timeSiteGenSet = 0;
            iDsa = 0;

        }
                
        // Note: m_timeSiteGenSet can be 0 here.
        cSecsUntilSiteGenFailOver = GetSecsUntilSiteGenFailOver();
        Assert(timeNow >= m_timeSiteGenSet+cSecsUntilSiteGenFailOver);
        if( 0==cSecsUntilSiteGenFailOver ) {
            // Avoid a fatal division by 0 below.
            cSecsUntilSiteGenFailOver = 1;
        }
        
        // For each fail-over interval that has passed since someone claimed
        // themselves to be site-generator, we skip over one DSA. E.g.,
        // after one fail-over period, we move on to the next DSA; after
        // two, we move on to the next-next DSA; three, the next-next-next
        // DSA; etc.
        iDsa += (DWORD) (timeNow - m_timeSiteGenSet)/cSecsUntilSiteGenFailOver;
        iDsa %= ViableISTGs.GetCount();
        pDsa = ViableISTGs[iDsa];
        ASSERT_VALID(pDsa);
        m_pSiteGeneratorDSA = pDsa;
    
        if (pDsa == pLocalDSA) {
            // Hey, *we* are the new site generator!  Stake our claim.
            UpdateSiteGenerator();
            InlineLogClaimedISTGRole;
        } else {
            InlineLogISTGFailOver;
        }
    }

    ASSERT_VALID(m_pSiteGeneratorDSA);
    return m_pSiteGeneratorDSA;
}


VOID
KCC_SITE::UpdateSiteGenerator()
//
// Update the site generator designation for this site.
//
{
    USHORT      cMods = 0;
    ATTRMODLIST rgMods[2];
    ATTRVAL     AttrVal;
    ULONG       dirError;

    if (NULL == m_pdnNtdsSiteSettings) {
        Assert(!"Cannot set site generator w/o NTDS Site Settings object!");
        return;
    }

    Assert(NULL != m_pSiteGeneratorDSA);
    Assert(m_pSiteGeneratorDSA == gpDSCache->GetLocalDSA());

    // Note that we do *not* use ATT_CHOICE_REPLACE_ATT.  ATT_CHOICE_REPLACE_ATT
    // does not update the meta data for the attribute if the new value is the
    // same as the old value, but sometimes we intentionally rewrite the same
    // value here to update the "keep-alive" time in the meta data (and thereby
    // renew our claim to be the current site generator).
    
    memset(rgMods, 0, sizeof(rgMods));

    rgMods[cMods].choice          = AT_CHOICE_REMOVE_ATT;
    rgMods[cMods].AttrInf.attrTyp = ATT_INTER_SITE_TOPOLOGY_GENERATOR;

    rgMods[cMods].pNextMod = &rgMods[cMods+1];
    cMods++;

    rgMods[cMods].choice                   = AT_CHOICE_ADD_ATT;
    rgMods[cMods].AttrInf.attrTyp          = ATT_INTER_SITE_TOPOLOGY_GENERATOR;
    rgMods[cMods].AttrInf.AttrVal.valCount = 1;
    rgMods[cMods].AttrInf.AttrVal.pAVal    = &AttrVal;
    AttrVal.valLen = m_pSiteGeneratorDSA->GetDsName()->structLen;
    AttrVal.pVal   = (BYTE *) m_pSiteGeneratorDSA->GetDsName();

    cMods++;
        
    dirError = KccModifyEntry(m_pdnNtdsSiteSettings, cMods, rgMods);
    if (0 != dirError) {
        KCC_LOG_MODIFYENTRY_FAILURE( m_pdnNtdsSiteSettings, dirError );
        KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
    }

    m_pdnSiteGenerator = m_pSiteGeneratorDSA->GetDsName();
}


BOOL
KCC_SITE::InitDsaList(
    IN  KCC_DSA_LIST   *pDsaList,
    IN  DWORD           left,
    IN  DWORD           right )
/*++

Routine Description:

    Load this site's DSAs from 'pDsaList'. The DSAs with indices in
    [left, right] belong to this site.

    Note: This list is sorted by GUID because
    GetNCBridgeheadForTransport() expects it to be sorted.
 
Arguments:

    None.

Return Values:

    The list of DSAs for the site.
    
--*/
{
    // This site must be valid but have no DSA list
    ASSERT_VALID( this );
    Assert( NULL==m_pDsaList );
    
    // The new DSA list must be valid and have at least one DSA
    ASSERT_VALID( pDsaList );
    Assert( pDsaList->GetCount()>0 );

    if (NULL==m_pdnNtdsSiteSettings) {
        // This site has no NTDS Site Settings object.  If it contains any
        // ntdsDsa objects it needs one! This is not a fatal error however.
        DPRINT1(0, "Site %ls has no NTDS Site Settings object!\n",
                m_pdnSiteObject->StringName);
        LogEvent(DS_EVENT_CAT_KCC,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_CHK_SITE_HAS_NO_NTDS_SETTINGS,
                 szInsertDN(m_pdnSiteObject),
                 0,
                 0); 
    }

    m_pDsaList = new KCC_DSA_LIST;
    return m_pDsaList->InitSubsequence( pDsaList, left, right );
}


KCC_DSA_LIST *
KCC_SITE::GetDsaList()
/*++

Routine Description:

    Retrieves the list of DSAs in this site.  If the list has not been
    initialized yet, that means that this site has no DSAs, so we create
    an empty list.

Arguments:

    None.

Return Values:

    The list of DSAs for the site.
    
--*/
{
    Assert( gpDSCache->IsValid(KCC_CACHE_STAGE_3_COMPLETE) );
    if (NULL == m_pDsaList) {
        // Initialize an empty list.
        m_pDsaList = new KCC_DSA_LIST;
        m_pDsaList->InitEmpty();
    }
    return m_pDsaList;
}


KCC_DSA_LIST *
KCC_SITE::GetTransportDsaList(
    IN  KCC_TRANSPORT * pTransport,
    OUT BOOL *          pfExplicitBridgeheadsDefined    OPTIONAL
    )
/*++

Routine Description:

    Get list of DSAs in the site valid for the given transport.

Arguments:

    pTransport - Transport for which DSAs are desired.

Return Values:

    The list of DSAs valid for this transport.
    
--*/
{
    DWORD i;
    KCC_DSA_LIST * pDsaList = NULL;
    BOOL fExplicitBridgeheadsDefined=FALSE;

    for (i = 0; i < m_cNumTransportDsaLists; i++) {
        ASSERT_VALID(m_pTransportDsaLists[i].pTransport);

        if (pTransport == m_pTransportDsaLists[i].pTransport) {
            // This is it!
            pDsaList = m_pTransportDsaLists[i].pDsaList;
            ASSERT_VALID(pDsaList);

            fExplicitBridgeheadsDefined
                = m_pTransportDsaLists[i].fExplicitBridgeheadsDefined;
            break;
        }
        else {
            // For expediency we assume that different KCC_TRANSPORT *'s imply
            // different transports; i.e., that there aren't two KCC_TRANSPORT
            // objects corresponding to the same transport.  (There shouldn't
            // be, for performance reasons if nothing else.)
            Assert(!NameMatched(m_pTransportDsaLists[i].pTransport->GetDN(),
                                pTransport->GetDN()));
        }
    }

    if (NULL == pDsaList) {
        // We have not yet cached the transport DSA list for this transport.
        // Do so now.
        pDsaList = new KCC_DSA_LIST;

        if (!pDsaList->InitBridgeheads(this,
                                       pTransport,
                                       &fExplicitBridgeheadsDefined)) {
            // DSA list failed to initialize.
            KCC_EXCEPT( ERROR_DS_DATABASE_ERROR, 0);
        }

        // Add pDsaList to the cache.
        KCC_TRANSPORT_DSA_LIST * pNewTransportDsaLists
            = new KCC_TRANSPORT_DSA_LIST[1 + m_cNumTransportDsaLists];

        if (m_cNumTransportDsaLists) {
            memcpy(pNewTransportDsaLists,
                   m_pTransportDsaLists,
                   m_cNumTransportDsaLists * sizeof(KCC_TRANSPORT_DSA_LIST));
            delete [] m_pTransportDsaLists;
        }

        pNewTransportDsaLists[m_cNumTransportDsaLists].pTransport = pTransport;
        pNewTransportDsaLists[m_cNumTransportDsaLists].pDsaList = pDsaList;
        pNewTransportDsaLists[m_cNumTransportDsaLists].fExplicitBridgeheadsDefined
            = fExplicitBridgeheadsDefined;

        m_pTransportDsaLists = pNewTransportDsaLists;
        m_cNumTransportDsaLists++;
    }

    if (NULL != pfExplicitBridgeheadsDefined) {
        *pfExplicitBridgeheadsDefined = fExplicitBridgeheadsDefined;
    }

    return pDsaList;
}

void
KCC_SITE::PopulateInterSiteConnectionLists()
//
// Search for all intersite ntdsConnection objects inbound to this site and
// populate the individual instersite connection lists associated with each
// KCC_DSA in the site.
//
// Logically this is the same as enumerating the DSAs in the site's DSA list
// and calling GetInterSiteCnList() on each to populate its connection
// list cache.  (The implementation differs however for performance reasons --
// i.e., to avoid so many inidividual searches/transactions.)
//
{
    ENTINFSEL Sel = {
        EN_ATTSET_LIST,
        { ARRAY_SIZE(KCC_CONNECTION::AttrList), KCC_CONNECTION::AttrList },
        EN_INFOTYPES_TYPES_VALS
    };

    BOOL          fSuccess = FALSE;
    ULONG         dirError;
    FILTER        filtTop = {0};
    FILTER        filtConnectionObject = {0};
    FILTER        filtIntersite = {0};
    FILTER        filtFromServer = {0};
    SEARCHRES *   pResults;
    ENTINFLIST *  pEntInfList;
    DSNAME *      pdnConnObjCat;
    DSNAME *      pLocalDSADN = gpDSCache->GetLocalDSADN();
    
    filtTop.choice                       = FILTER_CHOICE_AND;
    filtTop.FilterTypes.And.count        = 3;
    filtTop.FilterTypes.And.pFirstFilter = &filtConnectionObject;
    
    pdnConnObjCat = DsGetDefaultObjCategory(CLASS_NTDS_CONNECTION);
    if( NULL==pdnConnObjCat) {
        Assert( !"DsGetDefaultObjCategory() returned NULL" );
        KCC_EXCEPT(ERROR_DS_INTERNAL_FAILURE, 0);
    }

    // (objectCategory=ntdsConnection)
    filtConnectionObject.choice                                     = FILTER_CHOICE_ITEM;
    filtConnectionObject.FilterTypes.Item.choice                    = FI_CHOICE_EQUALITY;
    filtConnectionObject.FilterTypes.Item.FilTypes.ava.type         = ATT_OBJECT_CATEGORY;
    filtConnectionObject.FilterTypes.Item.FilTypes.ava.Value.valLen = pdnConnObjCat->structLen;
    filtConnectionObject.FilterTypes.Item.FilTypes.ava.Value.pVal   = (BYTE *) pdnConnObjCat;
    filtConnectionObject.pNextFilter                                = &filtIntersite;

    // (transportType=*)
    filtIntersite.choice                            = FILTER_CHOICE_ITEM;
    filtIntersite.FilterTypes.Item.choice           = FI_CHOICE_PRESENT;
    filtIntersite.FilterTypes.Item.FilTypes.present = ATT_TRANSPORT_TYPE;
    filtIntersite.pNextFilter                       = &filtFromServer;

    // (fromServer=*)
    // (I.e., ignore connections where from source server has been deleted --
    //  these objects are deleted by the corresponding destination DSA via
    //  a different code path.)
    filtFromServer.choice                            = FILTER_CHOICE_ITEM;
    filtFromServer.FilterTypes.Item.choice           = FI_CHOICE_PRESENT;
    filtFromServer.FilterTypes.Item.FilTypes.present = ATT_FROM_SERVER;

    dirError = KccSearch(m_pdnSiteObject,
                         SE_CHOICE_WHOLE_SUBTREE,
                         &filtTop,
                         &Sel,
                         &pResults);

    if (0 != dirError) {
        KCC_LOG_SEARCH_FAILURE(m_pdnSiteObject, dirError);
        KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
    }

    // Cache the list of DSAs for this site if they haven't been cached
    // already.
    GetDsaList();
    
    // Build an array of pointers to each individual ENTINFLIST element
    // returned.  Associate the dest DSA with each.
    KCC_ENTINFLIST_AND_DSA *  pObjects = NULL;
    DWORD                     cNumObjects = 0;

    if (pResults->count) {
        pObjects = new KCC_ENTINFLIST_AND_DSA [pResults->count];

        for (pEntInfList = &pResults->FirstEntInf;
             NULL != pEntInfList;
             pEntInfList = pEntInfList->pNextEntInf) {
            // Extract string DN of parent object (the dest DSA DN).
            DSNAME * pGuidlessParentDN
                = (DSNAME *) new BYTE[pEntInfList->Entinf.pName->structLen];
            TrimDSNameBy(pEntInfList->Entinf.pName, 1, pGuidlessParentDN);

            KCC_DSA * pDestDSA = m_pDsaList->GetDsa(pGuidlessParentDN);
            
            if (NULL != pDestDSA) {
                pObjects[cNumObjects].pEntInfList = pEntInfList;
                pObjects[cNumObjects].pDSA = pDestDSA;
                cNumObjects++;
            } else {
                // Cache coherency problem induced by performing connection
                // list and DSA list searches in different transactions.
                // Destination DSA was moved, renamed, or deleted in between
                // transactions.  Play it safe and abort this run.
                KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
            }
        }
    }

    // Sort the list by destination DSA.
    qsort(pObjects, cNumObjects, sizeof(*pObjects),
          CompareEntInfListAndDsaByDsaGuid);

    // DSA list is already sorted by DSA guid.
    Assert((0 == m_pDsaList->GetCount())
           || (m_pDsaList->GetSortFn() == KCC_DSA::CompareIndirectByNtdsDsaGuid));

    // For each set of inbound connections common to a given destination
    // DSA, initialize the corresponding KCC_DSA's intersite connection
    // list.
    DWORD iObject = 0;
    for (DWORD iDSA = 0; iDSA < m_pDsaList->GetCount(); iDSA++) {
        KCC_DSA * pDSA = m_pDsaList->GetDsa(iDSA);
        DWORD     iObjectNextDSA;
        
        // Build the linked ENTINFLISTs describing connection objects
        // inbound to this DSA.  (This list may be empty.)
        for (iObjectNextDSA = iObject;
             (iObjectNextDSA < cNumObjects)
                && (pObjects[iObjectNextDSA].pDSA == pDSA);
             iObjectNextDSA++) {
            if (iObjectNextDSA > iObject) {
                // Update ENTINFLIST linked list to put this ENTINFLIST
                // after the previous ENTINFLIST that matched this same
                // DSA.
                pObjects[iObjectNextDSA - 1].pEntInfList->pNextEntInf
                    = pObjects[iObjectNextDSA].pEntInfList;
            }
            
            // This is the end of the linked list (so far).
            pObjects[iObjectNextDSA].pEntInfList->pNextEntInf = NULL;
        }

        if (pDSA->IsIntersiteConnectionListCached()) {
            // Intersite connections already cached.  This is the case
            // for our own local DSA.
            Assert(pDSA == gpDSCache->GetLocalDSA());
        } else {
            DWORD        cNumObjectsThisDSA = iObjectNextDSA - iObject;
            ENTINFLIST * pObjectsThisDSA = cNumObjectsThisDSA
                                                ? pObjects[iObject].pEntInfList
                                                : NULL;
            KCC_INTERSITE_CONNECTION_LIST * pCnList
                = new KCC_INTERSITE_CONNECTION_LIST;

            // Initialize the connection list from the constructed
            // ENTINFLIST.
            if (!pCnList->Init(pDSA->GetDsName(),
                               cNumObjectsThisDSA,
                               pObjectsThisDSA)) {
                KCC_EXCEPT(ERROR_DS_INTERNAL_FAILURE, 0);
            }

            // Associate the newly created connection list with the DSA.
            pDSA->SetIntersiteConnectionList(pCnList);
        }

        iObject = iObjectNextDSA;
    }
}

KCC_DSA *
KCC_SITE::GetNCBridgeheadForTransportHelp(
    IN  KCC_CROSSREF *  pCrossRef,
    IN  KCC_DSA_LIST *  pDsaList,
    IN  KCC_TRANSPORT * Transport,
    IN  BOOL            fGCTopology,
    IN OUT KCC_DSA_ARRAY *pBestDsas,
    OUT BOOL *          pfStaleBridgeheadsFound
    )
/*++

Routine Description:

    This is a helper routine for GetNCBridgeheadForTransport(), below.
    
    Its task is to iterate through the given list of DSAs and return the first
    DSA that supports replication of the given NC.  "Stale" bridgeheads are not
    returned.
    
    If no bridgehead could be found that's currently viable,
    *pfStaleBridgeheadsFound will be TRUE iff one or more bridgeheads that could
    support replication of the given NC are present but are currently stale.

    For the local site, we return the first acceptable bridgehead that we find.
    For remote sites, bridgeheads are prioritized by whether or not the NC has
    been instantiated there. Bridgeheads which fully host the NC have highest
    priority.
    
Parameters:

    pCrossRef (IN) - CrossRef of NC for which replication is desired.
    
    pDsaList (IN) - DSAs to consider.
    
    pTransport (IN) - Transport being considered.
    
    fGCTopology (IN) - Tells if this is for GC topology generation.  If FALSE,
        read-only replicas are not viable.
    
    pBestDsas (OUT) - Total set of Dsa candidates

    pfStaleBridgeheadsFound (OUT) - If the function return value is NULL,
        indicates if bridgeheads that support all the criteria other than being
        stale were found.

Returns:

    Pointer to the KCC_DSA object that fits the bill, or NULL if none could be
    found.
    
--*/
{
    KCC_DSA            *pdsa;
    DWORD               idsa, cdsa, selectedDsa, r;
    BOOL                fIsMaster;
    KCC_NC_COMING_TYPE  isComing, bestIsComing;
    LPWSTR              pszTransportAddr;
    BOOL                fIsLocal = (this == gpDSCache->GetLocalSite());
    BOOL                fIsInstantiated;
    DSNAME             *pdnnc = pCrossRef->GetNCDN();

    ASSERT_VALID(this);
    ASSERT_VALID(pCrossRef);
    ASSERT_VALID(pDsaList);
    ASSERT_VALID(Transport);
    ASSERT_VALID(gpDSCache->GetLocalSite());
    Assert((this == gpDSCache->GetLocalSite())
           == !!NameMatched(GetObjectDN(),
                            gpDSCache->GetLocalSite()->GetObjectDN()));
    
    *pfStaleBridgeheadsFound = FALSE;
    
    pBestDsas->RemoveAll();
    cdsa = pDsaList->GetCount();

    for (idsa = 0; idsa < cdsa; idsa++) {
        pdsa = pDsaList->GetDsa(idsa);
        ASSERT_VALID(pdsa);

        fIsMaster = FALSE;

        // Bridgehead is viable if the following conditions are met:
        //
        // 1. The NC we want to replicate is instantiated, or if we've
        //    specifically been told it's okay for it not to be (e.g., local
        //    GC).
        // 2. The NC instantiation is of the required type -- i.e., is writeable
        //    for writeable NC topology, or read-only or writeable for GC
        //    topology.
        // 3. The DSA has an address for this transport.
        // 4. The bridgehead is not stale.

        if (pdsa->IsNCHost(pCrossRef, fIsLocal, &fIsMaster)
            && (fIsMaster || fGCTopology)
            && (NULL != (pszTransportAddr = pdsa->GetTransportAddr(Transport)))) {
            
            if (KccIsBridgeheadStale(pdsa->GetDsName())) {
                // Bridgehead is stale; it's not a viable candidate.
                DPRINT1(0, "Ignoring stale bridgehead %ls as possible candidate.\n",
                        pdsa->GetDsName()->StringName);
                *pfStaleBridgeheadsFound = TRUE;
            }
            else {
                if( fIsLocal ) {
                    // For the local bridgehead, we don't care if the NC is coming
                    // or not so we can immediately accept this bridgehead.
                    pBestDsas->Add(pdsa);
                } else {
                    // This bridgehead is acceptable. Let's find out if the NC has
                    // been fully instantiated at this DSA or if it is still coming.
                    fIsInstantiated = pdsa->IsNCInstantiated(pdnnc, NULL, &isComing);

                    // Since this server is in the remote site, the NC must be
                    // instantiated on it.
                    Assert( fIsInstantiated && KCC_NC_NOT_INSTANTIATED!=isComing );

                    // If this dsa has a better coming value than the best DSAs seen
                    // so far, clear the array of best DSAs.
                    if(pBestDsas->GetCount()>0 && isComing>bestIsComing) {
                        pBestDsas->RemoveAll();
                    }
                    pBestDsas->Add(pdsa);
                    bestIsComing = isComing;
                }
            }
        }
    }

    if( pBestDsas->GetCount()==0 ) {
        // No valid bridgeheads were found
        return NULL;
    } else {
        // At least one valid bridgehead was found. Choose one from the list.
        if( IsRandomBHSelectionEnabled() ) {
            // Rand returns 16-bits of random data although the result is not
            // very random. Mix it up a bit.
            r = rand();
            r ^= r>>8;
            selectedDsa = r % pBestDsas->GetCount();
        } else {
            selectedDsa = 0;
        }
        return (*pBestDsas)[selectedDsa];
    }
}

BOOL
KCC_SITE::GetNCBridgeheadForTransport( 
    IN  KCC_CROSSREF *  pCrossRef,
    IN  KCC_TRANSPORT * pTransport,
    IN  BOOL            fGCTopology,
    IN  BOOL            fReportWarnings,
    OUT KCC_DSA **      ppBridgeheadDsa
    )
/*++

Routine Description:

    This routine returns a DSA in the site that is capable of replicating the
    given NC over the specified transport for the particular topology type (GC
    or not), or NULL if no such DSA can be found.  "Stale" DSAs are not
    returned.
    
Parameters:

    pCrossRef (IN) - CrossRef of NC for which replication is desired.
    
    pTransport (IN) - Transport being considered.
    
    fGCTopology (IN) - Tells if this is for GC topology generation.  If FALSE,
        read-only replicas are not viable.
    
    fReportWarnings (IN) - Whether we should report warning conditions. A warning
                           condition is where we complain, but we still fall back
                           and return a useful result.

    ppBridgeheadDSA (OUT) - On successful return, holds a pointer to the KCC_DSA
        object for the DSA that fits the criteria.
        
Returns:

    TRUE - Viable bridgehead found.
    FALSE - No viable bridgehead could be found.
    
--*/
{
    KCC_DSA_ARRAY   bestDsas;
    KCC_DSA_LIST *  pDsaList;   
    KCC_DSA *       pdsa;
    BOOL            fExplicitBridgeheadsDefined;
    BOOL            fStaleBridgeheadsFound;

    ASSERT_VALID(this);
    ASSERT_VALID(pCrossRef);
    ASSERT_VALID(pTransport);
    Assert(ppBridgeheadDsa);
    
    // First check the cache.
    // Note, the use of this cache means that bridgehead selection will be sticky
    // across a single run of the kcc. Not sure if this is good or bad.
    if (m_NCTransportBridgeheadList.Find(pCrossRef->GetNCDN(),
                                         pTransport,
                                         fGCTopology,
                                         ppBridgeheadDsa)) {
        // We have already cached the qualifying bridgehead or lack thereof.
        // (I.e., this is both a positive and a negative cache.)
        return (NULL != *ppBridgeheadDsa);
    }

    // Bridgehead for this NC/transport/GC-ness has not yet been determined --
    // do so now and cache the result.

    // Get the list of servers that can use this transport for this site.
    // Note that this list has already been sorted according to bridgehead
    // preference, so the DSAs at the beginning of the list are generally
    // "better" than those found later in the list.  Thus we iterate from the
    // beginning and stop when we find the first viable candidate.

    pDsaList = GetTransportDsaList(pTransport,
                                   &fExplicitBridgeheadsDefined);
    ASSERT_VALID(pDsaList);
    
    pdsa = GetNCBridgeheadForTransportHelp(pCrossRef,
                                           pDsaList,
                                           pTransport,
                                           fGCTopology,
                                           &bestDsas,
                                           &fStaleBridgeheadsFound);
        
    if (NULL == pdsa) {
        // Failed to find a viable bridgehead.
        if (fStaleBridgeheadsFound) {
            // There are appropriate bridgeheads defined, but all of them are
            // currently stale.
            LogEvent(DS_EVENT_CAT_KCC,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_KCC_ALL_TRANSPORT_BRIDGEHEADS_STALE,
                     szInsertDN(GetObjectDN()),
                     szInsertDN(pTransport->GetDN()),
                     szInsertDN(pCrossRef->GetNCDN()));
        } else {
            if (fExplicitBridgeheadsDefined) {
                // The admin has defined explicit bridgeheads for this site &
                // transport, but none of them could possibly replicate the
                // needed information.  This is a configuration error.
                if (fReportWarnings) {
                    LogEvent(DS_EVENT_CAT_KCC,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_KCC_EXPLICIT_BRIDGEHEAD_LIST_INCOMPLETE,
                             szInsertDN(GetObjectDN()),
                             szInsertDN(pTransport->GetDN()),
                             szInsertDN(pCrossRef->GetNCDN()));
                }
                // Try again, considering all DSAs as potential candidates.
                pDsaList = GetDsaList();
                ASSERT_VALID(pDsaList);
                if( pDsaList ) {                
                    pdsa = GetNCBridgeheadForTransportHelp(pCrossRef,
                                                           pDsaList,
                                                           pTransport,
                                                           fGCTopology,
                                                           &bestDsas,
                                                           &fStaleBridgeheadsFound);
                }
            }

            if (NULL == pdsa) {
                // 1. This site is connected to other sites via this transport,
                //    as indicated by ISM (and the underlying siteLinks for this
                //    transport).
                // 2. We previously determined that this site contained a DSA
                //    that contained a read-only or writeable copy of this NC
                //    and thus the site needed to be included in the applicable
                //    sites list.
                // 3. We considered all DSAs in the site, not just those that
                //    were explicitly defined (if any).
                // 4. No otherwise viable bridgeheads are stale.
                // 5. No bridgehead could be found to support replication of
                //    this NC over this transport.
    
                // From the above we can conclude that the admin has told us
                // that this site is connected over a particular transport (by
                // publishing appropriate siteLinks), but no DSAs that support
                // both this transport *and* the required replication criteria
                // (NC, read-only/writeable) are present in the site.  We do
                // know from 2. that there are DSAs that contain the appropriate
                // NC, so we can conclude that  there are DSAs in the site that
                // support the required replication criteria, but none of those
                // DSAs support this transport.

                // This likely indicates that we're looking for a bridgehead for
                // the SMTP transport, but none of the DSAs' server objects has
                // a mailAddress attribute.
                
                // This shouldn't occur for the IP transport, since all DSAs
                // support IP replication.
                Assert(!pTransport->IsIntersiteIP());

                LogEvent(DS_EVENT_CAT_KCC,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_KCC_NO_BRIDGEHEADS_ENABLED_FOR_TRANSPORT,
                         szInsertDN(GetObjectDN()),
                         szInsertDN(pTransport->GetDN()),
                         szInsertDN(pCrossRef->GetNCDN()));
            }
        }
    }

    if (NULL != pdsa) {
        // Viable bridgehead found.
        ASSERT_VALID(pdsa);
        *ppBridgeheadDsa = pdsa;

        // Supportability logging event 8
        LogEvent8(DS_EVENT_CAT_KCC,
                  DS_EVENT_SEV_VERBOSE,
                  DIRLOG_KCC_BRIDGEHEAD_CHOSEN,
                  szInsertDN(pdsa->GetDsName()),
                  szInsertDN(GetObjectDN()),
                  szInsertDN(pCrossRef->GetNCDN()),
                  szInsertDN(pTransport->GetDN()),
                  0, 0, 0, 0);
    }

    // Add the result (found or not) to the cache.
    m_NCTransportBridgeheadList.Add(pCrossRef->GetNCDN(),
                                    pTransport,
                                    fGCTopology,
                                    pdsa);
    
    return (NULL != pdsa);
}


BOOL
KCC_SITE::GetNCBridgeheadForTransportBestDsas( 
    IN  KCC_CROSSREF *  pCrossRef,
    IN  KCC_TRANSPORT * pTransport,
    IN  BOOL            fGCTopology,
    IN OUT KCC_DSA_ARRAY *pBestDsas
    )
/*++

Routine Description:

    Return the list of bridgehead candidates without regard for bridgehead caching

Arguments:

    pCrossRef - 
    pTransport - 
    fGCTopology - 
    pBestDsas - 

Return Value:

    BOOL - There exists atleast one bridgehead

--*/

{
    KCC_DSA_LIST *  pDsaList;   
    KCC_DSA *       pdsa;
    BOOL            fExplicitBridgeheadsDefined;
    BOOL            fStaleBridgeheadsFound;

    ASSERT_VALID(this);
    ASSERT_VALID(pCrossRef);
    ASSERT_VALID(pTransport);

    pDsaList = GetTransportDsaList(pTransport,
                                   &fExplicitBridgeheadsDefined);
    ASSERT_VALID(pDsaList);
    
    pdsa = GetNCBridgeheadForTransportHelp(pCrossRef,
                                           pDsaList,
                                           pTransport,
                                           fGCTopology,
                                           pBestDsas,
                                           &fStaleBridgeheadsFound);
        
    return (NULL != pdsa);
} /* KCC_SITE::GetNCBridgeheadForTransportBestDsas */

VOID
KCC_SITE::SetSiteLinkFlag(
    DWORD transportIndex
    )
/*++

Routine Description:

    Set a flag indicating that there is a site-link connected to this
    site for the transport specified by 'transportIndex'.

Parameters:

    transportIndex  - The transport for which a site-link was found.

Return Value:

    None

--*/
{
    DWORD mask;

    ASSERT_VALID( this );
    Assert( transportIndex<32 );

    mask = 1<<transportIndex;
    m_siteLinkBitmap |= mask;
}


BOOLEAN
KCC_SITE::GetSiteLinkFlag(
    DWORD transportIndex
    )
/*++

Routine Description:

    Returns a flag indicating if this site has any site links for the
    transport specified by 'transportIndex'.

Parameters:

    transportIndex  - The index transport which we are querying.

Return Value:

    TRUE  - This site has a site-link for the specified transport
    FALSE - This site does not have a site-link for the specified transport

--*/
{
    DWORD mask;

    Assert( transportIndex<32 );
    ASSERT_VALID( this );
    
    mask = 1<<transportIndex;
    return !!(m_siteLinkBitmap & mask);
}


BOOLEAN
KCC_SITE::GetAnySiteLinkFlag(
    VOID
    )
/*++

Routine Description:

    Returns a flag indicating if this site has any site links at all    

Parameters:

    None

Return value:

    TRUE  - This site has a site-link for any transport
    FALSE - This site has no site-link for any transport

--*/
{
    ASSERT_VALID( this );
    return !!(m_siteLinkBitmap);
}


VOID
KCC_SITE::SetUnreachable(
    VOID
    )
/*++

Routine Description:

    Marks this site as being unreachable from the local site for some NC.

Parameters:

    None

Return value:

    None

--*/
{
    ASSERT_VALID( this );
    Assert( this != gpDSCache->GetLocalSite() );
    m_fUnreachable = TRUE;
    gpDSCache->SetAnySiteUnreachable();
}


BOOL
KCC_SITE::IsUnreachable(
    VOID
    )
/*++

Routine Description:

    If this site has been marked as unreachable, returns true.

Parameters:

    None

Return value:

    TRUE  - If the site has been marked as unreachable.
    FALSE - Otherwise.

--*/
{
    Assert( gpDSCache->IsReachableMarkingComplete() );
    return m_fUnreachable;
}



int __cdecl SiteConnMapCmp( const void* pa, const void* pb )
/*++

Routine Description:

    For comparing SITE_CONN_MAP objects. Used to qsort() the SITE_CONN_MAP list.
    The elements are sorted by comparing the 'site' pointers.

--*/
{
    KCC_SITE::KCC_SITE_CONN_MAP *a, *b;

    a = (KCC_SITE::KCC_SITE_CONN_MAP*) pa;
    b = (KCC_SITE::KCC_SITE_CONN_MAP*) pb;
    if( a->site-b->site > 0 ) return 1;
    if( a->site-b->site < 0 ) return -1;

    // If doing qsort(), we should never return 0. There cannot be two connections
    // sourcing from the same site.
    // If we're doing bsearch(), then one of a or b is our search key, and
    // should have its conn field initialized to NULL.
    Assert( a->conn==NULL || b->conn==NULL );
    return 0;
}


void
KCC_SITE::BuildSiteConnMap()
/*++

Routine Description:

    Build a DestSiteConnMap. Each element maps from a site to a connection which has
    that site as its destination site. All connections will have this site as their
    source site.
    
    This map is used so that we can rapidly answer the following query:
    Given a remote site, quickly find an a connection between this site and the
    remote site.
    
Parameters:

    none
        
Returns:

    nothing
    
--*/
{
    DWORD iEdge;

    // We expect that no map will exist at this point, since DestroySiteConnMap()
    // should be called when it is no longer needed. However, in exceptional
    // circumstances m_pDestSiteConnMap may be non-null, so we attempt to delete it. 
    if(m_pDestSiteConnMap) {
        delete [] m_pDestSiteConnMap;
        m_pDestSiteConnMap = NULL;
    }

    // We initialize this mapping using all the edges incident with this site
    m_destSiteConnMapSize = NumberOfOutEdges();
    if(m_destSiteConnMapSize) {
        m_pDestSiteConnMap = new KCC_SITE_CONN_MAP[ m_destSiteConnMapSize ];

        for( iEdge=0; iEdge<m_destSiteConnMapSize; iEdge++ ) {
            m_pDestSiteConnMap[iEdge].conn = (KCC_SITE_CONNECTION*) GetOutEdge(iEdge);
            ASSERT_VALID(m_pDestSiteConnMap[iEdge].conn);
            m_pDestSiteConnMap[iEdge].site = m_pDestSiteConnMap[iEdge].conn->GetDestinationSite();
            ASSERT_VALID(m_pDestSiteConnMap[iEdge].site);
        }

        qsort( m_pDestSiteConnMap, m_destSiteConnMapSize, sizeof(KCC_SITE::KCC_SITE_CONN_MAP), SiteConnMapCmp );
    }
}
    

KCC_SITE_CONNECTION*
KCC_SITE::FindConnInMap( 
    KCC_SITE* destSite
    )
/*++

Routine Description:

    Search for a connection using the mapping built by BuildConnMap
    NOTE: After calling BuildConnMap, if edges are dissociated from this site
    then deleted, the map will contain dangling pointers. Thus, unless care
    is taken, this function could return invalid pointers. 
    
Parameters:

    destSite (IN) - we want to find the connection between (this,destSite)
        
Returns:

    a pointer to the connection if one was found, NULL otherwise.
    
--*/
{
    KCC_SITE_CONN_MAP srch, *result;

    if(m_destSiteConnMapSize==0) return NULL;
    Assert( m_pDestSiteConnMap!=NULL );

    // Create our search key
    srch.site = destSite;
    srch.conn = NULL;

    result = (KCC_SITE_CONN_MAP*) bsearch( &srch, m_pDestSiteConnMap, m_destSiteConnMapSize,
        sizeof(KCC_SITE::KCC_SITE_CONN_MAP), SiteConnMapCmp );
    if(result) {                                
        ASSERT_VALID( result->site );
        Assert( result->site == destSite );
        ASSERT_VALID( result->conn );
        return result->conn;
    } else {
        return NULL;
    }
}


VOID
KCC_SITE::DestroySiteConnMap()
/*++

Routine Description:

    Search for a connection using the mapping built by BuildConnMap
    
Parameters:

    destSite (IN) - we want to find the connection between (this,destSite)
        
Returns:

    a pointer to the connection if one was found, NULL otherwise.
    
--*/
{
    if(m_destSiteConnMapSize==0) return;
    Assert( m_pDestSiteConnMap!=NULL );

    delete [] m_pDestSiteConnMap;
    m_pDestSiteConnMap = NULL;
    m_destSiteConnMapSize=0;
}


VOID
KCC_SITE::DeleteEdges()
{
    KCC_SITE_CONNECTION *   pEdge;
    ULONG                   iEdge, cEdge;

    cEdge = NumberOfOutEdges();
    for( iEdge=0; iEdge < cEdge; iEdge++ )
    {
        pEdge = (KCC_SITE_CONNECTION*) GetOutEdge(iEdge);
        delete pEdge;
    }
    ClearEdges();
}


///////////////////////////////////////////////////////////////////////////////
//
//  KCC_SITE_LIST methods
//

BOOL
KCC_SITE_LIST::IsValid()
//
// Is this object internally consistent?
//
{
    return m_fIsInitialized;
}

BOOL
KCC_SITE_LIST::InitAllSites()
//
// Initialize the collection
//
{
    ENTINFSEL SiteSel = {
        EN_ATTSET_LIST,
        {0, NULL},
        EN_INFOTYPES_TYPES_VALS
    };

    ATTR      rgSettingsAttrs[] =
    {
        { ATT_OPTIONS,       { 0, NULL } },
        { ATT_OBJ_DIST_NAME, { 0, NULL } },
        { ATT_REPL_PROPERTY_META_DATA, { 0, NULL } },
        { ATT_INTER_SITE_TOPOLOGY_GENERATOR, { 0, NULL } },
        { ATT_INTER_SITE_TOPOLOGY_FAILOVER, { 0, NULL } },
        { ATT_INTER_SITE_TOPOLOGY_RENEW, { 0, NULL } },
        { ATT_SCHEDULE, { 0, NULL } }
    };

    ENTINFSEL SettingsSel =
    {
        EN_ATTSET_LIST,
        {ARRAY_SIZE(rgSettingsAttrs), rgSettingsAttrs},
        EN_INFOTYPES_TYPES_VALS
    };

    WCHAR       szSitesRDN[] = L"Sites";
    DWORD       cchSitesRDN  = ARRAY_SIZE(szSitesRDN) - 1;
    
    WCHAR       szNtdsSiteSettingsRDN[] = L"NTDS Site Settings";
    DWORD       cbNtdsSiteSettingsRDN
                    = sizeof(szNtdsSiteSettingsRDN) - sizeof(*szNtdsSiteSettingsRDN);

    DSNAME *    pdnConfigNC = gpDSCache->GetConfigNC();
    ULONG       cbSitesContainer = pdnConfigNC->structLen +
                                     (MAX_RDN_SIZE+MAX_RDN_KEY_SIZE)*(sizeof(WCHAR));
    DSNAME *    pdnSitesContainer = (DSNAME *) new BYTE[cbSitesContainer];
    
    ULONG               dirError;
    FILTER              filtNameAndObjCat = {0};
    FILTER              filtName = {0};
    FILTER              filtObjCat = {0};
    SEARCHRES *         pSitesResults;
    SEARCHRES *         pSettingsResults;
    ENTINFLIST *        pSiteEntInfList;
    ENTINFLIST *        pSettingsEntInfList;
    ENTINF **           ppSettingEntinfArray = NULL;
    ENTINF **           ppCurrentEntinf;

    // Clear the member variables
    Reset();

    // Set up the root search dn
    AppendRDN(pdnConfigNC,
              pdnSitesContainer,
              cbSitesContainer,
              szSitesRDN,
              cchSitesRDN,
              ATT_COMMON_NAME);

    // Find all the site objects.
    DSNAME * pdnSiteCat = DsGetDefaultObjCategory(CLASS_SITE);
    if( NULL==pdnSiteCat ) {
        Assert( !"DsGetDefaultObjCategory() returned NULL" );
        KCC_EXCEPT(ERROR_DS_INTERNAL_FAILURE, 0);
    }

    // Set up the search filter
    filtObjCat.choice                  = FILTER_CHOICE_ITEM;
    filtObjCat.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    filtObjCat.FilterTypes.Item.FilTypes.ava.type         = ATT_OBJECT_CATEGORY;
    filtObjCat.FilterTypes.Item.FilTypes.ava.Value.valLen = pdnSiteCat->structLen;
    filtObjCat.FilterTypes.Item.FilTypes.ava.Value.pVal   = (BYTE *) pdnSiteCat;

    dirError = KccSearch(pdnSitesContainer,
                         SE_CHOICE_IMMED_CHLDRN,
                         &filtObjCat,
                         &SiteSel,
                         &pSitesResults);

    if (0 != dirError) {
        KCC_LOG_SEARCH_FAILURE(pdnSitesContainer, dirError);
        KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
    };

    if (0 == pSitesResults->count) {
        Assert(!"No site objects found!");
        LogUnhandledError(ERROR_DS_DATABASE_ERROR);
    };
    
    // Find all the NTDS Site Settings objects.
    filtNameAndObjCat.choice                       = FILTER_CHOICE_AND;
    filtNameAndObjCat.FilterTypes.And.count        = 2;
    filtNameAndObjCat.FilterTypes.And.pFirstFilter = &filtName;
        
    filtName.choice                                     = FILTER_CHOICE_ITEM;
    filtName.FilterTypes.Item.choice                    = FI_CHOICE_EQUALITY;
    filtName.FilterTypes.Item.FilTypes.ava.type         = ATT_RDN;
    filtName.FilterTypes.Item.FilTypes.ava.Value.valLen = cbNtdsSiteSettingsRDN;
    filtName.FilterTypes.Item.FilTypes.ava.Value.pVal   = (BYTE *) szNtdsSiteSettingsRDN;
    filtName.pNextFilter                                = &filtObjCat;
        
    DSNAME * pdnSiteSetCat = DsGetDefaultObjCategory(CLASS_NTDS_SITE_SETTINGS);
    if( NULL==pdnSiteSetCat ) {
        Assert( !"DsGetDefaultObjCategory() returned NULL" );
        KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
    }
    
    Assert(filtObjCat.choice == FILTER_CHOICE_ITEM);
    Assert(filtObjCat.FilterTypes.Item.choice == FI_CHOICE_EQUALITY);
    Assert(filtObjCat.FilterTypes.Item.FilTypes.ava.type == ATT_OBJECT_CATEGORY);
    filtObjCat.FilterTypes.Item.FilTypes.ava.Value.valLen = pdnSiteSetCat->structLen;
    filtObjCat.FilterTypes.Item.FilTypes.ava.Value.pVal   = (BYTE *) pdnSiteSetCat;
    
    dirError = KccSearch(pdnSitesContainer,
                         SE_CHOICE_WHOLE_SUBTREE,
                         &filtNameAndObjCat,
                         &SettingsSel,
                         &pSettingsResults);
            
    if (0 != dirError) {
        KCC_LOG_SEARCH_FAILURE(pdnSitesContainer, dirError);
        KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
    };

    // Sort the settings objects so we can find them efficiently

    if (pSettingsResults->count) {
        ppSettingEntinfArray = new ENTINF *[pSettingsResults->count];

        ppCurrentEntinf = ppSettingEntinfArray;
        for (pSettingsEntInfList = &pSettingsResults->FirstEntInf;
             NULL != pSettingsEntInfList;
             pSettingsEntInfList = pSettingsEntInfList->pNextEntInf) {

            // WARNING. MAINTENANCE ISSUE.
            // Rename each Entinf to have the name of its site
            // This makes matching settings to site easier later
            // We free the old name here.
            // Since new uses the thread-allocator, it is ok that the new
            // name is released below using FreeSearchRes()
            DSNAME *pdnSettings = pSettingsEntInfList->Entinf.pName;
            DSNAME *pdnSite = (DSNAME *) new BYTE[pdnSettings->structLen];
            TrimDSNameBy(pdnSettings, 1, pdnSite);

            // Free the orphaned memory of the old name. The new name will be
            // freed when the search results are released.
            THFree( pdnSettings );

            pSettingsEntInfList->Entinf.pName = pdnSite;

            *ppCurrentEntinf++ = &(pSettingsEntInfList->Entinf);
        }
        qsort( ppSettingEntinfArray, pSettingsResults->count, sizeof( ENTINF * ),
               CompareIndirectEntinfDsnameString );
    }

    // Create each site.

    for (pSiteEntInfList = &pSitesResults->FirstEntInf;
         NULL != pSiteEntInfList;
         pSiteEntInfList = pSiteEntInfList->pNextEntInf) {

        ENTINF *pKeyEntinf = &(pSiteEntInfList->Entinf);
        DSNAME * pdnSite = pKeyEntinf->pName;
        ENTINF * pSettingsEntInf = NULL;
        VOID *pElement;

        // For each site, match it to its corresponding site settings object.
        if (pSettingsResults->count) {
            pElement = bsearch( &pKeyEntinf,
                                ppSettingEntinfArray,
                                pSettingsResults->count,
                                sizeof(ENTINF *),
                                CompareIndirectEntinfDsnameString );

            if (pElement) {
                pSettingsEntInf = *((ENTINF **) pElement);
            } else {
                // pSettingsEntInf will be NULL in this case, which is permitted.
                // Event will be logged in KCC_SITE::InitSite()
            }
        }
        // else pSettingsEntInf will be NULL, indicating there is none

        KCC_SITE * psite = new KCC_SITE;
        
        if (psite->InitSite(pdnSite, pSettingsEntInf)) {
            m_SiteArray.Add( psite );
            m_SiteNameArray.Add( pdnSite, psite );
        }
        else {
            DPRINT1(0, "Initialization of site object %ls failed\n",
                    pdnSite->StringName);
        }

    } // end for
            
    // Free search results
    // On debug builds we hold on to the search results in order to
    // make debugging DirSearch problems easier
    #if DBG
        m_dbgSitesSearchResults = pSitesResults;
        DirFreeSearchRes( pSitesResults, TRUE );

        m_dbgSettingsSearchResults = pSettingsResults;
        DirFreeSearchRes( pSettingsResults, TRUE );
    #else
        DirFreeSearchRes( pSitesResults, FALSE );
        DirFreeSearchRes( pSettingsResults, FALSE );
    #endif            

    // There are no compatibility issues with sorting this array using the
    // new CompareSite function. The KCC_SITE_LIST was never sorted previously,
    // and its order is not significant in computing the old spanning tree.
    // The array is sorted so that the Find function will work efficiently.
    m_SiteArray.Sort( CompareIndirectSiteGuid );

    // Sort the names using the default sorting function
    m_SiteNameArray.Sort();

    m_fIsInitialized = TRUE;

    if (ppSettingEntinfArray) {
        delete [] ppSettingEntinfArray;
    }

    delete [] (BYTE *) pdnSitesContainer;

    return m_fIsInitialized;
}


BOOL
KCC_SITE_LIST::PopulateDSAs()
//
// Load all DSAs in the forest, then build a DSA list for each site.
//
{
    DSNAME         *pdnCurSite=NULL;
    KCC_SITE       *pSite;
    DWORD           iDSA=0, cDSA, siteStart;
    BOOL            fStartOfList, fEndOfList, fNameMatchesCurSite;

    // Initialize a list of all DSAs in the forest.
    // Claim: For a given site, all its DSAs are contiguous in this list.
    m_allDSAs.InitAllDSAs();
    cDSA = m_allDSAs.GetCount();
    if( 0==cDSA ) {
        Assert( !"Failed to find any DSAs in the forest!" );
        KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
    }


    // Loop over all DSAs in order to find ones that are in the same site.
    // Then, call that site's InitDsaList() function so that the site knows
    // who its DSAs are.
    for(;;) {
        Assert( iDSA<=cDSA );

        fStartOfList = (iDSA==0);
        fEndOfList = (iDSA==cDSA);
        if( fEndOfList ) {
            Assert( !fStartOfList );
        }
        if( !fStartOfList && !fEndOfList ) {
            fNameMatchesCurSite =
                NameMatched(m_allDSAs.GetDsa(iDSA)->GetSiteDN(),pdnCurSite);
        }
        
        // Check if we're at the end of a site:
        //  - This DSA is at the end of the list
        //  - This DSA's site is not the same as the current site (if any)
        if( fEndOfList || (!fStartOfList && !fNameMatchesCurSite) )
        {
            Assert( iDSA>0 && NULL!=pdnCurSite );
            pSite = GetSite( pdnCurSite );      // Uses binary-search
            if( pSite ) {
                if( ! pSite->InitDsaList(&m_allDSAs, siteStart, iDSA-1) ) {
                    DPRINT1( 0, "Failed to initialize DSA list for site %ls!\n",
                        pdnCurSite->StringName );
                }
            } else {
                // We have read inconsistent data from the database. We have
                // a DSA whose site does not exist. While this is not strictly
                // a fatal situation, we stop the KCC run so that we don't
                // mess up the topology by using these inconsistent objects.
                DPRINT1( 0, "Site %ls not found!\n", pdnCurSite->StringName );
                KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
            }

            if( iDSA==cDSA ) {
                break;
            }
        }

        Assert( iDSA<cDSA );

        // Check if we're at the start of a new site:
        //  - This is the first DSA in the list
        //  - This DSA's site is not the same as the current site (if any)
        if( fStartOfList || !fNameMatchesCurSite ) {
            pdnCurSite = m_allDSAs.GetDsa(iDSA)->GetSiteDN();
            siteStart = iDSA;
        }

        iDSA++;
    }

    return TRUE;
}


void
KCC_SITE_LIST::Reset()
//
// Set member variables to their pre-Init() state.
//
{
    m_fIsInitialized = FALSE;
    m_SiteArray.RemoveAll();
    m_SiteNameArray.RemoveAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\kccsconn.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kccsconn.cxx

ABSTRACT:

    KCC_SITE_CONNECTION

                       
    This class does not represent a ds object.  It represents a transport 
    connection between two sites in an enterprise.  Typically the information
    will get filled in from calls to transport plugin via ntism

CREATED:

    12/05/97    Colin Brace ( ColinBr )

REVISION HISTORY:

--*/

#include <ntdspchx.h>
#include "kcc.hxx"
#include "kccsite.hxx"
#include "kccconn.hxx"
#include "kcclink.hxx"
#include "kccdsa.hxx"
#include "kccduapi.hxx"
#include "kcctools.hxx"
#include "kcccref.hxx"
#include "kccstale.hxx"
#include "kcctrans.hxx"
#include "kccsconn.hxx"
#include "ismapi.h"


#define FILENO FILENO_KCC_KCCSCONN


void
KCC_SITE_CONNECTION::Reset()
// Set member variables to pre-init state
//
// Note, if this function is called on an initialized object, memory will
// be orphaned.  This may not matter since the memory is on the thread heap.
{
    TOPL_SCHEDULE_CACHE     scheduleCache;
   
    scheduleCache = gpDSCache->GetScheduleCache();
    Assert( NULL!=scheduleCache );

    m_fIsInitialized   = FALSE;

    m_pTransport       = NULL;
    m_pSourceSite      = NULL;
    m_pDestinationSite = NULL;
    m_pSourceDSA       = NULL;
    m_pDestinationDSA  = NULL;
    m_fLazyISMSchedule = FALSE;
    m_Transport        = NULL;
    m_SourceSite       = NULL;
    m_DestSite         = NULL;
    m_pAvailSchedule    = ToplGetAlwaysSchedule( scheduleCache );
    m_pReplSchedule    = ToplGetAlwaysSchedule( scheduleCache );
    m_ulReplInterval   = 0;
    m_ulOptions        = 0;
}

BOOL
KCC_SITE_CONNECTION::IsValid()
{
    return m_fIsInitialized;
}

TOPL_SCHEDULE
KCC_SITE_CONNECTION::GetAvailabilitySchedule(
    )
//
// Get the availability schedule for this connection. This may cause us to retrieve
// the schedule from the ISM.
//
{
    ISM_SCHEDULE        *IsmSchedule = NULL;
    TOPL_SCHEDULE_CACHE scheduleCache;
    TOPL_SCHEDULE       toplSchedule;
    DWORD               WinError;

    ASSERT_VALID( this );

    if( !m_fLazyISMSchedule ) {
        return m_pAvailSchedule;
    }

    // Retrieve the schedule from the ISM now
    m_fLazyISMSchedule = FALSE;
    Assert( NULL!=m_Transport );
    Assert( NULL!=m_SourceSite );
    Assert( NULL!=m_DestSite );
    
    WinError = I_ISMGetConnectionSchedule( m_Transport->GetDN()->StringName,
                                           m_SourceSite->GetObjectDN()->StringName,
                                           m_DestSite->GetObjectDN()->StringName,
                                           &IsmSchedule );
    if( ERROR_SUCCESS!=WinError ) {
        DPRINT3( 0, "I_ISMGetConnectionSchedule failed for transport %ls between sites %ls %ls\n",
                 m_Transport->GetDN()->StringName, 
                 m_SourceSite->GetObjectDN()->StringName, 
                 m_DestSite->GetObjectDN()->StringName );
        SetDefaultSchedule( m_ulReplInterval );
        return m_pAvailSchedule;
    }

    if( NULL==IsmSchedule || NULL==IsmSchedule->pbSchedule ) {
        DPRINT3( 4, "I_ISMGetConnectionSchedule returned no schedule for transport "
                 "%ls between sites %ls %ls. Using default schedule.\n",
                 m_Transport->GetDN()->StringName, 
                 m_SourceSite->GetObjectDN()->StringName, 
                 m_DestSite->GetObjectDN()->StringName );
        SetDefaultSchedule( m_ulReplInterval );
        return m_pAvailSchedule;
    }

    scheduleCache = gpDSCache->GetScheduleCache();
    Assert( NULL!=scheduleCache );

    __try {
        toplSchedule = ToplScheduleImport(
                scheduleCache,
                (PSCHEDULE) IsmSchedule->pbSchedule );
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        // Bad schedule.
        DPRINT2( 4,
           "ISM returned invalid schedule between sites %ls and %ls\n",
           m_SourceSite->GetObjectDN()->StringName,
           m_DestSite->GetObjectDN()->StringName );
        LogEvent(DS_EVENT_CAT_KCC,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_CHK_BAD_ISM_SCHEDULE,
                 szInsertDN(m_SourceSite->GetObjectDN()),
                 szInsertDN(m_DestSite->GetObjectDN()),
                 0);
        toplSchedule = ToplGetAlwaysSchedule( scheduleCache );
    }
    
    if( 0==ToplScheduleDuration(toplSchedule) ) {
        DPRINT3( 4, "I_ISMGetConnectionSchedule returned a NEVER schedule for "
                 "transport %ls between sites %ls %ls. Using default schedule.\n",
                 m_Transport->GetDN()->StringName, 
                 m_SourceSite->GetObjectDN()->StringName, 
                 m_DestSite->GetObjectDN()->StringName );
        SetDefaultSchedule( m_ulReplInterval );
    } else {
        SetSchedule( toplSchedule, m_ulReplInterval );
    }

    I_ISMFree( IsmSchedule );

    return m_pAvailSchedule;
}

TOPL_SCHEDULE
KCC_SITE_CONNECTION::GetReplicationSchedule(
    )
//
// Get the replication schedule for this connection. This may cause us to retrieve
// the schedule from the ISM.
//
// GetAvailabilitySchedule() is called to do the actual work. That function always
// ensures that the replication schedule has been prepared for us.
//
{
    GetAvailabilitySchedule();
    return m_pReplSchedule;
}

TOPL_SCHEDULE
KCC_SITE_CONNECTION::GetReplicationScheduleAltBH(
        KCC_DSA *pAlternateSourceDSA,
        KCC_DSA *pAlternateDestDSA )
//
// Get the replication schedule that would be used by this site connection if the
// alternate bridgeheads passed as parameters were used.
//
// pAlternateSourceDSA must be in the same site as this site connection's source
// DSA and pAlternateDestDSA must be in the same site as the destination DSA.
//
{
    TOPL_SCHEDULE_CACHE scheduleCache;
    TOPL_SCHEDULE       replSchedule;
    DWORD               staggeringNumber;

    ASSERT_VALID( this );
    Assert( m_ulReplInterval>0 );
    Assert( NameMatched(pAlternateSourceDSA->GetSiteDN(), GetSourceSite()->GetObjectDN()) );
    Assert( NameMatched(pAlternateDestDSA->GetSiteDN(), GetDestinationSite()->GetObjectDN()) );
    
    scheduleCache = gpDSCache->GetScheduleCache();
    Assert( NULL!=scheduleCache );
        
    GetAvailabilitySchedule();

    staggeringNumber = GetStaggeringNumber(
        GetSourceSite(), pAlternateSourceDSA, GetDestinationSite(), pAlternateDestDSA );

    replSchedule = ToplScheduleCreate(
        scheduleCache,
        m_ulReplInterval,
        m_pAvailSchedule,
        staggeringNumber);

    return replSchedule;
}

VOID
KCC_SITE_CONNECTION::RestaggerSchedule(
    VOID
    )
//
// This site connection has already been initialized.
// The end points of this site connection have been changed.
// The staggering must be recalculated.
//
{
    TOPL_SCHEDULE_CACHE scheduleCache;
    TOPL_SCHEDULE       replSchedule;
    DWORD               staggeringNumber;

    ASSERT_VALID( this );
    Assert( m_ulReplInterval>0 );
    ASSERT_VALID( m_pSourceSite );
    ASSERT_VALID( m_pDestinationSite );
    ASSERT_VALID( m_pSourceDSA );
    ASSERT_VALID( m_pDestinationDSA );
    Assert( !m_fLazyISMSchedule );
    
    scheduleCache = gpDSCache->GetScheduleCache();
    Assert( NULL!=scheduleCache );
        
    GetAvailabilitySchedule();

    staggeringNumber = GetStaggeringNumber(
        GetSourceSite(), GetSourceDSA(), GetDestinationSite(), GetDestinationDSA() );

    m_pReplSchedule = ToplScheduleCreate(
        scheduleCache,
        m_ulReplInterval,
        m_pAvailSchedule,
        staggeringNumber);
}

VOID
KCC_SITE_CONNECTION::SetISMSchedule(
    KCC_TRANSPORT   *Transport,
    KCC_SITE        *SourceSite,
    KCC_SITE        *DestSite,
    ULONG           ReplInterval
    )
//
// Set the schedule on this site connection to be a schedule which comes from
// the ISM. We don't actually retrieve the schedule until later.
//
{
    ASSERT_VALID( Transport );
    ASSERT_VALID( SourceSite );
    ASSERT_VALID( DestSite );
    
    m_fLazyISMSchedule = TRUE;
    m_Transport = Transport;
    m_SourceSite = SourceSite;
    m_DestSite = DestSite;
    m_pAvailSchedule = NULL;
    m_ulReplInterval = ReplInterval;
}

KCC_SITE_CONNECTION&
KCC_SITE_CONNECTION::SetSchedule(
    TOPL_SCHEDULE toplSchedule,
    ULONG         ReplInterval
    )
//
// toplSchedule is an availability schedule.
// ReplInterval is the period in minutes at which replication should poll.
//
// We convert the availability schedule to a replication schedule by polling
// at the period specified by the ReplInterval.
//
// Schedule-staggering may be employed -- see GetStaggeringNumber().
//
// Note: This function may not be called until the source/dest site,
// and source/dest dsa have been set.
//
{
    TOPL_SCHEDULE_CACHE     scheduleCache;
    DWORD                   staggeringNumber;

    ASSERT_VALID( this );
    ASSERT_VALID( m_pSourceSite );
    ASSERT_VALID( m_pDestinationSite );
    ASSERT_VALID( m_pSourceDSA );
    ASSERT_VALID( m_pDestinationDSA );
    Assert( !m_fLazyISMSchedule );
    
    scheduleCache = gpDSCache->GetScheduleCache();
    Assert( NULL!=scheduleCache );

    // Compute the schedule-staggering number for this connection
    staggeringNumber = GetStaggeringNumber(
        GetSourceSite(), GetSourceDSA(), GetDestinationSite(), GetDestinationDSA() );

    m_fLazyISMSchedule = FALSE;
    m_pAvailSchedule = toplSchedule;
    m_ulReplInterval = ReplInterval;
    
    m_pReplSchedule = ToplScheduleCreate(
        scheduleCache,
        m_ulReplInterval,
        m_pAvailSchedule,
        staggeringNumber);

    return *this;
}

KCC_SITE_CONNECTION&
KCC_SITE_CONNECTION::SetDefaultSchedule(
    ULONG ReplInterval
    )
//
// The default availability schedule is the always schedule.
// Create a replication schedule using the default availability schedule.
//
// Note: This function may not be called until the source/dest site,
// and source/dest dsa have been set.
//
{
    TOPL_SCHEDULE_CACHE scheduleCache=gpDSCache->GetScheduleCache();

    ASSERT_VALID( this );
    Assert( NULL!=scheduleCache );
    ASSERT_VALID( m_pSourceSite );
    ASSERT_VALID( m_pDestinationSite );
    ASSERT_VALID( m_pSourceDSA );
    ASSERT_VALID( m_pDestinationDSA );
    
    return SetSchedule( ToplGetAlwaysSchedule(scheduleCache), ReplInterval );
}

DWORD
KCC_SITE_CONNECTION::GetStaggeringNumber(
    KCC_SITE    *pSourceSite,
    KCC_DSA     *pSourceDsa,
    KCC_SITE    *pDestinationSite,
    KCC_DSA     *pDestDsa
    )
//
// Return a DWORD which will be used as the 'StaggeringNumber' parameter
// to ToplScheduleCreate.
//
// If the forest is not in Whistler-mode the staggering number will always be 0.
//
// If the schedule-staggering option has not been enabled in the source site of
// this connection, the staggering number will be 0.
//
// If the forest is in Whistler-mode and the schedule-staggering option has been
// enabled in the source-site, this function will return a hash of the source dsa
// and destination site dsa.
//
{
    DSNAME      *pSourceDsaDN, *pDestDsaDN;
    DWORD       forestVersion = gpDSCache->GetForestVersion();
    DWORD       sourceHash, destHash, totalHash;
    RPC_STATUS  rpcStatus;
    const DWORD NO_STAGGERING = 0;

    ASSERT_VALID(pSourceSite);
    ASSERT_VALID(pSourceDsa);
    ASSERT_VALID(pDestDsa);
    Assert(NameMatched(pSourceSite->GetObjectDN(), pSourceDsa->GetSiteDN()));

    // Staggering not supported in Win2K mode
    if( DS_BEHAVIOR_WIN2000==forestVersion ) {
        return NO_STAGGERING;
    }

    // Staggering only enabled if option bit set in source site
    if ( (!pSourceSite->IsScheduleStaggeringEnabled()) &&
         (!pDestinationSite->BuildRedundantServerTopology()) ) {
        return NO_STAGGERING;
    }

    // Get the hash for the source dsa
    pSourceDsaDN = pSourceDsa->GetDsName();
    sourceHash = UuidHash( &pSourceDsaDN->Guid, &rpcStatus );
    if( RPC_S_OK!=rpcStatus ) {
        KCC_EXCEPT( rpcStatus, 0 );
    }

    // Get the hash for the destination dsa
    pDestDsaDN = pDestDsa->GetDsName();
    destHash = UuidHash( &pDestDsaDN->Guid, &rpcStatus );
    if( RPC_S_OK!=rpcStatus ) {
        KCC_EXCEPT( rpcStatus, 0 );
    }

    // Note: sourceHash and destHash are 16-bits each.
    // The result is used to calculate a modular remainder, so the low order
    // bits should be random and reflect both parts.
    totalHash = sourceHash ^ destHash;

    return totalHash;
}

KCC_SITE_CONNECTION&
KCC_SITE_CONNECTION::SetSourceSite(
    IN KCC_SITE *pSite
    )
{
    ASSERT_VALID( this );

    Assert( pSite );

    //
    // This CTOPL_EDGE method links the edge part
    // of this site connection to the vertex part
    // object pSite
    //
    CTOPL_EDGE::SetFrom( pSite );

    m_pSourceSite = pSite;

    return *this;
}

KCC_SITE_CONNECTION&
KCC_SITE_CONNECTION::SetDestinationSite(
    IN KCC_SITE *pSite
    )
{
    ASSERT_VALID( this );

    Assert( pSite );

    //
    // This CTOPL_EDGE method links the edge part
    // of this site connection to the vertex part
    // object pSite
    //
    CTOPL_EDGE::SetTo( pSite );

    m_pDestinationSite = pSite;

    return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\kccnctl.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kccnctl.cxx

ABSTRACT:

    Routines to perform the automated NC topology

DETAILS:

CREATED:

    03/27/97    Colin Brace (ColinBr)

REVISION HISTORY:

--*/

#include <NTDSpchx.h>
#include "kcc.hxx"
#include "kcctask.hxx"
#include "kccconn.hxx"
#include "kcctopl.hxx"
#include "kcccref.hxx"
#include "kccdsa.hxx"
#include "kcctools.hxx"
#include "kcctrans.hxx"
#include "kccsconn.hxx"
#include "kccdynar.hxx"
#include "kccsite.hxx"
#include "kccduapi.hxx"
#include "kccstale.hxx"

#include "w32topl.h"

#define FILENO FILENO_KCC_KCCNCTL

//
// Prototypes of local functions
//

VOID
KccConstructRingTopology(
    IN     KCC_DSA_ARRAY *                  pDsaArray,
    IN     KCC_CROSSREF *                   pCrossRef,
    IN     BOOL                             fMasterOnly,
    IN OUT KCC_INTRASITE_CONNECTION_LIST *  pConnectionList
    );

VOID
KccConstructEfficientNCTopology(
    IN     KCC_CROSSREF *                   pCrossRef,
    IN     KCC_DSA_LIST &                   DsaList,
    IN     BOOL                             fRefresh,
    IN OUT KCC_INTRASITE_CONNECTION_LIST *  pConnectionList
    );

KCC_DSA*
KccDsaInGraph(
    IN DSNAME*    SourceDsName,
    IN TOPL_GRAPH Graph
    );

VOID
KccGetDsasInNC(
    IN  KCC_CROSSREF *  pCrossRef,
    IN  KCC_DSA_LIST &  dsaList,
    OUT KCC_DSA_ARRAY & dsaArray
    );

BOOL
KccCreateRandomConnection(
    IN  DSNAME             *pNC,
    IN  KCC_DSA_ARRAY       &dsaArray,
    IN OUT KCC_DSNAME_ARRAY &dnFromServers
    );


BOOL
KccIsTimeToRefreshTopology(
    IN KCC_DSA_LIST& dsaList
    );

//
// Function definitions
//

VOID
KccConstructMasterNCTopologiesForSite(
    IN OUT  KCC_INTRASITE_CONNECTION_LIST * pConnectionList
    )
/*++

Routine Description:

    This routine will determine what master naming contexts are
    hosted by the local dsa, and then construct a ring topology for all
    of those naming contexts.
    
Parameters:

    pConnectionList (IN/OUT)

Returns:

    None - the only errors are unexpected errors - so an exception is thrown
    
--*/
{
    //
    // NCArray is an array of pointers to DSNAME's off all naming
    // contexts hosted in by the local dsa.
    //
    KCC_CROSSREF_ARRAY  MasterHostedCrossRefArray;
    ULONG               i;
    KCC_SITE *          pLocalSite = gpDSCache->GetLocalSite();
    KCC_DSA_LIST *      pDsaList = pLocalSite->GetDsaList();
    KCC_DSA *           pLocalDSA = gpDSCache->GetLocalDSA();
    KCC_CROSSREF_LIST * pCrossRefList = gpDSCache->GetCrossRefList();
    BOOL                fRefresh;

    //
    // Make a list of all the master nc's the dsa hosts
    //
    for (i = 0; i < pCrossRefList->GetCount(); i++) {
        KCC_CROSSREF * pCrossRef = pCrossRefList->GetCrossRef(i);
        BOOL           fIsMaster;

        if (pLocalDSA->IsNCHost(pCrossRef, TRUE /* fIsLocal */, &fIsMaster)
            && fIsMaster) {
            MasterHostedCrossRefArray.Add(pCrossRef);
        }
    }

    // We should have at least three naming contexts
    Assert(MasterHostedCrossRefArray.GetCount() >= 3);

    //
    // Sort the array of naming contexts (by guid)
    // 2000-04-04 JeffParh - Why is sorting necessary?
    //
    MasterHostedCrossRefArray.Sort();

    //
    // Have so many new servers been added that we need to refresh our 
    // existing connections?
    //
    fRefresh = KccIsTimeToRefreshTopology(*pDsaList);

    //
    // For each naming context construct a ring topology
    //
    for (i = 0; i < MasterHostedCrossRefArray.GetCount(); i++) {
        KCC_CROSSREF * pCrossRef = MasterHostedCrossRefArray[i];
        KCC_DSA_ARRAY  DsaArray;
        DWORD ErrorCode;

        DPRINT1(3, "Constructing topology for %ws\n", pCrossRef->GetNCDN()->StringName);

        __try {

            DsaArray.GetLocalDsasHoldingNC( pCrossRef, TRUE );
            KccConstructRingTopology(&DsaArray,
                                     pCrossRef,
                                     TRUE,
                                     pConnectionList);

        } 
        __except( ToplIsToplException( (ErrorCode=GetExceptionCode()) ) ) {
            //
            // If an error occur in the w32topl, then the objects were somehow
            // mishandled.  Log the error and continue with the next
            // naming context
            //

            LogEvent8(
                DS_EVENT_CAT_KCC,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_KCC_AUTO_TOPL_GENERATION_INCOMPLETE,
                szInsertDN(pCrossRef->GetNCDN()),
                szInsertWin32ErrCode(ErrorCode),
                szInsertHex( DSID(FILENO, __LINE__) ),
                szInsertWin32Msg(ErrorCode),
                NULL, NULL, NULL, NULL
                );
        }
    }

    //
    // Add some more connections to minimize hops between servers.  Note that 
    // this is done after the ring topology so an nc can consider connections 
    // for other nc's ring topology as optimizing connections for their own 
    // topology.
    //
    if (!pLocalSite->IsMinimizeHopsDisabled()) {
        for (i = 0; i < MasterHostedCrossRefArray.GetCount(); i++) {
            KCC_CROSSREF * pCrossRef = MasterHostedCrossRefArray[i];
            BOOL fRefreshThisNc = FALSE;
            
            // By refreshing the configuration naming context, we
            // have refreshed the schema nc, too, so don't do it
            // twice.
            fRefreshThisNc = fRefresh
                             && (KCC_NC_TYPE_SCHEMA != pCrossRef->GetNCType());

            KccConstructEfficientNCTopology(pCrossRef,
                                            *pDsaList,
                                            fRefreshThisNc,
                                            pConnectionList);

        }
    }
}

VOID 
KccConstructPartialReplicaNCTopologiesForSite(
    IN OUT  KCC_INTRASITE_CONNECTION_LIST * pConnectionList
    )
/*++

Routine Description:

    This routine will determine what partial replica naming contexts are
    hosted by the local dsa, and then construct a ring topology for all
    of those naming contexts.
    
Parameters:

    pConnectionList (IN/OUT)

Returns:

    None - the only errors are unexpected errors - so an exception is thrown
    
--*/
{
    DWORD               icref;
    ULONG               i;
    KCC_DSA *           pLocalDSA = gpDSCache->GetLocalDSA();
    KCC_CROSSREF_LIST * pCrossRefList = gpDSCache->GetCrossRefList();
    BOOL                fIsMaster;

    if (!pLocalDSA->IsGC()) {
        // no partial replicas to process if this is not a GC
        return;
    }

    // We are going to iterate through partial replica NCs
    // we should get the list partial replica NCs that should
    // be hosted by this DSA by iterating through the crossref 
    // objects

    for (icref = 0; icref < pCrossRefList->GetCount(); icref++) {
        KCC_CROSSREF * pCrossRef = pCrossRefList->GetCrossRef(icref);
        KCC_DSA_ARRAY  DsaArray;
        DWORD ErrorCode;

        ASSERT_VALID(pCrossRef);

        if (pLocalDSA->IsNCHost(pCrossRef, TRUE /* fIsLocal */, &fIsMaster)
            && !fIsMaster) {
            // This is a partial replica NC that needs to be 
            // hosted by this GC.

            DPRINT1(3, "Constructing topology for %ws\n", pCrossRef->GetNCDN()->StringName);
    
            __try {

                DsaArray.GetLocalDsasHoldingNC( pCrossRef, FALSE );
                KccConstructRingTopology(&DsaArray,
                                         pCrossRef,
                                         FALSE,
                                         pConnectionList);
    
            } __except(ToplIsToplException(ErrorCode=GetExceptionCode())) {
                //
                // If an error occur in the w32topl, then the objects were somehow
                // mishandled.  Log the error and continue with the next
                // naming context
                //
    
                LogEvent8(
                    DS_EVENT_CAT_KCC,
                    DS_EVENT_SEV_ALWAYS,
                    DIRLOG_KCC_AUTO_TOPL_GENERATION_INCOMPLETE,
                    szInsertDN(pCrossRef->GetNCDN()),
                    szInsertWin32ErrCode(ErrorCode),
                    szInsertHex( DSID(FILENO, __LINE__) ),
                    szInsertWin32Msg(ErrorCode),
                    NULL, NULL, NULL, NULL
                    );
            }
        }
    }
}

VOID 
KccConstructGCTopologyForSite(
    IN OUT  KCC_INTRASITE_CONNECTION_LIST * pConnectionList
    )
/*++

Routine Description:

    This function creates a ring topology for all GCs in the local site.
    
Parameters:

    pConnectionList (IN/OUT)

Returns:

    None - the only errors are unexpected errors - so an exception is thrown
    
--*/
{
    KCC_DSA_ARRAY       DsaArray;
    KCC_CROSSREF_LIST  *pCrossRefList = gpDSCache->GetCrossRefList();
    KCC_CROSSREF       *pConfigCR;
    DSNAME             *pConfigDN = gpDSCache->GetConfigNC();
    KCC_DSA *           pLocalDSA = gpDSCache->GetLocalDSA();
    DWORD               ErrorCode;


    // No need to process GC topology if this is not a GC
    if (!pLocalDSA->IsGC()) {
        return;
    }


    // Find the CrossRef for Config
    pConfigCR = pCrossRefList->GetCrossRefForNC( pConfigDN );
    ASSERT_VALID(pConfigCR);
    if(!pConfigCR) {
        KCC_EXCEPT(ERROR_DS_OBJ_NOT_FOUND, 0);
    }


    DPRINT(3, "Constructing GC topology\n");
    
    __try {
    
        DsaArray.GetLocalGCs();
        KccConstructRingTopology(&DsaArray,
                                 pConfigCR,
                                 FALSE,
                                 pConnectionList);
                               
    } __except(ToplIsToplException(ErrorCode=GetExceptionCode())) {

        //
        // If an error occur in the w32topl, then the objects were somehow
        // mishandled.  Log the error and continue with the next
        // naming context
        //    
        LogEvent8(
            DS_EVENT_CAT_KCC,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_KCC_AUTO_TOPL_GENERATION_INCOMPLETE,
            szInsertDN(pConfigDN),
            szInsertWin32ErrCode(ErrorCode),
            szInsertHex( DSID(FILENO, __LINE__) ),
            szInsertWin32Msg(ErrorCode),
            NULL, NULL, NULL, NULL
            );
    }
}

VOID
KccConstructTopologiesForSite(
    IN OUT  KCC_INTRASITE_CONNECTION_LIST * pConnectionList
    )
/*++

Routine Description:

    Given the DSNAME of a site, this routine will determine what
    naming contexts are hosted by the local dsa, and then construct
    a list of all dsa's in this site for another function to analyse.
    
Parameters:

    pSite : the DSNAME of the site to constuct the topology for

Returns:

    None - the only errors are unexpected errors - so an exception is thrown
    
--*/
{
    // The local site is never empty because the local DSA is always in
    // the local site. This is checked when initializing the KCC_CACHE
    Assert( gpDSCache->GetLocalSite()->GetDsaList()->GetCount()>0 );

    KccConstructMasterNCTopologiesForSite(pConnectionList);
    
    KccConstructPartialReplicaNCTopologiesForSite(pConnectionList);
    
    KccConstructGCTopologyForSite(pConnectionList);
}
      
VOID
KccConstructRingTopology(
    IN     KCC_DSA_ARRAY *                  pDsaArray,
    IN     KCC_CROSSREF *                   pCrossRef,
    IN     BOOL                             fMasterOnly,
    IN OUT KCC_INTRASITE_CONNECTION_LIST *  pConnectionList
    )
/*++

Routine Description:

    Connect all servers in pDsaArray in a ring.

Parameters:

    pDsaArray       - This is a list of servers to connect in a ring.

    pCrossRef       - If we're building the topology for a particular NC, this
                      is the crossref of the NC.
                     
    fMasterOnly     - If we're building the topology for a particular NC, this
                      indicates whether pDsaArray contains just Masters or
                      Readonly copies too.
                      
    pConnectionList - a list of servers to mark if this function doesn't want
                      them removed                     

Returns:

--*/
{
    KCC_DSA       *pDsa;
    CTOPL_GRAPH   Graph;
    TOPL_ITERATOR VertexIter = NULL;
    KCC_DSA_ARRAY HostingDsaArray;
    ULONG         i, j;
    KCC_DSA *     pLocalDsa = gpDSCache->GetLocalDSA();
    BOOL          fIsMaster;

    ASSERT_VALID(pCrossRef);
    ASSERT_VALID(pDsaArray);
    ASSERT_VALID(pConnectionList);
            
    // If there aren't any servers in the list, don't do anything
    if (pDsaArray->GetCount() == 0) {
        DPRINT1(0, "ConstructNCTopology for %ws called with empty pDsaArray\n"
                "Server objects moved while KCC was running.",
                pCrossRef->GetNCDN()->StringName);
        return;
    }
    
    //
    // Iterate through the dsa's and for each dsa that is not
    // stale, add that dsa to the HostingDsaArray
    //
    for (i = 0; i < pDsaArray->GetCount(); i++) {
        pDsa = (*pDsaArray)[i];
        ASSERT_VALID(pDsa);

        pDsa->ClearEdges();

        if (!KccCriticalLinkServerIsStale(pDsa->GetDsName())
            && !KccCriticalConnectionServerIsStale(pDsa->GetDsName()))
        {
            // Dsa is online and should be included in the topology.
            HostingDsaArray.Add(pDsa);
            DPRINT2(4, "Dsa %ws is a candidate to source nc %ws\n",
                pDsa->GetDsName()->StringName,
                pCrossRef->GetNCDN()->StringName);
        } else {
            // We still want to keep connection objects inbound to the local
            // DSA from "stale" servers so we keep trying to replicate from
            // them.
            KCC_CONNECTION *pcn = pConnectionList
                                        ->GetConnectionFromSourceDSAUUID(
                                                &pDsa->GetDsName()->Guid);
            if (pcn) {
                pcn->AddReplicatedNC(pCrossRef->GetNCDN(), !fMasterOnly);
                pcn->SetReasonForConnection(KCC_STALE_SERVERS_TOPOLOGY);
                DPRINT2(4, "keeping connection %ws because of stale source %ws\n",
                        pcn->GetConnectionDN()->StringName,
                        pDsa->GetDsName()->StringName);
            }
        }
    }

    //
    // Sort the dsa's by guid
    //
    HostingDsaArray.Sort();

    //
    // Now find all the edges that connect two servers in 
    // the graph
    //
    for ( i = 0; i < HostingDsaArray.GetCount(); i++) {

        pDsa = HostingDsaArray[i];
        Assert(pDsa);

        //
        // The array of Dsa objects have already been sorted, so assign
        // an id for the graph routines
        //
        pDsa->SetId(i);

        //
        // Insert the Dsa into the graph
        //
        Graph.AddVertex( pDsa, pDsa );

        //
        // Now determine if any connections already exist for this naming
        // context's topology inbound to the local DSA.
        //
        if (pDsa == pLocalDsa) {
            KCC_CONNECTION *  Conn;
            KCC_DSA *         SourceDsa;
    
            for (j = 0; j < pConnectionList->GetCount(); j++) {
    
                Conn = pConnectionList->GetConnection(j);
    
                Assert(Conn);
                Assert(Conn->GetSourceDSADN());
    
                SourceDsa = HostingDsaArray.Find(Conn->GetSourceDSADN());
                
                if (SourceDsa) {
    
                    //
                    // This connection object connects two 
                    // servers in the graph
                    //
                    Conn->SetTo(pDsa);
                    Conn->SetFrom(SourceDsa);
    
                    //
                    // This makes the edge appear in the vertices
                    // list of head and tail vertices
                    //
                    Conn->Associate();
                }
            }
        }
    }

    //
    //  Determine what new connections need to be made and what old
    //  ones can be kept
    //
    TOPL_LIST     EdgeToAddList = ToplListCreate();
    TOPL_ITERATOR EdgeIter = ToplIterCreate();
    TOPL_EDGE    *EdgesToKeep = NULL;
    ULONG         cEdgesToKeep;

    __try {

        Graph.MakeRing(TOPL_RING_TWO_WAY,
                       EdgeToAddList,
                       &EdgesToKeep,
                       &cEdgesToKeep);
    
        //
        // For each connection returned that has to be created
        // check to see if it should be created on this dsa
        // then create it.
        //
        CTOPL_EDGE *Edge;
        for (Edge = NULL, ToplListSetIter(EdgeToAddList, EdgeIter);
            (Edge = (CTOPL_EDGE*) ToplIterGetObject(EdgeIter)) != NULL;
                ToplIterAdvance(EdgeIter)) {
    
            Assert(Edge);
    
            //
            // Is connection one that sources the local DSA - if so, create the
            // connection object locally
            //
            if( (CTOPL_VERTEX*)ToplEdgeGetToVertex(Edge) == (CTOPL_VERTEX*) pLocalDsa ) {
    
                //
                // This connection object should be made locally
                //
                KCC_DSA *         SourceDSA = (KCC_DSA*) Edge->GetFrom();
                KCC_CONNECTION *  pcnNew = new KCC_CONNECTION;
    
                Assert( gfIntrasiteSchedInited );
                pcnNew->SetEnabled(       TRUE                         );
                pcnNew->SetGenerated(     TRUE                         );
                pcnNew->SetSourceDSA(     SourceDSA                    );
                pcnNew->SetSchedule(      gpIntrasiteSchedule          );
                pcnNew->AddReplicatedNC(  pCrossRef->GetNCDN(), !fMasterOnly);
                pcnNew->SetReasonForConnection( KCC_RING_TOPOLOGY );
    
                DWORD dirError = pcnNew->Add(pLocalDsa->GetDsName(), DSID(FILENO,__LINE__));
    
                if (0 == dirError) {
                    pConnectionList->AddToList(pcnNew);
                }
            }
        }

        //
        // Now flag all the connections in pConnectionList we want to keep
        //
        if ( pConnectionList )
        {
            for ( i = 0; i < cEdgesToKeep; i++)
            {
                KCC_CONNECTION *pcnKeep;
                KCC_CONNECTION *pcn = (KCC_CONNECTION*)((CTOPL_EDGE*)EdgesToKeep[ i ]);
    
                pcnKeep = pConnectionList->GetConnectionWithSameGUID(pcn);
                if (pcnKeep)
                {
                    pcnKeep->AddReplicatedNC( pCrossRef->GetNCDN(), !fMasterOnly );
                    pcnKeep->SetReasonForConnection(KCC_RING_TOPOLOGY);
                }
                // else 
                //
                //  A connection object got added in between the time the deletion
                //  candidate list was created and now.  Fine - it is not in the list
                //  and it won't be deleted.
                //
            }
        }

    }
    __finally
    {

        //
        // Free the list and all the edges contained in the list
        // 
        ToplListFree(EdgeToAddList, TRUE);
        ToplIterFree(EdgeIter);
        if (EdgesToKeep)
        {
            ToplFree(EdgesToKeep);
        }

    }                

    return;

}

VOID
KccConstructEfficientNCTopology(
    IN      KCC_CROSSREF *                  pCrossRef,
    IN      KCC_DSA_LIST &                  dsaList,
    IN      BOOL                            fRefresh,
    IN OUT  KCC_INTRASITE_CONNECTION_LIST * pConnectionList 
    )
/*++

Routine Description:

    This routine looks at all the connections coming into the local server
    and makes sure there is at least n number of connections. n is determined by
    a special purpose function, KccGetNumberOfOptimizingEdges().
    
    Each server must have at least at least two incoming edges for the ring topology.
    This function adds KccGetNumberOfOptimizingEdges more to the server, sourced from
    random servers within the site that host the NC specified.
    
    This function has 3 sections:  Determing what connections are still considered
    useful, marking existing connections are useful so they won't get deleted, and
    creating any new connections if necessary.
    
Parameters:

    pCrossRef       - the crossref for the NC to build a topology for
    
    dsaList         - this is a list of servers from which to connect all 
                      servers that host this NC

    fRefresh        - refresh an old optimization connection if one exists
    
    pConnectionList - a list of servers to mark if this function doesn't want
                      them removed                     
                      
Returns:

    VOID

--*/
{
    KCC_INTRASITE_CONNECTION_LIST *pcnlist;
    KCC_CONNECTION       *pcn, *pcn2, *pcnOldest = NULL;
    KCC_DSA              *pdsa;
    DSNAME               *pdnFromServer;
    ULONG                cConnections, iConnection;
    BOOL                 fIsMaster;
    KCC_CONNECTION_ARRAY cnArray;
    KCC_DSNAME_ARRAY     dnFromServers;
    KCC_DSA_ARRAY        dsaArray;
    ULONG                TotalConnectionsNeeded = 0;
    ULONG                NewConnectionsNeeded = 0;
    ULONG                Index;
    BOOL                 fStatus;
    ULONG                Reason;
    BOOL                 fDeletionCandidate;
    DSNAME *             pdnLocalDSA = gpDSCache->GetLocalDSADN();

    Assert( pConnectionList );

    //
    // Bail out right away if we don't need more than the ring topology
    //
    if ( KccGetNumberOfOptimizingEdges( dsaList.GetCount() ) == 0 )
    {
        return;
    }

    //
    // In the initial part of the analysis, we keep track of all servers we have
    // connections from so if we have to randomly create a new connection, we
    // won't choose a server that we are already connected to.  For starters,
    // add the local machine to the list
    //
    dnFromServers.Add(pdnLocalDSA);

    //
    // Determine what connections we can consider that we already have.
    //

    pcnlist = gpDSCache->GetLocalDSA()->GetIntraSiteCnList();

    cConnections = pcnlist->GetCount();

    for ( iConnection = 0; iConnection < cConnections; iConnection++ )
    {
        pcn = pcnlist->GetConnection( iConnection );

        pdnFromServer = pcn->GetSourceDSADN();

        pdsa = dsaList.GetDsa( pdnFromServer );

        if (pdsa
            && pdsa->IsNCHost(pCrossRef, FALSE /* fIsLocal */, &fIsMaster)
            && fIsMaster) {
            //
            // Record this server in our list of servers that we
            // we have a connection from
            //
            dnFromServers.Add( pdsa->GetDsName() );

            //
            // Ok, this connection is from a server is the
            // current naming context - now, is this a connection
            // that is considered good?
            //
            
            if ( KccNonCriticalLinkServerIsStale( pdnFromServer )
              || KccNonCriticalConnectionServerIsStale( pdnFromServer ) )
            {

                //
                // This connection is no good, don't mark it as useful
                // so it gets deleted at the end of this iteration
                //
                NOTHING;
            }
            else
            {
                //
                // This connection can be considered
                //
                cnArray.Add( pcn );

            }

            //
            // While we are looping through all the connections, let's find
            // the likeliest candidate for deletion in case we want to
            // refresh the topology.
            //
            // Manual connections are not candidates for deletion.
            //
            fDeletionCandidate = FALSE;
            pcn2 = pConnectionList->GetConnectionWithSameGUID( pcn );
            if ( pcn2 )
            {
                Reason = pcn2->GetReasonForConnection();

                if(   ((Reason & ~KCC_MINIMIZE_HOPS_TOPOLOGY) == 0)
                   && (pcn2->IsGenerated()) )
                {
                    //
                    // This connection is only used to minimize
                    // hops
                    //
                    fDeletionCandidate = TRUE;
                    
                }
            }
    
            if ( fDeletionCandidate )
            {
                //
                // This is a connection that we could delete
                //
                if ( pcnOldest )
                {
                    if ( pcn2->GetWhenCreated() < pcnOldest->GetWhenCreated() )
                    {
                        pcnOldest = pcn2;
                    }
                }
                else
                {
                    pcnOldest = pcn2;
                }
            }
        }
    }

    if ( cnArray.GetCount() < 2 )
    {
        //
        // less than two connections => less than 3 servers are hosting this NC
        // in this site. No need to continue with Optimizing Edges algo.
        //
        return;
        
    }

    //
    // Ok, we have now constructed a list of connection objects
    // that source from servers in this site from the given naming
    // context that are not stale.  How many total connections
    // do we need?
    //
    TotalConnectionsNeeded = KccGetNumberOfOptimizingEdges( dsaList.GetCount() )
                             + 2;

    //        
    // Now determine if we need to create connections and how many current
    // connection we should mark as needed.
    //
    if ( cnArray.GetCount() < TotalConnectionsNeeded ) 
    {
        //
        // Create some new connections, randomly sourced
        //
        NewConnectionsNeeded = TotalConnectionsNeeded - cnArray.GetCount();

    }
    else 
    {
        //
        // We have exactly enough or too many
        //
        
        //
        // See if we want to replace an old connection
        //
        if ( fRefresh )
        {
            if ( pcnOldest )
            {
#if DBG
                //
                // This edge should only be used for optimizing purposes
                //
                {
                    DWORD dwReason;
            
                    dwReason = pcnOldest->GetReasonForConnection(); 
                    Assert( (dwReason & ~KCC_MINIMIZE_HOPS_TOPOLOGY) == 0 );
                }
#endif


                //
                // Delete it.
                // Only KCC-generated connection should have been
                // selected for deletion.
                //
                Assert( pcnOldest->IsGenerated() );
                if (!gConnectionDeletionCache.PreventRepeatedDeletion(
                        pcnOldest, DSID(FILENO,__LINE__) )) {
                    pcnOldest->Remove( DSID(FILENO,__LINE__) );
                    cnArray.Remove(pcnOldest);
                    pcnlist->RemoveFromList(pcnOldest);
                    delete pcnOldest;

                    //
                    // Make a new connection
                    //
                    NewConnectionsNeeded = 1;
                }
            }
            else
            {
                //
                //  We could not find an appropriate edge to delete.
                //
                NOTHING;
            }
        }
        else
        {
            //
            //  No desire to refresh this iteration
            //
            NOTHING;
        }

    }

    //
    // At this point, we have determined if any new connections need to be created
    // and if any edges need to be kept. 
    //

    //
    // First mark the minimum number of edges we need; this is a two pass algorithm:
    //

    //
    // First we mark all the edges that already have a reason to exist - use
    // these first; second mark edges with no reason
    //
    ULONG ccn, icn;
    ULONG cValidConnections = 0;

    ccn = cnArray.GetCount();

    for ( icn = 0; 
            icn < ccn && cValidConnections < TotalConnectionsNeeded; 
                icn++ )
    {
        pcn = cnArray[icn];
        Assert( pcn );
        
        //
        // Find the reason for this connection, if there is one
        //
        pcn2 = pConnectionList->GetConnectionWithSameGUID( pcn );
        if ( pcn2 )
        {
            Reason = pcn2->GetReasonForConnection();

            if ( Reason != KCC_NO_REASON )
            {
                Reason |= KCC_MINIMIZE_HOPS_TOPOLOGY;
                
                pcn2->AddReplicatedNC( pCrossRef->GetNCDN(), FALSE /* NOT GC */ );
                pcn2->SetReasonForConnection( Reason );

                cValidConnections++;
            
            }
        }
        else
        {
            //
            // Since this connection was not in the original list of
            // connections, it must have been created on this iteration
            // of the KCC; it fits the criteria of an optimizing connection
            // so let's use it
            //
            cValidConnections++;

        }
    }

    //
    // Second, if we have to, mark connections with no reason
    //
    for ( icn = 0; 
            icn < ccn && cValidConnections < TotalConnectionsNeeded; 
                icn++ )
    {
        pcn = cnArray[icn];
        Assert( pcn );
        
        //
        // Find the reason for this connection, if there is one
        //
        pcn2 = pConnectionList->GetConnectionWithSameGUID( pcn );
        if ( pcn2 )
        {
            DWORD dwReason2 = pcn2->GetReasonForConnection();

            //
            // If the connection has no reason and it is not the connection 
            // that we want to delete then mark it as needed.
            //
            if ( dwReason2 == KCC_NO_REASON 
              && !(fRefresh && pcn2 == pcnOldest ) )
            {
                dwReason2 |= KCC_MINIMIZE_HOPS_TOPOLOGY;
                
                pcn2->AddReplicatedNC( pCrossRef->GetNCDN(), FALSE /* NOT GC */ );
                pcn2->SetReasonForConnection( dwReason2 );

                cValidConnections++;
            }
        }
    }

    Assert( cValidConnections <= TotalConnectionsNeeded );
    
    // If we haven't decided to pick a new source for an old optimizing
    // connection, then if all current connections are valid we shouldn't
    // need to add any more.
    Assert(fRefresh
           || (cValidConnections != TotalConnectionsNeeded)
           || (0 == NewConnectionsNeeded));

    //
    // Now, create any connections we need to
    //
    if ( NewConnectionsNeeded > 0 )
    {

       //
       // First, make the array of servers that are possible candidates
       //
       KccGetDsasInNC(pCrossRef,     // the nc we are interested in 
                      dsaList,       // the list of servers in the current site
                      dsaArray);     // out - the servers hosting the nc

       for ( Index = 0; Index < NewConnectionsNeeded; Index++ )
       {
           fStatus = KccCreateRandomConnection( pCrossRef->GetNCDN(),
                                                dsaArray,
                                                dnFromServers );

           if ( !fStatus )
           {
               //
               // We were not able to find or create a new connection
               // try on the next KCC iteration
               //
               break;
               
            }
        }
    }
}


VOID
KccGetDsasInNC(
    IN  KCC_CROSSREF *  pCrossRef,
    IN  KCC_DSA_LIST &  dsaList,
    OUT KCC_DSA_ARRAY & dsaArray
    )
//
// Extract the servers from dsaList that host pNC and put them in
// dsaArray.
//
{

    ULONG    idsa, cdsa;
    KCC_DSA  *pdsa;
    BOOL     fIsMaster;
    KCC_DSA *pLocalDSA = gpDSCache->GetLocalDSA();

    cdsa = dsaList.GetCount();

    for (idsa = 0; idsa < cdsa; idsa++) {
        pdsa = dsaList.GetDsa(idsa);

        if (pdsa
            && pdsa->IsNCHost(pCrossRef, (pdsa == pLocalDSA), &fIsMaster)
            && fIsMaster) {
            //
            // This is a candidate
            //
            dsaArray.Add( pdsa );
        }
    }
}

BOOL
KccCreateRandomConnection(
    IN     DSNAME          *pNC,
    OUT    KCC_DSA_ARRAY    &dsaArray,
    IN OUT KCC_DSNAME_ARRAY &dnFromServers
    )
//
// Randomly choose a server from dsaArray that is not known to be stale
// and not server from whom we already have a connection. Once chosen
// make a connection from this server.
//
{
    ULONG    iSource;
    KCC_DSA *pdsa;
    ULONG    Count, cdsa;
    ULONG    cMaxRandomTries;
    BOOL     fSuccess = FALSE;
    DSNAME * pdnLocalDSA = gpDSCache->GetLocalDSADN();
    KCC_INTRASITE_CONNECTION_LIST * pConnectionList = gpDSCache->GetLocalDSA()->GetIntraSiteCnList();

    cMaxRandomTries = dsaArray.GetCount() * 2;

    for (Count = 0, pdsa = NULL; Count < cMaxRandomTries && !fSuccess; Count++) {

        iSource = rand() % dsaArray.GetCount();

        pdsa = dsaArray[ iSource ];

        if (!KccNonCriticalConnectionServerIsStale(pdsa->GetDsName())
            && !dnFromServers.IsElementOf(pdsa->GetDsName())) {
            //
            // Ok, this is a server that we don't have a connection
            // for.  Make a connection.
            //

            KCC_CONNECTION * pcnNew = new KCC_CONNECTION;
            
            Assert( gfIntrasiteSchedInited );
            pcnNew->SetEnabled(       TRUE                         );
            pcnNew->SetGenerated(     TRUE                         );
            pcnNew->SetSourceDSA(     pdsa                         );
            pcnNew->SetSchedule(      gpIntrasiteSchedule          );
            pcnNew->AddReplicatedNC(  pNC, FALSE /* not gc */ );
            pcnNew->SetReasonForConnection( KCC_MINIMIZE_HOPS_TOPOLOGY );

            DWORD dirError = pcnNew->Add( pdnLocalDSA, DSID(FILENO,__LINE__) );

            if (0 == dirError) {
                pConnectionList->AddToList(pcnNew);
                
                fSuccess = TRUE;
            }

            //
            // Don't use this source server again
            //
            dnFromServers.Add( pdsa->GetDsName() );
            
        } else {
            pdsa = NULL;
        }
    }

    if (!pdsa) {
        //
        // We didn't find one after the maximum number of random tries
        // Go through iteratively
        //
        Assert( Count == cMaxRandomTries );

        cdsa = dsaArray.GetCount();

        for (iSource = 0; !fSuccess && iSource < cdsa; iSource++) {

            pdsa = dsaArray[iSource];
    
            if (!KccNonCriticalConnectionServerIsStale(pdsa->GetDsName()) 
                && !dnFromServers.IsElementOf(pdsa->GetDsName())) {
                //
                // Ok, this is a server that we don't have a connection
                // for.  Make a connection.
                //
                KCC_CONNECTION * pcnNew = new KCC_CONNECTION;
                
                Assert( gfIntrasiteSchedInited );
                pcnNew->SetEnabled(       TRUE                         );
                pcnNew->SetGenerated(     TRUE                         );
                pcnNew->SetSourceDSA(     pdsa                         );
                pcnNew->SetSchedule(      gpIntrasiteSchedule          );
                pcnNew->AddReplicatedNC(  pNC, FALSE /* not gc */ );
                pcnNew->SetReasonForConnection( KCC_MINIMIZE_HOPS_TOPOLOGY );
    
                DWORD dirError = pcnNew->Add( pdnLocalDSA, DSID(FILENO,__LINE__) );
    
                if ( 0 == dirError ) {
                    pConnectionList->AddToList(pcnNew);
                    
                    fSuccess = TRUE;
                }
    
                //
                // Don't use this source server again
                //
                dnFromServers.Add( pdsa->GetDsName() );
            }
        }
    }

    return fSuccess;
}


BOOL
KccIsTimeToRefreshTopology(
    IN KCC_DSA_LIST& dsaList
    )
//
// Every 9 to 11 new servers, refresh the optimizing topology
//
{
    #define KCC_SERVER_REFRESH_DELTA (((rand() % 3) + 10))

    if ( gfLastServerCountSet && gLastServerCount > 7 )
    {
        if ( dsaList.GetCount() > gLastServerCount + KCC_SERVER_REFRESH_DELTA )
        {
            gLastServerCount = dsaList.GetCount();
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\kcctools.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kcctools.cxx

ABSTRACT:

    Miscellaneous global utility functions.

DETAILS:


CREATED:

    01/21/97    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <NTDSpchx.h>
#include <dsconfig.h>
#include "kcc.hxx"
#include "kccduapi.hxx"
#include "kcctools.hxx"
#include "kccconn.hxx"
#include "kccstale.hxx"
#include "kccsite.hxx"
#include <w32toplsched.h>

#define FILENO FILENO_KCC_KCCTOOLS

BOOL
KccIsDSAInStayOfExecution(
    IN  UUID *  puuidDSA,
    OUT BOOL *  pfIsDeleted
    )
//
// Is the DSA with the given Object-Guid / Invocation-ID deleted _and_ deleted
// less than KccGetStayOfExecution() seconds ago?
//
{
    BOOL        fIsInStayOfExecution = FALSE;
    BYTE   *    rgbDSADN;
    DSNAME *    pdnDSA;
    DWORD       dwStayOfExecutionLen;

    dwStayOfExecutionLen = gpDSCache->GetStayOfExecution();
    if( 0==dwStayOfExecutionLen ) {
        // Special case: Stay of Execution has been disabled.
        return FALSE;
    }

    // Construct a DSNAME for the object.
    // Note that string name is not used, so a DSNAME sized memory suffices
    rgbDSADN = (BYTE *) new BYTE[ DSNameSizeFromLen(0) ];

    pdnDSA = (DSNAME *) rgbDSADN;
    pdnDSA->Guid      = *puuidDSA;
    pdnDSA->structLen = DSNameSizeFromLen( 0 );

    // What is the earliest time the NTDS-DSA object could have been deleted
    // and still be within its stay of execution?
    DSTIME timeDeletedAfter = GetSecondsSince1601() - dwStayOfExecutionLen;

    // Does this object exist and match our criteria to be considered in a
    // stay of execution?

    ATTR      rgAttrs[] =
    {
        { ATT_IS_DELETED,   { 0, NULL } },
        { ATT_WHEN_CHANGED, { 0, NULL } }
    };

    ENTINFSEL Sel =
    {
        EN_ATTSET_LIST,
        { sizeof( rgAttrs )/sizeof( rgAttrs[ 0 ] ), rgAttrs },
        EN_INFOTYPES_TYPES_VALS
    };

    ULONG       dirError;
    READRES *   pReadRes = NULL;
    BOOL        fIsDeleted = FALSE;
    DSTIME      timeChanged = 0;

    dirError = KccRead( pdnDSA, &Sel, &pReadRes, KCC_INCLUDE_DELETED_OBJECTS );

    if (0 != dirError )
    {

        if ( ( referralError == dirError )
         || (    ( nameError == dirError )
              && (    pReadRes->CommRes.pErrInfo->NamErr.extendedErr
                   == DIRERR_OBJ_NOT_FOUND )
              && (    pReadRes->CommRes.pErrInfo->NamErr.problem
                   == NA_PROBLEM_NO_OBJECT ) ) )
        {

            //
            // This is the case where the object really does not exist
            //
            fIsInStayOfExecution = FALSE;
    
            if ( NULL != pfIsDeleted )
            {
                //
                // The object was deleted at some point.
                //
                *pfIsDeleted = TRUE;
            }
    
        }
        else
        {
            //
            // We will want to understand these cases as they should not happen
            //
            KCC_LOG_READ_FAILURE( pdnDSA, dirError );
            KCC_EXCEPT( DIRERR_MISSING_EXPECTED_ATT, dirError );
        }
    }
    else
    {
        // Read succeeded; parse returned attributes.
        for ( DWORD iAttr = 0; iAttr < pReadRes->entry.AttrBlock.attrCount; iAttr++ )
        {
            ATTR *  pattr = &pReadRes->entry.AttrBlock.pAttr[ iAttr ];

            switch ( pattr->attrTyp )
            {
            case ATT_IS_DELETED:
                Assert( 1 == pattr->AttrVal.valCount );
                Assert( sizeof( fIsDeleted ) == pattr->AttrVal.pAVal->valLen );
                fIsDeleted = *( (BOOL *) pattr->AttrVal.pAVal->pVal );
                break;

            case ATT_WHEN_CHANGED:
                Assert( 1 == pattr->AttrVal.valCount );
                Assert( sizeof( timeChanged ) == pattr->AttrVal.pAVal->valLen );
                timeChanged = *( (DSTIME *) pattr->AttrVal.pAVal->pVal );
                break;

            default:
                DPRINT1( 0, "Received unrequested attribute 0x%X.\n", pattr->attrTyp );
                break;
            }
        }

        // ATT_WHEN_CHANGED must be present
        if (!timeChanged) {
            Assert(!"NTDSKCC: KccRead did not return ATT_WHEN_CHANGED\n");
            KCC_EXCEPT( ERROR_DS_MISSING_REQUIRED_ATT, 0);
        }

        fIsInStayOfExecution = fIsDeleted && ( timeChanged >= timeDeletedAfter );

        if ( NULL != pfIsDeleted )
        {
            *pfIsDeleted = fIsDeleted;
        }
    }

    delete[] rgbDSADN;
    return fIsInStayOfExecution;
}


BOOL
KccIsDeleted(
    IN  DSNAME *    pdn
    )
//
// Is the given object logically deleted?
// If the object does not exist, or if there is an unexpected error, an
// exception is raised.
//
{
    ATTR      rgAttrs[] =
    {
        { ATT_IS_DELETED, { 0, NULL } }
    };

    ENTINFSEL Sel =
    {
        EN_ATTSET_LIST,
        { sizeof( rgAttrs )/sizeof( rgAttrs[ 0 ] ), rgAttrs },
        EN_INFOTYPES_TYPES_VALS
    };

    BOOL        fIsDeleted = FALSE;
    ULONG       dirError;
    READRES *   pReadRes = NULL;

    dirError = KccRead( pdn, &Sel, &pReadRes, KCC_INCLUDE_DELETED_OBJECTS );

    if ( 0 != dirError )
    {
        if ( attributeError == dirError )
        {
            INTFORMPROB * pprob = &pReadRes->CommRes.pErrInfo->AtrErr.FirstProblem.intprob;

            if (    ( PR_PROBLEM_NO_ATTRIBUTE_OR_VAL == pprob->problem )
                 && ( DIRERR_NO_REQUESTED_ATTS_FOUND == pprob->extendedErr )
               )
            {
                // ATT_IS_DELETED is not present; the object is live.
                fIsDeleted = FALSE;
                dirError = 0;
            }
        }
        else if (    ( referralError == dirError )
                 || (    ( nameError == dirError )
                      && (    pReadRes->CommRes.pErrInfo->NamErr.extendedErr
                           == DIRERR_OBJ_NOT_FOUND )
                      && (    pReadRes->CommRes.pErrInfo->NamErr.problem
                           == NA_PROBLEM_NO_OBJECT ) ) )
        {
            //
            // This is the case where the object really does not exist
            //
#if DBG
            if (referralError == dirError) {
                //
                // We should only get referrals when there is a guid and
                // no string name.
                //
                GUID NullGuid;
                RtlZeroMemory(&NullGuid, sizeof(GUID));

                Assert(!memcmp(&pdn->Guid, &NullGuid, sizeof(GUID)) 
                     && pdn->NameLen == 0);
            }
#endif
            fIsDeleted = TRUE;
            dirError = 0;
    
        }
        else
        {

            //
            // We will want to understand these cases as they should not happen
            //
            KCC_LOG_READ_FAILURE( pdn, dirError );
            KCC_EXCEPT( DIRERR_MISSING_EXPECTED_ATT, dirError );
        }
    }
    else
    {
        // Read succeeded; parse returned attributes.
        for ( DWORD iAttr = 0; iAttr < pReadRes->entry.AttrBlock.attrCount; iAttr++ )
        {
            ATTR *  pattr = &pReadRes->entry.AttrBlock.pAttr[ iAttr ];

            switch ( pattr->attrTyp )
            {
            case ATT_IS_DELETED:
                Assert( 1 == pattr->AttrVal.valCount );
                Assert( sizeof( BOOL ) == pattr->AttrVal.pAVal->valLen );
                fIsDeleted = *( (BOOL *) pattr->AttrVal.pAVal->pVal );
                break;

            default:
                DPRINT1( 0, "Received unrequested attribute 0x%X.\n", pattr->attrTyp );
                break;
            }
        }
    }

    return fIsDeleted;
}

BOOL
KccObjectExists(
    IN  UUID *  puuid,
    OUT BOOL *  pfIsDeleted OPTIONAL
    )
/*++

Routine Description:

    Determine whether an object with the given GUID exists (deleted or not) in
    the local DS.

Arguments:

    puuid (IN) - UUID of object to look for.

    pfIsDeleted (OUT, OPTIONAL) - On return, is set to TRUE if the object was
        found but is deleted.  Set to FALSE otherwise.

    pulLastChangeTime (OUT, OPTIONAL) - On return, holds the time the object
        was last changed if it exists.  Set to 0 otherwise.

Return Values:

    TRUE - object exists locally (deleted or not).
    FALSE - otherwise.

--*/
{
    ATTR      rgAttrs[] =
    {
        { ATT_WHEN_CHANGED, { 0, NULL } },
        { ATT_IS_DELETED,   { 0, NULL } }
    };

    ENTINFSEL Sel =
    {
        EN_ATTSET_LIST,
        { sizeof( rgAttrs )/sizeof( rgAttrs[ 0 ] ), rgAttrs },
        EN_INFOTYPES_TYPES_VALS
    };

    BOOL        fExists = FALSE;
    BOOL        fIsDeleted = FALSE;
    ULONG       dirError;
    READRES *   pReadRes = NULL;
    DSNAME      dn;

    Assert( NULL != puuid );

    memset( &dn, 0, sizeof( dn ) );
    dn.Guid = *puuid;
    dn.structLen = DSNameSizeFromLen( 0 );

    dirError = KccRead( &dn, &Sel, &pReadRes, KCC_INCLUDE_DELETED_OBJECTS );

    if ( 0 != dirError )
    {
        if (    ( referralError == dirError )
             || (    ( nameError == dirError )
                  && (    pReadRes->CommRes.pErrInfo->NamErr.extendedErr
                       == DIRERR_OBJ_NOT_FOUND )
                  && (    pReadRes->CommRes.pErrInfo->NamErr.problem
                       == NA_PROBLEM_NO_OBJECT ) ) )
        {
            // Object does not exist locally.
            Assert( !fExists );
            Assert( !fIsDeleted );
        }
        else
        {
            // Other error; bail.
            KCC_LOG_READ_FAILURE( &dn, dirError );
            KCC_EXCEPT( DIRERR_MISSING_EXPECTED_ATT, dirError );
        }
    }
    else
    {
        // Read succeeded; parse returned attributes.
        fExists = TRUE;
        Assert( !fIsDeleted );

        for ( DWORD iAttr = 0; iAttr < pReadRes->entry.AttrBlock.attrCount; iAttr++ )
        {
            ATTR *  pattr = &pReadRes->entry.AttrBlock.pAttr[ iAttr ];

            switch ( pattr->attrTyp )
            {
            case ATT_WHEN_CHANGED:
                break;

            case ATT_IS_DELETED:
                Assert( 1 == pattr->AttrVal.valCount );
                Assert( sizeof( BOOL ) == pattr->AttrVal.pAVal->valLen );
                fIsDeleted = *( (BOOL *) pattr->AttrVal.pAVal->pVal );
                break;

            default:
                DPRINT1( 0, "Received unrequested attribute 0x%X.\n", pattr->attrTyp );
                break;
            }
        }
    }

    if ( NULL != pfIsDeleted )
    {
        *pfIsDeleted = fIsDeleted;
    }

    return fExists;
}


BOOL
KccLinkServerIsStale(
    IN DSNAME* pdnFromServer,
    IN ULONG   FailuresAllowed,
    IN ULONG   MaxFailureTime
    )
//
// Determine if the specified server is considered to be stale to be
// part of the ring topology
//
{

    BOOL  fStale = FALSE;
    DWORD NumberOfFailures;
    DWORD TimeSinceLastSuccess;
    DWORD LastResult;
    BOOL  fUserNotifiedOfStaleness;

    if ( gpDSCache->GetLocalSite()->IsDetectStaleServersDisabled() )
    {
        // Nothing is stale when this option is turned off
        return FALSE;
    }

    if ( pdnFromServer )
    {

        if ( gLinkFailureCache.Get( pdnFromServer,
                                    &TimeSinceLastSuccess,
                                    &NumberOfFailures,
                                    &fUserNotifiedOfStaleness,
                                    &LastResult) )
        {

            //
            // The object is in the cache; has it been too long?
            //
            if (NumberOfFailures >  FailuresAllowed
             && TimeSinceLastSuccess > MaxFailureTime )
            {
                // Too bad
                fStale = TRUE;

                DPRINT4( 4, "KCC: (link server) Server %ws is stale, allowed=%d, time=%d, result=%d.\n",
                        pdnFromServer->StringName,
                        FailuresAllowed, MaxFailureTime, LastResult );

                if (!fUserNotifiedOfStaleness)
                {
                    gLinkFailureCache.NotifyUserOfStaleness( pdnFromServer );
                }
            }
            else
            {

                if ( fUserNotifiedOfStaleness )
                {
                    //
                    // At one point, this server was stale and the user was notified.
                    // Reset the flag so if the server becomes stale again, the
                    // user will be notified
                    //

                    gLinkFailureCache.ResetUserNotificationFlag( pdnFromServer );
                    
                }
            }
        }
    }

    return fStale;
}

BOOL
KccConnectionServerIsStale(
    IN  DSNAME * pdnFromServer,
    IN ULONG     FailuresAllowed,
    IN ULONG     MaxFailureTime
    )
//
// Determine if the specified server has failed DirReplicaAdd too many times 
// in a row to be considered for the ring topology
//
{

    BOOL  fStale = FALSE;

    DWORD NumberOfFailures;
    DWORD TimeSinceFirstAttempt;
    BOOL  fUserNotifiedOfStaleness;

    if ( gpDSCache->GetLocalSite()->IsDetectStaleServersDisabled() )
    {
        // Nothing is stale when this option is turned off
        return FALSE;
    }

    if ( pdnFromServer )
    {

        if ( gConnectionFailureCache.Get( pdnFromServer,
                                          &TimeSinceFirstAttempt,
                                          &NumberOfFailures,
                                          &fUserNotifiedOfStaleness,
                                          NULL /* dwLastResult */,
                                          NULL /* fErrorOccurredThisRun */ ) )
        {

            //
            // The object is in the cache; has it been to long?
            //
            if (NumberOfFailures >  FailuresAllowed
             && TimeSinceFirstAttempt > MaxFailureTime )
            {
                // Too bad
                fStale = TRUE;
                DPRINT3( 4, "KCC: (connection) Server %ws is stale, allowed=%d, time=%d.\n",
                        pdnFromServer->StringName,
                        FailuresAllowed, MaxFailureTime );

                if ( !fUserNotifiedOfStaleness )
                {
                    gConnectionFailureCache.NotifyUserOfStaleness( pdnFromServer );
                }
            }
            else
            {
                if ( fUserNotifiedOfStaleness )
                {
                    //
                    // At one point, this server was stale and the user was notified.
                    // Reset the flag so if the server becomes stale again, the
                    // user will be notified
                    //

                    gConnectionFailureCache.ResetUserNotificationFlag( pdnFromServer );
                    
                }
            }
        }
    }

    return fStale;
}

BOOL
KccCriticalLinkServerIsStale(
    IN  DSNAME *    pdnFromServer
    )
//
// Determine if the specified server is considered to be stale to be
// part of the ring topology
//
{
    return KccLinkServerIsStale( pdnFromServer, 
                                 gcCriticalLinkFailuresAllowed,
                                 gcSecsUntilCriticalLinkFailure );
}

BOOL
KccCriticalConnectionServerIsStale(
    IN  DSNAME *    pdnFromServer
    )
//
// Determine if the specified server is considered to be stale to be
// part of the ring topology
//
{
    return KccConnectionServerIsStale( pdnFromServer, 
                                       gcCriticalLinkFailuresAllowed,
                                       gcSecsUntilCriticalLinkFailure );
}


BOOL
KccNonCriticalLinkServerIsStale(
    IN  DSNAME *    pdnFromServer
    )
//
// Determine if the specified server is considered to stale 
// for optimization connections
//
{
    return KccLinkServerIsStale( pdnFromServer, 
                                 gcNonCriticalLinkFailuresAllowed,
                                 gcSecsUntilNonCriticalLinkFailure );
}

BOOL
KccNonCriticalConnectionServerIsStale(
    IN  DSNAME *    pdnFromServer
    )
//
// Determine if the specified server has failed DirReplicaAdd too many times
// in a row to be considered as an optimization connection
//
{

    return KccConnectionServerIsStale( pdnFromServer, 
                                       gcNonCriticalLinkFailuresAllowed,
                                       gcSecsUntilNonCriticalLinkFailure );
}


BOOL
KccIsBridgeheadStale(
    IN  DSNAME *    pdnFromServer
    )
//
// Determine if the specified server is considered to be stale to be
// part of the intersite topology
//
{
    return (KccLinkServerIsStale(pdnFromServer, 
                                 gcIntersiteLinkFailuresAllowed,
                                 gcSecsUntilIntersiteLinkFailure)
            || KccConnectionServerIsStale(pdnFromServer, 
                                          gcIntersiteLinkFailuresAllowed,
                                          gcSecsUntilIntersiteLinkFailure));
}


ULONG
KccGetNumberOfOptimizingEdges(
    IN ULONG  cServers
    )
//
// See toplmgnt.doc for more info.  The general idea here is that we want each
// server to be not more than 3 server hops from any other server. Assuming
// the ring connection between all servers in a given nc and site, let n 
// be the number of extra connections per server. Then let f(n) be the
// number of servers reachable from a given server within 3 hops.
//
// f(n) = 2*n^2 + 6*n + 6
//
// So the idea here is if the number of servers EXCLUDING the local server
// (hence the +1, below) is less than or equal to f(n) then given an idea
// placement of edges, each server can reach each other in 3 hops.  We have the
// number of servers and f(n), so we return n.
//
{
    #define f(x)  ( 2*(x)*(x) + 6*(x) + 6 )

    ULONG n;

    for ( n = 0; ; n++ )
    {
        if ( cServers <= f(n) + 1 )
        {
            return n;            
        }
    }

}


REPLTIMES*
KccConvertToplScheduleToReplTimes(
    IN TOPL_SCHEDULE toplSchedule
    )
/*++

Routine Description:

    Given a TOPL_SCHEDULE, allocate an equivalent ReplTimes structure and return it
    to the user. If the TOPL_SCHEDULE is NULL, an 'always available' ReplTimes
    structure will be returned.

Arguments:

    toplSchedule - the topl schedule to convert

Return Value:

    REPLTIMES - Allocated with new[]. Should be freed by caller using delete[].
    Never returns NULL.

--*/
{
    PSCHEDULE psched;
    REPLTIMES* replTimes;

    psched = ToplScheduleExportReadonly( gpDSCache->GetScheduleCache(), toplSchedule );
    replTimes = (REPLTIMES*) new BYTE[ sizeof(REPLTIMES) ];

    if (psched && ((sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES) <= psched->Size))
    {
        // We don't expect BANDWIDTH or PRIORITY schedule to be present in the DS Replication Schedule
        // But if they do we will ignore them and use only the INTERVAL schedule part
        if ((1 <= psched->NumberOfSchedules) && (3 >= psched->NumberOfSchedules))
            
        {
            // locate the interval schedule in the struct and ignore bandwidth & priority
            int nInterval = -1;
            for (int j = 0; j < (int) psched->NumberOfSchedules; j++)
            {
                if (SCHEDULE_INTERVAL == psched->Schedules[j].Type)
                {
                    // located the INTERVAL schedule - if there are more than one INTERVAL schedules
                    // in the blob, we will use only the first one.
                    nInterval = j;
                    break;
                }
            }

            if (nInterval >= 0)
            {
                // sanity check to see if all the interval schedule data is present
                if ((psched->Schedules[nInterval].Offset + SCHEDULE_DATA_ENTRIES) <= psched->Size)
                {
                    // Everything in the blob is as expected and we found a valid INTERVAL schedule
                    // - convert the 168 byte schedule data to the internal 84 byte format
                    PBYTE pbSchedule = ((PBYTE) psched) + psched->Schedules[nInterval].Offset;
                    for (int i = 0, j = 0; j < SCHEDULE_DATA_ENTRIES; ++i, j += 2)
                    {
                        replTimes->rgTimes[i] = (((pbSchedule[j] & 0x0F) << 4) | (pbSchedule[j+1] & 0x0F));
                    }

                    return replTimes;
                }
            }
        }
    }

    // given schedule is invalid or incorrectly formated - use default (always)
    memset(replTimes, 0xff, sizeof(REPLTIMES));
    return replTimes;
}
            

int __cdecl
KccCompareMetaData(
    IN  const void *  pvMetaData1,
    IN  const void *  pvMetaData2
    )
//
// Compare meta data (for use by bsearch()).
//
{
    PROPERTY_META_DATA * pMetaData1 = (PROPERTY_META_DATA *) pvMetaData1;
    PROPERTY_META_DATA * pMetaData2 = (PROPERTY_META_DATA *) pvMetaData2;

    if( pMetaData1->attrType < pMetaData2->attrType ) {
        return -1;
    } else if( pMetaData1->attrType > pMetaData2->attrType ) {
        return 1;
    } else {
        return 0;
    }
}


BOOL
KccFillGuidAndSid(
    IN OUT  DSNAME *    pdn
    )
//
// Find the object in the DS and add its GUID and SID to its in-memory DSNAME.
//
{
    ATTR rgAttrs[] = {
        { ATT_OBJ_DIST_NAME, { 0, NULL } }
    };

    ENTINFSEL Sel = {
        EN_ATTSET_LIST,
        { ARRAY_SIZE(rgAttrs), rgAttrs },
        EN_INFOTYPES_TYPES_VALS
    };

    ULONG       dirError;
    READRES *   pReadRes = NULL;
    DSNAME *    pdnFromDB;
    BOOL        fSuccess = FALSE;

    dirError = KccRead(pdn, &Sel, &pReadRes, KCC_INCLUDE_DELETED_OBJECTS);

    if (0 != dirError) {
        if ((referralError == dirError)
            || ((nameError == dirError)
                && (pReadRes->CommRes.pErrInfo->NamErr.extendedErr
                    == DIRERR_OBJ_NOT_FOUND)
                && (pReadRes->CommRes.pErrInfo->NamErr.problem
                    == NA_PROBLEM_NO_OBJECT))) {
            // Object does not exist locally.
            Assert(!fSuccess);
        }
        else {
            // Other error; bail.
            KCC_LOG_READ_FAILURE( pdn, dirError );
            KCC_EXCEPT( DIRERR_MISSING_EXPECTED_ATT, dirError );
        }
    }
    else {
        // Read succeeded; parse returned attributes.
        for (DWORD iAttr = 0; iAttr < pReadRes->entry.AttrBlock.attrCount; iAttr++) {
            ATTR *  pattr = &pReadRes->entry.AttrBlock.pAttr[ iAttr ];

            switch (pattr->attrTyp) {
            case ATT_OBJ_DIST_NAME:
                Assert(1 == pattr->AttrVal.valCount);
                pdnFromDB = (DSNAME *) pattr->AttrVal.pAVal->pVal;
                pdn->Guid   = pdnFromDB->Guid;
                pdn->Sid    = pdnFromDB->Sid;
                pdn->SidLen = pdnFromDB->SidLen;
                fSuccess = TRUE;
                break;

            default:
                DPRINT1(0, "Received unrequested attribute 0x%X.\n", pattr->attrTyp);
                break;
            }
        }

        Assert(fSuccess);
    }

    return fSuccess;
}


DSNAME *
KccGetDSNameFromGuid(
    IN  GUID *  pObjGuid
    )
/*++

Routine Description:

    Look up the DSNAME of the object in the database with the given objectGuid.

Arguments:

    pObjGuid (IN) - objectGuid of object to look for.

Return Values:

    The DSNAME of the object if it could be found, or NULL otherwise.

--*/
{
    ATTR rgAttrs[] = {
        { ATT_OBJ_DIST_NAME, { 0, NULL } }
    };

    ENTINFSEL Sel = {
        EN_ATTSET_LIST,
        { ARRAY_SIZE(rgAttrs), rgAttrs },
        EN_INFOTYPES_TYPES_VALS
    };

    ULONG       dirError;
    READRES *   pReadRes = NULL;
    BOOL        fSuccess = FALSE;
    DSNAME      dnGuidOnly = {0};
    DSNAME *    pdnFull = NULL;

    dnGuidOnly.structLen = DSNameSizeFromLen(0);
    dnGuidOnly.Guid = *pObjGuid;

    dirError = KccRead(&dnGuidOnly, &Sel, &pReadRes, KCC_INCLUDE_DELETED_OBJECTS);

    if (0 != dirError) {
        if ((referralError == dirError)
            || ((nameError == dirError)
                && (pReadRes->CommRes.pErrInfo->NamErr.extendedErr
                    == DIRERR_OBJ_NOT_FOUND)
                && (pReadRes->CommRes.pErrInfo->NamErr.problem
                    == NA_PROBLEM_NO_OBJECT))) {
            // Object does not exist locally.
            Assert(NULL == pdnFull);
        }
        else {
            // Other error; bail.
            KCC_LOG_READ_FAILURE( &dnGuidOnly, dirError );
            KCC_EXCEPT( DIRERR_MISSING_EXPECTED_ATT, dirError );
        }
    }
    else {
        // Read succeeded; parse returned attributes.
        for (DWORD iAttr = 0; iAttr < pReadRes->entry.AttrBlock.attrCount; iAttr++) {
            ATTR *  pattr = &pReadRes->entry.AttrBlock.pAttr[ iAttr ];

            switch (pattr->attrTyp) {
            case ATT_OBJ_DIST_NAME:
                Assert(1 == pattr->AttrVal.valCount);
                pdnFull = (DSNAME *) pattr->AttrVal.pAVal->pVal;
                break;

            default:
                DPRINT1(0, "Received unrequested attribute 0x%X.\n", pattr->attrTyp);
                break;
            }
        }

        Assert(NULL != pdnFull);
    }

    return pdnFull;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\kcctask.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kcctask.cxx

ABSTRACT:

    KCC_TASK class.

DETAILS:

    The KCC_TASK class is the base class of all KCC tasks (both periodic and
    notificatication-based).

    It's purpose is to provide a common interface and some common routines
    for all tasks.

CREATED:

    01/21/97    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <ntdspchx.h>

#include <string.h>

extern "C" {
#include <ntsam.h>
#include <lsarpc.h>
#include <lsaisrv.h>
}

#include <dsconfig.h>
#include "kcc.hxx"
#include "kcctask.hxx"
#include "kccduapi.hxx"
#include "kcctools.hxx"
#include <dstrace.h>

#define FILENO FILENO_KCC_KCCTASK

#define KCC_SCHEDULE_NAME   "KCC_Task_Schedule"
#define KCC_TRIGGER_NAME    "KCC_Task_Trigger"

typedef struct {
    KCC_TASK *  pTask;
    HANDLE      hevDone;
    DWORD *     pdwResult;
} KCC_TASK_TRIGGER_INFO;

// Five minutes
ULONG ulDefaultTaskRestartPeriod = (5*60);


DWORD
KCC_TASK::Execute(
    OUT DWORD * pcSecsUntilNextIteration
    )
//
// Wrapper for ExecuteBody().  Handles allocating and destroying thread
// states, binding, catching exceptions, and logging task start and
// finish.
//
{
    DWORD         ret = 0;
    DWORD         dwExceptionCode;
    void *        pvEA;
    DWORD         dsid;

    //
    // In case the inherited task mistakenly does not set the time of the next
    // occurance, or does not even get a chance to, make sure
    // pcSecsUntilNextIteration is  set to a value so the task will run again.
    //
    Assert(pcSecsUntilNextIteration);
    *pcSecsUntilNextIteration = ulDefaultTaskRestartPeriod;

    if (KCC_STARTED != geKccState) {
        return ERROR_DS_SHUTTING_DOWN;
    }

    DWORD dirError = THCreate(CALLERTYPE_KCC);

    if (0 != dirError) {
        return ERROR_OUTOFMEMORY;
    }

    // Set w32topl allocator routines.
    ToplSetAllocator(&THAlloc, &THReAlloc, &THFree);

    __try {
        LogAndTraceEvent(TRUE,
                         DS_EVENT_CAT_KCC,
                         DS_EVENT_SEV_INTERNAL,
                         DIRLOG_KCC_TASK_ENTRY,
                         EVENT_TRACE_TYPE_START,
                         DsGuidKccTask,
                         NULL, NULL, NULL, NULL,
                         NULL, NULL, NULL, NULL);
        
        //
        // Execute the task, bracketed by appropriate logged events (if the
        // KCC logging level is turned up high enough).
        //
        __try {
            LogBegin();
            ret = ExecuteBody(pcSecsUntilNextIteration);
            LogEndNormal();
        } __except(GetExceptionData(GetExceptionInformation(), &dwExceptionCode,
                                    &pvEA, &ret, &dsid)) {
            if (0 == ret) {
                ret = ERROR_DS_GENERIC_ERROR;
            }

            LogEndAbnormal(ret, dsid);
        }
    }
    __finally {
        // Reset w32topl allocator routines.
        ToplSetAllocator(NULL, NULL, NULL);
        
        LogAndTraceEvent(TRUE,
                         DS_EVENT_CAT_KCC,
                         DS_EVENT_SEV_INTERNAL,
                         DIRLOG_KCC_TASK_EXIT,
                         EVENT_TRACE_TYPE_END,
                         DsGuidKccTask,
                         NULL, NULL, NULL, NULL,
                         NULL, NULL, NULL, NULL);

        THDestroy();
    }

    return ret;
}

BOOL
KCC_TASK::Schedule(
    IN  DWORD   cSecsUntilFirstIteration
    )
//
// Schedule the first execution of the task.  Normally called as part
// of Init().
//
{
    return ::DoInsertInTaskQueue( &TaskQueueCallback, this, cSecsUntilFirstIteration,
        FALSE, KCC_SCHEDULE_NAME );
}

void
KCC_TASK::TaskQueueCallback(
    IN  void *  pvThis,
    OUT void ** ppvThisNext,
    OUT DWORD * pcSecsUntilNext
    )
//
// Callback for TaskQueue.  Wraps Execute().
//
{
    *ppvThisNext = pvThis;

    ( ( KCC_TASK * ) pvThis )->Execute( pcSecsUntilNext );
}

KCC_TASK*
KCC_TASK::ExtractTaskFromParam(
    IN  PCHAR   pParamName,
    IN  void*   pParam
    )
//
// The KCC currently puts two different types of entries in the task queue:
// periodically scheduled entries (from KCC_TASK::Schedule) and triggered
// entries (from KCC_TASK::Trigger). These two different types of entries
// store different parameters in the task queue. Scheduled tasks store only
// the task pointer. Triggered tasks store a trigger info block in order to
// do synchronous calls. This function is able to deal with both types of
// entries and extract the KCC_TASK pointer.
//
{
    KCC_TASK* pTask=NULL;
    
    if( !strcmp(pParamName,KCC_SCHEDULE_NAME) ) {
        pTask = (KCC_TASK*) pParam;
    }

    if( !strcmp(pParamName,KCC_TRIGGER_NAME) ) {
        KCC_TASK_TRIGGER_INFO * pTriggerInfo = (KCC_TASK_TRIGGER_INFO*) pParam;
        pTask = pTriggerInfo->pTask;
    }

    Assert( NULL!=pTask );
    return pTask;
}

BOOL
KCC_TASK::IsMatchedKCCTaskParams(
    IN  PCHAR   pParam1Name,
    IN  void*   param1,
    IN  PCHAR   pParam2Name,
    IN  void*   param2,
    IN  void*   pContext
    )
//
// Compare the parameters of two tasks in the KCC task queue
// and determine if they match.
//
// Currently, the KCC only has one task (update repl topology)
// so we verify that both task queue entries refer to the same task.
//
{
    KCC_TASK *pTask1, *pTask2;

    pTask1 = ExtractTaskFromParam( pParam1Name, param1 );
    pTask2 = ExtractTaskFromParam( pParam2Name, param2 );

    Assert( pTask1 == pTask2 );
    
    return TRUE;
}

DWORD
KCC_TASK::Trigger(
    IN  DWORD   dwFlags,
    IN  DWORD   dwDampedSecs
    )
//
// Execute this task (but serialize it with other tasks running in the task
// queue, esp. other runs of this same task).
//
// Caller may optionally wait for the task to complete (i.e., if the flag
// DS_KCC_FLAG_ASYNC_OP is specified in dwFlags.
//
// If the DS_KCC_FLAG_DAMPED flag is specified, the task will not be
// triggered if an equivalent task is scheduled to run within dwDampedSecs.
// If the flag is not specified, the dwDampedSecs parameter is ignored.
//
{
    HANDLE                  hevDone = NULL;
    HANDLE                  rgWaitHandles[2];
    DWORD                   waitStatus;
    KCC_TASK_TRIGGER_INFO * pTriggerInfo = NULL;
    DWORD                   ret = 0;
    BOOL                    fSuccess;

    pTriggerInfo = (KCC_TASK_TRIGGER_INFO *) malloc(sizeof(*pTriggerInfo));
    if (NULL == pTriggerInfo) {
        return ERROR_OUTOFMEMORY;
    }

    // Initialize the trigger info
    pTriggerInfo->pTask     = this;
    pTriggerInfo->hevDone   = NULL;
    pTriggerInfo->pdwResult = NULL;

    if (!(DS_KCC_FLAG_ASYNC_OP & dwFlags)) {
        // Waiting for completion; create synchronization event.
        hevDone = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (NULL == hevDone) {
            free(pTriggerInfo);
            return GetLastError();
        }

        // Set up additional trigger info for synchronous operations
        pTriggerInfo->hevDone   = hevDone;
        pTriggerInfo->pdwResult = &ret;
    }

    // If the damped flag was not specified, specify that
    // the Task Queue should not do dampening.
    if( !(dwFlags & DS_KCC_FLAG_DAMPED) ) {
        dwDampedSecs = TASKQ_NOT_DAMPED;
    }

    // Insert the new task into the task queue (optionally with dampening)
    fSuccess = DoInsertInTaskQueueDamped(
        &TriggerCallback,
        pTriggerInfo,
        0,
        FALSE,
        KCC_TRIGGER_NAME,
        dwDampedSecs,
        IsMatchedKCCTaskParams,
        NULL);
    
    if (!fSuccess) {
        // The task was not enqueued.

        // Free the resources we have allocated
        free(pTriggerInfo);
        CloseHandle(hevDone);

        // If dampening was enabled, this is a normal condition
        if( dwFlags & DS_KCC_FLAG_DAMPED ) {
            return ERROR_SUCCESS;
        } else {
            // TaskQueue insertion should not fail. It must be
            // a memory error.
            return ERROR_OUTOFMEMORY;
        }
    }

    if (NULL != hevDone) {
        // Wait for completion.
        rgWaitHandles[0] = ghKccShutdownEvent;
        rgWaitHandles[1] = hevDone;

        waitStatus = WaitForMultipleObjects(ARRAY_SIZE(rgWaitHandles),
                                            rgWaitHandles,
                                            FALSE,
                                            INFINITE);
        switch (waitStatus) {
        case WAIT_OBJECT_0:
            // Shutdown.
            ret = ERROR_DS_SHUTTING_DOWN;
            break;
        case WAIT_OBJECT_0 + 1:
            // Task completed!  Return value (ret) set by callback function.
            break;
        case WAIT_FAILED:
            ret = GetLastError();
            break;
        default:
            ret = ERROR_DS_INTERNAL_FAILURE;
            break;
        }

        CloseHandle(hevDone);
    }

    return ret;
}

void
KCC_TASK::TriggerCallback(
    IN  void *  pvTriggerInfo,
    OUT void ** ppvNextParam,
    OUT DWORD * pcSecsUntilNext
    )
//
// TaskQueue callback for triggered execution.  Wraps Execute().
//
{
    KCC_TASK_TRIGGER_INFO * pTriggerInfo;
    DWORD                   dwResult;

    pTriggerInfo = (KCC_TASK_TRIGGER_INFO *) pvTriggerInfo;

    // Execute our task.
    dwResult = pTriggerInfo->pTask->Execute(pcSecsUntilNext);

    // This is a one-shot execution; don't reschedule.
    *pcSecsUntilNext = TASKQ_DONT_RESCHEDULE;

    if (NULL != pTriggerInfo->hevDone) {
        // Tell waiting thread that we're done.
        *pTriggerInfo->pdwResult = dwResult;
        SetEvent(pTriggerInfo->hevDone);
    } else {
        // There is no event to signal so this must be an asynchronous operation.
        // Assert that there is no way of returning a result code.
        Assert( NULL==pTriggerInfo->pdwResult );
    }

    free(pTriggerInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\kccstetl.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kccstetl.cxx

ABSTRACT:

    Routines to perform the automated NC topology across sites

DETAILS:

CREATED:

    12/05/97    Colin Brace (ColinBr)

REVISION HISTORY:

--*/

#include <NTDSpchx.h>
#include "w32topl.h"
#include "kcc.hxx"
#include "kcctask.hxx"
#include "kccconn.hxx"
#include "kcctopl.hxx"
#include "kcccref.hxx"
#include "kccdsa.hxx"
#include "kcctools.hxx"
#include "kcctrans.hxx"
#include "kccsconn.hxx"
#include "kccdynar.hxx"
#include "kccsite.hxx"
#include "kccduapi.hxx"
#include "ismapi.h"
#include "kccsitelink.hxx"
#include "kccwalg.hxx"
#include "kccstale.hxx"

#include "kccstetl.hxx"

#define FILENO FILENO_KCC_KCCSTETL

#define DWORD_INFINITY ((DWORD)~0)

/*++

Inline Logging Functions

Below are a list of macros which log information using the debugging facilities
and the event log functions. The use of these functions helps to keep the
actual code more readable.

--*/

#define LOG_WE_ARE_ISTG \
    DPRINT( 3, "Local dsa is the site connection generator.\n" ); \
    LogEvent( \
        DS_EVENT_CAT_KCC, \
        DS_EVENT_SEV_EXTENSIVE, \
        DIRLOG_KCC_SITE_GENERATOR, \
        szInsertDN(pLocalSite->GetObjectDN()), \
        0, 0);

#define LOG_RANDOM_BH_ENABLED \
    LogEvent( \
        DS_EVENT_CAT_KCC, \
        DS_EVENT_SEV_INTERNAL, \
        DIRLOG_KCC_RANDOM_BH_ENABLED, \
        szInsertDN(pSite->GetObjectDN()), \
        0, 0);

#define LOG_SCHEDULE_STAGGERING_ENABLED \
    LogEvent( \
        DS_EVENT_CAT_KCC, \
        DS_EVENT_SEV_EXTENSIVE, \
        DIRLOG_KCC_SCHEDULE_STAGGERING_ENABLED, \
        szInsertDN(pSite->GetObjectDN()), \
        0, 0);

#define LOG_REDUNDANT_SERVER_ENABLED \
    LogEvent( \
        DS_EVENT_CAT_KCC, \
        DS_EVENT_SEV_INTERNAL, \
        DIRLOG_KCC_REDUNDANT_SERVER_ENABLED, \
        szInsertDN(pSite->GetObjectDN()), \
        0, 0);

#define LOG_NOT_VIABLE_TRANSPORT \
    DPRINT2(3, "Cannot replicate writeable domain NC %ls over non-IP transport %ls.\n", \
            pCrossRef->GetNCDN()->StringName, \
            Transport->GetDN()->StringName);

#define LOG_GET_CONNECTIVITY_FAILED \
    DPRINT1( 0, "I_ISMGetConnectivity failed with %d\n", WinError ); \
    LogEvent8(DS_EVENT_CAT_KCC, \
              DS_EVENT_SEV_ALWAYS, \
              DIRLOG_ISM_TRANSPORT_FAILURE, \
              szInsertDN(Transport->GetDN()), \
              szInsertWin32Msg(WinError), \
              szInsertWin32ErrCode(WinError), \
              NULL, NULL, NULL, NULL, NULL );

#define LOG_CONNECTION_FOUND \
    DPRINT4( 4, "There exists a connection between sites %ls and %ls using transport %ls at cost %d\n", \
            SiteSource->GetObjectDN()->StringName, SiteDest->GetObjectDN()->StringName, \
            Transport->GetDN()->StringName, Cost );

#define LOG_CONNECTION_NOT_FOUND \
    DPRINT3( 4, "No connection exists between %ls and %ls using transport %ls.\n", \
            SiteSource->GetObjectDN()->StringName, \
            SiteDest->GetObjectDN()->StringName, \
            Transport->GetDN()->StringName ); \

#define LOG_NEW_CONNECTION_CHEAPER \
    DPRINT4( 4, "Transport %ls between sites %ls and %ls is cheaper than transport %ls\n", \
             Transport->GetDN()->StringName, \
             SiteSource->GetObjectDN()->StringName, \
             SiteDest->GetObjectDN()->StringName, \
             OtherConnection->GetTransport()->GetDN()->StringName);

#define LOG_NEW_CONNECTION_NOT_CHEAPER \
    DPRINT4( 4, "Transport %ls between sites %ls and %ls is same or greater cost than transport %ls\n", \
             Transport->GetDN()->StringName,  \
             SiteSource->GetObjectDN()->StringName,  \
             SiteDest->GetObjectDN()->StringName, \
             OtherConnection->GetTransport()->GetDN()->StringName);

#define LOG_SOURCE_BH_FOUND \
    DPRINT2(4, "Server %ls selected as bridgehead for site %ls.\n", \
            DsaSource->GetDsName()->StringName, \
            SiteSource->GetObjectDN()->StringName);

#define LOG_SOURCE_BH_NOT_FOUND \
    DPRINT2( 3, "No bridgehead found for site %ls transport %ls.\n", \
            SiteDest->GetObjectDN()->StringName,  Transport->GetDN()->StringName );

#define LOG_DEST_BH_FOUND \
    DPRINT2(4, "Server %ls selected as bridgehead for site %ls.\n", \
            DsaDest->GetDsName()->StringName, \
            SiteDest->GetObjectDN()->StringName);

#define LOG_DEST_BH_NOT_FOUND \
    DPRINT2( 3, "No bridgehead found for site %ls transport %ls.\n", \
        SiteSource->GetObjectDN()->StringName,  Transport->GetDN()->StringName );

#define LOG_NC_AND_SITES \
    DPRINT3( 3, "Naming Context %ls is in %d writable sites, %d partial sites\n", \
             pCrossRef->GetNCDN()->StringName, \
             pSiteArrayWriteable->GetCount(), \
             pSiteArrayPartial->GetCount() ); \
    LogEvent( \
        DS_EVENT_CAT_KCC, \
        DS_EVENT_SEV_EXTENSIVE, \
        DIRLOG_KCC_NC_SITE_TOPOLOGY, \
        szInsertDN(pCrossRef->GetNCDN()), \
        szInsertUL(pSiteArrayWriteable->GetCount()), \
        szInsertUL(pSiteArrayPartial->GetCount()) );

#define LOG_CONNECTION_NEEDED \
    LogEvent8( \
        DS_EVENT_CAT_KCC, \
        DS_EVENT_SEV_EXTENSIVE, \
        DIRLOG_KCC_CONNECTION_EDGE_NEEDED, \
        szInsertDN(SiteConnection->GetSourceSite()->GetObjectDN()), \
        szInsertDN(SiteConnection->GetDestinationDSA()->GetDsName()), \
        szInsertDN(SiteConnection->GetSourceDSA()->GetDsName()), \
        szInsertDN(SiteConnection->GetTransport()->GetDN()), \
        0, 0, 0, 0 );

#define LOG_W32TOPL_EXCEPTION \
    DPRINT1( 0, "W32TOPL routines threw a %d exception during inter-site topology creation.\n", \
             ErrorCode ); \
    LogEvent8( DS_EVENT_CAT_KCC, \
              DS_EVENT_SEV_ALWAYS, \
              DIRLOG_KCC_AUTO_TOPL_GENERATION_INCOMPLETE, \
              szInsertDN(pCrossRef->GetNCDN()), \
              szInsertWin32ErrCode(ErrorCode), \
              szInsertHex( DSID(FILENO, __LINE__) ), \
              szInsertWin32Msg(ErrorCode), \
              NULL, NULL, NULL, NULL );


#define LOG_CONN_REDUNDANT  \
    DPRINT2( 3, "Conn %ws supercedes conn %ws, but is being kept because of the redundant topology.\n", \
             pcn2->GetConnectionDN()->StringName,\
             pcn->GetConnectionDN()->StringName\
        );\
    LogEvent(DS_EVENT_CAT_KCC,\
         DS_EVENT_SEV_INTERNAL,\
         DIRLOG_KCC_CONN_REDUNDANT,\
         szInsertDN(pcn2->GetConnectionDN()),\
         szInsertDN(pcn->GetConnectionDN()),\
         0);

//
// Prototypes of local functions
//
BOOL
KccAmISiteGenerator(
    VOID
    );

VOID
KccCreateInterSiteConnectionsForNc(
    IN  KCC_CROSSREF *          pCrossRef,
    IN  KCC_SITE *              pLocalSite,
    IN  BOOL                    fGCTopology,
    IN  KCC_SITE_ARRAY &        SiteArray,
    IN  KCC_TRANSPORT_LIST &    TransportList
    );

VOID
KccGetSiteConnections(
    IN  KCC_CROSSREF *          pCrossRef,
    IN  KCC_TRANSPORT_LIST *    pTransportList,
    IN  KCC_SITE_ARRAY &        SiteArray,
    IN  DSNAME *                pDNLocalSite,
    IN  BOOL                    fGCTopology
    );

VOID
KccCreateConnectionToSite(
    IN  KCC_CROSSREF *          pCrossRef,
    IN  KCC_SITE *              pLocalSite,
    IN  KCC_SITE_CONNECTION *   pSiteConnection,   
    IN  BOOL                    fGCTopology,    
    IN  KCC_TRANSPORT_LIST &    TransportList
    );

VOID
KccRemoveUnneededInterSiteConnections();


//
// Function definitions
//
VOID
KccConstructSiteTopologiesForEnterprise()
/*++

Routine Description:

    This routine will construct a minimum cost spanning tree across sites for
    naming context in the enterprise
    
Parameters:

    None.    

Returns:

    None; all errors interesting to the admin are logged.
    
--*/
{
    KCC_SITE_LIST *     pSiteList = gpDSCache->GetSiteList();
    KCC_SITE           *pSite, *pLocalSite = gpDSCache->GetLocalSite();
    KCC_CROSSREF_LIST * pCrossRefList = gpDSCache->GetCrossRefList();
    KCC_TRANSPORT_LIST *pTransportList = gpDSCache->GetTransportList();
    KCC_DSA *           pLocalDSA = gpDSCache->GetLocalDSA();
    KCC_DSA_LIST *      pLocalSiteDSAList = pLocalSite->GetDsaList();
    
    ULONG               icr, ccr, isite, idsa;

    //
    //  Now perform site wide operation of creating inter site connection
    //  objects
    //
    if ( !KccAmISiteGenerator() ) {
        DPRINT( 3, "Local dsa is not the site connection generator.\n" );
        return;
    }
    LOG_WE_ARE_ISTG;

    // Check that the intra-site schedule used in the current site is
    // in accordance with the ISTG failover period.
    gpDSCache->GetLocalSite()->CheckIntrasiteSchedule();
    
    if (pSiteList->GetCount() < 2) {
        // A single-site enterprise.  No need to run intersite topology
        // generation.
        Assert(1 == pSiteList->GetCount());
        return;
    }

    //
    // Report any sites in which schedule-staggering or random bridgehead
    // selection has been enabled.
    //
    for( isite=0; isite<pSiteList->GetCount(); isite++ ) {
        pSite = pSiteList->GetSite(isite);
        if( pSite->IsRandomBHSelectionEnabled() ) {
            LOG_RANDOM_BH_ENABLED;
        }
        // Note, still dependent on post W2K in the forest
        if( pSite->IsScheduleStaggeringEnabled() ) {
            LOG_SCHEDULE_STAGGERING_ENABLED;
        }
        if( pSite->BuildRedundantServerTopology() ) {
            LOG_REDUNDANT_SERVER_ENABLED;
        }
    }
    
    //
    // Sort the list of cross-ref objects and look for orphaned NCs.
    //
    pCrossRefList->Sort();
    ccr = pCrossRefList->GetCount();
    for( icr=0; icr<ccr; icr++ ) {
        pCrossRefList->GetCrossRef(icr)->CheckForOrphans();
    }

    //
    // Get all intersite connections in the site (hopefully small)
    //
    pLocalSite->PopulateInterSiteConnectionLists();

    //
    // Update staleness info from the bridgeheads in our site.
    // Use mark-sweep garbage collection to flush out any
    // unneeded imported entries.
    //
    gConnectionFailureCache.MarkUnneeded( TRUE );
    for (idsa = 0; idsa < pLocalSiteDSAList->GetCount(); idsa++) {
        pLocalSiteDSAList->GetDsa(idsa)->GetInterSiteCnList()
            ->UpdateStaleServerCache();
    }
    gConnectionFailureCache.FlushUnneeded( TRUE );
    

    if( gpDSCache->GetForestVersion() >= DS_BEHAVIOR_WIN_DOT_NET_WITH_MIXED_DOMAINS ) {
        
        KccGenerateTopologiesWhistler();

    } else {

        //
        // For each NC that is shared between two or more sites, create inter site 
        // connections between sites with that NC
        //
        for ( icr = 0; icr < ccr; icr++ )
        {
            KCC_CROSSREF *    pCrossRef = pCrossRefList->GetCrossRef(icr);
            KCC_SITE_ARRAY *  pSiteArrayWriteable = pCrossRef->GetWriteableSites();
            KCC_SITE_ARRAY *  pSiteArrayPartial = pCrossRef->GetPartialSites();
            
            if( icr==ccr-2 ) {
                // Schema should always be the penultimate crossref.
                // We skip it, because it has the same requirements as Config.
                Assert( KCC_NC_TYPE_SCHEMA==pCrossRef->GetNCType() );
                continue;
            }
            if( icr==ccr-1 ) {
                // Config should always be the last crossref.
                Assert( KCC_NC_TYPE_CONFIG==pCrossRef->GetNCType() );
            }
            
            LOG_NC_AND_SITES;

            if ( ( pSiteArrayWriteable->GetCount() > 1 ) &&
                 (pSiteArrayWriteable->IsElementOf(pLocalSite)) )
            {
                //
                // More than one site hosts a writeable replica of this NC.
                // And, this site is one of the sites holding a writeable copy.
                // Create a minimum cost spanning tree for this NC
                // using all sites that host at least one writeable replica
                // of the NC
    
                // 
                // The elements are sorted by site object guid so that every
                // KCC arrives at the same result.
                //
                // Note that for spanning tree compatibility when using the old
                // algorithm, we must always use this comparision function here
                // to establish the cannonical site ordering.
                //
                pSiteArrayWriteable->Sort( CompareSiteAndSettings );
    
                KccCreateInterSiteConnectionsForNc(pCrossRef,
                                                   pLocalSite,
                                                   FALSE,                  // non-GC topology
                                                   *pSiteArrayWriteable,
                                                   *pTransportList);
            } else {
                DPRINT1(3, "Writeable intersite topology not needed for NC %ws.\n",
                        pCrossRef->GetNCDN()->StringName);
            }
            
            if ( (pSiteArrayPartial->GetCount() > 0) &&
                 (pSiteArrayPartial->IsElementOf(pLocalSite)) )
            {
                // 
                // There is at least one site in the enterprise that hosts a partial
                // replica of this NC without any writeable copies on the same site.
                // And, this site is a candidate to hold a partial copy.
                // Create a minimum cost spanning tree for this NC using all sites
                // that host this NC (both writeable & partial)
                // 
    
                // Local site in partial list => it will not be in the writeable list
                Assert( (!(pSiteArrayWriteable->IsElementOf(pLocalSite))) );

                for (isite = 0; isite < pSiteArrayWriteable->GetCount(); isite++)
                {
                    pSiteArrayPartial->Add((*pSiteArrayWriteable)[isite]);
                }
    
                //
                // The elements are sorted by site object guid so that every KCC arrives
                // at the same result
                //
                // Note that for spanning tree compatibility when using the old
                // algorithm, we must always use this comparision function here
                // to establish the cannonical site ordering.
                //
                pSiteArrayPartial->Sort( CompareSiteAndSettings );
    
                KccCreateInterSiteConnectionsForNc(pCrossRef,
                                                   pLocalSite,
                                                   TRUE,                   // GC topology
                                                   *pSiteArrayPartial,
                                                   *pTransportList);
    
            } else {
                DPRINT1(3, "GC intersite topology not needed for NC %ws.\n",
                        pCrossRef->GetNCDN()->StringName );
            }
        
        }        
    
    }

    //
    // All sites that were unreachable have been appropriately marked.
    //
    gpDSCache->SetReachableMarkingComplete();

    //
    // Remove all inter-site connections within this site that are not
    // needed anymore. 
    //
    KccRemoveUnneededInterSiteConnections();
    
    return;
}

BOOL
KccAmISiteGenerator(
    VOID
    )
/*++

Routine Description:

    This function determines if the local server is the one server in the site
    designated to generate inbound connections from other sites.

Returns:

    TRUE if the local DSA should perform inter site connection generation.
    
--*/
{
    KCC_DSA * pLocalSiteGenerator;
    KCC_DSA * pLocalDSA = gpDSCache->GetLocalDSA();

    pLocalSiteGenerator = gpDSCache->GetLocalSite()->GetSiteGenerator();

    // Note that if no site generator can be determined (e.g., due to lack of
    // NTDS Site Settings object for our site), every DSA in the site will
    // take on this role until the NTDS Site Settings object is created.  (An
    // event has already been logged.)

    return (NULL == pLocalSiteGenerator)
           || (pLocalSiteGenerator == pLocalDSA);
}


VOID
KccCreateInterSiteConnectionsForNc(
    IN     KCC_CROSSREF *               pCrossRef,
    IN     KCC_SITE *                   pLocalSite,
    IN     BOOL                         fGCTopology,
    IN     KCC_SITE_ARRAY &             SiteArray,
    IN     KCC_TRANSPORT_LIST &         TransportList
    )
/*++

Routine Description:

    This routine will construct a minimum cost spanning tree across sites that
    have writable copy of the naming context specified.

    Or in the case of a GCTopology, across sites that have a writable or readable
    copy of the naming context specified.

Parameters:

    pCrossRef            - crossref for the naming context in question
    pLocalSite           - site in which the local DSA resides
    fGCTopology          - tells if the call is for generating GC topology
    SiteArray            - an array of sites that host this naming context
    TransportList        - the list of transports available
    SiteconnectorsToKeep - a list of intersite connectors to keep

Returns:

    None; all errors interesting to the admin are logged.
    
--*/
{
    DWORD       ErrorCode;
    CTOPL_GRAPH SiteGraph;
    KCC_SITE    *RootSite, *CurrentSite;
    TOPL_COMPONENTS *pComponents;
    CTOPL_EDGE  **EdgesNeeded;
    ULONG       cEdgesNeeded;
    ULONG       iSite, cSite, Index;

    RootSite = CurrentSite = NULL;

    // Site array is already sorted by site GUID. So, let us randomely
    // pick the site with the lowest guid as the root site. As long as
    // the logic to pick the rootsite is consitent on all site generators
    // it is good enough.
    RootSite = SiteArray[0];
    
    //
    // Routines from w32topl will throw exceptions on error, so this try is to
    // catch them
    //
    __try
    {
    
        //
        // Put all the nodes into a graph
        //
        for ( iSite = 0, cSite = SiteArray.GetCount();
                iSite < cSite;
                    iSite++ )
        {                   
            //
            // Make sure all edges are cleared from the last iteration
            //
            SiteArray[ iSite ]->ClearEdges();

            SiteGraph.AddVertex( SiteArray[iSite], SiteArray[iSite] ); 
            
            Assert(!!NameMatched(pLocalSite->GetObjectDN(),
                                 SiteArray[iSite]->GetObjectDN())
                   == (pLocalSite == SiteArray[iSite]));

            if (pLocalSite == SiteArray[iSite]) {
                // we are interested in creating site connections for the local site
                Assert(NULL == CurrentSite);
                CurrentSite = SiteArray[iSite];
            }
        }

        if (NULL == CurrentSite)
        {
            // LocalSite does not host (nor required to host) this NC -
            // no need to run the MST algo for this NC in this site generator           
            return;
        }

        // sanity asserts
        Assert(NULL != RootSite);
    
        //
        // For each site, determine what edges exists to/from other sites
        // put each edge into graph
        //
        KccGetSiteConnections( pCrossRef,
                               &TransportList,
                               SiteArray,
                               pLocalSite->GetObjectDN(),
                               fGCTopology );
    
        //
        // Call abstract graph function to create a minimum spanning tree
        //
        pComponents = SiteGraph.FindEdgesForMST( RootSite,
                                                 CurrentSite,
                                                &EdgesNeeded,
                                                &cEdgesNeeded );

        Assert( NULL!=pComponents );                                      
        if ( pComponents->numComponents==1 ) {
            if ( cEdgesNeeded < 1 ) {
                DPRINT( 3, "Spanning tree exists but no edges needed for this site.\n" );
                // (or no edges could be determined due to I_ISMGetConnectivity
                // failure, for example)
            }
        } else {
            KccNoSpanningTree( pCrossRef, pComponents );
        }

        ToplDeleteComponents(pComponents);
        DPRINT1( 3, "%d edges are needed.\n", cEdgesNeeded );
    
        //                                                      
        // For all such edges source from another site to us
        // call CreateConnectionToSite
        //
        for ( Index = 0; Index < cEdgesNeeded; Index++ )
        {
            KCC_SITE_CONNECTION  *SiteConnection;

            //
            // This SiteConnection object tells us what site
            // and by which servers to create a ntdsconnection
            //
    
            SiteConnection =  (KCC_SITE_CONNECTION *) EdgesNeeded[Index];
            ASSERT_VALID( SiteConnection );

            LOG_CONNECTION_NEEDED;
            
            //
            // Create the ntdsconnection if one does not already exist
            //
            KccCreateConnectionToSite(pCrossRef,
                                      pLocalSite,
                                      SiteConnection,
                                      fGCTopology,
                                      TransportList);
        }

        //
        // Graph edges are not needed any more -- free them
        //
        for ( iSite = 0, cSite = SiteArray.GetCount(); iSite < cSite; iSite++ ) {
            SiteArray[iSite]->DeleteEdges();
        }

    }
    __except( ToplIsToplException( ( ErrorCode=GetExceptionCode() ) ) )
    {
        //
        // The w32topl library threw an occur code; the implies an internal
        // mishandling of the objects.  Log an error indicated the inter-site
        // topology failed for this NC
        //
        LOG_W32TOPL_EXCEPTION;
    }

    return;
}

BOOL
KccAddSiteConnectionToGraph(
    KCC_CROSSREF*   pCrossRef,
    BOOL            fGCTopology,
    KCC_TRANSPORT*  Transport,
    KCC_SITE*       SiteSource,
    KCC_SITE*       SiteDest,
    ULONG           Cost,
    ULONG           LinkOptions,
    ULONG           ReplInterval
    )
/*++

Routine Description:

    Add a new site connection to our graph.
    We select bridgehead servers for the site connection at this point.
    
Parameters:

    pCrossRef    - The NC we're processing
    fGCTopology  - Indicates if we're building the GC topology
    Transport    - The Transport of the new site connection
    SiteSource   - The source site of the new site connection
    SiteDest     - The destination site of the new site connection
    Cost         - The cost of the new site connection
    LinkOptions  - The Link Options of the new site connection
    ReplInterval - The ReplInterval of the new site connection

Returns:

    TRUE  - If the new connection was successfully added
    FALSE - Otherwise
    
--*/
{
    KCC_SITE_CONNECTION *SiteConnection;
    KCC_DSA *DsaSource, *DsaDest;

    // Try to find servers in both sites that can use this transport
    // and host the nc in question?
    if( SiteSource->GetNCBridgeheadForTransport(pCrossRef, Transport, fGCTopology, TRUE, &DsaSource) ) {
        LOG_SOURCE_BH_FOUND;
    } else {
        LOG_SOURCE_BH_NOT_FOUND;
        return FALSE;
    }

    if( SiteDest->GetNCBridgeheadForTransport(pCrossRef, Transport, fGCTopology, TRUE, &DsaDest) ) {
        LOG_DEST_BH_FOUND;
    } else {
        LOG_DEST_BH_NOT_FOUND;
        return FALSE;
    }
    
    // Create and initialize a site-connection object
    SiteConnection = new KCC_SITE_CONNECTION;
    if( !SiteConnection->Init() ) {
        DPRINT( 0, "Unable to initialize site connection\n");
        return FALSE;
    }

    SiteConnection->SetSourceSite( SiteSource );
    SiteConnection->SetDestinationSite( SiteDest );
    SiteConnection->SetSourceDSA( DsaSource );
    SiteConnection->SetDestinationDSA( DsaDest );
    SiteConnection->SetTransport( Transport );
    SiteConnection->SetCost( Cost );
    SiteConnection->SetReplInterval( ReplInterval );

    SiteConnection->SetUsesNotification( LinkOptions & NTDSSITELINK_OPT_USE_NOTIFY );
    SiteConnection->SetTwoWaySync( LinkOptions & NTDSSITELINK_OPT_TWOWAY_SYNC );
    SiteConnection->SetDisableCompression( LinkOptions & NTDSSITELINK_OPT_DISABLE_COMPRESSION );

    // Note: Setting the schedule must be done after setting source/dest site & DSA.
    if( Transport->UseSiteLinkSchedules() ) {
        SiteConnection->SetISMSchedule( Transport, SiteSource, SiteDest, ReplInterval );
    } else {
        SiteConnection->SetDefaultSchedule( ReplInterval );
    }

    //
    // This makes the sites objects aware of this connection
    //
    SiteConnection->Associate();

    KccCheckSite( SiteSource );
    KccCheckSite( SiteDest );

    return TRUE;
}


VOID
KccGetSiteConnections(
   IN  KCC_CROSSREF *       pCrossRef,
   IN  KCC_TRANSPORT_LIST * pTransportList,
   IN  KCC_SITE_ARRAY &     SiteArray,
   IN  DSNAME *             pDNLocalSite,
   IN  BOOL                 fGCTopology
   )
/*++

Routine Description:

    This routine queries available transports to determine what physical
    connection exist between the sites listed in SiteArray. These connections
    are also used by the w32topl graph routine to create a minimum spanning tree
    
Parameters:

    pCrossRef            - crossref for the naming context in question
    SiteArray            - an array of sites that host this naming context
    TransportList        - the list of transports available
    pDNLocalSite         - DN of the local site
    fGCTopology          - TRUE, if this is for GC topology

Returns:

    None; all errors interesting to the admin are logged.
    
--*/
{

    DWORD               WinError;
    ISM_CONNECTIVITY    *IsmConnectivity = NULL;
    ULONG               iTransport, cTransports;
    KCC_SITE            *SiteSource, *SiteDest;
    ULONG               iSiteSource, iSiteDest, cSites;
    BOOL                fDataMismatch = FALSE, fAddedNewConnection;
    ULONG               *TransportIndexArray = NULL;
    KCC_DSA             *DsaSource, *DsaDest;
    KCC_SITE_CONNECTION *OtherConnection;
    KCC_NC_TYPE         NCType = pCrossRef->GetNCType();

    ASSERT_VALID(pCrossRef);
    ASSERT_VALID(pTransportList);
    ASSERT_VALID(&SiteArray);

    cSites = SiteArray.GetCount();

    __try {

        //
        // For each transport, consider the link
        //
        for ( iTransport = 0, cTransports = pTransportList->GetCount();
                iTransport < cTransports;
                    iTransport++ )
        {
            KCC_TRANSPORT *Transport;

            Transport = pTransportList->GetTransport(iTransport);
            ASSERT_VALID( Transport );
    
            if (!gfAllowMbrBetweenDCsOfSameDomain
                && !fGCTopology
                && !Transport->IsIntersiteIP()
                && (KCC_NC_TYPE_DOMAIN == NCType) )
            {
                // This is not a viable transport for this NC; skip it.
                LOG_NOT_VIABLE_TRANSPORT;
                continue;
            }

            WinError = I_ISMGetConnectivity( Transport->GetDN()->StringName,
                                            &IsmConnectivity );
            if ((ERROR_SUCCESS != WinError) || (NULL == IsmConnectivity)) {
                if (ERROR_SUCCESS == WinError) {
                    WinError = ERROR_DS_DRA_GENERIC;
                }
                LOG_GET_CONNECTIVITY_FAILED;
                __leave;
            }

            //
            // SiteArray is a list of sites that all have a dc that hosts a given
            // naming context.  We want to know how they are connected.
            //
            // IsmConnectivity contains information about how each site in the
            // enterprise is joined.
            //
            // TransportIndexArray is mapping from an element in SiteArray to
            // an element in IsmConnectivity.
            //

            TransportIndexArray = (ULONG*) new BYTE[ cSites * sizeof(ULONG) ];
    
            for ( iSiteSource = 0; iSiteSource < cSites; iSiteSource++ ) {
                ULONG i;
    
                SiteSource = SiteArray[ iSiteSource ];
                ASSERT_VALID( SiteSource );
    
                for ( i = 0; i < IsmConnectivity->cNumSites; i++ ) {
                    if ( !_wcsicmp( SiteSource->GetObjectDN()->StringName, IsmConnectivity->ppSiteDNs[i] ) ) {
                        TransportIndexArray[ iSiteSource ] = i;
                        break;
                    }
                }
            }
                                                                
            //
            // Now the determine the site connectivity
            //
            for ( iSiteSource = 0; iSiteSource < cSites; iSiteSource++ ) {
                SiteSource = SiteArray[ iSiteSource ];
                ASSERT_VALID( SiteSource );
    
                KccCheckSite( SiteSource );
                SiteSource->BuildSiteConnMap();

                for ( iSiteDest = 0; iSiteDest < cSites; iSiteDest++) {

                    //
                    // Don't bother with connections to the same site
                    //
                    if ( iSiteSource == iSiteDest ) {
                        continue;
                    }

                    PISM_LINK pLink;
                    ULONG   Cost, ReplInterval, LinkOptions;
                    BOOL fUseThisTransport = TRUE;
                    
                    SiteDest = SiteArray[ iSiteDest ];
                    ASSERT_VALID( SiteDest );
                    KccCheckSite( SiteDest );

                    //
                    // Is there a connection between SiteSource and SiteDest ?
                    //
                    pLink = &( IsmConnectivity->pLinkValues[ ( TransportIndexArray[ iSiteSource ]
                                                   *  IsmConnectivity->cNumSites )
                                                   +  TransportIndexArray[ iSiteDest ] ] );
                    Cost = pLink->ulCost;
                    ReplInterval = pLink->ulReplicationInterval;
                    LinkOptions = pLink->ulOptions;

                    if ( Cost < DWORD_INFINITY ) {
                        LOG_CONNECTION_FOUND;

                        //
                        // Is this cost cheaper than any connection already found?
                        //
                        // We want to quickly find the connection between SiteSource
                        // and SiteDest, so we use the map built earlier. Note that the
                        // map will contain stale entries when edges are deleted below,
                        // but this will not cause problems because once an edge has been
                        // deleted, we will search look for it again.
                        //
                        OtherConnection = SiteSource->FindConnInMap( SiteDest );

                        if ( OtherConnection ) {
                            if ( Cost < OtherConnection->GetCost() ) {
                                LOG_NEW_CONNECTION_CHEAPER;
                            } else {
                                LOG_NEW_CONNECTION_NOT_CHEAPER;
                                fUseThisTransport = FALSE;
                            }
                        }

                        if( fUseThisTransport ) {

                            // Add a new site connection to the graph between these two sites
                            fAddedNewConnection = KccAddSiteConnectionToGraph( pCrossRef, fGCTopology,
                                Transport, SiteSource, SiteDest, Cost, LinkOptions, ReplInterval );
                            
                            //
                            // Make the other site objects unaware of the old 
                            // more expensive transport
                            //
                            if( fAddedNewConnection && OtherConnection!=NULL ) {
                                OtherConnection->Disassociate();
                                KccCheckSite( SiteSource );
                                KccCheckSite( SiteDest );
                                delete OtherConnection;
                            }
                        }
                    } else {
                        LOG_CONNECTION_NOT_FOUND;
                    }

                } // iterate over sites

                SiteSource->DestroySiteConnMap();

            } // iterate over sites

            if ( TransportIndexArray ) {
                delete [] TransportIndexArray;
                TransportIndexArray = NULL;
            }
            if ( IsmConnectivity ) {
                I_ISMFree( IsmConnectivity );
                IsmConnectivity = NULL;
            }

        } // iterate over transports

    } __finally {
        if ( IsmConnectivity ) {
            I_ISMFree( IsmConnectivity );
        }
        if ( TransportIndexArray ) {
            delete [] TransportIndexArray;
        }
    }

    return;
}
                                                            

KCC_CONNECTION_ARRAY*
KccFindCandidateConnections(
    IN  KCC_CROSSREF *              pCrossRef,
    IN  KCC_SITE_CONNECTION *       pSiteConnection,   
    IN  BOOL                        fGCTopology
    )
/*++

Routine Description:

    The spanning tree algorithm (either Win2K or Whistler) has run and decided what
    connections it desires. pSiteConnection describes a desired connection. We want
    to examine the existing connections and see if any of them match the desired
    connection.
    
    The precise requirements for a connection to match are too numerous to list here; see
    the comments in the code below for details. The general requirements are:

        - Must source from the right site
        - Must be inbound to the local site
        - Source DSA must be an acceptable BH, host the NC, and (if necessary) be writeable
        - Dest DSA must be an acceptable BH, host the NC, and (if necessary) be writeable

    The overriding rule is that this function should never disqualify a connection which is
    identical to the desired connection.
    
    Note that a connection doesn't have to source to/from the desired servers,
    it just has to source to/from the desired sites.

Parameters:

    pCrossRef            - crossref for the naming context in question
    pSiteConnection      - the desired site connection
    fGCTopology          - tells if the create connection is for a GC topology
    
Returns:

    An pointer to an object which is an array of connection objects.
    If an error occurred (i.e. data read from the directory was inconsistent),
    NULL is returned.
    
--*/
{
    KCC_CONNECTION_LIST::SOURCE_SITE_CONN_ARRAY   *pSiteConnArray;
    KCC_INTERSITE_CONNECTION_LIST                 *pISiteConnList;
    KCC_CONNECTION_ARRAY                          *pCandidateConnArr;
    KCC_SITE                                      *pLocalSite = gpDSCache->GetLocalSite();
    KCC_TRANSPORT_LIST                            *pTransportList = gpDSCache->GetTransportList();
    
    // Desired attributes
    KCC_SITE               *pDesiredSourceSite = pSiteConnection->GetSourceSite();
    DSNAME                 *pdnDesiredSourceSite = pDesiredSourceSite->GetObjectDN();
    KCC_DSA                *pDesiredSourceDsa = pSiteConnection->GetSourceDSA();
    DSNAME                 *pdnDesiredSourceServer, *pdnDesiredDestServer;
    KCC_TRANSPORT          *pDesiredTransport = pSiteConnection->GetTransport();

    // Connection attributes
    KCC_CONNECTION         *pcn;
    KCC_DSA                *pConnSourceServer, *pConnDestServer;
    DSNAME                 *pdnConnSourceServer;
    KCC_TRANSPORT          *pConnTransport;
    LPWSTR                  pszTransportAddr;

    ULONG                   iconn, cconn, idsa, cdsa;
    BOOL                    fIsMaster, fSameSourceDSA, fSameDestDSA, fSameTransport;
    const BOOL              IS_LOCAL=TRUE, NOT_LOCAL=FALSE;

    // Verify parameters
    ASSERT_VALID( pDesiredTransport );
    
    // Allocate an array of candidate connections which we will fill up below.
    pCandidateConnArr = new KCC_CONNECTION_ARRAY;
        
    // Iterate over all DSAs in the local site and examine inbound intersite connections.
    cdsa = pLocalSite->GetDsaList()->GetCount();
    for( idsa=0; idsa<cdsa; idsa++ )
    {
        // Get the intersite connection list for this DSA, and then extract the
        // subset of those connections that source from our desired site.
        pISiteConnList = pLocalSite->GetDsaList()->GetDsa(idsa)->GetInterSiteCnList();
        ASSERT_VALID( pISiteConnList );
        pSiteConnArray = pISiteConnList->GetConnectionsFromSite( pdnDesiredSourceSite );

        // If there are no connections at the local DSA idsa which source from our
        // desired site just skip to next DSA.
        if( NULL==pSiteConnArray ) {
            continue;
        }
                       
        // Scan the list of connections from the desired site inbound to the DSA 'idsa',
        // looking for candidates which match pSiteConnection.
        cconn = pSiteConnArray->numConnections;
        for( iconn=0; iconn<cconn; iconn++ )
        {
            pcn = pSiteConnArray->connection[iconn];
            ASSERT_VALID( pcn );

            // Confirm that pdnConnSourceServer is in the site that we desired.
            pdnConnSourceServer = pcn->GetSourceDSADN();
            Assert( pdnConnSourceServer );
            Assert( NamePrefix(pDesiredSourceSite->GetObjectDN(),pdnConnSourceServer) );

            // Find this connection's transport
            Assert( NULL != pcn->GetTransportDN() );
            pConnTransport = pTransportList->GetTransport(pcn->GetTransportDN());
            if( NULL==pConnTransport ) {
                Assert( 0 && "Connection had an invalid transport DN" );
                KCC_EXCEPT( ERROR_DS_MISSING_REQUIRED_ATT, 0);
            }
            fSameTransport = (pConnTransport == pDesiredTransport);
                                 
            // Find the KCC_DSA object for the connection's source server. If the connection
            // is KCC-generated and the connection's source DSA is not the same as the
            // desired source DSA, check that the the DSA is acceptable. Here, acceptable
            // means the DSA is a preferred bridgehead, if preferred BHs are enabled.
            // If the connection is manually created, or if the connection's source DSA
            // is the same as the desired source DSA, we skip the acceptability check.
            pdnDesiredSourceServer = pDesiredSourceDsa->GetDsName();
            fSameSourceDSA = (0==CompareDsName(&pdnConnSourceServer,&pdnDesiredSourceServer));
            if( pcn->IsGenerated() && !fSameSourceDSA )
            {
                pConnSourceServer = pDesiredSourceSite
                                    ->GetTransportDsaList(pConnTransport)
                                    ->GetDsa(pdnConnSourceServer);
                if(!pConnSourceServer) {
                    DPRINT3(0, "%ls is no longer a bridgehead for transport %ls in site %ls.\n",
                            pdnConnSourceServer->StringName,
                            pConnTransport->GetDN()->StringName,
                            pDesiredSourceSite->GetObjectDN()->StringName);
                    continue;
                }
            } else {    
                pConnSourceServer = pDesiredSourceSite->GetDsaList()->GetDsa(pdnConnSourceServer);
                if(!pConnSourceServer) {
                    DPRINT2(0, "%ls is no longer a server in site %ls.\n",
                            pdnConnSourceServer->StringName,
                            pDesiredSourceSite->GetObjectDN()->StringName);
                    continue;
                }
            }
    
            // A valid source DSA must meet the following requirements:
            //  - it must host the desired NC
            //  - it must be master for a non-gc topology
            //  - it may be master or partial for a gc-topology.
            //  - it must have a valid transport address for its transport
            // If the connection's source DSA does not meet these requirements, we skip it.
            pszTransportAddr = pConnSourceServer->GetTransportAddr(pConnTransport);
            if(    !(pConnSourceServer->IsNCHost(pCrossRef, NOT_LOCAL, &fIsMaster))
                || (!fIsMaster && !fGCTopology)
                || !pszTransportAddr )
            {
                Assert( !fSameTransport || !fSameSourceDSA );
                // NC not instantiated on source bridgehead
                DPRINT3(3, "Connection %ws is not a candidate because NC %ws not instantiated on source %ws.\n",
                        pcn->GetConnectionDN()->StringName,
                        pCrossRef->GetNCDN()->StringName,
                        pConnSourceServer->GetDsName()->StringName );
                continue;
            }

            // We need to further see if the destination end of the connection in the local
            // site hosts the required NC correctly. Get a pointer to the DSA object here.   
            Assert( pSiteConnection->GetDestinationSite() == pLocalSite );
            pConnDestServer = pLocalSite->GetDsaList()->GetDsa(pcn->GetDestinationDSADN());
            if (NULL == pConnDestServer) {
                // Cache coherency problem.  This can occur due to the fact
                // that the intersite connections and DSAs are enumerated in
                // different transactions.  Bail and try again later.
                DPRINT1(0, "Cannot find DSA object %ls in cache\n",
                        pcn->GetDestinationDSADN()->StringName);
                delete pCandidateConnArr;
                return NULL;
            }

            // If the connection is KCC-generated and the connection's destination DSA is not
            // the same as the desired destination DSA, check that the the DSA is acceptable.
            // Here, acceptable means the DSA is a preferred bridgehead, if preferred BHs are enabled.
            // If the connection is manually created, or if the connection's destination DSA
            // is the same as the desired destination DSA, we skip the acceptability check.
            pdnDesiredDestServer = pSiteConnection->GetDestinationDSA()->GetDsName();
            fSameDestDSA = NameMatched(pcn->GetDestinationDSADN(), pdnDesiredDestServer);
            if( pcn->IsGenerated() && !fSameDestDSA )
            {
                if( NULL == pSiteConnection->GetDestinationSite()
                                ->GetTransportDsaList(pConnTransport)
                                ->GetDsa(pConnDestServer->GetDsName()) )
                {
                    DPRINT2(0, "%ls is no longer a BH for transport %ls in the local site.\n",
                            pConnDestServer->GetDsName()->StringName,
                            pConnTransport->GetDN()->StringName);
                    continue;
                }
            }
            
            // A valid destination DSA must meet the following requirements:
            //  - it must host the desired NC
            //  - it must be master for a non-gc topology
            //  - it must be partial for a gc-topology (Note: different from source DSA case)
            //  - it must have a valid transport address for its transport
            // If the connection's source DSA does not meet these requirements, we skip it.
            pszTransportAddr = pConnDestServer->GetTransportAddr(pConnTransport);
            if(    !pConnDestServer->IsNCHost(pCrossRef, IS_LOCAL, &fIsMaster)
                || (!fIsMaster && !fGCTopology)
                || (fIsMaster && fGCTopology)
                || (NULL == pszTransportAddr) )
            {
                // NC not instantiated on local bridgehead
                DPRINT3(3, "Connection %ws is not a candidate because NC %ws not instantiated on destination %ws.\n",
                        pcn->GetConnectionDN()->StringName,
                        pCrossRef->GetNCDN()->StringName,
                        pConnDestServer->GetDsName()->StringName );
                continue;
            }
            
            pCandidateConnArr->Add( pcn );
        }
    }

#if DBG
    // If we didn't select any candidates, see if there is one already which we should have
    if (!pCandidateConnArr->GetCount()) {
        KCC_INTERSITE_CONNECTION_LIST      *pConnList;
        KCC_CONNECTION                     *pDuplicateConn;
        GUID                               *pSourceDSAGuid;

        pConnList = pSiteConnection->GetDestinationDSA()->GetInterSiteCnList();
        pSourceDSAGuid = &pSiteConnection->GetSourceDSA()->GetDsName()->Guid;
        
        // Check to see if an inbound connection exists from the same DSA
        pDuplicateConn = pConnList->GetConnectionFromSourceDSAUUID(pSourceDSAGuid);
        if( NULL!=pDuplicateConn ) {
            DSNAME *pTransDN1, *pTransDN2;
            pTransDN1 = pDuplicateConn->GetTransportDN();
            pTransDN2 = pSiteConnection->GetTransport()->GetDN();

            if( NameMatched(pTransDN1,pTransDN2) ) {

                Assert( !"Failed to find a connection candidate when one exists!" );
            }
        }
    }
#endif

    return pCandidateConnArr;
}


VOID
KccUpdateCandidates(
    IN OUT KCC_CONNECTION_ARRAY*       pCandidateConnArr,
    IN     KCC_SITE_CONNECTION *       pSiteConnection
    )
/*++

Routine Description:

    This function examines all candidate connections and fixes up their schedules
    and options. We only do this if the candidate is KCC-generated and has the
    same transport as the desired connection.

Parameters:

    pCandidateConnArr    - the list of candidates
    pSiteConnection      - the desired site connection
    
Returns:

    None
    
--*/
{
    TOPL_SCHEDULE_CACHE     scheduleCache = gpDSCache->GetScheduleCache();
    TOPL_SCHEDULE           connSched, correctSched;    
    KCC_CONNECTION         *pcn;
    DWORD                   iconn, cconn;
 
    ASSERT_VALID( pCandidateConnArr );
    ASSERT_VALID( pSiteConnection );
    Assert( NULL!=scheduleCache );                        

    cconn = pCandidateConnArr->GetCount();
    for ( iconn=0; iconn<cconn; iconn++ )
    {
        pcn = (*pCandidateConnArr)[ iconn ];
        Assert( pcn );
        
        if(   pcn->IsGenerated()
           && KccIsEqualGUID(&pcn->GetTransportDN()->Guid,
                             &pSiteConnection->GetTransport()->GetDN()->Guid))
        {
            // KCC-generated object with the desired transport.  Verify that
            // the schedule and flags on the connection object are
            // what we think they should be, and if not then update
            // the object in the DS.
            BOOL            fUpdateConnectionInDS = FALSE;

            connSched  = pcn->GetSchedule();
            correctSched = pSiteConnection->GetReplicationScheduleAltBH(
                pcn->GetSourceDSA(), pcn->GetDestinationDSA() );
                        
            if( !ToplScheduleIsEqual(scheduleCache,connSched,correctSched) ) {

                if( pcn->IsUserOwnedSchedule() ) {
                    // Don't update the schedule because the connection has a
                    // user-owned schedule
                    LogEvent(DS_EVENT_CAT_KCC,
                             DS_EVENT_SEV_EXTENSIVE,
                             DIRLOG_KCC_CONNECTION_SCHEDULE_NOT_UPDATED,
                             szInsertDN(pcn->GetConnectionDN()),
                             0,0);
                } else {
                    // Wrong schedule -- fix it.
                    pcn->SetSchedule(correctSched);
                    fUpdateConnectionInDS = TRUE;
                }
            }

            if (pcn->UsesNotification() != pSiteConnection->UsesNotification()) {
                // Wrong notification setting -- fix it.
                pcn->SetOverrideNotification(pSiteConnection->UsesNotification());
                fUpdateConnectionInDS = TRUE;
            }

            if (pcn->IsTwoWaySynced() != pSiteConnection->IsTwoWaySynced()) {
                // Wrong two-way sync setting -- fix it.
                pcn->SetTwoWaySync(pSiteConnection->IsTwoWaySynced());
                fUpdateConnectionInDS = TRUE;
            }

            if (pcn->IsCompressionEnabled() != (!pSiteConnection->IsCompressionDisabled())) {
                // Wrong disable compression setting -- fix it.
                pcn->SetDisableIntersiteCompression(pSiteConnection->IsCompressionDisabled());
                fUpdateConnectionInDS = TRUE;
            }
               
            if (fUpdateConnectionInDS) {
                // Flush changes to this object back to the DS.
                pcn->UpdateDS();
            }                
        }
    }
}


VOID
KccCreateAlternateConnectionsToSite(
    IN  KCC_CROSSREF *          pCrossRef,
    IN  KCC_SITE *              pLocalSite,
    IN OUT  KCC_SITE_CONNECTION *   pSiteConnection,   
    IN  BOOL                    fGCTopology,    
    IN  DWORD                   cValidConnections
    )
/*++

Routine Description:

    Create a number of alternate connections, while not creating any duplicates

    Side effect: pSiteConnection is modified with a new set of endpoints

Arguments:

    pCrossRef - 
    pLocalSite - 
    pSiteConnection - 
    fGCTopology - 
    cValidConnections - 

Return Value:

    None

--*/
{
    KCC_DSA_ARRAY bestDestDsas, bestSourceDsas;
    KCC_SITE *pRemoteSite = pSiteConnection->GetSourceSite();
    KCC_TRANSPORT *pTransport = pSiteConnection->GetTransport();
    DWORD cTotalPairs, cUnusedPairs;
    DWORD cSourceDsas, cDestDsas;
    DWORD iSourceDsa, iDestDsa, iPair;
    DWORD cNeededConnections = (NTDSSETTINGS_DEFAULT_SERVER_REDUNDANCY - cValidConnections);

    struct _dsapair {
        KCC_DSA *pDestDsa;
        KCC_DSA *pSourceDsa;
    } *rgDsaPair;

    DPRINT3( 1, "Alternate: nc %ws has redundancy %d, goal %d\n",
             pCrossRef->GetNCDN()->StringName,
             cValidConnections, NTDSSETTINGS_DEFAULT_SERVER_REDUNDANCY );

    if ( (cValidConnections < 1) ||
         (cValidConnections >= NTDSSETTINGS_DEFAULT_SERVER_REDUNDANCY) ) {
        // Topology in error state, or
        // Topology already has enough redundancy, don't add any more
        return;
    }

    if( ! pRemoteSite->GetNCBridgeheadForTransportBestDsas(
            pCrossRef,
            pTransport,
            fGCTopology,
            &bestSourceDsas) ) {
        Assert( !"had a source bridgehead, now cant find any?" );
        return;
    }

    if( ! pLocalSite->GetNCBridgeheadForTransportBestDsas(
            pCrossRef,
            pTransport,
            fGCTopology,
            &bestDestDsas) ) {
        Assert( !"had a dest bridgehead, now cant find any?" );
        return;
    }

    cSourceDsas = bestSourceDsas.GetCount();
    cDestDsas = bestDestDsas.GetCount();
#if DBG
    DPRINT2( 1, "Best bridgeheads: source %d dest %d\n",cSourceDsas, cDestDsas );
    DPRINT( 2, "Dest Dsas:\n" );
    for( iDestDsa = 0; iDestDsa < cDestDsas; iDestDsa++ )
        DPRINT2( 2, "%d %ws\n", iDestDsa, bestDestDsas[ iDestDsa ]->GetDsName()->StringName );
    DPRINT( 2, "Source Dsas:\n" );
    for( iSourceDsa = 0; iSourceDsa < cSourceDsas; iSourceDsa++ )
        DPRINT2( 2, "%d %ws\n", iSourceDsa, bestSourceDsas[ iSourceDsa ]->GetDsName()->StringName );
#endif

    cTotalPairs = cSourceDsas * cDestDsas;
    if (cTotalPairs > cValidConnections) {
        cUnusedPairs = cTotalPairs - cValidConnections;
    } else {
        Assert( !"more connections than there are valid bridgeheads?" );
        cUnusedPairs = 0;
    }
    DPRINT3( 2, "Total pairs %d, pairs in use %d, unused %d\n",
             cTotalPairs, cValidConnections, cUnusedPairs );
    if (cNeededConnections > cUnusedPairs) {
        DPRINT2( 2, "We desire %d pairings, but only %d are available.\n",
                 cNeededConnections, cUnusedPairs );
        cNeededConnections = cUnusedPairs;
    }

    rgDsaPair = new struct _dsapair [ cTotalPairs ];

    // Enumerate the pairs so that the same bridgeheads are not adjacent
    // The idea is to insert the pairs in such an order that when you run through
    // the list linearly later, you don't reuse the same bridgehead quickly.
    // Here is an example with 2 source and 2 dest bridgeheads:
    // SrcBH   DestBh  iPair
    // 0       0       0
    // 0       1       2
    // 1       0       3
    // 1       1       1
    // 

    // FUTURE: Perf warning, n^2 algorithm
    // Next time use the LMMATCH algorithm to come up with the assignment of
    // redundant connections which generates the least load.
    for( iSourceDsa = 0; iSourceDsa < cSourceDsas; iSourceDsa++ ) {
        for( iDestDsa = 0; iDestDsa < cDestDsas; iDestDsa++ ) {

            iPair = ((iDestDsa+iSourceDsa) * cSourceDsas + iSourceDsa) % cTotalPairs;

            Assert( rgDsaPair[ iPair ] . pDestDsa == NULL );
            rgDsaPair[ iPair ] . pDestDsa = bestDestDsas[ iDestDsa ];
            Assert( rgDsaPair[ iPair ] . pSourceDsa == NULL );
            rgDsaPair[ iPair ] . pSourceDsa = bestSourceDsas[ iSourceDsa ];

            DPRINT3( 3, "\t%d\t%d\t%d\n", iSourceDsa, iDestDsa, iPair );
        }
    }
#if DBG
    // Assert that the shuffle does not corrupt
    // That no entries are overwritten, and that all slots are filled
    for( iPair = 0; iPair < cTotalPairs; iPair++ ) {
        Assert( rgDsaPair[ iPair ] . pDestDsa != NULL );
        Assert( rgDsaPair[ iPair ] . pSourceDsa != NULL );
    }
#endif

    // Try all pairs, trying to find non duplicates we can create
    for( iPair = 0; (iPair < cTotalPairs) && cNeededConnections; iPair++ ) {

        // This bit of magic tells whether a connection already exists given its
        // dsa endpoints. There is a similar check in CreateConnToSite. This
        // check is very efficient based on search trees.
        KCC_INTERSITE_CONNECTION_LIST *pConnList =
            rgDsaPair[ iPair ].pDestDsa->GetInterSiteCnList();
        GUID *pSourceDSAGuid =
            &(rgDsaPair[ iPair ].pSourceDsa->GetDsName()->Guid);
        KCC_CONNECTION *pDuplicateConn =
            pConnList->GetConnectionFromSourceDSAUUID(pSourceDSAGuid);

        if (!pDuplicateConn) {
            pSiteConnection->SetSourceDSA(rgDsaPair[ iPair ].pSourceDsa);
            pSiteConnection->SetDestinationDSA(rgDsaPair[ iPair ].pDestDsa);
            pSiteConnection->RestaggerSchedule();

            KCC_CONNECTION *pcnNew = new KCC_CONNECTION;

            pcnNew->SetEnabled(       TRUE                              );
            pcnNew->SetGenerated(     TRUE                              );

            pcnNew->SetOverrideNotification( pSiteConnection->UsesNotification() );
            pcnNew->SetTwoWaySync(    pSiteConnection->IsTwoWaySynced() );
            pcnNew->SetDisableIntersiteCompression( pSiteConnection->IsCompressionDisabled() );
            pcnNew->SetTransport(     pSiteConnection->GetTransport()->GetDN() );
            pcnNew->SetSourceDSA(     pSiteConnection->GetSourceDSA()   );
            pcnNew->AddReplicatedNC(  pCrossRef->GetNCDN(), fGCTopology );

            pcnNew->SetSchedule(      pSiteConnection->GetReplicationSchedule() );
            pcnNew->SetReasonForConnection(NTDSCONN_KCC_REDUNDANT_SERVER_TOPOLOGY);

            DWORD dirError = pcnNew->Add(
                pSiteConnection->GetDestinationDSA()->GetDsName(),
                DSID(FILENO,__LINE__) );
    
            if ( 0 != dirError ) {
                return;
            }

            // Add new connection to the cache.
            pLocalSite
                ->GetDsaList()
                ->GetDsa(pSiteConnection->GetDestinationDSA()->GetDsName())
                ->GetInterSiteCnList()
                ->AddToList(pcnNew);

            cNeededConnections--;
        }
    }

} /* CreateAlternateConnectionsToSite */

VOID
KccCreateConnectionToSite(
    IN  KCC_CROSSREF *              pCrossRef,
    IN  KCC_SITE *                  pLocalSite,
    IN  KCC_SITE_CONNECTION *       pSiteConnection,   
    IN  BOOL                        fGCTopology,    
    IN  KCC_TRANSPORT_LIST &        TransportList
    )
/*++

Routine Description:

    This routine will create a connection between the local site and the
    site specified between machines that hold the given nc if such a
    connection does not already exist.
    
Parameters:

    pCrossRef            - crossref for the naming context in question
    pLocalSite           - site in which the local DSA resides
    pSiteConnection      - the site connection to instantiate
    fGCTopology          - tells if the create connection is for a GC topology
    TransportList        - list of intersite transports

Returns:

    None - the only errors are unexpected errors - so an exception is thrown
    
--*/
{     
    KCC_SITE_LIST           *pSiteList = gpDSCache->GetSiteList();
    KCC_CONNECTION_ARRAY    *pConnArray;
    KCC_SITE                *pSite, *pDesiredSourceSite = pSiteConnection->GetSourceSite();
    KCC_NC_TYPE             NCType = pCrossRef->GetNCType();
    KCC_DSA                 *pDesiredSourceDsa;
    DWORD                   cValidConnections = 0;
    DSNAME                  *pNCDN;
    ULONG                   iconn, cconn, isite;
    KCC_DSNAME_ARRAY        staleBridgeheadDNArray;


    // We should not be trying to add a connection if either of the bridgeheads
    // are considered stale, because this will cause us to disregard an existing
    // connections and potentially create a duplicate.
    //
    // Although the bridgeheads were not considered stale earlier, their
    // staleness is time-dependent so we check again. If either of them are now
    // stale, we just don't bother creating this new connection. The connection
    // should be created on the next KCC run, because we shouldn't hit the same
    // race-condition twice in a row.
    pDesiredSourceDsa = pSiteConnection->GetSourceDSA();
    Assert( NULL!=pDesiredSourceDsa );
    if (   KccIsBridgeheadStale(pDesiredSourceDsa->GetDsName())
        || KccIsBridgeheadStale(pSiteConnection->GetDestinationDSA()->GetDsName()) )
    {
        return;
    }

    // Verify that the NC is instantiated on the source DSA.
    pNCDN = pCrossRef->GetNCDN();
    Assert( NULL!=pNCDN );
    Assert( pDesiredSourceDsa->IsNCInstantiated(pNCDN, NULL) );


    pConnArray = KccFindCandidateConnections( pCrossRef, pSiteConnection, fGCTopology );
    if( NULL==pConnArray ) {
        // An error must have occurred -- bail out.
        return;
    }
    KccUpdateCandidates( pConnArray, pSiteConnection );
    

    DPRINT3(3, "There are %d candidate connections that replicate naming context %ls from site %ls\n",
            pConnArray->GetCount(), pCrossRef->GetNCDN()->StringName,
            pDesiredSourceSite->GetObjectDN()->StringName);
    // Supportability logging event 5
    LogEvent(
        DS_EVENT_CAT_KCC,
        DS_EVENT_SEV_EXTENSIVE,
        DIRLOG_KCC_CANDIDATE_CONNECTIONS,
        szInsertUL(pConnArray->GetCount()),
        szInsertDN(pCrossRef->GetNCDN()),
        szInsertDN(pDesiredSourceSite->GetObjectDN())
        ); 
    

    //
    // From the list of existing replication connections see if they 
    // are over the cheapest transport available
    //
    cconn=pConnArray->GetCount();
    for ( iconn=0; iconn<cconn; iconn++ )
    {
        KCC_CONNECTION *pcn;
        pcn = (*pConnArray)[ iconn ];
        Assert( pcn );

        // If the connection was not autogenerated then assume this is
        // what the admin wants; otherwise if the connection uses the
        // transport we want then that is good, too.
        //
        // We will also re-use an in-use KCC-generated IP connection if
        // we're trying to add SMTP (even though SMTP was cheaper). Why?
        //
        // Suppose there is an in-use (ie, it doesn't replicate nothing) IP connection.
        // It must have been required by a writeable domain NC. Adding the SMTP connection
        // (which is cheaper) desired by the partial NCs would be redundant, because the
        // IP connection _has_ to be there. So, we accept the in-use IP connection.

        if (!pcn->IsGenerated() 
            || KccIsEqualGUID(&pcn->GetTransportDN()->Guid,
                              &pSiteConnection->GetTransport()->GetDN()->Guid)
            || (   !pSiteConnection->GetTransport()->IsIntersiteIP()
                && KCC_TRANSPORT::IsIntersiteIP(pcn->GetTransportDN())
                && !pcn->ReplicatesNothing()) )
        {
            
            if (KccIsBridgeheadStale(pcn->GetSourceDSADN())) {
                // Source server is stale.
                DPRINT2(0, "Ignoring connection %ls using stale outbound bridgehead %ls.\n",
                        pcn->GetConnectionDN()->StringName,
                        pcn->GetSourceDSADN()->StringName);
                pcn->SetReasonForConnection(KCC_STALE_SERVERS_TOPOLOGY);
                staleBridgeheadDNArray.Add( pcn->GetSourceDSADN() );
            }
            else if (KccIsBridgeheadStale(pcn->GetDestinationDSADN())) {
                // Destination server is stale.
                DPRINT2(0, "Ignoring connection %ls using stale inbound bridgehead %ls.\n",
                        pcn->GetConnectionDN()->StringName,
                        pcn->GetDestinationDSADN()->StringName);
                pcn->SetReasonForConnection(KCC_STALE_SERVERS_TOPOLOGY);
                staleBridgeheadDNArray.Add( pcn->GetDestinationDSADN() );
            }
            else {
                // This is the first "live" connection we've found that allows
                // us to replicate this NC -- it's a keeper!
                DPRINT3( 3, "Connection %ls is the connection object that we need"\
                            " to replicate over nc %ls over transport %ls\n", 
                         pcn->GetConnectionDN()->StringName,
                         pCrossRef->GetNCDN()->StringName, 
                         pcn->GetTransportDN()->StringName );
                
                cValidConnections++;
                pcn->SetReasonForConnection(
                    fGCTopology ? KCC_INTERSITE_GC_TOPOLOGY : KCC_INTERSITE_TOPOLOGY );
                // This is not 100% accurate due to connection ordering
                if (staleBridgeheadDNArray.GetCount()) {
                    pcn->SetReasonForConnection( KCC_SERVER_FAILOVER_TOPOLOGY );
                }
                // Supportability logging event 6
                LogEvent8(
                    DS_EVENT_CAT_KCC,
                    DS_EVENT_SEV_EXTENSIVE,
                    DIRLOG_KCC_LIVE_CONNECTION,
                    szInsertDN(pcn->GetConnectionDN()),
                    szInsertDN(pCrossRef->GetNCDN()),
                    szInsertDN(pcn->GetTransportDN()),
                    szInsertDN(pDesiredSourceSite->GetObjectDN()),
                    0, 0, 0, 0
                    ); 
            }

            // Supportability logging event 7, dump reason for connection
            LogEvent8(
                DS_EVENT_CAT_KCC,
                DS_EVENT_SEV_EXTENSIVE,
                DIRLOG_KCC_CONNECTION_REPLICATES_NC,
                szInsertDN(pcn->GetConnectionDN()),
                szInsertDN(pCrossRef->GetNCDN()),
                szInsertDN(pcn->GetTransportDN()),
                szInsertDN(pDesiredSourceSite->GetObjectDN()),
                szInsertUL(pcn->GetReasonForConnection()),
                szInsertUL(fGCTopology),
                0, 0
                ); 
            pcn->AddReplicatedNC(pCrossRef->GetNCDN(), fGCTopology);
        }
    }

    if ( !cValidConnections )
    {
        //
        // No such connection exists - create one
        //
        KCC_INTERSITE_CONNECTION_LIST      *pConnList;
        KCC_CONNECTION                     *pDuplicateConn;
        GUID                               *pSourceDSAGuid;

        pConnList = pSiteConnection->GetDestinationDSA()->GetInterSiteCnList();
        pSourceDSAGuid = &pSiteConnection->GetSourceDSA()->GetDsName()->Guid;
        
        // Check to see if an inbound connection exists from the same DSA
        pDuplicateConn = pConnList->GetConnectionFromSourceDSAUUID(pSourceDSAGuid);
        if( NULL!=pDuplicateConn ) {
            DSNAME *pTransDN1, *pTransDN2;
            pTransDN1 = pDuplicateConn->GetTransportDN();
            pTransDN2 = pSiteConnection->GetTransport()->GetDN();

            // A duplicate connection exists! If the connection has the same transport
            // type as the connection we are trying to create, then we definitely don't
            // want to create a new connection, so we bail out.
            // If the transports are different, then we are basically switching from
            // one transport to another. We allow creation of the (duplicate) connection
            // with the new transport, because the old one will be removed later on.
            
            if( NameMatched(pTransDN1,pTransDN2) ) {

                Assert( NULL==pDuplicateConn );
                DPRINT1(0, "Almost created a duplicate connection of %ls but prevented it",
                    pDuplicateConn->GetConnectionDN()->StringName );
                LogEvent(
                        DS_EVENT_CAT_KCC,
                        DS_EVENT_SEV_ALWAYS,
                        DIRLOG_KCC_ALMOST_MADE_DUP_CONNECTION,
                        szInsertDN(pDuplicateConn->GetConnectionDN()),
                        0, 0
                        );
                return;
            }
        }
        
        // Report stale bridgeheads that contributed to this decision
        /* Log the DNs of stale servers in batches of 8.
         * The first message is logged with severity ALWAYS but subsequent
         * messages are logged with severity EXTENSIVE. */
        DWORD dwLoggingLevel = DS_EVENT_SEV_ALWAYS;
        DWORD cStaleServers = staleBridgeheadDNArray.GetCount();
        
        for( DWORD iDN=0; iDN<cStaleServers; iDN+=8 ) {

            /* Define a macro to add one site DN to the event log message */
            #define INSERT_STALE_SERVER(x) \
                (iDN+x < cStaleServers) ? \
                     szInsertDN(staleBridgeheadDNArray[iDN+x]) : szInsertSz("")

            LogEvent8(
                DS_EVENT_CAT_KCC,
                dwLoggingLevel,
                DIRLOG_KCC_STALE_SITE_BRIDGEHEADS,
                INSERT_STALE_SERVER(0),
                INSERT_STALE_SERVER(1),
                INSERT_STALE_SERVER(2),
                INSERT_STALE_SERVER(3),
                INSERT_STALE_SERVER(4),
                INSERT_STALE_SERVER(5),
                INSERT_STALE_SERVER(6),
                INSERT_STALE_SERVER(7)
                );
        
            dwLoggingLevel = DS_EVENT_SEV_EXTENSIVE;
        }

        KCC_CONNECTION *pcnNew = new KCC_CONNECTION;

        pcnNew->SetEnabled(       TRUE                              );
        pcnNew->SetGenerated(     TRUE                              );

        pcnNew->SetOverrideNotification( pSiteConnection->UsesNotification() );
        pcnNew->SetTwoWaySync(    pSiteConnection->IsTwoWaySynced() );
        pcnNew->SetDisableIntersiteCompression( pSiteConnection->IsCompressionDisabled() );
        pcnNew->SetTransport(     pSiteConnection->GetTransport()->GetDN() );
        pcnNew->SetSourceDSA(     pSiteConnection->GetSourceDSA()   );
        pcnNew->AddReplicatedNC(  pCrossRef->GetNCDN(), fGCTopology );
        pcnNew->SetSchedule(      pSiteConnection->GetReplicationSchedule() );

        pcnNew->SetReasonForConnection(
            fGCTopology ? KCC_INTERSITE_GC_TOPOLOGY : KCC_INTERSITE_TOPOLOGY );
        if (staleBridgeheadDNArray.GetCount()) {
            pcnNew->SetReasonForConnection( KCC_SERVER_FAILOVER_TOPOLOGY );
        }
        // We infer that if there are any disconnected sites, that this is a
        // site failover connection.
        if (gpDSCache->IsAnySiteUnreachable()) {
            pcnNew->SetReasonForConnection( KCC_SITE_FAILOVER_TOPOLOGY );
        }

        DWORD dirError = pcnNew->Add(
            pSiteConnection->GetDestinationDSA()->GetDsName(),
            DSID(FILENO,__LINE__) );
    
        if ( 0 == dirError )
        {
            // Add new connection to the cache.
            pLocalSite
                ->GetDsaList()
                ->GetDsa(pSiteConnection->GetDestinationDSA()->GetDsName())
                ->GetInterSiteCnList()
                ->AddToList(pcnNew);
            cValidConnections++;
        }
    }                                    

    if (pLocalSite->BuildRedundantServerTopology()) {
        KccCreateAlternateConnectionsToSite( pCrossRef,
                                            pLocalSite,
                                            pSiteConnection,
                                            fGCTopology,
                                            cValidConnections );
    }

} /* CreateConnectionToSite */

VOID
KccRemoveIntersiteConnection(
    KCC_CONNECTION *pcn,
    DWORD dsid
    )
/*++

Routine Description:

    Remove a connection from the directory and in-memory data structures

    Note that it is the caller's responsibility to call
            (!gConnectionDeletionCache.PreventRepeatedDeletion( pcn )) ) {
    first to see if the connection should actually be deleted.

Parameters:

    pcn - The connection to be removed

Return value:

    None

--*/
{
    KCC_DSA    *pDestDSA;
    KCC_SITE   *pLocalSite = gpDSCache->GetLocalSite();
    DWORD       dirError;

    dirError = pcn->Remove( dsid );

    pDestDSA = pLocalSite->GetDsaList()->GetDsa(pcn->GetDestinationDSADN());
    ASSERT_VALID( pDestDSA );
    pDestDSA->GetInterSiteCnList()->RemoveFromList(pcn);

    delete pcn;
}


VOID
KccRemoveUnneededInterSiteConnections(
    VOID
    )
/*++

Routine Description:

    This function examines all connections inbound to the local site.
    It removes connections which are deemed to be unnecessary and
    updates the NCReason attribute on connections that must be kept.
    
Parameters:

    pLocalSite (IN) - internal representation of site object for our site

Returns:

    None - all significant errors are logged
    
--*/
{
    ULONG                 iconn, cconn, iconn2, idsa;
    KCC_CONNECTION_ARRAY  connArray;
    KCC_CONNECTION       *pcn, *pcn2;
    KCC_SITE             *pLocalSite = gpDSCache->GetLocalSite();
    BOOL                  fRemove=FALSE, fDontUpdateReason=FALSE;
    DWORD                 cConnectionsInClass;

    // Check connection list for redundant or unused connections.  E.g., no need
    // to keep  a connection that replicates only config & schema if another
    // connection exists from the same site that sources config, schema, & GC
    // info.

    // Sort by source site.  For connections from the same source, order by
    // increasing GC-ness.  If same GC-ness, sort admin-generated connections
    // last.
    //
    // The assertion is that if a connection A is superseded by connection B
    // and connection B is not superseded by A, then A must precede B in the
    // sorted list.

    // Build array containing all connections inbound to this site.
    for( idsa=0; idsa<pLocalSite->GetDsaList()->GetCount(); idsa++ ) {
        KCC_INTERSITE_CONNECTION_LIST * pISiteConnList
            = pLocalSite->GetDsaList()->GetDsa(idsa)->GetInterSiteCnList();
        
        for( iconn=0, cconn=pISiteConnList->GetCount(); iconn<cconn; iconn++ ) {
            connArray.Add(pISiteConnList->GetConnection(iconn));
        }
    }

    // Sort them as detailed above.
    connArray.Sort(KCC_CONNECTION::CompareForRemoval);

    for( iconn=0, cconn=connArray.GetCount(); iconn<cconn; iconn++ ) {

        // Get the connection from the array and check it
        pcn = connArray[ iconn ];
        ASSERT_VALID( pcn );
        Assert( NULL!=pcn->GetTransportDN() );

        // Clear our loop flags
        fRemove=FALSE;
        fDontUpdateReason=FALSE;
        cConnectionsInClass = 1;

        if( !pcn->IsGenerated() ) {
        	// Connections manually created by the Administrator (i.e. non-KCC
        	// generated connections) must always be kept.
        } else {
            if( !pcn->IsSourceSiteUnreachable() ) {
                if( pcn->ReplicatesNothing() ) {
                    fRemove=TRUE;
                } else {

                    // Examine other connection from the same site, looking for ones which
                    // supercede this connection.
                    for( iconn2=iconn+1; iconn2<cconn; iconn2++ ) {
                        pcn2 = connArray[ iconn2 ];
                        ASSERT_VALID( pcn2 );                  
                        if(!NameMatched(pcn->GetSourceSiteDN(),pcn2->GetSourceSiteDN())) {
                            // We've examined all connections that source from this site
                            break;
                        }
                        if( pcn2->Supercedes(pcn) ) {
                            // pcn is unnecessary, since it is superceded by pcn2
                            cConnectionsInClass++;
                            if ( (!pLocalSite->BuildRedundantServerTopology()) ||
                                 (cConnectionsInClass > NTDSSETTINGS_DEFAULT_SERVER_REDUNDANCY) ) {
                                fRemove=TRUE;
                                break;
                            }
                            else {
                                pcn->SetReasonForConnection(NTDSCONN_KCC_REDUNDANT_SERVER_TOPOLOGY);
                                LOG_CONN_REDUNDANT;
                            }
                        } else {
                            // pcn2 does not supercede pcn.  In this case pcn should not
                            // supercede pcn2, either (else our sort is incorrect). 
                            Assert( !pcn->Supercedes(pcn2) );
                        }
                    }
                    
                }
            } else {

                // The source site is unreachable
                fDontUpdateReason = TRUE;

            }
        }

        if( fRemove &&
            (!gConnectionDeletionCache.PreventRepeatedDeletion(
                pcn, DSID(FILENO, __LINE__) )) ) {
            // This connection was determined to be superfluous. Remove it.
            KccRemoveIntersiteConnection(pcn, DSID(FILENO,__LINE__));
        } else if( !fDontUpdateReason ) {
            pcn->UpdateReason();
        }

    }
}


#if DBG
VOID
KccCheckSite(
    IN KCC_SITE *Site
    )
/*++

Routine Description:
    
    This routine does some sanity checking of the Site and
    connections to other sites

Parameters:

    Site  - pointer to site object
    
Returns:

    Nothing

--*/
{
    KCC_SITE_CONNECTION *SiteConn = NULL;
    KCC_SITE            *OtherSite;
    ULONG                iEdge, cEdges;

    ASSERT_VALID( Site );


    for ( iEdge = 0, cEdges = Site->NumberOfOutEdges();
            iEdge < cEdges;
                iEdge++ )
    {
        SiteConn =  (KCC_SITE_CONNECTION *) Site->GetOutEdge( iEdge );
        ASSERT_VALID( SiteConn );

        OtherSite = (KCC_SITE*) SiteConn->GetFrom();
        ASSERT_VALID( OtherSite );
        Assert( OtherSite == Site ); 

        OtherSite = (KCC_SITE*) SiteConn->GetTo();
        ASSERT_VALID( OtherSite );
    }

    for ( iEdge = 0, cEdges = Site->NumberOfInEdges();
            iEdge < cEdges;
                iEdge++ )
    {
        KCC_SITE *ToSite;

        SiteConn =  (KCC_SITE_CONNECTION *) Site->GetInEdge( iEdge );
        ASSERT_VALID( SiteConn );

        OtherSite = (KCC_SITE*) SiteConn->GetFrom();
        ASSERT_VALID( OtherSite );

        OtherSite = (KCC_SITE*) SiteConn->GetTo();
        ASSERT_VALID( OtherSite );
        Assert( OtherSite == Site ); 

    }

    return;

}
#endif // #if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\kccstale.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kccstale.cxx

ABSTRACT:

    KCC_LINK_FAILURE_CACHE class.
    KCC_CONNECTION_FAILURE_CACHE class.

DETAILS:

    This class is holds information pertaining to staleness of the servers
    that the current dsa currently replicated with. Essentially given the ds name
    of an msft-dsa object that this server may replicate with, this class with have 
    methods that indicate whether the particular msft-dsa is a useful replication
    partner.                                                             
    

CREATED:

    10/20/97    Colin Brace (ColinBr)

REVISION HISTORY:

--*/

#include <ntdspchx.h>
#include "kcc.hxx"
#include "kccdsa.hxx"
#include "kcclink.hxx"
#include "kccconn.hxx"
#include "kcctools.hxx"
#include "kccstale.hxx"
#include "kccstetl.hxx"
#include <dsconfig.h>
#include <dsutil.h>

#define FILENO FILENO_KCC_KCCTOPL

//
// Some small helper functions
//
BOOL
KccExtractCacheInfo(
    IN  PCACHE_ENTRY pEntry,
    OUT ULONG  *     TimeSinceFirstFailure,    OPTIONAL
    OUT ULONG  *     NumberOfFailures,         OPTIONAL
    OUT BOOL   *     fUserNotifiedOfStaleness, OPTIONAL
    OUT DWORD  *     pdwLastResult,            OPTIONAL
    OUT BOOL   *     pfErrorOccurredThisRun    OPTIONAL
    )
{
    if ( pEntry )
    {
        if ( TimeSinceFirstFailure )
        {
            *TimeSinceFirstFailure = (ULONG)(GetSecondsSince1601() -
                                             pEntry->TimeOfFirstFailure);
        }

        if ( NumberOfFailures )
        {
            *NumberOfFailures = pEntry->NumberOfFailures;
        }

        if ( fUserNotifiedOfStaleness )
        {
            *fUserNotifiedOfStaleness = pEntry->fUserNotifiedOfStaleness;
        }

        if ( pdwLastResult )
        {
            *pdwLastResult = pEntry->dwLastResult;
        }

        if( pfErrorOccurredThisRun )
        {
            *pfErrorOccurredThisRun = pEntry->fErrorOccurredThisRun;
        }

        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

DWORD
KccAssignStatusImportance(
    IN DWORD dwStatus
    )
// Compute an integer according to how bad the status is
{
    DWORD dwWeight = 0;

    switch (dwStatus) {

        // Same as no value - least importance
    case ERROR_SUCCESS:
        dwWeight = 0;
        break;

        // Normal errors
    case ERROR_DS_DRA_REPL_PENDING:
    case ERROR_DS_DRA_PREEMPTED:
    case ERROR_DS_DRA_ABANDON_SYNC:
    case ERROR_DS_DRA_SHUTDOWN:
        dwWeight = 1;
        break;

        // Call not made errors
    case RPC_S_SERVER_UNAVAILABLE:
    case ERROR_DS_DNS_LOOKUP_FAILURE:
    case ERROR_DS_DRA_RPC_CANCELLED:
    case EPT_S_NOT_REGISTERED:
        dwWeight = 2;
        break;

        // Call failed type errors
    case ERROR_DS_DRA_OUT_OF_MEM:
    case ERROR_NOT_ENOUGH_MEMORY:
    case ERROR_BUSY:
    case ERROR_DS_DRA_BUSY:
    case ERROR_DS_DRA_SCHEMA_INFO_SHIP:
    case ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT:
    case ERROR_DS_DRA_SCHEMA_MISMATCH:
    case ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET:
    case ERROR_DS_DRA_SOURCE_IS_PARTIAL_REPLICA:
    case ERROR_DS_DRA_SOURCE_DISABLED:
    case ERROR_DS_DRA_SINK_DISABLED:
    case RPC_S_SERVER_TOO_BUSY:
    case RPC_S_CALL_FAILED:
        dwWeight = 3;
        break;

        // Security type errors
    case ERROR_TIME_SKEW:
    case ERROR_DS_DRA_ACCESS_DENIED:
    case ERROR_LOGON_FAILURE:
    case ERROR_WRONG_TARGET_NAME:
    case ERROR_DOMAIN_CONTROLLER_NOT_FOUND:
    case ERROR_ENCRYPTION_FAILED:
    case ERROR_ACCESS_DENIED:
    case ERROR_NOT_AUTHENTICATED:
    case ERROR_INVALID_PASSWORD:
    case ERROR_PASSWORD_EXPIRED:
    case ERROR_ACCOUNT_DISABLED:
    case ERROR_ACCOUNT_LOCKED_OUT:
        dwWeight = 3;
        break;

        // Everything else
    default:
        dwWeight = 100;
    }

    return dwWeight;
}

//
// Method definitions
// 


VOID
KCC_CACHE_LINKED_LIST::Add(
    IN PCACHE_ENTRY pEntry
    )
// Put the entry in the linked list
{
    ASSERT_VALID(this);
    Assert(OWN_RESOURCE_EXCLUSIVE(&m_resLock));

    Assert( pEntry );
    if ( pEntry )
    {           
        PushEntryList( &m_ListHead, &(pEntry->Link) );
    }
}

PCACHE_ENTRY
KCC_CACHE_LINKED_LIST::Find(
    IN  GUID   *    pGuid,
    IN  BOOL        fDelete
    )
// Find the entry in the linked list and delete if asked to
{

    PCACHE_ENTRY pEntry = NULL;
    PCACHE_ENTRY pLastEntry = NULL;

    ASSERT_VALID( this );
    Assert(OWN_RESOURCE_EXCLUSIVE(&m_resLock)
           || (!fDelete && OWN_RESOURCE_SHARED(&m_resLock)));
    Assert( pGuid );

    if ( !m_ListHead.Next )
    {
        // empty list - CONTAINING_RECORD does not detect this
        return NULL;
    }

    pEntry = CONTAINING_RECORD(m_ListHead.Next,
                               CACHE_ENTRY,
                               Link);

    pLastEntry = pEntry;

    while ( pEntry )
    {

        if ( KccIsEqualGUID( &pEntry->Guid,
                             pGuid ) )
        {
            //
            // This is it
            //
            break;
        }
        else 
        {
            pLastEntry = pEntry;

            if ( pEntry->Link.Next )
            {
                pEntry = CONTAINING_RECORD(pEntry->Link.Next,
                                           CACHE_ENTRY,
                                           Link);
            } 
            else 
            {
                pEntry = NULL;
            }

        }
        
    }

    if ( fDelete && pEntry )
    {

        //
        // Remove this entry from the list
        // 

        if ( pEntry == pLastEntry )
        {
            Assert( &(pEntry->Link) == m_ListHead.Next );
            m_ListHead.Next = pEntry->Link.Next;
        }
        else
        {
            pLastEntry->Link.Next = pEntry->Link.Next;
        }
        
    }

    return pEntry;
}

PCACHE_ENTRY
KCC_CACHE_LINKED_LIST::Pop(
    VOID
    )
// Pop the first entry from the list
{
    PCACHE_ENTRY       pEntry = NULL;
    PSINGLE_LIST_ENTRY pLink;

    ASSERT_VALID( this );
    Assert(OWN_RESOURCE_EXCLUSIVE(&m_resLock));

    pLink =  PopEntryList(&m_ListHead);

    if ( pLink )
    {
        pEntry = CONTAINING_RECORD(pLink,
                                   CACHE_ENTRY,
                                   Link);
    }

    return pEntry;

}

VOID
KCC_CACHE_LINKED_LIST::IncrementFailureCounts(
    VOID
    )
// Increment the failure count for every entry in the cache
{

    PCACHE_ENTRY pEntry = NULL;

    ASSERT_VALID( this );
    Assert(OWN_RESOURCE_EXCLUSIVE(&m_resLock));

    if ( !m_ListHead.Next )
    {
        // empty list - CONTAINING_RECORD does not detect this
        return;
    }

    pEntry = CONTAINING_RECORD(m_ListHead.Next,
                               CACHE_ENTRY,
                               Link);

    while ( pEntry )
    {

        pEntry->NumberOfFailures++;

        if ( pEntry->Link.Next )
        {
            pEntry = CONTAINING_RECORD(pEntry->Link.Next,
                                       CACHE_ENTRY,
                                       Link);
        } 
        else 
        {
            pEntry = NULL;
        }
    }

    return;
}

void
KCC_CACHE_LINKED_LIST::ResetFailureCounts()
//
// Reset all failure counts in the cache (but preserve the entries and in
// particular the flag telling us if an event has been logged).
//
{
    SINGLE_LIST_ENTRY * pList = m_ListHead.Next;
    
    ASSERT_VALID(this);
    Assert(OWN_RESOURCE_EXCLUSIVE(&m_resLock));

    while (NULL != pList) {
        PCACHE_ENTRY pEntry = CONTAINING_RECORD(pList, CACHE_ENTRY, Link);
        pEntry->NumberOfFailures = 0;

        pList = pEntry->Link.Next;
    }
}

BOOL
KCC_CACHE_LINKED_LIST::IsValid()
{
    return m_fIsInitialized;
}

BOOL
KCC_CACHE_LINKED_LIST::Init()
// Empty the list and start from scratch
{
    RtlZeroMemory( &m_ListHead, sizeof(SINGLE_LIST_ENTRY) );

    __try {
        RtlInitializeResource(&m_resLock);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        LogUnhandledError(GetExceptionCode());
        return FALSE;
    }

    m_fIsInitialized = TRUE;

    return m_fIsInitialized;
}

BOOL
KCC_CACHE_LINKED_LIST::ResetUserNotificationFlag(
    IN  DSNAME *    pdnFromServer
    )
// Set the fUserNotifiedOfStaleness to FALSE on pdnFromServer
{

    PCACHE_ENTRY pEntry;

    ASSERT_VALID(this);
    Assert(OWN_RESOURCE_EXCLUSIVE(&m_resLock));

    if ( pdnFromServer )
    {
        pEntry = Find( pdnFromServer, 
                       FALSE ); // don't delete the entry
    
        if ( pEntry )
        {
            pEntry->fUserNotifiedOfStaleness = FALSE;
    
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }

    return FALSE;

}

DWORD
KCC_CACHE_LINKED_LIST::Extract(
    OUT DS_REPL_KCC_DSA_FAILURESW **  ppFailures
    )
/*++

Routine Description:

    Returns the contents of the cache in external form.

Arguments:

    ppFailures (OUT) - On successful return, holds the external form of the
        contents of the cache.
    
Return Values:

    Win32 error code.

--*/
{
    SINGLE_LIST_ENTRY * pList;
    PCACHE_ENTRY pEntry = NULL;
    DWORD cNumEntries;
    DWORD cbFailures;
    DS_REPL_KCC_DSA_FAILUREW * pFailure;
    
    ASSERT_VALID(this);
    Assert(OWN_RESOURCE_EXCLUSIVE(&m_resLock)
           || OWN_RESOURCE_SHARED(&m_resLock));

    // Count the number of entries.  Yes, we should probably maintain a count.
    cNumEntries = 0;
    for (pList = m_ListHead.Next; NULL != pList; pList = pList->Next) {
        cNumEntries++;
    }

    cbFailures = offsetof(DS_REPL_KCC_DSA_FAILURESW, rgDsaFailure)
                 + cNumEntries * sizeof((*ppFailures)->rgDsaFailure[0]);
    
    *ppFailures = (DS_REPL_KCC_DSA_FAILURESW *) new BYTE[cbFailures];
    (*ppFailures)->cNumEntries = cNumEntries;

    // Add each entry to the list.
    for (pList = m_ListHead.Next, pFailure = &(*ppFailures)->rgDsaFailure[0];
         NULL != pList;
         pList = pList->Next, pFailure++) {
        pEntry = CONTAINING_RECORD(pList, CACHE_ENTRY, Link);
        
        DSTimeToFileTime(pEntry->TimeOfFirstFailure,
                         &pFailure->ftimeFirstFailure);
        
        pFailure->cNumFailures   = pEntry->NumberOfFailures;
        pFailure->uuidDsaObjGuid = pEntry->Guid;
        pFailure->dwLastResult   = pEntry->dwLastResult;
    }

    return 0;
}


VOID
KCC_CACHE_LINKED_LIST::Dump(
    BOOL ( *IsStale )( DSNAME * ) OPTIONAL
    )
// Prints out the current list via DPRINT
{

    PCACHE_ENTRY       pEntry;
    PSINGLE_LIST_ENTRY pLink;

    ULONG              rpcStatus;

    ULONG              TimeElasped;
    WCHAR              *GuidString;
    WCHAR              *DefaultGuidString = L"Unreadable guid";
    DSNAME             DsName;

    ASSERT_VALID( this );
    Assert(OWN_RESOURCE_EXCLUSIVE(&m_resLock)
           || OWN_RESOURCE_SHARED(&m_resLock));

    pLink = m_ListHead.Next;

    while ( pLink )
    {

        pEntry = CONTAINING_RECORD(pLink,
                                   CACHE_ENTRY,
                                   Link);

        TimeElasped = (ULONG)(GetSecondsSince1601() - pEntry->TimeOfFirstFailure);

        rpcStatus = UuidToStringW( &(pEntry->Guid),  &GuidString );

        if ( 0 != rpcStatus )
        {
            GuidString = DefaultGuidString;
        }

        DPRINT1( 0, "\tGuid: %ws\n", GuidString);
        DPRINT1( 0, "\tTime Elasped: %d\n", TimeElasped );
        DPRINT1( 0, "\tFailureCount: %d\n", pEntry->NumberOfFailures);
        DPRINT1( 0, "\tLastResult: %d\n", pEntry->dwLastResult);
        DPRINT1( 0, "\tUser Has Been Notified: %d\n", pEntry->fUserNotifiedOfStaleness );

        if ( IsStale )
        {
            //
            // Construct a guid only dsname
            //
            RtlZeroMemory( &DsName, sizeof( DSNAME ) );

            DsName.structLen = DSNameSizeFromLen( 0 );

            RtlCopyMemory( &DsName.Guid, &(pEntry->Guid), sizeof(GUID) );

            if ( (*IsStale)( &DsName ) )
            {
                DPRINT( 0, "\tStatus: Stale\n" );
            }
            else 
            {
                DPRINT( 0, "\tStatus: Not Stale\n" );
            }
        }

        DPRINT( 0, "\n" );
    

        if ( 0 == rpcStatus )
        {
            RpcStringFreeW( &GuidString );
        }

        pLink = pEntry->Link.Next;
        
    }

    //
    // Empty case
    //
    if ( !m_ListHead.Next )
    {
        DPRINT( 0, "\t< Empty >\n" );
        DPRINT( 0, "\n" );
    }

    return;
}

#if DBG
BOOL
KCC_CACHE_LINKED_LIST::RefreshFromRegistry(
    IN  LPSTR   pszRegKey
    )
//
// Test hook -- read stale server list from the registry.
//
// Reads REG_MULTI_SZ strings from the registry in the format:
//      <ntdsDsa guid>,<dsTime of first failure/last success>,<num failures>,<event generated>
// e.g., "04baf40a-8f0c-11d2-b38b-0000f87a46c8,12557642897,5,0".
//
{
    HKEY          hk;
    BOOL          fSuccess = FALSE;
    CHAR *        pchVals = NULL;
    DWORD         cbVals;
    DWORD         dwType;
    LPSTR         pszVal;
    DWORD         err;
    CACHE_ENTRY * pEntry;

    Assert(OWN_RESOURCE_EXCLUSIVE(&m_resLock));
    
    err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                       DSA_CONFIG_SECTION,
                       0,
                       KEY_ALL_ACCESS,
                       &hk);
    if (err) {
        return FALSE;
    }

    __try {
        err = RegQueryValueEx(hk, pszRegKey, NULL, &dwType, NULL, &cbVals);
        if (err) {
            __leave;
        }

        pchVals = (CHAR *) new BYTE[cbVals];
        
        err = RegQueryValueEx(hk, pszRegKey, NULL, &dwType, (BYTE *) pchVals, &cbVals);
        if (err) {
            __leave;
        }

        if (REG_MULTI_SZ != dwType) {
            Assert(!"Test failure -- stale cache reg value must be REG_MULTI_SZ!");
            __leave;
        }

        // Clear out the current contents of the cache.
        while (pEntry = Pop()) {
            free(pEntry);
        }

        // Iterate through each string in the multi-valued list.
        for (pszVal = pchVals; '\0' != *pszVal; pszVal += strlen(pszVal) + 1) {
            CHAR            szGuid[37];
            ULONGLONG       dsTime;
            ULONG           cNumFailures;
            BOOL            fUserNotified;
            GUID            Guid;

            if (4 > sscanf(pszVal, "%36s,%I64u,%u,%u", szGuid, &dsTime,
                           &cNumFailures, &fUserNotified)) {
                DPRINT1(0, "Bad stale cache reg entry: \"%s\"\n", pszVal);
                Assert(!"Test failure -- bad stale cache reg value!");
                __leave;
            }

            err = UuidFromString((UCHAR *) szGuid, &Guid);
            if (err) {
                DPRINT2(0, "Bad guid \"%s\" in stale cache reg entry: \"%s\"\n",
                        szGuid, pszVal);
                Assert(!"Test failure -- bad stale cache reg value!");
                __leave;
            }

            pEntry = Find(&Guid, FALSE);

            if (NULL == pEntry) {
                // Entry does not yet exist -- add it.
                pEntry = (CACHE_ENTRY *) malloc(sizeof(CACHE_ENTRY));
                if (NULL == pEntry) {
                    KCC_MEM_EXCEPT(sizeof(CACHE_ENTRY));
                }
            
                memset(pEntry, 0, sizeof(CACHE_ENTRY));
                pEntry->Guid = Guid;
            
                Add(pEntry);
            }
                
            Assert(0 == memcmp(&Guid, &pEntry->Guid, sizeof(GUID)));
            
            pEntry->TimeOfFirstFailure       = dsTime;
            pEntry->NumberOfFailures         = cNumFailures;
            pEntry->fUserNotifiedOfStaleness = fUserNotified;
        }

        DPRINT1(0, "Stale cache initialized from key %s.\n", pszRegKey);
        fSuccess = TRUE;
    }
    __finally {
        if (NULL != pchVals) {
            delete [] pchVals;
        }
        
        RegCloseKey(hk);
    }

    return fSuccess;
}
#endif

void
KCC_LINK_FAILURE_CACHE::UpdateEntry(
    IN  GUID *  pDsaObjGuid,
    IN  DSTIME  timeLastSuccess,
    IN  DWORD   cNumConsecutiveFailures,
    IN  DWORD   dwLastResult,
    IN  BOOL    fImported
    )
//
// Update entry in the cache (creating it if necessary).
// fImported should be set to TRUE (its default value) if this failure
// was imported from a bridgehead.
//
{
    m_List.AcquireLockExclusive();

    __try {
        UpdateEntryLockHeld(pDsaObjGuid,
                            timeLastSuccess,
                            cNumConsecutiveFailures,
                            dwLastResult,
                            fImported);
    }
    __finally {
        m_List.ReleaseLock();
    }
}

void
KCC_LINK_FAILURE_CACHE::UpdateEntryLockHeld(
    IN  GUID *  pDsaObjGuid,
    IN  DSTIME  timeLastSuccess,
    IN  DWORD   cNumConsecutiveFailures,
    IN  DWORD   dwLastResult,
    IN  BOOL    fImported
    )
//
// Update entry in the cache (creating it if necessary).
// Assumes exclusive lock is already held.
//
{
    PCACHE_ENTRY pEntry;

    if (!cNumConsecutiveFailures) {
        // No failures, no need to cache.
        return;
    }

    pEntry = m_List.Find( pDsaObjGuid,
                          FALSE // don't delete
                          );

    if ( pEntry )
    {
        if ( 0 == pEntry->NumberOfFailures )
        {
            //
            // Entry exists - replace with new data
            //
            pEntry->TimeOfFirstFailure = timeLastSuccess;
            pEntry->NumberOfFailures = cNumConsecutiveFailures;
            pEntry->dwLastResult = dwLastResult;

            // Since the number of failures is 0, we can consider this an
            // abandoned entry, so we set the fEntryIsImported flag to be in
            // accordance with this new failure information.
            // First check that the current value is not garbage though
            Assert( pEntry->fEntryIsImported==!!pEntry->fEntryIsImported );
            pEntry->fEntryIsImported = !!fImported;
        }
        else 
        {
            //
            // Entry exists - replace with worse data if possible
            //
            if ( pEntry->TimeOfFirstFailure < timeLastSuccess )
            {
                pEntry->TimeOfFirstFailure = timeLastSuccess;
            }

            if ( pEntry->NumberOfFailures < cNumConsecutiveFailures )
            {
                pEntry->NumberOfFailures = cNumConsecutiveFailures;
            }

            if ( KccAssignStatusImportance( pEntry->dwLastResult ) <
                 KccAssignStatusImportance( dwLastResult ) ) {
                pEntry->dwLastResult = dwLastResult;
            }

            // Since non-imported trumps imported, set fEntryIsImported to FALSE
            // if fImported is false. Check that the current value is not garbage first
            Assert( pEntry->fEntryIsImported==!!pEntry->fEntryIsImported );
            if( !fImported ) {
                pEntry->fEntryIsImported = FALSE;
            }
        }
        
        // No need to set fErrorOccurredThisRun or fUnneeded here -- any entry
        // in the cache should already have these field set to FALSE
        Assert( !pEntry->fErrorOccurredThisRun );
        Assert( !pEntry->fUnneeded );
    }
    else
    {
        //
        // New entry
        //

        pEntry = (PCACHE_ENTRY) malloc( sizeof( CACHE_ENTRY ) );
        if (NULL == pEntry) {
            KCC_MEM_EXCEPT(sizeof(CACHE_ENTRY));
        }

        memset( pEntry, 0, sizeof( CACHE_ENTRY ) );

        RtlCopyMemory( &pEntry->Guid, pDsaObjGuid, sizeof(GUID) );

        pEntry->TimeOfFirstFailure = timeLastSuccess;
        pEntry->NumberOfFailures = cNumConsecutiveFailures;
        pEntry->dwLastResult = dwLastResult;
        pEntry->fUserNotifiedOfStaleness = FALSE;

        // fErrorOccurredThisRun and fUnneeded are not used in the
        // link-failure cache so we just set them to FALSE.
        pEntry->fErrorOccurredThisRun = FALSE;
        pEntry->fUnneeded = FALSE;

        // Set the fEntryIsImported flag appropriately for this new failure.
        pEntry->fEntryIsImported = !!fImported;

        m_List.Add( pEntry );
    }
}

void
KCC_LINK_FAILURE_CACHE::UpdateEntry(
    IN  DS_REPL_KCC_DSA_FAILUREW *  pFailure
    )
//
// Update entry in the cache (creating it if necessary).
//
{
    DSTIME dsTime;

    if (pFailure && pFailure->cNumFailures) {
        FileTimeToDSTime(pFailure->ftimeFirstFailure, &dsTime);
        
        UpdateEntry(&pFailure->uuidDsaObjGuid,
                    dsTime,
                    pFailure->cNumFailures,
                    pFailure->dwLastResult );
    }
}

BOOL
KCC_LINK_FAILURE_CACHE::Refresh(
    VOID
    )
// Reads in the current reps-from info to make a cache
// of all from servers and their current state.
{
    BOOL        fSuccess;
    ULONG       NCCount, NCIndex;
    ULONG       RepsFromCount, RepsFromIndex;
    DSNAME *    pdnNC;
    KCC_DSA *   pLocalDSA = gpDSCache->GetLocalDSA();

    m_List.AcquireLockExclusive();

    __try {
#if DBG
        if (m_List.RefreshFromRegistry(KCC_LINK_FAILURE_KEY)) {
            // Test hook -- stale servers were enumerated in the registry.
            return TRUE;
        }
#endif
        //
        // Assume the worst
        //
        fSuccess = FALSE;
    
        NCCount = pLocalDSA->GetNCCount();
    
        // Reset failure counts of existing cache entries, so that we can
        // re-seed the cache with fresh failure counts/times.  (And still
        // maintain the "has event been logged" state.)
        m_List.ResetFailureCounts();
    
        for ( NCIndex = 0; NCIndex < NCCount; NCIndex++ )
        {
            KCC_CROSSREF  *pCrossRef;
            KCC_LINK_LIST *pLinkList, *pLinkListNotCached=NULL;
            KCC_LINK      *pLink;
    
            pdnNC = pLocalDSA->GetNC( NCIndex );
            Assert( pdnNC );

            //
            // Retrieve the reps-froms for this naming context
            //

            // Find the link list for this NC
            pCrossRef = gpDSCache->GetCrossRefList()->GetCrossRefForNC(pdnNC);
            if (NULL == pCrossRef) {
                // Local NC with no corresponding crossRef.
                pLinkList = new KCC_LINK_LIST;
                if (pLinkList->Init(pdnNC)) {
                    // Remember to free this later.
                    pLinkListNotCached = pLinkList;
                } else {
                    // Failed to initialize list (e.g., DS error, memory pressure,
                    // etc.).
                    delete pLinkList;
                    pLinkList = NULL;
                }
            } else {
                // NC has a corresponding crossRef -- get the cached link list.
                pLinkList = pCrossRef->GetLinkList();
            }
    
            if ( !pLinkList ) {
                goto End;
            }
    
            RepsFromCount = pLinkList->GetCount();
    
            for ( RepsFromIndex = 0; RepsFromIndex < RepsFromCount; RepsFromIndex++ )
            {
                PCACHE_ENTRY pEntry;
                GUID* pSourceDSAGUID;
                KCC_DSA* pSourceDsa;
                
                pLink = pLinkList->GetLink( RepsFromIndex );
                Assert( pLink );

                // Try to find the DSA object for the source DSA of this link
                pSourceDSAGUID = pLink->GetDSAUUID();
                pSourceDsa = gpDSCache->GetDSAByGUID( pSourceDSAGUID );

                if( NULL==pSourceDsa ) {
                    // The source DSA of this replication link is not in our list of DSAs.
                    // The DSA must have been deleted. We don't bother keeping failure
                    // entries for deleted DSAs. Note that the entry may or may not exist
                    // but we try to remove it anyways.
                    RemoveLockHeld(pSourceDSAGUID);
                } else {
                    UpdateEntryLockHeld(pSourceDSAGUID,
                                        pLink->GetTimeOfLastSuccess(),
                                        pLink->GetConnectFailureCount(),
                                        pLink->GetLastResult(),
                                        FALSE);
                }
            }

            // Free the link list if we did not get it from the cache
            if( pLinkListNotCached ) {
                delete pLinkListNotCached;
                pLinkListNotCached = NULL;
            }
        }
    }
    __finally {
        m_List.ReleaseLock();
    }

    fSuccess = TRUE;

End:

    return fSuccess;
}

BOOL
KCC_LINK_FAILURE_CACHE::Get(
    IN  DSNAME *    pdnFromServer,
    OUT ULONG  *    TimeSinceFirstFailure,    OPTIONAL
    OUT ULONG  *    NumberOfFailures,         OPTIONAL
    OUT BOOL   *    fUserNotifiedOfStaleness, OPTIONAL
    OUT DWORD  *    LastResult                OPTIONAL
    )
// Return the data of the ENTRY if it exists
{

    PCACHE_ENTRY pEntry;
    BOOL bReturn = FALSE;

    ASSERT_VALID(this);

    m_List.AcquireLockShared();
    
    __try {
        pEntry = m_List.Find(pdnFromServer, 
                             FALSE  // don't delete the entry
                             );
    
        if ( pEntry )
        {
            KccExtractCacheInfo(pEntry,
                                TimeSinceFirstFailure,
                                NumberOfFailures,
                                fUserNotifiedOfStaleness,
                                LastResult,
                                NULL
                                );
    
            bReturn = TRUE;        
        }
    }
    __finally {
        m_List.ReleaseLock();
    }

    return bReturn;
}

BOOL
KCC_LINK_FAILURE_CACHE::Remove(
    IN  GUID *    pGuid
    )
// Remove pdnFromServer from the cache
{
    PCACHE_ENTRY pEntry;
    BOOL bReturn = FALSE;

    ASSERT_VALID(this);

    m_List.AcquireLockExclusive();

    __try {
        bReturn = RemoveLockHeld( pGuid );
    }
    __finally {
        m_List.ReleaseLock();
    }

    return bReturn;
}

BOOL
KCC_LINK_FAILURE_CACHE::RemoveLockHeld(
    IN  GUID *    pGuid
    )
//
// Remove the cache entry by guid
// Assumes exclusive lock is already held.
//
{
    PCACHE_ENTRY pEntry;

    ASSERT_VALID(this);
    Assert( pGuid );

    // If the second parameter to Find() is true, the entry is removed from the list.
    pEntry = m_List.Find(pGuid, TRUE);
    
    if( pEntry ) {
        // pEntry was successfully removed
        free( pEntry );

        // Assert that the entry is no longer in the list
        ASSERT( NULL==m_List.Find(pGuid, FALSE) );
        return TRUE;
    }

    // Failed to find the entry
    return FALSE;
}

KCC_LINK_FAILURE_CACHE::NotifyUserOfStaleness(
    IN  DSNAME *    pdnFromServer
    )
// Make an event log entry indicating the KCC thinks a server is stale
{

    PCACHE_ENTRY pEntry;
    BOOL bReturn = FALSE;
    ULONG        FailureTimeInMinutes;

    ASSERT_VALID(this);

    m_List.AcquireLockExclusive();

    __try {
        pEntry = m_List.Find(pdnFromServer, 
                             FALSE  // don't delete the entry
                             );
    
        if ( pEntry )
        {
            //
            // If the user hasn't been notified and there is a name associated
            // with this dsname, do it.
            //
            if ( !pEntry->fUserNotifiedOfStaleness && pdnFromServer->NameLen > 0 )
            {
    
                FailureTimeInMinutes = (ULONG)(GetSecondsSince1601() -
                                               pEntry->TimeOfFirstFailure);
                FailureTimeInMinutes /= 60;    
    
                LogEvent8(DS_EVENT_CAT_KCC,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_KCC_REPLICA_LINK_DOWN,
                          szInsertUL( pEntry->NumberOfFailures ),
                          szInsertDN( pdnFromServer ),
                          szInsertUL( FailureTimeInMinutes ),
                          szInsertWin32Msg( pEntry->dwLastResult ),
                          szInsertWin32ErrCode( pEntry->dwLastResult ),
                          NULL, NULL, NULL );
    
                pEntry->fUserNotifiedOfStaleness = TRUE;
                
            }
    
            bReturn = TRUE;
        }
    }
    __finally {
        m_List.ReleaseLock();
    }

    return bReturn;

}

BOOL
KCC_LINK_FAILURE_CACHE::IsValid(
    VOID
    )
// Is this object internally consistent?
{
    return m_fIsInitialized;
}

VOID
KCC_LINK_FAILURE_CACHE::Reset(
    VOID
    )
{
    m_fIsInitialized = FALSE;
    return;
}

DWORD
KCC_LINK_FAILURE_CACHE::Extract(
    OUT DS_REPL_KCC_DSA_FAILURESW **  ppFailures
    )
{
    DWORD winError;

    m_List.AcquireLockShared();

    __try {
        winError = m_List.Extract(ppFailures);
    }
    __finally {
        m_List.ReleaseLock();
    }

    return winError;
}

VOID
KCC_LINK_FAILURE_CACHE::Dump(
    VOID
    )
// Prints out the current list via DPRINT
{
    DPRINT( 0, "This is the cache of servers with whom we have established\n" );
    DPRINT( 0, "a replication link.\n");
    DPRINT( 0, "\n");

    m_List.AcquireLockShared();

    __try {
        // Now dump the list
        m_List.Dump( KccCriticalLinkServerIsStale );
    }
    __finally {
        m_List.ReleaseLock();
    }

    return;
}

BOOL
KCC_LINK_FAILURE_CACHE::ResetUserNotificationFlag(
    IN  DSNAME *    pdnFromServer
    )
{
    BOOL fSuccess;

    m_List.AcquireLockExclusive();

    __try {
        fSuccess = m_List.ResetUserNotificationFlag( pdnFromServer );
    }
    __finally {
        m_List.ReleaseLock();
    }

    return fSuccess;
}


BOOL
KCC_CONNECTION_FAILURE_CACHE::Add(
    IN  DSNAME *    pdnFromServer,
    IN  DWORD       dwLastResult,
    IN  BOOL        fImported
    )
// Add to the cache if it is not there.
// The fImported flag indicates if the error was caused by a DirReplicaAdd()
// or DsBind() operation performed at the _local_ DSA, or if the error was
// imported from a bridgehead.
{

    PCACHE_ENTRY pEntry;
    BOOL bReturn = FALSE;

    ASSERT_VALID(this);

    m_List.AcquireLockExclusive();

    __try {
        pEntry = m_List.Find(pdnFromServer, 
                             FALSE  // don't delete the entry
                             );
    
        if ( !pEntry )
        {
            //
            // No entry exists, create one with initial values
            //
            pEntry = (PCACHE_ENTRY) malloc(sizeof(CACHE_ENTRY));
            if ( pEntry )
            {
                memset(pEntry, 0, sizeof(CACHE_ENTRY));
                pEntry->TimeOfFirstFailure = GetSecondsSince1601();
                pEntry->NumberOfFailures = 0;
                memcpy(&pEntry->Guid, &pdnFromServer->Guid, sizeof(GUID));
                pEntry->dwLastResult = dwLastResult;
                pEntry->fEntryIsImported = fImported;

                //
                // Put the entry in the cache
                //
                m_List.Add( pEntry );
            }
        }
    
        //
        // Return TRUE if the addition was successful
        //
        if ( pEntry )
        {
            bReturn = TRUE;
            
            // Check that the 'imported' flag is not garbage
            Assert( pEntry->fEntryIsImported==!!pEntry->fEntryIsImported );

            if( !fImported ) {
                pEntry->fErrorOccurredThisRun = TRUE;
                pEntry->fEntryIsImported = FALSE;
            }

            // Clear the unneeded flag on this entry, if it was set
            pEntry->fUnneeded = FALSE;
        }
    }
    __finally {
        m_List.ReleaseLock();
    }

    return bReturn;

}
    
void
KCC_CONNECTION_FAILURE_CACHE::UpdateEntry(
    IN  DS_REPL_KCC_DSA_FAILUREW *  pFailure
    )
//
// Update entry in the cache (creating it if necessary).
//
{
    DSTIME dsTime;

    if (pFailure && pFailure->cNumFailures) {
        DSNAME dn = {0};

        dn.structLen = DSNameSizeFromLen(0);
        dn.NameLen = 0;
        dn.Guid = pFailure->uuidDsaObjGuid;

        Add(&dn, pFailure->dwLastResult, TRUE);
    }
}

BOOL
KCC_CONNECTION_FAILURE_CACHE::Get(
    IN  DSNAME *    pdnFromServer,
    OUT ULONG  *    TimeSinceFirstFailure,    OPTIONAL
    OUT ULONG  *    NumberOfFailures,         OPTIONAL
    OUT BOOL   *    fUserNotifiedOfStaleness, OPTIONAL
    OUT DWORD  *    pdwLastResult,            OPTIONAL
    OUT BOOL   *    pfErrorOccurredThisRun    OPTIONAL
    )
// Return the data of the ENTRY if it exists
{

    PCACHE_ENTRY pEntry;
    BOOL bReturn = FALSE;

    ASSERT_VALID(this);

    m_List.AcquireLockShared();

    __try {
        pEntry = m_List.Find(pdnFromServer, 
                             FALSE  // don't delete the entry
                             );
    
        if ( pEntry )
        {
            KccExtractCacheInfo(pEntry,
                                TimeSinceFirstFailure,
                                NumberOfFailures,
                                fUserNotifiedOfStaleness,
                                pdwLastResult,
                                pfErrorOccurredThisRun
                                );
    
            bReturn = TRUE;        
        }
    }
    __finally {
        m_List.ReleaseLock();
    }

    return bReturn;
}

BOOL
KCC_CONNECTION_FAILURE_CACHE::Remove(
    IN  DSNAME *    pdnFromServer
    )
// Remove pdnFromServer from the cache
{
    PCACHE_ENTRY pEntry;
    BOOL bReturn = FALSE;

    ASSERT_VALID(this);

    m_List.AcquireLockExclusive();

    __try {
        pEntry = m_List.Find(pdnFromServer, 
                             TRUE  // delete the entry
                             );
    
        if ( pEntry )
        {
            free( pEntry );
            bReturn = TRUE;
        }
    }
    __finally {
        m_List.ReleaseLock();
    }

    return bReturn;

}

BOOL
KCC_CONNECTION_FAILURE_CACHE::NotifyUserOfStaleness(
    IN  DSNAME *    pdnFromServer
    )
// Make an event log entry indicating the KCC thinks a server is stale
{

    PCACHE_ENTRY pEntry;
    ULONG        FailureTimeInMinutes;
    BOOL bReturn = FALSE;

    ASSERT_VALID(this);
    
    m_List.AcquireLockExclusive();

    __try {
        pEntry = m_List.Find(pdnFromServer, 
                             FALSE  // don't delete the entry
                             );
    
        if ( pEntry )
        {
            //
            // If the user hasn't been notified and there is a name associated
            // with this dsname, do it.
            //
            if ( !pEntry->fUserNotifiedOfStaleness && pdnFromServer->NameLen > 0 )
            {
    
                FailureTimeInMinutes = (ULONG)(GetSecondsSince1601() -
                                               pEntry->TimeOfFirstFailure);
                FailureTimeInMinutes /= 60;    
    
                LogEvent8(DS_EVENT_CAT_KCC,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_KCC_CONNECTION_NOT_INSTANTIATED,
                          szInsertUL( pEntry->NumberOfFailures ),
                          szInsertDN( pdnFromServer ),
                          szInsertUL( FailureTimeInMinutes ),
                          szInsertWin32Msg( pEntry->dwLastResult ),
                          szInsertWin32ErrCode(pEntry->dwLastResult ),
                          NULL, NULL, NULL );
    
                pEntry->fUserNotifiedOfStaleness = TRUE;
                
            }
    
            bReturn = TRUE;
        }
    }
    __finally {
        m_List.ReleaseLock();
    }

    return bReturn;

}

BOOL
KCC_CONNECTION_FAILURE_CACHE::ResetUserNotificationFlag(
    IN  DSNAME *    pdnFromServer
    )
{
    BOOL fSuccess;

    m_List.AcquireLockExclusive();

    __try {
        fSuccess = m_List.ResetUserNotificationFlag( pdnFromServer );
    }
    __finally {
        m_List.ReleaseLock();
    }

    return fSuccess;
}

VOID
KCC_CONNECTION_FAILURE_CACHE::IncrementFailureCounts(
    VOID
    )
{
    m_List.AcquireLockExclusive();

    __try {
        m_List.IncrementFailureCounts();
    }
    __finally {
        m_List.ReleaseLock();
    }
}

BOOL
KCC_CONNECTION_FAILURE_CACHE::IsValid(
    VOID
    )
// Is this object internally consistent?
{
    return m_fIsInitialized;
}

DWORD
KCC_CONNECTION_FAILURE_CACHE::Extract(
    OUT DS_REPL_KCC_DSA_FAILURESW **  ppFailures
    )
{
    DWORD winError;

    m_List.AcquireLockShared();

    __try {
        winError = m_List.Extract(ppFailures);
    }
    __finally {
        m_List.ReleaseLock();
    }

    return winError;
}

VOID
KCC_CONNECTION_FAILURE_CACHE::Dump(
    VOID
    )
// Prints out the current list via DPRINT
{

    DPRINT( 0, "This is the cache of servers that we have not been\n" );
    DPRINT( 0, "able to establish contact with.\n" );
    DPRINT( 0, "\n");

    m_List.AcquireLockShared();

    __try {
        // Now dump the list
        m_List.Dump( KccCriticalConnectionServerIsStale );
    }
    __finally {
        m_List.ReleaseLock();
    }
}


BOOL
KCC_CONNECTION_FAILURE_CACHE::Refresh(
    VOID
)
// Reverifies staleness of failed servers in the non-imported cache entries.
// This function also initializes members of the cache that must be reset
// on a per-run basis, such as 'fErrorOccurredThisRun'.
// DsBind() to each machine in non-imported cache entries.  If the bind
// succeeds, the DSA is deemed no longer stale.
// First we obtain a snapshot of the machines in the list, we validate those
// machines, and then we update the list. This is done so we do not hold the lock
// while going off machine and risking a deadlock.
{
    SINGLE_LIST_ENTRY * pList = NULL;
    PCACHE_ENTRY pEntry = NULL;
    GUID *rgguid = NULL;
    DWORD cGuid = 0, cAllocated = 0, iGuid;
    DSNAME DN = {0};
        
    Assert( this );

    // Pass I - Extract out the guids that need to be tested

    m_List.AcquireLockExclusive();

    __try {
#if DBG
        if (m_List.RefreshFromRegistry(KCC_CONNECTION_FAILURE_KEY)) {
            // Test hook -- stale servers were enumerated in the registry.
            return TRUE;
        }
#endif
        pList = m_List.m_ListHead.Next;
        while (NULL != pList) {
            pEntry = CONTAINING_RECORD(pList, CACHE_ENTRY, Link);
            pList = pEntry->Link.Next;

            // Initialize per-KCC-run members of the cache entry.
            pEntry->fErrorOccurredThisRun = FALSE;

            // Don't reverify staleness for imported entries
            if( pEntry->fEntryIsImported ) {
                continue;
            }
            
            Assert(!fNullUuid(&pEntry->Guid));

            if (cGuid == cAllocated) {
                if (cAllocated == 0) {
                    cAllocated = 16;
                    Assert( !rgguid );
                    rgguid = (GUID *) THAlloc( sizeof( GUID ) * cAllocated );
                } else {
                    cAllocated *= 2;
                    Assert( rgguid );
                    rgguid = (GUID *) THReAlloc( rgguid, sizeof( GUID ) * cAllocated );
                }
                if (!rgguid) {
                    KCC_MEM_EXCEPT( sizeof( GUID ) * cAllocated );
                }
            }

            memcpy( &(rgguid[cGuid]), &(pEntry->Guid), sizeof( GUID ) );
            cGuid++;
        }
    }
    __finally {
        m_List.ReleaseLock();
    }

    // Pass II - Test the guids and remove them if they respond

    DN.structLen = DSNameSizeFromLen(0);

    for (iGuid = 0; iGuid < cGuid; iGuid++ ) {
        LPWSTR pszDsaAddr;
        HANDLE hDS;
        DWORD err;

        Assert(!fNullUuid(&(rgguid[iGuid])));
        DN.Guid = rgguid[iGuid];
            
        pszDsaAddr = GuidBasedDNSNameFromDSName(&DN);
        if (NULL == pszDsaAddr) {
            KCC_MEM_EXCEPT(100);
        }
    
        err = DsBindW(pszDsaAddr, NULL, &hDS);
        if (0 == err) {
            DsUnBindW(&hDS);
                
            DPRINT1(0, "Contacted %ls -- removing from stale connection cache.\n",
                    pszDsaAddr);

            Remove( &DN );
        }
        THFree(pszDsaAddr);
    }

    if (rgguid) {
        THFree( rgguid );
    }

    return TRUE;
}

VOID
KCC_CONNECTION_FAILURE_CACHE::MarkUnneeded(
    IN  BOOL    fImported
    )
// Mark all entries of the appropriate type (either imported
// or non-imported) as unneeded.
{
    Assert( this );
    m_List.AcquireLockExclusive();

    fImported = !!fImported;

    __try {
        SINGLE_LIST_ENTRY * pList = m_List.m_ListHead.Next;
        PCACHE_ENTRY pEntry = NULL;

        while (NULL != pList) {   
            pEntry = CONTAINING_RECORD(pList, CACHE_ENTRY, Link);
            pList = pEntry->Link.Next;

             // Check that the 'imported' flag is not garbage
            Assert( pEntry->fEntryIsImported==!!pEntry->fEntryIsImported );

            if( pEntry->fEntryIsImported==fImported ) {
                pEntry->fUnneeded = TRUE;
            }
        }
    }
    __finally {
        m_List.ReleaseLock();
    }
}


VOID
KCC_CONNECTION_FAILURE_CACHE::FlushUnneeded(
    IN  BOOL    fImported
    )
// Flush out all entries of the appropriate type (either imported
// or non-imported) which are still marked as unneeded.
{
    Assert( this );
    m_List.AcquireLockExclusive();

    fImported = !!fImported;

    __try {
        SINGLE_LIST_ENTRY * pList = m_List.m_ListHead.Next;
        PCACHE_ENTRY pLastEntry = NULL;
        PCACHE_ENTRY pEntry = NULL;

        while (NULL != pList) {
            pEntry = CONTAINING_RECORD(pList, CACHE_ENTRY, Link);
            pList = pEntry->Link.Next;

             // Check that the 'imported' flag is not garbage
            Assert( pEntry->fEntryIsImported==!!pEntry->fEntryIsImported );

            if(   pEntry->fEntryIsImported==fImported
               && pEntry->fUnneeded )
            {
                if (NULL == pLastEntry) {
                    // Remove list head.
                    m_List.m_ListHead.Next = pEntry->Link.Next;
                }
                else {
                    // Remove entry other than list head.
                    pLastEntry->Link.Next = pEntry->Link.Next;
                }
                
                free(pEntry);
                // Note that pLastEntry remains unchanged.
            } else {
                pLastEntry = pEntry;
            }
        }
    }
    __finally {
        m_List.ReleaseLock();
    }
}

PDELETION_CACHE_ENTRY
KCC_CONNECTION_DELETION_CACHE::Find(
    IN KCC_CONNECTION *pcn,
    IN BOOL fDelete
    )
// Find an entry in the cache. Remove expired entries as we go. If we find one
// unlink it and return it.
{
    BOOL fFound = FALSE;
    SINGLE_LIST_ENTRY * pList = m_ListHead.Next;
    PDELETION_CACHE_ENTRY pLastEntry = NULL;
    PDELETION_CACHE_ENTRY pEntry = NULL;
    DSTIME dsTimeAgeOut;
    GUID *pguidDestDsa = &(pcn->GetDestinationDSADN()->Guid);
    GUID *pguidSourceDsa = &(pcn->GetSourceDSADN()->Guid);
    DWORD dwOptions = pcn->GetOptions();

    ASSERT_VALID( this );
    Assert(!fNullUuid(pguidDestDsa));
    Assert(!fNullUuid(pguidSourceDsa));

    if ( !pList )
    {
        // empty list - CONTAINING_RECORD does not detect this
        return NULL;
    }

    dsTimeAgeOut = GetSecondsSince1601() - gcConnectionRetentionSecs;

    // Walk list looking for match
    // List is sorted by most recent deletions first.
    while (NULL != pList) {
        pEntry = CONTAINING_RECORD(pList, DELETION_CACHE_ENTRY, Link);
        pList = pEntry->Link.Next;

        if (pEntry->DeletionTime < dsTimeAgeOut) {
            // Since the list is sorted by recent deletion first, we know that if we
            // come to an entry that is too old, all the subsequent entries will also
            // be too old. We could detach the remaining list at this point and
            // deallocate the chain if we wanted to. That code seems pretty similar to
            // what we have here so I'm not going to change it.
            DPRINT3( 1,"Removing entry 0x%x because it is too old, deltime = %I64d, ageout = %I64d\n",
                     pEntry, pEntry->DeletionTime, dsTimeAgeOut );
            if (NULL == pLastEntry) {
                // Remove list head.
                m_ListHead.Next = pEntry->Link.Next;
            }
            else {
                // Remove entry other than list head.
                pLastEntry->Link.Next = pEntry->Link.Next;
            }
            memset( pEntry, 0, sizeof(DELETION_CACHE_ENTRY ) );
            free(pEntry);
            continue;
        }

        if ( (0 == memcmp( &pEntry->guidDestDsa, pguidDestDsa, sizeof(GUID) ) ) &&
             (0 == memcmp( &pEntry->guidSourceDsa, pguidSourceDsa, sizeof(GUID) ) ) &&
             (pEntry->dwOptions == dwOptions) ) {
            if (fDelete) {
                DPRINT1( 1, "Unlinking found entry 0x%x\n", pEntry );
                if (NULL == pLastEntry) {
                    // Remove list head.
                    m_ListHead.Next = pEntry->Link.Next;
                }
                else {
                    // Remove entry other than list head.
                    pLastEntry->Link.Next = pEntry->Link.Next;
                }
                pEntry->Link.Next = NULL;
            }
            fFound = TRUE;
            break;
        }

        pLastEntry = pEntry;
    }

    return fFound ? pEntry : NULL;
}

BOOL
KCC_CONNECTION_DELETION_CACHE::PreventRepeatedDeletion(
    KCC_CONNECTION *pcn,
    DWORD dsid
    )
// This call is made when we are considering deleting a connection and want to know
// whether to go through with it.  We expose this function to layers higher than
// KCC_CONN::Remove so they can know whether to clean up their in memory lists.
//
// See if a connection like this one is in the cache. If it is, see if we have surpassed
// our tolerance for repeated deletions.
{
    PDELETION_CACHE_ENTRY pEntry = NULL;

    // Note, no locking required since all usage single-threaded

    pEntry = Find( pcn, FALSE /* do not delete */ );
    if (!pEntry) {
        // Not previously deleted
        return FALSE;  // do not prevent
    }

    DPRINT2( 1, "Hit entry 0x%x in conn del cache, count = %d\n",
             pEntry, pEntry->cNumDeletions );

    if (pEntry->cNumDeletions < gcConnectionRepeatedDeletionTolerance) {
        // Within tolerance
        return FALSE;  // do not prevent
    }

    // At this point, we are going to prevent the deletion

    DPRINT2(0, "Keeping oscillating connection %ls using outbound bridgehead %ls.\n",
            pcn->GetConnectionDN()->StringName,
            pcn->GetSourceDSADN()->StringName);
    pcn->SetReasonForConnection(KCC_OSCILLATING_CONNECTION_TOPOLOGY);

    Assert( !"KCC Connection Oscillation?" );
    // Since deletion of this connection may occur repeatedly, notify the user
    // only the first time we start preventing its deletion.
    LogEvent8(DS_EVENT_CAT_KCC,
              (pEntry->cNumDeletions == gcConnectionRepeatedDeletionTolerance) ?
              DS_EVENT_SEV_ALWAYS : DS_EVENT_SEV_BASIC,
              DIRLOG_KCC_CONN_OSCILLATION,
              szInsertDN(pcn->GetConnectionDN()),
              szInsertUUID(&(pcn->GetDestinationDSADN()->Guid)),
              szInsertDN(pcn->GetSourceDSADN()),
              szInsertUUID(&(pcn->GetSourceDSADN()->Guid)),
              szInsertUL(pcn->GetOptions()),
              szInsertUL(gcConnectionRetentionSecs),
              szInsertUL(gcConnectionRepeatedDeletionTolerance),
              szInsertHex(dsid)
        );

    // Update the count of deletions seen or prevented
    pEntry->cNumDeletions++;
        
    return TRUE; // prevent deletion
}

VOID
KCC_CONNECTION_DELETION_CACHE::Add(
        KCC_CONNECTION *pcn
    )
// This routine is called when we actually remove the connection to record the fact.
// Add or Update an record of a connection deletion
{
    PDELETION_CACHE_ENTRY pEntry;

    pEntry = Find( pcn, TRUE /* unlink from list */ );
    if (NULL == pEntry) {
        // Entry does not yet exist -- add it.
        pEntry = (DELETION_CACHE_ENTRY *) malloc(sizeof(DELETION_CACHE_ENTRY));
        if (NULL == pEntry) {
            KCC_MEM_EXCEPT(sizeof(DELETION_CACHE_ENTRY));
        }
        memset(pEntry, 0, sizeof(DELETION_CACHE_ENTRY));
        memcpy( &pEntry->guidDestDsa, &(pcn->GetDestinationDSADN()->Guid), sizeof( GUID ) );
        Assert(!fNullUuid(&pEntry->guidDestDsa));
        memcpy( &pEntry->guidSourceDsa, &(pcn->GetSourceDSADN()->Guid), sizeof( GUID ) );
        Assert(!fNullUuid(&pEntry->guidSourceDsa));
        pEntry->dwOptions = pcn->GetOptions();
    }

    // Otherwise it would have been prevented
    // If this hits, there may be a remove path not covered by a prevent check
    Assert(pEntry->cNumDeletions < gcConnectionRepeatedDeletionTolerance);

    pEntry->DeletionTime = GetSecondsSince1601();
    pEntry->cNumDeletions++;

    // Reinsert at head of list to keep it sorted
    // Note, no locking required since all usage single-threaded
    PushEntryList( &m_ListHead, &(pEntry->Link) );
    DPRINT6( 1, "Caching conn deletion entry 0x%x, source %ws, dest %ws, options 0x%x, count = %d, deltime = %I64d\n",
             pEntry,
             pcn->GetSourceDSADN()->StringName,
             pcn->GetDestinationDSADN()->StringName,
             pcn->GetOptions(),
             pEntry->cNumDeletions, pEntry->DeletionTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\kcctopl.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kcctopl.cxx

ABSTRACT:

    KCC_TASK_UPDATE_REPL_TOPOLOGY class.

DETAILS:

    This task performs routine maintenance on the replication topology.
    This includes:
    
    .   generating a topology of NTDS-Connection objects,
    .   updating existing replication links with changes made to NTDS-
        Connection objects
    .   translating new NTDS-Connection objects into new replication
        links, and
    .   removing replication links for which there is no NTDS-Connection
        object.

    This list of duties will undoubtedly grow.

CREATED:

    01/21/97    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <NTDSpchx.h>
#include <dsconfig.h>
#include "kcc.hxx"
#include "kcctask.hxx"
#include "kccconn.hxx"
#include "kcctopl.hxx"
#include "kcccref.hxx"
#include "kccdsa.hxx"
#include "kccsite.hxx"
#include "kccduapi.hxx"
#include "kcctools.hxx"
#include "kccnctl.hxx"
#include "kcclink.hxx"
#include "kccstale.hxx"
#include "kccstetl.hxx"

#define FILENO FILENO_KCC_KCCTOPL

/*++

Inline Logging Functions

Below are a list of macros which log information using the debugging facilities
and the event log functions. The use of these functions helps to keep the
actual code more readable.

--*/

#define LOG_STALE_REPSTO \
{ \
    UCHAR *pszUuid; \
    RPC_STATUS rpcStatus; \
    rpcStatus = UuidToString( plink->GetDSAUUID(), &pszUuid ); \
    if( RPC_S_OK != rpcStatus ) { \
        KCC_EXCEPT( rpcStatus, 0 ); \
    } \
    LogEvent(DS_EVENT_CAT_KCC, \
             DS_EVENT_SEV_EXTENSIVE, \
             DIRLOG_KCC_STALE_REPSTO_DELETED, \
             szInsertSz(pszUuid), \
             szInsertDN(pdnNC), \
             szInsertUL(((ULONG) timeFailure))); \
    RpcStringFree(&pszUuid); \
}


BOOL
KCC_TASK_UPDATE_REPL_TOPOLOGY::Init()
//
// Initialize this task.
//
{
    return Schedule(gcSecsUntilFirstTopologyUpdate);
}

BOOL
KCC_TASK_UPDATE_REPL_TOPOLOGY::IsValid()
//
// Is this object internally consistent?
//
{
    return TRUE;
}

void
KCC_TASK_UPDATE_REPL_TOPOLOGY::LogBegin()
//
// Log task begin.
//
{
    DPRINT( 3, "Beginning to update replication topology.\n" );

    LogEvent(
        DS_EVENT_CAT_KCC,
        DS_EVENT_SEV_EXTENSIVE,
        DIRLOG_CHK_UPDATE_REPL_TOPOLOGY_BEGIN,
        0,
        0,
        0
        );
}

void
KCC_TASK_UPDATE_REPL_TOPOLOGY::LogEndNormal()
//
// Log normal task termination.
//
{
    DPRINT( 3, "Update replication topology terminated normally.\n" );

    LogEvent(
        DS_EVENT_CAT_KCC,
        DS_EVENT_SEV_EXTENSIVE,
        DIRLOG_CHK_UPDATE_REPL_TOPOLOGY_END_NORMAL,
        0,
        0,
        0
        );
}

void
KCC_TASK_UPDATE_REPL_TOPOLOGY::LogEndAbnormal(
    IN DWORD dwErrorCode,
    IN DWORD dsid
    )
//
// Log abnormal task termination.
//
{
    DPRINT2(
        0,
        "Update replication topology terminated abnormally (%d, DSID %x).\n",
        dwErrorCode,
        dsid
        );

    LogEvent8(
        DS_EVENT_CAT_KCC,
        (geKccState == KCC_STARTED) ? DS_EVENT_SEV_ALWAYS : DS_EVENT_SEV_MINIMAL,
        DIRLOG_CHK_UPDATE_REPL_TOPOLOGY_END_ABNORMAL,
        szInsertWin32Msg(dwErrorCode),
        szInsertHex(dsid),
        szInsertWin32ErrCode(dwErrorCode),
        szInsertUL(gcSecsBetweenTopologyUpdates),
        NULL, NULL, NULL, NULL
        );
}

DWORD
KCC_TASK_UPDATE_REPL_TOPOLOGY::ExecuteBody(
    OUT DWORD * pcSecsUntilNextIteration
    )
//
// Execute the task.
//
{
    KCC_INTRASITE_CONNECTION_LIST * pIntraSiteCnList;
    KCC_INTERSITE_CONNECTION_LIST * pInterSiteCnList;
    DWORD                           cMinsBetweenRuns;
    BOOL                            fKeepCurrentIntrasiteConnections;
    KCC_SITE *                      pLocalSite;
    KCC_DS_CACHE                    DSCache;
    int                             nPriority;
    DWORD                           dwErrCode;

    __try {
        nPriority = ((int) gdwKccThreadPriority) - KCC_THREAD_PRIORITY_BIAS;
        if( ! SetThreadPriority(GetCurrentThread(),nPriority) ) {
            dwErrCode = GetLastError();
            DPRINT1(0, "Failed to set the thread priority. Err=%d\n", dwErrCode);
            LogEvent(
                DS_EVENT_CAT_KCC,
                DS_EVENT_SEV_MINIMAL,
                DIRLOG_KCC_SET_PRIORITY_ERROR,
                szInsertWin32Msg(dwErrCode),
                NULL,
                NULL
                );
        }

        srand( (unsigned int) time(NULL) );

        // Initialize our DS cache.
        gpDSCache = &DSCache;
        if (!gpDSCache->Init()) {
            DPRINT(0, "Cache init failed!\n");
            KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
        }

        pLocalSite = gpDSCache->GetLocalSite();

        if (!gfLastServerCountSet) {
            gLastServerCount = pLocalSite->GetDsaList()->GetCount();
            gfLastServerCountSet = TRUE;
        }

        pIntraSiteCnList
            = gpDSCache->GetLocalDSA()->GetIntraSiteCnList();
            
        pInterSiteCnList
            = gpDSCache->GetLocalDSA()->GetInterSiteCnList();
            
        // For all connections inbound to the local DSA:
        //
        // 1. Make sure that if the source is in a different site, a transport
        //    type is set.  If not, set to IP and move the KCC_CONNECTION from
        //    the intra-site list to the inter-site list.
        //
        // 2. Make sure that if the source is in the same site, no transport
        //    type is set.  If it is, remote the transport type and move the
        //    KCC_CONNECTION from the inter-site list to the intra-site list.
        
        pIntraSiteCnList->UpdateTransportTypeForSite(pInterSiteCnList);
        pInterSiteCnList->UpdateTransportTypeForSite(pIntraSiteCnList);
        
        // Remove any duplicate intra-site connections from the list and from
        // the DS.
        pIntraSiteCnList->RemoveDuplicates(TRUE);

        if (!gLinkFailureCache.Refresh()) {
            DPRINT(0, "KCC_LINK_FAILURE_CACHE::Init failed.\n");
        }
        
        // Try to verify the staleness of all servers in the connection cache.
        // While we're at it, clear the 'fErrorOccurredThisRun' flags so that we know
        // if the errors occurred during this run of the KCC, or during an earlier run.
        if (!gConnectionFailureCache.Refresh()) {
            DPRINT(0, "KCC_LINK_FAILURE_CACHE::Init failed.\n");
        }


        // We use mark-sweep garbage collection to flush out any
        // unneeded non-imported connection failure cache entries.
        // First mark all non-imported entries as unneeded.
        // If we later have a DsBind() failure (contacting bridgeheads) or
        // a DirReplicaAdd() failure, they entries will be marked as needed.
        // Unneeded entries are flushed out at the end of the KCC run.
        gConnectionFailureCache.MarkUnneeded( FALSE );


        // For every naming context in the current site, build a topology
        // between DC's hosting each individual naming context; If the NC
        // we are considering at the local DC is a writeable NC include 
        // only DCs that hold master replicas of this NC in the site while 
        // generating the topology. If the NC we are considering at the local 
        // DC is a read-only NC (i.e. Partial NC) include both read-only & writeable
        // replicas of this NC in the site.
        GenerateIntraSiteTopologies(pIntraSiteCnList,
                                    &fKeepCurrentIntrasiteConnections);


        // Create connection objects as necessary to create spanning tree
        // of sites across enterprise
        GenerateInterSiteTopologies();

        // Remove the connection objects that existed at the beginning
        // of this task that were not needed by the current topology
        if (!pLocalSite->IsRemoveConnectionsDisabled()) {
            RemoveUnnecessaryConnections(pIntraSiteCnList,
                                         pLocalSite->GetObjectDN(),
                                         fKeepCurrentIntrasiteConnections);
        }

        // Coalesce replication links to topology implied by NTDS-Connection
        // objects.
        UpdateLinks();

        // Update Reps-To's with any changed network addresses and remove those
        // left as dangling references.
        UpdateRepsToReferences();

#ifdef ANALYZE_STATE_SERVER
        if (gfDumpStaleServerCaches) {
            gLinkFailureCache.Dump();
            gConnectionFailureCache.Dump();
        }
#endif

        // We use mark-sweep garbage collection to flush out any
        // unneeded non-imported connection failure cache entries.
        // All needed entries have been marked as such. We flush
        // out the unneeded entries now.
        gConnectionFailureCache.FlushUnneeded( FALSE );

    }
    __finally {
        *pcSecsUntilNextIteration = gcSecsBetweenTopologyUpdates;
        gpDSCache = NULL;
        gfIntrasiteSchedInited = FALSE;
        if( ! SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_NORMAL) ) {
            dwErrCode = GetLastError();
            DPRINT1(0, "Failed to set the thread priority. Err=%d\n", dwErrCode);
        }
    }

    return 0;
}


VOID
KCC_TASK_UPDATE_REPL_TOPOLOGY::GenerateIntraSiteTopologies(
    IN OUT KCC_INTRASITE_CONNECTION_LIST *  pConnectionList,
    OUT    BOOL *                           pfKeepCurrentIntrasiteConnections
    )
/*++

Routine Description:

    This routine determines the site of the local dsa and then proceeds to
    make sure that the local DSA has connection objects necessary for the
    intra site configuration

Parameters:

    pConnectionList - a list of connections at the start of the topology
                      generator

Returns:

    None - the only errors are unexpected errors, a debug print or event log is
           made.
    
--*/
{
    KCC_SITE *  pLocalSite = gpDSCache->GetLocalSite();
    DSNAME *    pdnLocalSite = pLocalSite->GetObjectDN();
    DWORD       dwExceptionCode, ulErrorCode, dsid;
    PVOID       dwEA;

    // Unless we're entirely successful, keep the current intrasite connections.
    *pfKeepCurrentIntrasiteConnections = TRUE;

    if (pLocalSite->IsAutoTopologyEnabled()) {
        DPRINT1(1, "Building topology for site %ws\n",
                pdnLocalSite->StringName);
        __try {
            KccConstructTopologiesForSite(pConnectionList);

            // Intrasite topology constructed; okay to delete superfluous
            // connections.
            *pfKeepCurrentIntrasiteConnections = FALSE;
        }
        __except (GetExceptionData(GetExceptionInformation(), &dwExceptionCode,
                                   &dwEA, &ulErrorCode, &dsid)) {
            // Any exception is fatal - log that the automatic topology
            // did not complete for this site
            LogEvent8(DS_EVENT_CAT_KCC,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_KCC_AUTO_TOPL_GENERATION_INCOMPLETE,
                     szInsertDN(pdnLocalSite),
                     szInsertWin32ErrCode(ulErrorCode),
                     szInsertHex(dsid),
                     szInsertWin32Msg(ulErrorCode),
                     NULL, NULL, NULL, NULL );
        }
    }
}

VOID
KCC_TASK_UPDATE_REPL_TOPOLOGY::GenerateInterSiteTopologies()
/*++

Routine Description:

    This routine determines the site of the local dsa and then proceeds to
    make sure that the local DSA has connection objects necessary for the
    intra site configuration

Parameters:

    None.

Returns:

    None - the only errors are unexpected errors, a debug print or event log is
           made.
    
--*/
{
    KCC_SITE *  pLocalSite = gpDSCache->GetLocalSite();
    DWORD       dwExceptionCode, ulErrorCode, dsid;
    PVOID       dwEA;

    if ( pLocalSite->IsInterSiteAutoTopologyEnabled() ) {

        DPRINT( 1, "Building site topology\n" );
        __try
        {
            KccConstructSiteTopologiesForEnterprise();
        }
        __except (GetExceptionData(GetExceptionInformation(), &dwExceptionCode,
                                   &dwEA, &ulErrorCode, &dsid)) {
            //
            // Any exception is fatal - log that the automatic topology
            // did not complete for this site
            //

            DSNAME * pdnLocalSite = pLocalSite->GetObjectDN();

            LogEvent8(
                DS_EVENT_CAT_KCC,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_KCC_AUTO_TOPL_GENERATION_INCOMPLETE,
                szInsertDN(pdnLocalSite),
                szInsertWin32ErrCode(ulErrorCode),
                szInsertHex(dsid),
                szInsertWin32Msg(ulErrorCode),
                NULL, NULL, NULL, NULL );
        }
    }
}

void
KCC_TASK_UPDATE_REPL_TOPOLOGY::UpdateRepsToReferences()
/*++

Routine Description:

    Update Reps-To's with any changed network addresses and remove those
    left as dangling references.

Arguments:

    None.

Return Values:

    None.

--*/
{
    KCC_LINK_LIST   RepsToList;
    DSNAME *        pdnNC;
    DWORD           cLinks;
    KCC_DSA *       pLocalDSA = gpDSCache->GetLocalDSA();

    ASSERT_VALID( this );

    // For each local NC...
    for ( DWORD iNC = 0; iNC < pLocalDSA->GetNCCount(); iNC++ )
    {
        // Get the NC name.
        pdnNC = pLocalDSA->GetNC( iNC );

        DPRINT1(2,
            "Checking for Reps-To updates on %ls.\n",
            pdnNC->StringName);

        if ( RepsToList.Init( pdnNC, ATT_REPS_TO ) )
        {
            // For each Reps-To value for this NC...
            cLinks = RepsToList.GetCount();

            for ( DWORD iLink = 0; iLink < cLinks; iLink++ )
            {
                KCC_LINK * plink = RepsToList.GetLink( iLink );
                DSTIME timeLastAttempt, timeLastSuccess, timeFailure;
                BOOL fExists, fIsDeleted;
                
                ASSERT_VALID( plink );

                // Determine for how long this link has been failing
                timeLastAttempt = plink->GetTimeOfLastAttempt();
                timeLastSuccess = plink->GetTimeOfLastSuccess();
                if( timeLastAttempt>=timeLastSuccess ) {
                    timeFailure = timeLastAttempt-timeLastSuccess;
                } else {
                    // Under normal circumstances, we would expect that:
                    //     timeLastSuccess <= timeLastAttempt.
                    // However, before Whistler Beta 3, timeLastSuccess was used but
                    // timeLastAttempt was always 0. Furthermore, clocks can move
                    // backwards so it is indeed possible that:
                    //     timeLastAttempt < timeLastSuccess.
                    // In this case, we cannot tell how long replication has failing over
                    // this link so we set timeFailure to 0.
                    timeFailure = 0;
                }

                fExists = KccObjectExists( plink->GetDSAUUID(), &fIsDeleted );

                if( timeFailure > (DSTIME) gcSecsUntilRepsToFailure ) {

                    // This repsTo has been failing for more than
                    // gcSecsUntilRepsToFailure seconds, so it is considered stale.
                    // Log an event and delete it.

                    LOG_STALE_REPSTO;
                    plink->Delete(pdnNC,
                                  KCC_LINK_DEL_REASON_DANGLING_REPS_TO,
                                  ATT_REPS_TO, 0);
                } else {
                    // This one's a keeper; does it have the right network
                    // address for the target server?

                    if ( fExists )
                    {
                        MTX_ADDR * pmtxRemote
                            = KCC_DSA::GetMtxAddr( plink->GetDSAUUID() );

                        if ( !MtxSame( pmtxRemote,
                                       plink->GetDSAAddr() ) )
                        {
                            // Wrong address; change it!
                            plink->SetDSAAddr( pmtxRemote );
                            plink->Update( pdnNC, ATT_REPS_TO );
                        }
                    }
                }
            }
        }
    }
}


VOID
KCC_TASK_UPDATE_REPL_TOPOLOGY::RemoveUnnecessaryConnections(
    IN OUT KCC_INTRASITE_CONNECTION_LIST *  pConnectionList,
    IN     DSNAME *                         pdnLocalSite,
    IN     BOOL                             fKeepCurrentIntrasiteConnections
    )
//
// Delete all intrasite KCC-generated connection objects that don't have a
// reason for existence
//
{
    ULONG Index;
    DSNAME * pdnLocalDSA = gpDSCache->GetLocalDSADN();

    Assert( pConnectionList );

    // If more than one connection exists from the same source DSA, keep the
    // best one and delete the others from the database.
    pConnectionList->RemoveDuplicates(TRUE);

    for (Index = 0;
         Index < pConnectionList->GetCount();
         /* Index++/count-- below */) {
        
        KCC_CONNECTION *pcn = pConnectionList->GetConnection( Index );

        // Inter-site connections are not present in the list.
        Assert(NULL == pcn->GetTransportDN());
        // If a server is moved to a different site while the KCC is running, it
        // is possible that a connection in this list may have a grandparent DN
        // which is different than the local site. The previous assertion is
        // good enough to guarantee that this is still an intra-site connection.
        
        // Remove unneeded intra-site connections.
        if (pcn->IsGenerated() 
            && pcn->GetReasonForConnection() == KCC_NO_REASON
            && (!gConnectionDeletionCache.PreventRepeatedDeletion(
                    pcn, DSID(FILENO,__LINE__) ))
            && !fKeepCurrentIntrasiteConnections) {
            // Ok, delete this
            pcn->Remove( DSID( FILENO,__LINE__) );
            pConnectionList->RemoveFromList(Index);
            delete pcn;
        } else {
            // We're keeping this connection
            // Update its reasons for living on the object itself
            pcn->UpdateReason();
            Index++;
        }
    }
}


void
KCC_TASK_UPDATE_REPL_TOPOLOGY::UpdateLinks()
//
// Create/update/delete local links based on connection objects.
//
// Internally the KCC keeps track of which NC's use a connection by the
// ReplicatesNC array. However, externally, applications depend on the fact
// that if a connection is present, replica links are created for all
// common NC's between those two systems. Thus the KCC can sometimes create
// extra replica links that are not strictly required according to the
// spanning tree.
//
{
    KCC_LINK_LIST                   *pLinkListLocal;
    DSNAME *                        pdnTransport;
    KCC_DSA *                       pLocalDSA = gpDSCache->GetLocalDSA();
    KCC_CROSSREF_LIST *             pCrossRefList = gpDSCache->GetCrossRefList();
    KCC_TRANSPORT_LIST *            pTransportList = gpDSCache->GetTransportList();
    KCC_INTRASITE_CONNECTION_LIST * pIntraSiteCnList = pLocalDSA->GetIntraSiteCnList();
    KCC_INTERSITE_CONNECTION_LIST * pInterSiteCnList = pLocalDSA->GetInterSiteCnList();
    DWORD                           iCR;
    KCC_LINK *                      pLink;
    #ifdef DBG
        struct LINKLISTCHECK {
            DWORD cr;
            GUID guid;
        };
        LINKLISTCHECK   *pLLCheck;
        DWORD           LLCMax, LLCSize, iLLC;
    #endif // DBG

    if (pLocalDSA->IsConnectionObjectTranslationDisabled()) {
        DPRINT(0, "Logical connection-to-replication link translation is disabled.\n");
        LogEvent(DS_EVENT_CAT_KCC,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_KCC_CONNECTION_OBJ_TRANSLATION_DISABLED,
                 NULL, NULL, NULL);
        return;
    }

    // Note that duplicates have already been removed from the intra-site list.
    // We remove the inter-site duplicates from the in-memory list only, not from
    // the DS -- deletion of inter-site objects is left to the ISTG.
    pInterSiteCnList->RemoveDuplicates();

    //
    // Ensure that existing links are in sync with the corresponding connection
    // objects.
    //

    for (DWORD iNC = 0; iNC < pLocalDSA->GetNCCount(); iNC++) {
        BOOL            fIsNCWriteable;
        DSNAME *        pdnNC = pLocalDSA->GetNC(iNC, &fIsNCWriteable);
        KCC_CROSSREF *  pCrossRef = pCrossRefList->GetCrossRefForNC(pdnNC);
        BOOL            fIsMaster;
        BOOL            fIsNCHost;
        KCC_LINK_LIST * pLinkListLocalNotCached = NULL;
        
        fIsNCHost = (NULL != pCrossRef)
                    && pLocalDSA->IsNCHost(pCrossRef,
                                           TRUE /* fIsLocal */,
                                           &fIsMaster);
        
        DPRINT1(2, "Checking for Reps-From updates on %ls.\n", pdnNC->StringName);

        // Find the link list for this NC
        if (NULL == pCrossRef) {
            // Local NC with no corresponding crossRef.
            pLinkListLocal = new KCC_LINK_LIST;
            if (pLinkListLocal->Init(pdnNC)) {
                // Remember to free this later.
                pLinkListLocalNotCached = pLinkListLocal;
            } else {
                // Failed to initialize list (e.g., DS error, memory pressure,
                // etc.).
                delete pLinkListLocal;
                pLinkListLocal = NULL;
            }
        } else {
            // NC has a corresponding crossRef -- get the cached link list.
            pLinkListLocal = pCrossRef->GetLinkList();
        }
        
        if (pLinkListLocal == NULL) {
            // Failed to construct link list due to low memory, etc.  We do
            // *not* get here if there simply are no links for this NC -- in
            // that case we have a valid, initialized link list with 0 entries.
            continue;
        }

        // Iterate through each link, then execute one more pass with
        // pLink == NULL (wherein we can do such things as tear down
        // NCs with no remaining sources, etc.).

        for (DWORD iLink = 0; iLink < (pLinkListLocal->GetCount() + 1);
             /* We update the index below because we might remove items from the list */
             )
        {
            KCC_LINK_DEL_REASON DeleteReason = KCC_LINK_DEL_REASON_NONE;

            if (iLink < pLinkListLocal->GetCount()) {
                pLink = pLinkListLocal->GetLink(iLink);
                ASSERT_VALID(pLink);
                Assert(!!pLink->IsLocalNCWriteable() == !!fIsNCWriteable);
            } else {
                pLink = NULL;
            }

            if (pLinkListLocal->IsNCGoing()) {
                // NC is in the process of being removed -- let it be.
                Assert(0 == pLinkListLocal->GetCount());
            } else if (!fIsNCHost) {
                if (NULL == pCrossRef) {
                    if (fIsNCWriteable) {
                        // NDNC crossRef has been deleted; remove replica.
                        // (Note we do not allow our domain crossRef to be
                        // deleted -- be it by an originating or replicated
                        // change.)
                        DeleteReason = KCC_LINK_DEL_REASON_NDNC_NO_CROSSREF;
                    } else {
                        // Domain has been removed from the enterprise;
                        // remove from GCs.
                        DeleteReason = KCC_LINK_DEL_REASON_READONLY_DOMAIN_REMOVED;
                    }
                } else if (!fIsNCWriteable) {
                    if (!pLocalDSA->IsGC()) {
                        // Remove read-only NC as local DSA is no longer a
                        // GC.
                        DeleteReason = KCC_LINK_DEL_REASON_READONLY_NOT_GC;
                    } else if (!pCrossRef->IsReplicatedToGCs()) {
                        // We're a GC and have instantiated a read-only
                        // replica of this NC, but it's not configured to
                        // be replicated to GCs.
                        DeleteReason = KCC_LINK_DEL_REASON_READONLY_NOT_HOSTED_BY_GCS;
                    }
                } else if ((KCC_NC_TYPE_NONDOMAIN == pCrossRef->GetNCType())
                           && !pCrossRef->IsDSAPresentInNCReplicaLocations(
                                                               pLocalDSA)) {
                    if (NULL != pLink) {
                        // Local DSA is no longer configured to be a replica
                        // of this NDNC.  Stop replicating from this source.
                        DeleteReason = KCC_LINK_DEL_REASON_NDNC_NOT_REPLICA_HOST;
                    } else {
                        // Local DSA is no longer configured to be a replica
                        // of this NDNC.  Rather than tearing down the NC
                        // outright, demote it such that any remaining
                        // updates and FSMO roles are transferred to another
                        // replica.
                        Assert(KCC_LINK_DEL_REASON_NONE == DeleteReason);
                        KCC_LINK::Demote(pCrossRef);
                    }
                } else {
                    // Why did we once decide to host this NC and now decide
                    // not to host it?
                    Assert(!"Can't determine why we should no longer host NC!");
                    LogUnhandledError(0);
                }
            } else if (!!fIsMaster != !!fIsNCWriteable) {
                // We should and do host a replica of this NC, but it is of
                // the wrong flavor -- i.e., we have a writeable replica and
                // need a read-only replica or vice versa.  This should
                // currently never happen, as NDNCs are the only writeable
                // NCs that can be added or removed from a DSA other than
                // during DCPROMO and NDNCs are currently speced never to
                // replicate to GCs (and therefore have no read-only
                // replicas).
                
                if (fIsMaster) {
                    // If this becomes a real supported path we should
                    // consider optimizing the transition from writeable to
                    // read-only (which should require no wire traffic).
                    DeleteReason = KCC_LINK_DEL_REASON_HAVE_WRITEABLE_NEED_READONLY;
                } else {
                    DeleteReason = KCC_LINK_DEL_REASON_HAVE_READONLY_NEED_WRITEABLE;
                }
            } else if (NULL != pLink) {
                // Attempt to find a connection object corresponding to this
                // link.
                KCC_CONNECTION * pcn;
                KCC_DSA *pSourceServer;
                BOOL fSourceIsMaster;
                UUID *pDsaUUID;

                pDsaUUID = pLink->GetDSAUUID();
                pSourceServer = gpDSCache->GetDSAByGUID( pDsaUUID );
                // Note: pSourceServer may be NULL if the server was not found.
                
                pcn = pIntraSiteCnList->GetConnectionFromSourceDSAUUID(pDsaUUID);
                if (NULL == pcn) {
                    pcn = pInterSiteCnList->GetConnectionFromSourceDSAUUID(pDsaUUID);
                }
                if (NULL == pcn) {
                    // No connection object for this link.
                    //
                    // Does it source from a DSA that is currently in a stay
                    // of execution (i.e., a DSA that has been recently
                    // deleted but still has time to revive its NTDS-DSA
                    // object)?
                    //
                    // When a server object is deleted, we keep trying to
                    // replicate from it for a certain period of time to
                    // allow it to see the deletion of its NTDS-DSA object
                    // and undelete it, which offers some measure of
                    // protection against inadvertent server deletion.
                    //
                    // Note that we provide an exception for the last source
                    // of a read-only NC so as to prevent the NC from being
                    // torn down, given that we've already evaluated that we
                    // should continue to host this NC.  In this case we're
                    // presumably shortly going to add a new source for this
                    // NC, after which point we'll be free to delete the
                    // old source.
                    //
                    // If pSourceServer is non-NULL, then this repsFrom's
                    // source server was found in the cache. This means that
                    // the server is not deleted, so the server is not in a
                    // stay of execution. So, we delete the repsFrom.
                    //
                    // If pSourceServer is NULL (i.e. it was not found in
                    // the cache), then the DSA must have been deleted.
                    // We check if the server is in a stay of execution.
                    // If it is not, then the repsFrom should be deleted.
                    // If the server is in a stay of execution, then we keep
                    // the repsFrom.
                    
                    if(   NULL!=pSourceServer
                       || !KccIsDSAInStayOfExecution(pDsaUUID))
                    {
                        // No connection object and not in stay of execution.
                        // Delete the replication link.
                        DeleteReason = KCC_LINK_DEL_REASON_NO_CONNECTION;
                    }
                } else if (NULL!=pSourceServer) {
                    if (!pSourceServer->IsNCHost(pCrossRef,
                                                 FALSE /* fIsLocal */,
                                                 &fSourceIsMaster)) {
                        // The NC is no longer instantiated on the source
                        // (e.g., we're a GC and the source was but is no
                        // longer a GC).
                        DeleteReason = KCC_LINK_DEL_REASON_SOURCE_NOT_HOST;
                    } else if (fIsNCWriteable && !fSourceIsMaster) {
                        // The source has a read-only replica and the local
                        // replica is writeable.
                        DeleteReason = KCC_LINK_DEL_REASON_SOURCE_READONLY;
                    } else if (!gfAllowMbrBetweenDCsOfSameDomain
                               && pLink->IsLocalNCWriteable()
                               && (KCC_NC_TYPE_DOMAIN == pCrossRef->GetNCType())
                               && (NULL != (pdnTransport = pcn->GetTransportDN()))
                               && !KCC_TRANSPORT::IsIntersiteIP(pdnTransport)) {
                        // This is not a viable transport for this NC.  By
                        // decree, writeable domain NCs must be replicated
                        // over IP.
                        LogEvent8(DS_EVENT_CAT_KCC,
                                  DS_EVENT_SEV_ALWAYS,
                                  DIRLOG_CHK_INVALID_TRANSPORT_FOR_WRITEABLE_DOMAIN_NC,
                                  szInsertDN(pcn->GetConnectionDN()),
                                  szInsertDN(pcn->GetSourceDSADN()),
                                  szInsertDN(pLocalDSA->GetDsName()),
                                  szInsertDN(pdnNC),
                                  szInsertDN(pdnTransport),
                                  NULL, NULL, NULL);
                    } else {
                        // Update link with any changes implied by this
                        // ntdsConnection object.
                        pcn->UpdateLink(pLink,
                                        pCrossRef,
                                        pLocalDSA->GetSiteDN(),
                                        pTransportList);
                    }
                }
            }

            // Delete the link if we deemed there to be a reason to do so.
            if (KCC_LINK_DEL_REASON_NONE != DeleteReason) {
                KCC_LINK::Delete(pLink, pdnNC, DeleteReason);

                if (NULL != pLink) {
                    // Now we remove this link from pLinkListLocal to keep our
                    // cache consistent.
                    pLinkListLocal->RemoveLink(iLink);
                
                    // Don't increment index because list has shrunk
                } else {
                    // This was the "NC granular" rather than "(NC,source)
                    // granular" pass, which is now complete.
                    iLink++;
                }
            } else {
                iLink++;
            }

        }

        if (NULL != pLinkListLocalNotCached) {
            delete pLinkListLocalNotCached;
        }
    }

    
    //
    // Now that we have done our best to synchronize existing links with
    // their corresponding connection objects, create any links that
    // do not yet exist.
    //

    #ifdef DBG
        // Allocate a list of LINKLISTCHECK objects
        // When we go to look up an item in a link list
        LLCSize = 0;
        LLCMax = (pIntraSiteCnList->GetCount() + pInterSiteCnList->GetCount())
            * pCrossRefList->GetCount();
        pLLCheck = new LINKLISTCHECK[ LLCMax ];
    #endif // DBG
    

    for (DWORD icn = 0;
         icn < pIntraSiteCnList->GetCount() + pInterSiteCnList->GetCount();
         icn++) {
        KCC_CONNECTION * pcn;

        pcn = (icn < pIntraSiteCnList->GetCount())
                ? pIntraSiteCnList->GetConnection(icn)
                : pInterSiteCnList->GetConnection(icn - pIntraSiteCnList->GetCount());
        Assert(NULL != pcn);

        DPRINT2(4, "Checking for new Reps-From on connection %ws source %ws\n",
                pcn->GetConnectionDN()->StringName,
                pcn->GetSourceDSADN()->StringName);

        if (0 == memcmp(&pLocalDSA->GetDsName()->Guid,
                        &pcn->GetSourceDSADN()->Guid,
                        sizeof(GUID))) {
            // Can't replicate from self!
            LogEvent(DS_EVENT_CAT_KCC,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_CHK_CANT_REPLICATE_FROM_SELF,
                     szInsertDN(pcn->GetConnectionDN()),
                     NULL,
                     NULL);
        } else if (pcn->IsEnabled()) {
            KCC_DSA *pdsaRemote = pcn->GetSourceDSA();
            for (iCR = 0; iCR < pCrossRefList->GetCount(); iCR++) {
                KCC_CROSSREF * pCrossRef = pCrossRefList->GetCrossRef(iCR);
                BOOL fIsRemoteMaster;
                BOOL fIsLocalMaster;

                if (pdsaRemote->IsNCHost(pCrossRef,
                                       FALSE /* fIsLocal */,
                                       &fIsRemoteMaster)
                    && pLocalDSA->IsNCHost(pCrossRef,
                                           TRUE /* fIsLocal */,
                                           &fIsLocalMaster)
                    && (!fIsLocalMaster || fIsRemoteMaster)) {
                    
                    // now we know we _should_ have a link; do we?
                    pLinkListLocal = pCrossRef->GetLinkList();
                    if ((NULL != pLinkListLocal)
                        && (NULL == pLinkListLocal->GetLinkFromSourceDSAObjGuid(
                                            &pcn->GetSourceDSADN()->Guid))) {
                        // We don't yet have a link to replicate this NC from
                        // pcn->GetSourceDSADN().
#if DBG
                        for( iLLC=0; iLLC<LLCSize; iLLC++ ) {
                            int cmp;
                            cmp = memcmp(
                                    &pLLCheck[iLLC].guid,
                                    &pcn->GetSourceDSADN()->Guid,
                                    sizeof(GUID) );
                            if( pLLCheck[iLLC].cr==iCR && 0==cmp ) {
                                Assert( 0 && "Didn't add entry to link list but should have!" );
                            }
                        }
#endif // DBG
                        if (!gfAllowMbrBetweenDCsOfSameDomain
                            && fIsLocalMaster
                            && (KCC_NC_TYPE_DOMAIN == pCrossRef->GetNCType())
                            && (NULL != (pdnTransport = pcn->GetTransportDN()))
                            && !KCC_TRANSPORT::IsIntersiteIP(pdnTransport)) {
                            // This is not a viable transport for this
                            // NC.  By decree, writeable domain NCs must
                            // be replicated over IP.
                            DPRINT3(0, "Connection %ls cannot replicate writeable domain NC %ls over non-IP transport %ls.\n",
                                    pcn->GetConnectionDN()->StringName,
                                    pCrossRef->GetNCDN()->StringName,
                                    pdnTransport->StringName);
                            LogEvent8(DS_EVENT_CAT_KCC,
                                      DS_EVENT_SEV_ALWAYS,
                                      DIRLOG_CHK_INVALID_TRANSPORT_FOR_WRITEABLE_DOMAIN_NC,
                                      szInsertDN(pcn->GetConnectionDN()),
                                      szInsertDN(pcn->GetSourceDSADN()),
                                      szInsertDN(pLocalDSA->GetDsName()),
                                      szInsertDN(pCrossRef->GetNCDN()),
                                      szInsertDN(pdnTransport),
                                      NULL, NULL, NULL);
                        } else {
                            // Link doesn't yet exist; add it.
                            pcn->AddLink(pCrossRef,
                                         fIsLocalMaster,
                                         pLocalDSA->GetSiteDN(),
                                         pLocalDSA,
                                         pdsaRemote,
                                         pTransportList);
                            // 
                            // After adding the link to the DS, we should also update the link cache
                            // for this NC. However, we will never search the cache for this new link,
                            // so we don't actually need to update the cache.
                            //
                            // Why do we never search the cache for this link? Earlier, we removed all
                            // duplicate connections from the pIntra/InterSiteCnList lists. Therefore all
                            // connections will have distinct source DSA's. Therefore, the above function
                            // ppLinkListCache[ NC ]->GetLinkFromSourceDSAObjGuid( DSA ) will never be
                            // called with the same (NC,DSA) parameters.
                            // 
                            
                            // The following bit of code adds the cross-ref index and the guid for
                            // the link we just created into an array called 'pLLCheck'. Later, when
                            // we search for links, we check this cache to make sure we're not searching
                            // for a link we should have added.
                            #if DBG
                                Assert( LLCSize<LLCMax );
                                pLLCheck[LLCSize].cr = iCR;
                                pLLCheck[LLCSize].guid = pcn->GetSourceDSADN()->Guid;
                                LLCSize++;
                            #endif
                        }
                    }
                }
            }
        }
    }

    #ifdef DBG
        delete [] pLLCheck;
    #endif
    

    // Update any servers that didn't repond to our attempts
    // to initiate a replication connection
    gConnectionFailureCache.IncrementFailureCounts();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\kcctrans.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kcctrans.cxx

              
ABSTRACT:

    KCC_TRANSPORT

DETAILS:

    This class represents the ds object Inter-Site Transport Type

CREATED:

    12/05/97    Colin Brace ( ColinBr )

REVISION HISTORY:

--*/

#include <ntdspchx.h>
#include "kcc.hxx"
#include "kccconn.hxx"
#include "kcclink.hxx"
#include "kccdsa.hxx"
#include "kccduapi.hxx"
#include "kcctools.hxx"
#include "kcccref.hxx"


#include "kcctrans.hxx"


#define FILENO FILENO_KCC_KCCTRANS

//
// KCC_TRANSPORT methods
//

void
KCC_TRANSPORT::Reset()
// Reset member variables to their pre-Init() state.
{
    m_fIsInitialized = FALSE;
    m_pdn = NULL;
    m_attAddressType = 0;
    m_dwOptions = 0;
    m_fIsSiteLinkListInitialized = FALSE;
    m_SiteLinkList.Reset();
    m_fIsBridgeListInitialized = FALSE;
    m_BridgeList.Reset();
    m_AllExplicitBridgeheadArray.RemoveAll();
}


BOOL
KCC_TRANSPORT::Init(
    IN  ENTINF *    pEntInf
    )
// Init the object given its ds properties
{

    DWORD   iAttr, cAttr, iAttrVal;
    ATTR *  pAttr;
    DWORD   cbVal;
    BYTE *  pbVal;

    Reset();

    m_pdn = pEntInf->pName;

    if( IsIntersiteIP(m_pdn) ) {
        // Default is schedules significant, bridges not required (transitive)
        m_dwOptions = 0;
    } else {
        // Default is schedules not significant, bridges not required (transitive)
        m_dwOptions = NTDSTRANSPORT_OPT_IGNORE_SCHEDULES;
    }

    for ( iAttr = 0, cAttr = pEntInf->AttrBlock.attrCount; 
            iAttr < cAttr; 
                iAttr++ )
    {
        pAttr = &pEntInf->AttrBlock.pAttr[ iAttr ];
        cbVal = pAttr->AttrVal.pAVal->valLen;
        pbVal = pAttr->AttrVal.pAVal->pVal;

        Assert( pAttr->attrTyp == ATT_BRIDGEHEAD_SERVER_LIST_BL ||
                1 == pAttr->AttrVal.valCount ); // most should be single-valued

        switch ( pAttr->attrTyp )
        {
        case ATT_BRIDGEHEAD_SERVER_LIST_BL:
            for ( iAttrVal = 0; iAttrVal < pAttr->AttrVal.valCount; iAttrVal++ )
            {
                DSNAME *pdnServer = (DSNAME *) pAttr->AttrVal.pAVal[ iAttrVal ].pVal;

                m_AllExplicitBridgeheadArray.Add( pdnServer );
            }
            // This list does not need to be sorted
            // Validation: Note that this list is supposed to contain server objects
            // we do not validate this condition here. Values that are not server
            // objects can be returned GetExplicitBridgeheadsForSite but this should
            // not cause any problems.
            break;

        case ATT_TRANSPORT_ADDRESS_ATTRIBUTE:
            Assert( cbVal == sizeof(ATTRTYP) );
            m_attAddressType = *((ATTRTYP *) pbVal);

            // Validation: Not validated
            break;

        case ATT_OPTIONS:
            Assert( cbVal == sizeof(DWORD) );
            m_dwOptions = *((DWORD *) pbVal);

            // Validation: Bitfields are not validated.
            break;

        default:
            DPRINT1( 0, "Received unrequested attribute 0x%X.\n", pAttr->attrTyp );
            break;
        }
    }

    m_fIsInitialized = TRUE;

    return m_fIsInitialized;
}

BOOL
KCC_TRANSPORT::IsValid()
// Is the object initialized and internally consistent ?
{
    return m_fIsInitialized;
}

DSNAME*
KCC_TRANSPORT::GetDN()
// Retrieve the DN of the object
{
    ASSERT_VALID( this );

    return m_pdn;
}

ATTRTYP
KCC_TRANSPORT::GetAddressType()
// Retrieve the ATTRTYP of the transport-specific address attribute.
// This ATTRTYP is an optional attribute of server objects.
{
    ASSERT_VALID( this );

    return m_attAddressType;
}

void
KCC_TRANSPORT::ReadSiteLinkList()
{
    ASSERT_VALID(this);
    Assert(!m_fIsSiteLinkListInitialized);

    if (!m_SiteLinkList.Init(this)) {
        KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
    }

    m_fIsSiteLinkListInitialized = TRUE;
}

void
KCC_TRANSPORT::ReadBridgeList()
{
    ASSERT_VALID(this);
    Assert(!m_fIsBridgeListInitialized);

    if (!m_BridgeList.Init(this)) {
        KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
    }

    m_fIsBridgeListInitialized = TRUE;
}

KCC_DSNAME_ARRAY *
KCC_TRANSPORT::GetExplicitBridgeheadsForSite(
    KCC_SITE *pSite
    )
//
// An array of DSNAMES of DSA objects is returned
//
// This is not currently cached on the assumption that higher level caching
// prevents this from being called more than once per site
//
// This approach to generating the list of explicit bridgeheads for a site is
// to walk the list of all bridgeheads on the transport. The alternative is to
// do a deep search for the set of server objects which have that bridgehead
// transport. I think it will be cheaper to read the per-transport list in once
// and seach that in memory. What makes this funky is that it is the SERVER
// object that is marked.  Since the KCC deals with the DSA object, a means is
// required to map the server to its corresponding DSA.
//
// NOTE: if there are values in the transport's explicit bridgehead list
// that are not actually server objects, but are in the subtree of objects
// rooted at pSite's object, they will be returned from this function. It is
// the job of the caller to separate the wheat from the chaff and determine
// which entries in the returned array actually refer to real NTDS Settings
// objects.
{
    DWORD iServer;
    KCC_DSNAME_ARRAY *pSiteArray = NULL;
    WCHAR       szRDN[]  = L"NTDS Settings";
    DWORD       cchRDN   = lstrlenW(szRDN);
    ULONG       cbNtdsDsaSettings;
    DSNAME *    pdnNtdsDsaSettings;

    for( iServer =0; iServer < m_AllExplicitBridgeheadArray.GetCount(); iServer++ ) {
        DSNAME *pdnServer = m_AllExplicitBridgeheadArray[iServer];

        if (NamePrefix(pSite->GetObjectDN(), pdnServer)) {

            if (!pSiteArray) {
                // Allocate array first time, only if needed
                pSiteArray = new KCC_DSNAME_ARRAY;
            }

            // Prepend NTDS Settings to server dn to make DSA dn
            cbNtdsDsaSettings = pdnServer->structLen
                + (MAX_RDN_SIZE + MAX_RDN_KEY_SIZE)
                * sizeof(WCHAR);
            pdnNtdsDsaSettings = (DSNAME *) new BYTE [cbNtdsDsaSettings];
        
            AppendRDN(pdnServer,
                      pdnNtdsDsaSettings,
                      cbNtdsDsaSettings,
                      szRDN,
                      cchRDN,
                      ATT_COMMON_NAME);

            // Note, these DSNAMES have no GUIDs. This is ok.
            pSiteArray->Add( pdnNtdsDsaSettings );

            pdnNtdsDsaSettings = NULL;
        }
    }

    // Sort the array so that isElementOf will work efficiently
    if (pSiteArray) {
        pSiteArray->Sort();
    }

    return pSiteArray;
}














//
// KCC_TRANSPORT_LIST methods
//
void
KCC_TRANSPORT_LIST::Reset()
{
    m_fIsInitialized = FALSE;
    m_pTransports = NULL;
    m_cTransports = 0;
}

BOOL
KCC_TRANSPORT_LIST::IsValid()
// Is the object initialized and internally consistent ?
{
    return m_fIsInitialized;
}

BOOL
KCC_TRANSPORT_LIST::Init()
{

    ATTR      rgAttrs[] =
    {
        { ATT_TRANSPORT_ADDRESS_ATTRIBUTE, { 0, NULL } },
        { ATT_OPTIONS, { 0, NULL } },
        { ATT_REPL_INTERVAL, { 0, NULL } },
        { ATT_BRIDGEHEAD_SERVER_LIST_BL, { 0, NULL } }
    };

    ENTINFSEL Sel =
    {
        EN_ATTSET_LIST,
        { sizeof( rgAttrs )/sizeof( rgAttrs[ 0 ] ), rgAttrs },
        EN_INFOTYPES_TYPES_VALS
    };

    DSNAME *    pdnConfigNC = gpDSCache->GetConfigNC();
    DSNAME *    pdnTransportCat = NULL;
    WCHAR       szTransportsContainerPrefix[]  = L"CN=Inter-Site Transports,CN=Sites,";
    ULONG       cbTransportsContainer = pdnConfigNC->structLen +
                                     ARRAY_SIZE(szTransportsContainerPrefix) * sizeof(WCHAR);
    DSNAME *    pdnTransportsContainer = (DSNAME *) new BYTE[cbTransportsContainer];
    ULONG               dirError;
    FILTER              Filter;
    SEARCHRES *         pResults;
    ENTINFLIST *        pEntInfList;

    // Clear the member variables
    Reset();
    pdnTransportCat = DsGetDefaultObjCategory(CLASS_INTER_SITE_TRANSPORT);
    ASSERT( NULL!=pdnTransportCat );

    // Set up the search filter
    memset( &Filter, 0, sizeof( Filter ) );

    Filter.choice                  = FILTER_CHOICE_ITEM;
    Filter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;

    Filter.FilterTypes.Item.FilTypes.ava.type         = ATT_OBJECT_CATEGORY;
    Filter.FilterTypes.Item.FilTypes.ava.Value.valLen = pdnTransportCat->structLen;
    Filter.FilterTypes.Item.FilTypes.ava.Value.pVal   = (BYTE *) pdnTransportCat;

    // Set up the root search dn
    wcscpy(pdnTransportsContainer->StringName, szTransportsContainerPrefix);
    wcscat(pdnTransportsContainer->StringName, pdnConfigNC->StringName);
    pdnTransportsContainer->NameLen = wcslen(pdnTransportsContainer->StringName);
    pdnTransportsContainer->structLen = DSNameSizeFromLen(pdnTransportsContainer->NameLen);
    Assert(0 == pdnTransportsContainer->SidLen);
    Assert(fNullUuid(&pdnTransportsContainer->Guid));
    
    dirError = KccSearch(
        pdnTransportsContainer,
        SE_CHOICE_IMMED_CHLDRN,
        &Filter,
        &Sel,
        &pResults
        );

    if ( 0 != dirError )
    {
        KCC_LOG_SEARCH_FAILURE( pdnTransportsContainer, dirError );
    }
    else
    {
        if ( 0 == pResults->count )
        {
           DPRINT( 0, "No transport objects found.\n" );
        }
        else
        {
            // Note that the internal representation of the transport list is a
            // little non-standard. Instead of being a pointer to an array of
            // pointers to objects, this is an array of the objects themselves.
            m_pTransports = new KCC_TRANSPORT[ pResults->count ];

            m_cTransports = 0;
            for ( pEntInfList = &pResults->FirstEntInf;
                  NULL != pEntInfList;
                  pEntInfList = pEntInfList->pNextEntInf
                )
            {
                KCC_TRANSPORT * pTransport = &(m_pTransports)[ m_cTransports ];

                if ( pTransport->Init( &pEntInfList->Entinf ) )
                {
                    m_cTransports++;
                }
                else
                {
                    if (  pEntInfList->Entinf.pName
                       && pEntInfList->Entinf.pName->StringName )
                    {
                        DPRINT1( 0, "Initialization of transport object %ls failed\n",
                                pEntInfList->Entinf.pName->StringName );
                    }
                    else
                    {
                        DPRINT( 0, "Initialization of transport object (NULL) failed\n" );
                    }
                }
            }
        }

        m_fIsInitialized = TRUE;

    }

    return m_fIsInitialized;

}

ULONG
KCC_TRANSPORT_LIST::GetCount()
{

    ASSERT_VALID( this );

    return m_cTransports;
}

KCC_TRANSPORT*
KCC_TRANSPORT_LIST::GetTransport(
    ULONG i
    )
{

    ASSERT_VALID( this );

    Assert( i < m_cTransports );

    if ( i < m_cTransports )
    {
        return &m_pTransports[ i ];
    }

    return NULL;
}



KCC_TRANSPORT*
KCC_TRANSPORT_LIST::GetTransport(
    DSNAME *pdnTransport
    )
{
    KCC_TRANSPORT * ptp;
    KCC_TRANSPORT * ptpReturn = NULL;
    DSNAME        * pdnCurrent;
    ULONG           itp;

    ASSERT_VALID( this );

    Assert( pdnTransport );

    for ( itp = 0; itp < m_cTransports; itp++ )
    {
        ptp  = &m_pTransports[ itp ];
        ASSERT_VALID( ptp );

        pdnCurrent = ptp->GetDN();
        Assert( pdnCurrent );

        if ( KccIsEqualGUID( &pdnCurrent->Guid, 
                             &pdnTransport->Guid ) )
        {
            //
            // This is it; pcn is the one we want
            //
            ptpReturn = ptp;
            break;
        }
    }

    return ptpReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\kccwalg.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kccwalg.cxx

ABSTRACT:

    This file implements new algorithms for Whistler to generate inter-site
    topologies. Uses new spanning-tree algorithms available in W32TOPL.

DETAILS:

CREATED:

    07/26/00    Nick Harvey (NickHar)

REVISION HISTORY:

--*/

#include <NTDSpchx.h>
#include "w32topl.h"
#include "kcc.hxx"
#include "kcctask.hxx"
#include "kccconn.hxx"
#include "kcctopl.hxx"
#include "kcccref.hxx"
#include "kccdsa.hxx"
#include "kcctools.hxx"
#include "kcctrans.hxx"
#include "kccsconn.hxx"
#include "kccdynar.hxx"
#include "kccsite.hxx"
#include "kccduapi.hxx"
#include "ismapi.h"
#include "kccsitelink.hxx"
#include "kccstetl.hxx"


#define FILENO FILENO_KCC_KCCWALG


PTOPL_GRAPH_STATE
KccSetupGraphState(
    VOID
    )
/*++

Routine Description:

    This function creates a W32TOPL 'graph state' object, which is a
    representation of the enterprise. The vertices of the graph are represented
    by site names. The edges of the graph correspond to site links, and the
    edge sets correspond to bridges. This graph state is used for calculating
    the inter-site topology in Whistler forests.

Parameters:

    None.    

Returns:

    A pointer to the graph state object that is created.
        
--*/
{
    KCC_SITE_LIST          *pSiteList = gpDSCache->GetSiteList();
    KCC_TRANSPORT_LIST     *pTransportList = gpDSCache->GetTransportList();
    KCC_TRANSPORT          *pTransport;
    KCC_SITE_LINK_LIST     *pSiteLinkList;
    KCC_SITE_LINK          *pSiteLink;
    KCC_SITE               *pSite;
    KCC_BRIDGE_LIST        *pBridgeList;
    KCC_BRIDGE             *pBridge;
    PTOPL_GRAPH_STATE       pGraphState;
    PTOPL_MULTI_EDGE        pEdge;
    PTOPL_MULTI_EDGE_SET    pEdgeSet;
    TOPL_REPL_INFO          replInfo;
    PVOID                  *vertexNames;
    DWORD                   iVtx,cVtx;
    DWORD                   iTnpt,cTnpt;
    DWORD                   iStlk,cStlk;
    DWORD                   iBrdg,cBrdg;
    DWORD                   numEdgesAdded;


    /* Set up the list of vertices and the graph state object */
    Assert( pSiteList!=NULL && pTransportList!=NULL );
    cVtx = pSiteList->GetCount();
    vertexNames = new PVOID[ cVtx ];
    for( iVtx=0; iVtx<cVtx; iVtx++ ) {
        pSite = pSiteList->GetSite(iVtx);
        ASSERT_VALID( pSite );
        vertexNames[iVtx] = pSite;
    }
    
    /* Create the actual graph state object (which includes the list of
     * vertices). This function should never return NULL. */
    Assert( gpDSCache->GetScheduleCache() );
    pGraphState = ToplMakeGraphState( vertexNames, cVtx,
        CompareIndirectSiteGuid, gpDSCache->GetScheduleCache() );

    /* The W32TOPL algorithms only support up to 32 transports. */
    cTnpt = pTransportList->GetCount();
    Assert( cTnpt<32 );

    /* This somewhat lengthy loop adds site links and bridges for every transport */
    for( iTnpt=0; iTnpt<cTnpt; iTnpt++ ) {

        pTransport = pTransportList->GetTransport(iTnpt);
        ASSERT_VALID( pTransport );

        /* Get all site links for this transport */
        pSiteLinkList = pTransport->GetSiteLinkList();
        cStlk = pSiteLinkList->GetCount();

        /* Ignore transports with no site links */
        if( cStlk<1 ) {
            continue;
        }

        /* If auto-bridging is on, we can build the edge set as we process the
         * site links. We create the edge set now. */
        if( pTransport->PerformAutomaticBridging() ) {
            pEdgeSet = new TOPL_MULTI_EDGE_SET;
            pEdgeSet->multiEdgeList = new PTOPL_MULTI_EDGE[ cStlk ];
        }

        /* Create a graph edge for each site link and add it to the graph */
        numEdgesAdded = 0;
        for( iStlk=0; iStlk<cStlk; iStlk++ ) {

            pSiteLink = pSiteLinkList->GetSiteLink(iStlk);
            ASSERT_VALID( pSiteLink );

            /* Site links containing fewer than 2 site can exist but they are not useful.
             * If the forest has more than 1 site and has such a site link, log a warning. */
            cVtx = pSiteLink->GetSiteCount();
            if( cVtx<2 && gpDSCache->GetSiteList()->GetCount()>1  ) {
                DPRINT1(0, "The site link %ls contains too few sites and will be ignored.\n",
                    pSiteLink->GetObjectDN()->StringName );
                LogEvent( DS_EVENT_CAT_KCC,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_KCC_SITE_LINK_TOO_SMALL,
                          szInsertDN( pSiteLink->GetObjectDN() ),
                          0, 0 );
                pSiteLink->SetGraphEdge( NULL );
                continue;
            }

            /* Set up the replication info for this edge */
            replInfo.cost = pSiteLink->GetCost();
            replInfo.options = pSiteLink->GetOptions();
            replInfo.repIntvl = pSiteLink->GetReplInterval();
            if( pTransport->UseSiteLinkSchedules() ) { 
                replInfo.schedule = pSiteLink->GetSchedule();
            } else {
                replInfo.schedule = NULL;
            }

            /* We have already checked all the parameters above, so this function
             * should not return any errors or NULL. */
            pEdge = ToplAddEdgeToGraph( pGraphState, cVtx, iTnpt, &replInfo );

            /* Add all vertices in this site link to the edge */
            for( iVtx=0; iVtx<cVtx; iVtx++ ) {
                pSite = pSiteLink->GetSite(iVtx);
                ASSERT_VALID( pSite );
                pSite->SetSiteLinkFlag( iTnpt );

                /* Since we have checked all the parameters above, we don't expect
                 * any errors here */
                ToplEdgeSetVtx( pGraphState, pEdge, iVtx, pSite );
            }

            /* There is a one-to-one correspondence between site links and graph
             * edges (except for site-links which were deemed invalid). When we add
             * edge sets to the graph below, we need to be able to find the graph edge
             * given a site link. We use the 'SetGraphEdge' function to specify this
             * correspondence. */
            pSiteLink->SetGraphEdge( pEdge );

            /* If automatic bridging was enabled for this transport, we go ahead and
             * add this graph edge to the edge set that we are building up. */
            if( pTransport->PerformAutomaticBridging() ) {
                Assert( pEdgeSet!=NULL && pEdgeSet->multiEdgeList!=NULL );
                Assert( numEdgesAdded<cStlk );
                pEdgeSet->multiEdgeList[numEdgesAdded++] = pEdge;
            }
        }

        /* Create the edge sets (bridges) for this transport */
        if( pTransport->PerformAutomaticBridging() ) {
            
            /* Any bridge containing fewer than 2 edges is useless, so we
             * don't bother to add it to the graph state. */
            if( numEdgesAdded>1 ) {
                Assert( pEdgeSet!=NULL && pEdgeSet->multiEdgeList!=NULL );
                Assert( numEdgesAdded<=cStlk );
                pEdgeSet->numMultiEdges = numEdgesAdded;
                ToplAddEdgeSetToGraph( pGraphState, pEdgeSet );
            } else {
                delete[] pEdgeSet->multiEdgeList;
                delete pEdgeSet;
                pEdgeSet = NULL;
            }

            /* If automatic bridging is enabled, then any other bridges are
             * redundant, so we don't bother to process them. */

        } else {

            pBridgeList = pTransport->GetBridgeList();
            ASSERT_VALID( pBridgeList );
            
            cBrdg = pBridgeList->GetCount();
            for( iBrdg=0; iBrdg<cBrdg; iBrdg++) {

                pBridge = pBridgeList->GetBridge(iBrdg);
                ASSERT_VALID( pBridge );
                cStlk = pBridge->GetSiteLinkCount();

                /* Create an edge set corresponding to this bridge */
                pEdgeSet = new TOPL_MULTI_EDGE_SET;
                pEdgeSet->multiEdgeList = new PTOPL_MULTI_EDGE[ cStlk ];
                
                /* Find all the edges that this bridge contains, and add
                 * them to the edge set. */
                numEdgesAdded = 0;
                for( iStlk=0; iStlk<cStlk; iStlk++ ) {
                    pEdge = pBridge->GetSiteLink(iStlk)->GetGraphEdge();
                    if( pEdge!=NULL ) {
                        Assert( pEdgeSet!=NULL && pEdgeSet->multiEdgeList!=NULL );
                        Assert( numEdgesAdded<cStlk );
                        pEdgeSet->multiEdgeList[numEdgesAdded++] = pEdge;
                    }
                }

                /* Any bridge containing fewer than 2 edges is useless, so we
                 * don't bother to add it to the graph state. */
                if( numEdgesAdded>1 ) {
                    Assert( pEdgeSet!=NULL && pEdgeSet->multiEdgeList!=NULL );
                    Assert( numEdgesAdded<=cStlk );
                    pEdgeSet->numMultiEdges = numEdgesAdded;
                    ToplAddEdgeSetToGraph( pGraphState, pEdgeSet );
                } else {
                    delete[] pEdgeSet->multiEdgeList;
                    delete pEdgeSet;
                    pEdgeSet = NULL;
                }

            }   /* For each Bridge */

        }       /* Not Auto-Bridging */

    }           /* For each Transport */

    return pGraphState;
}


VOID
KccCheckSiteConnectivity(
    VOID
    )
/*++

Routine Description:

    This function iterates over all sites in the enterprise and checks if they
    are in any site links. If they are not, and they contain one or more DCs, this
    is logged as a configuration error.

Parameters:

    None.    

Returns:

    Nothing.
        
--*/
{
    KCC_SITE_LIST          *pSiteList = gpDSCache->GetSiteList();
    KCC_SITE               *pSite;
    DWORD                   iSite, cSite;

    ASSERT_VALID( pSiteList );
    cSite = pSiteList->GetCount();

    if( cSite<2 ) {
        // If there are fewer than two sites, then we don't need any site links,
        // so we don't bother to check for them.
        return;
    }

    for( iSite=0; iSite<cSite; iSite++ ) {

        pSite = pSiteList->GetSite(iSite);
        ASSERT_VALID( pSite );

        if ( pSite->GetAnySiteLinkFlag()==FALSE
          && pSite->GetDsaList()->GetCount()>0 )
        {
            LogEvent(
                DS_EVENT_CAT_KCC,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_KCC_SITE_WITH_NO_LINKS,
                szInsertDN( pSite->GetObjectDN() ),
                0, 0
                ); 
        }

    }
    
}

    
TOPL_VERTEX_COLOR
KccSetupColorVtx(
     IN KCC_CROSSREF *       pCrossRef,
     IN KCC_SITE_ARRAY *     pSiteArrayWriteable,
     IN KCC_SITE_ARRAY *     pSiteArrayPartial,
    OUT PTOPL_COLOR_VERTEX  &colorVtxArray,
    OUT DWORD               &numColorVtx
    )
/*++

Routine Description:

    This function allocates a list of colored vertices, in preparation for calling
    the spanning-tree generation function. The colored vertices are sites which
    contain a writeable or partial replica of the NC specified by pCrossRef. Sites
    which contain at least one writeable replica are considered 'red' vertices.
    Sites which contain at least one partial replica but no writeable replicas are
    considered 'black' vertices. All other sites are considered 'white' vertices,
    and are not given a color.

Parameters:

    pCrossRef       - The cross-ref for the NC that we are currently processing.
                      This is needed to determine bridgehead availability at the
                      sites hosting this NC.

    pSiteArrayWriteable / pSiteArrayPartial
                    - These array contain all the sites containing writeable and partial
                      replicas of this NC, respectively.

    colorVtxArray   - A pointer to the array of color vertices that is created.

    numColorVtx     - The number of vertices in the colored vertex array.

Returns:

    The color of the local site.
        
--*/
{
    KCC_TRANSPORT_LIST  *pTransportList = gpDSCache->GetTransportList();
    KCC_TRANSPORT       *pTransport;
    KCC_SITE            *pSite, *pLocalSite = gpDSCache->GetLocalSite();
    KCC_DSA             *pBridgehead;
    BOOLEAN              fAllowReadonlyBridgeheads;
    TOPL_VERTEX_COLOR    localSiteColor;
    DWORD                numWriteable = pSiteArrayWriteable->GetCount();
    DWORD                maxNumColorVtx;
    DWORD                NCType = pCrossRef->GetNCType();
    DWORD                acceptRedRed, acceptBlack, mask;
    DWORD                isite, iTnpt;


    Assert( pSiteArrayWriteable!=NULL && pSiteArrayPartial!=NULL );

    // Check if this NC is hosted in the local site, and thus determine the
    // 'color' of this site, as required by the W32TOPL algorithms.
    if( pSiteArrayWriteable->IsElementOf(pLocalSite) ) {

        // Local site hosts a writeable copy -- we generate the spanning
        // tree between all writeable copies.
        localSiteColor = COLOR_RED;
        maxNumColorVtx = numWriteable;
        fAllowReadonlyBridgeheads = FALSE;

    } else if( pSiteArrayPartial->IsElementOf(pLocalSite) ) {

        // Local site hosts a partial copy -- we must generate the spanning
        // tree between all writeable and partial copies.
        localSiteColor = COLOR_BLACK;
        maxNumColorVtx = numWriteable + pSiteArrayPartial->GetCount();

        // The local site contains only a partial replica of this NC, so it is
        // considered to be generating a 'GC Topology'. This means that we allow
        // bridgeheads to be read-only replicas.
        fAllowReadonlyBridgeheads = TRUE;

    } else {

        // The local site doesn't host this NC, so it is white.
        // This site doesn't need to construct the topology for this NC, so
        // we don't need to build the list of color vertices.
        numColorVtx = 0;
        colorVtxArray = NULL;

        return COLOR_WHITE;
    }

    numColorVtx = 0;
    colorVtxArray = new TOPL_COLOR_VERTEX[ maxNumColorVtx ];

    // Process each site in the pSiteArrayWriteable/Partial arrays, as appropriate.
    for (isite = 0; isite < maxNumColorVtx; isite++)
    {
        if( isite < numWriteable ) {
            Assert( isite < pSiteArrayWriteable->GetCount() );
            pSite = (*pSiteArrayWriteable)[ isite ];
        } else {
            Assert( isite-numWriteable < pSiteArrayPartial->GetCount() );
            pSite = (*pSiteArrayPartial)[ isite-numWriteable ];
        }
        ASSERT_VALID( pSite );
        KccCheckSite( pSite );

        acceptRedRed = acceptBlack = 0;

        // The W32TOPL algorithms only support up to 32 transports.
        Assert( pTransportList->GetCount()<32 );

        for (iTnpt = 0; iTnpt < pTransportList->GetCount(); iTnpt++ )
        {
            pTransport = pTransportList->GetTransport(iTnpt);
            ASSERT_VALID( pTransport );

            // By default, allow this transport at this site
            mask = 1 << iTnpt;

            // 'acceptRedRed' is meaningless for sites which are black (since they
            // will never have any red-red edges), but we compute the bitmap anyways.
            acceptRedRed |= mask;
            acceptBlack |= mask;

            if (!gfAllowMbrBetweenDCsOfSameDomain
                && !fAllowReadonlyBridgeheads
                && !pTransport->IsIntersiteIP()
                && (KCC_NC_TYPE_DOMAIN == NCType) )
            {
                // Disallow this transport at this site between writeable copies
                // (i.e., disable along red-red edges).
                acceptRedRed &= ~mask;

                // This is not a viable transport for this NC
                DPRINT2(3, "Cannot replicate writeable domain NC %ls over non-IP transport %ls.\n",
                    pCrossRef->GetNCDN()->StringName,
                    pTransport->GetDN()->StringName);
                continue;
            }

            if( FALSE==pSite->GetSiteLinkFlag(iTnpt) )
            {
                // If there are no site-links to this site, then disable this transport
                // at this site.
                acceptRedRed &= ~mask;
                acceptBlack &= ~mask;

                DPRINT2( 3, "No site-links at site %ls for transport %ls.\n",
                    pSite->GetObjectDN()->StringName,  pTransport->GetDN()->StringName );
                continue;
            }

            // If there are site-links for this transport at this site, then
            // try to get a bridgehead for this transport at this site.
            // We don't emit warnings here because we are just testing for general
            // bridgehead viability. We don't know yet whether there are any replicas of
            // the partition in other sites which might actually cause this bridgehead
            // to be used.
            if ( pSite->GetSiteLinkFlag(iTnpt)
                 && !pSite->GetNCBridgeheadForTransport(pCrossRef,
                                                        pTransport,
                                                        fAllowReadonlyBridgeheads,
                                                        FALSE, // no warnings
                                                       &pBridgehead) )
            {
                // No bridgehead, so disable this transport at this site completely.
                acceptRedRed &= ~mask;
                acceptBlack &= ~mask;

                DPRINT2( 3, "No bridgehead found for site %ls transport %ls.\n",
                    pSite->GetObjectDN()->StringName,  pTransport->GetDN()->StringName );
            }

        }   // for each transport


        // Add entry for this site to the array of colored vertices
        Assert( numColorVtx < maxNumColorVtx );
        colorVtxArray[ numColorVtx ].name = pSite;
        colorVtxArray[ numColorVtx ].acceptRedRed = acceptRedRed;
        colorVtxArray[ numColorVtx ].acceptBlack = acceptBlack;

        if( isite < numWriteable ) {
            colorVtxArray[ numColorVtx ].color = COLOR_RED;
        } else {
            colorVtxArray[ numColorVtx ].color = COLOR_BLACK;
        }

        numColorVtx++;

    }       // for each site

    return localSiteColor;
}

VOID
KccCreateConnectionsFromSTEdges(
    IN KCC_CROSSREF        *pCrossRef,
    IN TOPL_VERTEX_COLOR    localSiteColor,
    IN PTOPL_MULTI_EDGE    *stEdgeList,
    IN DWORD                numStEdges
    )
/*++

Routine Description:

    This function examines the output of the spanning-tree generation algorithm,
    and creates the appropriate connection objects.

Parameters:

    pCrossRef       - The cross-ref for the NC that we are currently processing.
                      This is needed to determine bridgehead availability at the
                      sites hosting this NC.

    localSiteColor  - Specifies the color of the local site. We use this information
                      to determine if we will accept read-only bridgeheads or not.

    stEdgeList      - The list of spanning-tree edges which was output from the
                      spanning-tree generation algorithm.

    numStEdges      - The number of edges in stEdgeList

Returns:

    Nothing
        
--*/
{
    KCC_TRANSPORT_LIST  *pTransportList = gpDSCache->GetTransportList();
    KCC_SITE            *pLocalSite = gpDSCache->GetLocalSite();
    KCC_SITE_CONNECTION  siteConnection;
    KCC_DSA             *pBridgehead;
    KCC_SITE            *pRemoteSite, *pSite, *pDestSite;
    KCC_TRANSPORT       *pTransport;
    DWORD                iEdge, iVtx, iTnpt;
    DWORD                options, dwReplInterval;
    BOOLEAN              fEdgeContainsLocalSite=FALSE, fAllowReadonlyBridgeheads;


    fAllowReadonlyBridgeheads = ( localSiteColor == COLOR_BLACK );

    // Examine the output edges, and create a site-connection object for each edge
    for( iEdge=0; iEdge<numStEdges; iEdge++ )
    {
        // The vertex names in the output edge are sorted by their name (i.e. GUID).
        // We need to examine them both to determine which is the local site and
        // which is the remote site
        Assert( stEdgeList[iEdge]->numVertices==2 );
        pRemoteSite = NULL;
        for( iVtx=0; iVtx<2; iVtx++ ) {

            pSite = (KCC_SITE*) stEdgeList[iEdge]->vertexNames[iVtx].name;
            ASSERT_VALID( pSite );
            KccCheckSite( pSite );
            
            if( pSite == pLocalSite ) {
                fEdgeContainsLocalSite = TRUE;
            } else {
                pRemoteSite = pSite;
            }
        }
        Assert( fEdgeContainsLocalSite );

        // If W32TOPL passed back a directed edge and the local site is not
        // the destination of this directed edge, we don't create a connection.
        if( stEdgeList[iEdge]->fDirectedEdge ) {
            pDestSite = (KCC_SITE*) stEdgeList[iEdge]->vertexNames[1].name;
            if( pDestSite!=pLocalSite ) {
                continue;
            }
        }

        siteConnection.Init();

        // Determine which transport should be used
        iTnpt = stEdgeList[iEdge]->edgeType;
        if( iTnpt >= pTransportList->GetCount() ) {
            Assert( !"A TOPL_MULTI_EDGE passed into KccCreateConnectionsFromSTEdges "
                    "had an invalid edgeType." );
            continue;
        }

        pTransport = pTransportList->GetTransport( iTnpt );
        if( NULL==pTransport ) {
            Assert( !"pTransportList->GetTransport() returned NULL unexpectedly" );
            continue;
        }

        siteConnection.SetTransport( pTransport );


        // Find the source (i.e. remote) site and bridgehead
        ASSERT_VALID( pRemoteSite );
        siteConnection.SetSourceSite( pRemoteSite );
        if( ! pRemoteSite->GetNCBridgeheadForTransport( pCrossRef, pTransport,
                    fAllowReadonlyBridgeheads, TRUE, &pBridgehead ) )
        {
            // We failed to find a bridgehead for pLocalSite.
            // This should never happen, since we already found a bridgehead above.
            DPRINT2( 3, "No bridgehead found for site %ls transport %ls.\n",
                pRemoteSite->GetObjectDN()->StringName,  pTransport->GetDN()->StringName );
            Assert( FALSE && "No bridgehead found when processing output" );
            continue;
        }
        siteConnection.SetSourceDSA( pBridgehead );


        // Find the destination (i.e. local) site and bridgehead            
        siteConnection.SetDestinationSite( pLocalSite );
        if (!pLocalSite->GetNCBridgeheadForTransport( pCrossRef, pTransport,
                    fAllowReadonlyBridgeheads, TRUE, &pBridgehead ) )
        {
            // We failed to find a bridgehead for pLocalSite.
            // This should never happen, since we already found a bridgehead above.
            DPRINT2( 3, "No bridgehead found for site %ls transport %ls.\n",
                pLocalSite->GetObjectDN()->StringName,  pTransport->GetDN()->StringName );
            Assert( FALSE && "No bridgehead found when processing output" );
            continue;
        }
        siteConnection.SetDestinationDSA( pBridgehead );


        // Set the various replication options
        options = stEdgeList[iEdge]->ri.options;
        siteConnection.SetCost( stEdgeList[iEdge]->ri.cost );
        dwReplInterval = stEdgeList[iEdge]->ri.repIntvl;
        // We are building n-way redundancy, so reduce frequency by 1/n
        // We count on schedule staggering to offset the schedules
        if (pLocalSite->BuildRedundantServerTopology()) {
            dwReplInterval *= NTDSSETTINGS_DEFAULT_SERVER_REDUNDANCY;
        }
        siteConnection.SetReplInterval( dwReplInterval );
        siteConnection.SetUsesNotification( options & NTDSSITELINK_OPT_USE_NOTIFY );
        siteConnection.SetTwoWaySync( options & NTDSSITELINK_OPT_TWOWAY_SYNC );
        siteConnection.SetDisableCompression( options & NTDSSITELINK_OPT_DISABLE_COMPRESSION );

        // Set up the schedule
        siteConnection.SetSchedule( stEdgeList[iEdge]->ri.schedule, dwReplInterval );

        // Supportability logging event 4
        LogEvent8(
            DS_EVENT_CAT_KCC,
            DS_EVENT_SEV_EXTENSIVE,
            DIRLOG_KCC_CONNECTION_EDGE_NEEDED,
            szInsertDN(siteConnection.GetSourceSite()->GetObjectDN()),
            szInsertDN(siteConnection.GetDestinationDSA()->GetDsName()),
            szInsertDN(siteConnection.GetSourceDSA()->GetDsName()),
            szInsertDN(siteConnection.GetTransport()->GetDN()),
            0, 0, 0, 0
            ); 

        //
        // Create the ntdsconnection if one does not already exist
        //
        KccCreateConnectionToSite( pCrossRef,
                                   pLocalSite,
                                   &siteConnection,
                                   fAllowReadonlyBridgeheads,
                                   *pTransportList );
    }

}


/***** NonintersectingScheduleExceptionHandler *****/
/* Check if this exception is the 'non-intersecting schedule' exception from
 * W32TOPL. If it is, extract the information (site pointers) which describes
 * where the non-intersecting schedules were found, and log an error. */
LONG
NonintersectingScheduleExceptionHandler(
    PEXCEPTION_POINTERS  pep,
    KCC_CROSSREF        *pCrossRef
    )
{
    EXCEPTION_RECORD *per=pep->ExceptionRecord;
    KCC_SITE         *pSite[3];
    DWORD             i;

    if( per->ExceptionCode==TOPL_EX_NONINTERSECTING_SCHEDULES )
    {
        Assert( per->NumberParameters==3 );
        Assert( sizeof(PVOID)==sizeof(ULONG_PTR) );

        for( i=0; i<3; i++ ) {
            pSite[i] = ((KCC_SITE**) per->ExceptionInformation)[i];
            ASSERT_VALID( pSite[i] );
            KccCheckSite( pSite[i] );
        }        

        DPRINT4( 0, "When processing the topology for NC %ls, a shortest-path with "
                "non-intersecting schedules was found. The path originated at site %ls "
                "and the non-intersecting schedules were discovered between sites %ls "
                "and %ls. This path is considered invalid and be ignored.\n",
                pCrossRef->GetNCDN()->StringName,
                pSite[0]->GetObjectDN()->StringName,
                pSite[1]->GetObjectDN()->StringName,
                pSite[2]->GetObjectDN()->StringName
                );
        
        LogEvent8( DS_EVENT_CAT_KCC,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_KCC_NONINTERSECTING_SCHEDULES,
                  szInsertDN( pCrossRef->GetNCDN() ),
                  szInsertDN( pSite[0]->GetObjectDN() ),
                  szInsertDN( pSite[1]->GetObjectDN() ),
                  szInsertDN( pSite[2]->GetObjectDN() ),
                  0, 0, 0, 0
                  );

        return EXCEPTION_CONTINUE_EXECUTION;
    }
    
    return EXCEPTION_CONTINUE_SEARCH;
}


/***** KccNoSpanningTree *****/
VOID
KccNoSpanningTree(
    IN KCC_CROSSREF    *pCrossRef,
    IN PTOPL_COMPONENTS pComponentInfo
    )
/*++

Routine Description:

    We could not build a spanning tree which connects the whole enterprise.
    In this function we mark all sites which are not in the local component
    as unreachable. We also log an event stating this problem and the DNs of
    sites that could not be reached.

    At most 8 sites are logged at ALWAYS severity; any additional sites are
    logged at EXTENSIVE severity.

Parameters:

    pCrossRef       The crossref for the NC that we are currently proccessing
    pComponentInfo  Info about the components as returned by W32TOPL
                      
Returns:

    None
    
--*/
{
    KCC_SITE           *pSite, *pLocalSite = gpDSCache->GetLocalSite();
    BOOL                fFoundLocalSite=FALSE;
    TOPL_COMPONENT     *pComp;
    DWORD               iComp, iVtx, iDN, cUnreachable, dwLoggingLevel;
    KCC_DSNAME_ARRAY    unreachableDNArray;

    Assert( NULL!=pComponentInfo );

    /* Log a generic event about the failure to create a spanning tree */
    DPRINT1(1, "Minimum spanning tree does not exist for NC %ls.\n",
            pCrossRef->GetNCDN()->StringName );
    LogEvent(
        DS_EVENT_CAT_KCC,
        DS_EVENT_SEV_ALWAYS,
        DIRLOG_KCC_NO_SPANNING_TREE,
        szInsertDN(pCrossRef->GetNCDN()),
        0, 0 ); 

    /* Verify that the local site is in the first component */
    #ifdef DBG
        Assert( pComponentInfo->numComponents>=2 );
        pComp = &pComponentInfo->pComponent[0];
        for( iVtx=0; iVtx<pComp->numVertices; iVtx++ ) {
            if( pComp->vertexNames[iVtx]==pLocalSite ) {
                fFoundLocalSite = TRUE;
                break;
            }
        }
        Assert( fFoundLocalSite );
    #endif

    /* Find all sites which cannot be reached. Any site in 
     * Component0 can be reached, so we start looking in Component1.
     * Also mark all sites in other components as unreachable. */
    for( iComp=1; iComp<pComponentInfo->numComponents; iComp++ ) {
        pComp = &pComponentInfo->pComponent[iComp];
        for( iVtx=0; iVtx<pComp->numVertices; iVtx++ ) {
            pSite = (KCC_SITE*) pComp->vertexNames[iVtx];
            ASSERT_VALID(pSite);
            Assert( pSite!=gpDSCache->GetLocalSite() );
            pSite->SetUnreachable();
            unreachableDNArray.Add( pSite->GetObjectDN() );
        }
    }

    /* Log the DNs of unreachable sites in batches of 8.
     * The first message is logged with severity ALWAYS but subsequent
     * messages are logged with severity EXTENSIVE. */
    dwLoggingLevel = DS_EVENT_SEV_ALWAYS;
    cUnreachable = unreachableDNArray.GetCount();

    for( iDN=0; iDN<cUnreachable; iDN+=8 ) {

        /* Define a macro to add one site DN to the event log message */
        #define INSERT_UNREACHABLE_SITE(x) \
            (iDN+x < cUnreachable) ? \
                szInsertDN(unreachableDNArray[iDN+x]) : szInsertSz("")

        LogEvent8(
            DS_EVENT_CAT_KCC,
            dwLoggingLevel,
            DIRLOG_KCC_DISCONNECTED_SITE,
            INSERT_UNREACHABLE_SITE(0),
            INSERT_UNREACHABLE_SITE(1),
            INSERT_UNREACHABLE_SITE(2),
            INSERT_UNREACHABLE_SITE(3),
            INSERT_UNREACHABLE_SITE(4),
            INSERT_UNREACHABLE_SITE(5),
            INSERT_UNREACHABLE_SITE(6),
            INSERT_UNREACHABLE_SITE(7)
            );
        
        dwLoggingLevel = DS_EVENT_SEV_EXTENSIVE;
    }
}


VOID
KccGenerateTopologiesWhistler( VOID )
/*++

Routine Description:

    This function generates the inter-site topology when the forest is in
    Whistler mode. A single graph state object is created to represent the
    network structure, then for each NC we calculate a minimum-cost spanning
    tree. We create connection objects for each edge in the spanning tree
    which is incident with the local site.

Parameters:

    None
                      
Returns:

    If topology generation was not completely successful, we return true
    so that existing connections will be kept.
    
--*/
{
    KCC_CROSSREF_LIST *  pCrossRefList = gpDSCache->GetCrossRefList();
    KCC_SITE_ARRAY *     pSiteArrayWriteable;
    KCC_SITE_ARRAY *     pSiteArrayPartial;
    KCC_SITE *           pLocalSite = gpDSCache->GetLocalSite();
    KCC_CROSSREF *       pCrossRef;
    PTOPL_GRAPH_STATE    pGraphState;
    TOPL_VERTEX_COLOR    localSiteColor;
    TOPL_COLOR_VERTEX   *colorVtxArray;
    PTOPL_MULTI_EDGE    *stEdgeList;
    TOPL_COMPONENTS      componentInfo;
    DWORD                numColorVtx, numVtxStEdges;
    DWORD                icr, ccr;
    DWORD                errCode;


    DPRINT( 3, "KCC is using the Whistler Topology Generation Algorithm\n" );
    LogEvent(DS_EVENT_CAT_KCC,
             DS_EVENT_SEV_EXTENSIVE,
             DIRLOG_KCC_WHISTLER_TOPOLOGY_ALG,
             0, 0, 0);

    pGraphState = KccSetupGraphState();
    KccCheckSiteConnectivity();

    //
    // For each NC that is shared between two or more sites, create inter site 
    // connections between sites with that NC.
    //
    ccr = pCrossRefList->GetCount();
    for( icr=0; icr<ccr; icr++ )
    {
        pCrossRef = pCrossRefList->GetCrossRef(icr);
        pSiteArrayWriteable = pCrossRef->GetWriteableSites();
        pSiteArrayPartial = pCrossRef->GetPartialSites();

        if( icr==ccr-2 ) {
            // Schema should always be the penultimate crossref.
            // We skip it, because it has the same requirements as Config.
            Assert( KCC_NC_TYPE_SCHEMA==pCrossRef->GetNCType() );
            continue;
        }
        if( icr==ccr-1 ) {
            // Config should always be the last crossref.
            Assert( KCC_NC_TYPE_CONFIG==pCrossRef->GetNCType() );
        }

        DPRINT3( 3, "Naming Context %ls is in %d writable sites, %d partial sites\n", 
                 pCrossRef->GetNCDN()->StringName,
                 pSiteArrayWriteable->GetCount(),
                 pSiteArrayPartial->GetCount() );   

        // Supportability logging event 2
        LogEvent(
            DS_EVENT_CAT_KCC,
            DS_EVENT_SEV_EXTENSIVE,
            DIRLOG_KCC_NC_SITE_TOPOLOGY,
            szInsertDN(pCrossRef->GetNCDN()),
            szInsertUL(pSiteArrayWriteable->GetCount()),
            szInsertUL(pSiteArrayPartial->GetCount())
            );

        __try {

            // Setup a 'color vertex' list, which contains information about all sites
            // which host this NC, and the bridgeheads which are available at those sites.
            localSiteColor = KccSetupColorVtx( pCrossRef,
                                               pSiteArrayWriteable,
                                               pSiteArrayPartial,
                                               colorVtxArray,
                                               numColorVtx );
            
            if( localSiteColor==COLOR_WHITE || numColorVtx<2 ) {
    
                DPRINT1(3, "Do not need to build spanning tree for NC %ls.\n",
                        pCrossRef->GetNCDN()->StringName );
    
                // Either the local site does not host this NC, or
                // the spanning tree would not have any edges. In
                // either case, we do not need to compute the topology.
                // Skip to the next NC.
                __leave;
    
            }
    
            DPRINT2(3, "Running spanning tree algorithm for NC %ls. There are "
                       "%d colored vertices.\n",
                       pCrossRef->GetNCDN()->StringName,
                       numColorVtx );
    
            // Call W32TOPL's new spanning tree algorithm
            __try {

                stEdgeList = ToplGetSpanningTreeEdgesForVtx( pGraphState, pLocalSite,
                    colorVtxArray, numColorVtx, &numVtxStEdges, &componentInfo );

            } __except( NonintersectingScheduleExceptionHandler(
                            GetExceptionInformation(), pCrossRef) )
            {
                // Do nothing here -- exception was handled in handler function
            }
    
            DPRINT2(3, "Topology generation finished. There are %d graph components, "
                       "and %d edges at the local site.\n",
                       componentInfo.numComponents, numVtxStEdges );
                
            // If there is more than one component, then the enterprise is not
            // fully connected by the tree (i.e. the tree is not spanning).
            if( componentInfo.numComponents > 1 ) {    
    
                KccNoSpanningTree( pCrossRef, &componentInfo );

            }
    
            KccCreateConnectionsFromSTEdges( pCrossRef, localSiteColor,
                stEdgeList, numVtxStEdges );
    
            // Clean up the memory that we used while processing this NC
            Assert( colorVtxArray!=NULL );
            delete[] colorVtxArray;
            ToplDeleteSpanningTreeEdges( stEdgeList, numVtxStEdges );
            ToplDeleteComponents( &componentInfo );

        } __except( ToplIsToplException( ( errCode=GetExceptionCode() ) ) ) {

            //
            // The w32topl library threw an occur code; the implies an internal
            // mishandling of the objects.  Log an error indicated the inter-site
            // topology failed for this NC
            //
    
            DPRINT1( 1, "W32TOPL routines threw a %d exception during inter-site topology creation.\n", 
                     errCode );
    
            LogEvent8( DS_EVENT_CAT_KCC,
                       DS_EVENT_SEV_ALWAYS,
                       DIRLOG_KCC_AUTO_TOPL_GENERATION_INCOMPLETE,
                       szInsertDN(pCrossRef->GetNCDN()),
                       szInsertWin32ErrCode(errCode),
                       szInsertHex( DSID(FILENO, __LINE__) ),
                       szInsertWin32Msg(errCode),
                       NULL, NULL, NULL, NULL );
        }

    }   // Build topology for each NC

    ToplDeleteGraphState( pGraphState );

    // Note: We have not freed the memory for:
    //      The array of vertex names
    //      The edge sets
    // This memory will be cleared up when the thread exits
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\sim\buildcfg.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    buildcfg.c

ABSTRACT:

    Configuration Builder.  Loads INI files.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <attids.h>
#include <debug.h>
#include "kccsim.h"
#include "util.h"
#include "dir.h"
#include "ldif.h"
#include "user.h"
#include "buildcfg.h"
#include <fileno.h>
#define FILENO  FILENO_KCCSIM_BUILDCFG

BUILDCFG_GLOBALS                    globals;

RTL_GENERIC_COMPARE_RESULTS
NTAPI
BuildCfgCompareUuids (
    IN  PRTL_GENERIC_TABLE          pTable,
    IN  PVOID                       pFirstStruct,
    IN  PVOID                       pSecondStruct
    )
/*++

Routine Description:

    Compares two UUIDs.  For use with an RTL_GENERIC_TABLE.

Arguments:

    pTable              - The table containing the UUIDs.
    pFirstStruct        - The first UUID.
    pSecondStruct       - The second UUID.

Return Value:

    GenericLessThan, GenericEqual or GenericGreaterThan.

--*/
{
    INT                             iCmp;
    RTL_GENERIC_COMPARE_RESULTS     result;

    iCmp = memcmp (pFirstStruct, pSecondStruct, sizeof (UUID));
    if (iCmp < 0) {
        result = GenericLessThan;
    } else if (iCmp > 0) {
        result = GenericGreaterThan;
    } else {
        Assert (iCmp == 0);
        result = GenericEqual;
    }

    return result;
}

VOID
BuildCfgMakeUuids (
    IN  ULONG                       ulNumUuids
    )
/*++

Routine Description:

    Creates a bunch of UUIDs and sorts them in ascending order.

Arguments:

    ulNumUuids          - The number of UUIDs to make.

Return Value:

    None.

--*/
{
    UUID                            uuid;
    ULONG                           ul;

    RtlInitializeGenericTable (
        &globals.tableUuids,
        BuildCfgCompareUuids,
        KCCSimTableAlloc,
        KCCSimTableFree,
        NULL
        );

    for (ul = 0; ul < ulNumUuids; ul++) {
        KCCSIM_CHKERR (UuidCreate (&uuid));
        RtlInsertElementGenericTable (
            &globals.tableUuids,
            &uuid,
            sizeof (UUID),
            NULL
            );
    }

    RtlEnumerateGenericTable (&globals.tableUuids, TRUE);
}

LPCWSTR
BuildCfgGetFirstStringByKey (
    IN  LPCWSTR                     pwszStringBlock,
    IN  LPCWSTR                     pwszKey
    )
/*++

Routine Description:

    When parsing INI files, we want to avoid GetPrivateProfileStringW for
    two reasons: first, it is very slow, and second, it does not recognize
    keys with multiple values.  This function provides a substitute.  It
    scans through a multi-string returned by GetPrivateProfileSectionW for
    a given key and returns the associated value.  Additional values can be
    obtained by calling BuildCfgGetNextStringByKey.

Arguments:

    pwszStringBlock     - A block of strings returned by
                          GetPrivateProfileSectionW.
    pwszKey             - The key to search for.

Return Value:

    The associated value, or NULL if the key cannot be found.

--*/
{
    LPCWSTR                         pwszKeyAt = pwszStringBlock;
    LPCWSTR                         pwszString = NULL;
    ULONG                           ulKeyAtLen;

    while (*pwszKeyAt != L'\0') {

        // Get the key length of this entry
        for (ulKeyAtLen = 0; pwszKeyAt[ulKeyAtLen] != L'='; ulKeyAtLen++) {
            // We should never hit a \0 or space before an =
            Assert (pwszKeyAt[ulKeyAtLen] != L' ');
            Assert (pwszKeyAt[ulKeyAtLen] != L'\0');
        }

        if (wcslen (pwszKey) == ulKeyAtLen &&
            _wcsnicmp (pwszKey, pwszKeyAt, ulKeyAtLen) == 0) {
            pwszString = pwszKeyAt + (ulKeyAtLen + 1);
            break;
        }

        // Advance to the next string
        pwszKeyAt += (wcslen (pwszKeyAt) + 1);
    }

    return pwszString;
}

LPCWSTR
BuildCfgDemandFirstStringByKey (
    IN  LPCWSTR                     pwszFn,
    IN  LPCWSTR                     pwszSection,
    IN  LPCWSTR                     pwszStringBlock,
    IN  LPCWSTR                     pwszKey
    )
/*++

Routine Description:

    Same as BuildCfgGetFirstStringByKey, but raises an exception if they key
    is not found.

Arguments:

    pwszFn              - The filename of the INI file.  Used for error
                          reporting.
    pwszSection         - The name of the INI file section.  Also used for
                          error reporting.
    pwszStringBlock     - A block of strings returned by
                          GetPrivateProfileSectionW.
    pwszKey             - The key to search for.

Return Value:

    The associated value.  Never returns NULL.

--*/
{
    LPCWSTR                         pwszString;

    pwszString = BuildCfgGetFirstStringByKey (pwszStringBlock, pwszKey);
    if (pwszString == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            BUILDCFG_ERROR_KEY_ABSENT,
            pwszFn,
            pwszSection,
            pwszKey
            );
    }

    return pwszString;
}

LPCWSTR
BuildCfgGetNextStringByKey (
    IN  LPCWSTR                     pwszString,
    IN  LPCWSTR                     pwszKey
    )
/*++

Routine Description:

    Returns the next value associated with a particular key.

Arguments:

    pwszString          - The previous value, returned by
                          BuildCfgGetFirstStringByKey or
                          BuildCfgGetNextStringByKey.
    pwszKey             - The key to search for.

Return Value:

    The next associated value, or NULL if no more exist.

--*/
{
    // Advance to the next string
    pwszString += (wcslen (pwszString) + 1);
    return BuildCfgGetFirstStringByKey (pwszString, pwszKey);
}

LPWSTR
BuildCfgAllocGetSection (
    IN  LPCWSTR                     pwszFn,
    IN  LPCWSTR                     pwszSection
    )
/*++

Routine Description:

    Retrieves a section from the INI file, allocating space to hold it.

Arguments:

    pwszFn              - The filename of the INI file.
    pwszSection         - The name of the section.

Return Value:

    The section, as a multisz string, or NULL if it does not exist.

--*/
{
    DWORD                           dwBufSize;
    DWORD                           dwBufUsed;
    LPWSTR                          pwszBuf = NULL;

    dwBufSize = 0;
    while (TRUE) {
        dwBufSize += 1024;
        pwszBuf = KCCSimAlloc (sizeof (WCHAR) * dwBufSize);
        dwBufUsed = GetPrivateProfileSectionW (
            pwszSection,
            pwszBuf,
            dwBufSize,
            pwszFn
            );
        if (dwBufUsed == dwBufSize - 2) {
            KCCSimFree (pwszBuf);
        } else {
            break;
        }
    }

    return pwszBuf;
}

LPWSTR
BuildCfgAllocDemandSection (
    IN  LPCWSTR                     pwszFn,
    IN  LPCWSTR                     pwszSection
    )
/*++

Routine Description:

    Same as BuildCfgAllocGetSection, but raises an exception if the section
    does not exist.

Arguments:

    pwszFn              - The filename of the INI file.
    pwszSection         - The name of the section.

Return Value:

    The section, as a multisz string.  Never returns NULL.

--*/
{
    LPWSTR                          pwszBuf;

    pwszBuf = BuildCfgAllocGetSection (pwszFn, pwszSection);

    if (pwszBuf[0] == L'\0') {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            BUILDCFG_ERROR_SECTION_ABSENT,
            pwszFn,
            pwszSection
            );
    }

    return pwszBuf;
}

VOID
BuildCfgProcessServers (
    IN  LPCWSTR                     pwszFn,
    IN  LPCWSTR                     pwszSiteName,
    IN  PSIM_ENTRY                  pEntryServersContainer,
    IN  LPCWSTR                     pwszServerType,
    IN  ULONG                       ulNumServers,
    IN  PSIM_ENTRY                  pEntryNTDSSiteSettings
    )
/*++

Routine Description:

    Creates servers within a site.

Arguments:

    pwszFn              - The filename of the INI file.
    pwszSiteName        - The name of the site in which to place the servers.
    pEntryServersContainer - The entry that corresponds to the servers
                          container of this site.
    pwszServerType      - The server type (section heading) to create.
    ulNumServers        - The number of servers to create.
    pEntryNTDSSiteSettings - The entry that corresponds to the NTDS Site
                          Settings object of this site.

Return Value:

    None.

--*/
{
    LPWSTR                          pwszSectionServer = NULL;

    LPCWSTR                         pwszServerOptions, pwszDomain, pwszRDNMask,
                                    pwszBridgehead[BUILDCFG_NUM_TRANSPORTS];

    PSIM_ENTRY                      pEntryServer;
    ULONG                           ulServerOptions, ulServerNum, ul,
                                    ulBridgeheadAt;

    Assert (globals.pdnRootDomain != NULL);

    Assert (pEntryServersContainer != NULL);

    if (pwszServerType[0] == L'\0') {
        // Generic servers.
        ulServerOptions = 0;
        pwszRDNMask = BUILDCFG_GENERIC_SERVER_ID;
        pwszDomain = globals.pdnRootDomain->StringName;
        pwszBridgehead[0] = NULL;
    } else {

        ulServerOptions = 0;

        pwszSectionServer = BuildCfgAllocDemandSection (
            pwszFn,
            pwszServerType
            );
        pwszServerOptions = BuildCfgGetFirstStringByKey (
            pwszSectionServer,
            BUILDCFG_KEY_SERVEROPTIONS
            );

        if (pwszServerOptions != NULL) {
            for (ul = 0; pwszServerOptions[ul] != L'\0'; ul++) {
                switch (towupper (pwszServerOptions[ul])) {
                    case KCCSIM_CID_NTDSDSA_OPT_IS_GC:
                        ulServerOptions |= NTDSDSA_OPT_IS_GC;
                        break;
                    case KCCSIM_CID_NTDSDSA_OPT_DISABLE_INBOUND_REPL:
                        ulServerOptions |= NTDSDSA_OPT_DISABLE_INBOUND_REPL;
                        break;
                    case KCCSIM_CID_NTDSDSA_OPT_DISABLE_OUTBOUND_REPL:
                        ulServerOptions |= NTDSDSA_OPT_DISABLE_OUTBOUND_REPL;
                        break;
                    case KCCSIM_CID_NTDSDSA_OPT_DISABLE_NTDSCONN_XLATE:
                        ulServerOptions |= NTDSDSA_OPT_DISABLE_NTDSCONN_XLATE;
                        break;
                    case L' ':
                        break;
                    default:
                        KCCSimException (
                            KCCSIM_ETYPE_INTERNAL,
                            BUILDCFG_ERROR_INVALID_SERVER_OPTION,
                            pwszFn,
                            pwszServerType,
                            pwszServerOptions
                            );
                        break;
                }
            }
        }

        pwszDomain = BuildCfgGetFirstStringByKey (
            pwszSectionServer,
            BUILDCFG_KEY_DOMAIN
            );
        if (pwszDomain == NULL) {
            pwszDomain = globals.pdnRootDomain->StringName;
        }

        pwszRDNMask = BuildCfgGetFirstStringByKey (
            pwszSectionServer,
            BUILDCFG_KEY_RDNMASK
            );
        if (pwszRDNMask == NULL) {
            pwszRDNMask = pwszServerType;
        }

        // Determine the transports for which this type of server is an
        // explicit bridgehead.
        ulBridgeheadAt = 0;
        for (pwszBridgehead[ulBridgeheadAt] = BuildCfgGetFirstStringByKey (
                pwszSectionServer, BUILDCFG_KEY_BRIDGEHEAD);
             pwszBridgehead[ulBridgeheadAt] != NULL;
             pwszBridgehead[ulBridgeheadAt] = BuildCfgGetNextStringByKey (
                pwszBridgehead[ulBridgeheadAt-1], BUILDCFG_KEY_BRIDGEHEAD)) {
            ulBridgeheadAt++;
        }

    }

    // Now actually add the servers.

    ulServerNum = 0;
    for (ul = 0; ul < ulNumServers; ul++) {

        pEntryServer = BuildCfgMakeServer (
            &ulServerNum,
            pwszRDNMask,
            pwszSiteName,
            pwszDomain,
            pEntryServersContainer,
            ulServerOptions
            );

        // For each transport that we're an explicit bridgehead for, add us
        // to the explicit bridgeheads list.
        for (ulBridgeheadAt = 0;
             pwszBridgehead[ulBridgeheadAt] != NULL;
             ulBridgeheadAt++) {
            BuildCfgAddAsBridgehead (
                pwszServerType,
                pEntryServer,
                pwszBridgehead[ulBridgeheadAt]
                );
        }

        ulServerNum++;
    }

    KCCSimFree (pwszSectionServer);
}

VOID
BuildCfgProcessSite (
    IN  LPCWSTR                     pwszFn,
    IN  LPCWSTR                     pwszSiteName
    )
/*++

Routine Description:

    Create a site.

Arguments:

    pwszFn              - The filename of the INI file.
    pwszSiteName        - The name of the site.

Return Value:

    None.

--*/
{
    PSIM_ENTRY                      pEntrySite, pEntryServersContainer,
                                    pEntryNTDSSiteSettings, pEntryServer;

    LPWSTR                          pwszSectionSite;

    LPCWSTR                         pwszSiteOptions, pwszISTG,
                                    pwszServersInfo, pwszPos;
    ULONG                           ulSiteOptions,
                                    ulNumServers, ulServerOptions, ul;
    LPWSTR                          pwszNumEnd;

    Assert (globals.pEntrySitesContainer != NULL);

    pwszSectionSite = BuildCfgAllocDemandSection (
        pwszFn,
        pwszSiteName
        );
    pwszSiteOptions = BuildCfgGetFirstStringByKey (
        pwszSectionSite,
        BUILDCFG_KEY_SITEOPTIONS
        );
    ulSiteOptions = 0;
    if (pwszSiteOptions != NULL) {
        for (ul = 0; pwszSiteOptions[ul] != L'\0'; ul++) {
            switch (towupper (pwszSiteOptions[ul])) {
                case KCCSIM_CID_NTDSSETTINGS_OPT_IS_AUTO_TOPOLOGY_DISABLED:
                    ulSiteOptions |=
                    NTDSSETTINGS_OPT_IS_AUTO_TOPOLOGY_DISABLED;
                    break;
                case KCCSIM_CID_NTDSSETTINGS_OPT_IS_TOPL_CLEANUP_DISABLED:
                    ulSiteOptions |=
                    NTDSSETTINGS_OPT_IS_TOPL_CLEANUP_DISABLED;
                    break;
                case KCCSIM_CID_NTDSSETTINGS_OPT_IS_TOPL_MIN_HOPS_DISABLED:
                    ulSiteOptions |=
                    NTDSSETTINGS_OPT_IS_TOPL_MIN_HOPS_DISABLED;
                    break;
                case KCCSIM_CID_NTDSSETTINGS_OPT_IS_TOPL_DETECT_STALE_DISABLED:
                    ulSiteOptions |=
                    NTDSSETTINGS_OPT_IS_TOPL_DETECT_STALE_DISABLED;
                    break;
                case KCCSIM_CID_NTDSSETTINGS_OPT_IS_INTER_SITE_AUTO_TOPOLOGY_DISABLED:
                    ulSiteOptions |=
                    NTDSSETTINGS_OPT_IS_INTER_SITE_AUTO_TOPOLOGY_DISABLED;
                    break;
                case L' ':
                    break;
                default:
                    KCCSimException (
                        KCCSIM_ETYPE_INTERNAL,
                        BUILDCFG_ERROR_INVALID_SITE_OPTION,
                        pwszFn,
                        pwszSiteName,
                        pwszSiteOptions
                        );
                    break;
            }
            pwszSiteOptions++;
        }
    }

    pEntrySite = BuildCfgMakeSite (pwszSiteName, ulSiteOptions);
    pEntryServersContainer = KCCSimFindFirstChild (
        pEntrySite, CLASS_SERVERS_CONTAINER, NULL);
    pEntryNTDSSiteSettings = KCCSimFindFirstChild (
        pEntrySite, CLASS_NTDS_SITE_SETTINGS, NULL);
    Assert (pEntryServersContainer != NULL);
    Assert (pEntryNTDSSiteSettings != NULL);

    // Create the servers for this site
    for (pwszServersInfo = BuildCfgDemandFirstStringByKey (
            pwszFn, pwszSiteName, pwszSectionSite, BUILDCFG_KEY_SERVERS);
         pwszServersInfo != NULL;
         pwszServersInfo = BuildCfgGetNextStringByKey (
            pwszServersInfo, BUILDCFG_KEY_SERVERS)) {

        ulNumServers = wcstoul (pwszServersInfo, &pwszNumEnd, 10);
        if (ulNumServers == 0) {
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                BUILDCFG_ERROR_INVALID_SERVERS,
                pwszFn,
                pwszSiteName,
                pwszServersInfo
                );
        }

        while (*pwszNumEnd == L',' || *pwszNumEnd == L' ') {
            pwszNumEnd++;
        }

        BuildCfgProcessServers (
            pwszFn,
            pwszSiteName,
            pEntryServersContainer,
            pwszNumEnd,
            ulNumServers,
            pEntryNTDSSiteSettings
            );

    }

    // Set the inter-site topology generator.

    pwszISTG = BuildCfgDemandFirstStringByKey (
        pwszFn, pwszSiteName, pwszSectionSite, BUILDCFG_KEY_ISTG);

    if (!BuildCfgISTG (pEntryNTDSSiteSettings, pEntryServersContainer, pwszISTG)) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            BUILDCFG_ERROR_INVALID_ISTG,
            pwszFn,
            pwszSiteName,
            pwszISTG
            );
    }

    KCCSimFree (pwszSectionSite);
}


BYTE CharToNibble( char c ) {
    if( c>='0' && c<='9' ) {
        return c-'0';
    }
    if( c>='A' && c<='F' ) {
        return c-'A'+10;
    }
    return 0;
}


VOID
BuildCfgProcessSiteLink (
    IN  LPCWSTR                     pwszFn,
    IN  LPCWSTR                     pwszSiteLink
    )
/*++

Routine Description:

    Create a site-link.

Arguments:

    pwszFn              - The filename of the INI file.
    pwszSiteLink        - The name of the site-link.

Return Value:

    None.

--*/
{
    PSIM_ENTRY                      pEntrySiteLink;

    LPWSTR                          pwszSectionSiteLink;
    LPCWSTR                         pwszTransport, pwszSiteName,
                                    pwszSiteLinkOptions, pwszSchedule;
    ULONG                           ulCost, ulReplInterval,
                                    ulSiteLinkOptions, ul;
    DWORD                           cbSchedule, cbSchedData;
    DWORD                           iChar, cChar, iData;
    PSCHEDULE                       pSchedule;
    BYTE                           *pData,x;
    char*                           mbstr;

    pwszSectionSiteLink = BuildCfgAllocDemandSection (
        pwszFn,
        pwszSiteLink
        );

    pwszTransport = BuildCfgDemandFirstStringByKey (
        pwszFn,
        pwszSiteLink,
        pwszSectionSiteLink,
        BUILDCFG_KEY_TRANSPORT
        );
    ulCost = wcstoul (BuildCfgDemandFirstStringByKey (
        pwszFn,
        pwszSiteLink,
        pwszSectionSiteLink,
        BUILDCFG_KEY_COST
        ), NULL, 10);
    ulReplInterval = wcstoul (BuildCfgDemandFirstStringByKey (
        pwszFn,
        pwszSiteLink,
        pwszSectionSiteLink,
        BUILDCFG_KEY_REPLINTERVAL
        ), NULL, 10);
    pwszSiteLinkOptions = BuildCfgGetFirstStringByKey (
        pwszSectionSiteLink,
        BUILDCFG_KEY_SITELINKOPTIONS
        );
    ulSiteLinkOptions = 0;
    if (pwszSiteLinkOptions != NULL) {
        for (ul = 0; pwszSiteLinkOptions[ul] != L'\0'; ul++) {
            switch (towupper (pwszSiteLinkOptions[ul])) {
                case KCCSIM_CID_NTDSSITELINK_OPT_USE_NOTIFY:
                    ulSiteLinkOptions |= NTDSSITELINK_OPT_USE_NOTIFY;
                    break;
                case KCCSIM_CID_NTDSSITELINK_OPT_TWOWAY_SYNC:
                    ulSiteLinkOptions |= NTDSSITELINK_OPT_TWOWAY_SYNC;
                    break;
                case L' ':
                    break;
                default:
                    KCCSimException (
                        KCCSIM_ETYPE_INTERNAL,
                        BUILDCFG_ERROR_INVALID_SITELINK_OPTION,
                        pwszFn,
                        pwszSiteLink,
                        pwszSiteLinkOptions
                        );
                    break;
            }
        }
    }

    pwszSchedule = BuildCfgGetFirstStringByKey (
        pwszSectionSiteLink,
        BUILDCFG_KEY_SCHEDULE
        );
    if( pwszSchedule==NULL ) {
        pSchedule = NULL;
    } else {
        /* Create a schedule object */
        cbSchedule = sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES;
        cbSchedData = SCHEDULE_DATA_ENTRIES;
        pSchedule = KCCSimAlloc( cbSchedule );
        pSchedule->Size = cbSchedule;
        pSchedule->NumberOfSchedules = 1;
        pSchedule->Schedules[0].Type = SCHEDULE_INTERVAL;
        pSchedule->Schedules[0].Offset = sizeof(SCHEDULE);
        pData = ((char*)pSchedule)+sizeof(SCHEDULE);
        memset( pData, 0, cbSchedData );

        cChar = wcslen(pwszSchedule);
        mbstr = KCCSimAlloc( 2*(cChar+1) );
        wcstombs( mbstr, pwszSchedule, 2*(cChar+1) );
        
        iChar=0; iData=0;
        while( iChar<cChar && iData<cbSchedData) {
            x = CharToNibble( mbstr[iChar++] );
            x <<= 4;
            if( iChar<cChar ) {
                x |= CharToNibble( mbstr[iChar++] );                
            }
            pData[iData++] = x;
        }

        KCCSimFree( mbstr );
    }

    pEntrySiteLink = BuildCfgMakeSiteLink (
        pwszTransport,
        pwszSiteLink,
        ulCost,
        ulReplInterval,
        ulSiteLinkOptions,
        pSchedule
        );

    if( pSchedule ) {
        KCCSimFree( pSchedule );
    }

    for (pwszSiteName = BuildCfgDemandFirstStringByKey (
            pwszFn, pwszSiteLink, pwszSectionSiteLink, BUILDCFG_KEY_SITE);
         pwszSiteName != NULL;
         pwszSiteName = BuildCfgGetNextStringByKey (
            pwszSiteName, BUILDCFG_KEY_SITE)) {

        BuildCfgAddSiteToSiteLink (pwszSiteLink, pEntrySiteLink, pwszSiteName);

    }

    KCCSimFree (pwszSectionSiteLink);
}

VOID
BuildCfgProcessBridge (
    IN  LPCWSTR                     pwszFn,
    IN  LPCWSTR                     pwszBridge
    )
/*++

Routine Description:

    Create a bridge.

Arguments:

    pwszFn              - The filename of the INI file.
    pwszBridge          - The name of the bridge.

Return Value:

    None.

--*/
{
    PSIM_ENTRY                      pEntryBridge;
    PSIM_ENTRY                      pEntryTransportContainer;

    LPWSTR                          pwszSectionBridge;
    LPCWSTR                         pwszTransport, pwszSiteLinkName;
    ULONG                           ul;
    
    pwszSectionBridge = BuildCfgAllocDemandSection (
        pwszFn,
        pwszBridge
        );

    pwszTransport = BuildCfgDemandFirstStringByKey (
        pwszFn,
        pwszBridge,
        pwszSectionBridge,
        BUILDCFG_KEY_TRANSPORT
        );

    pEntryBridge = BuildCfgMakeBridge (
        pwszTransport,
        pwszBridge,
        &pEntryTransportContainer
        );

    for (pwszSiteLinkName = BuildCfgDemandFirstStringByKey (
            pwszFn, pwszBridge, pwszSectionBridge, BUILDCFG_KEY_SITELINK);
         pwszSiteLinkName != NULL;
         pwszSiteLinkName = BuildCfgGetNextStringByKey (
            pwszSiteLinkName, BUILDCFG_KEY_SITELINK)) {

        BuildCfgAddSiteLinkToBridge (pwszBridge, pEntryTransportContainer,
                                     pEntryBridge, pwszSiteLinkName);

    }

    KCCSimFree (pwszSectionBridge);
}

VOID
BuildCfgProcessTransport (
    IN  LPCWSTR                     pwszFn,
    IN  LPCWSTR                     pwszTransportName
    )
/*++

Routine Description:

    Create a site.

Arguments:

    pwszFn              - The filename of the INI file.
    pwszTransportName   - The name of the transport.

Return Value:

    None.

--*/
{
    LPWSTR                          pwszSectionTransport;

    LPCWSTR                         pwszTransportOptions;

    DWORD                           ulTransportOptions, ul;

    pwszSectionTransport = BuildCfgAllocDemandSection (
        pwszFn,
        pwszTransportName
        );
    pwszTransportOptions = BuildCfgGetFirstStringByKey (
        pwszSectionTransport,
        BUILDCFG_KEY_TRANSPORTOPTIONS
        );
    ulTransportOptions = 0;
    if (pwszTransportOptions != NULL) {
        for (ul = 0; pwszTransportOptions[ul] != L'\0'; ul++) {
            switch (towupper (pwszTransportOptions[ul])) {
            case KCCSIM_CID_NTDSTRANSPORT_OPT_IGNORE_SCHEDULES:
                ulTransportOptions |= NTDSTRANSPORT_OPT_IGNORE_SCHEDULES;
                break;
            case KCCSIM_CID_NTDSTRANSPORT_OPT_BRIDGES_REQUIRED:
                ulTransportOptions |= NTDSTRANSPORT_OPT_BRIDGES_REQUIRED;
                break;
            case L' ':
                break;
            default:
                KCCSimException (
                    KCCSIM_ETYPE_INTERNAL,
                    BUILDCFG_ERROR_INVALID_SITE_OPTION,
                    pwszFn,
                    pwszTransportName,
                    pwszTransportOptions
                    );
                break;
            }
            pwszTransportOptions++;
        }
    }

    BuildCfgUpdateTransport( pwszTransportName, ulTransportOptions );

    KCCSimFree (pwszSectionTransport);
}

VOID
BuildCfg (
    IN  LPCWSTR                     pwszFnRaw
    )
/*++

Routine Description:

    Builds a complete configuration.

Arguments:

    pwszFnRaw           - The input filename as specified by the user.

Return Value:

    None.

--*/
{
    PSIM_ENTRY                      pEntryConfig, pEntryDomain;
    LPWSTR                          pwszFn = NULL;

    LPWSTR                          pwszSectionConfig, pwszSectionSite;
    LPCWSTR                         pwszNumUuids, pwszRootDn, pwszDomainName,
                                    pwszSiteName,
                                    pwszSiteLinkName, pwszExplicitBridgeheads,
                                    pwszForestVersion, pwszBridgeName,
                                    pwszTransportName;

    ULONG                           ulNumUuids, ulForestVersion;

    // Prepend ".\" onto the beginning of the filename, so that the ini
    // parsing routines won't search for it in the windows directory
    pwszFn = KCCSimAlloc (sizeof (WCHAR) * (3 + wcslen (pwszFnRaw)));
    swprintf (pwszFn, L".\\%s", pwszFnRaw);

    // First reinitialize the directory, destroying any existing contents.
    KCCSimInitializeDir ();

    pwszSectionConfig = BuildCfgAllocDemandSection (
        pwszFn,
        BUILDCFG_SECTION_CONFIG
        );

    // Make some Uuids.
    pwszNumUuids = BuildCfgGetFirstStringByKey (
        pwszSectionConfig,
        BUILDCFG_KEY_MAX_UUIDS
        );
    if (pwszNumUuids == NULL) {
        ulNumUuids = BUILDCFG_DEFAULT_MAX_UUIDS;
    } else {
        ulNumUuids = wcstoul (pwszNumUuids, NULL, 10);
    }
    BuildCfgMakeUuids (ulNumUuids);

    pwszForestVersion = BuildCfgGetFirstStringByKey (
        pwszSectionConfig,
        BUILDCFG_KEY_FOREST_VERSION
        );
    if (pwszForestVersion == NULL) {
        ulForestVersion = DS_BEHAVIOR_WIN2000;
    } else {
        ulForestVersion = wcstoul (pwszForestVersion, NULL, 10);
        if (ulForestVersion > DS_BEHAVIOR_VERSION_CURRENT) {
            ulForestVersion = DS_BEHAVIOR_VERSION_CURRENT;
        }
    }

    pwszRootDn = BuildCfgDemandFirstStringByKey (
        pwszFn,
        BUILDCFG_SECTION_CONFIG,
        pwszSectionConfig,
        BUILDCFG_KEY_ROOT_DOMAIN
        );
    pEntryConfig = BuildCfgMakeConfig (pwszRootDn, ulForestVersion);

    // Enable explicit bridgeheads
    for (pwszExplicitBridgeheads = BuildCfgGetFirstStringByKey (
            pwszSectionConfig, BUILDCFG_KEY_EXPLICITBRIDGEHEADS);
         pwszExplicitBridgeheads != NULL;
         pwszExplicitBridgeheads = BuildCfgGetNextStringByKey (
            pwszExplicitBridgeheads, BUILDCFG_KEY_EXPLICITBRIDGEHEADS)) {

        if (!BuildCfgUseExplicitBridgeheads (pwszExplicitBridgeheads)) {
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                BUILDCFG_ERROR_UNKNOWN_TRANSPORT,
                BUILDCFG_SECTION_CONFIG,
                pwszExplicitBridgeheads
                );
        }

    }

    // Create the domains
    for (pwszDomainName = BuildCfgGetFirstStringByKey (
            pwszSectionConfig, BUILDCFG_KEY_DOMAIN);
         pwszDomainName != NULL;
         pwszDomainName = BuildCfgGetNextStringByKey (
            pwszDomainName, BUILDCFG_KEY_DOMAIN)) {

        pEntryDomain = BuildCfgMakeDomain (pwszDomainName);
        BuildCfgMakeCrossRef (pEntryDomain, NULL, TRUE);

    }

    // Create the sites
    for (pwszSiteName = BuildCfgDemandFirstStringByKey (
            pwszFn, BUILDCFG_SECTION_CONFIG, pwszSectionConfig, BUILDCFG_KEY_SITE);
         pwszSiteName != NULL;
         pwszSiteName = BuildCfgGetNextStringByKey (
            pwszSiteName, BUILDCFG_KEY_SITE)) {

        BuildCfgProcessSite (
            pwszFn,
            pwszSiteName
            );

    }

    // Create the site-links
    for (pwszSiteLinkName = BuildCfgGetFirstStringByKey (
            pwszSectionConfig, BUILDCFG_KEY_SITELINK);
         pwszSiteLinkName != NULL;
         pwszSiteLinkName = BuildCfgGetNextStringByKey (
            pwszSiteLinkName, BUILDCFG_KEY_SITELINK)) {

        BuildCfgProcessSiteLink (
            pwszFn,
            pwszSiteLinkName
            );

    }

    // Create the bridges
    for (pwszBridgeName = BuildCfgGetFirstStringByKey (
            pwszSectionConfig, BUILDCFG_KEY_BRIDGE);
         pwszBridgeName != NULL;
         pwszBridgeName = BuildCfgGetNextStringByKey (
            pwszBridgeName, BUILDCFG_KEY_BRIDGE)) {

        BuildCfgProcessBridge (
            pwszFn,
            pwszBridgeName
            );

    }

    // Transport characteristics
    for (pwszTransportName = BuildCfgGetFirstStringByKey (
            pwszSectionConfig, BUILDCFG_KEY_TRANSPORT);
         pwszTransportName != NULL;
         pwszTransportName = BuildCfgGetNextStringByKey (
            pwszTransportName, BUILDCFG_KEY_TRANSPORT)) {

        BuildCfgProcessTransport (
            pwszFn,
            pwszTransportName
            );

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\sim\buildcfg.h ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    buildcfg.h

ABSTRACT:

    Header file for buildcfg.c.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/
               
// Header files
#include <schedule.h>
#include <mdglobal.h>

// Config section
#define BUILDCFG_SECTION_CONFIG             L"Configuration"
#define BUILDCFG_KEY_ROOT_DOMAIN            L"RootDomain"
#define BUILDCFG_KEY_DOMAIN                 L"Domain"
#define BUILDCFG_KEY_SITE                   L"Site"
#define BUILDCFG_KEY_SITELINK               L"SiteLink"
#define BUILDCFG_KEY_BRIDGE                 L"SiteLinkBridge"
#define BUILDCFG_KEY_EXPLICITBRIDGEHEADS    L"ExplicitBridgeheads"
#define BUILDCFG_KEY_MAX_UUIDS              L"MaxUuids"
#define BUILDCFG_KEY_FOREST_VERSION         L"ForestVersion"

// Site section
#define BUILDCFG_KEY_SERVERS                L"Servers"
#define BUILDCFG_KEY_SITEOPTIONS            L"SiteOptions"
#define BUILDCFG_KEY_ISTG                   L"ISTG"

// Server type section
#define BUILDCFG_KEY_SERVEROPTIONS          L"ServerOptions"
#define BUILDCFG_KEY_BRIDGEHEAD             L"Bridgehead"
#define BUILDCFG_KEY_DOMAIN                 L"Domain"
#define BUILDCFG_KEY_RDNMASK                L"RDNMask"

// Site-link section
#define BUILDCFG_KEY_TRANSPORT              L"Transport"
#define BUILDCFG_KEY_COST                   L"Cost"
#define BUILDCFG_KEY_REPLINTERVAL           L"ReplInterval"
#define BUILDCFG_KEY_SITELINKOPTIONS        L"SiteLinkOptions"
#define BUILDCFG_KEY_SCHEDULE               L"Schedule"

// Bridge section

// Transport section
#define BUILDCFG_KEY_TRANSPORTOPTIONS            L"TransportOptions"

// RDNs
#define BUILDCFG_RDN_CONFIG                 L"Configuration"
#define BUILDCFG_RDN_SITES_CONTAINER        L"Sites"
#define BUILDCFG_RDN_NTDS_SITE_SETTINGS     L"NTDS Site Settings"
#define BUILDCFG_RDN_SERVERS_CONTAINER      L"Servers"
#define BUILDCFG_RDN_NTDS_SETTINGS          L"NTDS Settings"
#define BUILDCFG_RDN_INTERSITE_TRANSPORTS   L"Inter-Site Transports"
#define BUILDCFG_RDN_DMD                    L"Schema"
#define BUILDCFG_RDN_CROSS_REF_CONTAINER    L"Partitions"
#define BUILDCFG_RDN_CROSS_REF_CONFIG       L"Enterprise Configuration"
#define BUILDCFG_RDN_CROSS_REF_DMD          L"Enterprise Schema"
#define BUILDCFG_RDN_SERVICES               L"Services"
#define BUILDCFG_RDN_WINDOWS_NT             L"Windows NT"
#define BUILDCFG_RDN_DIRECTORY_SERVICE      L"Directory Service"
#define BUILDCFG_NAME_MAIL_ADDRESS          L"_IsmService"

// Some #defines
#define BUILDCFG_NUM_TRANSPORTS     2
#define BUILDCFG_GENERIC_SERVER_ID  L"SERVER"
#define BUILDCFG_DEFAULT_MAX_UUIDS  1000

// Internal structures

typedef struct {
    const WCHAR                     wszRDN[1+MAX_RDN_SIZE];
    const ATTRTYP                   transportAddressAttribute;
    const WCHAR                     transportDLLName[15];
    PSIM_ENTRY                      pEntry;
} BUILDCFG_TRANSPORT_INFO;

typedef struct {
    PDSNAME                         pdnRootDomain;
    PDSNAME                         pdnConfig;
    PDSNAME                         pdnDmd;
    LPWSTR                          pwszRootDomainDNSName;
    PSIM_ENTRY                      pEntrySitesContainer;
    PSIM_ENTRY                      pEntryCrossRefContainer;
    RTL_GENERIC_TABLE               tableUuids;
} BUILDCFG_GLOBALS;

extern BUILDCFG_GLOBALS             globals;

const BUILDCFG_TRANSPORT_INFO *
BuildCfgGetTransportInfo (
    IN  LPCWSTR                     pwszTransportRDN
    );

BOOL
BuildCfgUseExplicitBridgeheads (
    IN  LPCWSTR                     pwszTransportRDN
    );

PSIM_ENTRY
BuildCfgMakeCrossRef (
    IN  PSIM_ENTRY                  pEntryNc,
    IN  LPCWSTR                     pwszRDN OPTIONAL,
    IN  BOOL                        bIsDomain
    );

PSIM_ENTRY
BuildCfgMakeDomain (
    IN  LPCWSTR                     pwszDomain
    );

PSIM_ENTRY
BuildCfgMakeSite (
    IN  LPCWSTR                     pwszSiteRDN,
    IN  ULONG                       ulSiteOptions
    );

PSIM_ENTRY
BuildCfgMakeSiteLink (
    IN  LPCWSTR                     pwszTransport,
    IN  LPCWSTR                     pwszSiteLink,
    IN  ULONG                       ulCost,
    IN  ULONG                       ulReplInterval,
    IN  ULONG                       ulOptions,
    IN  PSCHEDULE                   pSchedule
    );

VOID
BuildCfgAddSiteToSiteLink (
    IN  LPCWSTR                     pwszSiteLinkRDN,
    IN  PSIM_ENTRY                  pEntrySiteLink,
    IN  LPCWSTR                     pwszSiteRDN
    );

PSIM_ENTRY
BuildCfgMakeBridge (
    IN  LPCWSTR                     pwszTransport,
    IN  LPCWSTR                     pwszBridge,
    OUT PSIM_ENTRY *                ppEntryTransport
    );

VOID
BuildCfgAddSiteLinkToBridge (
    IN  LPCWSTR                     pwszBridgeRDN,
    IN  PSIM_ENTRY                  pEntryTransportContainer,
    IN  PSIM_ENTRY                  pEntryBridge,
    IN  LPCWSTR                     pwszSiteLinkRDN
    );

BOOL
BuildCfgISTG (
    IN  PSIM_ENTRY                  pEntryNTDSSiteSettings,
    IN  PSIM_ENTRY                  pEntryServersContainer,
    IN  LPCWSTR                     pwszServerRDN
    );

VOID
BuildCfgAddAsBridgehead (
    IN  LPCWSTR                     pwszServerType,
    IN  PSIM_ENTRY                  pEntryServer,
    IN  LPCWSTR                     pwszTransportRDN
    );

PSIM_ENTRY
BuildCfgMakeServer (
    IO  PULONG                      pulServerNum,
    IN  LPCWSTR                     pwszServerRDNMask,
    IN  LPCWSTR                     pwszSiteRDN,
    IN  LPCWSTR                     pwszDomain,
    IN  PSIM_ENTRY                  pEntryServersContainer,
    IN  ULONG                       ulServerOptions
    );

PSIM_ENTRY
BuildCfgMakeConfig (
    IN  LPCWSTR                     pwszRootDn,
    IN  DWORD                       ulForestVersion
    );

VOID
BuildCfgUpdateTransport (
    IN  LPCWSTR                     pwszTransport,
    IN  ULONG                       ulTransportOptions
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\sim\dir.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    dir.c

ABSTRACT:

    Contains routines for interfacing the simulated
    directory.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <ismapi.h>
#include <attids.h>
#include <objids.h>
#include <filtypes.h>
#include <debug.h>
#include "kccsim.h"
#include "util.h"
#include "dir.h"
#include "state.h"
#include "ldif.h"
#include <fileno.h>
#define FILENO  FILENO_KCCSIM_DIR

BOOL fNullUuid (const UUID *pUuid);

struct _GUID_TABLE_ENTRY {
    GUID                            guid;
    PSIM_ENTRY                      pEntry;
};

struct _DSNAME_TABLE_ENTRY {
    LPSTR                           mappedName;
    PSIM_ENTRY                      pEntry;
};

struct _KCCSIM_ANCHOR {
    PDSNAME                     pdnDmd;
    PDSNAME                     pdnDsa;
    PDSNAME                     pdnDomain;
    PDSNAME                     pdnConfig;
    PDSNAME                     pdnRootDomain;
    PDSNAME                     pdnLdapDmd;
    PDSNAME                     pdnPartitions;
    PDSNAME                     pdnDsSvcConfig;
    PDSNAME                     pdnSite;
    LPWSTR                      pwszDomainName;
    LPWSTR                      pwszDomainDNSName;
    LPWSTR                      pwszRootDomainDNSName;
};

typedef struct {
    PSIM_ENTRY                  pRootEntry;
    struct _KCCSIM_ANCHOR       anchor;
    RTL_GENERIC_TABLE           tableGuid;
    RTL_GENERIC_TABLE           tableDsname;
} SIM_DIRECTORY, * PSIM_DIRECTORY;

PSIM_DIRECTORY                      g_pSimDir = NULL;

RTL_GENERIC_COMPARE_RESULTS
NTAPI
KCCSimGuidTableCompare (
    IN  const RTL_GENERIC_TABLE *   pTable,
    IN  const VOID *                pFirstStruct,
    IN  const VOID *                pSecondStruct
    )
/*++

Routine Description:

    KCCSim maintains an RTL_GENERIC_TABLE that maps GUIDs to
    directory entries.  This enables fast searches by GUID.
    This function binary-compares two GUIDs.

Arguments:

    pTable              - Always &g_pSimDir->tableGuid
    pFirstStruct        - The first GUID to compare
    pSecondStruct       - The second GUID

Return Value:

    GenericLessThan, GenericGreaterThan, or GenericEqual

--*/
{
    struct _GUID_TABLE_ENTRY *      pFirstEntry;
    struct _GUID_TABLE_ENTRY *      pSecondEntry;
    int                             iCmp;
    RTL_GENERIC_COMPARE_RESULTS     result;

    pFirstEntry = (struct _GUID_TABLE_ENTRY *) pFirstStruct;
    pSecondEntry = (struct _GUID_TABLE_ENTRY *) pSecondStruct;

    // We do a simple byte-by-byte comparison.
    iCmp = memcmp (&pFirstEntry->guid, &pSecondEntry->guid, sizeof (GUID));
    if (iCmp < 0) {
        result = GenericLessThan;
    } else if (iCmp > 0) {
        result = GenericGreaterThan;
    } else {
        Assert (iCmp == 0);
        result = GenericEqual;
    }

    return result;
}

RTL_GENERIC_COMPARE_RESULTS
NTAPI
KCCSimDsnameTableCompare (
    IN  const RTL_GENERIC_TABLE *   pTable,
    IN  const VOID *                pFirstStruct,
    IN  const VOID *                pSecondStruct
    )
/*++

Routine Description:

    KCCSim maintains an RTL_GENERIC_TABLE that maps DSNAMEs to
    directory entries.  This enables fast searches by DSNAME.
    This function binary-compares two DSNAMEs.

Arguments:

    pTable              - Always &g_pSimDir->tableDsname
    pFirstStruct        - The first Dsname to compare
    pSecondStruct       - The second Dsname

Return Value:

    GenericLessThan, GenericGreaterThan, or GenericEqual

--*/
{
    struct _DSNAME_TABLE_ENTRY *    pFirstEntry;
    struct _DSNAME_TABLE_ENTRY *    pSecondEntry;
    int                             iCmp;
    RTL_GENERIC_COMPARE_RESULTS     result;

    Assert( pFirstStruct!=NULL && pSecondStruct!=NULL );
    pFirstEntry = (struct _DSNAME_TABLE_ENTRY *) pFirstStruct;
    pSecondEntry = (struct _DSNAME_TABLE_ENTRY *) pSecondStruct;

    Assert( pFirstEntry->mappedName!=NULL && pSecondEntry->mappedName!=NULL );
    iCmp = strcmp( pFirstEntry->mappedName, pSecondEntry->mappedName );

    if (iCmp < 0) {
        result = GenericLessThan;
    } else if (iCmp > 0) {
        result = GenericGreaterThan;
    } else {
        Assert (iCmp == 0);
        result = GenericEqual;
    }

    return result;
}

PSIM_ENTRY
KCCSimLookupEntryByGuid (
    IN  const GUID *                pGuid
    )
/*++

Routine Description:

    Searches the GUID table for the associated entry.

Arguments:

    pGuid               - The GUID to use as a key

Return Value:

    The associated entry, or NULL if none exists.

--*/
{
    struct _GUID_TABLE_ENTRY        lookup;
    struct _GUID_TABLE_ENTRY *      pFound;

    Assert (pGuid != NULL);

    memcpy (&lookup.guid, pGuid, sizeof (GUID));
    lookup.pEntry = NULL;
    pFound = RtlLookupElementGenericTable (&g_pSimDir->tableGuid, &lookup);

    if (pFound == NULL) {
        return NULL;
    } else {
        return pFound->pEntry;
    }
}

PSIM_ENTRY
KCCSimLookupEntryByDsname (
    IN  const DSNAME *               pdn
    )
/*++

Routine Description:

    Searches the Dsname table for the associated entry.

Arguments:

    pdn                 - The Dsname to use as a key

Return Value:

    The associated entry, or NULL if none exists.

--*/
{
    struct _DSNAME_TABLE_ENTRY        lookup;
    struct _DSNAME_TABLE_ENTRY *      pFound;

    Assert (pdn != NULL);

    lookup.mappedName = SimDSNAMEToMappedStrExternal( (DSNAME*) pdn, TRUE );
    lookup.pEntry = NULL;
    pFound = RtlLookupElementGenericTable( &g_pSimDir->tableDsname, &lookup );
    KCCSimFree( lookup.mappedName );

    if (pFound == NULL) {
        return NULL;
    } else {
        Assert( pFound->pEntry!=NULL );
        return pFound->pEntry;
    }
}

VOID
KCCSimInsertEntryIntoGuidTable (
    IN  PSIM_ENTRY                  pEntry
    )
/*++

Routine Description:

    Inserts an entry into the GUID table.

Arguments:

    pEntry              - The entry to insert.

Return Value:

    None.

--*/
{
    struct _GUID_TABLE_ENTRY        insert;
    PVOID                           pOld;

    Assert (pEntry != NULL);

    if (fNullUuid (&pEntry->pdn->Guid)) {
        return;
    }

    memcpy (&insert.guid, &pEntry->pdn->Guid, sizeof (GUID));
    insert.pEntry = pEntry;

    pOld = RtlInsertElementGenericTable (
        &g_pSimDir->tableGuid,
        (PVOID) &insert,
        sizeof (struct _GUID_TABLE_ENTRY),
        NULL
        );
}

VOID
KCCSimInsertEntryIntoDsnameTable (
    IN  PSIM_ENTRY                  pEntry
    )
/*++

Routine Description:

    Inserts an entry into the Dsname table.

Arguments:

    pEntry              - The entry to insert.

Return Value:

    None.

--*/
{
    struct _DSNAME_TABLE_ENTRY      insert;
    PVOID                           pOld;

    Assert (pEntry != NULL);

    insert.mappedName = SimDSNAMEToMappedStrExternal( pEntry->pdn, TRUE );
    insert.pEntry = pEntry;

    pOld = RtlInsertElementGenericTable (
        &g_pSimDir->tableDsname,
        (PVOID) &insert,
        sizeof (struct _DSNAME_TABLE_ENTRY),
        NULL
        );
}

BOOL
KCCSimRemoveEntryFromGuidTable (
    IN  PSIM_ENTRY                  pEntry
    )
/*++

Routine Description:

    Removes an entry from the GUID table.

Arguments:

    pEntry              - The entry to remove.

Return Value:

    TRUE if the entry was found and removed.
    FALSE if the entry was not found in the GUID table.

--*/
{
    struct _GUID_TABLE_ENTRY        remove;

    Assert (pEntry != NULL);
    if (fNullUuid (&pEntry->pdn->Guid)) {
        return FALSE;
    }

    memcpy (&remove.guid, &pEntry->pdn->Guid, sizeof (GUID));
    
    return RtlDeleteElementGenericTable (&g_pSimDir->tableGuid, &remove);
}
  
BOOL
KCCSimRemoveEntryFromDsnameTable (
    IN  PSIM_ENTRY                  pEntry
    )
/*++

Routine Description:

    Removes an entry from the Dsname table.

Arguments:

    pEntry              - The entry to remove.

Return Value:

    TRUE if the entry was found and removed.
    FALSE if the entry was not found in the Dsname table.

--*/
{
    struct _DSNAME_TABLE_ENTRY        remove, *pFound;
    LPSTR                             mappedName;
    BOOLEAN                           fSuccess;

    Assert (pEntry != NULL);
    Assert (pEntry->pdn != NULL);

    remove.mappedName = SimDSNAMEToMappedStrExternal( pEntry->pdn, TRUE );
    remove.pEntry = NULL;
    
    pFound = RtlLookupElementGenericTable( &g_pSimDir->tableDsname, &remove );
    if( NULL==pFound || NULL==pFound->mappedName ) {
        Assert( !"RtlLookupElementGenericTable() returned NULL unexpectedly" );
        return FALSE;
    }
    mappedName = pFound->mappedName;
    
    fSuccess = RtlDeleteElementGenericTable( &g_pSimDir->tableDsname, &remove );
    Assert( fSuccess );

    KCCSimFree( mappedName );
    KCCSimFree( remove.mappedName );

    return fSuccess;
}
    

VOID
KCCSimFreeValue (
    IO  PSIM_VALUE *                ppVal
    )
/*++

Routine Description:

    Frees a single attribute value.

Arguments:

    ppVal               - Pointer to the attribute value to free.

Return Value:

    None.

--*/
{
    if (ppVal == NULL || *ppVal == NULL) {
        return;
    }

    KCCSimFree ((*ppVal)->pVal);
    KCCSimFree (*ppVal);
    *ppVal = NULL;
}

BOOL
KCCSimAttRefIsValid (
    IN  PSIM_ATTREF                 pAttRef
    )
/*++

Routine Description:

    Determines whether an ATTREF struct refers to a valid
    attribute.  This function tests for three conditions:
        1) The entry is non-null.
        2) The attribute is non-null.
        3) The attribute exists somewhere in the entry's
           linked list of attributes.
    This function is intended primarily for use within Asserts.

Arguments:

    pAttRef             - Pointer to the attribute
                          reference to test.

Return Value:

    TRUE if the attribute reference is valid.

--*/
{
    PSIM_ATTRIBUTE                  pAttrAt;

    if (pAttRef == NULL         ||
        pAttRef->pEntry == NULL ||
        pAttRef->pAttr == NULL   ) {
        return FALSE;
    }

    pAttrAt = pAttRef->pEntry->pAttrFirst;
    while (pAttrAt != NULL) {
        if (pAttrAt == pAttRef->pAttr) {
            return TRUE;
        }
        pAttrAt = pAttrAt->next;
    }
    
    return FALSE;
}

BOOL
KCCSimGetAttribute (
    IN  PSIM_ENTRY                  pEntry,
    IN  ATTRTYP                     attrType,
    OUT PSIM_ATTREF                 pAttRef OPTIONAL
    )
/*++

Routine Description:

    Returns an attribute reference corresponding to the desired
    entry and attribute type.

Arguments:

    pEntry              - The entry to search.
    attrType            - The attribute type to search for.
    pAttRef             - OPTIONAL.  Pointer to a preallocated
                          attribute reference that will be filled
                          with information about this attribute.
                          If the attribute does not exist,
                          pAttRef->pAttr will be set to NULL.

Return Value:

    TRUE if the attribute exists.

--*/
{
    PSIM_ATTRIBUTE                  pAttrAt;

    Assert (pEntry != NULL);

    pAttrAt = pEntry->pAttrFirst;
    while (pAttrAt != NULL &&
           pAttrAt->attrType != attrType) {
        pAttrAt = pAttrAt->next;
    }

    if (pAttRef != NULL) {
        pAttRef->pEntry = pEntry;
        pAttRef->pAttr = pAttrAt;       // May be NULL
    }

    return (pAttrAt != NULL);
}

VOID
KCCSimNewAttribute (
    IN  PSIM_ENTRY                  pEntry,
    IN  ATTRTYP                     attrType,
    OUT PSIM_ATTREF                 pAttRef OPTIONAL
    )
/*++

Routine Description:

    Creates a new attribute with no values.

Arguments:

    pEntry              - The entry in which to create the attribute.
    attrType            - The attribute type.
    pAttRef             - OPTIONAL.  Pointer to a preallocated
                          attribute reference that will be filled
                          with information about this attribute.

Return Value:

    None.

--*/
{
    PSIM_ATTRIBUTE                  pNewAttr;

    Assert (pEntry != NULL);

    pNewAttr = KCCSIM_NEW (SIM_ATTRIBUTE);
    pNewAttr->attrType = attrType;
    pNewAttr->pValFirst = NULL;

    // For speed, we add the attribute on to the beginning of the list
    pNewAttr->next = pEntry->pAttrFirst;
    pEntry->pAttrFirst = pNewAttr;

    if (pAttRef != NULL) {
        pAttRef->pEntry = pEntry;
        pAttRef->pAttr = pNewAttr;
    }
}

VOID
KCCSimFreeAttribute (
    IO  PSIM_ATTRIBUTE *            ppAttr
    )
/*++

Routine Description:

    Frees a single attribute.  Routines outside of dir.c should
    call KCCSimRemoveAttribute instead.

Arguments:

    ppAttr              - Pointer to the attribute to free.

Return Value:

    None.

--*/
{
    PSIM_VALUE                      pValAt, pValNext;

    if (ppAttr == NULL || *ppAttr == NULL) {
        return;
    }

    pValAt = (*ppAttr)->pValFirst;
    while (pValAt != NULL) {
        pValNext = pValAt->next;
        KCCSimFreeValue (&pValAt);
        pValAt = pValNext;
    }

    KCCSimFree (*ppAttr);
    *ppAttr = NULL;
}

VOID
KCCSimRemoveAttribute (
    IO  PSIM_ATTREF                 pAttRef
    )
/*++

Routine Description:

    Removes an attribute from the directory.  This will
    also set pAttRef->pAttr to NULL.

Arguments:

    pAttRef             - Pointer to a valid attribute reference.

Return Value:

    None.

--*/
{
    PSIM_ATTRIBUTE                  pAttrAt;

    Assert (KCCSimAttRefIsValid (pAttRef));

    // Base case: First attribute in entry
    if (pAttRef->pAttr == pAttRef->pEntry->pAttrFirst) {
        // The new first attribute becomes this one's child.
        pAttRef->pEntry->pAttrFirst = pAttRef->pEntry->pAttrFirst->next;
    } else {

        // It's not the first attribute in the entry.
        // So, search for the parent of this attribute.
        pAttrAt = pAttRef->pEntry->pAttrFirst;
        while (pAttrAt != NULL &&
               pAttrAt->next != pAttRef->pAttr) {
            pAttrAt = pAttrAt->next;
        }

        // If we didn't find its parent, something is seriously
        // wrong (since this was Asserted to be a valid attref.)
        Assert (pAttrAt != NULL);
        Assert (pAttrAt->next != NULL);

        // Skip over this attribute
        pAttrAt->next = pAttrAt->next->next;

    }

    KCCSimFreeAttribute (&(pAttRef->pAttr));
}

VOID
KCCSimAddValueToAttribute (
    IN  PSIM_ATTREF                 pAttRef,
    IN  ULONG                       ulValLen,
    IN  PBYTE                       pValData
    )
/*++

Routine Description:

    Adds a preallocated data block to the directory.  The caller
    should NOT deallocate it after calling this function (or else
    the directory will be corrupted.)  To copy data into the
    directory, use KCCSimAllocAddValueToAttribute.

Arguments:

    pAttRef             - Pointer to a valid attribute reference.
    ulValLen            - The length of the data block.
    pValData            - The data to add.

Return Value:

    None.

--*/
{
    PSIM_VALUE                      pNewVal;

    Assert (KCCSimAttRefIsValid (pAttRef));
    Assert (pValData != NULL);

    pNewVal = KCCSIM_NEW (SIM_VALUE);
    pNewVal->ulLen = ulValLen;
    pNewVal->pVal = pValData;

    // For speed, we add the value on to the beginning of the list
    pNewVal->next = pAttRef->pAttr->pValFirst;
    pAttRef->pAttr->pValFirst = pNewVal;

    // Now we check for special attribute types.

    // Are we adding a GUID?
    if (pAttRef->pAttr->attrType == ATT_OBJECT_GUID) {
        Assert (pNewVal->ulLen == sizeof (GUID));
        // Copy this value into the entry's DSNAME struct.
        memcpy (&pAttRef->pEntry->pdn->Guid,
                (GUID *) pNewVal->pVal,
                sizeof (GUID));
        KCCSimInsertEntryIntoGuidTable (pAttRef->pEntry);
    }

    // Are we adding a SID?
    if (pAttRef->pAttr->attrType == ATT_OBJECT_SID) {
        // Copy the SID into the entry's DSNAME struct.
        strncpy (pAttRef->pEntry->pdn->Sid.Data,
                 (SYNTAX_SID *) pNewVal->pVal,
                 min (ulValLen, MAX_NT4_SID_SIZE));
        pAttRef->pEntry->pdn->SidLen = min (ulValLen, MAX_NT4_SID_SIZE);
    }

    // If the attribute is an LDAP Display Name, it means we've found
    // an attribute descriptor in the schema.  So, we should add its
    // objectCategory to the schema mapping.
    if (pAttRef->pAttr->attrType == ATT_LDAP_DISPLAY_NAME) {
        KCCSimSetObjCategory (
            KCCSimStringToAttrType ((SYNTAX_UNICODE *) pNewVal->pVal),
            pAttRef->pEntry->pdn
            );
    }

}

VOID
KCCSimAllocAddValueToAttribute (
    IN  PSIM_ATTREF                 pAttRef,
    IN  ULONG                       ulValLen,
    IN  PBYTE                       pValData
    )
/*++

Routine Description:

    Copies a data block into the directory.

Arguments:

    pAttRef             - Pointer to a valid attribute reference.
    ulValLen            - The length of the data block.
    pValData            - The data to copy.

Return Value:

    None.

--*/
{
    PBYTE                           pValCopy;

    pValCopy = KCCSimAlloc (ulValLen);
    memcpy (pValCopy, pValData, ulValLen);
    KCCSimAddValueToAttribute (pAttRef, ulValLen, pValCopy);
}

BOOL
KCCSimIsValueInAttribute (
    IN  PSIM_ATTREF                 pAttRef,
    IN  ULONG                       ulValLen,
    IN  PBYTE                       pValData
    )
/*++

Routine Description:

    Determines whether or not a particular value is in an attribute.

Arguments:

    pAttRef             - Pointer to a valid attribute reference.
    ulValLen            - The length of the value.
    pValData            - The value to check.

Return Value:

    TRUE if the specified value is in the attribute.

--*/
{
    PSIM_VALUE                      pValAt;
    BOOL                            bFound;

    Assert (KCCSimAttRefIsValid (pAttRef));
    Assert (pValData != NULL);

    bFound = FALSE;

    for (pValAt = pAttRef->pAttr->pValFirst;
         pValAt != NULL;
         pValAt = pValAt->next) {
        
        if (KCCSimCompare (
                pAttRef->pAttr->attrType,
                FI_CHOICE_EQUALITY,
                pValAt->ulLen,
                pValAt->pVal,
                ulValLen,
                pValData)) {
            bFound = TRUE;
            break;
        }

    }

    return bFound;
}

BOOL
KCCSimRemoveValueFromAttribute (
    IN  PSIM_ATTREF                 pAttRef,
    IN  ULONG                       ulValLen,
    IN  PBYTE                       pValData
    )
/*++

Routine Description:

    Removes an attribute value from the directory.

Arguments:

    pAttRef             - Pointer to a valid attribute reference.
    ulValLen            - The length of the data block.
    pValData            - The data to remove.

Return Value:

    TRUE if the value was found and removed.
    FALSE if the value could not be found in the attribute.

--*/
{
    PSIM_VALUE                      pValAt, pValFound;
    BOOL                            bRemoved;

    Assert (KCCSimAttRefIsValid (pAttRef));
    Assert (pValData != NULL);

    // No values:
    if (pAttRef->pAttr->pValFirst == NULL) {
        return FALSE;
    }

    bRemoved = FALSE;

    // Base case: Check if the first value in the attribute matches
    if (KCCSimCompare (
            pAttRef->pAttr->attrType,
            FI_CHOICE_EQUALITY,
            pAttRef->pAttr->pValFirst->ulLen,
            pAttRef->pAttr->pValFirst->pVal,
            ulValLen,
            pValData)) {
        pValFound = pAttRef->pAttr->pValFirst;
        pAttRef->pAttr->pValFirst = pAttRef->pAttr->pValFirst->next;
        bRemoved = TRUE;
    } else {
    
        // Search for the parent of the matching value    
        pValAt = pAttRef->pAttr->pValFirst;
        while (pValAt->next != NULL) {

            if (KCCSimCompare (
                    pAttRef->pAttr->attrType,
                    FI_CHOICE_EQUALITY,
                    pValAt->next->ulLen,
                    pValAt->next->pVal,
                    ulValLen,
                    pValData)) {

                // pValAt is the parent of the matching value.
                pValFound = pValAt->next;
                pValAt->next = pValAt->next->next;
                bRemoved = TRUE;
                break;

            }
        }
    }

    if (bRemoved) {
        KCCSimFreeValue (&pValFound);
    }

    return bRemoved;
}

VOID
KCCSimFreeEntryAttributes (
    IN  PSIM_ENTRY                  pEntry
    )
/*++

Routine Description:

    Frees all the attributes associated with an entry.

Arguments:

    pEntry              - The entry to free.

Return Value:

    None.

--*/
{
    PSIM_ATTRIBUTE                  pAttrAt, pAttrNext;

    if (pEntry == NULL) {
        return;
    }

    pAttrAt = pEntry->pAttrFirst;
    while (pAttrAt != NULL) {
        pAttrNext = pAttrAt->next;
        KCCSimFreeAttribute (&pAttrAt);
        pAttrAt = pAttrNext;
    }

    pEntry->pAttrFirst = NULL;
    return;
}

VOID
KCCSimFreeEntryTree (
    IO  PSIM_ENTRY *                ppEntry
    )
/*++

Routine Description:

    Frees an entry and all its children.  Routines outside of
    dir.c should call KCCSimRemoveEntry instead.

Arguments:

    ppEntry             - Pointer to the entry to free.

Return Value:

    None.

--*/
{
    PSIM_ENTRY                      pChildAt, pChildNext;

    if (ppEntry == NULL || *ppEntry == NULL)
        return;

    KCCSimRemoveEntryFromGuidTable (*ppEntry);
    KCCSimRemoveEntryFromDsnameTable (*ppEntry);
    KCCSimFreeEntryAttributes (*ppEntry);
    
    if ((*ppEntry)->pdn != NULL) {
        KCCSimFree ((*ppEntry)->pdn);
    }

    pChildAt = (*ppEntry)->children;
    while (pChildAt != NULL) {
        pChildNext = pChildAt->next;
        KCCSimFreeEntryTree (&pChildAt);
        pChildAt = pChildNext;
    }

    KCCSimFree (*ppEntry);
    *ppEntry = NULL;
}

SHORT
KCCSimNthAncestor (
    IN  const DSNAME *              pdn1,
    IN  const DSNAME *              pdn2
    )
/*++

Routine Description:

    Determines the number of levels separating pdn2 from pdn1.
    Operates purely syntactically and does not access the directory.

Arguments:

    pdn1, pdn2          - The DSNAMEs to compare.

Return Value:

    -1 if pdn1 is not an ancestor of pdn2.
     0 if pdn1 == pdn2.
     n if pdn1 is n levels above pdn2.
          (1 for parent, 2 for grandparent, etc)

--*/
{
    PDSNAME                         pdnTrimmed;
    unsigned                        count1, count2;
    SHORT                           iResult;

    if (CountNameParts (pdn1, &count1) ||
        CountNameParts (pdn2, &count2)) {
        // There was a parse error trying to count one of them
        return -1;
    }

    iResult = -1;   // Assume the worst

    if (count1 == count2) {         // Same level
        if (NameMatchedStringNameOnly (pdn1, pdn2)) {
            iResult = 0;            // They're identical
        }
    } else {

        // They're not on the same level.  See if pdn1 is an
        // ancestor of pdn2

        pdnTrimmed = (PDSNAME) KCCSimAlloc (pdn2->structLen);
        // _WHY_ isn't the first argument to TrimDSNameBy
        // a (const DSNAME *) instead of a (DSNAME *)???
        TrimDSNameBy ((PDSNAME) pdn2, count2-count1, pdnTrimmed);
        if (NameMatchedStringNameOnly (pdn1, pdnTrimmed)) {
            iResult = count2-count1;
        }
        KCCSimFree (pdnTrimmed);

    }

    return iResult;
}

PSIM_ENTRY
KCCSimDsnameToEntry (
    IN  const DSNAME *              pdn,
    IN  ULONG                       ulOptions
    )
/*++

Routine Description:

    Finds the directory entry associated with a DSNAME.

Arguments:

    pdn                 - The DSNAME to search for.
    ulOptions           - Several options ORed together.

    KCCSIM_NO_OPTIONS:
        Normal behavior.
    KCCSIM_WRITE:
        If no entry exists that corresponds to the specified DSNAME,
        create one.  If an entry does exist, destroy its contents.
    KCCSIM_STRING_NAME_ONLY:
        Ignores GUIDs in DSNAMEs and searches only by string name.

Return Value:

    The associated entry, or NULL if none exists.
    Note that if KCCSIM_WRITE is specified, this function will never
    return NULL.

--*/
{
    PSIM_ENTRY                      pCurEntry, pChildAt, pNewEntry;
    PDSNAME                         pdnParent;
    BOOL                            bIsParent, bNewEntry;
    DWORD                           dwRootParts, dwPdnParts;

    // If pdn is NULL, we return the root entry.  If the directory
    // is empty, this will just return NULL.
    if (pdn == NULL) {
        return g_pSimDir->pRootEntry;
    }

    // If this is an empty pdn, we have nothing to go on.
    // So we just return NULL
    if (pdn->NameLen == 0 &&
        fNullUuid (&pdn->Guid)) {
        return NULL;
    }

    // If WRITE is enabled, we must have a stringname and a NULL GUID.
    Assert (!((ulOptions & KCCSIM_WRITE) && (pdn->NameLen == 0)));
    Assert (!((ulOptions & KCCSIM_WRITE) && !fNullUuid (&pdn->Guid)));

    bNewEntry = FALSE;
    pCurEntry = NULL;

    // We prefer to search by GUID whenever possible.
    if (    (!(ulOptions & KCCSIM_STRING_NAME_ONLY))
         && (!fNullUuid (&pdn->Guid))) {
        pCurEntry = KCCSimLookupEntryByGuid (&pdn->Guid);
    }

    // Try searching our Dsname cache
    if( pCurEntry==NULL && pdn->NameLen>0 ) {
        pCurEntry = KCCSimLookupEntryByDsname( pdn );

        if(pCurEntry==NULL) {

            bNewEntry = TRUE;

            if( ulOptions&KCCSIM_WRITE ) {

                if( g_pSimDir->pRootEntry == NULL ) {
                    
                    // If the directory is empty, create the root entry
                    g_pSimDir->pRootEntry = KCCSIM_NEW (SIM_ENTRY);
                    pCurEntry = g_pSimDir->pRootEntry;
                                                                       
                } else {
    
                    // The root exists, but pdn didn't.
                    
                    // Check if we're trying to add an entry which is a sibling
                    // (or worse, parent) of the root entry. We want to allow
                    // root siblings so that we can support domain trees which
                    // are disjoint from the root. First we count the number of
                    // parts of the root name and the pdn we want to add.
                    if(CountNameParts(g_pSimDir->pRootEntry->pdn, &dwRootParts)) {
                        KCCSimException (
                            KCCSIM_ETYPE_INTERNAL,
                            KCCSIM_ERROR_INVALID_DSNAME,
                            g_pSimDir->pRootEntry->pdn
                            );
                    }

                    if(CountNameParts(pdn, &dwPdnParts)) {
                        KCCSimException (
                            KCCSIM_ETYPE_INTERNAL,
                            KCCSIM_ERROR_INVALID_DSNAME,
                            pdn
                            );
                    }

                    if( dwPdnParts <= dwRootParts ) {
                        
                        // We create a new entry, which will be added to our
                        // Dsname and Guid indices, but it won't be accessible
                        // as a child or sibling of any other entry.
                        pCurEntry = KCCSIM_NEW(SIM_ENTRY);
                    
                    } else {

                        // Look for the parent of pdn so that we can create pdn.
                        pdnParent = KCCSimAlloc( pdn->structLen );
                        TrimDSNameBy( (DSNAME*) pdn, 1, pdnParent );
        
                        pCurEntry = KCCSimLookupEntryByDsname( pdnParent );
                        if( NULL==pCurEntry ) {
                            KCCSimException (
                                KCCSIM_ETYPE_INTERNAL,
                                KCCSIM_ERROR_NO_PARENT_FOR_OBJ,
                                pdn->StringName
                                );
                        }
    
                        if( pCurEntry->children ) {
                            Assert( pCurEntry->lastChild->next == NULL );
                            pCurEntry->lastChild->next = KCCSIM_NEW (SIM_ENTRY);
                            pCurEntry->lastChild = pCurEntry->lastChild->next;
                            pCurEntry = pCurEntry->lastChild;
                        } else {
                            Assert( pCurEntry->lastChild == NULL );
                            pCurEntry->children = KCCSIM_NEW (SIM_ENTRY);
                            pCurEntry->lastChild = pCurEntry->children;
                            pCurEntry = pCurEntry->lastChild;                        
                        }
        
                        KCCSimFree( pdnParent );
                    }
                }

            } else {
                // Object was not found, and the write option is not on.
                // We just return NULL.
            }
        }
    }

    if (ulOptions & KCCSIM_WRITE) {
        if (pCurEntry == NULL) {
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_COULD_NOT_WRITE_ENTRY
                );
        }
        if (bNewEntry) {
            Assert (pCurEntry != NULL);
            pCurEntry->pdn = KCCSimAlloc (pdn->structLen);
            memcpy (pCurEntry->pdn, pdn, pdn->structLen);
            pCurEntry->pAttrFirst = NULL;
            pCurEntry->children = NULL;
            pCurEntry->next = NULL;
            KCCSimInsertEntryIntoGuidTable (pCurEntry);
            KCCSimInsertEntryIntoDsnameTable (pCurEntry);
        } else {
            // This is not a new entry.  Destroy the existing contents.
            Assert (pCurEntry != NULL);
            KCCSimRemoveEntryFromGuidTable (pCurEntry);
            KCCSimRemoveEntryFromDsnameTable (pCurEntry);
            KCCSimFreeEntryAttributes (pCurEntry);
            KCCSimCopyGuidAndSid (pCurEntry->pdn, pdn);
            KCCSimInsertEntryIntoGuidTable (pCurEntry);
            KCCSimInsertEntryIntoDsnameTable (pCurEntry);
        }
    }

    return pCurEntry;
}

VOID
KCCSimRemoveEntry (
    IO  PSIM_ENTRY *                ppEntry
    )
/*++

Routine Description:

    Removes an entry from the directory.

Arguments:

    ppEntry             - Pointer to the entry to remove.

Return Value:

    None.

--*/
{
    PDSNAME                         pdnParent;
    PSIM_ENTRY                      pEntry;
    PSIM_ENTRY                      pEntryParent;
    PSIM_ENTRY                      pEntryAt;

    Assert (ppEntry != NULL);
    pEntry = *ppEntry;              // Just for convenience
    Assert (pEntry != NULL);

    // Is this entry the root?
    if (pEntry == g_pSimDir->pRootEntry) {
        // The caller had better know what he's doing . . .
        g_pSimDir->pRootEntry = NULL;
    } else {

        // We want this entry's parent.
        pdnParent = KCCSimAlloc (pEntry->pdn->structLen);
        TrimDSNameBy (pEntry->pdn, 1, pdnParent);
        pEntryParent = KCCSimDsnameToEntry (pdnParent, KCCSIM_NO_OPTIONS);

        // Something is very wrong if the parent isn't in the dir
        Assert (pEntryParent != NULL);

        // Base case: This is the first child of the parent
        if (pEntry == pEntryParent->children) {
            pEntryParent->children = pEntryParent->children->next;
            
            // If the entry was the only one in the list, update
            // the tail pointer
            if( pEntryParent->children==NULL ) {
                pEntryParent->lastChild = NULL;
            }

        } else {

            // Find the child immediately before this one
            pEntryAt = pEntryParent->children;
            while (pEntryAt != NULL &&
                   pEntryAt->next != pEntry) {
                pEntryAt = pEntryAt->next;
            }

            // If we didn't find this entry's older sibling,
            // that means this entry isn't linked to its parent --
            // which should never happen
            Assert (pEntryAt != NULL);
            Assert (pEntryAt->next != NULL);

            // We found the entry -- it is pEntryAt->next
            Assert (pEntryAt->next == pEntry);

            // Skip over this entry in the list of siblings
            pEntryAt->next = pEntryAt->next->next;

            // Update the tail pointer
            if( pEntryAt->next==NULL ) {
                pEntryParent->lastChild = pEntryAt;
            }

        }


    }

    KCCSimFreeEntryTree (ppEntry);      // poof
}

PDSNAME
KCCSimAlwaysGetObjCategory (
    IN  ATTRTYP                     objClass
    )
/*++

Routine Description:

    Returns the object category associated with an object class.
    When we initially populated the directory, we may have found
    an entry in the schema tree corresponding to this object class.
    If this is the case, we'll use the object category that we
    already know.
    
    However, since the schema tree is huge, it takes quite a while
    to load from an ldif file.  We don't want the user to have to do
    this every time KCCSim is run.  So, it's quite possible that we
    don't know the object category at this point.  If that's the case,
    we make an educated guess by appending the default schema RDN
    to the DMD DN stored in the anchor.  We store the result in the
    schema table for easy lookup later on.

Arguments:

    objClass            - The object class to look for.

Return Value:

    The DSNAME of the object category.

--*/
{
    PDSNAME                         pdnObjCategory;
    LPCWSTR                         pwszSchemaRDN;

    Assert (g_pSimDir->anchor.pdnDmd != NULL);

    // Do we already know the object category?
    pdnObjCategory = KCCSimAttrObjCategory (objClass);

    if (pdnObjCategory == NULL) {

        // No, we don't.  This means it wasn't found in the schema.
        // This is ok: since we're running off of a simulated
        // directory, it's possible that the user just didn't want
        // to load the entire schema.  So we make an educated guess,
        // and store it in the global table for future reference.
        pwszSchemaRDN = KCCSimAttrSchemaRDN (objClass);
        // This objClass had better be in the table
        Assert (pwszSchemaRDN != NULL);

        pdnObjCategory = KCCSimAllocAppendRDN (
            g_pSimDir->anchor.pdnDmd,
            pwszSchemaRDN,
            ATT_COMMON_NAME
            );
        // Store this object category in the schema table.
        KCCSimSetObjCategory (objClass, pdnObjCategory);

        // We want to return a pointer to the DSNAME struct
        // that's stored in the schema table, since the user
        // isn't expected to free the return value.
        KCCSimFree (pdnObjCategory);
        pdnObjCategory = KCCSimAttrObjCategory (objClass);
        Assert (pdnObjCategory != NULL);

    }

    return pdnObjCategory;
}

LPWSTR
KCCSimAllocGuidBasedDNSNameFromDSName (
    IN  const DSNAME *              pdn
    )
/*++

Routine Description:

    This function does just what it says -- transforms a
    DSNAME to a guid-based DNS name.

Arguments:

    pdn                 - The DSNAME to convert.

Return Value:

    An allocated buffer that holds the guid-based DNS name.

--*/
{
    GUID                            guidCopy;
    LPWSTR                          pwszStringizedGuid;
    LPWSTR                          pwszGuidBasedDNSName;
    ULONG                           ulLen;

    Assert (g_pSimDir->anchor.pwszRootDomainDNSName != NULL);

    // UuidToStringW isn't very nice.  It wants a GUID * when it
    // should really only need a const GUID *.  So we have to make a copy.
    memcpy (&guidCopy, &pdn->Guid, sizeof (GUID));
    KCCSIM_CHKERR (UuidToStringW (
        &guidCopy,
        &pwszStringizedGuid
        ));

    Assert (36 == wcslen (pwszStringizedGuid));
    ulLen = 36 /* guid */ + 8 /* "._mcdcs." */ +
      wcslen (g_pSimDir->anchor.pwszRootDomainDNSName) /* root DNS */ + 1 /* \0 */;
    pwszGuidBasedDNSName = KCCSimAlloc (sizeof (WCHAR) * ulLen);
    swprintf (
        pwszGuidBasedDNSName,
        L"%s._msdcs.%s",
        pwszStringizedGuid,
        g_pSimDir->anchor.pwszRootDomainDNSName
        );

    RpcStringFreeW (&pwszStringizedGuid);

    return pwszGuidBasedDNSName;
}

// This little routine:
// (1) Checks to see if the specified DSNAME is in the directory (by string)
// (2) If it is, copies the GUID and SID out of the directory

BOOL
KCCSimUpdateDsnameFromDirectory (
    IO  PDSNAME                     pdn
    )
/*++

Routine Description:

    Updates a DSNAME's GUID and SID from the directory.

Arguments:

    pdn                 - The DSNAME to update

Return Value:

    TRUE if the DSNAME was found and updated.
    FALSE if the DSNAME could not be found in the directory.

--*/
{
    PSIM_ENTRY                      pEntry;

    pEntry = KCCSimDsnameToEntry (pdn, KCCSIM_STRING_NAME_ONLY);

    if (pEntry != NULL) {
        KCCSimCopyGuidAndSid (pdn, pEntry->pdn);
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
KCCSimIsEntryOfObjectClass (
    IN  PSIM_ENTRY                  pEntry,
    IN  ATTRTYP                     objClass,
    IN  const DSNAME *              pdnObjCategory OPTIONAL
    )
/*++

Routine Description:

    Determines if an entry matches a specified object class.
    If pdnObjCategory is specified, the function will first
    search by object category, then by object class.  If
    pdnObjCategory is NULL, it will search only by object class.

Arguments:

    pEntryStart         - The first entry to search.
    objClass            - The object class to search for.
    pdnObjCategory      - The object category to search for.

Return Value:

    TRUE if the entry matches the specified object class.

--*/
{
    SIM_ATTREF                      attRef;
    PSIM_VALUE                      pValAt;
    ATTRTYP                         curObjClass;
    BOOL                            bFound;

    // First try to use the object category.
    if (pdnObjCategory != NULL) {

        KCCSimGetAttribute (pEntry, ATT_OBJECT_CATEGORY, &attRef);
        if (attRef.pAttr != NULL &&
            attRef.pAttr->pValFirst != NULL &&
            NameMatched (pdnObjCategory, (SYNTAX_DISTNAME *) attRef.pAttr->pValFirst->pVal)) {
            // Found it!
            return TRUE;
        }
        
    }

    // We failed to find it by object category.  So search by object class.
    bFound = FALSE;
    KCCSimGetAttribute (pEntry, ATT_OBJECT_CLASS, &attRef);
    if (attRef.pAttr != NULL &&
        attRef.pAttr->pValFirst != NULL) {
        for (pValAt = attRef.pAttr->pValFirst;
             pValAt != NULL;
             pValAt = pValAt->next) {
            Assert (pValAt->pVal != NULL);
            curObjClass = *((SYNTAX_OBJECT_ID *) pValAt->pVal);
            if (curObjClass == objClass) {
                bFound = TRUE;
                break;
            }
        }
    }
    return bFound;
}

PSIM_ENTRY
KCCSimFindFirstChild (
    IN  PSIM_ENTRY                  pEntryParent,
    IN  ATTRTYP                     objClass,
    IN  const DSNAME *              pdnObjCategory OPTIONAL
    )
/*++

Routine Description:

    Finds the oldest child of a directory entry that matches
    the specified object class or object category.

Arguments:

    pEntryParent        - The parent entry to search from.
    objClass            - The object class to search for.
    pdnObjCategory      - The object category to search for.

Return Value:

    The first matching entry, or NULL if none exist.

--*/
{
    PSIM_ENTRY                      pEntryAt;

    Assert (pEntryParent != NULL);

    for (pEntryAt = pEntryParent->children;
         pEntryAt != NULL;
         pEntryAt = pEntryAt->next) {

        if (KCCSimIsEntryOfObjectClass (
                pEntryAt, objClass, pdnObjCategory)) {
            break;
        }

    }

    return pEntryAt;
}

PSIM_ENTRY
KCCSimFindNextChild (
    IN  PSIM_ENTRY                  pEntryThisChild,
    IN  ATTRTYP                     objClass,
    IN  const DSNAME *              pdnObjCategory OPTIONAL
    )
/*++

Routine Description:

    This function should be called after KCCSimFindFirstChild.
    It finds the next child that matches the specified object
    class or object category.

Arguments:

    pEntryThisChild     - The return value of a call to
                          KCCSimFindFirstChild or KCCSimFindNextChild.
    objClass            - The object class to search for.
    pdnObjCategory      - The object category to search for.

Return Value:

    The next matching entry, or NULL if no more exist.

--*/
{
    PSIM_ENTRY                      pEntryAt;

    Assert (pEntryThisChild != NULL);

    for (pEntryAt = pEntryThisChild->next;
         pEntryAt != NULL;
         pEntryAt = pEntryAt->next) {

        if (KCCSimIsEntryOfObjectClass (
                pEntryAt, objClass, pdnObjCategory)) {
            break;
        }

    }

    return pEntryAt;
}

const DSNAME *
KCCSimAnchorDn (
    IN  KCCSIM_ANCHOR_ID            anchorId
    )
/*++

Routine Description:

    Fetches a DN from the anchor.

Arguments:

    anchorId            - The DN to fetch, KCCSIM_ANCHOR_*_DN.

Return Value:

    The DSNAME from the anchor.

--*/
{
    PDSNAME                         pdn = NULL;

    switch (anchorId) {
        case KCCSIM_ANCHOR_DMD_DN:
            pdn = g_pSimDir->anchor.pdnDmd;
            break;
        case KCCSIM_ANCHOR_DSA_DN:
            pdn = g_pSimDir->anchor.pdnDsa;
            break;
        case KCCSIM_ANCHOR_DOMAIN_DN:
            pdn = g_pSimDir->anchor.pdnDomain;
            break;
        case KCCSIM_ANCHOR_CONFIG_DN:
            pdn = g_pSimDir->anchor.pdnConfig;
            break;
        case KCCSIM_ANCHOR_ROOT_DOMAIN_DN:
            pdn = g_pSimDir->anchor.pdnRootDomain;
            break;
        case KCCSIM_ANCHOR_LDAP_DMD_DN:
            pdn = g_pSimDir->anchor.pdnLdapDmd;
            break;
        case KCCSIM_ANCHOR_PARTITIONS_DN:
            pdn = g_pSimDir->anchor.pdnPartitions;
            break;
        case KCCSIM_ANCHOR_DS_SVC_CONFIG_DN:
            pdn = g_pSimDir->anchor.pdnDsSvcConfig;
            break;
        case KCCSIM_ANCHOR_SITE_DN:
            pdn = g_pSimDir->anchor.pdnSite;
            break;
        default:
            Assert (!L"Invalid parameter in KCCSimAnchorDn.");
            break;
    }

    Assert (pdn != NULL);
    return pdn;
}

LPCWSTR
KCCSimAnchorString (
    IN  KCCSIM_ANCHOR_ID            anchorId
    )
/*++

Routine Description:

    Fetches a string from the anchor.

Arguments:

    anchorId            - The string to fetch, KCCSIM_ANCHOR_*_NAME.

Return Value:

    The string from the anchor.

--*/
{
    LPCWSTR                         pwsz = NULL;

    switch (anchorId) {
        case KCCSIM_ANCHOR_DOMAIN_NAME:
            pwsz = g_pSimDir->anchor.pwszDomainName;
            break;
        case KCCSIM_ANCHOR_DOMAIN_DNS_NAME:
            pwsz = g_pSimDir->anchor.pwszDomainDNSName;
            break;
        case KCCSIM_ANCHOR_ROOT_DOMAIN_DNS_NAME:
            pwsz = g_pSimDir->anchor.pwszRootDomainDNSName;
            break;
        default:
            Assert (!L"Invalid parameter in KCCSimAnchorString.");
            break;
    }

    Assert (pwsz != NULL);
    return pwsz;
}

VOID
KCCSimFreeAnchor (
    VOID
    )
/*++

Routine Description:

    Frees the anchor.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Assert (g_pSimDir != NULL);

    KCCSimFree (g_pSimDir->anchor.pdnDomain);
    g_pSimDir->anchor.pdnDomain = NULL;
    KCCSimFree (g_pSimDir->anchor.pdnConfig);
    g_pSimDir->anchor.pdnConfig = NULL;
    KCCSimFree (g_pSimDir->anchor.pdnRootDomain);
    g_pSimDir->anchor.pdnRootDomain = NULL;
    KCCSimFree (g_pSimDir->anchor.pdnLdapDmd);
    g_pSimDir->anchor.pdnLdapDmd = NULL;
    KCCSimFree (g_pSimDir->anchor.pdnPartitions);
    g_pSimDir->anchor.pdnPartitions = NULL;
    KCCSimFree (g_pSimDir->anchor.pdnDsSvcConfig);
    g_pSimDir->anchor.pdnDsSvcConfig = NULL;
    KCCSimFree (g_pSimDir->anchor.pdnSite);
    g_pSimDir->anchor.pdnSite = NULL;
    KCCSimFree (g_pSimDir->anchor.pwszDomainName);
    g_pSimDir->anchor.pwszDomainName = NULL;
    KCCSimFree (g_pSimDir->anchor.pwszDomainDNSName);
    g_pSimDir->anchor.pwszDomainDNSName = NULL;
    KCCSimFree (g_pSimDir->anchor.pwszRootDomainDNSName);
    g_pSimDir->anchor.pwszRootDomainDNSName = NULL;
}

VOID
KCCSimBuildAnchor (
    IN  LPCWSTR                     pwszDsaDn
    )
/*++

Routine Description:

    Builds the anchor.  This should be called after a
    directory has been loaded.  It populates the anchor with
    information from the directory, from the viewpoint of
    pwszDsaDn.

    If this is called again with a different DSA DN, it will
    free the existing anchor before building a new one.

Arguments:

    pwszDsaDn           - The DN of a valid NTDS Settings object.

Return Value:

    None.

--*/
{
    WCHAR                          *wszBuf;
    PSIM_ENTRY                      pEntryDsa, pEntryPartitions, pEntryCrossRef;
    SIM_ATTREF                      attRef, attRefNcName;
    PSIM_VALUE                      pValNCAt;

    // Free the existing anchor, if present.
    KCCSimFreeAnchor ();

    // If there is no DSA DN, it means the user failed to specify one
    // on the commandline.  We can't do anything, so just give up
    if (pwszDsaDn == NULL || pwszDsaDn[0] == '\0') {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_CANT_INIT_NO_DSA_DN
            );
    }

    g_pSimDir->anchor.pdnDsa = KCCSimAllocDsname (pwszDsaDn);
    // Check that the specified DSA DN really is in the directory.
    // If not, give up
    pEntryDsa = KCCSimDsnameToEntry (g_pSimDir->anchor.pdnDsa, KCCSIM_NO_OPTIONS);
    if (pEntryDsa == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_CANT_INIT_DN_NOT_IN_DIRECTORY,
            pwszDsaDn
            );
    }
    KCCSimUpdateDsnameFromDirectory (g_pSimDir->anchor.pdnDsa);

    // Derive the site DN from the DSA DN.
    g_pSimDir->anchor.pdnSite =
      (PDSNAME) KCCSimAlloc (g_pSimDir->anchor.pdnDsa->structLen);
    if (0 != TrimDSNameBy (g_pSimDir->anchor.pdnDsa, 3, g_pSimDir->anchor.pdnSite)) {
        // We couldn't trim 3 RDNs off of the DSA DN.  That must be because the
        // DSA DN is not valid.
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_CANT_INIT_INVALID_DSA_DN
            );
    }
    KCCSimUpdateDsnameFromDirectory (g_pSimDir->anchor.pdnSite);

    // Derive the config DN from the Site DN.  It must be shorter.
    g_pSimDir->anchor.pdnConfig =
      (PDSNAME) KCCSimAlloc (g_pSimDir->anchor.pdnSite->structLen);
    if (0 != TrimDSNameBy (g_pSimDir->anchor.pdnSite, 2, g_pSimDir->anchor.pdnConfig)) {
        // We couldn't trim 2 RDNs off of the Site DN.  That's the DSA DN's problem
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_CANT_INIT_INVALID_DSA_DN
            );
    }
    KCCSimUpdateDsnameFromDirectory (g_pSimDir->anchor.pdnConfig);

    // Derive the root DN from the config DN.  It must be shorter
    g_pSimDir->anchor.pdnRootDomain =
      (PDSNAME) KCCSimAlloc (g_pSimDir->anchor.pdnConfig->structLen);
    if (0 != TrimDSNameBy (g_pSimDir->anchor.pdnConfig, 1, g_pSimDir->anchor.pdnRootDomain)) {
        // We couldn't trim 1 RDN off of the Config DN.
        // Again that's a problem with the DSA DN.
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_CANT_INIT_INVALID_DSA_DN
            );
    }

    // Check that the derived root DN really is in the directory.
    // If not, something's wrong with the DSA DN
    if (!KCCSimUpdateDsnameFromDirectory (g_pSimDir->anchor.pdnRootDomain)) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_CANT_INIT_INVALID_DSA_DN
            );
    }

    // Partitions:
    g_pSimDir->anchor.pdnPartitions = KCCSimAllocAppendRDN (
        g_pSimDir->anchor.pdnConfig,
        KCCSIM_PARTITIONS_RDN,
        ATT_COMMON_NAME
        );
    pEntryPartitions = KCCSimDsnameToEntry (g_pSimDir->anchor.pdnPartitions, KCCSIM_NO_OPTIONS);
    if (pEntryPartitions == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_CANT_INIT_DN_NOT_IN_DIRECTORY,
            g_pSimDir->anchor.pdnPartitions->StringName
            );
    }

    // Service config:
    wszBuf = (WCHAR*) KCCSimAlloc( sizeof(WCHAR)*
        (  1 + wcslen(KCCSIM_SERVICES_CONTAINER)
         + g_pSimDir->anchor.pdnConfig->structLen)
        );
    swprintf (
        wszBuf,
        L"%s%s",
        KCCSIM_SERVICES_CONTAINER,
        g_pSimDir->anchor.pdnConfig->StringName
        );
    g_pSimDir->anchor.pdnDsSvcConfig = KCCSimAllocDsname( wszBuf );
    KCCSimFree( wszBuf );
    KCCSimUpdateDsnameFromDirectory (g_pSimDir->anchor.pdnDsSvcConfig);

    // Now we get the DMD location.  This will be an attribute of the
    // DSA entry.  It also gives us the LDAP DMD location.
    KCCSimGetAttribute (
        pEntryDsa,
        ATT_DMD_LOCATION,
        &attRef
        );
    if (attRef.pAttr == NULL ||
        attRef.pAttr->pValFirst == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_CANT_INIT_NO_DMD_LOCATION
            );
    }

    g_pSimDir->anchor.pdnDmd = (PDSNAME) KCCSimAlloc
        (attRef.pAttr->pValFirst->ulLen);
    memcpy (
        g_pSimDir->anchor.pdnDmd,
        attRef.pAttr->pValFirst->pVal,
        attRef.pAttr->pValFirst->ulLen
        );
    if (!KCCSimUpdateDsnameFromDirectory (g_pSimDir->anchor.pdnDmd)) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_CANT_INIT_DN_NOT_IN_DIRECTORY,
            g_pSimDir->anchor.pdnDmd->StringName
            );
    }

    // Now we make the LDAP DMD Dn
    g_pSimDir->anchor.pdnLdapDmd = KCCSimAllocAppendRDN (
        g_pSimDir->anchor.pdnDmd,
        KCCSIM_AGGREGATE_RDN,
        ATT_COMMON_NAME
        );
    KCCSimUpdateDsnameFromDirectory (g_pSimDir->anchor.pdnLdapDmd);

    // Next we get the local domain name.  This DSA will have 3 writable NCs:
    // The config dn, the DMD dn and the local dn.  So we look at its NCs, and
    // whichever is neither the config nor the DMD dn is the one we want.
    KCCSimGetAttribute (
        pEntryDsa,
        ATT_HAS_MASTER_NCS,
        &attRef
        );
    if (attRef.pAttr != NULL) {
        for (pValNCAt = attRef.pAttr->pValFirst;
             pValNCAt != NULL;
             pValNCAt = pValNCAt->next) {
            if (!NameMatched (
                    (PDSNAME) pValNCAt->pVal,
                    g_pSimDir->anchor.pdnConfig) &&
                !NameMatched (
                    (PDSNAME) pValNCAt->pVal,
                    g_pSimDir->anchor.pdnDmd)) {
                g_pSimDir->anchor.pdnDomain = (PDSNAME) KCCSimAlloc
                    (pValNCAt->ulLen);
                memcpy (
                    g_pSimDir->anchor.pdnDomain,
                    pValNCAt->pVal,
                    pValNCAt->ulLen
                    );
                if (!KCCSimUpdateDsnameFromDirectory (g_pSimDir->anchor.pdnDomain)) {
                    KCCSimException (
                        KCCSIM_ETYPE_INTERNAL,
                        KCCSIM_ERROR_CANT_INIT_DN_NOT_IN_DIRECTORY,
                        g_pSimDir->anchor.pdnDomain->StringName
                        );
                }
                break;
            }
        }
    }

    if (g_pSimDir->anchor.pdnDomain == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_CANT_INIT_INVALID_MASTER_NCS
            );
    }

    // Now, we want to get some information out of the partitions container.

    for (pEntryCrossRef = KCCSimFindFirstChild (
            pEntryPartitions, CLASS_CROSS_REF, NULL);
         pEntryCrossRef != NULL;
         pEntryCrossRef = KCCSimFindNextChild (
            pEntryCrossRef, CLASS_CROSS_REF, NULL)) {

        // See if this is the root domain cross-ref.
        KCCSimGetAttribute (
            pEntryCrossRef,
            ATT_NC_NAME,
            &attRefNcName
            );
        if (attRefNcName.pAttr != NULL &&
            attRefNcName.pAttr->pValFirst != NULL &&
            NameMatched (
                g_pSimDir->anchor.pdnRootDomain,
                (PDSNAME) attRefNcName.pAttr->pValFirst->pVal)) {
            // It is.
            KCCSimGetAttribute (
                pEntryCrossRef,
                ATT_DNS_ROOT,
                &attRef
                );
            if (attRef.pAttr != NULL &&
                attRef.pAttr->pValFirst != NULL) {
                g_pSimDir->anchor.pwszRootDomainDNSName = KCCSIM_WCSDUP
                    ((LPWSTR) attRef.pAttr->pValFirst->pVal);
            }
        }

        // See if this is the local domain cross-ref.
        if (attRefNcName.pAttr != NULL &&
            attRefNcName.pAttr->pValFirst != NULL &&
            NameMatched (
                g_pSimDir->anchor.pdnDomain,
                (PDSNAME) attRefNcName.pAttr->pValFirst->pVal)) {
            // It is.
            KCCSimGetAttribute (
                pEntryCrossRef,
                ATT_DNS_ROOT,
                &attRef
                );
            if (attRef.pAttr != NULL &&
                attRef.pAttr->pValFirst != NULL) {
                g_pSimDir->anchor.pwszDomainDNSName = KCCSIM_WCSDUP
                    ((LPWSTR) attRef.pAttr->pValFirst->pVal);
            }
            KCCSimGetAttribute (
                pEntryCrossRef,
                ATT_NETBIOS_NAME,
                &attRef
                );
            if (attRef.pAttr != NULL &&
                attRef.pAttr->pValFirst != NULL) {
                g_pSimDir->anchor.pwszDomainName = KCCSIM_WCSDUP
                    ((LPWSTR) attRef.pAttr->pValFirst->pVal);
            }
        }

    }

    if (g_pSimDir->anchor.pwszRootDomainDNSName == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_CANT_INIT_NO_CROSS_REF,
            g_pSimDir->anchor.pdnRootDomain->StringName
            );
    }
    if (g_pSimDir->anchor.pwszDomainName == NULL ||
        g_pSimDir->anchor.pwszDomainDNSName == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_CANT_INIT_NO_CROSS_REF,
            g_pSimDir->anchor.pdnDomain->StringName
            );
    }

}

ATTRTYP
KCCSimUpdateObjClassAttr (
    IN  PSIM_ATTREF                 pAttRef
    )
/*++

Routine Description:

    Updates an object class attribute, i.e. fills in all super-classes
    if they are missing.  So if the only value in the attribute is
    CLASS_NTDS_SITE_SETTINGS, this routine will add
    CLASS_APPLICATION_SITE_SETTINGS and CLASS_TOP.

Arguments:

    pAttr               - The attribute to update.

Return Value:

    The most specific object class in the attribute.  In the above
    example, this would return CLASS_NTDS_SITE_SETTINGS.

--*/
{
    #define MAX_CLASSES             10  // The maximum number of values
                                        // in an objClass attribute

    PSIM_VALUE                      pValAt;
    ATTRTYP                         objClass[MAX_CLASSES],
                                    superClass[MAX_CLASSES];
    ATTRTYP                         objClassMostSpecific = INVALID_ATT;
    BOOL                            bFoundSuperClass, bFoundMostSpecific;
    ULONG                           ulNumClasses, ulClass, ul;

    Assert (KCCSimAttRefIsValid (pAttRef));
    Assert (pAttRef->pAttr->attrType == ATT_OBJECT_CLASS);

    // Count the number of object classes, copy them into a convenient
    // array, and create another array that contains the superclass of
    // each object class.
    ulNumClasses = 0;
    for (pValAt = pAttRef->pAttr->pValFirst;
         pValAt != NULL;
         pValAt = pValAt->next) {
        // If this assert is ever fired, we need to raise MAX_CLASSES
        Assert (ulNumClasses < MAX_CLASSES);
        objClass[ulNumClasses] = *((SYNTAX_OBJECT_ID *) pValAt->pVal);
        superClass[ulNumClasses] = KCCSimAttrSuperClass (objClass[ulNumClasses]);
        ulNumClasses++;
    }

    // Now make sure that, for each class, its super-class is in the
    // attribute (objClass array).  If it isn't, then add it
    for (ulClass = 0; ulClass < ulNumClasses; ulClass++) {
        bFoundSuperClass = FALSE;
        for (ul = 0; ul < ulNumClasses; ul++) {
            if (objClass[ul] == superClass[ulClass]) {
                bFoundSuperClass = TRUE;
                break;
            }
        }
        if (!bFoundSuperClass) {
            KCCSimAllocAddValueToAttribute (
                pAttRef,
                sizeof (ATTRTYP),
                (PBYTE) &superClass[ulClass]
                );
            // Now the new class we just added might have its own
            // superclass that differs from anything we've seen before.
            // We may need to add that in as well - so stick it on the
            // end of the array, and increase ulNumClasses.
            Assert (ulNumClasses < MAX_CLASSES);
            objClass[ulNumClasses] = superClass[ulClass];
            superClass[ulNumClasses] = KCCSimAttrSuperClass (objClass[ulNumClasses]);
            ulNumClasses++;
        }
    }

    // Now we pick the most specific object class.  If there is only
    // one, then it is obviously the one we want; otherwise we find the class
    // that does not appear as the super-class of anything in the attribute.

    if (ulNumClasses == 1) {
        objClassMostSpecific = objClass[0];
    } else {
        bFoundMostSpecific = FALSE;
        for (ulClass = 0; ulClass < ulNumClasses; ulClass++) {
            // Assume it's the most specific until proven otherwise
            bFoundMostSpecific = TRUE;
            for (ul = 0; ul < ulNumClasses; ul++) {
                if (superClass[ul] == objClass[ulClass]) {
                    bFoundMostSpecific = FALSE;
                    break;
                }
            }
            if (bFoundMostSpecific) {
                objClassMostSpecific = objClass[ulClass];
                break;
            }
        }
        // And unless there are class-inheritance loops in the schema
        // table (in which case we have bigger problems):
        Assert (bFoundMostSpecific);
    }

    return objClassMostSpecific;
}

VOID
KCCSimAddMissingAttributes (
    IN  PSIM_ENTRY                  pEntry
    )
/*++

Routine Description:

    Checks to see if certain vital attributes (e.g. objectGUID,
    distinguishedName) are present, and fills them in if they are
    absent.

Arguments:

    pEntry              - The entry to fill in.

Return Value:

    None.

--*/
{
    SIM_ATTREF                      attRef;
    WCHAR                           wszRDN[1+MAX_RDN_SIZE];

    ATTRTYP                         objClassForCategory;
    PDSNAME                         pdnObjCategory;

    Assert (pEntry != NULL);

    KCCSimQuickRDNOf (pEntry->pdn, wszRDN);

    // objectGUID:
    if (!KCCSimGetAttribute (pEntry, ATT_OBJECT_GUID, NULL)) {

        KCCSimNewAttribute (pEntry, ATT_OBJECT_GUID, &attRef);
        // First make sure there is a GUID in the object dn.
        if (fNullUuid (&pEntry->pdn->Guid)) {
            // The dn has no GUID either!  So we'll have to make one up.
            KCCSIM_CHKERR (UuidCreate (&pEntry->pdn->Guid));
        }
        // Now add the dn's GUID to the attribute.
        KCCSimAllocAddValueToAttribute (
            &attRef,
            sizeof (GUID),
            (PBYTE) &pEntry->pdn->Guid
            );

    }

    // distinguishedName:
    if (!KCCSimGetAttribute (pEntry, ATT_OBJ_DIST_NAME, NULL)) {
        KCCSimNewAttribute (pEntry, ATT_OBJ_DIST_NAME, &attRef);
        KCCSimAllocAddValueToAttribute (
            &attRef,
            pEntry->pdn->structLen,
            (PBYTE) pEntry->pdn
            );
    }
    // name:
    if (!KCCSimGetAttribute (pEntry, ATT_RDN, NULL)) {
        KCCSimNewAttribute (pEntry, ATT_RDN, &attRef);
        KCCSimAllocAddValueToAttribute (
            &attRef,
            KCCSIM_WCSMEMSIZE (wszRDN),
            (PBYTE) wszRDN
            );
    }
    // cn:
    if (!KCCSimGetAttribute (pEntry, ATT_COMMON_NAME, NULL)) {
        KCCSimNewAttribute (pEntry, ATT_COMMON_NAME, &attRef);
        KCCSimAllocAddValueToAttribute (
            &attRef,
            KCCSIM_WCSMEMSIZE (wszRDN),
            (PBYTE) wszRDN
            );
    }

    // Finally, we do objectClass and objectCategory.
    
    if (KCCSimGetAttribute (pEntry, ATT_OBJECT_CLASS, &attRef)) {

        objClassForCategory = KCCSimUpdateObjClassAttr (&attRef);

        // Finally, add the category, if necessary
        if (!KCCSimGetAttribute (pEntry, ATT_OBJECT_CATEGORY, NULL)) {
            KCCSimNewAttribute (pEntry, ATT_OBJECT_CATEGORY, &attRef);
            pdnObjCategory = KCCSimAlwaysGetObjCategory (objClassForCategory);
            KCCSimAllocAddValueToAttribute (
                &attRef,
                pdnObjCategory->structLen,
                (PBYTE) pdnObjCategory
                );
        }

    }
}

VOID
KCCSimUpdatePropertyMetaData (
    IN  PSIM_ATTREF                 pAttRef,
    IN  const UUID *                puuidDsaOriginating OPTIONAL
    )
/*++

Routine Description:

    Updates the property meta data for an attribute.

Arguments:

    pAttRef             - Pointer to the attribute reference for the attribute
                          to update.
    puuidDsaOriginating - The originating DSA's UUID.  A null uuid is used
                          if this parameter is omitted.

Return Value:

    None.

--*/
{
    SIM_ATTREF                      attRefPropertyMetaData;
    PROPERTY_META_DATA_VECTOR *     pMetaDataVector;
    PROPERTY_META_DATA *            pThisMetaData;
    ATTRMODLIST                     attrModList;

    ULONG                           ulMDAt;

    Assert (KCCSimAttRefIsValid (pAttRef));

    // First get this entry's property meta data.
    if (KCCSimGetAttribute (
            pAttRef->pEntry,
            ATT_REPL_PROPERTY_META_DATA,
            &attRefPropertyMetaData
            )) {

        // There exists a property meta data vector attribute.
        Assert (attRefPropertyMetaData.pAttr->pValFirst != NULL);
        pMetaDataVector = (PROPERTY_META_DATA_VECTOR *)
            attRefPropertyMetaData.pAttr->pValFirst->pVal;
        Assert (pMetaDataVector->dwVersion == 1);

        // Find this attribute in the vector.
        pThisMetaData = NULL;
        for (ulMDAt = 0; ulMDAt < pMetaDataVector->V1.cNumProps; ulMDAt++) {
            if (pMetaDataVector->V1.rgMetaData[ulMDAt].attrType ==
                pAttRef->pAttr->attrType) {
                pThisMetaData = &pMetaDataVector->V1.rgMetaData[ulMDAt];
                break;
            }
        }

        if (pThisMetaData == NULL) {
            // We didn't find it, so allocate space for a new one.
            attRefPropertyMetaData.pAttr->pValFirst->pVal = KCCSimReAlloc (
                attRefPropertyMetaData.pAttr->pValFirst->pVal,
                attRefPropertyMetaData.pAttr->pValFirst->ulLen +
                    sizeof (PROPERTY_META_DATA)
            );
            pMetaDataVector = (PROPERTY_META_DATA_VECTOR *)
                attRefPropertyMetaData.pAttr->pValFirst->pVal;
            pMetaDataVector->V1.cNumProps++;
            pThisMetaData = &pMetaDataVector->V1.rgMetaData
                [pMetaDataVector->V1.cNumProps-1];
            pThisMetaData->dwVersion = 0;
        }

    } else {

        // No property meta data vector exists; we must create a new one.
        KCCSimNewAttribute (
            pAttRef->pEntry,
            ATT_REPL_PROPERTY_META_DATA,
            &attRefPropertyMetaData
            );
        pMetaDataVector = KCCSIM_NEW (PROPERTY_META_DATA_VECTOR);
        KCCSimAddValueToAttribute (
            &attRefPropertyMetaData,
            sizeof (PROPERTY_META_DATA_VECTOR),
            (PBYTE) pMetaDataVector
            );
        pMetaDataVector->dwVersion = 1;
        pMetaDataVector->V1.cNumProps = 1;
        pThisMetaData = &pMetaDataVector->V1.rgMetaData[0];
        pThisMetaData->dwVersion = 0;

    }

    // Do the actual updating.
    pThisMetaData->attrType = pAttRef->pAttr->attrType;
    pThisMetaData->dwVersion++;
    pThisMetaData->timeChanged = SimGetSecondsSince1601 ();
    if (puuidDsaOriginating == NULL) {
        RtlZeroMemory (&pThisMetaData->uuidDsaOriginating, sizeof (UUID));
    } else {
        memcpy (
            &(pThisMetaData->uuidDsaOriginating),
            puuidDsaOriginating,
            sizeof (UUID)
            );
    }
    pThisMetaData->usnOriginating = 0;
    pThisMetaData->usnProperty = 0;

    return;
}

VOID
KCCSimUpdateWholeDirectoryRecurse (
    IN  PSIM_ENTRY                  pEntry
    )
/*++

Routine Description:

    Updates the directory starting at pEntry.
    When ldifldap supplies us with DSNAMEs, it neglects to include
    GUIDs and SIDs.  When a DSNAME-valued attribute is read, we do
    not necessarily know anything about the actual directory entry
    that it refers to (since the reference may occur sooner in the
    LDIF file than the actual entry.)  Therefore, after reading in
    a simulated directory, we must scan through all DSNAME-valued
    attributes and, where appropriate, update them with the
    corresponding GUIDs and SIDs.

Arguments:

    pEntry              - The base of the tree.

Return Value:

    None.

--*/
{
    PSIM_ENTRY                      pChildAt;
    PSIM_ATTRIBUTE                  pAttrAt;
    SIM_ATTREF                      attRef;
    PSIM_VALUE                      pValAt;

    if (pEntry == NULL) {
        return;
    }

    // We begin by updating the current entry.  We cycle through
    // and update each attribute.

    for (pAttrAt = pEntry->pAttrFirst;
         pAttrAt != NULL;
         pAttrAt = pAttrAt->next) {

        if (ATT_OBJ_DIST_NAME == pAttrAt->attrType) {

            // If the attribute is a distinguishedName, we simply copy the GUID
            // and SID out of this entry's Dsname.

            Assert (pAttrAt->pValFirst != NULL);
            Assert (pAttrAt->pValFirst->pVal != NULL);
            Assert (NameMatchedStringNameOnly (
                            (SYNTAX_DISTNAME *) pAttrAt->pValFirst->pVal,
                            pEntry->pdn));

            KCCSimCopyGuidAndSid (
                (SYNTAX_DISTNAME *) pAttrAt->pValFirst->pVal,
                pEntry->pdn
                );

        } else if (KCCSimAttrSyntaxType (pAttrAt->attrType) == SYNTAX_DISTNAME_TYPE) {

            // If this is a DISTNAME that is not a distinguishedName attribute,
            // we call UpdateDsnameFromDirectory.

            for (pValAt = pAttrAt->pValFirst;
                 pValAt != NULL;
                 pValAt = pValAt->next) {
                KCCSimUpdateDsnameFromDirectory (
                    (SYNTAX_DISTNAME *) pValAt->pVal
                    );
            }

        }

        // If this attribute is an inter-site topology generator attribute, we
        // need to update its metadata to appease the KCC.
        // We cannot rely on the metadata being present, because ldifde doesn't
        // (and shouldn't) export metadata by default.  Forcing the user to
        // supply metadata for every entry in the directory would create
        // enormous overhead.
        if (pAttrAt->attrType == ATT_INTER_SITE_TOPOLOGY_GENERATOR) {
            attRef.pEntry = pEntry;
            attRef.pAttr = pAttrAt;
            KCCSimUpdatePropertyMetaData (&attRef, NULL);
        }

    }

    // Now update this entry's children.

    pChildAt = pEntry->children;
    while (pChildAt != NULL) {

        KCCSimUpdateWholeDirectoryRecurse (pChildAt);
        pChildAt = pChildAt->next;

    }
}

VOID
KCCSimUpdateWholeDirectory (
    VOID
    )
/*++

Routine Description:

    Refreshes the directory.

Arguments:

    None.

Return Value:

    None.

--*/
{
    // Free the server state table; it may no longer be valid.
    KCCSimFreeStates ();
    KCCSimUpdateWholeDirectoryRecurse (g_pSimDir->pRootEntry);
}

VOID
KCCSimFreeDirectory (
    VOID
    )
/*++

Routine Description:

    Frees the entire directory.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (g_pSimDir == NULL) {
        return;
    }

    KCCSimFreeEntryTree (&g_pSimDir->pRootEntry);
    // That should also free the GUID and Dsname tables
    Assert (RtlIsGenericTableEmpty (&g_pSimDir->tableGuid));
    Assert (RtlIsGenericTableEmpty (&g_pSimDir->tableDsname));
    KCCSimFreeAnchor ();

    KCCSimFree (g_pSimDir);
    g_pSimDir = NULL;
}

VOID
KCCSimInitializeDir (
    VOID
    )
/*++

Routine Description:

    Initializes the simulated directory.

Arguments:

    None.

Return Value:

    None.

--*/
{
    KCCSimFreeDirectory ();

    Assert (g_pSimDir == NULL);

    g_pSimDir = KCCSIM_NEW (SIM_DIRECTORY);

    g_pSimDir->pRootEntry = NULL;
    g_pSimDir->anchor.pdnDmd = NULL;
    g_pSimDir->anchor.pdnDsa = NULL;
    g_pSimDir->anchor.pdnDomain = NULL;
    g_pSimDir->anchor.pdnConfig = NULL;
    g_pSimDir->anchor.pdnRootDomain = NULL;
    g_pSimDir->anchor.pdnLdapDmd = NULL;
    g_pSimDir->anchor.pdnPartitions = NULL;
    g_pSimDir->anchor.pdnDsSvcConfig = NULL;
    g_pSimDir->anchor.pdnSite = NULL;
    g_pSimDir->anchor.pwszDomainName = NULL;
    g_pSimDir->anchor.pwszDomainDNSName = NULL;
    g_pSimDir->anchor.pwszRootDomainDNSName = NULL;
    RtlInitializeGenericTable (
        &g_pSimDir->tableGuid,
        KCCSimGuidTableCompare,
        KCCSimTableAlloc,
        KCCSimTableFree,
        NULL
        );
    RtlInitializeGenericTable (
        &g_pSimDir->tableDsname,
        KCCSimDsnameTableCompare,
        KCCSimTableAlloc,
        KCCSimTableFree,
        NULL
        );

}

VOID
KCCSimAllocGetAllServers (
    OUT ULONG *                     pulNumServers,
    OUT PSIM_ENTRY **               papEntryNTDSSettings
    )
/*++

Routine Description:

    Allocates an array containing the directory entries of
    all NTDS DSA objects in the enterprise.  The user is
    expected to call KCCSimFree (*papEntryNTDSSettings).

Arguments:

    pulNumServers       - The number of servers in the enterprise.
    papdnServers        - Pointer to an array containing the entry
                          of each server in the enterprise.

Return Value:

    None.

--*/
{
    PSIM_ENTRY                      pEntryConfig, pEntrySitesContainer,
                                    pEntrySite, pEntryServersContainer,
                                    pEntryServer, pEntryNTDSSettings;

    ULONG                           ulNumServers, ul;
    PSIM_ENTRY *                    apEntryNTDSSettings;

    Assert (pulNumServers != NULL);
    Assert (papEntryNTDSSettings != NULL);

    if (g_pSimDir->anchor.pdnConfig != NULL) {
        pEntryConfig = KCCSimDsnameToEntry (g_pSimDir->anchor.pdnConfig, KCCSIM_NO_OPTIONS);
    } else {
        pEntryConfig = KCCSimFindFirstChild (
            g_pSimDir->pRootEntry, CLASS_CONFIGURATION, NULL);
    }
    Assert (pEntryConfig != NULL);
    pEntrySitesContainer = KCCSimFindFirstChild (
        pEntryConfig, CLASS_SITES_CONTAINER, NULL);
    if (pEntrySitesContainer == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_SITES_CONTAINER_MISSING
            );
    }

    // Count the number of servers.
    ulNumServers = 0;
    for (pEntrySite = KCCSimFindFirstChild (
            pEntrySitesContainer, CLASS_SITE, NULL);
         pEntrySite != NULL;
         pEntrySite = KCCSimFindNextChild (
            pEntrySite, CLASS_SITE, NULL)) {

        pEntryServersContainer = KCCSimFindFirstChild (
            pEntrySite, CLASS_SERVERS_CONTAINER, NULL);
        Assert (pEntryServersContainer != NULL);
        for (pEntryServer = KCCSimFindFirstChild (
                pEntryServersContainer, CLASS_SERVER, NULL);
             pEntryServer != NULL;
             pEntryServer = KCCSimFindNextChild (
                pEntryServer, CLASS_SERVER, NULL)) {
            ulNumServers++;
        }

    }

    apEntryNTDSSettings = KCCSIM_NEW_ARRAY (PSIM_ENTRY, ulNumServers);

    // Fill in the entries.
    ul = 0;
    for (pEntrySite = KCCSimFindFirstChild (
            pEntrySitesContainer, CLASS_SITE, NULL);
         pEntrySite != NULL;
         pEntrySite = KCCSimFindNextChild (
            pEntrySite, CLASS_SITE, NULL)) {

        pEntryServersContainer = KCCSimFindFirstChild (
            pEntrySite, CLASS_SERVERS_CONTAINER, NULL);
        Assert (pEntryServersContainer != NULL);
        for (pEntryServer = KCCSimFindFirstChild (
                pEntryServersContainer, CLASS_SERVER, NULL);
             pEntryServer != NULL;
             pEntryServer = KCCSimFindNextChild (
                pEntryServer, CLASS_SERVER, NULL)) {
            
            Assert (ul < ulNumServers);
            pEntryNTDSSettings = KCCSimFindFirstChild (
                pEntryServer, CLASS_NTDS_DSA, NULL);
            if( NULL==pEntryNTDSSettings ) {
                KCCSimPrintMessage (
                    KCCSIM_ERROR_SERVER_BUT_NO_SETTINGS,
                    pEntryServer->pdn->StringName
                );                
            } else {
                apEntryNTDSSettings[ul] = pEntryNTDSSettings;
                ul++;
            }
        }

    }
    Assert (ul <= ulNumServers);

    *pulNumServers = ul;
    *papEntryNTDSSettings = apEntryNTDSSettings;
}

PSIM_ENTRY
KCCSimMatchChildForCompare (
    IN  PSIM_ENTRY                  pEntryParent,
    IN  PSIM_ENTRY                  pEntryMatch
    )
/*++

Routine Description:

    Searches for a child entry that matches another entry.
    Used for regression testing.

Arguments:

    pEntryParent        - The entry whose children we are to search.
    pEntryMatch         - The entry we are trying to match.

Return Value:

    The child of pEntryParent that matches pEntryMatch, if one exists;
    otherwise NULL.

--*/
{
    PSIM_ENTRY                      pEntryChild;
    SIM_ATTREF                      attRef;
    const DSNAME *                  pdnMatchFromServerAtt;
    BOOL                            bIsMatch;

    pdnMatchFromServerAtt = NULL;
    if (KCCSimIsEntryOfObjectClass (
            pEntryMatch,
            CLASS_NTDS_CONNECTION,
            NULL
            )) {
        // If we're trying to match a connection object, then its
        // RDN will be a stringized GUID.  Since GUIDs can vary
        // unpredictably, we match using the fromserver attribute
        // instead (assuming there is one.)
        KCCSimGetAttribute (pEntryMatch, ATT_FROM_SERVER, &attRef);
        if (attRef.pAttr != NULL &&
            attRef.pAttr->pValFirst != NULL) {
            pdnMatchFromServerAtt =
                (const DSNAME *) attRef.pAttr->pValFirst->pVal;
        }
    }

    for (pEntryChild = pEntryParent->children;
         pEntryChild != NULL;
         pEntryChild = pEntryChild->next) {

        bIsMatch = FALSE;

        if (pdnMatchFromServerAtt == NULL) {
            // We haven't set a fromserver attribute, so we want to
            // match by DN.
            bIsMatch = NameMatchedStringNameOnly (pEntryChild->pdn, pEntryMatch->pdn);
        } else {

            // We want to match by fromserver attribute.
            KCCSimGetAttribute (pEntryChild, ATT_FROM_SERVER, &attRef);
            if (attRef.pAttr != NULL &&
                attRef.pAttr->pValFirst != NULL) {
                bIsMatch = NameMatchedStringNameOnly (
                    (const DSNAME *) attRef.pAttr->pValFirst->pVal,
                    pdnMatchFromServerAtt
                    );
            }

        }

        if (bIsMatch) {
            break;
        }

    }

    return pEntryChild;
}

BOOL
KCCSimCompareEntries (
    IN  PSIM_ENTRY                  pEntryReal,
    IN  PSIM_ENTRY                  pEntryStored
    )
/*++

Routine Description:

    Compares two entries for regression testing.

Arguments:

    pEntryReal          - The entry from the real (in-memory) directory.
    pEntryStored        - The entry loaded from the LDIF file.

Return Value:

    TRUE if the entries are identical; false otherwise.

--*/
{
    BOOL                            bIdentical;
    PSIM_ENTRY                      pChild, pEntryChildReal;
    PSIM_ATTRIBUTE                  pAttrAt;
    SIM_ATTREF                      attRefStored, attRefReal;
    PSIM_VALUE                      pValAt;
    ULONG                           ulSyntax;

    ULONG                           ulNumVals;
    WCHAR                           wszLtowBuf[1+KCCSIM_MAX_LTOA_CHARS];

    bIdentical = TRUE;

    // Check for extraneous attributes.
    for (pAttrAt = pEntryReal->pAttrFirst;
         pAttrAt != NULL;
         pAttrAt = pAttrAt->next) {
        if (!KCCSimGetAttribute (pEntryStored, pAttrAt->attrType, NULL)) {
            KCCSimPrintMessage (
                KCCSIM_MSG_DIRCOMPARE_EXTRANEOUS_ATTRIBUTE,
                pEntryReal->pdn->StringName,
                KCCSimAttrTypeToString (pAttrAt->attrType)
                );
            
            // For regression test purposes, we need to consider some extraneous
            // attributes as being harmless. These attributes are:
            // msDS-Behavior-Version, replPropertyMetaData, mS-DS-ReplicatesNCReason
            // 
            if( pAttrAt->attrType != ATT_MS_DS_BEHAVIOR_VERSION         &&
                pAttrAt->attrType != ATT_MS_DS_REPLICATES_NC_REASON     &&
                pAttrAt->attrType != ATT_REPL_PROPERTY_META_DATA
                )
            {
                bIdentical = FALSE;
            }
        }
    }

    attRefStored.pEntry = pEntryStored;

    // Verify the attributes.
    for (pAttrAt = pEntryStored->pAttrFirst;
         pAttrAt != NULL;
         pAttrAt = pAttrAt->next) {

        attRefStored.pAttr = pAttrAt;
        if (!KCCSimGetAttribute (pEntryReal, pAttrAt->attrType, &attRefReal)) {
            KCCSimPrintMessage (
                KCCSIM_MSG_DIRCOMPARE_MISSING_ATTRIBUTE,
                pEntryReal->pdn->StringName,
                KCCSimAttrTypeToString (pAttrAt->attrType)
                );
            bIdentical = FALSE;
        } else {

            ulSyntax = KCCSimAttrSyntaxType (pAttrAt->attrType);

            // Note that we compare values of only those attributes with
            // specific syntaxes.
            // We don't compare attribute values of connection objects at all.
            if (!KCCSimIsEntryOfObjectClass (pEntryStored, CLASS_NTDS_CONNECTION, NULL) &&
                pAttrAt->attrType != ATT_OBJECT_GUID             &&
                pAttrAt->attrType != ATT_INVOCATION_ID           &&
                pAttrAt->attrType != ATT_SMTP_MAIL_ADDRESS       &&
                pAttrAt->attrType != ATT_REPL_PROPERTY_META_DATA &&
                (ulSyntax == SYNTAX_OBJECT_ID_TYPE     ||
                 ulSyntax == SYNTAX_NOCASE_STRING_TYPE ||
                 ulSyntax == SYNTAX_OCTET_STRING_TYPE  ||
                 ulSyntax == SYNTAX_UNICODE_TYPE)) {

                // Check for extraneous attribute values.
                ulNumVals = 0;
                // In the real database, the object class contains all super-classes.
                // In the stored file, only the most specific class is present.
                // Skip checking this direction since real db is a super-set
                if (pAttrAt->attrType != ATT_OBJECT_CLASS) {
                    for (pValAt = attRefReal.pAttr->pValFirst;
                         pValAt != NULL;
                         pValAt = pValAt->next) {
                        if (!KCCSimIsValueInAttribute (
                            &attRefStored,
                            pValAt->ulLen,
                            pValAt->pVal
                            )) {
                            ulNumVals++;
                        }
                    }
                }
                if (ulNumVals != 0) {
                    KCCSimPrintMessage (
                        KCCSIM_MSG_DIRCOMPARE_EXTRANEOUS_VALUES,
                        pEntryReal->pdn->StringName,
                        KCCSimAttrTypeToString (pAttrAt->attrType),
                        _ultow (ulNumVals, wszLtowBuf, 10)
                        );
                }

                // Verify the attribute values.
                ulNumVals = 0;
                for (pValAt = pAttrAt->pValFirst;
                     pValAt != NULL;
                     pValAt = pValAt->next) {
                    if (!KCCSimIsValueInAttribute (
                            &attRefReal,
                            pValAt->ulLen,
                            pValAt->pVal
                            )) {
                        ulNumVals++;
                    }
                }
                if (ulNumVals != 0) {
                    KCCSimPrintMessage (
                        KCCSIM_MSG_DIRCOMPARE_MISSING_VALUES,
                        pEntryReal->pdn->StringName,
                        KCCSimAttrTypeToString (pAttrAt->attrType),
                        _ultow (ulNumVals, wszLtowBuf, 10)
                        );
                }

            }

        }

    }

    // Check for extraneous children.
    for (pChild = pEntryReal->children;
         pChild != NULL;
         pChild = pChild->next) {
        if (KCCSimMatchChildForCompare (pEntryStored, pChild) == NULL) {
            KCCSimPrintMessage (
                KCCSIM_MSG_DIRCOMPARE_EXTRANEOUS_DN,
                pChild->pdn->StringName
                );
            bIdentical = FALSE;
        }
    }

    // Recurse.
    for (pChild = pEntryStored->children;
         pChild != NULL;
         pChild = pChild->next) {

        pEntryChildReal = KCCSimMatchChildForCompare (pEntryReal, pChild);
        if (pEntryChildReal == NULL) {
            KCCSimPrintMessage (
                KCCSIM_MSG_DIRCOMPARE_MISSING_DN,
                pChild->pdn->StringName
                );
            bIdentical = FALSE;
        } else {
            bIdentical &= KCCSimCompareEntries (pEntryChildReal, pChild);
        }

    }

    return bIdentical;
}

VOID
KCCSimCompareDirectory (
    IN  LPWSTR                      pwszFn
    )
/*++

Routine Description:

    Compares the in-memory directory with one stored in an LDIF file.

Arguments:

    pwszFn              - The LDIF file to compare against.

Return Value:

    None.

--*/
{
    PSIM_DIRECTORY                  pRealDirectory = NULL;
    BOOL                            bIdentical;

    __try {

        // All of our directory functions are hard-coded to use g_pSimDir.
        // We want to load an LDIF file into a blank directory.  So, we
        // store the real pseudo-directory in a safe place, null out
        // g_pSimDir, load the stored directory into g_pSimDir, and after
        // we finish our comparison, restore things to normal.
        pRealDirectory = g_pSimDir;
        g_pSimDir = NULL;
        KCCSimInitializeDir ();
        KCCSimLoadLdif (pwszFn);

        if (pRealDirectory == NULL ||
            pRealDirectory->pRootEntry == NULL ||
            !NameMatchedStringNameOnly (
                pRealDirectory->pRootEntry->pdn,
                g_pSimDir->pRootEntry->pdn
                )) {
            bIdentical = FALSE;
            KCCSimPrintMessage (KCCSIM_ERROR_CANT_COMPARE_DIFFERENT_ROOTS);
        } else {
            bIdentical = KCCSimCompareEntries (pRealDirectory->pRootEntry, g_pSimDir->pRootEntry);
        }

        if (bIdentical) {
            KCCSimPrintMessage (KCCSIM_MSG_DIRCOMPARE_IDENTICAL);
        }

    } __finally {

        // Restore things to normal!
        KCCSimFreeDirectory ();
        g_pSimDir = pRealDirectory;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\sim\buildmak.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    buildmak.c

ABSTRACT:

    Accessory to buildcfg.c that performs the actual
    construction of the simulated directory.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <attids.h>
#include <debug.h>
#include "kccsim.h"
#include "util.h"
#include "dir.h"
#include "simtime.h"
#include "buildcfg.h"
#include "objids.h"
#include "schedule.h"
#include <fileno.h>
#define FILENO  FILENO_KCCSIM_BUILDMAK

BUILDCFG_TRANSPORT_INFO             transportInfo[BUILDCFG_NUM_TRANSPORTS] = {
    { L"IP",    ATT_DNS_HOST_NAME,      L"ismip.dll",  NULL },
    { L"SMTP",  ATT_SMTP_MAIL_ADDRESS,  L"",           NULL }
};

VOID
BuildCfgGetNextUuid (
    OUT UUID *                      puuid
    )
/*++

Routine Description:

    Gets the next UUID stored in the table.  UUIDs obtained through this
    function will always be returned in ascending order.

Arguments:

    puuid               - Pointer to a UUID structure that will hold the
                          result.

Return Value:

    None.

--*/
{
    PVOID                           p;

    p = RtlEnumerateGenericTable (&globals.tableUuids, FALSE);
    if (p == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            BUILDCFG_ERROR_NOT_ENOUGH_UUIDS
            );
    }
    memcpy (puuid, p, sizeof (UUID));
}

const BUILDCFG_TRANSPORT_INFO *
BuildCfgGetTransportInfo (
    IN  LPCWSTR                     pwszTransportRDN
    )
/*++

Routine Description:

    Gets the information associated with a particular transport.

Arguments:

    pwszTransportRDN    - The RDN of this inter-site transport.

Return Value:

    The transport info structure, or NULL if the supplied RDN is not valid.

--*/
{
    const BUILDCFG_TRANSPORT_INFO * pTransport;

    ULONG                           ul;

    pTransport = NULL;
    for (ul = 0; ul < ARRAY_SIZE (transportInfo); ul++) {
        if (_wcsicmp (pwszTransportRDN, transportInfo[ul].wszRDN) == 0) {
            pTransport = &transportInfo[ul];
            break;
        }
    }

    return pTransport;
}

BOOL
BuildCfgUseExplicitBridgeheads (
    IN  LPCWSTR                     pwszTransportRDN
    )
/*++

Routine Description:

    Flags a particular transport as using explicit bridgeheads.

Arguments:

    pwszTransportRDN    - The RDN of the transport that will use explicit
                          bridgeheads.

Return Value:

    TRUE if the transport was successfully flagged.
    FALSE if the supplied RDN is not valid.

--*/
{
    const BUILDCFG_TRANSPORT_INFO * pTransport;

    pTransport = BuildCfgGetTransportInfo (pwszTransportRDN);

    if (pTransport == NULL) {
        return FALSE;
    }

    if (!KCCSimGetAttribute (
            pTransport->pEntry,
            ATT_BRIDGEHEAD_SERVER_LIST_BL,
            NULL
            )) {
        KCCSimNewAttribute (
            pTransport->pEntry,
            ATT_BRIDGEHEAD_SERVER_LIST_BL,
            NULL
            );
    }

    return TRUE;
}

PSIM_ENTRY
BuildCfgSetupNewEntry (
    IN  const DSNAME *              pdnParent,
    IN  LPCWSTR                     pwszRDN OPTIONAL,
    IN  ATTRTYP                     objClass
    )
/*++

Routine Description:

    Establishes a new directory entry.

Arguments:

    pdnParent           - The dn of this entry's parent.
    pwszRDN             - The RDN of this entry.  If omitted, pdnParent
                          is interpreted as the DN of this entry.
    objClass            - The most specific object class of this entry.

Return Value:

    The newly created entry in the directory.

--*/
{
    PDSNAME                         pdn = NULL;
    PSIM_ENTRY                      pEntry;
    SIM_ATTREF                      attRef;

    WCHAR                           wszRDN[1+MAX_RDN_SIZE];
    DSTIME                          dsTime;
    ATTRTYP                         objClassAt;

    Assert (globals.pdnDmd != NULL);

    Assert (pdnParent != NULL);

    if (pwszRDN == NULL) {
        pEntry = KCCSimDsnameToEntry (pdnParent, KCCSIM_WRITE);
    } else {
        pdn = KCCSimAllocAppendRDN (
            pdnParent,
            pwszRDN,
            ATT_COMMON_NAME
            );
        pEntry = KCCSimDsnameToEntry (pdn, KCCSIM_WRITE);
        KCCSimFree (pdn);
        pdn = NULL;
    }

    // objectGUID:
    BuildCfgGetNextUuid (&pEntry->pdn->Guid);
    KCCSimNewAttribute (pEntry, ATT_OBJECT_GUID, &attRef);
    KCCSimAllocAddValueToAttribute (
        &attRef,
        sizeof (GUID),
        (PBYTE) &pEntry->pdn->Guid
        );

    // distinguishedName:
    KCCSimNewAttribute (pEntry, ATT_OBJ_DIST_NAME, &attRef);
    KCCSimAllocAddValueToAttribute (
        &attRef,
        pEntry->pdn->structLen,
        (PBYTE) pEntry->pdn
        );

    KCCSimQuickRDNOf (pEntry->pdn, wszRDN);

    // cn:
    KCCSimNewAttribute (pEntry, ATT_COMMON_NAME, &attRef);
    KCCSimAllocAddValueToAttribute (
        &attRef,
        KCCSIM_WCSMEMSIZE (wszRDN),
        (PBYTE) wszRDN
        );

    // name:
    KCCSimNewAttribute (pEntry, ATT_RDN, &attRef);
    KCCSimAllocAddValueToAttribute (
        &attRef,
        KCCSIM_WCSMEMSIZE (wszRDN),
        (PBYTE) wszRDN
        );

    dsTime = KCCSimGetRealTime ();

    // whenCreated:
    KCCSimNewAttribute (pEntry, ATT_WHEN_CREATED, &attRef);
    KCCSimAllocAddValueToAttribute (
        &attRef,
        sizeof (DSTIME),
        (PBYTE) &dsTime
        );

    // whenChanged:
    KCCSimNewAttribute (pEntry, ATT_WHEN_CHANGED, &attRef);
    KCCSimAllocAddValueToAttribute (
        &attRef,
        sizeof (DSTIME),
        (PBYTE) &dsTime
        );

    // objClass:
    KCCSimNewAttribute (pEntry, ATT_OBJECT_CLASS, &attRef);
    for (objClassAt = objClass;
         ;
         objClassAt = KCCSimAttrSuperClass (objClassAt)) {

        KCCSimAllocAddValueToAttribute (
            &attRef,
            sizeof (ATTRTYP),
            (PBYTE) &objClassAt
            );
        if (KCCSimAttrSuperClass (objClassAt) == objClassAt) {
            break;
        }

    }

    // objCategory:
    KCCSimNewAttribute (pEntry, ATT_OBJECT_CATEGORY, &attRef);
    pdn = KCCSimAllocAppendRDN (
        globals.pdnDmd,
        KCCSimAttrSchemaRDN (objClass),
        ATT_COMMON_NAME
        );
    KCCSimAddValueToAttribute (
        &attRef,
        pdn->structLen,
        (PBYTE) pdn
        );

    // instanceType: 
    if( objClass==CLASS_DOMAIN_DNS
        || objClass==CLASS_CONFIGURATION
        || objClass==CLASS_DMD ) {
        DWORD  instType;

        switch(objClass) {
            case CLASS_DOMAIN_DNS:
                instType=NC_MASTER;
                break;
            case CLASS_CONFIGURATION:
            case CLASS_DMD:
                instType=NC_MASTER_SUBREF;
                break;
        }

        // BUGBUG: Should also handle child domains, and
        // config in child domains here

        KCCSimNewAttribute (pEntry, ATT_INSTANCE_TYPE, &attRef);
        KCCSimAllocAddValueToAttribute (
            &attRef, sizeof(DWORD), (PBYTE) &instType );
    }

    return pEntry;
}

PSIM_ENTRY
BuildCfgGetCrossRef (
    IN  LPCWSTR                     pwszCrossRefRDN
    )
/*++

Routine Description:

    Gets a cross-ref from the directory.

Arguments:

    pwszCrossRefRDN     - The RDN of the cross-ref.

Return Value:

    The entry of the cross-ref in the directory, or NULL if it does not exist.

--*/
{
    PSIM_ENTRY                      pEntryCrossRef;
    WCHAR                           wszRDN[1+MAX_RDN_SIZE];

    Assert (globals.pEntryCrossRefContainer != NULL);
    Assert (pwszCrossRefRDN != NULL);

    for (pEntryCrossRef = KCCSimFindFirstChild (
            globals.pEntryCrossRefContainer, CLASS_CROSS_REF, NULL);
         pEntryCrossRef != NULL;
         pEntryCrossRef = KCCSimFindNextChild (
            pEntryCrossRef, CLASS_CROSS_REF, NULL)) {

        KCCSimQuickRDNOf (pEntryCrossRef->pdn, wszRDN);
        if (wcscmp (pwszCrossRefRDN, wszRDN) == 0) {
            break;
        }

    }

    return pEntryCrossRef;
}

PSIM_ENTRY
BuildCfgGetSite (
    IN  LPCWSTR                     pwszSiteRDN
    )
/*++

Routine Description:

    Locates a site by RDN.

Arguments:

    pwszSiteRDN         - The RDN of the site.

Return Value:

    The entry of the site in the directory, or NULL if it does not exist.

--*/
{
    PSIM_ENTRY                      pEntrySiteAt;
    WCHAR                           wszRDN[1+MAX_RDN_SIZE];
    
    Assert (globals.pEntrySitesContainer != NULL);
    Assert (pwszSiteRDN != NULL);

    for (pEntrySiteAt = KCCSimFindFirstChild (
            globals.pEntrySitesContainer, CLASS_SITE, NULL);
         pEntrySiteAt != NULL;
         pEntrySiteAt = KCCSimFindNextChild (
            pEntrySiteAt, CLASS_SITE, NULL)) {

        KCCSimQuickRDNOf (pEntrySiteAt->pdn, wszRDN);
        if (wcscmp (pwszSiteRDN, wszRDN) == 0) {
            break;
        }

    }

    return pEntrySiteAt;
}

PSIM_ENTRY
BuildCfgGetSiteLink (
    IN  PSIM_ENTRY                  pEntryTransportContainer,
    IN  LPCWSTR                     pwszSiteLinkRDN
    )
/*++

Routine Description:

    Locates a site-link by RDN.

Arguments:

    pEntryTransportContainer - container to search
    pwszSiteLinkRDN         - The RDN of the site.

Return Value:

    The entry of the site-link in the directory, or NULL if it does not exist.

--*/
{
    PSIM_ENTRY                      pEntrySiteAt;
    WCHAR                           wszRDN[1+MAX_RDN_SIZE];
    
    Assert (globals.pEntrySitesContainer != NULL);
    Assert (pwszSiteLinkRDN != NULL);

    for (pEntrySiteAt = KCCSimFindFirstChild (
        pEntryTransportContainer, CLASS_SITE_LINK, NULL);
         pEntrySiteAt != NULL;
         pEntrySiteAt = KCCSimFindNextChild (
             pEntrySiteAt, CLASS_SITE_LINK, NULL))
    {

        KCCSimQuickRDNOf (pEntrySiteAt->pdn, wszRDN);
        if (wcscmp (pwszSiteLinkRDN, wszRDN) == 0) {
            break;
        }

    }

    return pEntrySiteAt;
}

PSIM_ENTRY
BuildCfgGetServer (
    IN  PSIM_ENTRY                  pEntryServersContainer,
    IN  LPCWSTR                     pwszServerRDN
    )
/*++

Routine Description:

    Locates a server by RDN.

Arguments:

    pEntryServersContainer - The entry of the servers container to search.
    pwszServerRDN       - The RDN of the server.

Return Value:

    The entry of the server in the directory, or NULL if it does not exist
    in this servers container.

--*/
{
    PSIM_ENTRY                      pEntryServerAt;
    WCHAR                           wszRDN[1+MAX_RDN_SIZE];

    for (pEntryServerAt = KCCSimFindFirstChild (
            pEntryServersContainer, CLASS_SERVER, NULL);
         pEntryServerAt != NULL;
         pEntryServerAt = KCCSimFindNextChild (
            pEntryServerAt, CLASS_SERVER, NULL)) {

        KCCSimQuickRDNOf (pEntryServerAt->pdn, wszRDN);
        if (wcscmp (pwszServerRDN, wszRDN) == 0) {
            break;
        }

    }

    return pEntryServerAt;
}

PSIM_ENTRY
BuildCfgGetNTDSSettings (
    IN  PSIM_ENTRY                  pEntryServersContainer,
    IN  LPCWSTR                     pwszServerRDN
    )
/*++

Routine Description:

    Locates a NTDS-Settings object by server RDN.

Arguments:

    pEntryServersContainer - The entry of the servers container to search.
    pwszServerRDN       - The RDN of the server.

Return Value:

    The entry of the NTDS Settings of the server in the directory,
    or NULL if it does not exist in this servers container.

--*/
{
    PSIM_ENTRY                      pEntryServerAt;
    PSIM_ENTRY                      pEntryNTDSSettings;
    WCHAR                           wszRDN[1+MAX_RDN_SIZE];
    PDSNAME                         pdn = NULL;
    BOOL                            fFound = FALSE;

    for (pEntryServerAt = KCCSimFindFirstChild (
            pEntryServersContainer, CLASS_SERVER, NULL);
         pEntryServerAt != NULL;
         pEntryServerAt = KCCSimFindNextChild (
            pEntryServerAt, CLASS_SERVER, NULL)) {

        KCCSimQuickRDNOf (pEntryServerAt->pdn, wszRDN);
        if (wcscmp (pwszServerRDN, wszRDN) == 0) {
            fFound = TRUE;
            break;
        }
    }

    if (!fFound) {
        // Server RDN not found!
        return NULL;
    }

    pdn = KCCSimAllocAppendRDN (
        pEntryServerAt->pdn,
        BUILDCFG_RDN_NTDS_SETTINGS,
        ATT_COMMON_NAME
        );
    pEntryNTDSSettings = KCCSimDsnameToEntry (pdn, KCCSIM_NO_OPTIONS);
    Assert( pEntryNTDSSettings );

    KCCSimFree (pdn);

    return pEntryNTDSSettings;
}

PSIM_ENTRY
BuildCfgMakeCrossRef (
    IN  PSIM_ENTRY                  pEntryNc,
    IN  LPCWSTR                     pwszRDN OPTIONAL,
    IN  BOOL                        bIsDomain
    )
/*++

Routine Description:

    Creates a cross-ref entry.

Arguments:

    pEntryNc            - The entry in the directory corresponding to NC
                          to which this cross-ref refers.
    pwszRDN             - The RDN of this cross-ref object.  Defaults to the
                          RDN of pEntryNc.
    bIsDomain           - TRUE if this cross-ref represents a domain; FALSE
                          if it represents a non-domain NC (e.g. the schema.)

Return Value:

    The newly created cross-ref.

--*/
{
    PSIM_ENTRY                      pEntryCrossRef;
    SIM_ATTREF                      attRef;
    WCHAR                           wszNcRDN[1+MAX_RDN_SIZE];
    ULONG                           ul;
    LPWSTR                          pwzDnsRoot;
    PDS_NAME_RESULTW                pResult = NULL;

    Assert (globals.pEntryCrossRefContainer != NULL);
    Assert (pEntryNc != NULL);

    __try {
        KCCSimQuickRDNOf (pEntryNc->pdn, wszNcRDN);
        if (pwszRDN == NULL) {
            pwszRDN = wszNcRDN;
        }

        pEntryCrossRef = BuildCfgGetCrossRef (pwszRDN);
        if (pEntryCrossRef != NULL) {
            // Already exists, return it
            __leave;
        }

        pEntryCrossRef = BuildCfgSetupNewEntry (
            globals.pEntryCrossRefContainer->pdn,
            pwszRDN,
            CLASS_CROSS_REF
            );

        // netBIOSName:
        if (bIsDomain) {
            KCCSimNewAttribute (pEntryCrossRef, ATT_NETBIOS_NAME, &attRef);
            KCCSimAllocAddValueToAttribute (
                &attRef,
                KCCSIM_WCSMEMSIZE (wszNcRDN),
                (PBYTE) wszNcRDN
                );
        }

        // dNSRoot:
        // For domain nc's, construct the dns root syntactically based on the dn
        KCCSimNewAttribute (pEntryCrossRef, ATT_DNS_ROOT, &attRef);
        if (bIsDomain) {
            DWORD status;
            LPWSTR pwzDn = pEntryNc->pdn->StringName;
            status = DsCrackNamesW( NULL,
                                    DS_NAME_FLAG_SYNTACTICAL_ONLY,
                                    DS_FQDN_1779_NAME,
                                    DS_CANONICAL_NAME_EX,
                                    1,
                                    &pwzDn,
                                    &pResult);
            if ( (status != ERROR_SUCCESS) ||
                 (pResult == NULL) ||
                 (pResult->cItems == 0) ||
                 (pResult->rItems[0].pDomain == NULL) ) {
                KCCSimException (
                    KCCSIM_ETYPE_INTERNAL,
                    BUILDCFG_ERROR_INVALID_DOMAIN_DN,
                    pEntryNc->pdn->StringName
                    );
            }
            pwzDnsRoot = pResult->rItems[0].pDomain;
        } else {
            pwzDnsRoot = globals.pwszRootDomainDNSName;
        }
        KCCSimAllocAddValueToAttribute (
            &attRef,
            KCCSIM_WCSMEMSIZE(pwzDnsRoot),
            (PBYTE) pwzDnsRoot
            );

        // systemFlags:
        KCCSimNewAttribute (pEntryCrossRef, ATT_SYSTEM_FLAGS, &attRef);
        ul = FLAG_CR_NTDS_NC;
        if (bIsDomain) {
            ul |= FLAG_CR_NTDS_DOMAIN;
        }
        KCCSimAllocAddValueToAttribute (
            &attRef,
            sizeof (ULONG),
            (PBYTE) &ul
            );

        // nCName:
        KCCSimNewAttribute (pEntryCrossRef, ATT_NC_NAME, &attRef);
        KCCSimAllocAddValueToAttribute (
            &attRef,
            pEntryNc->pdn->structLen,
            (PBYTE) pEntryNc->pdn
            );

    } __finally {
        if (pResult != NULL) {
            DsFreeNameResultW(pResult);
        }
    }

    return pEntryCrossRef;
}

PSIM_ENTRY
BuildCfgMakeDomain (
    IN  LPCWSTR                     pwszDomain
    )
/*++

Routine Description:

    Creates a domain.

Arguments:

    pwszDomain          - The DN of the domain.

Return Value:

    The newly created entry.

--*/
{
    PDSNAME                         pdnDomain = NULL;
    PDSNAME                         pdnParent = NULL;
    WCHAR                           wszRDN[1+MAX_RDN_SIZE];
    PSIM_ENTRY                      pEntryDomain = NULL;

    __try {

        pdnDomain = KCCSimAllocDsname (pwszDomain);
        pdnParent = KCCSimAlloc (pdnDomain->structLen);

        if (TrimDSNameBy (pdnDomain, 1, pdnParent) != 0) {
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                BUILDCFG_ERROR_INVALID_DOMAIN_DN,
                pdnDomain->StringName
                );
        }

        if (KCCSimDsnameToEntry (pdnParent, KCCSIM_NO_OPTIONS) == NULL) {
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                BUILDCFG_ERROR_INVALID_DOMAIN_DN,
                pdnDomain->StringName
                );
        }

        pEntryDomain = BuildCfgSetupNewEntry (
            pdnDomain,
            NULL,
            CLASS_DOMAIN_DNS
            );

    } __finally {

        KCCSimFree (pdnDomain);
        KCCSimFree (pdnParent);

    }

    return pEntryDomain;
}

PSIM_ENTRY
BuildCfgMakeSite (
    IN  LPCWSTR                     pwszSiteRDN,
    IN  ULONG                       ulSiteOptions
    )
/*++

Routine Description:

    Creates a site.

Arguments:

    pwszSiteRDN         - The RDN of the site.
    ulSiteOptions       - Site options.

Return Value:

    The newly created site entry.

--*/
{
    PSIM_ENTRY                      pEntrySite, pEntryNTDSSiteSettings,
                                    pEntryServersContainer;
    SIM_ATTREF                      attRef;

    ULONG                           ulSiteAt, ulServerAt;

    pEntrySite = BuildCfgSetupNewEntry (
        globals.pEntrySitesContainer->pdn,
        pwszSiteRDN,
        CLASS_SITE
        );

    pEntryNTDSSiteSettings = BuildCfgSetupNewEntry (
        pEntrySite->pdn,
        BUILDCFG_RDN_NTDS_SITE_SETTINGS,
        CLASS_NTDS_SITE_SETTINGS
        );

    // options:
    KCCSimNewAttribute (pEntryNTDSSiteSettings, ATT_OPTIONS, &attRef);
    KCCSimAllocAddValueToAttribute (
        &attRef,
        sizeof (ULONG),
        (PBYTE) &ulSiteOptions
        );

    pEntryServersContainer = BuildCfgSetupNewEntry (
        pEntrySite->pdn,
        BUILDCFG_RDN_SERVERS_CONTAINER,
        CLASS_SERVERS_CONTAINER
        );

    return pEntrySite;
}

PSIM_ENTRY
BuildCfgMakeSiteLink (
    IN  LPCWSTR                     pwszTransport,
    IN  LPCWSTR                     pwszSiteLinkRDN,
    IN  ULONG                       ulCost,
    IN  ULONG                       ulReplInterval,
    IN  ULONG                       ulOptions,
    IN  PSCHEDULE                   pSchedule
    )
/*++

Routine Description:

    Creates a site-link.

Arguments:

    pwszTransport       - Transport type of this site-link.
    pwszSiteLinkRDN     - RDN of this site-link.
    ulCost              - cost attribute.
    ulReplInterval      - replInterval attribute.
    ulOptions           - options attribute.

Return Value:

    The newly created site-link entry.

--*/
{
    const BUILDCFG_TRANSPORT_INFO * pTransport;
    PSIM_ENTRY                      pEntrySiteLink;
    SIM_ATTREF                      attRef;

    // Validate this transport type.
    pTransport = BuildCfgGetTransportInfo (pwszTransport);
    if (pTransport == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            BUILDCFG_ERROR_UNKNOWN_TRANSPORT,
            pwszSiteLinkRDN,
            pwszTransport
            );
    }

    pEntrySiteLink = BuildCfgSetupNewEntry (
        pTransport->pEntry->pdn,
        pwszSiteLinkRDN,
        CLASS_SITE_LINK
        );

    // cost:
    KCCSimNewAttribute (pEntrySiteLink, ATT_COST, &attRef);
    KCCSimAllocAddValueToAttribute (
        &attRef,
        sizeof (ULONG),
        (PBYTE) &ulCost
        );

    // replInterval:
    KCCSimNewAttribute (pEntrySiteLink, ATT_REPL_INTERVAL, &attRef);
    KCCSimAllocAddValueToAttribute (
        &attRef,
        sizeof (ULONG),
        (PBYTE) &ulReplInterval
        );

    // options:
    KCCSimNewAttribute (pEntrySiteLink, ATT_OPTIONS, &attRef);
    KCCSimAllocAddValueToAttribute (
        &attRef,
        sizeof (ULONG),
        (PBYTE) &ulOptions
        );
    // schedule:
    if( pSchedule ) {
        KCCSimNewAttribute (pEntrySiteLink, ATT_SCHEDULE, &attRef);
        KCCSimAllocAddValueToAttribute (
            &attRef,
            sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES,
            (PBYTE) pSchedule
            );
    }

    return pEntrySiteLink;
}    

VOID
BuildCfgAddSiteToSiteLink (
    IN  LPCWSTR                     pwszSiteLinkRDN,
    IN  PSIM_ENTRY                  pEntrySiteLink,
    IN  LPCWSTR                     pwszSiteRDN
    )
/*++

Routine Description:

    Places a site in a site-link.

Arguments:

    pwszSiteLinkRDN     - The RDN of the site-link.  Used for error reporting.
    pEntrySiteLink      - The site-link entry.
    pwszSiteRDN         - The RDN of the site to add.

Return Value:

    

--*/
{
    PSIM_ENTRY                      pEntrySite;
    SIM_ATTREF                      attRef;

    pEntrySite = BuildCfgGetSite (pwszSiteRDN);

    if (pEntrySite == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            BUILDCFG_ERROR_INVALID_SITE,
            pwszSiteLinkRDN,
            pwszSiteRDN
            );
    }

    if (!KCCSimGetAttribute (pEntrySiteLink, ATT_SITE_LIST, &attRef)) {
        KCCSimNewAttribute (pEntrySiteLink, ATT_SITE_LIST, &attRef);
    }
    KCCSimAllocAddValueToAttribute (
        &attRef,
        pEntrySite->pdn->structLen,
        (PBYTE) pEntrySite->pdn
        );
}

PSIM_ENTRY
BuildCfgMakeBridge (
    IN  LPCWSTR                     pwszTransport,
    IN  LPCWSTR                     pwszBridgeRDN,
    OUT PSIM_ENTRY *                ppEntryTransport
    )
/*++

Routine Description:

    Creates a site-link.

Arguments:

    pwszTransport       - Transport type of this site-link.
    pwszBridgeRDN       - RDN of this bridge.
    ppEntryTransport    - Entry corresponding to the named transport

Return Value:

    The newly created bridge entry.

--*/
{
    const BUILDCFG_TRANSPORT_INFO * pTransport;
    PSIM_ENTRY                      pEntryBridge;
    SIM_ATTREF                      attRef;

    // Validate this transport type.
    pTransport = BuildCfgGetTransportInfo (pwszTransport);
    if (pTransport == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            BUILDCFG_ERROR_UNKNOWN_TRANSPORT,
            pwszBridgeRDN,
            pwszTransport
            );
    }

    pEntryBridge = BuildCfgSetupNewEntry (
        pTransport->pEntry->pdn,
        pwszBridgeRDN,
        CLASS_SITE_LINK_BRIDGE
        );

    // Return transport entry
    *ppEntryTransport = pTransport->pEntry;

    return pEntryBridge;
}    

VOID
BuildCfgAddSiteLinkToBridge (
    IN  LPCWSTR                     pwszBridgeRDN,
    IN  PSIM_ENTRY                  pEntryTransportContainer,
    IN  PSIM_ENTRY                  pEntryBridge,
    IN  LPCWSTR                     pwszSiteLinkRDN
    )
/*++

Routine Description:

    Places a site-link in a bridge.

Arguments:

    pwszBridgeRDN     - The RDN of the bridge.  Used for error reporting.
    pEntryTransportContainer - container to search for site links
    pEntryBridge      - The bridge entry.
    pwszSiteLinkRDN   - The RDN of the site-link to add.

Return Value:

    

--*/
{
    PSIM_ENTRY                      pEntrySiteLink;
    SIM_ATTREF                      attRef;

    pEntrySiteLink = BuildCfgGetSiteLink (pEntryTransportContainer,
                                          pwszSiteLinkRDN);

    if (pEntrySiteLink == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            BUILDCFG_ERROR_INVALID_SITE,
            pwszBridgeRDN,
            pwszSiteLinkRDN
            );
    }

    if (!KCCSimGetAttribute (pEntryBridge, ATT_SITE_LINK_LIST, &attRef)) {
        KCCSimNewAttribute (pEntryBridge, ATT_SITE_LINK_LIST, &attRef);
    }
    KCCSimAllocAddValueToAttribute (
        &attRef,
        pEntrySiteLink->pdn->structLen,
        (PBYTE) pEntrySiteLink->pdn
        );
}

BOOL
BuildCfgISTG (
    IN  PSIM_ENTRY                  pEntryNTDSSiteSettings,
    IN  PSIM_ENTRY                  pEntryServersContainer,
    IN  LPCWSTR                     pwszServerRDN
    )
/*++

Routine Description:

    Sets the inter-site topology generator for a site.

Arguments:

    pEntryNTDSSiteSettings - The entry of the NTDS Site Settings object.
    pEntryServersContainer - The entry of the servers container for this site.
    pwszServerRDN       - The RDN of the server that is to be the ISTG.

Return Value:

    TRUE if the ISTG was properly set.
    FALSE if the server does not exist in this site.

--*/
{
    PSIM_ENTRY                      pEntryNTDSSettings;

    SIM_ATTREF                      attRef;

    PROPERTY_META_DATA_VECTOR *     pMetaDataVector;
    PROPERTY_META_DATA *            pMetaData;

    Assert (pEntryNTDSSiteSettings != NULL);
    Assert (pEntryServersContainer != NULL);

    pEntryNTDSSettings = BuildCfgGetNTDSSettings (pEntryServersContainer, pwszServerRDN);
    if (pEntryNTDSSettings == NULL) {
        return FALSE;
    }

    KCCSimGetAttribute (
        pEntryNTDSSiteSettings,
        ATT_INTER_SITE_TOPOLOGY_GENERATOR,
        &attRef
        );

    if (attRef.pAttr == NULL) {

        // interSiteTopologyGenerator
        KCCSimNewAttribute (
            pEntryNTDSSiteSettings,
            ATT_INTER_SITE_TOPOLOGY_GENERATOR,
            &attRef
            );
        KCCSimAllocAddValueToAttribute (
            &attRef,
            pEntryNTDSSettings->pdn->structLen,
            (PBYTE) pEntryNTDSSettings->pdn
            );

        // replPropertyMetaData for ATT_INTER_SITE_TOPOLOGY_GENERATOR
        KCCSimNewAttribute (
            pEntryNTDSSiteSettings,
            ATT_REPL_PROPERTY_META_DATA,
            &attRef
            );
        pMetaDataVector = KCCSimAlloc (MetaDataVecV1SizeFromLen (1));
        pMetaDataVector->dwVersion = VERSION_V1;
        pMetaDataVector->V1.cNumProps = 1;
        pMetaData = &pMetaDataVector->V1.rgMetaData[0];
        pMetaData->attrType = ATT_INTER_SITE_TOPOLOGY_GENERATOR;
        pMetaData->dwVersion = 1;
        pMetaData->timeChanged = KCCSimGetRealTime ();
        memcpy (
            &pMetaData->uuidDsaOriginating,
            &pEntryNTDSSettings->pdn->Guid,
            sizeof (UUID)
            );
        pMetaData->usnOriginating = 1;
        pMetaData->usnProperty = 1;
        KCCSimAddValueToAttribute (
            &attRef,
            MetaDataVecV1SizeFromLen (1),
            (PBYTE) pMetaDataVector
            );

    }

    return TRUE;
}

VOID
BuildCfgAddAsBridgehead (
    IN  LPCWSTR                     pwszServerType,
    IN  PSIM_ENTRY                  pEntryServer,
    IN  LPCWSTR                     pwszTransportRDN
    )
/*++

Routine Description:

    Establishes a server as a bridgehead for a given transport.

Arguments:

    pwszServerType      - The server type of this server.  Used for
                          error reporting.
    pEntryServer        - The entry of this server.
    pwszTransportRDN    - The transport for which this server is a bridgehead.

Return Value:

    None.

--*/
{
    const BUILDCFG_TRANSPORT_INFO * pTransport;
    SIM_ATTREF                      attRef;

    Assert (pwszTransportRDN != NULL);

    pTransport = BuildCfgGetTransportInfo (pwszTransportRDN);
    if (pTransport == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            BUILDCFG_ERROR_UNKNOWN_TRANSPORT,
            pwszServerType,
            pwszTransportRDN
            );
    }

    if (!KCCSimGetAttribute (
            pTransport->pEntry,
            ATT_BRIDGEHEAD_SERVER_LIST_BL,
            &attRef
            )) {
        KCCSimPrintMessage (
            BUILDCFG_WARNING_NO_EXPLICIT_BRIDGEHEADS,
            pwszServerType,
            pwszTransportRDN
            );
        return;
    }

    Assert (attRef.pAttr != NULL);

    KCCSimAllocAddValueToAttribute (
        &attRef,
        pEntryServer->pdn->structLen,
        (PBYTE) pEntryServer->pdn
        );
}


PSIM_ENTRY
BuildCfgMakeServer (
    IO  PULONG                      pulServerNum,
    IN  LPCWSTR                     pwszServerRDNMask,
    IN  LPCWSTR                     pwszSiteRDN,
    IN  LPCWSTR                     pwszDomain,
    IN  PSIM_ENTRY                  pEntryServersContainer,
    IN  ULONG                       ulServerOptions
    )
/*++

Routine Description:

    Creates a server.

Arguments:

    pulServerNum        - Pointer to the server number.  If this is nonzero on
                          input, it represents the current server number and is
                          not changed on output.  If it is zero on input, then
                          the current server number is set to the first
                          available server number for this site and server
                          type, and *pulServerNum is changed to the current
                          server number on output.
    pwszServerRDNMask   - The RDN mask of this server.
    pwszSiteRDN         - The RDN of this site.
    pwszDomain          - The DN of the domain to which the server belongs.
    pEntryServersContainer - The servers container of the site to which this
                          server should be added.
    ulServerOptions     - options attribute.

Return Value:

    The newly created server entry.

--*/
{
    PSIM_ENTRY                      pEntryCrossRef;
    PSIM_ENTRY                      pEntryServer, pEntryNTDSSettings;
    SIM_ATTREF                      attRef;
    PDSNAME                         pdnNc, pdnOtherNc;

    WCHAR                           wszServerRDN[1+MAX_RDN_SIZE];
    LPWSTR                          pwsz, pwszStringizedGuid;
    ULONG                           ulBytes, ulDsaVersion;

    Assert (globals.pwszRootDomainDNSName != NULL);
    Assert (globals.pEntryCrossRefContainer != NULL);
    Assert (pwszSiteRDN != NULL);
    Assert (pEntryServersContainer != NULL);

    // Get this domain
    pdnNc = KCCSimAllocDsname (pwszDomain);
    if (KCCSimDsnameToEntry (pdnNc, KCCSIM_NO_OPTIONS) == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            BUILDCFG_ERROR_INVALID_DOMAIN,
            pwszSiteRDN,
            pwszDomain
            );
    }

    if (*pulServerNum == 0) {
        // Find the first available server ID
        do {
            (*pulServerNum)++;
            swprintf (
                wszServerRDN,
                L"%s-%s%d",
                pwszSiteRDN,
                pwszServerRDNMask,
                *pulServerNum
                );
            pEntryServer = BuildCfgGetServer (pEntryServersContainer, wszServerRDN);
        } while (pEntryServer != NULL);
    } else {
        swprintf (
            wszServerRDN,
            L"%s-%s%d",
            pwszSiteRDN,
            pwszServerRDNMask,
            *pulServerNum
            );
    }

    pEntryServer = BuildCfgSetupNewEntry (
        pEntryServersContainer->pdn,
        wszServerRDN,
        CLASS_SERVER
        );

    // dNSHostName:
    ulBytes = sizeof (WCHAR) * (
        wcslen (wszServerRDN) +
        1 +     // For the '.'
        wcslen (globals.pwszRootDomainDNSName) +
        1       // For the '\0'
        );
    pwsz = KCCSimAlloc (ulBytes);
    swprintf (
        pwsz,
        L"%s.%s",
        wszServerRDN,
        globals.pwszRootDomainDNSName
        );
    KCCSimNewAttribute (pEntryServer, ATT_DNS_HOST_NAME, &attRef);
    KCCSimAddValueToAttribute (&attRef, ulBytes, (PBYTE) pwsz);

    pEntryNTDSSettings = BuildCfgSetupNewEntry (
        pEntryServer->pdn,
        BUILDCFG_RDN_NTDS_SETTINGS,
        CLASS_NTDS_DSA
        );

    // mailAddress:
    UuidToStringW (&pEntryNTDSSettings->pdn->Guid, &pwszStringizedGuid);
    Assert (36 == wcslen (pwszStringizedGuid));
    ulBytes = sizeof (WCHAR) * (
        wcslen (BUILDCFG_NAME_MAIL_ADDRESS) +
        1 +     // For the '@'
        36 +    // For the stringized GUID
        1 +     // For the '.'
        wcslen (globals.pwszRootDomainDNSName) +
        1       // For the '\0'
        );
    pwsz = KCCSimAlloc (ulBytes);
    swprintf (
        pwsz,
        L"%s@%s.%s",
        BUILDCFG_NAME_MAIL_ADDRESS,
        pwszStringizedGuid,
        globals.pwszRootDomainDNSName
        );
    RpcStringFreeW (&pwszStringizedGuid);
    KCCSimNewAttribute (pEntryServer, ATT_SMTP_MAIL_ADDRESS, &attRef);
    KCCSimAddValueToAttribute (&attRef, ulBytes - sizeof (WCHAR), (PBYTE) pwsz);

    // hasMasterNCs:
    KCCSimNewAttribute (pEntryNTDSSettings, ATT_HAS_MASTER_NCS, &attRef);
    KCCSimAllocAddValueToAttribute (
        &attRef,
        globals.pdnConfig->structLen,
        (PBYTE) globals.pdnConfig
        );
    KCCSimAllocAddValueToAttribute (
        &attRef,
        globals.pdnDmd->structLen,
        (PBYTE) globals.pdnDmd
        );
    KCCSimAllocAddValueToAttribute (
        &attRef,
        pdnNc->structLen,
        (PBYTE) pdnNc
        );

    // hasPartialReplicaNCs:
    if (ulServerOptions & NTDSDSA_OPT_IS_GC) {
        for (pEntryCrossRef = KCCSimFindFirstChild (
                globals.pEntryCrossRefContainer, CLASS_CROSS_REF, NULL);
             pEntryCrossRef != NULL;
             pEntryCrossRef = KCCSimFindNextChild (
                pEntryCrossRef, CLASS_CROSS_REF, NULL)) {

            KCCSimGetAttribute (pEntryCrossRef, ATT_NC_NAME, &attRef);
            pdnOtherNc = (PDSNAME) attRef.pAttr->pValFirst->pVal;

            if (!NameMatched (pdnOtherNc, globals.pdnConfig) &&
                !NameMatched (pdnOtherNc, globals.pdnDmd) &&
                !NameMatched (pdnOtherNc, pdnNc)) {
                if (!KCCSimGetAttribute (pEntryNTDSSettings,
                        ATT_HAS_PARTIAL_REPLICA_NCS, &attRef)) {
                    KCCSimNewAttribute (pEntryNTDSSettings,
                        ATT_HAS_PARTIAL_REPLICA_NCS, &attRef);
                }
                KCCSimAllocAddValueToAttribute (
                    &attRef,
                    pdnOtherNc->structLen,
                    (PBYTE) pdnOtherNc
                    );
            }

        }
    }

    // dMDLocation:
    KCCSimNewAttribute (pEntryNTDSSettings, ATT_DMD_LOCATION, &attRef);
    KCCSimAllocAddValueToAttribute (
        &attRef,
        globals.pdnDmd->structLen,
        (PBYTE) globals.pdnDmd
        );

    // invocationID: Same as GUID for NTDS Settings object
    KCCSimNewAttribute (pEntryNTDSSettings, ATT_INVOCATION_ID, &attRef);
    KCCSimAllocAddValueToAttribute (
        &attRef,
        sizeof (GUID),
        (PBYTE) &pEntryNTDSSettings->pdn->Guid
        );

    // options
    KCCSimNewAttribute (pEntryNTDSSettings, ATT_OPTIONS, &attRef);
    KCCSimAllocAddValueToAttribute (
        &attRef,
        sizeof (ULONG),
        (PBYTE) &ulServerOptions
        );

    // msDS-Behavior-Version
    ulDsaVersion = DS_BEHAVIOR_WIN_DOT_NET_WITH_MIXED_DOMAINS;
    KCCSimNewAttribute( pEntryNTDSSettings, ATT_MS_DS_BEHAVIOR_VERSION, &attRef );
    KCCSimAllocAddValueToAttribute( &attRef, sizeof (ULONG), (PBYTE) &ulDsaVersion );

    return pEntryServer;
}

VOID
BuildCfgUpdateTransport (
    IN  LPCWSTR                     pwszTransportRDN,
    IN  ULONG                       ulTransportOptions
    )
/*++

Routine Description:

    Update transport properties

Arguments:

    pwszTransportRDN - Transport being modified
    ulTransportOptions - New value of options

Return Value:

    None.

--*/
{
    const BUILDCFG_TRANSPORT_INFO * pTransport;
    SIM_ATTREF                      attRef;

    Assert (pwszTransportRDN != NULL);

    pTransport = BuildCfgGetTransportInfo (pwszTransportRDN);
    if (pTransport == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            BUILDCFG_ERROR_UNKNOWN_TRANSPORT,
            pwszTransportRDN,
            pwszTransportRDN
            );
    }

    Assert( pTransport->pEntry );

    // options:
    KCCSimNewAttribute (pTransport->pEntry, ATT_OPTIONS, &attRef);
    KCCSimAllocAddValueToAttribute (
        &attRef,
        sizeof (ULONG),
        (PBYTE) &ulTransportOptions
        );

} /* BuildCfgUpdateTransport  */


PSIM_ENTRY
BuildCfgMakeConfig (
    IN  LPCWSTR                     pwszRootDn,
    IN  DWORD                       ulForestVersion
    )
/*++

Routine Description:

    Sets up the initial config & associated containers.

Arguments:

    pwszRootDn          - The root DN of the enterprise.
    ulForestVersion     - Version number to write for the forest

Return Value:

    The entry of the configuration container.

--*/
{
    PSIM_ENTRY                      pEntryRoot, pEntryConfig, pEntryIntersiteTransports,
                                    pEntryTransport, pEntryDmd, pEntryContainer;
    SIM_ATTREF                      attRef;

    ULONG                           ulTransportAt;

    globals.pdnRootDomain = KCCSimAllocDsname (pwszRootDn);
    globals.pdnConfig = KCCSimAllocAppendRDN (
        globals.pdnRootDomain,
        BUILDCFG_RDN_CONFIG,
        ATT_COMMON_NAME
        );
    globals.pdnDmd = KCCSimAllocAppendRDN (
        globals.pdnConfig,
        BUILDCFG_RDN_DMD,
        ATT_COMMON_NAME
        );
    globals.pwszRootDomainDNSName
        = KCCSimAllocDsnameToDNSName (globals.pdnRootDomain);

    // Create the root domain container

    pEntryRoot = BuildCfgSetupNewEntry (
        globals.pdnRootDomain,
        NULL,
        CLASS_DOMAIN_DNS
        );

    pEntryConfig = BuildCfgSetupNewEntry (
        pEntryRoot->pdn,
        BUILDCFG_RDN_CONFIG,
        CLASS_CONFIGURATION
        );

    // Create the sites container & sub-containers

    globals.pEntrySitesContainer = BuildCfgSetupNewEntry (
        pEntryConfig->pdn,
        BUILDCFG_RDN_SITES_CONTAINER,
        CLASS_SITES_CONTAINER
        );

    pEntryIntersiteTransports = BuildCfgSetupNewEntry (
        globals.pEntrySitesContainer->pdn,
        BUILDCFG_RDN_INTERSITE_TRANSPORTS,
        CLASS_INTER_SITE_TRANSPORT_CONTAINER
        );

    for (ulTransportAt = 0;
         ulTransportAt < ARRAY_SIZE (transportInfo);
         ulTransportAt++) {

        pEntryTransport = BuildCfgSetupNewEntry (
            pEntryIntersiteTransports->pdn,
            transportInfo[ulTransportAt].wszRDN,
            CLASS_INTER_SITE_TRANSPORT
            );
        transportInfo[ulTransportAt].pEntry = pEntryTransport;

        KCCSimNewAttribute (pEntryTransport, ATT_TRANSPORT_ADDRESS_ATTRIBUTE, &attRef);
        KCCSimAllocAddValueToAttribute (
            &attRef,
            sizeof (ATTRTYP),
            (PBYTE) &transportInfo[ulTransportAt].transportAddressAttribute
            );

        KCCSimNewAttribute (pEntryTransport, ATT_TRANSPORT_DLL_NAME, &attRef);
        KCCSimAllocAddValueToAttribute (
            &attRef,
            KCCSIM_WCSMEMSIZE (transportInfo[ulTransportAt].transportDLLName),
            (PBYTE) transportInfo[ulTransportAt].transportDLLName
            );

    }

    // Create the DMD container

    pEntryDmd = BuildCfgSetupNewEntry (
        pEntryConfig->pdn,
        BUILDCFG_RDN_DMD,
        CLASS_DMD
        );

    // Create the cross-ref container
    globals.pEntryCrossRefContainer = BuildCfgSetupNewEntry (
        pEntryConfig->pdn,
        BUILDCFG_RDN_CROSS_REF_CONTAINER,
        CLASS_CROSS_REF_CONTAINER
        );

    // Create msDsBehaviorVersion attribute
    KCCSimNewAttribute (globals.pEntryCrossRefContainer,
                        ATT_MS_DS_BEHAVIOR_VERSION, &attRef);
    KCCSimAllocAddValueToAttribute (
        &attRef, sizeof(DWORD), (PBYTE) &ulForestVersion );

    // Create the root domain cross-ref
    BuildCfgMakeCrossRef (
        pEntryRoot,
        NULL,
        TRUE
        );

    // Create the enterprise config cross-ref
    BuildCfgMakeCrossRef (
        pEntryConfig,
        BUILDCFG_RDN_CROSS_REF_CONFIG,
        FALSE
        );

    // Create the enterprise schema cross-ref
    BuildCfgMakeCrossRef (
        pEntryDmd,
        BUILDCFG_RDN_CROSS_REF_DMD,
        FALSE
        );

    // Create the services container & sub-containers

    pEntryContainer = BuildCfgSetupNewEntry (
        pEntryConfig->pdn,
        BUILDCFG_RDN_SERVICES,
        CLASS_CONTAINER
        );
    pEntryContainer = BuildCfgSetupNewEntry (
        pEntryContainer->pdn,
        BUILDCFG_RDN_WINDOWS_NT,
        CLASS_CONTAINER
        );
    BuildCfgSetupNewEntry (
        pEntryContainer->pdn,
        BUILDCFG_RDN_DIRECTORY_SERVICE,
        CLASS_NTDS_SERVICE
        );

    return pEntryConfig;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\sim\dir.h ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    dir.h

ABSTRACT:

    Header to be included by all files that access
    the simulated directory.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#ifndef _KCCSIM_DIR_H_
#define _KCCSIM_DIR_H_

typedef struct _SIM_VALUE {
    ULONG                           ulLen;
    PBYTE                           pVal;
    struct _SIM_VALUE *             next;
} SIM_VALUE, * PSIM_VALUE;

typedef struct _SIM_ATTRIBUTE {
    ATTRTYP                         attrType;
    PSIM_VALUE                      pValFirst;
    struct _SIM_ATTRIBUTE *         next;
} SIM_ATTRIBUTE, * PSIM_ATTRIBUTE;

typedef struct _SIM_ENTRY {
    PDSNAME                         pdn;
    PSIM_ATTRIBUTE                  pAttrFirst;
    struct _SIM_ENTRY *             children, *lastChild;
    struct _SIM_ENTRY *             next;
} SIM_ENTRY, * PSIM_ENTRY;

typedef enum {
    KCCSIM_ANCHOR_DMD_DN,
    KCCSIM_ANCHOR_DSA_DN,
    KCCSIM_ANCHOR_DOMAIN_DN,
    KCCSIM_ANCHOR_CONFIG_DN,
    KCCSIM_ANCHOR_ROOT_DOMAIN_DN,
    KCCSIM_ANCHOR_LDAP_DMD_DN,
    KCCSIM_ANCHOR_PARTITIONS_DN,
    KCCSIM_ANCHOR_DS_SVC_CONFIG_DN,
    KCCSIM_ANCHOR_SITE_DN,
    KCCSIM_ANCHOR_DOMAIN_NAME,
    KCCSIM_ANCHOR_DOMAIN_DNS_NAME,
    KCCSIM_ANCHOR_ROOT_DOMAIN_DNS_NAME
} KCCSIM_ANCHOR_ID;

// SIM_ATTREF is how the user references an attribute

typedef struct {
    PSIM_ENTRY                  pEntry;
    PSIM_ATTRIBUTE              pAttr;
} SIM_ATTREF, * PSIM_ATTREF;

// Function prototypes

// From eval.c:

BOOL
KCCSimCompare (
    IN  ULONG                       ulSyntax,
    IN  UCHAR                       ucChoice,
    IN  ULONG                       ulLen1,
    IN  const BYTE *                pVal1,
    IN  ULONG                       ulLen2,
    IN  const BYTE *                pVal2
    );

// From dir.c:

VOID
KCCSimFreeValue (
    IO  PSIM_VALUE *                ppVal
    );

BOOL
KCCSimAttRefIsValid (
    IN  PSIM_ATTREF                 pAttRef
    );

BOOL
KCCSimGetAttribute (
    IN  PSIM_ENTRY                  pEntry,
    IN  ATTRTYP                     attrTyp,
    OUT PSIM_ATTREF                 pAttRef OPTIONAL
    );

VOID
KCCSimNewAttribute (
    IN  PSIM_ENTRY                  pEntry,
    IN  ATTRTYP                     attrType,
    OUT PSIM_ATTREF                 pAttRef OPTIONAL
    );

VOID
KCCSimRemoveAttribute (
    IO  PSIM_ATTREF                 pAttRef
    );

VOID
KCCSimAddValueToAttribute (
    IN  PSIM_ATTREF                 pAttRef,
    IN  ULONG                       ulValLen,
    IN  PBYTE                       pValData
    );

VOID
KCCSimAllocAddValueToAttribute (
    IN  PSIM_ATTREF                 pAttRef,
    IN  ULONG                       ulValLen,
    IN  PBYTE                       pValData
    );

BOOL
KCCSimRemoveValueFromAttribute (
    IN  PSIM_ATTREF                 pAttRef,
    IN  ULONG                       ulValLen,
    IN  PBYTE                       pValData
    );

SHORT
KCCSimNthAncestor (
    IN  const DSNAME *              pdn1,
    IN  const DSNAME *              pdn2
    );

PSIM_ENTRY
KCCSimDsnameToEntry (
    IN  const DSNAME *              pdn,
    IN  ULONG                       ulOptions
    );

PDSNAME
KCCSimAlwaysGetObjCategory (
    IN  ATTRTYP                     objClass
    );

LPWSTR
KCCSimAllocGuidBasedDNSNameFromDSName (
    IN  const DSNAME *              pdn
    );

BOOL
KCCSimUpdateDsnameFromDirectory (
    IO  PDSNAME                     pdn
    );

VOID
KCCSimRemoveEntry (
    IO  PSIM_ENTRY *                pEntry
    );

const DSNAME *
KCCSimAnchorDn (
    IN  KCCSIM_ANCHOR_ID            anchorId
    );

LPCWSTR
KCCSimAnchorString (
    IN  KCCSIM_ANCHOR_ID            anchorId
    );

PSIM_ENTRY
KCCSimFindFirstChild (
    IN  PSIM_ENTRY                  pEntryParent,
    IN  ATTRTYP                     objClass,
    IN  const DSNAME *              pdnCategory OPTIONAL
    );

PSIM_ENTRY
KCCSimFindNextChild (
    IN  PSIM_ENTRY                  pEntryParent,
    IN  ATTRTYP                     objClass,
    IN  const DSNAME *              pdnCategory OPTIONAL
    );

ATTRTYP
KCCSimUpdateObjClassAttr (
    IN  PSIM_ATTREF                 pAttRef
    );

VOID
KCCSimAddMissingAttributes (
    IN  PSIM_ENTRY                  pEntry
    );

VOID
KCCSimUpdatePropertyMetaData (
    IN  PSIM_ATTREF                 pAttRef,
    IN  const UUID *                puuidDsaOriginating OPTIONAL
    );

VOID
KCCSimBuildAnchor (
    IN  LPCWSTR                     pwszDnDsa
    );

VOID
KCCSimUpdateWholeDirectory (
    VOID
    );

VOID
KCCSimInitializeDir (
    VOID
    );

VOID
KCCSimAllocGetAllServers (
    OUT ULONG *                     pulNumServers,
    OUT PSIM_ENTRY **               papEntryNTDSSettings
    );

VOID
KCCSimCompareDirectory (
    IN  LPWSTR                      pwszFn
    );

#endif // _KCCSIM_DIR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\sim\eval.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    eval.c

ABSTRACT:

    Contains routines for evaluating comparisons
    between attribute values.  Used primarily for
    evaluating filters in searches.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <filtypes.h>
#include "util.h"
#include "dir.h"

/***

    A brief note.

    We cannot simply use the comparison routines in dbsyntax.c.
    The dblayer reformats data before placing it in the database.
    In the simulated directory, we store all of our data in the
    form recognized by the mdlayer (i.e. as a SYNTAX_*.)  Therefore
    the comparison methods differ.  Since there are tons of syntax
    types, only the ones needed by the KCC are emulated here.  If a
    search is called on any others, an exception will be raised.

***/

BOOL
KCCSimIsNullTermA (
    IN  LPCSTR                      psz,
    IN  ULONG                       ulCnt
    )
/*++

Routine Description:

    Checks whether a buffer is a null-terminated string, scanning
    ahead a fixed number of characters.  This function is useful
    for determining whether the contents of a fixed-length buffer
    represent a null-termined string.  Note that we cannot use
    strlen or _strncnt, because if the buffer is not a
    null-terminated string we risk running outside of it.

Arguments:

    psz                 - The string to check.
    ulCnt               - The length of the buffer, in CHARs.

Return Value:

    TRUE if psz is a null-terminated string.

--*/
{
    ULONG                           ul;

    for (ul = 0; ul < ulCnt; ul++) {
        if (psz[ul] == '\0') {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
KCCSimIsNullTermW (
    IN  LPCWSTR                     pwsz,
    IN  ULONG                       ulCnt
    )
/*++

Routine Description:

    Unicode version of KCCSimIsNullTermA.

Arguments:

    pwsz                - The string to check.
    ulCnt               - The length of the buffer, in WCHARs.

Return Value:

    TRUE if pwsz is a null-terminated string.

--*/
{
    ULONG                           ul;

    for (ul = 0; ul < ulCnt; ul++) {
        if (pwsz[ul] == L'\0') {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
KCCSimEvalFromCmp (
    IN  UCHAR                       ucOp,
    IN  INT                         iCmp
    )
/*++

Routine Description:

    This function converts an compare-result integer
    (i.e. returned by wcscmp, memcmp, etc) and determines
    whether it represents a TRUE or FALSE evaluation of
    an expression.

Arguments:

    ucOp                - The compare operation being performed.
    iCmp                - The compare-result integer.

Return Value:

    TRUE if the expression evaluates true.

--*/
{
    switch (ucOp) {

        case FI_CHOICE_PRESENT:
            return TRUE;
            break;

        case FI_CHOICE_EQUALITY:
            return (iCmp == 0);
            break;
        
        case FI_CHOICE_NOT_EQUAL:
            return (iCmp != 0);

        case FI_CHOICE_LESS:
            return (iCmp < 0);
            break;

        case FI_CHOICE_LESS_OR_EQ:
            return (iCmp <= 0);
            break;

        case FI_CHOICE_GREATER_OR_EQ:
            return (iCmp >= 0);
            break;

        case FI_CHOICE_GREATER:
            return (iCmp > 0);
            break;

        default:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_INVALID_COMPARE_OPERATION
                );
            return FALSE;
            break;
    }
}

BOOL
KCCSimEvalDistname (
    IN  UCHAR                       ucOp,
    IN  ULONG                       ulLen1,
    IN  const SYNTAX_DISTNAME *     pVal1,
    IN  ULONG                       ulLen2,
    IN  const SYNTAX_DISTNAME *     pVal2
    )
/*++

Routine Description:

    Compares two DISTNAMEs.

Arguments:

    ucOp                - The operation to be performed.
    ulLen1              - Length of the first buffer.
    pVal1               - The first buffer.
    ulLen2              - Length of the second buffer.
    pVal2               - The second buffer.

Return Value:

    TRUE if the DISTNAMEs match.

--*/
{
    if (ulLen1 < sizeof (SYNTAX_DISTNAME) ||
        ulLen1 < pVal1->structLen ||
        ulLen2 < sizeof (SYNTAX_DISTNAME) ||
        ulLen2 < pVal2->structLen) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_INVALID_COMPARE_FORMAT
            );
    }

    switch (ucOp) {

        case FI_CHOICE_PRESENT:
            return TRUE;
            break;

        case FI_CHOICE_EQUALITY:
            return NameMatched (pVal1, pVal2);
            break;

        case FI_CHOICE_NOT_EQUAL:
            return !NameMatched (pVal1, pVal2);
            break;

        default:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_INVALID_COMPARE_OPERATION
                );
            return FALSE;
            break;
    }
    
}

BOOL
KCCSimEvalObjectID (
    IN  UCHAR                       ucOp,
    IN  ULONG                       ulLen1,
    IN  const SYNTAX_OBJECT_ID *    pVal1,
    IN  ULONG                       ulLen2,
    IN  const SYNTAX_OBJECT_ID *    pVal2
    )
/*++

Routine Description:

    Compares two OBJECT_IDs.

Arguments:

    ucOp                - The operation to be performed.
    ulLen1              - Length of the first buffer.
    pVal1               - The first buffer.
    ulLen2              - Length of the second buffer.
    pVal2               - The second buffer.

Return Value:

    TRUE if the object IDs match.

--*/
{
    if (ulLen1 != sizeof (SYNTAX_OBJECT_ID) ||
        ulLen2 != sizeof (SYNTAX_OBJECT_ID)) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_INVALID_COMPARE_FORMAT
            );
    }

    return KCCSimEvalFromCmp (ucOp, *pVal2 - *pVal1);
}

BOOL
KCCSimEvalNocaseString (
    IN  UCHAR                       ucOp,
    IN  ULONG                       ulLen1,
    IN  const SYNTAX_NOCASE_STRING *pVal1,
    IN  ULONG                       ulLen2,
    IN  const SYNTAX_NOCASE_STRING *pVal2
    )
/*++

Routine Description:

    Compares two NOCASE_STRINGs.

Arguments:

    ucOp                - The operation to be performed.
    ulLen1              - Length of the first buffer.
    pVal1               - The first buffer.
    ulLen2              - Length of the second buffer.
    pVal2               - The second buffer.

Return Value:

    TRUE if the strings match (not case-sensitive.)

--*/
{
    if (!KCCSimIsNullTermA (pVal1, ulLen1) ||
        !KCCSimIsNullTermA (pVal2, ulLen2)) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_INVALID_COMPARE_FORMAT
            );
    }

    if (ucOp == FI_CHOICE_SUBSTRING) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_UNSUPPORTED_FILITEM_CHOICE
            );
        return FALSE;
    } else {

        return KCCSimEvalFromCmp (ucOp, _stricmp (pVal2, pVal1));

    }
}

BOOL
KCCSimEvalOctetString (
    IN  UCHAR                       ucOp,
    IN  ULONG                       ulLen1,
    IN  const SYNTAX_OCTET_STRING * pVal1,
    IN  ULONG                       ulLen2,
    IN  const SYNTAX_OCTET_STRING * pVal2
    )
/*++

Routine Description:

    Compares two OCTET_STRINGs.

Arguments:

    ucOp                - The operation to be performed.
    ulLen1              - Length of the first buffer.
    pVal1               - The first buffer.
    ulLen2              - Length of the second buffer.
    pVal2               - The second buffer.

Return Value:

    TRUE if the strings match.

--*/
{
    int iCmp;

    if (ucOp == FI_CHOICE_SUBSTRING) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_UNSUPPORTED_FILITEM_CHOICE
            );
        return FALSE;
    } else {

        iCmp = memcmp (pVal2, pVal1, min (ulLen1, ulLen2));
        if (iCmp == 0) {
            iCmp = ulLen2 - ulLen1;
        }

        return KCCSimEvalFromCmp (ucOp, iCmp);

    }
}

BOOL
KCCSimEvalUnicode (
    IN  UCHAR                       ucOp,
    IN  ULONG                       ulLen1,
    IN  const SYNTAX_UNICODE *      pVal1,
    IN  ULONG                       ulLen2,
    IN  const SYNTAX_UNICODE *      pVal2
    )
/*++

Routine Description:

    Compares two UNICODEs.

Arguments:

    ucOp                - The operation to be performed.
    ulLen1              - Length of the first buffer.
    pVal1               - The first buffer.
    ulLen2              - Length of the second buffer.
    pVal2               - The second buffer.

Return Value:

    TRUE if the unicode strings match.

--*/
{
    if (!KCCSimIsNullTermW (pVal1, ulLen1) ||
        !KCCSimIsNullTermW (pVal2, ulLen2)) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_INVALID_COMPARE_FORMAT
            );
    }

    if (ucOp == FI_CHOICE_SUBSTRING) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_UNSUPPORTED_FILITEM_CHOICE
            );
        return FALSE;
    } else {
        return KCCSimEvalFromCmp (ucOp, _wcsicmp (pVal2, pVal1));
    }
}

BOOL
KCCSimCompare (
    IN  ATTRTYP                     attrType,
    IN  UCHAR                       ucOper,
    IN  ULONG                       ulLen1,
    IN  const BYTE *                pVal1,
    IN  ULONG                       ulLen2,
    IN  const BYTE *                pVal2
    )
/*++

Routine Description:

    Compares two attribute values.

Arguments:

    attrType            - The type of the attribute whose values are
                          being compared.
    ucOp                - The operation to be performed.
    ulLen1              - Length of the first buffer.
    pVal1               - The first buffer.
    ulLen2              - Length of the second buffer.
    pVal2               - The second buffer.

Return Value:

    TRUE if the attribute values match.

--*/
{
    ULONG                           ulSyntax;
    BOOL                            bResult;

    ulSyntax = KCCSimAttrSyntaxType (attrType);

    if (ucOper == FI_CHOICE_PRESENT) {
        return TRUE;
    }

    switch (ulSyntax) {

        case SYNTAX_DISTNAME_TYPE:
            return KCCSimEvalDistname (
                ucOper,
                ulLen1,
                (SYNTAX_DISTNAME *) pVal1,
                ulLen2,
                (SYNTAX_DISTNAME *) pVal2
                );
            break;

        case SYNTAX_OBJECT_ID_TYPE:
            return KCCSimEvalObjectID (
                ucOper,
                ulLen1,
                (SYNTAX_OBJECT_ID *) pVal1,
                ulLen2,
                (SYNTAX_OBJECT_ID *) pVal2
                );
            break;

        case SYNTAX_NOCASE_STRING_TYPE:
            return KCCSimEvalNocaseString (
                ucOper,
                ulLen1,
                (SYNTAX_NOCASE_STRING *) pVal1,
                ulLen2,
                (SYNTAX_NOCASE_STRING *) pVal2
                );
            break;

        case SYNTAX_OCTET_STRING_TYPE:
            return KCCSimEvalOctetString (
                ucOper,
                ulLen1,
                (SYNTAX_OCTET_STRING *) pVal1,
                ulLen2,
                (SYNTAX_OCTET_STRING *) pVal2
                );
            break;

        case SYNTAX_UNICODE_TYPE:
            return KCCSimEvalUnicode (
                ucOper,
                ulLen1,
                (SYNTAX_UNICODE *) pVal1,
                ulLen2,
                (SYNTAX_UNICODE *) pVal2
                );
            break;

        default:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_UNSUPPORTED_SYNTAX_TYPE,
                KCCSimAttrTypeToString (attrType)
                );
            return FALSE;
            break;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\sim\kccsim.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kccsim.h

ABSTRACT:

    Main header file for KCCSim.  This replaces all "real" functions
    that KCCSim simulated with their simulated counterparts.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#ifndef _KCCSIM_H_
#define _KCCSIM_H_

// We need these includes to prototype the simulated functions.
#include <lsarpc.h>
#include <ismapi.h>

//
// This header file is full of expressions that are always false. These
// expressions manifest themselves in macros that take unsigned values
// and make tests, for example, of greater than or equal to zero.
//
// Turn off these warnings until the authors can fix this code.
//

#pragma warning(disable:4296)

//
// Memory Allocation Functions
#define THAlloc                             KCCSimThreadAlloc
#define THReAlloc                           KCCSimThreadReAlloc
#define THFree                              KCCSimThreadFree
#undef  THAllocEx
#define THAllocEx(pTHS,ulSize)              KCCSimThreadAlloc(ulSize)
#define THCreate( type )                    KCCSimThreadCreate();
#define THDestroy()                         KCCSimThreadDestroy();

// Simulated LSA Functions
#define LsaIQueryInformationPolicyTrusted   SimLsaIQueryInformationPolicyTrusted
#define LsaIFree_LSAPR_POLICY_INFORMATION   SimLsaIFree_LSAPR_POLICY_INFORMATION

// Simulated ISM Functions
#define I_ISMGetTransportServers            KCCSimI_ISMGetTransportServers
#define I_ISMGetConnectionSchedule          KCCSimI_ISMGetConnectionSchedule
#define I_ISMGetConnectivity                KCCSimI_ISMGetConnectivity
#define I_ISMFree                           KCCSimI_ISMFree

// Simulated DS Client Functions
#define DsReplicaGetInfoW                   SimDsReplicaGetInfoW
#define DsReplicaFreeInfo                   SimDsReplicaFreeInfo
#define DsBindW                             SimDsBindW
#define DsUnBindW                           SimDsUnBindW

// Simulated Directory Service Functions
#define GetSecondsSince1601                 SimGetSecondsSince1601
#define GuidBasedDNSNameFromDSName          SimGuidBasedDNSNameFromDSName
#define DsGetDefaultObjCategory             SimDsGetDefaultObjCategory
#define GetConfigurationName                SimGetConfigurationName
#define DirRead                             SimDirRead
#define DirSearch                           SimDirSearch
#define DirAddEntry                         SimDirAddEntry
#define DirRemoveEntry                      SimDirRemoveEntry
#define DirModifyEntry                      SimDirModifyEntry
#define MtxAddrFromTransportAddr            SimMtxAddrFromTransportAddr
#define TransportAddrFromMtxAddr            SimTransportAddrFromMtxAddr
#define DirReplicaAdd                       SimDirReplicaAdd
#define DirReplicaDelete                    SimDirReplicaDelete
#define DirReplicaGetDemoteTarget           SimDirReplicaGetDemoteTarget
#define DirReplicaDemote                    SimDirReplicaDemote
#define DirReplicaModify                    SimDirReplicaModify
#define DirReplicaReferenceUpdate           SimDirReplicaReferenceUpdate
#define DSNAMEToMappedStrExternal(x)        SimDSNAMEToMappedStrExternal(x,FALSE)

// Debug Overrides
#undef  DPRINT
#define DPRINT(n,s)                 KCCSimDbgLog (n, s)
#undef  DPRINT1
#define DPRINT1(n,s,x)              KCCSimDbgLog (n, s, x)
#undef  DPRINT2
#define DPRINT2(n,s,x,y)            KCCSimDbgLog (n, s, x, y)
#undef  DPRINT3
#define DPRINT3(n,s,x,y,z)          KCCSimDbgLog (n, s, x, y, z)
#undef  DPRINT4
#define DPRINT4(n,s,x,y,z,w)        KCCSimDbgLog (n, s, x, y, z, w)

// Log Event Overrides
// Note that this catches all events logged with LogEvent and LogEvent8. It does
// not catch LogEvent8WithData. This is rarely used by the KCC at present.
#undef LogEvent8
#define LogEvent8(cat, sev, msg, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) \
    KCCSimEventLog( cat, sev, msg, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL ); \
    LogEvent8WithData(cat, sev, msg, arg1, arg2, arg3, arg4, arg5, \
                      arg6, arg7, arg8, 0, NULL)



// Utilities

LPVOID
KCCSimAlloc (
    IN  ULONG                       ulSize
    );

LPVOID
KCCSimReAlloc (
    IN  LPVOID                      pOld,
    IN  ULONG                       ulSize
    );

VOID
KCCSimFree (
    IN  LPVOID                      p
    );

VOID
KCCSimDbgLog (
    IN  ULONG                       ulLevel,
    IN  LPCSTR                      pszFormat,
    ...
    );

VOID
KCCSimEventLog (
    IN  ULONG                       ulCategory,
    IN  ULONG                       ulSeverity,
    IN  DWORD                       dwMessageId,
    ...
    );

LPVOID
KCCSimThreadAlloc (
    IN  ULONG                       ulSize
    );

LPVOID
KCCSimThreadReAlloc (
    IN  LPVOID                      pOld,
    IN  ULONG                       ulSize
    );

VOID
KCCSimThreadFree (
    IN  LPVOID                      p
    );

DWORD
KCCSimThreadCreate (
    void
    );

VOID
KCCSimThreadDestroy (
    void
    );

// Function prototypes - LSA

NTSTATUS NTAPI
SimLsaIQueryInformationPolicyTrusted (
    IN  POLICY_INFORMATION_CLASS    InformationClass,
    OUT PLSAPR_POLICY_INFORMATION   *Buffer
    );

VOID NTAPI
SimLsaIFree_LSAPR_POLICY_INFORMATION (
    IN  POLICY_INFORMATION_CLASS    InformationClass,
    IN  PLSAPR_POLICY_INFORMATION   PolicyInformation
    );

// Function prototypes - KCCSIM wrappers of simulated ISM functions

DWORD
KCCSimI_ISMGetTransportServers (
    IN  HANDLE                      hIsm,
    IN  LPCWSTR                     pszSiteDN,
    OUT ISM_SERVER_LIST **          ppServerList
    );

DWORD
KCCSimI_ISMGetConnectionSchedule (
    IN  HANDLE                      hIsm,
    IN  LPCWSTR                     pszSite1DN,
    IN  LPCWSTR                     pszSite2DN,
    OUT ISM_SCHEDULE **             ppSchedule
    );

DWORD
KCCSimI_ISMGetConnectivity (
    IN  LPCWSTR                     pszTransportDN,
    OUT ISM_CONNECTIVITY **         ppConnectivity
    );

DWORD
KCCSimI_ISMFree (
    IN  VOID *                      pv
    );

// Function Prototypes - NTDSAPI

DWORD
WINAPI
SimDsReplicaGetInfoW (
    HANDLE                          hDs,
    DS_REPL_INFO_TYPE               InfoType,
    LPCWSTR                         pszObject,
    UUID *                          puuidForSourceDsaObjGuid,
    VOID **                         ppInfo
    );

void
WINAPI
SimDsReplicaFreeInfo (
    DS_REPL_INFO_TYPE               InfoType,
    VOID *                          pInfo
    );

DWORD
WINAPI
SimDsBindW (
    LPCWSTR                         DomainControllerName,
    LPCWSTR                         DnsDomainName,
    HANDLE *                        phDS
    );

DWORD
WINAPI
SimDsUnBindW (
    HANDLE *                        phDS
    );

// Function Prototypes - NTDSA

DSTIME
SimGetSecondsSince1601 (
    VOID
    );

LPWSTR
SimGuidBasedDNSNameFromDSName (
    PDSNAME                         pdnServer
    );

PDSNAME
SimDsGetDefaultObjCategory (
    ATTRTYP                         attrTyp
    );

NTSTATUS
SimGetConfigurationName (
    DWORD                           which,
    DWORD *                         pcbName,
    DSNAME *                        pName
    );

ULONG
SimDirRead (
    READARG FAR *                   pReadArg,
    READRES **                      ppReadRes
    );

ULONG
SimDirSearch (
    SEARCHARG *                     pSearchArg,
    SEARCHRES **                    ppSearchRes
    );

ULONG
SimDirAddEntry (
    ADDARG *                        pAddArg,
    ADDRES **                       ppAddRes
    );

ULONG
SimDirRemoveEntry (
    REMOVEARG *                     pRemoveArg,
    REMOVERES **                    ppRemoveRes
    );

ULONG
SimDirModifyEntry (
    MODIFYARG *                     pModifyArg,
    MODIFYRES **                    ppModifyRes
    );

MTX_ADDR *
SimMtxAddrFromTransportAddr (
    IN  LPWSTR                      psz
    );

LPWSTR
SimTransportAddrFromMtxAddr (
    MTX_ADDR *                      pMtxAddr
    );

ULONG
SimDirReplicaAdd (
    IN  PDSNAME                     pdnNC,
    IN  PDSNAME                     pdnSourceDsa,
    IN  PDSNAME                     pdnTransport,
    IN  LPWSTR                      pwszSourceDsaAddress,
    IN  LPWSTR                      pwszSourceDsaDnsDomainName,
    IN  REPLTIMES *                 preptimesSync,
    IN  ULONG                       ulOptions
    );

ULONG
SimDirReplicaDelete (
    IN  PDSNAME                     pdnNC,
    IN  LPWSTR                      pwszSourceDRA,
    IN  ULONG                       ulOptions
    );

struct _DRS_DEMOTE_TARGET_SEARCH_INFO;
ULONG
SimDirReplicaGetDemoteTarget(
    IN      DSNAME *                                pNC,
    IN OUT  struct _DRS_DEMOTE_TARGET_SEARCH_INFO * pDSTInfo,
    OUT     LPWSTR *                                ppszDemoteTargetDNSName,
    OUT     DSNAME **                               ppDemoteTargetDSADN
    );

ULONG
SimDirReplicaDemote(
    IN  DSNAME *                    pNC,
    IN  LPWSTR                      pszOtherDSADNSName,
    IN  DSNAME *                    pOtherDSADN,
    IN  ULONG                       ulOptions
    );

ULONG
SimDirReplicaModify (
    IN  PDSNAME                     pNC,
    IN  UUID *                      puuidSourceDRA,
    IN  UUID *                      puuidTransportObj,
    IN  LPWSTR                      pszSourceDRA,
    IN  REPLTIMES *                 prtSchedule,
    IN  ULONG                       ulReplicaFlags,
    IN  ULONG                       ulModifyFields,
    IN  ULONG                       ulOptions
    );

ULONG
SimDirReplicaReferenceUpdate(
    DSNAME *    pNC,
    LPWSTR      pszRepsToDRA,
    UUID *      puuidRepsToDRA,
    ULONG       ulOptions
    );

LPSTR
SimDSNAMEToMappedStrExternal(
    IN DSNAME *pName,
    IN OPTIONAL BOOLEAN fUseNormalAllocator
    );

VOID
SimDirFreeSearchRes(
    IN SEARCHRES *pSearchRes
    );

VOID
SimDirFreeReadRes(
    IN READRES *pReadRes
    );

#endif // _KCCSIM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\sim\ldif.h ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    ldif.h

ABSTRACT:

    Header file for ldif.c.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

VOID
KCCSimLogDirectoryAdd (
    IN  const DSNAME *              pdn,
    IN  ATTRBLOCK *                 pAddBlock
    );

VOID
KCCSimLogDirectoryRemove (
    IN  const DSNAME *              pdn
    );

VOID
KCCSimLogDirectoryModify (
    IN  const DSNAME *              pdn,
    IN  ULONG                       ulCount,
    IN  ATTRMODLIST *               pModifyList
    );

VOID
KCCSimLogSingleAttValChange (
    IN  PSIM_ATTREF                 pAttRef,
    IN  ULONG                       ulValLen,
    IN  const BYTE *                pValData,
    IN  USHORT                      choice
    );

VOID
KCCSimLoadLdif (
    IN  LPCWSTR                     pwszFn
    );

BOOL
KCCSimExportChanges (
    IN  LPCWSTR                     pwszFn,
    IN  BOOL                        bOverwrite
    );

VOID
KCCSimExportWholeDirectory (
    IN  LPCWSTR                     pwszFn,
    IN  BOOL                        bExportConfigOnly
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\sim\ldif.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    ldif.c

ABSTRACT:

    Contains routines for importing and exporting the
    simulated directory (or portions of it) to/from an
    ldif file.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <winldap.h>
#include <dsutil.h>
#include <ldifext.h>
#include <attids.h>
#include <debug.h>
#include "kccsim.h"
#include "util.h"
#include "dir.h"
#include <fileno.h>
#define FILENO  FILENO_KCCSIM_LDIF

/***

    Ldap formats attribute values differently
    from the directory.  Therefore some conversion is necessary.
    It would be nice if conversion routines were exposed somewhere;
    unfortunately, they are not, so kccsim needs to do its own
    conversions.  This is an unpleasant duplicated code issue.

    Ldifldap does not export LDIF_Records to files, but it
    really should.  To support the possibility that such support is
    added in the future, kccsim packages everything into LDIF_Records
    before exporting.  The existing export routines should be
    regarded as stubs, to be replaced when the appropriate routines
    are exposed in ldifldap (if they ever are.)

***/

WORD
KCCSimLdapTimeAsciiToInt (
    IN  CHAR                        cAscii
    )
/*++

Routine Description:

    A cheap hack for converting an ascii representation of
    an integer to a word.  This method seems marginally
    safer (but more annoying) than the simple identity
    (WORD = CHAR - '0').

Arguments:

    cAscii              - An ascii representation of an integer.

Return Value:

    The associated WORD.

--*/
{
    WORD                            wRet;

    switch (cAscii) {

        case '0': wRet = 0; break;
        case '1': wRet = 1; break;
        case '2': wRet = 2; break;
        case '3': wRet = 3; break;
        case '4': wRet = 4; break;
        case '5': wRet = 5; break;
        case '6': wRet = 6; break;
        case '7': wRet = 7; break;
        case '8': wRet = 8; break;
        case '9': wRet = 9; break;
        
        default:
            Assert (!"ldif.c: KCCSimLdapTimeAsciiToInt: invalid input.");
            wRet = 0;
            break;

    }

    return wRet;
}

BOOL
KCCSimLdapTimeToDSTime (
    IN  LPCSTR                  pszLdapTime,
    IN  ULONG                   ulLdapValLen,
    OUT DSTIME *                pdsTime
    )
/*++

Routine Description:

    Converts an ldif time string ("YYYYMMDDhhmmss.0Z") to
    a DSTIME.

Arguments:

    pszLdapTime         - The ldap time string.
    ulLdapValLen        - Length of the time string, in bytes.
    pdsTime             - Pointer to a DSTIME that will hold
                          the result.

Return Value:

    TRUE if the conversion was successful.
    FALSE if the ldif time string was improperly formatted.

--*/
{
    SYSTEMTIME                  systemTime;
    FILETIME                    fileTime;
    DSTIME                      dsTime;
    ULONG                       ul;
    BOOL                        bValid;

    // Check that this is a valid ldif time, i.e.
    // a string of the form "YYYYMMDDhhmmss.0Z"

    bValid = TRUE;
    if (ulLdapValLen < 17             ||
        pszLdapTime[14] != '.'     ||
        pszLdapTime[15] != '0'     ||
        pszLdapTime[16] != 'Z') {
        bValid = FALSE;
    }
    for (ul = 0; ul < 14; ul++) {
        if (!isdigit (pszLdapTime[ul])) {
            bValid = FALSE;
            break;
        }
    }

    if (!bValid) {
        return FALSE;
    }

    systemTime.wYear =
        1000 * KCCSimLdapTimeAsciiToInt (*(pszLdapTime++)) +
         100 * KCCSimLdapTimeAsciiToInt (*(pszLdapTime++)) +
          10 * KCCSimLdapTimeAsciiToInt (*(pszLdapTime++)) +
           1 * KCCSimLdapTimeAsciiToInt (*(pszLdapTime++));

    systemTime.wMonth =
          10 * KCCSimLdapTimeAsciiToInt (*(pszLdapTime++)) +
           1 * KCCSimLdapTimeAsciiToInt (*(pszLdapTime++));

    systemTime.wDay =
          10 * KCCSimLdapTimeAsciiToInt (*(pszLdapTime++)) +
           1 * KCCSimLdapTimeAsciiToInt (*(pszLdapTime++));

    systemTime.wHour =
          10 * KCCSimLdapTimeAsciiToInt (*(pszLdapTime++)) +
           1 * KCCSimLdapTimeAsciiToInt (*(pszLdapTime++));

    systemTime.wMinute =
          10 * KCCSimLdapTimeAsciiToInt (*(pszLdapTime++)) +
           1 * KCCSimLdapTimeAsciiToInt (*(pszLdapTime++));

    systemTime.wSecond =
          10 * KCCSimLdapTimeAsciiToInt (*(pszLdapTime++)) +
           1 * KCCSimLdapTimeAsciiToInt (*(pszLdapTime++));

    systemTime.wMilliseconds = 0;

    SystemTimeToFileTime (&systemTime, &fileTime);
    FileTimeToDSTime (fileTime, pdsTime);

    return TRUE;
}


BOOL
KccSimDecodeLdapDistnameBinary(
    const BYTE * pszLdapDistnameBinaryValue,
    PVOID *ppvData,
    LPDWORD pcbLength,
    LPSTR *ppszDn
    )

/*++

Routine Description:

    Description

Arguments:

    pszLdapDistnameBinaryValue - Incoming ldap encoded distname binary value
    ppvData - Newly allocated data. Caller must deallocate
    pcbLength - length of returned data
    ppszDn - pointer to dn within incoming buffer, do not deallocate

Return Value:

    BOOL - 

--*/

{
    LPSTR pszColon, pszData;
    DWORD length, i;

    // Check for 'B'
    if (*pszLdapDistnameBinaryValue != 'B') {
        return FALSE;
    }

    // Check for 1st :
    pszLdapDistnameBinaryValue++;
    if (*pszLdapDistnameBinaryValue != ':') {
        return FALSE;
    }

    // Get the length
    pszLdapDistnameBinaryValue++;
    length = strtol(pszLdapDistnameBinaryValue, NULL, 10);
    if (length & 1) {
        // Length should be even
        return FALSE;
    }
    *pcbLength = length / 2;

    // Check for 2nd :
    pszColon = strchr(pszLdapDistnameBinaryValue, L':');
    if (!pszColon) {
        return FALSE;
    }

    // Make sure length is correct
    pszData = pszColon + 1;
    if (pszData[length] != ':') {
        return FALSE;
    }
    pszColon = strchr(pszData, ':');
    if (!pszColon) {
        return FALSE;
    }
    if (pszColon != pszData + length) {
        return FALSE;
    }

    // Decode the data
    *ppvData = KCCSimAlloc( *pcbLength );

    for( i = 0; i < *pcbLength; i++ ) {
        CHAR szHexString[3];
        szHexString[0] = *pszData++;
        szHexString[1] = *pszData++;
        szHexString[2] = '\0';
        ((PCHAR) (*ppvData))[i] = (CHAR) strtol(szHexString, NULL, 16);
    }

    Assert( pszData == pszColon );

    // Return pointer to dn
    *ppszDn = pszColon + 1;

    return TRUE;
} /* decodeLdapDistnameBinary */


BOOL
KCCSimAllocConvertDNBFromLdapVal (
    IN  const BYTE *            pLdapVal,
    OUT PULONG                  pulValLen,
    OUT PBYTE *                 ppVal
    )

/*++

Routine Description:

    Description

Arguments:

    pLdapVal - 
    pulValLen - 
    ppVal - 

Return Value:

    None

--*/

{
    PVOID pvPayload = NULL, pvData = NULL, pvDNB;
    DWORD cbPayload, cbData, cbDNB;
    LPSTR pszDn = NULL;
    PDSNAME pDn = NULL;
    SYNTAX_ADDRESS *pSA;
    SYNTAX_DISTNAME_BINARY *pDNB;

    if (!KccSimDecodeLdapDistnameBinary( pLdapVal,
                                         &pvPayload, &cbPayload, &pszDn )) {
        return FALSE;
    }
    // pszDn is not allocated, but points into pLdapVal
    pDn = KCCSimAllocDsnameFromNarrow (pszDn);

    cbData = STRUCTLEN_FROM_PAYLOAD_LEN( cbPayload );
    pvData = KCCSimAlloc( cbData );
    pSA = (SYNTAX_ADDRESS *)pvData;
    pSA->structLen = cbData;
    memcpy( &(pSA->byteVal), pvPayload, cbPayload );

    cbDNB = DERIVE_NAME_DATA_SIZE( pDn, pSA );
    pvDNB = KCCSimAlloc( cbDNB );
    pDNB = (SYNTAX_DISTNAME_BINARY *)pvDNB;

    BUILD_NAME_DATA( pDNB, pDn, pSA );

    *pulValLen = cbDNB;
    *ppVal = (PBYTE) pDNB;

    if (pvPayload) {
        KCCSimFree( pvPayload );
    }
    if (pvData) {
        KCCSimFree( pvData );
    }
    if (pDn) {
        KCCSimFree( pDn );
    }

    return TRUE;
} /* KCCSimAllocConvertDNBFromLdapVal  */

VOID
KCCSimAllocConvertFromLdapVal (
    IN  LPCWSTR                 pwszFn,
    IN  LPCWSTR                 pwszDn,
    IN  ATTRTYP                 attrType,
    IN  ULONG                   ulLdapValLen,
    IN  const BYTE *            pLdapVal,
    OUT PULONG                  pulValLen,
    OUT PBYTE *                 ppVal
    )
/*++

Routine Description:

    Converts an ldap-formatted value to a properly
    formatted attribute value, allocating space.

Arguments:

    pwszFn              - The filename of the ldif file being processed.  Used
                          for error reporting purposes.
    pwszDn              - The DN of the entry being processed.  Used for error
                          reporting purposes.
    attrType            - Attribute type of the value being converted.
    ulLdapValLen        - Length of the ldap value buffer.
    pLdapVal            - LDAP value.
    pulValLen           - Pointer to a ULONG that will hold the length of the
                          newly allocated buffer.
    ppVal               - Pointer to a PBYTE that will hold the newly allocated
                          buffer.

Return Value:

    None.

--*/
{
    PBYTE                       pVal;

    PDSNAME                     pdn;
    ULONG                       ulSize;

    switch (KCCSimAttrSyntaxType (attrType)) {

        case SYNTAX_DISTNAME_TYPE:
            // The incoming value is a narrow string.  We want the
            // associated DN.  We do not add a GUID to the DN at this
            // stage, since we don't necessarily know it.  That will
            // be done later, when the directory is updated.
            pdn = KCCSimAllocDsnameFromNarrow (pLdapVal);
            *pulValLen = pdn->structLen;
            ((SYNTAX_DISTNAME *) pVal) =
                pdn;
            break;

        case SYNTAX_DISTNAME_BINARY_TYPE:
        {
            if (!KCCSimAllocConvertDNBFromLdapVal(
                pLdapVal,
                pulValLen,
                &pVal)) {

                // This is a warning because W2K kccsim generates DNB
                // as base64, which we don't support.
                KCCSimPrintMessage (                    
                    KCCSIM_WARNING_LDIF_INVALID_DISTNAME_BINARY,
                    pwszFn,
                    pwszDn,
                    KCCSimAttrTypeToString (attrType)
                    );
                *pulValLen = 0;
                pVal = NULL;
            }
            break;
        }

        case SYNTAX_OBJECT_ID_TYPE:
            // The incoming value is a narrow string.  We want the
            // attribute type associated with that string.
            *pulValLen = sizeof (SYNTAX_OBJECT_ID);
            pVal = KCCSimAlloc (*pulValLen);
            *((SYNTAX_OBJECT_ID *) pVal) =
                KCCSimNarrowStringToAttrType (pLdapVal);
            // Print a warning if we failed to convert the string;
            // it will default to 0.
            if (*((SYNTAX_OBJECT_ID *) pVal) == 0) {
                KCCSimPrintMessage (
                    KCCSIM_WARNING_LDIF_INVALID_OBJECT_ID,
                    pwszFn,
                    pwszDn,
                    KCCSimAttrTypeToString (attrType)
                    );
            }
            break;

        case SYNTAX_BOOLEAN_TYPE:
            // Here the incoming value is either "TRUE" or "FALSE".
            *pulValLen = sizeof (SYNTAX_BOOLEAN);
            pVal = KCCSimAlloc (*pulValLen);
            if (strcmp (pLdapVal, "TRUE") == 0) {
                *((SYNTAX_BOOLEAN *) pVal) = TRUE;
            } else if (strcmp (pLdapVal, "FALSE") == 0) {
                *((SYNTAX_BOOLEAN *) pVal) = FALSE;
            } else {
                // It wasn't "TRUE" or "FALSE"; print
                // a warning and default to FALSE.
                KCCSimPrintMessage (
                    KCCSIM_WARNING_LDIF_INVALID_BOOLEAN,
                    pwszFn,
                    pwszDn,
                    KCCSimAttrTypeToString (attrType)
                    );
                *((SYNTAX_BOOLEAN *) pVal) = FALSE;
            }
            break;

        case SYNTAX_INTEGER_TYPE:
            // The incoming value is a narrow string.
            *pulValLen = sizeof (SYNTAX_INTEGER);
            pVal = KCCSimAlloc (*pulValLen);
            *((SYNTAX_INTEGER *) pVal) =
                atol (pLdapVal);
            break;

        case SYNTAX_TIME_TYPE:
            // The incoming value is an LDAP formatted time.
            *pulValLen = sizeof (SYNTAX_TIME);
            pVal = KCCSimAlloc (*pulValLen);
            if (!KCCSimLdapTimeToDSTime (
                    (LPSTR) pLdapVal,
                    ulLdapValLen,
                    (SYNTAX_TIME *) pVal
                    )) {
                // It was improperly formatted; print
                // a warning and default to 0 (never).
                KCCSimPrintMessage (
                    KCCSIM_WARNING_LDIF_INVALID_TIME,
                    pwszFn,
                    pwszDn,
                    KCCSimAttrTypeToString (attrType)
                    );
                *((SYNTAX_TIME *) pVal) = 0;
            }
            break;

        case SYNTAX_UNICODE_TYPE:
            // The incoming value is a narrow string; we must
            // convert to a wide string.
            pVal = (PBYTE) KCCSimAllocWideStr (
                CP_UTF8, (LPSTR) pLdapVal);
            *pulValLen = KCCSIM_WCSMEMSIZE ((LPWSTR) pVal);
            break;

        case SYNTAX_I8_TYPE:
            // The incoming value is a narrow string; we want
            // a large integer, so we use atoli.
            *pulValLen = sizeof (LARGE_INTEGER);
            pVal = KCCSimAlloc (*pulValLen);
            *((SYNTAX_I8 *) pVal) =
                atoli ((LPSTR) pLdapVal);
            break;

        // For all of the below, we want either a binary or a
        // narrow string.  So we can just do a direct block-copy.
        case SYNTAX_UNDEFINED_TYPE:
        case SYNTAX_CASE_STRING_TYPE:
        case SYNTAX_NOCASE_STRING_TYPE:
        case SYNTAX_PRINT_CASE_STRING_TYPE:
        case SYNTAX_NUMERIC_STRING_TYPE:
        case SYNTAX_OCTET_STRING_TYPE:
        case SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE:
        case SYNTAX_SID_TYPE:
            *pulValLen = ulLdapValLen;
            pVal = KCCSimAlloc (*pulValLen);
            memcpy (pVal, pLdapVal, ulLdapValLen);
            break;

        default:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_UNSUPPORTED_SYNTAX_TYPE,
                KCCSimAttrTypeToString (attrType)
                );
            pVal = NULL;
            break;

    }

    *ppVal = pVal;

}


VOID
KCCSimAllocConvertDNBToLdapVal(
    IN  const BYTE *            pVal,
    OUT PULONG                  pulLdapValLen,
    OUT PBYTE *                 ppLdapVal
    )

/*++

Routine Description:

    Convert a directory entry value to a LDAP Distname Binary

    Copied and modified from ldapcore.cxx:LDAP_LDAPDNBlobToDirDNBlob

Arguments:

    ulValLen - binary length
    pVal - binary value
    pulLdapValLen - Updated string length in chars
    ppLdapVal - ascii string

Return Value:

    None

--*/

{
    DWORD cbPayload, cbName, cbTotal, j;
    SYNTAX_ADDRESS *pSA;
    PDSNAME pDn;
    LPSTR pszName = NULL, pszLdap = NULL, p;

    pDn = NAMEPTR( (SYNTAX_DISTNAME_BINARY *) pVal );
    pSA = DATAPTR( (SYNTAX_DISTNAME_BINARY *) pVal );

    cbPayload = PAYLOAD_LEN_FROM_STRUCTLEN( pSA->structLen );

    // Convert wide string to narrow string.
    pszName = (LPSTR) KCCSimAllocNarrowStr(CP_UTF8, pDn->StringName);
    cbName = KCCSIM_STRMEMSIZE(pszName);

    cbTotal = 2 + 10 + 1 + (2*cbPayload) + 1 + cbName;

    p = pszLdap = (LPSTR) KCCSimAlloc( cbTotal );
    
    *p++ = 'B';
    *p++ = ':';

    // There are two hex digits for each byte of data
    _ltoa( cbPayload * 2, p, 10 );
    p += strlen( p );

    *p++ = ':';

    for(j=0; j < cbPayload ; j++) {
        sprintf(p,"%02X", pSA->byteVal[j]);
        p += 2;
    }

    *p++ = ':';

    strcpy( p, pszName );

    *pulLdapValLen = ((DWORD) (pszLdap - p)) + cbName;
    *ppLdapVal = (PBYTE) pszLdap;

    // cbTotal is an upper limit, because we estimate the length
    // of the string-ized count of digits
    Assert( *pulLdapValLen <= cbTotal );

    KCCSimFree( pszName );

} /* KCCSimAllocConvertDNBToLdapVal */

VOID
KCCSimAllocConvertToLdapVal (
    IN  ATTRTYP                 attrType,
    IN  ULONG                   ulValLen,
    IN  const BYTE *            pVal,
    OUT PULONG                  pulLdapValLen,
    OUT PBYTE *                 ppLdapVal
    )
/*++

Routine Description:

    Converts a value from the directory to an ldap-formatted value.

Arguments:

    attrType            - Attribute type of the value being converted.
    pulValLen           - The length of the value in the directory.
    ppVal               - The value in the directory.
    pulLdapValLen       - Pointer to a ULONG that will hold the length of the
                          newly allocated buffer.
    ppLdapVal           - Pointer to a PBYTE that will hold the newly allocated
                          buffer.

Return Value:

    None.

--*/
{
    PBYTE                       pLdapVal;

    SYSTEMTIME                  systemTime;
    struct tm                   tmTime;

    switch (KCCSimAttrSyntaxType (attrType)) {

        case SYNTAX_DISTNAME_TYPE:
            // Convert wide string to narrow string.
            pLdapVal = (PBYTE) KCCSimAllocNarrowStr (
                CP_UTF8, ((SYNTAX_DISTNAME *) pVal)->StringName);
            *pulLdapValLen = KCCSIM_STRMEMSIZE ((LPSTR) pLdapVal);
            break;

        case SYNTAX_OBJECT_ID_TYPE:
            // Convert object ID to wide string to narrow string.
            pLdapVal = (PBYTE) KCCSimAllocNarrowStr (
                CP_UTF8,
                KCCSimAttrTypeToString (*((SYNTAX_OBJECT_ID *) pVal))
                );
            *pulLdapValLen = KCCSIM_STRMEMSIZE ((LPSTR) pLdapVal);
            break;

        case SYNTAX_BOOLEAN_TYPE:
            // Convert BOOL to "TRUE" or "FALSE".
            if (*((SYNTAX_BOOLEAN *) pVal)) {
                pLdapVal = KCCSIM_STRDUP ("TRUE");
            } else {
                pLdapVal = KCCSIM_STRDUP ("FALSE");
            }
            *pulLdapValLen = KCCSIM_STRMEMSIZE ((LPSTR) pLdapVal);
            break;

        case SYNTAX_INTEGER_TYPE:
            // Convert integer to narrow string.
            pLdapVal = KCCSimAlloc (sizeof (CHAR) * (1 + KCCSIM_MAX_LTOA_CHARS));
            _ltoa (*((SYNTAX_INTEGER *) pVal), (LPSTR) pLdapVal, 10);
            *pulLdapValLen = KCCSIM_STRMEMSIZE ((LPSTR) pLdapVal);
            break;

        case SYNTAX_TIME_TYPE:
            // Convert the time using strftime.
            pLdapVal = KCCSimAlloc (18);
            DSTimeToUtcSystemTime (
                *((SYNTAX_TIME *) pVal),
                &systemTime
                );
            tmTime.tm_year = systemTime.wYear - 1900;
            tmTime.tm_mon = systemTime.wMonth - 1;
            tmTime.tm_wday = systemTime.wDayOfWeek;
            tmTime.tm_mday = systemTime.wDay;
            tmTime.tm_hour = systemTime.wHour;
            tmTime.tm_min = systemTime.wMinute;
            tmTime.tm_sec = systemTime.wSecond;
            tmTime.tm_isdst = 0;
            tmTime.tm_yday = 0;
            strftime ((LPSTR) pLdapVal, 17, "%Y%m%d%H%M%S.0Z", &tmTime);
            *pulLdapValLen = KCCSIM_STRMEMSIZE ((LPSTR) pLdapVal);
            break;

        case SYNTAX_UNICODE_TYPE:
            // Convert wide string to narrow string.
            pLdapVal = (PBYTE) KCCSimAllocNarrowStr (CP_UTF8, (SYNTAX_UNICODE *) pVal);
            *pulLdapValLen = KCCSIM_STRMEMSIZE ((LPSTR) pLdapVal);
            break;

        case SYNTAX_I8_TYPE:
            // Convert large integer to narrow string.
            pLdapVal = KCCSimAlloc (sizeof (CHAR) * (1 + KCCSIM_MAX_LITOA_CHARS));
            litoa (*((SYNTAX_I8 *) pVal), pLdapVal, 10);
            *pulLdapValLen = KCCSIM_STRMEMSIZE ((LPSTR) pLdapVal);
            break;

        case SYNTAX_DISTNAME_BINARY_TYPE:
            KCCSimAllocConvertDNBToLdapVal(
                pVal,
                pulLdapValLen,
                &pLdapVal
                );
            break;

        // All the rest can be done using block-copy.
        case SYNTAX_UNDEFINED_TYPE:
        case SYNTAX_CASE_STRING_TYPE:
        case SYNTAX_NOCASE_STRING_TYPE:
        case SYNTAX_PRINT_CASE_STRING_TYPE:
        case SYNTAX_NUMERIC_STRING_TYPE:
        case SYNTAX_OCTET_STRING_TYPE:
        case SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE:
        case SYNTAX_SID_TYPE:
            *pulLdapValLen = ulValLen;
            pLdapVal = KCCSimAlloc (*pulLdapValLen);
            memcpy (pLdapVal, pVal, ulValLen);
            break;

        default:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_UNSUPPORTED_SYNTAX_TYPE
                );
            pLdapVal = NULL;
            break;

    }

    *ppLdapVal = pLdapVal;
}

VOID
KCCSimAddMods (
    IN  LPCWSTR                 pwszFn,
    IN  PSIM_ENTRY              pEntry,
    IN  PLDAPModW *             pLdapMods
    )
/*++

Routine Description:

    Inserts an array of PLDAPModW structures into the directory.

Arguments:

    pwszFn              - The filename of the LDIF file being processed.
                          Used for error reporting purposes.
    pEntry              - The entry into which to insert the mods.
    pLdapMods           - NULL-terminated array of PLDAPModW structures.

Return Value:

    None.

--*/
{
    ATTRTYP                     attrType;
    ULONG                       mod_op;

    SIM_ATTREF                  attRef;
    ULONG                       ulAttrAt, ulValAt;

    ULONG                       ulValLen;
    PBYTE                       pVal;

    for (ulAttrAt = 0; pLdapMods[ulAttrAt] != NULL; ulAttrAt++) {

        if (!(pLdapMods[ulAttrAt]->mod_op & LDAP_MOD_BVALUES)) {
            // We don't support string values yet, since ldifldap
            // only returns bervals.
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_LDAPMOD_STRINGVAL_NOT_SUPPORTED
                );
        }

        // Get this attribute
        attrType = KCCSimStringToAttrType (pLdapMods[ulAttrAt]->mod_type);
        KCCSimGetAttribute (
            pEntry,
            attrType,
            &attRef
            );
        mod_op = pLdapMods[ulAttrAt]->mod_op & (~LDAP_MOD_BVALUES);

        switch (mod_op) {

            case LDAP_MOD_REPLACE:
                // Replace this attribute, so delete the existing one.
                if (attRef.pAttr != NULL) {
                    KCCSimRemoveAttribute (&attRef);
                }
                // Deliberate fall-through to LDAP_MOD_ADD:

            case LDAP_MOD_ADD:
                if (attRef.pAttr == NULL) {
                    // Create this attribute if it doesn't exist.
                    KCCSimNewAttribute (
                        pEntry,
                        attrType,
                        &attRef
                        );
                }
                Assert (attRef.pAttr != NULL);
                for (ulValAt = 0;
                     pLdapMods[ulAttrAt]->mod_bvalues[ulValAt] != NULL;
                     ulValAt++) {
                    KCCSimAllocConvertFromLdapVal (
                        pwszFn,
                        pEntry->pdn->StringName,
                        attrType,
                        pLdapMods[ulAttrAt]->mod_bvalues[ulValAt]->bv_len,
                        pLdapMods[ulAttrAt]->mod_bvalues[ulValAt]->bv_val,
                        &ulValLen,
                        &pVal
                        );
                    if( NULL!=pVal ) {
                        KCCSimAddValueToAttribute (
                            &attRef,
                            ulValLen,
                            pVal
                            );
                    }
                }
                break;

            case LDAP_MOD_DELETE:
                if (attRef.pAttr == NULL) {
                    break;
                }
                if (pLdapMods[ulAttrAt]->mod_bvalues == NULL) {
                    // No values specified; delete the entire attribute.
                    KCCSimRemoveAttribute (&attRef);
                } else {
                    // Delete specific attribute values.
                    for (ulValAt = 0;
                         pLdapMods[ulAttrAt]->mod_bvalues[ulValAt] != NULL;
                         ulValAt++) {
                        KCCSimAllocConvertFromLdapVal (
                            pwszFn,
                            pEntry->pdn->StringName,
                            attrType,
                            pLdapMods[ulAttrAt]->mod_bvalues[ulValAt]->bv_len,
                            pLdapMods[ulAttrAt]->mod_bvalues[ulValAt]->bv_val,
                            &ulValLen,
                            &pVal
                            );
                        KCCSimRemoveValueFromAttribute (
                            &attRef,
                            pLdapMods[ulAttrAt]->mod_bvalues[ulValAt]->bv_len,
                            pLdapMods[ulAttrAt]->mod_bvalues[ulValAt]->bv_val
                            );
                        if (pVal != NULL) {
                            KCCSimFree (pVal);
                        }
                    }
                }
                break;

            default:
                KCCSimException (
                    KCCSIM_ETYPE_INTERNAL,
                    KCCSIM_ERROR_LDAPMOD_UNSUPPORTED_MODIFY_CHOICE
                    );
                break;

        }

    }

}

PLDAPModW
KCCSimAllocAttrToLdapMod (
    IN  ULONG                       mod_op,
    IN  LPCWSTR                     pwszLdapDisplayName,
    IN  ATTR *                      pAttr
    )
/*++

Routine Description:

    Converts an ATTR structure to a PLDAPModW.  This function
    allocates space to hold the PLDAPModW structure.

Arguments:

    mod_op              - The operation being performed.
    pwszLdapDisplayName - LDAP display name of the attribute.
    pAttr               - Pointer to the attribute in question.
                          May be NULL to indicate no attribute values.

Return Value:

    The newly allocated PLDAPModW.

--*/
{
    PLDAPModW                       pLdapMod;
    ULONG                           ulValAt;

    pLdapMod = KCCSIM_NEW (LDAPModW);
    pLdapMod->mod_op = mod_op | LDAP_MOD_BVALUES;
    pLdapMod->mod_type = KCCSIM_WCSDUP (pwszLdapDisplayName);

    if (pAttr == NULL) {
        pLdapMod->mod_bvalues = NULL;
    } else {

        pLdapMod->mod_bvalues = KCCSIM_NEW_ARRAY
            (struct berval *, 1 + pAttr->AttrVal.valCount);

        for (ulValAt = 0; ulValAt < pAttr->AttrVal.valCount; ulValAt++) {

            pLdapMod->mod_bvalues[ulValAt] = KCCSIM_NEW (struct berval);
            KCCSimAllocConvertToLdapVal (
                pAttr->attrTyp,
                pAttr->AttrVal.pAVal[ulValAt].valLen,
                pAttr->AttrVal.pAVal[ulValAt].pVal,
                &(pLdapMod->mod_bvalues[ulValAt]->bv_len),
                &(pLdapMod->mod_bvalues[ulValAt]->bv_val)
                );

        }

        pLdapMod->mod_bvalues[ulValAt] = NULL;

    }

    return pLdapMod;
}

VOID
KCCSimFreeLdapMods (
    IN  PLDAPModW *                 ppLdapMod
    )
/*++

Routine Description:

    Frees a NULL-terminated array of PLDAPModWs.

Arguments:

    ppLdapMod           - The array to free.

Return Value:

    None.

--*/
{
    ULONG                           ulModAt, ulValAt;

    if (ppLdapMod == NULL) {
        return;
    }

    for (ulModAt = 0;
         ppLdapMod[ulModAt] != NULL;
         ulModAt++) {

        Assert (ppLdapMod[ulModAt]->mod_op & LDAP_MOD_BVALUES);

        if (ppLdapMod[ulModAt]->mod_type != NULL) {
            KCCSimFree (ppLdapMod[ulModAt]->mod_type);
        }

        if (ppLdapMod[ulModAt]->mod_bvalues != NULL) {

            for (ulValAt = 0;
                 ppLdapMod[ulModAt]->mod_bvalues[ulValAt] != NULL;
                 ulValAt++) {

                if (ppLdapMod[ulModAt]->mod_bvalues[ulValAt]->bv_val != NULL) {
                    KCCSimFree (ppLdapMod[ulModAt]->mod_bvalues[ulValAt]->bv_val);
                }
                KCCSimFree (ppLdapMod[ulModAt]->mod_bvalues[ulValAt]);

            }
            KCCSimFree (ppLdapMod[ulModAt]->mod_bvalues);

        }

        KCCSimFree (ppLdapMod[ulModAt]);

    }

    KCCSimFree (ppLdapMod);
}

/***

    The next several routines are concerned with maintaining a list of
    changes to the directory.  KCCSim supports an export mode where only
    the changes made to the directory since the last export are reported.
    Every time a function (such as a SimDir* API) modifies the simulated
    directory, it calls KCCSimLogDirectory*.  The change is then added
    to a global list of changes.  This global list is written out when
    KCCSimExportChanges () is called.

***/

struct _KCCSIM_CHANGE {
    LPWSTR                          pwszDn;
    int                             operation;
    LDAPModW **                     ppLdapMod;
    struct _KCCSIM_CHANGE *         next;
};

struct _KCCSIM_CHANGE *             gMostRecentChange = NULL;

VOID
KCCSimFreeChanges (
    IN  struct _KCCSIM_CHANGE *     pChanges
    )
/*++

Routine Description:

    Frees a list of changes.

Arguments:

    pChanges            - The list to free.

Return Value:

    None.

--*/
{
    struct _KCCSIM_CHANGE *         pChangeNext;
    ULONG                           ulModAt;

    while (pChanges != NULL) {

        pChangeNext = pChanges->next;

        if (pChanges->pwszDn != NULL) {
            KCCSimFree (pChanges->pwszDn);
        }
        KCCSimFreeLdapMods (pChanges->ppLdapMod);
        KCCSimFree (pChanges);

        pChanges = pChangeNext;

    }
}

VOID
KCCSimLogDirectoryAdd (
    IN  const DSNAME *              pdn,
    IN  ATTRBLOCK *                 pAddBlock
    )
/*++

Routine Description:

    Logs an add to the global change list.

Arguments:

    pdn                 - The affected DN.
    pAddBlock           - The ATTRBLOCK corresponding to the add.

Return Value:

    None.

--*/
{
    struct _KCCSIM_CHANGE *         pChange;
    ULONG                           ulAttrAt, ulValAt;

    Assert (pAddBlock != NULL);

    pChange = KCCSIM_NEW (struct _KCCSIM_CHANGE);
    pChange->pwszDn = KCCSIM_WCSDUP (pdn->StringName);
    pChange->operation = CHANGE_ADD;
    pChange->ppLdapMod = KCCSIM_NEW_ARRAY (PLDAPModW, 1 + pAddBlock->attrCount);

    for (ulAttrAt = 0; ulAttrAt < pAddBlock->attrCount; ulAttrAt++) {

        pChange->ppLdapMod[ulAttrAt] =
        KCCSimAllocAttrToLdapMod (
            LDAP_MOD_ADD,
            KCCSimAttrTypeToString (pAddBlock->pAttr[ulAttrAt].attrTyp),
            &(pAddBlock->pAttr[ulAttrAt])
            );

    }

    pChange->ppLdapMod[ulAttrAt] = NULL;

    pChange->next = gMostRecentChange;
    gMostRecentChange = pChange;
}

VOID
KCCSimLogDirectoryRemove (
    IN  const DSNAME *              pdn
    )
/*++

Routine Description:

    Logs a remove to the global change list.

Arguments:

    pdn                 - The affected DN.

Return Value:

    None.

--*/
{
    struct _KCCSIM_CHANGE *         pChange;
    pChange = KCCSIM_NEW (struct _KCCSIM_CHANGE);
    pChange->pwszDn = KCCSIM_WCSDUP (pdn->StringName);
    pChange->operation = CHANGE_DEL;
    pChange->ppLdapMod = NULL;

    pChange->next = gMostRecentChange;
    gMostRecentChange = pChange;
}

VOID
KCCSimLogDirectoryModify (
    IN  const DSNAME *              pdn,
    IN  ULONG                       ulCount,
    IN  ATTRMODLIST *               pModifyList
    )
/*++

Routine Description:

    Logs a modify to the global change list.

Arguments:

    pdn                 - The affected DN.
    ulCount             - The number of modifications present.
    pModifyList         - The list of modifications.

Return Value:

    None.

--*/
{
    ATTRMODLIST *                   pModifyAt;
    struct _KCCSIM_CHANGE *         pChange;
    LPCWSTR                         pwszLdapDisplayName;
    ULONG                           ulModAt;

    Assert (ulCount > 0);

    pChange = KCCSIM_NEW (struct _KCCSIM_CHANGE);
    pChange->pwszDn = KCCSIM_WCSDUP (pdn->StringName);
    pChange->operation = CHANGE_MOD;
    pChange->ppLdapMod = KCCSIM_NEW_ARRAY (PLDAPModW, 1 + ulCount);

    pModifyAt = pModifyList;
    for (ulModAt = 0; ulModAt < ulCount; ulModAt++) {

        // If ulCount is correct, we should still be non-null
        Assert (pModifyAt != NULL);
        pwszLdapDisplayName = KCCSimAttrTypeToString (pModifyAt->AttrInf.attrTyp);

        switch (pModifyAt->choice) {

            case AT_CHOICE_ADD_ATT:
                pChange->ppLdapMod[ulModAt] =
                KCCSimAllocAttrToLdapMod (
                    LDAP_MOD_ADD,
                    pwszLdapDisplayName,
                    &(pModifyAt->AttrInf)
                    );
                break;

            case AT_CHOICE_REMOVE_ATT:
                pChange->ppLdapMod[ulModAt] =
                KCCSimAllocAttrToLdapMod (
                    LDAP_MOD_DELETE,
                    pwszLdapDisplayName,
                    NULL
                    );
                break;

            case AT_CHOICE_ADD_VALUES:
                pChange->ppLdapMod[ulModAt] =
                KCCSimAllocAttrToLdapMod (
                    LDAP_MOD_ADD,
                    pwszLdapDisplayName,
                    &(pModifyAt->AttrInf)
                    );
                break;

            case AT_CHOICE_REMOVE_VALUES:
                pChange->ppLdapMod[ulModAt] =
                KCCSimAllocAttrToLdapMod (
                    LDAP_MOD_DELETE,
                    pwszLdapDisplayName,
                    &(pModifyAt->AttrInf)
                    );
                break;

            case AT_CHOICE_REPLACE_ATT:
                pChange->ppLdapMod[ulModAt] =
                KCCSimAllocAttrToLdapMod (
                    LDAP_MOD_REPLACE,
                    pwszLdapDisplayName,
                    &(pModifyAt->AttrInf)
                    );
                break;

            default:
                KCCSimException (
                    KCCSIM_ETYPE_INTERNAL,
                    KCCSIM_ERROR_UNSUPPORTED_MODIFY_CHOICE
                    );
                break;

        }

        pModifyAt = pModifyAt->pNextMod;

    }

    pChange->ppLdapMod[ulModAt] = NULL;

    pChange->next = gMostRecentChange;
    gMostRecentChange = pChange;
}

VOID
KCCSimLogSingleAttValChange (
    IN  PSIM_ATTREF                 pAttRef,
    IN  ULONG                       ulValLen,
    IN  PBYTE                       pValData,
    IN  USHORT                      choice
    )
/*++

Routine Description:

    Shortcut routine to log a single modification of an attribute value.

Arguments:

    pAttRef             - A valid reference to the attribute being modified.
    ulValLen            - Length of the buffer containing the affected value.
    pValData            - The affected attribute value.
    choice              - One of AT_CHOICE_*.

Return Value:

    None.

--*/
{
    ATTRMODLIST                     attrModList;

    Assert (KCCSimAttRefIsValid (pAttRef));
    Assert (pValData != NULL);

    attrModList.pNextMod = NULL;
    attrModList.choice = choice;
    attrModList.AttrInf.attrTyp = pAttRef->pAttr->attrType;
    attrModList.AttrInf.AttrVal.valCount = 1;
    attrModList.AttrInf.AttrVal.pAVal = KCCSIM_NEW (ATTRVAL);
    attrModList.AttrInf.AttrVal.pAVal[0].valLen = ulValLen;
    attrModList.AttrInf.AttrVal.pAVal[0].pVal = pValData;
    KCCSimLogDirectoryModify (
        pAttRef->pEntry->pdn,
        1,
        &attrModList
        );
    KCCSimFree (attrModList.AttrInf.AttrVal.pAVal);
}    

VOID
KCCSimHandleLdifError (
    IN  LPCWSTR                 pwszFn,
    IN  LDIF_Error *            pLdifError
    )
/*++

Routine Description:

    Checks the return struct of an LDIF_* call, and takes the
    appropriate action (i.e. raises an exception on error.)

Arguments:

    pwszFn              - The LDIF file being processed.  Used for error
                          reporting purposes.
    pLdifError          - The error struct.

Return Value:

    None.

--*/
{
    WCHAR                       wszLtowBuf[1+KCCSIM_MAX_LTOA_CHARS];

    switch (pLdifError->error_code) {

        case LL_SUCCESS:
            break;

        case LL_SYNTAX:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_LDIF_SYNTAX,
                pwszFn,
                _ltow (pLdifError->line_number, wszLtowBuf, 10)
                );
            break;

        case LL_FILE_ERROR:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_LDIF_FILE_ERROR,
                pwszFn
                );
            break;

        default:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_LDIF_UNEXPECTED,
                pwszFn,
                _ultow (pLdifError->error_code, wszLtowBuf, 16)
                );
            break;

    }
}

VOID
KCCSimLoadLdif (
    IN  LPCWSTR                 pwszFn
    )
/*++

Routine Description:

    Loads an ldif file into the directory.

Arguments:

    pwszFn              - The ldif file to load.

Return Value:

    None.

--*/
{
    LDIF_Error                  ldifError;
    LDIF_Record                 ldifRecord;
    PDSNAME                     pdn;
    PSIM_ENTRY                  pEntry;
    struct change_list *        changeAt;
    ULONG                       ulCount = 0;

    RtlZeroMemory (&ldifRecord, sizeof (LDIF_Record));

    // This is an ugly typecast; LDIF_InitializeImport should
    // accept a constant string as the filename.
    ldifError = LDIF_InitializeImport (NULL, (LPWSTR) pwszFn, NULL, NULL, NULL);
    if (ldifError.error_code != LL_SUCCESS) {
        KCCSimHandleLdifError (pwszFn, &ldifError);
    }

    do {

        ldifError = LDIF_Parse (&ldifRecord);

        if (ldifError.error_code != LL_SUCCESS &&
            ldifError.error_code != LL_EOF) {
            KCCSimHandleLdifError (pwszFn, &ldifError);
        }

        pdn = KCCSimAllocDsname (ldifRecord.dn);

        if (ldifRecord.fIsChangeRecord) {

            changeAt = ldifRecord.changes;
            while (changeAt != NULL) {
                switch (changeAt->operation) {

                    case CHANGE_ADD:
                        if (KCCSimDsnameToEntry (pdn, KCCSIM_NO_OPTIONS) != NULL) {
                            KCCSimPrintMessage (
                                KCCSIM_WARNING_LDIF_ENTRY_ALREADY_EXISTS,
                                pwszFn,
                                pdn->StringName
                                );
                        }
                        pEntry = KCCSimDsnameToEntry (pdn, KCCSIM_WRITE);
                        KCCSimAddMods (pwszFn, pEntry, changeAt->mods_mem);
                        break;

                    case CHANGE_DEL:
                        pEntry = KCCSimDsnameToEntry (pdn, KCCSIM_NO_OPTIONS);
                        if (pEntry == NULL) {
                            KCCSimPrintMessage (
                                KCCSIM_WARNING_LDIF_NO_ENTRY_TO_DELETE,
                                pwszFn,
                                pdn->StringName
                                );
                            break;
                        }
                        KCCSimRemoveEntry (&pEntry);
                        break;

                    case CHANGE_MOD:
                        pEntry = KCCSimDsnameToEntry (pdn, KCCSIM_NO_OPTIONS);
                        if (pEntry == NULL) {
                            KCCSimPrintMessage (
                                KCCSIM_WARNING_LDIF_NO_ENTRY_TO_MODIFY,
                                pwszFn,
                                pdn->StringName
                                );
                            break;
                        }
                        KCCSimAddMods (pwszFn, pEntry, changeAt->mods_mem);
                        break;

                    default:
                        KCCSimException (
                            KCCSIM_ETYPE_INTERNAL,
                            KCCSIM_ERROR_UNSUPPORTED_LDIF_OPERATION
                            );
                        break;

                }
                changeAt = changeAt->next;
            }

        } else {        // !fIsChangeRecord

            pEntry = KCCSimDsnameToEntry (pdn, KCCSIM_NO_OPTIONS);
            if (pEntry != NULL) {
                KCCSimPrintMessage (
                    KCCSIM_WARNING_LDIF_REPLACING_TREE,
                    pwszFn,
                    pdn->StringName
                    );
                KCCSimRemoveEntry (&pEntry);
            }
            pEntry = KCCSimDsnameToEntry (pdn, KCCSIM_WRITE);
            KCCSimAddMods (pwszFn, pEntry, ldifRecord.content);

        }

        KCCSimFree (pdn);
        LDIF_ParseFree (&ldifRecord);

    } while (ldifError.error_code != LL_EOF);

    LDIF_CleanUp();
}

// A string is safe if:
// Every character is between ASCII 0x20 and 0x7e
// The first character is neither ':', ' ' nor '<'.
BOOL
KCCSimIsSafe (
    IN  LPCSTR                      psz
    )
/*++

Routine Description:

    Verifies that a string is safe to write into an LDIF file.  A string
    is safe if both of these conditions are satisfied:
        (1) Every character is between ASCII 0x20 and 0x78
        (2) The first character is neither ':', ' ' nor '<'.

Arguments:

    psz                 - The string to verify.

Return Value:

    TRUE if the string is safe.

--*/
{
    ULONG                           ul;

    Assert (psz != NULL);

    if (psz[0] == ':' ||
        psz[0] == ' ' ||
        psz[0] == '<') {
        return FALSE;
    }

    for (ul = 0; psz[ul] != '\0'; ul++) {
        if (psz[ul] < 0x20 || psz[ul] > 0x7e) {
            return FALSE;
        }
    }

    return TRUE;
}

VOID
KCCSimExportVals (
    IN  FILE *                      fpOut,
    IN  PLDAPModW                   pLdapMod
    )
/*++

Routine Description:

    Exports the data contained in an LDAPModW structure to
    an output file.

Arguments:

    fpOut               - File pointer of the output file.
    pLdapMod            - Pointer to the LDAPModW to export.

Return Value:

    None.

--*/
{
    ULONG                           ulValAt;

    NTSTATUS                        ntStatus;
    PWSTR                           pwsz;
    ULONG                           cb;
    BOOL                            bBinary;
    
    Assert (pLdapMod->mod_op & LDAP_MOD_BVALUES);

    if (pLdapMod->mod_bvalues == NULL) {
        return;
    }

    for (ulValAt = 0;
         pLdapMod->mod_bvalues[ulValAt] != NULL;
         ulValAt++) {

        fwprintf (fpOut, L"%s:", pLdapMod->mod_type);
        switch (KCCSimAttrSyntaxType (KCCSimStringToAttrType (pLdapMod->mod_type))) {

            case SYNTAX_DISTNAME_TYPE:
            case SYNTAX_DISTNAME_BINARY_TYPE:
            case SYNTAX_OBJECT_ID_TYPE:
            case SYNTAX_CASE_STRING_TYPE:
            case SYNTAX_NOCASE_STRING_TYPE:
            case SYNTAX_PRINT_CASE_STRING_TYPE:
            case SYNTAX_NUMERIC_STRING_TYPE:
            case SYNTAX_BOOLEAN_TYPE:
            case SYNTAX_INTEGER_TYPE:
            case SYNTAX_TIME_TYPE:
            case SYNTAX_UNICODE_TYPE:
            case SYNTAX_I8_TYPE:
                bBinary = !KCCSimIsSafe (
                    (LPSTR) pLdapMod->mod_bvalues[ulValAt]->bv_val);
                break;

            case SYNTAX_UNDEFINED_TYPE:
            case SYNTAX_OCTET_STRING_TYPE:
            case SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE:
            case SYNTAX_SID_TYPE:
                bBinary = TRUE;
                break;

            default:
                KCCSimException (
                    KCCSIM_ETYPE_INTERNAL,
                    KCCSIM_ERROR_UNSUPPORTED_SYNTAX_TYPE,
                    pLdapMod->mod_type
                    );
                bBinary = TRUE;
                break;

        }

        if (bBinary) {

            pwsz = base64encode (
                pLdapMod->mod_bvalues[ulValAt]->bv_val,
                pLdapMod->mod_bvalues[ulValAt]->bv_len
                );
            Assert( pwsz != NULL );
            fwprintf (
                fpOut,
                L": %s\n",
                pwsz
                );
            MemFree( pwsz );

        } else {

            fwprintf (
                fpOut,
                L" %S\n",
                (LPSTR) pLdapMod->mod_bvalues[ulValAt]->bv_val
                );

        }

    }

}

VOID
KCCSimStubExport (
    IN  FILE *                      fpOut,
    IN  LDIF_Record *               pLdifRecord
    )
/*++

Routine Description:

    Stub routine to export an LDIF_Record.  This shouldn't be necessary;
    a routine with the same functionality should be a part of ldifldap.
    (As is, this results in a lot of duplicate code.)

Arguments:

    fpOut               - File pointer of the output file.
    pLdifRecord         - The ldif record to export.

Return Value:

    None.

--*/
{
    struct change_list *            changeAt;
    ULONG                           ulModAt;

    fwprintf (
        fpOut,
        L"dn: %s\n",
        pLdifRecord->dn
        );

    if (pLdifRecord->fIsChangeRecord) {

        for (changeAt = pLdifRecord->changes;
             changeAt != NULL;
             changeAt = changeAt->next) {

            switch (changeAt->operation) {

                case CHANGE_ADD:
                    fwprintf (fpOut, L"changetype: add\n");
                    for (ulModAt = 0;
                         changeAt->mods_mem[ulModAt] != NULL;
                         ulModAt++) {
                        KCCSimExportVals (fpOut, changeAt->mods_mem[ulModAt]);
                    }
                    break;

                case CHANGE_DEL:
                    fwprintf (fpOut, L"changetype: delete\n");
                    break;

                case CHANGE_MOD:
                    fwprintf (fpOut, L"changetype: modify\n");
                    for (ulModAt = 0;
                         changeAt->mods_mem[ulModAt] != NULL;
                         ulModAt++) {
                        switch (changeAt->mods_mem[ulModAt]->mod_op & (~LDAP_MOD_BVALUES)) {
                            case LDAP_MOD_ADD:
                                fwprintf (fpOut, L"add");
                                break;
                            case LDAP_MOD_DELETE:
                                fwprintf (fpOut, L"delete");
                                break;
                            case LDAP_MOD_REPLACE:
                                fwprintf (fpOut, L"replace");
                                break;
                            default:
                                Assert (FALSE);
                                break;
                        }
                        fwprintf (fpOut, L": %s\n", changeAt->mods_mem[ulModAt]->mod_type);
                        KCCSimExportVals (fpOut, changeAt->mods_mem[ulModAt]);
                        fwprintf (fpOut, L"-\n");
                    }
                    break;

                default:
                    Assert (FALSE);
                    break;

            }

        }

    } else {    // !fIsChangeRecord

        for (ulModAt = 0;
             pLdifRecord->content[ulModAt] != NULL;
             ulModAt++) {
            KCCSimExportVals (fpOut, pLdifRecord->content[ulModAt]);
        }

    }

    fwprintf (fpOut, L"\n");

}

BOOL
KCCSimExportChanges (
    IN  LPCWSTR                     pwszFn,
    IN  BOOL                        bOverwrite
    )
/*++

Routine Description:

    Exports the global list of changes to the directory.  This function
    also empties the list.

    This function will package the changes into an LDIF_Record before
    exporting; this is done to maintain future compatibility with ldif
    export routines.

Arguments:

    pwszFn              - Filename of the export file.
    bOverwrite          - If TRUE, the file will be overwritten if it exists.
                          If FALSE and the file exists, changes will be
                          appended to the end of the file.

Return Value:

    TRUE if changes were exported.
    FALSE if there were no changes to export.

--*/
{
    FILE *                          fpOut;
    struct _KCCSIM_CHANGE *         pChangeReversed;
    struct _KCCSIM_CHANGE *         pChangeThis;
    struct _KCCSIM_CHANGE *         pChangeLessRecent;

    LDIF_Record                     ldifRecord;
    struct change_list              ldifChange;

    if (gMostRecentChange == NULL) {
        return FALSE;
    }

    fpOut = _wfopen (pwszFn, bOverwrite ? L"wt" : L"a+t");
    if (fpOut == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_WIN32,
            GetLastError ()
            );
    }

    // First we reverse the list of changes.  In the reversed list,
    // pChangeReversed will be the oldest change.
    pChangeThis = gMostRecentChange;
    pChangeReversed = NULL;
    while (pChangeThis != NULL) {
        pChangeLessRecent = pChangeThis->next;
        pChangeThis->next = pChangeReversed;
        pChangeReversed = pChangeThis;
        pChangeThis = pChangeLessRecent;
    }

    // Now package everything into an LDIF_Record
    ldifChange.next = NULL;
    ldifChange.deleteold = 0;
    ldifRecord.fIsChangeRecord = TRUE;
    ldifRecord.changes = &ldifChange;

    for (pChangeThis = pChangeReversed;
         pChangeThis != NULL;
         pChangeThis = pChangeThis->next) {

        ldifRecord.dn = pChangeThis->pwszDn;
        ldifRecord.changes->operation = pChangeThis->operation;
        ldifRecord.changes->mods_mem = pChangeThis->ppLdapMod;
        KCCSimStubExport (
            fpOut,
            &ldifRecord
            );

    }

    KCCSimFreeChanges (pChangeReversed);
    gMostRecentChange = NULL;

    fclose (fpOut);

    return TRUE;
}

BOOL
KCCSimIsAttrOkForConfigOnly (
    IN  PSIM_ATTRIBUTE              pAttr
    )
{
    return (
           pAttr->attrType != ATT_OBJECT_GUID
        && pAttr->attrType != ATT_OBJ_DIST_NAME
        && pAttr->attrType != ATT_WHEN_CREATED
        && pAttr->attrType != ATT_WHEN_CHANGED
        );
}

BOOL
KCCSimIsEntryOkForConfigOnly (
    IN  PSIM_ENTRY                  pEntry
    )
{
    SIM_ATTREF                      attRef;
    ATTRTYP                         attrType;

    // In config-only mode, we only export certain object classes.
    if (!KCCSimGetAttribute (pEntry, ATT_OBJECT_CLASS, &attRef)) {
        return FALSE;
    }
    // Get the most specific object class.
    attrType = KCCSimUpdateObjClassAttr (&attRef);

    // Object classes that we always include:
    if (attrType == CLASS_SITE               ||
        attrType == CLASS_NTDS_SITE_SETTINGS ||
        attrType == CLASS_SERVERS_CONTAINER  ||
        attrType == CLASS_SERVER             ||
        attrType == CLASS_NTDS_DSA           ||
        attrType == CLASS_NTDS_CONNECTION    ||
        attrType == CLASS_SITE_LINK
        ) {
        return TRUE;
    }

    // Object classes that we sometimes include:

    if (attrType == CLASS_CROSS_REF &&
        KCCSimGetAttribute (pEntry, ATT_SYSTEM_FLAGS, &attRef) &&
        (*((SYNTAX_INTEGER *) attRef.pAttr->pValFirst->pVal) & FLAG_CR_NTDS_DOMAIN)
        ) {
        // It's a cross-ref object for a domain.
        return TRUE;
    }

    // Reject everything else.
    return FALSE;
}

VOID
KCCSimRecursiveExport (
    IN  FILE *                      fpOut,
    IN  BOOL                        bExportConfigOnly,
    IN  PSIM_ENTRY                  pEntry
    )
/*++

Routine Description:

    Recursively exports the entire directory.

Arguments:

    fpOut               - File pointer of the output file.
    bExportConfigOnly   - TRUE if we should only export configuration
                          data so that the result can be loaded onto
                          a real server later.
    pEntry              - The entry to start at.

Return Value:

    None.

--*/
{
    PSIM_ENTRY                      pChildAt;
    PSIM_ATTRIBUTE                  pAttr;
    PSIM_VALUE                      pVal;
    SIM_ATTREF                      attRef;
    ULONG                           ulNumAttrs, ulNumVals, ulAttrAt, ulValAt;

    ATTRTYP                         objClassToUse;

    LDIF_Record                     ldifRecord;

    if (!bExportConfigOnly ||
        KCCSimIsEntryOkForConfigOnly (pEntry)) {

        // First we export this entry.

        ldifRecord.dn = pEntry->pdn->StringName;
        ldifRecord.fIsChangeRecord = FALSE;

        // Count the number of attributes.
        ulNumAttrs = 0;
        for (pAttr = pEntry->pAttrFirst;
             pAttr != NULL;
             pAttr = pAttr->next) {
            if (!bExportConfigOnly ||
                KCCSimIsAttrOkForConfigOnly (pAttr)) {
                ulNumAttrs++;
            }
        }
        ldifRecord.content = KCCSIM_NEW_ARRAY (PLDAPModW, 1 + ulNumAttrs);

        ulAttrAt = 0;
        for (pAttr = pEntry->pAttrFirst;
             pAttr != NULL;
             pAttr = pAttr->next) {

            if (bExportConfigOnly &&
                !KCCSimIsAttrOkForConfigOnly (pAttr)) {
                continue;
            }

            Assert (ulAttrAt < ulNumAttrs);
            ldifRecord.content[ulAttrAt] = KCCSIM_NEW (LDAPModW);
            ldifRecord.content[ulAttrAt]->mod_op = LDAP_MOD_ADD | LDAP_MOD_BVALUES;
            ldifRecord.content[ulAttrAt]->mod_type =
                KCCSIM_WCSDUP (KCCSimAttrTypeToString (pAttr->attrType));
        
            // Count the number of attribute values.
            if (pAttr->attrType == ATT_OBJECT_CLASS) {
                ulNumVals = 1;
            } else {
                ulNumVals = 0;
                for (pVal = pAttr->pValFirst;
                     pVal != NULL;
                     pVal = pVal->next) {
                    ulNumVals++;
                }
            }
            ldifRecord.content[ulAttrAt]->mod_bvalues =
                KCCSIM_NEW_ARRAY (struct berval *, 1 + ulNumVals);

            if (pAttr->attrType == ATT_OBJECT_CLASS) {

                // Get the most specific object class.
                attRef.pEntry = pEntry;
                attRef.pAttr = pAttr;
                objClassToUse = KCCSimUpdateObjClassAttr (&attRef);
                ldifRecord.content[ulAttrAt]->mod_bvalues[0] =
                    KCCSIM_NEW (struct berval);
                KCCSimAllocConvertToLdapVal (
                    ATT_OBJECT_CLASS,
                    sizeof (ATTRTYP),
                    (PBYTE) &objClassToUse,
                    &(ldifRecord.content[ulAttrAt]->mod_bvalues[0]->bv_len),
                    &(ldifRecord.content[ulAttrAt]->mod_bvalues[0]->bv_val)
                    );

            } else {

                ulValAt = 0;
                for (pVal = pAttr->pValFirst;
                     pVal != NULL;
                     pVal = pVal->next) {

                    Assert (ulValAt < ulNumVals);
                    ldifRecord.content[ulAttrAt]->mod_bvalues[ulValAt] =
                        KCCSIM_NEW (struct berval);
                    KCCSimAllocConvertToLdapVal (
                        pAttr->attrType,
                        pVal->ulLen,
                        pVal->pVal,
                        &(ldifRecord.content[ulAttrAt]->mod_bvalues[ulValAt]->bv_len),
                        &(ldifRecord.content[ulAttrAt]->mod_bvalues[ulValAt]->bv_val)
                        );
                    ulValAt++;

                }
                Assert (ulValAt == ulNumVals);
        
            }

            ldifRecord.content[ulAttrAt]->mod_bvalues[ulNumVals] = NULL;
            ulAttrAt++;

        }
        Assert (ulAttrAt == ulNumAttrs);
    
        ldifRecord.content[ulNumAttrs] = NULL;

        KCCSimStubExport (fpOut, &ldifRecord);
        KCCSimFreeLdapMods (ldifRecord.content);

    }

    // Recursively export this entry's children.
    for (pChildAt = pEntry->children;
         pChildAt != NULL;
         pChildAt = pChildAt->next) {

        KCCSimRecursiveExport (fpOut, bExportConfigOnly, pChildAt);

    }
}

VOID
KCCSimExportWholeDirectory (
    IN  LPCWSTR                     pwszFn,
    IN  BOOL                        bExportConfigOnly
    )
/*++

Routine Description:

    Exports the entire directory.

Arguments:

    pwszFn              - Filename of the output file.
    bExportConfigOnly   - TRUE if we should only export configuration
                          data so that the result can be loaded onto
                          a real server later.

Return Value:

    None.

--*/
{
    FILE *                          fpOut;
    PSIM_ENTRY                      pStartEntry;

    fpOut = _wfopen (pwszFn, L"wt");
    if (fpOut == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_WIN32,
            GetLastError ()
            );
    }

    __try {
        pStartEntry = KCCSimDsnameToEntry (NULL, KCCSIM_NO_OPTIONS);
        KCCSimRecursiveExport (fpOut, bExportConfigOnly, pStartEntry);
    } __finally {
        fclose (fpOut);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\sim\runkcc.cxx ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    runkcc.cxx

ABSTRACT:

    C++ file to drive the KCC.  The exposed (extern "C") function
    is prototyped in user.h.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspchx.h>
#pragma hdrstop

extern "C" {
#include <drs.h>
#include <ntdskcc.h>
#include "user.h"
#include "simtime.h"
}
#include <kcc.hxx>
#include <kcctask.hxx>
#include <kccconn.hxx>
#include <kcctopl.hxx>

class KCC_TASK_URT_WRAPPER : public KCC_TASK_UPDATE_REPL_TOPOLOGY
{
public:
    VOID
    CallTaskExecute (PDWORD pDw);
};

VOID
KCC_TASK_URT_WRAPPER::CallTaskExecute (
    IN  PDWORD                      pDw
    )
{
    Execute (pDw);
}

extern "C"
VOID
KCCSimRunKcc (
    VOID
    )
{
    KCC_TASK_URT_WRAPPER            kccWrap;
    DWORD                           dw;

    KCCSimStartTicking ();
    kccWrap.CallTaskExecute (&dw);
    KCCSimStopTicking ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\sim\kccsim.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kccsim.c

ABSTRACT:

    The body of KCCSim.  This file contains wmain and
    some initialization routines.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <drs.h>
#include <dsutil.h>
#include <attids.h>
#include <filtypes.h>
#include <ntdskcc.h>
#include <debug.h>
#include "kccsim.h"
#include "util.h"
#include "dir.h"
#include "simtime.h"
#include "ldif.h"
#include "user.h"
#include "state.h"
#include <fileno.h>
#define FILENO  FILENO_KCCSIM_STATE

// Function prototypes - ISM simulation library

VOID SimI_ISMInitialize (VOID);
VOID SimI_ISMTerminate (VOID);

// Function prototypes - LDAP LDIF utilities

#if DBG

VOID InitMem (VOID);
VOID DumpMemoryTracker( VOID );

#endif  // DBG


VOID
KCCSimExpandRDN (
    IO  LPWSTR                      pwszBuf
    )
{
    PSIM_ENTRY                      pEntryServer, pEntryDsa;

    FILTER                          filter;
    ENTINFSEL                       entinfsel;
    SEARCHARG                       searchArg;
    SEARCHRES *                     pSearchRes = NULL;

    if (pwszBuf == NULL || pwszBuf[0] == L'\0') {
        return;
    }

    // If it contains an '=' sign, assume it's a DN, not an RDN
    if (wcschr (pwszBuf, L'=') != NULL) {
        return;
    }

    // The Dir API returns results in thread-alloc'd memory.
    // Initialize the thread state

    KCCSimThreadCreate();

    searchArg.pObject = NULL;
    searchArg.choice = SE_CHOICE_WHOLE_SUBTREE;
    searchArg.bOneNC = FALSE;
    searchArg.pFilter = &filter;
    searchArg.searchAliases = FALSE;
    searchArg.pSelection = &entinfsel;
    searchArg.pSelectionRange = NULL;
    InitCommarg (&searchArg.CommArg);
    filter.pNextFilter = NULL;
    filter.choice = FILTER_CHOICE_ITEM;
    filter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    filter.FilterTypes.Item.FilTypes.ava.type = ATT_RDN;
    filter.FilterTypes.Item.FilTypes.ava.Value.valLen = KCCSIM_WCSMEMSIZE (pwszBuf);
    filter.FilterTypes.Item.FilTypes.ava.Value.pVal = (PBYTE) pwszBuf;
    filter.FilterTypes.Item.FilTypes.pbSkip = NULL;
    filter.FilterTypes.Item.expectedSize = 0;
    entinfsel.attSel = EN_ATTSET_LIST;
    entinfsel.AttrTypBlock.attrCount = 0;
    entinfsel.AttrTypBlock.pAttr = NULL;
    entinfsel.infoTypes = EN_INFOTYPES_TYPES_ONLY;

    SimDirSearch (&searchArg, &pSearchRes);

    if (pSearchRes->count == 0) {
        return;
        // No entries found.
    }

    pEntryServer = KCCSimDsnameToEntry (
        pSearchRes->FirstEntInf.Entinf.pName, KCCSIM_NO_OPTIONS);
    if (pEntryServer == NULL) {
        return;
    }

    pEntryDsa = KCCSimFindFirstChild (
        pEntryServer, CLASS_NTDS_DSA, NULL);
    if (pEntryDsa == NULL) {
        return;
    }

    // pwszBuf size is hardcoded at 1024. Good enough for
    // this simulator for now.
    if (pEntryDsa->pdn->NameLen >= 1024) {
        Assert(pEntryDsa->pdn->NameLen < 1024);
        return;
    }

    // We've finally found it.
    wcsncpy (
        pwszBuf,
        pEntryDsa->pdn->StringName,
        pEntryDsa->pdn->NameLen
        );
    // ensure string is terminated
    pwszBuf[pEntryDsa->pdn->NameLen] = '\0';

    KCCSimThreadDestroy();
}

VOID
KCCSimSyntaxError (
    IN  BOOL                        bIsScript,
    IN  LPCWSTR                     pwszBuf,
    IN  ULONG                       ulLineAt
    )
/*++

Routine Description:

    Notifies the user of a syntax error.

Arguments:

    bIsScript           - TRUE if the command was found in a script;
                          FALSE if it was entered on the command line.
    pwszBuf             - The erroneous command.
    ulLineAt            - The line in the script where this error occurred.

Return Value:

    None.

--*/
{
    WCHAR                           wszLineBuf[6];

    if (pwszBuf == NULL) {
        return;
    }

    if (bIsScript) {

        swprintf (wszLineBuf, L"%.5u", ulLineAt);
        KCCSimPrintMessage (
            KCCSIM_MSG_SYNTAX_ERROR_LINE,
            pwszBuf,
            wszLineBuf
            );

    } else {

        KCCSimPrintMessage (
            KCCSIM_MSG_SYNTAX_ERROR,
            pwszBuf
            );

    }
}

#define DO_SYNTAX_ERROR \
        KCCSimSyntaxError (fpScript != stdin, wszCommand, ulLineAt)

VOID
KCCSimRunKccAll (
    VOID
    )
/*++

Routine Description:

    Runs the KCC iteratively as each server in the enterprise.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG                           ulNumServers, ul;
    PSIM_ENTRY *                    apEntryNTDSSettings = NULL;
    WCHAR                           wszRDN[1+MAX_RDN_SIZE];

    __try {

        KCCSimAllocGetAllServers (&ulNumServers, &apEntryNTDSSettings);

        for (ul = 0; ul < ulNumServers; ul++) {
            KCCSimBuildAnchor (apEntryNTDSSettings[ul]->pdn->StringName);
            KCCSimPrintMessage (
                KCCSIM_MSG_RUNNING_KCC,
                KCCSimQuickRDNBackOf
                    (apEntryNTDSSettings[ul]->pdn, 1, wszRDN)
                );
            KCCSimRunKcc ();
            KCCSimPrintMessage (
                KCCSIM_MSG_DID_RUN_KCC,
                wszRDN
                );
        }

    } __finally {

        KCCSimFree (apEntryNTDSSettings);

    }
}

VOID
KCCSimRun (
    FILE *                          fpScript
    )
/*++

Routine Description:

    Runs KCCSim.

Arguments:

    fpScript            - The stream where we get command input.  This may
                          be stdin.

Return Value:

    None.

--*/
{
    WCHAR                           wszCommand[1024],
                                    wszArg0[1024],
                                    wszArg1[1024],
                                    wszArg2[1024],
                                    wszArg3[1024],
                                    wszArg4[1024],
                                    wszArg5[1024];
    BOOL                            bQuit, bUpdated;
    ULONG                           ulLineAt;
    PDSNAME                         pdn1 = NULL,
                                    pdn2 = NULL,
                                    pdn3 = NULL;
    WCHAR                           wszRDN[1+MAX_RDN_SIZE];

    DWORD                           dwErrorType, dwErrorCode;

    CHAR                            szTimeBuf[1+SZDSTIME_LEN];
    WCHAR                           wszLtowBuf1[1+KCCSIM_MAX_LTOA_CHARS],
                                    wszLtowBuf2[1+KCCSIM_MAX_LTOA_CHARS];
    ULONG                           ul1, ul2;

    bQuit = FALSE;
    bUpdated = FALSE;
    ulLineAt = 0;

    // By default, always display level 0 debug messages and level 1 events
    // to the console
    KCCSimSetDebugLog (L"stdout", 0, 1);

    while (!bQuit) {

        __try {

            if (fpScript == stdin) {
                printf (
                    "\n\nSimulated Time: %s\n",
                    DSTimeToDisplayString (SimGetSecondsSince1601 (), szTimeBuf)
                    );
                printf (
                    "   Actual Time: %s\n",
                    DSTimeToDisplayString (KCCSimGetRealTime (), szTimeBuf)
                    );
                wprintf (L"\n> ");
            }

            if (fgetws (wszCommand, 1023, fpScript) == NULL) {
                // Must be an end-of-file.  Switch to user mode.
                fpScript = stdin;
                continue;
            }
            ulLineAt++;
            // Kill the trailing '\n'
            wszCommand[wcslen (wszCommand) - 1] = L'\0';

            if (wszCommand[0] == L'\0') {
                continue;
            }

            if (fpScript == stdin) {
                wprintf (L"\n");
            }

            if (!KCCSimParseCommand (wszCommand, 0, wszArg0) ||
                !KCCSimParseCommand (wszCommand, 1, wszArg1) ||
                !KCCSimParseCommand (wszCommand, 2, wszArg2) ||
                !KCCSimParseCommand (wszCommand, 3, wszArg3) ||
                !KCCSimParseCommand (wszCommand, 4, wszArg4) ||
                !KCCSimParseCommand (wszCommand, 5, wszArg5)) {
                DO_SYNTAX_ERROR;
                continue;
            }

            switch (towlower (wszArg0[0])) {

                case ';':
                    break;

                // Compare the simulated directory to one represented by an
                // ldif file
                case L'c':
                    if (wszArg1[0] == L'\0') {
                        DO_SYNTAX_ERROR;
                        break;
                    }
                    KCCSimCompareDirectory (wszArg1);
                    break;

                // Display information about the simulated environment
                case L'd':
                    if (!bUpdated) {
                        KCCSimUpdateWholeDirectory ();
                        bUpdated = TRUE;
                        KCCSimPrintMessage (KCCSIM_MSG_DID_INITIALIZE_DIRECTORY);
                    }
                    switch (towlower (wszArg0[1])) {
                        case L'c':  // Configuration information
                            KCCSimDisplayConfigInfo ();
                            break;
                        case L'g':  // Graph Information
                            KCCSimDisplayGraphInfo ();
                            break;
                        case L'd':  // Directory dump
                            KCCSimDumpDirectory (wszArg1);
                            break;
                        case L's':  // Server info
                            if (wszArg1[0] == L'\0') {
                                DO_SYNTAX_ERROR;
                                break;
                            }
                            KCCSimExpandRDN (wszArg1);
                            KCCSimBuildAnchor (wszArg1);
                            KCCSimDisplayServer ();
                            break;
                        default:
                            DO_SYNTAX_ERROR;
                            break;
                    }
                    break;

                // Load part of the directory from an ldif or ini file
                case L'l':
                    if (wszArg1[0] == L'\0') {
                        DO_SYNTAX_ERROR;
                        break;
                    }
                    switch (towlower (wszArg0[1])) {
                        case L'i':  // Load an ini file
                            bUpdated = FALSE;
                            __try {
                                BuildCfg (wszArg1);
                            } __finally {
                                // This is to avoid loading PART of an INI
                                // file, which could cause problems.  If an
                                // exception occurs we reinitialize everything
                                if (AbnormalTermination ()) {
                                    KCCSimInitializeDir ();
                                }
                            }
                            KCCSimPrintMessage (
                                KCCSIM_MSG_DID_LOAD_INPUT_FILE,
                                wszArg1
                                );
                            break;
                        case L'l':  // Load an ldif file
                            bUpdated = FALSE;
                            KCCSimLoadLdif (wszArg1);
                            KCCSimPrintMessage (
                                KCCSIM_MSG_DID_LOAD_INPUT_FILE,
                                wszArg1
                                );
                            break;
                        default:
                            DO_SYNTAX_ERROR;
                            break;
                    }
                    break;

                // Open a debug log
                case L'o':
                    ul1 = wcstoul (wszArg2, NULL, 0);    // Will default to 0
                    ul2 = wcstoul (wszArg3, NULL, 0);    // Will default to 0
                    KCCSimSetDebugLog (wszArg1, ul1, ul2);
                    KCCSimPrintMessage (
                        KCCSIM_MSG_DID_OPEN_DEBUG_LOG,
                        wszArg1,
                        _ultow (ul1, wszLtowBuf1, 10),
                        _ultow (ul2, wszLtowBuf2, 10)
                        );
                    break;

                // Quit
                case L'q':
#if DBG
                    KCCSimPrintStatistics();
#endif
                    bQuit = TRUE;
                    break;

                // Run the KCC
                case L'r':
                    if (!bUpdated) {
                        KCCSimUpdateWholeDirectory ();
                        bUpdated = TRUE;
                        KCCSimPrintMessage (KCCSIM_MSG_DID_INITIALIZE_DIRECTORY);
                    }
                    if (towlower (wszArg0[1]) == L'r') {    // Run all
                        KCCSimRunKccAll ();
                        break;
                    }
                    if (wszArg1[0] == L'\0') {
                        DO_SYNTAX_ERROR;
                        break;
                    }
                    KCCSimExpandRDN (wszArg1);
                    KCCSimBuildAnchor (wszArg1);
                    KCCSimPrintMessage (
                        KCCSIM_MSG_RUNNING_KCC,
                        KCCSimQuickRDNBackOf (KCCSimAnchorDn (KCCSIM_ANCHOR_DSA_DN), 1, wszRDN)
                        );
                    KCCSimRunKcc ();
                    KCCSimPrintMessage (
                        KCCSIM_MSG_DID_RUN_KCC,
                        wszRDN
                        );
                    break;

                // Set a server state parameter
                case L's':
                    if (!bUpdated) {
                        KCCSimUpdateWholeDirectory ();
                        bUpdated = TRUE;
                        KCCSimPrintMessage (KCCSIM_MSG_DID_INITIALIZE_DIRECTORY);
                    }
                    switch (towlower (wszArg0[1])) {
                        case 'b':
                            if (wszArg1[0] == L'\0' || wszArg2[0] == L'\0') {
                                DO_SYNTAX_ERROR;
                                break;
                            }
                            KCCSimExpandRDN (wszArg1);
                            pdn1 = KCCSimAllocDsname (wszArg1);
                            ul1 = wcstoul (wszArg2, NULL, 10);
                            if (KCCSimSetBindError (pdn1, ul1)) {
                                KCCSimPrintMessage (
                                    KCCSIM_MSG_DID_SET_BIND_ERROR,
                                    wszArg1,
                                    _ultow (ul1, wszLtowBuf1, 10)
                                    );
                            } else {
                                KCCSimPrintMessage (
                                    KCCSIM_MSG_SERVER_DOES_NOT_EXIST,
                                    wszArg1
                                    );
                            }
                            KCCSimFree (pdn1);
                            pdn1 = NULL;
                            break;
                        case 's':
                            if (wszArg1[0] == L'\0' || wszArg2[0] == L'\0' ||
                                wszArg3[0] == L'\0' || wszArg4[0] == L'\0') {
                                DO_SYNTAX_ERROR;
                                break;
                            }
                            KCCSimExpandRDN (wszArg1);
                            KCCSimExpandRDN (wszArg2);
                            pdn1 = KCCSimAllocDsname (wszArg1);
                            pdn2 = KCCSimAllocDsname (wszArg2);
                            pdn3 = KCCSimAllocDsname (wszArg3);
                            ul1 = wcstoul (wszArg4, NULL, 10);
                            if (wszArg5[0] == L'\0') {
                                ul2 = 1;        // Default
                            } else {
                                ul2 = wcstoul (wszArg5, NULL, 10);
                            }
                            if (KCCSimReportSync (pdn1, pdn3, pdn2, ul1, ul2)) {
                                KCCSimPrintMessage (
                                    KCCSIM_MSG_DID_REPORT_SYNC,
                                    _ultow (ul2, wszLtowBuf2, 10),
                                    _ultow (ul1, wszLtowBuf1, 10),
                                    wszArg1,
                                    wszArg2,
                                    wszArg3
                                    );
                            } else {
                                KCCSimPrintMessage (
                                    KCCSIM_MSG_COULD_NOT_REPORT_SYNC,
                                    wszArg1,
                                    wszArg2,
                                    wszArg3
                                    );
                            }
                            KCCSimFree (pdn1);
                            pdn1 = NULL;
                            KCCSimFree (pdn2);
                            pdn2 = NULL;
                            KCCSimFree (pdn3);
                            pdn3 = NULL;
                            break;
                        default:
                            DO_SYNTAX_ERROR;
                            break;
                    }
                    break;

                // Add seconds to the simulated time
                case L't':
                    if (wszArg1[0] == L'\0') {
                        DO_SYNTAX_ERROR;
                        break;
                    }
                    if (!bUpdated) {
                        KCCSimUpdateWholeDirectory ();
                        bUpdated = TRUE;
                        KCCSimPrintMessage (KCCSIM_MSG_DID_INITIALIZE_DIRECTORY);
                    }
                    ul1 = wcstoul (wszArg1, NULL, 10);
                    KCCSimAddSeconds (ul1);
                    KCCSimPrintMessage (
                        KCCSIM_MSG_DID_ADD_SECONDS,
                        _ultow (ul1, wszLtowBuf1, 10)
                        );
                    break;

                // Write the simulated directory to an ldif file
                case L'w':
                    if (wszArg1[0] == L'\0') {
                        DO_SYNTAX_ERROR;
                        break;
                    }
                    switch (wszArg0[1]) {
                        case 'a':   // Append changes
                            if (KCCSimExportChanges (wszArg1, FALSE)) {
                                KCCSimPrintMessage (
                                    KCCSIM_MSG_DID_APPEND_CHANGES,
                                    wszArg1
                                    );
                            } else {
                                KCCSimPrintMessage (
                                    KCCSIM_MSG_NO_CHANGES_TO_EXPORT
                                    );
                            }
                            break;
                        case 'c':   // Write changes
                            if (KCCSimExportChanges (wszArg1, TRUE)) {
                                KCCSimPrintMessage (
                                    KCCSIM_MSG_DID_EXPORT_CHANGES,
                                    wszArg1
                                    );
                            } else {
                                KCCSimPrintMessage (
                                    KCCSIM_MSG_NO_CHANGES_TO_EXPORT
                                    );
                            }
                            break;
                        case 'w':   // Write whole directory
                            KCCSimExportWholeDirectory (wszArg1, FALSE);
                            KCCSimPrintMessage (
                                KCCSIM_MSG_DID_EXPORT_WHOLE_DIRECTORY,
                                wszArg1
                                );
                            break;
                        case 'x':
                            KCCSimExportWholeDirectory (wszArg1, TRUE);
                            KCCSimPrintMessage (
                                KCCSIM_MSG_DID_EXPORT_IMPORTABLE_DIRECTORY,
                                wszArg1
                                );
                            break;
                        default:
                            DO_SYNTAX_ERROR;
                            break;
                    }
                    break;

                // Help
                case L'h':
                case L'?':
                    KCCSimPrintMessage (KCCSIM_MSG_COMMAND_HELP);
                    break;

                default:
                    DO_SYNTAX_ERROR;
                    break;

            }

        } __except (KCCSimHandleException (
                        GetExceptionInformation (),
                        &dwErrorType,
                        &dwErrorCode)) {

            switch (dwErrorType) {

                case KCCSIM_ETYPE_WIN32:
                    KCCSimPrintMessage (KCCSIM_MSG_ANNOUNCE_WIN32_ERROR);
                    break;

                case KCCSIM_ETYPE_INTERNAL:
                    KCCSimPrintMessage (KCCSIM_MSG_ANNOUNCE_INTERNAL_ERROR);
                    break;

                default:
                    Assert (!L"This type of error should never happen!");
                    break;

            }

            KCCSimPrintExceptionMessage ();

            if (dwErrorType != KCCSIM_ETYPE_INTERNAL) {
                bQuit = TRUE;
            }

        }   // __try/__except

    }       // while (!bQuit)

}

ULONG
__cdecl
wmain (
    INT                             argc,
    LPWSTR *                        argv
    )
/*++

Routine Description:

    Main entrypoint for KCCSim.

Arguments:

    argc                - Number of command line arguments.
    argv                - Command line arguments.

Return Value:

    Win32 error code.

--*/
{
    FILE *                          fpScript;
    INT                             iArgAt;
    BOOL                            bQuit, bQuiet;

    __try {

        // Basic initialization.
        KCCSimInitializeTime ();    // Initialize the simulated time
        KCCSimInitializeSchema ();  // Initialize the schema table
        KCCSimInitializeDir ();     // Initialize the directory

        SimI_ISMInitialize ();      // Initialize the simulated ism functions
        KccInitialize ();           // Initialize the KCC
#if DBG
        InitMem ();                 // Needed by ldifldap
#endif

        fpScript = stdin;
        bQuit = FALSE;
        bQuiet = FALSE;

        for (iArgAt = 1; iArgAt < argc; iArgAt++) {

            if (argv[iArgAt][0] == L'/' || argv[iArgAt][0] == L'-') {
                switch (towlower (argv[iArgAt][1])) {

                    case L'h':
                    case L'?':
                        KCCSimPrintMessage (KCCSIM_MSG_HELP);
                        _getch ();
                        KCCSimPrintMessage (KCCSIM_MSG_COMMAND_HELP);
                        bQuit = TRUE;
                        break;

                    case L'q':
                        bQuiet = TRUE;
                        break;

                    default:
                        break;

                }
            } else if (fpScript == stdin) {

                fpScript = _wfopen (argv[iArgAt], L"rt");
                if (fpScript == NULL) {
                    KCCSimPrintMessage (
                        KCCSIM_MSG_ANNOUNCE_CANT_OPEN_SCRIPT,
                        argv[iArgAt]
                        );
                    wprintf (KCCSimMsgToString (
                        KCCSIM_ETYPE_WIN32,
                        GetLastError ()
                        ));
                    bQuit = TRUE;
                }

            }

        }

    } __except (KCCSimHandleException (
                        GetExceptionInformation (),
                        NULL,
                        NULL)) {

        KCCSimPrintMessage (KCCSIM_MSG_ANNOUNCE_ERROR_INITIALIZING);
        KCCSimPrintExceptionMessage ();
        bQuit = TRUE;

    }

    if (!bQuit) {
        KCCSimQuiet (bQuiet);
        KCCSimRun (fpScript);
    }

    // Terminate the simulated ism functions.
    SimI_ISMTerminate ();

#if DBG
    DumpMemoryTracker(); // Show unused ldif memory
#endif

    // Close any open log file.
    KCCSimSetDebugLog (NULL, 0, 0);

    // Close the script file.
    if (fpScript != stdin) {
        fclose (fpScript);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\sim\simdsapi.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    simdsapi.c

ABSTRACT:

    Simulates the Ds* APIs.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <drs.h>
#include <ntdskcc.h>
#include <debug.h>
#include "kccsim.h"
#include "util.h"
#include "dir.h"
#include "state.h"
#include <fileno.h>
#define FILENO  FILENO_KCCSIM_SIMDSAPI

BOOL fNullUuid (const GUID *);

DWORD
WINAPI
SimDsReplicaGetInfoW (
    IN  HANDLE                      hDs,
    IN  DS_REPL_INFO_TYPE           InfoType,
    IN  LPCWSTR                     pszObject,
    IN  UUID *                      puuidForSourceDsaObjGuid,
    OUT VOID **                     ppInfo
    )
/*++

Routine Description:

    Simulates the DsReplicaGetInfoW API.

Arguments:

    hDs                 - A "handle" returned by SimDsBindW (which is
                          really just a PDSNAME).
    InfoType            - The information type to return.
    pszObject           - Currently unused.
    puuidForSourceDsaObjGuid - Currently unused.
    ppInfo              - Pointer to the result.

Return Value:

    None.

--*/
{
    DWORD                           status = NO_ERROR;

    *ppInfo = NULL;

    if (NULL == hDs ||
        NULL == ppInfo ||
        (((ULONG) InfoType >= DS_REPL_INFO_TYPE_MAX) &&
         ((ULONG) InfoType <= DS_REPL_INFO_TYPEP_MIN))) {
        return ERROR_INVALID_PARAMETER;
    }

    switch (InfoType) {

        case DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES:
        case DS_REPL_INFO_KCC_DSA_LINK_FAILURES:
            *ppInfo = KCCSimGetDsaFailures ((PDSNAME) hDs);
            if (NULL == *ppInfo) {
                Assert(!"KCCSimGetDsaFailures failed?");
                status = ERROR_NOT_ENOUGH_MEMORY;
            }
            break;

        default:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_UNSUPPORTED_DS_REPL_INFO_TYPE
                );
            break;

    }

    return status;
}

VOID
WINAPI
SimDsReplicaFreeInfo (
    IN  DS_REPL_INFO_TYPE           InfoType,
    IN  VOID *                      pInfo
    )
/*++

Routine Description:

    Simulates the DsReplicaFreeInfo API.

Arguments:

    InfoType            - The information type of pInfo.
    pInfo               - A buffer returned by SimDsReplicaGetInfoW.

Return Value:

    None.

--*/
{
    DS_REPL_KCC_DSA_FAILURESW *     pFailures;
    ULONG                           ul;

    switch (InfoType) {

        case DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES:
        case DS_REPL_INFO_KCC_DSA_LINK_FAILURES:
            // We only need to free pInfo
            break;

        default:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_UNSUPPORTED_DS_REPL_INFO_TYPE
                );
            break;

    }

    KCCSimFree (pInfo);
    return;
}

DWORD
WINAPI
SimDsBindW (
    IN  LPCWSTR                     DomainControllerName,
    IN  LPCWSTR                     DnsDomainName,
    IO  HANDLE *                    phDS
    )
/*++

Routine Description:

    Simulates the DsBindW API.

Arguments:

    DomainControllerName - Guid-based dns name of the DC to which to bind.
    DnsDomainName       - Currently unused.
    phDS                - Pointer to a "handle" that will store the DSNAME
                          of the server we bind to.

Return Value:

    Win32 error code.

--*/
{
    PDSNAME                         pdnServer = NULL;
    LPWSTR                          pwsz = NULL;
    DWORD                           dwErr;

    Assert (DnsDomainName == NULL);         // Not supported

    // Create a blank PDSNAME to hold the GUID of this server.
    pdnServer = KCCSimAllocDsname (NULL);
    // Create the string-based UUID to pass to UuidFromStringW.
    pwsz = KCCSIM_WCSDUP (DomainControllerName);
    Assert (wcslen (pwsz) >= 36);
    pwsz[36] = L'\0';
    // Fill in the GUID structure in pdnServer.
    KCCSIM_CHKERR (UuidFromStringW (pwsz, &pdnServer->Guid));
    KCCSimFree (pwsz);
    // Check to see if we're simulating a bind error on this server.
    dwErr = KCCSimGetBindError (pdnServer);
    if (dwErr == NO_ERROR) {
        // Success; the handle points to the server's DSNAME.
        *phDS = (HANDLE) pdnServer;
    } else {
        *phDS = NULL;
        KCCSimFree (pdnServer);
    }

    return dwErr;
}

DWORD
WINAPI
SimDsUnBindW (
    IO  HANDLE *                    phDS
    )
/*++

Routine Description:

    Simulates the DsUnBindW API.

Arguments:

    phDS                - Pointer to a handle returned by SimDsBindW.

Return Value:

    Win32 error code.

--*/
{
    if (*phDS != NULL) {
        KCCSimFree (*phDS);
        *phDS = NULL;
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\sim\simism.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    simism.c

ABSTRACT:

    Simulates the ISM APIs.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <ismapi.h>
#include <attids.h>
#include <debug.h>
#include "../../ism/include/common.h"
#include "kccsim.h"
#include "util.h"
#include "dir.h"
#include <fileno.h>
#define FILENO  FILENO_KCCSIM_SIMISM

/***

    The following functions are callbacks for the ISM simulator library.

***/

DWORD
DirReadTransport (
    IN  PVOID                       pConnectionHandle,
    IO  PTRANSPORT_INSTANCE         pTransport
    )
/*++

Routine Description:

    Retrieves information about a transport.

Arguments:

    pConnectionHandle   - Not used.
    pTransport          - The transport to fill with data.  It is expected that
                          pTransport->Name is valid initially.

Return Value:

    Win32 error code.

--*/
{
    PSIM_ENTRY                      pEntry;
    SIM_ATTREF                      attRef;
    PDSNAME                         pdn;

    pdn = KCCSimAllocDsname (pTransport->Name);
    pEntry = KCCSimDsnameToEntry (pdn, KCCSIM_NO_OPTIONS);
    KCCSimFree (pdn);
    if (pEntry != NULL) {

        if (KCCSimGetAttribute (pEntry, ATT_REPL_INTERVAL, &attRef)) {
            pTransport->ReplInterval = 
                *((SYNTAX_INTEGER *) attRef.pAttr->pValFirst->pVal);
        }
        if (KCCSimGetAttribute (pEntry, ATT_OPTIONS, &attRef)) {
            pTransport->Options =
                *((SYNTAX_INTEGER *) attRef.pAttr->pValFirst->pVal);
        }

    }

    return ERROR_SUCCESS;
}

VOID
DirFreeSiteList (
    IN  DWORD                       dwNumberSites,
    IN  LPWSTR *                    ppwszSiteList
    )
/*++

Routine Description:

    Frees an array of strings.

Arguments:

    dwNumberSites       - The number of strings in the array.
    ppwszSiteList       - The array to free.

Return Value:

    None.

--*/
{
    ULONG                           ulSiteAt;

    if (ppwszSiteList == NULL) {
        return;
    }

    for (ulSiteAt = 0; ulSiteAt < dwNumberSites; ulSiteAt++) {
        KCCSimFree (ppwszSiteList[ulSiteAt]);
    }
    KCCSimFree (ppwszSiteList);
}

VOID
DirCopySiteList (
    IN  DWORD                       dwNumberSites,
    IN  LPWSTR *                    ppwszSiteList,
    OUT LPWSTR **                   pppwszCopy
    )
/*++

Routine Description:

    Makes a copy of an array of strings.

Arguments:

    dwNumberSites       - Number of strings in the array.
    ppwszSiteList       - The array to copy.
    pppwszCopy          - Pointer to the copy.

Return Value:

    None.

--*/
{
    LPWSTR *                        ppwszCopy;
    ULONG                           ulSiteAt;

    ppwszCopy = KCCSIM_NEW_ARRAY (LPWSTR, dwNumberSites);

    // Fill the copy with NULLs in case we run out of memory
    for (ulSiteAt = 0; ulSiteAt < dwNumberSites; ulSiteAt++) {
        ppwszCopy[ulSiteAt] = NULL;
    }

    // Copy the strings
    for (ulSiteAt = 0; ulSiteAt < dwNumberSites; ulSiteAt++) {
        if (ppwszSiteList[ulSiteAt] != NULL) {
            ppwszCopy[ulSiteAt] = KCCSIM_WCSDUP (ppwszSiteList[ulSiteAt]);
        }
    }

    *pppwszCopy = ppwszCopy;
}

DWORD
DirGetSiteList (
    IN  PVOID                       pConnectionHandle,
    OUT LPDWORD                     pdwNumberSites,
    OUT LPWSTR **                   pppwszSiteList
    )
/*++

Routine Description:

    Retrieves a list of all sites in the enterprise.

Arguments:

    pConnectionHandle   - Not used.
    pdwNumberSites      - The number of sites in the enterprise.
    pppwszSiteList      - Array of site DNs.

Return Value:

    Win32 error code.

--*/
{
    PSIM_ENTRY                      pEntryConfig, pEntrySitesContainer,
                                    pEntrySite;

    DWORD                           dwNumberSites = 0;
    LPWSTR *                        ppwszSiteList = NULL;
    ULONG                           ulSiteAt;

    *pdwNumberSites = 0;
    *pppwszSiteList = NULL;         // Default

    __try {

        // First locate the sites container.
        pEntryConfig = KCCSimDsnameToEntry (
            KCCSimAnchorDn (KCCSIM_ANCHOR_CONFIG_DN), KCCSIM_NO_OPTIONS);
        pEntrySitesContainer = KCCSimFindFirstChild (
            pEntryConfig, CLASS_SITES_CONTAINER, NULL);
        if (pEntrySitesContainer == NULL) {
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_SITES_CONTAINER_MISSING
            );
        }

        // Now determine the number of sites.
        dwNumberSites = 0;
        for (pEntrySite = KCCSimFindFirstChild (
                pEntrySitesContainer, CLASS_SITE, NULL);
             pEntrySite != NULL;
             pEntrySite = KCCSimFindNextChild (
                pEntrySite, CLASS_SITE, NULL)) {
            dwNumberSites++;
        }

        // Now fill in the list with NULLs in case we run out of memory.
        ppwszSiteList = KCCSIM_NEW_ARRAY (LPWSTR, dwNumberSites);
        for (ulSiteAt = 0; ulSiteAt < dwNumberSites; ulSiteAt++) {
            ppwszSiteList[ulSiteAt] = NULL;
        }

        ulSiteAt = 0;
        for (pEntrySite = KCCSimFindFirstChild (
                pEntrySitesContainer, CLASS_SITE, NULL);
             pEntrySite != NULL;
             pEntrySite = KCCSimFindNextChild (
                pEntrySite, CLASS_SITE, NULL)) {

            Assert (ulSiteAt < dwNumberSites);
            ppwszSiteList[ulSiteAt] = KCCSIM_WCSDUP (pEntrySite->pdn->StringName);
            ulSiteAt++;

        }
        Assert (ulSiteAt == dwNumberSites);

        // We're done!
        *pdwNumberSites = dwNumberSites;
        *pppwszSiteList = ppwszSiteList;

    // If an exception occurs and the site list has been allocated, be sure to free it.
    // If the site list has not yet been allocated, ppwszSiteList will still have its
    // initial value of NULL.
    } __finally {
    
        if (AbnormalTermination() && (ppwszSiteList!=NULL)) {
            DirFreeSiteList (dwNumberSites, ppwszSiteList);
        }

    }

    return ERROR_SUCCESS;
}

DWORD
DirGetSiteBridgeheadList(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    LPCWSTR SiteDN,
    LPDWORD pNumberServers,
    LPWSTR **ppServerList
    )
/*++

Routine Description:

     ISM dir-layer callback to get bridgehead list

Arguments:

     pTransport - ISM transport object
     ConnectionHandle - connection state context, unused
     SiteDN - DN of site for which bridgheads are requested
     pNumberServers - address to which the number found is written
     ppServerList - address to which is written the array of servers

Return Value:

    Win32 error code.

--*/
{
    LPWSTR *                        pServerList = NULL;
    ULONG                           cb;

    PSIM_ENTRY                      pEntryTransport, pEntrySite;
    SIM_ATTREF                      attRef;
    PSIM_VALUE                      pValAt;

    const DSNAME *                  pdnSite = NULL;
    PDSNAME                         pdn = NULL;
    ULONG                           ulNumBridgeheads, ul;

    if (NULL == ppServerList) {
        return ERROR_INVALID_PARAMETER;
    }

    *ppServerList = NULL;

    __try {

        pdn = KCCSimAllocDsname (pTransport->Name);
        pEntryTransport = KCCSimDsnameToEntry (pdn, KCCSIM_NO_OPTIONS);
        KCCSimFree (pdn);
        pdn = NULL;
        pdn = KCCSimAllocDsname (SiteDN);
        pEntrySite = KCCSimDsnameToEntry (pdn, KCCSIM_NO_OPTIONS);
        KCCSimFree (pdn);
        pdn = NULL;

        if (pEntryTransport == NULL || pEntrySite == NULL) {
            return ERROR_NOT_FOUND;
        }

        if (!KCCSimGetAttribute (
                pEntryTransport,
                ATT_BRIDGEHEAD_SERVER_LIST_BL,
                &attRef
                )) {
            // No bridgehead list attribute.  Just return NULL.
            *pNumberServers = 0;
            *ppServerList = NULL;
            return NO_ERROR;
        }

        // First determine how many servers are bridgeheads in this site.
        ulNumBridgeheads = 0;
        for (pValAt = attRef.pAttr->pValFirst;
             pValAt != NULL;
             pValAt = pValAt->next) {
            DSNAME *pdnServer = (SYNTAX_DISTNAME *) pValAt->pVal;
            if (KCCSimNthAncestor (pEntrySite->pdn, pdnServer) != -1) {
                ulNumBridgeheads++;
            }
        }

        // Allocate space
        cb = sizeof (LPWSTR) * ulNumBridgeheads;
        pServerList = KCCSimAlloc (cb);

        // Fill in the bridgeheads.
        ul = 0;
        for (pValAt = attRef.pAttr->pValFirst;
             pValAt != NULL;
             pValAt = pValAt->next) {
            DSNAME *pdnServer = (SYNTAX_DISTNAME *) pValAt->pVal;
            if (KCCSimNthAncestor (pEntrySite->pdn, pdnServer) != -1) {
                Assert (ul < ulNumBridgeheads);
                pServerList[ul] = KCCSIM_WCSDUP( pdnServer->StringName );
                ul++;
            }
        }
        Assert (ul == ulNumBridgeheads);

        *pNumberServers = ul;
        *ppServerList = pServerList;

    } __finally {

        if (pdn) {
            KCCSimFree (pdn);
        }
        if (AbnormalTermination ()) {
            KCCSimFree (pServerList);
        }

    }

    return NO_ERROR;
}

VOID
DirTerminateIteration (
    OUT PVOID *                     ppIterateContextHandle
    )
/*++

Routine Description:

    Terminates an iterator.  An iterator is just a PSIM_ENTRY or
    a PSIM_VALUE, so we do not need to free anything.

Arguments:

    ppIterateContextHandle - Handle of the iterator to terminate.

Return Value:

    None.

--*/
{
    *ppIterateContextHandle = NULL;
}

DWORD
DirIterateSiteLinks (
    IN  PTRANSPORT_INSTANCE         pTransport,
    IN  PVOID                       pConnectionHandle,
    IO  PVOID *                     ppIterateContextHandle,
    IO  LPWSTR                      pwszSiteLinkName
    )
/*++

Routine Description:

    Iterates over all site links in a transport.

Arguments:

    pTransport          - The transport to search.
    pConnectionHandle   - Not used.
    ppIterateContextHandle - Handle of the iterator. If *ppIterateContextHandle
                          is NULL, creates a new iterator.
    pwszSiteLinkName    - Preallocated string buffer of length
                          MAX_REG_COMPONENT that will hold the site link DN.

Return Value:

    None.

--*/
{
    PSIM_ENTRY                      pEntryTransport, pEntrySiteLink;
    PDSNAME                         pdnTransport = NULL;

    __try {

        pEntrySiteLink = *((PSIM_ENTRY *) ppIterateContextHandle);

        if (pEntrySiteLink == NULL) {
            // This is the first call to IterateSiteLinks ().
            pdnTransport = KCCSimAllocDsname (pTransport->Name);
            pEntryTransport = KCCSimDsnameToEntry (pdnTransport, KCCSIM_NO_OPTIONS);
            pEntrySiteLink = KCCSimFindFirstChild (
                pEntryTransport, CLASS_SITE_LINK, NULL);
        } else {
            pEntrySiteLink = KCCSimFindNextChild (
                pEntrySiteLink, CLASS_SITE_LINK, NULL);
        }

        *ppIterateContextHandle = (PVOID) pEntrySiteLink;

        if (pEntrySiteLink == NULL) {
            pwszSiteLinkName = L'\0';
        } else {
            wcsncpy (
                pwszSiteLinkName,
                pEntrySiteLink->pdn->StringName,
                MAX_REG_COMPONENT
                );
        }

    } __finally {

        KCCSimFree (pdnTransport);

    }

    if (*ppIterateContextHandle == NULL) {
        return ERROR_NO_MORE_ITEMS;
    } else {
        return ERROR_SUCCESS;
    }
}

VOID
DirFreeMultiszString (
    IN  LPWSTR                      pwszMultiszString
    )
/*++

Routine Description:

    Frees a multi-sz string.

Arguments:

    pwszMultiszString   - The string to free.

Return Value:

    None.

--*/
{
    KCCSimFree (pwszMultiszString);
}

VOID
DirFreeSchedule (
    IN  PBYTE                       pSchedule
    )
/*++

Routine Description:

    Frees a schedule.

Arguments:

    pSchedule           - The schedule to free.

Return Value:

    None.

--*/
{
    KCCSimFree (pSchedule);
}

DWORD
DirReadSiteLink (
    IN  PTRANSPORT_INSTANCE         pTransport,
    IN  PVOID                       pConnectionHandle,
    IN  LPWSTR                      pwszSiteLinkName,
    OUT LPWSTR *                    ppwszSiteList,
    IO  PISM_LINK                   pLinkValue,
    OUT PBYTE *                     ppSchedule OPTIONAL
    )
/*++

Routine Description:

    Reads information out of a site link.

Arguments:

    pTransport          - The transport type of this site-link.
    pConnectionHandle   - Not used.
    pwszSiteLinkName    - The DN of this site link.
    ppwszSiteList       - A list of sites that belong to this site link,
                          stored as a multi-sz string.
    pLinkValue          - Pointer to an ISM_LINK that will hold
                          supplementary information about this site link.
    ppSchedule          - The schedule of this site link.

Return Value:

    Win32 error code.

--*/
{
    PSIM_ENTRY                      pEntrySiteLink;
    SIM_ATTREF                      attRef;
    PSIM_VALUE                      pValAt;
    PDSNAME                         pdnSiteLink = NULL;
    PDSNAME                         pdnSiteVal;

    ULONG                           cbSiteList, ulPos;
    LPWSTR                          pwszSiteList = NULL;
    PBYTE                           pSchedule = NULL;

    // Set the defaults.
    if (ppwszSiteList != NULL) {
        *ppwszSiteList = NULL;
    }
    if (ppSchedule != NULL) {
        *ppSchedule = NULL;
    }

    __try {

        pdnSiteLink = KCCSimAllocDsname (pwszSiteLinkName);
        pEntrySiteLink = KCCSimDsnameToEntry (pdnSiteLink, KCCSIM_NO_OPTIONS);

        Assert (pEntrySiteLink != NULL);

        // Site list attribute
        if (KCCSimGetAttribute (pEntrySiteLink, ATT_SITE_LIST, &attRef)) {

            cbSiteList = 0;
            for (pValAt = attRef.pAttr->pValFirst;
                 pValAt != NULL;
                 pValAt = pValAt->next) {

                pdnSiteVal = (SYNTAX_DISTNAME *) pValAt->pVal;
                cbSiteList += (wcslen (pdnSiteVal->StringName) + 1);

            }
            cbSiteList++;   // For the multisz trailing \0

            pwszSiteList = KCCSimAlloc (sizeof (WCHAR) * cbSiteList);

            ulPos = 0;
            for (pValAt = attRef.pAttr->pValFirst;
                 pValAt != NULL;
                 pValAt = pValAt->next) {

                pdnSiteVal = (SYNTAX_DISTNAME *) pValAt->pVal;
                wcscpy (&pwszSiteList[ulPos], pdnSiteVal->StringName);
                ulPos += (wcslen (pdnSiteVal->StringName) + 1);

            }
            pwszSiteList[ulPos++] = L'\0';  // Multisz trailing \0
            Assert (cbSiteList == ulPos);

        }

        // Cost attribute
        if (KCCSimGetAttribute (pEntrySiteLink, ATT_COST, &attRef)) {
            pLinkValue->ulCost =
                *((SYNTAX_INTEGER *) attRef.pAttr->pValFirst->pVal);
        }

        // Replication Interval attribute
        if (KCCSimGetAttribute (pEntrySiteLink, ATT_REPL_INTERVAL, &attRef)) {
            pLinkValue->ulReplicationInterval =
                *((SYNTAX_INTEGER *) attRef.pAttr->pValFirst->pVal);
        }

        // Options attribute
        if (KCCSimGetAttribute (pEntrySiteLink, ATT_OPTIONS, &attRef)) {
            pLinkValue->ulOptions =
                *((SYNTAX_INTEGER *) attRef.pAttr->pValFirst->pVal);
        }

        // Schedule attribute
        if (KCCSimGetAttribute (pEntrySiteLink, ATT_SCHEDULE, &attRef)) {
            pSchedule = KCCSimAlloc (attRef.pAttr->pValFirst->ulLen);
            memcpy (
                pSchedule,
                attRef.pAttr->pValFirst->pVal,
                attRef.pAttr->pValFirst->ulLen
                );
        }

        if (ppwszSiteList != NULL) {
            *ppwszSiteList = pwszSiteList;
        }
        if (ppSchedule != NULL) {
            *ppSchedule = pSchedule;
        }

    } __finally {

        KCCSimFree (pdnSiteLink);
        if (AbnormalTermination ()) {
            DirFreeMultiszString (pwszSiteList);
            DirFreeSchedule (pSchedule);
        }

    }

    return ERROR_SUCCESS;
}

DWORD
DirIterateSiteLinkBridges (
    IN  PTRANSPORT_INSTANCE         pTransport,
    IN  PVOID                       pConnectionHandle,
    IO  PVOID *                     ppIterateContextHandle,
    IO  LPWSTR                      pwszSiteLinkBridgeName
    )
/*++

Routine Description:

    Iterates over the bridgeheads for a given transport.

Arguments:

    pTransport          - The transport to search.
    pConnectionHandle   - Not used.
    ppIterateContextHandle - Handle of the iterator. If *ppIterateContextHandle
                          is NULL, creates a new iterator.
    pwszSiteLinkBridgeName - Preallocated string buffer of length
                          MAX_REG_COMPONENT that will hold the name of the
                          bridghead server.

Return Value:

    

--*/
{
    PSIM_ENTRY                      pEntryTransport;
    SIM_ATTREF                      attRef;
    PSIM_VALUE                      pValBridgehead;
    PDSNAME                         pdnTransport = NULL;

    __try {

        pValBridgehead = *((PSIM_VALUE *) ppIterateContextHandle);

        if (pValBridgehead == NULL) {
            // This is the first call
            pdnTransport = KCCSimAllocDsname (pTransport->Name);
            pEntryTransport = KCCSimDsnameToEntry (pdnTransport, KCCSIM_NO_OPTIONS);
            if (KCCSimGetAttribute (pEntryTransport,
                    ATT_BRIDGEHEAD_SERVER_LIST_BL, &attRef)) {
                pValBridgehead = attRef.pAttr->pValFirst;
            }
        } else {
            // Not the first call
            pValBridgehead = pValBridgehead->next;
        }

        *ppIterateContextHandle = (PVOID) pValBridgehead;

        if (pValBridgehead == NULL) {
            pwszSiteLinkBridgeName[0] = L'\0';
        } else {
            wcsncpy (
                pwszSiteLinkBridgeName,
                (LPWSTR) pValBridgehead->pVal,
                MAX_REG_COMPONENT
                );
        }

    } __finally {

        KCCSimFree (pdnTransport);

    }

    if (*ppIterateContextHandle == NULL) {
        return ERROR_NO_MORE_ITEMS;
    } else {
        return ERROR_SUCCESS;
    }
}

DWORD
DirReadSiteLinkBridge (
    IN  PTRANSPORT_INSTANCE         pTransport,
    IN  PVOID                       pConnectionHandle,
    IN  LPWSTR                      pwszSiteLinkBridgeName,
    IO  LPWSTR *                    ppwszSiteLinkList
    )
//
// Not implemented
//
{
    return ERROR_INVALID_PARAMETER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\sim\simmderr.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    simmderr.c

ABSTRACT:

    Simulates the error reporting routines
    for the Dir* APIs.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <debug.h>
#include "kccsim.h"
#include "util.h"

/***

    This is kind of an ugly file.  In order to avoid duplicating absurd
    amounts of code, we simply include mderror.c directly.  We stub out
    some #defines to prevent mderror.c from behaving in undesired ways,
    and then enclose its component functions in neat little wrappers.
    Function comments are omitted as each of the functions in this file
    is self-explanatory.

***/

// For simulating the error routines
#include <mdglobal.h>
#include <direrr.h>
#define __SCACHE_H__
#define _dbglobal_h_
#define _mdglobal_h_
#define _MDLOCAL_
#define _DSATOOLS_
// Need to undo override in kccsim.h since mderror.c includes dsevent.h
#undef LogEvent8

THSTATE *                           pFakeTHS;
#define pTHStls                     pFakeTHS
#define gfDsaWritable               FALSE
#define SetDsaWritability(x,y)
#define CreateErrorString(x,y)      0

#include "../../ntdsa/src/mderror.c"

int
KCCSimDoSetUpdError (
    COMMRES *                       pCommRes,
    USHORT                          problem,
    DWORD                           dwExtendedErr,
    DWORD                           dwExtendedData,
    DWORD                           dsid
    )
{
    int                             iRet;

    pFakeTHS = KCCSIM_NEW (THSTATE);
    pFakeTHS->fDRA = FALSE;

    iRet = DoSetUpdError (
        problem,
        dwExtendedErr,
        dwExtendedData,
        dsid
        );

    pCommRes->errCode = pFakeTHS->errCode;
    pCommRes->pErrInfo = pFakeTHS->pErrInfo;

    KCCSimFree (pFakeTHS);

    return iRet;
}

int
KCCSimDoSetAttError (
    COMMRES *                       pCommRes,
    PDSNAME                         pDN,
    ATTRTYP                         aTyp,
    USHORT                          problem,
    ATTRVAL *                       pAttVal,
    DWORD                           extendedErr,
    DWORD                           extendedData,
    DWORD                           dsid
    )
{
    int                             iRet;

    pFakeTHS = KCCSIM_NEW (THSTATE);
    pFakeTHS->fDRA = FALSE;
    
    iRet = DoSetAttError (
        pDN,
        aTyp,
        problem,
        pAttVal,
        extendedErr,
        extendedData,
        dsid
        );

    pCommRes->errCode = pFakeTHS->errCode;
    pCommRes->pErrInfo = pFakeTHS->pErrInfo;

    KCCSimFree (pFakeTHS);

    return iRet;
}

int
KCCSimDoSetNamError (
    COMMRES *                       pCommRes,
    USHORT                          problem,
    PDSNAME                         pDN,
    DWORD                           dwExtendedErr,
    DWORD                           dwExtendedData,
    DWORD                           dsid
    )
{
    int                             iRet;

    pFakeTHS = KCCSIM_NEW (THSTATE);
    pFakeTHS->fDRA = FALSE;

    iRet = DoSetNamError (
        problem,
        pDN,
        dwExtendedErr,
        dwExtendedData,
        dsid
        );

    pCommRes->errCode = pFakeTHS->errCode;
    pCommRes->pErrInfo = pFakeTHS->pErrInfo;

    KCCSimFree (pFakeTHS);

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\sim\schmap.c ===
/*++

Copyright (c) 2000 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    schmap.c

ABSTRACT:

    This file was automatically generated by schtable.exe.

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <attids.h>
#include "schmap.h"

// Define symbols missing from attids.h
#define ATT_ENTRY_TTL 0xffffffff
#define CLASS_DYNAMIC_OBJECT 0xffffffff

const struct _SCHTABLE_MAPPING          schTable[] = {

    { L"accountExpires"                            , ATT_ACCOUNT_EXPIRES                          , SYNTAX_I8_TYPE                    , L"Account-Expires"                           , 0                                             },
    { L"accountNameHistory"                        , ATT_ACCOUNT_NAME_HISTORY                     , SYNTAX_UNICODE_TYPE               , L"Account-Name-History"                      , 0                                             },
    { L"aCSAggregateTokenRatePerUser"              , ATT_ACS_AGGREGATE_TOKEN_RATE_PER_USER        , SYNTAX_I8_TYPE                    , L"ACS-Aggregate-Token-Rate-Per-User"         , 0                                             },
    { L"aCSAllocableRSVPBandwidth"                 , ATT_ACS_ALLOCABLE_RSVP_BANDWIDTH             , SYNTAX_I8_TYPE                    , L"ACS-Allocable-RSVP-Bandwidth"              , 0                                             },
    { L"aCSCacheTimeout"                           , ATT_ACS_CACHE_TIMEOUT                        , SYNTAX_INTEGER_TYPE               , L"ACS-Cache-Timeout"                         , 0                                             },
    { L"aCSDirection"                              , ATT_ACS_DIRECTION                            , SYNTAX_INTEGER_TYPE               , L"ACS-Direction"                             , 0                                             },
    { L"aCSDSBMDeadTime"                           , ATT_ACS_DSBM_DEADTIME                        , SYNTAX_INTEGER_TYPE               , L"ACS-DSBM-DeadTime"                         , 0                                             },
    { L"aCSDSBMPriority"                           , ATT_ACS_DSBM_PRIORITY                        , SYNTAX_INTEGER_TYPE               , L"ACS-DSBM-Priority"                         , 0                                             },
    { L"aCSDSBMRefresh"                            , ATT_ACS_DSBM_REFRESH                         , SYNTAX_INTEGER_TYPE               , L"ACS-DSBM-Refresh"                          , 0                                             },
    { L"aCSEnableACSService"                       , ATT_ACS_ENABLE_ACS_SERVICE                   , SYNTAX_BOOLEAN_TYPE               , L"ACS-Enable-ACS-Service"                    , 0                                             },
    { L"aCSEnableRSVPAccounting"                   , ATT_ACS_ENABLE_RSVP_ACCOUNTING               , SYNTAX_BOOLEAN_TYPE               , L"ACS-Enable-RSVP-Accounting"                , 0                                             },
    { L"aCSEnableRSVPMessageLogging"               , ATT_ACS_ENABLE_RSVP_MESSAGE_LOGGING          , SYNTAX_BOOLEAN_TYPE               , L"ACS-Enable-RSVP-Message-Logging"           , 0                                             },
    { L"aCSEventLogLevel"                          , ATT_ACS_EVENT_LOG_LEVEL                      , SYNTAX_INTEGER_TYPE               , L"ACS-Event-Log-Level"                       , 0                                             },
    { L"aCSIdentityName"                           , ATT_ACS_IDENTITY_NAME                        , SYNTAX_UNICODE_TYPE               , L"ACS-Identity-Name"                         , 0                                             },
    { L"aCSMaxAggregatePeakRatePerUser"            , ATT_ACS_MAX_AGGREGATE_PEAK_RATE_PER_USER     , SYNTAX_I8_TYPE                    , L"ACS-Max-Aggregate-Peak-Rate-Per-User"      , 0                                             },
    { L"aCSMaxDurationPerFlow"                     , ATT_ACS_MAX_DURATION_PER_FLOW                , SYNTAX_INTEGER_TYPE               , L"ACS-Max-Duration-Per-Flow"                 , 0                                             },
    { L"aCSMaxNoOfAccountFiles"                    , ATT_ACS_MAX_NO_OF_ACCOUNT_FILES              , SYNTAX_INTEGER_TYPE               , L"ACS-Max-No-Of-Account-Files"               , 0                                             },
    { L"aCSMaxNoOfLogFiles"                        , ATT_ACS_MAX_NO_OF_LOG_FILES                  , SYNTAX_INTEGER_TYPE               , L"ACS-Max-No-Of-Log-Files"                   , 0                                             },
    { L"aCSMaxPeakBandwidth"                       , ATT_ACS_MAX_PEAK_BANDWIDTH                   , SYNTAX_I8_TYPE                    , L"ACS-Max-Peak-Bandwidth"                    , 0                                             },
    { L"aCSMaxPeakBandwidthPerFlow"                , ATT_ACS_MAX_PEAK_BANDWIDTH_PER_FLOW          , SYNTAX_I8_TYPE                    , L"ACS-Max-Peak-Bandwidth-Per-Flow"           , 0                                             },
    { L"aCSMaxSizeOfRSVPAccountFile"               , ATT_ACS_MAX_SIZE_OF_RSVP_ACCOUNT_FILE        , SYNTAX_INTEGER_TYPE               , L"ACS-Max-Size-Of-RSVP-Account-File"         , 0                                             },
    { L"aCSMaxSizeOfRSVPLogFile"                   , ATT_ACS_MAX_SIZE_OF_RSVP_LOG_FILE            , SYNTAX_INTEGER_TYPE               , L"ACS-Max-Size-Of-RSVP-Log-File"             , 0                                             },
    { L"aCSMaxTokenBucketPerFlow"                  , ATT_ACS_MAX_TOKEN_BUCKET_PER_FLOW            , SYNTAX_I8_TYPE                    , L"ACS-Max-Token-Bucket-Per-Flow"             , 0                                             },
    { L"aCSMaxTokenRatePerFlow"                    , ATT_ACS_MAX_TOKEN_RATE_PER_FLOW              , SYNTAX_I8_TYPE                    , L"ACS-Max-Token-Rate-Per-Flow"               , 0                                             },
    { L"aCSMaximumSDUSize"                         , ATT_ACS_MAXIMUM_SDU_SIZE                     , SYNTAX_I8_TYPE                    , L"ACS-Maximum-SDU-Size"                      , 0                                             },
    { L"aCSMinimumDelayVariation"                  , ATT_ACS_MINIMUM_DELAY_VARIATION              , SYNTAX_I8_TYPE                    , L"ACS-Minimum-Delay-Variation"               , 0                                             },
    { L"aCSMinimumLatency"                         , ATT_ACS_MINIMUM_LATENCY                      , SYNTAX_I8_TYPE                    , L"ACS-Minimum-Latency"                       , 0                                             },
    { L"aCSMinimumPolicedSize"                     , ATT_ACS_MINIMUM_POLICED_SIZE                 , SYNTAX_I8_TYPE                    , L"ACS-Minimum-Policed-Size"                  , 0                                             },
    { L"aCSNonReservedMaxSDUSize"                  , ATT_ACS_NON_RESERVED_MAX_SDU_SIZE            , SYNTAX_I8_TYPE                    , L"ACS-Non-Reserved-Max-SDU-Size"             , 0                                             },
    { L"aCSNonReservedMinPolicedSize"              , ATT_ACS_NON_RESERVED_MIN_POLICED_SIZE        , SYNTAX_I8_TYPE                    , L"ACS-Non-Reserved-Min-Policed-Size"         , 0                                             },
    { L"aCSNonReservedPeakRate"                    , ATT_ACS_NON_RESERVED_PEAK_RATE               , SYNTAX_I8_TYPE                    , L"ACS-Non-Reserved-Peak-Rate"                , 0                                             },
    { L"aCSNonReservedTokenSize"                   , ATT_ACS_NON_RESERVED_TOKEN_SIZE              , SYNTAX_I8_TYPE                    , L"ACS-Non-Reserved-Token-Size"               , 0                                             },
    { L"aCSNonReservedTxLimit"                     , ATT_ACS_NON_RESERVED_TX_LIMIT                , SYNTAX_I8_TYPE                    , L"ACS-Non-Reserved-Tx-Limit"                 , 0                                             },
    { L"aCSNonReservedTxSize"                      , ATT_ACS_NON_RESERVED_TX_SIZE                 , SYNTAX_I8_TYPE                    , L"ACS-Non-Reserved-Tx-Size"                  , 0                                             },
    { L"aCSPermissionBits"                         , ATT_ACS_PERMISSION_BITS                      , SYNTAX_I8_TYPE                    , L"ACS-Permission-Bits"                       , 0                                             },
    { L"aCSPolicyName"                             , ATT_ACS_POLICY_NAME                          , SYNTAX_UNICODE_TYPE               , L"ACS-Policy-Name"                           , 0                                             },
    { L"aCSPriority"                               , ATT_ACS_PRIORITY                             , SYNTAX_INTEGER_TYPE               , L"ACS-Priority"                              , 0                                             },
    { L"aCSRSVPAccountFilesLocation"               , ATT_ACS_RSVP_ACCOUNT_FILES_LOCATION          , SYNTAX_UNICODE_TYPE               , L"ACS-RSVP-Account-Files-Location"           , 0                                             },
    { L"aCSRSVPLogFilesLocation"                   , ATT_ACS_RSVP_LOG_FILES_LOCATION              , SYNTAX_UNICODE_TYPE               , L"ACS-RSVP-Log-Files-Location"               , 0                                             },
    { L"aCSServiceType"                            , ATT_ACS_SERVICE_TYPE                         , SYNTAX_INTEGER_TYPE               , L"ACS-Service-Type"                          , 0                                             },
    { L"aCSTimeOfDay"                              , ATT_ACS_TIME_OF_DAY                          , SYNTAX_UNICODE_TYPE               , L"ACS-Time-Of-Day"                           , 0                                             },
    { L"aCSTotalNoOfFlows"                         , ATT_ACS_TOTAL_NO_OF_FLOWS                    , SYNTAX_INTEGER_TYPE               , L"ACS-Total-No-Of-Flows"                     , 0                                             },
    { L"aCSServerList"                             , ATT_ACS_SERVER_LIST                          , SYNTAX_UNICODE_TYPE               , L"ACS-Server-List"                           , 0                                             },
    { L"notes"                                     , ATT_ADDITIONAL_INFORMATION                   , SYNTAX_UNICODE_TYPE               , L"Additional-Information"                    , 0                                             },
    { L"additionalTrustedServiceNames"             , ATT_ADDITIONAL_TRUSTED_SERVICE_NAMES         , SYNTAX_UNICODE_TYPE               , L"Additional-Trusted-Service-Names"          , 0                                             },
    { L"streetAddress"                             , ATT_ADDRESS                                  , SYNTAX_UNICODE_TYPE               , L"Address"                                   , 0                                             },
    { L"addressBookRoots"                          , ATT_ADDRESS_BOOK_ROOTS                       , SYNTAX_DISTNAME_TYPE              , L"Address-Book-Roots"                        , 0                                             },
    { L"addressEntryDisplayTable"                  , ATT_ADDRESS_ENTRY_DISPLAY_TABLE              , SYNTAX_OCTET_STRING_TYPE          , L"Address-Entry-Display-Table"               , 0                                             },
    { L"addressEntryDisplayTableMSDOS"             , ATT_ADDRESS_ENTRY_DISPLAY_TABLE_MSDOS        , SYNTAX_OCTET_STRING_TYPE          , L"Address-Entry-Display-Table-MSDOS"         , 0                                             },
    { L"homePostalAddress"                         , ATT_ADDRESS_HOME                             , SYNTAX_UNICODE_TYPE               , L"Address-Home"                              , 0                                             },
    { L"addressSyntax"                             , ATT_ADDRESS_SYNTAX                           , SYNTAX_OCTET_STRING_TYPE          , L"Address-Syntax"                            , 0                                             },
    { L"addressType"                               , ATT_ADDRESS_TYPE                             , SYNTAX_NOCASE_STRING_TYPE         , L"Address-Type"                              , 0                                             },
    { L"adminContextMenu"                          , ATT_ADMIN_CONTEXT_MENU                       , SYNTAX_UNICODE_TYPE               , L"Admin-Context-Menu"                        , 0                                             },
    { L"adminCount"                                , ATT_ADMIN_COUNT                              , SYNTAX_INTEGER_TYPE               , L"Admin-Count"                               , 0                                             },
    { L"adminDescription"                          , ATT_ADMIN_DESCRIPTION                        , SYNTAX_UNICODE_TYPE               , L"Admin-Description"                         , 0                                             },
    { L"adminDisplayName"                          , ATT_ADMIN_DISPLAY_NAME                       , SYNTAX_UNICODE_TYPE               , L"Admin-Display-Name"                        , 0                                             },
    { L"adminMultiselectPropertyPages"             , ATT_ADMIN_MULTISELECT_PROPERTY_PAGES         , SYNTAX_UNICODE_TYPE               , L"Admin-Multiselect-Property-Pages"          , 0                                             },
    { L"adminPropertyPages"                        , ATT_ADMIN_PROPERTY_PAGES                     , SYNTAX_UNICODE_TYPE               , L"Admin-Property-Pages"                      , 0                                             },
    { L"allowedAttributes"                         , ATT_ALLOWED_ATTRIBUTES                       , SYNTAX_OBJECT_ID_TYPE             , L"Allowed-Attributes"                        , 0                                             },
    { L"allowedAttributesEffective"                , ATT_ALLOWED_ATTRIBUTES_EFFECTIVE             , SYNTAX_OBJECT_ID_TYPE             , L"Allowed-Attributes-Effective"              , 0                                             },
    { L"allowedChildClasses"                       , ATT_ALLOWED_CHILD_CLASSES                    , SYNTAX_OBJECT_ID_TYPE             , L"Allowed-Child-Classes"                     , 0                                             },
    { L"allowedChildClassesEffective"              , ATT_ALLOWED_CHILD_CLASSES_EFFECTIVE          , SYNTAX_OBJECT_ID_TYPE             , L"Allowed-Child-Classes-Effective"           , 0                                             },
    { L"altSecurityIdentities"                     , ATT_ALT_SECURITY_IDENTITIES                  , SYNTAX_UNICODE_TYPE               , L"Alt-Security-Identities"                   , 0                                             },
    { L"aNR"                                       , ATT_ANR                                      , SYNTAX_UNICODE_TYPE               , L"ANR"                                       , 0                                             },
    { L"appSchemaVersion"                          , ATT_APP_SCHEMA_VERSION                       , SYNTAX_INTEGER_TYPE               , L"App-Schema-Version"                        , 0                                             },
    { L"applicationName"                           , ATT_APPLICATION_NAME                         , SYNTAX_UNICODE_TYPE               , L"Application-Name"                          , 0                                             },
    { L"appliesTo"                                 , ATT_APPLIES_TO                               , SYNTAX_UNICODE_TYPE               , L"Applies-To"                                , 0                                             },
    { L"assetNumber"                               , ATT_ASSET_NUMBER                             , SYNTAX_UNICODE_TYPE               , L"Asset-Number"                              , 0                                             },
    { L"assistant"                                 , ATT_ASSISTANT                                , SYNTAX_DISTNAME_TYPE              , L"Assistant"                                 , 0                                             },
    { L"assocNTAccount"                            , ATT_ASSOC_NT_ACCOUNT                         , SYNTAX_OCTET_STRING_TYPE          , L"Assoc-NT-Account"                          , 0                                             },
    { L"attributeDisplayNames"                     , ATT_ATTRIBUTE_DISPLAY_NAMES                  , SYNTAX_UNICODE_TYPE               , L"Attribute-Display-Names"                   , 0                                             },
    { L"attributeID"                               , ATT_ATTRIBUTE_ID                             , SYNTAX_OBJECT_ID_TYPE             , L"Attribute-ID"                              , 0                                             },
    { L"attributeSecurityGUID"                     , ATT_ATTRIBUTE_SECURITY_GUID                  , SYNTAX_OCTET_STRING_TYPE          , L"Attribute-Security-GUID"                   , 0                                             },
    { L"attributeSyntax"                           , ATT_ATTRIBUTE_SYNTAX                         , SYNTAX_OBJECT_ID_TYPE             , L"Attribute-Syntax"                          , 0                                             },
    { L"attributeTypes"                            , ATT_ATTRIBUTE_TYPES                          , SYNTAX_UNICODE_TYPE               , L"Attribute-Types"                           , 0                                             },
    { L"auditingPolicy"                            , ATT_AUDITING_POLICY                          , SYNTAX_OCTET_STRING_TYPE          , L"Auditing-Policy"                           , 0                                             },
    { L"authenticationOptions"                     , ATT_AUTHENTICATION_OPTIONS                   , SYNTAX_INTEGER_TYPE               , L"Authentication-Options"                    , 0                                             },
    { L"authorityRevocationList"                   , ATT_AUTHORITY_REVOCATION_LIST                , SYNTAX_OCTET_STRING_TYPE          , L"Authority-Revocation-List"                 , 0                                             },
    { L"auxiliaryClass"                            , ATT_AUXILIARY_CLASS                          , SYNTAX_OBJECT_ID_TYPE             , L"Auxiliary-Class"                           , 0                                             },
    { L"badPasswordTime"                           , ATT_BAD_PASSWORD_TIME                        , SYNTAX_I8_TYPE                    , L"Bad-Password-Time"                         , 0                                             },
    { L"badPwdCount"                               , ATT_BAD_PWD_COUNT                            , SYNTAX_INTEGER_TYPE               , L"Bad-Pwd-Count"                             , 0                                             },
    { L"birthLocation"                             , ATT_BIRTH_LOCATION                           , SYNTAX_OCTET_STRING_TYPE          , L"Birth-Location"                            , 0                                             },
    { L"bridgeheadServerListBL"                    , ATT_BRIDGEHEAD_SERVER_LIST_BL                , SYNTAX_DISTNAME_TYPE              , L"Bridgehead-Server-List-BL"                 , 0                                             },
    { L"bridgeheadTransportList"                   , ATT_BRIDGEHEAD_TRANSPORT_LIST                , SYNTAX_DISTNAME_TYPE              , L"Bridgehead-Transport-List"                 , 0                                             },
    { L"builtinCreationTime"                       , ATT_BUILTIN_CREATION_TIME                    , SYNTAX_I8_TYPE                    , L"Builtin-Creation-Time"                     , 0                                             },
    { L"builtinModifiedCount"                      , ATT_BUILTIN_MODIFIED_COUNT                   , SYNTAX_I8_TYPE                    , L"Builtin-Modified-Count"                    , 0                                             },
    { L"businessCategory"                          , ATT_BUSINESS_CATEGORY                        , SYNTAX_UNICODE_TYPE               , L"Business-Category"                         , 0                                             },
    { L"bytesPerMinute"                            , ATT_BYTES_PER_MINUTE                         , SYNTAX_INTEGER_TYPE               , L"Bytes-Per-Minute"                          , 0                                             },
    { L"cACertificate"                             , ATT_CA_CERTIFICATE                           , SYNTAX_OCTET_STRING_TYPE          , L"CA-Certificate"                            , 0                                             },
    { L"cACertificateDN"                           , ATT_CA_CERTIFICATE_DN                        , SYNTAX_UNICODE_TYPE               , L"CA-Certificate-DN"                         , 0                                             },
    { L"cAConnect"                                 , ATT_CA_CONNECT                               , SYNTAX_UNICODE_TYPE               , L"CA-Connect"                                , 0                                             },
    { L"cAUsages"                                  , ATT_CA_USAGES                                , SYNTAX_UNICODE_TYPE               , L"CA-Usages"                                 , 0                                             },
    { L"cAWEBURL"                                  , ATT_CA_WEB_URL                               , SYNTAX_UNICODE_TYPE               , L"CA-WEB-URL"                                , 0                                             },
    { L"canUpgradeScript"                          , ATT_CAN_UPGRADE_SCRIPT                       , SYNTAX_UNICODE_TYPE               , L"Can-Upgrade-Script"                        , 0                                             },
    { L"canonicalName"                             , ATT_CANONICAL_NAME                           , SYNTAX_UNICODE_TYPE               , L"Canonical-Name"                            , 0                                             },
    { L"catalogs"                                  , ATT_CATALOGS                                 , SYNTAX_UNICODE_TYPE               , L"Catalogs"                                  , 0                                             },
    { L"categories"                                , ATT_CATEGORIES                               , SYNTAX_UNICODE_TYPE               , L"Categories"                                , 0                                             },
    { L"categoryId"                                , ATT_CATEGORY_ID                              , SYNTAX_OCTET_STRING_TYPE          , L"Category-Id"                               , 0                                             },
    { L"certificateAuthorityObject"                , ATT_CERTIFICATE_AUTHORITY_OBJECT             , SYNTAX_DISTNAME_TYPE              , L"Certificate-Authority-Object"              , 0                                             },
    { L"certificateRevocationList"                 , ATT_CERTIFICATE_REVOCATION_LIST              , SYNTAX_OCTET_STRING_TYPE          , L"Certificate-Revocation-List"               , 0                                             },
    { L"certificateTemplates"                      , ATT_CERTIFICATE_TEMPLATES                    , SYNTAX_UNICODE_TYPE               , L"Certificate-Templates"                     , 0                                             },
    { L"classDisplayName"                          , ATT_CLASS_DISPLAY_NAME                       , SYNTAX_UNICODE_TYPE               , L"Class-Display-Name"                        , 0                                             },
    { L"codePage"                                  , ATT_CODE_PAGE                                , SYNTAX_INTEGER_TYPE               , L"Code-Page"                                 , 0                                             },
    { L"cOMClassID"                                , ATT_COM_CLASSID                              , SYNTAX_UNICODE_TYPE               , L"COM-ClassID"                               , 0                                             },
    { L"cOMCLSID"                                  , ATT_COM_CLSID                                , SYNTAX_UNICODE_TYPE               , L"COM-CLSID"                                 , 0                                             },
    { L"cOMInterfaceID"                            , ATT_COM_INTERFACEID                          , SYNTAX_UNICODE_TYPE               , L"COM-InterfaceID"                           , 0                                             },
    { L"cOMOtherProgId"                            , ATT_COM_OTHER_PROG_ID                        , SYNTAX_UNICODE_TYPE               , L"COM-Other-Prog-Id"                         , 0                                             },
    { L"cOMProgID"                                 , ATT_COM_PROGID                               , SYNTAX_UNICODE_TYPE               , L"COM-ProgID"                                , 0                                             },
    { L"cOMTreatAsClassId"                         , ATT_COM_TREAT_AS_CLASS_ID                    , SYNTAX_UNICODE_TYPE               , L"COM-Treat-As-Class-Id"                     , 0                                             },
    { L"cOMTypelibId"                              , ATT_COM_TYPELIB_ID                           , SYNTAX_UNICODE_TYPE               , L"COM-Typelib-Id"                            , 0                                             },
    { L"cOMUniqueLIBID"                            , ATT_COM_UNIQUE_LIBID                         , SYNTAX_UNICODE_TYPE               , L"COM-Unique-LIBID"                          , 0                                             },
    { L"info"                                      , ATT_COMMENT                                  , SYNTAX_UNICODE_TYPE               , L"Comment"                                   , 0                                             },
    { L"cn"                                        , ATT_COMMON_NAME                              , SYNTAX_UNICODE_TYPE               , L"Common-Name"                               , 0                                             },
    { L"company"                                   , ATT_COMPANY                                  , SYNTAX_UNICODE_TYPE               , L"Company"                                   , 0                                             },
    { L"contentIndexingAllowed"                    , ATT_CONTENT_INDEXING_ALLOWED                 , SYNTAX_BOOLEAN_TYPE               , L"Content-Indexing-Allowed"                  , 0                                             },
    { L"contextMenu"                               , ATT_CONTEXT_MENU                             , SYNTAX_UNICODE_TYPE               , L"Context-Menu"                              , 0                                             },
    { L"controlAccessRights"                       , ATT_CONTROL_ACCESS_RIGHTS                    , SYNTAX_OCTET_STRING_TYPE          , L"Control-Access-Rights"                     , 0                                             },
    { L"cost"                                      , ATT_COST                                     , SYNTAX_INTEGER_TYPE               , L"Cost"                                      , 0                                             },
    { L"countryCode"                               , ATT_COUNTRY_CODE                             , SYNTAX_INTEGER_TYPE               , L"Country-Code"                              , 0                                             },
    { L"c"                                         , ATT_COUNTRY_NAME                             , SYNTAX_UNICODE_TYPE               , L"Country-Name"                              , 0                                             },
    { L"createDialog"                              , ATT_CREATE_DIALOG                            , SYNTAX_UNICODE_TYPE               , L"Create-Dialog"                             , 0                                             },
    { L"createTimeStamp"                           , ATT_CREATE_TIME_STAMP                        , SYNTAX_TIME_TYPE                  , L"Create-Time-Stamp"                         , 0                                             },
    { L"createWizardExt"                           , ATT_CREATE_WIZARD_EXT                        , SYNTAX_UNICODE_TYPE               , L"Create-Wizard-Ext"                         , 0                                             },
    { L"creationTime"                              , ATT_CREATION_TIME                            , SYNTAX_I8_TYPE                    , L"Creation-Time"                             , 0                                             },
    { L"creationWizard"                            , ATT_CREATION_WIZARD                          , SYNTAX_UNICODE_TYPE               , L"Creation-Wizard"                           , 0                                             },
    { L"creator"                                   , ATT_CREATOR                                  , SYNTAX_UNICODE_TYPE               , L"Creator"                                   , 0                                             },
    { L"cRLObject"                                 , ATT_CRL_OBJECT                               , SYNTAX_DISTNAME_TYPE              , L"CRL-Object"                                , 0                                             },
    { L"cRLPartitionedRevocationList"              , ATT_CRL_PARTITIONED_REVOCATION_LIST          , SYNTAX_OCTET_STRING_TYPE          , L"CRL-Partitioned-Revocation-List"           , 0                                             },
    { L"crossCertificatePair"                      , ATT_CROSS_CERTIFICATE_PAIR                   , SYNTAX_OCTET_STRING_TYPE          , L"Cross-Certificate-Pair"                    , 0                                             },
    { L"currMachineId"                             , ATT_CURR_MACHINE_ID                          , SYNTAX_OCTET_STRING_TYPE          , L"Curr-Machine-Id"                           , 0                                             },
    { L"currentLocation"                           , ATT_CURRENT_LOCATION                         , SYNTAX_OCTET_STRING_TYPE          , L"Current-Location"                          , 0                                             },
    { L"currentParentCA"                           , ATT_CURRENT_PARENT_CA                        , SYNTAX_DISTNAME_TYPE              , L"Current-Parent-CA"                         , 0                                             },
    { L"currentValue"                              , ATT_CURRENT_VALUE                            , SYNTAX_OCTET_STRING_TYPE          , L"Current-Value"                             , 0                                             },
    { L"dBCSPwd"                                   , ATT_DBCS_PWD                                 , SYNTAX_OCTET_STRING_TYPE          , L"DBCS-Pwd"                                  , 0                                             },
    { L"defaultClassStore"                         , ATT_DEFAULT_CLASS_STORE                      , SYNTAX_DISTNAME_TYPE              , L"Default-Class-Store"                       , 0                                             },
    { L"defaultGroup"                              , ATT_DEFAULT_GROUP                            , SYNTAX_DISTNAME_TYPE              , L"Default-Group"                             , 0                                             },
    { L"defaultHidingValue"                        , ATT_DEFAULT_HIDING_VALUE                     , SYNTAX_BOOLEAN_TYPE               , L"Default-Hiding-Value"                      , 0                                             },
    { L"defaultLocalPolicyObject"                  , ATT_DEFAULT_LOCAL_POLICY_OBJECT              , SYNTAX_DISTNAME_TYPE              , L"Default-Local-Policy-Object"               , 0                                             },
    { L"defaultObjectCategory"                     , ATT_DEFAULT_OBJECT_CATEGORY                  , SYNTAX_DISTNAME_TYPE              , L"Default-Object-Category"                   , 0                                             },
    { L"defaultPriority"                           , ATT_DEFAULT_PRIORITY                         , SYNTAX_INTEGER_TYPE               , L"Default-Priority"                          , 0                                             },
    { L"defaultSecurityDescriptor"                 , ATT_DEFAULT_SECURITY_DESCRIPTOR              , SYNTAX_UNICODE_TYPE               , L"Default-Security-Descriptor"               , 0                                             },
    { L"deltaRevocationList"                       , ATT_DELTA_REVOCATION_LIST                    , SYNTAX_OCTET_STRING_TYPE          , L"Delta-Revocation-List"                     , 0                                             },
    { L"department"                                , ATT_DEPARTMENT                               , SYNTAX_UNICODE_TYPE               , L"Department"                                , 0                                             },
    { L"description"                               , ATT_DESCRIPTION                              , SYNTAX_UNICODE_TYPE               , L"Description"                               , 0                                             },
    { L"desktopProfile"                            , ATT_DESKTOP_PROFILE                          , SYNTAX_UNICODE_TYPE               , L"Desktop-Profile"                           , 0                                             },
    { L"destinationIndicator"                      , ATT_DESTINATION_INDICATOR                    , SYNTAX_PRINT_CASE_STRING_TYPE     , L"Destination-Indicator"                     , 0                                             },
    { L"dhcpClasses"                               , ATT_DHCP_CLASSES                             , SYNTAX_OCTET_STRING_TYPE          , L"dhcp-Classes"                              , 0                                             },
    { L"dhcpFlags"                                 , ATT_DHCP_FLAGS                               , SYNTAX_I8_TYPE                    , L"dhcp-Flags"                                , 0                                             },
    { L"dhcpIdentification"                        , ATT_DHCP_IDENTIFICATION                      , SYNTAX_UNICODE_TYPE               , L"dhcp-Identification"                       , 0                                             },
    { L"dhcpMask"                                  , ATT_DHCP_MASK                                , SYNTAX_PRINT_CASE_STRING_TYPE     , L"dhcp-Mask"                                 , 0                                             },
    { L"dhcpMaxKey"                                , ATT_DHCP_MAXKEY                              , SYNTAX_I8_TYPE                    , L"dhcp-MaxKey"                               , 0                                             },
    { L"dhcpObjDescription"                        , ATT_DHCP_OBJ_DESCRIPTION                     , SYNTAX_UNICODE_TYPE               , L"dhcp-Obj-Description"                      , 0                                             },
    { L"dhcpObjName"                               , ATT_DHCP_OBJ_NAME                            , SYNTAX_UNICODE_TYPE               , L"dhcp-Obj-Name"                             , 0                                             },
    { L"dhcpOptions"                               , ATT_DHCP_OPTIONS                             , SYNTAX_OCTET_STRING_TYPE          , L"dhcp-Options"                              , 0                                             },
    { L"dhcpProperties"                            , ATT_DHCP_PROPERTIES                          , SYNTAX_OCTET_STRING_TYPE          , L"dhcp-Properties"                           , 0                                             },
    { L"dhcpRanges"                                , ATT_DHCP_RANGES                              , SYNTAX_PRINT_CASE_STRING_TYPE     , L"dhcp-Ranges"                               , 0                                             },
    { L"dhcpReservations"                          , ATT_DHCP_RESERVATIONS                        , SYNTAX_PRINT_CASE_STRING_TYPE     , L"dhcp-Reservations"                         , 0                                             },
    { L"dhcpServers"                               , ATT_DHCP_SERVERS                             , SYNTAX_PRINT_CASE_STRING_TYPE     , L"dhcp-Servers"                              , 0                                             },
    { L"dhcpSites"                                 , ATT_DHCP_SITES                               , SYNTAX_PRINT_CASE_STRING_TYPE     , L"dhcp-Sites"                                , 0                                             },
    { L"dhcpState"                                 , ATT_DHCP_STATE                               , SYNTAX_PRINT_CASE_STRING_TYPE     , L"dhcp-State"                                , 0                                             },
    { L"dhcpSubnets"                               , ATT_DHCP_SUBNETS                             , SYNTAX_PRINT_CASE_STRING_TYPE     , L"dhcp-Subnets"                              , 0                                             },
    { L"dhcpType"                                  , ATT_DHCP_TYPE                                , SYNTAX_INTEGER_TYPE               , L"dhcp-Type"                                 , 0                                             },
    { L"dhcpUniqueKey"                             , ATT_DHCP_UNIQUE_KEY                          , SYNTAX_I8_TYPE                    , L"dhcp-Unique-Key"                           , 0                                             },
    { L"dhcpUpdateTime"                            , ATT_DHCP_UPDATE_TIME                         , SYNTAX_I8_TYPE                    , L"dhcp-Update-Time"                          , 0                                             },
    { L"displayName"                               , ATT_DISPLAY_NAME                             , SYNTAX_UNICODE_TYPE               , L"Display-Name"                              , 0                                             },
    { L"displayNamePrintable"                      , ATT_DISPLAY_NAME_PRINTABLE                   , SYNTAX_PRINT_CASE_STRING_TYPE     , L"Display-Name-Printable"                    , 0                                             },
    { L"dITContentRules"                           , ATT_DIT_CONTENT_RULES                        , SYNTAX_UNICODE_TYPE               , L"DIT-Content-Rules"                         , 0                                             },
    { L"division"                                  , ATT_DIVISION                                 , SYNTAX_UNICODE_TYPE               , L"Division"                                  , 0                                             },
    { L"dMDLocation"                               , ATT_DMD_LOCATION                             , SYNTAX_DISTNAME_TYPE              , L"DMD-Location"                              , 0                                             },
    { L"dmdName"                                   , ATT_DMD_NAME                                 , SYNTAX_UNICODE_TYPE               , L"DMD-Name"                                  , 0                                             },
    { L"dNReferenceUpdate"                         , ATT_DN_REFERENCE_UPDATE                      , SYNTAX_DISTNAME_TYPE              , L"DN-Reference-Update"                       , 0                                             },
    { L"dnsAllowDynamic"                           , ATT_DNS_ALLOW_DYNAMIC                        , SYNTAX_BOOLEAN_TYPE               , L"Dns-Allow-Dynamic"                         , 0                                             },
    { L"dnsAllowXFR"                               , ATT_DNS_ALLOW_XFR                            , SYNTAX_BOOLEAN_TYPE               , L"Dns-Allow-XFR"                             , 0                                             },
    { L"dNSHostName"                               , ATT_DNS_HOST_NAME                            , SYNTAX_UNICODE_TYPE               , L"DNS-Host-Name"                             , 0                                             },
    { L"dnsNotifySecondaries"                      , ATT_DNS_NOTIFY_SECONDARIES                   , SYNTAX_INTEGER_TYPE               , L"Dns-Notify-Secondaries"                    , 0                                             },
    { L"dNSProperty"                               , ATT_DNS_PROPERTY                             , SYNTAX_OCTET_STRING_TYPE          , L"DNS-Property"                              , 0                                             },
    { L"dnsRecord"                                 , ATT_DNS_RECORD                               , SYNTAX_OCTET_STRING_TYPE          , L"Dns-Record"                                , 0                                             },
    { L"dnsRoot"                                   , ATT_DNS_ROOT                                 , SYNTAX_UNICODE_TYPE               , L"Dns-Root"                                  , 0                                             },
    { L"dnsSecureSecondaries"                      , ATT_DNS_SECURE_SECONDARIES                   , SYNTAX_INTEGER_TYPE               , L"Dns-Secure-Secondaries"                    , 0                                             },
    { L"dNSTombstoned"                             , ATT_DNS_TOMBSTONED                           , SYNTAX_BOOLEAN_TYPE               , L"DNS-Tombstoned"                            , 0                                             },
    { L"domainCAs"                                 , ATT_DOMAIN_CERTIFICATE_AUTHORITIES           , SYNTAX_DISTNAME_TYPE              , L"Domain-Certificate-Authorities"            , 0                                             },
    { L"dc"                                        , ATT_DOMAIN_COMPONENT                         , SYNTAX_UNICODE_TYPE               , L"Domain-Component"                          , 0                                             },
    { L"domainCrossRef"                            , ATT_DOMAIN_CROSS_REF                         , SYNTAX_DISTNAME_TYPE              , L"Domain-Cross-Ref"                          , 0                                             },
    { L"domainID"                                  , ATT_DOMAIN_ID                                , SYNTAX_DISTNAME_TYPE              , L"Domain-ID"                                 , 0                                             },
    { L"domainIdentifier"                          , ATT_DOMAIN_IDENTIFIER                        , SYNTAX_INTEGER_TYPE               , L"Domain-Identifier"                         , 0                                             },
    { L"domainPolicyObject"                        , ATT_DOMAIN_POLICY_OBJECT                     , SYNTAX_DISTNAME_TYPE              , L"Domain-Policy-Object"                      , 0                                             },
    { L"domainPolicyReference"                     , ATT_DOMAIN_POLICY_REFERENCE                  , SYNTAX_DISTNAME_TYPE              , L"Domain-Policy-Reference"                   , 0                                             },
    { L"domainReplica"                             , ATT_DOMAIN_REPLICA                           , SYNTAX_UNICODE_TYPE               , L"Domain-Replica"                            , 0                                             },
    { L"domainWidePolicy"                          , ATT_DOMAIN_WIDE_POLICY                       , SYNTAX_OCTET_STRING_TYPE          , L"Domain-Wide-Policy"                        , 0                                             },
    { L"driverName"                                , ATT_DRIVER_NAME                              , SYNTAX_UNICODE_TYPE               , L"Driver-Name"                               , 0                                             },
    { L"driverVersion"                             , ATT_DRIVER_VERSION                           , SYNTAX_INTEGER_TYPE               , L"Driver-Version"                            , 0                                             },
    { L"dSCorePropagationData"                     , ATT_DS_CORE_PROPAGATION_DATA                 , SYNTAX_TIME_TYPE                  , L"DS-Core-Propagation-Data"                  , 0                                             },
    { L"dSHeuristics"                              , ATT_DS_HEURISTICS                            , SYNTAX_UNICODE_TYPE               , L"DS-Heuristics"                             , 0                                             },
    { L"dSUIAdminMaximum"                          , ATT_DS_UI_ADMIN_MAXIMUM                      , SYNTAX_INTEGER_TYPE               , L"DS-UI-Admin-Maximum"                       , 0                                             },
    { L"dSUIAdminNotification"                     , ATT_DS_UI_ADMIN_NOTIFICATION                 , SYNTAX_UNICODE_TYPE               , L"DS-UI-Admin-Notification"                  , 0                                             },
    { L"dSUIShellMaximum"                          , ATT_DS_UI_SHELL_MAXIMUM                      , SYNTAX_INTEGER_TYPE               , L"DS-UI-Shell-Maximum"                       , 0                                             },
    { L"dSASignature"                              , ATT_DSA_SIGNATURE                            , SYNTAX_OCTET_STRING_TYPE          , L"DSA-Signature"                             , 0                                             },
    { L"dynamicLDAPServer"                         , ATT_DYNAMIC_LDAP_SERVER                      , SYNTAX_DISTNAME_TYPE              , L"Dynamic-LDAP-Server"                       , 0                                             },
    { L"mail"                                      , ATT_E_MAIL_ADDRESSES                         , SYNTAX_UNICODE_TYPE               , L"E-mail-Addresses"                          , 0                                             },
    { L"eFSPolicy"                                 , ATT_EFSPOLICY                                , SYNTAX_OCTET_STRING_TYPE          , L"EFSPolicy"                                 , 0                                             },
    { L"employeeID"                                , ATT_EMPLOYEE_ID                              , SYNTAX_UNICODE_TYPE               , L"Employee-ID"                               , 0                                             },
    { L"employeeNumber"                            , ATT_EMPLOYEE_NUMBER                          , SYNTAX_UNICODE_TYPE               , L"Employee-Number"                           , 0                                             },
    { L"employeeType"                              , ATT_EMPLOYEE_TYPE                            , SYNTAX_UNICODE_TYPE               , L"Employee-Type"                             , 0                                             },
    { L"Enabled"                                   , ATT_ENABLED                                  , SYNTAX_BOOLEAN_TYPE               , L"Enabled"                                   , 0                                             },
    { L"enabledConnection"                         , ATT_ENABLED_CONNECTION                       , SYNTAX_BOOLEAN_TYPE               , L"Enabled-Connection"                        , 0                                             },
    { L"enrollmentProviders"                       , ATT_ENROLLMENT_PROVIDERS                     , SYNTAX_UNICODE_TYPE               , L"Enrollment-Providers"                      , 0                                             },
    { L"entryTTL"                                  , ATT_ENTRY_TTL                                , SYNTAX_INTEGER_TYPE               , L"Entry-TTL"                                 , 0                                             },
    { L"extendedAttributeInfo"                     , ATT_EXTENDED_ATTRIBUTE_INFO                  , SYNTAX_UNICODE_TYPE               , L"Extended-Attribute-Info"                   , 0                                             },
    { L"extendedCharsAllowed"                      , ATT_EXTENDED_CHARS_ALLOWED                   , SYNTAX_BOOLEAN_TYPE               , L"Extended-Chars-Allowed"                    , 0                                             },
    { L"extendedClassInfo"                         , ATT_EXTENDED_CLASS_INFO                      , SYNTAX_UNICODE_TYPE               , L"Extended-Class-Info"                       , 0                                             },
    { L"extensionName"                             , ATT_EXTENSION_NAME                           , SYNTAX_UNICODE_TYPE               , L"Extension-Name"                            , 0                                             },
    { L"extraColumns"                              , ATT_EXTRA_COLUMNS                            , SYNTAX_UNICODE_TYPE               , L"Extra-Columns"                             , 0                                             },
    { L"facsimileTelephoneNumber"                  , ATT_FACSIMILE_TELEPHONE_NUMBER               , SYNTAX_UNICODE_TYPE               , L"Facsimile-Telephone-Number"                , 0                                             },
    { L"fileExtPriority"                           , ATT_FILE_EXT_PRIORITY                        , SYNTAX_UNICODE_TYPE               , L"File-Ext-Priority"                         , 0                                             },
    { L"flags"                                     , ATT_FLAGS                                    , SYNTAX_INTEGER_TYPE               , L"Flags"                                     , 0                                             },
    { L"flatName"                                  , ATT_FLAT_NAME                                , SYNTAX_UNICODE_TYPE               , L"Flat-Name"                                 , 0                                             },
    { L"forceLogoff"                               , ATT_FORCE_LOGOFF                             , SYNTAX_I8_TYPE                    , L"Force-Logoff"                              , 0                                             },
    { L"foreignIdentifier"                         , ATT_FOREIGN_IDENTIFIER                       , SYNTAX_OCTET_STRING_TYPE          , L"Foreign-Identifier"                        , 0                                             },
    { L"friendlyNames"                             , ATT_FRIENDLY_NAMES                           , SYNTAX_UNICODE_TYPE               , L"Friendly-Names"                            , 0                                             },
    { L"fromEntry"                                 , ATT_FROM_ENTRY                               , SYNTAX_BOOLEAN_TYPE               , L"From-Entry"                                , 0                                             },
    { L"fromServer"                                , ATT_FROM_SERVER                              , SYNTAX_DISTNAME_TYPE              , L"From-Server"                               , 0                                             },
    { L"frsComputerReference"                      , ATT_FRS_COMPUTER_REFERENCE                   , SYNTAX_DISTNAME_TYPE              , L"Frs-Computer-Reference"                    , 0                                             },
    { L"frsComputerReferenceBL"                    , ATT_FRS_COMPUTER_REFERENCE_BL                , SYNTAX_DISTNAME_TYPE              , L"Frs-Computer-Reference-BL"                 , 0                                             },
    { L"fRSControlDataCreation"                    , ATT_FRS_CONTROL_DATA_CREATION                , SYNTAX_UNICODE_TYPE               , L"FRS-Control-Data-Creation"                 , 0                                             },
    { L"fRSControlInboundBacklog"                  , ATT_FRS_CONTROL_INBOUND_BACKLOG              , SYNTAX_UNICODE_TYPE               , L"FRS-Control-Inbound-Backlog"               , 0                                             },
    { L"fRSControlOutboundBacklog"                 , ATT_FRS_CONTROL_OUTBOUND_BACKLOG             , SYNTAX_UNICODE_TYPE               , L"FRS-Control-Outbound-Backlog"              , 0                                             },
    { L"fRSDirectoryFilter"                        , ATT_FRS_DIRECTORY_FILTER                     , SYNTAX_UNICODE_TYPE               , L"FRS-Directory-Filter"                      , 0                                             },
    { L"fRSDSPoll"                                 , ATT_FRS_DS_POLL                              , SYNTAX_INTEGER_TYPE               , L"FRS-DS-Poll"                               , 0                                             },
    { L"fRSExtensions"                             , ATT_FRS_EXTENSIONS                           , SYNTAX_OCTET_STRING_TYPE          , L"FRS-Extensions"                            , 0                                             },
    { L"fRSFaultCondition"                         , ATT_FRS_FAULT_CONDITION                      , SYNTAX_UNICODE_TYPE               , L"FRS-Fault-Condition"                       , 0                                             },
    { L"fRSFileFilter"                             , ATT_FRS_FILE_FILTER                          , SYNTAX_UNICODE_TYPE               , L"FRS-File-Filter"                           , 0                                             },
    { L"fRSFlags"                                  , ATT_FRS_FLAGS                                , SYNTAX_INTEGER_TYPE               , L"FRS-Flags"                                 , 0                                             },
    { L"fRSLevelLimit"                             , ATT_FRS_LEVEL_LIMIT                          , SYNTAX_INTEGER_TYPE               , L"FRS-Level-Limit"                           , 0                                             },
    { L"fRSMemberReference"                        , ATT_FRS_MEMBER_REFERENCE                     , SYNTAX_DISTNAME_TYPE              , L"FRS-Member-Reference"                      , 0                                             },
    { L"fRSMemberReferenceBL"                      , ATT_FRS_MEMBER_REFERENCE_BL                  , SYNTAX_DISTNAME_TYPE              , L"FRS-Member-Reference-BL"                   , 0                                             },
    { L"fRSPartnerAuthLevel"                       , ATT_FRS_PARTNER_AUTH_LEVEL                   , SYNTAX_INTEGER_TYPE               , L"FRS-Partner-Auth-Level"                    , 0                                             },
    { L"fRSPrimaryMember"                          , ATT_FRS_PRIMARY_MEMBER                       , SYNTAX_DISTNAME_TYPE              , L"FRS-Primary-Member"                        , 0                                             },
    { L"fRSReplicaSetGUID"                         , ATT_FRS_REPLICA_SET_GUID                     , SYNTAX_OCTET_STRING_TYPE          , L"FRS-Replica-Set-GUID"                      , 0                                             },
    { L"fRSReplicaSetType"                         , ATT_FRS_REPLICA_SET_TYPE                     , SYNTAX_INTEGER_TYPE               , L"FRS-Replica-Set-Type"                      , 0                                             },
    { L"fRSRootPath"                               , ATT_FRS_ROOT_PATH                            , SYNTAX_UNICODE_TYPE               , L"FRS-Root-Path"                             , 0                                             },
    { L"fRSRootSecurity"                           , ATT_FRS_ROOT_SECURITY                        , SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE, L"FRS-Root-Security"                         , 0                                             },
    { L"fRSServiceCommand"                         , ATT_FRS_SERVICE_COMMAND                      , SYNTAX_UNICODE_TYPE               , L"FRS-Service-Command"                       , 0                                             },
    { L"fRSServiceCommandStatus"                   , ATT_FRS_SERVICE_COMMAND_STATUS               , SYNTAX_UNICODE_TYPE               , L"FRS-Service-Command-Status"                , 0                                             },
    { L"fRSStagingPath"                            , ATT_FRS_STAGING_PATH                         , SYNTAX_UNICODE_TYPE               , L"FRS-Staging-Path"                          , 0                                             },
    { L"fRSTimeLastCommand"                        , ATT_FRS_TIME_LAST_COMMAND                    , SYNTAX_TIME_TYPE                  , L"FRS-Time-Last-Command"                     , 0                                             },
    { L"fRSTimeLastConfigChange"                   , ATT_FRS_TIME_LAST_CONFIG_CHANGE              , SYNTAX_TIME_TYPE                  , L"FRS-Time-Last-Config-Change"               , 0                                             },
    { L"fRSUpdateTimeout"                          , ATT_FRS_UPDATE_TIMEOUT                       , SYNTAX_INTEGER_TYPE               , L"FRS-Update-Timeout"                        , 0                                             },
    { L"fRSVersion"                                , ATT_FRS_VERSION                              , SYNTAX_UNICODE_TYPE               , L"FRS-Version"                               , 0                                             },
    { L"fRSVersionGUID"                            , ATT_FRS_VERSION_GUID                         , SYNTAX_OCTET_STRING_TYPE          , L"FRS-Version-GUID"                          , 0                                             },
    { L"fRSWorkingPath"                            , ATT_FRS_WORKING_PATH                         , SYNTAX_UNICODE_TYPE               , L"FRS-Working-Path"                          , 0                                             },
    { L"fSMORoleOwner"                             , ATT_FSMO_ROLE_OWNER                          , SYNTAX_DISTNAME_TYPE              , L"FSMO-Role-Owner"                           , 0                                             },
    { L"garbageCollPeriod"                         , ATT_GARBAGE_COLL_PERIOD                      , SYNTAX_INTEGER_TYPE               , L"Garbage-Coll-Period"                       , 0                                             },
    { L"generatedConnection"                       , ATT_GENERATED_CONNECTION                     , SYNTAX_BOOLEAN_TYPE               , L"Generated-Connection"                      , 0                                             },
    { L"generationQualifier"                       , ATT_GENERATION_QUALIFIER                     , SYNTAX_UNICODE_TYPE               , L"Generation-Qualifier"                      , 0                                             },
    { L"givenName"                                 , ATT_GIVEN_NAME                               , SYNTAX_UNICODE_TYPE               , L"Given-Name"                                , 0                                             },
    { L"globalAddressList"                         , ATT_GLOBAL_ADDRESS_LIST                      , SYNTAX_DISTNAME_TYPE              , L"Global-Address-List"                       , 0                                             },
    { L"governsID"                                 , ATT_GOVERNS_ID                               , SYNTAX_OBJECT_ID_TYPE             , L"Governs-ID"                                , 0                                             },
    { L"gPLink"                                    , ATT_GP_LINK                                  , SYNTAX_UNICODE_TYPE               , L"GP-Link"                                   , 0                                             },
    { L"gPOptions"                                 , ATT_GP_OPTIONS                               , SYNTAX_INTEGER_TYPE               , L"GP-Options"                                , 0                                             },
    { L"gPCFileSysPath"                            , ATT_GPC_FILE_SYS_PATH                        , SYNTAX_UNICODE_TYPE               , L"GPC-File-Sys-Path"                         , 0                                             },
    { L"gPCFunctionalityVersion"                   , ATT_GPC_FUNCTIONALITY_VERSION                , SYNTAX_INTEGER_TYPE               , L"GPC-Functionality-Version"                 , 0                                             },
    { L"gPCMachineExtensionNames"                  , ATT_GPC_MACHINE_EXTENSION_NAMES              , SYNTAX_UNICODE_TYPE               , L"GPC-Machine-Extension-Names"               , 0                                             },
    { L"gPCUserExtensionNames"                     , ATT_GPC_USER_EXTENSION_NAMES                 , SYNTAX_UNICODE_TYPE               , L"GPC-User-Extension-Names"                  , 0                                             },
    { L"gPCWQLFilter"                              , ATT_GPC_WQL_FILTER                           , SYNTAX_UNICODE_TYPE               , L"GPC-WQL-Filter"                            , 0                                             },
    { L"groupAttributes"                           , ATT_GROUP_ATTRIBUTES                         , SYNTAX_INTEGER_TYPE               , L"Group-Attributes"                          , 0                                             },
    { L"groupMembershipSAM"                        , ATT_GROUP_MEMBERSHIP_SAM                     , SYNTAX_OCTET_STRING_TYPE          , L"Group-Membership-SAM"                      , 0                                             },
    { L"groupPriority"                             , ATT_GROUP_PRIORITY                           , SYNTAX_UNICODE_TYPE               , L"Group-Priority"                            , 0                                             },
    { L"groupType"                                 , ATT_GROUP_TYPE                               , SYNTAX_INTEGER_TYPE               , L"Group-Type"                                , 0                                             },
    { L"groupstoIgnore"                            , ATT_GROUPS_TO_IGNORE                         , SYNTAX_UNICODE_TYPE               , L"Groups-to-Ignore"                          , 0                                             },
    { L"hasMasterNCs"                              , ATT_HAS_MASTER_NCS                           , SYNTAX_DISTNAME_TYPE              , L"Has-Master-NCs"                            , 0                                             },
    { L"hasPartialReplicaNCs"                      , ATT_HAS_PARTIAL_REPLICA_NCS                  , SYNTAX_DISTNAME_TYPE              , L"Has-Partial-Replica-NCs"                   , 0                                             },
    { L"helpData16"                                , ATT_HELP_DATA16                              , SYNTAX_OCTET_STRING_TYPE          , L"Help-Data16"                               , 0                                             },
    { L"helpData32"                                , ATT_HELP_DATA32                              , SYNTAX_OCTET_STRING_TYPE          , L"Help-Data32"                               , 0                                             },
    { L"helpFileName"                              , ATT_HELP_FILE_NAME                           , SYNTAX_UNICODE_TYPE               , L"Help-File-Name"                            , 0                                             },
    { L"homeDirectory"                             , ATT_HOME_DIRECTORY                           , SYNTAX_UNICODE_TYPE               , L"Home-Directory"                            , 0                                             },
    { L"homeDrive"                                 , ATT_HOME_DRIVE                               , SYNTAX_UNICODE_TYPE               , L"Home-Drive"                                , 0                                             },
    { L"iconPath"                                  , ATT_ICON_PATH                                , SYNTAX_UNICODE_TYPE               , L"Icon-Path"                                 , 0                                             },
    { L"implementedCategories"                     , ATT_IMPLEMENTED_CATEGORIES                   , SYNTAX_OCTET_STRING_TYPE          , L"Implemented-Categories"                    , 0                                             },
    { L"indexedScopes"                             , ATT_INDEXEDSCOPES                            , SYNTAX_UNICODE_TYPE               , L"IndexedScopes"                             , 0                                             },
    { L"initialAuthIncoming"                       , ATT_INITIAL_AUTH_INCOMING                    , SYNTAX_UNICODE_TYPE               , L"Initial-Auth-Incoming"                     , 0                                             },
    { L"initialAuthOutgoing"                       , ATT_INITIAL_AUTH_OUTGOING                    , SYNTAX_UNICODE_TYPE               , L"Initial-Auth-Outgoing"                     , 0                                             },
    { L"initials"                                  , ATT_INITIALS                                 , SYNTAX_UNICODE_TYPE               , L"Initials"                                  , 0                                             },
    { L"installUiLevel"                            , ATT_INSTALL_UI_LEVEL                         , SYNTAX_INTEGER_TYPE               , L"Install-Ui-Level"                          , 0                                             },
    { L"instanceType"                              , ATT_INSTANCE_TYPE                            , SYNTAX_INTEGER_TYPE               , L"Instance-Type"                             , 0                                             },
    { L"interSiteTopologyFailover"                 , ATT_INTER_SITE_TOPOLOGY_FAILOVER             , SYNTAX_INTEGER_TYPE               , L"Inter-Site-Topology-Failover"              , 0                                             },
    { L"interSiteTopologyGenerator"                , ATT_INTER_SITE_TOPOLOGY_GENERATOR            , SYNTAX_DISTNAME_TYPE              , L"Inter-Site-Topology-Generator"             , 0                                             },
    { L"interSiteTopologyRenew"                    , ATT_INTER_SITE_TOPOLOGY_RENEW                , SYNTAX_INTEGER_TYPE               , L"Inter-Site-Topology-Renew"                 , 0                                             },
    { L"internationalISDNNumber"                   , ATT_INTERNATIONAL_ISDN_NUMBER                , SYNTAX_NUMERIC_STRING_TYPE        , L"International-ISDN-Number"                 , 0                                             },
    { L"invocationId"                              , ATT_INVOCATION_ID                            , SYNTAX_OCTET_STRING_TYPE          , L"Invocation-Id"                             , 0                                             },
    { L"ipsecData"                                 , ATT_IPSEC_DATA                               , SYNTAX_OCTET_STRING_TYPE          , L"Ipsec-Data"                                , 0                                             },
    { L"ipsecDataType"                             , ATT_IPSEC_DATA_TYPE                          , SYNTAX_INTEGER_TYPE               , L"Ipsec-Data-Type"                           , 0                                             },
    { L"ipsecFilterReference"                      , ATT_IPSEC_FILTER_REFERENCE                   , SYNTAX_DISTNAME_TYPE              , L"Ipsec-Filter-Reference"                    , 0                                             },
    { L"ipsecID"                                   , ATT_IPSEC_ID                                 , SYNTAX_UNICODE_TYPE               , L"Ipsec-ID"                                  , 0                                             },
    { L"ipsecISAKMPReference"                      , ATT_IPSEC_ISAKMP_REFERENCE                   , SYNTAX_DISTNAME_TYPE              , L"Ipsec-ISAKMP-Reference"                    , 0                                             },
    { L"ipsecName"                                 , ATT_IPSEC_NAME                               , SYNTAX_UNICODE_TYPE               , L"Ipsec-Name"                                , 0                                             },
    { L"iPSECNegotiationPolicyAction"              , ATT_IPSEC_NEGOTIATION_POLICY_ACTION          , SYNTAX_UNICODE_TYPE               , L"IPSEC-Negotiation-Policy-Action"           , 0                                             },
    { L"ipsecNegotiationPolicyReference"           , ATT_IPSEC_NEGOTIATION_POLICY_REFERENCE       , SYNTAX_DISTNAME_TYPE              , L"Ipsec-Negotiation-Policy-Reference"        , 0                                             },
    { L"iPSECNegotiationPolicyType"                , ATT_IPSEC_NEGOTIATION_POLICY_TYPE            , SYNTAX_UNICODE_TYPE               , L"IPSEC-Negotiation-Policy-Type"             , 0                                             },
    { L"ipsecNFAReference"                         , ATT_IPSEC_NFA_REFERENCE                      , SYNTAX_DISTNAME_TYPE              , L"Ipsec-NFA-Reference"                       , 0                                             },
    { L"ipsecOwnersReference"                      , ATT_IPSEC_OWNERS_REFERENCE                   , SYNTAX_DISTNAME_TYPE              , L"Ipsec-Owners-Reference"                    , 0                                             },
    { L"ipsecPolicyReference"                      , ATT_IPSEC_POLICY_REFERENCE                   , SYNTAX_DISTNAME_TYPE              , L"Ipsec-Policy-Reference"                    , 0                                             },
    { L"isCriticalSystemObject"                    , ATT_IS_CRITICAL_SYSTEM_OBJECT                , SYNTAX_BOOLEAN_TYPE               , L"Is-Critical-System-Object"                 , 0                                             },
    { L"isDefunct"                                 , ATT_IS_DEFUNCT                               , SYNTAX_BOOLEAN_TYPE               , L"Is-Defunct"                                , 0                                             },
    { L"isDeleted"                                 , ATT_IS_DELETED                               , SYNTAX_BOOLEAN_TYPE               , L"Is-Deleted"                                , 0                                             },
    { L"isEphemeral"                               , ATT_IS_EPHEMERAL                             , SYNTAX_BOOLEAN_TYPE               , L"Is-Ephemeral"                              , 0                                             },
    { L"memberOf"                                  , ATT_IS_MEMBER_OF_DL                          , SYNTAX_DISTNAME_TYPE              , L"Is-Member-Of-DL"                           , 0                                             },
    { L"isMemberOfPartialAttributeSet"             , ATT_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET       , SYNTAX_BOOLEAN_TYPE               , L"Is-Member-Of-Partial-Attribute-Set"        , 0                                             },
    { L"isPrivilegeHolder"                         , ATT_IS_PRIVILEGE_HOLDER                      , SYNTAX_DISTNAME_TYPE              , L"Is-Privilege-Holder"                       , 0                                             },
    { L"isSingleValued"                            , ATT_IS_SINGLE_VALUED                         , SYNTAX_BOOLEAN_TYPE               , L"Is-Single-Valued"                          , 0                                             },
    { L"keywords"                                  , ATT_KEYWORDS                                 , SYNTAX_UNICODE_TYPE               , L"Keywords"                                  , 0                                             },
    { L"knowledgeInformation"                      , ATT_KNOWLEDGE_INFORMATION                    , SYNTAX_NOCASE_STRING_TYPE         , L"Knowledge-Information"                     , 0                                             },
    { L"lastBackupRestorationTime"                 , ATT_LAST_BACKUP_RESTORATION_TIME             , SYNTAX_I8_TYPE                    , L"Last-Backup-Restoration-Time"              , 0                                             },
    { L"lastContentIndexed"                        , ATT_LAST_CONTENT_INDEXED                     , SYNTAX_I8_TYPE                    , L"Last-Content-Indexed"                      , 0                                             },
    { L"lastKnownParent"                           , ATT_LAST_KNOWN_PARENT                        , SYNTAX_DISTNAME_TYPE              , L"Last-Known-Parent"                         , 0                                             },
    { L"lastLogoff"                                , ATT_LAST_LOGOFF                              , SYNTAX_I8_TYPE                    , L"Last-Logoff"                               , 0                                             },
    { L"lastLogon"                                 , ATT_LAST_LOGON                               , SYNTAX_I8_TYPE                    , L"Last-Logon"                                , 0                                             },
    { L"lastLogonTimestamp"                        , ATT_LAST_LOGON_TIMESTAMP                     , SYNTAX_I8_TYPE                    , L"Last-Logon-Timestamp"                      , 0                                             },
    { L"lastSetTime"                               , ATT_LAST_SET_TIME                            , SYNTAX_I8_TYPE                    , L"Last-Set-Time"                             , 0                                             },
    { L"lastUpdateSequence"                        , ATT_LAST_UPDATE_SEQUENCE                     , SYNTAX_UNICODE_TYPE               , L"Last-Update-Sequence"                      , 0                                             },
    { L"lDAPAdminLimits"                           , ATT_LDAP_ADMIN_LIMITS                        , SYNTAX_UNICODE_TYPE               , L"LDAP-Admin-Limits"                         , 0                                             },
    { L"lDAPDisplayName"                           , ATT_LDAP_DISPLAY_NAME                        , SYNTAX_UNICODE_TYPE               , L"LDAP-Display-Name"                         , 0                                             },
    { L"lDAPIPDenyList"                            , ATT_LDAP_IPDENY_LIST                         , SYNTAX_OCTET_STRING_TYPE          , L"LDAP-IPDeny-List"                          , 0                                             },
    { L"legacyExchangeDN"                          , ATT_LEGACY_EXCHANGE_DN                       , SYNTAX_NOCASE_STRING_TYPE         , L"Legacy-Exchange-DN"                        , 0                                             },
    { L"linkID"                                    , ATT_LINK_ID                                  , SYNTAX_INTEGER_TYPE               , L"Link-ID"                                   , 0                                             },
    { L"linkTrackSecret"                           , ATT_LINK_TRACK_SECRET                        , SYNTAX_OCTET_STRING_TYPE          , L"Link-Track-Secret"                         , 0                                             },
    { L"lmPwdHistory"                              , ATT_LM_PWD_HISTORY                           , SYNTAX_OCTET_STRING_TYPE          , L"Lm-Pwd-History"                            , 0                                             },
    { L"localPolicyFlags"                          , ATT_LOCAL_POLICY_FLAGS                       , SYNTAX_INTEGER_TYPE               , L"Local-Policy-Flags"                        , 0                                             },
    { L"localPolicyReference"                      , ATT_LOCAL_POLICY_REFERENCE                   , SYNTAX_DISTNAME_TYPE              , L"Local-Policy-Reference"                    , 0                                             },
    { L"localeID"                                  , ATT_LOCALE_ID                                , SYNTAX_INTEGER_TYPE               , L"Locale-ID"                                 , 0                                             },
    { L"l"                                         , ATT_LOCALITY_NAME                            , SYNTAX_UNICODE_TYPE               , L"Locality-Name"                             , 0                                             },
    { L"localizedDescription"                      , ATT_LOCALIZED_DESCRIPTION                    , SYNTAX_UNICODE_TYPE               , L"Localized-Description"                     , 0                                             },
    { L"localizationDisplayId"                     , ATT_LOCALIZATION_DISPLAY_ID                  , SYNTAX_INTEGER_TYPE               , L"Localization-Display-Id"                   , 0                                             },
    { L"location"                                  , ATT_LOCATION                                 , SYNTAX_UNICODE_TYPE               , L"Location"                                  , 0                                             },
    { L"lockOutObservationWindow"                  , ATT_LOCK_OUT_OBSERVATION_WINDOW              , SYNTAX_I8_TYPE                    , L"Lock-Out-Observation-Window"               , 0                                             },
    { L"lockoutDuration"                           , ATT_LOCKOUT_DURATION                         , SYNTAX_I8_TYPE                    , L"Lockout-Duration"                          , 0                                             },
    { L"lockoutThreshold"                          , ATT_LOCKOUT_THRESHOLD                        , SYNTAX_INTEGER_TYPE               , L"Lockout-Threshold"                         , 0                                             },
    { L"lockoutTime"                               , ATT_LOCKOUT_TIME                             , SYNTAX_I8_TYPE                    , L"Lockout-Time"                              , 0                                             },
    { L"thumbnailLogo"                             , ATT_LOGO                                     , SYNTAX_OCTET_STRING_TYPE          , L"Logo"                                      , 0                                             },
    { L"logonCount"                                , ATT_LOGON_COUNT                              , SYNTAX_INTEGER_TYPE               , L"Logon-Count"                               , 0                                             },
    { L"logonHours"                                , ATT_LOGON_HOURS                              , SYNTAX_OCTET_STRING_TYPE          , L"Logon-Hours"                               , 0                                             },
    { L"logonWorkstation"                          , ATT_LOGON_WORKSTATION                        , SYNTAX_OCTET_STRING_TYPE          , L"Logon-Workstation"                         , 0                                             },
    { L"lSACreationTime"                           , ATT_LSA_CREATION_TIME                        , SYNTAX_I8_TYPE                    , L"LSA-Creation-Time"                         , 0                                             },
    { L"lSAModifiedCount"                          , ATT_LSA_MODIFIED_COUNT                       , SYNTAX_I8_TYPE                    , L"LSA-Modified-Count"                        , 0                                             },
    { L"machineArchitecture"                       , ATT_MACHINE_ARCHITECTURE                     , SYNTAX_INTEGER_TYPE               , L"Machine-Architecture"                      , 0                                             },
    { L"machinePasswordChangeInterval"             , ATT_MACHINE_PASSWORD_CHANGE_INTERVAL         , SYNTAX_I8_TYPE                    , L"Machine-Password-Change-Interval"          , 0                                             },
    { L"machineRole"                               , ATT_MACHINE_ROLE                             , SYNTAX_INTEGER_TYPE               , L"Machine-Role"                              , 0                                             },
    { L"machineWidePolicy"                         , ATT_MACHINE_WIDE_POLICY                      , SYNTAX_OCTET_STRING_TYPE          , L"Machine-Wide-Policy"                       , 0                                             },
    { L"managedBy"                                 , ATT_MANAGED_BY                               , SYNTAX_DISTNAME_TYPE              , L"Managed-By"                                , 0                                             },
    { L"managedObjects"                            , ATT_MANAGED_OBJECTS                          , SYNTAX_DISTNAME_TYPE              , L"Managed-Objects"                           , 0                                             },
    { L"manager"                                   , ATT_MANAGER                                  , SYNTAX_DISTNAME_TYPE              , L"Manager"                                   , 0                                             },
    { L"mAPIID"                                    , ATT_MAPI_ID                                  , SYNTAX_INTEGER_TYPE               , L"MAPI-ID"                                   , 0                                             },
    { L"marshalledInterface"                       , ATT_MARSHALLED_INTERFACE                     , SYNTAX_OCTET_STRING_TYPE          , L"Marshalled-Interface"                      , 0                                             },
    { L"masteredBy"                                , ATT_MASTERED_BY                              , SYNTAX_DISTNAME_TYPE              , L"Mastered-By"                               , 0                                             },
    { L"maxPwdAge"                                 , ATT_MAX_PWD_AGE                              , SYNTAX_I8_TYPE                    , L"Max-Pwd-Age"                               , 0                                             },
    { L"maxRenewAge"                               , ATT_MAX_RENEW_AGE                            , SYNTAX_I8_TYPE                    , L"Max-Renew-Age"                             , 0                                             },
    { L"maxStorage"                                , ATT_MAX_STORAGE                              , SYNTAX_I8_TYPE                    , L"Max-Storage"                               , 0                                             },
    { L"maxTicketAge"                              , ATT_MAX_TICKET_AGE                           , SYNTAX_I8_TYPE                    , L"Max-Ticket-Age"                            , 0                                             },
    { L"mayContain"                                , ATT_MAY_CONTAIN                              , SYNTAX_OBJECT_ID_TYPE             , L"May-Contain"                               , 0                                             },
    { L"meetingAdvertiseScope"                     , ATT_MEETINGADVERTISESCOPE                    , SYNTAX_UNICODE_TYPE               , L"meetingAdvertiseScope"                     , 0                                             },
    { L"meetingApplication"                        , ATT_MEETINGAPPLICATION                       , SYNTAX_UNICODE_TYPE               , L"meetingApplication"                        , 0                                             },
    { L"meetingBandwidth"                          , ATT_MEETINGBANDWIDTH                         , SYNTAX_INTEGER_TYPE               , L"meetingBandwidth"                          , 0                                             },
    { L"meetingBlob"                               , ATT_MEETINGBLOB                              , SYNTAX_OCTET_STRING_TYPE          , L"meetingBlob"                               , 0                                             },
    { L"meetingContactInfo"                        , ATT_MEETINGCONTACTINFO                       , SYNTAX_UNICODE_TYPE               , L"meetingContactInfo"                        , 0                                             },
    { L"meetingDescription"                        , ATT_MEETINGDESCRIPTION                       , SYNTAX_UNICODE_TYPE               , L"meetingDescription"                        , 0                                             },
    { L"meetingEndTime"                            , ATT_MEETINGENDTIME                           , SYNTAX_TIME_TYPE                  , L"meetingEndTime"                            , 0                                             },
    { L"meetingID"                                 , ATT_MEETINGID                                , SYNTAX_UNICODE_TYPE               , L"meetingID"                                 , 0                                             },
    { L"meetingIP"                                 , ATT_MEETINGIP                                , SYNTAX_UNICODE_TYPE               , L"meetingIP"                                 , 0                                             },
    { L"meetingIsEncrypted"                        , ATT_MEETINGISENCRYPTED                       , SYNTAX_UNICODE_TYPE               , L"meetingIsEncrypted"                        , 0                                             },
    { L"meetingKeyword"                            , ATT_MEETINGKEYWORD                           , SYNTAX_UNICODE_TYPE               , L"meetingKeyword"                            , 0                                             },
    { L"meetingLanguage"                           , ATT_MEETINGLANGUAGE                          , SYNTAX_UNICODE_TYPE               , L"meetingLanguage"                           , 0                                             },
    { L"meetingLocation"                           , ATT_MEETINGLOCATION                          , SYNTAX_UNICODE_TYPE               , L"meetingLocation"                           , 0                                             },
    { L"meetingMaxParticipants"                    , ATT_MEETINGMAXPARTICIPANTS                   , SYNTAX_INTEGER_TYPE               , L"meetingMaxParticipants"                    , 0                                             },
    { L"meetingName"                               , ATT_MEETINGNAME                              , SYNTAX_UNICODE_TYPE               , L"meetingName"                               , 0                                             },
    { L"meetingOriginator"                         , ATT_MEETINGORIGINATOR                        , SYNTAX_UNICODE_TYPE               , L"meetingOriginator"                         , 0                                             },
    { L"meetingOwner"                              , ATT_MEETINGOWNER                             , SYNTAX_UNICODE_TYPE               , L"meetingOwner"                              , 0                                             },
    { L"meetingProtocol"                           , ATT_MEETINGPROTOCOL                          , SYNTAX_UNICODE_TYPE               , L"meetingProtocol"                           , 0                                             },
    { L"meetingRating"                             , ATT_MEETINGRATING                            , SYNTAX_UNICODE_TYPE               , L"meetingRating"                             , 0                                             },
    { L"meetingRecurrence"                         , ATT_MEETINGRECURRENCE                        , SYNTAX_UNICODE_TYPE               , L"meetingRecurrence"                         , 0                                             },
    { L"meetingScope"                              , ATT_MEETINGSCOPE                             , SYNTAX_UNICODE_TYPE               , L"meetingScope"                              , 0                                             },
    { L"meetingStartTime"                          , ATT_MEETINGSTARTTIME                         , SYNTAX_TIME_TYPE                  , L"meetingStartTime"                          , 0                                             },
    { L"meetingType"                               , ATT_MEETINGTYPE                              , SYNTAX_UNICODE_TYPE               , L"meetingType"                               , 0                                             },
    { L"meetingURL"                                , ATT_MEETINGURL                               , SYNTAX_UNICODE_TYPE               , L"meetingURL"                                , 0                                             },
    { L"member"                                    , ATT_MEMBER                                   , SYNTAX_DISTNAME_TYPE              , L"Member"                                    , 0                                             },
    { L"mhsORAddress"                              , ATT_MHS_OR_ADDRESS                           , SYNTAX_UNICODE_TYPE               , L"MHS-OR-Address"                            , 0                                             },
    { L"minPwdAge"                                 , ATT_MIN_PWD_AGE                              , SYNTAX_I8_TYPE                    , L"Min-Pwd-Age"                               , 0                                             },
    { L"minPwdLength"                              , ATT_MIN_PWD_LENGTH                           , SYNTAX_INTEGER_TYPE               , L"Min-Pwd-Length"                            , 0                                             },
    { L"minTicketAge"                              , ATT_MIN_TICKET_AGE                           , SYNTAX_I8_TYPE                    , L"Min-Ticket-Age"                            , 0                                             },
    { L"modifiedCount"                             , ATT_MODIFIED_COUNT                           , SYNTAX_I8_TYPE                    , L"Modified-Count"                            , 0                                             },
    { L"modifiedCountAtLastProm"                   , ATT_MODIFIED_COUNT_AT_LAST_PROM              , SYNTAX_I8_TYPE                    , L"Modified-Count-At-Last-Prom"               , 0                                             },
    { L"modifyTimeStamp"                           , ATT_MODIFY_TIME_STAMP                        , SYNTAX_TIME_TYPE                  , L"Modify-Time-Stamp"                         , 0                                             },
    { L"moniker"                                   , ATT_MONIKER                                  , SYNTAX_OCTET_STRING_TYPE          , L"Moniker"                                   , 0                                             },
    { L"monikerDisplayName"                        , ATT_MONIKER_DISPLAY_NAME                     , SYNTAX_UNICODE_TYPE               , L"Moniker-Display-Name"                      , 0                                             },
    { L"moveTreeState"                             , ATT_MOVE_TREE_STATE                          , SYNTAX_OCTET_STRING_TYPE          , L"Move-Tree-State"                           , 0                                             },
    { L"msCOM-DefaultPartitionLink"                , ATT_MS_COM_DEFAULTPARTITIONLINK              , SYNTAX_DISTNAME_TYPE              , L"ms-COM-DefaultPartitionLink"               , 0                                             },
    { L"msCOM-ObjectId"                            , ATT_MS_COM_OBJECTID                          , SYNTAX_OCTET_STRING_TYPE          , L"ms-COM-ObjectId"                           , 0                                             },
    { L"msCOM-PartitionLink"                       , ATT_MS_COM_PARTITIONLINK                     , SYNTAX_DISTNAME_TYPE              , L"ms-COM-PartitionLink"                      , 0                                             },
    { L"msCOM-PartitionSetLink"                    , ATT_MS_COM_PARTITIONSETLINK                  , SYNTAX_DISTNAME_TYPE              , L"ms-COM-PartitionSetLink"                   , 0                                             },
    { L"msCOM-UserLink"                            , ATT_MS_COM_USERLINK                          , SYNTAX_DISTNAME_TYPE              , L"ms-COM-UserLink"                           , 0                                             },
    { L"msCOM-UserPartitionSetLink"                , ATT_MS_COM_USERPARTITIONSETLINK              , SYNTAX_DISTNAME_TYPE              , L"ms-COM-UserPartitionSetLink"               , 0                                             },
    { L"msDS-AllowedDNSSuffixes"                   , ATT_MS_DS_ALLOWED_DNS_SUFFIXES               , SYNTAX_UNICODE_TYPE               , L"ms-DS-Allowed-DNS-Suffixes"                , 0                                             },
    { L"msDS-Auxiliary-Classes"                    , ATT_MS_DS_AUXILIARY_CLASSES                  , SYNTAX_OBJECT_ID_TYPE             , L"ms-DS-Auxiliary-Classes"                   , 0                                             },
    { L"msDS-Approx-Immed-Subordinates"            , ATT_MS_DS_APPROX_IMMED_SUBORDINATES          , SYNTAX_INTEGER_TYPE               , L"ms-DS-Approx-Immed-Subordinates"           , 0                                             },
    { L"msDS-Behavior-Version"                     , ATT_MS_DS_BEHAVIOR_VERSION                   , SYNTAX_INTEGER_TYPE               , L"ms-DS-Behavior-Version"                    , 0                                             },
    { L"msDS-Cached-Membership"                    , ATT_MS_DS_CACHED_MEMBERSHIP                  , SYNTAX_OCTET_STRING_TYPE          , L"ms-DS-Cached-Membership"                   , 0                                             },
    { L"msDS-Cached-Membership-Time-Stamp"         , ATT_MS_DS_CACHED_MEMBERSHIP_TIME_STAMP       , SYNTAX_I8_TYPE                    , L"ms-DS-Cached-Membership-Time-Stamp"        , 0                                             },
    { L"mS-DS-ConsistencyGuid"                     , ATT_MS_DS_CONSISTENCY_GUID                   , SYNTAX_OCTET_STRING_TYPE          , L"MS-DS-Consistency-Guid"                    , 0                                             },
    { L"mS-DS-ConsistencyChildCount"               , ATT_MS_DS_CONSISTENCY_CHILD_COUNT            , SYNTAX_INTEGER_TYPE               , L"MS-DS-Consistency-Child-Count"             , 0                                             },
    { L"mS-DS-CreatorSID"                          , ATT_MS_DS_CREATOR_SID                        , SYNTAX_SID_TYPE                   , L"MS-DS-Creator-SID"                         , 0                                             },
    { L"msDS-Entry-Time-To-Die"                    , ATT_MS_DS_ENTRY_TIME_TO_DIE                  , SYNTAX_TIME_TYPE                  , L"ms-DS-Entry-Time-To-Die"                   , 0                                             },
    { L"msDS-FilterContainers"                     , ATT_MS_DS_FILTER_CONTAINERS                  , SYNTAX_UNICODE_TYPE               , L"ms-DS-Filter-Containers"                   , 0                                             },
    { L"msDS-HasInstantiatedNCs"                   , ATT_MS_DS_HAS_INSTANTIATED_NCS               , SYNTAX_DISTNAME_BINARY_TYPE       , L"ms-DS-Has-Instantiated-NCs"                , 0                                             },
    { L"msDS-TrustForestTrustInfo"                 , ATT_MS_DS_TRUST_FOREST_TRUST_INFO            , SYNTAX_OCTET_STRING_TYPE          , L"ms-DS-Trust-Forest-Trust-Info"             , 0                                             },
    { L"ms-DS-MachineAccountQuota"                 , ATT_MS_DS_MACHINE_ACCOUNT_QUOTA              , SYNTAX_INTEGER_TYPE               , L"MS-DS-Machine-Account-Quota"               , 0                                             },
    { L"msDS-Other-Settings"                       , ATT_MS_DS_OTHER_SETTINGS                     , SYNTAX_UNICODE_TYPE               , L"ms-DS-Other-Settings"                      , 0                                             },
    { L"msDS-NCReplCursors"                        , ATT_MS_DS_NC_REPL_CURSORS                    , SYNTAX_UNICODE_TYPE               , L"ms-DS-NC-Repl-Cursors"                     , 0                                             },
    { L"msDS-NCReplInboundNeighbors"               , ATT_MS_DS_NC_REPL_INBOUND_NEIGHBORS          , SYNTAX_UNICODE_TYPE               , L"ms-DS-NC-Repl-Inbound-Neighbors"           , 0                                             },
    { L"msDS-NCReplOutboundNeighbors"              , ATT_MS_DS_NC_REPL_OUTBOUND_NEIGHBORS         , SYNTAX_UNICODE_TYPE               , L"ms-DS-NC-Repl-Outbound-Neighbors"          , 0                                             },
    { L"msDS-NC-Replica-Locations"                 , ATT_MS_DS_NC_REPLICA_LOCATIONS               , SYNTAX_DISTNAME_TYPE              , L"ms-DS-NC-Replica-Locations"                , 0                                             },
    { L"msDS-Non-Security-Group-Extra-Classes"     , ATT_MS_DS_NON_SECURITY_GROUP_EXTRA_CLASSES   , SYNTAX_UNICODE_TYPE               , L"ms-DS-Non-Security-Group-Extra-Classes"    , 0                                             },
    { L"msDS-Preferred-GC-Site"                    , ATT_MS_DS_PREFERRED_GC_SITE                  , SYNTAX_DISTNAME_TYPE              , L"ms-DS-Preferred-GC-Site"                   , 0                                             },
    { L"msDS-ReplAttributeMetaData"                , ATT_MS_DS_REPL_ATTRIBUTE_META_DATA           , SYNTAX_UNICODE_TYPE               , L"ms-DS-Repl-Attribute-Meta-Data"            , 0                                             },
    { L"msDS-ReplValueMetaData"                    , ATT_MS_DS_REPL_VALUE_META_DATA               , SYNTAX_UNICODE_TYPE               , L"ms-DS-Repl-Value-Meta-Data"                , 0                                             },
    { L"mS-DS-ReplicatesNCReason"                  , ATT_MS_DS_REPLICATES_NC_REASON               , SYNTAX_DISTNAME_BINARY_TYPE       , L"MS-DS-Replicates-NC-Reason"                , 0                                             },
    { L"msDS-Replication-Notify-First-DSA-Delay"   , ATT_MS_DS_REPLICATION_NOTIFY_FIRST_DSA_DELAY , SYNTAX_INTEGER_TYPE               , L"ms-DS-Replication-Notify-First-DSA-Delay"  , 0                                             },
    { L"msDS-Replication-Notify-Subsequent-DSA-Delay", ATT_MS_DS_REPLICATION_NOTIFY_SUBSEQUENT_DSA_DELAY, SYNTAX_INTEGER_TYPE               , L"ms-DS-Replication-Notify-Subsequent-DSA-Delay", 0                                             },
    { L"msDs-Schema-Extensions"                    , ATT_MS_DS_SCHEMA_EXTENSIONS                  , SYNTAX_OCTET_STRING_TYPE          , L"ms-ds-Schema-Extensions"                   , 0                                             },
    { L"msDS-SDReferenceDomain"                    , ATT_MS_DS_SD_REFERENCE_DOMAIN                , SYNTAX_DISTNAME_TYPE              , L"ms-DS-SD-Reference-Domain"                 , 0                                             },
    { L"msDS-Security-Group-Extra-Classes"         , ATT_MS_DS_SECURITY_GROUP_EXTRA_CLASSES       , SYNTAX_UNICODE_TYPE               , L"ms-DS-Security-Group-Extra-Classes"        , 0                                             },
    { L"msDS-Settings"                             , ATT_MS_DS_SETTINGS                           , SYNTAX_UNICODE_TYPE               , L"ms-DS-Settings"                            , 0                                             },
    { L"msDS-Site-Affinity"                        , ATT_MS_DS_SITE_AFFINITY                      , SYNTAX_OCTET_STRING_TYPE          , L"ms-DS-Site-Affinity"                       , 0                                             },
    { L"msDS-User-Account-Control-Computed"        , ATT_MS_DS_USER_ACCOUNT_CONTROL_COMPUTED      , SYNTAX_INTEGER_TYPE               , L"ms-DS-User-Account-Control-Computed"       , 0                                             },
    { L"ownerBL"                                   , ATT_MS_EXCH_OWNER_BL                         , SYNTAX_DISTNAME_TYPE              , L"ms-Exch-Owner-BL"                          , 0                                             },
    { L"msFRS-Hub-Member"                          , ATT_MS_FRS_HUB_MEMBER                        , SYNTAX_DISTNAME_TYPE              , L"ms-FRS-Hub-Member"                         , 0                                             },
    { L"msFRS-Topology-Pref"                       , ATT_MS_FRS_TOPOLOGY_PREF                     , SYNTAX_UNICODE_TYPE               , L"ms-FRS-Topology-Pref"                      , 0                                             },
    { L"msPKI-Cert-Template-OID"                   , ATT_MS_PKI_CERT_TEMPLATE_OID                 , SYNTAX_UNICODE_TYPE               , L"ms-PKI-Cert-Template-OID"                  , 0                                             },
    { L"msPKI-Certificate-Application-Policy"      , ATT_MS_PKI_CERTIFICATE_APPLICATION_POLICY    , SYNTAX_UNICODE_TYPE               , L"ms-PKI-Certificate-Application-Policy"     , 0                                             },
    { L"msPKI-Certificate-Name-Flag"               , ATT_MS_PKI_CERTIFICATE_NAME_FLAG             , SYNTAX_INTEGER_TYPE               , L"ms-PKI-Certificate-Name-Flag"              , 0                                             },
    { L"msPKI-Certificate-Policy"                  , ATT_MS_PKI_CERTIFICATE_POLICY                , SYNTAX_UNICODE_TYPE               , L"ms-PKI-Certificate-Policy"                 , 0                                             },
    { L"msPKI-Enrollment-Flag"                     , ATT_MS_PKI_ENROLLMENT_FLAG                   , SYNTAX_INTEGER_TYPE               , L"ms-PKI-Enrollment-Flag"                    , 0                                             },
    { L"msPKI-Minimal-Key-Size"                    , ATT_MS_PKI_MINIMAL_KEY_SIZE                  , SYNTAX_INTEGER_TYPE               , L"ms-PKI-Minimal-Key-Size"                   , 0                                             },
    { L"msPKI-OID-Attribute"                       , ATT_MS_PKI_OID_ATTRIBUTE                     , SYNTAX_INTEGER_TYPE               , L"ms-PKI-OID-Attribute"                      , 0                                             },
    { L"msPKI-OID-CPS"                             , ATT_MS_PKI_OID_CPS                           , SYNTAX_UNICODE_TYPE               , L"ms-PKI-OID-CPS"                            , 0                                             },
    { L"msPKI-OID-User-Notice"                     , ATT_MS_PKI_OID_USER_NOTICE                   , SYNTAX_UNICODE_TYPE               , L"ms-PKI-OID-User-Notice"                    , 0                                             },
    { L"msPKI-Private-Key-Flag"                    , ATT_MS_PKI_PRIVATE_KEY_FLAG                  , SYNTAX_INTEGER_TYPE               , L"ms-PKI-Private-Key-Flag"                   , 0                                             },
    { L"msPKI-Supersede-Templates"                 , ATT_MS_PKI_SUPERSEDE_TEMPLATES               , SYNTAX_UNICODE_TYPE               , L"ms-PKI-Supersede-Templates"                , 0                                             },
    { L"msPKI-Template-Minor-Revision"             , ATT_MS_PKI_TEMPLATE_MINOR_REVISION           , SYNTAX_INTEGER_TYPE               , L"ms-PKI-Template-Minor-Revision"            , 0                                             },
    { L"msPKI-Template-Schema-Version"             , ATT_MS_PKI_TEMPLATE_SCHEMA_VERSION           , SYNTAX_INTEGER_TYPE               , L"ms-PKI-Template-Schema-Version"            , 0                                             },
    { L"msPKI-RA-Application-Policies"             , ATT_MS_PKI_RA_APPLICATION_POLICIES           , SYNTAX_UNICODE_TYPE               , L"ms-PKI-RA-Application-Policies"            , 0                                             },
    { L"msPKI-RA-Policies"                         , ATT_MS_PKI_RA_POLICIES                       , SYNTAX_UNICODE_TYPE               , L"ms-PKI-RA-Policies"                        , 0                                             },
    { L"msPKI-RA-Signature"                        , ATT_MS_PKI_RA_SIGNATURE                      , SYNTAX_INTEGER_TYPE               , L"ms-PKI-RA-Signature"                       , 0                                             },
    { L"msRRASAttribute"                           , ATT_MS_RRAS_ATTRIBUTE                        , SYNTAX_UNICODE_TYPE               , L"ms-RRAS-Attribute"                         , 0                                             },
    { L"msRRASVendorAttributeEntry"                , ATT_MS_RRAS_VENDOR_ATTRIBUTE_ENTRY           , SYNTAX_UNICODE_TYPE               , L"ms-RRAS-Vendor-Attribute-Entry"            , 0                                             },
    { L"mS-SQL-Name"                               , ATT_MS_SQL_NAME                              , SYNTAX_UNICODE_TYPE               , L"MS-SQL-Name"                               , 0                                             },
    { L"mS-SQL-RegisteredOwner"                    , ATT_MS_SQL_REGISTEREDOWNER                   , SYNTAX_UNICODE_TYPE               , L"MS-SQL-RegisteredOwner"                    , 0                                             },
    { L"mS-SQL-Contact"                            , ATT_MS_SQL_CONTACT                           , SYNTAX_UNICODE_TYPE               , L"MS-SQL-Contact"                            , 0                                             },
    { L"mS-SQL-Location"                           , ATT_MS_SQL_LOCATION                          , SYNTAX_UNICODE_TYPE               , L"MS-SQL-Location"                           , 0                                             },
    { L"mS-SQL-Memory"                             , ATT_MS_SQL_MEMORY                            , SYNTAX_I8_TYPE                    , L"MS-SQL-Memory"                             , 0                                             },
    { L"mS-SQL-Build"                              , ATT_MS_SQL_BUILD                             , SYNTAX_INTEGER_TYPE               , L"MS-SQL-Build"                              , 0                                             },
    { L"mS-SQL-ServiceAccount"                     , ATT_MS_SQL_SERVICEACCOUNT                    , SYNTAX_UNICODE_TYPE               , L"MS-SQL-ServiceAccount"                     , 0                                             },
    { L"mS-SQL-CharacterSet"                       , ATT_MS_SQL_CHARACTERSET                      , SYNTAX_INTEGER_TYPE               , L"MS-SQL-CharacterSet"                       , 0                                             },
    { L"mS-SQL-SortOrder"                          , ATT_MS_SQL_SORTORDER                         , SYNTAX_UNICODE_TYPE               , L"MS-SQL-SortOrder"                          , 0                                             },
    { L"mS-SQL-UnicodeSortOrder"                   , ATT_MS_SQL_UNICODESORTORDER                  , SYNTAX_INTEGER_TYPE               , L"MS-SQL-UnicodeSortOrder"                   , 0                                             },
    { L"mS-SQL-Clustered"                          , ATT_MS_SQL_CLUSTERED                         , SYNTAX_BOOLEAN_TYPE               , L"MS-SQL-Clustered"                          , 0                                             },
    { L"mS-SQL-NamedPipe"                          , ATT_MS_SQL_NAMEDPIPE                         , SYNTAX_UNICODE_TYPE               , L"MS-SQL-NamedPipe"                          , 0                                             },
    { L"mS-SQL-MultiProtocol"                      , ATT_MS_SQL_MULTIPROTOCOL                     , SYNTAX_UNICODE_TYPE               , L"MS-SQL-MultiProtocol"                      , 0                                             },
    { L"mS-SQL-SPX"                                , ATT_MS_SQL_SPX                               , SYNTAX_UNICODE_TYPE               , L"MS-SQL-SPX"                                , 0                                             },
    { L"mS-SQL-TCPIP"                              , ATT_MS_SQL_TCPIP                             , SYNTAX_UNICODE_TYPE               , L"MS-SQL-TCPIP"                              , 0                                             },
    { L"mS-SQL-AppleTalk"                          , ATT_MS_SQL_APPLETALK                         , SYNTAX_UNICODE_TYPE               , L"MS-SQL-AppleTalk"                          , 0                                             },
    { L"mS-SQL-Vines"                              , ATT_MS_SQL_VINES                             , SYNTAX_UNICODE_TYPE               , L"MS-SQL-Vines"                              , 0                                             },
    { L"mS-SQL-Status"                             , ATT_MS_SQL_STATUS                            , SYNTAX_I8_TYPE                    , L"MS-SQL-Status"                             , 0                                             },
    { L"mS-SQL-LastUpdatedDate"                    , ATT_MS_SQL_LASTUPDATEDDATE                   , SYNTAX_UNICODE_TYPE               , L"MS-SQL-LastUpdatedDate"                    , 0                                             },
    { L"mS-SQL-InformationURL"                     , ATT_MS_SQL_INFORMATIONURL                    , SYNTAX_UNICODE_TYPE               , L"MS-SQL-InformationURL"                     , 0                                             },
    { L"mS-SQL-ConnectionURL"                      , ATT_MS_SQL_CONNECTIONURL                     , SYNTAX_UNICODE_TYPE               , L"MS-SQL-ConnectionURL"                      , 0                                             },
    { L"mS-SQL-PublicationURL"                     , ATT_MS_SQL_PUBLICATIONURL                    , SYNTAX_UNICODE_TYPE               , L"MS-SQL-PublicationURL"                     , 0                                             },
    { L"mS-SQL-GPSLatitude"                        , ATT_MS_SQL_GPSLATITUDE                       , SYNTAX_UNICODE_TYPE               , L"MS-SQL-GPSLatitude"                        , 0                                             },
    { L"mS-SQL-GPSLongitude"                       , ATT_MS_SQL_GPSLONGITUDE                      , SYNTAX_UNICODE_TYPE               , L"MS-SQL-GPSLongitude"                       , 0                                             },
    { L"mS-SQL-GPSHeight"                          , ATT_MS_SQL_GPSHEIGHT                         , SYNTAX_UNICODE_TYPE               , L"MS-SQL-GPSHeight"                          , 0                                             },
    { L"mS-SQL-Version"                            , ATT_MS_SQL_VERSION                           , SYNTAX_UNICODE_TYPE               , L"MS-SQL-Version"                            , 0                                             },
    { L"mS-SQL-Language"                           , ATT_MS_SQL_LANGUAGE                          , SYNTAX_UNICODE_TYPE               , L"MS-SQL-Language"                           , 0                                             },
    { L"mS-SQL-Description"                        , ATT_MS_SQL_DESCRIPTION                       , SYNTAX_UNICODE_TYPE               , L"MS-SQL-Description"                        , 0                                             },
    { L"mS-SQL-Type"                               , ATT_MS_SQL_TYPE                              , SYNTAX_UNICODE_TYPE               , L"MS-SQL-Type"                               , 0                                             },
    { L"mS-SQL-InformationDirectory"               , ATT_MS_SQL_INFORMATIONDIRECTORY              , SYNTAX_BOOLEAN_TYPE               , L"MS-SQL-InformationDirectory"               , 0                                             },
    { L"mS-SQL-Database"                           , ATT_MS_SQL_DATABASE                          , SYNTAX_UNICODE_TYPE               , L"MS-SQL-Database"                           , 0                                             },
    { L"mS-SQL-AllowAnonymousSubscription"         , ATT_MS_SQL_ALLOWANONYMOUSSUBSCRIPTION        , SYNTAX_BOOLEAN_TYPE               , L"MS-SQL-AllowAnonymousSubscription"         , 0                                             },
    { L"mS-SQL-Alias"                              , ATT_MS_SQL_ALIAS                             , SYNTAX_UNICODE_TYPE               , L"MS-SQL-Alias"                              , 0                                             },
    { L"mS-SQL-Size"                               , ATT_MS_SQL_SIZE                              , SYNTAX_I8_TYPE                    , L"MS-SQL-Size"                               , 0                                             },
    { L"mS-SQL-CreationDate"                       , ATT_MS_SQL_CREATIONDATE                      , SYNTAX_UNICODE_TYPE               , L"MS-SQL-CreationDate"                       , 0                                             },
    { L"mS-SQL-LastBackupDate"                     , ATT_MS_SQL_LASTBACKUPDATE                    , SYNTAX_UNICODE_TYPE               , L"MS-SQL-LastBackupDate"                     , 0                                             },
    { L"mS-SQL-LastDiagnosticDate"                 , ATT_MS_SQL_LASTDIAGNOSTICDATE                , SYNTAX_UNICODE_TYPE               , L"MS-SQL-LastDiagnosticDate"                 , 0                                             },
    { L"mS-SQL-Applications"                       , ATT_MS_SQL_APPLICATIONS                      , SYNTAX_UNICODE_TYPE               , L"MS-SQL-Applications"                       , 0                                             },
    { L"mS-SQL-Keywords"                           , ATT_MS_SQL_KEYWORDS                          , SYNTAX_UNICODE_TYPE               , L"MS-SQL-Keywords"                           , 0                                             },
    { L"mS-SQL-Publisher"                          , ATT_MS_SQL_PUBLISHER                         , SYNTAX_UNICODE_TYPE               , L"MS-SQL-Publisher"                          , 0                                             },
    { L"mS-SQL-AllowKnownPullSubscription"         , ATT_MS_SQL_ALLOWKNOWNPULLSUBSCRIPTION        , SYNTAX_BOOLEAN_TYPE               , L"MS-SQL-AllowKnownPullSubscription"         , 0                                             },
    { L"mS-SQL-AllowImmediateUpdatingSubscription" , ATT_MS_SQL_ALLOWIMMEDIATEUPDATINGSUBSCRIPTION, SYNTAX_BOOLEAN_TYPE               , L"MS-SQL-AllowImmediateUpdatingSubscription" , 0                                             },
    { L"mS-SQL-AllowQueuedUpdatingSubscription"    , ATT_MS_SQL_ALLOWQUEUEDUPDATINGSUBSCRIPTION   , SYNTAX_BOOLEAN_TYPE               , L"MS-SQL-AllowQueuedUpdatingSubscription"    , 0                                             },
    { L"mS-SQL-AllowSnapshotFilesFTPDownloading"   , ATT_MS_SQL_ALLOWSNAPSHOTFILESFTPDOWNLOADING  , SYNTAX_BOOLEAN_TYPE               , L"MS-SQL-AllowSnapshotFilesFTPDownloading"   , 0                                             },
    { L"mS-SQL-ThirdParty"                         , ATT_MS_SQL_THIRDPARTY                        , SYNTAX_BOOLEAN_TYPE               , L"MS-SQL-ThirdParty"                         , 0                                             },
    { L"msTAPI-ConferenceBlob"                     , ATT_MS_TAPI_CONFERENCE_BLOB                  , SYNTAX_OCTET_STRING_TYPE          , L"ms-TAPI-Conference-Blob"                   , 0                                             },
    { L"msTAPI-IpAddress"                          , ATT_MS_TAPI_IP_ADDRESS                       , SYNTAX_UNICODE_TYPE               , L"ms-TAPI-Ip-Address"                        , 0                                             },
    { L"msTAPI-ProtocolId"                         , ATT_MS_TAPI_PROTOCOL_ID                      , SYNTAX_UNICODE_TYPE               , L"ms-TAPI-Protocol-Id"                       , 0                                             },
    { L"msTAPI-uid"                                , ATT_MS_TAPI_UNIQUE_IDENTIFIER                , SYNTAX_UNICODE_TYPE               , L"ms-TAPI-Unique-Identifier"                 , 0                                             },
    { L"msWMI-Author"                              , ATT_MS_WMI_AUTHOR                            , SYNTAX_UNICODE_TYPE               , L"ms-WMI-Author"                             , 0                                             },
    { L"msWMI-ChangeDate"                          , ATT_MS_WMI_CHANGEDATE                        , SYNTAX_UNICODE_TYPE               , L"ms-WMI-ChangeDate"                         , 0                                             },
    { L"msWMI-Class"                               , ATT_MS_WMI_CLASS                             , SYNTAX_UNICODE_TYPE               , L"ms-WMI-Class"                              , 0                                             },
    { L"msWMI-ClassDefinition"                     , ATT_MS_WMI_CLASSDEFINITION                   , SYNTAX_UNICODE_TYPE               , L"ms-WMI-ClassDefinition"                    , 0                                             },
    { L"msWMI-CreationDate"                        , ATT_MS_WMI_CREATIONDATE                      , SYNTAX_UNICODE_TYPE               , L"ms-WMI-CreationDate"                       , 0                                             },
    { L"msWMI-Genus"                               , ATT_MS_WMI_GENUS                             , SYNTAX_INTEGER_TYPE               , L"ms-WMI-Genus"                              , 0                                             },
    { L"msWMI-ID"                                  , ATT_MS_WMI_ID                                , SYNTAX_UNICODE_TYPE               , L"ms-WMI-ID"                                 , 0                                             },
    { L"msWMI-IntDefault"                          , ATT_MS_WMI_INTDEFAULT                        , SYNTAX_INTEGER_TYPE               , L"ms-WMI-intDefault"                         , 0                                             },
    { L"msWMI-intFlags1"                           , ATT_MS_WMI_INTFLAGS1                         , SYNTAX_INTEGER_TYPE               , L"ms-WMI-intFlags1"                          , 0                                             },
    { L"msWMI-intFlags2"                           , ATT_MS_WMI_INTFLAGS2                         , SYNTAX_INTEGER_TYPE               , L"ms-WMI-intFlags2"                          , 0                                             },
    { L"msWMI-intFlags3"                           , ATT_MS_WMI_INTFLAGS3                         , SYNTAX_INTEGER_TYPE               , L"ms-WMI-intFlags3"                          , 0                                             },
    { L"msWMI-intFlags4"                           , ATT_MS_WMI_INTFLAGS4                         , SYNTAX_INTEGER_TYPE               , L"ms-WMI-intFlags4"                          , 0                                             },
    { L"msWMI-IntMax"                              , ATT_MS_WMI_INTMAX                            , SYNTAX_INTEGER_TYPE               , L"ms-WMI-intMax"                             , 0                                             },
    { L"msWMI-IntMin"                              , ATT_MS_WMI_INTMIN                            , SYNTAX_INTEGER_TYPE               , L"ms-WMI-intMin"                             , 0                                             },
    { L"msWMI-IntValidValues"                      , ATT_MS_WMI_INTVALIDVALUES                    , SYNTAX_INTEGER_TYPE               , L"ms-WMI-intValidValues"                     , 0                                             },
    { L"msWMI-Int8Default"                         , ATT_MS_WMI_INT8DEFAULT                       , SYNTAX_I8_TYPE                    , L"ms-WMI-int8Default"                        , 0                                             },
    { L"msWMI-Int8Max"                             , ATT_MS_WMI_INT8MAX                           , SYNTAX_I8_TYPE                    , L"ms-WMI-int8Max"                            , 0                                             },
    { L"msWMI-Int8Min"                             , ATT_MS_WMI_INT8MIN                           , SYNTAX_I8_TYPE                    , L"ms-WMI-int8Min"                            , 0                                             },
    { L"msWMI-Int8ValidValues"                     , ATT_MS_WMI_INT8VALIDVALUES                   , SYNTAX_I8_TYPE                    , L"ms-WMI-int8ValidValues"                    , 0                                             },
    { L"msWMI-Mof"                                 , ATT_MS_WMI_MOF                               , SYNTAX_UNICODE_TYPE               , L"ms-WMI-Mof"                                , 0                                             },
    { L"msWMI-Name"                                , ATT_MS_WMI_NAME                              , SYNTAX_UNICODE_TYPE               , L"ms-WMI-Name"                               , 0                                             },
    { L"msWMI-NormalizedClass"                     , ATT_MS_WMI_NORMALIZEDCLASS                   , SYNTAX_UNICODE_TYPE               , L"ms-WMI-NormalizedClass"                    , 0                                             },
    { L"msWMI-Parm1"                               , ATT_MS_WMI_PARM1                             , SYNTAX_UNICODE_TYPE               , L"ms-WMI-Parm1"                              , 0                                             },
    { L"msWMI-Parm2"                               , ATT_MS_WMI_PARM2                             , SYNTAX_UNICODE_TYPE               , L"ms-WMI-Parm2"                              , 0                                             },
    { L"msWMI-Parm3"                               , ATT_MS_WMI_PARM3                             , SYNTAX_UNICODE_TYPE               , L"ms-WMI-Parm3"                              , 0                                             },
    { L"msWMI-Parm4"                               , ATT_MS_WMI_PARM4                             , SYNTAX_UNICODE_TYPE               , L"ms-WMI-Parm4"                              , 0                                             },
    { L"msWMI-PropertyName"                        , ATT_MS_WMI_PROPERTYNAME                      , SYNTAX_UNICODE_TYPE               , L"ms-WMI-PropertyName"                       , 0                                             },
    { L"msWMI-Query"                               , ATT_MS_WMI_QUERY                             , SYNTAX_UNICODE_TYPE               , L"ms-WMI-Query"                              , 0                                             },
    { L"msWMI-QueryLanguage"                       , ATT_MS_WMI_QUERYLANGUAGE                     , SYNTAX_UNICODE_TYPE               , L"ms-WMI-QueryLanguage"                      , 0                                             },
    { L"msWMI-ScopeGuid"                           , ATT_MS_WMI_SCOPEGUID                         , SYNTAX_UNICODE_TYPE               , L"ms-WMI-ScopeGuid"                          , 0                                             },
    { L"msWMI-SourceOrganization"                  , ATT_MS_WMI_SOURCEORGANIZATION                , SYNTAX_UNICODE_TYPE               , L"ms-WMI-SourceOrganization"                 , 0                                             },
    { L"msWMI-StringDefault"                       , ATT_MS_WMI_STRINGDEFAULT                     , SYNTAX_UNICODE_TYPE               , L"ms-WMI-stringDefault"                      , 0                                             },
    { L"msWMI-StringValidValues"                   , ATT_MS_WMI_STRINGVALIDVALUES                 , SYNTAX_UNICODE_TYPE               , L"ms-WMI-stringValidValues"                  , 0                                             },
    { L"msWMI-TargetClass"                         , ATT_MS_WMI_TARGETCLASS                       , SYNTAX_UNICODE_TYPE               , L"ms-WMI-TargetClass"                        , 0                                             },
    { L"msWMI-TargetNameSpace"                     , ATT_MS_WMI_TARGETNAMESPACE                   , SYNTAX_UNICODE_TYPE               , L"ms-WMI-TargetNameSpace"                    , 0                                             },
    { L"msWMI-TargetObject"                        , ATT_MS_WMI_TARGETOBJECT                      , SYNTAX_OCTET_STRING_TYPE          , L"ms-WMI-TargetObject"                       , 0                                             },
    { L"msWMI-TargetPath"                          , ATT_MS_WMI_TARGETPATH                        , SYNTAX_UNICODE_TYPE               , L"ms-WMI-TargetPath"                         , 0                                             },
    { L"msWMI-TargetType"                          , ATT_MS_WMI_TARGETTYPE                        , SYNTAX_UNICODE_TYPE               , L"ms-WMI-TargetType"                         , 0                                             },
    { L"mscopeId"                                  , ATT_MSCOPE_ID                                , SYNTAX_PRINT_CASE_STRING_TYPE     , L"Mscope-Id"                                 , 0                                             },
    { L"msiFileList"                               , ATT_MSI_FILE_LIST                            , SYNTAX_UNICODE_TYPE               , L"Msi-File-List"                             , 0                                             },
    { L"msiScript"                                 , ATT_MSI_SCRIPT                               , SYNTAX_OCTET_STRING_TYPE          , L"Msi-Script"                                , 0                                             },
    { L"msiScriptName"                             , ATT_MSI_SCRIPT_NAME                          , SYNTAX_UNICODE_TYPE               , L"Msi-Script-Name"                           , 0                                             },
    { L"msiScriptPath"                             , ATT_MSI_SCRIPT_PATH                          , SYNTAX_UNICODE_TYPE               , L"Msi-Script-Path"                           , 0                                             },
    { L"msiScriptSize"                             , ATT_MSI_SCRIPT_SIZE                          , SYNTAX_INTEGER_TYPE               , L"Msi-Script-Size"                           , 0                                             },
    { L"mSMQAuthenticate"                          , ATT_MSMQ_AUTHENTICATE                        , SYNTAX_BOOLEAN_TYPE               , L"MSMQ-Authenticate"                         , 0                                             },
    { L"mSMQBasePriority"                          , ATT_MSMQ_BASE_PRIORITY                       , SYNTAX_INTEGER_TYPE               , L"MSMQ-Base-Priority"                        , 0                                             },
    { L"mSMQComputerType"                          , ATT_MSMQ_COMPUTER_TYPE                       , SYNTAX_NOCASE_STRING_TYPE         , L"MSMQ-Computer-Type"                        , 0                                             },
    { L"mSMQComputerTypeEx"                        , ATT_MSMQ_COMPUTER_TYPE_EX                    , SYNTAX_UNICODE_TYPE               , L"MSMQ-Computer-Type-Ex"                     , 0                                             },
    { L"mSMQCost"                                  , ATT_MSMQ_COST                                , SYNTAX_INTEGER_TYPE               , L"MSMQ-Cost"                                 , 0                                             },
    { L"mSMQCSPName"                               , ATT_MSMQ_CSP_NAME                            , SYNTAX_NOCASE_STRING_TYPE         , L"MSMQ-CSP-Name"                             , 0                                             },
    { L"mSMQDependentClientService"                , ATT_MSMQ_DEPENDENT_CLIENT_SERVICE            , SYNTAX_BOOLEAN_TYPE               , L"MSMQ-Dependent-Client-Service"             , 0                                             },
    { L"mSMQDependentClientServices"               , ATT_MSMQ_DEPENDENT_CLIENT_SERVICES           , SYNTAX_BOOLEAN_TYPE               , L"MSMQ-Dependent-Client-Services"            , 0                                             },
    { L"mSMQDigests"                               , ATT_MSMQ_DIGESTS                             , SYNTAX_OCTET_STRING_TYPE          , L"MSMQ-Digests"                              , 0                                             },
    { L"mSMQDigestsMig"                            , ATT_MSMQ_DIGESTS_MIG                         , SYNTAX_OCTET_STRING_TYPE          , L"MSMQ-Digests-Mig"                          , 0                                             },
    { L"mSMQDsService"                             , ATT_MSMQ_DS_SERVICE                          , SYNTAX_BOOLEAN_TYPE               , L"MSMQ-Ds-Service"                           , 0                                             },
    { L"mSMQDsServices"                            , ATT_MSMQ_DS_SERVICES                         , SYNTAX_BOOLEAN_TYPE               , L"MSMQ-Ds-Services"                          , 0                                             },
    { L"mSMQEncryptKey"                            , ATT_MSMQ_ENCRYPT_KEY                         , SYNTAX_OCTET_STRING_TYPE          , L"MSMQ-Encrypt-Key"                          , 0                                             },
    { L"mSMQForeign"                               , ATT_MSMQ_FOREIGN                             , SYNTAX_BOOLEAN_TYPE               , L"MSMQ-Foreign"                              , 0                                             },
    { L"mSMQInRoutingServers"                      , ATT_MSMQ_IN_ROUTING_SERVERS                  , SYNTAX_DISTNAME_TYPE              , L"MSMQ-In-Routing-Servers"                   , 0                                             },
    { L"mSMQInterval1"                             , ATT_MSMQ_INTERVAL1                           , SYNTAX_INTEGER_TYPE               , L"MSMQ-Interval1"                            , 0                                             },
    { L"mSMQInterval2"                             , ATT_MSMQ_INTERVAL2                           , SYNTAX_INTEGER_TYPE               , L"MSMQ-Interval2"                            , 0                                             },
    { L"mSMQJournal"                               , ATT_MSMQ_JOURNAL                             , SYNTAX_BOOLEAN_TYPE               , L"MSMQ-Journal"                              , 0                                             },
    { L"mSMQJournalQuota"                          , ATT_MSMQ_JOURNAL_QUOTA                       , SYNTAX_INTEGER_TYPE               , L"MSMQ-Journal-Quota"                        , 0                                             },
    { L"mSMQLabel"                                 , ATT_MSMQ_LABEL                               , SYNTAX_NOCASE_STRING_TYPE         , L"MSMQ-Label"                                , 0                                             },
    { L"mSMQLabelEx"                               , ATT_MSMQ_LABEL_EX                            , SYNTAX_UNICODE_TYPE               , L"MSMQ-Label-Ex"                             , 0                                             },
    { L"mSMQLongLived"                             , ATT_MSMQ_LONG_LIVED                          , SYNTAX_INTEGER_TYPE               , L"MSMQ-Long-Lived"                           , 0                                             },
    { L"mSMQMigrated"                              , ATT_MSMQ_MIGRATED                            , SYNTAX_BOOLEAN_TYPE               , L"MSMQ-Migrated"                             , 0                                             },
    { L"mSMQNameStyle"                             , ATT_MSMQ_NAME_STYLE                          , SYNTAX_BOOLEAN_TYPE               , L"MSMQ-Name-Style"                           , 0                                             },
    { L"mSMQNt4Flags"                              , ATT_MSMQ_NT4_FLAGS                           , SYNTAX_INTEGER_TYPE               , L"MSMQ-Nt4-Flags"                            , 0                                             },
    { L"mSMQNt4Stub"                               , ATT_MSMQ_NT4_STUB                            , SYNTAX_INTEGER_TYPE               , L"MSMQ-Nt4-Stub"                             , 0                                             },
    { L"mSMQOSType"                                , ATT_MSMQ_OS_TYPE                             , SYNTAX_INTEGER_TYPE               , L"MSMQ-OS-Type"                              , 0                                             },
    { L"mSMQOutRoutingServers"                     , ATT_MSMQ_OUT_ROUTING_SERVERS                 , SYNTAX_DISTNAME_TYPE              , L"MSMQ-Out-Routing-Servers"                  , 0                                             },
    { L"mSMQOwnerID"                               , ATT_MSMQ_OWNER_ID                            , SYNTAX_OCTET_STRING_TYPE          , L"MSMQ-Owner-ID"                             , 0                                             },
    { L"mSMQPrevSiteGates"                         , ATT_MSMQ_PREV_SITE_GATES                     , SYNTAX_DISTNAME_TYPE              , L"MSMQ-Prev-Site-Gates"                      , 0                                             },
    { L"mSMQPrivacyLevel"                          , ATT_MSMQ_PRIVACY_LEVEL                       , SYNTAX_INTEGER_TYPE               , L"MSMQ-Privacy-Level"                        , 0                                             },
    { L"mSMQQMID"                                  , ATT_MSMQ_QM_ID                               , SYNTAX_OCTET_STRING_TYPE          , L"MSMQ-QM-ID"                                , 0                                             },
    { L"mSMQQueueJournalQuota"                     , ATT_MSMQ_QUEUE_JOURNAL_QUOTA                 , SYNTAX_INTEGER_TYPE               , L"MSMQ-Queue-Journal-Quota"                  , 0                                             },
    { L"mSMQQueueNameExt"                          , ATT_MSMQ_QUEUE_NAME_EXT                      , SYNTAX_UNICODE_TYPE               , L"MSMQ-Queue-Name-Ext"                       , 0                                             },
    { L"mSMQQueueQuota"                            , ATT_MSMQ_QUEUE_QUOTA                         , SYNTAX_INTEGER_TYPE               , L"MSMQ-Queue-Quota"                          , 0                                             },
    { L"mSMQQueueType"                             , ATT_MSMQ_QUEUE_TYPE                          , SYNTAX_OCTET_STRING_TYPE          , L"MSMQ-Queue-Type"                           , 0                                             },
    { L"mSMQQuota"                                 , ATT_MSMQ_QUOTA                               , SYNTAX_INTEGER_TYPE               , L"MSMQ-Quota"                                , 0                                             },
    { L"msMQ-Recipient-FormatName"                 , ATT_MSMQ_RECIPIENT_FORMATNAME                , SYNTAX_UNICODE_TYPE               , L"MSMQ-Recipient-FormatName"                 , 0                                             },
    { L"mSMQRoutingService"                        , ATT_MSMQ_ROUTING_SERVICE                     , SYNTAX_BOOLEAN_TYPE               , L"MSMQ-Routing-Service"                      , 0                                             },
    { L"mSMQRoutingServices"                       , ATT_MSMQ_ROUTING_SERVICES                    , SYNTAX_BOOLEAN_TYPE               , L"MSMQ-Routing-Services"                     , 0                                             },
    { L"mSMQServiceType"                           , ATT_MSMQ_SERVICE_TYPE                        , SYNTAX_INTEGER_TYPE               , L"MSMQ-Service-Type"                         , 0                                             },
    { L"mSMQServices"                              , ATT_MSMQ_SERVICES                            , SYNTAX_INTEGER_TYPE               , L"MSMQ-Services"                             , 0                                             },
    { L"mSMQSignCertificates"                      , ATT_MSMQ_SIGN_CERTIFICATES                   , SYNTAX_OCTET_STRING_TYPE          , L"MSMQ-Sign-Certificates"                    , 0                                             },
    { L"mSMQSignCertificatesMig"                   , ATT_MSMQ_SIGN_CERTIFICATES_MIG               , SYNTAX_OCTET_STRING_TYPE          , L"MSMQ-Sign-Certificates-Mig"                , 0                                             },
    { L"mSMQSignKey"                               , ATT_MSMQ_SIGN_KEY                            , SYNTAX_OCTET_STRING_TYPE          , L"MSMQ-Sign-Key"                             , 0                                             },
    { L"mSMQSite1"                                 , ATT_MSMQ_SITE_1                              , SYNTAX_DISTNAME_TYPE              , L"MSMQ-Site-1"                               , 0                                             },
    { L"mSMQSite2"                                 , ATT_MSMQ_SITE_2                              , SYNTAX_DISTNAME_TYPE              , L"MSMQ-Site-2"                               , 0                                             },
    { L"mSMQSiteForeign"                           , ATT_MSMQ_SITE_FOREIGN                        , SYNTAX_BOOLEAN_TYPE               , L"MSMQ-Site-Foreign"                         , 0                                             },
    { L"mSMQSiteGates"                             , ATT_MSMQ_SITE_GATES                          , SYNTAX_DISTNAME_TYPE              , L"MSMQ-Site-Gates"                           , 0                                             },
    { L"mSMQSiteGatesMig"                          , ATT_MSMQ_SITE_GATES_MIG                      , SYNTAX_DISTNAME_TYPE              , L"MSMQ-Site-Gates-Mig"                       , 0                                             },
    { L"mSMQSiteID"                                , ATT_MSMQ_SITE_ID                             , SYNTAX_OCTET_STRING_TYPE          , L"MSMQ-Site-ID"                              , 0                                             },
    { L"mSMQSiteName"                              , ATT_MSMQ_SITE_NAME                           , SYNTAX_NOCASE_STRING_TYPE         , L"MSMQ-Site-Name"                            , 0                                             },
    { L"mSMQSiteNameEx"                            , ATT_MSMQ_SITE_NAME_EX                        , SYNTAX_UNICODE_TYPE               , L"MSMQ-Site-Name-Ex"                         , 0                                             },
    { L"mSMQSites"                                 , ATT_MSMQ_SITES                               , SYNTAX_OCTET_STRING_TYPE          , L"MSMQ-Sites"                                , 0                                             },
    { L"mSMQTransactional"                         , ATT_MSMQ_TRANSACTIONAL                       , SYNTAX_BOOLEAN_TYPE               , L"MSMQ-Transactional"                        , 0                                             },
    { L"mSMQUserSid"                               , ATT_MSMQ_USER_SID                            , SYNTAX_OCTET_STRING_TYPE          , L"MSMQ-User-Sid"                             , 0                                             },
    { L"mSMQVersion"                               , ATT_MSMQ_VERSION                             , SYNTAX_INTEGER_TYPE               , L"MSMQ-Version"                              , 0                                             },
    { L"msNPAllowDialin"                           , ATT_MSNPALLOWDIALIN                          , SYNTAX_BOOLEAN_TYPE               , L"msNPAllowDialin"                           , 0                                             },
    { L"msNPCalledStationID"                       , ATT_MSNPCALLEDSTATIONID                      , SYNTAX_PRINT_CASE_STRING_TYPE     , L"msNPCalledStationID"                       , 0                                             },
    { L"msNPCallingStationID"                      , ATT_MSNPCALLINGSTATIONID                     , SYNTAX_PRINT_CASE_STRING_TYPE     , L"msNPCallingStationID"                      , 0                                             },
    { L"msNPSavedCallingStationID"                 , ATT_MSNPSAVEDCALLINGSTATIONID                , SYNTAX_PRINT_CASE_STRING_TYPE     , L"msNPSavedCallingStationID"                 , 0                                             },
    { L"msRADIUSCallbackNumber"                    , ATT_MSRADIUSCALLBACKNUMBER                   , SYNTAX_PRINT_CASE_STRING_TYPE     , L"msRADIUSCallbackNumber"                    , 0                                             },
    { L"msRADIUSFramedIPAddress"                   , ATT_MSRADIUSFRAMEDIPADDRESS                  , SYNTAX_INTEGER_TYPE               , L"msRADIUSFramedIPAddress"                   , 0                                             },
    { L"msRADIUSFramedRoute"                       , ATT_MSRADIUSFRAMEDROUTE                      , SYNTAX_PRINT_CASE_STRING_TYPE     , L"msRADIUSFramedRoute"                       , 0                                             },
    { L"msRADIUSServiceType"                       , ATT_MSRADIUSSERVICETYPE                      , SYNTAX_INTEGER_TYPE               , L"msRADIUSServiceType"                       , 0                                             },
    { L"msRASSavedCallbackNumber"                  , ATT_MSRASSAVEDCALLBACKNUMBER                 , SYNTAX_PRINT_CASE_STRING_TYPE     , L"msRASSavedCallbackNumber"                  , 0                                             },
    { L"msRASSavedFramedIPAddress"                 , ATT_MSRASSAVEDFRAMEDIPADDRESS                , SYNTAX_INTEGER_TYPE               , L"msRASSavedFramedIPAddress"                 , 0                                             },
    { L"msRASSavedFramedRoute"                     , ATT_MSRASSAVEDFRAMEDROUTE                    , SYNTAX_PRINT_CASE_STRING_TYPE     , L"msRASSavedFramedRoute"                     , 0                                             },
    { L"mustContain"                               , ATT_MUST_CONTAIN                             , SYNTAX_OBJECT_ID_TYPE             , L"Must-Contain"                              , 0                                             },
    { L"nameServiceFlags"                          , ATT_NAME_SERVICE_FLAGS                       , SYNTAX_INTEGER_TYPE               , L"Name-Service-Flags"                        , 0                                             },
    { L"nCName"                                    , ATT_NC_NAME                                  , SYNTAX_DISTNAME_TYPE              , L"NC-Name"                                   , 0                                             },
    { L"nETBIOSName"                               , ATT_NETBIOS_NAME                             , SYNTAX_UNICODE_TYPE               , L"NETBIOS-Name"                              , 0                                             },
    { L"netbootAllowNewClients"                    , ATT_NETBOOT_ALLOW_NEW_CLIENTS                , SYNTAX_BOOLEAN_TYPE               , L"netboot-Allow-New-Clients"                 , 0                                             },
    { L"netbootAnswerOnlyValidClients"             , ATT_NETBOOT_ANSWER_ONLY_VALID_CLIENTS        , SYNTAX_BOOLEAN_TYPE               , L"netboot-Answer-Only-Valid-Clients"         , 0                                             },
    { L"netbootAnswerRequests"                     , ATT_NETBOOT_ANSWER_REQUESTS                  , SYNTAX_BOOLEAN_TYPE               , L"netboot-Answer-Requests"                   , 0                                             },
    { L"netbootCurrentClientCount"                 , ATT_NETBOOT_CURRENT_CLIENT_COUNT             , SYNTAX_INTEGER_TYPE               , L"netboot-Current-Client-Count"              , 0                                             },
    { L"netbootGUID"                               , ATT_NETBOOT_GUID                             , SYNTAX_OCTET_STRING_TYPE          , L"Netboot-GUID"                              , 0                                             },
    { L"netbootInitialization"                     , ATT_NETBOOT_INITIALIZATION                   , SYNTAX_UNICODE_TYPE               , L"Netboot-Initialization"                    , 0                                             },
    { L"netbootIntelliMirrorOSes"                  , ATT_NETBOOT_INTELLIMIRROR_OSES               , SYNTAX_UNICODE_TYPE               , L"netboot-IntelliMirror-OSes"                , 0                                             },
    { L"netbootLimitClients"                       , ATT_NETBOOT_LIMIT_CLIENTS                    , SYNTAX_BOOLEAN_TYPE               , L"netboot-Limit-Clients"                     , 0                                             },
    { L"netbootLocallyInstalledOSes"               , ATT_NETBOOT_LOCALLY_INSTALLED_OSES           , SYNTAX_UNICODE_TYPE               , L"netboot-Locally-Installed-OSes"            , 0                                             },
    { L"netbootMachineFilePath"                    , ATT_NETBOOT_MACHINE_FILE_PATH                , SYNTAX_UNICODE_TYPE               , L"Netboot-Machine-File-Path"                 , 0                                             },
    { L"netbootMaxClients"                         , ATT_NETBOOT_MAX_CLIENTS                      , SYNTAX_INTEGER_TYPE               , L"netboot-Max-Clients"                       , 0                                             },
    { L"netbootMirrorDataFile"                     , ATT_NETBOOT_MIRROR_DATA_FILE                 , SYNTAX_UNICODE_TYPE               , L"Netboot-Mirror-Data-File"                  , 0                                             },
    { L"netbootNewMachineNamingPolicy"             , ATT_NETBOOT_NEW_MACHINE_NAMING_POLICY        , SYNTAX_UNICODE_TYPE               , L"netboot-New-Machine-Naming-Policy"         , 0                                             },
    { L"netbootNewMachineOU"                       , ATT_NETBOOT_NEW_MACHINE_OU                   , SYNTAX_DISTNAME_TYPE              , L"netboot-New-Machine-OU"                    , 0                                             },
    { L"netbootSCPBL"                              , ATT_NETBOOT_SCP_BL                           , SYNTAX_DISTNAME_TYPE              , L"netboot-SCP-BL"                            , 0                                             },
    { L"netbootServer"                             , ATT_NETBOOT_SERVER                           , SYNTAX_DISTNAME_TYPE              , L"netboot-Server"                            , 0                                             },
    { L"netbootSIFFile"                            , ATT_NETBOOT_SIF_FILE                         , SYNTAX_UNICODE_TYPE               , L"Netboot-SIF-File"                          , 0                                             },
    { L"netbootTools"                              , ATT_NETBOOT_TOOLS                            , SYNTAX_UNICODE_TYPE               , L"netboot-Tools"                             , 0                                             },
    { L"networkAddress"                            , ATT_NETWORK_ADDRESS                          , SYNTAX_NOCASE_STRING_TYPE         , L"Network-Address"                           , 0                                             },
    { L"nextLevelStore"                            , ATT_NEXT_LEVEL_STORE                         , SYNTAX_DISTNAME_TYPE              , L"Next-Level-Store"                          , 0                                             },
    { L"nextRid"                                   , ATT_NEXT_RID                                 , SYNTAX_INTEGER_TYPE               , L"Next-Rid"                                  , 0                                             },
    { L"nonSecurityMember"                         , ATT_NON_SECURITY_MEMBER                      , SYNTAX_DISTNAME_TYPE              , L"Non-Security-Member"                       , 0                                             },
    { L"nonSecurityMemberBL"                       , ATT_NON_SECURITY_MEMBER_BL                   , SYNTAX_DISTNAME_TYPE              , L"Non-Security-Member-BL"                    , 0                                             },
    { L"notificationList"                          , ATT_NOTIFICATION_LIST                        , SYNTAX_DISTNAME_TYPE              , L"Notification-List"                         , 0                                             },
    { L"nTGroupMembers"                            , ATT_NT_GROUP_MEMBERS                         , SYNTAX_OCTET_STRING_TYPE          , L"NT-Group-Members"                          , 0                                             },
    { L"nTMixedDomain"                             , ATT_NT_MIXED_DOMAIN                          , SYNTAX_INTEGER_TYPE               , L"NT-Mixed-Domain"                           , 0                                             },
    { L"ntPwdHistory"                              , ATT_NT_PWD_HISTORY                           , SYNTAX_OCTET_STRING_TYPE          , L"Nt-Pwd-History"                            , 0                                             },
    { L"nTSecurityDescriptor"                      , ATT_NT_SECURITY_DESCRIPTOR                   , SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE, L"NT-Security-Descriptor"                    , 0                                             },
    { L"distinguishedName"                         , ATT_OBJ_DIST_NAME                            , SYNTAX_DISTNAME_TYPE              , L"Obj-Dist-Name"                             , 0                                             },
    { L"objectCategory"                            , ATT_OBJECT_CATEGORY                          , SYNTAX_DISTNAME_TYPE              , L"Object-Category"                           , 0                                             },
    { L"objectClass"                               , ATT_OBJECT_CLASS                             , SYNTAX_OBJECT_ID_TYPE             , L"Object-Class"                              , 0                                             },
    { L"objectClassCategory"                       , ATT_OBJECT_CLASS_CATEGORY                    , SYNTAX_INTEGER_TYPE               , L"Object-Class-Category"                     , 0                                             },
    { L"objectClasses"                             , ATT_OBJECT_CLASSES                           , SYNTAX_UNICODE_TYPE               , L"Object-Classes"                            , 0                                             },
    { L"objectCount"                               , ATT_OBJECT_COUNT                             , SYNTAX_INTEGER_TYPE               , L"Object-Count"                              , 0                                             },
    { L"objectGUID"                                , ATT_OBJECT_GUID                              , SYNTAX_OCTET_STRING_TYPE          , L"Object-Guid"                               , 0                                             },
    { L"objectSid"                                 , ATT_OBJECT_SID                               , SYNTAX_SID_TYPE                   , L"Object-Sid"                                , 0                                             },
    { L"objectVersion"                             , ATT_OBJECT_VERSION                           , SYNTAX_INTEGER_TYPE               , L"Object-Version"                            , 0                                             },
    { L"oEMInformation"                            , ATT_OEM_INFORMATION                          , SYNTAX_UNICODE_TYPE               , L"OEM-Information"                           , 0                                             },
    { L"oMObjectClass"                             , ATT_OM_OBJECT_CLASS                          , SYNTAX_OCTET_STRING_TYPE          , L"OM-Object-Class"                           , 0                                             },
    { L"oMSyntax"                                  , ATT_OM_SYNTAX                                , SYNTAX_INTEGER_TYPE               , L"OM-Syntax"                                 , 0                                             },
    { L"oMTGuid"                                   , ATT_OMT_GUID                                 , SYNTAX_OCTET_STRING_TYPE          , L"OMT-Guid"                                  , 0                                             },
    { L"oMTIndxGuid"                               , ATT_OMT_INDX_GUID                            , SYNTAX_OCTET_STRING_TYPE          , L"OMT-Indx-Guid"                             , 0                                             },
    { L"operatingSystem"                           , ATT_OPERATING_SYSTEM                         , SYNTAX_UNICODE_TYPE               , L"Operating-System"                          , 0                                             },
    { L"operatingSystemHotfix"                     , ATT_OPERATING_SYSTEM_HOTFIX                  , SYNTAX_UNICODE_TYPE               , L"Operating-System-Hotfix"                   , 0                                             },
    { L"operatingSystemServicePack"                , ATT_OPERATING_SYSTEM_SERVICE_PACK            , SYNTAX_UNICODE_TYPE               , L"Operating-System-Service-Pack"             , 0                                             },
    { L"operatingSystemVersion"                    , ATT_OPERATING_SYSTEM_VERSION                 , SYNTAX_UNICODE_TYPE               , L"Operating-System-Version"                  , 0                                             },
    { L"operatorCount"                             , ATT_OPERATOR_COUNT                           , SYNTAX_INTEGER_TYPE               , L"Operator-Count"                            , 0                                             },
    { L"optionDescription"                         , ATT_OPTION_DESCRIPTION                       , SYNTAX_UNICODE_TYPE               , L"Option-Description"                        , 0                                             },
    { L"options"                                   , ATT_OPTIONS                                  , SYNTAX_INTEGER_TYPE               , L"Options"                                   , 0                                             },
    { L"optionsLocation"                           , ATT_OPTIONS_LOCATION                         , SYNTAX_PRINT_CASE_STRING_TYPE     , L"Options-Location"                          , 0                                             },
    { L"o"                                         , ATT_ORGANIZATION_NAME                        , SYNTAX_UNICODE_TYPE               , L"Organization-Name"                         , 0                                             },
    { L"ou"                                        , ATT_ORGANIZATIONAL_UNIT_NAME                 , SYNTAX_UNICODE_TYPE               , L"Organizational-Unit-Name"                  , 0                                             },
    { L"originalDisplayTable"                      , ATT_ORIGINAL_DISPLAY_TABLE                   , SYNTAX_OCTET_STRING_TYPE          , L"Original-Display-Table"                    , 0                                             },
    { L"originalDisplayTableMSDOS"                 , ATT_ORIGINAL_DISPLAY_TABLE_MSDOS             , SYNTAX_OCTET_STRING_TYPE          , L"Original-Display-Table-MSDOS"              , 0                                             },
    { L"otherLoginWorkstations"                    , ATT_OTHER_LOGIN_WORKSTATIONS                 , SYNTAX_UNICODE_TYPE               , L"Other-Login-Workstations"                  , 0                                             },
    { L"otherMailbox"                              , ATT_OTHER_MAILBOX                            , SYNTAX_UNICODE_TYPE               , L"Other-Mailbox"                             , 0                                             },
    { L"middleName"                                , ATT_OTHER_NAME                               , SYNTAX_UNICODE_TYPE               , L"Other-Name"                                , 0                                             },
    { L"otherWellKnownObjects"                     , ATT_OTHER_WELL_KNOWN_OBJECTS                 , SYNTAX_DISTNAME_BINARY_TYPE       , L"Other-Well-Known-Objects"                  , 0                                             },
    { L"owner"                                     , ATT_OWNER                                    , SYNTAX_DISTNAME_TYPE              , L"Owner"                                     , 0                                             },
    { L"packageFlags"                              , ATT_PACKAGE_FLAGS                            , SYNTAX_INTEGER_TYPE               , L"Package-Flags"                             , 0                                             },
    { L"packageName"                               , ATT_PACKAGE_NAME                             , SYNTAX_UNICODE_TYPE               , L"Package-Name"                              , 0                                             },
    { L"packageType"                               , ATT_PACKAGE_TYPE                             , SYNTAX_INTEGER_TYPE               , L"Package-Type"                              , 0                                             },
    { L"parentCA"                                  , ATT_PARENT_CA                                , SYNTAX_DISTNAME_TYPE              , L"Parent-CA"                                 , 0                                             },
    { L"parentCACertificateChain"                  , ATT_PARENT_CA_CERTIFICATE_CHAIN              , SYNTAX_OCTET_STRING_TYPE          , L"Parent-CA-Certificate-Chain"               , 0                                             },
    { L"parentGUID"                                , ATT_PARENT_GUID                              , SYNTAX_OCTET_STRING_TYPE          , L"Parent-GUID"                               , 0                                             },
    { L"partialAttributeDeletionList"              , ATT_PARTIAL_ATTRIBUTE_DELETION_LIST          , SYNTAX_OCTET_STRING_TYPE          , L"Partial-Attribute-Deletion-List"           , 0                                             },
    { L"partialAttributeSet"                       , ATT_PARTIAL_ATTRIBUTE_SET                    , SYNTAX_OCTET_STRING_TYPE          , L"Partial-Attribute-Set"                     , 0                                             },
    { L"pekKeyChangeInterval"                      , ATT_PEK_KEY_CHANGE_INTERVAL                  , SYNTAX_I8_TYPE                    , L"Pek-Key-Change-Interval"                   , 0                                             },
    { L"pekList"                                   , ATT_PEK_LIST                                 , SYNTAX_OCTET_STRING_TYPE          , L"Pek-List"                                  , 0                                             },
    { L"pendingCACertificates"                     , ATT_PENDING_CA_CERTIFICATES                  , SYNTAX_OCTET_STRING_TYPE          , L"Pending-CA-Certificates"                   , 0                                             },
    { L"pendingParentCA"                           , ATT_PENDING_PARENT_CA                        , SYNTAX_DISTNAME_TYPE              , L"Pending-Parent-CA"                         , 0                                             },
    { L"perMsgDialogDisplayTable"                  , ATT_PER_MSG_DIALOG_DISPLAY_TABLE             , SYNTAX_OCTET_STRING_TYPE          , L"Per-Msg-Dialog-Display-Table"              , 0                                             },
    { L"perRecipDialogDisplayTable"                , ATT_PER_RECIP_DIALOG_DISPLAY_TABLE           , SYNTAX_OCTET_STRING_TYPE          , L"Per-Recip-Dialog-Display-Table"            , 0                                             },
    { L"personalTitle"                             , ATT_PERSONAL_TITLE                           , SYNTAX_UNICODE_TYPE               , L"Personal-Title"                            , 0                                             },
    { L"otherFacsimileTelephoneNumber"             , ATT_PHONE_FAX_OTHER                          , SYNTAX_UNICODE_TYPE               , L"Phone-Fax-Other"                           , 0                                             },
    { L"otherHomePhone"                            , ATT_PHONE_HOME_OTHER                         , SYNTAX_UNICODE_TYPE               , L"Phone-Home-Other"                          , 0                                             },
    { L"homePhone"                                 , ATT_PHONE_HOME_PRIMARY                       , SYNTAX_UNICODE_TYPE               , L"Phone-Home-Primary"                        , 0                                             },
    { L"otherIpPhone"                              , ATT_PHONE_IP_OTHER                           , SYNTAX_UNICODE_TYPE               , L"Phone-Ip-Other"                            , 0                                             },
    { L"ipPhone"                                   , ATT_PHONE_IP_PRIMARY                         , SYNTAX_UNICODE_TYPE               , L"Phone-Ip-Primary"                          , 0                                             },
    { L"primaryInternationalISDNNumber"            , ATT_PHONE_ISDN_PRIMARY                       , SYNTAX_UNICODE_TYPE               , L"Phone-ISDN-Primary"                        , 0                                             },
    { L"otherMobile"                               , ATT_PHONE_MOBILE_OTHER                       , SYNTAX_UNICODE_TYPE               , L"Phone-Mobile-Other"                        , 0                                             },
    { L"mobile"                                    , ATT_PHONE_MOBILE_PRIMARY                     , SYNTAX_UNICODE_TYPE               , L"Phone-Mobile-Primary"                      , 0                                             },
    { L"otherTelephone"                            , ATT_PHONE_OFFICE_OTHER                       , SYNTAX_UNICODE_TYPE               , L"Phone-Office-Other"                        , 0                                             },
    { L"otherPager"                                , ATT_PHONE_PAGER_OTHER                        , SYNTAX_UNICODE_TYPE               , L"Phone-Pager-Other"                         , 0                                             },
    { L"pager"                                     , ATT_PHONE_PAGER_PRIMARY                      , SYNTAX_UNICODE_TYPE               , L"Phone-Pager-Primary"                       , 0                                             },
    { L"physicalDeliveryOfficeName"                , ATT_PHYSICAL_DELIVERY_OFFICE_NAME            , SYNTAX_UNICODE_TYPE               , L"Physical-Delivery-Office-Name"             , 0                                             },
    { L"physicalLocationObject"                    , ATT_PHYSICAL_LOCATION_OBJECT                 , SYNTAX_DISTNAME_TYPE              , L"Physical-Location-Object"                  , 0                                             },
    { L"thumbnailPhoto"                            , ATT_PICTURE                                  , SYNTAX_OCTET_STRING_TYPE          , L"Picture"                                   , 0                                             },
    { L"pKICriticalExtensions"                     , ATT_PKI_CRITICAL_EXTENSIONS                  , SYNTAX_UNICODE_TYPE               , L"PKI-Critical-Extensions"                   , 0                                             },
    { L"pKIDefaultCSPs"                            , ATT_PKI_DEFAULT_CSPS                         , SYNTAX_UNICODE_TYPE               , L"PKI-Default-CSPs"                          , 0                                             },
    { L"pKIDefaultKeySpec"                         , ATT_PKI_DEFAULT_KEY_SPEC                     , SYNTAX_INTEGER_TYPE               , L"PKI-Default-Key-Spec"                      , 0                                             },
    { L"pKIEnrollmentAccess"                       , ATT_PKI_ENROLLMENT_ACCESS                    , SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE, L"PKI-Enrollment-Access"                     , 0                                             },
    { L"pKIExpirationPeriod"                       , ATT_PKI_EXPIRATION_PERIOD                    , SYNTAX_OCTET_STRING_TYPE          , L"PKI-Expiration-Period"                     , 0                                             },
    { L"pKIExtendedKeyUsage"                       , ATT_PKI_EXTENDED_KEY_USAGE                   , SYNTAX_UNICODE_TYPE               , L"PKI-Extended-Key-Usage"                    , 0                                             },
    { L"pKIKeyUsage"                               , ATT_PKI_KEY_USAGE                            , SYNTAX_OCTET_STRING_TYPE          , L"PKI-Key-Usage"                             , 0                                             },
    { L"pKIMaxIssuingDepth"                        , ATT_PKI_MAX_ISSUING_DEPTH                    , SYNTAX_INTEGER_TYPE               , L"PKI-Max-Issuing-Depth"                     , 0                                             },
    { L"pKIOverlapPeriod"                          , ATT_PKI_OVERLAP_PERIOD                       , SYNTAX_OCTET_STRING_TYPE          , L"PKI-Overlap-Period"                        , 0                                             },
    { L"pKT"                                       , ATT_PKT                                      , SYNTAX_OCTET_STRING_TYPE          , L"PKT"                                       , 0                                             },
    { L"pKTGuid"                                   , ATT_PKT_GUID                                 , SYNTAX_OCTET_STRING_TYPE          , L"PKT-Guid"                                  , 0                                             },
    { L"policyReplicationFlags"                    , ATT_POLICY_REPLICATION_FLAGS                 , SYNTAX_INTEGER_TYPE               , L"Policy-Replication-Flags"                  , 0                                             },
    { L"portName"                                  , ATT_PORT_NAME                                , SYNTAX_UNICODE_TYPE               , L"Port-Name"                                 , 0                                             },
    { L"possSuperiors"                             , ATT_POSS_SUPERIORS                           , SYNTAX_OBJECT_ID_TYPE             , L"Poss-Superiors"                            , 0                                             },
    { L"possibleInferiors"                         , ATT_POSSIBLE_INFERIORS                       , SYNTAX_OBJECT_ID_TYPE             , L"Possible-Inferiors"                        , 0                                             },
    { L"postOfficeBox"                             , ATT_POST_OFFICE_BOX                          , SYNTAX_UNICODE_TYPE               , L"Post-Office-Box"                           , 0                                             },
    { L"postalAddress"                             , ATT_POSTAL_ADDRESS                           , SYNTAX_UNICODE_TYPE               , L"Postal-Address"                            , 0                                             },
    { L"postalCode"                                , ATT_POSTAL_CODE                              , SYNTAX_UNICODE_TYPE               , L"Postal-Code"                               , 0                                             },
    { L"preferredDeliveryMethod"                   , ATT_PREFERRED_DELIVERY_METHOD                , SYNTAX_INTEGER_TYPE               , L"Preferred-Delivery-Method"                 , 0                                             },
    { L"preferredOU"                               , ATT_PREFERRED_OU                             , SYNTAX_DISTNAME_TYPE              , L"Preferred-OU"                              , 0                                             },
    { L"prefixMap"                                 , ATT_PREFIX_MAP                               , SYNTAX_OCTET_STRING_TYPE          , L"Prefix-Map"                                , 0                                             },
    { L"presentationAddress"                       , ATT_PRESENTATION_ADDRESS                     , SYNTAX_ADDRESS_TYPE               , L"Presentation-Address"                      , 0                                             },
    { L"previousCACertificates"                    , ATT_PREVIOUS_CA_CERTIFICATES                 , SYNTAX_OCTET_STRING_TYPE          , L"Previous-CA-Certificates"                  , 0                                             },
    { L"previousParentCA"                          , ATT_PREVIOUS_PARENT_CA                       , SYNTAX_DISTNAME_TYPE              , L"Previous-Parent-CA"                        , 0                                             },
    { L"primaryGroupID"                            , ATT_PRIMARY_GROUP_ID                         , SYNTAX_INTEGER_TYPE               , L"Primary-Group-ID"                          , 0                                             },
    { L"primaryGroupToken"                         , ATT_PRIMARY_GROUP_TOKEN                      , SYNTAX_INTEGER_TYPE               , L"Primary-Group-Token"                       , 0                                             },
    { L"printAttributes"                           , ATT_PRINT_ATTRIBUTES                         , SYNTAX_INTEGER_TYPE               , L"Print-Attributes"                          , 0                                             },
    { L"printBinNames"                             , ATT_PRINT_BIN_NAMES                          , SYNTAX_UNICODE_TYPE               , L"Print-Bin-Names"                           , 0                                             },
    { L"printCollate"                              , ATT_PRINT_COLLATE                            , SYNTAX_BOOLEAN_TYPE               , L"Print-Collate"                             , 0                                             },
    { L"printColor"                                , ATT_PRINT_COLOR                              , SYNTAX_BOOLEAN_TYPE               , L"Print-Color"                               , 0                                             },
    { L"printDuplexSupported"                      , ATT_PRINT_DUPLEX_SUPPORTED                   , SYNTAX_BOOLEAN_TYPE               , L"Print-Duplex-Supported"                    , 0                                             },
    { L"printEndTime"                              , ATT_PRINT_END_TIME                           , SYNTAX_INTEGER_TYPE               , L"Print-End-Time"                            , 0                                             },
    { L"printFormName"                             , ATT_PRINT_FORM_NAME                          , SYNTAX_UNICODE_TYPE               , L"Print-Form-Name"                           , 0                                             },
    { L"printKeepPrintedJobs"                      , ATT_PRINT_KEEP_PRINTED_JOBS                  , SYNTAX_BOOLEAN_TYPE               , L"Print-Keep-Printed-Jobs"                   , 0                                             },
    { L"printLanguage"                             , ATT_PRINT_LANGUAGE                           , SYNTAX_UNICODE_TYPE               , L"Print-Language"                            , 0                                             },
    { L"printMACAddress"                           , ATT_PRINT_MAC_ADDRESS                        , SYNTAX_UNICODE_TYPE               , L"Print-MAC-Address"                         , 0                                             },
    { L"printMaxCopies"                            , ATT_PRINT_MAX_COPIES                         , SYNTAX_INTEGER_TYPE               , L"Print-Max-Copies"                          , 0                                             },
    { L"printMaxResolutionSupported"               , ATT_PRINT_MAX_RESOLUTION_SUPPORTED           , SYNTAX_INTEGER_TYPE               , L"Print-Max-Resolution-Supported"            , 0                                             },
    { L"printMaxXExtent"                           , ATT_PRINT_MAX_X_EXTENT                       , SYNTAX_INTEGER_TYPE               , L"Print-Max-X-Extent"                        , 0                                             },
    { L"printMaxYExtent"                           , ATT_PRINT_MAX_Y_EXTENT                       , SYNTAX_INTEGER_TYPE               , L"Print-Max-Y-Extent"                        , 0                                             },
    { L"printMediaReady"                           , ATT_PRINT_MEDIA_READY                        , SYNTAX_UNICODE_TYPE               , L"Print-Media-Ready"                         , 0                                             },
    { L"printMediaSupported"                       , ATT_PRINT_MEDIA_SUPPORTED                    , SYNTAX_UNICODE_TYPE               , L"Print-Media-Supported"                     , 0                                             },
    { L"printMemory"                               , ATT_PRINT_MEMORY                             , SYNTAX_INTEGER_TYPE               , L"Print-Memory"                              , 0                                             },
    { L"printMinXExtent"                           , ATT_PRINT_MIN_X_EXTENT                       , SYNTAX_INTEGER_TYPE               , L"Print-Min-X-Extent"                        , 0                                             },
    { L"printMinYExtent"                           , ATT_PRINT_MIN_Y_EXTENT                       , SYNTAX_INTEGER_TYPE               , L"Print-Min-Y-Extent"                        , 0                                             },
    { L"printNetworkAddress"                       , ATT_PRINT_NETWORK_ADDRESS                    , SYNTAX_UNICODE_TYPE               , L"Print-Network-Address"                     , 0                                             },
    { L"printNotify"                               , ATT_PRINT_NOTIFY                             , SYNTAX_UNICODE_TYPE               , L"Print-Notify"                              , 0                                             },
    { L"printNumberUp"                             , ATT_PRINT_NUMBER_UP                          , SYNTAX_INTEGER_TYPE               , L"Print-Number-Up"                           , 0                                             },
    { L"printOrientationsSupported"                , ATT_PRINT_ORIENTATIONS_SUPPORTED             , SYNTAX_UNICODE_TYPE               , L"Print-Orientations-Supported"              , 0                                             },
    { L"printOwner"                                , ATT_PRINT_OWNER                              , SYNTAX_UNICODE_TYPE               , L"Print-Owner"                               , 0                                             },
    { L"printPagesPerMinute"                       , ATT_PRINT_PAGES_PER_MINUTE                   , SYNTAX_INTEGER_TYPE               , L"Print-Pages-Per-Minute"                    , 0                                             },
    { L"printRate"                                 , ATT_PRINT_RATE                               , SYNTAX_INTEGER_TYPE               , L"Print-Rate"                                , 0                                             },
    { L"printRateUnit"                             , ATT_PRINT_RATE_UNIT                          , SYNTAX_UNICODE_TYPE               , L"Print-Rate-Unit"                           , 0                                             },
    { L"printSeparatorFile"                        , ATT_PRINT_SEPARATOR_FILE                     , SYNTAX_UNICODE_TYPE               , L"Print-Separator-File"                      , 0                                             },
    { L"printShareName"                            , ATT_PRINT_SHARE_NAME                         , SYNTAX_UNICODE_TYPE               , L"Print-Share-Name"                          , 0                                             },
    { L"printSpooling"                             , ATT_PRINT_SPOOLING                           , SYNTAX_UNICODE_TYPE               , L"Print-Spooling"                            , 0                                             },
    { L"printStaplingSupported"                    , ATT_PRINT_STAPLING_SUPPORTED                 , SYNTAX_BOOLEAN_TYPE               , L"Print-Stapling-Supported"                  , 0                                             },
    { L"printStartTime"                            , ATT_PRINT_START_TIME                         , SYNTAX_INTEGER_TYPE               , L"Print-Start-Time"                          , 0                                             },
    { L"printStatus"                               , ATT_PRINT_STATUS                             , SYNTAX_UNICODE_TYPE               , L"Print-Status"                              , 0                                             },
    { L"printerName"                               , ATT_PRINTER_NAME                             , SYNTAX_UNICODE_TYPE               , L"Printer-Name"                              , 0                                             },
    { L"priorSetTime"                              , ATT_PRIOR_SET_TIME                           , SYNTAX_I8_TYPE                    , L"Prior-Set-Time"                            , 0                                             },
    { L"priorValue"                                , ATT_PRIOR_VALUE                              , SYNTAX_OCTET_STRING_TYPE          , L"Prior-Value"                               , 0                                             },
    { L"priority"                                  , ATT_PRIORITY                                 , SYNTAX_INTEGER_TYPE               , L"Priority"                                  , 0                                             },
    { L"privateKey"                                , ATT_PRIVATE_KEY                              , SYNTAX_OCTET_STRING_TYPE          , L"Private-Key"                               , 0                                             },
    { L"privilegeAttributes"                       , ATT_PRIVILEGE_ATTRIBUTES                     , SYNTAX_INTEGER_TYPE               , L"Privilege-Attributes"                      , 0                                             },
    { L"privilegeDisplayName"                      , ATT_PRIVILEGE_DISPLAY_NAME                   , SYNTAX_UNICODE_TYPE               , L"Privilege-Display-Name"                    , 0                                             },
    { L"privilegeHolder"                           , ATT_PRIVILEGE_HOLDER                         , SYNTAX_DISTNAME_TYPE              , L"Privilege-Holder"                          , 0                                             },
    { L"privilegeValue"                            , ATT_PRIVILEGE_VALUE                          , SYNTAX_I8_TYPE                    , L"Privilege-Value"                           , 0                                             },
    { L"productCode"                               , ATT_PRODUCT_CODE                             , SYNTAX_OCTET_STRING_TYPE          , L"Product-Code"                              , 0                                             },
    { L"profilePath"                               , ATT_PROFILE_PATH                             , SYNTAX_UNICODE_TYPE               , L"Profile-Path"                              , 0                                             },
    { L"proxiedObjectName"                         , ATT_PROXIED_OBJECT_NAME                      , SYNTAX_DISTNAME_BINARY_TYPE       , L"Proxied-Object-Name"                       , 0                                             },
    { L"proxyAddresses"                            , ATT_PROXY_ADDRESSES                          , SYNTAX_UNICODE_TYPE               , L"Proxy-Addresses"                           , 0                                             },
    { L"proxyGenerationEnabled"                    , ATT_PROXY_GENERATION_ENABLED                 , SYNTAX_BOOLEAN_TYPE               , L"Proxy-Generation-Enabled"                  , 0                                             },
    { L"proxyLifetime"                             , ATT_PROXY_LIFETIME                           , SYNTAX_I8_TYPE                    , L"Proxy-Lifetime"                            , 0                                             },
    { L"publicKeyPolicy"                           , ATT_PUBLIC_KEY_POLICY                        , SYNTAX_OCTET_STRING_TYPE          , L"Public-Key-Policy"                         , 0                                             },
    { L"purportedSearch"                           , ATT_PURPORTED_SEARCH                         , SYNTAX_UNICODE_TYPE               , L"Purported-Search"                          , 0                                             },
    { L"pwdHistoryLength"                          , ATT_PWD_HISTORY_LENGTH                       , SYNTAX_INTEGER_TYPE               , L"Pwd-History-Length"                        , 0                                             },
    { L"pwdLastSet"                                , ATT_PWD_LAST_SET                             , SYNTAX_I8_TYPE                    , L"Pwd-Last-Set"                              , 0                                             },
    { L"pwdProperties"                             , ATT_PWD_PROPERTIES                           , SYNTAX_INTEGER_TYPE               , L"Pwd-Properties"                            , 0                                             },
    { L"qualityOfService"                          , ATT_QUALITY_OF_SERVICE                       , SYNTAX_INTEGER_TYPE               , L"Quality-Of-Service"                        , 0                                             },
    { L"queryFilter"                               , ATT_QUERY_FILTER                             , SYNTAX_UNICODE_TYPE               , L"Query-Filter"                              , 0                                             },
    { L"queryPolicyBL"                             , ATT_QUERY_POLICY_BL                          , SYNTAX_DISTNAME_TYPE              , L"Query-Policy-BL"                           , 0                                             },
    { L"queryPolicyObject"                         , ATT_QUERY_POLICY_OBJECT                      , SYNTAX_DISTNAME_TYPE              , L"Query-Policy-Object"                       , 0                                             },
    { L"queryPoint"                                , ATT_QUERYPOINT                               , SYNTAX_UNICODE_TYPE               , L"QueryPoint"                                , 0                                             },
    { L"rangeLower"                                , ATT_RANGE_LOWER                              , SYNTAX_INTEGER_TYPE               , L"Range-Lower"                               , 0                                             },
    { L"rangeUpper"                                , ATT_RANGE_UPPER                              , SYNTAX_INTEGER_TYPE               , L"Range-Upper"                               , 0                                             },
    { L"name"                                      , ATT_RDN                                      , SYNTAX_UNICODE_TYPE               , L"RDN"                                       , 0                                             },
    { L"rDNAttID"                                  , ATT_RDN_ATT_ID                               , SYNTAX_OBJECT_ID_TYPE             , L"RDN-Att-ID"                                , 0                                             },
    { L"registeredAddress"                         , ATT_REGISTERED_ADDRESS                       , SYNTAX_OCTET_STRING_TYPE          , L"Registered-Address"                        , 0                                             },
    { L"remoteServerName"                          , ATT_REMOTE_SERVER_NAME                       , SYNTAX_UNICODE_TYPE               , L"Remote-Server-Name"                        , 0                                             },
    { L"remoteSource"                              , ATT_REMOTE_SOURCE                            , SYNTAX_UNICODE_TYPE               , L"Remote-Source"                             , 0                                             },
    { L"remoteSourceType"                          , ATT_REMOTE_SOURCE_TYPE                       , SYNTAX_INTEGER_TYPE               , L"Remote-Source-Type"                        , 0                                             },
    { L"remoteStorageGUID"                         , ATT_REMOTE_STORAGE_GUID                      , SYNTAX_UNICODE_TYPE               , L"Remote-Storage-GUID"                       , 0                                             },
    { L"replPropertyMetaData"                      , ATT_REPL_PROPERTY_META_DATA                  , SYNTAX_OCTET_STRING_TYPE          , L"Repl-Property-Meta-Data"                   , 0                                             },
    { L"replTopologyStayOfExecution"               , ATT_REPL_TOPOLOGY_STAY_OF_EXECUTION          , SYNTAX_INTEGER_TYPE               , L"Repl-Topology-Stay-Of-Execution"           , 0                                             },
    { L"replUpToDateVector"                        , ATT_REPL_UPTODATE_VECTOR                     , SYNTAX_OCTET_STRING_TYPE          , L"Repl-UpToDate-Vector"                      , 0                                             },
    { L"replicaSource"                             , ATT_REPLICA_SOURCE                           , SYNTAX_UNICODE_TYPE               , L"Replica-Source"                            , 0                                             },
    { L"directReports"                             , ATT_REPORTS                                  , SYNTAX_DISTNAME_TYPE              , L"Reports"                                   , 0                                             },
    { L"replInterval"                              , ATT_REPL_INTERVAL                            , SYNTAX_INTEGER_TYPE               , L"Repl-Interval"                             , 0                                             },
    { L"repsFrom"                                  , ATT_REPS_FROM                                , SYNTAX_OCTET_STRING_TYPE          , L"Reps-From"                                 , 0                                             },
    { L"repsTo"                                    , ATT_REPS_TO                                  , SYNTAX_OCTET_STRING_TYPE          , L"Reps-To"                                   , 0                                             },
    { L"requiredCategories"                        , ATT_REQUIRED_CATEGORIES                      , SYNTAX_OCTET_STRING_TYPE          , L"Required-Categories"                       , 0                                             },
    { L"retiredReplDSASignatures"                  , ATT_RETIRED_REPL_DSA_SIGNATURES              , SYNTAX_OCTET_STRING_TYPE          , L"Retired-Repl-DSA-Signatures"               , 0                                             },
    { L"tokenGroups"                               , ATT_TOKEN_GROUPS                             , SYNTAX_SID_TYPE                   , L"Token-Groups"                              , 0                                             },
    { L"tokenGroupsGlobalAndUniversal"             , ATT_TOKEN_GROUPS_GLOBAL_AND_UNIVERSAL        , SYNTAX_SID_TYPE                   , L"Token-Groups-Global-And-Universal"         , 0                                             },
    { L"tokenGroupsNoGCAcceptable"                 , ATT_TOKEN_GROUPS_NO_GC_ACCEPTABLE            , SYNTAX_SID_TYPE                   , L"Token-Groups-No-GC-Acceptable"             , 0                                             },
    { L"revision"                                  , ATT_REVISION                                 , SYNTAX_INTEGER_TYPE               , L"Revision"                                  , 0                                             },
    { L"rid"                                       , ATT_RID                                      , SYNTAX_INTEGER_TYPE               , L"Rid"                                       , 0                                             },
    { L"rIDAllocationPool"                         , ATT_RID_ALLOCATION_POOL                      , SYNTAX_I8_TYPE                    , L"RID-Allocation-Pool"                       , 0                                             },
    { L"rIDAvailablePool"                          , ATT_RID_AVAILABLE_POOL                       , SYNTAX_I8_TYPE                    , L"RID-Available-Pool"                        , 0                                             },
    { L"rIDManagerReference"                       , ATT_RID_MANAGER_REFERENCE                    , SYNTAX_DISTNAME_TYPE              , L"RID-Manager-Reference"                     , 0                                             },
    { L"rIDNextRID"                                , ATT_RID_NEXT_RID                             , SYNTAX_INTEGER_TYPE               , L"RID-Next-RID"                              , 0                                             },
    { L"rIDPreviousAllocationPool"                 , ATT_RID_PREVIOUS_ALLOCATION_POOL             , SYNTAX_I8_TYPE                    , L"RID-Previous-Allocation-Pool"              , 0                                             },
    { L"rIDSetReferences"                          , ATT_RID_SET_REFERENCES                       , SYNTAX_DISTNAME_TYPE              , L"RID-Set-References"                        , 0                                             },
    { L"rIDUsedPool"                               , ATT_RID_USED_POOL                            , SYNTAX_I8_TYPE                    , L"RID-Used-Pool"                             , 0                                             },
    { L"rightsGuid"                                , ATT_RIGHTS_GUID                              , SYNTAX_UNICODE_TYPE               , L"Rights-Guid"                               , 0                                             },
    { L"roleOccupant"                              , ATT_ROLE_OCCUPANT                            , SYNTAX_DISTNAME_TYPE              , L"Role-Occupant"                             , 0                                             },
    { L"rootTrust"                                 , ATT_ROOT_TRUST                               , SYNTAX_DISTNAME_TYPE              , L"Root-Trust"                                , 0                                             },
    { L"rpcNsAnnotation"                           , ATT_RPC_NS_ANNOTATION                        , SYNTAX_UNICODE_TYPE               , L"rpc-Ns-Annotation"                         , 0                                             },
    { L"rpcNsBindings"                             , ATT_RPC_NS_BINDINGS                          , SYNTAX_UNICODE_TYPE               , L"rpc-Ns-Bindings"                           , 0                                             },
    { L"rpcNsCodeset"                              , ATT_RPC_NS_CODESET                           , SYNTAX_UNICODE_TYPE               , L"rpc-Ns-Codeset"                            , 0                                             },
    { L"rpcNsEntryFlags"                           , ATT_RPC_NS_ENTRY_FLAGS                       , SYNTAX_INTEGER_TYPE               , L"rpc-Ns-Entry-Flags"                        , 0                                             },
    { L"rpcNsGroup"                                , ATT_RPC_NS_GROUP                             , SYNTAX_UNICODE_TYPE               , L"rpc-Ns-Group"                              , 0                                             },
    { L"rpcNsInterfaceID"                          , ATT_RPC_NS_INTERFACE_ID                      , SYNTAX_UNICODE_TYPE               , L"rpc-Ns-Interface-ID"                       , 0                                             },
    { L"rpcNsObjectID"                             , ATT_RPC_NS_OBJECT_ID                         , SYNTAX_UNICODE_TYPE               , L"rpc-Ns-Object-ID"                          , 0                                             },
    { L"rpcNsPriority"                             , ATT_RPC_NS_PRIORITY                          , SYNTAX_INTEGER_TYPE               , L"rpc-Ns-Priority"                           , 0                                             },
    { L"rpcNsProfileEntry"                         , ATT_RPC_NS_PROFILE_ENTRY                     , SYNTAX_UNICODE_TYPE               , L"rpc-Ns-Profile-Entry"                      , 0                                             },
    { L"rpcNsTransferSyntax"                       , ATT_RPC_NS_TRANSFER_SYNTAX                   , SYNTAX_UNICODE_TYPE               , L"rpc-Ns-Transfer-Syntax"                    , 0                                             },
    { L"sAMAccountName"                            , ATT_SAM_ACCOUNT_NAME                         , SYNTAX_UNICODE_TYPE               , L"SAM-Account-Name"                          , 0                                             },
    { L"sAMAccountType"                            , ATT_SAM_ACCOUNT_TYPE                         , SYNTAX_INTEGER_TYPE               , L"SAM-Account-Type"                          , 0                                             },
    { L"schedule"                                  , ATT_SCHEDULE                                 , SYNTAX_OCTET_STRING_TYPE          , L"Schedule"                                  , 0                                             },
    { L"schemaFlagsEx"                             , ATT_SCHEMA_FLAGS_EX                          , SYNTAX_INTEGER_TYPE               , L"Schema-Flags-Ex"                           , 0                                             },
    { L"schemaIDGUID"                              , ATT_SCHEMA_ID_GUID                           , SYNTAX_OCTET_STRING_TYPE          , L"Schema-ID-GUID"                            , 0                                             },
    { L"schemaInfo"                                , ATT_SCHEMA_INFO                              , SYNTAX_OCTET_STRING_TYPE          , L"Schema-Info"                               , 0                                             },
    { L"schemaUpdate"                              , ATT_SCHEMA_UPDATE                            , SYNTAX_TIME_TYPE                  , L"Schema-Update"                             , 0                                             },
    { L"schemaVersion"                             , ATT_SCHEMA_VERSION                           , SYNTAX_INTEGER_TYPE               , L"Schema-Version"                            , 0                                             },
    { L"scopeFlags"                                , ATT_SCOPE_FLAGS                              , SYNTAX_INTEGER_TYPE               , L"Scope-Flags"                               , 0                                             },
    { L"scriptPath"                                , ATT_SCRIPT_PATH                              , SYNTAX_UNICODE_TYPE               , L"Script-Path"                               , 0                                             },
    { L"sDRightsEffective"                         , ATT_SD_RIGHTS_EFFECTIVE                      , SYNTAX_INTEGER_TYPE               , L"SD-Rights-Effective"                       , 0                                             },
    { L"searchFlags"                               , ATT_SEARCH_FLAGS                             , SYNTAX_INTEGER_TYPE               , L"Search-Flags"                              , 0                                             },
    { L"searchGuide"                               , ATT_SEARCH_GUIDE                             , SYNTAX_OCTET_STRING_TYPE          , L"Search-Guide"                              , 0                                             },
    { L"securityIdentifier"                        , ATT_SECURITY_IDENTIFIER                      , SYNTAX_SID_TYPE                   , L"Security-Identifier"                       , 0                                             },
    { L"seeAlso"                                   , ATT_SEE_ALSO                                 , SYNTAX_DISTNAME_TYPE              , L"See-Also"                                  , 0                                             },
    { L"seqNotification"                           , ATT_SEQ_NOTIFICATION                         , SYNTAX_INTEGER_TYPE               , L"Seq-Notification"                          , 0                                             },
    { L"serialNumber"                              , ATT_SERIAL_NUMBER                            , SYNTAX_PRINT_CASE_STRING_TYPE     , L"Serial-Number"                             , 0                                             },
    { L"serverName"                                , ATT_SERVER_NAME                              , SYNTAX_UNICODE_TYPE               , L"Server-Name"                               , 0                                             },
    { L"serverReference"                           , ATT_SERVER_REFERENCE                         , SYNTAX_DISTNAME_TYPE              , L"Server-Reference"                          , 0                                             },
    { L"serverReferenceBL"                         , ATT_SERVER_REFERENCE_BL                      , SYNTAX_DISTNAME_TYPE              , L"Server-Reference-BL"                       , 0                                             },
    { L"serverRole"                                , ATT_SERVER_ROLE                              , SYNTAX_INTEGER_TYPE               , L"Server-Role"                               , 0                                             },
    { L"serverState"                               , ATT_SERVER_STATE                             , SYNTAX_INTEGER_TYPE               , L"Server-State"                              , 0                                             },
    { L"serviceBindingInformation"                 , ATT_SERVICE_BINDING_INFORMATION              , SYNTAX_UNICODE_TYPE               , L"Service-Binding-Information"               , 0                                             },
    { L"serviceClassID"                            , ATT_SERVICE_CLASS_ID                         , SYNTAX_OCTET_STRING_TYPE          , L"Service-Class-ID"                          , 0                                             },
    { L"serviceClassInfo"                          , ATT_SERVICE_CLASS_INFO                       , SYNTAX_OCTET_STRING_TYPE          , L"Service-Class-Info"                        , 0                                             },
    { L"serviceClassName"                          , ATT_SERVICE_CLASS_NAME                       , SYNTAX_UNICODE_TYPE               , L"Service-Class-Name"                        , 0                                             },
    { L"serviceDNSName"                            , ATT_SERVICE_DNS_NAME                         , SYNTAX_UNICODE_TYPE               , L"Service-DNS-Name"                          , 0                                             },
    { L"serviceDNSNameType"                        , ATT_SERVICE_DNS_NAME_TYPE                    , SYNTAX_UNICODE_TYPE               , L"Service-DNS-Name-Type"                     , 0                                             },
    { L"serviceInstanceVersion"                    , ATT_SERVICE_INSTANCE_VERSION                 , SYNTAX_OCTET_STRING_TYPE          , L"Service-Instance-Version"                  , 0                                             },
    { L"servicePrincipalName"                      , ATT_SERVICE_PRINCIPAL_NAME                   , SYNTAX_UNICODE_TYPE               , L"Service-Principal-Name"                    , 0                                             },
    { L"setupCommand"                              , ATT_SETUP_COMMAND                            , SYNTAX_UNICODE_TYPE               , L"Setup-Command"                             , 0                                             },
    { L"shellContextMenu"                          , ATT_SHELL_CONTEXT_MENU                       , SYNTAX_UNICODE_TYPE               , L"Shell-Context-Menu"                        , 0                                             },
    { L"shellPropertyPages"                        , ATT_SHELL_PROPERTY_PAGES                     , SYNTAX_UNICODE_TYPE               , L"Shell-Property-Pages"                      , 0                                             },
    { L"shortServerName"                           , ATT_SHORT_SERVER_NAME                        , SYNTAX_UNICODE_TYPE               , L"Short-Server-Name"                         , 0                                             },
    { L"showInAddressBook"                         , ATT_SHOW_IN_ADDRESS_BOOK                     , SYNTAX_DISTNAME_TYPE              , L"Show-In-Address-Book"                      , 0                                             },
    { L"showInAdvancedViewOnly"                    , ATT_SHOW_IN_ADVANCED_VIEW_ONLY               , SYNTAX_BOOLEAN_TYPE               , L"Show-In-Advanced-View-Only"                , 0                                             },
    { L"sIDHistory"                                , ATT_SID_HISTORY                              , SYNTAX_SID_TYPE                   , L"SID-History"                               , 0                                             },
    { L"signatureAlgorithms"                       , ATT_SIGNATURE_ALGORITHMS                     , SYNTAX_UNICODE_TYPE               , L"Signature-Algorithms"                      , 0                                             },
    { L"siteGUID"                                  , ATT_SITE_GUID                                , SYNTAX_OCTET_STRING_TYPE          , L"Site-GUID"                                 , 0                                             },
    { L"siteLinkList"                              , ATT_SITE_LINK_LIST                           , SYNTAX_DISTNAME_TYPE              , L"Site-Link-List"                            , 0                                             },
    { L"siteList"                                  , ATT_SITE_LIST                                , SYNTAX_DISTNAME_TYPE              , L"Site-List"                                 , 0                                             },
    { L"siteObject"                                , ATT_SITE_OBJECT                              , SYNTAX_DISTNAME_TYPE              , L"Site-Object"                               , 0                                             },
    { L"siteObjectBL"                              , ATT_SITE_OBJECT_BL                           , SYNTAX_DISTNAME_TYPE              , L"Site-Object-BL"                            , 0                                             },
    { L"siteServer"                                , ATT_SITE_SERVER                              , SYNTAX_DISTNAME_TYPE              , L"Site-Server"                               , 0                                             },
    { L"mailAddress"                               , ATT_SMTP_MAIL_ADDRESS                        , SYNTAX_UNICODE_TYPE               , L"SMTP-Mail-Address"                         , 0                                             },
    { L"sPNMappings"                               , ATT_SPN_MAPPINGS                             , SYNTAX_UNICODE_TYPE               , L"SPN-Mappings"                              , 0                                             },
    { L"st"                                        , ATT_STATE_OR_PROVINCE_NAME                   , SYNTAX_UNICODE_TYPE               , L"State-Or-Province-Name"                    , 0                                             },
    { L"street"                                    , ATT_STREET_ADDRESS                           , SYNTAX_UNICODE_TYPE               , L"Street-Address"                            , 0                                             },
    { L"structuralObjectClass"                     , ATT_STRUCTURAL_OBJECT_CLASS                  , SYNTAX_OBJECT_ID_TYPE             , L"Structural-Object-Class"                   , 0                                             },
    { L"subClassOf"                                , ATT_SUB_CLASS_OF                             , SYNTAX_OBJECT_ID_TYPE             , L"Sub-Class-Of"                              , 0                                             },
    { L"subRefs"                                   , ATT_SUB_REFS                                 , SYNTAX_DISTNAME_TYPE              , L"Sub-Refs"                                  , 0                                             },
    { L"subSchemaSubEntry"                         , ATT_SUBSCHEMASUBENTRY                        , SYNTAX_DISTNAME_TYPE              , L"SubSchemaSubEntry"                         , 0                                             },
    { L"superScopeDescription"                     , ATT_SUPER_SCOPE_DESCRIPTION                  , SYNTAX_UNICODE_TYPE               , L"Super-Scope-Description"                   , 0                                             },
    { L"superScopes"                               , ATT_SUPER_SCOPES                             , SYNTAX_PRINT_CASE_STRING_TYPE     , L"Super-Scopes"                              , 0                                             },
    { L"superiorDNSRoot"                           , ATT_SUPERIOR_DNS_ROOT                        , SYNTAX_UNICODE_TYPE               , L"Superior-DNS-Root"                         , 0                                             },
    { L"supplementalCredentials"                   , ATT_SUPPLEMENTAL_CREDENTIALS                 , SYNTAX_OCTET_STRING_TYPE          , L"Supplemental-Credentials"                  , 0                                             },
    { L"supportedApplicationContext"               , ATT_SUPPORTED_APPLICATION_CONTEXT            , SYNTAX_OCTET_STRING_TYPE          , L"Supported-Application-Context"             , 0                                             },
    { L"sn"                                        , ATT_SURNAME                                  , SYNTAX_UNICODE_TYPE               , L"Surname"                                   , 0                                             },
    { L"syncAttributes"                            , ATT_SYNC_ATTRIBUTES                          , SYNTAX_INTEGER_TYPE               , L"Sync-Attributes"                           , 0                                             },
    { L"syncMembership"                            , ATT_SYNC_MEMBERSHIP                          , SYNTAX_DISTNAME_TYPE              , L"Sync-Membership"                           , 0                                             },
    { L"syncWithObject"                            , ATT_SYNC_WITH_OBJECT                         , SYNTAX_DISTNAME_TYPE              , L"Sync-With-Object"                          , 0                                             },
    { L"syncWithSID"                               , ATT_SYNC_WITH_SID                            , SYNTAX_SID_TYPE                   , L"Sync-With-SID"                             , 0                                             },
    { L"systemAuxiliaryClass"                      , ATT_SYSTEM_AUXILIARY_CLASS                   , SYNTAX_OBJECT_ID_TYPE             , L"System-Auxiliary-Class"                    , 0                                             },
    { L"systemFlags"                               , ATT_SYSTEM_FLAGS                             , SYNTAX_INTEGER_TYPE               , L"System-Flags"                              , 0                                             },
    { L"systemMayContain"                          , ATT_SYSTEM_MAY_CONTAIN                       , SYNTAX_OBJECT_ID_TYPE             , L"System-May-Contain"                        , 0                                             },
    { L"systemMustContain"                         , ATT_SYSTEM_MUST_CONTAIN                      , SYNTAX_OBJECT_ID_TYPE             , L"System-Must-Contain"                       , 0                                             },
    { L"systemOnly"                                , ATT_SYSTEM_ONLY                              , SYNTAX_BOOLEAN_TYPE               , L"System-Only"                               , 0                                             },
    { L"systemPossSuperiors"                       , ATT_SYSTEM_POSS_SUPERIORS                    , SYNTAX_OBJECT_ID_TYPE             , L"System-Poss-Superiors"                     , 0                                             },
    { L"telephoneNumber"                           , ATT_TELEPHONE_NUMBER                         , SYNTAX_UNICODE_TYPE               , L"Telephone-Number"                          , 0                                             },
    { L"teletexTerminalIdentifier"                 , ATT_TELETEX_TERMINAL_IDENTIFIER              , SYNTAX_OCTET_STRING_TYPE          , L"Teletex-Terminal-Identifier"               , 0                                             },
    { L"telexNumber"                               , ATT_TELEX_NUMBER                             , SYNTAX_OCTET_STRING_TYPE          , L"Telex-Number"                              , 0                                             },
    { L"primaryTelexNumber"                        , ATT_TELEX_PRIMARY                            , SYNTAX_UNICODE_TYPE               , L"Telex-Primary"                             , 0                                             },
    { L"templateRoots"                             , ATT_TEMPLATE_ROOTS                           , SYNTAX_DISTNAME_TYPE              , L"Template-Roots"                            , 0                                             },
    { L"terminalServer"                            , ATT_TERMINAL_SERVER                          , SYNTAX_OCTET_STRING_TYPE          , L"Terminal-Server"                           , 0                                             },
    { L"co"                                        , ATT_TEXT_COUNTRY                             , SYNTAX_UNICODE_TYPE               , L"Text-Country"                              , 0                                             },
    { L"textEncodedORAddress"                      , ATT_TEXT_ENCODED_OR_ADDRESS                  , SYNTAX_UNICODE_TYPE               , L"Text-Encoded-OR-Address"                   , 0                                             },
    { L"timeRefresh"                               , ATT_TIME_REFRESH                             , SYNTAX_I8_TYPE                    , L"Time-Refresh"                              , 0                                             },
    { L"timeVolChange"                             , ATT_TIME_VOL_CHANGE                          , SYNTAX_I8_TYPE                    , L"Time-Vol-Change"                           , 0                                             },
    { L"title"                                     , ATT_TITLE                                    , SYNTAX_UNICODE_TYPE               , L"Title"                                     , 0                                             },
    { L"tombstoneLifetime"                         , ATT_TOMBSTONE_LIFETIME                       , SYNTAX_INTEGER_TYPE               , L"Tombstone-Lifetime"                        , 0                                             },
    { L"transportAddressAttribute"                 , ATT_TRANSPORT_ADDRESS_ATTRIBUTE              , SYNTAX_OBJECT_ID_TYPE             , L"Transport-Address-Attribute"               , 0                                             },
    { L"transportDLLName"                          , ATT_TRANSPORT_DLL_NAME                       , SYNTAX_UNICODE_TYPE               , L"Transport-DLL-Name"                        , 0                                             },
    { L"transportType"                             , ATT_TRANSPORT_TYPE                           , SYNTAX_DISTNAME_TYPE              , L"Transport-Type"                            , 0                                             },
    { L"treatAsLeaf"                               , ATT_TREAT_AS_LEAF                            , SYNTAX_BOOLEAN_TYPE               , L"Treat-As-Leaf"                             , 0                                             },
    { L"treeName"                                  , ATT_TREE_NAME                                , SYNTAX_UNICODE_TYPE               , L"Tree-Name"                                 , 0                                             },
    { L"trustAttributes"                           , ATT_TRUST_ATTRIBUTES                         , SYNTAX_INTEGER_TYPE               , L"Trust-Attributes"                          , 0                                             },
    { L"trustAuthIncoming"                         , ATT_TRUST_AUTH_INCOMING                      , SYNTAX_OCTET_STRING_TYPE          , L"Trust-Auth-Incoming"                       , 0                                             },
    { L"trustAuthOutgoing"                         , ATT_TRUST_AUTH_OUTGOING                      , SYNTAX_OCTET_STRING_TYPE          , L"Trust-Auth-Outgoing"                       , 0                                             },
    { L"trustDirection"                            , ATT_TRUST_DIRECTION                          , SYNTAX_INTEGER_TYPE               , L"Trust-Direction"                           , 0                                             },
    { L"trustParent"                               , ATT_TRUST_PARENT                             , SYNTAX_DISTNAME_TYPE              , L"Trust-Parent"                              , 0                                             },
    { L"trustPartner"                              , ATT_TRUST_PARTNER                            , SYNTAX_UNICODE_TYPE               , L"Trust-Partner"                             , 0                                             },
    { L"trustPosixOffset"                          , ATT_TRUST_POSIX_OFFSET                       , SYNTAX_INTEGER_TYPE               , L"Trust-Posix-Offset"                        , 0                                             },
    { L"trustType"                                 , ATT_TRUST_TYPE                               , SYNTAX_INTEGER_TYPE               , L"Trust-Type"                                , 0                                             },
    { L"uASCompat"                                 , ATT_UAS_COMPAT                               , SYNTAX_INTEGER_TYPE               , L"UAS-Compat"                                , 0                                             },
    { L"uNCName"                                   , ATT_UNC_NAME                                 , SYNTAX_UNICODE_TYPE               , L"UNC-Name"                                  , 0                                             },
    { L"unicodePwd"                                , ATT_UNICODE_PWD                              , SYNTAX_OCTET_STRING_TYPE          , L"Unicode-Pwd"                               , 0                                             },
    { L"upgradeProductCode"                        , ATT_UPGRADE_PRODUCT_CODE                     , SYNTAX_OCTET_STRING_TYPE          , L"Upgrade-Product-Code"                      , 0                                             },
    { L"uPNSuffixes"                               , ATT_UPN_SUFFIXES                             , SYNTAX_UNICODE_TYPE               , L"UPN-Suffixes"                              , 0                                             },
    { L"userAccountControl"                        , ATT_USER_ACCOUNT_CONTROL                     , SYNTAX_INTEGER_TYPE               , L"User-Account-Control"                      , 0                                             },
    { L"userCert"                                  , ATT_USER_CERT                                , SYNTAX_OCTET_STRING_TYPE          , L"User-Cert"                                 , 0                                             },
    { L"comment"                                   , ATT_USER_COMMENT                             , SYNTAX_UNICODE_TYPE               , L"User-Comment"                              , 0                                             },
    { L"userParameters"                            , ATT_USER_PARAMETERS                          , SYNTAX_UNICODE_TYPE               , L"User-Parameters"                           , 0                                             },
    { L"userPassword"                              , ATT_USER_PASSWORD                            , SYNTAX_OCTET_STRING_TYPE          , L"User-Password"                             , 0                                             },
    { L"userPrincipalName"                         , ATT_USER_PRINCIPAL_NAME                      , SYNTAX_UNICODE_TYPE               , L"User-Principal-Name"                       , 0                                             },
    { L"userSharedFolder"                          , ATT_USER_SHARED_FOLDER                       , SYNTAX_UNICODE_TYPE               , L"User-Shared-Folder"                        , 0                                             },
    { L"userSharedFolderOther"                     , ATT_USER_SHARED_FOLDER_OTHER                 , SYNTAX_UNICODE_TYPE               , L"User-Shared-Folder-Other"                  , 0                                             },
    { L"userSMIMECertificate"                      , ATT_USER_SMIME_CERTIFICATE                   , SYNTAX_OCTET_STRING_TYPE          , L"User-SMIME-Certificate"                    , 0                                             },
    { L"userWorkstations"                          , ATT_USER_WORKSTATIONS                        , SYNTAX_UNICODE_TYPE               , L"User-Workstations"                         , 0                                             },
    { L"uSNChanged"                                , ATT_USN_CHANGED                              , SYNTAX_I8_TYPE                    , L"USN-Changed"                               , 0                                             },
    { L"uSNCreated"                                , ATT_USN_CREATED                              , SYNTAX_I8_TYPE                    , L"USN-Created"                               , 0                                             },
    { L"uSNDSALastObjRemoved"                      , ATT_USN_DSA_LAST_OBJ_REMOVED                 , SYNTAX_I8_TYPE                    , L"USN-DSA-Last-Obj-Removed"                  , 0                                             },
    { L"USNIntersite"                              , ATT_USN_INTERSITE                            , SYNTAX_INTEGER_TYPE               , L"USN-Intersite"                             , 0                                             },
    { L"uSNLastObjRem"                             , ATT_USN_LAST_OBJ_REM                         , SYNTAX_I8_TYPE                    , L"USN-Last-Obj-Rem"                          , 0                                             },
    { L"uSNSource"                                 , ATT_USN_SOURCE                               , SYNTAX_I8_TYPE                    , L"USN-Source"                                , 0                                             },
    { L"validAccesses"                             , ATT_VALID_ACCESSES                           , SYNTAX_INTEGER_TYPE               , L"Valid-Accesses"                            , 0                                             },
    { L"vendor"                                    , ATT_VENDOR                                   , SYNTAX_UNICODE_TYPE               , L"Vendor"                                    , 0                                             },
    { L"versionNumber"                             , ATT_VERSION_NUMBER                           , SYNTAX_INTEGER_TYPE               , L"Version-Number"                            , 0                                             },
    { L"versionNumberHi"                           , ATT_VERSION_NUMBER_HI                        , SYNTAX_INTEGER_TYPE               , L"Version-Number-Hi"                         , 0                                             },
    { L"versionNumberLo"                           , ATT_VERSION_NUMBER_LO                        , SYNTAX_INTEGER_TYPE               , L"Version-Number-Lo"                         , 0                                             },
    { L"volTableGUID"                              , ATT_VOL_TABLE_GUID                           , SYNTAX_OCTET_STRING_TYPE          , L"Vol-Table-GUID"                            , 0                                             },
    { L"volTableIdxGUID"                           , ATT_VOL_TABLE_IDX_GUID                       , SYNTAX_OCTET_STRING_TYPE          , L"Vol-Table-Idx-GUID"                        , 0                                             },
    { L"volumeCount"                               , ATT_VOLUME_COUNT                             , SYNTAX_INTEGER_TYPE               , L"Volume-Count"                              , 0                                             },
    { L"wbemPath"                                  , ATT_WBEM_PATH                                , SYNTAX_UNICODE_TYPE               , L"Wbem-Path"                                 , 0                                             },
    { L"wellKnownObjects"                          , ATT_WELL_KNOWN_OBJECTS                       , SYNTAX_DISTNAME_BINARY_TYPE       , L"Well-Known-Objects"                        , 0                                             },
    { L"whenChanged"                               , ATT_WHEN_CHANGED                             , SYNTAX_TIME_TYPE                  , L"When-Changed"                              , 0                                             },
    { L"whenCreated"                               , ATT_WHEN_CREATED                             , SYNTAX_TIME_TYPE                  , L"When-Created"                              , 0                                             },
    { L"winsockAddresses"                          , ATT_WINSOCK_ADDRESSES                        , SYNTAX_OCTET_STRING_TYPE          , L"Winsock-Addresses"                         , 0                                             },
    { L"wWWHomePage"                               , ATT_WWW_HOME_PAGE                            , SYNTAX_UNICODE_TYPE               , L"WWW-Home-Page"                             , 0                                             },
    { L"url"                                       , ATT_WWW_PAGE_OTHER                           , SYNTAX_UNICODE_TYPE               , L"WWW-Page-Other"                            , 0                                             },
    { L"x121Address"                               , ATT_X121_ADDRESS                             , SYNTAX_NUMERIC_STRING_TYPE        , L"X121-Address"                              , 0                                             },
    { L"userCertificate"                           , ATT_X509_CERT                                , SYNTAX_OCTET_STRING_TYPE          , L"X509-Cert"                                 , 0                                             },
    { L"aCSPolicy"                                 , CLASS_ACS_POLICY                             , 0                                 , L"ACS-Policy"                                , CLASS_TOP                                     },
    { L"aCSResourceLimits"                         , CLASS_ACS_RESOURCE_LIMITS                    , 0                                 , L"ACS-Resource-Limits"                       , CLASS_TOP                                     },
    { L"aCSSubnet"                                 , CLASS_ACS_SUBNET                             , 0                                 , L"ACS-Subnet"                                , CLASS_TOP                                     },
    { L"addressBookContainer"                      , CLASS_ADDRESS_BOOK_CONTAINER                 , 0                                 , L"Address-Book-Container"                    , CLASS_TOP                                     },
    { L"addressTemplate"                           , CLASS_ADDRESS_TEMPLATE                       , 0                                 , L"Address-Template"                          , CLASS_DISPLAY_TEMPLATE                        },
    { L"applicationEntity"                         , CLASS_APPLICATION_ENTITY                     , 0                                 , L"Application-Entity"                        , CLASS_TOP                                     },
    { L"applicationProcess"                        , CLASS_APPLICATION_PROCESS                    , 0                                 , L"Application-Process"                       , CLASS_TOP                                     },
    { L"applicationSettings"                       , CLASS_APPLICATION_SETTINGS                   , 0                                 , L"Application-Settings"                      , CLASS_TOP                                     },
    { L"applicationSiteSettings"                   , CLASS_APPLICATION_SITE_SETTINGS              , 0                                 , L"Application-Site-Settings"                 , CLASS_TOP                                     },
    { L"applicationVersion"                        , CLASS_APPLICATION_VERSION                    , 0                                 , L"Application-Version"                       , CLASS_APPLICATION_SETTINGS                    },
    { L"attributeSchema"                           , CLASS_ATTRIBUTE_SCHEMA                       , 0                                 , L"Attribute-Schema"                          , CLASS_TOP                                     },
    { L"builtinDomain"                             , CLASS_BUILTIN_DOMAIN                         , 0                                 , L"Builtin-Domain"                            , CLASS_TOP                                     },
    { L"categoryRegistration"                      , CLASS_CATEGORY_REGISTRATION                  , 0                                 , L"Category-Registration"                     , CLASS_LEAF                                    },
    { L"certificationAuthority"                    , CLASS_CERTIFICATION_AUTHORITY                , 0                                 , L"Certification-Authority"                   , CLASS_TOP                                     },
    { L"classRegistration"                         , CLASS_CLASS_REGISTRATION                     , 0                                 , L"Class-Registration"                        , CLASS_LEAF                                    },
    { L"classSchema"                               , CLASS_CLASS_SCHEMA                           , 0                                 , L"Class-Schema"                              , CLASS_TOP                                     },
    { L"classStore"                                , CLASS_CLASS_STORE                            , 0                                 , L"Class-Store"                               , CLASS_TOP                                     },
    { L"comConnectionPoint"                        , CLASS_COM_CONNECTION_POINT                   , 0                                 , L"Com-Connection-Point"                      , CLASS_CONNECTION_POINT                        },
    { L"computer"                                  , CLASS_COMPUTER                               , 0                                 , L"Computer"                                  , CLASS_USER                                    },
    { L"configuration"                             , CLASS_CONFIGURATION                          , 0                                 , L"Configuration"                             , CLASS_TOP                                     },
    { L"connectionPoint"                           , CLASS_CONNECTION_POINT                       , 0                                 , L"Connection-Point"                          , CLASS_LEAF                                    },
    { L"contact"                                   , CLASS_CONTACT                                , 0                                 , L"Contact"                                   , CLASS_ORGANIZATIONAL_PERSON                   },
    { L"container"                                 , CLASS_CONTAINER                              , 0                                 , L"Container"                                 , CLASS_TOP                                     },
    { L"controlAccessRight"                        , CLASS_CONTROL_ACCESS_RIGHT                   , 0                                 , L"Control-Access-Right"                      , CLASS_TOP                                     },
    { L"country"                                   , CLASS_COUNTRY                                , 0                                 , L"Country"                                   , CLASS_TOP                                     },
    { L"cRLDistributionPoint"                      , CLASS_CRL_DISTRIBUTION_POINT                 , 0                                 , L"CRL-Distribution-Point"                    , CLASS_TOP                                     },
    { L"crossRef"                                  , CLASS_CROSS_REF                              , 0                                 , L"Cross-Ref"                                 , CLASS_TOP                                     },
    { L"crossRefContainer"                         , CLASS_CROSS_REF_CONTAINER                    , 0                                 , L"Cross-Ref-Container"                       , CLASS_TOP                                     },
    { L"device"                                    , CLASS_DEVICE                                 , 0                                 , L"Device"                                    , CLASS_TOP                                     },
    { L"dfsConfiguration"                          , CLASS_DFS_CONFIGURATION                      , 0                                 , L"Dfs-Configuration"                         , CLASS_TOP                                     },
    { L"dHCPClass"                                 , CLASS_DHCP_CLASS                             , 0                                 , L"DHCP-Class"                                , CLASS_TOP                                     },
    { L"displaySpecifier"                          , CLASS_DISPLAY_SPECIFIER                      , 0                                 , L"Display-Specifier"                         , CLASS_TOP                                     },
    { L"displayTemplate"                           , CLASS_DISPLAY_TEMPLATE                       , 0                                 , L"Display-Template"                          , CLASS_TOP                                     },
    { L"dMD"                                       , CLASS_DMD                                    , 0                                 , L"DMD"                                       , CLASS_TOP                                     },
    { L"dnsNode"                                   , CLASS_DNS_NODE                               , 0                                 , L"Dns-Node"                                  , CLASS_TOP                                     },
    { L"dnsZone"                                   , CLASS_DNS_ZONE                               , 0                                 , L"Dns-Zone"                                  , CLASS_TOP                                     },
    { L"domain"                                    , CLASS_DOMAIN                                 , 0                                 , L"Domain"                                    , CLASS_TOP                                     },
    { L"domainDNS"                                 , CLASS_DOMAIN_DNS                             , 0                                 , L"Domain-DNS"                                , CLASS_DOMAIN                                  },
    { L"domainPolicy"                              , CLASS_DOMAIN_POLICY                          , 0                                 , L"Domain-Policy"                             , CLASS_LEAF                                    },
    { L"dSUISettings"                              , CLASS_DS_UI_SETTINGS                         , 0                                 , L"DS-UI-Settings"                            , CLASS_TOP                                     },
    { L"dSA"                                       , CLASS_DSA                                    , 0                                 , L"DSA"                                       , CLASS_APPLICATION_ENTITY                      },
    { L"dynamicObject"                             , CLASS_DYNAMIC_OBJECT                         , 0                                 , L"Dynamic-Object"                            , CLASS_TOP                                     },
    { L"fileLinkTracking"                          , CLASS_FILE_LINK_TRACKING                     , 0                                 , L"File-Link-Tracking"                        , CLASS_TOP                                     },
    { L"fileLinkTrackingEntry"                     , CLASS_FILE_LINK_TRACKING_ENTRY               , 0                                 , L"File-Link-Tracking-Entry"                  , CLASS_TOP                                     },
    { L"foreignSecurityPrincipal"                  , CLASS_FOREIGN_SECURITY_PRINCIPAL             , 0                                 , L"Foreign-Security-Principal"                , CLASS_TOP                                     },
    { L"fTDfs"                                     , CLASS_FT_DFS                                 , 0                                 , L"FT-Dfs"                                    , CLASS_TOP                                     },
    { L"group"                                     , CLASS_GROUP                                  , 0                                 , L"Group"                                     , CLASS_TOP                                     },
    { L"groupOfNames"                              , CLASS_GROUP_OF_NAMES                         , 0                                 , L"Group-Of-Names"                            , CLASS_TOP                                     },
    { L"groupPolicyContainer"                      , CLASS_GROUP_POLICY_CONTAINER                 , 0                                 , L"Group-Policy-Container"                    , CLASS_CONTAINER                               },
    { L"indexServerCatalog"                        , CLASS_INDEX_SERVER_CATALOG                   , 0                                 , L"Index-Server-Catalog"                      , CLASS_CONNECTION_POINT                        },
    { L"infrastructureUpdate"                      , CLASS_INFRASTRUCTURE_UPDATE                  , 0                                 , L"Infrastructure-Update"                     , CLASS_TOP                                     },
    { L"intellimirrorGroup"                        , CLASS_INTELLIMIRROR_GROUP                    , 0                                 , L"Intellimirror-Group"                       , CLASS_TOP                                     },
    { L"intellimirrorSCP"                          , CLASS_INTELLIMIRROR_SCP                      , 0                                 , L"Intellimirror-SCP"                         , CLASS_SERVICE_ADMINISTRATION_POINT            },
    { L"interSiteTransport"                        , CLASS_INTER_SITE_TRANSPORT                   , 0                                 , L"Inter-Site-Transport"                      , CLASS_TOP                                     },
    { L"interSiteTransportContainer"               , CLASS_INTER_SITE_TRANSPORT_CONTAINER         , 0                                 , L"Inter-Site-Transport-Container"            , CLASS_TOP                                     },
    { L"ipsecBase"                                 , CLASS_IPSEC_BASE                             , 0                                 , L"Ipsec-Base"                                , CLASS_TOP                                     },
    { L"ipsecFilter"                               , CLASS_IPSEC_FILTER                           , 0                                 , L"Ipsec-Filter"                              , CLASS_IPSEC_BASE                              },
    { L"ipsecISAKMPPolicy"                         , CLASS_IPSEC_ISAKMP_POLICY                    , 0                                 , L"Ipsec-ISAKMP-Policy"                       , CLASS_IPSEC_BASE                              },
    { L"ipsecNegotiationPolicy"                    , CLASS_IPSEC_NEGOTIATION_POLICY               , 0                                 , L"Ipsec-Negotiation-Policy"                  , CLASS_IPSEC_BASE                              },
    { L"ipsecNFA"                                  , CLASS_IPSEC_NFA                              , 0                                 , L"Ipsec-NFA"                                 , CLASS_IPSEC_BASE                              },
    { L"ipsecPolicy"                               , CLASS_IPSEC_POLICY                           , 0                                 , L"Ipsec-Policy"                              , CLASS_IPSEC_BASE                              },
    { L"leaf"                                      , CLASS_LEAF                                   , 0                                 , L"Leaf"                                      , CLASS_TOP                                     },
    { L"licensingSiteSettings"                     , CLASS_LICENSING_SITE_SETTINGS                , 0                                 , L"Licensing-Site-Settings"                   , CLASS_APPLICATION_SITE_SETTINGS               },
    { L"linkTrackObjectMoveTable"                  , CLASS_LINK_TRACK_OBJECT_MOVE_TABLE           , 0                                 , L"Link-Track-Object-Move-Table"              , CLASS_FILE_LINK_TRACKING                      },
    { L"linkTrackOMTEntry"                         , CLASS_LINK_TRACK_OMT_ENTRY                   , 0                                 , L"Link-Track-OMT-Entry"                      , CLASS_LEAF                                    },
    { L"linkTrackVolEntry"                         , CLASS_LINK_TRACK_VOL_ENTRY                   , 0                                 , L"Link-Track-Vol-Entry"                      , CLASS_LEAF                                    },
    { L"linkTrackVolumeTable"                      , CLASS_LINK_TRACK_VOLUME_TABLE                , 0                                 , L"Link-Track-Volume-Table"                   , CLASS_FILE_LINK_TRACKING                      },
    { L"locality"                                  , CLASS_LOCALITY                               , 0                                 , L"Locality"                                  , CLASS_TOP                                     },
    { L"lostAndFound"                              , CLASS_LOST_AND_FOUND                         , 0                                 , L"Lost-And-Found"                            , CLASS_TOP                                     },
    { L"mailRecipient"                             , CLASS_MAIL_RECIPIENT                         , 0                                 , L"Mail-Recipient"                            , CLASS_TOP                                     },
    { L"meeting"                                   , CLASS_MEETING                                , 0                                 , L"Meeting"                                   , CLASS_TOP                                     },
    { L"msCOM-Partition"                           , CLASS_MS_COM_PARTITION                       , 0                                 , L"ms-COM-Partition"                          , CLASS_TOP                                     },
    { L"msCOM-PartitionSet"                        , CLASS_MS_COM_PARTITIONSET                    , 0                                 , L"ms-COM-PartitionSet"                       , CLASS_TOP                                     },
    { L"msDS-App-Configuration"                    , CLASS_MS_DS_APP_CONFIGURATION                , 0                                 , L"ms-DS-App-Configuration"                   , CLASS_APPLICATION_SETTINGS                    },
    { L"msExchConfigurationContainer"              , CLASS_MS_EXCH_CONFIGURATION_CONTAINER        , 0                                 , L"ms-Exch-Configuration-Container"           , CLASS_CONTAINER                               },
    { L"msPKI-Enterprise-Oid"                      , CLASS_MS_PKI_ENTERPRISE_OID                  , 0                                 , L"ms-PKI-Enterprise-Oid"                     , CLASS_TOP                                     },
    { L"msPKI-Key-Recovery-Agent"                  , CLASS_MS_PKI_KEY_RECOVERY_AGENT              , 0                                 , L"ms-PKI-Key-Recovery-Agent"                 , CLASS_USER                                    },
    { L"mS-SQL-SQLServer"                          , CLASS_MS_SQL_SQLSERVER                       , 0                                 , L"MS-SQL-SQLServer"                          , CLASS_SERVICE_CONNECTION_POINT                },
    { L"mS-SQL-OLAPServer"                         , CLASS_MS_SQL_OLAPSERVER                      , 0                                 , L"MS-SQL-OLAPServer"                         , CLASS_SERVICE_CONNECTION_POINT                },
    { L"mS-SQL-SQLRepository"                      , CLASS_MS_SQL_SQLREPOSITORY                   , 0                                 , L"MS-SQL-SQLRepository"                      , CLASS_TOP                                     },
    { L"mS-SQL-SQLPublication"                     , CLASS_MS_SQL_SQLPUBLICATION                  , 0                                 , L"MS-SQL-SQLPublication"                     , CLASS_TOP                                     },
    { L"mS-SQL-SQLDatabase"                        , CLASS_MS_SQL_SQLDATABASE                     , 0                                 , L"MS-SQL-SQLDatabase"                        , CLASS_TOP                                     },
    { L"mS-SQL-OLAPDatabase"                       , CLASS_MS_SQL_OLAPDATABASE                    , 0                                 , L"MS-SQL-OLAPDatabase"                       , CLASS_TOP                                     },
    { L"mS-SQL-OLAPCube"                           , CLASS_MS_SQL_OLAPCUBE                        , 0                                 , L"MS-SQL-OLAPCube"                           , CLASS_TOP                                     },
    { L"msTAPI-RtConference"                       , CLASS_MS_TAPI_RT_CONFERENCE                  , 0                                 , L"ms-TAPI-Rt-Conference"                     , CLASS_TOP                                     },
    { L"msTAPI-RtPerson"                           , CLASS_MS_TAPI_RT_PERSON                      , 0                                 , L"ms-TAPI-Rt-Person"                         , CLASS_TOP                                     },
    { L"msWMI-IntRangeParam"                       , CLASS_MS_WMI_INTRANGEPARAM                   , 0                                 , L"ms-WMI-IntRangeParam"                      , CLASS_MS_WMI_RANGEPARAM                       },
    { L"msWMI-IntSetParam"                         , CLASS_MS_WMI_INTSETPARAM                     , 0                                 , L"ms-WMI-IntSetParam"                        , CLASS_MS_WMI_RANGEPARAM                       },
    { L"msWMI-MergeablePolicyTemplate"             , CLASS_MS_WMI_MERGEABLEPOLICYTEMPLATE         , 0                                 , L"ms-WMI-MergeablePolicyTemplate"            , CLASS_MS_WMI_POLICYTEMPLATE                   },
    { L"msWMI-ObjectEncoding"                      , CLASS_MS_WMI_OBJECTENCODING                  , 0                                 , L"ms-WMI-ObjectEncoding"                     , CLASS_TOP                                     },
    { L"msWMI-PolicyTemplate"                      , CLASS_MS_WMI_POLICYTEMPLATE                  , 0                                 , L"ms-WMI-PolicyTemplate"                     , CLASS_TOP                                     },
    { L"msWMI-PolicyType"                          , CLASS_MS_WMI_POLICYTYPE                      , 0                                 , L"ms-WMI-PolicyType"                         , CLASS_TOP                                     },
    { L"msWMI-RangeParam"                          , CLASS_MS_WMI_RANGEPARAM                      , 0                                 , L"ms-WMI-RangeParam"                         , CLASS_TOP                                     },
    { L"msWMI-RealRangeParam"                      , CLASS_MS_WMI_REALRANGEPARAM                  , 0                                 , L"ms-WMI-RealRangeParam"                     , CLASS_MS_WMI_RANGEPARAM                       },
    { L"msWMI-Rule"                                , CLASS_MS_WMI_RULE                            , 0                                 , L"ms-WMI-Rule"                               , CLASS_TOP                                     },
    { L"msWMI-ShadowObject"                        , CLASS_MS_WMI_SHADOWOBJECT                    , 0                                 , L"ms-WMI-ShadowObject"                       , CLASS_TOP                                     },
    { L"msWMI-SimplePolicyTemplate"                , CLASS_MS_WMI_SIMPLEPOLICYTEMPLATE            , 0                                 , L"ms-WMI-SimplePolicyTemplate"               , CLASS_MS_WMI_POLICYTEMPLATE                   },
    { L"msWMI-Som"                                 , CLASS_MS_WMI_SOM                             , 0                                 , L"ms-WMI-Som"                                , CLASS_TOP                                     },
    { L"msWMI-StringSetParam"                      , CLASS_MS_WMI_STRINGSETPARAM                  , 0                                 , L"ms-WMI-StringSetParam"                     , CLASS_MS_WMI_RANGEPARAM                       },
    { L"msWMI-UintRangeParam"                      , CLASS_MS_WMI_UINTRANGEPARAM                  , 0                                 , L"ms-WMI-UintRangeParam"                     , CLASS_MS_WMI_RANGEPARAM                       },
    { L"msWMI-UintSetParam"                        , CLASS_MS_WMI_UINTSETPARAM                    , 0                                 , L"ms-WMI-UintSetParam"                       , CLASS_MS_WMI_RANGEPARAM                       },
    { L"msWMI-UnknownRangeParam"                   , CLASS_MS_WMI_UNKNOWNRANGEPARAM               , 0                                 , L"ms-WMI-UnknownRangeParam"                  , CLASS_MS_WMI_RANGEPARAM                       },
    { L"msWMI-WMIGPO"                              , CLASS_MS_WMI_WMIGPO                          , 0                                 , L"ms-WMI-WMIGPO"                             , CLASS_TOP                                     },
    { L"mSMQConfiguration"                         , CLASS_MSMQ_CONFIGURATION                     , 0                                 , L"MSMQ-Configuration"                        , CLASS_TOP                                     },
    { L"msMQ-Custom-Recipient"                     , CLASS_MSMQ_CUSTOM_RECIPIENT                  , 0                                 , L"MSMQ-Custom-Recipient"                     , CLASS_TOP                                     },
    { L"mSMQEnterpriseSettings"                    , CLASS_MSMQ_ENTERPRISE_SETTINGS               , 0                                 , L"MSMQ-Enterprise-Settings"                  , CLASS_TOP                                     },
    { L"msMQ-Group"                                , CLASS_MSMQ_GROUP                             , 0                                 , L"MSMQ-Group"                                , CLASS_TOP                                     },
    { L"mSMQMigratedUser"                          , CLASS_MSMQ_MIGRATED_USER                     , 0                                 , L"MSMQ-Migrated-User"                        , CLASS_TOP                                     },
    { L"mSMQQueue"                                 , CLASS_MSMQ_QUEUE                             , 0                                 , L"MSMQ-Queue"                                , CLASS_TOP                                     },
    { L"mSMQSettings"                              , CLASS_MSMQ_SETTINGS                          , 0                                 , L"MSMQ-Settings"                             , CLASS_TOP                                     },
    { L"mSMQSiteLink"                              , CLASS_MSMQ_SITE_LINK                         , 0                                 , L"MSMQ-Site-Link"                            , CLASS_TOP                                     },
    { L"nTDSConnection"                            , CLASS_NTDS_CONNECTION                        , 0                                 , L"NTDS-Connection"                           , CLASS_LEAF                                    },
    { L"nTDSDSA"                                   , CLASS_NTDS_DSA                               , 0                                 , L"NTDS-DSA"                                  , CLASS_APPLICATION_SETTINGS                    },
    { L"nTDSService"                               , CLASS_NTDS_SERVICE                           , 0                                 , L"NTDS-Service"                              , CLASS_TOP                                     },
    { L"nTDSSiteSettings"                          , CLASS_NTDS_SITE_SETTINGS                     , 0                                 , L"NTDS-Site-Settings"                        , CLASS_APPLICATION_SITE_SETTINGS               },
    { L"nTFRSMember"                               , CLASS_NTFRS_MEMBER                           , 0                                 , L"NTFRS-Member"                              , CLASS_TOP                                     },
    { L"nTFRSReplicaSet"                           , CLASS_NTFRS_REPLICA_SET                      , 0                                 , L"NTFRS-Replica-Set"                         , CLASS_TOP                                     },
    { L"nTFRSSettings"                             , CLASS_NTFRS_SETTINGS                         , 0                                 , L"NTFRS-Settings"                            , CLASS_APPLICATION_SETTINGS                    },
    { L"nTFRSSubscriber"                           , CLASS_NTFRS_SUBSCRIBER                       , 0                                 , L"NTFRS-Subscriber"                          , CLASS_TOP                                     },
    { L"nTFRSSubscriptions"                        , CLASS_NTFRS_SUBSCRIPTIONS                    , 0                                 , L"NTFRS-Subscriptions"                       , CLASS_TOP                                     },
    { L"organization"                              , CLASS_ORGANIZATION                           , 0                                 , L"Organization"                              , CLASS_TOP                                     },
    { L"organizationalPerson"                      , CLASS_ORGANIZATIONAL_PERSON                  , 0                                 , L"Organizational-Person"                     , CLASS_PERSON                                  },
    { L"organizationalRole"                        , CLASS_ORGANIZATIONAL_ROLE                    , 0                                 , L"Organizational-Role"                       , CLASS_TOP                                     },
    { L"organizationalUnit"                        , CLASS_ORGANIZATIONAL_UNIT                    , 0                                 , L"Organizational-Unit"                       , CLASS_TOP                                     },
    { L"packageRegistration"                       , CLASS_PACKAGE_REGISTRATION                   , 0                                 , L"Package-Registration"                      , CLASS_TOP                                     },
    { L"person"                                    , CLASS_PERSON                                 , 0                                 , L"Person"                                    , CLASS_TOP                                     },
    { L"physicalLocation"                          , CLASS_PHYSICAL_LOCATION                      , 0                                 , L"Physical-Location"                         , CLASS_LOCALITY                                },
    { L"pKICertificateTemplate"                    , CLASS_PKI_CERTIFICATE_TEMPLATE               , 0                                 , L"PKI-Certificate-Template"                  , CLASS_TOP                                     },
    { L"pKIEnrollmentService"                      , CLASS_PKI_ENROLLMENT_SERVICE                 , 0                                 , L"PKI-Enrollment-Service"                    , CLASS_TOP                                     },
    { L"printQueue"                                , CLASS_PRINT_QUEUE                            , 0                                 , L"Print-Queue"                               , CLASS_CONNECTION_POINT                        },
    { L"queryPolicy"                               , CLASS_QUERY_POLICY                           , 0                                 , L"Query-Policy"                              , CLASS_TOP                                     },
    { L"remoteMailRecipient"                       , CLASS_REMOTE_MAIL_RECIPIENT                  , 0                                 , L"Remote-Mail-Recipient"                     , CLASS_TOP                                     },
    { L"remoteStorageServicePoint"                 , CLASS_REMOTE_STORAGE_SERVICE_POINT           , 0                                 , L"Remote-Storage-Service-Point"              , CLASS_SERVICE_ADMINISTRATION_POINT            },
    { L"residentialPerson"                         , CLASS_RESIDENTIAL_PERSON                     , 0                                 , L"Residential-Person"                        , CLASS_PERSON                                  },
    { L"rIDManager"                                , CLASS_RID_MANAGER                            , 0                                 , L"RID-Manager"                               , CLASS_TOP                                     },
    { L"rIDSet"                                    , CLASS_RID_SET                                , 0                                 , L"RID-Set"                                   , CLASS_TOP                                     },
    { L"rpcContainer"                              , CLASS_RPC_CONTAINER                          , 0                                 , L"Rpc-Container"                             , CLASS_CONTAINER                               },
    { L"rpcEntry"                                  , CLASS_RPC_ENTRY                              , 0                                 , L"rpc-Entry"                                 , CLASS_CONNECTION_POINT                        },
    { L"rpcGroup"                                  , CLASS_RPC_GROUP                              , 0                                 , L"rpc-Group"                                 , CLASS_RPC_ENTRY                               },
    { L"rpcProfile"                                , CLASS_RPC_PROFILE                            , 0                                 , L"rpc-Profile"                               , CLASS_RPC_ENTRY                               },
    { L"rpcProfileElement"                         , CLASS_RPC_PROFILE_ELEMENT                    , 0                                 , L"rpc-Profile-Element"                       , CLASS_RPC_ENTRY                               },
    { L"rpcServer"                                 , CLASS_RPC_SERVER                             , 0                                 , L"rpc-Server"                                , CLASS_RPC_ENTRY                               },
    { L"rpcServerElement"                          , CLASS_RPC_SERVER_ELEMENT                     , 0                                 , L"rpc-Server-Element"                        , CLASS_RPC_ENTRY                               },
    { L"rRASAdministrationConnectionPoint"         , CLASS_RRAS_ADMINISTRATION_CONNECTION_POINT   , 0                                 , L"RRAS-Administration-Connection-Point"      , CLASS_SERVICE_ADMINISTRATION_POINT            },
    { L"rRASAdministrationDictionary"              , CLASS_RRAS_ADMINISTRATION_DICTIONARY         , 0                                 , L"RRAS-Administration-Dictionary"            , CLASS_TOP                                     },
    { L"samDomain"                                 , CLASS_SAM_DOMAIN                             , 0                                 , L"Sam-Domain"                                , CLASS_TOP                                     },
    { L"samDomainBase"                             , CLASS_SAM_DOMAIN_BASE                        , 0                                 , L"Sam-Domain-Base"                           , CLASS_TOP                                     },
    { L"samServer"                                 , CLASS_SAM_SERVER                             , 0                                 , L"Sam-Server"                                , CLASS_SECURITY_OBJECT                         },
    { L"secret"                                    , CLASS_SECRET                                 , 0                                 , L"Secret"                                    , CLASS_LEAF                                    },
    { L"securityObject"                            , CLASS_SECURITY_OBJECT                        , 0                                 , L"Security-Object"                           , CLASS_TOP                                     },
    { L"securityPrincipal"                         , CLASS_SECURITY_PRINCIPAL                     , 0                                 , L"Security-Principal"                        , CLASS_TOP                                     },
    { L"server"                                    , CLASS_SERVER                                 , 0                                 , L"Server"                                    , CLASS_TOP                                     },
    { L"serversContainer"                          , CLASS_SERVERS_CONTAINER                      , 0                                 , L"Servers-Container"                         , CLASS_TOP                                     },
    { L"serviceAdministrationPoint"                , CLASS_SERVICE_ADMINISTRATION_POINT           , 0                                 , L"Service-Administration-Point"              , CLASS_SERVICE_CONNECTION_POINT                },
    { L"serviceClass"                              , CLASS_SERVICE_CLASS                          , 0                                 , L"Service-Class"                             , CLASS_LEAF                                    },
    { L"serviceConnectionPoint"                    , CLASS_SERVICE_CONNECTION_POINT               , 0                                 , L"Service-Connection-Point"                  , CLASS_CONNECTION_POINT                        },
    { L"serviceInstance"                           , CLASS_SERVICE_INSTANCE                       , 0                                 , L"Service-Instance"                          , CLASS_CONNECTION_POINT                        },
    { L"site"                                      , CLASS_SITE                                   , 0                                 , L"Site"                                      , CLASS_TOP                                     },
    { L"siteLink"                                  , CLASS_SITE_LINK                              , 0                                 , L"Site-Link"                                 , CLASS_TOP                                     },
    { L"siteLinkBridge"                            , CLASS_SITE_LINK_BRIDGE                       , 0                                 , L"Site-Link-Bridge"                          , CLASS_TOP                                     },
    { L"sitesContainer"                            , CLASS_SITES_CONTAINER                        , 0                                 , L"Sites-Container"                           , CLASS_TOP                                     },
    { L"storage"                                   , CLASS_STORAGE                                , 0                                 , L"Storage"                                   , CLASS_CONNECTION_POINT                        },
    { L"subnet"                                    , CLASS_SUBNET                                 , 0                                 , L"Subnet"                                    , CLASS_TOP                                     },
    { L"subnetContainer"                           , CLASS_SUBNET_CONTAINER                       , 0                                 , L"Subnet-Container"                          , CLASS_TOP                                     },
    { L"subSchema"                                 , CLASS_SUBSCHEMA                              , 0                                 , L"SubSchema"                                 , CLASS_TOP                                     },
    { L"top"                                       , CLASS_TOP                                    , 0                                 , L"Top"                                       , CLASS_TOP                                     },
    { L"trustedDomain"                             , CLASS_TRUSTED_DOMAIN                         , 0                                 , L"Trusted-Domain"                            , CLASS_LEAF                                    },
    { L"typeLibrary"                               , CLASS_TYPE_LIBRARY                           , 0                                 , L"Type-Library"                              , CLASS_TOP                                     },
    { L"user"                                      , CLASS_USER                                   , 0                                 , L"User"                                      , CLASS_ORGANIZATIONAL_PERSON                   },
    { L"volume"                                    , CLASS_VOLUME                                 , 0                                 , L"Volume"                                    , CLASS_CONNECTION_POINT                        } 

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\sim\schmap.h ===
/*++

Copyright (c) 2000 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    schmap.h

ABSTRACT:

    This file was automatically generated by schtable.exe.

--*/

#ifndef _KCCSIM_SCHMAP_H_
#define _KCCSIM_SCHMAP_H_

#define SCHTABLE_MAX_LDAPNAME_LEN       44
#define SCHTABLE_MAX_SCHEMANAME_LEN     45
#define SCHTABLE_NUM_ROWS               1134

struct _SCHTABLE_MAPPING {
    const WCHAR                         wszLdapDisplayName[1+SCHTABLE_MAX_LDAPNAME_LEN];
    const ATTRTYP                       attrType;
    const ULONG                         ulSyntax;
    const WCHAR                         wszSchemaRDN[1+SCHTABLE_MAX_SCHEMANAME_LEN];
    const ATTRTYP                       superClass;
};

extern const struct _SCHTABLE_MAPPING   schTable[];

#endif // _KCCSIM_SCHMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\sim\simmd.h ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    simmd.h

ABSTRACT:

    Header file for the simmd*.c simulated APIs.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#ifndef _SIMMD_H_
#define _SIMMD_H_

// From simmderr.c

// For now, dsid = 0
#define KCCSimSetUpdError(pCR,problem,e) \
        KCCSimDoSetUpdError(pCR,problem,e,0,0)
#define KCCSimSetUpdErrorEx(pCR,problem,e,d) \
        KCCSimDoSetUpdError(pCR,problem,e,d,0)

#define KCCSimSetAttError(pCR,pDN,aTyp,problem,pAV,e) \
        KCCSimDoSetAttError(pCR,pDN,aTyp,problem,pAV,e,0,0)
#define KCCSimSetAttErrorEx(pCR,pDN,aTyp,problem,pAV,e,ed) \
        KCCSimDoSetAttError(pCR,pDN,aTyp,problem,pAV,e,ed,0)

#define KCCSimSetNamError(pCR,problem,pDN,e) \
        KCCSimDoSetNamError(pCR,problem,pDN,e,0,0)
#define KCCSimSetNamErrorEx(pCR,problem,pDN,e,ed) \
        KCCSimDoSetNamError(pCR,problem,pDN,e,ed,0)

int
KCCSimDoSetUpdError (
    COMMRES *                       pCommRes,
    USHORT                          problem,
    DWORD                           extendedErr,
    DWORD                           extendedData,
    DWORD                           dsid
    );

int
KCCSimDoSetAttError (
    COMMRES *                       pCommRes,
    PDSNAME                         pDN,
    ATTRTYP                         aTyp,
    USHORT                          problem,
    ATTRVAL *                       pAttVal,
    DWORD                           extendedErr,
    DWORD                           extendedData,
    DWORD                           dsid
    );

int
KCCSimDoSetNamError (
    COMMRES *                       pCommRes,
    USHORT                          problem,
    PDSNAME                         pDN,
    DWORD                           extendedErr,
    DWORD                           extendedData,
    DWORD                           dsid
    );

// From simmdnam.c

PSIM_ENTRY
KCCSimResolveName (
    PDSNAME                         pObject,
    COMMRES *                       pCommRes
    );

#endif // _SIMMD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\sim\simlsa.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    simlsa.c

ABSTRACT:

    Simulates the LSA functions.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include "kccsim.h"
#include "util.h"
#include "dir.h"

VOID
KCCSimAllocLsaUnicodeString (
    IN  LPCWSTR                     pwszString,
    IO  PLSAPR_UNICODE_STRING       pLsaUnicodeString
    )
/*++

Routine Description:

    Converter for LSAPR_UINCODE_STRINGs.

Arguments:

    pwszString          - String to convert.
    pLsaUnicodeString   - Pointer to an LSAPR_UNICODE_STRING that will hold
                          the result.

Return Value:

    None.

--*/
{
    pLsaUnicodeString->Buffer = KCCSIM_WCSDUP (pwszString);
    pLsaUnicodeString->Length = (USHORT)wcslen (pLsaUnicodeString->Buffer);
}

VOID
KCCSimQueryDnsDomainInformation (
    IO  PLSAPR_POLICY_DNS_DOMAIN_INFO pDnsDomainInfo
    )
/*++

Routine Description:

    Helper function for SimLsaIQueryInformationPolicyTrusted that
    fills an LSAPR_POLICY_DNS_DOMAIN_INFO structure with data.

Arguments:

    pDnsDomainInfo      - Pointer to a DNS domain info structure that will
                          hold the result.

Return Value:

    None.

--*/
{
    KCCSimAllocLsaUnicodeString (
        KCCSimAnchorString (KCCSIM_ANCHOR_DOMAIN_NAME),
        &pDnsDomainInfo->Name
        );
    KCCSimAllocLsaUnicodeString (
        KCCSimAnchorString (KCCSIM_ANCHOR_DOMAIN_DNS_NAME),
        &pDnsDomainInfo->DnsDomainName
        );
    KCCSimAllocLsaUnicodeString (
        KCCSimAnchorString (KCCSIM_ANCHOR_ROOT_DOMAIN_DNS_NAME),
        &pDnsDomainInfo->DnsForestName
        );
    memcpy (
        &pDnsDomainInfo->DomainGuid,
        &(KCCSimAnchorDn (KCCSIM_ANCHOR_DOMAIN_DN))->Guid,
        sizeof (GUID)
        );
    pDnsDomainInfo->Sid = NULL;
}

NTSTATUS NTAPI
SimLsaIQueryInformationPolicyTrusted (
    IN  POLICY_INFORMATION_CLASS    InformationClass,
    OUT PLSAPR_POLICY_INFORMATION * Buffer
    )
/*++

Routine Description:

    Simulates the LsaIQueryInformationPolicyTrusted API.

Arguments:

    InformationClass    - The information class to query.
    Buffer              - A pointer to the result.

Return Value:

    STATUS_*.

--*/
{
    PLSAPR_POLICY_INFORMATION       pPolicyInfo;
    NTSTATUS                        ntStatus;

    pPolicyInfo = KCCSIM_NEW (LSAPR_POLICY_INFORMATION);

    switch (InformationClass) {

        case PolicyDnsDomainInformation:
            KCCSimQueryDnsDomainInformation (
                &pPolicyInfo->PolicyDnsDomainInfo
                );
            break;

        case PolicyAuditLogInformation:
        case PolicyAuditEventsInformation:
        case PolicyPrimaryDomainInformation:
        case PolicyPdAccountInformation:
        case PolicyAccountDomainInformation:
        case PolicyLsaServerRoleInformation:
        case PolicyReplicaSourceInformation:
        case PolicyDefaultQuotaInformation:
        case PolicyModificationInformation:
        case PolicyAuditFullSetInformation:
        case PolicyAuditFullQueryInformation:
        default:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_UNSUPPORTED_POLICY_INFORMATION_CLASS
                );
            break;

    }

    *Buffer = pPolicyInfo;

    return STATUS_SUCCESS;

}

VOID NTAPI
SimLsaIFree_LSAPR_POLICY_INFORMATION (
    IN  POLICY_INFORMATION_CLASS    InformationClass,
    IN  PLSAPR_POLICY_INFORMATION   PolicyInformation
    )
/*++

Routine Description:

    Simulates the LsaIFree_LSAPR_POLICY_INFORMATION API.

Arguments:

    InformationClass    - The information class of PolicyInformation.
    PolicyInformation   - The structure to free.

Return Value:

    None.

--*/
{
    PLSAPR_POLICY_DNS_DOMAIN_INFO   pDnsDomainInfo;

    if (PolicyInformation != NULL) {

        switch (InformationClass) {

            case PolicyDnsDomainInformation:
                pDnsDomainInfo = &PolicyInformation->PolicyDnsDomainInfo;
                if (pDnsDomainInfo->Name.Buffer != NULL) {
                    KCCSimFree (pDnsDomainInfo->Name.Buffer);
                }
                if (pDnsDomainInfo->DnsDomainName.Buffer != NULL) {
                    KCCSimFree (pDnsDomainInfo->DnsDomainName.Buffer);
                }
                if (pDnsDomainInfo->DnsForestName.Buffer != NULL) {
                    KCCSimFree (pDnsDomainInfo->DnsForestName.Buffer);
                }
                if (pDnsDomainInfo->Sid != NULL) {
                    KCCSimFree (pDnsDomainInfo->Sid);
                }
                break;

            case PolicyAuditLogInformation:
            case PolicyAuditEventsInformation:
            case PolicyPrimaryDomainInformation:
            case PolicyPdAccountInformation:
            case PolicyAccountDomainInformation:
            case PolicyLsaServerRoleInformation:
            case PolicyReplicaSourceInformation:
            case PolicyDefaultQuotaInformation:
            case PolicyModificationInformation:
            case PolicyAuditFullSetInformation:
            case PolicyAuditFullQueryInformation:
            default:
                KCCSimException (
                    KCCSIM_ETYPE_INTERNAL,
                    KCCSIM_ERROR_UNSUPPORTED_POLICY_INFORMATION_CLASS
                    );
                break;

        }

        KCCSimFree (PolicyInformation);

    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\sim\simmdnam.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    simmdnam.c

ABSTRACT:

    Helper functions to do name resolution for the
    SimDir* APIs.  Also contains simulators for some
    of the name-processing APIs from ntdsa.dll.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <direrr.h>
#include <debug.h>
#include <winldap.h>
#include "kccsim.h"
#include "util.h"
#include "dir.h"
#include "simmd.h"
#include <fileno.h>
#define FILENO  FILENO_KCCSIM_SIMMDNAM

LPWSTR
SimGuidBasedDNSNameFromDSName (
    IN  PDSNAME                     pdnServer
    )
/*++

Routine Description:

    Simulates the GuidBasedDNSNameFromDSName API.

Arguments:

    pdnServer           - The DSName to convert.

Return Value:

    An allocated GUID-based DNS name.

--*/
{
    return KCCSimAllocGuidBasedDNSNameFromDSName (pdnServer);
}

PSIM_ENTRY
KCCSimResolveName (
    IN  PDSNAME                     pObject,
    IO  COMMRES *                   pCommRes
    )
/*++

Routine Description:

    Resolves a given DSNAME into a simulated directory entry.

Arguments:

    pObject             - The DN to resolve.
    pCommRes            - A COMMRES structure where any errors that occur
                          are to be recorded.

Return Value:

    The corresponding simulated directory entry, or NULL if none
    could be found.

--*/
{
    PSIM_ENTRY                      pEntry;

    pEntry = KCCSimDsnameToEntry (pObject, KCCSIM_NO_OPTIONS);
    if (pEntry == NULL) {                   // Entry doesn't exist
        KCCSimSetNamError (
            pCommRes,
            NA_PROBLEM_NO_OBJECT,
            NULL,
            DIRERR_OBJ_NOT_FOUND
            );
    }

    return pEntry;
}

PDSNAME
SimDsGetDefaultObjCategory (
    IN  ATTRTYP                     objClass
    )
/*++

Routine Description:

    Simulates the DsGetDefaultObjCategory API.

Arguments:

    objClass            - The object class.

Return Value:

    The corresponding default object category.

--*/
{
    return KCCSimAlwaysGetObjCategory (objClass);
}

NTSTATUS
SimGetConfigurationName (
    IN  DWORD                       which,
    IO  DWORD *                     pcbName,
    IO  DSNAME *                    pName
    )
/*++

Routine Description:

    Simulates the GetConfigurationName API.

Arguments:

    which               - A DSCONFIGNAME_* constant that specifies the
                          DN to retrieve.
    pcbName             - On input, contains the size of the pName buffer
                          in bytes.  If STATUS_BUFFER_TOO_SMALL is returned,
                          then on output, contains the required buffer size.
    pName               - A preallocated buffer that will hold the returned
                          configuration name.

Return Value:

    STATUS_*.

--*/
{
    const DSNAME *                  pdn;

    if (pcbName == NULL) {
        return (STATUS_INVALID_PARAMETER);
    }

    RtlZeroMemory (pName, *pcbName);

    switch (which) {
        case DSCONFIGNAME_DMD:
            pdn = KCCSimAnchorDn (KCCSIM_ANCHOR_DMD_DN);
            break;
        case DSCONFIGNAME_DSA:
            pdn = KCCSimAnchorDn (KCCSIM_ANCHOR_DSA_DN);
            break;
        case DSCONFIGNAME_DOMAIN:
            pdn = KCCSimAnchorDn (KCCSIM_ANCHOR_DOMAIN_DN);
            break;
        case DSCONFIGNAME_CONFIGURATION:
            pdn = KCCSimAnchorDn (KCCSIM_ANCHOR_CONFIG_DN);
            break;
        case DSCONFIGNAME_ROOT_DOMAIN:
            pdn = KCCSimAnchorDn (KCCSIM_ANCHOR_ROOT_DOMAIN_DN);
            break;
        case DSCONFIGNAME_LDAP_DMD:
            pdn = KCCSimAnchorDn (KCCSIM_ANCHOR_LDAP_DMD_DN);
            break;
        case DSCONFIGNAME_PARTITIONS:
            pdn = KCCSimAnchorDn (KCCSIM_ANCHOR_PARTITIONS_DN);
            break;
        case DSCONFIGNAME_DS_SVC_CONFIG:
            pdn = KCCSimAnchorDn (KCCSIM_ANCHOR_DS_SVC_CONFIG_DN);
            break;
        default:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_UNSUPPORTED_CONFIG_NAME
                );
            pdn = NULL;
            break;
    }

    // Check if pName is large enough
    if (*pcbName < pdn->structLen) {
        *pcbName = pdn->structLen;
        return (STATUS_BUFFER_TOO_SMALL);
    }

    if (pName == NULL) {
        return (STATUS_INVALID_PARAMETER);
    }

    memcpy (pName, pdn, pdn->structLen);

    return (STATUS_SUCCESS);

}


LPSTR
SimDSNAMEToMappedStrExternal(
    IN DSNAME *pName,
    IN OPTIONAL BOOLEAN fUseNormalAllocator
    )

/*++

Routine Description:

    Return a ASCII string key that can be used for sorting dsnames

    We need to simulate this function instead of calling the corresponding
    function in ntdsa because that function allocates its own memory.

    The memory returned by this function must be off of the thread heap
    so that the caller can free it himself.

Arguments:

    pDn - 

Return Value:

    LPSTR - 

--*/

{
    LPWSTR *ppwzRDNs = NULL, *ppwzLoopRDNs, pwzRDN;
    LPSTR pszKey = NULL;
    LPWSTR pwzParts = NULL;
    ULONG mappedLen, inLen;

    Assert( pName );

    // Break up name into RDNs without types
    // This may not handle quoting quite as well as UnQuoteRDN, but it will
    // be close enough for the simulator's purposes
    ppwzRDNs = ldap_explode_dnW( pName->StringName, 1 );
    if (!ppwzRDNs) {
        return NULL;
    }

    // Space for concatenated name
    pwzParts = KCCSimAlloc( pName->NameLen * sizeof(WCHAR) );

    // Concatenate the RDNs to form a temporary name

    ppwzLoopRDNs = ppwzRDNs;
    for( pwzRDN = *ppwzLoopRDNs++; pwzRDN; pwzRDN = *ppwzLoopRDNs++ ) {
        wcscat( pwzParts, pwzRDN );
    }

    // Calculate length of mapped string
    inLen = wcslen( pwzParts );
    mappedLen = LCMapStringW(DS_DEFAULT_LOCALE,
                             (DS_DEFAULT_LOCALE_COMPARE_FLAGS | LCMAP_SORTKEY),
                             pwzParts,
                             inLen,
                             NULL,
                             0);
    if (mappedLen) {
        // Caller owned memory returned on thread heap!
        if( fUseNormalAllocator ) {
            pszKey = KCCSimAlloc( mappedLen );
        } else {
            pszKey = KCCSimThreadAlloc( mappedLen );
        }

        if (!LCMapStringW(DS_DEFAULT_LOCALE,
                         (DS_DEFAULT_LOCALE_COMPARE_FLAGS | LCMAP_SORTKEY),
                          pwzParts,
                          inLen,
                          (WCHAR *)pszKey,
                          mappedLen)) {

            DPRINT1 (0, "LCMapString failed with %x\n", GetLastError());
            KCCSimFree( pszKey );
            pszKey = NULL;
        }

    }
    else {
        DPRINT1 (0, "LCMapString failed with %x\n", GetLastError());
        Assert( FALSE );
    }

//cleanup:

    if (ppwzRDNs) {
        ldap_value_freeW( ppwzRDNs );
    }

    if (pwzParts) {
        KCCSimFree( pwzParts );
    }

    return pszKey;

} /* SimDSNAMEToMappedStrExternal */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\sim\simtime.h ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    simtime.h

ABSTRACT:

    Header file for simtime.c.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

VOID
KCCSimInitializeTime (
    VOID
    );

VOID
KCCSimStartTicking (
    VOID
    );

VOID
KCCSimStopTicking (
    VOID
    );

VOID
KCCSimAddSeconds (
    ULONG                           ulSeconds
    );

DSTIME
KCCSimGetRealTime (
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\sim\simtime.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    simtime.c

ABSTRACT:

    Routines that govern the simulated time.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <debug.h>
#include "simtime.h"
#include <fileno.h>
#define FILENO  FILENO_KCCSIM_SIMTIME

struct _KCCSIM_TIME {
    DSTIME                          timeSim;
    BOOL                            bIsTicking;
    DSTIME                          timeStartedTicking;
};

struct _KCCSIM_TIME                 gSimTime;

VOID
KCCSimInitializeTime (
    VOID
    )
/*++

Routine Description:

    Initializes the simulated time to the real time.

Arguments:

    None.

Return Values:

    None.

--*/
{
    gSimTime.timeSim = KCCSimGetRealTime ();
    gSimTime.bIsTicking = FALSE;
    gSimTime.timeStartedTicking = 0;
}

VOID
KCCSimStartTicking (
    VOID
    )
/*++

Routine Description:

    Starts the simulated time.

Arguments:

    None.

Return Values:

    None.

--*/
{
    Assert (!gSimTime.bIsTicking);
    gSimTime.bIsTicking = TRUE;
    gSimTime.timeStartedTicking = KCCSimGetRealTime ();
}

VOID
KCCSimStopTicking (
    VOID
    )
/*++

Routine Description:

    Pauses the simulated time.

Arguments:

    None.

Return Values:

    None.

--*/
{
    Assert (gSimTime.bIsTicking);
    gSimTime.timeSim +=
      (KCCSimGetRealTime () - gSimTime.timeStartedTicking);
    gSimTime.bIsTicking = FALSE;
    gSimTime.timeStartedTicking = 0;
}

DSTIME
SimGetSecondsSince1601 (
    VOID
    )
/*++

Routine Description:

    Simulates GetSecondsSince1601 () by returning the simulated time.

Arguments:

    None.

Return Values:

    The simulated time.

--*/
{
    if (gSimTime.bIsTicking) {
        return (gSimTime.timeSim +
                KCCSimGetRealTime () - gSimTime.timeStartedTicking);
    } else {
        return gSimTime.timeSim;
    }
}

VOID
KCCSimAddSeconds (
    ULONG                           ulSeconds
    )
/*++

Routine Description:

    Increments the simulated time.

Arguments:

    ulSeconds           - Number of seconds to add.

Return Values:

    None.

--*/
{
    gSimTime.timeSim += ulSeconds;
}

/***

    KCCSimGetRealTime MUST be placed at the end of this file!  In order to
    get the real time, we call the real GetSecondsSince1601 (), so we must
    #undef the fake one.  This will affect (perhaps adversely) any functions
    that appear below KCCSimGetRealTime.

***/

// Prototype for the real GetSecondsSince1601, since it isn't exposed.
DSTIME GetSecondsSince1601 (
    VOID
    );

DSTIME
KCCSimGetRealTime (
    VOID
    )
/*++

Routine Description:

    Returns the real time.

Arguments:

    None.

Return Values:

    The real time.

--*/
{
#ifdef GetSecondsSince1601
#undef GetSecondsSince1601
#endif
    return GetSecondsSince1601 ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\sim\simmdrd.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    simmdrd.c

ABSTRACT:

    Simulates the read functions from the mdlayer
    (DirRead, DirSearch.)

    Note that these routines return results in thread allocated memory (see ThCreate,
    ThAlloc, etc).  There must be thread state active in order for these routines
    to be able to allocate memory.

    The results of these routines should not be used for simulator long term memory of
    cached results. If the caller wants there results to outlast the current thread
    state, he must copy them.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <direrr.h>
#include <attids.h>
#include <filtypes.h>
#include "kccsim.h"
#include "util.h"
#include "dir.h"
#include "simmd.h"
#include "state.h"

#define NO_UPPER_LIMIT              0xffffffff

VOID
KCCSimGetValueLimits (
    IN  ATTRTYP                     attrType,
    IN  RANGEINFSEL *               pRangeSel,
    OUT PDWORD                      pStartIndex,
    OUT PDWORD                      pNumValues
    )
/*++

Routine Description:

    Given a range selection, returns the start index and
    number of values to return from an attribute.
    
    Note this is almost identical to the corresponding
    function in the dblayer.

Arguments:

    attrType            - The attribute type being read.
    pRangeSel           - The range selection.
    pStartIndex         - Pointer to a DWORD that will hold the start index.
    pNumValues          - Pointer to a DWORD that will hold the number of
                          values to retrieve.

Return Value:

    None.

--*/
{
    DWORD                           i;

    // Assume no limits.
    *pStartIndex = 0;
    *pNumValues = NO_UPPER_LIMIT;

    if(!pRangeSel) {
        // Yup, no limits.
        return;
    }

    // OK, assume only general limit, not specific match.
    *pNumValues = pRangeSel->valueLimit;

    // Look through the rangesel for a specific match
    for(i=0;i<pRangeSel->count;i++) {
        if(attrType == pRangeSel->pRanges[i].AttId) {
            if(pRangeSel->pRanges[i].upper == NO_UPPER_LIMIT) {
                *pStartIndex = pRangeSel->pRanges[i].lower;
                return;
            }
            else if(pRangeSel->pRanges[i].lower <=pRangeSel->pRanges[i].upper) {
                DWORD tempNumVals;
                *pStartIndex = pRangeSel->pRanges[i].lower;
                tempNumVals = (pRangeSel->pRanges[i].upper -
                               pRangeSel->pRanges[i].lower   )+ 1;

                if(*pNumValues != NO_UPPER_LIMIT) {
                    *pNumValues = min(*pNumValues, tempNumVals);
                }
                else {
                    *pNumValues = tempNumVals;
                }
            }
            else {
                *pNumValues = 0;
            }
            return;
        }
    }
}

VOID
KCCSimRegisterLimitReached (
    IO  RANGEINF *                  pRangeInf,
    IN  ATTRTYP                     attrType,
    IN  DWORD                       dwLower,
    IN  DWORD                       dwUpper
    )
/*++

Routine Description:

    When the number of attribute values read has reached the
    maximum allowed, this function makes a note of it in the
    rangeinf parameter.

Arguments:

    pRangeInf           - The rangeinf structure.
    attrType            - The attribute type.
    dwLower             - The lower limit.
    dwUpper             - The upper limit.

Return Value:

    None.

--*/
{
    if (pRangeInf->count == 0) {
        pRangeInf->pRanges = KCCSIM_THNEW (RANGEINFOITEM);
    } else {
        pRangeInf->pRanges =
          KCCSimThreadReAlloc (
              pRangeInf->pRanges,
              (pRangeInf->count + 1) * sizeof (RANGEINFOITEM));
    }

    pRangeInf->pRanges[pRangeInf->count].AttId = attrType;
    pRangeInf->pRanges[pRangeInf->count].lower = dwLower;
    pRangeInf->pRanges[pRangeInf->count].upper = dwUpper;

    pRangeInf->count++;
}

BOOL
KCCSimIsMatchingAttribute (
    IN  ENTINFSEL *                 pEntSel,
    IN  ATTRTYP                     attrType
    )
/*++

Routine Description:

    Checks whether the given attribute satisfies the entry
    selection parameters specified for a read.

Arguments:

    pEntSel             - Entry selection parameters.
    attrType            - The attribute type.

Return Value:

    TRUE if the attribute satisfies the given constraints.

--*/
{
    BOOL                            bResult;
    ULONG                           ulAttrAt;

    // If there are no restrictions, just return true
    if (pEntSel == NULL) {
        return TRUE;
    }

    switch (pEntSel->attSel) {

        case EN_ATTSET_ALL:
            bResult = TRUE;
            break;

        case EN_ATTSET_LIST:
            bResult = FALSE;
            // Check if it's in the list
            for (ulAttrAt = 0;
                 ulAttrAt < pEntSel->AttrTypBlock.attrCount;
                 ulAttrAt++) {
                if (attrType == pEntSel->AttrTypBlock.pAttr[ulAttrAt].attrTyp) {
                    bResult = TRUE;
                    break;
                }
            }
            break;

        case EN_ATTSET_ALL_WITH_LIST:
        case EN_ATTSET_LIST_DRA:
        case EN_ATTSET_ALL_DRA:
        case EN_ATTSET_LIST_DRA_EXT:
        case EN_ATTSET_ALL_DRA_EXT:
        case EN_ATTSET_LIST_DRA_PUBLIC:
        case EN_ATTSET_ALL_DRA_PUBLIC:
        default:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_UNSUPPORTED_ATTSET
                );
            bResult = FALSE;
            break;

    }

    return bResult;
}

VOID
KCCSimPackSingleAttribute (
    IN  ATTRTYP                     attrType,
    IN  PSIM_VALUE                  pValFirst,
    IN  UCHAR                       infoTypes,
    IN  RANGEINFSEL *               pRangeSel,
    IO  ATTR *                      pAttr,
    IO  RANGEINF *                  pRangeInf
    )
{
    PSIM_VALUE                      pValStart, pValAt;
    DWORD                           dwValAt, dwStartIndex, dwNumValues;

    pAttr->attrTyp = attrType;

    switch (infoTypes) {

        case EN_INFOTYPES_TYPES_ONLY:
            pAttr->AttrVal.valCount = 0;
            pAttr->AttrVal.pAVal = NULL;
            break;

        case EN_INFOTYPES_TYPES_VALS:
            KCCSimGetValueLimits (attrType,
                                  pRangeSel,
                                  &dwStartIndex,
                                  &dwNumValues);
            // Proceed to value dwStartIndex
            pValStart = pValFirst;
            dwValAt = 0;
            while (dwValAt < dwStartIndex && pValStart != NULL) {
                dwValAt++;
                pValStart = pValStart->next;
            }
            // Determine the actual number of values to return
            pValAt = pValStart;
            dwValAt = 0;
            while (dwValAt < dwNumValues && pValAt != NULL) {
                dwValAt++;
                pValAt = pValAt->next;
            }
            pAttr->AttrVal.valCount = dwValAt;
            pAttr->AttrVal.pAVal =
                (ATTRVAL *) KCCSimThreadAlloc (sizeof (ATTRVAL) * dwValAt);
            // Pack the values
            pValAt = pValStart;
            dwValAt = 0;
            while (dwValAt < dwNumValues && pValAt != NULL) {
                pAttr->AttrVal.pAVal[dwValAt].valLen
                  = pValAt->ulLen;
                pAttr->AttrVal.pAVal[dwValAt].pVal
                  = (PBYTE) KCCSimThreadAlloc (pValAt->ulLen);
                memcpy (pAttr->AttrVal.pAVal[dwValAt].pVal,
                        pValAt->pVal,
                        pValAt->ulLen);
                dwValAt++;
                pValAt = pValAt->next;
            }
            // Right now, the only time we can have a limited range is if
            // the user explicitly requested one.  This happens if either:
            // - There's a lower limit, or
            // - Not all values were returned, and the next one to be returned
            //   (= dwStartIndex + dwNumValues) is strictly less than valueLimit
            if (pRangeSel != NULL &&
                (dwStartIndex > 0 ||
                 (dwStartIndex + dwNumValues < pRangeSel->valueLimit &&
                  pValAt != NULL))) {
                KCCSimRegisterLimitReached (
                    pRangeInf,
                    attrType,
                    dwStartIndex,
                    dwStartIndex + dwNumValues - 1
                    );
            }
            break;

        case EN_INFOTYPES_TYPES_MAPI:
        case EN_INFOTYPES_SHORTNAMES:
        case EN_INFOTYPES_MAPINAMES:
        default:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_UNSUPPORTED_INFOTYPE
                );
            break;

    }
}


// When defined, the simulator will return simulated repsfroms to the KCC.
#define SIMULATED_REPSFROM


VOID
KCCSimPackAttributes (
    IN  PSIM_ENTRY                  pEntry,
    IN  ENTINFSEL *                 pEntSel,
    IN  RANGEINFSEL *               pRangeSel,
    IO  ENTINF *                    pEntInf,
    IO  RANGEINF *                  pRangeInf
    )
/*++

Routine Description:

    Given ENTINFSEL and RANGEINFSEL structures, this function
    generates the ENTINF and RANGEINF structures for a particular entry.

Arguments:

    pEntry              - The entry to process.
    pEntInfSel          - The entry selection constraints.
    pRangeInfSel        - The range selection constraints.
    pEntInf             - Pointer to an ENTINF structure that will hold
                          the returned data.
    pRangeInf           - Pointer to a RANGEINF structure that will hold
                          the returned range restrictions.

Return Value:

    None.

--*/
{
    UCHAR                           infoTypes;

    PSIM_ATTRIBUTE                  pAttrAt;
    ATTRBLOCK *                     pAttrBlock;
    DWORD                           dwAttrAt;

    if (pEntSel == NULL) {      // Use default for infoTypes
        infoTypes = EN_INFOTYPES_TYPES_VALS;
    } else {
        infoTypes = pEntSel->infoTypes;
    }

    // Fill in pEntInf / pRangeInf basics

    pEntInf->pName = KCCSimThreadAlloc (pEntry->pdn->structLen);
    memcpy (
        pEntInf->pName,
        pEntry->pdn,
        pEntry->pdn->structLen
        );
    pEntInf->ulFlags = 0;        // We don't fill this in yet, but unused by KCC.
    pRangeInf->count = 0;
    pRangeInf->pRanges = NULL;

    // Fill in the attribute block & range info
    pAttrBlock = &pEntInf->AttrBlock;

    // How many attributes are there that match attSel?
    pAttrAt = pEntry->pAttrFirst;
    dwAttrAt = 0;
    while (pAttrAt != NULL) {
        if (
#ifdef SIMULATED_REPSFROM
            pAttrAt->attrType != ATT_REPS_FROM &&   // repsFrom is handled separately
#endif // SIMULATED_REPSFROM
            KCCSimIsMatchingAttribute (pEntSel, pAttrAt->attrType)) {
            dwAttrAt++;
        }
        pAttrAt = pAttrAt->next;
    }

    // Did they request repsFrom?
#ifdef SIMULATED_REPSFROM
    if (KCCSimIsMatchingAttribute (pEntSel, ATT_REPS_FROM) &&
        KCCSimGetRepsFroms (
            KCCSimAnchorDn (KCCSIM_ANCHOR_DSA_DN),
            pEntry->pdn
            ) != NULL) {
        dwAttrAt++;
    }
#endif // SIMULATED_REPSFROM

    pAttrBlock->attrCount = dwAttrAt;
    pAttrBlock->pAttr = (ATTR *) KCCSimThreadAlloc (sizeof (ATTR) * dwAttrAt);

    pAttrAt = pEntry->pAttrFirst;
    dwAttrAt = 0;
    while (pAttrAt != NULL) {
        if (
#ifdef SIMULATED_REPSFROM
            pAttrAt->attrType != ATT_REPS_FROM &&
#endif // SIMULATED_REPSFROM
            KCCSimIsMatchingAttribute (pEntSel, pAttrAt->attrType)) {

            KCCSimPackSingleAttribute (
                pAttrAt->attrType,
                pAttrAt->pValFirst,
                infoTypes,
                pRangeSel,
                &pAttrBlock->pAttr[dwAttrAt],
                pRangeInf
                );
            dwAttrAt++;

        }
        pAttrAt = pAttrAt->next;
    }

    // Add repsFrom
#ifdef SIMULATED_REPSFROM
    if (KCCSimIsMatchingAttribute (pEntSel, ATT_REPS_FROM) &&
        KCCSimGetRepsFroms (
            KCCSimAnchorDn (KCCSIM_ANCHOR_DSA_DN),
            pEntry->pdn
            ) != NULL) {
        KCCSimPackSingleAttribute (
            ATT_REPS_FROM,
            KCCSimGetRepsFroms (
                KCCSimAnchorDn (KCCSIM_ANCHOR_DSA_DN),
                pEntry->pdn),
            infoTypes,
            pRangeSel,
            &pAttrBlock->pAttr[dwAttrAt],
            pRangeInf
            );
    }
#endif // SIMULATED_REPSFROM
}

ULONG
SimDirRead (
    IN  READARG FAR *               pReadArg,
    OUT READRES **                  ppReadRes
    )
/*++

Routine Description:

    Simulates the DirRead API.

Arguments:

    pReadArg            - Standard DirRead arguments.
    ppReadRes           - Standard DirRead results.

Return Value:

    DIRERR_*.

--*/
{
    READRES *                       pReadRes;
    PSIM_ENTRY                      pEntry;
    ENTINF *                        pEntInf;
    RANGEINF *                      pRangeInf;

    ULONG                           ul;

    g_Statistics.DirReadOps++;
    *ppReadRes = pReadRes = KCCSIM_THNEW (READRES);
    pReadRes->CommRes.errCode = 0;

    pEntry = KCCSimResolveName (pReadArg->pObject, &pReadRes->CommRes);

    if (pEntry != NULL) {

        KCCSimPackAttributes (pEntry,
                              pReadArg->pSel,
                              pReadArg->pSelRange,
                              &pReadRes->entry,
                              &pReadRes->range);

        // If the user requested a list of attributes, and the list
        // is nonempty, and no attributes were found, it's an error
        if (pReadArg->pSel &&
            pReadArg->pSel->AttrTypBlock.attrCount > 0 &&
            pReadRes->entry.AttrBlock.attrCount == 0) {

            for (ul = 0; ul < pReadArg->pSel->AttrTypBlock.attrCount; ul++) {

                KCCSimSetAttError (
                    &pReadRes->CommRes,
                    pReadArg->pObject,
                    pReadArg->pSel->AttrTypBlock.pAttr[ul].attrTyp,
                    PR_PROBLEM_NO_ATTRIBUTE_OR_VAL,
                    NULL,
                    DIRERR_NO_REQUESTED_ATTS_FOUND
                );

            }
        }

    }

    return pReadRes->CommRes.errCode;
}

BOOL
KCCSimEvalChoice (
    PSIM_ENTRY                      pEntry,
    UCHAR                           ucChoice,
    ATTRTYP                         attrType,
    ULONG                           ulFilterValLen,
    PUCHAR                          pFilterVal,
    PBOOL                           pbSkip
    )
/*++

Routine Description:

    Evaluates a filter on a given entry.

Arguments:

    pEntry              - The entry to evaluate.
    ucChoice            - The filter choice.
    attrType            - The attribute type.
    ulFilterValLen      - Length of the filter value.
    pFilterVal          - The filter value.
    pbSkip              - Skip parameter.

Return Value:

    TRUE if this entry matches the filter.

--*/
{
    SIM_ATTREF                      attRef;
    PSIM_VALUE                      pVal;
    BOOL                            bEvalAny, bPassed;

    bEvalAny = FALSE;           // Have we checked any values?
    bPassed = FALSE;            // Have any values passed the test?

    // Find this attribute in the directory
    KCCSimGetAttribute (pEntry, attrType, &attRef);

    // We only try to evaluate this FILITEM if pbSkip is FALSE
    // or doesn't exist.

    if (attRef.pAttr != NULL &&
        (pbSkip == NULL || *pbSkip == FALSE)) {

        for (pVal = attRef.pAttr->pValFirst;
             pVal != NULL;
             pVal = pVal->next) {

            // Found a value.
            bEvalAny = TRUE;

            if (KCCSimCompare (
                    attrType,
                    ucChoice,
                    ulFilterValLen,
                    pFilterVal,
                    pVal->ulLen,
                    pVal->pVal)) {
                bPassed = TRUE;
                break;
            }

        } // for

    } // if

    // If we evaluated at least one value, then we return
    // bPassed.  If we evaluated no values, we return TRUE
    // if and only if the filitem choice is FI_CHOICE_NOT_EQUAL.
    if (bEvalAny) {
        return bPassed;
    } else {
        return (ucChoice == FI_CHOICE_NOT_EQUAL);
    }

}

BOOL
KCCSimEvalItem (
    PSIM_ENTRY                      pEntry,
    FILITEM *                       pFilItem
    )
/*++

Routine Description:

    Evaluates a single filter item on a given entry.

Arguments:

    pEntry              - The entry to evaluate.
    pFilItem            - The filter item.

Return Value:

    TRUE if the entry matches the filter item.

--*/
{
    BOOL bResult = FALSE;

    // Get the attribute type
    switch (pFilItem->choice) {
        
        case FI_CHOICE_FALSE:
            bResult = FALSE;
            break;

        case FI_CHOICE_TRUE:
            bResult = TRUE;
            break;

        case FI_CHOICE_PRESENT:
            bResult = KCCSimEvalChoice (
                pEntry,
                pFilItem->choice,
                pFilItem->FilTypes.present,
                0,
                NULL,
                pFilItem->FilTypes.pbSkip
                );
            break;

        case FI_CHOICE_SUBSTRING:
            bResult = KCCSimEvalChoice (
                pEntry,
                pFilItem->choice,
                pFilItem->FilTypes.pSubstring->type,
                0,          // N/A for substrings
                (PUCHAR) pFilItem->FilTypes.pSubstring,
                pFilItem->FilTypes.pbSkip
                );
            break;

        case FI_CHOICE_EQUALITY:
        case FI_CHOICE_NOT_EQUAL:
        case FI_CHOICE_GREATER_OR_EQ:
        case FI_CHOICE_GREATER:
        case FI_CHOICE_LESS_OR_EQ:
        case FI_CHOICE_LESS:
        case FI_CHOICE_BIT_AND:
        case FI_CHOICE_BIT_OR:
            bResult = KCCSimEvalChoice (
                pEntry,
                pFilItem->choice,
                pFilItem->FilTypes.ava.type,
                pFilItem->FilTypes.ava.Value.valLen,
                pFilItem->FilTypes.ava.Value.pVal,
                pFilItem->FilTypes.pbSkip
                );
            break;

        default:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_UNSUPPORTED_FILITEM_CHOICE
                );
            break;

    }

    return bResult;
}

BOOL
KCCSimFilter (
    IN  PSIM_ENTRY                  pEntry,
    IN  PFILTER                     pFilter
    )
/*++

Routine Description:

    Evaluates a filter on a given entry.

Arguments:

    pEntry              - The entry to evaluate.
    pFilter             - The filter.

Return Value:

    TRUE if the entry matches the filter.

--*/
{
    PFILTER                         pFilterAt;
    BOOL                            bThisFilterValue;
    USHORT                          usCount;

    // What kind of filter is this?
    switch (pFilter->choice) {

        case FILTER_CHOICE_ITEM:
            // It's an item, so we can just evaluate the FILITEM.
            bThisFilterValue = KCCSimEvalItem (
                pEntry,
                &(pFilter->FilterTypes.Item)
                );
            break;

        case FILTER_CHOICE_AND:
            // It's an AND filterset.  So, check if any of its elements
            // are false.  Return TRUE only if all elements return TRUE.
            bThisFilterValue = TRUE;
            pFilterAt = pFilter->FilterTypes.And.pFirstFilter;
            usCount = pFilter->FilterTypes.And.count;
            while (pFilterAt != NULL && usCount > 0) {
                if (KCCSimFilter (pEntry, pFilterAt) == FALSE) {
                    bThisFilterValue = FALSE;
                    break;
                }
                pFilterAt = pFilterAt->pNextFilter;
                usCount--;
            }
            break;

        case FILTER_CHOICE_OR:
            // It's an OR filterset.  Same idea as with AND: we return
            // FALSE only if all elements return FALSE.
            bThisFilterValue = FALSE;
            pFilterAt = pFilter->FilterTypes.Or.pFirstFilter;
            usCount = pFilter->FilterTypes.Or.count;
            while (pFilterAt != NULL && usCount > 0) {
                if (KCCSimFilter (pEntry, pFilterAt) == TRUE) {
                    bThisFilterValue = TRUE;
                    break;
                }
                pFilterAt = pFilterAt->pNextFilter;
                usCount--;
            }
            break;

        case FILTER_CHOICE_NOT:
            // It's a NOT.  Return the converse of its element.
            bThisFilterValue =
                !KCCSimFilter (pEntry, pFilter->FilterTypes.pNot);
            break;

        default:
            // It's something we don't know about . . .
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_UNSUPPORTED_FILTER_CHOICE
                );
            bThisFilterValue = FALSE;
            break;

    }

    return bThisFilterValue;
}

VOID
KCCSimDoSearch (
    IN  PSIM_ENTRY                  pEntryAt,
    IN  UCHAR                       ucChoice,
    IN  PFILTER                     pFilter,
    IN  ENTINFSEL *                 pEntSel,
    IN  RANGEINFSEL *               pRangeSel,
    IO  PBOOL                       pbFirstFind,
    IO  SEARCHRES *                 pSearchRes
    )
/*++

Routine Description:

    Recursive search routine.  Generates search results for
    pEntryAt and all of its children, under the supplied choice,
    filter, entry selection and range selection constraints.

    Note: For performance reason, we prepend new matches to the beginning
    of the result list. Therefore, the ordering of the results is not what
    it used to be, but this shouldn't matter.

Arguments:

    pEntryAt            - The entry we're currently searching.
    ucChoice            - The type of search we are doing (base only,
                          immediate children, or whole subtree)
    pFilter             - The filter.
    pEntSel             - The entry selection constraints.
    pRangeSel           - The range selection constraints.
    pbFirstFind         - Initially set to TRUE.  After a match has
                          been found, this is set to FALSE.
    pSearchRes          - Preallocated search results structure.

Return Value:

    None.

--*/
{
    PSIM_ENTRY                      pChildAt;
    ENTINFLIST *                    pEntInfList;
    RANGEINFLIST *                  pRangeInfList;
    ENTINF *                        pEntInf;
    RANGEINF *                      pRangeInf;

    if (KCCSimFilter (pEntryAt, pFilter)) {

        // This entry matches the filter, so we need to generate
        // search results.

        pSearchRes->count++;

        if (*pbFirstFind) {
            pEntInf = &(pSearchRes->FirstEntInf.Entinf);
            pRangeInf = &(pSearchRes->FirstRangeInf.RangeInf);
        } else {
            ENTINFLIST *pEntTail;
            RANGEINFLIST *pRangeTail;

            // Add a new entinf to the _head_ of the list
            pEntTail = pSearchRes->FirstEntInf.pNextEntInf;
            pEntInfList = KCCSIM_THNEW (ENTINFLIST);
            pSearchRes->FirstEntInf.pNextEntInf = pEntInfList;
            pEntInfList->pNextEntInf = pEntTail;
            pEntInf = &(pEntInfList->Entinf);

            // Add a new rangeinf to the _head_ of the list
            pRangeTail = pSearchRes->FirstRangeInf.pNext;
            pRangeInfList = KCCSIM_THNEW (RANGEINFLIST);
            pSearchRes->FirstRangeInf.pNext = pRangeInfList;
            pRangeInfList->pNext = pRangeTail;
            pRangeInf = &(pRangeInfList->RangeInf);
        }

        // Pack the attributes for this entry.
        KCCSimPackAttributes (
            pEntryAt,
            pEntSel,
            pRangeSel,
            pEntInf,
            pRangeInf
            );

        *pbFirstFind = FALSE;

    }

    switch (ucChoice) {

        case SE_CHOICE_BASE_ONLY:
            // We're done!
            break;

        case SE_CHOICE_IMMED_CHLDRN:
            // We need to do a recursive base-only search on each child.
            pChildAt = pEntryAt->children;
            while (pChildAt != NULL) {
                KCCSimDoSearch (
                    pChildAt,
                    SE_CHOICE_BASE_ONLY,
                    pFilter,
                    pEntSel,
                    pRangeSel,
                    pbFirstFind,
                    pSearchRes
                    );
                pChildAt = pChildAt->next;
            }
            break;

        case SE_CHOICE_WHOLE_SUBTREE:
            // We need to do a recursive whole-subtree search on each child.
            pChildAt = pEntryAt->children;
            while (pChildAt != NULL) {
                KCCSimDoSearch (
                    pChildAt,
                    SE_CHOICE_WHOLE_SUBTREE,
                    pFilter,
                    pEntSel,
                    pRangeSel,
                    pbFirstFind,
                    pSearchRes
                    );
                pChildAt = pChildAt->next;
            }
            break;

        default:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_UNSUPPORTED_SE_CHOICE
                );
            break;

    }
}    

ULONG
SimDirSearch (
    IN  SEARCHARG *                 pSearchArg,
    OUT SEARCHRES **                ppSearchRes
    )
/*++

Routine Description:

    Simulates the DirSearch API.

Arguments:

    pSearchArg          - Standard search arguments.
    ppSearchRes         - Standard search results.

Return Value:

    DIRERR_*.

--*/
{
    SEARCHRES *                     pSearchRes;
    PSIM_ENTRY                      pBase;

    BOOL                            bFirstFind;

    g_Statistics.DirSearchOps++;
    *ppSearchRes = pSearchRes = KCCSIM_THNEW (SEARCHRES);
    pSearchRes->CommRes.errCode = 0;

    pBase = KCCSimResolveName (pSearchArg->pObject, &pSearchRes->CommRes);

    if (pBase != NULL) {

        pSearchRes->baseProvided = FALSE;           // Ignored
        pSearchRes->bSorted = FALSE;                // Ignored
        pSearchRes->pBase = NULL;                   // Ignored
        pSearchRes->count = 0;
        pSearchRes->FirstEntInf.pNextEntInf = NULL;
        pSearchRes->FirstRangeInf.pNext = NULL;
        pSearchRes->pPartialOutcomeQualifier = NULL;// Ignored
        pSearchRes->PagedResult.fPresent = FALSE;   // Ignored
        pSearchRes->PagedResult.pRestart = NULL;   // Ignored
        bFirstFind = TRUE;
        // Call the recursive search.
        KCCSimDoSearch (
            pBase,
            pSearchArg->choice,
            pSearchArg->pFilter,
            pSearchArg->pSelection,
            pSearchArg->pSelectionRange,
            &bFirstFind,
            pSearchRes
            );

    }

    return pSearchRes->CommRes.errCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\sim\user.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    user.c

ABSTRACT:

    Contains user interface routines for KCCSim.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

    04/12/2000      Nicholas Harvey (nickhar)
        Added functions to examine the current intra-site topologies and
        display graph-theoretic information.

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <drs.h>
#include <dsutil.h>
#include <mdglobal.h>
#include <attids.h>
#include <debug.h>
#include "kccsim.h"
#include "util.h"
#include "dir.h"
#include "state.h"
#include "user.h"
#include <fileno.h>
#define FILENO  FILENO_KCCSIM_USER

VOID
KCCSimDumpDirectoryRecurse (
    IN  PSIM_ENTRY                  pEntry,
    IN  ULONG                       ulDepth
    )
/*++

Routine Description:

    Recursively retty-prints the DN of every entry
    in a sub-tree of the directory.

Arguments:

    pEntry              - The entry to start from.
    ulDepth             - Present depth of the sub-tree.  Used to determine
                          how far over each DN should be tabbed.

Return Value:

    None.

--*/
{
    PSIM_ENTRY                      pEntryChildAt;
    PSIM_ATTRIBUTE                  pAttrAt;
    ULONG                           ulCount, ulNumAttrs;

    pAttrAt = pEntry->pAttrFirst;
    ulNumAttrs = 0;
    while (pAttrAt != NULL) {
        ulNumAttrs++;
        pAttrAt = pAttrAt->next;
    }
    for (ulCount = 0; ulCount < ulDepth; ulCount++)
        printf ("  ");
    wprintf (
        L"%-*.*s%3.3s [%2d]\n",
        71 - (2 * ulDepth),
        71 - (2 * ulDepth),
        pEntry->pdn->StringName,
        wcslen (pEntry->pdn->StringName) > 71 - (2 * ulDepth) ?
            L"..." :
            L"   ",
        ulNumAttrs
        );

    for (pEntryChildAt = pEntry->children;
         pEntryChildAt != NULL;
         pEntryChildAt = pEntryChildAt->next) {
        KCCSimDumpDirectoryRecurse (pEntryChildAt, 1L + ulDepth);
    }
}

VOID
KCCSimDumpDirectory (
    IN  LPCWSTR                     pwszStartDn
    )
/*++

Routine Description:

    Pretty-prints the DN of every entry in a sub-tree of the directory.

Arguments:

    pwszStartDn         - The DN to use as the root.

Return Value:

    None.

--*/
{
    PDSNAME                         pdn;
    PSIM_ENTRY                      pEntryStart;

    if (pwszStartDn == NULL || pwszStartDn[0] == L'\0') {
        pEntryStart = KCCSimDsnameToEntry (NULL, KCCSIM_NO_OPTIONS);
    } else {
        pdn = KCCSimAllocDsname (pwszStartDn);
        pEntryStart = KCCSimDsnameToEntry (pdn, KCCSIM_NO_OPTIONS);
        KCCSimFree (pdn);
    }

    if (pEntryStart != NULL) {
        KCCSimDumpDirectoryRecurse (pEntryStart, 0);
    }
}

LPWSTR
KCCSimNtdsDsaGuidToServerName (
    IN  GUID *                      pGuid,
    IO  LPWSTR                      pwszBuf
    )
/*++

Routine Description:

    Helper function that returns a server's RDN given the
    GUID of its NTDS Settings object.

Arguments:

    pGuid               - Pointer to the GUID of an NTDS Settings object.
    pwszBuf             - Preallocated buffer to hold the server RDN.

Return Value:

    Always returns pwszBuf.

--*/
{
    PSIM_ENTRY                      pEntry;
    PDSNAME                         pdn;

    pdn = KCCSimAllocDsname (NULL);
    memcpy (&pdn->Guid, pGuid, sizeof (GUID));
    pEntry = KCCSimDsnameToEntry (pdn, KCCSIM_NO_OPTIONS);
    KCCSimFree (pdn);

    if (pEntry == NULL) {
        return NULL;
    }

    pdn = KCCSimAlloc (pEntry->pdn->structLen);
    TrimDSNameBy (pEntry->pdn, 1, pdn);
    KCCSimQuickRDNOf (pdn, pwszBuf);
    KCCSimFree (pdn);
    return pwszBuf;
}

VOID
KCCSimDisplayLinksForNC (
    const DSNAME *                  pdnServer,
    const DSNAME *                  pdnNC,
    BOOL                            bIsMasterNC
    )
{
    PSIM_VALUE                      pValAt;

    REPLICA_LINK *                  prl;
    CHAR                            szLastSuccess[1+SZDSTIME_LEN];
    CHAR                            szLastAttempt[1+SZDSTIME_LEN];
    WCHAR                           wszRDN[1+MAX_RDN_SIZE];
    LPWSTR                          pwszOtherDsaGuidS,
                                    pwszInvocIdS,
                                    pwszTransportGuidS;

    wprintf (
        L"\nREPLICA_LINKs for %s NC\n%s\n",
        bIsMasterNC ? L"master" : L"partial replica",
        pdnNC->StringName
        );

    for (pValAt = KCCSimGetRepsFroms (pdnServer, pdnNC);
         pValAt != NULL;
         pValAt = pValAt->next) {

        prl = (REPLICA_LINK *) pValAt->pVal;
        VALIDATE_REPLICA_LINK_VERSION (prl);
        Assert (prl->V1.cbOtherDraOffset == offsetof (REPLICA_LINK, V1.rgb));

        KCCSIM_CHKERR (UuidToStringW (
            &prl->V1.uuidDsaObj,
            &pwszOtherDsaGuidS));
        KCCSIM_CHKERR (UuidToStringW (
            &prl->V1.uuidInvocId,
            &pwszInvocIdS));
        KCCSIM_CHKERR (UuidToStringW (
            &prl->V1.uuidTransportObj,
            &pwszTransportGuidS));

        wprintf (
            L"\n"
            L"Consecutive Failures: %d\n"
            L"Last Success        : %S\n"
            L"Last Attempt        : %S\n"
            L"Last Result         : %d\n"
            L"Replica Flags       : 0x%x\n"
            L"Other DSA GUID      : %s [%s]\n"
            L"Other DSA Invocation: %s\n"
            L"Transport GUID      : %s\n"
            L"Other DSA Matrix Adr: %S\n",
            prl->V1.cConsecutiveFailures,
            DSTimeToDisplayString (prl->V1.timeLastSuccess, szLastSuccess),
            DSTimeToDisplayString (prl->V1.timeLastAttempt, szLastAttempt),
            prl->V1.ulResultLastAttempt,
            prl->V1.ulReplicaFlags,
            pwszOtherDsaGuidS,
            KCCSimNtdsDsaGuidToServerName (&prl->V1.uuidDsaObj, wszRDN),
            pwszInvocIdS,
            pwszTransportGuidS,
            ((MTX_ADDR *) prl->V1.rgb)->mtx_name
            );

        RpcStringFreeW (&pwszOtherDsaGuidS);
        RpcStringFreeW (&pwszInvocIdS);
        RpcStringFreeW (&pwszTransportGuidS);

    }

}

VOID
KCCSimDisplayServer (
    VOID
    )
{
    PSIM_ENTRY                      pEntryDsa;
    SIM_ATTREF                      attRef;
    PSIM_VALUE                      pValAt;
    PDSNAME                         pdn;
    WCHAR                           wszRDN[1+MAX_RDN_SIZE];

    pEntryDsa = KCCSimDsnameToEntry (
        KCCSimAnchorDn (KCCSIM_ANCHOR_DSA_DN),
        KCCSIM_NO_OPTIONS
        );

    KCCSimQuickRDNBackOf (
        pEntryDsa->pdn,
        1,
        wszRDN
        );

    wprintf (L"Configuration for %s:\n\n", wszRDN);

    KCCSimPrintMessage (
        KCCSIM_MSG_DISPLAY_ANCHOR,
        (KCCSimAnchorDn (KCCSIM_ANCHOR_DMD_DN))->StringName,
        (KCCSimAnchorDn (KCCSIM_ANCHOR_DSA_DN))->StringName,
        (KCCSimAnchorDn (KCCSIM_ANCHOR_DOMAIN_DN))->StringName,
        (KCCSimAnchorDn (KCCSIM_ANCHOR_CONFIG_DN))->StringName,
        (KCCSimAnchorDn (KCCSIM_ANCHOR_ROOT_DOMAIN_DN))->StringName,
        (KCCSimAnchorDn (KCCSIM_ANCHOR_LDAP_DMD_DN))->StringName,
        (KCCSimAnchorDn (KCCSIM_ANCHOR_PARTITIONS_DN))->StringName,
        (KCCSimAnchorDn (KCCSIM_ANCHOR_DS_SVC_CONFIG_DN))->StringName,
        (KCCSimAnchorDn (KCCSIM_ANCHOR_SITE_DN))->StringName,
        KCCSimAnchorString (KCCSIM_ANCHOR_DOMAIN_NAME),
        KCCSimAnchorString (KCCSIM_ANCHOR_DOMAIN_DNS_NAME),
        KCCSimAnchorString (KCCSIM_ANCHOR_ROOT_DOMAIN_DNS_NAME)
        );

    wprintf (
        L"\nThis server returns %d on bind attempts.\n",
        KCCSimGetBindError (pEntryDsa->pdn)
        );

    if (!KCCSimGetAttribute (pEntryDsa, ATT_HAS_MASTER_NCS, &attRef)) {
        wprintf (L"Could not locate Master NCs!\n");
        return;
    }

    for (pValAt = attRef.pAttr->pValFirst;
         pValAt != NULL;
         pValAt = pValAt->next) {

        KCCSimDisplayLinksForNC (pEntryDsa->pdn, (PDSNAME) pValAt->pVal, TRUE);

    }

    if (KCCSimGetAttribute (pEntryDsa, ATT_HAS_PARTIAL_REPLICA_NCS, &attRef)) {
        for (pValAt = attRef.pAttr->pValFirst;
             pValAt != NULL;
             pValAt = pValAt->next) {

            KCCSimDisplayLinksForNC (pEntryDsa->pdn, (PDSNAME) pValAt->pVal, FALSE);

        }
    }

}

VOID
KCCSimDisplayTopologyInfo (
    IN  PSIM_ENTRY                  pEntrySites,
    IN  BOOL                        bInterSite
    )
/*++

Routine Description:

    Displays information about the enterprise topology.

Arguments:

    pEntrySites         - The Sites container.
    bInterSite          - If TRUE, displays the inter-site topology.
                          If FALSE, displays the intra-site topology
                          for each site in the enterprise.

Return Value:

    None.

--*/
{
    PSIM_ENTRY                      pEntrySiteAt, pEntrySiteSettings,
                                    pEntryServers, pEntryServerAt,
                                    pEntryNtdsDsa, pEntryConnectionAt;
    SIM_ATTREF                      attRef;
    LPWSTR                          pwszUuid;
    WCHAR                           wszRDNBuf1[1+MAX_RDN_SIZE],
                                    wszRDNBuf2[1+MAX_RDN_SIZE],
                                    wszRDNBuf3[1+MAX_RDN_SIZE];
    ULONG                           ulOptions;
    BOOL                            bIsEnabled, bPrint;
    PDSNAME                         pdnTransportType = NULL,
                                    pdnFromServer = NULL;
    RPC_STATUS                      rpcStatus;
    PSIM_VALUE                      pValAt;

    if (bInterSite) {
        wprintf (L"Intersite Topology:\n");
    } else {
        wprintf (L"Intrasite Topology:\n");
    }

    for (pEntrySiteAt = KCCSimFindFirstChild (
            pEntrySites, CLASS_SITE, NULL);
         pEntrySiteAt != NULL;
         pEntrySiteAt = KCCSimFindNextChild (
            pEntrySiteAt, CLASS_SITE, NULL)) {

        pEntrySiteSettings = KCCSimFindFirstChild (
            pEntrySiteAt,
            CLASS_NTDS_SITE_SETTINGS,
            NULL
            );
        if (pEntrySiteSettings == NULL) {
            wprintf (
                L"Site [%s]: Could not locate NTDS Site Settings!\n",
                KCCSimQuickRDNOf (pEntrySiteAt->pdn, wszRDNBuf1)
                );
            continue;
        }

        KCCSimGetAttribute (pEntrySiteSettings, ATT_OPTIONS, &attRef);
        if (attRef.pAttr == NULL ||
            attRef.pAttr->pValFirst == NULL) {
            ulOptions = 0;
        } else {
            ulOptions = *((SYNTAX_INTEGER *) attRef.pAttr->pValFirst->pVal);
        }

        rpcStatus = UuidToStringW (&pEntrySiteAt->pdn->Guid, &pwszUuid);
        if( rpcStatus != RPC_S_OK ) {
            wprintf ( L"Site [%s]: Failed to convert Guid to string!\n",
                KCCSimQuickRDNOf (pEntrySiteAt->pdn, wszRDNBuf1)
                );
            continue;
        }

        if (!bInterSite) {
            wprintf (
                L"Site [%c%c%c%c%c] %s [%s]:\n",
                (ulOptions & NTDSSETTINGS_OPT_IS_AUTO_TOPOLOGY_DISABLED)     ?
                  KCCSIM_CID_NTDSSETTINGS_OPT_IS_AUTO_TOPOLOGY_DISABLED      : L' ',
                (ulOptions & NTDSSETTINGS_OPT_IS_TOPL_CLEANUP_DISABLED)      ?
                  KCCSIM_CID_NTDSSETTINGS_OPT_IS_TOPL_CLEANUP_DISABLED       : L' ',
                (ulOptions & NTDSSETTINGS_OPT_IS_TOPL_MIN_HOPS_DISABLED)     ?
                  KCCSIM_CID_NTDSSETTINGS_OPT_IS_TOPL_MIN_HOPS_DISABLED      : L' ',
                (ulOptions & NTDSSETTINGS_OPT_IS_TOPL_DETECT_STALE_DISABLED) ?
                  KCCSIM_CID_NTDSSETTINGS_OPT_IS_TOPL_DETECT_STALE_DISABLED  : L' ',
                (ulOptions & NTDSSETTINGS_OPT_IS_INTER_SITE_AUTO_TOPOLOGY_DISABLED) ?
                  KCCSIM_CID_NTDSSETTINGS_OPT_IS_INTER_SITE_AUTO_TOPOLOGY_DISABLED
                                                                             : L' ',
                pwszUuid,
                KCCSimQuickRDNOf (pEntrySiteAt->pdn, wszRDNBuf1)
                );
        }
        RpcStringFreeW (&pwszUuid);

        pEntryServers = KCCSimFindFirstChild (
            pEntrySiteAt,
            CLASS_SERVERS_CONTAINER,
            NULL
            );

        if (pEntryServers == NULL) {
            wprintf (L"  Could not locate servers container!\n");
            continue;
        }

        for (pEntryServerAt = KCCSimFindFirstChild (
                pEntryServers, CLASS_SERVER, NULL);
             pEntryServerAt != NULL;
             pEntryServerAt = KCCSimFindNextChild (
                pEntryServerAt, CLASS_SERVER, NULL)) {

            pEntryNtdsDsa = KCCSimFindFirstChild (
                pEntryServerAt,
                CLASS_NTDS_DSA,
                NULL
                );
            if (pEntryNtdsDsa == NULL) {
                wprintf (
                    L"  Server [%s]: Could not locate NTDS Settings!\n",
                    KCCSimQuickRDNOf (pEntryServerAt->pdn, wszRDNBuf1)
                    );
                continue;
            }

            KCCSimGetAttribute (pEntryNtdsDsa, ATT_OPTIONS, &attRef);
            if (attRef.pAttr == NULL ||
                attRef.pAttr->pValFirst == NULL) {
                ulOptions = 0;
            } else {
                ulOptions = *((SYNTAX_INTEGER *) attRef.pAttr->pValFirst->pVal);
            }

            rpcStatus = UuidToStringW (&pEntryNtdsDsa->pdn->Guid, &pwszUuid);
            if( rpcStatus != RPC_S_OK ) {
                wprintf ( L"  Server [%s]: Failed to convert Guid to string!\n",
                    KCCSimQuickRDNOf (pEntryServerAt->pdn, wszRDNBuf1)
                    );
                continue;
            }

            if (!bInterSite) {
                wprintf (
                    L"  Server [%c%c%c%c] %s [%s]:\n",
                    (ulOptions & NTDSDSA_OPT_IS_GC)                  ?
                      KCCSIM_CID_NTDSDSA_OPT_IS_GC                   : L' ',
                    (ulOptions & NTDSDSA_OPT_DISABLE_INBOUND_REPL)   ?
                      KCCSIM_CID_NTDSDSA_OPT_DISABLE_INBOUND_REPL    : L' ',
                    (ulOptions & NTDSDSA_OPT_DISABLE_OUTBOUND_REPL)  ?
                      KCCSIM_CID_NTDSDSA_OPT_DISABLE_OUTBOUND_REPL   : L' ',
                    (ulOptions & NTDSDSA_OPT_DISABLE_NTDSCONN_XLATE) ?
                      KCCSIM_CID_NTDSDSA_OPT_DISABLE_NTDSCONN_XLATE  : L' ',
                    pwszUuid,
                    KCCSimQuickRDNOf (pEntryServerAt->pdn, wszRDNBuf1)
                    );
            }
            RpcStringFreeW (&pwszUuid);

            for (pEntryConnectionAt = KCCSimFindFirstChild (
                    pEntryNtdsDsa, CLASS_NTDS_CONNECTION, NULL);
                 pEntryConnectionAt != NULL;
                 pEntryConnectionAt = KCCSimFindNextChild (
                    pEntryConnectionAt, CLASS_NTDS_CONNECTION, NULL)) {

                KCCSimGetAttribute (pEntryConnectionAt, ATT_ENABLED_CONNECTION, &attRef);
                if (attRef.pAttr == NULL || attRef.pAttr->pValFirst == NULL) {
                    wprintf (
                        L"    Connection %s lacks an enabled attribute!\n",
                        KCCSimQuickRDNOf (pEntryConnectionAt->pdn, wszRDNBuf1)
                        );
                    continue;
                }
                if (*((SYNTAX_BOOLEAN *) attRef.pAttr->pValFirst->pVal)) {
                     bIsEnabled = TRUE;
                } else {
                    bIsEnabled = FALSE;
                }

                KCCSimGetAttribute (pEntryConnectionAt, ATT_FROM_SERVER, &attRef);
                if (attRef.pAttr == NULL || attRef.pAttr->pValFirst == NULL) {
                    wprintf (
                        L"    Connection %s lacks a fromServer attribute!\n",
                        KCCSimQuickRDNOf (pEntryConnectionAt->pdn, wszRDNBuf1)
                        );
                    continue;
                }
                pdnFromServer = (SYNTAX_DISTNAME *) attRef.pAttr->pValFirst->pVal;

                KCCSimGetAttribute (pEntryConnectionAt, ATT_OPTIONS, &attRef);
                if (attRef.pAttr == NULL ||
                    attRef.pAttr->pValFirst == NULL) {
                    ulOptions = 0;
                } else {
                    ulOptions = *((SYNTAX_INTEGER *) attRef.pAttr->pValFirst->pVal);
                }

                KCCSimGetAttribute (pEntryConnectionAt, ATT_TRANSPORT_TYPE, &attRef);
                if (attRef.pAttr == NULL ||
                    attRef.pAttr->pValFirst == NULL) {
                    pdnTransportType = NULL;
                } else {
                    pdnTransportType = (SYNTAX_DISTNAME *) attRef.pAttr->pValFirst->pVal;
                }

                bPrint = FALSE;
                if (bInterSite && (pdnTransportType != NULL)) {
                    wprintf (
                        L"[%s] Connection [%c%c%c%c] [%-4s] to %s from %s\n",
                        bIsEnabled ? L"Enabled " : L"Disabled",
                        (ulOptions & NTDSCONN_OPT_IS_GENERATED)            ?
                          KCCSIM_CID_NTDSCONN_OPT_IS_GENERATED             : L' ',
                        (ulOptions & NTDSCONN_OPT_TWOWAY_SYNC)             ?
                          KCCSIM_CID_NTDSCONN_OPT_TWOWAY_SYNC              : L' ',
                        (ulOptions & NTDSCONN_OPT_OVERRIDE_NOTIFY_DEFAULT) ?
                          KCCSIM_CID_NTDSCONN_OPT_OVERRIDE_NOTIFY_DEFAULT  : L' ',
                        (ulOptions & NTDSCONN_OPT_USE_NOTIFY)              ?
                          KCCSIM_CID_NTDSCONN_OPT_USE_NOTIFY               : L' ',
                        KCCSimQuickRDNOf (pdnTransportType, wszRDNBuf1),
                        KCCSimQuickRDNOf (pEntryServerAt->pdn, wszRDNBuf2),
                        KCCSimQuickRDNBackOf (pdnFromServer, 1, wszRDNBuf3)
                        );
                    bPrint = TRUE;
                } else if (!bInterSite && (pdnTransportType == NULL)) {
                    wprintf (
                        L"    [%s] Connection [%c%c%c%c] from %s\n",
                        bIsEnabled ? L"Enabled " : L"Disabled",
                        (ulOptions & NTDSCONN_OPT_IS_GENERATED)            ?
                          KCCSIM_CID_NTDSCONN_OPT_IS_GENERATED             : L' ',
                        (ulOptions & NTDSCONN_OPT_TWOWAY_SYNC)             ?
                          KCCSIM_CID_NTDSCONN_OPT_TWOWAY_SYNC              : L' ',
                        (ulOptions & NTDSCONN_OPT_OVERRIDE_NOTIFY_DEFAULT) ?
                          KCCSIM_CID_NTDSCONN_OPT_OVERRIDE_NOTIFY_DEFAULT  : L' ',
                        (ulOptions & NTDSCONN_OPT_USE_NOTIFY)              ?
                          KCCSIM_CID_NTDSCONN_OPT_USE_NOTIFY               : L' ',
                        KCCSimQuickRDNBackOf (pdnFromServer, 1, wszRDNBuf1)
                        );
                    bPrint = TRUE;
                }

                if (bPrint) {
                    // Print the list of NC's to replicate over this connection (if available)
                    KCCSimGetAttribute (pEntryConnectionAt, ATT_MS_DS_REPLICATES_NC_REASON, &attRef);
                    if (attRef.pAttr != NULL) {
                        wprintf( L"    [" );
                        for (pValAt = attRef.pAttr->pValFirst;
                             pValAt != NULL;
                             pValAt = pValAt->next) {
                            // pVal is a distname-binary
                            SYNTAX_DISTNAME_BINARY *pReason = (SYNTAX_DISTNAME_BINARY *) pValAt->pVal;
                            DSNAME *pdnNC = NAMEPTR( pReason );
                            wprintf( L"%s ", KCCSimQuickRDNOf (pdnNC, wszRDNBuf1) );
                        }
                        wprintf( L"]\n" );
                    }

                    // Print this connection's schedule (if it exists)
                    KCCSimGetAttribute (pEntryConnectionAt, ATT_SCHEDULE, &attRef);
                    if (attRef.pAttr != NULL) {
                        PSCHEDULE pSchedule;
                        DWORD i, lastByte, cbSchedule, cbSchedData;
                        char* pData;

                        cbSchedule = sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES;
                        cbSchedData = SCHEDULE_DATA_ENTRIES;

                        wprintf( L"    [ " );
                        if( attRef.pAttr->pValFirst->ulLen != cbSchedule ) {

                            wprintf( L" Invalid Schedule " );

                        } else {

                            pSchedule = (PSCHEDULE) attRef.pAttr->pValFirst->pVal;
                            pData = ((char*) pSchedule) + sizeof(SCHEDULE);
                            
                            // Find the last non-zero byte in the string
                            lastByte = SCHEDULE_DATA_ENTRIES-1;
                            while( pData[lastByte]==0 ) {
                                lastByte--;
                            }
                            
                            // Print the schedule data in hex, ignoring trailing zeros,
                            // and inserting spaces between every dword
                            for( i=0; i<=lastByte; i++ ) {
                                wprintf( L"%02x", pData[i] );
                                if(i%4==3) wprintf( L" ");
                            }

                            if( lastByte==0 ) {
                                wprintf( L"empty schedule" );
                            }
                        }                        
                        wprintf( L" ]\n" );
                    }                }

            } // for each connection

        }  // for each server/dsa

    } // for each site

    wprintf (L"\n");
}

VOID
KCCSimDisplayConfigInfo (
    VOID
    )
/*++

Routine Description:

    Displays the configuration information.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PSIM_ENTRY                      pEntryRoot, pEntryConfig, pEntrySites,
                                    pEntryTransports, pEntryTransportAt,
                                    pEntrySiteLinkAt, pEntryBridgeAt;
    SIM_ATTREF                      attRef;
    PSIM_VALUE                      pValAt;

    WCHAR                           wszRDNBuf1[1+MAX_RDN_SIZE],
                                    wszRDNBuf2[1+MAX_RDN_SIZE];
    ULONG                           ulOptions;

    pEntryRoot = KCCSimDsnameToEntry (NULL, KCCSIM_NO_OPTIONS);
    if (pEntryRoot == NULL) {
        wprintf (L"The directory is empty!\n");
        return;
    }

    pEntryConfig = KCCSimFindFirstChild (pEntryRoot, CLASS_CONFIGURATION, NULL);
    if (pEntryConfig == NULL) {
        wprintf (L"Could not locate config container!\n");
        return;
    }

    wprintf (L"Displaying configuration information.\n\n");

    pEntrySites = KCCSimFindFirstChild (
        pEntryConfig,
        CLASS_SITES_CONTAINER,
        NULL
        );
    if (pEntrySites == NULL) {
        wprintf (L"Could not locate sites container!\n");
        return;
    }

    KCCSimDisplayTopologyInfo (pEntrySites, FALSE);
    KCCSimDisplayTopologyInfo (pEntrySites, TRUE);

    pEntryTransports = KCCSimFindFirstChild (
        pEntrySites,
        CLASS_INTER_SITE_TRANSPORT_CONTAINER,
        NULL
        );
    if (pEntryTransports == NULL) {
        wprintf (L"Could not locate inter-site transports container!\n");
        return;
    }

    for (pEntryTransportAt = KCCSimFindFirstChild
            (pEntryTransports, CLASS_INTER_SITE_TRANSPORT, NULL);
         pEntryTransportAt != NULL;
         pEntryTransportAt = KCCSimFindNextChild
            (pEntryTransportAt, CLASS_INTER_SITE_TRANSPORT, NULL)) {

        KCCSimQuickRDNOf (pEntryTransportAt->pdn, wszRDNBuf1);

        for (pEntryBridgeAt = KCCSimFindFirstChild
                (pEntryTransportAt, CLASS_SITE_LINK_BRIDGE, NULL);
             pEntryBridgeAt != NULL;
             pEntryBridgeAt = KCCSimFindNextChild
                (pEntryBridgeAt, CLASS_SITE_LINK_BRIDGE, NULL)) {

            wprintf (
                L"[%s] Bridge %s:\n",
                wszRDNBuf1,
                KCCSimQuickRDNOf (pEntryBridgeAt->pdn, wszRDNBuf2)
                );

            wprintf (L"  Site-Links  :");
            if (KCCSimGetAttribute (pEntryBridgeAt, ATT_SITE_LINK_LIST, &attRef)) {
                for (pValAt = attRef.pAttr->pValFirst;
                     pValAt != NULL;
                     pValAt = pValAt->next) {
                    wprintf (L" [%s]", KCCSimQuickRDNOf
                             ((SYNTAX_DISTNAME *) pValAt->pVal, wszRDNBuf2));
                }
            }
            wprintf (L"\n");
        }

        for (pEntrySiteLinkAt = KCCSimFindFirstChild
                (pEntryTransportAt, CLASS_SITE_LINK, NULL);
             pEntrySiteLinkAt != NULL;
             pEntrySiteLinkAt = KCCSimFindNextChild
                (pEntrySiteLinkAt, CLASS_SITE_LINK, NULL)) {

            wprintf (
                L"[%s] Site-link %s:\n",
                wszRDNBuf1,
                KCCSimQuickRDNOf (pEntrySiteLinkAt->pdn, wszRDNBuf2)
                );

            wprintf (L"  Sites        :");
            if (KCCSimGetAttribute (pEntrySiteLinkAt, ATT_SITE_LIST, &attRef)) {
                for (pValAt = attRef.pAttr->pValFirst;
                     pValAt != NULL;
                     pValAt = pValAt->next) {
                    wprintf (L" [%s]", KCCSimQuickRDNOf
                             ((SYNTAX_DISTNAME *) pValAt->pVal, wszRDNBuf2));
                }
            }
            wprintf (L"\n");

            if (KCCSimGetAttribute (pEntrySiteLinkAt, ATT_COST, &attRef)) {
                wprintf (L"  Cost         : %lu\n", *((SYNTAX_INTEGER *)
                         attRef.pAttr->pValFirst->pVal));
            }
            if (KCCSimGetAttribute (pEntrySiteLinkAt, ATT_REPL_INTERVAL, &attRef)) {
                wprintf (L"  Repl Interval: %lu\n", *((SYNTAX_INTEGER *)
                         attRef.pAttr->pValFirst->pVal));
            }

        }

    }
}


/*++

Structure Name:
    
    SimpleDict

Description:

    Simple fixed-size dictionary for mapping a set of Unicode strings to
    integers in [0,n]. Uses a simple sorted array.

Usage:
    Create using DictNew(), giving the maximum number of entries.
    Add entries using the DictAdd() function.
    After adding all entries, use DictSort() to sort the entries.
    The entries can then be efficiently looked up using DictLookup().
    When finished with the dictionary, use DictFree() to free its memory.

--*/
typedef struct {
    WCHAR**     data;
    int         maxSize, curSize;
    char        sorted;         
} SimpleDict;


VOID
DictNew (
    SimpleDict                      *d,
    int                             size
    )
/*++

Routine Description:

    DictNew - Create a new SimpleDict

Arguments:

    d                   - Pointer to a SimpleDict structure
    size                - Maximum number of elements the dict can contain

Return Value:

    None, but returns an initialized dictionary in d
    
--*/
{
    int i;
    Assert( size>0 );
    d->maxSize = d->curSize = 0;
    d->data = (WCHAR**) KCCSimAlloc( sizeof(WCHAR*)*size );
    d->maxSize = size;
}


VOID
DictFree (
    SimpleDict                       *d
    )
/*++

Routine Description:

    DictFree - Free the memory used by a SimpleDict

Arguments:

    d                   - Pointer to a valid SimpleDict structure

Return Value:

    None

--*/
{
    int i;
    for(i=0;i<d->curSize;i++) {
        if(d->data[i]) {
            KCCSimFree( d->data[i] );
            d->data[i] = NULL;
        }
    }
    KCCSimFree( d->data );
    d->data=NULL;
    d->maxSize = d->curSize = 0;
}


VOID
DictAdd (
    SimpleDict *d,
    WCHAR* wszStr
    )
/*++

Routine Description:

    DictAdd - Add a string to the dictionary
    The dictionary must not be full already.

Arguments:

    d                   - Pointer to a valid SimpleDict structure
    wszStr              - Pointer to a Unicode string

Return Value:

    None

--*/
{
    Assert( d->curSize<d->maxSize );
    d->data[d->curSize] = (WCHAR*) KCCSimAlloc( (wcslen(wszStr)+1)*sizeof(WCHAR) );
    wcscpy( d->data[d->curSize], wszStr );
    d->curSize++;
    d->sorted=0;
}


int __cdecl wszCompare( const WCHAR** arg1, const WCHAR** arg2 ) {
    return wcscmp( *arg1, *arg2 );
}


VOID
DictSort (
    SimpleDict *d
    )
/*++

Routine Description:

    DictSort - Sort the entries in a dictionary for efficient lookup.

Arguments:

    d                   - Pointer to a valid SimpleDict structure

Return Value:

    None
    
--*/
{
    Assert( d->data );
    qsort( d->data, d->curSize, sizeof(WCHAR*), wszCompare );
    d->sorted=1;
}


int
DictLookup (
    SimpleDict *d,
    WCHAR* wszStr
    )
/*++

Routine Description:

    DictLookup - Search the dictionary for a string matching wszStr,
    and map its name to an integer.

Arguments:

    d                   - Pointer to a valid SimpleDict structure
    wszStr              - The string we're looking for

Return Value:

    If the string was found, return its index in [0,n]. If it
    was not found, return -1.

--*/
{
    void* p;
    int x;
    Assert( d->data );
    if( !d->sorted ) DictSort(d);
    p = bsearch( &wszStr, d->data, d->curSize, sizeof(WCHAR*), wszCompare );
    if(p==NULL) { return -1; }
    x = (int) (((WCHAR**)p)-d->data);
    Assert(0==wcscmp(wszStr,d->data[x]));
    return x;
}


#define INTMIN(x,y) ((x)<(y)?(x):(y))
#define INF      (~((int)0))


VOID
KCCSimDisplaySiteGraphInfo (
    IN  PSIM_ENTRY                  pEntrySites
    )
/*++
Routine Description:

    Displays graph-theoretic information about a site.

Arguments:

    pEntrySites         - The Sites container.

Return Value:

    None.

--*/
{
    PSIM_ENTRY                      pEntrySiteAt, pEntrySiteSettings,
                                    pEntryServers, pEntryServerAt,
                                    pEntryNtdsDsa, pEntryConnectionAt;
    SIM_ATTREF                      attRef;
    LPWSTR                          pwszUuid;
    WCHAR                           wszRDNBuf1[1+MAX_RDN_SIZE];
    BOOL                            bIsEnabled;
    PDSNAME                         pdnFromServer = NULL;

    SimpleDict                      dict;
    int                             i,j,k;
    int                             numServers, toServer, fromServer;
    unsigned int                    *mat=NULL,diam,avg;


    /* Loop over all sites */
    for (pEntrySiteAt = KCCSimFindFirstChild(pEntrySites, CLASS_SITE, NULL);
         pEntrySiteAt != NULL;
         pEntrySiteAt = KCCSimFindNextChild(pEntrySiteAt, CLASS_SITE, NULL)) {


        UuidToStringW (&pEntrySiteAt->pdn->Guid, &pwszUuid);
        KCCSimQuickRDNOf(pEntrySiteAt->pdn, wszRDNBuf1);
        wprintf( L"Site %s [%s]:\n",pwszUuid,wszRDNBuf1);
        RpcStringFreeW (&pwszUuid);

        pEntryServers = KCCSimFindFirstChild(pEntrySiteAt,CLASS_SERVERS_CONTAINER,NULL);
        if (pEntryServers == NULL) {
            wprintf (L"  Could not locate servers container!\n");
            continue;
        }


        /* Count the number of servers in the site */
        numServers=0;
        for (pEntryServerAt = KCCSimFindFirstChild (pEntryServers, CLASS_SERVER, NULL);
             pEntryServerAt != NULL;
             pEntryServerAt = KCCSimFindNextChild (pEntryServerAt, CLASS_SERVER, NULL))
        {
            numServers++;
        }

        wprintf(L"  Servers: %d\n", numServers);
        if( numServers==0 ) { continue; }
        DictNew(&dict, numServers);

        __try {

            /* Add the names of the servers to the dictionary */
            for (pEntryServerAt = KCCSimFindFirstChild (pEntryServers, CLASS_SERVER, NULL);
                 pEntryServerAt != NULL;
                 pEntryServerAt = KCCSimFindNextChild (pEntryServerAt, CLASS_SERVER, NULL))
            {
                KCCSimQuickRDNOf (pEntryServerAt->pdn, wszRDNBuf1);
                DictAdd(&dict, wszRDNBuf1);
            }
            DictSort(&dict);

            /* Allocate our adjacency matrix */
            mat = (int*) KCCSimAlloc( sizeof(int)*numServers*numServers );
            for(i=0;i<numServers;i++) {
                for(j=0;j<numServers;j++) {
                    mat[i*numServers+j] = (i==j)?0:INF;
                }
            }

            /* Loop over all servers in the site */
            for (pEntryServerAt = KCCSimFindFirstChild (pEntryServers, CLASS_SERVER, NULL);
                 pEntryServerAt != NULL;
                 pEntryServerAt = KCCSimFindNextChild (pEntryServerAt, CLASS_SERVER, NULL)) {

                pEntryNtdsDsa = KCCSimFindFirstChild(pEntryServerAt, CLASS_NTDS_DSA, NULL);
                if (pEntryNtdsDsa == NULL) {
                    wprintf( L"  Server [%s]: Could not locate NTDS Settings!\n",
                        KCCSimQuickRDNOf (pEntryServerAt->pdn, wszRDNBuf1));
                    continue;
                }

                KCCSimQuickRDNOf (pEntryServerAt->pdn, wszRDNBuf1);
                toServer = DictLookup(&dict, wszRDNBuf1);
                Assert(toServer>=0);

                /* Loop over all connections of this server */
                for (pEntryConnectionAt = KCCSimFindFirstChild (
                        pEntryNtdsDsa, CLASS_NTDS_CONNECTION, NULL);
                     pEntryConnectionAt != NULL;
                     pEntryConnectionAt = KCCSimFindNextChild (
                        pEntryConnectionAt, CLASS_NTDS_CONNECTION, NULL)) {

                    KCCSimGetAttribute (pEntryConnectionAt, ATT_ENABLED_CONNECTION, &attRef);
                    if (attRef.pAttr == NULL || attRef.pAttr->pValFirst == NULL) {
                        wprintf(L"    Connection %s lacks an enabled attribute!\n",
                            KCCSimQuickRDNOf (pEntryConnectionAt->pdn, wszRDNBuf1));
                        continue;
                    }
                    if (*((SYNTAX_BOOLEAN *) attRef.pAttr->pValFirst->pVal)) {
                         bIsEnabled = TRUE;
                    } else {
                        bIsEnabled = FALSE;
                    }

                    KCCSimGetAttribute (pEntryConnectionAt, ATT_FROM_SERVER, &attRef);
                    if (attRef.pAttr == NULL || attRef.pAttr->pValFirst == NULL) {
                        wprintf (L"    Connection %s lacks a fromServer attribute!\n",
                            KCCSimQuickRDNOf (pEntryConnectionAt->pdn, wszRDNBuf1));
                        continue;
                    }
                    pdnFromServer = (SYNTAX_DISTNAME *) attRef.pAttr->pValFirst->pVal;
                    KCCSimQuickRDNBackOf(pdnFromServer, 1, wszRDNBuf1);
                    fromServer = DictLookup( &dict, wszRDNBuf1 );

                    /* Ignore inter-site connections */
                    if( fromServer==-1 ) { continue; }

                    if( bIsEnabled ) {
                        Assert( 0<=fromServer ); Assert( fromServer<numServers );
                        Assert( 0<=toServer );   Assert( toServer<numServers );

                        /* Update our adjacency matrix accordingly */
                        mat[ toServer*numServers + fromServer ] = 1;
                    }

                }   /* End of connections */

            }   /* End of servers */

            /* Now that we have condensed the graph topology into an adjancency matrix,
             * we run Floyd-Warshall to determine all-pairs shortest path costs */
            for(k=0;k<numServers;k++) {
                for(i=0;i<numServers;i++) {
                    for(j=0;j<numServers;j++) {
                        if( mat[i*numServers+k]!=INF && mat[k*numServers+j]!=INF ) {
                            mat[i*numServers+j] =
                                INTMIN( mat[i*numServers+j],
                                        mat[i*numServers+k]+mat[k*numServers+j] ); 
                        }
                    }
                }
            }

            /* Now find the maximum length of a shortest path (ie, diameter) */
            diam = avg = 0;
            for(i=0;i<numServers;i++) {
                for(j=0;j<numServers;j++) {
                    if( mat[i*numServers+j]>diam ) diam=mat[i*numServers+j];
                    if(i!=j) avg+=mat[i*numServers+j];
                }
            }

            /* Print our results */
            if(diam==INF) {
                wprintf( L"    Intra-site topology diameter: Infinite (Graph disconnected)\n");
                wprintf( L"    Average shortest-path length: Infinite\n");
            } else {
                wprintf( L"    Intra-site topology diameter: %d\n", diam);
                wprintf( L"    Average shortest-path length: %f\n",
                    ((float)avg)/(float)(numServers*numServers-numServers));
            }

        } __finally {

            if(mat) KCCSimFree(mat);
            DictFree(&dict);

        }

    }   /* End of sites */

    wprintf (L"\n");
}


VOID
KCCSimDisplayGraphInfo (
    VOID
    )
/*++

Routine Description:

    Examines the configuration (ie. Connection objects in the current
    directory), and calculates some graph-theoretic statistics.
    Calls KCCSimDisplaySiteGraphInfo() to do most of the work.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PSIM_ENTRY                      pEntryRoot, pEntryConfig, pEntrySites;

    pEntryRoot = KCCSimDsnameToEntry (NULL, KCCSIM_NO_OPTIONS);
    if (pEntryRoot == NULL) {
        wprintf (L"The directory is empty!\n");
        return;
    }

    pEntryConfig = KCCSimFindFirstChild (pEntryRoot, CLASS_CONFIGURATION, NULL);
    if (pEntryConfig == NULL) {
        wprintf (L"Could not locate config container!\n");
        return;
    }

    wprintf (L"Displaying graph information.\n\n");

    pEntrySites = KCCSimFindFirstChild ( pEntryConfig, CLASS_SITES_CONTAINER, NULL );
    if (pEntrySites == NULL) {
        wprintf (L"Could not locate sites container!\n");
        return;
    }

    KCCSimDisplaySiteGraphInfo(pEntrySites);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\sim\simmdwt.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    simmdwt.c

ABSTRACT:

    Simulates the write functions from the mdlayer
    (DirAddEntry, DirRemoveEntry, DirModifyEntry.)

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <direrr.h>
#include <attids.h>
#include <debug.h>
#include "kccsim.h"
#include "util.h"
#include "dir.h"
#include "simmd.h"
#include "ldif.h"
#include <fileno.h>
#define FILENO  FILENO_KCCSIM_SIMMDWT

VOID
KCCSimAddValBlockToAtt (
    IN  PSIM_ATTREF                 pAttRef,
    IN  ATTRVALBLOCK *              pValsInf
    )
/*++

Routine Description:

    Adds an attribute value block to a simulated directory attribute.
    
    Note that this does not do any constraint checking, e.g. if you try
    to add several values to a single-valued attribute, it won't complain.

Arguments:

    pAttRef             - A reference to the desired attribute in the
                          simulated directory.
    pValsInf            - The values to add to the given attribute.

Return Value:

    None.

--*/
{
    ULONG                           ulValAt;
    PBYTE                           pValCopy;

    for (ulValAt = 0; ulValAt < pValsInf->valCount; ulValAt++) {

        pValCopy = KCCSimAlloc (pValsInf->pAVal[ulValAt].valLen);
        memcpy (
            pValCopy,
            pValsInf->pAVal[ulValAt].pVal,
            pValsInf->pAVal[ulValAt].valLen
            );

        KCCSimAddValueToAttribute (
            pAttRef,
            pValsInf->pAVal[ulValAt].valLen,
            pValCopy
            );

    }
}

ULONG
SimDirAddEntry (
    IN  ADDARG *                    pAddArg,
    OUT ADDRES **                   ppAddRes
    )
/*++

Routine Description:

    Simulates the DirAddEntry API.

Arguments:

    pAddArg             - Standard add arguments.
    ppAddRes            - Standard add results.

Return Value:

    DIRERR_*.

--*/
{
    PSIM_ENTRY                      pEntry;
    SIM_ATTREF                      attRef;
    ADDRES *                        pAddRes;
    ULONG                           ulAttrAt;

    Assert (pAddArg->pMetaDataVecRemote == NULL);

    g_Statistics.DirAddOps++;
    *ppAddRes = pAddRes = KCCSIM_NEW (ADDRES);
    pAddRes->CommRes.errCode = 0;

    // Check to see if this dsname already exists
    pEntry = KCCSimDsnameToEntry (pAddArg->pObject, KCCSIM_STRING_NAME_ONLY);

    if (pEntry == NULL) {       // It doesn't exist; we're clear to add
        
        pEntry = KCCSimDsnameToEntry (pAddArg->pObject, KCCSIM_WRITE);
        Assert (pEntry != NULL);

        for (ulAttrAt = 0; ulAttrAt < pAddArg->AttrBlock.attrCount; ulAttrAt++) {

            KCCSimNewAttribute (
                pEntry,
                pAddArg->AttrBlock.pAttr[ulAttrAt].attrTyp,
                &attRef
                );

            KCCSimAddValBlockToAtt (
                &attRef,
                &(pAddArg->AttrBlock.pAttr[ulAttrAt].AttrVal)
                );

        }

        // Add any missing vital attributes (such as GUID)
        KCCSimAddMissingAttributes (pEntry);

        // Fill the incoming DN with the GUID
        memcpy (&pAddArg->pObject->Guid, &pEntry->pdn->Guid, sizeof (GUID));

        // Log this change.
        KCCSimLogDirectoryAdd (
            pAddArg->pObject,
            &pAddArg->AttrBlock
            );

    } else {                    // The entry already exists!
        KCCSimSetUpdError (
            &pAddRes->CommRes,
            UP_PROBLEM_ENTRY_EXISTS,
            DIRERR_OBJ_STRING_NAME_EXISTS
            );
    }

    return pAddRes->CommRes.errCode;
}

ULONG
SimDirRemoveEntry (
    IN  REMOVEARG *                 pRemoveArg,
    OUT REMOVERES **                ppRemoveRes
    )
/*++

Routine Description:

    Simulates the DirRemoveEntry API.

Arguments:

    pRemoveArg          - Standard remove arguments.
    ppRemoveRes         - Standard remove results.

Return Value:

    DIRERR_*.

--*/
{
    PSIM_ENTRY                      pEntry;
    REMOVERES *                     pRemoveRes;

    Assert (pRemoveArg->pMetaDataVecRemote == NULL);

    g_Statistics.DirRemoveOps++;
    *ppRemoveRes = pRemoveRes = KCCSIM_NEW (REMOVERES);
    pRemoveRes->CommRes.errCode = 0;

    pEntry = KCCSimResolveName (pRemoveArg->pObject, &pRemoveRes->CommRes);

    if (pEntry != NULL) {
        
        if (pRemoveArg->fTreeDelete) {
            pRemoveArg->fTreeDelete = FALSE;    // This is what the real API does
            // We need to log this removal before we free the entry!
            KCCSimLogDirectoryRemove (pRemoveArg->pObject);
            KCCSimRemoveEntry (&pEntry);    // poof
        } else {

            // fTreeDelete not specified, so we must be careful
            if (pEntry->children != NULL) {     // Children exist
                KCCSimSetUpdError (
                    &pRemoveRes->CommRes,
                    UP_PROBLEM_CANT_ON_NON_LEAF,
                    DIRERR_CHILDREN_EXIST
                    );
            } else {                            // No children exist
                // We need to log this removal before we free the entry!
                KCCSimLogDirectoryRemove (pRemoveArg->pObject);
                KCCSimRemoveEntry (&pEntry);
            }

        }

    }

    return pRemoveRes->CommRes.errCode;
}

VOID
KCCSimModifyAtt (
    IN  PSIM_ENTRY                  pEntry,
    IN  USHORT                      usChoice,
    IN  ATTR *                      pAttrInf,
    IN  COMMARG *                   pCommArg,
    IN  COMMRES *                   pCommRes
    )
/*++

Routine Description:

    Helper function for SimDirModifyEntry.  Processes a single attribute.

Arguments:

    pEntry              - The entry whose attribute is being modified
    usChoice            - The type of modification being performed.
    pAttrInf            - Attribute info structure.
    pCommArg            - Standard common arguments.
    pCommRes            - Standard common results.

Return Value:

    None.

--*/
{
    SIM_ATTREF                      attRef;
    ULONG                           ulValAt;

    switch (usChoice) {

        case AT_CHOICE_ADD_ATT:
            // Check if this attribute exists.
            if (KCCSimGetAttribute (pEntry, pAttrInf->attrTyp, NULL)) {
                KCCSimSetAttError (
                    pCommRes,
                    pEntry->pdn,
                    pAttrInf->attrTyp,
                    PR_PROBLEM_ATT_OR_VALUE_EXISTS,
                    NULL,
                    DIRERR_ATT_ALREADY_EXISTS
                    );
            } else {
                KCCSimNewAttribute (pEntry, pAttrInf->attrTyp, &attRef);
                KCCSimAddValBlockToAtt (&attRef, &pAttrInf->AttrVal);
                KCCSimUpdatePropertyMetaData (
                    &attRef,
                    &(KCCSimAnchorDn (KCCSIM_ANCHOR_DSA_DN))->Guid
                    );
            }
            break;
        
        case AT_CHOICE_REMOVE_ATT:
            // Get this attribute
            if (KCCSimGetAttribute (pEntry, pAttrInf->attrTyp, &attRef)) {
                KCCSimRemoveAttribute (&attRef);
            } else {                        // The attribute doesn't exist.
                // Does the caller even care?
                if (!pCommArg->Svccntl.fPermissiveModify) {
                    KCCSimSetAttError (
                        pCommRes,
                        pEntry->pdn,
                        pAttrInf->attrTyp,
                        PR_PROBLEM_NO_ATTRIBUTE_OR_VAL,
                        NULL,
                        DIRERR_ATT_IS_NOT_ON_OBJ
                        );
                }
            }
            break;

        case AT_CHOICE_ADD_VALUES:
            if (KCCSimGetAttribute (pEntry, pAttrInf->attrTyp, &attRef)) {
                KCCSimAddValBlockToAtt (&attRef, &pAttrInf->AttrVal);
                KCCSimUpdatePropertyMetaData (
                    &attRef,
                    &(KCCSimAnchorDn (KCCSIM_ANCHOR_DSA_DN))->Guid
                    );
            } else {
                KCCSimSetAttError (
                    pCommRes,
                    pEntry->pdn,
                    pAttrInf->attrTyp,
                    PR_PROBLEM_NO_ATTRIBUTE_OR_VAL,
                    NULL,
                    DIRERR_ATT_IS_NOT_ON_OBJ
                    );
            }
            break;

        case AT_CHOICE_REMOVE_VALUES:
            if (KCCSimGetAttribute (pEntry, pAttrInf->attrTyp, &attRef)) {
                for (ulValAt = 0; ulValAt < pAttrInf->AttrVal.valCount; ulValAt++) {
                    if (KCCSimRemoveValueFromAttribute (
                            &attRef,
                            pAttrInf->AttrVal.pAVal[ulValAt].valLen,
                            pAttrInf->AttrVal.pAVal[ulValAt].pVal
                            )) {
                        KCCSimUpdatePropertyMetaData (
                            &attRef,
                            &(KCCSimAnchorDn (KCCSIM_ANCHOR_DSA_DN))->Guid
                            );
                    } else if (!pCommArg->Svccntl.fPermissiveModify) {
                        // We failed to remove the value 'cause it wasn't there,
                        // and we're doing a non-permissive modify, so generate
                        // an error.
                        KCCSimSetAttError (
                            pCommRes,
                            pEntry->pdn,
                            pAttrInf->attrTyp,
                            PR_PROBLEM_NO_ATTRIBUTE_OR_VAL,
                            &(pAttrInf->AttrVal.pAVal[ulValAt]),
                            DIRERR_CANT_REM_MISSING_ATT_VAL
                            );
                        break;
                    }
                }
            } else {                    // Attribute doesn't exist
                KCCSimSetAttError (
                    pCommRes,
                    pEntry->pdn,
                    pAttrInf->attrTyp,
                    PR_PROBLEM_NO_ATTRIBUTE_OR_VAL,
                    NULL,
                    DIRERR_ATT_IS_NOT_ON_OBJ
                    );
            }
            break;

        case AT_CHOICE_REPLACE_ATT:
            // Remove the attribute if it exists.
            if (KCCSimGetAttribute (pEntry, pAttrInf->attrTyp, &attRef)) {
                KCCSimRemoveAttribute (&attRef);
            }
            KCCSimNewAttribute (pEntry, pAttrInf->attrTyp, &attRef);
            KCCSimAddValBlockToAtt (&attRef, &pAttrInf->AttrVal);
            KCCSimUpdatePropertyMetaData (
                &attRef,
                &(KCCSimAnchorDn (KCCSIM_ANCHOR_DSA_DN))->Guid
                );
            break;

        default:
            KCCSimException (
                KCCSIM_ETYPE_INTERNAL,
                KCCSIM_ERROR_UNSUPPORTED_MODIFY_CHOICE
                );
            break;

    }

}

ULONG
SimDirModifyEntry (
    IN  MODIFYARG *                 pModifyArg,
    OUT MODIFYRES **                ppModifyRes
    )
/*++

Routine Description:

    Simulates the DirModifyEntry API.

Arguments:

    pModifyArg          - Standard modify arguments.
    ppModifyRes         - Standard modify results.

Return Value:

    DIRERR_*.

--*/
{
    MODIFYRES *                     pModifyRes;
    ATTRMODLIST *                   pModAt;
    PSIM_ENTRY                      pEntry;

    Assert (pModifyArg->pMetaDataVecRemote == NULL);

    g_Statistics.DirModifyOps++;
    *ppModifyRes = pModifyRes = KCCSIM_NEW (MODIFYRES);
    pModifyRes->CommRes.errCode = 0;

    pEntry = KCCSimResolveName (pModifyArg->pObject, &pModifyRes->CommRes);

    if (pEntry != NULL) {

        pModAt = &pModifyArg->FirstMod;
        while (pModAt != NULL) {

            KCCSimModifyAtt (
                pEntry,
                pModAt->choice,
                &pModAt->AttrInf,
                &pModifyArg->CommArg,
                &pModifyRes->CommRes
                );
            pModAt = pModAt->pNextMod;

        }

        KCCSimLogDirectoryModify (
            pModifyArg->pObject,
            pModifyArg->count,
            &pModifyArg->FirstMod
            );

    }
    
    return pModifyRes->CommRes.errCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\sim\simmdrep.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    simmdrep.c

ABSTRACT:

    Simulates the Replica functions from the mdlayer
    (DirReplica*).

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <attids.h>
#include <mdglobal.h>
#include <drserr.h>
#include <dsaapi.h>
#include <debug.h>
#include "kccsim.h"
#include "util.h"
#include "dir.h"
#include "state.h"
#include <fileno.h>
#define FILENO  FILENO_KCCSIM_SIMMDREP

BOOL MtxSame (UNALIGNED MTX_ADDR *pmtx1, UNALIGNED MTX_ADDR *pmtx2);

MTX_ADDR *
SimMtxAddrFromTransportAddr (
    IN  LPWSTR                      psz
    )
/*++

Routine Description:

    Simulates the MtxAddrFromTransportAddr API.
    
    Note that this is essentially identical to the corresponding function in
    drautil.c.

Arguments:

    psz                 - The string to convert.

Return Values:

    A pointer to the equivalent MTX_ADDR.

--*/
{
    DWORD       cch;
    MTX_ADDR *  pmtx;
    
    Assert(NULL != psz);
    
    cch = WideCharToMultiByte(CP_UTF8, 0L, psz, -1, NULL, 0, NULL, NULL);
    if (0 == cch) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            GetLastError()
            );
    }

    // Note that cch includes the null terminator, whereas MTX_TSIZE_FROM_LEN
    // expects a count that does *not* include the null terminator.
    
    pmtx = (MTX_ADDR *) KCCSimAlloc (MTX_TSIZE_FROM_LEN (cch-1));
    pmtx->mtx_namelen = cch;
    
    cch = WideCharToMultiByte(CP_UTF8, 0L, psz, -1, pmtx->mtx_name, cch, NULL,
                              NULL);
    if (0 == cch) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            GetLastError()
            );
    }
    
    Assert(cch == pmtx->mtx_namelen);
    Assert(L'\0' == pmtx->mtx_name[cch - 1]);
    
    return pmtx;
}

LPWSTR
SimTransportAddrFromMtxAddr (
    IN  MTX_ADDR *                  pMtxAddr
    )
/*++

Routine Description:

    Simulates the TransportAddrFromMtxAddr API.

Arguments:

    pMtxAddr            - The MTX_ADDR to convert.

Return Value:

    The equivalent transport address.

--*/
{
    return KCCSimAllocWideStr (CP_UTF8, pMtxAddr->mtx_name);
}

ULONG
SimDirReplicaAdd (
    IN  PDSNAME                     pdnNC,
    IN  PDSNAME                     pdnSourceDsa,
    IN  PDSNAME                     pdnTransport,
    IN  LPWSTR                      pwszSourceDsaAddress,
    IN  LPWSTR                      pwszSourceDsaDnsDomainName,
    IN  REPLTIMES *                 preptimesSync,
    IN  ULONG                       ulOptions
    )
/*++

Routine Description:

    Simulates the DirReplicaAdd API.

Arguments:

    pdnNC               - The NC to which we are adding this repsfrom.
    pdnSourceDsa        - The DN of the source server's NTDS Settings object.
    pdnTransport        - The transport DN.
    pwszSourceDsaAddress- The source DSA address.
    pwszSourceDsaDnsDomainName
                        - The DNS Domain Name of the source DSA.
    preptimesSync       - The replication schedule.
    ulOptions           - Option flags.

Return Value:

    DRAERR_*.

--*/
{
    REPLICA_LINK *                  pReplicaLinkOld = NULL;
    REPLICA_LINK *                  pReplicaLinkNew = NULL;
    ULONG                           cbReplicaLinkNew;

    USHORT                          usChangeType;
    MTX_ADDR *                      pMtxAddr = NULL;
    DSTIME                          timeNow;

    __try {

        if (NULL == pdnNC ||
            NULL == pwszSourceDsaAddress) {
            return DRAERR_InvalidParameter;
        }
        Assert (pdnSourceDsa != NULL);

        // Check that this NC exists.
        if (KCCSimDsnameToEntry (pdnNC, KCCSIM_NO_OPTIONS) == NULL) {
            return DRAERR_BadNC;
        }

        // If this replica link already exists, get rid of the old one.
        pReplicaLinkOld = KCCSimExtractReplicaLink (
            KCCSimAnchorDn (KCCSIM_ANCHOR_DSA_DN),
            pdnNC,
            &pdnSourceDsa->Guid,
            NULL
            );

        timeNow = SimGetSecondsSince1601 ();
        pMtxAddr = SimMtxAddrFromTransportAddr (pwszSourceDsaAddress);

        // Allocate and set up a new replica link.
        cbReplicaLinkNew = sizeof (REPLICA_LINK) + MTX_TSIZE (pMtxAddr);
        pReplicaLinkNew = KCCSimAlloc (cbReplicaLinkNew);
        pReplicaLinkNew->dwVersion = VERSION_V1;
        pReplicaLinkNew->V1.cb = cbReplicaLinkNew;
        pReplicaLinkNew->V1.cConsecutiveFailures = 0;
        pReplicaLinkNew->V1.timeLastSuccess = timeNow;
        pReplicaLinkNew->V1.timeLastAttempt = timeNow;
        pReplicaLinkNew->V1.ulResultLastAttempt = ERROR_SUCCESS;
        pReplicaLinkNew->V1.cbOtherDraOffset =
          (DWORD) (pReplicaLinkNew->V1.rgb - (PBYTE) pReplicaLinkNew);
        pReplicaLinkNew->V1.cbOtherDra = MTX_TSIZE (pMtxAddr);
        pReplicaLinkNew->V1.ulReplicaFlags = ulOptions & RFR_FLAGS;
        if (preptimesSync == NULL) {
            RtlZeroMemory (&pReplicaLinkNew->V1.rtSchedule, sizeof (REPLTIMES));
        } else {
            memcpy (
                &pReplicaLinkNew->V1.rtSchedule,
                preptimesSync,
                sizeof (REPLTIMES)
                );
        }
        
        RtlZeroMemory (&pReplicaLinkNew->V1.usnvec, sizeof (USN_VECTOR));
        memcpy (
            &pReplicaLinkNew->V1.uuidDsaObj,
            &pdnSourceDsa->Guid,
            sizeof (UUID)
            );
        
        // Invocation ID is just the same as source DSA UUID.
        // We could get the real invocation ID of the server from the in-memory
        // directory, but this is not needed for the simulation.
        memcpy (
            &pReplicaLinkNew->V1.uuidInvocId,
            &pdnSourceDsa->Guid,
            sizeof (UUID)
            );
        if (pdnTransport == NULL) {
            RtlZeroMemory (&pReplicaLinkNew->V1.uuidTransportObj, sizeof (UUID));
        } else {
            memcpy (
                &pReplicaLinkNew->V1.uuidTransportObj,
                &pdnTransport->Guid,
                sizeof (UUID)
                );
        }
        memcpy (
            RL_POTHERDRA (pReplicaLinkNew),
            pMtxAddr,
            MTX_TSIZE (pMtxAddr)
            );

        // Insert the new replica link into the server state table.
        KCCSimInsertReplicaLink (
            KCCSimAnchorDn (KCCSIM_ANCHOR_DSA_DN),
            pdnNC,
            pReplicaLinkNew
            );

    } __finally {

        KCCSimFree (pMtxAddr);
        KCCSimFree (pReplicaLinkOld);

    }

    return DRAERR_Success;
}

ULONG
SimDirReplicaDelete (
    IN  PDSNAME                     pdnNC,
    IN  LPWSTR                      pwszSourceDRA,
    IN  ULONG                       ulOptions
    )
/*++

Routine Description:

    Simulates the DirReplicaDelete API.
    
    Currently will not delete the entire NC tree if the last
    link for a partial replica is severed.  This is not needed for purposes
    of the simulation.

Arguments:

    pdnNC               - The NC from which we are deleting this repsfrom.
    pwszSourceDRA       - The source DRA whose repsfrom we want to delete.
    ulOptions           - Option flags.

Return Values:

    DRAERR_*.

--*/
{
    MTX_ADDR *                      pMtxAddr = NULL;
    REPLICA_LINK *                  pReplicaLink = NULL;

    __try {

        if (NULL == pdnNC) {
            return DRAERR_InvalidParameter;
        }

        // Check that this is a valid NC.
        if (KCCSimDsnameToEntry (pdnNC, KCCSIM_NO_OPTIONS) == NULL) {
            return DRAERR_BadNC;
        }

        pMtxAddr = SimMtxAddrFromTransportAddr (pwszSourceDRA);

        // Extract this repsfrom from the server state table.
        pReplicaLink = KCCSimExtractReplicaLink (
            KCCSimAnchorDn (KCCSIM_ANCHOR_DSA_DN),
            pdnNC,
            NULL,
            pMtxAddr
            );

        if (pReplicaLink == NULL) {
            return DRAERR_NoReplica;
        }

        return DRAERR_Success;

    } __finally {

        KCCSimFree (pMtxAddr);
        KCCSimFree (pReplicaLink);

    }

    return DRAERR_Success;
}

ULONG
SimDirReplicaGetDemoteTarget(
    IN      DSNAME *                                pNC,
    IN OUT  struct _DRS_DEMOTE_TARGET_SEARCH_INFO * pDSTInfo,
    OUT     LPWSTR *                                ppszDemoteTargetDNSName,
    OUT     DSNAME **                               ppDemoteTargetDSADN
    )
/*++

Routine Description:

    Simulates the DirReplicaGetDemoteTarget API.

Arguments:

    As for DirReplicaGetDemoteTarget.

Return Values:

    0 on success, Win32 error on failure.
    
--*/
{
    return ERROR_NO_SUCH_DOMAIN;
}


ULONG
SimDirReplicaDemote(
    IN  DSNAME *    pNC,
    IN  LPWSTR      pszOtherDSADNSName,
    IN  DSNAME *    pOtherDSADN,
    IN  ULONG       ulOptions
    )
/*++

Routine Description:

    Simulates the DirReplicaDemote API.

Arguments:

    pNC (IN) - Name of the writeable NC to remove.

    pOtherDSADN (IN) - NTDS Settings (ntdsDsa) DN of the DSA to give FSMO
        roles/replicate to.

    ulOptions (IN) - Ignored - none yet defined.

Return Values:

    0 on success, Win32 error on failure.
    
--*/
{
    // Don't bother simulating FSMO role transfer -- just tear down the NC.
    return SimDirReplicaDelete(pNC,
                               NULL,
                               DRS_REF_OK | DRS_NO_SOURCE | DRS_ASYNC_REP);
}

ULONG
SimDirReplicaModify (
    IN  PDSNAME                     pNC,
    IN  UUID *                      puuidSourceDRA,
    IN  UUID *                      puuidTransportObj,
    IN  LPWSTR                      pszSourceDRA,
    IN  REPLTIMES *                 prtSchedule,
    IN  ULONG                       ulReplicaFlags,
    IN  ULONG                       ulModifyFields,
    IN  ULONG                       ulOptions
    )
/*++

Routine Description:

    Simulates the DirReplicaModify API.

Arguments:

    pNC                 - The NC whose repsfrom we are modifying.
    puuidSourceDRA      - The UUID of the source DRA.
    puuidTransportObj   - The UUID of the transport object.
    pszSourceDRA        - The string name of the source DRA DN.
    prtSchedule         - The replication schedule.
    ulReplicaFlags      - Replication flags.
    ulModifyFields      - The fields that we wish to modify.
    ulOptions           - Option flags.

Return Values:

    DRAERR_*.

--*/
{
    MTX_ADDR *                      pMtxAddr = NULL;
    REPLICA_LINK *                  pReplicaLinkOld = NULL;
    REPLICA_LINK *                  pReplicaLinkNew = NULL;
    ULONG                           cbReplicaLinkNew;

    __try {

        // This blob is lifted out of the real DirReplicaModify.
        if (    ( NULL == pNC )
             || ( ( NULL == puuidSourceDRA ) && ( NULL == pszSourceDRA ) )
             || ( ( NULL == pszSourceDRA   ) && ( DRS_UPDATE_ADDRESS  & ulModifyFields ) )
             || ( ( NULL == prtSchedule    ) && ( DRS_UPDATE_SCHEDULE & ulModifyFields ) )
             || ( 0 == ulModifyFields )
             || (    ulModifyFields
                  != (   ulModifyFields
                       & ( DRS_UPDATE_ADDRESS | DRS_UPDATE_SCHEDULE | DRS_UPDATE_FLAGS
                           | DRS_UPDATE_TRANSPORT
                         )
                     )
                )
           )
        {
            return DRAERR_InvalidParameter;
        }

        // Check that this is a valid NC.
        if (KCCSimDsnameToEntry (pNC, KCCSIM_NO_OPTIONS) == NULL) {
            return DRAERR_BadNC;
        }

        if (pszSourceDRA != NULL) {
            pMtxAddr = SimMtxAddrFromTransportAddr (pszSourceDRA);
        }

        // Extract the replica link from the server state table.  We'll
        // re-insert it after the modifications are done.
        pReplicaLinkOld = KCCSimExtractReplicaLink (
            KCCSimAnchorDn (KCCSIM_ANCHOR_DSA_DN),
            pNC,
            puuidSourceDRA,
            pMtxAddr
            );

        if (pReplicaLinkOld == NULL) {
            return DRAERR_NoReplica;
        }
        
        // Set up the new replica link.  How we do this depends on
        // whether or not we are updating the address.

        if (ulModifyFields & DRS_UPDATE_ADDRESS) {

            // Updating the address, so we reallocate.
            cbReplicaLinkNew = sizeof (REPLICA_LINK) + MTX_TSIZE (pMtxAddr);
            pReplicaLinkNew = (REPLICA_LINK *) KCCSimAlloc (cbReplicaLinkNew);
            memcpy (
                pReplicaLinkNew,
                pReplicaLinkOld,
                min (cbReplicaLinkNew, pReplicaLinkOld->V1.cb)
                );
            pReplicaLinkNew->V1.cb = cbReplicaLinkNew;
            pReplicaLinkNew->V1.cbOtherDra = MTX_TSIZE (pMtxAddr);
            memcpy (RL_POTHERDRA (pReplicaLinkNew), pMtxAddr, MTX_TSIZE (pMtxAddr));
            // We leave pReplicaLinkOld non-NULL, so it will be freed in the
            // __finally block.

        } else {
            // No need to reallocate.
            pReplicaLinkNew = pReplicaLinkOld;
            pReplicaLinkOld = NULL;     // Make sure we don't free this later
        }

        // By now, the new replica link should be set up.
        Assert (pReplicaLinkNew != NULL);

        if (ulModifyFields & DRS_UPDATE_FLAGS) {
            pReplicaLinkNew->V1.ulReplicaFlags = ulReplicaFlags;
        }

        if (ulModifyFields & DRS_UPDATE_SCHEDULE) {
            memcpy (&pReplicaLinkNew->V1.rtSchedule, prtSchedule, sizeof (REPLTIMES));
        }

        if (ulModifyFields & DRS_UPDATE_TRANSPORT) {
            Assert (puuidTransportObj != NULL);
            memcpy (&pReplicaLinkNew->V1.uuidTransportObj, puuidTransportObj, sizeof (UUID));
        }

        // Finally, re-insert the modified replica link into the state table.
        KCCSimInsertReplicaLink (
            KCCSimAnchorDn (KCCSIM_ANCHOR_DSA_DN),
            pNC,
            pReplicaLinkNew
            );

    } __finally {

        KCCSimFree (pReplicaLinkOld);
        KCCSimFree (pMtxAddr);

    }

    return DRAERR_Success;
}


ULONG
SimDirReplicaReferenceUpdate(
    DSNAME *    pNC,
    LPWSTR      pszRepsToDRA,
    UUID *      puuidRepsToDRA,
    ULONG       ulOptions
    )
{
    // ISSUE-nickhar-09/25/2000: We should simulate this function properly.
    return DRAERR_Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\sim\state.h ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    state.h

ABSTRACT:

    Header file for state.c.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

VOID
KCCSimFreeStates (
    VOID
    );

ULONG
KCCSimGetBindError (
    IN  const DSNAME *              pdnServer
    );

BOOL
KCCSimSetBindError (
    IN  const DSNAME *              pdnServer,
    IN  ULONG                       ulBindError
    );

#ifdef _mdglobal_h_

REPLICA_LINK *
KCCSimExtractReplicaLink (
    IN  const DSNAME *              pdnServer,
    IN  const DSNAME *              pdnNC,
    IN  const UUID *                puuidDsaObj,
    IN  MTX_ADDR *                  pMtxAddr
    );

VOID
KCCSimInsertReplicaLink (
    IN  const DSNAME *              pdnServer,
    IN  const DSNAME *              pdnNC,
    IN  REPLICA_LINK *              pReplicaLink
    );

#endif

PSIM_VALUE
KCCSimGetRepsFroms (
    IN  const DSNAME *              pdnServer,
    IN  const DSNAME *              pdnNC
    );

BOOL
KCCSimReportSync (
    IN  const DSNAME *              pdnServerTo,
    IN  const DSNAME *              pdnNC,
    IN  const DSNAME *              pdnServerFrom,
    IN  ULONG                       ulSyncError,
    IN  ULONG                       ulNumAttempts
    );

DS_REPL_KCC_DSA_FAILURESW *
KCCSimGetDsaFailures (
    IN  const DSNAME *              pdnServer
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\sim\state.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    state.c

ABSTRACT:

    Manages the server state table.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <mdglobal.h>
#include <attids.h>
#include <dsutil.h>
#include <debug.h>
#include "kccsim.h"
#include "util.h"
#include "dir.h"
#include "state.h"
#include <fileno.h>
#define FILENO  FILENO_KCCSIM_STATE	

BOOL fNullUuid (const GUID *);
BOOL MtxSame (UNALIGNED MTX_ADDR *pmtx1, UNALIGNED MTX_ADDR *pmtx2);

/***

    The KCC often wants to know information about the state of another server
    (usually the site bridgehead.)  It obtains information about other servers
    in two ways: through errors returned by DsBindW, and through data returned
    by DsGetReplicaInfoW.

    In addition, the KCC relies on the repsFrom attributes stored on the local
    DSA.  This is a non-replicated attribute that is (potentially) different
    for every server in the enterprise.  Since KCCSim maintains only a single
    instance of the directory, this raises the potential for conflict if the
    user wishes to run multiple iterations of the KCC from different servers.

    Both problems are resolved by maintaining a global server state table.
    The server state table contains one entry for each server in the
    enterprise.  Each table entry contains a set of repsFrom attributes (one
    for each NC held by the given server) and supplementary information.
    Therefore, calls to DsBindW and DsGetReplicaInfoW simply retrieve data
    out of the server state table; and the potential conflict is resolved
    because each iteration of the KCC only modifies the repsFrom attributes
    corresponding to the current local DSA.

***/

// This structure represents a single repsFrom attribute.
struct _KCCSIM_REPS_FROM_ATT {
    PDSNAME                         pdnNC;
    PSIM_VALUE                      pValFirst;
};

//
// This structure represents a server state.
// pEntryNTDSSettings   - The NTDS Settings object of this server.
// ulBindError          - The error code to return if DsBindW is called
//                        on this server.
// ulNumNCs             - Number of NCs held by this server.
// aRepsFrom            - Array of repsFrom attributes of size ulNumNCs.
//
struct _KCCSIM_SERVER_STATE {
    PSIM_ENTRY                      pEntryNTDSSettings;
    ULONG                           ulBindError;
    ULONG                           ulNumNCs;
    struct _KCCSIM_REPS_FROM_ATT *  aRepsFrom;
};

ULONG                               g_ulNumServers;
struct _KCCSIM_SERVER_STATE *       g_aState = NULL;

VOID
KCCSimFreeStates (
    VOID
    )
/*++

Routine Description:

    Frees the entire state table.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PSIM_VALUE                      pValAt, pValNext;
    ULONG                           ulServer, ulNC;

    if (g_aState == NULL) {
        return;
    }

    for (ulServer = 0; ulServer < g_ulNumServers; ulServer++) {
        for (ulNC = 0; ulNC < g_aState[ulServer].ulNumNCs; ulNC++) {
            KCCSimFree (g_aState[ulServer].aRepsFrom[ulNC].pdnNC);
            pValAt = g_aState[ulServer].aRepsFrom[ulNC].pValFirst;
            while (pValAt != NULL) {
                pValNext = pValAt->next;
                KCCSimFree (pValAt->pVal);
                KCCSimFree (pValAt);
                pValAt = pValNext;
            }
        }
        KCCSimFree (g_aState[ulServer].aRepsFrom);
    }
    KCCSimFree (g_aState);
    g_aState = NULL;
}

VOID
KCCSimInitializeStates (
    VOID
    )
/*++

Routine Description:

    Initializes the state table.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ATTRTYP                         ncClass[2] = {
                                        ATT_HAS_MASTER_NCS,
                                        ATT_HAS_PARTIAL_REPLICA_NCS };

    SIM_ATTREF                      attRef;
    PSIM_VALUE                      pValAt;

    ULONG                           ulServer, ulNCType, ulNC;
    PSIM_ENTRY *                    apEntryNTDSSettings;
    struct _KCCSIM_SERVER_STATE     state;

    KCCSimAllocGetAllServers (&g_ulNumServers, &apEntryNTDSSettings);
    g_aState = KCCSIM_NEW_ARRAY (struct _KCCSIM_SERVER_STATE, g_ulNumServers);

    for (ulServer = 0; ulServer < g_ulNumServers; ulServer++) {

        g_aState[ulServer].pEntryNTDSSettings = apEntryNTDSSettings[ulServer];
        g_aState[ulServer].ulBindError = 0;

        // How many NCs are there?
        g_aState[ulServer].ulNumNCs = 0;
        for (ulNCType = 0; ulNCType < 2; ulNCType++) {
            if (KCCSimGetAttribute (
                    apEntryNTDSSettings[ulServer],
                    ncClass[ulNCType],
                    &attRef
                    )) {
                for (pValAt = attRef.pAttr->pValFirst;
                     pValAt != NULL;
                     pValAt = pValAt->next) {
                    g_aState[ulServer].ulNumNCs++;
                }
            }
        }

        g_aState[ulServer].aRepsFrom = KCCSIM_NEW_ARRAY
            (struct _KCCSIM_REPS_FROM_ATT, g_aState[ulServer].ulNumNCs);

        ulNC = 0;
        for (ulNCType = 0; ulNCType < 2; ulNCType++) {
            if (KCCSimGetAttribute (
                    apEntryNTDSSettings[ulServer],
                    ncClass[ulNCType],
                    &attRef
                    )) {
                for (pValAt = attRef.pAttr->pValFirst;
                     pValAt != NULL;
                     pValAt = pValAt->next) {

                    Assert (ulNC < g_aState[ulServer].ulNumNCs);
                    g_aState[ulServer].aRepsFrom[ulNC].pdnNC =
                        KCCSimAlloc (pValAt->ulLen);
                    memcpy (
                        g_aState[ulServer].aRepsFrom[ulNC].pdnNC,
                        pValAt->pVal,
                        pValAt->ulLen
                        );
                    g_aState[ulServer].aRepsFrom[ulNC].pValFirst = NULL;
                    ulNC++;

                }
            }
        }
        Assert (ulNC == g_aState[ulServer].ulNumNCs);

    }

    KCCSimFree (apEntryNTDSSettings);
}

struct _KCCSIM_SERVER_STATE *
KCCSimServerStateOf (
    IN  const DSNAME *              pdnServer
    )
/*++

Routine Description:

    Retrieves the server state entry corresponding to a particular server.

Arguments:

    pdnServer           - The server whose state we want to retrieve.

Return Value:

    The corresponding state table entry.

--*/
{
    struct _KCCSIM_SERVER_STATE *   pState;
    ULONG                           ul;

    if (g_aState == NULL) {
        KCCSimInitializeStates ();
    }

    pState = NULL;
    for (ul = 0; ul < g_ulNumServers; ul++) {
        if (NameMatched (pdnServer, g_aState[ul].pEntryNTDSSettings->pdn)) {
            pState = &g_aState[ul];
            break;
        }
    }

    return pState;
}

struct _KCCSIM_REPS_FROM_ATT *
KCCSimRepsFromAttOf (
    IN  const DSNAME *              pdnServer,
    IN  const DSNAME *              pdnNC
    )
/*++

Routine Description:

    Retrieves the repsfrom attribute corresponding to a particular
    server in a particular NC.

Arguments:

    pdnServer           - The server whose repsfrom attribute we want.
    pdnNC               - The naming context.

Return Value:

    The corresponding repsfrom attribute.

--*/
{
    struct _KCCSIM_SERVER_STATE *   pState;
    struct _KCCSIM_REPS_FROM_ATT *  pRepsFromAtt;
    ULONG                           ul;

    pState = KCCSimServerStateOf (pdnServer);
    if (pState == NULL) {
        return NULL;
    }

    pRepsFromAtt = NULL;
    for (ul = 0; ul < pState->ulNumNCs; ul++) {
        if (NameMatched (pdnNC, pState->aRepsFrom[ul].pdnNC)) {
            pRepsFromAtt = &pState->aRepsFrom[ul];
            break;
        }
    }

    return pRepsFromAtt;
}

ULONG
KCCSimGetBindError (
    IN  const DSNAME *              pdnServer
    )
/*++

Routine Description:

    Publicized function to get the bind error associated with a server.

Arguments:

    pdnServer           - The DN of the server.

Return Value:

    The associated bind error.

--*/
{
    struct _KCCSIM_SERVER_STATE *   pState;

    pState = KCCSimServerStateOf (pdnServer);

    if (pState == NULL) {
        return NO_ERROR;
    } else {
        return pState->ulBindError;
    }
}   

BOOL
KCCSimSetBindError (
    IN  const DSNAME *              pdnServer,
    IN  ULONG                       ulBindError
    )
/*++

Routine Description:

    Publicized function to set the bind error associated with a server.

Arguments:

    pdnServer           - The DN of the server.
    ulBindError         - The bind error.

Return Value:

    TRUE if the error code could be set.
    FALSE if the specified server does not exist.

--*/
{
    struct _KCCSIM_SERVER_STATE *   pState;

    pState = KCCSimServerStateOf (pdnServer);
    
    if (pState == NULL) {
        return FALSE;
    } else {
        pState->ulBindError = ulBindError;
        return TRUE;
    }
}

BOOL
KCCSimMatchReplicaLink (
    IN  const REPLICA_LINK *        pReplicaLink,
    IN  const UUID *                puuidDsaObj OPTIONAL,
    IN  MTX_ADDR *                  pMtxAddr OPTIONAL
    )
/*++

Routine Description:

    Determines whether a REPLICA_LINK corresponds to a given
    source DSA.  Matches by UUID if puuidDsaObj is present;
    otherwise searches by MTX_ADDR.  One of puuidDsaObj or
    pMtxAddr must be non-NULL.

Arguments:

    pReplicaLink        - The replica link to match.
    puuidDsaObj         - Source DSA UUID to match by.
    pMtxAddr            - Source DSA address to match by.

Return Value:

    TRUE if the REPLICA_LINK matches.

--*/
{
    Assert (pReplicaLink != NULL);
    Assert ((puuidDsaObj != NULL) || (pMtxAddr != NULL));
    VALIDATE_REPLICA_LINK_VERSION (pReplicaLink);

    if (puuidDsaObj == NULL) {
        // Search by MTX_ADDR
        if (MtxSame (pMtxAddr, RL_POTHERDRA (pReplicaLink))) {
            return TRUE;
        }
    } else {
        // Search by UUID
        if (memcmp (puuidDsaObj, &pReplicaLink->V1.uuidDsaObj, sizeof (UUID)) == 0) {
            return TRUE;
        }
    }

    return FALSE;
}

REPLICA_LINK *
KCCSimExtractReplicaLink (
    IN  const DSNAME *              pdnServer,
    IN  const DSNAME *              pdnNC,
    IN  const UUID *                puuidDsaObj OPTIONAL,
    IN  MTX_ADDR *                  pMtxAddr OPTIONAL
    )
/*++

Routine Description:

    Removes a REPLICA_LINK from the state table.  The REPLICA_LINK
    may be referenced either by source DSA UUID or matrix address;
    one of them must be non-NULL.

Arguments:

    pdnServer           - The server whose repsfrom attribute we are accessing.
    pdnNC               - The naming context.
    puuidDsaObj         - UUID of the source DSA.
    pMtxAddr            - MTX_ADDR of the source DSA.

Return Value:

    The REPLICA_LINK that was removed.  It is the caller's responsibility
    to free this structure by calling KCCSimFree.

--*/
{
    struct _KCCSIM_REPS_FROM_ATT *  pRepsFromAtt;
    PSIM_VALUE                      pValAt, pValTemp;
    REPLICA_LINK *                  pReplicaLink;

    Assert (pdnServer != NULL);
    Assert (pdnNC != NULL);
    Assert ((puuidDsaObj != NULL) || (pMtxAddr != NULL));

    pRepsFromAtt = KCCSimRepsFromAttOf (pdnServer, pdnNC);
    Assert (pRepsFromAtt != NULL);
    if (pRepsFromAtt->pValFirst == NULL) {
        return NULL;
    }

    pReplicaLink = NULL;        // Default to NULL return value

    // Does the list head match?
    if (KCCSimMatchReplicaLink (
            (REPLICA_LINK *) pRepsFromAtt->pValFirst->pVal,
            puuidDsaObj,
            pMtxAddr
            )) {
        pReplicaLink = (REPLICA_LINK *) pRepsFromAtt->pValFirst->pVal;
        pValTemp = pRepsFromAtt->pValFirst;
        pRepsFromAtt->pValFirst = pRepsFromAtt->pValFirst->next;
        KCCSimFree (pValTemp);
    } else {
        // Search for the parent of the matching entry
        for (pValAt = pRepsFromAtt->pValFirst;
             pValAt != NULL && pValAt->next != NULL;
             pValAt = pValAt->next) {

            if (KCCSimMatchReplicaLink (
                    (REPLICA_LINK *) pValAt->next->pVal,
                    puuidDsaObj,
                    pMtxAddr
                    )) {
                pReplicaLink = (REPLICA_LINK *) pValAt->next->pVal;
                pValTemp = pValAt->next;
                pValAt->next = pValAt->next->next;
                KCCSimFree (pValTemp);
                break;
            }

        }
    }

    return pReplicaLink;
}

VOID
KCCSimInsertReplicaLink (
    IN  const DSNAME *              pdnServer,
    IN  const DSNAME *              pdnNC,
    IN  REPLICA_LINK *              pReplicaLink
    )
/*++

Routine Description:

    Inserts a REPLICA_LINK into the state table.  No allocation is
    performed; the caller should NOT free pReplicaLink afterward!

Arguments:

    pdnServer           - The server whose repsfrom attribute we are accessing.
    pdnNC               - The naming context.
    pReplicaLink        - The replica link to insert.

Return Value:

    None.

--*/
{
    struct _KCCSIM_REPS_FROM_ATT *  pRepsFromAtt;
    REPLICA_LINK *                  pReplicaLinkOld;
    PSIM_VALUE                      pNewVal;

    Assert (pReplicaLink != NULL);
    VALIDATE_REPLICA_LINK_VERSION (pReplicaLink);

    pRepsFromAtt = KCCSimRepsFromAttOf (pdnServer, pdnNC);
    Assert (pRepsFromAtt != NULL);

#if DBG
    // Check to make sure we don't already have this REPLICA_LINK!
    pReplicaLinkOld = KCCSimExtractReplicaLink (
        pdnServer,
        pdnNC,
        &pReplicaLink->V1.uuidDsaObj,
        NULL
        );
    Assert (pReplicaLinkOld == NULL);
    pReplicaLinkOld = KCCSimExtractReplicaLink (
        pdnServer,
        pdnNC,
        NULL,
        RL_POTHERDRA (pReplicaLink)
        );
    Assert (pReplicaLinkOld == NULL);
#endif

    pNewVal = KCCSIM_NEW (SIM_VALUE);
    pNewVal->ulLen = pReplicaLink->V1.cb;
    pNewVal->pVal = (PBYTE) pReplicaLink;
    pNewVal->next = pRepsFromAtt->pValFirst;
    pRepsFromAtt->pValFirst = pNewVal;
}

PSIM_VALUE
KCCSimGetRepsFroms (
    IN  const DSNAME *              pdnServer,
    IN  const DSNAME *              pdnNC
    )
{
    struct _KCCSIM_REPS_FROM_ATT *  pRepsFromAtt;

    pRepsFromAtt = KCCSimRepsFromAttOf (pdnServer, pdnNC);
    if (pRepsFromAtt == NULL) {
        return NULL;
    } else {
        return pRepsFromAtt->pValFirst;
    }
}

BOOL
KCCSimReportSync (
    IN  const DSNAME *              pdnServerTo,
    IN  const DSNAME *              pdnNC,
    IN  const DSNAME *              pdnServerFrom,
    IN  ULONG                       ulSyncError,
    IN  ULONG                       ulNumAttempts
    )
{
    PSIM_ENTRY                      pEntryServerFrom;
    REPLICA_LINK *                  pReplicaLink = NULL;
    DSTIME                          timeNow;

    Assert (pdnServerTo != NULL);
    Assert (pdnNC != NULL);
    Assert (pdnServerFrom != NULL);

    __try {

        if (KCCSimRepsFromAttOf (pdnServerTo, pdnNC) == NULL) {
            return FALSE;
        }

        // Find the from server in the directory so we're sure to have its guid
        pEntryServerFrom = KCCSimDsnameToEntry (pdnServerFrom, KCCSIM_NO_OPTIONS);
        if (pEntryServerFrom == NULL) {
            Assert (pEntryServerFrom != NULL);
            return FALSE;
        }
        pReplicaLink = KCCSimExtractReplicaLink (
            pdnServerTo,
            pdnNC,
            &pEntryServerFrom->pdn->Guid,
            NULL
            );

        if (pReplicaLink == NULL) {
            return FALSE;
        }

        if (ulNumAttempts == 0) {
            return TRUE;
        }

        timeNow = SimGetSecondsSince1601 ();

        pReplicaLink->V1.ulResultLastAttempt = ulSyncError;
        pReplicaLink->V1.timeLastAttempt = timeNow;
        if (ulSyncError == 0) {
            pReplicaLink->V1.timeLastSuccess = timeNow;
            pReplicaLink->V1.cConsecutiveFailures = 0;
        } else {
            pReplicaLink->V1.cConsecutiveFailures += ulNumAttempts;
        }

    } __finally {

        if (pReplicaLink != NULL) {
            KCCSimInsertReplicaLink (
                pdnServerTo,
                pdnNC,
                pReplicaLink
                );
        }

    }

    return TRUE;
}

RTL_GENERIC_COMPARE_RESULTS
NTAPI
KCCSimCompareFailures (
    IN  PRTL_GENERIC_TABLE          pTable,
    IN  PVOID                       pFirstStruct,
    IN  PVOID                       pSecondStruct
    )
/*++

Routine Description:

    Compares two DS_REPL_KCC_DSA_FAILUREW structures by source DSA UUID.

Arguments:

    pTable              - Not used.
    pFirstStruct        - The first structure to compare.
    pSecondStruct       - The second structure to compare.

Return Value:

    One of GenericLessThan, GenericEqual, or GenericGreaterThan.

--*/
{
    DS_REPL_KCC_DSA_FAILUREW *      pFirstFailure;
    DS_REPL_KCC_DSA_FAILUREW *      pSecondFailure;
    INT                             iCmp;
    RTL_GENERIC_COMPARE_RESULTS     result;

    pFirstFailure = (DS_REPL_KCC_DSA_FAILUREW *) pFirstStruct;
    pSecondFailure = (DS_REPL_KCC_DSA_FAILUREW *) pSecondStruct;

    iCmp = memcmp (
        &pFirstFailure->uuidDsaObjGuid,
        &pSecondFailure->uuidDsaObjGuid,
        sizeof (GUID)
        );

    if (iCmp < 0) {
        result = GenericLessThan;
    } else if (iCmp > 0) {
        result = GenericGreaterThan;
    } else {
        Assert (iCmp == 0);
        result = GenericEqual;
    }

    return result;
}

VOID
KCCSimUpdateFailureTable (
    IN  PRTL_GENERIC_TABLE          pTable,
    IN  REPLICA_LINK *              pReplicaLink
    )
/*++

Routine Description:

    Processes a REPLICA_LINK and updates the failure table if necessary.

Arguments:

    pTable              - The failure table to update.
    pReplicaLink        - The replica link to process.

Return Value:

    None.

--*/
{
    DS_REPL_KCC_DSA_FAILUREW        failure;
    DS_REPL_KCC_DSA_FAILUREW *      pFailure;

    PSIM_ENTRY                      pEntry;
    PDSNAME                         pdn;
    DSTIME                          dsTime;

    // If this replica link isn't a failure, do nothing.
    if (pReplicaLink->V1.cConsecutiveFailures == 0) {
        return;
    }

    memcpy (&failure.uuidDsaObjGuid, &pReplicaLink->V1.uuidDsaObj, sizeof (GUID));
    pFailure = RtlLookupElementGenericTable (pTable, &failure);

    // If this uuid isn't in the table yet, add it.
    if (pFailure == NULL) {

        // We need to know the DN; so we look for it in the directory.
        pdn = KCCSimAllocDsname (NULL);
        memcpy (&pdn->Guid, &failure.uuidDsaObjGuid, sizeof (GUID));
        pEntry = KCCSimDsnameToEntry (pdn, KCCSIM_NO_OPTIONS);
        KCCSimFree (pdn);
        pdn = NULL;
        Assert (pEntry != NULL);

        failure.pszDsaDN = pEntry->pdn->StringName;
        DSTimeToFileTime (
            pReplicaLink->V1.timeLastSuccess,
            &failure.ftimeFirstFailure
            );
        failure.cNumFailures = pReplicaLink->V1.cConsecutiveFailures;
        failure.dwLastResult = 0;   // This is what the KCC does . . .
        RtlInsertElementGenericTable (
            pTable,
            (PVOID) &failure,
            sizeof (DS_REPL_KCC_DSA_FAILUREW),
            NULL
            );

    } else {

        // This uuid is in the table.  So update with worst-case info
        FileTimeToDSTime (pFailure->ftimeFirstFailure, &dsTime);
        if (dsTime < pReplicaLink->V1.timeLastSuccess) {
            DSTimeToFileTime (
                pReplicaLink->V1.timeLastSuccess,
                &pFailure->ftimeFirstFailure
                );
        }
        if (pFailure->cNumFailures < pReplicaLink->V1.cConsecutiveFailures) {
            pFailure->cNumFailures = pReplicaLink->V1.cConsecutiveFailures;
        }

    }
}

DS_REPL_KCC_DSA_FAILURESW *
KCCSimGetDsaFailures (
    IN  const DSNAME *              pdnServer
    )
/*++

Routine Description:

    Builds and returns the failures cache for a particular server.
    This is a bit tricky.  Each server will have several NCs, but
    we only want to return one failure entry per source DSA.  In
    addition, if there are several failures for a single source DSA
    (spread over several NCs), we want to merge them into a
    "worst-case" scenario (in the same way the real KCC builds its
    failure cache.)  We do this by building an RTL_GENERIC_TABLE
    that maps source DSA UUIDs to DS_REPLICA_KCC_DSA_FAILUREWs.  We
    then serialize this table into the return structure.

Arguments:

    pdnServer           - The server whose failures we want.

Return Value:

    The corresponding failures cache.

--*/
{
    DS_REPL_KCC_DSA_FAILURESW *     pDsaFailures = NULL;
    RTL_GENERIC_TABLE               tableFailures;
    ULONG                           cbDsaFailures;
    PVOID                           p;

    struct _KCCSIM_SERVER_STATE *   pState;
    REPLICA_LINK *                  pReplicaLink;
    PSIM_VALUE                      pValAt;
    ULONG                           ulNC, ulNumFailures, ul;

    __try {

        pState = KCCSimServerStateOf (pdnServer);
        if (pState == NULL) {
            return NULL;
        }

        RtlInitializeGenericTable (
            &tableFailures,
            KCCSimCompareFailures,
            KCCSimTableAlloc,
            KCCSimTableFree,
            NULL
            );

        for (ulNC = 0; ulNC < pState->ulNumNCs; ulNC++) {
            for (pValAt = pState->aRepsFrom[ulNC].pValFirst;
                 pValAt != NULL;
                 pValAt = pValAt->next) {

                pReplicaLink = (REPLICA_LINK *) pValAt->pVal;
                KCCSimUpdateFailureTable (
                    &tableFailures,
                    pReplicaLink
                    );

            }
        }

        ulNumFailures = RtlNumberGenericTableElements (&tableFailures);
        cbDsaFailures = offsetof (DS_REPL_KCC_DSA_FAILURESW, rgDsaFailure[0]) +
                        (sizeof (DS_REPL_KCC_DSA_FAILUREW) * ulNumFailures);
        pDsaFailures = KCCSimAlloc (cbDsaFailures);
        pDsaFailures->cNumEntries = ulNumFailures;
        pDsaFailures->dwReserved = 0;
        
        ul = 0;
        for (p = RtlEnumerateGenericTable (&tableFailures, TRUE);
             p != NULL;
             p = RtlEnumerateGenericTable (&tableFailures, FALSE)) {

            Assert (ul < ulNumFailures);
            memcpy (
                &pDsaFailures->rgDsaFailure[ul],
                p,
                sizeof (DS_REPL_KCC_DSA_FAILUREW)
                );
            ul++;

        }
        Assert (ul == ulNumFailures);

    } __finally {
    
        if (AbnormalTermination ()) {
            KCCSimFree (pDsaFailures);
        }
        
    }

    return pDsaFailures;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\sim\user.h ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    user.h

ABSTRACT:

    Header file for user.c.  Also contains the main
    routines from buildcfg.c and runkcc.cxx.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

//
// The following are character IDs for the option flags.
// These are used by the routines in user.c to display the options associated
// with each object, and by buildcfg.c to specify object options.
//

#define KCCSIM_CID_NTDSDSA_OPT_IS_GC                                        L'G'
#define KCCSIM_CID_NTDSDSA_OPT_DISABLE_INBOUND_REPL                         L'I'
#define KCCSIM_CID_NTDSDSA_OPT_DISABLE_OUTBOUND_REPL                        L'O'
#define KCCSIM_CID_NTDSDSA_OPT_DISABLE_NTDSCONN_XLATE                       L'X'
#define KCCSIM_CID_EXPLICIT_BRIDGEHEAD                                      L'B'
#define KCCSIM_CID_NTDSCONN_OPT_IS_GENERATED                                L'G'
#define KCCSIM_CID_NTDSCONN_OPT_TWOWAY_SYNC                                 L'2'
#define KCCSIM_CID_NTDSCONN_OPT_OVERRIDE_NOTIFY_DEFAULT                     L'O'
#define KCCSIM_CID_NTDSCONN_OPT_USE_NOTIFY                                  L'N'
#define KCCSIM_CID_NTDSSETTINGS_OPT_IS_AUTO_TOPOLOGY_DISABLED               L'A'
#define KCCSIM_CID_NTDSSETTINGS_OPT_IS_TOPL_CLEANUP_DISABLED                L'C'
#define KCCSIM_CID_NTDSSETTINGS_OPT_IS_TOPL_MIN_HOPS_DISABLED               L'M'
#define KCCSIM_CID_NTDSSETTINGS_OPT_IS_TOPL_DETECT_STALE_DISABLED           L'S'
#define KCCSIM_CID_NTDSSETTINGS_OPT_IS_INTER_SITE_AUTO_TOPOLOGY_DISABLED    L'I'
#define KCCSIM_CID_NTDSTRANSPORT_OPT_IGNORE_SCHEDULES                       L'S'
#define KCCSIM_CID_NTDSTRANSPORT_OPT_BRIDGES_REQUIRED                       L'B'
#define KCCSIM_CID_NTDSSITELINK_OPT_USE_NOTIFY                              L'N'
#define KCCSIM_CID_NTDSSITELINK_OPT_TWOWAY_SYNC                             L'2'

// From user.c

VOID
KCCSimDumpDirectory (
    LPCWSTR                     pwszStartDn
    );

VOID
KCCSimDisplayServer (
    VOID
    );

VOID
KCCSimDisplayConfigInfo (
    VOID
    );

VOID
KCCSimDisplayGraphInfo (
    VOID
    );

// From buildcfg.c

VOID
BuildCfg (
    LPCWSTR                     pwszFnIn
    );

// From runkcc.cxx

VOID
KCCSimRunKcc (
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\sim\util.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    util.c

ABSTRACT:

    Contains a bunch of quick, useful utilities.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <dsevent.h>
#include <debug.h>
#include <ismapi.h>
#include <taskq.h>
#include "util.h"
#include "schmap.h"
#include <fileno.h>
#define FILENO  FILENO_KCCSIM_UTIL

#define                             ERROR_BUF_LEN 4096

HINSTANCE                           hNtdsMsg = NULL;

WCHAR                               g_wszExceptionMsg[ERROR_BUF_LEN];
BOOL                                g_bQuiet = FALSE;
FILE *                              g_pFileLog = NULL;
ULONG                               g_ulDebugLevel = 0;
ULONG                               g_ulEventLevel = 0;
KCCSIM_STATISTICS                   g_Statistics;
HANDLE                              g_ThreadHeap = NULL;
BOOL                                gfIsTqRunning = TRUE;

// Function prototypes - ISM simulation library - private APIs

LPVOID
KCCSimAlloc (
    IN  ULONG                       ulSize
    );

VOID
KCCSimFree (
    IN  LPVOID                      p
    );

DWORD
SimI_ISMGetTransportServers (
    IN  HANDLE                      hIsm,
    IN  LPCWSTR                     pszSiteDN,
    OUT ISM_SERVER_LIST **          ppServerList
    );

DWORD
SimI_ISMGetConnectionSchedule (
    IN  HANDLE                      hIsm,
    IN  LPCWSTR                     pszSite1DN,
    IN  LPCWSTR                     pszSite2DN,
    OUT ISM_SCHEDULE **             ppSchedule
    );

DWORD
SimI_ISMGetConnectivity (
    IN  LPCWSTR                     pszTransportDN,
    OUT ISM_CONNECTIVITY **         ppConnectivity
    );

DWORD
SimI_ISMFree (
    IN  VOID *                      pv
    );

VOID
KCCSimQuiet (
    IN  BOOL                        bQuiet
    )
/*++

Routine Description:

    Turns quiet mode on and off.  In quiet mode, only error
    messages are printed.

Arguments:

    bQuiet              - TRUE to enable quiet mode,
                          FALSE to disable quiet mode.

Return Value:

    None.

--*/
{
    g_bQuiet = bQuiet;
}

DWORD
KCCSimHandleException (
    IN  const EXCEPTION_POINTERS *  pExceptPtrs,
    OUT PDWORD                      pdwErrType OPTIONAL,
    OUT PDWORD                      pdwErrCode OPTIONAL
    )
/*++

Routine Description:

    Extracts information from an EXCEPTION_POINTERS structure
    about an exception fired by KCCSim.  

Arguments:

    pExceptPtrs         - A valid EXCEPTION_POINTERS structure
    pdwErrType          - OPTIONAL.  Pointer to a DWORD to hold
                          the error type of the exception.
                          (e.g. KCCSIM_ETYPE_WIN32)
    pdwErrCode          - OPTIONAL.  Pointer to a DWORD to hold
                          the error code of the exception.
                          (e.g. ERROR_NOT_ENOUGH_MEMORY)

Return Value:

    If this was a KCCSIM_EXCEPTION, returns EXCEPTION_EXECUTE_HANDLER
    and fills pdwErrType and pdwErrCode, if present, with the
    appropriate values.  Otherwise, returns EXCEPTION_CONTINUE_SEARCH
    and fills pdwErrType and pdwErrCode, if present, with the value 0.

--*/
{
    Assert (pExceptPtrs != NULL);

    if (pExceptPtrs->ExceptionRecord->ExceptionCode == KCCSIM_EXCEPTION) {
        Assert (pExceptPtrs->ExceptionRecord->NumberParameters == 2);
        if (pdwErrType != NULL) {
            *pdwErrType = (DWORD) pExceptPtrs->ExceptionRecord->ExceptionInformation[0];
        }
        if (pdwErrCode != NULL) {
            *pdwErrCode = (DWORD) pExceptPtrs->ExceptionRecord->ExceptionInformation[1];
        }
        return EXCEPTION_EXECUTE_HANDLER;
    } else {
        if (pdwErrType != NULL) {
            *pdwErrType = 0;
        }
        if (pdwErrCode != NULL) {
            *pdwErrCode = 0;
        }
        return EXCEPTION_CONTINUE_SEARCH;
    }
}

LPCWSTR
KCCSimVaMsgToString (
    IN  DWORD                       dwErrorType,
    IN  DWORD                       dwMessageCode,
    IN  va_list *                   pArguments
    )
/*++

Routine Description:

    Retrieves the string associated with a given error type
    and message code.

Arguments:

    dwErrorType         - The error type.  (KCCSIM_ETYPE_*)
    dwMessageCode       - The message code.
                          (e.g. ERROR_NOT_ENOUGH_MEMORY or
                                KCCSIM_MSG_DID_RUN_KCC)
    pArguments          - Pointer to a list of arguments to substitute.

Return Value:

    The associated string.

--*/
{
    static WCHAR                    szError[ERROR_BUF_LEN];

    switch (dwErrorType) {

        case KCCSIM_ETYPE_WIN32:
            if (FormatMessageW (
                        FORMAT_MESSAGE_FROM_SYSTEM,
                        NULL,
                        dwMessageCode,
                        GetSystemDefaultLangID (),
                        szError,
                        ERROR_BUF_LEN,
                        pArguments) != NO_ERROR) {
                Assert (wcslen (szError) >= 2);
                szError[wcslen (szError) - 2] = '\0';   // Remove \r\n
            } else {
                swprintf (szError, L"Win32 error %d occurred.", dwMessageCode);
            }
            break;

        case KCCSIM_ETYPE_INTERNAL:
            if (FormatMessageW (
                FORMAT_MESSAGE_FROM_HMODULE,
                NULL,
                dwMessageCode,
                GetSystemDefaultLangID (),
                szError,
                ERROR_BUF_LEN,
                pArguments) != NO_ERROR) {
                Assert (wcslen (szError) >= 2);
                szError[wcslen (szError) - 2] = '\0';   // Remove \r\n
            } else {
                swprintf (szError, L"KCCSim internal error %d occurred. (%d)",
                        dwMessageCode, GetLastError() );
            }
            break;

        default:
            swprintf (szError, L"Unrecognized error type.");
            break;

    }

    return szError;
}

LPCWSTR
KCCSimMsgToString (
    IN  DWORD                       dwErrType,
    IN  DWORD                       dwMessageCode,
    ...
    )
/*++

Routine Description:

    Public version of KCCSimVaMsgToString.

Arguments:

    dwErrType           - The error type.
    dwMessageCode       - The message code.
    ...                 - Optional arguments.

Return Value:

    The associated string.

--*/
{
    LPCWSTR                         pwsz;
    va_list                         arguments;

    va_start (arguments, dwMessageCode);
    pwsz = KCCSimVaMsgToString (dwErrType, dwMessageCode, &arguments);
    va_end (arguments);

    return pwsz;
}

VOID
KCCSimPrintMessage (
    IN  DWORD                       dwMessageCode,
    ...
    )
/*++

Routine Description:

    Prints a message with optional arguments.
    Has no effect in quiet mode.

Arguments:

    dwMessageCode       - The message code.
    ...                 - Optional arguments.

Return Value:

    None.

--*/
{
    LPCWSTR                         pwszStr;
    va_list                         arguments;

    va_start (arguments, dwMessageCode);
    pwszStr = KCCSimVaMsgToString (KCCSIM_ETYPE_INTERNAL, dwMessageCode, &arguments);
    va_end (arguments);
    if (!g_bQuiet) {
        wprintf (L"%s\n", pwszStr);
    }
    if (g_pFileLog!=NULL && g_pFileLog!=stdout) {
        fwprintf (g_pFileLog, L"\n%s\n", pwszStr);
    }
}

VOID
KCCSimException (
    IN  DWORD                       dwErrType,
    IN  DWORD                       dwErrCode,
    ...
    )
/*++

Routine Description:

    Raises an exception of class KCCSIM_EXCEPTION.  Also
    fills the global buffer g_wszExceptionMsg with the
    associated error message.

Arguments:

    dwErrType           - The error type.
    dwErrCode           - The error code.
    ...                 - Optional arguments to substitute within
                          the associated error message.

Return Value:

    None.

--*/
{
    // We use static data to avoid allocating any additional memory
    // at this point.
    static ULONG_PTR                ulpErr[2];
    static va_list                  arguments;

    va_start (arguments, dwErrCode);
    wcscpy (
        g_wszExceptionMsg,
        KCCSimVaMsgToString (dwErrType, dwErrCode, &arguments)
        );
    va_end (arguments);
    ulpErr[0] = dwErrType;
    ulpErr[1] = dwErrCode;

    RaiseException (
        KCCSIM_EXCEPTION,
        EXCEPTION_NONCONTINUABLE,
        2,
        ulpErr);
}

VOID
KCCSimPrintExceptionMessage (
    VOID
    )
/*++

Routine Description:

    Prints the message associated with the last call to
    KCCSimException.

Arguments:

    None.

Return Value:

    None.

--*/
{
    wprintf (L"%s\n", g_wszExceptionMsg);
}

VOID
KCCSimSetDebugLog (
    IN  LPCWSTR                     pwszFn OPTIONAL,
    IN  ULONG                       ulDebugLevel,
    IN  ULONG                       ulEventLevel
    )
/*++

Routine Description:

    Opens a debug log.

Arguments:

    pwszFn              - The filename to open.  If NULL, closes the
                          existing log and does not open a new one.

    ulDebugLevel        - Maximum debugging verbosity
    ulEventLevel        - Maximum event log verbosity

Return Value:

    None.

--*/
{
    // Close the existing log, if present
    if (g_pFileLog != NULL &&
        g_pFileLog != stdin &&
        g_pFileLog != stdout ) {
        KCCSIM_CHKERR (fclose (g_pFileLog));
    }

    if (pwszFn == NULL || pwszFn[0] == L'\0') {
        // If the message resource library is open, free it
        if (hNtdsMsg != NULL) {
            if (FreeLibrary (hNtdsMsg) == 0) {
                KCCSimException (
                    KCCSIM_ETYPE_WIN32,
                    GetLastError ()
                    );
            }
            hNtdsMsg = NULL;
        }
        return;
    }

    // Open the file log
    if( wcscmp(pwszFn, L"stdout")==0 ) {
        g_pFileLog = stdout;
    } else {
        g_pFileLog = _wfopen (pwszFn, L"wt");
    }
    if (g_pFileLog == NULL) {
        KCCSimException (
            KCCSIM_ETYPE_WIN32,
            GetLastError ()
            );
    }

    // Set the debug level
    g_ulDebugLevel = ulDebugLevel;
    g_ulEventLevel = ulEventLevel;

    // Open the message resource library if it isn't open already
    if (hNtdsMsg == NULL) {
        hNtdsMsg = LoadLibraryExW (
            L"ntdsmsg",
            NULL,
            LOAD_LIBRARY_AS_DATAFILE
            );
        if (hNtdsMsg == NULL) {
            KCCSimException (
                KCCSIM_ETYPE_WIN32,
                GetLastError ()
                );
        }
    }
}

VOID
KCCSimDbgLog (
    IN  ULONG                       ulLevel,
    IN  LPCSTR                      pszFormat,
    ...
    )
/*++

Routine Description:

    Logs a debug message.  If no debug log is currently open, this
    function has no effect.

Arguments:

    ulLevel             - Debug level of the message.
    pszFormat           - printf-style format string.
    ...                 - Optional arguments.

Return Value:

    None.

--*/
{
    va_list                         arguments;
    static long                     lastTime=0;
    unsigned long                   curTime;
    time_t                          tempTime;

    if (g_pFileLog == NULL) {
        if (ulLevel == 0) {
            // Always count level zero debug messages
            g_Statistics.DebugMessagesEmitted++;
        }
        return;
    }

    va_start (arguments, pszFormat);
    if (ulLevel <= g_ulDebugLevel) {
        time( &tempTime );
        curTime = (long) tempTime;
        
        g_Statistics.DebugMessagesEmitted++;
        fprintf (g_pFileLog, "[%d] ", ulLevel);
        fprintf (g_pFileLog, "[%4d] ", lastTime ? curTime-lastTime : 0 );
        vfprintf (g_pFileLog, pszFormat, arguments);

        lastTime = curTime;
    }
    va_end (arguments);

}

VOID
KCCSimEventLog (
    IN  ULONG                       ulCategory,
    IN  ULONG                       ulSeverity,
    IN  DWORD                       dwMessageId,
    ...
    )
/*++

Routine Description:

    Logs an event.  If no debug log is currently open, this
    function has no effect.

Arguments:

    ulCategory          - The event category.
    ulSeverity          - The event severity.
    dwMessageId         - The event message ID from the ntdsmsg.dll resource.
    ...                 - Optional string-valued arguments.

Return Value:

    None.

--*/
{
    va_list                         arguments;
    LPWSTR                          pwszBuf;
    CHAR                            cid, fSimAlloc=FALSE;

    g_Statistics.LogEventsCalled++;
    if (ulSeverity > g_ulEventLevel) {
        return;
    }
    g_Statistics.LogEventsEmitted++;
    if (g_pFileLog == NULL) {
        return;
    }

    // If a file log is open, the message resource file
    // must be loaded.
    Assert (hNtdsMsg != NULL);

    va_start (arguments, dwMessageId);
    if (FormatMessageW (
            FORMAT_MESSAGE_FROM_HMODULE |
            FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_MAX_WIDTH_MASK,
            hNtdsMsg,
            dwMessageId,
            GetSystemDefaultLangID (),
            (LPWSTR) &pwszBuf,
            0,
            &arguments
            ) == 0) {
        pwszBuf = KCCSimAlloc(64 * sizeof(WCHAR));
        fSimAlloc = TRUE;
        swprintf( pwszBuf, L"LogEvent: message id 0x%x not found.", dwMessageId );
    }
    va_end (arguments);

    switch (ulSeverity) {
        case DS_EVENT_SEV_ALWAYS:     cid = 'A'; break;
        case DS_EVENT_SEV_MINIMAL:    cid = 'M'; break;
        case DS_EVENT_SEV_BASIC:      cid = 'B'; break;
        case DS_EVENT_SEV_EXTENSIVE:  cid = 'E'; break;
        case DS_EVENT_SEV_VERBOSE:    cid = 'V'; break;
        case DS_EVENT_SEV_INTERNAL:   cid = 'I'; break;
        case DS_EVENT_SEV_NO_LOGGING: cid = 'N'; break;
        default:                      cid = '?'; break;
    }

    fprintf (g_pFileLog, "[%c] %ls\n", cid, pwszBuf);
    if( fSimAlloc ) {
        KCCSimFree(pwszBuf);
    } else {
        LocalFree(pwszBuf);
    }
}

LPVOID
KCCSimAlloc (
    IN  ULONG                       ulSize
    )
/*++

Routine Description:

    Allocates memory. This memory is initialized to zero.

Arguments:

    ulSize              - Amount of memory to allocate.

Return Value:

    A pointer to the allocated memory buffer.  Note that KCCSimAlloc
    will never return NULL; if there is an error, it will raise an
    exception.

--*/
{
    LPVOID                          p;

    if ((p = LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT,ulSize)) == NULL) {
        printf( "Memory allocation failure - failed to allocate %d bytes.\n", ulSize );
        KCCSimException (KCCSIM_ETYPE_WIN32, GetLastError ());
    }

    g_Statistics.SimBytesTotalAllocated += ulSize;
    g_Statistics.SimBytesOutstanding += ulSize;
    if (g_Statistics.SimBytesOutstanding > g_Statistics.SimBytesMaxOutstanding) {
        g_Statistics.SimBytesMaxOutstanding = g_Statistics.SimBytesOutstanding;
    }

    return p;
}

LPVOID
KCCSimReAlloc (
    IN  LPVOID                      pOld,
    IN  ULONG                       ulSize
    )
/*++

Routine Description:

    Reallocates memory.

Arguments:

    pOld                - An existing block of memory.
    ulSize              - Size of the new block of memory.

Return Value:

    A pointer to the reallocated block of memory.

--*/
{
    LPVOID                          pNew;
    DWORD                           oldSize;

    Assert( pOld );

    oldSize = (DWORD) LocalSize( pOld );
    g_Statistics.SimBytesOutstanding -= oldSize;
    g_Statistics.SimBytesTotalAllocated -= oldSize;

    if ((pNew = LocalReAlloc (pOld, ulSize, LMEM_ZEROINIT)) == NULL) {
        printf( "Memory allocation failure - failed to reallocate %d bytes.\n", ulSize );
        KCCSimException (KCCSIM_ETYPE_WIN32, GetLastError ());
    }

    g_Statistics.SimBytesTotalAllocated += ulSize;
    g_Statistics.SimBytesOutstanding += ulSize;
    if (g_Statistics.SimBytesOutstanding > g_Statistics.SimBytesMaxOutstanding) {
        g_Statistics.SimBytesMaxOutstanding = g_Statistics.SimBytesOutstanding;
    }

    return pNew;
}

VOID
KCCSimFree (
    IN  LPVOID                      p
    )
/*++

Routine Description:

    Frees memory.  KCCSimFree (NULL) has no effect.

Arguments:

    p                   - The block of memory to free.

Return Value:

    None.

--*/
{
    DWORD oldSize;

    if (p != NULL) {
        oldSize = (DWORD) LocalSize( p );
        LocalFree( p );
        g_Statistics.SimBytesOutstanding -= oldSize;
    }
}


DWORD
KCCSimThreadCreate(
    void
    )

/*++

Routine Description:

    Description

Arguments:

    void - 

Return Value:

    DWORD - 

--*/

{
#define INITIAL_HEAP_SIZE (16 * 1024 * 1024)
    if (g_ThreadHeap) {
        Assert( FALSE );
        KCCSimException (KCCSIM_ETYPE_WIN32, ERROR_INVALID_PARAMETER);
    }

    g_ThreadHeap = HeapCreate( 0, INITIAL_HEAP_SIZE, 0 );
    if (g_ThreadHeap) {
        return 0;
    } else {
        KCCSimException (KCCSIM_ETYPE_WIN32, GetLastError ());
        return 1;
    }
} /* KCCSimThreadCreate */


VOID
KCCSimThreadDestroy(
    void
    )

/*++

Routine Description:

    Description

Arguments:

    void - 

Return Value:

    None

--*/

{
    if (!g_ThreadHeap) {
        Assert( FALSE );
        return;
    }
    if (!HeapDestroy( g_ThreadHeap )) {
        KCCSimException (KCCSIM_ETYPE_WIN32, GetLastError ());
    }
    g_ThreadHeap = NULL;
} /* KCCSimThreadDestroy */

LPVOID
KCCSimThreadAlloc (
    IN  ULONG                       ulSize
    )
/*++

Routine Description:

    Allocates memory.

Arguments:

    ulSize              - Amount of memory to allocate.

Return Value:

    A pointer to the allocated memory buffer.  Note that KCCSimAlloc
    will never return NULL; if there is an error, it will raise an
    exception.

--*/
{
    LPVOID                          p;

    Assert( g_ThreadHeap );

    if ((p = HeapAlloc( g_ThreadHeap, HEAP_ZERO_MEMORY, ulSize)) == NULL) {
        printf( "Memory allocation failure - failed to allocate %d bytes.\n", ulSize );
        KCCSimException (KCCSIM_ETYPE_WIN32, GetLastError ());
    }

    g_Statistics.ThreadBytesTotalAllocated += ulSize;
    g_Statistics.ThreadBytesOutstanding += ulSize;
    if (g_Statistics.ThreadBytesOutstanding > g_Statistics.ThreadBytesMaxOutstanding) {
        g_Statistics.ThreadBytesMaxOutstanding = g_Statistics.ThreadBytesOutstanding;
    }

    return p;
}

LPVOID
KCCSimThreadReAlloc (
    IN  LPVOID                      pOld,
    IN  ULONG                       ulSize
    )
/*++

Routine Description:

    Reallocates memory.

Arguments:

    pOld                - An existing block of memory.
    ulSize              - Size of the new block of memory.

Return Value:

    A pointer to the reallocated block of memory.

--*/
{
    LPVOID                          pNew;
    DWORD                           oldSize;

    Assert( g_ThreadHeap );
    Assert( pOld );

    oldSize = (DWORD) HeapSize( g_ThreadHeap, 0, pOld );
    Assert( oldSize != 0xffffffff );
    g_Statistics.ThreadBytesOutstanding -= oldSize;
    g_Statistics.ThreadBytesTotalAllocated -= oldSize;

    if ((pNew = HeapReAlloc( g_ThreadHeap, HEAP_ZERO_MEMORY, pOld, ulSize)) == NULL) {
        printf( "Memory allocation failure - failed to reallocate %d bytes.\n", ulSize );
        KCCSimException (KCCSIM_ETYPE_WIN32, GetLastError ());
    }

    g_Statistics.ThreadBytesTotalAllocated += ulSize;
    g_Statistics.ThreadBytesOutstanding += ulSize;
    if (g_Statistics.ThreadBytesOutstanding > g_Statistics.ThreadBytesMaxOutstanding) {
        g_Statistics.ThreadBytesMaxOutstanding = g_Statistics.ThreadBytesOutstanding;
    }

    return pNew;
}

VOID
KCCSimThreadFree (
    IN  LPVOID                      p
    )
/*++

Routine Description:

    Frees memory.  KCCSimFree (NULL) has no effect.

Arguments:

    p                   - The block of memory to free.

Return Value:

    None.

--*/
{
    DWORD ret, oldSize;

    Assert( g_ThreadHeap );

    if (p != NULL) {
        oldSize = (DWORD) HeapSize( g_ThreadHeap, 0, p );
        Assert( oldSize != 0xffffffff );

        if (!HeapFree( g_ThreadHeap, 0, p )) {
            KCCSimException (KCCSIM_ETYPE_WIN32, GetLastError ());
        }
        g_Statistics.ThreadBytesOutstanding -= oldSize;
    }
}

PVOID
KCCSimTableAlloc (
    IN  RTL_GENERIC_TABLE *         pTable,
    IN  CLONG                       ByteSize
    )
//
// This is just a wrapper for use by RTL_GENERIC_TABLEs.
//
{
    return KCCSimAlloc (ByteSize);
}

VOID
KCCSimTableFree (
    IN  RTL_GENERIC_TABLE *         pTable,
    IN  PVOID                       Buffer
    )
//
// This is just a wrapper for use by RTL_GENERIC_TABLEs.
//
{
    KCCSimFree (Buffer);
}

BOOL
KCCSimParseCommand (
    IN  LPCWSTR                     pwsz,
    IN  ULONG                       ulArg,
    IO  LPWSTR                      pwszBuf
    )
/*++

Routine Description:

    Retrieves a single argument from an arbitrary command of
    the form:
    arg0 arg1 "quoted arg2" arg3 ...

Arguments:

    pwsz                - The command line.
    ulArg               - The argument number to retrieve
                          (starting with 0)
    pwszBuf             - A preallocated buffer that will hold
                          the parsed argument.  To be safe, it
                          should be at least as long as
                          wcslen (pwsz).  If there are fewer than
                          ulArg+1 arguments, this will hold the
                          string L"\0".

Return Value:

    TRUE if the command line is properly formatted.
    FALSE if the command line contains an odd number of quotes.

--*/
{
    BOOL                            bIsInQuotes;
    ULONG                           ul;

    bIsInQuotes = FALSE;

    for (ul = 0; ul < ulArg; ul++) {

        // Skip past any white space
        while (*pwsz == L' ') {
            pwsz++;
        }

        // Skip past this command
        while (    (*pwsz != L'\0')
                && (*pwsz != L' ' || bIsInQuotes)) {
            if (*pwsz == L'\"') {
                bIsInQuotes = !bIsInQuotes;
            }
            pwsz++;
        }

    }

    if (!bIsInQuotes) {

        // Skip past any white space
        while (*pwsz == L' ') {
            pwsz++;
        }

        // Copy this command into the buffer
        while (    (*pwsz != L'\0')
                && (*pwsz != L' ' || bIsInQuotes)) {
            if (*pwsz == L'\"') {
                bIsInQuotes = !bIsInQuotes;
            } else {
                *pwszBuf = *pwsz;
                pwszBuf++;
            }
            pwsz++;
        }

    }

    *pwszBuf = L'\0';
    // Return true unless we stopped inside quotes
    return (!bIsInQuotes);
}

LPWSTR
KCCSimAllocWideStr (
    IN  UINT                        CodePage,
    IN  LPCSTR                      psz
    )
/*++

Routine Description:

    Converts a narrow string to a wide string.

Arguments:

    CodePage            - The code page to use.
    psz                 - The narrow string.

Return Value:

    The allocated wide string.  Never returns NULL.

--*/
{
    LPWSTR                          pwsz;
    ULONG                           cb;

    cb = MultiByteToWideChar (
        CodePage,
        0,
        psz,
        -1,
        NULL,
        0
        );
    if (0 == cb) {
        KCCSimException (
            KCCSIM_ETYPE_WIN32,
            GetLastError ()
            );
    }

    pwsz = KCCSimAlloc ((sizeof (WCHAR)) * (1 + cb));

    cb = MultiByteToWideChar (
        CodePage,
        0,
        psz,
        -1,
        pwsz,
        cb
        );
    if (0 == cb) {
        KCCSimException (
            KCCSIM_ETYPE_WIN32,
            GetLastError ()
            );
    }

    pwsz[cb] = 0;
    return pwsz;
}

LPSTR
KCCSimAllocNarrowStr (
    IN  UINT                        CodePage,
    IN  LPCWSTR                     pwsz
    )
/*++

Routine Description:

    Converts a wide string to a narrow string.

Arguments:

    CodePage            - The code page to use.
    pwsz                - The wide string.

Return Value:

    The allocated narrow string.  Never returns NULL.

--*/
{
    LPSTR                           psz;
    ULONG                           cb;

    cb = WideCharToMultiByte (
        CodePage,
        0,
        pwsz,
        -1,
        NULL,
        0,
        NULL,
        NULL
        );

    psz = KCCSimAlloc (cb);

    cb = WideCharToMultiByte (
        CodePage,
        0,
        pwsz,
        -1,
        psz,
        cb,
        NULL,
        NULL
        );
    if (0 == cb) {
        KCCSimException (
            KCCSIM_ETYPE_WIN32,
            GetLastError ()
            );
    }

    return psz;
}

PDSNAME
KCCSimAllocDsname (
    IN  LPCWSTR                     pwszDn OPTIONAL
    )
/*++

Routine Description:

    Creates a DSNAME structure with a given StringName.
    The GUID and SID are left blank.

Arguments:

    pwszDn              - The string name.  If NULL, creates a
                          DSNAME with a 0-length StringName.

Return Value:

    The allocated DSNAME.  Never returns NULL.

--*/
{
    PDSNAME                         pdn;
    ULONG                           ulNameLen;

    if (pwszDn == NULL) {
        ulNameLen = 0;
    } else {
        ulNameLen = wcslen (pwszDn);
    }

    pdn = (PDSNAME) KCCSimAlloc (DSNameSizeFromLen (ulNameLen));
    pdn->structLen = DSNameSizeFromLen (ulNameLen);
    pdn->SidLen = 0;
    pdn->NameLen = ulNameLen;

    if (pwszDn == NULL) {
        pdn->StringName[0] = '\0';
    } else {
        wcscpy (pdn->StringName, pwszDn);
    }

    return pdn;
}

PDSNAME
KCCSimAllocDsnameFromNarrow (
    IN  LPCSTR                      pszDn OPTIONAL
    )
/*++

Routine Description:

    Same as KCCSimAllocDsname, but accepts a narrow
    string as parameter.

Arguments:

    pszDn               - The string name.  If NULL, creates a
                          DSNAME with a 0-length StringName.

Return Value:

    The allocated DSNAME.  Never returns NULL.

--*/
{
    PDSNAME                   pdn;
    WCHAR                    *wszBuf;

    if (pszDn == NULL) {
        return KCCSimAllocDsname (NULL);
    } else {
        wszBuf = (WCHAR*) KCCSimAlloc((strlen(pszDn)+1)*sizeof(WCHAR));
        if (MultiByteToWideChar (
                CP_ACP,
                0,
                pszDn,
                1 + strlen (pszDn),
                wszBuf,
                1 + strlen (pszDn)
                ) == 0) {
            KCCSimException (
                KCCSIM_ETYPE_WIN32,
                GetLastError ()
                );
        }

        pdn = KCCSimAllocDsname (wszBuf);
        KCCSimFree( wszBuf );
        return pdn;
    }
}

LPWSTR
KCCSimQuickRDNOf (
    IN  const DSNAME *              pdn,
    IO  LPWSTR                      pwszBuf
    )
/*++

Routine Description:

    Retrieves the RDN of a DSNAME.

Arguments:

    pdn                 - The full DSNAME.
    pwszBuf             - A preallocated buffer of length MAX_RDN_SIZE
                          that will hold the corresponding RDN.

Return Value:

    Always returns pwszBuf.

--*/
{
    ULONG                           ulLen;
    ATTRTYP                         attrTyp;

    KCCSIM_CHKERR (GetRDNInfoExternal (
        pdn,
        pwszBuf,
        &ulLen,
        &attrTyp
        ));

    pwszBuf[ulLen] = '\0';
    return pwszBuf;
}

LPWSTR
KCCSimQuickRDNBackOf (
    IN  const DSNAME *              pdn,
    IN  ULONG                       ulBackBy,
    IO  LPWSTR                      pwszBuf
    )
/*++

Routine Description:

    Retrieves the RDN of an ancestor of a DSNAME.

Arguments:

    pdn                 - The full DSNAME.
    ulBackBy            - Number of RDNs to shave off before calling
                          KCCSimQuickRDNOf.
    pwszBuf             - A preallocated buffer of length MAX_RDN_SIZE
                          that will hold the corresponding RDN.

Return Value:

    Always returns pwszBuf.

--*/
{
    PDSNAME                         pdnTrimmed;

    if (ulBackBy == 0) {
        return KCCSimQuickRDNOf (pdn, pwszBuf);
    } else {
        pdnTrimmed = KCCSimAlloc (pdn->structLen);
        TrimDSNameBy ((PDSNAME) pdn, ulBackBy, pdnTrimmed);
        KCCSimQuickRDNOf (pdnTrimmed, pwszBuf);
        KCCSimFree (pdnTrimmed);
        return pwszBuf;
    }
}

PDSNAME
KCCSimAllocAppendRDN (
    IN  const DSNAME *              pdnOld,
    IN  LPCWSTR                     pwszNewRDN,
    IN  ATTRTYP                     attClass
    )
/*++

Routine Description:

    Appends an RDN onto an existing DSNAME.

Arguments:

    pdnOld              - The existing DSNAME.
    pwszNewRDN          - The RDN to append.
    attClass            - Attribute class of this RDN; typically
                          ATT_COMMON_NAME.

Return Value:

    A newly allocated DSNAME with the appended RDN.

--*/
{
    PDSNAME                         pdnNew;
    LPWSTR                          pwszNewRDNCopy;
    ULONG                           cbBytesNeeded, ulAppendResult;

    // We're given a LPCWSTR, but AppendRDN wants an LPWSTR.
    // So we make a copy.

    pwszNewRDNCopy = KCCSIM_WCSDUP (pwszNewRDN);

    cbBytesNeeded = AppendRDN (
        (PDSNAME) pdnOld,
        NULL,
        0,
        pwszNewRDNCopy,
        0,
        attClass
        );
    Assert (cbBytesNeeded > 0);

    pdnNew = KCCSimAlloc (cbBytesNeeded);
    ulAppendResult = AppendRDN (
        (PDSNAME) pdnOld,
        pdnNew,
        cbBytesNeeded,
        pwszNewRDNCopy,
        0,
        attClass
        );
    Assert (ulAppendResult == 0);       // Everything should be fine

    KCCSimFree (pwszNewRDNCopy);

    return pdnNew;
}

LPWSTR
KCCSimAllocDsnameToDNSName (
    IN  const DSNAME *              pdn
    )
/*++

Routine Description:

    Converts a DSNAME structure to the associated DSNAME, e.g.
    DC=ntdev,DC=microsoft,DC=com => ntdev.microsoft.com

Arguments:

    pdn                 - The DSNAME to convert.

Return Value:

    The allocated converted string. If the DSNAME is invalid,
    an exception is thrown.

--*/
{
    LPWSTR                          pwszDNSName;
    WCHAR                           wszRDN[1+MAX_RDN_SIZE];
    ULONG                           ulLen, ulNameParts, ulRDNAt;
    ULONG                           ulResult;
    
    Assert (pdn != NULL);
    Assert (pdn->NameLen > 0);

    ulResult = CountNameParts (pdn, &ulNameParts);
    if( 0!=ulResult ) {
        KCCSimException (
            KCCSIM_ETYPE_INTERNAL,
            KCCSIM_ERROR_INVALID_DSNAME,
            pdn->StringName
            );
    }

    // Determine how much space is needed.
    ulLen = 0;
    for (ulRDNAt = 0; ulRDNAt < ulNameParts; ulRDNAt++) {
        ulLen += wcslen (KCCSimQuickRDNBackOf (pdn, ulRDNAt, wszRDN)) + 1;
    }
    ulLen -= 1;

    pwszDNSName = KCCSimAlloc (sizeof (WCHAR) * (1 + ulLen));

    // Build the DNS Name
    pwszDNSName[0] = L'\0';
    for (ulRDNAt = 0; ulRDNAt < ulNameParts; ulRDNAt++) {
        wcscat (pwszDNSName, KCCSimQuickRDNBackOf (pdn, ulRDNAt, wszRDN));
        if (ulRDNAt != ulNameParts - 1) {
            wcscat (pwszDNSName, L".");
        }
    }

    return pwszDNSName;
}

VOID
KCCSimCopyGuidAndSid (
    IO  PDSNAME                     pdnDst,
    IN  const DSNAME *              pdnSrc
    )
/*++

Routine Description:

    Copies the GUID and SID from one DSNAME to another.
    Does not affect the StringNames of the DSNAMEs involved.

Arguments:

    pdnDst              - The destination DSNAME.
    pdnSrc              - The source DSNAME.

Return Value:

    None.

--*/
{
    if (pdnDst != NULL && pdnSrc != NULL) {

        memcpy (&pdnDst->Guid,
                &pdnSrc->Guid,
                sizeof (GUID));

        pdnDst->SidLen = pdnSrc->SidLen;

        memcpy (&pdnDst->Sid,
                &pdnSrc->Sid,
                sizeof (NT4SID));

    }
}

RTL_GENERIC_TABLE                   g_TableSchema;

struct _KCCSIM_SCHEMA_ENTRY {
    ATTRTYP                         attrType;
    const struct _SCHTABLE_MAPPING *pSchTableEntry;
    PDSNAME                         pdnObjCategory;
};

RTL_GENERIC_COMPARE_RESULTS
NTAPI
KCCSimSchemaTableCompare (
    IN  RTL_GENERIC_TABLE *         pTable,
    IN  PVOID                       pFirstStruct,
    IN  PVOID                       pSecondStruct
    )
/*++

Routine Description:

    Compares two _KCCSIM_SCHEMA_ENTRY structures by ATTRTYP.

Arguments:

    pTable              - Always &g_TableSchema.
    pFirstStruct        - The first ATTRTYP to compare.
    pSecondStruct       - The second ATTRTYP to compare.

Return Value:

    GenericLessThan, GenericGreaterThan or GenericEqual

--*/
{
    struct _KCCSIM_SCHEMA_ENTRY *   pFirstEntry;
    struct _KCCSIM_SCHEMA_ENTRY *   pSecondEntry;
    int                             iCmp;
    RTL_GENERIC_COMPARE_RESULTS     result;

    pFirstEntry = (struct _KCCSIM_SCHEMA_ENTRY *) pFirstStruct;
    pSecondEntry = (struct _KCCSIM_SCHEMA_ENTRY *) pSecondStruct;
    iCmp = pFirstEntry->attrType - pSecondEntry->attrType;

    if (iCmp < 0) {
        result = GenericLessThan;
    } else if (iCmp > 0) {
        result = GenericGreaterThan;
    } else {
        Assert (iCmp == 0);
        result = GenericEqual;
    }

    return result;
}

VOID
KCCSimInitializeSchema (
    VOID
    )
/*++

Routine Description:

    KCCSim maintains an RTL_GENERIC_TABLE that maps ATTRTYPs to
    schema information.  This table serves as a makeshift schema; it
    is necessary because we usually do not have a complete view of
    the schema available.  When we initially load an ldif file, for
    example, we need to know the ATTRTYP and attribute syntax of each
    attribute that is loaded.
    
    Upon initialization, this schema information
    is read out of the automatically generated table in schmap.c and
    stored in the RTL_GENERIC_TABLE for rapid lookup.
    Object categories are not stored in schmap.c (since they vary
    depending on the DN of the schema), and by default the
    pdnObjCategory field of g_TableSchema is NULL.  As object
    categories become known, they will be filled in as appropriate.    

Arguments:

    None.

Return Value:

    None.

--*/
{
    struct _KCCSIM_SCHEMA_ENTRY     insert;
    ULONG                           ul;

    RtlInitializeGenericTable (
        &g_TableSchema,
        KCCSimSchemaTableCompare,
        KCCSimTableAlloc,
        KCCSimTableFree,
        NULL
        );

    for (ul = 0; ul < SCHTABLE_NUM_ROWS; ul++) {
        insert.attrType = schTable[ul].attrType;
        insert.pSchTableEntry = &schTable[ul];
        insert.pdnObjCategory = NULL;
        RtlInsertElementGenericTable (
            &g_TableSchema,
            (PVOID) &insert,
            sizeof (struct _KCCSIM_SCHEMA_ENTRY),
            NULL
            );
    }
}

struct _KCCSIM_SCHEMA_ENTRY *
KCCSimSchemaTableLookup (
    IN  ATTRTYP                     attrType
    )
/*++

Routine Description:

    This retrieves the _KCCSIM_SCHEMA_ENTRY structure associated
    with a particular ATTRTYP.  The _KCCSIM_SCHEMA_ENTRY type is
    not publicized, but this function is called by the conversion
    functions below.

Arguments:

    attrType            - The attribute type to search for.

Return Value:

    The associated _KCCSIM_SCHEMA_ENTRY.

--*/
{
    struct _KCCSIM_SCHEMA_ENTRY     lookup;
    struct _KCCSIM_SCHEMA_ENTRY *   pFound;

    lookup.attrType = attrType;
    lookup.pSchTableEntry = NULL;
    lookup.pdnObjCategory = NULL;
    pFound = RtlLookupElementGenericTable (&g_TableSchema, &lookup);

    return pFound;
}

LPCWSTR
KCCSimAttrTypeToString (
    IN  ATTRTYP                     attrType
    )
//
// Converts an attribute type to an LDAP display name.
// (e.g. ATT_GOVERNS_ID => L"governsID")
//
{
    struct _KCCSIM_SCHEMA_ENTRY *   pSchemaEntry;

    pSchemaEntry = KCCSimSchemaTableLookup (attrType);

    if (pSchemaEntry == NULL) {
        return NULL;
    } else {
        Assert (pSchemaEntry->pSchTableEntry != NULL);
        return (pSchemaEntry->pSchTableEntry->wszLdapDisplayName);
    }
}

ATTRTYP
KCCSimStringToAttrType (
    IN  LPCWSTR                     pwszName
    )
//
// Converts an LDAP display name to an attribute type.
// (e.g. L"governsID" => ATT_GOVERNS_ID)
//
{
    ULONG                           ul;

    // The table is indexed by attrType, not name, so we have
    // to do this by brute force.

    for (ul = 0; ul < SCHTABLE_NUM_ROWS; ul++) {
        if (wcscmp (pwszName, schTable[ul].wszLdapDisplayName) == 0) {
            break;
        }
    }

    if (ul == SCHTABLE_NUM_ROWS) {
        return 0;
    } else {
        return schTable[ul].attrType;
    }
}

ATTRTYP
KCCSimNarrowStringToAttrType (
    IN  LPCSTR                      pszName
    )
//
// Converts a narrow-string LDAP display name to an attribute type.
// (e.g. "governsID" => ATT_GOVERNS_ID)
//
{
    static WCHAR                    wszBuf[1+SCHTABLE_MAX_LDAPNAME_LEN];

    if (MultiByteToWideChar (
            CP_ACP,
            0,
            pszName,
            1 + min (strlen (pszName), SCHTABLE_MAX_LDAPNAME_LEN),
            wszBuf,
            1 + SCHTABLE_MAX_LDAPNAME_LEN
            ) == 0) {
        KCCSimException (
            KCCSIM_ETYPE_WIN32,
            GetLastError ()
            );
    }

    return KCCSimStringToAttrType (wszBuf);
}

ULONG
KCCSimAttrSyntaxType (
    IN  ATTRTYP                     attrType
    )
//
// Returns an attribute's syntax type (SYNTAX_*_TYPE defined in ntdsa.h.)
// (e.g. ATT_GOVERNS_ID => SYNTAX_OBJECT_ID_TYPE)
//
{
    struct _KCCSIM_SCHEMA_ENTRY *   pSchemaEntry;

    pSchemaEntry = KCCSimSchemaTableLookup (attrType);

    if (pSchemaEntry == NULL) {
        return 0;
    } else {
        Assert (pSchemaEntry->pSchTableEntry != NULL);
        return (pSchemaEntry->pSchTableEntry->ulSyntax);
    }
}

LPCWSTR
KCCSimAttrSchemaRDN (
    IN  ATTRTYP                     attrType
    )
//
// Converts an attribute type to a schema RDN.
// (e.g. ATT_GOVERNS_ID => L"Governs-ID")
//
{
    struct _KCCSIM_SCHEMA_ENTRY *   pSchemaEntry;

    pSchemaEntry = KCCSimSchemaTableLookup (attrType);

    if (pSchemaEntry == NULL) {
        return NULL;
    } else {
        Assert (pSchemaEntry->pSchTableEntry != NULL);
        return (pSchemaEntry->pSchTableEntry->wszSchemaRDN);
    }
}

ATTRTYP
KCCSimAttrSuperClass (
    IN  ATTRTYP                     attrType
    )
//
// Converts a class type to the type of its super-class.
// (i.e. CLASS_NTDS_DSA => CLASS_APPLICATION_SETTINGS,
//       CLASS_APPLICATION_SETTINGS => CLASS_TOP,
//       CLASS_TOP => CLASS_TOP)
//
{
    struct _KCCSIM_SCHEMA_ENTRY *   pSchemaEntry;

    pSchemaEntry = KCCSimSchemaTableLookup (attrType);

    if (pSchemaEntry == NULL) {
        return 0;
    } else {
        Assert (pSchemaEntry->pSchTableEntry != NULL);
        return (pSchemaEntry->pSchTableEntry->superClass);
    }
}

PDSNAME
KCCSimAttrObjCategory (
    IN  ATTRTYP                     attrType
    )
//
// Converts an attribute type to an object category.
// If no object category is present for this attribute, returns NULL.
// A more general function, KCCSimAlwaysGetObjCategory, is prototyped
// in dir.h.
//
{
    struct _KCCSIM_SCHEMA_ENTRY *   pSchemaEntry;

    pSchemaEntry = KCCSimSchemaTableLookup (attrType);

    if (pSchemaEntry == NULL) {
        return NULL;
    } else {
        return (pSchemaEntry->pdnObjCategory);
    }
}

VOID
KCCSimSetObjCategory (
    IN  ATTRTYP                     attrType,
    IN  const DSNAME *              pdnObjCategory
    )
//
// Set this attribute's object category in the schema table.
//
{
    struct _KCCSIM_SCHEMA_ENTRY *   pSchemaEntry;

    pSchemaEntry = KCCSimSchemaTableLookup (attrType);

    if (pSchemaEntry != NULL) {

        pSchemaEntry->pdnObjCategory = KCCSimAlloc (pdnObjCategory->structLen);
        memcpy (
            pSchemaEntry->pdnObjCategory,
            pdnObjCategory,
            pdnObjCategory->structLen
            );

    }
}


VOID
KCCSimPrintStatistics(
    void
    )

/*++

Routine Description:

    Description

Arguments:

    void - 

Return Value:

    None

--*/

{
    FILETIME ftCreationTime;
    FILETIME ftExitTime;
    FILETIME ftKernelTime = { 0 };
    FILETIME ftUserTime = { 0 };
    FILETIME ftIsmUserTime;
    SYSTEMTIME systemTime;

    if (!GetThreadTimes( GetCurrentThread(),
                         &ftCreationTime,
                         &ftExitTime,
                         &ftKernelTime,
                         &ftUserTime)) {
        printf( "GetThreadTimes call failed, error %d\n", GetLastError() );
    }

#define PRINT_DWORD( x ) printf( "%s = %d\n", #x, x );
#define PRINT_DWORD_MB( x ) printf( "%s = %d bytes (%.2f MB)\n", #x, x, x / (1024.0 * 1024.0) );
    printf( "Statistics:\n" );
    PRINT_DWORD( g_Statistics.DirAddOps );
    PRINT_DWORD( g_Statistics.DirModifyOps );
    PRINT_DWORD( g_Statistics.DirRemoveOps );
    PRINT_DWORD( g_Statistics.DirReadOps );
    PRINT_DWORD( g_Statistics.DirSearchOps );
    PRINT_DWORD( g_Statistics.DebugMessagesEmitted );
    PRINT_DWORD( g_Statistics.LogEventsCalled );
    PRINT_DWORD( g_Statistics.LogEventsEmitted );
    PRINT_DWORD_MB( g_Statistics.SimBytesTotalAllocated );
    PRINT_DWORD_MB( g_Statistics.SimBytesOutstanding );
    PRINT_DWORD_MB( g_Statistics.SimBytesMaxOutstanding );
    PRINT_DWORD_MB( g_Statistics.ThreadBytesTotalAllocated );
    PRINT_DWORD_MB( g_Statistics.ThreadBytesOutstanding );
    PRINT_DWORD_MB( g_Statistics.ThreadBytesMaxOutstanding );
    PRINT_DWORD( g_Statistics.IsmGetTransportServersCalls );
    PRINT_DWORD( g_Statistics.IsmGetConnScheduleCalls );
    PRINT_DWORD( g_Statistics.IsmGetConnectivityCalls );
    PRINT_DWORD( g_Statistics.IsmFreeCalls );

    ZeroMemory( &systemTime, sizeof( SYSTEMTIME ) );
    if (!FileTimeToSystemTime( &ftKernelTime, &systemTime )) {
        printf( "FileTimeToSystemTime failed, error %d\n", GetLastError() );
    }
    printf( "kernel cpu time = %d:%d:%d.%d\n",
            systemTime.wHour,
            systemTime.wMinute,
            systemTime.wSecond,
            systemTime.wMilliseconds );

    Assert( sizeof( ULONGLONG) == sizeof( FILETIME ) );
    memcpy( &ftIsmUserTime, &(g_Statistics.IsmUserTime), sizeof( FILETIME ) );
    ZeroMemory( &systemTime, sizeof( SYSTEMTIME ) );
    if (!FileTimeToSystemTime( &ftIsmUserTime, &systemTime )) {
        printf( "FileTimeToSystemTime failed, error %d\n", GetLastError() );
    }
    printf( "Ism user cpu time = %d:%d:%d.%d\n",
            systemTime.wHour,
            systemTime.wMinute,
            systemTime.wSecond,
            systemTime.wMilliseconds );

    ZeroMemory( &systemTime, sizeof( SYSTEMTIME ) );
    if (!FileTimeToSystemTime( &ftUserTime, &systemTime )) {
        printf( "FileTimeToSystemTime failed, error %d\n", GetLastError() );
    }
    printf( "user cpu time = %d:%d:%d.%d\n",
            systemTime.wHour,
            systemTime.wMinute,
            systemTime.wSecond,
            systemTime.wMilliseconds );

} /* KCCSimPrintStatistics */


DWORD
KCCSimI_ISMGetTransportServers (
    IN  HANDLE                      hIsm,
    IN  LPCWSTR                     pszSiteDN,
    OUT ISM_SERVER_LIST **          ppServerList
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD status;

    g_Statistics.IsmGetTransportServersCalls++;

    status = SimI_ISMGetTransportServers( hIsm, pszSiteDN, ppServerList );

    return status;
}


DWORD
KCCSimI_ISMGetConnectionSchedule (
    IN  HANDLE                      hIsm,
    IN  LPCWSTR                     pszSite1DN,
    IN  LPCWSTR                     pszSite2DN,
    OUT ISM_SCHEDULE **             ppSchedule
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD status;

    g_Statistics.IsmGetConnScheduleCalls++;

    status = SimI_ISMGetConnectionSchedule( hIsm, pszSite1DN, pszSite2DN, ppSchedule );

    return status;
}


DWORD
KCCSimI_ISMGetConnectivity (
    IN  LPCWSTR                     pszTransportDN,
    OUT ISM_CONNECTIVITY **         ppConnectivity
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD status;
    FILETIME ftCreationTimeBefore, ftCreationTimeAfter;
    FILETIME ftExitTimeBefore, ftExitTimeAfter;
    FILETIME ftKernelTimeBefore = { 0 }, ftKernelTimeAfter = { 0 };
    FILETIME ftUserTimeBefore = { 0 }, ftUserTimeAfter = { 0 };
    ULONGLONG llBefore, llAfter;

    if (!GetThreadTimes( GetCurrentThread(),
                         &ftCreationTimeBefore,
                         &ftExitTimeBefore,
                         &ftKernelTimeBefore,
                         &ftUserTimeBefore)) {
        printf( "GetThreadTimes call failed, error %d\n", GetLastError() );
    }

    g_Statistics.IsmGetConnectivityCalls++;

    status = SimI_ISMGetConnectivity( pszTransportDN, ppConnectivity );

    if (!GetThreadTimes( GetCurrentThread(),
                         &ftCreationTimeAfter,
                         &ftExitTimeAfter,
                         &ftKernelTimeAfter,
                         &ftUserTimeAfter)) {
        printf( "GetThreadTimes call failed, error %d\n", GetLastError() );
    }

    Assert( sizeof( ULONGLONG) == sizeof( FILETIME ) );
    memcpy( &llBefore, &ftUserTimeBefore, sizeof( ULONGLONG ) );
    memcpy( &llAfter, &ftUserTimeAfter, sizeof( ULONGLONG ) );
    g_Statistics.IsmUserTime += (llAfter - llBefore);

    return status;
}


DWORD
KCCSimI_ISMFree (
    IN  VOID *                      pv
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD status;

    g_Statistics.IsmFreeCalls++;

    status = SimI_ISMFree( pv );

    return status;
}


DSTIME
GetSecondsSince1601( void )
{
    SYSTEMTIME sysTime;
    FILETIME   fileTime;

    DSTIME  dsTime = 0, tempTime = 0;

    GetSystemTime( &sysTime );
    
    // Get FileTime
    SystemTimeToFileTime(&sysTime, &fileTime);
    dsTime = fileTime.dwLowDateTime;
    tempTime = fileTime.dwHighDateTime;
    dsTime |= (tempTime << 32);

    // Ok. now we have the no. of 100 ns intervals since 1601
    // in dsTime. Convert to seconds and return
    
    return(dsTime/(10*1000*1000L));
}

// Stub out unused taskq functions

BOOL
InitTaskScheduler(
    IN  DWORD           cSpares,
    IN  SPAREFN_INFO *  pSpares,
    IN  BOOL            fRunImmediately
    )
{
    return TRUE;
}

BOOL
ShutdownTaskSchedulerWait(
    DWORD   dwWaitTimeInMilliseconds    // maximum time to wait for current
    )                                   //   task (if any) to complete
{
    return TRUE;
}

BOOL
DoInsertInTaskQueue(
    PTASKQFN    pfnTaskQFn,     // task to execute
    void *      pvParam,        // user-defined parameter to that task
    DWORD       cSecsFromNow,   // secs from now to execute
    BOOL        fReschedule,
    PCHAR       pfnName
    )
{
    return TRUE;
}

BOOL
DoInsertInTaskQueueDamped(
    PTASKQFN    pfnTaskQFn,     // task to execute
    void *      pvParam,        // user-defined parameter to that task
    DWORD       cSecsFromNow,   // secs from now to execute
    BOOL        fReschedule,
    PCHAR       pfnName,
    DWORD       cSecsDamped,
    PISMATCHED  IsMatchedParam,
    void *      pContext
    )
{
    return TRUE;
}

void
ShutdownTaskSchedulerTrigger( void )
{
    NOTHING;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\sim\util.h ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    dir.c

ABSTRACT:

    Contains assorted utilities.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#ifndef _KCCSIM_UTIL_H_
#define _KCCSIM_UTIL_H_

// Include the automatically generated error message file

#include "msg.h"

#define IO                          IN OUT
#define ARRAY_SIZE(x)               ((sizeof (x)) / (sizeof (x[0])))
#define KCCSIM_MAX_LTOA_CHARS       33
#define KCCSIM_MAX_LITOA_CHARS      64

#define KCCSIM_PARTITIONS_RDN       L"Partitions"
#define KCCSIM_SERVICES_CONTAINER   L"CN=Directory Service,CN=Windows NT,CN=Services,"
#define KCCSIM_AGGREGATE_RDN        L"Aggregate"

// Exception and error type codes

#define KCCSIM_EXCEPTION            0xE0020001
#define KCCSIM_ETYPE_WIN32          1
#define KCCSIM_ETYPE_INTERNAL       2

// Option flags

#define KCCSIM_NO_OPTIONS           0x00000000
#define KCCSIM_WRITE                0x00000001
#define KCCSIM_STRING_NAME_ONLY     0x00000002

// A few macros

#define KCCSIM_NEW(x) \
    (x *) KCCSimAlloc (sizeof (x))

#define KCCSIM_NEW_ARRAY(x,y) \
    (x *) KCCSimAlloc ((y) * sizeof (x))

#define KCCSIM_STRMEMSIZE(x) \
    (sizeof (CHAR) * (strlen (x) + 1))

#define KCCSIM_WCSMEMSIZE(x) \
    (sizeof (WCHAR) * (wcslen (x) + 1))

#define KCCSIM_STRDUP(src)              \
    strcpy ((LPSTR) KCCSimAlloc (KCCSIM_STRMEMSIZE (src)), src)

#define KCCSIM_WCSDUP(src)              \
    wcscpy ((LPWSTR) KCCSimAlloc (KCCSIM_WCSMEMSIZE (src)), src)

#define KCCSIM_CHKERR(x) {              \
    DWORD _dwWin32Err = (x);            \
    if (NO_ERROR != _dwWin32Err)        \
        KCCSimException (               \
            KCCSIM_ETYPE_WIN32,         \
            _dwWin32Err);               \
}

#define KCCSIM_THNEW(x) \
    (x *) KCCSimThreadAlloc (sizeof (x))

// Statistics

typedef struct _STATISTICS {
    DWORD DirAddOps;
    DWORD DirModifyOps;
    DWORD DirRemoveOps;
    DWORD DirReadOps;
    DWORD DirSearchOps;
    DWORD DebugMessagesEmitted;
    DWORD LogEventsCalled;
    DWORD LogEventsEmitted;
    DWORD SimBytesTotalAllocated;
    DWORD SimBytesOutstanding;
    DWORD SimBytesMaxOutstanding;
    DWORD ThreadBytesTotalAllocated;
    DWORD ThreadBytesOutstanding;
    DWORD ThreadBytesMaxOutstanding;
    ULONGLONG IsmUserTime;
    DWORD IsmGetTransportServersCalls;
    DWORD IsmGetConnScheduleCalls;
    DWORD IsmGetConnectivityCalls;
    DWORD IsmFreeCalls;
} KCCSIM_STATISTICS, *PKCCSIM_STATISTICS;

extern KCCSIM_STATISTICS g_Statistics;

// Function prototypes

VOID
KCCSimQuiet (
    IN  BOOL                        bQuiet
    );

DWORD
KCCSimHandleException (
    IN  const EXCEPTION_POINTERS *  pExceptionPtrs,
    OUT PDWORD                      pdwErrType OPTIONAL,
    OUT PDWORD                      pdwErrCode OPTIONAL
    );

LPCWSTR
KCCSimMsgToString (
    IN  DWORD                       dwErrType,
    IN  DWORD                       dwMessageCode,
    ...
    );

VOID
KCCSimPrintMessage (
    IN  DWORD                       dwMessageCode,
    ...
    );

VOID
KCCSimException (
    IN  DWORD                       dwErrType,
    IN  DWORD                       dwErrCode,
    ...
    );

VOID
KCCSimPrintExceptionMessage (
    VOID
    );

VOID
KCCSimSetDebugLog (
    IN  LPCWSTR                     pwszFn OPTIONAL,
    IN  ULONG                       ulDebugLevel,
    IN  ULONG                       ulLogLevel
    );

PVOID
KCCSimTableAlloc (
    IN  RTL_GENERIC_TABLE *         pTable,
    IN  CLONG                       ByteSize
    );

VOID
KCCSimTableFree (
    IN  RTL_GENERIC_TABLE *         pTable,
    IN  PVOID                       Buffer
    );

BOOL
KCCSimParseCommand (
    IN  LPCWSTR                     pwsz,
    IN  ULONG                       ulArg,
    IO  LPWSTR                      pwszBuf
    );

LPWSTR
KCCSimAllocWideStr (
    IN  UINT                        CodePage,
    IN  LPCSTR                      psz
    );

LPSTR
KCCSimAllocNarrowStr (
    IN  UINT                        CodePage,
    IN  LPCWSTR                     pwsz
    );

PDSNAME
KCCSimAllocDsname (
    IN  LPCWSTR                     pwszDn OPTIONAL
    );

PDSNAME
KCCSimAllocDsnameFromNarrow (
    IN  LPCSTR                      pszDn OPTIONAL
    );

LPWSTR
KCCSimQuickRDNOf (
    IN  const DSNAME *              pdn,
    IO  LPWSTR                      pwszBuf
    );

LPWSTR
KCCSimQuickRDNBackOf (
    IN  const DSNAME *              pdn,
    IN  ULONG                       ulBackBy,
    IO  LPWSTR                      pwszBuf
    );

PDSNAME
KCCSimAllocAppendRDN (
    IN  const DSNAME *              pdnOld,
    IN  LPCWSTR                     pwszNewRDN,
    IN  ATTRTYP                     attClass
    );

LPWSTR
KCCSimAllocDsnameToDNSName (
    IN  const DSNAME *              pdn
    );

VOID
KCCSimCopyGuidAndSid (
    IO  PDSNAME                     pdnDst,
    IN  const DSNAME *              pdnSrc
    );

VOID
KCCSimInitializeSchema (
    VOID
    );

LPCWSTR
KCCSimAttrTypeToString (
    IN  ATTRTYP                     attrType
    );

ATTRTYP
KCCSimStringToAttrType (
    IN  LPCWSTR                     pwszString
    );

ATTRTYP
KCCSimNarrowStringToAttrType (
    IN  LPCSTR                      pszString
    );

ULONG
KCCSimAttrSyntaxType (
    IN  ATTRTYP                     attrType
    );

LPCWSTR
KCCSimAttrSchemaRDN (
    IN  ATTRTYP                     attrType
    );

ATTRTYP
KCCSimAttrSuperClass (
    IN  ATTRTYP                     attrType
    );

PDSNAME
KCCSimAttrObjCategory (
    IN  ATTRTYP                     attrType
    );

VOID
KCCSimSetObjCategory (
    IN  ATTRTYP                     attrType,
    IN  const DSNAME *              pdnObjCategory
    );

VOID
KCCSimPrintStatistics(
    void
    );

#endif // _KCCSIM_UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\sim\schtable\schtable.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    schtable.c

ABSTRACT:

    Automatically generates the schema mapping source
    and header files that are used by KCCSim.  Reads
    its input from mkdit.ini in ds\setup.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include "schtable.h"

LPWSTR
SchTableAdvanceToNextString (
    IN  LPWSTR                      pwszCurString
    )
/*++

Routine Description:

    Finds the start of the next string in an INI profile section.

Arguments:

    IN  pwszCurString       - A pointer to the current string.

Return Value:

    If there are more strings in this profile section after
    pwszCurString, returns a pointer to the next one.  Otherwise
    returns NULL.

--*/
{
    while (*(pwszCurString++) != L'\0')
        ;

    if (*pwszCurString == L'\0') {
        return NULL;
    }

    else return pwszCurString;
}

ULONG
SchTableHexToInt (
    IN  WCHAR                       wc
    )
//
// Quick hack to convert a hex digit ('b') to an integer (11).
//
{
    switch (towlower (wc)) {
        case L'0': return 0;
        case L'1': return 1;
        case L'2': return 2;
        case L'3': return 3;
        case L'4': return 4;
        case L'5': return 5;
        case L'6': return 6;
        case L'7': return 7;
        case L'8': return 8;
        case L'9': return 9;
        case L'a': return 10;
        case L'b': return 11;
        case L'c': return 12;
        case L'd': return 13;
        case L'e': return 14;
        case L'f': return 15;
        default  : return 0;
    }
}

LPCWSTR
SchTableHexStringToSyntax (
    IN  LPCWSTR                     pwszHexString
    )
/*++

Routine Description:

    Converts a hex string such as those found in mkdit.ini
    to an attribute syntax type.

Arguments:

    IN  pwszHexString       - The hex-encoded string.

Return Value:

    The string representing the constant symbol for this
    attribute syntax type (e.g. "SYNTAX_DISTNAME").

--*/
{
    ULONG                               ulSyntax;

    // Make sure the string is properly formatted.
    if (pwszHexString == NULL       ||
        wcslen (pwszHexString) != 8 ||
        pwszHexString[0] != L'\\'   ||
        pwszHexString[1] != L'x') {
        return L"0";
    }

    // We just assume it's the last two digits of the string -
    // this will be true unless something in mkdit.ini changes
    ulSyntax = 16 * SchTableHexToInt (pwszHexString[6])
                  + SchTableHexToInt (pwszHexString[7]);

    // Return the name if we know it
    if (ulSyntax >= 0 && ulSyntax < SCHTABLE_MAX_SUPPORTED_SYNTAX) {
        return SCHTABLE_NTDSA_SYNTAX_NAME[ulSyntax];
    } else {
        return L"0";
    }
}

VOID
SchTableCreateGenericLdapName (
    IN  LPCWSTR                         pwszSchemaRDN,
    IO  LPWSTR                          pwszLdapDisplayName
    )
/*++

Routine Description:

    Converts a schema RDN ("Sub-Refs") to the corresponding
    generic LDAP display name ("subRefs").

Arguments:

    pwszSchemaRDN       - The schema RDN.
    pwszLdapDisplayName - Pointer to a preallocated buffer where
                          the LDAP display name is to be stored.
                          Since the generic LDAP display name is
                          never longer than the common name, this
                          can safely be of length
                          wcslen (pwszSchemaRDN).

Return Value:

    None.

--*/
{
    *pwszLdapDisplayName = towlower (*pwszSchemaRDN);
    pwszLdapDisplayName++;
    if (*pwszSchemaRDN == L'\0') {
        return;
    }

    do {

        pwszSchemaRDN++;
        if (*pwszSchemaRDN != L'-') {
            *pwszLdapDisplayName = *pwszSchemaRDN;
            pwszLdapDisplayName++;
        }

    } while (*pwszSchemaRDN != L'\0');

}

VOID
SchTableCreateAttributeConstant (
    IN  LPCWSTR                     pwszSchemaRDN,
    IO  LPWSTR                      pwszAttConstant,
    IN  BOOL                        bIsClass
    )
/*++

Routine Description:

    Converts a schema RDN ("Sub-Refs") to the corresponding
    attribute constant name ("ATT_SUB_REFS").

Arguments:

    pwszSchemaRDN       - The schema RDN.
    pwszAttConstant     - Pointer to a preallocated buffer where
                          the attribute constant name is to be stored.
                          Since the attribute constant name is
                          never longer than the common name, this
                          can safely be of length
                          wcslen (pwszSchemaRDN).
    bIsClass            - TRUE if this is a class, FALSE if it's an attribute.

Return Value:

    None.

--*/
{
    LPCWSTR                             pwszPrefix;

    pwszPrefix = (bIsClass ? L"CLASS_" : L"ATT_");

    swprintf (pwszAttConstant, pwszPrefix);
    pwszAttConstant += wcslen (pwszPrefix);

    while (*pwszSchemaRDN != L'\0') {

        if (*pwszSchemaRDN == L'-') {
            *pwszAttConstant = L'_';
        } else {
            *pwszAttConstant = towupper (*pwszSchemaRDN);
        }
        
        pwszSchemaRDN++;
        pwszAttConstant++;

    }

    *pwszAttConstant = L'\0';
}

BOOL
SchTableAddRow (
    IN  FILE *                      fpSource,
    IN  BOOL                        bIsLastRow,
    IN  LPCWSTR                     pwszSchemaRDN,
    OUT PULONG                      pulLdapNameLen,
    OUT PULONG                      pulSchemaRDNLen
    )
/*++

Routine Description:

    Adds a row to the schema mapping table.

Arguments:

    fpSource            - Pointer to the .c file.
    bIsLastRow          - TRUE if this is the last row to output.
    pwszSchemaRDN       - The name of the schema RDN.
    pulLdapNameLen      - The length of the LDAP display name.
    pulSchemaRDNLen     - The length of the schema RDN.

Return Value:

    TRUE if the row was successfully added.

--*/
{
    static WCHAR                        wszProfile[SCHTABLE_PROFILE_BUFFER_SIZE],
                                        wszQuotedLdapNameBuf[SCHTABLE_STRING_BUFFER_SIZE],
                                        wszQuotedSchemaRDNBuf[SCHTABLE_STRING_BUFFER_SIZE],
                                        wszAttConstantBuf[SCHTABLE_STRING_BUFFER_SIZE],
                                        wszBuf[SCHTABLE_STRING_BUFFER_SIZE],
                                        wszSubClassOfBuf[SCHTABLE_STRING_BUFFER_SIZE];

    LPWSTR                              pwszStringAt, pwszNextString, pwszToken,
                                        pwszLdapDisplayName, pwszSyntax, pwszSubClassOf;

    BOOL                                bIsClass;

    pwszLdapDisplayName = NULL;
    pwszSyntax = NULL;
    pwszSubClassOf = NULL;
    bIsClass = FALSE;

    if (GetPrivateProfileSectionW (
            pwszSchemaRDN,
            wszProfile,
            SCHTABLE_PROFILE_BUFFER_SIZE,
            SCHTABLE_MKDIT_INI_FILEPATH
            ) == SCHTABLE_PROFILE_BUFFER_SIZE - 2) {
        wprintf (L"SCHTABLE: Could not process attribute %s\n"
                 L"          because the default buffer is not large enough.\n",
                 pwszSchemaRDN);
        return FALSE;
    }

    pwszStringAt = wszProfile;
    while (pwszStringAt != NULL) {

        // Find the start of the next string, since we're
        // going to pick this one apart with wcstok
        pwszNextString = SchTableAdvanceToNextString (pwszStringAt);
        pwszToken = wcstok (pwszStringAt, L"=");

        // If this string has relevant information, remember where it is
        if (pwszToken != NULL) {
            if (_wcsicmp (pwszToken, SCHTABLE_MKDIT_KEY_LDAP_DISPLAY_NAME) == 0) {
                pwszLdapDisplayName = wcstok (NULL, L"=");
            } else if (_wcsicmp (pwszToken, SCHTABLE_MKDIT_KEY_ATTRIBUTE_SYNTAX) == 0) {
                pwszSyntax = wcstok (NULL, L"=");
            } else if (_wcsicmp (pwszToken, SCHTABLE_MKDIT_KEY_SUB_CLASS_OF) == 0) {
                bIsClass = TRUE;
                pwszSubClassOf = wcstok (NULL, L"=");
            }
        }

        pwszStringAt = pwszNextString;

    }

    // Create the attribute constant name
    SchTableCreateAttributeConstant (pwszSchemaRDN, wszAttConstantBuf, bIsClass);

    // Create the subclassof constant name
    if (pwszSubClassOf != NULL) {
        SchTableCreateAttributeConstant (pwszSubClassOf, wszSubClassOfBuf, TRUE);
    } else {
        swprintf (wszSubClassOfBuf, L"0");
    }

    // Quote the schema RDN name
    swprintf (wszQuotedSchemaRDNBuf, L"L\"%s\"", pwszSchemaRDN);
    *pulSchemaRDNLen = wcslen (pwszSchemaRDN);

    // If we didn't find an LDAP display name, substitute a generated generic one
    if (pwszLdapDisplayName == NULL) {
        SchTableCreateGenericLdapName (pwszSchemaRDN, wszBuf);
        pwszLdapDisplayName = wszBuf;
    }

    // Quote the LDAP display name
    swprintf (wszQuotedLdapNameBuf, L"L\"%s\"", pwszLdapDisplayName);
    *pulLdapNameLen = wcslen (pwszLdapDisplayName);

    fwprintf (
        fpSource,
        L"    { %-*s, %-*s, %-*s, %-*s, %-*s }%c\n",
        SCHTABLE_NAME_FIELD_WIDTH,
        wszQuotedLdapNameBuf,
        SCHTABLE_NAME_FIELD_WIDTH,
        wszAttConstantBuf,
        SCHTABLE_MAX_SYNTAX_NAME_LEN,
        SchTableHexStringToSyntax (pwszSyntax),
        SCHTABLE_NAME_FIELD_WIDTH,
        wszQuotedSchemaRDNBuf,
        SCHTABLE_NAME_FIELD_WIDTH,
        wszSubClassOfBuf,
        bIsLastRow ? L' ' : L','
        );

    return TRUE;
}

int
__cdecl
wmain (
    IN  int                         argc,
    IN  LPWSTR *                    argv
    )
/*++

Routine Description:

    wmain () for schtable.exe.

Arguments:

    argc                - Argument count.
    argv                - Argument values.

Return Value:

    Win32 exit code.

--*/
{
    FILE *                              fpHeader;
    FILE *                              fpSource;
    ULONG                               ulNumRows, ulLdapNameLen, ulSchemaRDNLen,
                                        ulMaxLdapNameLen, ulMaxSchemaRDNLen;

    WCHAR                               wszSchemaProfile[SCHTABLE_PROFILE_BUFFER_SIZE];
    LPWSTR                              pwszStringAt, pwszNextString, pwszToken;

    // Keep track of the longest name length.
    ulMaxLdapNameLen = 0;
    ulMaxSchemaRDNLen = 0;

    fpHeader = _wfopen (SCHTABLE_OUTPUT_HEADER_FILE, L"w");
    fpSource = _wfopen (SCHTABLE_OUTPUT_SOURCE_FILE, L"w");

    fwprintf (fpHeader, SCHTABLE_COMMENT, SCHTABLE_OUTPUT_HEADER_FILE);

    fwprintf (fpSource, SCHTABLE_COMMENT, SCHTABLE_OUTPUT_SOURCE_FILE);
    fwprintf (fpSource, SCHTABLE_INITIAL);

    ulNumRows = 0;
    if (GetPrivateProfileSectionW (
            SCHTABLE_MKDIT_PROFILE_SCHEMA,
            wszSchemaProfile,
            SCHTABLE_PROFILE_BUFFER_SIZE,
            SCHTABLE_MKDIT_INI_FILEPATH
            ) == SCHTABLE_PROFILE_BUFFER_SIZE - 2) {
        wprintf (L"SCHTABLE: Default buffer size is not large enough to hold\n"
                 L"          the entire schema table.\n");
    }

    pwszStringAt = wszSchemaProfile;
    while (pwszStringAt != NULL) {

        pwszNextString = SchTableAdvanceToNextString (pwszStringAt);
        pwszToken = wcstok (pwszStringAt, L"=");
        if (pwszToken != NULL &&
            _wcsicmp (pwszToken, SCHTABLE_MKDIT_KEY_CHILD) == 0) {

            // Found a child.
            pwszToken = wcstok (NULL, L"=");
            if (pwszToken != NULL &&
                // Ignore the aggregate attribute if we find it
                _wcsicmp (pwszToken, SCHTABLE_RDN_AGGREGATE) != 0) {
                if (SchTableAddRow (
                    fpSource,
                    pwszNextString == NULL,
                    pwszToken,
                    &ulLdapNameLen,
                    &ulSchemaRDNLen
                    )) {
                    // Successfully added a row
                    ulNumRows++;
                    if (ulLdapNameLen > ulMaxLdapNameLen) {
                        ulMaxLdapNameLen = ulLdapNameLen;
                    }
                    if (ulSchemaRDNLen > ulMaxSchemaRDNLen) {
                        ulMaxSchemaRDNLen = ulSchemaRDNLen;
                    }
                }
            }

        }

        pwszStringAt = pwszNextString;
    }

    fwprintf (
        fpSource,
        SCHTABLE_FINAL
        );

    fwprintf (
        fpHeader,
        SCHTABLE_HEADER,
        ulMaxLdapNameLen,
        ulMaxSchemaRDNLen,
        ulNumRows
        );

    fclose (fpSource);
    fclose (fpHeader);

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\sim\schtable\schtable.h ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    schtable.h

ABSTRACT:

    Header file for schtable.

CREATED:

    08/01/99        Aaron Siegel (t-aarons)

REVISION HISTORY:

--*/

#define IO                          IN OUT

// The pathname of mkdit.ini:
const LPWSTR SCHTABLE_MKDIT_INI_FILEPATH =
      L"..\\..\\..\\schema\\mkdit.ini";
// Names of the source and header files to output:
const LPWSTR SCHTABLE_OUTPUT_HEADER_FILE           = L"schmap.h";
const LPWSTR SCHTABLE_OUTPUT_SOURCE_FILE           = L"schmap.c";
// Some keys that are used to search through mkdit.ini:
const LPWSTR SCHTABLE_MKDIT_PROFILE_SCHEMA         = L"SCHEMA";
const LPWSTR SCHTABLE_MKDIT_KEY_CHILD              = L"CHILD";
const LPWSTR SCHTABLE_MKDIT_KEY_COMMON_NAME        = L"Common-Name";
const LPWSTR SCHTABLE_MKDIT_KEY_LDAP_DISPLAY_NAME  = L"LDAP-Display-Name";
const LPWSTR SCHTABLE_MKDIT_KEY_ATTRIBUTE_SYNTAX   = L"Attribute-Syntax";
const LPWSTR SCHTABLE_MKDIT_KEY_SUB_CLASS_OF       = L"Sub-Class-Of";
// We want to ignore the Aggregate attribute; here's its RDN:
const LPWSTR SCHTABLE_RDN_AGGREGATE                = L"Aggregate";

#define SCHTABLE_PROFILE_BUFFER_SIZE                32768
#define SCHTABLE_STRING_BUFFER_SIZE                 128

#define SCHTABLE_NAME_FIELD_WIDTH                   45

#define SCHTABLE_MAX_SUPPORTED_SYNTAX               18
#define SCHTABLE_MAX_SYNTAX_NAME_LEN                34

// These refer to the names of the SYNTAX_* constants from
// ntdsa.h.  Referring to the syntaxes by name rather than
// by number makes the resulting file more readable.
const WCHAR SCHTABLE_NTDSA_SYNTAX_NAME
            [SCHTABLE_MAX_SUPPORTED_SYNTAX]
            [1+SCHTABLE_MAX_SYNTAX_NAME_LEN] = {
      
      L"SYNTAX_UNDEFINED_TYPE",
      L"SYNTAX_DISTNAME_TYPE",
      L"SYNTAX_OBJECT_ID_TYPE",
      L"SYNTAX_CASE_STRING_TYPE",
      L"SYNTAX_NOCASE_STRING_TYPE",
      L"SYNTAX_PRINT_CASE_STRING_TYPE",
      L"SYNTAX_NUMERIC_STRING_TYPE",
      L"SYNTAX_DISTNAME_BINARY_TYPE",
      L"SYNTAX_BOOLEAN_TYPE",
      L"SYNTAX_INTEGER_TYPE",
      L"SYNTAX_OCTET_STRING_TYPE",
      L"SYNTAX_TIME_TYPE",
      L"SYNTAX_UNICODE_TYPE",
      L"SYNTAX_ADDRESS_TYPE",
      L"SYNTAX_DISTNAME_STRING_TYPE",
      L"SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE",
      L"SYNTAX_I8_TYPE",
      L"SYNTAX_SID_TYPE"

};

const LPWSTR SCHTABLE_COMMENT =

      L"/*++\n"
      L"\n"
      L"Copyright (c) 2000 Microsoft Corporation.\n"
      L"All rights reserved.\n"
      L"\n"
      L"MODULE NAME:\n"
      L"\n"
      L"    %s\n"
      L"\n"
      L"ABSTRACT:\n"
      L"\n"
      L"    This file was automatically generated by schtable.exe.\n"
      L"\n"
      L"--*/\n"
      L"\n";

const LPWSTR SCHTABLE_HEADER =

      L"#ifndef _KCCSIM_SCHMAP_H_\n"
      L"#define _KCCSIM_SCHMAP_H_\n"
      L"\n"
      L"#define SCHTABLE_MAX_LDAPNAME_LEN       %d\n"
      L"#define SCHTABLE_MAX_SCHEMANAME_LEN     %d\n"
      L"#define SCHTABLE_NUM_ROWS               %d\n"
      L"\n"
      L"struct _SCHTABLE_MAPPING {\n"
      L"    const WCHAR                         wszLdapDisplayName[1+SCHTABLE_MAX_LDAPNAME_LEN];\n"
      L"    const ATTRTYP                       attrType;\n"
      L"    const ULONG                         ulSyntax;\n"
      L"    const WCHAR                         wszSchemaRDN[1+SCHTABLE_MAX_SCHEMANAME_LEN];\n"
      L"    const ATTRTYP                       superClass;\n"
      L"};\n"
      L"\n"
      L"extern const struct _SCHTABLE_MAPPING   schTable[];\n"
      L"\n"
      L"#endif // _KCCSIM_SCHMAP_H_\n";

const LPWSTR SCHTABLE_INITIAL =

      L"#include <ntdspch.h>\n"
      L"#include <ntdsa.h>\n"
      L"#include <attids.h>\n"
      L"#include \"schmap.h\"\n"
      L"\n"
      L"// Define symbols missing from attids.h\n"
      L"#define ATT_ENTRY_TTL 0xffffffff\n"
      L"#define CLASS_DYNAMIC_OBJECT 0xffffffff\n"
      L"\n"
      L"const struct _SCHTABLE_MAPPING          schTable[] = {\n"
      L"\n";

const LPWSTR SCHTABLE_FINAL =

      L"\n"
      L"};\n";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\abandon.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    abandon.cxx handle abandon requests to an LDAP server

Abstract:

   This module implements the LDAP abandon APIs.

Author:

    Andy Herron (andyhe)        02-Jul-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

ULONG
SendLdapAbandon (
    PLDAP_CONN Connection,
    ULONG msgid
    );


ULONG __cdecl
ldap_abandon (
    LDAP *ExternalHandle,
    ULONG msgid
    )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);
    if (!connection && ExternalHandle)
    {
        return LDAP_PARAM_ERROR;
    }

    err = LdapAbandon( connection, msgid, TRUE );

    if (connection)
    {
        DereferenceLdapConnection( connection );
    }

    return err;
}

ULONG
LdapAbandon (
    PLDAP_CONN connection,
    ULONG msgid,
    BOOLEAN SendAbandon
    )
{
    PLDAP_REQUEST request = NULL;
    PLIST_ENTRY listEntry;
    ULONG err = LDAP_SUCCESS;
    USHORT connCount;
    PREFERRAL_TABLE_ENTRY referral;
    PLDAP_MESSAGEWAIT waitStructure = NULL;

    if (msgid == 0) {

        err = LDAP_PARAM_ERROR;
        SetConnectionError( connection, err, NULL );
        goto exit_abandon;
    }

    request = FindLdapRequest( (LONG) msgid );

    if (request == NULL) {

        err = LDAP_OTHER;                   // we've already freed it?
        SetConnectionError( connection, err, NULL );
        goto exit_abandon;
    }

    ACQUIRE_LOCK( &request->Lock );

    request->Abandoned = TRUE;
    ClearPendingListForRequest( request );

    RELEASE_LOCK( &request->Lock );
    
    if (SendAbandon) {

        //
        //  send an abandon request to each connection that we have referenced for
        //  this request
        //

        err = SendLdapAbandon( request->PrimaryConnection, msgid );

        referral = request->ReferralConnections;
        if (referral != NULL) {

            for (connCount = 0;
                 connCount < request->ReferralTableSize;
                 connCount++ ) {

                if (referral->ReferralServer != NULL) {

                    (VOID) SendLdapAbandon( referral->ReferralServer, msgid );
                }

                referral++;     // on to next entry
            }
        }
    } else {

        err = LDAP_SUCCESS;
    }


    CloseLdapRequest( request );
    DereferenceLdapRequest( request );

    //
    //  free any waiters that are waiting for this message
    //

    ACQUIRE_LOCK( &ConnectionListLock );

    listEntry = GlobalListWaiters.Flink;

    while (listEntry != &GlobalListWaiters) {

        waitStructure = CONTAINING_RECORD( listEntry,
                                           LDAP_MESSAGEWAIT,
                                           WaitListEntry );
        listEntry = listEntry->Flink;

        if (waitStructure->MessageNumber == msgid) {

            waitStructure->Satisfied = TRUE;
            SetEvent( waitStructure->Event );
        }
    }

    RELEASE_LOCK( &ConnectionListLock );

    LdapWakeupSelect();

exit_abandon:

    err = ((err == LDAP_SUCCESS) ? 0 : (ULONG) -1 );

    return err;
}

ULONG
SendLdapAbandon (
    PLDAP_CONN Connection,
    ULONG msgid
    )
{
    ULONG err = LDAP_SUCCESS;
    CLdapBer *lber = NULL;
    LONG abandonMessageId;
    ULONG hr = LDAP_PARAM_ERROR;

    if ((Connection != NULL) &&
        (Connection->TcpHandle != INVALID_SOCKET)) {

        hr = NOERROR;

        //
        //  Send the server an abandon message if we actually have a connection
        //  to the server.
        //
        //  the ldapv2 abandon message looks like this :
        //
        //  AbandonRequest ::= [APPLICATION 16] MessageID
        //

        lber = new CLdapBer( Connection->publicLdapStruct.ld_version );

        GET_NEXT_MESSAGE_NUMBER( abandonMessageId );

        if (lber != NULL) {

            hr = lber->HrStartWriteSequence();

            if (hr != NOERROR) {
                 hr = LDAP_ENCODING_ERROR;
                 goto returnError;
            }

            hr = lber->HrAddValue( abandonMessageId );

            if (hr != NOERROR) {
                 hr = LDAP_ENCODING_ERROR;
                 goto returnError;
            }

            hr = lber->HrAddValue((LONG) msgid, LDAP_ABANDON_CMD );

            if (hr != NOERROR) {
                 hr = LDAP_ENCODING_ERROR;
                 goto returnError;
            }

            hr = lber->HrEndWriteSequence();

            if (hr != NOERROR) {
                 hr = LDAP_ENCODING_ERROR;
                 goto returnError;
            }

            //
            //  send the abandon request.
            //

            ACQUIRE_LOCK( &Connection->ReconnectLock );

            err = LdapSend( Connection, lber );

            RELEASE_LOCK( &Connection->ReconnectLock );

            if (err != LDAP_SUCCESS) {

                IF_DEBUG(NETWORK_ERRORS) {
                    LdapPrint2( "SendLdapAbandon connection 0x%x send with error of 0x%x.\n",
                                Connection, err );
                }
            }

            goto returnError;

        } else {

            IF_DEBUG(OUTMEMORY) {
                LdapPrint1( "SendLdapAbandonn connection 0x%x could not allocate unbind.\n",
                            Connection );
            }
            err = LDAP_NO_MEMORY;
        }
    }

returnError:

    SetConnectionError( Connection, hr, NULL );

    if (lber != NULL) {

       delete lber;
    }

    return (hr == NOERROR) ? err : hr;
}

// abandon.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\add.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    add.cxx handle add requests to an LDAP server

Abstract:

   This module implements the LDAP add APIs.

Author:

    Andy Herron (andyhe)        02-Jul-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

ULONG
EncodeAddList (
    CLdapBer *Lber,
    LDAPModW *AttributeList[],
    BOOLEAN Unicode
    );

ULONG
LdapAdd (
    PLDAP_CONN connection,
    PWCHAR DistinguishedName,
    LDAPModW *AttributeList[],
    BOOLEAN Unicode,
    BOOLEAN Synchronous,
    PLDAPControlW *ServerControls,
    PLDAPControlW *ClientControls,
    ULONG   *MessageNumber
    )
//
//  This allows a client to add an entry to the tree.  Note that if Unicode
//  is FALSE, then the AttributeList does not point to a list of Unicode
//  attributes, but rather a list of single byte attributes.
//
{
    PLDAP_REQUEST request = NULL;
    ULONG messageNumber;
    ULONG err;

    ASSERT(connection != NULL);

    if (MessageNumber == NULL) {

        return LDAP_PARAM_ERROR;
    }

    *MessageNumber = (ULONG) -1;

    err = LdapConnect( connection, NULL, FALSE );

    if (err != 0) {
       return err;
    }

    SetConnectionError( connection, LDAP_SUCCESS, NULL );

    request = LdapCreateRequest( connection, LDAP_ADD_CMD );

    if (request == NULL) {

        IF_DEBUG(OUTMEMORY) {
            LdapPrint1( "ldap_add connection 0x%x couldn't allocate request.\n", connection);
        }
        err = LDAP_NO_MEMORY;
        SetConnectionError( connection, err, NULL );
        return err;
    }

    messageNumber = request->MessageId;

    request->Synchronous = Synchronous;

    request->add.Unicode = Unicode;

    err = LDAP_SUCCESS;

    if ((ServerControls != NULL) || (ClientControls != NULL)) {

        err = LdapCheckControls( request,
                                 ServerControls,
                                 ClientControls,
                                 Unicode,
                                 0 );

        if (err != LDAP_SUCCESS) {

            IF_DEBUG(CONTROLS) {
                LdapPrint2( "ldap_add connection 0x%x trouble with SControl, err 0x%x.\n",
                            connection, err );
            }
        }
    }

    if (err == LDAP_SUCCESS) {

        if (Synchronous || (request->ChaseReferrals == 0)) {

            request->AllocatedParms = FALSE;
            request->OriginalDN = DistinguishedName;
            request->add.AttributeList = AttributeList;

        } else {

            request->AllocatedParms = TRUE;

            if (DistinguishedName != NULL) {

                request->OriginalDN = ldap_dup_stringW( DistinguishedName, 0, LDAP_UNICODE_SIGNATURE );

                if (request->OriginalDN == NULL) {

                    err = LDAP_NO_MEMORY;
                }
            }
            if ( err == LDAP_SUCCESS ) {

                err = LdapDupLDAPModStructure(  AttributeList,
                                                Unicode,
                                                &request->add.AttributeList );
            }
        }
    }

    if (err == LDAP_SUCCESS) {

        START_LOGGING;
        DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=%d][OP=ldap_add][DN=%ws][ST=%I64d]",
               request->MessageId, DistinguishedName, request->RequestTime));
        LogAttributesAndControls(NULL, AttributeList, ServerControls, Unicode);
        DSLOG((DSLOG_FLAG_NOTIME,"[-]\n"));
        END_LOGGING;

        err = SendLdapAdd(  request,
                            connection,
                            request->OriginalDN,
                            request->add.AttributeList,
                            (CLdapBer **)&request->BerMessageSent,
                            request->add.Unicode,
                            0 );
    }

    if (err != LDAP_SUCCESS) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "ldap_add connection 0x%x errored with 0x%x.\n",
                        connection, err );
        }

        DSLOG((0,"[+][ID=%d][ET=%I64d][ER=%d][-]\n",request->MessageId,LdapGetTickCount(), err));

        messageNumber = (ULONG) -1;
        SetConnectionError( connection, err, NULL );

        CloseLdapRequest( request );
    }

    *MessageNumber = messageNumber;

    DereferenceLdapRequest( request );

    return err;
}


ULONG __cdecl
ldap_addW (
    LDAP *ExternalHandle,
    PWCHAR DistinguishedName,
    LDAPModW *AttributeList[]
    )
//
//  This is the client API to allow adding objects to the directory.
//
{
    ULONG err;
    ULONG msgId;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err =  LdapAdd( connection,
                    DistinguishedName,
                    AttributeList,
                    TRUE,
                    FALSE,
                    NULL,
                    NULL,
                    &msgId
                    );

    DereferenceLdapConnection( connection );

    return msgId;
}

ULONG __cdecl
ldap_add (
    LDAP *ExternalHandle,
    PCHAR DistinguishedName,
    LDAPModA *AttributeList[]
    )
//
//  This is the client API to allow adding objects to the directory.
//
{
    ULONG err;
    ULONG msgId = (ULONG) -1;

    err =  ldap_add_extA(   ExternalHandle,
                            DistinguishedName,
                            AttributeList,
                            NULL,
                            NULL,
                            &msgId
                            );
    return msgId;
}

ULONG __cdecl
ldap_add_sW (
    LDAP *ExternalHandle,
    PWCHAR DistinguishedName,
    LDAPModW *AttributeList[]
    )
{
    return ldap_add_ext_sW(  ExternalHandle,
                             DistinguishedName,
                             AttributeList,
                             NULL,
                             NULL
                             );
}

ULONG __cdecl
ldap_add_s (
    LDAP *ExternalHandle,
    PCHAR DistinguishedName,
    LDAPModA *AttributeList[]
    )
//
//  This is the client API to allow adding objects to the directory.
//
{
    return ldap_add_ext_sA( ExternalHandle,
                            DistinguishedName,
                            AttributeList,
                            NULL,
                            NULL
                            );
}

WINLDAPAPI ULONG LDAPAPI ldap_add_extW(
        LDAP *ExternalHandle,
        PWCHAR DistinguishedName,
        LDAPModW *AttributeList[],
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        ULONG           *MessageNumber
        )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {

        return LDAP_PARAM_ERROR;
    }

    err =  LdapAdd( connection,
                    DistinguishedName,
                    AttributeList,
                    TRUE,
                    FALSE,
                    ServerControls,
                    ClientControls,
                    MessageNumber
                    );

    DereferenceLdapConnection( connection );

    return err;
}

WINLDAPAPI ULONG LDAPAPI ldap_add_extA
(
        LDAP *ExternalHandle,
        PCHAR DistinguishedName,
        LDAPModA *AttributeList[],
        PLDAPControlA   *ServerControls,
        PLDAPControlA   *ClientControls,
        ULONG           *MessageNumber
        )
{
    ULONG err;
    PWCHAR wName = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if ((connection == NULL) || (MessageNumber == NULL)) {

        err = LDAP_PARAM_ERROR;
        goto error;
    }

    *MessageNumber = (ULONG) -1;

    err = ToUnicodeWithAlloc( DistinguishedName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, LDAP_PARAM_ERROR, NULL );
        goto error;
    }

    err = LdapAdd( connection,
                   wName,
                   (LDAPModW **)AttributeList,
                   FALSE,
                   FALSE,
                   (PLDAPControlW *) ServerControls,
                   (PLDAPControlW *) ClientControls,
                   MessageNumber
                   );

error:
    if (wName)
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    if (connection)
        DereferenceLdapConnection( connection );

    return err;
}

WINLDAPAPI ULONG LDAPAPI ldap_add_ext_sW(
        LDAP *ExternalHandle,
        PWCHAR DistinguishedName,
        LDAPModW *AttributeList[],
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls
        )
{
    ULONG msgId;
    ULONG err;
    LDAPMessage *results = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err =   LdapAdd( connection,
                     DistinguishedName,
                     AttributeList,
                     TRUE,
                     TRUE,
                     ServerControls,
                     ClientControls,
                     &msgId
                     );

    //
    //  if we error'd out before we sent the request, return the error here.
    //

    if (msgId != (ULONG) -1) {

        //
        //  we simply need to wait for the response to come in.
        //

        err = ldap_result_with_error( connection,
                                      msgId,
                                      LDAP_MSG_ALL,
                                      NULL,           // no timeout value specified
                                      &results,
                                      NULL
                                      );

        if (results == NULL) {

            LdapAbandon( connection, msgId, TRUE );

        } else {

            err = ldap_result2error( ExternalHandle,
                                     results,
                                     TRUE
                                     );
        }
    }

    DereferenceLdapConnection( connection );

    return err;
}

WINLDAPAPI ULONG LDAPAPI ldap_add_ext_sA(
        LDAP *ExternalHandle,
        PCHAR DistinguishedName,
        LDAPModA *AttributeList[],
        PLDAPControlA   *ServerControls,
        PLDAPControlA   *ClientControls
        )
{
    ULONG err;
    PWCHAR wName = NULL;
    ULONG msgId;
    LDAPMessage *results = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = ToUnicodeWithAlloc( DistinguishedName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        goto error;
    }

    err = LdapAdd(   connection,
                     wName,
                     (LDAPModW **)AttributeList,
                     FALSE,
                     TRUE,
                     (PLDAPControlW *) ServerControls,
                     (PLDAPControlW *) ClientControls,
                     &msgId
                     );

    //
    //  if we error'd out before we sent the request, return the error here.
    //

    if (msgId != (ULONG) -1) {

        //
        //  otherwise we simply need to wait for the response to come in.
        //

        err = ldap_result_with_error( connection,
                                      msgId,
                                      LDAP_MSG_ALL,
                                      NULL,           // no timeout value specified
                                      &results,
                                      NULL
                                    );

        if (results == NULL) {

            LdapAbandon( connection, msgId, TRUE );

        } else {

            err = ldap_result2error( ExternalHandle,
                                     results,
                                     TRUE
                                     );
        }
    }

error:
    if (wName)
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    DereferenceLdapConnection( connection );

    return err;
}


ULONG
SendLdapAdd (
    PLDAP_REQUEST Request,
    PLDAP_CONN Connection,
    PWCHAR DistinguishedName,
    LDAPModW *AttributeList[],
    CLdapBer **Lber,
    BOOLEAN Unicode,
    LONG AltMsgId
    )
//
//  This allows a client to add an entry to the tree.  Note that if Unicode
//  is FALSE, then the AttributeList does not point to a list of Unicode
//  attributes, but rather a list of single byte attributes.
//
{
    ULONG hr;

    if ( (Connection->publicLdapStruct.ld_version == LDAP_VERSION2) &&
         ( LdapCheckForMandatoryControl( Request->ServerControls ) == TRUE )) {

        IF_DEBUG(CONTROLS) {
            LdapPrint1( "SendLdapAdd Connection 0x%x has mandatory controls.\n", Connection);
        }
        SetConnectionError( Connection, LDAP_UNAVAILABLE_CRIT_EXTENSION, NULL );
        return LDAP_UNAVAILABLE_CRIT_EXTENSION;
    }

    CLdapBer *lber = new CLdapBer( Connection->publicLdapStruct.ld_version );

    if (lber == NULL) {
        SetConnectionError( Connection, LDAP_NO_MEMORY, NULL );
        return LDAP_NO_MEMORY;
    }

    //
    //  The request looks like the following :
    //
    //     AddRequest ::=
    //         [APPLICATION 8] SEQUENCE {
    //              entry          LDAPDN,
    //              attrs          SEQUENCE OF SEQUENCE {
    //                                  type          AttributeType,
    //                                  values        SET OF AttributeValue
    //                             }
    //         }
    //

    hr = lber->HrStartWriteSequence();
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldap_add startWrite conn 0x%x encoding error of 0x%x.\n",
                        Connection, hr );
        }
        goto encodingError;

    } else {            // we can't forget EndWriteSequence

       if (AltMsgId != 0) {

          hr = lber->HrAddValue((LONG) AltMsgId );

       } else {

          hr = lber->HrAddValue((LONG) Request->MessageId );
       }

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldap_add MsgNo conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            goto encodingError;
        }

        hr = lber->HrStartWriteSequence(LDAP_ADD_CMD);
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldap_add cmd conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            goto encodingError;

        } else {        // we can't forget EndWriteSequence

            hr = lber->HrAddValue((const WCHAR *) DistinguishedName );
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_add DN conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                goto encodingError;
            }

            //
            //  add the attribute list and we're done.
            //

            hr = lber->HrStartWriteSequence();
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_add attrlist conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                goto encodingError;

            } else {        // we can't forget EndWriteSequence

                hr = EncodeAddList( lber, AttributeList, Unicode );

                if (hr != LDAP_SUCCESS) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "ldap_add attrlist conn 0x%x encoding error of 0x%x.\n",
                                    Connection, hr );
                    }
                    if (lber != NULL) {
                        delete lber;
                    }
                    return hr;
                }

                hr = lber->HrEndWriteSequence();
                ASSERT( hr == NOERROR );
            }

            hr = lber->HrEndWriteSequence();
            ASSERT( hr == NOERROR );
        }

        //
        //  put in the server controls here if required
        //

        if ( (Connection->publicLdapStruct.ld_version != LDAP_VERSION2) &&
             ( Request->ServerControls != NULL )) {

            hr = InsertServerControls( Request, Connection, lber );

            if (hr != LDAP_SUCCESS) {

                if (lber != NULL) {
                    delete lber;
                }
                return hr;
            }
        }

        hr = lber->HrEndWriteSequence();
        ASSERT( hr == NOERROR );
    }

    //
    //  send the search request.
    //

    ACQUIRE_LOCK( &Connection->ReconnectLock );

    AddToPendingList( Request, Connection );

    hr = LdapSend( Connection, lber );

    if (hr != LDAP_SUCCESS) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "ldap_add connection 0x%x send with error of 0x%x.\n",
                        Connection, hr );
        }
        
        DecrementPendingList( Request, Connection );

    } else {

        //
        //  Save off the lber value, free any lber message that is already
        //  present.
        //

        lber = (CLdapBer *) InterlockedExchangePointer(  (PVOID *) Lber,
                                                         (PVOID) lber );
    }

    RELEASE_LOCK( &Connection->ReconnectLock );

    if (lber != NULL) {

       delete lber;
    }

    return hr;

encodingError:

    if (lber != NULL) {
        delete lber;
    }

    return LDAP_ENCODING_ERROR;
}



ULONG
EncodeAddList (
    CLdapBer *Lber,
    LDAPModW *AttributeList[],
    BOOLEAN Unicode
    )
//
//  This routine is used by LdapAdd to copy a list of LDAPMOD records
//  to an outgoing message.  It is a different BER structure than LdapModify
//  uses.
//
//              attrs          SEQUENCE OF SEQUENCE {
//                                  type          AttributeType,
//                                  values        SET OF AttributeValue
//                             }
{
    ULONG count = 0;
    ULONG hr;

    if (AttributeList == NULL) {

        return LDAP_SUCCESS;
    }

    while (AttributeList[count] != NULL) {

        PLDAPModW attr = AttributeList[count];

        hr = Lber->HrStartWriteSequence();
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint1( "ldap_add attrlist 2 encoding error of 0x%x.\n", hr );
            }
            return LDAP_ENCODING_ERROR;
        }

        //
        //  We don't have to worry when adding the attribute
        //  types if we need to convert them to unicode to
        //  preserve any DBCS codes as they should be IA5
        //  attribute names only.
        //

        if (Unicode) {

            hr = Lber->HrAddValue((const WCHAR *) attr->mod_type );

        } else {

            hr = Lber->HrAddValue((const CHAR *) attr->mod_type );
        }
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint1( "ldap_add attrlist 3 encoding error of 0x%x.\n", hr );
            }
            return LDAP_ENCODING_ERROR;
        }

        hr = Lber->HrStartWriteSequence(BER_SET);
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint1( "ldap_add attrlist 4 encoding error of 0x%x.\n", hr );
            }
            return LDAP_ENCODING_ERROR;
        }

        //
        //  the attribute value is either a string or a ptr to
        //  a berval structure.  Handle appropriately.
        //

        if (attr->mod_op & LDAP_MOD_BVALUES) {

            //
            //  array of berval structures, put each one into request
            //

            if (attr->mod_vals.modv_bvals != NULL) {

                ULONG valCount = 0;

                while (attr->mod_vals.modv_bvals[valCount]) {

                    PLDAP_BERVAL berValue = attr->mod_vals.modv_bvals[valCount++];

                    hr = Lber->HrAddBinaryValue((BYTE *) berValue->bv_val,
                                                        berValue->bv_len );
                    if (hr != NOERROR) {

                        IF_DEBUG(PARSE) {
                            LdapPrint1( "ldap_add attrlist 5 encoding error of 0x%x.\n", hr );
                        }
                        return LDAP_ENCODING_ERROR;
                    }
                }
            }

        } else {

            //
            //  array of strings, put each one into request
            //

            if (attr->mod_vals.modv_strvals != NULL) {

                ULONG valCount = 0;

                while (attr->mod_vals.modv_strvals[valCount]) {

                    if (Unicode) {

                        PWCHAR strValue = attr->mod_vals.modv_strvals[valCount++];

                        hr = Lber->HrAddValue((const WCHAR *) strValue );

                    } else {

                        PWCHAR wValue = NULL;
                        PCHAR strValue = ((PLDAPModA)attr)->mod_vals.modv_strvals[valCount++];

                        //
                        //  We need to convert from single byte
                        //  to unicode.  Otherwise we may be
                        //  putting DBCS codes into the UTF8
                        //  stream, which would not be good.
                        //

                        hr = ToUnicodeWithAlloc( strValue,
                                                 -1,
                                                 &wValue,
                                                 LDAP_UNICODE_SIGNATURE,
                                                 LANG_ACP );

                        if (hr == LDAP_SUCCESS) {

                            hr = Lber->HrAddValue((const WCHAR *) wValue );
                        }

                        ldapFree( wValue, LDAP_UNICODE_SIGNATURE );
                    }

                    if (hr != NOERROR) {

                        IF_DEBUG(PARSE) {
                            LdapPrint1( "ldap_add attrlist 6 encoding error of 0x%x.\n", hr );
                        }
                        return LDAP_ENCODING_ERROR;
                    }
                }
            }
        }

        hr = Lber->HrEndWriteSequence();     // BER_SET
        ASSERT( hr == NOERROR );

        hr = Lber->HrEndWriteSequence();
        ASSERT( hr == NOERROR );

        count++;
    }

    return LDAP_SUCCESS;
}


ULONG
LdapDupLDAPModStructure (
    LDAPModW *AttributeList[],
    BOOLEAN Unicode,
    LDAPModW **OutputList[]
)
//
//  This routine creates a duplicate of a list of attribute and value pairs
//  so that when we get a referral, we have the original fields to recreate
//  the BER encoded ASN1.
//
{
    ULONG hr = LDAP_SUCCESS;
    ULONG count = 0;
    PLDAPModW *newAttrList = NULL;

    ULONG numAttrs = 0;
    ULONG numValues = 0;

    *OutputList = NULL;

    if (AttributeList == NULL) {

        return hr;
    }

    while (AttributeList[count] != NULL) {

        count++;
    }

    numAttrs = count;

    count++;

    newAttrList = (PLDAPModW *) ldapMalloc( count * sizeof( PLDAPModW ),
                                            LDAP_ATTRIBUTE_MODIFY_SIGNATURE );

    if (newAttrList == NULL) {

        IF_DEBUG(OUTMEMORY) {
            LdapPrint0( "LdapDupLDAPModStructure 1 could not allocate memory.\n" );
        }
        return LDAP_NO_MEMORY;
    }

    count = 0;

    while (count < numAttrs) {

        PLDAPModW attr = AttributeList[count];
        PLDAPModW newAttr;

        newAttr = (PLDAPModW) ldapMalloc( sizeof( LDAPModW ), LDAP_ATTRIBUTE_MODIFY_SIGNATURE );

        if (newAttr == NULL) {

            IF_DEBUG(OUTMEMORY) {
                LdapPrint0( "LdapDupLDAPModStructure 2 could not allocate memory.\n" );
            }
            hr = LDAP_NO_MEMORY;
            goto exitWithError;
        }

        newAttrList[count++] = newAttr;
        newAttr->mod_op = attr->mod_op;

        if (attr->mod_type != NULL) {

            if (Unicode) {

                newAttr->mod_type = ldap_dup_stringW( attr->mod_type,
                                                      0,
                                                      LDAP_UNICODE_SIGNATURE );

            } else {

                newAttr->mod_type = (PWCHAR) ldap_dup_string(
                                                      (PCHAR) attr->mod_type,
                                                      0,
                                                      LDAP_ANSI_SIGNATURE );
            }

            if (newAttr->mod_type == NULL) {

                IF_DEBUG(OUTMEMORY) {
                    LdapPrint0( "LdapDupLDAPModStructure 3 could not allocate memory.\n" );
                }
                hr = LDAP_NO_MEMORY;
                goto exitWithError;
            }
        }

        //
        //  the attribute value is either a string or a ptr to
        //  a berval structure.  Handle appropriately.
        //

        if (attr->mod_op & LDAP_MOD_BVALUES) {

            //
            //  array of berval structures, allocate a copy of each one
            //

            if (attr->mod_vals.modv_bvals != NULL) {

                ULONG valCount = 0;

                while (attr->mod_vals.modv_bvals[valCount]) {

                    valCount++;
                }

                numValues = valCount;

                valCount++;

                newAttr->mod_vals.modv_bvals = (PLDAP_BERVAL *) ldapMalloc(
                             valCount * sizeof( PLDAP_BERVAL ),
                            LDAP_MOD_VALUE_SIGNATURE );

                if (newAttr->mod_vals.modv_bvals == NULL) {

                    IF_DEBUG(OUTMEMORY) {
                        LdapPrint0( "LdapDupLDAPModStructure 4 could not allocate memory.\n" );
                    }
                    hr = LDAP_NO_MEMORY;
                    goto exitWithError;
                }

                PLDAP_BERVAL newBerVals = (PLDAP_BERVAL) ldapMalloc(
                                valCount * sizeof( LDAP_BERVAL ),
                                LDAP_MOD_VALUE_SIGNATURE );

                if (newBerVals == NULL) {

                    IF_DEBUG(OUTMEMORY) {
                        LdapPrint0( "LdapDupLDAPModStructure 5 could not allocate memory.\n" );
                    }
                    hr = LDAP_NO_MEMORY;
                    goto exitWithError;
                }

                valCount = 0;

                while (valCount < numValues) {

                    newAttr->mod_vals.modv_bvals[valCount] = newBerVals;

                    PLDAP_BERVAL berValue = attr->mod_vals.modv_bvals[valCount++];

                    newBerVals->bv_len = berValue->bv_len;

                    if ((berValue->bv_val != NULL) &&
                        (berValue->bv_len != 0)) {

                        newBerVals->bv_val = (PCHAR) ldapMalloc(
                                    berValue->bv_len,
                                    LDAP_MOD_VALUE_BERVAL_SIGNATURE );

                        if (newBerVals->bv_val == NULL) {

                            IF_DEBUG(OUTMEMORY) {
                                LdapPrint0( "LdapDupLDAPModStructure 6 could not allocate memory.\n" );
                            }
                            hr = LDAP_NO_MEMORY;
                            goto exitWithError;
                        }

                        CopyMemory( newBerVals->bv_val,
                                    berValue->bv_val,
                                    berValue->bv_len );
                    }
                    newBerVals++;
                }
            }

        } else {

            //
            //  array of strings, allocate a copy of each one
            //

            if (attr->mod_vals.modv_strvals != NULL) {

                ULONG valCount = 0;

                while (attr->mod_vals.modv_strvals[valCount]) {

                    valCount++;
                }

                numValues = valCount;

                valCount++;

                newAttr->mod_vals.modv_strvals = (PWCHAR *) ldapMalloc(
                             valCount * sizeof( PWCHAR ),
                            LDAP_MOD_VALUE_SIGNATURE );

                if (newAttr->mod_vals.modv_strvals == NULL) {

                    IF_DEBUG(OUTMEMORY) {
                        LdapPrint0( "LdapDupLDAPModStructure 7 could not allocate memory.\n" );
                    }
                    hr = LDAP_NO_MEMORY;
                    goto exitWithError;
                }

                valCount = 0;

                while (valCount < numValues) {

                    if (Unicode) {

                        PWCHAR strValue = attr->mod_vals.modv_strvals[valCount];

                        newAttr->mod_vals.modv_strvals[ valCount ] =
                            ldap_dup_stringW(   strValue,
                                                0,
                                                LDAP_UNICODE_SIGNATURE );

                    } else {

                        PCHAR strValue = (PCHAR) attr->mod_vals.modv_strvals[valCount];

                        newAttr->mod_vals.modv_strvals[ valCount ] = (PWCHAR)
                            ldap_dup_string(    strValue,
                                                0,
                                                LDAP_ANSI_SIGNATURE );
                    }


                    if ( newAttr->mod_vals.modv_strvals[valCount++] == NULL ) {

                        IF_DEBUG(OUTMEMORY) {
                            LdapPrint0( "LdapDupLDAPModStructure 8 could not allocate memory.\n" );
                        }
                        hr = LDAP_NO_MEMORY;
                        goto exitWithError;
                    }
                }
            }
        }
    }

exitWithError:

    if (hr != LDAP_SUCCESS) {

        LdapFreeLDAPModStructure( newAttrList, Unicode );

    } else {

        *OutputList = newAttrList;
    }

    return hr;
}

VOID
LdapFreeLDAPModStructure (
    PLDAPModW *AttributeList,
    BOOLEAN Unicode
    )
{
    ULONG count = 0;

    if (AttributeList == NULL) {

        return;
    }

    while (AttributeList[count] != NULL) {

        PLDAPModW attr = AttributeList[count++];

        if (attr->mod_type != NULL) {

            if (Unicode) {

                ldapFree( attr->mod_type, LDAP_UNICODE_SIGNATURE );

            } else {

                ldapFree( attr->mod_type, LDAP_ANSI_SIGNATURE );
            }
        }

        //
        //  the attribute value is either a string or a ptr to
        //  a berval structure.  Handle appropriately.
        //

        if (attr->mod_op & LDAP_MOD_BVALUES) {

            //
            //  array of berval structures, free a copy of each one
            //

            if (attr->mod_vals.modv_bvals != NULL) {

                ULONG valCount = 0;

                while (attr->mod_vals.modv_bvals[valCount]) {

                    PLDAP_BERVAL berValue = attr->mod_vals.modv_bvals[valCount++];

                    if (berValue->bv_val != NULL) {

                        ldapFree( berValue->bv_val,
                                    LDAP_MOD_VALUE_BERVAL_SIGNATURE );
                    }
                }

                if (attr->mod_vals.modv_bvals[0] != NULL) {

                    ldapFree( attr->mod_vals.modv_bvals[0], LDAP_MOD_VALUE_SIGNATURE );
                }

                ldapFree( attr->mod_vals.modv_bvals, LDAP_MOD_VALUE_SIGNATURE );
            }

        } else {

            //
            //  array of strings, allocate a copy of each one
            //

            if (attr->mod_vals.modv_strvals != NULL) {

                ULONG valCount = 0;

                while (attr->mod_vals.modv_strvals[valCount]) {

                    if (Unicode) {

                        PWCHAR strValue = attr->mod_vals.modv_strvals[valCount];

                        ldapFree( strValue, LDAP_UNICODE_SIGNATURE );

                    } else {

                        PCHAR strValue = (PCHAR) attr->mod_vals.modv_strvals[valCount];

                        ldapFree( strValue, LDAP_ANSI_SIGNATURE );
                    }
                    valCount++;
                }

                ldapFree( attr->mod_vals.modv_strvals, LDAP_MOD_VALUE_SIGNATURE );
            }
        }

        ldapFree( attr, LDAP_ATTRIBUTE_MODIFY_SIGNATURE );
    }

    ldapFree( AttributeList, LDAP_ATTRIBUTE_MODIFY_SIGNATURE );

    return;
}

// add.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\bind.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    bind.c    send a bind to an LDAP server

Abstract:

   This module implements the LDAP ldap_bind API.

Author:

    Andy Herron    (andyhe)        08-May-1996
    Anoop Anantha  (AnoopA)        24-Jun-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"


BOOLEAN FailedntdsapiLoadLib = FALSE;

ULONG
LdapNonUnicodeBind (
    LDAP *ExternalHandle,
    PCHAR DistName,
    PCHAR Cred,
    ULONG Method,
    BOOLEAN Synchronous
    );

ULONG
LdapGetServiceNameForBind (
    PLDAP_CONN Connection,
    struct l_timeval  *Timeout,
    ULONG AuthMethod
    );

PWCHAR
LdapMakeServiceNameFromHostName (
    PWCHAR HostName
    );

//
//  This routine is one of the main entry points for clients calling into the
//  ldap API.
//

ULONG __cdecl
ldap_simple_bindW (
    LDAP *ExternalHandle,
    PWCHAR DistName,
    PWCHAR PassWord )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return (ULONG) -1;
    }

    err  =  LdapBind( connection,
                      DistName,
                      LDAP_AUTH_SIMPLE,
                      PassWord,
                      FALSE);

    DereferenceLdapConnection( connection );

    return err;
}

ULONG __cdecl
ldap_simple_bind_sW (
    LDAP *ExternalHandle,
    PWCHAR DistName,
    PWCHAR PassWord
    )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err  =  LdapBind( connection,
                      DistName,
                      LDAP_AUTH_SIMPLE,
                      PassWord,
                      TRUE);

    DereferenceLdapConnection( connection );

    return err;
}

ULONG __cdecl
ldap_bindW (
    LDAP *ExternalHandle,
    PWCHAR DistName,
    PWCHAR Cred,
    ULONG Method
    )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return (ULONG) -1;
    }

    err  =  LdapBind( connection,
                      DistName,
                      Method,
                      Cred,
                      FALSE);

    DereferenceLdapConnection( connection );

    return err;
}

ULONG __cdecl
ldap_bind_sW (
    LDAP *ExternalHandle,
    PWCHAR DistName,
    PWCHAR Cred,
    ULONG Method
    )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err  =  LdapBind( connection,
                      DistName,
                      Method,
                      Cred,
                      TRUE);

    DereferenceLdapConnection( connection );

    return err;
}

ULONG __cdecl
ldap_simple_bind (
    LDAP *ExternalHandle,
    PCHAR DistName,
    PCHAR PassWord )
{
    return LdapNonUnicodeBind( ExternalHandle, DistName, PassWord, LDAP_AUTH_SIMPLE, FALSE );
}

ULONG __cdecl
ldap_simple_bind_s (
    LDAP *ExternalHandle,
    PCHAR DistName,
    PCHAR PassWord
    )
{
    return LdapNonUnicodeBind( ExternalHandle, DistName, PassWord, LDAP_AUTH_SIMPLE, TRUE );
}

ULONG __cdecl
ldap_bind (
    LDAP *ExternalHandle,
    PCHAR DistName,
    PCHAR Cred,
    ULONG Method
    )
{
    return LdapNonUnicodeBind( ExternalHandle, DistName, Cred, Method, FALSE );
}

ULONG __cdecl
ldap_bind_s (
    LDAP *ExternalHandle,
    PCHAR DistName,
    PCHAR Cred,
    ULONG Method
    )
{
    return LdapNonUnicodeBind( ExternalHandle, DistName, Cred, Method, TRUE );
}

ULONG
LdapNonUnicodeBind (
    LDAP *ExternalHandle,
    PCHAR DistName,
    PCHAR Cred,
    ULONG Method,
    BOOLEAN Synchronous
    )
{
    ULONG err;
    PWCHAR wName = NULL;
    PWCHAR wPassword = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return (ULONG) ( Synchronous ? LDAP_PARAM_ERROR : -1 );
    }

    err = ToUnicodeWithAlloc( DistName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {
        goto error;
    }

    if (Method != LDAP_AUTH_SIMPLE) {

        wPassword = (PWCHAR) Cred;

    } else {

        err = ToUnicodeWithAlloc( Cred, -1, &wPassword, LDAP_UNICODE_SIGNATURE, LANG_ACP );
    }

    if (err != LDAP_SUCCESS) {
        goto error;
    }

    err = LdapBind( connection,
                    wName,
                    Method,
                    wPassword,
                    Synchronous);

error:
    if (wName)
    {
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );
    }

    if (Method == LDAP_AUTH_SIMPLE && wPassword) {

        ldapFree( wPassword, LDAP_UNICODE_SIGNATURE );
    }

    DereferenceLdapConnection( connection );

    return err;
}


ULONG
LdapBind (
    PLDAP_CONN connection,
    PWCHAR BindDistName,
    ULONG Method,
    PWCHAR BindCred,
    BOOLEAN Synchronous
    )
//
//  This routine sends a bind request to the server and optionally waits
//  for a reply.
//
//  If the call is Sychronous, it returns the LDAP error code.  Otherwise it
//  returns either -1 for failure or the LDAP message number if successful.
//
{

    ULONG err;
    PLDAP_REQUEST request = NULL;
    BOOLEAN haveLock = FALSE;
    BOOLEAN resetBindInProgress = FALSE;
    LONG messageNumber = 0;
    ULONG credentialLength = 0;
    ULONG oldVersion;
    struct l_timeval BindTimeout;
    ULONG initialBindError = LDAP_SUCCESS;
    BOOLEAN terminateConnection = FALSE;
    BOOLEAN fSentMessage = FALSE;
    LUID savedCurrentLogonId = {0, 0};
#if DBG
    ULONGLONG startTime = LdapGetTickCount();
#endif

    ULONG flags = ( connection->NegotiateFlags == DEFAULT_NEGOTIATE_FLAGS ) ?
                    ( 0 ) : connection->NegotiateFlags;


    ASSERT(connection != NULL);

    err = LdapConnect( connection, NULL, FALSE );

    if (err != 0) {

        return (ULONG) ( Synchronous ? err : -1 );
    }

    if (!connection->WhistlerServer) {
        //
        // If this is a second bind on a connection which has signing/sealing
        // turned on, we must disallow it. This is by design because the server can't
        // handle multiple binds on a signed/sealed connection.
        //
        if (connection->CurrentSignStatus || connection->CurrentSealStatus) {

            LdapPrint0("Second Bind is illegal on a signed/sealed connection\n");
            return LDAP_UNWILLING_TO_PERFORM;

        }
    }



    oldVersion = connection->publicLdapStruct.ld_version;

    if (( Method == LDAP_AUTH_NEGOTIATE ) || ( Method == LDAP_AUTH_DIGEST )){

        //
        //  set the connection type to LDAP v3.
        //

        connection->publicLdapStruct.ld_version = LDAP_VERSION3;
    }

    CLdapBer lber( connection->publicLdapStruct.ld_version );

    //
    //  we initially set the error state to success so that the lowest layer
    //  can set it accurately.
    //

    SetConnectionError( connection, LDAP_SUCCESS, NULL );

    IF_DEBUG(CONNECTION) {
        LdapPrint2( "ldap_bind called for conn 0x%x, host is %s.\n",
                        connection, connection->publicLdapStruct.ld_host);
    }

    ACQUIRE_LOCK( &connection->StateLock );
    haveLock = TRUE;

    if ((connection->ConcurrentBind) && (Method != LDAP_AUTH_SIMPLE)) {

        IF_DEBUG(CONNECTION) {
            LdapPrint2( "ldap_bind connection 0x%x in concurrent mode but method=0x%x\n",
                        connection, Method);
        }
        err = LDAP_UNWILLING_TO_PERFORM;
        SetConnectionError( connection, err, NULL );
        goto exitBind;
    }

    if (connection->ConnObjectState != ConnObjectActive) {

        IF_DEBUG(CONNECTION) {
            LdapPrint1( "ldap_bind connection 0x%x is closing.\n", connection);
        }
        err = LDAP_PARAM_ERROR;
        SetConnectionError( connection, err, NULL );
        goto exitBind;
    }

    //
    //  Free existing DN if we have one for the current connection
    //

    ldapFree( connection->DNOnBind, LDAP_USER_DN_SIGNATURE );
    connection->DNOnBind = NULL;

    //
    //  If someone sends a bind for a v2 CLDAP session, just remember the
    //  DN for the search request and we're done.
    //

    if ((connection->UdpHandle != INVALID_SOCKET) &&
        (connection->publicLdapStruct.ld_version == LDAP_VERSION2)) {

        IF_DEBUG(CONNECTION) {
            LdapPrint1( "ldap_bind connection 0x%x is connectionless.\n", connection);
        }

        if (BindDistName != NULL) {

            ULONG dnLength = strlenW( BindDistName );

            if (dnLength > 0) {

                connection->DNOnBind = (PLDAPDN) ldapMalloc(
                            (dnLength + 1) * sizeof(WCHAR), LDAP_USER_DN_SIGNATURE );

                if (connection->DNOnBind != NULL) {

                    CopyMemory( connection->DNOnBind,
                                BindDistName,
                                dnLength * sizeof(WCHAR) );
                }
            }
        }

        err = LDAP_SUCCESS;
        messageNumber = -1;     // if they do an async call, we need to return
                                // an invalid msg number so they don't try to
                                // wait on it.  They'd wait a LONG time.

        goto exitBind;
    }

    if (connection->TcpHandle == INVALID_SOCKET) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint1( "ldap_bind connection 0x%x is connectionless.\n", connection);
        }
        err = LDAP_PROTOCOL_ERROR;
        SetConnectionError( connection, err, NULL );
        goto exitBind;
    }

    if (!connection->ConcurrentBind) {

        if (connection->BindInProgress == TRUE) {

            IF_DEBUG(API_ERRORS) {
                LdapPrint1( "ldap_bind connection 0x%x has bind in progress.\n", connection);
            }
            err = LDAP_LOCAL_ERROR;
            SetConnectionError( connection, err, NULL );
            goto exitBind;
        }

        connection->BindInProgress = TRUE;
    }
    
    resetBindInProgress = TRUE;

    FreeCurrentCredentials( connection );

    RELEASE_LOCK( &connection->StateLock );
    haveLock = FALSE;

    if (( Method != LDAP_AUTH_SIMPLE ) && 
        ( Method != LDAP_AUTH_EXTERNAL )) {

        if ( ! Synchronous ) {

            //
            // All of these methods must be called through
            // the synchronous handler routine.
            //

            err = LDAP_PARAM_ERROR;
            goto exitBind;
        }

        if (!LdapInitSecurity()) {
        
            IF_DEBUG(API_ERRORS) {
                LdapPrint1( "ldap_bind connection 0x%x failed to init security.\n", connection);
            }
            err = LDAP_LOCAL_ERROR;
            SetConnectionError( connection, err, NULL );
            goto exitBind;
        }

        err = LDAP_AUTH_METHOD_NOT_SUPPORTED;

        //
        // Get the specific auth details set up.
        //

        if ( Method == LDAP_AUTH_SICILY ) {

            err = LdapTryAllMsnAuthentication( connection, BindCred );

        } else if ( Method == LDAP_AUTH_NEGOTIATE ) {

            if (( SspiPackageNegotiate ) ||
                 (connection->PreferredSecurityPackage)) {

                //
                // Determine the service name to use for kerberos auth.
                // This has to be regenerated each time a bind is performed
                // including the autoreconnect scenario.
                //
                // AnoopA: 2/4/98
                // We need to put in a timeout because we were hanging
                // when the server failed to respond to our searches
                //

                   if (connection->publicLdapStruct.ld_timelimit != 0) {
                       BindTimeout.tv_sec = connection->publicLdapStruct.ld_timelimit;
                   }
                   else {
                       BindTimeout.tv_sec = 120;
                   }

                   BindTimeout.tv_usec = 0;

                   LdapDetermineServerVersion(connection, &BindTimeout, &(connection->WhistlerServer));

                   if (connection->ServiceNameForBind != NULL) {

                       ldapFree( connection->ServiceNameForBind, LDAP_SERVICE_NAME_SIGNATURE );
                       connection->ServiceNameForBind = NULL;
                   }
                
                   err = LdapGetServiceNameForBind( connection, &BindTimeout, Method );
                   IF_DEBUG(BIND) {
                       LdapPrint1("New servicename for bind is %S\n", connection->ServiceNameForBind);
                   }

                //
                // For LDAP_AUTH_NEGOTIATE, we expect the credentials
                // to be either NULL (to indicate the locally logged
                // on user), or to contain a SEC_WINNT_AUTH_IDENTITY
                // structure.
                //

                if ( (err != LDAP_OPERATIONS_ERROR) &&
                     (err != LDAP_SERVER_DOWN) &&
                     (err != LDAP_REFERRAL_V2) &&
                     (err != LDAP_TIMEOUT) ) {

                    PWCHAR serviceNameForBind;

                    if ((!connection->ForceHostBasedSPN) && (connection->ServiceNameForBind != NULL)) {

                        serviceNameForBind = connection->ServiceNameForBind;

                    } else {

                        serviceNameForBind = LdapMakeServiceNameFromHostName(connection->HostNameW);
                        if (!serviceNameForBind) {
                            IF_DEBUG(OUTMEMORY) {
                                LdapPrint1( "ldap_bind connection 0x%x couldn't allocate service name.\n", connection);
                            }

                            err = LDAP_NO_MEMORY;
                            SetConnectionError( connection, err, NULL );
                            goto exitBind;
                        }

                    }

                    //
                    // A third party server like Netscape might support
                    // DIGEST-MD5 but not support GSS-SPNEGO
                    //

                    if (SspiPackageDigest &&
                        !connection->PreferredSecurityPackage &&
                        !connection->SupportsGSS_SPNEGO &&
                        connection->SupportsDIGEST ) {

                        flags = connection->NegotiateFlags;
                        Method = LDAP_AUTH_DIGEST;

                        if (serviceNameForBind != connection->ServiceNameForBind) {
                            // must have come from LdapMakeServiceNameFromHostName
                            ldapFree(serviceNameForBind, LDAP_SERVICE_NAME_SIGNATURE);
                        }

                        goto TryIndividualAuthMethods;
                            
                    } else {

                        err = LdapSspiBind( connection,
                                            (connection->PreferredSecurityPackage)?
                                            connection->PreferredSecurityPackage:
                                            SspiPackageNegotiate,
                                            Method,
                                            connection->NegotiateFlags,
                                            BindDistName,
                                            serviceNameForBind,
                                            BindCred );
                    }
                    
                    initialBindError = err;

                    if (serviceNameForBind != connection->ServiceNameForBind) {
                        // must have come from LdapMakeServiceNameFromHostName
                        // --> need to free it
                        ldapFree(serviceNameForBind, LDAP_SERVICE_NAME_SIGNATURE);
                    }
                }

                if (err == LDAP_PROTOCOL_ERROR) {

                    //
                    //  if the server doesn't support v3, we back off to
                    //  NTLM authentication.
                    //
                    
                    connection->publicLdapStruct.ld_version = LDAP_VERSION2;
                    Method = LDAP_AUTH_NTLM;
                    goto TryIndividualAuthMethods;

                } else if (err == LDAP_AUTH_METHOD_NOT_SUPPORTED) {

                    //
                    //  if the server doesn't support v3, we back off to
                    //  NTLM authentication.
                    //

                    connection->publicLdapStruct.ld_version = oldVersion;
                    Method = LDAP_AUTH_NTLM;                    
                    goto TryIndividualAuthMethods;

                } else if (err == LDAP_TIMEOUT ||
                           err == LDAP_SERVER_DOWN) {

                   //
                   // The server failed to respond to our search request
                   // Abort the bind
                   //

                   goto exitBind;

                }
            }
        } else {

TryIndividualAuthMethods:

            //
            // These are the same on the wire as when
            // LDAP_AUTH_SICILY is used, but they skip
            // the package enumeration and authenticate
            // directly as requested.
            //
            if (connection->publicLdapStruct.ld_timelimit != 0) {
                BindTimeout.tv_sec = connection->publicLdapStruct.ld_timelimit;
            }
            else {
                BindTimeout.tv_sec = 120;
            }

            BindTimeout.tv_usec = 0;
            LdapDetermineServerVersion(connection, &BindTimeout, &(connection->WhistlerServer));

            if ((Method == LDAP_AUTH_DPA) && (SspiPackageDpa != NULL)) {

                err = LdapSspiBind( connection,
                                    SspiPackageDpa,
                                    Method,
                                    flags,
                                    L"DPA",
                                    NULL,
                                    BindCred );

            } else if ((Method == LDAP_AUTH_MSN) && (SspiPackageSicily != NULL)) {

                err = LdapSspiBind( connection,
                                    SspiPackageSicily,
                                    Method,
                                    flags,
                                    L"MSN",
                                    NULL,
                                    BindCred );

            } else if ((Method == LDAP_AUTH_NTLM)  && (SspiPackageNtlm != NULL)) {

                err = LdapSspiBind( connection,
                                    SspiPackageNtlm,
                                    Method,
                                    flags,
                                    L"NTLM",
                                    NULL,
                                    BindCred );

            } else if ((Method == LDAP_AUTH_DIGEST)  && (SspiPackageDigest != NULL)) {

                //
                // Read the RootDSE and also determine the SPN to use.
                //
                
                ldapFree( connection->ServiceNameForBind, LDAP_SERVICE_NAME_SIGNATURE );
                connection->ServiceNameForBind = NULL;

                err = LdapGetServiceNameForBind( connection, &BindTimeout, Method );

                PWCHAR serviceNameForBind = NULL;
                
                if ((!connection->ForceHostBasedSPN) && (connection->ServiceNameForBind != NULL)) {

                    serviceNameForBind = connection->ServiceNameForBind;

                } else {

                    serviceNameForBind = LdapMakeServiceNameFromHostName(connection->HostNameW);
                    if (!serviceNameForBind) {
                        IF_DEBUG(OUTMEMORY) {
                            LdapPrint1( "ldap_bind connection 0x%x couldn't allocate service name.\n", connection);
                        }

                        err = LDAP_NO_MEMORY;
                        SetConnectionError( connection, err, NULL );
                        goto exitBind;
                    }

                }

                
                if (err == LDAP_SUCCESS) {

                    err = LdapSspiBind( connection,
                                        SspiPackageDigest,
                                        Method,
                                        flags,
                                        NULL,
                                        serviceNameForBind,
                                        BindCred );
                }

                if (serviceNameForBind != connection->ServiceNameForBind) {
                    // must have come from LdapMakeServiceNameFromHostName
                    // --> need to free it
                    ldapFree(serviceNameForBind, LDAP_SERVICE_NAME_SIGNATURE);
                }


            }

        }

    } else if ( Method == LDAP_AUTH_SIMPLE ) {

        //
        // Simple authentication.
        //

        request = LdapCreateRequest( connection, LDAP_BIND_CMD );

        if (request == NULL) {

            IF_DEBUG(OUTMEMORY) {
                LdapPrint1( "ldap_bind connection 0x%x couldn't allocate request.\n", connection);
            }

            err = LDAP_NO_MEMORY;
            SetConnectionError( connection, err, NULL );
            goto exitBind;
        }

        messageNumber = request->MessageId;
        request->ChaseReferrals = 0;

        //
        // Make sure this no other waiting thread steals a response meant
        // for us.
        //
    
        request->Synchronous = Synchronous;

        //
        //  format the bind request.
        //

        if ((connection->publicLdapStruct.ld_version == LDAP_VERSION2) ||
            (connection->publicLdapStruct.ld_version == LDAP_VERSION3)) {

            //
            //  the ldapv2 Bind message looks like this :
            //
            //  [APPLICATION 0] (IMPLICIT) SEQUENCE {
            //      version (INTEGER)
            //      szDN (LDAPDN)
            //      authentication CHOICE {
            //          simple  [0] OCTET STRING
            //          [... other choices ...]
            //          }
            //      }

            err = lber.HrStartWriteSequence();
            if (err != NOERROR) {
                SetConnectionError( connection, err, NULL );
                goto exitBind;
            }
            err = lber.HrAddValue( messageNumber );
            if (err != NOERROR) {
                SetConnectionError( connection, err, NULL );
                goto exitBind;
            }
            
            err = lber.HrStartWriteSequence(LDAP_BIND_CMD);
            if (err != NOERROR) {
                SetConnectionError( connection, err, NULL );
                goto exitBind;
            }            
            err = lber.HrAddValue((LONG) connection->publicLdapStruct.ld_version);
            if (err != NOERROR) {
                SetConnectionError( connection, err, NULL );
                goto exitBind;
            }            
            err = lber.HrAddValue((const WCHAR *) BindDistName );
            if (err != NOERROR) {
                SetConnectionError( connection, err, NULL );
                goto exitBind;
            }            

            WCHAR   nullStr = L'\0';
            PWCHAR  credentials = BindCred;

            if (credentials != NULL) {

                credentialLength = (strlenW( credentials ) + 1) * sizeof(WCHAR);
                err = lber.HrAddValue((const WCHAR *) credentials, Method );

            } else {

                credentials = &nullStr;
                err = lber.HrAddBinaryValue( (BYTE *) credentials, 0, Method );
            }

            if (err != NOERROR) {
                SetConnectionError( connection, err, NULL );
                goto exitBind;
            }

            err = lber.HrEndWriteSequence();
            ASSERT(err == NOERROR);
            err = lber.HrEndWriteSequence();
            ASSERT(err == NOERROR);

        } else {

            IF_DEBUG(API_ERRORS) {
                LdapPrint2( "ldap_bind connection 0x%x asked for version 0x%x.\n",
                            connection, connection->publicLdapStruct.ld_version );
            }

            err = LDAP_PROTOCOL_ERROR;
            SetConnectionError( connection, err, NULL );
            goto exitBind;
        }

        //
        //  send the bind request.
        //

        ACQUIRE_LOCK( &connection->ReconnectLock );

        AddToPendingList( request, connection );

        err = LdapSend( connection, &lber );

        if (err != LDAP_SUCCESS) {

            IF_DEBUG(NETWORK_ERRORS) {
                LdapPrint2( "ldap_bind connection 0x%x send with error of 0x%x.\n",
                            connection, err );
            }

            DecrementPendingList( request, connection );
            RELEASE_LOCK( &connection->ReconnectLock );

        } else {
        
            fSentMessage = TRUE;
            
            RELEASE_LOCK( &connection->ReconnectLock );
            
            if (Synchronous) {

                PLDAPMessage message = NULL;

                ULONG timeout = LDAP_BIND_TIME_LIMIT_DEFAULT;


                if (connection->publicLdapStruct.ld_timelimit != 0) {
                    timeout = connection->publicLdapStruct.ld_timelimit * 1000;
                }

                err = LdapWaitForResponseFromServer( connection,
                                                     request,
                                                     timeout,
                                                     FALSE,     /// not search results
                                                     &message,
                                                     TRUE );    // Disable autoreconnect
                if (err == LDAP_SUCCESS) {

                    if (message != NULL) {

                        err = message->lm_returncode;

                    } else {

                        ASSERT( connection->ServerDown );  

                        err = LDAP_SERVER_DOWN;

                        IF_DEBUG(SERVERDOWN) {
                            LdapPrint2( "ldapBind thread 0x%x has connection 0x%x as down.\n",
                                            GetCurrentThreadId(),
                                            connection );
                        }
                    }

                    IF_DEBUG(TRACE1) {
                        LdapPrint2( "LdapBind conn 0x%x gets response of 0x%x from server.\n",
                                    connection, err );
                    }

                } else {

                    IF_DEBUG(TRACE2) {
                        LdapPrint2( "LdapBind conn 0x%x didn't get response from server, 0x%x.\n",
                                    connection, err );
                    }
                }


                if (message != NULL) {
                    ldap_msgfree( message );
                }
            }
        }
    } else {
        
        //
        // External authentication. From draft-ietf-ldapext-authmeth-04.txt,
        // the DN contains the Authorization Id of the following two forms:
        //
        // ; distinguished-name-based authz id.
        // dnAuthzId  = "dn:" dn
        // dn         = utf8string    ; with syntax defined in RFC 2253
        //
        // ; unspecified userid, UTF-8 encoded.
        // uAuthzId   = "u:" userid
        // userid     = utf8string    ; syntax unspecified
        //
        // One of the above authzIds will be part of the credentials field in
        // the SASL credentials field.
        //

        ASSERT(  Method == LDAP_AUTH_EXTERNAL );

        if ( BindCred || (! Synchronous)) {
            
            //
            // You can't specify credentials in an EXTERNAL SASL bind nor
            // can it be called asynchronously.
            //
            
            err = LDAP_PARAM_ERROR;
            goto exitBind;
        }

        err = LdapExchangeOpaqueToken(connection,
                                      LDAP_AUTH_SASL,         // auth mechanism
                                      L"EXTERNAL",            // oid
                                      BindDistName,           // authzId
                                      NULL,                   // Credentials
                                      0,                      // Credential length
                                      NULL,                   // return data
                                      NULL,                   // return data in berval form
                                      NULL,                   // server controls
                                      NULL,                   // client controls
                                      (PULONG) &messageNumber,// Message Number
                                      FALSE,                  // Send only
                                      TRUE,                   // Controls are unicode
                                      &fSentMessage           // did the message get sent?
                                      );


    }  // End of EXTERNAL auth.

    if (( Method == LDAP_AUTH_SIMPLE ) ||
        ( Method == LDAP_AUTH_EXTERNAL )) {

        // For non-SSPI bind methods, we want to clear the security context (if any)
        // of the connection, in case this was a re-bind following a previous 
        // SSPI bind.  We also need to clear any signing/sealing left over from
        // the previous bind.  We do this only if we got to the point of actually
        // sending the bind message to the server.

        if (fSentMessage) {

            // We save off the LUID so that, if we're reconnecting, we can later
            // restore the previous LUID rather than overwrite it with a new one
            savedCurrentLogonId = connection->CurrentLogonId;
            
            CloseCredentials( connection );

            ACQUIRE_LOCK(&ConnectionListLock)
            
            if ((connection->SecureStream) &&
                (connection->CurrentSignStatus || connection->CurrentSealStatus)) {
                
                
                PSECURESTREAM pTemp;
                pTemp = (PSECURESTREAM) connection->SecureStream;
                delete pTemp;
                
                connection->SecureStream = NULL;
                connection->CurrentSignStatus = FALSE;
                connection->CurrentSealStatus = FALSE;

            }  

            RELEASE_LOCK(&ConnectionListLock)
        }
    }

    if (err == LDAP_SUCCESS) {

        //
        //  save off the credentials we used to get to this server
        //

        ACQUIRE_LOCK( &connection->StateLock );

        ldapFree( connection->DNOnBind, LDAP_USER_DN_SIGNATURE );
        connection->DNOnBind = NULL;

        if (( Method == LDAP_AUTH_SIMPLE ) ||
            ( Method == LDAP_AUTH_EXTERNAL )) {

            FreeCurrentCredentials(connection);

            if (credentialLength > 0) {

                // Note that we'll need up to (DES_BLOCKLEN-1) bytes of padding for RtlEncryptMemory
                connection->CurrentCredentials = (PWCHAR) ldapMalloc( credentialLength + 1 + (DES_BLOCKLEN-1),
                                                             LDAP_CREDENTIALS_SIGNATURE );


                if ( connection->CurrentCredentials != NULL ) {

                    CopyMemory( connection->CurrentCredentials,
                                BindCred,
                                credentialLength );

                    if (GlobalUseScrambling) {

                        ACQUIRE_LOCK( &connection->ScramblingLock );

                        pRtlInitUnicodeString( &connection->ScrambledCredentials, connection->CurrentCredentials);
                        RoundUnicodeStringMaxLength(&connection->ScrambledCredentials, DES_BLOCKLEN);

                        //
                        // Scramble plain-text credentials
                        //

                        EncodeUnicodeString(&connection->ScrambledCredentials);
                        connection->Scrambled = TRUE;

                        RELEASE_LOCK( &connection->ScramblingLock );
                    }

                }
            }
            connection->BindMethod = Method;

            // save off the LUID for referral chasing
            if (!connection->Reconnecting) {
                GetCurrentLuid( &connection->CurrentLogonId );
            }
            else {
                connection->CurrentLogonId = savedCurrentLogonId;
            }
            
        }

        connection->BindPerformed = TRUE;

        if (BindDistName != NULL) {

            ULONG dnLength = strlenW( BindDistName ) * sizeof(WCHAR);

            if (dnLength > 0) {

                connection->DNOnBind = (PLDAPDN) ldapMalloc( dnLength + sizeof(WCHAR), LDAP_USER_DN_SIGNATURE );

                if (connection->DNOnBind != NULL) {

                    CopyMemory( connection->DNOnBind,
                                BindDistName,
                                dnLength );
                }
            }
        }

        RELEASE_LOCK( &connection->StateLock );
    }

exitBind:

    IF_DEBUG(BIND) {
        LdapPrint2( "ldap_bind returned err = 0x%x for connection 0x%x.\n",
                     err, connection );
    }

    if (resetBindInProgress == TRUE) {

        ldap_msgfree( connection->BindResponse );
        connection->BindResponse = NULL;

        connection->BindInProgress = FALSE;
    }

    //
    //  if the server returns a protocol error, RFC 2251 mandates
    //  the client MUST close the connection as the server will
    //  be unwilling to accept further operations. We mark
    //  the connection as down so that future requests trigger
    //  a disconnect/reconnect.
    //

    if ((err != LDAP_SUCCESS) &&
        (terminateConnection == TRUE)) {

        if (!haveLock) {
            ACQUIRE_LOCK( &connection->StateLock );
        }

        connection->HostConnectState = HostConnectStateError;

        if (!haveLock) {
            RELEASE_LOCK( &connection->StateLock );
        }
    }

    if (haveLock) {
        RELEASE_LOCK( &connection->StateLock );
    }

    if (! Synchronous) {

        if (err == LDAP_SUCCESS) {

            err = messageNumber;

        } else {

            err = (DWORD) -1;

            if (request != NULL) {

                CloseLdapRequest( request );
            }
        }

    } else {

        if (request != NULL) {

            CloseLdapRequest( request );
        }
    }

    if (request != NULL) {

        DereferenceLdapRequest( request );
    }

    START_LOGGING;
    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=ldap_bind]"));
    DSLOG((0,"[DN=%ws][PA=0x%x][ST=%I64d][ET=%I64d][ER=%d][-]\n",
           BindDistName, Method, startTime, LdapGetTickCount(), err));
    END_LOGGING;

    return err;
}

ULONG
FreeCurrentCredentials (
    PLDAP_CONN Connection
    )
{
    if (Connection->CurrentCredentials != NULL) {

        ULONG tag;

        if ( Connection->BindMethod == LDAP_AUTH_SIMPLE ) {

            tag = LDAP_CREDENTIALS_SIGNATURE;

        } else {

            tag = LDAP_SECURITY_SIGNATURE;
        }

        ldapSecureFree( Connection->CurrentCredentials, tag );
        Connection->CurrentCredentials = NULL;
    }
    Connection->BindMethod = 0;

    if (GlobalUseScrambling) {
        pRtlInitUnicodeString( &Connection->ScrambledCredentials, NULL);
    }

    return LDAP_SUCCESS;
}

// important: must be lower-case, per RFC 2829, section 11
#define LDAP_SERVICE_PREFIX L"ldap"

PWCHAR
LdapMakeServiceNameFromHostName (
    PWCHAR HostName
    )
{
    PWCHAR pszServiceName = NULL;

    if (!LoadUser32Now()) {
        return NULL;
    }

    pszServiceName = (PWCHAR) ldapMalloc( (strlenW(LDAP_SERVICE_PREFIX) + strlenW(HostName) + 2)*sizeof(WCHAR), LDAP_SERVICE_NAME_SIGNATURE);
    if (!pszServiceName) {
        return NULL;
    };

    pfwsprintfW (pszServiceName, L"%s/%s", LDAP_SERVICE_PREFIX, HostName);

    return pszServiceName;
}


ULONG
LdapGetServiceNameForBind (
    PLDAP_CONN Connection,
    struct l_timeval  *Timeout,
    ULONG AuthMethod
    )
{

#define TEMPBUFFERSIZE  4096

   PWCHAR  pszSpn = NULL;
   DWORD   pcSpnLength = TEMPBUFFERSIZE;
   PLDAP   ldapConnection = Connection->ExternalInfo;
   ULONG   err;
   PLDAPMessage results = NULL;
   ULONG oldChaseReferrals = Connection->publicLdapStruct.ld_options;
   BOOLEAN foundGSSAPI = FALSE;
   BOOLEAN foundGSS_SPNEGO = FALSE;
   BOOLEAN foundDIGEST = FALSE;
   USHORT PortNumber = 0;
   PWCHAR servicename = NULL;
    
   PWCHAR attrList[4] = { L"supportedSASLMechanisms",
                          NULL };

   //
   // We try to generate a service principle name if we have a fully qualified
   // machine name.
   //

   if ((Connection->DnsSuppliedName != NULL) &&
       (NTDSLibraryHandle == NULL) &&
        (!FailedntdsapiLoadLib) ){

      //
      // Try to load ntdsapi.dll
      //

      ACQUIRE_LOCK( &LoadLibLock );

      NTDSLibraryHandle = LoadSystem32LibraryA( "NTDSAPI.DLL" );

      if (NTDSLibraryHandle != NULL) {

         pDsMakeSpnW = (FNDSMAKESPNW) GetProcAddress( NTDSLibraryHandle, "DsMakeSpnW" );

      if (pDsMakeSpnW == NULL) {

         //
         // No big deal. We won't die if we don't get that function
         // Just don't try to load the dll again.
         //

         FailedntdsapiLoadLib = TRUE;
         FreeLibrary( NTDSLibraryHandle );
         NTDSLibraryHandle = NULL;
      }

      } else {

         FailedntdsapiLoadLib = TRUE;
      }

      RELEASE_LOCK( &LoadLibLock );
   }


   if (pDsMakeSpnW) {

          //
          // We have to decide what we want to pass in as the service name. If we
          // connect using an IP address, we are out of luck and end up reading
          // the rootDSE attribute anyway.
          //
          // AnoopA (1/27/99): I have to read the RootDSE ALWAYS to figure out if the
          // server is pre-GSS-SPNEGO or not. But, we will try our best to get the
          // servicename through DsMakeSpn and not from the RootDSE.
          //
    

          //
          // If we had a domain name, we must redirect it to the appropriate KDC by 
          // supplying the @domain in the end. So, the new SPN will look like:
          //
          // LDAP/FQMN/FQDN@FQDN
          //
    
          pszSpn = (PWCHAR) ldapMalloc( TEMPBUFFERSIZE, LDAP_BUFFER_SIGNATURE );

          if (!pszSpn) {
              goto ReadRootDSE;
          }

          if (Connection->DomainName) {
    
              LONG DomainLength = strlenW(Connection->DomainName);
              
              if (DomainLength >= TEMPBUFFERSIZE/8) {
                  goto ReadRootDSE;
              }

              servicename = (PWCHAR)ldapMalloc( (DomainLength*2+2)* sizeof(WCHAR),
                                                 LDAP_BUFFER_SIGNATURE);
    
              if (!servicename) {
                  goto ReadRootDSE;
              }
    
              CopyMemory( servicename,
                          Connection->DomainName,
                          DomainLength * sizeof(WCHAR));

              if ( (!(Connection->ResolvedGetDCFlags & DS_NDNC_FLAG)) &&
                   (AuthMethod != LDAP_AUTH_DIGEST) ) {

                  // If binding to a non-domain naming context (NDNC), we don't
                  // want to include the so-called DomainName (really, the NDNC name)
                  // as a realm hint, because NDNCs aren't Kerberos realms.
                  // It also doesn't make sense to include the realm hint in the Digest
                  // case.
              
                  *(servicename+DomainLength) = L'@';
        
                  CopyMemory( servicename + DomainLength+1,
                              Connection->DomainName,
                              DomainLength * sizeof(WCHAR));
              }
    
          } else {
              
              servicename = Connection->DnsSuppliedName;
          }
          
          if ( (!((Connection->PortNumber == LDAP_PORT) ||
                  (Connection->PortNumber == LDAP_GC_PORT) ||
                  (Connection->PortNumber == LDAP_SSL_PORT) ||
                  (Connection->PortNumber == LDAP_SSL_GC_PORT))) &&
                  (AuthMethod != LDAP_AUTH_DIGEST)) {
    
              //
              // This connection is on a non-standard port. Include it in the SPN, unless
              // we're building a Digest URI (Digest doesn't take the port number)
              //

              PortNumber = Connection->PortNumber;
          }
    
          IF_DEBUG(BIND) {
             LdapPrint1("Connection->hostname is %s\n", Connection->publicLdapStruct.ld_host);
             LdapPrint1("Connection->DnsSuppliedNAme is %S\n ", Connection->DnsSuppliedName);
             LdapPrint1("Connection->DomainName is %S\n ", Connection->DomainName);
         }

          //
          // Note: The service class name in the SPN must be lower-case ("ldap").
          // This is required by RFC 2829, section 11.  W2k DCs are not case-sensitive,
          // however, some third-party servers are.
          //
          err  = pDsMakeSpnW( LDAP_SERVICE_PREFIX,     // ServiceClass
                              servicename,            // ServiceName
                              Connection->DnsSuppliedName,  // Optional InstanceName
                              PortNumber,             // PortNumber, if nonstandard
                              NULL,                   // Optional referrer
                              &pcSpnLength,           // Length of buffer
                              pszSpn                  // Actual buffer
                              );
    
    
       if (err == ERROR_SUCCESS) {
    
          Connection->ServiceNameForBind = ldap_dup_stringW(
                                                           pszSpn,
                                                           0,
                                                           LDAP_SERVICE_NAME_SIGNATURE );
    
        IF_DEBUG(BIND) {
             LdapPrint2("LDAP: DsMakeSpn returned %S with error %d\n", Connection->ServiceNameForBind, err);
        }
        }
    
   }

ReadRootDSE:

    Connection->publicLdapStruct.ld_options &= ~LDAP_OPT_CHASE_REFERRALS;
    Connection->publicLdapStruct.ld_options &= ~LDAP_CHASE_SUBORDINATE_REFERRALS;
    Connection->publicLdapStruct.ld_options &= ~LDAP_CHASE_EXTERNAL_REFERRALS;

    //
    // Ensure that we don't try to sign/seal - remember that we haven't
    // bound yet.
    //

    err = ldap_search_ext_sW( ldapConnection,
                              NULL,
                              LDAP_SCOPE_BASE,
                              L"(objectclass=*)",
                              attrList,
                              0,            // attributes only
                              NULL,         // server controls
                              NULL,         // client controls
                              Timeout,
                              0,            // size limit
                              &results
                              );

    if (results != NULL) {

        PLDAPMessage message = ldap_first_record( Connection,
                                                  results,
                                                  LDAP_RES_SEARCH_ENTRY );

        if (message != NULL) {

            struct berelement *opaque = NULL;
            PWCHAR attribute = LdapFirstAttribute( Connection,
                                                   message,
                                                   (BerElement **) &opaque,
                                                   TRUE );

            while (attribute != NULL) {

                PWCHAR *values = NULL;
                ULONG count;

                if (LdapGetValues( Connection,
                                   message,
                                   attribute,
                                   FALSE,
                                   TRUE,
                                   (PVOID *) &values) != NOERROR)
                    values = NULL;

                ULONG totalValues = ldap_count_valuesW( values );

                if ( ldapWStringsIdentical(
                                     attribute,
                                     -1,
                                     L"supportedSASLMechanisms",
                                     -1 )) {


                    for (count = 0; count < totalValues; count++ ) {

                        if (ldapWStringsIdentical(
                                            values[count],
                                            -1,
                                            L"GSSAPI",
                                            -1 )) {
                            foundGSSAPI = TRUE;
                            IF_DEBUG(BIND) {
                                LdapPrint1( "ldapBind found GSSAPI auth type on conn 0x%x\n", Connection);
                            }
                        } else if (ldapWStringsIdentical(
                                            values[count],
                                            -1,
                                            L"GSS-SPNEGO",
                                            -1 )) {
                            foundGSS_SPNEGO = TRUE;
                            IF_DEBUG(BIND) {
                                LdapPrint1( "ldapBind found GSS-SPNEGO auth type on conn 0x%x\n", Connection);
                            }
                        } else if (ldapWStringsIdentical(
                                            values[count],
                                            -1,
                                            L"DIGEST-MD5",
                                            -1 )) {
                            foundDIGEST = TRUE;
                            IF_DEBUG(BIND) {
                                LdapPrint1( "ldapBind found DIGEST auth type on conn 0x%x\n", Connection);
                            }
                        }
                    }

                }

                ldap_value_freeW( values );

                attribute = LdapNextAttribute( Connection,
                                               message,
                                               opaque,
                                               TRUE );
            }
        }

        ldap_msgfree( results );
    }

    Connection->publicLdapStruct.ld_options = oldChaseReferrals;

    if (err == LDAP_SUCCESS) {

        //
        // This must be a v3 server we are talking to. It responded successfully
        // to our RootDSE search 
        //
        
        IF_DEBUG(BIND) {
            LdapPrint0("ldap bind: Server is v3\n");
        }
        Connection->HighestSupportedLdapVersion = LDAP_VERSION3;

        if  ((foundGSS_SPNEGO == FALSE) && (foundGSSAPI == FALSE)) {

            //
            // Non-AD server
            //

            IF_DEBUG(BIND) {
                LdapPrint0("ldap bind: Server does not support GSSAPI or GSS-SPNEGO\n");
            }

        } else if ((foundGSS_SPNEGO == FALSE) && (foundGSSAPI == TRUE)){

            //
            // AD Beta2 server
            //
            Connection->SupportsGSSAPI = TRUE;
            IF_DEBUG(BIND) {
                LdapPrint0("ldap bind: Server supports GSSAPI but not GSS-SPNEGO\n");
            }

        } else if ((foundGSS_SPNEGO == TRUE) && (foundGSSAPI == FALSE)) {

            //
            // Non-AD server but it supports the negotiate package.
            //

            Connection->SupportsGSS_SPNEGO = TRUE;
            IF_DEBUG(BIND) {
                LdapPrint0("ldap bind: Server supports GSS-SPNEGO but not GSSAPI\n");
            }

        } else if ((foundGSS_SPNEGO == TRUE) && (foundGSSAPI == TRUE)) {

            //
            // AD Beta3 server
            //

            Connection->SupportsGSS_SPNEGO = TRUE;
            Connection->SupportsGSSAPI = TRUE;
            IF_DEBUG(BIND) {
                LdapPrint0("ldap bind: Server supports both GSS-SPNEGO and GSSAPI\n");
            }
        }

        Connection->SupportsDIGEST = foundDIGEST;
    
    } else {

        //
        // This server probably requires a bind before doing a search.
        //
        IF_DEBUG(BIND) {
            LdapPrint0("ldap bind: Server is v2\n");
        }
        Connection->HighestSupportedLdapVersion = LDAP_VERSION2;
    }

   
   if (Connection->DomainName) {
       ldapFree(servicename, LDAP_BUFFER_SIGNATURE);
       servicename = NULL;
   }
    
   if (pszSpn) {
       ldapFree(pszSpn, LDAP_BUFFER_SIGNATURE);
       pszSpn = NULL;
   }
    
   return err;

}

BOOLEAN
LdapAuthError(
   ULONG err
   )
{
    //
    // Returns FALSE for non authentication errors like LDAP_BUSY etc.
    //

    if (( err == LDAP_INAPPROPRIATE_AUTH )  ||
        ( err == LDAP_INVALID_CREDENTIALS ) ||
        ( err == LDAP_INSUFFICIENT_RIGHTS ) ||
        ( err == LDAP_AUTH_METHOD_NOT_SUPPORTED ) ||
        ( err == LDAP_STRONG_AUTH_REQUIRED )  ||
        ( err == LDAP_AUTH_UNKNOWN )) {

        return TRUE;
    }

    return FALSE;
}

ULONG
LdapDetermineServerVersion (
    PLDAP_CONN Connection,
    struct l_timeval  *Timeout,
    BOOLEAN *pfIsServerWhistler     // OUT
    )
{
    PLDAP   ldapConnection = Connection->ExternalInfo;
    ULONG   err;
    PLDAPMessage results = NULL;
    ULONG oldChaseReferrals = Connection->publicLdapStruct.ld_options;

    PWCHAR attrList[2] = { L"supportedCapabilities",
                           NULL };

    Connection->publicLdapStruct.ld_options &= ~LDAP_OPT_CHASE_REFERRALS;
    Connection->publicLdapStruct.ld_options &= ~LDAP_CHASE_SUBORDINATE_REFERRALS;
    Connection->publicLdapStruct.ld_options &= ~LDAP_CHASE_EXTERNAL_REFERRALS;

    *pfIsServerWhistler = FALSE;

    err = ldap_search_ext_sW( ldapConnection,
                              NULL,
                              LDAP_SCOPE_BASE,
                              L"(objectclass=*)",
                              attrList,
                              0,            // attributes only
                              NULL,         // server controls
                              NULL,         // client controls
                              Timeout,
                              0,            // size limit
                              &results
                              );

    if (results != NULL) {

        PLDAPMessage message = ldap_first_record( Connection,
                                                  results,
                                                  LDAP_RES_SEARCH_ENTRY );

        if (message != NULL) {

            struct berelement *opaque = NULL;
            PWCHAR attribute = LdapFirstAttribute( Connection,
                                                   message,
                                                   (BerElement **) &opaque,
                                                   TRUE );

            while (attribute != NULL) {

                PWCHAR *values = NULL;
                ULONG count;

                if (LdapGetValues( Connection,
                                   message,
                                   attribute,
                                   FALSE,
                                   TRUE,
                                   (PVOID *) &values) != NOERROR)
                    values = NULL;

                ULONG totalValues = ldap_count_valuesW( values );

                if ( ldapWStringsIdentical(
                                     attribute,
                                     -1,
                                     L"supportedCapabilities",
                                     -1 )) {


                    for (count = 0; count < totalValues; count++ ) {

                        if (ldapWStringsIdentical(
                                            values[count],
                                            -1,
                                            L"1.2.840.113556.1.4.1791", // Whistler w/ rebind fixes OID
                                            -1 )) {
                            *pfIsServerWhistler = TRUE;
                            IF_DEBUG(BIND) {
                                LdapPrint1( "ldapBind found server is Whistler or better AD on conn 0x%x\n", Connection);
                            }
                        }
                    }

                }

                ldap_value_freeW( values );

                attribute = LdapNextAttribute( Connection,
                                               message,
                                               opaque,
                                               TRUE );
            }
        }

        ldap_msgfree( results );
    }

    Connection->publicLdapStruct.ld_options = oldChaseReferrals;

    return err;
}

// bind.c eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\attrib.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    attrib.cxx parse out attributes from LDAP results

Abstract:

   This module implements the APIs to break apart LDAP results

Author:

    Andy Herron (andyhe)        02-Jul-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

PWCHAR
LdapFirstAttribute (
    PLDAP_CONN      connection,
    LDAPMessage     *Message,
    BerElement      **OpaqueResults,
    BOOLEAN         Unicode
    )
//
//  This routine gets the first attribute of the message.  It stores the attr
//  name in a "per connection" buffer but since we like to be multi-thread
//  safe, this is "per connection per thread" just for grins.
//
{
    CLdapBer *lber;
    ULONG hr;
    PLDAP_ATTR_NAME_THREAD_STORAGE threadAttr;
    DWORD currentThread;
    PWCHAR results = NULL;
    ULONG tLength;

    PLIST_ENTRY pThreadListEntry = NULL;
    PTHREAD_ENTRY pThreadEntry = NULL;
    BOOLEAN fRetriedFindThread = FALSE;

    *OpaqueResults = NULL;

    if ((Message == NULL) || (Message->lm_msgtype != LDAP_RES_SEARCH_ENTRY)) {

        SetConnectionError( connection, LDAP_DECODING_ERROR, NULL );
        return NULL;
    }

    currentThread = GetCurrentThreadId();

    //
    // Find the buffer to store the attribute name off of this connection
    // This requires first finding the THREAD_ENTRY for this thread,
    // then the attribute entry for this connection off of that thread entry.
    //
retryFindThread:

    ACQUIRE_LOCK( &PerThreadListLock );

    pThreadListEntry = GlobalPerThreadList.Flink;

    // find the THREAD_ENTRY for this thread
    while (pThreadListEntry != &GlobalPerThreadList) {

        pThreadEntry = CONTAINING_RECORD( pThreadListEntry, THREAD_ENTRY, ThreadEntry );
        pThreadListEntry = pThreadListEntry->Flink;

        if (pThreadEntry->dwThreadID == currentThread) {
            break;
        }

        pThreadEntry = NULL;
    }

    if (!pThreadEntry && !fRetriedFindThread) {
        // this thread must have been created before this DLL was loaded-
        // create a per-thread entry for it now
        RELEASE_LOCK( &PerThreadListLock );

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldapFirstAttr could not find ThreadEntry for conn 0x%x, thread 0x%x.  Creating one.\n",
                            connection, currentThread );
        }

        if (!AddPerThreadEntry(currentThread)) {
            IF_DEBUG(PARSE) {
                LdapPrint2( "ldapFirstAttr AddPerThreadEntry failed, conn 0x%x, thread 0x%x.\n",
                                connection, currentThread );
            }
            SetConnectionError( connection, LDAP_NO_MEMORY, NULL );
            return NULL;
        }

        fRetriedFindThread = TRUE;
        goto retryFindThread;
    }
    else if (!pThreadEntry) {
        // shouldn't happen --- somehow a thread entry wasn't created
        RELEASE_LOCK( &PerThreadListLock );
        IF_DEBUG(PARSE) {
            LdapPrint2( "ldapFirstAttr no per-thread entry, conn 0x%x, thread 0x%x.\n",
                            connection, currentThread );
        }            
        ASSERT(pThreadEntry);
        SetConnectionError( connection, LDAP_LOCAL_ERROR, NULL );
        return NULL;
    }

    // find the attribute entry for this connection
    threadAttr = pThreadEntry->pCurrentAttrList;

    while (threadAttr != NULL) {

        if (threadAttr->PrimaryConn == connection) {
            ASSERT(threadAttr->Thread == currentThread);
            break;
        }

        threadAttr = threadAttr->pNext;
    }

    if (threadAttr == NULL) {

        threadAttr = (PLDAP_ATTR_NAME_THREAD_STORAGE) ldapMalloc(
                                sizeof( LDAP_ATTR_NAME_THREAD_STORAGE ),
                                LDAP_ATTR_THREAD_SIGNATURE );

        if (threadAttr == NULL) {

            IF_DEBUG(OUTMEMORY) {
                LdapPrint1( "ldapFirstAttr could not alloc curr attribute for thread for conn 0x%x.\n",
                                connection );
            }

            RELEASE_LOCK( &PerThreadListLock );
            SetConnectionError( connection, LDAP_NO_MEMORY, NULL );
            return NULL;
        }

        IF_DEBUG(TRACE1) {
            LdapPrint3( "ldapFirstAttr allocated attr at 0x%x for thread 0x%x, conn 0x%x.\n",
                            threadAttr, currentThread, connection );
        }

        threadAttr->Thread = currentThread;
        threadAttr->AttrTag.Tag = LDAP_DONT_FREE_SIGNATURE;
        threadAttr->AttrTagW.Tag = LDAP_DONT_FREE_SIGNATURE;
        threadAttr->pNext = pThreadEntry->pCurrentAttrList;
        threadAttr->PrimaryConn = connection;
        pThreadEntry->pCurrentAttrList = threadAttr;
    }
    
    RELEASE_LOCK( &PerThreadListLock );


    //
    //  We now at least have a place to put the results if all is successful
    //  ( in threadAttr->AttributeName )
    //

    SetConnectionError( connection, LDAP_SUCCESS, NULL );

    lber = (CLdapBer *) Message->lm_ber;

    if (lber == NULL) {

        goto protocolError;
    }

    hr = LdapGoToFirstAttribute( connection, lber );
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldap_first_attribute 1 conn 0x%x received protocol error 0x%x .\n",
                            connection, hr);
        }

protocolError:
        SetConnectionError( connection, LDAP_DECODING_ERROR, NULL );
        threadAttr = NULL;
        goto exitGetFirstAttr;
    }

    hr = lber->HrStartReadSequence();

    if (hr != NOERROR) {
        IF_DEBUG(PARSE) {
            LdapPrint2( "ldap_first_attribute 8 conn 0x%x received protocol error 0x%x .\n",
                            connection, hr);
        }
        goto exitGetFirstAttr;
    }

    //
    //  Next up is the first attribute type... let's store it off.
    //

    hr = lber->HrGetValue(  (WCHAR *) &(threadAttr->AttributeNameW[0]),
                            MAX_ATTRIBUTE_NAME_LENGTH - 1,
                            BER_OCTETSTRING );

    if (hr != NOERROR) {
        IF_DEBUG(PARSE) {
            LdapPrint2( "ldap_first_attribute 2 conn 0x%x received protocol error 0x%x .\n",
                            connection, hr);
        }
        goto protocolError;
    }

    //
    //  We save off both the unicode and single byte form of the attribute
    //  name and then return whichever one they want.
    //

    tLength = WideCharToMultiByte(  CP_ACP,
                                    0,
                                    &(threadAttr->AttributeNameW[0]),
                                    -1,
                                    (PCHAR) &(threadAttr->AttributeName[0]),
                                    MAX_ATTRIBUTE_NAME_LENGTH - 1,
                                    NULL,
                                    NULL );

    if (tLength == 0) {

        SetConnectionError( connection, LDAP_NO_MEMORY, NULL );
        goto exitGetFirstAttr;
    }

    threadAttr->AttributeName[tLength-1] = '\0';

    if (Unicode) {

        results = &(threadAttr->AttributeNameW[0]);

    } else {

        results = (PWCHAR) &(threadAttr->AttributeName[0]);
    }

    //
    //  next up is the actual values for this attribute... we'll not quite skip
    //  past it since we may be able to read it straight off in ldap_get_values
    //

    *OpaqueResults = (BerElement *) lber;

exitGetFirstAttr:

    return results;
}

PWCHAR __cdecl
ldap_first_attributeW (
    LDAP            *ExternalHandle,
    LDAPMessage     *Message,
    BerElement      **OpaqueResults
    )
{
    PLDAP_CONN connection = NULL;
    PWCHAR results = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return NULL;
    }

    results = LdapFirstAttribute( connection,
                                  Message,
                                  OpaqueResults,
                                  TRUE );

    DereferenceLdapConnection( connection );

    return results;
}

PCHAR __cdecl
ldap_first_attribute (
    LDAP            *ExternalHandle,
    LDAPMessage     *Message,
    BerElement      **OpaqueResults
    )
{
    PLDAP_CONN connection = NULL;
    PCHAR results = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return NULL;
    }

    results = (PCHAR) LdapFirstAttribute( connection,
                                          Message,
                                          OpaqueResults,
                                          FALSE );

    DereferenceLdapConnection( connection );

    return results;
}

PCHAR __cdecl
ldap_first_attributeA (
    LDAP            *ExternalHandle,
    LDAPMessage     *Message,
    BerElement      **OpaqueResults
    )
{
    PLDAP_CONN connection = NULL;
    PCHAR results = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return NULL;
    }

    results = (PCHAR) LdapFirstAttribute( connection,
                                          Message,
                                          OpaqueResults,
                                          FALSE );

    DereferenceLdapConnection( connection );

    return results;
}

PWCHAR
LdapNextAttribute (
    PLDAP_CONN      connection,
    LDAPMessage     *Message,
    BerElement      *OpaqueResults,
    BOOLEAN         Unicode
    )
//
//  This routine gets the next attribute of the message.  It's the follow-on
//  to ldap_first_attribute above.
//
{
    CLdapBer *lber;
    ULONG hr;
    PLDAP_ATTR_NAME_THREAD_STORAGE threadAttr;
    DWORD currentThread;
    ULONG tag;
    PWCHAR results = NULL;
    ULONG tLength;

    PLIST_ENTRY pThreadListEntry = NULL;
    PTHREAD_ENTRY pThreadEntry = NULL;
    BOOLEAN fRetriedFindThread = FALSE;

    if ((Message == NULL) || (Message->lm_msgtype != LDAP_RES_SEARCH_ENTRY)) {

        SetConnectionError( connection, LDAP_DECODING_ERROR, NULL );
        return NULL;
    }

    currentThread = GetCurrentThreadId();

    //
    // Find the buffer that stored the attribute name off of this connection
    // This requires first finding the THREAD_ENTRY for this thread,
    // then the attribute entry for this connection off of that thread entry.
    //
retryFindThread:

    ACQUIRE_LOCK( &PerThreadListLock );

    pThreadListEntry = GlobalPerThreadList.Flink;

    // find the THREAD_ENTRY for this thread
    while (pThreadListEntry != &GlobalPerThreadList) {

        pThreadEntry = CONTAINING_RECORD( pThreadListEntry, THREAD_ENTRY, ThreadEntry );
        pThreadListEntry = pThreadListEntry->Flink;

        if (pThreadEntry->dwThreadID == currentThread) {
            break;
        }

        pThreadEntry = NULL;
    }

    if (!pThreadEntry && !fRetriedFindThread) {
        // this thread must have been created before this DLL was loaded-
        // create a per-thread entry for it now
        RELEASE_LOCK( &PerThreadListLock );

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldapNextAttr could not find ThreadEntry for conn 0x%x, thread 0x%x.  Creating one.\n",
                            connection, currentThread );
        }

        if (!AddPerThreadEntry(currentThread)) {
            IF_DEBUG(PARSE) {
                LdapPrint2( "ldapNextAttr AddPerThreadEntry failed, conn 0x%x, thread 0x%x.\n",
                                connection, currentThread );
            }
            SetConnectionError( connection, LDAP_NO_MEMORY, NULL );
            goto exitGetNextAttr;
        }

        fRetriedFindThread = TRUE;
        goto retryFindThread;
    }
    else if (!pThreadEntry) {
        // shouldn't happen --- somehow a thread entry wasn't created
        RELEASE_LOCK( &PerThreadListLock );
        IF_DEBUG(PARSE) {
            LdapPrint2( "ldapNextAttr no per-thread entry, conn 0x%x, thread 0x%x.\n",
                            connection, currentThread );
        }            
        ASSERT(pThreadEntry);
        SetConnectionError( connection, LDAP_LOCAL_ERROR, NULL );
        goto exitGetNextAttr;
    }    


    // find the attribute entry for this connection
    threadAttr = pThreadEntry->pCurrentAttrList;

    while (threadAttr != NULL) {

        if (threadAttr->PrimaryConn == connection) {
            ASSERT(threadAttr->Thread == currentThread);
            break;
        }

        threadAttr = threadAttr->pNext;
    }

    RELEASE_LOCK( &PerThreadListLock );
    
    if (threadAttr == NULL) {

        SetConnectionError( connection, LDAP_LOCAL_ERROR, NULL );
        goto exitGetNextAttr;
    }

    //
    //  We now at least have a place to put the results if all is successful
    //  ( in threadAttr->AttributeName )
    //

    SetConnectionError( connection, LDAP_SUCCESS, NULL );

    if (OpaqueResults == NULL) {

        threadAttr = NULL;
        SetConnectionError( connection, LDAP_LOCAL_ERROR, NULL );
        goto exitGetNextAttr;
    }

    lber = (CLdapBer *) OpaqueResults;

    //
    //  depending on what the last call was, we're either at the start of a
    //  sequence for the next attribute or the start of a set of attribute
    //  values for the current attribute.  We'll peak at the tag and if
    //  we're at a set, we'll skip the value.
    //

    hr = lber->HrPeekTag( &tag );

    if (hr == LDAP_NO_SUCH_ATTRIBUTE) {

        threadAttr = NULL;
        goto exitGetNextAttr;
    }

    if (tag == BER_SET) {

        hr = lber->HrSkipElement();     // skip the attribute value
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldapNextAttr 1 conn 0x%x received protocol error 0x%x .\n",
                                connection, hr);
            }
            goto protocolError;
        }

        hr = lber->HrPeekTag( &tag );


        if (hr == LDAP_NO_SUCH_ATTRIBUTE) {

            threadAttr = NULL;
            goto exitGetNextAttr;
        }
        else if ( hr != NOERROR ) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldapNextAttr 4 conn 0x%x received protocol error 0x%x .\n",
                                connection, hr);
            }
            goto protocolError;
        }
    }

    hr = lber->HrEndReadSequence();

    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldapNextAttr 5 conn 0x%x received protocol error 0x%x .\n",
                            connection, hr);
        }
    }

    if (tag != BER_SEQUENCE) {

        //
        //  we're at the end of the attributes
        //

        threadAttr = NULL;
        goto exitGetNextAttr;
    }

    hr = lber->HrStartReadSequence(BER_SEQUENCE);
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldapNextAttr 2 conn 0x%x received protocol error 0x%x .\n",
                            connection, hr);
        }

protocolError:
        SetConnectionError( connection, LDAP_DECODING_ERROR, NULL );
        threadAttr = NULL;
        goto exitGetNextAttr;
    }

    //
    //  Next up is the first attribute type... let's store it off.
    //

    hr = lber->HrGetValue(  (WCHAR *) &(threadAttr->AttributeNameW[0]),
                            MAX_ATTRIBUTE_NAME_LENGTH - 1,
                            BER_OCTETSTRING );

    if (hr != NOERROR) {
        IF_DEBUG(PARSE) {
            LdapPrint2( "ldapNextAttr 3 conn 0x%x received protocol error 0x%x .\n",
                            connection, hr);
        }
        goto protocolError;
    }

    //
    //  We save off both the unicode and single byte form of the attribute
    //  name and then return whichever one they want.
    //

    tLength = WideCharToMultiByte(  CP_ACP,
                                    0,
                                    &(threadAttr->AttributeNameW[0]),
                                    -1,
                                    (PCHAR) &(threadAttr->AttributeName[0]),
                                    MAX_ATTRIBUTE_NAME_LENGTH - 1,
                                    NULL,
                                    NULL );

    if (tLength == 0) {

        SetConnectionError( connection, LDAP_NO_MEMORY, NULL );
        goto exitGetNextAttr;
    }


    threadAttr->AttributeName[tLength-1] = '\0';

    if (Unicode) {

        results = &(threadAttr->AttributeNameW[0]);

    } else {

        results = (PWCHAR) &(threadAttr->AttributeName[0]);
    }

    //
    //  next up is the actual values for this attribute... we'll leave the
    //  lber object in this state in case they come in for a read.  If they
    //  go to read the attribute that matches the threadAttr->AttributeName,
    //  we'll be right there.
    //

exitGetNextAttr:

    return results;
}

PWCHAR __cdecl
ldap_next_attributeW (
    LDAP            *ExternalHandle,
    LDAPMessage     *Message,
    BerElement      *OpaqueResults
    )
{
    PLDAP_CONN connection = NULL;
    PWCHAR results = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return NULL;
    }

    results = LdapNextAttribute( connection,
                                 Message,
                                 OpaqueResults,
                                 TRUE );

    DereferenceLdapConnection( connection );

    return results;
}

PCHAR __cdecl
ldap_next_attribute (
    LDAP            *ExternalHandle,
    LDAPMessage     *Message,
    BerElement      *OpaqueResults
    )
{
    PLDAP_CONN connection = NULL;
    PCHAR results = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return NULL;
    }

    results = (PCHAR) LdapNextAttribute( connection,
                                         Message,
                                         OpaqueResults,
                                         FALSE );

    DereferenceLdapConnection( connection );

    return results;
}

PCHAR __cdecl
ldap_next_attributeA (
    LDAP            *ExternalHandle,
    LDAPMessage     *Message,
    BerElement      *OpaqueResults
    )
{
    PLDAP_CONN connection = NULL;
    PCHAR results = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return NULL;
    }

    results = (PCHAR) LdapNextAttribute( connection,
                                         Message,
                                         OpaqueResults,
                                         FALSE );

    DereferenceLdapConnection( connection );

    return results;
}


ULONG LdapGoToFirstAttribute (
    PLDAP_CONN Connection,
    CLdapBer *Lber
    )
//
//  This resets the parsing of the message and goes to the first attribute
//
{
    ULONG hr;
    ULONG tag = BER_INVALID_TAG;

    Lber->Reset(FALSE);

    hr = Lber->HrStartReadSequence(BER_SEQUENCE);
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldapFirstAttr 1 conn 0x%x received protocol error 0x%x .\n",
                            Connection, hr);
        }
        return(LDAP_DECODING_ERROR);
    }

    hr = Lber->HrSkipElement();     // skip the message number
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldapFirstAttr 2 conn 0x%x received protocol error 0x%x .\n",
                            Connection, hr);
        }
        return(LDAP_DECODING_ERROR);
    }

    hr = Lber->HrPeekTag( &tag );
    ASSERT( hr == NOERROR );

    //
    //  if this is a UDP connection, skip the DN if specified.
    //

    if ((Connection->UdpHandle != INVALID_SOCKET) &&
        (Connection->publicLdapStruct.ld_version == LDAP_VERSION2) &&
        (tag == BER_OCTETSTRING)) {

        hr = Lber->HrSkipElement();
        if ( hr != NOERROR ) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldapFirstAttr 8 conn 0x%x received protocol error 0x%x .\n",
                                Connection, hr);
            }
            return(LDAP_DECODING_ERROR);
        }

        hr = Lber->HrPeekTag( &tag );
        ASSERT( hr == NOERROR );
    }

    if (tag == BER_SEQUENCE) {

        hr = Lber->HrStartReadSequence(tag);
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldapFirstAttr 3 conn 0x%x received protocol error 0x%x .\n",
                              Connection, hr);
            }
            return(LDAP_DECODING_ERROR);
        }

        hr = Lber->HrPeekTag( &tag );
        ASSERT( hr == NOERROR );
    }

    //
    //  start reading the actual result sequence
    //

    hr = Lber->HrStartReadSequence(LDAP_RES_SEARCH_ENTRY);

    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldapFirstAttr 4 conn 0x%x received protocol error 0x%x .\n",
                            Connection, hr);
        }
        return(LDAP_DECODING_ERROR);
    }

    hr = Lber->HrPeekTag( &tag );
    ASSERT( hr == NOERROR );

    if (tag == BER_SEQUENCE) {

        hr = Lber->HrStartReadSequence(tag);
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldapFirstAttr 5 conn 0x%x received protocol error 0x%x .\n",
                                Connection, hr);
            }
            return(LDAP_DECODING_ERROR);
        }
    }

    hr = Lber->HrSkipElement();     // skip the distinguished name
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldapFirstAttr 6 conn 0x%x received protocol error 0x%x .\n",
                            Connection, hr);
        }
        return(LDAP_DECODING_ERROR);
    }

    hr = Lber->HrStartReadSequence();

    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldapFirstAttr 7 conn 0x%x received protocol error 0x%x .\n",
                            Connection, hr);
        }
        return(LDAP_DECODING_ERROR);
    }

    return LDAP_SUCCESS;
}

// attrib.cxx eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\autorec.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    receive.c    receive data from an LDAP server

Abstract:

   This module implements auto reconnect to an LDAP server

Author:

    Andy Herron    (andyhe)        07-Oct-1997
    Anoop Anantha  (AnoopA)        24-Jun-1998


Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

#define RECONNECT_INTERVAL 5000  // min autoreconnect interval (millisecs)

ULONG
LdapResendRequests (
    PLDAP_CONN Connection
    );

ULONG
FreeMessagesFromConnection (
    PLDAP_REQUEST Request,
    PLDAP_CONN Connection
    );

ULONG
LdapAutoReconnect (
    PLDAP_CONN Connection
    )
//
//  The connection has a reference we need to clear when we're done with it.
//  Also, the Connection->ReconnectLock should be held before coming in here
//  and Connection->HostConnectState must be set to HostConnectStateReconnecting.
//
{
    ULONG err = LDAP_SERVER_DOWN;
    PCHAR copyOfPrimaryCreds = NULL;
    ULONG bindMethod;
    BOOLEAN clearPending = FALSE;
    int sockerr = 0;

    ACQUIRE_LOCK( &Connection->StateLock );

    IF_DEBUG(RECONNECT) {
        LdapPrint2( "LdapAutoReconnect trying to reconnect conn 0x%x to %s.\n",
            Connection, Connection->publicLdapStruct.ld_host );
    }

    ASSERT( Connection->AutoReconnect == TRUE );
    
    if (Connection->Reconnecting == TRUE) {
    
        IF_DEBUG(RECONNECT) {
            LdapPrint1( "LdapAutoReconnect conn 0x%x already reconnecting.\n",
                        Connection);
        }
        
        Connection->HostConnectState = HostConnectStateError;
        
        RELEASE_LOCK( &Connection->StateLock );
        goto exitReconnect;
    }

    if (((Connection->HostConnectState != HostConnectStateError) &&
         (Connection->HostConnectState != HostConnectStateReconnecting )) ||
        (Connection->ConnObjectState != ConnObjectActive ) ||
        (Connection->BindInProgress == TRUE) ||
        (Connection->TcpHandle == INVALID_SOCKET)) {

        IF_DEBUG(RECONNECT) {
            LdapPrint1( "LdapAutoReconnect conn 0x%x not in correct state.\n",
                        Connection);
            if ((Connection->HostConnectState != HostConnectStateError) &&
                (Connection->HostConnectState != HostConnectStateReconnecting )) {

                LdapPrint1( "LdapAutoReconnect host state is %u.\n",
                                Connection->HostConnectState);
            }
            if (Connection->ConnObjectState != ConnObjectActive) {
                clearPending = TRUE;
                LdapPrint0( "LdapAutoReconnect connection state is closing.\n");
            }
            if (Connection->BindInProgress) {
                LdapPrint0( "LdapAutoReconnect connection has bind in progress.\n");
            }
            if (Connection->TcpHandle == INVALID_SOCKET) {
                LdapPrint0( "LdapAutoReconnect connection has invalid socket.\n");
            }
        }

        clearPending = TRUE;

        if (Connection->HostConnectState == HostConnectStateReconnecting) {

            Connection->HostConnectState = HostConnectStateError;
        }
        RELEASE_LOCK( &Connection->StateLock );
        goto exitReconnect;
    }

    //
    // Don't reconnect to the server like crazy if it keeps dropping us.
    // We might be on the server's IP deny list.
    //

    if ((Connection->LastReconnectAttempt != 0) &&
        (LdapGetTickCount() - Connection->LastReconnectAttempt < RECONNECT_INTERVAL)) {

        IF_DEBUG(RECONNECT) {
            LdapPrint1( "LdapAutoReconnect conn 0x%x reconnecting too frequently.\n",
                        Connection);
        }
        
        if (Connection->HostConnectState == HostConnectStateReconnecting) {

            Connection->HostConnectState = HostConnectStateError;
        }
        
        RELEASE_LOCK( &Connection->StateLock );
        goto exitReconnect;
    }
    
    //
    //  the only time we should get here is if we're in a reconnecting state
    //  not during a bind and not during a close.
    //

    ASSERT( Connection->HostConnectState == HostConnectStateReconnecting );

    Connection->ServerDown = FALSE;
    Connection->Reconnecting = TRUE;
    Connection->BindInProgress = FALSE;

    RELEASE_LOCK( &Connection->StateLock );

    //
    //  reset back to a basic state
    //

    BeginSocketProtection( Connection );

    sockerr = (*pclosesocket)(Connection->TcpHandle);
    ASSERT(sockerr == 0);
    
    Connection->TcpHandle = (*psocket)(PF_INET, SOCK_STREAM, 0);

    EndSocketProtection( Connection );

    if (Connection->TcpHandle == INVALID_SOCKET) {

        IF_DEBUG(RECONNECT) {
            LdapPrint1( "LdapAutoReconnect conn 0x%x could not reopen socket.\n",
                        Connection);
        }
        clearPending = TRUE;
        ACQUIRE_LOCK( &Connection->StateLock );
        Connection->HostConnectState = HostConnectStateError;
        Connection->Reconnecting = FALSE;
        Connection->ServerDown = TRUE;
        RELEASE_LOCK( &Connection->StateLock );
        goto exitReconnect;
    }

    // prevent socket hijacking
    if (psetsockopt) {
    
        BOOL t = TRUE;

        (*psetsockopt)( Connection->TcpHandle,
                        SOL_SOCKET,
                        SO_EXCLUSIVEADDRUSE,
                        reinterpret_cast<char*>(&t),
                        sizeof(t) );
    }
    
    if (Connection->PendingMessage != NULL) {

        CLdapBer *lber = (CLdapBer *) Connection->PendingMessage->lm_ber;

        if (lber != NULL) {

            delete lber;
        }
        ldapFree( Connection->PendingMessage, LDAP_MESG_SIGNATURE );
        Connection->PendingMessage = NULL;
    }

    ACQUIRE_LOCK(&ConnectionListLock)

    if (Connection->SecureStream != NULL) {
        
        delete ((PSECURESTREAM) Connection->SecureStream) ;
        Connection->SecureStream = NULL;
    }
    Connection->CurrentSignStatus= FALSE;
    Connection->CurrentSealStatus= FALSE;

    RELEASE_LOCK(&ConnectionListLock)

    Connection->LastReconnectAttempt = LdapGetTickCount();

    err = LdapConnect( Connection, NULL, TRUE );

    if (err != 0) {

        IF_DEBUG(RECONNECT) {
            LdapPrint1( "LdapAutoReconnect failed to connect, err 0x%x.\n", err);
        }

        ACQUIRE_LOCK( &Connection->StateLock );
        Connection->HostConnectState = HostConnectStateError;
        Connection->Reconnecting = FALSE;
        RELEASE_LOCK( &Connection->StateLock );

        SetEvent( Connection->ConnectEvent );
        err = LDAP_UNAVAILABLE;
        clearPending = TRUE;
        goto exitReconnect;
    }


    //
    // put the server into concurrent fast bind mode,
    // if this is a fast bind connection
    //
    if (Connection->ConcurrentBind) {

        err = ldap_extended_operation_sW(
                        Connection->ExternalInfo,
                        LDAP_SERVER_FAST_BIND_OID_W,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL);

        if (err != LDAP_SUCCESS) {

            IF_DEBUG(RECONNECT) {
                LdapPrint2( "LdapAutoReconnect conn 0x%x failed to turn on fast concurrent binding, err 0x%x.\n",
                            Connection, err);
            }

            ACQUIRE_LOCK( &Connection->StateLock );
            Connection->HostConnectState = HostConnectStateError;
            Connection->Reconnecting = FALSE;
            Connection->ServerDown = TRUE;
            RELEASE_LOCK( &Connection->StateLock );

            SetEvent( Connection->ConnectEvent );
            err = LDAP_SERVER_DOWN;
            clearPending = TRUE;
            goto exitReconnect;
        }
    }

    //
    //  send bind request
    //

    ACQUIRE_LOCK( &Connection->StateLock );
    bindMethod = Connection->BindMethod;
    RELEASE_LOCK( &Connection->StateLock );


    // If the connection is in fast concurrent bind mode,
    // we don't bother re-binding --- there's no security context
    // to re-establish anyway
    if ((bindMethod != 0) && (!Connection->ConcurrentBind)) {

        ACQUIRE_LOCK( &Connection->StateLock );
        
        PLDAPDN dnOnBind = Connection->DNOnBind;

        //
        // Unscramble the credentials
        //

        PWCHAR creds = Connection->CurrentCredentials;
        UNICODE_STRING OldScrambledCreds;

        ACQUIRE_LOCK( &Connection->ScramblingLock );

        if ( GlobalUseScrambling && Connection->Scrambled && Connection->CurrentCredentials) {

           DecodeUnicodeString(&Connection->ScrambledCredentials);
           Connection->Scrambled = FALSE;
        }

        OldScrambledCreds = Connection->ScrambledCredentials;

        RELEASE_LOCK( &Connection->ScramblingLock );


        Connection->CurrentCredentials = NULL;
        Connection->DNOnBind = NULL;

        RELEASE_LOCK( &Connection->StateLock );

        err = LdapBind( Connection,
                        dnOnBind,
                        bindMethod,
                        creds,
                        TRUE          // Synchronous
                        );

        IF_DEBUG(RECONNECT) {
            LdapPrint2( "LdapAutoReconnect: Bind to host %s returned 0x%x\n",
                    Connection->publicLdapStruct.ld_host, err );
        }

        //
        // If rebind fails for any reason other than auth failure,
        // restore the old credentials.
        //

        if (( err != LDAP_SUCCESS ) &&
            ( !LdapAuthError( err ) )) {

            ACQUIRE_LOCK( &Connection->StateLock );
            Connection->BindMethod = bindMethod;
            Connection->DNOnBind = dnOnBind;
            Connection->CurrentCredentials = creds;

            //
            // Rescramble the credentials
            //

            ACQUIRE_LOCK( &Connection->ScramblingLock );

            Connection->ScrambledCredentials = OldScrambledCreds;

            if ( GlobalUseScrambling && !Connection->Scrambled && Connection->CurrentCredentials) {

               EncodeUnicodeString(&Connection->ScrambledCredentials);
               Connection->Scrambled = TRUE;
            }

            RELEASE_LOCK( &Connection->ScramblingLock );
            RELEASE_LOCK( &Connection->StateLock );


        } else {

            //
            // We either succeeded or we got a real authentication error.
            // So, we free the credentials. If it succeeded, LdapBind() would
            // have made a copy. If failed, we don't want these credentials.
            //

            if (creds != NULL) {

                ULONG tag;

                if ( bindMethod == LDAP_AUTH_SIMPLE ) {

                    tag = LDAP_CREDENTIALS_SIGNATURE;

                } else {

                    tag = LDAP_SECURITY_SIGNATURE;
                }

                ldapSecureFree( creds, tag );
            }

            ldapFree( dnOnBind, LDAP_USER_DN_SIGNATURE );
        }


        if ( err != LDAP_SUCCESS ) {

            //
            //  bummer... we couldn't reauthenticate as the user.  Oh well.
            //

            IF_DEBUG(RECONNECT) {
                LdapPrint2( "LdapAutoReconnect conn 0x%x could not bind, err = 0x%x\n",
                            Connection, err );
            }

            ACQUIRE_LOCK( &Connection->StateLock );
            Connection->HostConnectState = HostConnectStateError;
            Connection->Reconnecting = FALSE;
            Connection->ServerDown = TRUE;

            //
            // Make sure we don't try to reconnect again because we don't have
            // the original bind credentials anymore.
            //

            if (LdapAuthError(err)) {
                Connection->AutoReconnect = FALSE;
            }
            RELEASE_LOCK( &Connection->StateLock );

            SetEvent( Connection->ConnectEvent );
            clearPending = TRUE;
            goto exitReconnect;
        }
    }

    err = LdapResendRequests( Connection );

    ACQUIRE_LOCK( &Connection->StateLock );
    Connection->Reconnecting = FALSE;
    RELEASE_LOCK( &Connection->StateLock );
    SetEvent( Connection->ConnectEvent );

    if (err != LDAP_SUCCESS) {

        clearPending = TRUE;
    }

exitReconnect:

    if (clearPending) {

        LdapPrint2("Autoreconnect failure on connection 0x%x, err is 0x%x\n",Connection, err);
        ClearPendingListForConnection( Connection );
    }

    if (copyOfPrimaryCreds != NULL) {

        ldapFree( copyOfPrimaryCreds, LDAP_SECURITY_SIGNATURE );
    }

    return err;
}

ULONG
LdapResendRequests (
    PLDAP_CONN Connection
    )
{
    //
    //  go through each pending request and search for either primary
    //  requests or referral requests for this connection.
    //

    ULONG err = LDAP_SUCCESS;
    PLDAP_REQUEST request;
    PLIST_ENTRY listEntry;
    PMESSAGE_ID_LIST_ENTRY messageIdsToFree = NULL;
    PMESSAGE_ID_LIST_ENTRY currentNode = NULL;
    CLdapBer *lber;
    ULONG msgId;
    ULONG intermediateErr = LDAP_SUCCESS;

    ACQUIRE_LOCK( &RequestListLock );

    listEntry = GlobalListRequests.Flink;

    while (listEntry != &GlobalListRequests) {

        request = CONTAINING_RECORD( listEntry, LDAP_REQUEST, RequestListEntry );
        request = ReferenceLdapRequest(request);

        if (!request) {
            listEntry = listEntry->Flink;
            continue;
        }

        msgId = 0;
        err = LDAP_SUCCESS;

        ACQUIRE_LOCK( &request->Lock );

        if (Connection == request->PrimaryConnection) {

            if ((request->PagedSearchBlock)  ||
                (request->Abandoned) ||
                (request->ResponsesOutstanding == 0)) {

                //
                // Don't bother to resend this request. This is the original paged search request
                // which we retain as a handle for paging. It does not contain a BER buffer.
                //

                IF_DEBUG(SERVERDOWN) {
                    LdapPrint1("LdapResendRequest: Skipping over paged/abandoned/completed requests 0x%x\n", request);
                }
                RELEASE_LOCK( &request->Lock );
                listEntry = listEntry->Flink;
                DereferenceLdapRequest( request );
                continue;
            }


            //
            //  if we still have ber, we send it off.  If we don't, then we
            //  know that we've already given results to the client.  If it's
            //  not a search, we're done.  If it is a search, then we basically
            //  abandon the request since we've only given partial results.
            //

            msgId = request->MessageId;

            //
            //  grab the ber buffer, send it out if it's there and then put it
            //  back in a safe way.
            //

            lber = (CLdapBer *) InterlockedExchangePointer(  &request->BerMessageSent,
                                                             NULL );
            if ( lber != NULL ) {

                FreeMessagesFromConnection( request, Connection );

                RELEASE_LOCK( &request->Lock );
                RELEASE_LOCK( &RequestListLock );

                //
                // If we keep resending this request, and the server keeps dropping
                // us and forcing us to autoreconnect again, then stop sending this
                // request.  We exempt notification searches from this logic because
                // they can stay around for a long time and in doing so legitimately
                // rack up a large number of reconnects.
                //
                if ((request->NotificationSearch) ||
                    (request->ResentAttempts < GlobalRequestResendLimit)) {

                    request->ResentAttempts++;
                    err = LdapSend( Connection, lber );
                }
                else {
                
                    IF_DEBUG(SERVERDOWN) {
                        LdapPrint1("LdapResendRequest: Request 0x%x has too many resends\n", request);
                    }

                    // this will be picked up below and force a call to SimulateErrorMessage
                    err = LDAP_SERVER_DOWN;
                }
                
                lber = (CLdapBer *) InterlockedExchangePointer((PVOID *)&request->BerMessageSent,
                                                               (PVOID)lber );

                ACQUIRE_LOCK( &RequestListLock );
                ACQUIRE_LOCK( &request->Lock );

                if (lber != NULL) {

                    delete lber;
                }
                
            } else {

                //
                //  We've already received a response for this request.
                //

                err = LDAP_CONNECT_ERROR;

            }

        }

        //
        //  now we go through the referral table for this request...
        //

        PREFERRAL_TABLE_ENTRY refTable = request->ReferralConnections;

        if (refTable != NULL && err == LDAP_SUCCESS) {

            USHORT limit = request->ReferralTableSize;
            USHORT referralCount = 0;

            while (referralCount < limit && err == LDAP_SUCCESS) {

                if (refTable->ReferralServer == Connection) {

                    //
                    //  free all responses that we've received to date for this
                    //  request.
                    //

                    //
                    //  grab the ber buffer, send it out if it's there and then put it
                    //  back in a safe way.
                    //

                    lber = (CLdapBer *) InterlockedExchangePointer(  &refTable->BerMessageSent,
                                                                     NULL );
                    if (lber != NULL) {

                        if (msgId == 0) {       // only free messages once

                            FreeMessagesFromConnection( request, Connection );
                        }

                        RELEASE_LOCK( &request->Lock );
                        RELEASE_LOCK( &RequestListLock );

                        //
                        // If we keep resending this request, and the server keeps dropping
                        // us and forcing us to autoreconnect again, then stop sending this
                        // request.  If the parent of this referral was a notification search,
                        // we exempt it because notification searches can stay around for a long
                        // time.
                        //
                        if ((request->NotificationSearch) ||
                            (refTable->ResentAttempts < GlobalRequestResendLimit)) {

                            refTable->ResentAttempts++;
                            err = LdapSend( Connection, lber );
                        }
                        else {
                        
                            IF_DEBUG(SERVERDOWN) {
                                LdapPrint2("LdapResendRequest: Referral 0x%x for request 0x%x has too many resends\n",
                                            refTable,
                                            request);
                            }

                            err = LDAP_SERVER_DOWN;
                        }

                        ACQUIRE_LOCK( &RequestListLock );
                        ACQUIRE_LOCK( &request->Lock );

                        lber = (CLdapBer *) InterlockedExchangePointer(
                                            (PVOID *) &refTable->BerMessageSent,
                                            (PVOID) lber );

                        if (lber != NULL) {

                            delete lber;
                        }
                    } else {

                        //
                        //  We've already received a response for this request.
                        //

                        err = LDAP_CONNECT_ERROR;
                    }

                    msgId = request->MessageId;
                }
                referralCount++;
                refTable++;
            }
        }

        if (err != LDAP_SUCCESS) {

            ASSERT( msgId != 0 );

            //
            //  either we had problems resending the request or we've already
            //  received a response.  If we've already received a response,
            //  then we need to look at whether or not we've received all the
            //  responses (in which case we don't worry about it) or if we've
            //  only received partial, we close out the request with an error.
            //

            if ((request->Operation != LDAP_SEARCH_CMD) &&
                (err == LDAP_CONNECT_ERROR)) {

                //
                //  we've already received this response.  all is well for
                //  this request.
                //

                err = LDAP_SUCCESS;

            } else {

                //
                //  Either the send failed or it's a search and we've already
                //  given back part of the results.  Either way, we can't
                //  expect a response back, so we'll have to simulate one.
                //

                ULONG simErr = SimulateErrorMessage( Connection,
                                                     request,
                                                     LDAP_SERVER_DOWN
                                                     );
                IF_DEBUG(SERVERDOWN) {
                    LdapPrint2( "ldapResentRequests thread 0x%x simulated down message for connection 0x%x\n",
                                    GetCurrentThreadId(),
                                    Connection );
                }

                if (simErr != LDAP_SUCCESS) {

                    request->Abandoned = TRUE;
                }

                currentNode = (PMESSAGE_ID_LIST_ENTRY) ldapMalloc( sizeof( MESSAGE_ID_LIST_ENTRY ),
                                                               LDAP_MSGID_SIGNATURE );

                if (currentNode != NULL) {

                    currentNode->Next = messageIdsToFree;
                    currentNode->MessageId = msgId;
                    messageIdsToFree = currentNode;
                }

                ClearPendingListForRequest( request );
            }
        }

        //
        // Record the first error we stumble upon. Otherwise, it might get
        // lost as we cycle through the list of requests.
        //

        if (( err != LDAP_SUCCESS ) &&
            ( intermediateErr == LDAP_SUCCESS )) {

            intermediateErr = err;
        }

        RELEASE_LOCK( &request->Lock );

        listEntry = listEntry->Flink;
                
        DereferenceLdapRequest( request );

    }

    RELEASE_LOCK( &RequestListLock );

    //
    //  Now we go through and wake up any threads that are waiting for these
    //  requests.
    //

    if (messageIdsToFree != NULL) {

        ACQUIRE_LOCK( &ConnectionListLock );

        while (messageIdsToFree != NULL) {

            currentNode = messageIdsToFree;
            messageIdsToFree = messageIdsToFree->Next;

            CheckForWaiters( currentNode->MessageId, FALSE, Connection );
            ldapFree( currentNode, LDAP_MSGID_SIGNATURE );
        }

        RELEASE_LOCK( &ConnectionListLock );

        LdapWakeupSelect();
    }

    if (err == LDAP_SERVER_DOWN) {

        IF_DEBUG(SERVERDOWN) {
            LdapPrint2( "ldapResentRequests thread 0x%x has connection 0x%x as down.\n",
                            GetCurrentThreadId(),
                            Connection );
        }
    }

    return  (intermediateErr == LDAP_SUCCESS) ? err : intermediateErr;
}

ULONG
FreeMessagesFromConnection (
    PLDAP_REQUEST Request,
    PLDAP_CONN Connection
    )
{
    PLDAPMessage current = Request->MessageLinkedList;
    PLDAPMessage previous = NULL;
    PLDAPMessage next;

    while (current != NULL) {

        //
        //  flatten out the two lists (lm_next and lm_chain) into a single list
        //

        if (current->lm_next != NULL) {

            if (current->lm_chain != NULL) {

                //
                //  append the chain list onto the next list
                //

                next = current->lm_chain;

                while (next->lm_chain != NULL) {
                    next = next->lm_chain;
                }

                next->lm_chain = current->lm_next;

            } else {

                current->lm_chain = current->lm_next;
            }
            current->lm_next = NULL;
        }

        if (current->Connection == Connection->ExternalInfo) {

            //
            //  remove this entry from the list
            //

            next = current->lm_chain;

            if (previous == NULL) {

                Request->MessageLinkedList = next;

            } else {

                previous->lm_chain = next;
            }

            current->lm_chain = NULL;
            ldap_msgfree( current );
            current = next;

        } else {

            previous = current;
            current = current->lm_chain;
        }
    }

    return LDAP_SUCCESS;
}

// autorec.cxx eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\cache.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    cache.cxx  RootDSE cache maintencance for the LDAP api

Abstract:

   This module implements routines that maintain the RootDSE cache

Author:

    Anoop Anantha (anoopa)        06-Jan-1999

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"


//
// The attribute cache itself is a two dimensional array of the form shown
// below. We have a hardcoded list of attributes we can cache. To add another
// cacheable item, simply add it to the list below. Keep in mind that the total
// size of the attribute+values must not exceed INITIAL_MAX_RECEIVE_BUFFER.
//

static PWCHAR CachedAttributeList[] = {
                                L"subschemaSubentry",
                                L"dsServiceName",
                                L"namingContexts",
                                L"defaultNamingContext",
                                L"schemaNamingContext",
                                L"configurationNamingContext",
                                L"rootDomainNamingContext",
                                L"supportedControl",
                                L"supportedLDAPVersion",
                                L"supportedLDAPPolicies",
                                L"supportedSASLMechanisms",
                                L"dnsHostName",
                                L"ldapServiceName",
                                L"serverName",
                                L"supportedCapabilities",
                                NULL
                        };

#define NUM_CACHED_ATTR  ((sizeof(CachedAttributeList)/sizeof(PWCHAR))-1)

//
// The CACHEHOLDER is considered as one CachePage. This is dynamically
// allocated on a per server basis. Since we can't have multidimensional
// arrays with different data types in each dimension, we have to play
// some tricks here by using the second row of the cache as PWCHAR*
// instead of PWCHAR. This is because an attribute can be multivalued.
//

typedef struct _CACHEHOLDER {

    LONG        RefCount;            // This CachePage is referenced, do not delete
    PWCHAR      ServerName;          // The name of the server
    USHORT      PortNumber;          // Target port number on the server
    ULONGLONG   CreateTime;          // Timestamp of cachepage creation
    ULONGLONG   LastAccessTime;
    PWCHAR      CacheTemplate[2][NUM_CACHED_ATTR];// points to an array of CachedAttributeList

} CACHEHOLDER, *PCACHEHOLDER;


#define CacheStateCacheHit                          0
#define CacheStateStaleCache                        1
#define CacheStateServerNotCached                   2
#define CacheStateNonCachableAttribute              3

//
// Maximum number of servers whose RootDSEs we are willing to cache
//

#define MAX_CACHE_SIZE          5
#define CACHE_TIMEOUT           900000   // 15 minutes in millisecs

//
// RootDSE cache holder. Currently, we have place for holding upto
// MAX_CACHE_SIZE servers.
//

PCACHEHOLDER CacheArray[MAX_CACHE_SIZE];


BOOLEAN
ValidateServerReturnedAttrList(
    PLDAP_CONN   Connection,
    PLDAPMessage message
    );


VOID
InitializeLdapCache (
   VOID
   )
{
    ACQUIRE_LOCK( &CacheLock );

    for (int i=0; i< MAX_CACHE_SIZE; i++) {

        CacheArray[i] = NULL;
    }

    RELEASE_LOCK( &CacheLock );

}


VOID
FreeCachePage(
   PCACHEHOLDER CachePage
   )
{
    //
    // The CacheLock must be held coming in here !
    //

    if ( CachePage == NULL) {

        return;
    }

    ldapFree( CachePage->ServerName, LDAP_HOST_NAME_SIGNATURE);

    for (int i=0; i<NUM_CACHED_ATTR; i++) {

        ldapFree( CachePage->CacheTemplate[0][i], LDAP_VALUE_SIGNATURE);
        PWCHAR *CurrentVal = (PWCHAR*) CachePage->CacheTemplate[1][i];

        if (CurrentVal != NULL) {

            for (int j=0; (CurrentVal[j]!= NULL) ; j++) {

                ldapFree( CurrentVal[j], LDAP_VALUE_SIGNATURE );
            }

            ldapFree( CurrentVal, LDAP_VALUE_LIST_SIGNATURE );
        }
    }

    ldapFree( CachePage, LDAP_VALUE_SIGNATURE );
}


VOID
FreeEntireLdapCache(
   VOID
   )
{
    //
    // The CacheLock must be held coming in here !
    //

    for (int i=0; i<MAX_CACHE_SIZE; i++) {

        if ( CacheArray[i] != NULL) {

            FreeCachePage( CacheArray[i] );
            CacheArray[i] = NULL;
        }
    }
}


ULONG
AllAttributesAreCacheable (
   PLDAP_CONN Connection,
   PWCHAR  AttributeList[],
   BOOLEAN Unicode
   )
{
    //
    // Scan through the list of attributes to determine if ALL of them are
    // cacheable. Even if one of them isn't cacheable, we return
    // CacheStateNonCachableAttribute. We then check to see if our local
    // cached copy is valid.
    //
    // Possible return values are:
    //          CacheStateNonCachableAttribute
    //          CacheStateCacheHit
    //          CacheStateStaleCache
    //          CacheStateServerNotCached
    //          other failure errors
    //

    PWCHAR* CurrentAttribute = AttributeList;
    PWCHAR* stdattr = CachedAttributeList;
    int i, err;

    if (!CurrentAttribute ) {

        return CacheStateNonCachableAttribute;
    }

    while (*CurrentAttribute != NULL) {

        //
        // As a temp measure, convert the attribute list to unicode before
        // the comparision. We will have to remove this conversion later due
        // to performance reasons.
        //

        PWCHAR wAttr = NULL;

        if (!Unicode) {

            err = ToUnicodeWithAlloc( (PCHAR) *CurrentAttribute,
                                      -1,
                                      &wAttr,
                                      LDAP_UNICODE_SIGNATURE,
                                      LANG_ACP
                                      );
        }

        while (*stdattr != NULL) {

            if (ldapWStringsIdentical((Unicode ? *CurrentAttribute : wAttr ),
                                      -1,
                                      *stdattr,
                                      -1 )) {
                //
                // Match found. Proceed to the next attribute on the list
                //

                IF_DEBUG(CACHE) {
                    LdapPrint1("Yes, %S is a cacheable attribute\n", (Unicode ? *CurrentAttribute : wAttr ));
                }
                stdattr = CachedAttributeList;
                CurrentAttribute++;
                break;
            }

            stdattr++;
        }

        ldapFree( wAttr, LDAP_UNICODE_SIGNATURE );

        if (*stdattr == NULL) {
            //
            // We have exhausted the list. We didn't find a match.
            //
            IF_DEBUG(CACHE) {
                LdapPrint0("Sorry, atleast one attribute is not cacheable\n");
            }
            return CacheStateNonCachableAttribute;
        }
    }

    ACQUIRE_LOCK( &CacheLock );

    for (i=0; i<MAX_CACHE_SIZE; i++) {


        if (CacheArray[i] != NULL) {

            IF_DEBUG(CACHE) {
                LdapPrint2("Comparing current server %S with cached server %S\n", Connection->DnsSuppliedName, CacheArray[i]->ServerName);
            }

            if (ldapWStringsIdentical( Connection->DnsSuppliedName,
                                       -1,
                                       CacheArray[i]->ServerName,
                                       -1
                                       ) &&
                (CacheArray[i]->PortNumber == Connection->PortNumber)) {

                if ((LdapGetTickCount() - CacheArray[i]->CreateTime) < CACHE_TIMEOUT) {

                    IF_DEBUG(CACHE) {
                        LdapPrint0("AllAttributesAreCacheable: Returning CACHE HIT..\n");
                    }

                    //
                    // Reference the cache page so that it is not replaced.
                    //

                    CacheArray[i]->RefCount++;

                    //
                    // Update the last accessed time.
                    //

                    CacheArray[i]->LastAccessTime = LdapGetTickCount();

                    RELEASE_LOCK( &CacheLock );
                    return CacheStateCacheHit;

                } else {

                    IF_DEBUG(CACHE) {
                        LdapPrint0("AllAttributesAreCacheable: Returning STALE CACHE..\n");
                    }
                    RELEASE_LOCK( &CacheLock );
                    return CacheStateStaleCache;
                }
            }
        }
    }

    RELEASE_LOCK( &CacheLock );

    IF_DEBUG(CACHE) {
        LdapPrint0("AllAttributesAreCacheable: Returning SERVER NOT CACHED!..\n");
    }

    return CacheStateServerNotCached;
}

ULONG
AccessLdapCache (
    IN PLDAP_REQUEST Request,
    IN PLDAP_CONN Connection,
    IN PWCHAR  DistinguishedName,
    IN ULONG   ScopeOfSearch,
    IN PWCHAR  SearchFilter,
    IN PWCHAR  AttributeList[],
    IN ULONG   AttributesOnly,
    IN BOOLEAN Unicode
    )
{
    //
    // We try to see if we already have an unexpired copy of the data in
    // our local cache. If so, we return it and update the access time, mark the
    // request as cached and return. Remember that we must also fill up the buffers
    // of the request with the fabricated LDAP message.
    //
    //
    // We should check to see if ALL of the requested attributes are among the cached
    // attributes. If even one of them is not present, we have to send out a search
    // with ALL attributes and refresh the cache in the process.
    //
    // Since this is a Quick 'n Dirty cache, we have a preconfigured set of attributes
    // which we will cache for each server.
    //
    // subschemaSubentry:
    // dsServiceName:
    // namingContexts:
    // defaultNamingContext:
    // schemaNamingContext:
    // configurationNamingContext:
    // rootDomainNamingContext:
    // supportedControl:
    // supportedLDAPVersion:
    // supportedLDAPPolicies:
    // supportedSASLMechanisms:
    // dnsHostName:
    // ldapServiceName:
    // serverName:
    // supportedCapabilities:
    //
    //
    // Since we will have marked the request as cacheable, when we retrieve the
    // message in our receive pump, we will have to copy the attributes we care
    // about. If the request is marked as a cache hit, we obviously don't copy
    // the attributes.
    //

    DBG_UNREFERENCED_PARAMETER( AttributesOnly );
    DBG_UNREFERENCED_PARAMETER( SearchFilter );
    DBG_UNREFERENCED_PARAMETER( ScopeOfSearch );
    DBG_UNREFERENCED_PARAMETER( DistinguishedName );

    ULONG err = 0;

    err = AllAttributesAreCacheable( Connection,
                                     AttributeList,
                                     Unicode );

    if (err == CacheStateCacheHit) {

        //
        // This was a perfect cache hit. We have to fabricate the appropriate
        // message and add it to the connection buffers.
        //

            Request->CopyResultToCache = FALSE;
            Request->ResultsAreCached = TRUE;

            err = FabricateLdapResult(
                            Request,
                            Connection,
                            Request->OriginalDN,
                            Request->search.AttributeList,
                            Request->search.Unicode
                            );

    } else {

        if ((err == CacheStateStaleCache) || (err == CacheStateServerNotCached)) {

            //
            // We will replace the attribute list with our own cacheable
            // attribute list so that we can cache most attributes.
            //

            PWCHAR *OrigAttrList = Request->search.AttributeList;
            BOOLEAN OrigUnicode = Request->search.Unicode;
            ULONG  OrigAttributesOnly = Request->search.AttributesOnly;

            Request->search.AttributeList = CachedAttributeList;
            Request->search.AttributesOnly = 0;
            Request->search.Unicode = TRUE;

            err = SendLdapSearch(Request,
                                 Connection,
                                 Request->OriginalDN,
                                 Request->search.ScopeOfSearch,
                                 Request->search.SearchFilter,
                                 Request->search.AttributeList,
                                 Request->search.AttributesOnly,
                                 Request->search.Unicode,
                                 (CLdapBer **)&Request->BerMessageSent,
                                 0 );

            //
            // Restore the saved parameters.
            //

            Request->search.AttributeList = OrigAttrList;
            Request->search.Unicode = OrigUnicode;
            Request->search.AttributesOnly = OrigAttributesOnly;

            Request->CopyResultToCache = TRUE;
            Request->ResultsAreCached = FALSE;

        } else if (err == CacheStateNonCachableAttribute) {

            //
            // Query consists of non-cacheable attribute(s). There is nothing we
            // can do except send the search across unaltered.
            //

            err = SendLdapSearch(Request,
                                 Connection,
                                 Request->OriginalDN,
                                 Request->search.ScopeOfSearch,
                                 Request->search.SearchFilter,
                                 Request->search.AttributeList,
                                 Request->search.AttributesOnly,
                                 Request->search.Unicode,
                                 (CLdapBer **)&Request->BerMessageSent,
                                 0 );
        }

    }

    return err;

}

ULONG
FabricateLdapResult (
    IN PLDAP_REQUEST request,
    IN PLDAP_CONN     Connection,
    IN PWCHAR     DistinguishedName,
    IN PWCHAR     AttributeList[],
    IN BOOLEAN    Unicode
    )
{
    //
    // Create a Ber-encoded message and insert it into the message stream.
    //

    ULONG err = LDAP_SUCCESS;
    CLdapBer *lber = NULL;
    ULONG hr = NO_ERROR;
    PLDAP_RECVBUFFER buffer = NULL;
    int CacheIndex = -1;

    lber = new CLdapBer( Connection->publicLdapStruct.ld_version );

    if (lber == NULL) {

        IF_DEBUG(OUTMEMORY) {
            LdapPrint1( "FabricateLdapResult: unable to alloc msg for 0x%x.\n",
                        Connection );
        }

        err = LDAP_NO_MEMORY;
        return err;
    }

    //
    // Depending on the list of requested attributes encode the response
    // message.
    //

    hr = lber->HrStartWriteSequence();      // Start of entire message
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "FabricateLdapResult: startWrite conn 0x%x encoding error of 0x%x.\n",
                        Connection, hr );
        }

        hr = LDAP_ENCODING_ERROR;
        goto returnError;

    } else {            // we can't forget EndWriteSequence

          hr = lber->HrAddValue((LONG) request->MessageId );

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "FabricateLdapResult: MsgNo conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            hr = LDAP_ENCODING_ERROR;
            goto returnError;
        }

        hr = lber->HrStartWriteSequence(LDAP_RES_SEARCH_ENTRY);

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "FabricateLdapResult: cmd conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            hr = LDAP_ENCODING_ERROR;
            goto returnError;

        }

        hr = lber->HrAddValue((const WCHAR *) DistinguishedName );
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "FabricateLdapResult: DN conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            hr = LDAP_ENCODING_ERROR;
            goto returnError;
        }

        //
        // Now, start adding the PartialAttributelist (SEQUENCE OF SEQUENCE)
        //

        hr = lber->HrStartWriteSequence();

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "FabricateLdapResult: DN conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            hr = LDAP_ENCODING_ERROR;
            goto returnError;
        }


        if (AttributeList != NULL) {

            ULONG count = 0;
            PWCHAR *CachedValues = NULL;

            while (AttributeList[count] != NULL) {


            if (!RetrieveFromCache( Connection, AttributeList[count], Unicode, &CacheIndex, &CachedValues)) {

                IF_DEBUG(PARSE) {
                    LdapPrint0( "FabricateLdapResult: RetrieveFromCache failed\n");
                }

                hr = LDAP_NO_MEMORY;
                goto returnError;

            } else if ( CachedValues == NULL ) {

                //
                // The server does not contain this attribute. Don't encode it.
                //

                count++;
                continue;
            }


            hr = lber->HrStartWriteSequence();  // This attribute type
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "FabricateLdapResult: DN conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                hr = LDAP_ENCODING_ERROR;
                goto returnError;
            }
                if (Unicode) {

                    hr = lber->HrAddValue((const WCHAR *) AttributeList[count]);

                } else {

                    hr = lber->HrAddValue((const CHAR *) AttributeList[count]);
                }

                if (hr != NOERROR) {
                    IF_DEBUG(PARSE) {
                        if (Unicode) {
                            IF_DEBUG(CACHE) {
                                LdapPrint3( "FabricateLdapResult: conn 0x%x encoding error of 0x%x, attr = %S.\n",
                                        Connection, hr, AttributeList[count] );
                            }
                        } else {
                            IF_DEBUG(CACHE) {
                                LdapPrint3( "FabricateLdapResult: conn 0x%x encoding error of 0x%x, attr = %s.\n",
                                        Connection, hr, AttributeList[count] );
                            }
                        }
                    }
                    hr = LDAP_ENCODING_ERROR;
                    goto returnError;
                }

                //
                // Here, we encode the value list returned from the cache. Remember
                // that a given attribute type (like supportedcontrols) might be
                // multi-valued.
                //

                hr = lber->HrStartWriteSequence(BER_SET);

                if (hr != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "FabricateLdapResult: cmd conn 0x%x encoding error of 0x%x.\n",
                                    Connection, hr );
                    }
                    hr = LDAP_ENCODING_ERROR;
                    goto returnError;

                }

                ULONG newcount = 0;

                while (CachedValues[newcount] != NULL) {

                    hr = lber->HrAddValue((const WCHAR *) CachedValues[newcount]);

                    if (hr != NOERROR) {

                        IF_DEBUG(PARSE) {
                            LdapPrint2( "FabricateLdapResult: cmd conn 0x%x encoding error of 0x%x.\n",
                                        Connection, hr );
                        }
                        hr = LDAP_ENCODING_ERROR;
                        goto returnError;

                    }

                    //
                    // Free the value once we are done.
                    //

                    ldapFree( CachedValues[newcount], LDAP_VALUE_SIGNATURE );
                    newcount++;
                }

                //
                // End the set
                //

                hr = lber->HrEndWriteSequence();
                ASSERT( hr == NOERROR );

                //
                // End sequence for the PartialAttributeList (Current Attribute type)
                //

                hr = lber->HrEndWriteSequence();
                ASSERT( hr == NOERROR );

                ldapFree( CachedValues, LDAP_VALUE_LIST_SIGNATURE );
                count++;

            }

            //
            // Dereference the cache page after we are done. It is now
            // open for LRU replacement.
            //

            ASSERT( CacheIndex >= 0 );

            ACQUIRE_LOCK( &CacheLock );

            CacheArray[CacheIndex]->RefCount--;

            IF_DEBUG(CACHE) {
                LdapPrint2("FabricateLdapMessage: Refcount is %d, Cacheindex is %d\n",CacheArray[CacheIndex]->RefCount, CacheIndex );
            }

            ASSERT( CacheArray[CacheIndex]->RefCount >=0 );
            RELEASE_LOCK( &CacheLock );

        }

        //
        // End sequence for the PartialAttributeList
        //

        hr = lber->HrEndWriteSequence();
        ASSERT( hr == NOERROR );


        //
        // End sequence for the SearchResultEntry (there is only one for RootDSE)
        //

        hr = lber->HrEndWriteSequence();
        ASSERT( hr == NOERROR );

        //
        // End sequence for the first message
        //

        hr = lber->HrEndWriteSequence();               // Entire Response
        ASSERT( hr == NOERROR );

        //
        // Now, encode the SearchResultDone message.
        //

        hr = lber->HrStartWriteSequence();             // New message

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "FabricateLdapResult: cmd conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            hr = LDAP_ENCODING_ERROR;
            goto returnError;

        }

        hr = lber->HrAddValue((LONG) request->MessageId );

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "FabricateLdapResult: cmd conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            hr = LDAP_ENCODING_ERROR;
            goto returnError;

        }

        hr = lber->HrStartWriteSequence(LDAP_RES_SEARCH_RESULT);

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "FabricateLdapResult: cmd conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            hr = LDAP_ENCODING_ERROR;
            goto returnError;

        }

        hr = lber->HrAddValue((LONG) LDAP_SUCCESS, BER_ENUMERATED );   // Result code

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "FabricateLdapResult: cmd conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            hr = LDAP_ENCODING_ERROR;
            goto returnError;

        }

        hr = lber->HrAddValue((const WCHAR *) NULL);   // Ldap DN

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "FabricateLdapResult: cmd conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            hr = LDAP_ENCODING_ERROR;
            goto returnError;

        }

        hr = lber->HrAddValue((const WCHAR *) NULL);   // Error Message

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "FabricateLdapResult: cmd conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            hr = LDAP_ENCODING_ERROR;
            goto returnError;

        }

        hr = lber->HrEndWriteSequence();               // SearchResultDone
        ASSERT( hr == NOERROR );

        hr = lber->HrEndWriteSequence();               // New Message
        ASSERT( hr == NOERROR );


        //
        // Inject the newly created buffer into the receive stream.
        //

        buffer = LdapGetReceiveStructure(lber->CbData());

        if (buffer == NULL) {

            IF_DEBUG(OUTMEMORY) {
                LdapPrint0( "FabricateLdapResult: failed to get receive buffer\n");
            }

            goto returnError;
        }

        buffer->NumberOfBytesReceived = lber->CbData();
        buffer->Connection = Connection;

        //
        // Copy the value field over
        //

        CopyMemory( (PCHAR) &buffer->DataBuffer[0],
                     lber->PbData(),
                     lber->CbData()
                    );

        ACQUIRE_LOCK( &ConnectionListLock );

        InsertTailList( &Connection->CompletedReceiveList,
                        &buffer->ReceiveListEntry );

        RELEASE_LOCK( &ConnectionListLock );

        delete lber;
        lber = NULL;
    }


    return err;

returnError:

    SetConnectionError( Connection, hr, NULL );

    if (lber != NULL) {

       delete lber;
    }

    return hr;
}


BOOLEAN
RetrieveFromCache(
  IN PLDAP_CONN  Connection,
  IN PWCHAR AttributeName,
  IN BOOLEAN Unicode,
  IN OUT int *CacheIndex,
  IN OUT PWCHAR **ValueList
 )
{
    //
    // Takes in an Attribute name (like SupportedSaslMechanisms) and returns the
    // cached value. Since there could be multiple values for a given function,
    // a null-terminated list of attribute values is returned. It is the caller's
    // responsibility to free the string.
    //

    int CurrentCacheIndex = -1;
    int i, err;
    PWCHAR *pPtrArr = NULL;

    if (!ValueList) {
        return FALSE;
    }

    *ValueList = NULL;

    //
    // Discover the CachePage position if we don't know about it
    //

    ACQUIRE_LOCK( &CacheLock );

    if (*CacheIndex == -1) {

        for (i = 0; i<MAX_CACHE_SIZE; i++) {

            if ((CacheArray[i]) &&
                (ldapWStringsIdentical( Connection->DnsSuppliedName,
                                        -1,
                                        CacheArray[i]->ServerName,
                                        -1) ) &&
                (CacheArray[i]->PortNumber == Connection->PortNumber)) {

                *CacheIndex = i;
                break;
            }
        }
    }

    CurrentCacheIndex = *CacheIndex;

    if (CurrentCacheIndex == -1) {
        LdapPrint0("RetrieveFromCache: CachePage missing in late stage\n");
        ASSERT(CurrentCacheIndex != -1);
        SetConnectionError(Connection, LDAP_LOCAL_ERROR, NULL );
        RELEASE_LOCK( &CacheLock );
        return FALSE;
    }

    ASSERT( CacheArray[CurrentCacheIndex]->RefCount > 0 );

    //
    // Update the last accessed time.
    //

    CacheArray[CurrentCacheIndex]->LastAccessTime = LdapGetTickCount();

    //
    // Find out number of values present for the given AttributeType
    // We need this so that we can allocate the array needed to store it.
    //

    int AttrIndex = -1;

    //
    // Temporarily convert to UNICODE to perform the comparision
    //

    PWCHAR wAttrName = AttributeName;

    if (!Unicode) {

        err = ToUnicodeWithAlloc( (PCHAR) AttributeName,
                                  -1,
                                  &wAttrName,
                                  LDAP_UNICODE_SIGNATURE,
                                  LANG_ACP
                                  );

        if (err != LDAP_SUCCESS) {

            SetConnectionError( Connection, err, NULL );
            RELEASE_LOCK( &CacheLock );
            return FALSE;
        }
    }


    //
    // Discover the attribute index in the CachePage.
    //

    for (i=0; i<NUM_CACHED_ATTR; i++) {

        if (ldapWStringsIdentical(wAttrName,
                                   -1,
                                   CacheArray[CurrentCacheIndex]->CacheTemplate[0][i],
                                   -1 ) ) {

                    IF_DEBUG(PARSE) {
                        LdapPrint1("Found cache match for attribute %S\n",wAttrName );
                    }

                AttrIndex = i;
            }
    }

    if (!Unicode) {
        ldapFree( wAttrName, LDAP_UNICODE_SIGNATURE );
    }

    if (AttrIndex != -1) {

        PWCHAR* CurrentAttributeList = (PWCHAR*) CacheArray[CurrentCacheIndex]->CacheTemplate[1][AttrIndex];

        //
        // Count the number of values for the given attribute.
        //

        int NumValues;

        for (NumValues=0; CurrentAttributeList && (CurrentAttributeList[NumValues] != NULL); NumValues++) ;

        pPtrArr = (PWCHAR*) ldapMalloc(sizeof(PWCHAR)*(NumValues+1), LDAP_VALUE_LIST_SIGNATURE);

        if (pPtrArr == NULL) {

            SetConnectionError(Connection, LDAP_NO_MEMORY, NULL );
            RELEASE_LOCK( &CacheLock );
            return FALSE;
        }

        //
        // Now, copy the values to the array
        //

        PWCHAR* temp = (PWCHAR*) CacheArray[CurrentCacheIndex]->CacheTemplate[1][AttrIndex];

        for (i=0; i<NumValues; i++) {

            pPtrArr[i] = ldap_dup_stringW( temp[i],
                                           0,
                                           LDAP_VALUE_SIGNATURE);

            if (pPtrArr[i] == NULL) {
                RELEASE_LOCK( &CacheLock );
                return FALSE;
            }

        }

    }

    RELEASE_LOCK( &CacheLock );
    *ValueList = pPtrArr;
    return TRUE;

}

BOOLEAN
ValidateServerReturnedAttrList(
    PLDAP_CONN   Connection,
    PLDAPMessage message
    )
{
    //
    // Validate the server's returned response.  It must contain only those attributes
    // we asked for, and must not exceed the number of cachable attributes.
    //
    ULONG i;
    ULONG cAttr = 0;
    struct berelement *opaque = NULL;

    
    PWCHAR srvAttr = LdapFirstAttribute( Connection,
                                         message,
                                         (BerElement **) &opaque,
                                         TRUE );

    while (srvAttr != NULL) {

        cAttr++;

        // Is it on our list?
        for (i=0; i<NUM_CACHED_ATTR; i++) {

            if (ldapWStringsIdentical(srvAttr,
                                      -1,
                                      CachedAttributeList[i],
                                      -1)) {
                break;
            }

        }

        if (i == NUM_CACHED_ATTR) {

            // Server returned bogus attribute
            IF_DEBUG(CACHE){
                LdapPrint1("Server returned bad attr %S\n",srvAttr);
            }
            
            return FALSE;
        }

        srvAttr = LdapNextAttribute( Connection,
                                       message,
                                       opaque,
                                       TRUE );
    }

    if (cAttr > NUM_CACHED_ATTR) {

        // Server returned too many attributes
        IF_DEBUG(CACHE){
            LdapPrint1("Server returned too many (%d) attrs\n", cAttr);
        }
        
        return FALSE;
    }


    return TRUE;
}

BOOLEAN
CopyResultToCache(
  PLDAP_CONN   Connection,
  PLDAPMessage Result
 )
{
    //
    // Makes a copy of the incoming ldap message into the cache. Returns TRUE
    // if it could copy a cache page and FALSE if unsuccessful.
    //

    int i, err;

    IF_DEBUG(CACHE){
        LdapPrint1("Copying RootDSE of %S to cache...\n",Connection->DnsSuppliedName );
    }

    if (Result == NULL) {

        return FALSE;
    }

    //
    // Step through the first (and only) entry, If it is missing, there
    // is nothing to do.
    //

    PLDAPMessage message = ldap_first_record(Connection,
                                             Result,
                                             LDAP_RES_SEARCH_ENTRY );
    if (message == NULL) {

        return FALSE;
    }


    // Make sure the server gave us what we asked for
    if (!ValidateServerReturnedAttrList(Connection, message)) {
    
        return FALSE;
    }
    
    //
    // Figure out which CachePage we can use to store this data.
    //

    int CacheIndex = -1;
    int lruIndex = -1;
    ULONGLONG lru = 0;
    int firstAvailableSlot = -1;

    ACQUIRE_LOCK( &CacheLock );

    if (GlobalLdapShuttingDown == TRUE) {

        //
        // The client is terminating
        //

        RELEASE_LOCK( &CacheLock );
        return FALSE;
    }

    for (i = 0; i<MAX_CACHE_SIZE; i++) {

        if (CacheArray[i] == NULL) {

            if (firstAvailableSlot == -1) {
                firstAvailableSlot = i;
            }

        } else if (ldapWStringsIdentical( Connection->DnsSuppliedName,
                                          -1,
                                          CacheArray[i]->ServerName,
                                          -1) &&
                   (CacheArray[i]->PortNumber == Connection->PortNumber)) {

            CacheIndex = i;
            break;

        } else {

            //
            // Make a note of the Least Recently Used CachePage.
            // Might be useful later if we don't find any empty pages.
            // If a page is referenced, don't even think about replacing
            // it.
            //

            if ((lruIndex == -1) && (CacheArray[i]->RefCount == 0)) {

                lruIndex = i;
                lru = CacheArray[i]->LastAccessTime;

            } else if ((lruIndex != -1) &&
                       (lru > CacheArray[i]->LastAccessTime) &&
                       (CacheArray[i]->RefCount == 0))  {

                lruIndex = i;
                lru = CacheArray[i]->LastAccessTime;
            }
        }
    }


    if (CacheIndex == -1) {

        //
        // We didn't find a match.
        //

        if ((firstAvailableSlot == -1) && (lruIndex == -1)) {

            //
            // and there is no space to create a new page, Sorry!
            //

            IF_DEBUG(CACHE){
                LdapPrint0("No space to cache new server RootDSE, increase MAX_CACHE_SIZE\n");
            }
            RELEASE_LOCK( &CacheLock );
            return FALSE;

        } else if ((lruIndex != -1) && (firstAvailableSlot == -1)) {

            //
            // Luckily, we can delete an existing page.
            //

            IF_DEBUG(CACHE){
                LdapPrint1("Deleting existing page %d for lack of space\n",lruIndex);
            }
            FreeCachePage( CacheArray[lruIndex] );
            CacheArray[lruIndex] = NULL;
            CacheIndex = lruIndex;

        } else {

            //
            // We found an existing empty slot to create a new page.
            //

            IF_DEBUG(CACHE){
                LdapPrint1("Found empty slot %d, creating new cache page\n", firstAvailableSlot);
            }
            CacheIndex = firstAvailableSlot;
        }

        //
        // Create the new page
        //

        CacheArray[CacheIndex] = (PCACHEHOLDER) ldapMalloc(sizeof(CACHEHOLDER), LDAP_VALUE_SIGNATURE);

        if (CacheArray[CacheIndex] == NULL) {
            SetConnectionError(Connection, LDAP_NO_MEMORY, NULL);
            RELEASE_LOCK( &CacheLock );
            return FALSE;
        }

        CacheArray[CacheIndex]->ServerName = ldap_dup_stringW(Connection->DnsSuppliedName,
                                                              0,
                                                              LDAP_HOST_NAME_SIGNATURE
                                                              );
        if (CacheArray[CacheIndex]->ServerName == NULL) {

            ldapFree(CacheArray[CacheIndex], LDAP_VALUE_SIGNATURE);
            CacheArray[CacheIndex] = NULL;

            SetConnectionError(Connection, LDAP_NO_MEMORY, NULL);
            RELEASE_LOCK( &CacheLock );
            return FALSE;
        }

        CacheArray[CacheIndex]->PortNumber = Connection->PortNumber;

    }

    IF_DEBUG(CACHE) {
        LdapPrint2("CopyResultToCache: refcount is %d, CacheIndex is %d\n", CacheArray[CacheIndex]->RefCount, CacheIndex);
    }

    CacheArray[CacheIndex]->CreateTime = LdapGetTickCount();
    CacheArray[CacheIndex]->LastAccessTime = LdapGetTickCount();

    struct berelement *opaque = NULL;

    PWCHAR attribute = LdapFirstAttribute( Connection,
                                  message,
                                  (BerElement **) &opaque,
                                  TRUE );

    i = 0;

    while (attribute != NULL) {

        PWCHAR *values = NULL;
        ULONG count;
        PWCHAR *dest = NULL;
        PWCHAR currentVal = NULL;

        err = LdapGetValues(Connection,
                            message,
                            attribute,
                            FALSE,
                            TRUE,       // return in Unicode
                            (PVOID *) &values
                            );

        ULONG totalValues = ldap_count_valuesW( values );

        //
        // Free the existing attribute name and store the new one
        // inside.
        //

        if (CacheArray[CacheIndex]->CacheTemplate[0][i] != NULL) {

            ldapFree(CacheArray[CacheIndex]->CacheTemplate[0][i], LDAP_VALUE_SIGNATURE);
        }

        CacheArray[CacheIndex]->CacheTemplate[0][i] = ldap_dup_stringW(attribute,
                                                                       0,
                                                                       LDAP_VALUE_SIGNATURE);

        if (CacheArray[CacheIndex]->CacheTemplate[0][i] == NULL) {
            RELEASE_LOCK( &CacheLock );
            SetConnectionError( Connection, LDAP_NO_MEMORY, NULL );
            return FALSE;
        }


        if (CacheArray[CacheIndex]->CacheTemplate[1][i] != NULL) {

            //
            // Free the existing value list and values.
            //

            PWCHAR *CurrentVal = (PWCHAR*) CacheArray[CacheIndex]->CacheTemplate[1][i];

            for (int j=0; (CurrentVal[j]!= NULL) ; j++) {

                ldapFree( CurrentVal[j], LDAP_VALUE_SIGNATURE );
            }

            ldapFree( CurrentVal, LDAP_VALUE_LIST_SIGNATURE );
            CacheArray[CacheIndex]->CacheTemplate[1][i] = NULL;
        }

        dest = (PWCHAR*) ldapMalloc(sizeof(PWCHAR)*(totalValues+1), LDAP_VALUE_LIST_SIGNATURE);

        if (dest == NULL) {
            RELEASE_LOCK( &CacheLock );
            SetConnectionError( Connection, LDAP_NO_MEMORY, NULL );
            return FALSE;
        }

        //
        // Since we can't have multidimensional arrays with
        // different data types in each dimension, we have to play
        // some tricks here by using the second row of the cache as
        // PWCHAR* instead of PWCHAR. This is because an attribute
        // can be multivalued.
        //

        CacheArray[CacheIndex]->CacheTemplate[1][i] = (PWCHAR) dest;

        for (count = 0; count < totalValues; count++, currentVal++ ) {

            //
            // Copy the values
            //

            dest[count] = ldap_dup_stringW(values[count],
                                    0,
                                    LDAP_VALUE_SIGNATURE
                                    );
        }

        ldap_value_freeW( values );
        i++;
        attribute = LdapNextAttribute( Connection,
                                       message,
                                       opaque,
                                       TRUE );

    }  // while (attribute != NULL)

    //
    // Bump the refcount. We know that we will access this page immediately.
    //

    CacheArray[CacheIndex]->RefCount++;
    RELEASE_LOCK( &CacheLock );

    return TRUE;

}

// cache.cxx eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\compare.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    compare.cxx handle compare requests to an LDAP server

Abstract:

   This module implements the LDAP compare APIs.

Author:

    Andy Herron (andyhe)        02-Jul-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

//
//  This is the client API to allow comparing objects to the directory.
//
ULONG
LdapCompare (
    PLDAP_CONN connection,
    PWCHAR DistinguishedName,
    PWCHAR Attribute,
    PWCHAR Value,           // either value or Data is not null, not both
    struct berval   *Data,
    BOOLEAN Unicode,
    BOOLEAN Synchronous,
    PLDAPControlW   *ServerControls,
    PLDAPControlW   *ClientControls,
    ULONG           *MessageNumber
    )
{
    ULONG hr;
    PLDAP_REQUEST request = NULL;
    ULONG messageNumber;
    ULONG err;

    if (MessageNumber == NULL) {

        return LDAP_PARAM_ERROR;
    }

    *MessageNumber = (ULONG) -1;

    err = LdapConnect( connection, NULL, FALSE );

    if (err != 0) {
       return err;
    }

    SetConnectionError( connection, LDAP_SUCCESS, NULL );

    request = LdapCreateRequest( connection, LDAP_COMPARE_CMD );

    if (request == NULL) {

        IF_DEBUG(OUTMEMORY) {
            LdapPrint1( "ldap_compare connection 0x%x couldn't allocate request.\n", connection);
        }
        hr = LDAP_NO_MEMORY;
        SetConnectionError( connection, hr, NULL );
        return hr;
    }

    messageNumber = request->MessageId;

    request->Synchronous = Synchronous;

    hr = LDAP_SUCCESS;

    if ((ServerControls != NULL) || (ClientControls != NULL)) {

        hr = LdapCheckControls( request,
                                ServerControls,
                                ClientControls,
                                Unicode,
                                0 );

        if (hr != LDAP_SUCCESS) {

            IF_DEBUG(CONTROLS) {
                LdapPrint2( "ldap_comp connection 0x%x trouble with SControl, err 0x%x.\n",
                            connection, hr );
            }
        }
    }

    if (hr == LDAP_SUCCESS) {

        if (Synchronous || (request->ChaseReferrals == 0)) {

            request->AllocatedParms = FALSE;
            request->OriginalDN = DistinguishedName;
            request->compare.Attribute = Attribute;
            request->compare.Value = Value;
            if (Data) {

                request->compare.Data.bv_val = Data->bv_val;
                request->compare.Data.bv_len = Data->bv_len;
            }

        } else {

            request->AllocatedParms = TRUE;

            if (DistinguishedName != NULL) {

                request->OriginalDN = ldap_dup_stringW( DistinguishedName, 0, LDAP_UNICODE_SIGNATURE );

                if (request->OriginalDN == NULL) {

                    hr = LDAP_NO_MEMORY;
                }
            }

            if ((hr == LDAP_SUCCESS) && ((Value != NULL) || (Data != NULL))) {

                request->compare.Attribute = ldap_dup_stringW( Attribute, 0, LDAP_UNICODE_SIGNATURE );

                if (request->compare.Attribute == NULL) {

                    hr = LDAP_NO_MEMORY;
                }
            }

            if ((hr == LDAP_SUCCESS) && (Value != NULL)) {

                request->compare.Value = ldap_dup_stringW( Value, 0, LDAP_UNICODE_SIGNATURE );

                if (request->compare.Value == NULL) {

                    hr = LDAP_NO_MEMORY;
                }
            }

            if ((hr == LDAP_SUCCESS) &&
                (Data != NULL) &&
                (Data->bv_val != NULL) &&
                (Data->bv_len > 0)) {

                request->compare.Data.bv_val = (PCHAR) ldapMalloc(
                                Data->bv_len,
                                LDAP_COMPARE_DATA_SIGNATURE );

                if (request->compare.Data.bv_val == NULL) {

                    hr = LDAP_NO_MEMORY;

                } else {

                    CopyMemory( request->compare.Data.bv_val,
                                Data->bv_val,
                                Data->bv_len );

                    request->compare.Data.bv_len = Data->bv_len;

                }
            }
        }
    }

    if (hr == LDAP_SUCCESS) {

        START_LOGGING;
        DSLOG((DSLOG_FLAG_TAG_CNPN,"[+]"));
        DSLOG((0,"[ID=%d][OP=ldap_compare][DN=%ws][ST=%I64d][ATTR=%ws][-]\n",
               request->MessageId, DistinguishedName, request->RequestTime,
               Attribute));
        END_LOGGING;

        hr = SendLdapCompare( request,
                              connection,
                              (CLdapBer **)&request->BerMessageSent,
                              request->OriginalDN,
                              0 );
    }

    if (hr != LDAP_SUCCESS) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "ldap_compare connection 0x%x errored with 0x%x.\n",
                        connection, hr );
        }

        DSLOG((0,"[+][ID=%d][ET=%I64d][ER=%d][-]\n",request->MessageId,LdapGetTickCount(), hr));
        messageNumber = (ULONG) -1;
        SetConnectionError( connection, hr, NULL );

        CloseLdapRequest( request );
    }

    *MessageNumber = messageNumber;

    DereferenceLdapRequest( request );
    return hr;
}

ULONG
SendLdapCompare (
    PLDAP_REQUEST Request,
    PLDAP_CONN Connection,
    CLdapBer **Lber,
    PWCHAR DistinguishedName,
    LONG AltMsgId
    )
{
    PWCHAR Attribute = Request->compare.Attribute;
    PWCHAR Value = Request->compare.Value;
    struct berval   *Data = &Request->compare.Data;
    ULONG hr;

    CLdapBer *lber = new CLdapBer( Connection->publicLdapStruct.ld_version );

    if (lber == NULL) {
        SetConnectionError( Connection, LDAP_NO_MEMORY, NULL );
        return LDAP_NO_MEMORY;
    }

    //
    //  The request looks like the following :
    //
    //     CompareRequest ::=
    //         [APPLICATION 14] SEQUENCE {
    //              entry          LDAPDN,
    //              ava            SEQUENCE {
    //                                  type          AttributeType,
    //                                  value         AttributeValue
    //                             }
    //         }
    //

    hr = lber->HrStartWriteSequence();
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldap_compare startWrite conn 0x%x encoding error of 0x%x.\n",
                        Connection, hr );
        }

        goto encodingError;

    } else {            // we can't forget EndWriteSequence

       if (AltMsgId != 0) {

          hr = lber->HrAddValue((LONG) AltMsgId );

       } else {

          hr = lber->HrAddValue((LONG) Request->MessageId );
       }

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldap_compare MsgNo conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            goto encodingError;
        }

        hr = lber->HrStartWriteSequence(LDAP_COMPARE_CMD);
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldap_compare cmd conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            goto encodingError;

        } else {        // we can't forget EndWriteSequence

            hr = lber->HrAddValue((const WCHAR *) DistinguishedName );
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_compare DN conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                goto encodingError;
            }

            //
            //  add the attribute list and we're done.
            //

            hr = lber->HrStartWriteSequence();
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_compare 1 conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                goto encodingError;

            } else {        // we can't forget EndWriteSequence

                hr = lber->HrAddValue((const WCHAR *) Attribute );
                if (hr != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "ldap_compare 2 conn 0x%x encoding error of 0x%x.\n",
                                    Connection, hr );
                    }
                    goto encodingError;
                }

                if ((Data->bv_len > 0) && (Data->bv_val != NULL)) {

                    hr = lber->HrAddBinaryValue((BYTE *) Data->bv_val,
                                                        Data->bv_len );

                } else {

                    hr = lber->HrAddValue((const WCHAR *) Value );
                }

                if (hr != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "ldap_compare 3 conn 0x%x encoding error of 0x%x.\n",
                                    Connection, hr );
                    }
                    goto encodingError;
                }

                hr = lber->HrEndWriteSequence();
                ASSERT( hr == NOERROR );
            }

            hr = lber->HrEndWriteSequence();
            ASSERT( hr == NOERROR );
        }

        //
        //  put in the server controls here if required
        //

        if ( (Connection->publicLdapStruct.ld_version != LDAP_VERSION2) &&
             ( Request->ServerControls != NULL )) {

            hr = InsertServerControls( Request, Connection, lber );

            if (hr != LDAP_SUCCESS) {

                if (lber != NULL) {
                   delete lber;
                }
                return hr;
            }
        }

        hr = lber->HrEndWriteSequence();
        ASSERT( hr == NOERROR );
    }

    //
    //  send the compare request.
    //
    
    ACQUIRE_LOCK( &Connection->ReconnectLock );

    AddToPendingList( Request, Connection );

    hr = LdapSend( Connection, lber );

    if (hr != LDAP_SUCCESS) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "ldap_compare connection 0x%x send with error of 0x%x.\n",
                        Connection, hr );
        }
        DecrementPendingList( Request, Connection );

    } else {

        //
        //  Save off the lber value, free any lber message that is already
        //  present.
        //

        lber = (CLdapBer *) InterlockedExchangePointer((PVOID *) Lber,
                                                       (PVOID) lber );
    }

    RELEASE_LOCK( &Connection->ReconnectLock );

    if (lber != NULL) {

       delete lber;
    }

    return hr;

encodingError:

    if (lber != NULL) {
        delete lber;
    }

    return LDAP_ENCODING_ERROR;
}

ULONG __cdecl
ldap_compareW (
    LDAP *ExternalHandle,
    PWCHAR DistinguishedName,
    PWCHAR Attribute,
    PWCHAR Value
    )
{
    PLDAP_CONN connection = NULL;
    ULONG err;
    ULONG msgId;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapCompare(connection,
                      DistinguishedName,
                      Attribute,
                      Value,
                      NULL,
                      TRUE,
                      FALSE,
                      NULL,
                      NULL,
                      &msgId
                      );

    DereferenceLdapConnection( connection );

    return msgId;
}

ULONG __cdecl
ldap_compare (
    LDAP *ExternalHandle,
    PCHAR DistinguishedName,
    PCHAR Attribute,
    PCHAR Value
    )
{
    ULONG err;
    ULONG msgId = (ULONG) -1;

    err = ldap_compare_extA(ExternalHandle,
                            DistinguishedName,
                            Attribute,
                            Value,
                            NULL,
                            NULL,
                            NULL,
                            &msgId
                            );
    return msgId;
}


ULONG __cdecl
ldap_compare_sW (
    LDAP *ExternalHandle,
    PWCHAR DistinguishedName,
    PWCHAR Attribute,
    PWCHAR Value
    )
{
    return ldap_compare_ext_sW(  ExternalHandle,
                                 DistinguishedName,
                                 Attribute,
                                 Value,
                                 NULL,
                                 NULL,
                                 NULL
                                 );
}

ULONG __cdecl
ldap_compare_s (
    LDAP *ExternalHandle,
    PCHAR DistinguishedName,
    PCHAR Attribute,
    PCHAR Value
    )
{
    return ldap_compare_ext_sA( ExternalHandle,
                                DistinguishedName,
                                Attribute,
                                Value,
                                NULL,
                                NULL,
                                NULL
                                );
}

ULONG __cdecl
ldap_compare_extW(
        LDAP *ExternalHandle,
        PWCHAR DistinguishedName,
        PWCHAR Attr,
        PWCHAR Value,           // either value or Data is not null, not both
        struct berval   *Data,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        ULONG           *MessageNumber
        )
{
    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err =  LdapCompare( connection,
                        DistinguishedName,
                        Attr,
                        Value,
                        Data,
                        TRUE,
                        FALSE,
                        ServerControls,
                        ClientControls,
                        MessageNumber
                        );

    DereferenceLdapConnection( connection );

    return err;
}


ULONG __cdecl
ldap_compare_extA(
        LDAP *ExternalHandle,
        PCHAR DistinguishedName,
        PCHAR Attr,
        PCHAR Value,           // either value or Data is not null, not both
        struct berval   *Data,
        PLDAPControlA   *ServerControls,
        PLDAPControlA   *ClientControls,
        ULONG           *MessageNumber
        )
{
    ULONG err;
    PWCHAR wName = NULL;
    PLDAP_CONN connection = NULL;
    PWCHAR wAttr = NULL;
    PWCHAR wValue = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if ((connection == NULL) || (MessageNumber == NULL)) {

        err = LDAP_PARAM_ERROR;
        goto error;
    }

    *MessageNumber = (ULONG) -1;

    err = ToUnicodeWithAlloc( DistinguishedName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, LDAP_PARAM_ERROR, NULL );
        goto error;
    }

    err = ToUnicodeWithAlloc( Attr, -1, &wAttr, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, LDAP_PARAM_ERROR, NULL );
        goto error;
    }

    if ((Value != NULL) && (Data == NULL)) {

        err = ToUnicodeWithAlloc( Value, -1, &wValue, LDAP_UNICODE_SIGNATURE, LANG_ACP );

        if (err != LDAP_SUCCESS) {

            SetConnectionError( connection, LDAP_PARAM_ERROR, NULL );
            goto error;
        }
    }

    err = LdapCompare(   connection,
                         wName,
                         wAttr,
                         wValue,
                         Data,
                         FALSE,
                         FALSE,
                         (PLDAPControlW *) ServerControls,
                         (PLDAPControlW *) ClientControls,
                         MessageNumber
                         );

error:
    if (wName)
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    if (wValue)
        ldapFree( wValue, LDAP_UNICODE_SIGNATURE );

    if (wAttr)
        ldapFree( wAttr, LDAP_UNICODE_SIGNATURE );

    if (connection)
        DereferenceLdapConnection( connection );

    return err;
}


ULONG __cdecl
ldap_compare_ext_sW(
        LDAP *ExternalHandle,
        PWCHAR DistinguishedName,
        PWCHAR Attr,
        PWCHAR Value,           // either value or Data is not null, not both
        struct berval   *Data,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls
        )
{
    ULONG msgId;
    ULONG err;
    LDAPMessage *results = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapCompare( connection,
                       DistinguishedName,
                       Attr,
                       Value,
                       Data,
                       TRUE,
                       TRUE,
                       ServerControls,
                       ClientControls,
                       &msgId
                       );

    //
    //  if we error'd out before we sent the request, return the error here.
    //

    if (msgId != (ULONG) -1) {

        //
        //  we simply need to wait for the response to come in.
        //

        err = ldap_result_with_error( connection,
                                      msgId,
                                      LDAP_MSG_ALL,
                                      NULL,           // no timeout value specified
                                      &results,
                                      NULL
                                      );

        if (results == NULL) {

            LdapAbandon( connection, msgId, TRUE );

        } else {

            err = ldap_result2error( ExternalHandle,
                                     results,
                                     TRUE
                                     );
        }
    }

    DereferenceLdapConnection( connection );

    return err;
}

ULONG __cdecl
ldap_compare_ext_sA(
        LDAP *ExternalHandle,
        PCHAR DistinguishedName,
        PCHAR Attr,
        PCHAR Value,            // either value or Data is not null, not both
        struct berval   *Data,
        PLDAPControlA   *ServerControls,
        PLDAPControlA   *ClientControls
        )
{
    ULONG err;
    PWCHAR wName = NULL;
    ULONG msgId;
    LDAPMessage *results = NULL;
    PLDAP_CONN connection = NULL;
    PWCHAR wAttr = NULL;
    PWCHAR wValue = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = ToUnicodeWithAlloc( DistinguishedName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        goto error;
    }

    err = ToUnicodeWithAlloc( Attr, -1, &wAttr, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        goto error;
    }

    if ((Value != NULL) && (Data == NULL)) {

        err = ToUnicodeWithAlloc( Value, -1, &wValue, LDAP_UNICODE_SIGNATURE, LANG_ACP );

        if (err != LDAP_SUCCESS) {

            goto error;
        }
    }

    err = LdapCompare(   connection,
                         wName,
                         wAttr,
                         wValue,
                         Data,
                         FALSE,
                         TRUE,
                         (PLDAPControlW *) ServerControls,
                         (PLDAPControlW *) ClientControls,
                         &msgId
                         );

    //
    //  if we error'd out before we sent the request, return the error here.
    //

    if (msgId != (ULONG) -1) {

        //
        //  otherwise we simply need to wait for the response to come in.
        //

        err = ldap_result_with_error( connection,
                                      msgId,
                                      LDAP_MSG_ALL,
                                      NULL,           // no timeout value specified
                                      &results,
                                      NULL
                                    );

        if (results == NULL) {

            LdapAbandon( connection, msgId, TRUE );

        } else {

            err = ldap_result2error( ExternalHandle,
                                     results,
                                     TRUE
                                     );
        }
    }

error:
    if (wName)
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    if (wAttr)
        ldapFree( wAttr, LDAP_UNICODE_SIGNATURE );

    if (wValue)
        ldapFree( wValue, LDAP_UNICODE_SIGNATURE );

    ASSERT(connection != NULL);
    DereferenceLdapConnection( connection );

    return err;
}

// compare.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\decode.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    decode.cxx   decode data from an LDAP server

Abstract:

   This module handles decoding incoming data from an LDAP server

Author:

    Andy Herron (andyhe)        01-Jun-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"


ULONG __cdecl
ldap_result2error (
    LDAP            *ExternalHandle,
    LDAPMessage     *res,
    ULONG           FreeIt
    )
//
//  This is one of the main entry points of the LDAP API... it returns the
//  error code that the server returned to a requesting client.  We've already
//  parsed out the return code so there's not much work.
//
{
    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);
    if (!connection && ExternalHandle)
    {
        return LDAP_PARAM_ERROR;
    }

    //
    //  since we return -1 on calls such as ldap_search as a message id, we'll
    //  explicitely check for it here.
    //

    if ( res == (LDAPMessage *) -1 ) {

        res = NULL;
    }

    if (res != NULL) {

        LDAPMessage *checkResult = res;

        err = res->lm_returncode;

        while ((checkResult != NULL) &&
               ((checkResult->lm_msgtype == LDAP_RES_REFERRAL) ||
                (checkResult->lm_msgtype == LDAP_RES_SEARCH_ENTRY))) {

            checkResult = checkResult->lm_chain;
        }

        //
        //  return the result from a non-search entry record, rather than just
        //  the first entry in the list.  This is because the server's
        //  return code is stored in the last entry.
        //

        if (checkResult != NULL) {
            err = checkResult->lm_returncode;
        }

        SetConnectionError( connection, err, NULL );

        if ( FreeIt ) {

            ldap_msgfree( res );
        }

    } else {

        if (connection != NULL) {

            err = connection->publicLdapStruct.ld_errno;

        } else {

            err = LDAP_LOCAL_ERROR;
        }
    }

    if (connection)
    {
        DereferenceLdapConnection( connection );
    }

    return err;
}

ULONG
LdapInitialDecodeMessage (
    IN PLDAP_CONN Connection,
    IN PLDAPMessage LdapMsg
    )
//
//  This routine breaks out the return code, opcode, and message number from
//  the response returned by the server.
//
{
    ULONG tag = 0;
    CLdapBer *lber;
    LONG messageNumber;
    ULONG err = LDAP_OPERATIONS_ERROR;
    ULONG hr;
    BOOLEAN enclosingSequence = FALSE;

    lber = (CLdapBer *) (LdapMsg->lm_ber);

    if ( lber == NULL ) {

        return LDAP_LOCAL_ERROR;
    }

    hr = lber->HrStartReadSequence(BER_SEQUENCE);
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldapMsgFromBuff 1 conn 0x%x received protocol error 0x%x .\n",
                            Connection, hr);
        }

protocolError:
        SetConnectionError( Connection, LDAP_PROTOCOL_ERROR, NULL );
        return(LDAP_PROTOCOL_ERROR);
    }

    hr = lber->HrGetValue( &messageNumber );
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldapMsgFromBuff 2 conn 0x%x received protocol error 0x%x .\n",
                            Connection, hr);
        }

        goto protocolError;
    }

    LdapMsg->lm_msgid = GET_BASE_MESSAGE_NUMBER( messageNumber );
    LdapMsg->lm_referral = (USHORT) GET_REFERRAL_NUMBER( messageNumber );

    hr = lber->HrPeekTag( &tag );
    ASSERT( hr == NOERROR );

    //
    //  if this is a UDP connection, skip the DN if specified.
    //

    if ((Connection->UdpHandle != INVALID_SOCKET) &&
        (Connection->publicLdapStruct.ld_version == LDAP_VERSION2) &&
        (tag == BER_OCTETSTRING)) {

        hr = lber->HrSkipElement();
        if ( hr != NOERROR ) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldapMsgFromBuff 11 conn 0x%x received protocol error 0x%x .\n",
                                Connection, hr);
            }
            goto protocolError;
        }

        hr = lber->HrPeekTag( &tag );
        ASSERT( hr == NOERROR );
    }

    if (tag == BER_SEQUENCE) {

        hr = lber->HrStartReadSequence(tag);
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldapMsgFromBuff 3 conn 0x%x received protocol error 0x%x .\n",
                                Connection, hr);
            }

            goto protocolError;
        }

        enclosingSequence = TRUE;

        hr = lber->HrPeekTag( &tag );
        ASSERT( hr == NOERROR );
    }

    //
    //  strip off the protocolOp specification
    //

    LdapMsg->lm_msgtype = tag;
    hr = lber->HrStartReadSequence(LdapMsg->lm_msgtype);

    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldapMsgFromBuff 5 conn 0x%x received protocol error 0x%x .\n",
                            Connection, hr);
        }

        goto protocolError;
    }

    //
    //  based on the message type, process the rest of it.
    //

    switch (LdapMsg->lm_msgtype) {
    case LDAP_RES_BIND:
    case LDAP_RES_SEARCH_RESULT:
    case LDAP_RES_MODIFY:
    case LDAP_RES_ADD:
    case LDAP_RES_DELETE:
    case LDAP_RES_MODRDN:
    case LDAP_RES_COMPARE:
    case LDAP_RES_EXTENDED:

        hr = lber->HrPeekTag( &tag );
        ASSERT( hr == NOERROR );

        if (tag == BER_SEQUENCE) {

            hr = lber->HrStartReadSequence(tag);
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldapMsgFromBuff 6 conn 0x%x received protocol error 0x%x .\n",
                                    Connection, hr);
                }

                goto protocolError;
            }
        }

        hr = lber->HrGetEnumValue( (LONG *) &err );
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldapMsgFromBuff 7 conn 0x%x received protocol error 0x%x .\n",
                                Connection, hr);
            }

            goto protocolError;
        }

        //
        //  there's nothing left to process in this packet.  No need to
        //  process the rest of it as it's just two (or three) EndReadSequences.
        //

        break;

    case LDAP_RES_SEARCH_ENTRY:

        //
        //   save off the offset of the distinguished name since we refer to
        //   it so often
        //

        hr = lber->HrPeekTag( &tag );
        ASSERT( hr == NOERROR );

        if (tag == BER_SEQUENCE) {

            hr = lber->HrStartReadSequence(tag);
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldapMsgFromBuff 8 conn 0x%x received protocol error 0x%x .\n",
                                    Connection, hr);
                }
                goto protocolError;
            }
        }

        hr = lber->HrSetDNLocation();

        if (hr != LDAP_SUCCESS) {

            return hr;
        }

        err = 0;

        //
        //  searchEntry response can fail if the DN is absent.
        //

        break;

    case LDAP_RES_REFERRAL:

        //
        //  for a referral, all is well if we simply receive it.
        //

        hr = lber->HrPeekTag( &tag );
        ASSERT( hr == NOERROR );

        if (tag == BER_SEQUENCE) {

            hr = lber->HrStartReadSequence(BER_SEQUENCE);
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldapMsgFromBuff 6 conn 0x%x received protocol error 0x%x .\n",
                                    Connection, hr);
                }

                goto protocolError;
            }
        }

        err = 0;
        break;

    default:

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "ldapMsgFromBuff 10 conn 0x%x received protocol error tag=0x%x .\n",
                            Connection, LdapMsg->lm_msgtype);
        }
        goto protocolError;
    }

    LdapMsg->lm_returncode = err;
    SetConnectionError( Connection, err, NULL );

    return LDAP_SUCCESS;
}

// decode.cxx eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\controls.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    controls.cxx  control block maintencance for the LDAP api

Abstract:

   This module implements routines that handle client and server controls

Author:

    Andy Herron (andyhe)        02-Apr-1997

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

#define LDAP_CONTROL_NOTIFICATIONS_W    L"1.2.840.113556.1.4.528"

ULONG
LdapDupControls (
    PLDAP_REQUEST Request,
    PLDAPControlW **OutputControls,
    PLDAPControlW *InputControls,
    BOOLEAN Unicode,
    ULONG ExtraSlots
    );

ULONG
LdapCheckControls (
    PLDAP_REQUEST Request,
    PLDAPControlW *ServerControls,
    PLDAPControlW *ClientControls,
    BOOLEAN Unicode,
    ULONG   ExtraSlots
    )
{
    ULONG err = LDAP_SUCCESS;

    if (Request->AllocatedControls) {

        ldap_controls_freeW( Request->ServerControls );
        Request->ServerControls = NULL;

        ldap_controls_freeW( Request->ClientControls );
        Request->ClientControls = NULL;

        Request->AllocatedControls = FALSE;
    }

    if ((ServerControls == NULL) &&
        (ClientControls == NULL) &&
        (ExtraSlots == 0)) {

        return LDAP_SUCCESS;
    }

    PLDAPControlW currentControl;

    if (ClientControls != NULL) {

        //
        //  if any of them are mandatory and we don't support them, return error
        //

        PLDAPControlW *controls = ClientControls;

        while (*controls != NULL) {

            currentControl = *controls;

            //
            //  right now it's real easy, the only one we support is the
            //  one that sets referrals options per request
            //

            BOOLEAN setReferrals = FALSE;

            if (Unicode) {

                if (ldapWStringsIdentical( currentControl->ldctl_oid,
                                           -1,
                                           LDAP_CONTROL_REFERRALS_W,
                                           -1 ) == TRUE ) {
                    setReferrals = TRUE;
                }
            } else {

                if (CompareStringA( LDAP_DEFAULT_LOCALE,
                                    NORM_IGNORECASE,
                                    (PCHAR) currentControl->ldctl_oid,
                                    -1,
                                    LDAP_CONTROL_REFERRALS,
                                    -1 ) == 2) {

                    setReferrals = TRUE;
                }
            }

            if (setReferrals) {

                if ((currentControl->ldctl_value.bv_len != sizeof(ULONG)) ||
                    (currentControl->ldctl_value.bv_val == NULL)) {

                    setReferrals = FALSE;       // bad client control

                } else {

                    ULONG refFlags = *((ULONG *)(currentControl->ldctl_value.bv_val));

                    if (refFlags == PtrToUlong(LDAP_OPT_ON)) {

                        Request->ChaseReferrals = (LDAP_CHASE_SUBORDINATE_REFERRALS |
                                                   LDAP_CHASE_EXTERNAL_REFERRALS);

                    } else if (refFlags == PtrToUlong(LDAP_OPT_OFF)) {

                        Request->ChaseReferrals = 0;

                    } else if ((refFlags & (LDAP_CHASE_SUBORDINATE_REFERRALS |
                                            LDAP_CHASE_EXTERNAL_REFERRALS))
                                 != refFlags) {

                        setReferrals = FALSE;       // bad client control

                    } else {

                        Request->ChaseReferrals = LOBYTE( LOWORD( refFlags ) );
                    }
                    IF_DEBUG(REFERRALS) {
                        LdapPrint2( "LdapCheckControls set referrals to 0x%x for request 0x%x\n",
                                    Request->ChaseReferrals, Request );
                    }
                }
            }

            if ((currentControl->ldctl_iscritical) && (setReferrals == FALSE)) {

                IF_DEBUG(API_ERRORS) {
                    LdapPrint1( "LdapCheckControls does not support client control %S\n",
                                currentControl->ldctl_oid );
                }
                return LDAP_UNAVAILABLE_CRIT_EXTENSION;
            }
            controls++;
        }
    }

    
    //
    // Always allocate controls.
    //

    {
        Request->AllocatedControls = TRUE;

        //
        //  grab the controls and store them off on the request block
        //

        if ((ServerControls != NULL) || (ExtraSlots > 0)) {

            err = LdapDupControls( Request,
                                   &Request->ServerControls,
                                    ServerControls,
                                    Unicode,
                                    ExtraSlots );

            if (err != LDAP_SUCCESS) {

                IF_DEBUG(CONTROLS) {
                    LdapPrint1( "LdapCheckControls could not dup server control, err 0x%x\n",
                                err );
                }
                return err;
            }
        }

        if (ClientControls != NULL) {

            err = LdapDupControls( Request,
                                   &Request->ClientControls,
                                    ClientControls,
                                    Unicode,
                                    ExtraSlots );

            if (err != LDAP_SUCCESS) {

                IF_DEBUG(CONTROLS) {
                    LdapPrint1( "LdapCheckControls could not dup client control, err 0x%x\n",
                                err );
                }
                return err;
            }
        }
    }

    return err;
}

ULONG
LdapDupControls (
    PLDAP_REQUEST Request,
    PLDAPControlW **OutputControls,
    PLDAPControlW *InputControls,
    BOOLEAN Unicode,
    ULONG ExtraSlots
    )
//
//  If ExtraSlots is not zero, then instead of converting from ansi to unicode,
//  we just leave them in ansi.  This is used in paged results, since we don't
//  want to convert from ansi to unicode twice.
//
{
    ULONG err = LDAP_SUCCESS;
    ULONG numberEntries = 1;
    PLDAPControlW currentControl;
    PLDAPControlW *controls = InputControls;

    if (controls != NULL) {

        PLDAPControlW temp;

        while (*controls != NULL) {

            temp = *controls;

            //
            // If they pass us an empty control, bail.
            //

            if (temp->ldctl_oid == NULL) {
                break;
            }
            numberEntries++;
            controls++;
        }
    }

    numberEntries += ExtraSlots;

    if (numberEntries == 1) {

        *OutputControls = NULL;
        return LDAP_SUCCESS;
    }

    PLDAPControlW *newArray;
    PLDAPControlW newControl;

    newArray = (PLDAPControlW *) ldapMalloc(
                (numberEntries * sizeof(PLDAPControlW)) +
                ((numberEntries - 1) * sizeof(LDAPControlW)),
                LDAP_CONTROL_LIST_SIGNATURE );

    if (newArray == NULL) {

        return LDAP_NO_MEMORY;
    }

    controls = InputControls;

    newControl = (PLDAPControlW) &(newArray[numberEntries]);

    *OutputControls = newArray;

    //
    //  setup new array of pointers to controls.  set up the copies of the
    //  controls also.
    //

    while ((--numberEntries) > 0 && (err == LDAP_SUCCESS)) {

        if (controls != NULL) {

            currentControl = *controls;

        } else {

            currentControl = NULL;
        }

        *newArray = newControl;

        //
        //  take into account that we may have some empty entries at the
        //  end, though we still setup the pointers for them.  These are for
        //  for the server sort and paged results control.
        //

        if (currentControl != NULL) {

            newControl->ldctl_iscritical = currentControl->ldctl_iscritical;

            if (Unicode) {

                newControl->ldctl_oid = ldap_dup_stringW(
                                                currentControl->ldctl_oid,
                                                0,
                                                LDAP_VALUE_SIGNATURE );

                err = (newControl->ldctl_oid == NULL) ? LDAP_NO_MEMORY : LDAP_SUCCESS;

            } else if (ExtraSlots > 0) {

                newControl->ldctl_oid = (PWCHAR) ldap_dup_string(
                            (PCHAR) currentControl->ldctl_oid,
                            0,
                            LDAP_VALUE_SIGNATURE );

                err = (newControl->ldctl_oid == NULL) ? LDAP_NO_MEMORY : LDAP_SUCCESS;
                

            } else {

                err = ToUnicodeWithAlloc( (PCHAR) currentControl->ldctl_oid,
                                          -1,
                                          &newControl->ldctl_oid,
                                          LDAP_VALUE_SIGNATURE,
                                          LANG_ACP );
                

            }

            if (err != LDAP_SUCCESS) {

               break;
            }

            if (ldapWStringsIdentical( newControl->ldctl_oid,
                                       -1,
                                       LDAP_CONTROL_NOTIFICATIONS_W,
                                       -1) == TRUE) {
                
                IF_DEBUG(CONTROLS) {
                    LdapPrint0("Detected a notifications request\n");
                }
                Request->NotificationSearch = TRUE;
            }

            newControl->ldctl_value.bv_len = currentControl->ldctl_value.bv_len;

            if (newControl->ldctl_value.bv_len > 0) {

                newControl->ldctl_value.bv_val = (PCHAR) ldapMalloc(
                                        newControl->ldctl_value.bv_len,
                                        LDAP_CONTROL_SIGNATURE );

                if (newControl->ldctl_value.bv_val == NULL) {
                
                    err = LDAP_NO_MEMORY;
                    break;
                }

                CopyMemory( newControl->ldctl_value.bv_val,
                            currentControl->ldctl_value.bv_val,
                            newControl->ldctl_value.bv_len );
            }

            controls++;
        }

        newArray++;
        newControl++;
    }

    *newArray = NULL;

    if (err != LDAP_SUCCESS) {

        ldap_controls_freeW( *OutputControls );
        *OutputControls = NULL;
    }

    return err;
}

BOOLEAN
LdapCheckForMandatoryControl (
    PLDAPControlW *Controls
    )
{
    if (Controls == NULL) {

        return FALSE;
    }

    PLDAPControlW currentControl;

    //
    //  if any of them are mandatory and we don't support them, return error
    //

    while (*Controls != NULL) {

        currentControl = *Controls;

        if (currentControl->ldctl_iscritical) {

            return TRUE;
        }

        Controls++;
    }
    return FALSE;
}

ULONG
InsertServerControls (
    PLDAP_REQUEST Request,
    PLDAP_CONN Connection,
    CLdapBer *lber
    )
{
    ULONG hr;

    if ((Request->ServerControls == NULL) ||
        (*(Request->ServerControls) == NULL)) {

        return LDAP_SUCCESS;
    }

    PLDAPControlW currentControl;
    PLDAPControlW *controls = Request->ServerControls;

    hr = lber->HrStartWriteSequence( 0xA0 );    // constructed
                                                // context specific
                                                // tag is 0
    if (hr != NOERROR) {

        IF_DEBUG(CONTROLS) {
            LdapPrint2( "InsertServerControls conn 0x%x encoding error of 0x%x.\n",
                        Connection, hr );
        }
        return hr;

    } else {        // we can't forget EndWriteSequence

        while (*controls != NULL) {

            currentControl = *controls;

            hr = lber->HrStartWriteSequence();

            if (hr != NOERROR) {

                break;
            }

            hr = lber->HrAddValue((const WCHAR *) currentControl->ldctl_oid);

            if (hr != NOERROR) {

                IF_DEBUG(CONTROLS) {
                    LdapPrint3( "InsertServerControls conn 0x%x encoding error of 0x%x, oid = %S.\n",
                                Connection, hr, currentControl->ldctl_oid );
                }
                return hr;
            }

            hr = lber->HrAddValue((BOOLEAN) currentControl->ldctl_iscritical, BER_BOOLEAN );
            if (hr != NOERROR) {

                IF_DEBUG(CONTROLS) {
                    LdapPrint3( "InsertServerControls conn 0x%x encoding crit err 0x%x, oid = %S.\n",
                                Connection, hr, currentControl->ldctl_oid );
                }
                return hr;
            }

            hr = lber->HrAddBinaryValue((BYTE *) currentControl->ldctl_value.bv_val,
                                                 currentControl->ldctl_value.bv_len );
            if (hr != NOERROR) {

                IF_DEBUG(CONTROLS) {
                    LdapPrint3( "InsertServerControls conn 0x%x encoding value err 0x%x, oid = %S.\n",
                                Connection, hr, currentControl->ldctl_oid );
                }
                return hr;
            }

            hr = lber->HrEndWriteSequence();
            ASSERT( hr == NOERROR );

            controls++;
        }

        hr = lber->HrEndWriteSequence();
        ASSERT( hr == NOERROR );
    }

    return hr;
}


ULONG
LdapRetrieveControlsFromMessage (
    PLDAPControlW **ControlArray,
    ULONG codePage,
    CLdapBer *Lber
    )
{
    //
    //  coming in here, we've just started reading the sequence of controls.
    //
    //  This gets a bit tricky.  Since we don't want to keep manipulating
    //  the array of controls, we'll first count the number of controls
    //  there are in the message, allocate the array, and then go back and
    //  read them in.
    //
    //      Controls ::= SEQUENCE OF Control
    //
    //      Control ::= SEQUENCE {
    //              controlType             LDAPOID,
    //              criticality             BOOLEAN DEFAULT FALSE,
    //              controlValue            OCTET STRING OPTIONAL }
    //

    ULONG numberEntries = 1;

    PLDAPControlW *controls = NULL;
    PLDAPControlW newControl;
    ULONG hr = NOERROR;

    *ControlArray = NULL;

    while (hr == NOERROR) {

        hr = Lber->HrStartReadSequence();

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint1( "LdapParseResult couldn't decode control, result 0x%x.\n", hr);
            }
            continue;
        }

        numberEntries++;

        hr = Lber->HrEndReadSequence();
        ASSERT( hr == NOERROR );
    }

    if (numberEntries > 1) {

        controls = (PLDAPControlW *) ldapMalloc(
                    (numberEntries * sizeof(PLDAPControlW)) +
                    ((numberEntries - 1) * sizeof(LDAPControlW)),
                    LDAP_CONTROL_LIST_SIGNATURE );

        if (controls == NULL) {

            hr = LDAP_NO_MEMORY;

        } else {

            ULONG tag = BER_INVALID_TAG;

            // reset the Lber back to the beginning of the controls

            Lber->Reset(FALSE);

            hr = Lber->HrStartReadSequence(BER_SEQUENCE);
            ASSERT( hr == NOERROR );

            hr = Lber->HrSkipElement();     // skip message id
            ASSERT( hr == NOERROR );

            hr = Lber->HrPeekTag( &tag );
            ASSERT( hr == NOERROR );

            if (tag == BER_OCTETSTRING) {  //  if this is a UDP connection, skip the DN if specified.

                hr = Lber->HrSkipElement();
                ASSERT( hr == NOERROR );

                hr = Lber->HrPeekTag( &tag );
                ASSERT( hr == NOERROR );
            }

            if (tag == BER_SEQUENCE) {

                hr = Lber->HrStartReadSequence(tag);
                ASSERT( hr == NOERROR );
            }

            hr = Lber->HrPeekTag( &tag );
            ASSERT( hr == NOERROR );

            hr = Lber->HrStartReadSequence(tag);      // meat of LdapResult
            ASSERT( hr == NOERROR );

            hr = Lber->HrEndReadSequence();
            ASSERT( hr == NOERROR );

            hr = Lber->HrPeekTag( &tag );
            ASSERT( hr == NOERROR );

            hr = Lber->HrStartReadSequence(tag);      // start of controls
            ASSERT( hr == NOERROR );

            newControl = (PLDAPControlW) &(controls[numberEntries]);

            //
            //  setup new array of pointers to controls.  set up the
            //  copies of the controls also.
            //

            *ControlArray = controls;

            if (hr == NOERROR) {

                while ((--numberEntries) > 0 && (hr == NOERROR)) {

                    //
                    //  for each control, save off the OID, criticality, and
                    //  control value into the array of control structures.
                    //

                    *controls = newControl;

                    //      Control ::= SEQUENCE {
                    //              controlType             LDAPOID,
                    //              criticality             BOOLEAN DEFAULT FALSE,
                    //              controlValue            OCTET STRING OPTIONAL }

                    hr = Lber->HrStartReadSequence();

                    if (hr != NOERROR) {

                        IF_DEBUG(PARSE) {
                            LdapPrint1( "LdapParseResult couldn't parse control, result 0x%x.\n", hr);
                        }
                        break;
                    }

                    if (codePage == LANG_UNICODE) {

                        hr = Lber->HrGetValueWithAlloc(&newControl->ldctl_oid);

                    } else {

                        hr = Lber->HrGetValueWithAlloc((PCHAR *) &newControl->ldctl_oid);
                    }

                    if (hr != NOERROR) {

                        IF_DEBUG(PARSE) {
                            LdapPrint1( "LdapParseResult couldn't parse control, result 0x%x.\n", hr);
                        }
                        break;
                    }

                    LONG criticality = 0;

                    hr = Lber->HrGetValue( &criticality, BER_BOOLEAN );

                    newControl->ldctl_iscritical = ((criticality == 0) ? FALSE : TRUE );

                    PBYTE pData = NULL;

                    hr = Lber->HrGetBinaryValuePointer(&pData, &newControl->ldctl_value.bv_len);

                    if (hr != NOERROR) {

                        IF_DEBUG(PARSE) {
                            LdapPrint1( "LdapParseResult couldn't parse control, result 0x%x.\n", hr);
                        }
                        ldapFree( newControl->ldctl_oid, LDAP_VALUE_SIGNATURE );
                        break;
                    }

                    if (newControl->ldctl_value.bv_len > 0) {

                        newControl->ldctl_value.bv_val = (PCHAR) ldapMalloc(
                                                newControl->ldctl_value.bv_len,
                                                LDAP_CONTROL_SIGNATURE );

                        if (newControl->ldctl_value.bv_val == NULL) {

                            ldapFree( newControl->ldctl_oid, LDAP_VALUE_SIGNATURE );
                            hr = LDAP_NO_MEMORY;
                            break;
                        }

                        CopyMemory( newControl->ldctl_value.bv_val,
                                    pData,
                                    newControl->ldctl_value.bv_len );
                    }

                    controls++;
                    newControl++;
                }

                *controls = NULL;
            }
        }
    }

    if ((hr != NOERROR) && (*ControlArray) ){

        ldap_controls_freeW( *ControlArray );
        *ControlArray = NULL;
    }

    return hr;
}


WINLDAPAPI
ULONG LDAPAPI
ldap_free_controlsW (               // old one that can be removed eventually
    PLDAPControlW *Controls
    )
{
    return ldap_controls_freeW( Controls );
}

WINLDAPAPI
ULONG LDAPAPI
ldap_free_controlsA (               // old one that can be removed eventually
        LDAPControlA **Controls
        )
{
    return ldap_free_controlsW( (PLDAPControlW *) Controls );
}

WINLDAPAPI
ULONG LDAPAPI
ldap_controls_freeA (
        LDAPControlA **Controls
        )
{
    return ldap_free_controlsW( (PLDAPControlW *) Controls );
}

WINLDAPAPI
ULONG LDAPAPI
ldap_control_freeA (
        LDAPControlA *Control
        )
{
    return ldap_control_freeW( (PLDAPControlW) Control );
}

WINLDAPAPI
ULONG LDAPAPI
ldap_controls_freeW (
        LDAPControlW **Controls
        )
{
    if (Controls != NULL) {

        PLDAPControlW *controls = Controls;

        //
        //  free the controls
        //

        while (*controls != NULL) {

            ldapFree( (*controls)->ldctl_oid, LDAP_VALUE_SIGNATURE );
            ldapFree( (*controls)->ldctl_value.bv_val, LDAP_CONTROL_SIGNATURE );
            controls++;
        }

        ldapFree( Controls, LDAP_CONTROL_LIST_SIGNATURE );
    }
    return LDAP_SUCCESS;
}

WINLDAPAPI ULONG
LDAPAPI
ldap_control_freeW (
        LDAPControlW *Control
        )
{
    if (Control != NULL) {
        ldapFree( Control->ldctl_oid, LDAP_VALUE_SIGNATURE );
        ldapFree( Control->ldctl_value.bv_val, LDAP_CONTROL_SIGNATURE );
        ldapFree( Control, LDAP_CONTROL_SIGNATURE );
    }
    return LDAP_SUCCESS;
}

// controls.cxx eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\cstream.cxx ===
/***

File: cstream.cxx

Description:

    This is a simple class used to manage the crypto stream
    in streams based protocols (SSL, PCT, Kerberos with packet
    encryption).

Authors:

    Cory West <corywest@microsoft.com>
    Anoop Anantha <AnoopA@microsoft.com>
      - added client certificate authentication code.
      - added StartTLS/StopTLS support.

Copyright (C) 2000 Microsoft Corporation
All rights reserved.

***/

#include "precomp.h"
#pragma hdrstop
#include "cstream.hxx"

SECURITY_STATUS
SSPINegotiateLoop(
    PLDAP_CONN   Connection,
    CtxtHandle * hContext,
    PCredHandle  phCred,
    ULONG        UserMethod,
    PCHAR        UserName,
    BOOL         fDoInitialRead
);

VOID *CryptStream::operator new (
    size_t cSize
    )
{
    return ldapMalloc( (DWORD) cSize, LDAP_SSL_CLASS_SIGNATURE );
}

VOID CryptStream::operator delete (
    VOID *pInstance
    )
{
    ldapFree( pInstance, LDAP_SSL_CLASS_SIGNATURE );
    return;
}

CryptStream::CryptStream(
    PLDAP_CONN pLdapConn,
    PSecurityFunctionTableW encryptFunctionTable,
    BOOLEAN UseSSL
)
/*+++

The only constructor for this class.

---*/
{

    Connection = pLdapConn;

    pCryptoBuffers = NULL;
    dwMaxMessage = 0;

    pbOutboundCrypto = NULL;
    cbOutboundCryptoLen = 0;
    EncryptFunctionTable = encryptFunctionTable;

    hSslCredentials.dwLower = (ULONG) -1;
    hSslCredentials.dwUpper = (ULONG) -1;

    hSslContext.dwUpper = (ULONG) -1;
    hSslContext.dwUpper = (ULONG) -1;

    pbInboundCrypto = NULL;
    cbInboundCryptoLen = 0;
    cbInboundCryptoBytes = 0;

    cbCongestedClearText = 0;

    bCurrentMessageSizeValid = FALSE;

    cbMaxBufferUsed = 0;
    cUnsignsPerformed = 0;

    cbNegotiateBuffer = 0;
    pbNegotiateBuffer = 0;

    if (!UseSSL) {
       
       //
       // Setup the stream sizes here
       //

        int retval = EncryptFunctionTable->QueryContextAttributesW(
                      &Connection->SecurityContext,
                      SECPKG_ATTR_SIZES,
                      (PVOID) &ContextSizes );


        IF_DEBUG( SSL ) {
            
            LdapPrint1("QryContextAttributes returned 0x%x\n",retval);
            LdapPrint4("Negotiate attr sizes %d %d %d %d\n", 
                        ContextSizes.cbMaxToken,
                        ContextSizes.cbMaxSignature,
                        ContextSizes.cbBlockSize,
                        ContextSizes.cbSecurityTrailer );

            SecPkgContext_PackageInfo ContextPackageInfo;

            retval = EncryptFunctionTable->QueryContextAttributesW(
                      &Connection->SecurityContext,
                      SECPKG_ATTR_PACKAGE_INFO,
                      &ContextPackageInfo );

            LdapPrint3( "PackageInfo: %S %S %d\n",
                        ContextPackageInfo.PackageInfo->Name,
                        ContextPackageInfo.PackageInfo->Comment,
                        ContextPackageInfo.PackageInfo->wRPCID
                        );

            if ( retval == SEC_E_OK ) {
                EncryptFunctionTable->FreeContextBuffer( ContextPackageInfo.PackageInfo );
            }
        
        }

        retval = EncryptFunctionTable->QueryContextAttributesW(
                   &Connection->SecurityContext,
                   SECPKG_ATTR_STREAM_SIZES,
                   (PVOID) &SspiStreamSizes );

        if ((retval == SEC_E_OK) && (SspiStreamSizes.cbMaximumMessage != 0)) {
            dwMaxMessage = SspiStreamSizes.cbMaximumMessage;
        }
        else {
            // SSPI package imposes no size restriction
            dwMaxMessage = (DWORD) -1;
        }

        IF_DEBUG(SSL) {
            LdapPrint1("QryContextAttributes for SECPKG_ATTR_STREAM_SIZES returned 0x%x\n",retval);
            LdapPrint4("Stream sizes %d %d %d %d ", 
                        SspiStreamSizes.cbHeader,
                        SspiStreamSizes.cbTrailer,
                        SspiStreamSizes.cbMaximumMessage,
                        SspiStreamSizes.cBuffers);
            LdapPrint1("%d\n", SspiStreamSizes.cbBlockSize);
        }
        

    } else {  // using SSL.

        //
        // Fix up the correct function pointers to use for SSL encrypt/decrypt.
        //

        LdapSslEncrypt = (ENCRYPT_MESSAGE_FN) EncryptFunctionTable->Reserved3;
        LdapSslDecrypt = (DECRYPT_MESSAGE_FN) EncryptFunctionTable->Reserved4;

        ASSERT( LdapSslEncrypt );
        ASSERT( LdapSslDecrypt );

    }
    
    bUseSSL = UseSSL;

    return;
}

CryptStream::~CryptStream(
)
/*+++

The only destructor for this class.

---*/
{
    if ((hSslCredentials.dwLower != (ULONG) -1) ||
        (hSslCredentials.dwUpper != (ULONG) -1)) {

        EncryptFunctionTable->FreeCredentialHandle(
            &hSslCredentials );
    }

    if ((hSslContext.dwLower != (ULONG) -1) ||
        (hSslContext.dwUpper != (ULONG) -1)) {

        EncryptFunctionTable->DeleteSecurityContext(
            &hSslContext );
    }

    ldapFree( pbOutboundCrypto, LDAP_SECURITY_SIGNATURE );
    ldapFree( pbInboundCrypto, LDAP_SECURITY_SIGNATURE );
    ldapFree( pCryptoBuffers, LDAP_SECURITY_SIGNATURE );
    ldapFree( pbNegotiateBuffer, LDAP_SECURITY_SIGNATURE );

    return;
}

BOOLEAN
CryptStream::CheckInboundSpace(
    ULONG cbBytesNeeded
)
/*+++

Description:

    This internal routine checks to make sure that there
    are at least cbBytesNeeded available in the inbound
    crypto buffer.  The routine grows the buffer if
    necessary.

Parameters:

    cbBytesNeeded   - Minimum number of bytes to grow.

---*/
{

    PBYTE NewBuffer;
    ULONG NewBufferSize;

    if ( ( cbInboundCryptoLen - cbInboundCryptoBytes ) >= cbBytesNeeded ) {
        return TRUE;
    }

    //
    // Otherwise, resize.
    //

    NewBufferSize = cbInboundCryptoBytes + cbBytesNeeded + STREAM_GROW_SIZE;
    NewBuffer = (PBYTE) ldapMalloc( NewBufferSize, LDAP_SECURITY_SIGNATURE );

    if ( NewBuffer == NULL ) {
        return FALSE;
    }

    if (cbInboundCryptoBytes) {
        CopyMemory( NewBuffer, pbInboundCrypto, cbInboundCryptoBytes );
    }

    ldapFree( pbInboundCrypto, LDAP_SECURITY_SIGNATURE );

    pbInboundCrypto = NewBuffer;
    cbInboundCryptoLen = NewBufferSize;


    return TRUE;
}

ULONG CryptStream::DecryptLdapReceive(
    PLDAP_RECVBUFFER pCryptoReceive
)
/*+++

Description:

    This routine takes cipher text from the transport and
    processes it and passes it to the message pump.

Parameters:

    pCryptoReceive   - The next ldap receive.

Notes:

    This only gets called when the connection list lock
    is held so we don't have to worry about locking or
    ordering.

    If this ends up being slow, we could slow down all 
    client receives and may want to alter the way we 
    protect the message ordering here!

---*/
{

    ULONG LdapError = LDAP_SUCCESS;
    SECURITY_STATUS sErr;

    PBYTE pbCryptoHead, pbDecryptHead, pbClearTextHead;
    ULONG cbCryptoBytes, cbClearTextBytes;

    PLDAP_RECVBUFFER pDeleteReceive = NULL;

    if (!bUseSSL) {

      return (UnSignAndSealLdapStream( pCryptoReceive ));
    }

    
    //
    // If the crypt stream is in a congested state, try
    // to process the pending clear text before we do
    // more decrypto work.
    //
    // Congestion occurs when the inbound buffer has
    // cleartext at the head that we could not inject
    // into the message pump on a previous call.
    //

    if ( cbCongestedClearText ) {

        LdapError = InjectNewReceive( pbInboundCrypto,
                                      cbCongestedClearText );

        if ( LdapError != LDAP_SUCCESS ) {

            //
            // Still congested, don't process any crypto.
            //

            return LdapError;
        }

        //
        // Slide the crypto data if neccessary.
        //

        if ( cbInboundCryptoBytes ) {

            ldap_MoveMemory( (PCHAR) pbInboundCrypto,
                             (PCHAR) pbInboundCrypto + cbCongestedClearText,
                             cbInboundCryptoBytes );
        }

        cbCongestedClearText = 0;
    }

    //
    // Figure out what to decrypt.
    //
    // Here's how we use these buffers.  We decrypt in place in
    // either the crypt stream inbound buffer or in the receive
    // structure itself.  As we decrypt data, we slide the clear
    // text to the head of the buffer that we are decrypting.
    // When we can decrypt no more, we copy off the clear text
    // into the current receive structure or (if it's not big
    // enough) into a newly allocated receive structure.  We pass
    // this clear text receive out to the message pump.  If there's
    // left over crypto, we move it to the head of the inbound
    // crypto buffer for this stream.
    //

    if ( cbInboundCryptoBytes ) {

        //
        // If there's some residual crypto in the inbound
        // buffer, we have to append this data and decrypt
        // from the stream buffer.  Otherwise, we can
        // decrypt in place.
        //

        if ( !CheckInboundSpace( pCryptoReceive->NumberOfBytesReceived ) ) {
            return LDAP_NO_MEMORY;
        }

        pbCryptoHead = pbInboundCrypto + cbInboundCryptoBytes;

        ldap_MoveMemory( (PCHAR) pbCryptoHead,
                         (PCHAR)  &(pCryptoReceive->DataBuffer[0]),
                         pCryptoReceive->NumberOfBytesReceived );

        pbCryptoHead = pbInboundCrypto;
        cbCryptoBytes = cbInboundCryptoBytes + pCryptoReceive->NumberOfBytesReceived;
        pbDecryptHead = pbInboundCrypto;
        cbClearTextBytes = 0;

    } else {

        //
        // There's no pending crypto, so we can decrypt this
        // in place and save ourselves a copy.
        //

        pbCryptoHead = (PBYTE) &(pCryptoReceive->DataBuffer[0]);
        cbCryptoBytes = pCryptoReceive->NumberOfBytesReceived;
        pbDecryptHead = pbCryptoHead;
        cbClearTextBytes = 0;

    }

    //
    // Remember the start of the actual clear text!
    //

    pbClearTextHead = pbDecryptHead;

    //
    // Loop while there's data to decrypt.
    //

    while ( cbCryptoBytes ) {

        //
        // Setup the buffer chain.
        //

        pCryptoBuffers[0].pvBuffer =  pbCryptoHead;
        pCryptoBuffers[0].cbBuffer =  cbCryptoBytes;
        pCryptoBuffers[0].BufferType = SECBUFFER_DATA;

        for ( ULONG i = 1; i < SspiStreamSizes.cBuffers; i++ ) {
            pCryptoBuffers[i].pvBuffer = NULL;
            pCryptoBuffers[i].cbBuffer = 0;
            pCryptoBuffers[i].BufferType = SECBUFFER_EMPTY;
        }

        //
        // Actually decrypt the data!
        //

        sErr = LdapSslDecrypt(
                    &hSslContext,
                    &Decrypt,
                    0,
                    NULL );

        if ( sErr == ERROR_SUCCESS ) {

            //
            // We decrypted some data, update our pointers
            // and see if we need to continue.
            //

            pbCryptoHead = NULL;
            cbCryptoBytes = 0;

            for ( i = 1; i < SspiStreamSizes.cBuffers; i++ ) {

                if ( pCryptoBuffers[i].BufferType == SECBUFFER_DATA ) {

                    //
                    // Slide the data down if necessary.
                    //

                    if ( pbDecryptHead != pCryptoBuffers[i].pvBuffer ) {

                        ldap_MoveMemory( (PCHAR) pbDecryptHead,
                                         (PCHAR) pCryptoBuffers[i].pvBuffer,
                                         pCryptoBuffers[i].cbBuffer );
                    }

                    pbDecryptHead += pCryptoBuffers[i].cbBuffer;
                    cbClearTextBytes += pCryptoBuffers[i].cbBuffer;
                }

                if ( pCryptoBuffers[i].BufferType == SECBUFFER_EXTRA ) {

                    pbCryptoHead = (PBYTE) pCryptoBuffers[i].pvBuffer;
                    cbCryptoBytes = pCryptoBuffers[i].cbBuffer;
                }

            }

        } else if ( sErr == SEC_E_INCOMPLETE_MESSAGE ) {

            //
            // We've decrypted all we can.  Bail out.
            //

            break;

        } else if ( (sErr == SEC_I_RENEGOTIATE) ) {

            //
            // The server has just requested that the client initiate
            // another handshake sequence. At this point, the server will
            // typically send no more data until a ClientHello message
            // is received from the client. The client should send any
            // accumulated data (if it has any) and then start another
            // handshake sequence by calling InitializeSecurityContext.
            //

            //
            // You can not renegotiate an SSL connection while
            // a bind is in progress b/c the two procedures
            // use some common state variables...
            //

           if ( Connection->BindInProgress == TRUE) {

              return ERROR_LOGON_SESSION_COLLISION;
           }

            Connection->BindInProgress = TRUE;
            Connection->SslSetupInProgress = TRUE;

            sErr = SSPINegotiateLoop( FALSE );

            if ( sErr != SEC_E_OK ) {

               //
               // We failed to renegotiate for some reason. So, we have to
               // dump all crypto.
               //

               IF_DEBUG( SSL ) {
                   LdapPrint1( "wldap32: DecryptMessage couldn't decrypt.  sErr = 0x%x\n.", sErr );
               }

                cbInboundCryptoBytes = 0;
                RemoveEntryList( &pCryptoReceive->ReceiveListEntry );
                LdapFreeReceiveStructure( pCryptoReceive, TRUE );

                LdapError = LdapConvertSecurityError( Connection, sErr );
                return LdapError;
            }

            Connection->BindInProgress = FALSE;
            Connection->SslSetupInProgress = FALSE;

            //
            // When the last bit of handshake data is read from
            // the server, it often comes bundled with some encrypted
            // application data. This needs to be placed in the
            // pbCryptoHead buffer by the SSPINegotiateLoop function,
            // so that it can be decrypted in the next pass through the
            // loop.
            //

            continue;

        } else {

            //
            // We failed in some catastrophic way, so we
            // pretty much have to dump all crypto that
            // we have and try to recover on the next receive.
            // I'm betting this will never recover.
            //

            IF_DEBUG( SSL ) {
                LdapPrint1( "wldap32: DecryptMessage couldn't decrypt.  sErr = 0x%x\n.", sErr );
            }

            cbInboundCryptoBytes = 0;
            RemoveEntryList( &pCryptoReceive->ReceiveListEntry );
            LdapFreeReceiveStructure( pCryptoReceive, TRUE );

            LdapError = LdapConvertSecurityError( Connection, sErr );
            return LdapError;
        }

    }

    //
    // At this point, we have done all the decryption that
    // we can.  The following should be true:
    //
    //     pbClearTextHead   - The contiguous chunk of clear text.
    //     cbClearTextBytes  - The length of the clear text.
    //     cbCryptoBytes     - The left over crypto data.
    //     pbCryptoHead      - The left over crypto length.
    //
    // If we did the decryption in place in the receive
    // structure, we can just pass the data out in the receive
    // structure.  If we did the decryption in the crypt stream
    // buffer, but the clear text will fit in the current
    // receive structure, we can copy and pass the data out
    // in the receive.  Otherwise, we'll have to free the
    // current receive and allocate a larger one for the clear
    // text.
    //

    if ( ( cbInboundCryptoBytes ) &&
         ( cbClearTextBytes > pCryptoReceive->BufferSize ) ) {

        //
        // The resulting clear text won't fit in the current
        // receive buffer that we have, so we have to inject
        // an allocated buffer into the list.
        //

        LdapError = InjectNewReceive( pbClearTextHead,
                                      cbClearTextBytes );

        if ( LdapError != LDAP_SUCCESS ) {

            //
            // We couldn't inject so we have to leave the
            // stream in a congested state and try to
            // recover later.  Don't forget to slide to
            // leftover crypto down.
            //

            if ( cbCryptoBytes ) {

                ldap_MoveMemory( (PCHAR) pbInboundCrypto + cbClearTextBytes,
                                 (PCHAR) pbCryptoHead,
                                 cbCryptoBytes );

                cbInboundCryptoBytes = cbCryptoBytes;
                cbCryptoBytes = 0;
            }

            cbCongestedClearText = cbClearTextBytes;
        }

        //
        // Remove the receive from the list.  Since we know
        // we're working from the pending buffer in the crypt
        // stream, we can free this receive.
        //

        RemoveEntryList( &pCryptoReceive->ReceiveListEntry );
        LdapFreeReceiveStructure( pCryptoReceive, TRUE );

    } else if ( cbClearTextBytes ) {

        if ( cbInboundCryptoBytes == 0 ) {

            //
            // We used the actual receive buffer, so we can use
            // that same buffer to post the receive to the message
            // pump.
            //

            pCryptoReceive->NumberOfBytesReceived = cbClearTextBytes;

        } else if ( cbClearTextBytes <= pCryptoReceive->BufferSize ) {

            //
            // We did the decrypt in the stream, but the data
            // will fit in this receive, so use it.
            //

            CopyMemory( &(pCryptoReceive->DataBuffer[0]),
                        pbClearTextHead,
                        cbClearTextBytes );

            pCryptoReceive->NumberOfBytesReceived = cbClearTextBytes;

        }

        //
        // Move this receive to to completed list.
        //

        RemoveEntryList( &pCryptoReceive->ReceiveListEntry );
        InsertTailList( &Connection->CompletedReceiveList,
                        &pCryptoReceive->ReceiveListEntry );

    } else {

        //
        // There was no decrypted data, so we're done with
        // this receive.  We can't actually delete it until
        // we save off any pending crypto.
        //

        RemoveEntryList( &pCryptoReceive->ReceiveListEntry );
        pDeleteReceive = pCryptoReceive;

    }

    //
    // If there was any crypto data pending, put it in
    // the inbound buffer and we will do the right thing
    // on the next receive.
    //
    // We should try to protect this from failure
    // more since this will drop important crypto data.
    //

    if ( cbCryptoBytes ) {

        if ( pbInboundCrypto != pbCryptoHead ) {

            if ( !CheckInboundSpace( cbCryptoBytes ) ) {
                return LDAP_NO_MEMORY;
            }

            ldap_MoveMemory( (PCHAR) pbInboundCrypto,
                             (PCHAR) pbCryptoHead,
                             cbCryptoBytes );
        }

        cbInboundCryptoBytes = cbCryptoBytes;

    } else {

        cbInboundCryptoBytes = 0;
    }

    if ( pDeleteReceive ) {
        LdapFreeReceiveStructure( pDeleteReceive, TRUE );
    }

    return LdapError;
}

ULONG
CryptStream::InjectNewReceive(
    PBYTE pbClearText,
    ULONG cbClearText
)
/*+++

Description:

    This routine takes a block of clear text that is too
    big for the current receive buffer and injects into
    the message pump by allocating a properly sized
    receive buffer.

Arguments:

    pbClearText - The clear text buffer.
    cbClearText - The length of the clear text.

 ---*/
{

    PLDAP_RECVBUFFER pNewReceive;

    //
    // Allocate a new receive buffer.
    //

    pNewReceive = (PLDAP_RECVBUFFER) ldapMalloc( sizeof( LDAP_RECVBUFFER ) +
                                                 cbClearText,
                                                 LDAP_RECV_SIGNATURE );

    if ( pNewReceive == NULL ) {
        return LDAP_NO_MEMORY;
    }

    //
    //  Initialize non-zero fields.
    //

    pNewReceive->Connection = Connection;
    pNewReceive->BufferSize = cbClearText;
    pNewReceive->NumberOfBytesReceived = cbClearText;

    CopyMemory( &(pNewReceive->DataBuffer[0]),
                pbClearText,
                cbClearText );

    InsertTailList( &Connection->CompletedReceiveList,
                    &pNewReceive->ReceiveListEntry );

    return LDAP_SUCCESS;
}

ULONG
CryptStream::LdapSendSsl(
    PBYTE   pbClearText,
    ULONG   cbClearText
)
/*+++

Description:

    This routine takes the plain text request, encrypts it,
    and sends it off to the server.

Parameters:

    pbClearText   - The clear text request.
    cbClearText   - The length of the clear text.

Notes:

    This routine only gets called when the
    send lock for the host connection is held.
    The send lock protects the send data
    structures.

---*/
{

    ULONG           LdapError = LDAP_SUCCESS;
    SECURITY_STATUS sErr;
    SecBufferDesc   Encrypt;
    SecBuffer       CryptoBuffers[3];
    PBYTE           pbSendData, pbSendCrypto;
    ULONG           cbSendDataLeft, cbProcessedCrypto;
    ULONG           cbSpaceLeft, cbSpaceNeeded;
    ULONG           cbThisData;

    if (!bUseSSL) {

          return (SignAndSealLdapStream(pbClearText, cbClearText));
    }

    //
    // Set the initial pointers.
    //

    pbSendData = pbClearText;
    pbSendCrypto = pbOutboundCrypto;
    cbSendDataLeft = cbClearText;
    cbSpaceLeft = cbOutboundCryptoLen;
    cbProcessedCrypto = 0;

    //
    // Loop until we hit an error condition or run out of data to send.
    //

    for( ;; ) {

        //
        // How much will we process this time around?
        //

        if ( cbSendDataLeft > dwMaxMessage ) {
            cbThisData = dwMaxMessage;
        } else {
            cbThisData = cbSendDataLeft;
        }

        //
        // If there's not enough room to send another piece, or
        // if there's no more data to process, send what we have
        // processed so far and continue if necessary.
        //

        cbSpaceNeeded = SspiStreamSizes.cbHeader;
        cbSpaceNeeded += cbThisData;
        cbSpaceNeeded += SspiStreamSizes.cbTrailer;

        if ( ( cbSpaceNeeded > cbSpaceLeft ) ||
             ( cbSendDataLeft == 0 ) ) {

            //
            // Send what we have processed.
            //

            LdapError = LdapSendRaw( Connection,
                                     (PCHAR) pbOutboundCrypto,
                                     cbProcessedCrypto );

            if ( LdapError != LDAP_SUCCESS ) {
                break;
            }

            if ( cbSendDataLeft == 0 ) {

                //
                // There's no more data to process, so Exit.
                //

                break;

            } else {

                //
                // We've still got data, so reset the pointers.
                //

                pbSendCrypto = pbOutboundCrypto;
                cbSpaceLeft = cbOutboundCryptoLen;
                cbProcessedCrypto = 0;
            }

        }

        //
        // Prepare the encrypt buffer array.
        //

        CryptoBuffers[0].pvBuffer = pbSendCrypto;
        CryptoBuffers[0].cbBuffer = SspiStreamSizes.cbHeader;
        CryptoBuffers[0].BufferType = SECBUFFER_TOKEN;

        pbSendCrypto += SspiStreamSizes.cbHeader;
        cbSpaceLeft -= SspiStreamSizes.cbHeader;

        CryptoBuffers[1].pvBuffer = pbSendCrypto;
        CryptoBuffers[1].cbBuffer = cbThisData;
        CryptoBuffers[1].BufferType = SECBUFFER_DATA;

        ldap_MoveMemory( (PCHAR) pbSendCrypto, (PCHAR) pbSendData, cbThisData );

        cbSendDataLeft -= cbThisData;
        pbSendData += cbThisData;

        pbSendCrypto += cbThisData;
        cbSpaceLeft -= cbThisData;

        //
        // Not all packages require a trailer buffer.
        //

        if ( SspiStreamSizes.cbTrailer ) {

            CryptoBuffers[2].pvBuffer = pbSendCrypto;
            CryptoBuffers[2].cbBuffer = SspiStreamSizes.cbTrailer;
            CryptoBuffers[2].BufferType = SECBUFFER_TOKEN;

            pbSendCrypto += SspiStreamSizes.cbTrailer;
            cbSpaceLeft -= SspiStreamSizes.cbTrailer;

        } else {

            CryptoBuffers[2].pvBuffer = NULL;
            CryptoBuffers[2].cbBuffer = 0;
            CryptoBuffers[2].BufferType = SECBUFFER_EMPTY;

        }

        Encrypt.cBuffers = 3;
        Encrypt.pBuffers = CryptoBuffers;
        Encrypt.ulVersion = SECBUFFER_VERSION;

        //
        // Encrypt this portion of the message and continue.
        //

        sErr = LdapSslEncrypt(
               &hSslContext,
               0,
               &Encrypt,
               0 );

        LdapError = LdapConvertSecurityError( Connection, sErr );

        if ( LdapError != LDAP_SUCCESS ) {
            break;
        }
        
        cbProcessedCrypto = CryptoBuffers[0].cbBuffer +
                            CryptoBuffers[1].cbBuffer +
                            CryptoBuffers[2].cbBuffer;
    }

    //
    // We broke out of the loop, so either we
    // finished or there was an error.
    //

    return LdapError;
}

ULONG
CryptStream::NegotiateSecureConnection(
    PSecPkgInfoW Package
)
/*+++

Description:

    Negotiate an SSL session on the connection.
    We will always use the unified ssl/pct provider.

    This must not happen while a bind is in progress
    as we use some of the same state variable in
    each code path to track the SSPI status.

    This routine sets the following class private members:

        SspiPackage        - The package used on this connection.
        hSslCredentials    - The credentials handle for this connection.
        SslCredExpiry      - The expire time of these credentials.
        hSslContext        - The security context for this connection.
        SslContextExpiry   - The expire time of this context.
        SspiStreamSizes    - The stream sizes for this stream.

    This routine also allocates the pbOutboundCrypto buffer.

    This must return a Win32 error code.

1/21/1998 : Modified by AnoopA to incorporate client authentication.

---*/
{

    SECURITY_STATUS sErr;

    SecBufferDesc   OutBuffer;
    SecBuffer       OutBuffers[1];

    PBYTE           pbInboundToken = NULL;
    
    DWORD           ContextAttribs;
    PWCHAR          TargetName = NULL;
    DWORD           dwSspiFlags;
    ULONG           LdapError;

    SCHANNEL_CRED   schCred = {0};

    ASSERT( Connection != NULL );
    ASSERT( Package != NULL );
    ASSERT( EncryptFunctionTable != NULL );

    //
    // We will not pass any client creds initially (we don't have any!). If
    // the server demands creds, we will decide later.
    //

    schCred.dwVersion = SCHANNEL_CRED_VERSION;

    //
    // If a client cert routine is supplied, instruct schannel not to pick a
    // default client cert.
    //

    if (Connection->ClientCertRoutine) {
        schCred.dwFlags |= SCH_CRED_NO_DEFAULT_CREDS;
    } else {
        schCred.dwFlags |= SCH_CRED_USE_DEFAULT_CREDS;
    }

    //
    // If the app wants to manually validate the server cert, prevent schannel
    // from doing so.
    //

    if (Connection->ServerCertRoutine) {
        schCred.dwFlags |= SCH_CRED_MANUAL_CRED_VALIDATION;
    } else {
        schCred.dwFlags |= SCH_CRED_AUTO_CRED_VALIDATION;
    }

    sErr = EncryptFunctionTable->AcquireCredentialsHandleW(
               NULL,                          // User name for the credentials.
               Package->Name,                 // Security package name.
               SECPKG_CRED_OUTBOUND,          // These are outbound only credentials.
               NULL,                          // The LUID - not applicable here!
               &schCred,                      // The package specific data with flags.
               NULL,                          // The specific get key function.
               NULL,                          // Argument to the get key function.
               &hSslCredentials,              // OUT: Pointer to the credential.
               &SslCredExpiry                 // OUT: Credential expiration time.
           );

    if ( sErr != SEC_E_OK ) {
        return sErr;
    }

    SspiPackage = Package;

    //
    // Set up the security flags and buffers.  The single
    // outbound buffer is for the outbound sspi token.  The
    // first inbound buffer is used to present the inbound
    // data to SSPI.  The second inbound buffer gets the
    // left over data when the inbound data contains more
    // than one token.
    //

    dwSspiFlags = ISC_REQ_SEQUENCE_DETECT |
                  ISC_REQ_REPLAY_DETECT   |
                  ISC_REQ_CONFIDENTIALITY |
                  ISC_REQ_MUTUAL_AUTH     |
                  ISC_RET_EXTENDED_ERROR  |
                  ISC_REQ_STREAM          |
                  ISC_REQ_ALLOCATE_MEMORY;

    //
    // Setup OutBuffer for InitializeSecurityContext call
    //

    OutBuffers[0].pvBuffer = NULL;
    OutBuffers[0].cbBuffer = 0;
    OutBuffers[0].BufferType = SECBUFFER_TOKEN;

    OutBuffer.cBuffers = 1;
    OutBuffer.pBuffers = OutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

    //
    // Canonicalize the target name for the security provider
    // and reset the authentication leg counter.
    //

    if (Connection->DnsSuppliedName != NULL) {

        TargetName = Connection->DnsSuppliedName;

    } else {

        TargetName = Connection->HostNameW;
    }

    //
    // Start the negotiation. We will try to do it initially with the
    // default credentials.
    //

    sErr = EncryptFunctionTable->InitializeSecurityContextW(
               &hSslCredentials,
               NULL,
               TargetName,
               dwSspiFlags,
               0,
               SECURITY_NATIVE_DREP,
               NULL,
               0,
               &hSslContext,
               &OutBuffer,
               &ContextAttribs,
               &SslContextExpiry
           );

    if ( sErr != SEC_I_CONTINUE_NEEDED ) {
        goto ExitWithCleanup;
    }

    //
    // Send the HELLO token.
    //

    ASSERT( OutBuffers[0].cbBuffer != 0 );
    ASSERT( OutBuffers[0].pvBuffer != NULL );

    LdapError = LdapSendRaw( Connection,
                             (PCHAR) OutBuffers[0].pvBuffer,
                             OutBuffers[0].cbBuffer );

    EncryptFunctionTable->FreeContextBuffer( OutBuffers[0].pvBuffer );

    OutBuffers[0].cbBuffer = 0;
    OutBuffers[0].pvBuffer = NULL;

    if ( LdapError != LDAP_SUCCESS ) {

        sErr = ERROR_CONNECTION_INVALID;
        goto ExitWithCleanup;
    }

    //
    // Continue the SSL negotiate loop until it completes.
    //

    sErr = SSPINegotiateLoop( FALSE );

    if ( sErr != SEC_E_OK ) {
        goto ExitWithCleanup;
    }

    //
    // Set up the stream state for the crypto transport.
    //

    sErr = EncryptFunctionTable->QueryContextAttributesW(
               &hSslContext,
               SECPKG_ATTR_STREAM_SIZES,
               (PVOID) &SspiStreamSizes );

    if ( sErr != SEC_E_OK ) {
        goto ExitWithCleanup;
    }

    //
    // Allocate the buffer that we use to process outbound messages.
    //

    cbOutboundCryptoLen = SspiStreamSizes.cbHeader +
                          SspiStreamSizes.cbMaximumMessage +
                          SspiStreamSizes.cbTrailer;

    dwMaxMessage = SspiStreamSizes.cbMaximumMessage;

    pbOutboundCrypto = (PBYTE) ldapMalloc( cbOutboundCryptoLen,
                                           LDAP_SECURITY_SIGNATURE );

    if ( pbOutboundCrypto == NULL ) {
        sErr = ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Allocate the buffer chain that we'll use to talk to SSPI.
    //

    pCryptoBuffers = (PSecBuffer) ldapMalloc(
                         ( sizeof( SecBuffer ) * SspiStreamSizes.cBuffers ),
                         LDAP_SECURITY_SIGNATURE );

    if ( pCryptoBuffers == NULL ) {
        sErr = ERROR_NOT_ENOUGH_MEMORY;
    }

    Decrypt.cBuffers = SspiStreamSizes.cBuffers;
    Decrypt.pBuffers = pCryptoBuffers;
    Decrypt.ulVersion = SECBUFFER_VERSION;

ExitWithCleanup:

    if ( sErr != SEC_E_OK ) {

        //
        // If we failed, free the SSL credentials handle.
        //

        if ((hSslCredentials.dwLower != (ULONG) -1) ||
            (hSslCredentials.dwUpper != (ULONG) -1)) {

            EncryptFunctionTable->FreeCredentialHandle(
                &hSslCredentials );

            hSslCredentials.dwLower = (ULONG) -1;
            hSslCredentials.dwUpper = (ULONG) -1;
        }

        if ((hSslContext.dwLower != (ULONG) -1) ||
            (hSslContext.dwUpper != (ULONG) -1)) {

            EncryptFunctionTable->DeleteSecurityContext(
                &hSslContext );

            hSslContext.dwLower = (ULONG) -1;
            hSslContext.dwUpper = (ULONG) -1;
        }

        SspiPackage = NULL;
    }

    if ( pbInboundToken ) {
        ldapFree( pbInboundToken, LDAP_SECURITY_SIGNATURE );
    }

    return sErr;

}

SECURITY_STATUS
CryptStream::TearDownSecureConnection(
    VOID
)
/*+++

Description:

    Notify schannel and the server that we are about to close the connection.
    This involves building a SSL/TLS close notify message and sending that 
    message to the server.

    This must return a Win32 error code.

---*/
{
    SECURITY_STATUS sErr;

    SecBufferDesc   OutBuffer;
    SecBuffer       OutBuffers[1];

    SecBufferDesc   InBuffer;
    SecBuffer       InBuffers[4];
    
    DWORD           ContextAttribs;
    ULONG           LdapError;
    DWORD           dwType;
    DWORD           dwSSPIFlags;

    PBYTE           pbJunkBuffer = NULL;
    ULONG           cbReceived = 0;
    
    ASSERT( Connection != NULL );
    ASSERT( EncryptFunctionTable != NULL );

    //
    // Notify schannel that we are about to close the connection.
    //
    
    dwType = SCHANNEL_SHUTDOWN;
    
    OutBuffers[0].pvBuffer   = &dwType;
    OutBuffers[0].BufferType = SECBUFFER_TOKEN;
    OutBuffers[0].cbBuffer   = sizeof(dwType);
    
    OutBuffer.cBuffers  = 1;
    OutBuffer.pBuffers  = OutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

    sErr = EncryptFunctionTable->ApplyControlToken( &hSslContext,
                                                    &OutBuffer );

    IF_DEBUG( SSL ) {
        LdapPrint1("TearDownSecureConnection:ApplyControlToken returned 0x%x\n",sErr);
    }
    
    if ( sErr != SEC_E_OK ) {
        goto ExitWithCleanup;
    }

    //
    // Build an SSL close notify message.
    //
    
    dwSSPIFlags = ISC_REQ_SEQUENCE_DETECT   |
                  ISC_REQ_REPLAY_DETECT     |
                  ISC_REQ_CONFIDENTIALITY   |
                  ISC_RET_EXTENDED_ERROR    |
                  ISC_REQ_ALLOCATE_MEMORY   |
                  ISC_REQ_STREAM;
    
    OutBuffers[0].pvBuffer   = NULL;
    OutBuffers[0].BufferType = SECBUFFER_TOKEN;
    OutBuffers[0].cbBuffer   = 0;
    
    OutBuffer.cBuffers  = 1;
    OutBuffer.pBuffers  = OutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

    sErr = EncryptFunctionTable->InitializeSecurityContextW(
               &hSslCredentials,
               &hSslContext,
               NULL,
               dwSSPIFlags,
               0,
               SECURITY_NATIVE_DREP,
               NULL,
               0,
               &hSslContext,
               &OutBuffer,
               &ContextAttribs,
               &SslContextExpiry
           );

    if ( sErr != SEC_E_OK ) {
        goto ExitWithCleanup;
    }

    //
    // Send the CLOSE_NOTIFY alert to the server.
    //

    ASSERT( OutBuffers[0].cbBuffer != 0 );
    ASSERT( OutBuffers[0].pvBuffer != NULL );

    LdapError = LdapSendRaw( Connection,
                             (PCHAR) OutBuffers[0].pvBuffer,
                             OutBuffers[0].cbBuffer );

    EncryptFunctionTable->FreeContextBuffer( OutBuffers[0].pvBuffer );

    OutBuffers[0].cbBuffer = 0;
    OutBuffers[0].pvBuffer = NULL;

    if ( LdapError != LDAP_SUCCESS ) {

        sErr = ERROR_CONNECTION_INVALID;
        goto ExitWithCleanup;
    }

    pbJunkBuffer = (PBYTE) ldapMalloc( SspiMaxTokenSize, LDAP_SECURITY_SIGNATURE );

    if ( !pbJunkBuffer ) {

        sErr = ERROR_NOT_ENOUGH_MEMORY;
        goto ExitWithCleanup;
    }

TryReceiveAgain:

    LdapError = SslBlockingReceive( pbJunkBuffer,
                                    SspiMaxTokenSize, // size of data to receive
                                    &cbReceived
                                    );

    if (LdapError != LDAP_SUCCESS) {

        sErr = (LdapError==LDAP_TIMEOUT)? ERROR_TIMEOUT : ERROR_BAD_NET_RESP;
        goto ExitWithCleanup;
    }

    InBuffers[0].BufferType = SECBUFFER_DATA;
    InBuffers[0].cbBuffer = cbReceived;
    InBuffers[0].pvBuffer = pbJunkBuffer;

    //
    // For some wierd reason, we have to tack on 3 additional empty buffers
    // for this to work.
    //

    for ( ULONG i = 1; i < 4; i++ ) {
        InBuffers[i].pvBuffer = NULL;
        InBuffers[i].cbBuffer = 0;
        InBuffers[i].BufferType = SECBUFFER_EMPTY;
    }

    InBuffer.cBuffers  = min(SspiStreamSizes.cBuffers, 4);
    InBuffer.pBuffers  = InBuffers;
    InBuffer.ulVersion = SECBUFFER_VERSION;

    sErr = LdapSslDecrypt(
                &hSslContext,
                &InBuffer,
                0,
                NULL );

    //
    // Since we have explicitly abandoned all outstanding requests prior to
    // sending the StopTLS alert, this message must be the server response
    // to the StopTLS request. Disregard all other messages the server might
    // send us.
    //

    if ( sErr != SEC_I_CONTEXT_EXPIRED ) {

        IF_DEBUG( SSL ) {
            LdapPrint1("TearDownSecureConnection: DecryptMessage returns 0x%x\n", sErr);
        }
//      ASSERT( FALSE );
        goto TryReceiveAgain;
    }

ExitWithCleanup:

    ldapFree( pbJunkBuffer, LDAP_SECURITY_SIGNATURE );

    IF_DEBUG( SSL ) {
         LdapPrint1("TearDownSecureConnection win32 error is 0x%x\n", sErr);
    }

    return sErr;

}



ULONG
CryptStream::SslBlockingReceive(
    PBYTE  pbReceive,
    ULONG  cbReceive,
    PULONG pcbReceived
)
/*+++

Description:

    This routine does a synchronous receive of SSL data
    during connection negotiation/teardown. Since the sockets
    are marked as non-blocking, this routine does a select
    on the socket and then receives data after the select
    fires.

Parameters:

    pbReceive - Buffer to receive into.
    cbReceive - Size of the receive buffer.

    This function returns an LDAP_ERROR.

---*/
{

    fd_set SockRead;
    struct timeval Timeout;
    int SockErr;

    //
    // Set the timeout and the socket array.
    //

    Timeout.tv_sec = LDAP_SSL_NEGOTIATE_TIME_DEFAULT;
    Timeout.tv_usec = 0;

    FD_ZERO( &SockRead );
    FD_SET( Connection->TcpHandle, &SockRead );

    SockErr = (*pselect)( 0,
                          &SockRead,
                          NULL,
                          NULL,
                          &Timeout );

    if ( ( SockErr == SOCKET_ERROR ) ||
         ( SockErr != 1 ) ) {

        //
        // The server didn't respond in the allotted time.
        // The setup will fail and this connection will
        // not get opened.
        //

        return LDAP_TIMEOUT;

    }

    //
    // Actually receive the data.
    //

    SockErr = (*precv)( Connection->TcpHandle,
                        (PCHAR) pbReceive,
                        cbReceive,
                        0 );

    if ( SockErr == SOCKET_ERROR ) {

        //
        // The setup will fail and this connection will
        // not get opened.
        //

        return LDAP_TIMEOUT;

    } else if ( SockErr == 0 ) {

        //
        // The server has closed the connection.
        //

        IF_DEBUG(SERVERDOWN) {
            LdapPrint2( "ldapSslBlockingRecv thread 0x%x has connection 0x%x as down.\n",
                            GetCurrentThreadId(),
                            Connection );
        }
        return LDAP_SERVER_DOWN;
    }

    //
    // We got some data... groovy.
    //

    *pcbReceived = SockErr;
    return LDAP_SUCCESS;
}

SECURITY_STATUS
CryptStream::SSPINegotiateLoop(
    BOOL         fDoInitialRead
)
 {

    SECURITY_STATUS      scRet;
    ULONG                LdapError;

    SecBufferDesc        InBuffer;
    SecBuffer            InBuffers[2];
    SecBufferDesc        OutBuffer;
    SecBuffer            OutBuffers[1];

    BOOL                 fDoRead;
    DWORD                dwSSPIFlags;
    DWORD                dwSSPIOutFlags;

    ULONG           cbInboundLen, cbProcessedBytes;
    PBYTE           pbReceiveStart;
    ULONG           cbReceived;

    BOOL          bInvokedCertCallback = FALSE;
    DWORD         dwPassesThroughUserCredLoop = 2;

    //
    // Set up the flags. In the first pass, we don't supply the
    // credentials.
    //


    fDoRead = fDoInitialRead;

    dwSSPIFlags = ISC_REQ_SEQUENCE_DETECT   |
                  ISC_REQ_REPLAY_DETECT     |
                  ISC_REQ_CONFIDENTIALITY   |
                  ISC_REQ_MUTUAL_AUTH       |
                  ISC_RET_EXTENDED_ERROR    |
                  ISC_REQ_STREAM            |
                  ISC_REQ_ALLOCATE_MEMORY;

    //
    //  Initialize buffer chains.
    //

    OutBuffer.cBuffers = 1;
    OutBuffer.pBuffers = OutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

    InBuffer.cBuffers = 2;
    InBuffer.pBuffers = InBuffers;
    InBuffer.ulVersion = SECBUFFER_VERSION;

    //
    // Allocate a token buffer if we don't already have one.
    // SspiMaxTokenSize is the size of the largest possible
    // token according to the security provider.  This keeps
    // us from having to resize or copy.
    //

    if ( !pbNegotiateBuffer ) {

        pbNegotiateBuffer = (PBYTE) ldapMalloc( SspiMaxTokenSize,
                                                LDAP_SECURITY_SIGNATURE );

        if ( pbNegotiateBuffer == NULL ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    pbReceiveStart = pbNegotiateBuffer + cbNegotiateBuffer;
    cbInboundLen = SspiMaxTokenSize - cbNegotiateBuffer;

    //
    // InBuffers[0] describes the inbound
    // token data that is waiting to be processed.
    //

    InBuffers[0].pvBuffer = pbNegotiateBuffer;
    InBuffers[0].cbBuffer = cbNegotiateBuffer;
    InBuffers[0].BufferType = SECBUFFER_TOKEN;

    //
    // Start negotiating SSL.
    //

    scRet = SEC_I_CONTINUE_NEEDED;

     while( scRet == SEC_I_CONTINUE_NEEDED ||
            scRet == SEC_E_INCOMPLETE_MESSAGE ||
            scRet == SEC_I_INCOMPLETE_CREDENTIALS ) {

         //
         // If we have no data, or we need more data, do a receive.
         //
         // Note that we don't do a receive if we need to furnish credentials.
         //

         if( (( InBuffers[0].cbBuffer == 0 )&&(scRet != SEC_I_INCOMPLETE_CREDENTIALS)) ||
             ( scRet == SEC_E_INCOMPLETE_MESSAGE ) ) {

             if( fDoRead ) {

                 LdapError = SslBlockingReceive( pbReceiveStart,
                                                 cbInboundLen,
                                                 &cbReceived );

                if ( LdapError != LDAP_SUCCESS ) {
                    scRet = SEC_E_INTERNAL_ERROR;
                    break;
                }

                pbReceiveStart += cbReceived;
                cbInboundLen -= cbReceived;
                cbNegotiateBuffer += cbReceived;
                InBuffers[0].cbBuffer += cbReceived;

            } else {

                fDoRead = TRUE;
            }
        }

        //
        // InBuffers[1] is for getting extra data that
        // SSPI/SCHANNEL doesn't proccess on this
        // run around the loop.
        //

        InBuffers[1].pvBuffer   = NULL;
        InBuffers[1].cbBuffer   = 0;
        InBuffers[1].BufferType = SECBUFFER_EMPTY;

        OutBuffers[0].pvBuffer   = 0;
        OutBuffers[0].BufferType = SECBUFFER_TOKEN;
        OutBuffers[0].cbBuffer   = 0;

        scRet = EncryptFunctionTable->InitializeSecurityContextW(
                    &hSslCredentials,
                    &hSslContext,
                    NULL,
                    dwSSPIFlags,
                    0,
                    SECURITY_NATIVE_DREP,
                    &InBuffer,
                    0,
                    NULL,
                    &OutBuffer,
                    &dwSSPIOutFlags,
                    &SslCredExpiry
                );

       if ( ( scRet == SEC_E_OK )              ||
            ( scRet == SEC_I_CONTINUE_NEEDED ) ||
            ( ( FAILED(scRet) ) && ( ( dwSSPIOutFlags & ISC_RET_EXTENDED_ERROR ) != 0 ) ) ) {

           if  ( ( OutBuffers[0].cbBuffer != 0 ) &&
                 ( OutBuffers[0].pvBuffer != NULL ) ) {

               LdapError = LdapSendRaw( Connection,
                                        (PCHAR) OutBuffers[0].pvBuffer,
                                        OutBuffers[0].cbBuffer );

               if ( LdapError != LDAP_SUCCESS ) {
                   scRet = SEC_E_INTERNAL_ERROR;
                   break;
               }

               EncryptFunctionTable->FreeContextBuffer( OutBuffers[0].pvBuffer );
               OutBuffers[0].pvBuffer = NULL;
               OutBuffers[0].cbBuffer = 0;
           }
       }

       if ( scRet == SEC_E_OK ) {

          //
          // A secure connection has been established.
          //

           if ( InBuffers[1].BufferType == SECBUFFER_EXTRA ) {

               cbProcessedBytes = InBuffers[0].cbBuffer - InBuffers[1].cbBuffer;

               ldap_MoveMemory( (PCHAR) InBuffers[0].pvBuffer,
                                (PCHAR) ( (PBYTE)InBuffers[0].pvBuffer + cbProcessedBytes ),
                                InBuffers[1].cbBuffer );

               InBuffers[0].cbBuffer = InBuffers[1].cbBuffer;
               cbNegotiateBuffer = InBuffers[1].cbBuffer;

           } else {

               InBuffers[0].cbBuffer = 0;
               cbNegotiateBuffer = 0;
           }

           //
           // Bail out to quit.  We leave the remaining token data
           // sitting in the buffer for the next negotiate.
           //

           //
           // This is a good time for the client to validate the server's
           // certificate
           //

           CERT_CONTEXT ServerCertContext;
           BOOL   retval;

           if ( Connection->ServerCertRoutine != NULL ) {

              scRet = EncryptFunctionTable->QueryContextAttributesW(
                                                                   &hSslContext,
                                                                   SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                                                                   (PVOID) &ServerCertContext
                                                                   );
              if (scRet != SEC_E_OK) {

                 break;
              }

              //
              // We now have the certificate of the remote server. We callout to
              // the client to see if it likes it.
              //

              retval = Connection->ServerCertRoutine( Connection->ExternalInfo,
                                                      &ServerCertContext );

              if (retval == FALSE) {
                 //
                 // The user didn't like the server certificate for some reason.
                 // We will have to terminate the connection.
                 //
                 scRet = SEC_E_INTERNAL_ERROR;
                 break;
              }
           }
           break;

       } else if ( scRet == SEC_I_INCOMPLETE_CREDENTIALS ) {


          if (dwPassesThroughUserCredLoop <= 0) {

                // We've tried the user's callback (if applicable).
                // We've tried it without client credentials.
                // The server isn't accepting it.  Give up so we
                // don't loop forever.
                            
                IF_DEBUG(SSL) {
                    LdapPrint0("SSPINegotiateLoop: bailing out due to SEC_I_INCOMPLETE_CREDENTIALS\n");
                }

                scRet = SEC_E_NO_CREDENTIALS;
                return scRet;
          }

          dwPassesThroughUserCredLoop--;


          //
          // The server has demanded to see our client certificate. Check to
          // see if the user has registered a callout. If yes, call out else
          // try to complete the handshake without credentials.
          //

          if (( Connection->ClientCertRoutine != NULL) && ( bInvokedCertCallback == FALSE )) {
    
              //
              // Ask the security package for a list of Certificate Authorities
              // that the server trusts.
              //
    
              scRet = EncryptFunctionTable->QueryContextAttributesW(
                                                                   &hSslContext,
                                                                   SECPKG_ATTR_ISSUER_LIST_EX,
                                                                   (PVOID) &TrustedCAList );
    
              if ( scRet != SEC_E_OK ) {
                 break;
              }
    
              //
              // We succeeded in getting a list of the server-trusted CAs. We should
              // now callout to the user registered callback routine.
              //
    
              BOOL retval;
              PCCERT_CONTEXT  pCertificate = NULL;
    
              retval = Connection->ClientCertRoutine( Connection->ExternalInfo,
                                                      &TrustedCAList,
                                                      &pCertificate
                                                      );
              bInvokedCertCallback = TRUE;
    
              if (retval == FALSE) {
    
                 //
                 // We could not get a client certificate. Let's try to
                 // complete the handshake without using a client cert.
                 //
    
                 dwSSPIFlags |= ISC_REQ_USE_SUPPLIED_CREDS;
                 scRet = SEC_I_INCOMPLETE_CREDENTIALS;
                 continue;
    
              }
    
              //
              // we now acquire a new set of credentials based on the client
              // certificate and call Initializesecuritycontext again.
              //
    
              SCHANNEL_CRED  UserSchCred = {0};

              UserSchCred.dwVersion = SCHANNEL_CRED_VERSION;
              UserSchCred.dwFlags |= SCH_CRED_NO_DEFAULT_CREDS;
              UserSchCred.paCred = &pCertificate;
              UserSchCred.cCreds = 1;  // honor only the first cert in the chain.

              scRet = EncryptFunctionTable->AcquireCredentialsHandleW(
                         NULL,
                         SspiPackageSslPct->Name,
                         SECPKG_CRED_OUTBOUND,
                         NULL,
                         &UserSchCred,                  // IN: User supplied creds
                         NULL,
                         NULL,
                         &hSslCredentials,              // OUT: Pointer to the credential.
                         &SslCredExpiry                 // OUT: Credential expiration time.
                     );
    
              if ( scRet != SEC_E_OK ) {
                  return scRet;
              }
    
              //
              // We need to tell SSPI to use the supplied credentials
              //
    
              dwSSPIFlags |= ISC_REQ_USE_SUPPLIED_CREDS;
              scRet = SEC_I_INCOMPLETE_CREDENTIALS;

    
          } else {

             //
             // We have no user-registered callback or the server didn't like
             // the credentials we supplied. So, our only resort is to continue
             // with no credentials.
             //

             dwSSPIFlags |= ISC_REQ_USE_SUPPLIED_CREDS;
             continue;
          }

       } else if ( FAILED(scRet) && ( scRet != SEC_E_INCOMPLETE_MESSAGE ) ) {

           //
           // Free the security context handle and delete the local
           // data structures associated with the handle and try another
           // pkg if available.  I don't see that this is happening.
           //

           break;
       }

       if ( ( scRet != SEC_E_INCOMPLETE_MESSAGE ) &&
            ( scRet != SEC_I_INCOMPLETE_CREDENTIALS ) ) {

           if ( InBuffers[1].BufferType == SECBUFFER_EXTRA ) {

               cbProcessedBytes = InBuffers[0].cbBuffer - InBuffers[1].cbBuffer;
               ldap_MoveMemory( (PCHAR) InBuffers[0].pvBuffer,
                                (PCHAR) ( (PBYTE)InBuffers[0].pvBuffer + cbProcessedBytes ),
                                InBuffers[1].cbBuffer );

               InBuffers[0].cbBuffer = InBuffers[1].cbBuffer;
               cbNegotiateBuffer = InBuffers[1].cbBuffer;
               pbReceiveStart = pbNegotiateBuffer + cbNegotiateBuffer;
               cbInboundLen = SspiMaxTokenSize - cbNegotiateBuffer;

           } else {

               //
               // prepare for next receive
               //

               InBuffers[0].cbBuffer = 0;
               cbNegotiateBuffer = 0;
               pbReceiveStart = pbNegotiateBuffer;
               cbInboundLen = SspiMaxTokenSize;
           }
       }
   }

    return ( scRet );
}



SECURITY_STATUS
CryptStream::GetSSLAttributes(
    PSecPkgContext_ConnectionInfo pSecInfo
)
{
   //
   // Gets the SSL attributes of a connection, and fills up the supplied
   // SecPkgContext_ConnectionInfo structure.
   //
   SECURITY_STATUS      scRet;

   scRet = EncryptFunctionTable->QueryContextAttributesW(
                     &hSslContext,
                     SECPKG_ATTR_CONNECTION_INFO,
                     pSecInfo
                     );

   return scRet;

}


ULONG
CryptStream::SignAndSealLdapStream(
    PBYTE   pbClearText,
    ULONG   cbClearText
)
/*+++

Description:

    This routine takes the plain text request, signs it inplace,
    and sends it off to the server.

Parameters:

    pbClearText   - The clear text request.
    cbClearText   - The length of the clear text.

Notes:

    This routine only gets called when the
    send lock for the host connection is held.
    The send lock protects the send data
    structures.

---*/
{
   
   ULONG           LdapError = LDAP_SUCCESS;
   SECURITY_STATUS sErr;
   SecBufferDesc   Encrypt;
   SecBuffer       CryptoBuffers[3];
   PBYTE           pbSendData, pbSendCrypto;
   ULONG           cbProcessedCrypto = 0;
   BOOLEAN         SignOnly = FALSE; 

   ULONG           cbBytesLeft = cbClearText;
   ULONG           cbBytesToSend = 0;
   ULONG           cbOffset = 0;
   
   //
   // Set the initial pointers.
   //
   
   IF_DEBUG(SSL) {
       LdapPrint1("Signing/Sealing %d bytes of cleartext.\n",cbClearText );
   }

   pbSendData = pbClearText;
   pbSendCrypto = (PBYTE) ldapMalloc(
                     sizeof(EncryptHeader_v1) + 
                     ((dwMaxMessage == (DWORD)-1) ? cbClearText : dwMaxMessage) + 
                     ContextSizes.cbMaxSignature + ContextSizes.cbBlockSize +
                     ContextSizes.cbSecurityTrailer,
                     LDAP_SECURITY_SIGNATURE);
   
   if (pbSendCrypto == NULL) {
      return LDAP_NO_MEMORY;
   }


   PEncryptHeader_v1 pEncryptHeader = (PEncryptHeader_v1) pbSendCrypto;

   //
   // Advance pointer to the start of the message buffer.
   //

   pbSendCrypto += sizeof(EncryptHeader_v1);

   //
   // Sign or seal this message as appropriate
   //
   
   if ((Connection->CurrentSignStatus) && !(Connection->CurrentSealStatus)) {
       
       //
       // We need to sign only, not seal.
       //
       
       SignOnly = TRUE;
   }


   while (cbBytesLeft > 0) {


       if (dwMaxMessage == (DWORD)-1) {
            // package imposes no size restriction --> encrypt
            // all in one chunk
            cbBytesToSend = cbBytesLeft;    // == cbClearText
       }
       else {
           // we send the minimum of either the cleartext bytes
           // remaining or the maximum bytes we can send in one
           // chunk
           if (cbBytesLeft > dwMaxMessage) {
               cbBytesToSend = dwMaxMessage;
           }
           else {
               cbBytesToSend = cbBytesLeft;
           }
       }

       //
       // Encrypting also buys us signing if we had asked for integrity/replay/sequence
       // For sealing, we prepare the buffers in a different way
       //
       
       CryptoBuffers[0].pvBuffer = pbSendCrypto;
       CryptoBuffers[0].cbBuffer = ContextSizes.cbSecurityTrailer;
       CryptoBuffers[0].BufferType = SECBUFFER_TOKEN;
       
       CryptoBuffers[1].pvBuffer = pbSendCrypto+ContextSizes.cbSecurityTrailer;
       CryptoBuffers[1].cbBuffer = cbBytesToSend;
       CryptoBuffers[1].BufferType = SECBUFFER_DATA;
       CopyMemory( CryptoBuffers[1].pvBuffer, (const char*) pbClearText+cbOffset, cbBytesToSend);

       CryptoBuffers[2].pvBuffer = pbSendCrypto+ContextSizes.cbSecurityTrailer+cbBytesToSend;
       CryptoBuffers[2].cbBuffer = ContextSizes.cbMaxSignature + ContextSizes.cbBlockSize;
       CryptoBuffers[2].BufferType = SECBUFFER_PADDING;
   
       Encrypt.cBuffers = 3;
       Encrypt.pBuffers = CryptoBuffers;
       Encrypt.ulVersion = SECBUFFER_VERSION;

       sErr = EncryptFunctionTable->EncryptMessage(
                   &Connection->SecurityContext,
                   (SignOnly ? KERB_WRAP_NO_ENCRYPT : 0), 
                   &Encrypt,
                   0 );

       cbProcessedCrypto =  sizeof(EncryptHeader_v1) +
                            CryptoBuffers[0].cbBuffer +
                            CryptoBuffers[1].cbBuffer +
                            CryptoBuffers[2].cbBuffer;

       LdapError = LdapConvertSecurityError( Connection, sErr );
       
       IF_DEBUG(SSL) {
           LdapPrint1("EncryptMessage returned 0x%x\n", sErr);
       }

       if ( LdapError != LDAP_SUCCESS) {
          
          IF_DEBUG(SSL){
              LdapPrint2("EncryptMessage failed with 0x%x, sec context is 0x%x\n", sErr, &Connection->SecurityContext);
          }
          ldapFree(pEncryptHeader, LDAP_SECURITY_SIGNATURE);
          return LdapError;
       }

       //
       // After we successfully processed a message, we must slide the lower two
       // buffers up as specified by CryptoBuffers[0].cbBuffer
       //

       ASSERT(CryptoBuffers[0].cbBuffer <= ContextSizes.cbSecurityTrailer);
       ASSERT(CryptoBuffers[1].cbBuffer == cbBytesToSend);
       ASSERT(CryptoBuffers[2].cbBuffer <= (ContextSizes.cbBlockSize + ContextSizes.cbMaxSignature) );

       if (CryptoBuffers[0].cbBuffer < ContextSizes.cbSecurityTrailer) {
       
           IF_DEBUG(SSL){
               LdapPrint1("Shifting encryptbuffers by %d\n",CryptoBuffers[0].cbBuffer - ContextSizes.cbSecurityTrailer );
           }

           ldap_MoveMemory( (PCHAR) CryptoBuffers[0].pvBuffer+CryptoBuffers[0].cbBuffer,
                            (PCHAR) CryptoBuffers[1].pvBuffer,
                            CryptoBuffers[1].cbBuffer + CryptoBuffers[2].cbBuffer
                            );
       
       }

       //
       // We need to frame the crypto on the wire with 4 byte octets which contain
       // (in network byte order), the size of the ensuing crypto.
       //

       pEncryptHeader->EncryptMessageSize = (*phtonl) (cbProcessedCrypto - sizeof(EncryptHeader_v1));
       
       //
       // Ship this signed/sealed message to the server
       //

       LdapError = LdapSendRaw( Connection,
                               (PCHAR) pEncryptHeader,
                                cbProcessedCrypto );


       IF_DEBUG(SSL) {
           LdapPrint3("Sending %d signed/sealed bytes with retval 0x%x, %d bytes of cleartext to go\n", cbProcessedCrypto, LdapError, (cbBytesLeft-cbBytesToSend));
       }


       if (LdapError != LDAP_SUCCESS) {
            break;
       }

       //
       cbBytesLeft -= cbBytesToSend;
       cbOffset += cbBytesToSend;

   }

   ldapFree(pEncryptHeader, LDAP_SECURITY_SIGNATURE);

   return LdapError;
}


ULONG CryptStream::UnSignAndSealLdapStream(
    PLDAP_RECVBUFFER pCryptoReceive
)
/*+++

Description:

    This routine takes cipher text from the transport and
    processes it and passes it to the message pump.

Parameters:

    pCryptoReceive   - The next ldap receive.

Notes:

    This only gets called when the connection list lock
    is held so we don't have to worry about locking or
    ordering. We also do a lot of buffer copies. If this turns
    out to be slow, we should change the architecture.
*/
{

   SecBufferDesc   Decrypt;
   SecBuffer       CryptoBuffers[2];

   PBYTE pbCryptoHead;
   ULONG LdapError = LDAP_SUCCESS;
   SECURITY_STATUS sErr;

   ULONG cbCryptoBytes;

   pbCryptoHead = (PBYTE) &(pCryptoReceive->DataBuffer[0]);
   cbCryptoBytes = pCryptoReceive->NumberOfBytesReceived;
   BOOLEAN         UnSignOnly = FALSE; 
   
   if ( !cbCryptoBytes ) {

      RemoveEntryList( &pCryptoReceive->ReceiveListEntry );
      LdapFreeReceiveStructure( pCryptoReceive, TRUE );
      return LDAP_SUCCESS;
   }

   //
   // We have to ensure that we received the entire message before
   // trying to process it. So, we try to check the length only if it is
   // a brand new message. If not, we simply squirrel away the partial 
   // message.
   //

   PEncryptHeader_v1 pEncryptHeader = (PEncryptHeader_v1) pbCryptoHead;
   

   if ( !cbInboundCryptoBytes ) {

      //
      // we don't have any stored crypto, we assume this
      // to be a brand new message. Remember that the incoming header is
      // in network byte order.
      //

      //
      // Make sure we got enough bytes for the EncryptMessageSize
      //
      if (cbCryptoBytes >= sizeof (ULONG)) {
   
          ULONG IncomingMessageLength = sizeof(EncryptHeader_v1) +
                                (*pntohl) (pEncryptHeader->EncryptMessageSize);

          cbCurrentMessageSize = IncomingMessageLength;

          bCurrentMessageSizeValid = TRUE;
      }
  
   } 
   
      //
      // To make life easier, always store off the incoming message in our
      // private crypto buffers as it could contain partial messages
      //

   if ( pbInboundCrypto != pbCryptoHead ) {
      
      if ( !CheckInboundSpace( cbCryptoBytes ) ) {
     
          return LDAP_NO_MEMORY;
      }
      
      ldap_MoveMemory( (PCHAR) pbInboundCrypto + cbInboundCryptoBytes,
               (PCHAR) pbCryptoHead,
               cbCryptoBytes );
               
      cbInboundCryptoBytes += cbCryptoBytes;
      
      RemoveEntryList( &pCryptoReceive->ReceiveListEntry );
      LdapFreeReceiveStructure( pCryptoReceive, TRUE );
   }

   // If we didn't have enough bytes before to get the message size, try again
   // now that we've combined any bytes we got this time with the bytes we got the
   // last time
   if (!bCurrentMessageSizeValid) {

      if (cbInboundCryptoBytes >= sizeof (ULONG)) {

          PEncryptHeader_v1 pEncryptHeaderTemp = (PEncryptHeader_v1) pbInboundCrypto;

          ULONG IncomingMessageLength = sizeof(EncryptHeader_v1) +
                                (*pntohl) (pEncryptHeaderTemp->EncryptMessageSize);

          cbCurrentMessageSize = IncomingMessageLength;

          bCurrentMessageSizeValid = TRUE;
      }
   }

   if ((!bCurrentMessageSizeValid) || ( cbCurrentMessageSize > cbInboundCryptoBytes)) {

      //
      // We don't have enough crypto to start processing, we hope to have
      // the rest the next time we come in here.
      //

      return LDAP_SUCCESS;
   }

   // keep track of how much buffer space we're using, for our
   // buffer trimming algorithm
   if (cbInboundCryptoBytes > cbMaxBufferUsed) {
       cbMaxBufferUsed = cbInboundCryptoBytes;
   }
   cUnsignsPerformed++;


   if ((Connection->CurrentSignStatus) && !(Connection->CurrentSealStatus)) {
       
       //
       // The data is only signed, not sealed.
       //

       UnSignOnly = TRUE;
   }
   
   //
   // Now, we have atleast one complete message in our buffers
   //
   // cbCurrentMessageSize : Number of bytes in the first message we want to decrypt.
   // pbInboundCrypto      : Start of the message buffer
   // cbInboundCryptoBytes : Total number of bytes in the buffer
   //
   // Note that we could have some extra crypto in the end. If so, we have to
   // slide it to the beginning and set the new message size. If not, we free
   // our entire buffer and we are done.
   //

   for ( ;; ) {

       //
       // Loop through our buffers trying to decrypt
       //

   
       if (!bCurrentMessageSizeValid || 
           !cbInboundCryptoBytes ||
           (cbCurrentMessageSize > cbInboundCryptoBytes) ) {
        
           return LdapError;
        }
   
       IF_DEBUG(SSL) {
           LdapPrint1("CurrentMessageSize is  %d bytes\n", cbCurrentMessageSize);
           LdapPrint1("Total size of inbound buffer is  %d bytes\n", cbInboundCryptoBytes);
         }

      //
      // Advance to the start of the encrypted message
      //
      
      pbCryptoHead = pbInboundCrypto;
      pEncryptHeader = (PEncryptHeader_v1) pbCryptoHead;

      //
      // Actually unsign/decrypt the data!
      //

      CryptoBuffers[0].pvBuffer =  pbCryptoHead + sizeof(EncryptHeader_v1);
      CryptoBuffers[0].cbBuffer =  (*pntohl) (pEncryptHeader->EncryptMessageSize);
      CryptoBuffers[0].BufferType = SECBUFFER_STREAM;
   
      CryptoBuffers[1].pvBuffer = NULL;
      CryptoBuffers[1].cbBuffer = 0;
      CryptoBuffers[1].BufferType = SECBUFFER_DATA;
   
      Decrypt.cBuffers = 2;
      Decrypt.pBuffers = CryptoBuffers;
      Decrypt.ulVersion = SECBUFFER_VERSION;

      sErr = EncryptFunctionTable->DecryptMessage(
              &Connection->SecurityContext,
              &Decrypt,
              0,
              NULL );
   
   
      if ( sErr != ERROR_SUCCESS ){
   
          //
          // We failed in some catastrophic way, so we
          // pretty much have to dump all crypto and close 
          // the connection.
          //
   
          IF_DEBUG(SSL) {
              LdapPrint1( "wldap32: DecryptMessage couldn't decrypt.  sErr = 0x%x\n.", sErr );
              ASSERT( sErr == ERROR_SUCCESS );
          }

          LdapError = LdapConvertSecurityError( Connection, sErr );

          goto Cleanup;
      }
      
   
     ASSERT ( sErr == ERROR_SUCCESS );
      
     //
     // Copy the clear text into a new receive buffer.
     //
   
     LdapError = InjectNewReceive( (PBYTE) CryptoBuffers[1].pvBuffer,
                                   CryptoBuffers[1].cbBuffer
                                   );
     
     if (LdapError != LDAP_SUCCESS) {
   
        goto Cleanup;
     }
   
     IF_DEBUG(SSL) {
         LdapPrint1("Actual number of decrypted bytes is %d\n", CryptoBuffers[0].cbBuffer);
     }

      //
      // If we have any extra bytes remaining in our buffers, slide it to the
      // top. If not, we can delete the entire buffer.
      //
      
     ASSERT (cbInboundCryptoBytes >= cbCurrentMessageSize);
   
     if (cbInboundCryptoBytes > cbCurrentMessageSize) {
   
         ldap_MoveMemory((PCHAR) pbInboundCrypto,
                 (PCHAR) pbInboundCrypto+cbCurrentMessageSize,
                 cbInboundCryptoBytes - cbCurrentMessageSize
                 );
         
         //
         // Adjust the number of remaining crypto available
         //

         cbInboundCryptoBytes -= cbCurrentMessageSize;
         
         pEncryptHeader = (PEncryptHeader_v1) pbInboundCrypto;

         if (cbInboundCryptoBytes >= sizeof (ULONG)) {
             ULONG NewIncomingMessageLength = sizeof(EncryptHeader_v1) +
                                        (*pntohl) (pEncryptHeader->EncryptMessageSize);
          
             cbCurrentMessageSize = NewIncomingMessageLength;
             bCurrentMessageSizeValid = TRUE;
         }
         else {
             bCurrentMessageSizeValid = FALSE;
         }

         
   
     } else {
        
        //
        // We have no extra crypto left to decode.
        //
   
        goto Cleanup;
     }
   
   }   // for (;;)

Cleanup:

    cbCurrentMessageSize = 0;
    bCurrentMessageSizeValid = FALSE;
    cbInboundCryptoBytes = 0;

    if (cUnsignsPerformed > REEVAL_BUFFER_COUNT) {

        //
        // It's time to see if our buffer (pbInboundCrypto) may be
        // too large.  Every REEVAL_BUFFER_COUNT times through this code,
        // we check to see if the largest message in the last REEVAL_BUFFER_COUNT
        // number of operations used at least half of the buffer size.  If so,
        // fine --- we keep it.  If not, we free it and let it regrow on future
        // operations.  This avoids keeping a huge buffer around forever just because
        // one message happened to need it.
        // 
        if (cbMaxBufferUsed < (cbInboundCryptoLen/2)) {
            // buffer may be too large, get rid of it and start
            // from scratch on next operation
            ldapFree(pbInboundCrypto, LDAP_SECURITY_SIGNATURE);
            cbInboundCryptoLen = 0;
            pbInboundCrypto = NULL;
        }

        // reset for the next round
        cUnsignsPerformed = 0;
        cbMaxBufferUsed = 0;
    }
    
    return LdapError;
     
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\delete.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    delete.cxx handle delete requests to an LDAP server

Abstract:

   This module implements the LDAP delete APIs.

Author:

    Andy Herron (andyhe)        02-Jul-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

ULONG
LdapDelete(
        PLDAP_CONN connection,
        PWCHAR DistinguishedName,
        BOOLEAN Unicode,
        BOOLEAN Synchronous,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        ULONG           *MessageNumber
    )
{
    ULONG hr;
    PLDAP_REQUEST request = NULL;
    ULONG messageNumber;
    ULONG err;

    if (MessageNumber == NULL) {

        return LDAP_PARAM_ERROR;
    }

    *MessageNumber = (ULONG) -1;

    err = LdapConnect( connection, NULL, FALSE );

    if (err != 0) {
       return err;
    }

    SetConnectionError( connection, LDAP_SUCCESS, NULL );

    request = LdapCreateRequest( connection, LDAP_DELETE_CMD );

    if (request == NULL) {

        IF_DEBUG(OUTMEMORY) {
            LdapPrint1( "ldap_delete connection 0x%x couldn't allocate request.\n", connection);
        }
        hr = LDAP_NO_MEMORY;
        SetConnectionError( connection, hr, NULL );
        return hr;
    }

    messageNumber = request->MessageId;

    request->Synchronous = Synchronous;

    hr = LDAP_SUCCESS;

    if ((ServerControls != NULL) || (ClientControls != NULL)) {

        hr = LdapCheckControls( request,
                                ServerControls,
                                ClientControls,
                                Unicode,
                                0 );

        if (hr != LDAP_SUCCESS) {

            IF_DEBUG(CONTROLS) {
                LdapPrint2( "ldap_del connection 0x%x trouble with SControl, err 0x%x.\n",
                            connection, hr );
            }
        }
    }

    if (hr == LDAP_SUCCESS) {

        if (Synchronous || (request->ChaseReferrals == 0)) {

            request->AllocatedParms = FALSE;
            request->OriginalDN = DistinguishedName;

        } else {

            request->AllocatedParms = TRUE;

            if (DistinguishedName != NULL) {

                request->OriginalDN = ldap_dup_stringW( DistinguishedName, 0, LDAP_UNICODE_SIGNATURE );

                if (request->OriginalDN == NULL) {

                    hr = LDAP_NO_MEMORY;
                }
            }
        }
    }

    if (hr == LDAP_SUCCESS) {

        START_LOGGING;
        DSLOG((DSLOG_FLAG_TAG_CNPN,"[+]"));
        DSLOG((0,"[ID=%d][OP=ldap_delete][DN=%ws][ST=%I64d][-]\n",
               request->MessageId, DistinguishedName,
               request->RequestTime));
        END_LOGGING;

        hr = SendLdapDelete( request,
                             connection,
                             request->OriginalDN,
                             (CLdapBer **)&request->BerMessageSent,
                             0 );
    }

    if (hr != LDAP_SUCCESS) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "ldap_add connection 0x%x errored with 0x%x.\n",
                        connection, hr );
        }

        DSLOG((0,"[+][ID=%d][ET=%I64d][ER=%d][-]\n",request->MessageId,LdapGetTickCount(), hr));
        messageNumber = (ULONG) -1;
        SetConnectionError( connection, hr, NULL );

        CloseLdapRequest( request );
    }

    *MessageNumber = messageNumber;

    DereferenceLdapRequest( request );

    return hr;
}

ULONG
SendLdapDelete (
    PLDAP_REQUEST Request,
    PLDAP_CONN Connection,
    PWCHAR DistinguishedName,
    CLdapBer **Lber,
    LONG AltMsgId
    )
{
    ULONG hr;

    CLdapBer *lber = new CLdapBer( Connection->publicLdapStruct.ld_version );

    if (lber == NULL) {
        SetConnectionError( Connection, LDAP_NO_MEMORY, NULL );
        return LDAP_NO_MEMORY;
    }

    //
    //  The request looks like the following :
    //
    //   DelRequest ::= [APPLICATION 10] LDAPDN
    //

    hr = lber->HrStartWriteSequence();
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldap_delete startWrite conn 0x%x encoding error of 0x%x.\n",
                        Connection, hr );
        }

        goto encodingError;

    } else {            // we can't forget EndWriteSequence

       if (AltMsgId != 0) {

          hr = lber->HrAddValue((LONG) AltMsgId );

       } else {

          hr = lber->HrAddValue((LONG) Request->MessageId );
       }

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldap_delete MsgNo conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            goto encodingError;
        }

        hr = lber->HrAddValue((const WCHAR *) DistinguishedName, LDAP_DELETE_CMD );
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldap_delete DN conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            goto encodingError;
        }

        //
        //  put in the server controls here if required
        //

        if ( (Connection->publicLdapStruct.ld_version != LDAP_VERSION2) &&
             ( Request->ServerControls != NULL )) {

            hr = InsertServerControls( Request, Connection, lber );

            if (hr != LDAP_SUCCESS) {

                if (lber != NULL) {

                   delete lber;
                }
                return hr;
            }
        }

        hr = lber->HrEndWriteSequence();
        ASSERT( hr == NOERROR );
    }

    //
    //  send the delete request.
    //

    ACQUIRE_LOCK( &Connection->ReconnectLock );

    AddToPendingList( Request, Connection );

    hr = LdapSend( Connection, lber );

    if (hr != LDAP_SUCCESS) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "ldap_delete connection 0x%x send with error of 0x%x.\n",
                        Connection, hr );
        }
        DecrementPendingList( Request, Connection );

    } else {

        //
        //  Save off the lber value, free any lber message that is already
        //  present.
        //

        lber = (CLdapBer *) InterlockedExchangePointer((PVOID *) Lber,
                                                       (PVOID) lber );
    }

    RELEASE_LOCK( &Connection->ReconnectLock );

    if (lber != NULL) {

       delete lber;
    }

    return hr;

encodingError:

    if (lber != NULL) {

       delete lber;
    }

    return LDAP_ENCODING_ERROR;
}

ULONG __cdecl
ldap_delete_extW(
        LDAP *ExternalHandle,
        PWCHAR dn,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        ULONG           *MessageNumber
    )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err =  LdapDelete(  connection,
                        dn,
                        TRUE,
                        FALSE,
                        ServerControls,
                        ClientControls,
                        MessageNumber
                        );

    DereferenceLdapConnection( connection );

    return err;
}

ULONG __cdecl
ldap_deleteW (
    LDAP *ExternalHandle,
    PWCHAR DistinguishedName
    )
{
    ULONG err;
    ULONG msgId = (ULONG) -1;

    err = ldap_delete_extW( ExternalHandle,
                            DistinguishedName,
                            NULL,
                            NULL,
                            &msgId
                            );
    return msgId;
}

ULONG __cdecl
ldap_delete (
    LDAP *ExternalHandle,
    PCHAR DistinguishedName
    )
{
    ULONG err;
    ULONG msgId = (ULONG) -1;

    err = ldap_delete_extA( ExternalHandle,
                            DistinguishedName,
                            NULL,
                            NULL,
                            &msgId
                            );
    return msgId;
}


ULONG __cdecl
ldap_delete_sW (
    LDAP *ExternalHandle,
    PWCHAR DistinguishedName
    )
{
    return ldap_delete_ext_sW( ExternalHandle, DistinguishedName, NULL, NULL );
}

ULONG __cdecl
ldap_delete_s (
    LDAP *ExternalHandle,
    PCHAR DistinguishedName
    )
{
    return ldap_delete_ext_sA( ExternalHandle, DistinguishedName, NULL, NULL );
}


ULONG __cdecl
ldap_delete_extA(
        LDAP *ExternalHandle,
        PCHAR DistinguishedName,
        PLDAPControlA   *ServerControls,
        PLDAPControlA   *ClientControls,
        ULONG           *MessageNumber
        )
{
    ULONG err;
    PWCHAR wName = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if ((connection == NULL) || (MessageNumber == NULL)) {

        err = LDAP_PARAM_ERROR;
        goto error;
    }

    *MessageNumber = (ULONG) -1;

    err = ToUnicodeWithAlloc( DistinguishedName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, LDAP_PARAM_ERROR, NULL );
        goto error;
    }

    err = LdapDelete(  connection,
                       wName,
                       FALSE,
                       FALSE,
                       (PLDAPControlW *) ServerControls,
                       (PLDAPControlW *) ClientControls,
                       MessageNumber
                       );

error:
    if (wName)
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    if (connection)
        DereferenceLdapConnection( connection );

    return err;
}

ULONG __cdecl
ldap_delete_ext_sW(
        LDAP *ExternalHandle,
        PWCHAR dn,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls
        )
{
    ULONG err;
    ULONG msgId;
    LDAPMessage *results = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapDelete(connection,
                     dn,
                     TRUE,
                     TRUE,
                     ServerControls,
                     ClientControls,
                     &msgId
                     );

    //
    //  if we error'd out before we sent the request, return the error here.
    //

    if (msgId != (ULONG) -1) {

        //
        //  otherwise we simply need to wait for the response to come in.
        //

        err = ldap_result_with_error( connection,
                                      msgId,
                                      LDAP_MSG_ALL,
                                      NULL,           // no timeout value specified
                                      &results,
                                      NULL
                                    );

        if (results == NULL) {

            LdapAbandon( connection, msgId, TRUE );

        } else {

            err = ldap_result2error( ExternalHandle,
                                     results,
                                     TRUE
                                     );
        }
    }

    DereferenceLdapConnection( connection );

    return err;
}

ULONG __cdecl
ldap_delete_ext_sA(
        LDAP *ExternalHandle,
        PCHAR DistinguishedName,
        PLDAPControlA   *ServerControls,
        PLDAPControlA   *ClientControls
        )
{
    ULONG err;
    PWCHAR wName = NULL;
    ULONG msgId;
    LDAPMessage *results = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = ToUnicodeWithAlloc( DistinguishedName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        goto error;
    }

    err = LdapDelete(connection,
                     wName,
                     FALSE,
                     TRUE,
                     (PLDAPControlW *) ServerControls,
                     (PLDAPControlW *) ClientControls,
                     &msgId
                     );

    //
    //  if we error'd out before we sent the request, return the error here.
    //

    if (msgId != (ULONG) -1) {

        //
        //  otherwise we simply need to wait for the response to come in.
        //

        err = ldap_result_with_error( connection,
                                      msgId,
                                      LDAP_MSG_ALL,
                                      NULL,           // no timeout value specified
                                      &results,
                                      NULL
                                    );

        if (results == NULL) {

            LdapAbandon( connection, msgId, TRUE );

        } else {

            err = ldap_result2error( ExternalHandle,
                                     results,
                                     TRUE
                                     );
        }
    }

error:
    if (wName)
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    DereferenceLdapConnection( connection );

    return err;

}

// delete.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\debug.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    debug.h   LDAP client 32 debugging/tracing

Abstract:

   This module implements debugging/tracing macros

Author:

    Andy Herron    (andyhe)        08-May-1996
    Anoop Anantha  (AnoopA)        24-Jun-1998

Revision History:

--*/

#ifndef _LDAPDEBUG_
#define _LDAPDEBUG_

extern DBGPRINT GlobalLdapDbgPrint;

//
//  If SRVDBG is not defined and DBG is TRUE, define SRVDBG
//

#ifndef DBG
#define DBG 0
#endif

// Debugging macros
//

#if !DBG
#define LDAPDBG 0
#else
#define LDAPDBG 1
#endif

#undef IF_DEBUG
#undef LDAP_ASSERT
#undef ASSERT     

extern ULONG LdapDebug;

#if LDAPDBG

    #if (WINVER >= 0x0400)

    ULONG
    _cdecl
    DbgPrint(
        PCH Format,
        ...
        );

    #endif

    #define LDAP_ASSERT  DebugBreak();
    #define ASSERT( x )   if ( !(x) ) DebugBreak();

    #define DEBUG if (TRUE)
    #define IF_DEBUG(flag) if (LdapDebug & (DEBUG_ ## flag))

    #define LdapPrint0(fmt) if (GlobalLdapDbgPrint) {(*GlobalLdapDbgPrint)(("0x%x: "),(GetCurrentThreadId()));(*GlobalLdapDbgPrint)((fmt));}
    #define LdapPrint1(fmt,v0) if (GlobalLdapDbgPrint) {(*GlobalLdapDbgPrint)(("0x%x: "),(GetCurrentThreadId()));(*GlobalLdapDbgPrint)((fmt),(v0));}
    #define LdapPrint2(fmt,v0,v1) if (GlobalLdapDbgPrint) {(*GlobalLdapDbgPrint)(("0x%x: "),(GetCurrentThreadId()));(*GlobalLdapDbgPrint)((fmt),(v0),(v1));}
    #define LdapPrint3(fmt,v0,v1,v2) if (GlobalLdapDbgPrint) {(*GlobalLdapDbgPrint)(("0x%x: "),(GetCurrentThreadId()));(*GlobalLdapDbgPrint)((fmt),(v0),(v1),(v2));}
    #define LdapPrint4(fmt,v0,v1,v2,v3) if (GlobalLdapDbgPrint) {(*GlobalLdapDbgPrint)(("0x%x: "),(GetCurrentThreadId()));(*GlobalLdapDbgPrint)((fmt),(v0),(v1),(v2),(v3));}
    #define PRINT_LITERAL(literal) if (GlobalLdapDbgPrint) {(*GlobalLdapDbgPrint)(("0x%x: "),(GetCurrentThreadId()));(*GlobalLdapDbgPrint)( #literal" = %lx\n", (literal) );}

#else

    #define ASSERT( x )   ;
    #define DEBUG if (FALSE)
    #define IF_DEBUG(flag) if (FALSE)
    #define IF_NCP_DEBUG(flag) if (FALSE)

    #define LdapPrint0(fmt)
    #define LdapPrint1(fmt,v0)
    #define LdapPrint2(fmt,v0,v1)
    #define LdapPrint3(fmt,v0,v1,v2)
    #define LdapPrint4(fmt,v0,v1,v2,v3)

#endif

#define DEBUG_TRACE1              0x00000001
#define DEBUG_TRACE2              0x00000002
#define DEBUG_REFCNT              0x00000004
#define DEBUG_HEAP                0x00000008

#define DEBUG_CACHE               0x00000010
#define DEBUG_SSL                 0x00000020
#define DEBUG_SPEWSEARCH          0x00000040
#define DEBUG_SERVERDOWN          0x00000080

#define DEBUG_CONNECT             0x00000100
#define DEBUG_RECONNECT           0x00000200
#define DEBUG_RECEIVEDATA         0x00000400
#define DEBUG_PING                0x00000800

#define DEBUG_EOM                 0x00001000
#define DEBUG_BER                 0x00002000
#define DEBUG_OUTMEMORY           0x00004000
#define DEBUG_CONTROLS            0x00008000

#define DEBUG_HANDLES             0x00010000
#define DEBUG_CLDAP               0x00020000
#define DEBUG_FILTER              0x00040000
#define DEBUG_BIND                0x00080000

#define DEBUG_NETWORK_ERRORS      0x00100000
#define DEBUG_SCRATCH             0x00200000
#define DEBUG_PARSE               0x00400000
#define DEBUG_REFERRALS           0x00800000

#define DEBUG_SEARCH              0x01000000
#define DEBUG_REQUEST             0x02000000
#define DEBUG_CONNECTION          0x04000000
#define DEBUG_INIT_TERM           0x08000000

#define DEBUG_API_ERRORS          0x10000000
#define DEBUG_STOP_ON_ERRORS      0x20000000 /* If set, stop on internal errs */
#define DEBUG_ERRORS2             0x40000000
#define DEBUG_ERRORS              0x80000000

//
// Logging lock
//

#if DBG
#define START_LOGGING           ACQUIRE_LOCK(&LoadLibLock)
#define END_LOGGING             RELEASE_LOCK(&LoadLibLock)
#else
#define START_LOGGING           
#define END_LOGGING             
#endif

#endif // ndef _LDAPDEBUG_

// debug.h eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\default.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    default.cxx utility routine to get default ldap server

Abstract:

Author:

    Chuck Chan     (chuckc)        10-Sep-1996
    Andy Herron    (andyhe)
    Anoop Anantha  (AnoopA)        24-Jun-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

//
// Misc definitions & helper functions
//

VOID LoadNetApi32Now(
    VOID
    );

typedef DWORD (*PF_DsGetDcName) (
    IN LPCWSTR ComputerName OPTIONAL,
    IN LPCWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN GUID *SiteGuid OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
);

typedef DWORD (*PF_NetApiBufferFree) (
    IN LPVOID Buffer
);

typedef DWORD (*PF_DsGetDcOpen) (
    IN LPCSTR DnsName,              // UTF-8 Name
    IN ULONG Reserved,
    IN LPCWSTR SiteName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCSTR DnsTreeName OPTIONAL,
    IN ULONG Flags,
    OUT PHANDLE RetGetDcContext
    );

typedef DWORD (*PF_DsGetDcOpenW) (
    IN LPCWSTR DnsName,              // Unicode Name
    IN ULONG Reserved,
    IN LPCWSTR SiteName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR DnsTreeName OPTIONAL,  // Unicode Name
    IN ULONG Flags,
    OUT PHANDLE RetGetDcContext
    );

typedef DWORD (*PF_DsGetDcNext) (
    IN HANDLE GetDcContextHandle,
    OUT PULONG SockAddressCount OPTIONAL,
    OUT LPSOCKET_ADDRESS *SockAddresses OPTIONAL,
    OUT LPSTR *DnsHostName OPTIONAL
    );

typedef DWORD (*PF_DsGetDcNextW) (
    IN HANDLE GetDcContextHandle,
    OUT PULONG SockAddressCount OPTIONAL,
    OUT LPSOCKET_ADDRESS *SockAddresses OPTIONAL,
    OUT LPWSTR *DnsHostName OPTIONAL     // Unicode Name
    );

typedef DWORD (*PF_DsGetDcClose) (
    IN HANDLE GetDcContextHandle
    );

typedef DWORD (*PF_DsGetDcCloseW) (
    IN HANDLE GetDcContextHandle
    );

typedef LONG (APIENTRY * PF_RegOpenKeyExW) (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
);

typedef LONG (APIENTRY * PF_RegQueryValueExW) (
    HKEY hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
);

typedef LONG (APIENTRY * PF_RegCloseKey) (
    HKEY hKey
    );

typedef DWORD (*PF_DsGetSiteNameW)(
    IN  LPCWSTR ComputerName OPTIONAL,
    OUT LPWSTR *SiteName
);

typedef DWORD (*PF_DsRoleGetPrimaryDomainInformation) (
    IN LPCWSTR lpServer OPTIONAL,
    IN DSROLE_PRIMARY_DOMAIN_INFO_LEVEL InfoLevel,
    OUT PBYTE *Buffer
);

typedef VOID (*PF_DsRoleFreeMemory) (
    IN PVOID    Buffer
);


PF_DsGetDcName pfDsGetDcName = NULL;
PF_DsGetDcOpen pfDsGetDcOpen = NULL;
PF_DsGetDcNext pfDsGetDcNext = NULL;
PF_DsGetDcClose pfDsGetDcClose = NULL;
PF_DsGetDcOpenW pfDsGetDcOpenW = NULL;
PF_DsGetDcNextW pfDsGetDcNextW = NULL;
PF_DsGetDcCloseW pfDsGetDcCloseW = NULL;
PF_NetApiBufferFree pfNetApiBufferFree = NULL;
PF_RegOpenKeyExW pfRegOpenKeyExW = NULL;
PF_RegQueryValueExW pfRegQueryValueExW = NULL;
PF_RegCloseKey pfRegCloseKey = NULL;
PF_DsGetSiteNameW pfDsGetSiteName = NULL;
PF_DsRoleGetPrimaryDomainInformation pfDsRoleGetPrimaryDomainInformation = NULL;
PF_DsRoleFreeMemory pfDsRoleFreeMemory = NULL;

BOOLEAN FailedNetApi32LoadLib = FALSE;
BOOLEAN FailedAdvApi32LoadLib = FALSE;

BOOLEAN  UnicodeDsGetDCx = TRUE;


VOID LoadNetApi32Now(
    VOID
    )
{
    //
    // if the netapi32 DLL is not loaded, we make sure its loaded now.
    //

    if ((pfNetApiBufferFree != NULL) || (FailedNetApi32LoadLib == TRUE)) {

        return;
    }

    ACQUIRE_LOCK( &LoadLibLock );

    if ((NetApi32LibraryHandle == NULL) && ! FailedNetApi32LoadLib) {

        // load the library. if it fails, it would have done a SetLastError.

        if ( !GlobalWin9x ) {
            
            NetApi32LibraryHandle = LoadSystem32LibraryA("NETAPI32.DLL");
        
        } else {
            
            NetApi32LibraryHandle = LoadSystem32LibraryA("LOGONSRV.DLL");
        }


        if (NetApi32LibraryHandle != NULL) {

            pfDsGetDcName =  (PF_DsGetDcName) GetProcAddress(
                                                NetApi32LibraryHandle,
                                                "DsGetDcNameW");
            //
            // On NT 5.1 and above, we will find the unicode versions
            // of the DsGetDcOpen/Next/Close.
            //

            pfDsGetDcOpenW =  (PF_DsGetDcOpenW) GetProcAddress(
                                                 NetApi32LibraryHandle,
                                                 "DsGetDcOpenW");

            if (pfDsGetDcOpenW) {

                //
                // Whistler and above.
                //
                

                pfDsGetDcNextW =  (PF_DsGetDcNextW) GetProcAddress(
                                                    NetApi32LibraryHandle,
                                                    "DsGetDcNextW");
                pfDsGetDcCloseW =  (PF_DsGetDcCloseW) GetProcAddress(
                                                    NetApi32LibraryHandle,
                                                    "DsGetDcCloseW");
            } else {

                UnicodeDsGetDCx = FALSE;
                
                pfDsGetDcOpen =  (PF_DsGetDcOpen) GetProcAddress(
                                                    NetApi32LibraryHandle,
                                                    "DsGetDcOpen");
                pfDsGetDcNext =  (PF_DsGetDcNext) GetProcAddress(
                                                    NetApi32LibraryHandle,
                                                    "DsGetDcNext");
                pfDsGetDcClose =  (PF_DsGetDcClose) GetProcAddress(
                                                    NetApi32LibraryHandle,
                                                    "DsGetDcClose");
            }

            pfNetApiBufferFree = (PF_NetApiBufferFree) GetProcAddress(
                                                NetApi32LibraryHandle,
                                                "NetApiBufferFree");
            pfDsGetSiteName =  (PF_DsGetSiteNameW) GetProcAddress(
                                                NetApi32LibraryHandle,
                                                "DsGetSiteNameW");
            pfDsRoleGetPrimaryDomainInformation = (PF_DsRoleGetPrimaryDomainInformation) GetProcAddress(
                                                  NetApi32LibraryHandle,
                                                  "DsRoleGetPrimaryDomainInformation");
            pfDsRoleFreeMemory = (PF_DsRoleFreeMemory) GetProcAddress(
                                                  NetApi32LibraryHandle,
                                                  "DsRoleFreeMemory");
        } else {

            //
            //  only try to loadlib the file once
            //

            FailedNetApi32LoadLib = TRUE;
        }
    }

    RELEASE_LOCK( &LoadLibLock );
    return;
}

//
// Synopsis:   This routine is a wrapper around DsGetDcName(). However, it also
//             returns data from registry in case we cant find the DC.
//
// Parameters: Address - Used to return array of address strings. Typically
//             "122.356.006.676" or "phoenix".
//
//             Count - size of array on input, count of items on output.
//
//             Verify - if TRUE will as DsGetDcName to DS_FORCE_REDISCOVERY
//
// Returns:    NO_ERROR or Win32 error code.
//
// Notes:      The strings returned in the result array need to be freed
//
//
// Example usage:
//
//    if (err = GetDefaultLdapServer(NULL, Addresses, &Count, FALSE)) {
//
//         printf("GetDefaultLdapServer failed with: %d\n", err) ;
//    }
//
//    printf("LDAP servers are:\n") ;
//    for (i = 0; i < Count; i++) {
//
//        printf("%S\n", Addresses[i]) ;
//        (void) LocalFree(Addresses[i]) ;
//    }
//

DWORD
GetDefaultLdapServer(
    PWCHAR DomainName,
    LPWSTR Addresses[],
    LPWSTR DnsHostNames[],
    LPWSTR MemberDomains[],
    LPDWORD Count,
    ULONG DsFlags,
    BOOLEAN *SameSite,
    USHORT PortNumber,
    ULONG *pResolvedDsFlags
    )
{
    DWORD  err = 0;
    DWORD  index = 0 ;
    PDOMAIN_CONTROLLER_INFOW pDomainControllerInfo = NULL;

    if (!Addresses || !Count || !DnsHostNames || !SameSite) {

        return ERROR_INVALID_PARAMETER ;
    }

    *SameSite = FALSE;

    // if not already loaded, load dll now

    (void) LoadNetApi32Now() ;

    if ((pfDsGetDcName != NULL) && (index < *Count)) {

       DWORD Flags = 0;

       if (( PortNumber == LDAP_GC_PORT ) ||
            ( PortNumber == LDAP_SSL_GC_PORT )) {

          Flags = ( DS_ONLY_LDAP_NEEDED   |
                    DS_GC_SERVER_REQUIRED |
                    DS_RETURN_DNS_NAME    |
                    DsFlags );
       
       } else {

          //
          // By default, look for DCs
          //

          Flags = ( DS_ONLY_LDAP_NEEDED           |
                    DS_RETURN_DNS_NAME            |
                    DsFlags );
       }

        err = (*pfDsGetDcName)(NULL,
                               DomainName,
                               NULL,
                               NULL,
                               Flags,
                               &pDomainControllerInfo
                               ) ;
        if (err == NO_ERROR) {

            ASSERT((pDomainControllerInfo->DomainControllerAddress[1] \
                   == TEXT('\\'))) ;

            Addresses[index] = ldap_dup_stringW( pDomainControllerInfo->
                                                DomainControllerAddress+2,
                                                0,
                                                LDAP_HOST_NAME_SIGNATURE );

            if (!Addresses[index]) {

                err = ERROR_OUTOFMEMORY;
                goto error;
            }

            DnsHostNames[index] = ldap_dup_stringW( pDomainControllerInfo->
                                                    DomainControllerName+2,
                                                    0,
                                                    LDAP_HOST_NAME_SIGNATURE );

            if (!DnsHostNames[index]) {

                ldapFree(Addresses[index], LDAP_HOST_NAME_SIGNATURE);
                Addresses[index] = NULL;
                
                err = ERROR_OUTOFMEMORY;
                goto error;
            }


            if (MemberDomains) {
                MemberDomains[index] = ldap_dup_stringW( pDomainControllerInfo->
                                                        DomainName,
                                                        0,
                                                        LDAP_HOST_NAME_SIGNATURE );

                if ((!MemberDomains[index]) && (pDomainControllerInfo->DomainName)) {

                    ldapFree(DnsHostNames[index], LDAP_HOST_NAME_SIGNATURE);
                    ldapFree(Addresses[index], LDAP_HOST_NAME_SIGNATURE);
                    DnsHostNames[index] = NULL;
                    Addresses[index] = NULL;
                    
                    err = ERROR_OUTOFMEMORY;
                    goto error;
                }
                                                        
            }
            
            if ((pDomainControllerInfo->DcSiteName) && (pDomainControllerInfo->ClientSiteName)) {

                  if ( (lstrcmpW(pDomainControllerInfo->DcSiteName, pDomainControllerInfo->ClientSiteName) == 0)) {
      
                     *SameSite = TRUE;
                  } else {
      
                     *SameSite = FALSE;
                  }
            } else {

               *SameSite = FALSE;
            }

            *pResolvedDsFlags = pDomainControllerInfo->Flags;

            //
            // If there are dots at the end of either the DC name or the domain
            // name, we will strip it off.
            //

            PWCHAR checkForEndDot =  NULL;

            if ( DnsHostNames[index] ) {
                  
                 checkForEndDot = DnsHostNames[index];

                  while (*checkForEndDot != L'\0') {
                     checkForEndDot++;
                  }
                  
                  if (*(checkForEndDot-1) == L'.') {
                     //
                     // Remove the '.' at the end.
                     //
                     *(checkForEndDot-1) = L'\0';
                  }
            }

            if (MemberDomains) {
                if ( MemberDomains[index] ) {
                    
                    checkForEndDot = MemberDomains[index];

                     while (*checkForEndDot != L'\0') {
                        checkForEndDot++;
                     }
                     
                     if (*(checkForEndDot-1) == L'.') {
                        //
                        // Remove the '.' at the end.
                        //
                        *(checkForEndDot-1) = L'\0';
                     }
                }
            }


            if (pfNetApiBufferFree != NULL) {
                (*pfNetApiBufferFree)(pDomainControllerInfo);
                pDomainControllerInfo = NULL;
            }
            index++ ;
        }
    }

    *Count = index ;

error:

    if ((pfNetApiBufferFree != NULL) && (pDomainControllerInfo != NULL)) {
        (*pfNetApiBufferFree)(pDomainControllerInfo);
        pDomainControllerInfo = NULL;
    }
    
    return err;
}



DWORD LoadRegAPISet(void)
{
    DWORD error = ERROR_SUCCESS;

    // if not already loaded, load dll now
    ACQUIRE_LOCK( &LoadLibLock );

    if ((AdvApi32LibraryHandle == NULL) && ! FailedAdvApi32LoadLib ) {

        // load the library. if it fails, it would have done a SetLastError.

        AdvApi32LibraryHandle = LoadSystem32LibraryA("ADVAPI32.DLL");

        if (AdvApi32LibraryHandle == NULL) {

            //
            //  only try to loadlib the file once
            //

            FailedAdvApi32LoadLib = TRUE;
            pfRegOpenKeyExW = NULL;

            RELEASE_LOCK( &LoadLibLock );
            return GetLastError();
        }
    }

    if ((AdvApi32LibraryHandle != NULL) && (pfRegOpenKeyExW == NULL)) {

        pfRegOpenKeyExW =  (PF_RegOpenKeyExW) GetProcAddress(
                                                    AdvApi32LibraryHandle,
                                                    "RegOpenKeyExW");
        pfRegQueryValueExW = (PF_RegQueryValueExW) GetProcAddress(
                                                    AdvApi32LibraryHandle,
                                                    "RegQueryValueExW");
        pfRegCloseKey = (PF_RegCloseKey) GetProcAddress(
                                                    AdvApi32LibraryHandle,
                                                    "RegCloseKey");

        if ((pfRegQueryValueExW == NULL) ||
            (pfRegCloseKey == NULL)) {

            pfRegOpenKeyExW = NULL;
            error = ERROR_FILE_NOT_FOUND;
        }
    }

    RELEASE_LOCK( &LoadLibLock );

    return error;
}


#define LDAP_INTEGRITY_DEFAULT_KEY      L"System\\CurrentControlSet\\Services\\LDAP"
#define LDAP_INTEGRITY_DEFAULT_VALUE    L"LdapClientIntegrity"

DWORD ReadRegIntegrityDefault(DWORD *pdwIntegrity)
{
    DWORD  err;
    HKEY   hKey;
    DWORD  dwType;
    DWORD  dwIntegSetting;
    DWORD  cbIntegSetting = sizeof(dwIntegSetting);

    //
    // Open the registry Key
    //

    if (err = RegOpenKeyExW (  HKEY_LOCAL_MACHINE,
                               LDAP_INTEGRITY_DEFAULT_KEY,
                               0L,
                               KEY_READ,
                               &hKey)) {

        return err ;
    }

    err = RegQueryValueExW (hKey,
                            LDAP_INTEGRITY_DEFAULT_VALUE,
                            NULL,
                            &dwType,
                            (LPBYTE) &dwIntegSetting,
                            &cbIntegSetting) ;

    if (err == ERROR_SUCCESS) {

        if (dwType != REG_DWORD) {
            err = ERROR_CANTREAD;
        }
        else {
            *pdwIntegrity = dwIntegSetting;
        }
    }

    RegCloseKey(hKey) ;

    return err;
}


DWORD
InitLdapServerFromDomain(
    LPCWSTR DomainName,
    ULONG Flags,
    OUT HANDLE *Handle,
    LPWSTR *Site
    )
{
    DWORD  status;
    DWORD flags = Flags;
    PCHAR DomainNameU = NULL;   // UTF-8 domain name

    flags &= DS_PDC_REQUIRED |
             DS_GC_SERVER_REQUIRED |
             DS_WRITABLE_REQUIRED |
             DS_ONLY_LDAP_NEEDED;

    // if not already loaded, load dll now

    (void) LoadNetApi32Now() ;

    if ( UnicodeDsGetDCx && 
         ((pfDsGetDcOpenW  == NULL) ||
          (pfDsGetDcNextW  == NULL) ||
          (pfDsGetDcCloseW == NULL))) {
        
        return ERROR_FILE_NOT_FOUND ;   // something wrong here.
    }

    if ((pfDsGetDcOpen  == NULL) ||
        (pfDsGetDcNext  == NULL) ||
        (pfDsGetDcClose == NULL)) {

        return ERROR_FILE_NOT_FOUND ;   // Win9x possibly
    }

    if (Site != NULL ) {

        *Site = NULL;

        if (pfDsGetSiteName != NULL &&
            pfNetApiBufferFree != NULL) {

            status = (*pfDsGetSiteName)( NULL, Site );
        }
    }

    if ( UnicodeDsGetDCx ) {

        status = (*pfDsGetDcOpenW)( DomainName,     // Unicode domain name
                                    0,
                                    Site != NULL ? *Site : NULL,
                                    NULL,
                                    NULL,
                                    flags,
                                    Handle
                                    );

    
    } else {

        //
        // Convert domain name to UTF-8 to work around the inconsistency
        // in the API.
        //
    
    
        status = FromUnicodeWithAlloc( (PWCHAR) DomainName,
                                       &DomainNameU,
                                       LDAP_HOST_NAME_SIGNATURE,
                                       LANG_UTF8
                                       );
    
        if ( status != LDAP_SUCCESS ) {
    
            return status;
        }
    
        status = (*pfDsGetDcOpen)(
                                  (LPCSTR) DomainNameU,     // UTF-8 domain name
                                  0,
                                  Site != NULL ? *Site : NULL,
                                  NULL,
                                  NULL,
                                  flags,
                                  Handle
                                  );
    
    }

    return status;
}

DWORD
NextLdapServerFromDomain(
    HANDLE Handle,
    LPSOCKET_ADDRESS *SockAddresses,
    PWCHAR *DnsHostNameW,
    PULONG SocketCount
    )
{
    DWORD  status = NO_ERROR;
    HANDLE handle = NULL;
    PCHAR  DnsHostNameU = NULL;

    if (SockAddresses != NULL) {
        *SockAddresses = NULL;
    }

    if (SocketCount != NULL) {
        *SocketCount = 0;
    }

    if (DnsHostNameW != NULL) {
       *DnsHostNameW = NULL;
    }

    if ( UnicodeDsGetDCx ) {
        
        status = (*pfDsGetDcNextW)(  Handle,
                                     SocketCount,
                                     SockAddresses,
                                     DnsHostNameW
                                     ) ;
    } else {

        status = (*pfDsGetDcNext)(  Handle,
                                    SocketCount,
                                    SockAddresses,
                                    &DnsHostNameU
                                    ) ;
        
        if (( DnsHostNameU != NULL ) &&
            ( status == LDAP_SUCCESS )) {
    
            status = ToUnicodeWithAlloc(DnsHostNameU,
                                        -1,
                                        DnsHostNameW,
                                        LDAP_HOST_NAME_SIGNATURE,
                                        LANG_UTF8);
        }
    }

    return status;
}


DWORD
CloseLdapServerFromDomain(
    HANDLE Handle,
    LPWSTR Site
    )
{

    if ( UnicodeDsGetDCx ) {
    
        (*pfDsGetDcCloseW)(Handle) ;

    } else {

        (*pfDsGetDcClose)(Handle) ;
    }

    if (Site != NULL) {
        (*pfNetApiBufferFree)(Site);
    }

    return NO_ERROR;
}


#define LDAP_REF_DBG_KEY      L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\LDAP"
#define LDAP_REF_DBG_VALUE    L"ReferralPopup"

VOID
DiscoverDebugRegKey(
    VOID
    )
{
    DWORD  err;
    HKEY   hKey;
    DWORD  popup = 0;
    DWORD  dwType, cb = sizeof(popup);


//    ACQUIRE_LOCK( &LoadLibLock );

    if ((AdvApi32LibraryHandle == NULL) && ! FailedAdvApi32LoadLib ) {

        // load the library. if it fails, it would have done a SetLastError.

        AdvApi32LibraryHandle = LoadSystem32LibraryA("ADVAPI32.DLL");

        if (AdvApi32LibraryHandle == NULL) {

            //
            //  only try to loadlib the file once
            //

            FailedAdvApi32LoadLib = TRUE;
            pfRegOpenKeyExW = NULL;
            
            DbgPrint("Bad library handle\n");

//          RELEASE_LOCK( &LoadLibLock );
            return;
        }
    }

    if ((AdvApi32LibraryHandle != NULL) && (pfRegOpenKeyExW == NULL)) {

        pfRegOpenKeyExW =  (PF_RegOpenKeyExW) GetProcAddress(
                                                    AdvApi32LibraryHandle,
                                                    "RegOpenKeyExW");
        pfRegQueryValueExW = (PF_RegQueryValueExW) GetProcAddress(
                                                    AdvApi32LibraryHandle,
                                                    "RegQueryValueExW");
        pfRegCloseKey = (PF_RegCloseKey) GetProcAddress(
                                                    AdvApi32LibraryHandle,
                                                    "RegCloseKey");

        if ((pfRegQueryValueExW == NULL) ||
            (pfRegCloseKey == NULL)) {

            pfRegOpenKeyExW = NULL;
        }
    }

//    RELEASE_LOCK( &LoadLibLock );

    if (pfRegOpenKeyExW == NULL) {

       DbgPrint("Bad func ptr\n");

        return;

    } else {

        //
        // Open the registry Key
        //

        if (err = (*pfRegOpenKeyExW) (  HKEY_LOCAL_MACHINE,
                                        LDAP_REF_DBG_KEY,
                                        0L,
                                        KEY_READ,
                                        &hKey)) {
           DbgPrint("cant open regkey\n");

            return;
        }

        err = (*pfRegQueryValueExW) (hKey,
                                     LDAP_REF_DBG_VALUE,
                                     NULL,
                                     &dwType,
                                     (LPBYTE) &popup,
                                     &cb) ;

        if (err == NO_ERROR) {

        
           DbgPrint("Found debug key\n");
           PopupRegKeyFound = popup ? TRUE: FALSE;
        } else {
           DbgPrint("Bad api return value\n");

        }

        (*pfRegCloseKey)(hKey) ;
    }
    return ;
}



ULONG
GetCurrentMachineParams(
    PWCHAR* Address,
    PWCHAR* DnsHostName
    )
{

    //
    // Try our best to figure out if the current machine is a DC. If
    // we succeed, we return the machine name so that future binds can
    // create an SPN out of it. Note that we do not try to retrieve the
    // domain name of the current machine. This is because we don't want
    // to fail over to other members of this domain at a later stage.
    //
    
    #define MAX_DNS_NAME_SIZE    200
    ULONG err = LDAP_OTHER;

    // if not already loaded, load dll now

    (void) LoadNetApi32Now() ;
    
    if (!pfDsRoleGetPrimaryDomainInformation  ||
        !pfDsRoleFreeMemory) {

        return ERROR_FILE_NOT_FOUND;        // NT4 and Win9x
    }

    if (!Address || !DnsHostName) {

        return LDAP_LOCAL_ERROR;
    }

    *Address = *DnsHostName = NULL;

    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pBasic = NULL;

    err = pfDsRoleGetPrimaryDomainInformation( NULL,
                                              DsRolePrimaryDomainInfoBasic,
                                              (PBYTE *)&pBasic
                                              );

    if (err != LDAP_SUCCESS) {

        return err;
    }

    if ((pBasic->MachineRole == DsRole_RoleBackupDomainController) ||
        (pBasic->MachineRole == DsRole_RolePrimaryDomainController)) {

        //
        // Copy the localhost IP address 
        //

        *Address = ldap_dup_stringW( L"127.0.0.1", 0, LDAP_HOST_NAME_SIGNATURE );

        if (!*Address) {
            
            err = LDAP_NO_MEMORY;
            goto CleanupAndExit;
        }

        DWORD bufSize = 0; 
        
        //
        // discover the size of the hostname
        //

        GetComputerNameW( NULL, &bufSize );

        if (bufSize == 0) {
            
            err = LDAP_LOCAL_ERROR;
            goto CleanupAndExit;
        }
        
        ASSERT( bufSize < 1000 );        
        
        *DnsHostName = (PWCHAR) ldapMalloc( (bufSize+1)*sizeof(WCHAR),
                                             LDAP_HOST_NAME_SIGNATURE );
            
        if (!*DnsHostName) {
            
            err = LDAP_NO_MEMORY;
            goto CleanupAndExit;
        }
        
        //
        // Call again to retrieve the actual hostname.
        //

        if ( !GetComputerNameW( *DnsHostName, &bufSize ) ) {

            err = LDAP_LOCAL_ERROR;
            goto CleanupAndExit;
        }
    
    } else {

        //
        // This machine is not a DC.
        //

        err = LDAP_UNAVAILABLE;
    }

CleanupAndExit:

        if (pBasic) {
            pfDsRoleFreeMemory( pBasic );
        }
        
        if (err != LDAP_SUCCESS) {
            ldapFree(*DnsHostName, LDAP_HOST_NAME_SIGNATURE);
            ldapFree(*Address, LDAP_HOST_NAME_SIGNATURE);
            *Address = *DnsHostName = NULL;
        }
        
        return err;

}


ULONG
GetPrimaryDomainName(
    PWCHAR* pDomainName
    )
{

    ULONG err = ERROR_SUCCESS;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pBasic = NULL;

    ASSERT(pDomainName != NULL);

    //
    // Load the necessary APIs
    //
    (void) LoadNetApi32Now() ;
    
    if (!pfDsRoleGetPrimaryDomainInformation  ||
        !pfDsRoleFreeMemory) {

        return ERROR_FILE_NOT_FOUND;        // NT4 and Win9x
    }


    //
    // Retrieve the domain info
    //
    err = pfDsRoleGetPrimaryDomainInformation( NULL,
                                              DsRolePrimaryDomainInfoBasic,
                                              (PBYTE *)&pBasic
                                              );

    if (err != ERROR_SUCCESS) {

        goto exit;
    }

    
    //
    // Copy off the DNS domain name
    //
    
    *pDomainName = ldap_dup_stringW( pBasic->DomainNameDns, 0, LDAP_HOST_NAME_SIGNATURE );

    if ( (*pDomainName == NULL) && (pBasic->DomainNameDns != NULL) ) {
    
        // out of memory
        err = LDAP_NO_MEMORY;
        goto exit;
    }
    
exit:

    if (pBasic) {
        pfDsRoleFreeMemory( pBasic );
    }

    return err;
}


// default.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\extend.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    extend.cxx handle extended requests to an LDAP server

Abstract:

   This module implements the LDAP delete APIs.

Author:

    Andy Herron (andyhe)        02-Jul-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

//
//  These APIs allow a client to send an extended request (free for all) to
//  an LDAPv3 (or above) server.  The functionality is fairly open... you can
//  send any request you'd like.  Note that since we don't know if you'll
//  be receiving a single or multiple results, you'll have to explicitly tell
//  us when you're done with the request by calling ldap_close_extended_op.
//

ULONG
LdapExtendedOp(
        PLDAP_CONN connection,
        PWCHAR Oid,
        struct berval   *Data,
        BOOLEAN Unicode,
        BOOLEAN Synchronous,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        ULONG           *MessageNumber
    )
{
    ULONG hr;
    PLDAP_REQUEST request = NULL;
    ULONG messageNumber;
    ULONG err;

    if (MessageNumber == NULL) {

        return LDAP_PARAM_ERROR;
    }

    *MessageNumber = (ULONG) -1;

    err = LdapConnect( connection, NULL, FALSE );

    if (err != 0) {
       return err;
    }

    SetConnectionError( connection, LDAP_SUCCESS, NULL );

    request = LdapCreateRequest( connection, LDAP_EXTENDED_CMD );

    if (request == NULL) {

        IF_DEBUG(OUTMEMORY) {
            LdapPrint1( "ldap_extended connection 0x%x couldn't allocate request.\n", connection);
        }
        hr = LDAP_NO_MEMORY;
        SetConnectionError( connection, hr, NULL );
        return hr;
    }

    messageNumber = request->MessageId;

    request->Synchronous = Synchronous;

    hr = LDAP_SUCCESS;

    if ((ServerControls != NULL) || (ClientControls != NULL)) {

        hr = LdapCheckControls( request,
                                ServerControls,
                                ClientControls,
                                Unicode,
                                0 );

        if (hr != LDAP_SUCCESS) {

            IF_DEBUG(CONTROLS) {
                LdapPrint2( "ldap_del connection 0x%x trouble with SControl, err 0x%x.\n",
                            connection, hr );
            }
        }
    }

    if (hr == LDAP_SUCCESS) {

        request->extended.Data.bv_len = Data ? Data->bv_len : 0;

        if (Synchronous || (request->ChaseReferrals == 0)) {

            request->AllocatedParms = FALSE;
            request->OriginalDN = Oid;
            request->extended.Data.bv_val = Data ? Data->bv_val : NULL;

        } else {

            request->AllocatedParms = TRUE;

            if (Oid != NULL) {

                request->OriginalDN = ldap_dup_stringW( Oid, 0, LDAP_UNICODE_SIGNATURE );

                if (request->OriginalDN == NULL) {

                    hr = LDAP_NO_MEMORY;
                }
            }

            if ((hr == LDAP_SUCCESS) &&
                (Data != NULL) &&
                (Data->bv_val != NULL) &&
                (Data->bv_len > 0)) {

                request->extended.Data.bv_val = (PCHAR) ldapMalloc(
                                request->extended.Data.bv_len,
                                LDAP_EXTENDED_OP_SIGNATURE );

                if (request->extended.Data.bv_val == NULL) {

                    hr = LDAP_NO_MEMORY;

                } else {

                    CopyMemory( request->extended.Data.bv_val,
                                Data->bv_val,
                                request->extended.Data.bv_len );

                }
            }
        }
    }

    if (hr == LDAP_SUCCESS) {

        hr = SendLdapExtendedOp( request,
                                 connection,
                                 request->OriginalDN,
                                 (CLdapBer **)&request->BerMessageSent,
                                 0 );
    }

    if (hr != LDAP_SUCCESS) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "ldap_add connection 0x%x errored with 0x%x.\n",
                        connection, hr );
        }

        messageNumber = (ULONG) -1;
        SetConnectionError( connection, hr, NULL );

        CloseLdapRequest( request );
    }

    *MessageNumber = messageNumber;

    DereferenceLdapRequest( request );
    return hr;
}

ULONG
SendLdapExtendedOp (
    PLDAP_REQUEST Request,
    PLDAP_CONN Connection,
    PWCHAR Oid,
    CLdapBer **Lber,
    LONG AltMsgId
    )
{
    ULONG hr;
    struct berval   *Data = &Request->extended.Data;

    CLdapBer *lber = new CLdapBer( Connection->publicLdapStruct.ld_version );

    if (lber == NULL) {
        SetConnectionError( Connection, LDAP_NO_MEMORY, NULL );
        return LDAP_NO_MEMORY;
    }

    //
    //  The request looks like the following :
    //
    //   ExtendedRequest ::= [APPLICATION 23] SEQUENCE {
    //          requestName      [0] LDAPOID,
    //          requestValue     [1] OCTET STRING OPTIONAL }
    //

    hr = lber->HrStartWriteSequence();
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldap_extendedop startWrite conn 0x%x encoding error of 0x%x.\n",
                        Connection, hr );
        }

        goto encodingError;

    } else {            // we can't forget EndWriteSequence

       if (AltMsgId != 0) {

          hr = lber->HrAddValue((LONG) AltMsgId );

       } else {

          hr = lber->HrAddValue((LONG) Request->MessageId );
       }

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldap_extendedop MsgNo conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            goto encodingError;
        }

        hr = lber->HrStartWriteSequence(LDAP_EXTENDED_CMD);
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldap_extendedop startWrite conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }

            goto encodingError;

        } else {            // we can't forget EndWriteSequence

            hr = lber->HrAddValue((const WCHAR *) Oid, BER_CLASS_CONTEXT_SPECIFIC | 0x00 );
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_extendedop OID conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                goto encodingError;
            }

            hr = lber->HrAddBinaryValue((BYTE *) Data->bv_val,
                                                ((Data->bv_val == NULL ) ?
                                                        0 : Data->bv_len ),
                                           (BER_CLASS_CONTEXT_SPECIFIC | 0x01));
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_extendedop conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                goto encodingError;
            }

            hr = lber->HrEndWriteSequence();
            ASSERT( hr == NOERROR );
        }

        //
        //  put in the server controls here if required
        //

        if ( (Connection->publicLdapStruct.ld_version != LDAP_VERSION2) &&
             ( Request->ServerControls != NULL )) {

            hr = InsertServerControls( Request, Connection, lber );

            if (hr != LDAP_SUCCESS) {

                if (lber != NULL) {

                   delete lber;
                }
                return hr;
            }
        }

        hr = lber->HrEndWriteSequence();
        ASSERT( hr == NOERROR );
    }

    //
    //  send the extended operations request.
    //

    ACQUIRE_LOCK( &Connection->ReconnectLock );

    AddToPendingList( Request, Connection );

    hr = LdapSend( Connection, lber );

    if (hr != LDAP_SUCCESS) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "ldap_extendedop connection 0x%x send with error of 0x%x.\n",
                        Connection, hr );
        }
        DecrementPendingList( Request, Connection );

    } else {

        //
        //  Save off the lber value, free any lber message that is already
        //  present.
        //

        lber = (CLdapBer *) InterlockedExchangePointer((PVOID *) Lber,
                                                       (PVOID) lber );
    }

    RELEASE_LOCK( &Connection->ReconnectLock );

    if (lber != NULL) {

       delete lber;
    }

    return hr;

encodingError:

    if (lber != NULL) {

       delete lber;
    }

    return LDAP_ENCODING_ERROR;
}

ULONG __cdecl
ldap_extended_operationW(
        LDAP *ExternalHandle,
        PWCHAR Oid,
        struct berval   *Data,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        ULONG           *MessageNumber
        )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapExtendedOp(   connection,
                            Oid,
                            Data,
                            TRUE,
                            FALSE,
                            ServerControls,
                            ClientControls,
                            MessageNumber
                            );

    DereferenceLdapConnection( connection );

    return err;
}

ULONG __cdecl
ldap_extended_operationA (
        LDAP *ExternalHandle,
        PCHAR Oid,
        struct berval   *Data,
        PLDAPControlA   *ServerControls,
        PLDAPControlA   *ClientControls,
        ULONG           *MessageNumber
        )
{
    ULONG err;
    PWCHAR wName = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if ((connection == NULL) || (MessageNumber == NULL)) {

        err = LDAP_PARAM_ERROR;
        goto error;
    }

    *MessageNumber = (ULONG) -1;

    err = ToUnicodeWithAlloc( Oid, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, LDAP_PARAM_ERROR, NULL );
        goto error;
    }

    err = LdapExtendedOp(   connection,
                            wName,
                            Data,
                            FALSE,
                            FALSE,
                            (PLDAPControlW *) ServerControls,
                            (PLDAPControlW *) ClientControls,
                            MessageNumber
                            );

error:
    if (wName)
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    if (connection)
        DereferenceLdapConnection( connection );

    return err;
}

//
// This is a Synchronous version of ldap_extened_operation. It parses out
// the response data and OId if present and returns it to the user.
//
// It returns the server error code. However, it could also return client
// errors like LDAP_NO_MEMORY, LDAP_PARAM_ERROR etc.
//

ULONG __cdecl
ldap_extended_operation_sA (
        LDAP *ExternalHandle,
        PCHAR Oid,
        struct berval   *Data,
        PLDAPControlA   *ServerControls,
        PLDAPControlA   *ClientControls,
        PCHAR           *ReturnedOid,
        struct berval   **ReturnedData
        )
{
    ULONG err;
    PWCHAR wOid = NULL;
    PLDAP_CONN connection = NULL;
    ULONG  MessageNumber = (ULONG) -1;
    LDAPMessage   *Res = NULL;
    ULONG ServerError = LDAP_SUCCESS;


    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {

        err = LDAP_PARAM_ERROR;
        goto error;
    }

    err = ToUnicodeWithAlloc( Oid, -1, &wOid, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        goto error;
    }

    err = LdapExtendedOp(   connection,
                            wOid,
                            Data,
                            FALSE,   // ANSI controls
                            FALSE,   // Asynchronous
                            (PLDAPControlW *) ServerControls,
                            (PLDAPControlW *) ClientControls,
                            &MessageNumber
                            );

    if (err != LDAP_SUCCESS) {
        
        goto error;
    }

    ASSERT( MessageNumber != (ULONG) -1 );

    err = ldap_result_with_error(  connection,
                                   MessageNumber,
                                   LDAP_MSG_ALL,
                                   NULL,
                                   &Res,
                                   NULL
                                   );

    if (err != LDAP_SUCCESS) {
        
        goto error;
    }

    //
    // Pluck out the server returned error.
    //

    if (Res != NULL) {

        ServerError = ldap_result2error( connection->ExternalInfo,
                                         Res,
                                         FALSE
                                         );
    }


    //
    // Even if the server failed us, parse the extended response for the OID
    // and return data if any.
    //

    err = LdapParseExtendedResult( connection,
                                   Res,
                                   (PWCHAR*) ReturnedOid,
                                   ReturnedData,
                                   TRUE,       // Free the message
                                   LANG_ACP
                                   );

    //
    // Give precedence to the server return code.
    //

    if (ServerError != LDAP_SUCCESS) {

        err = ServerError;
    }


error:
    if (wOid)
        ldapFree( wOid, LDAP_UNICODE_SIGNATURE );

    if (connection)
        DereferenceLdapConnection( connection );

    return err;

}

//
// This is a Synchronous version of ldap_extened_operation. It parses out
// the response data and OId if present and returns it to the user.
//
// It returns the server error code. However, it could also return client
// errors like LDAP_NO_MEMORY, LDAP_PARAM_ERROR etc.
//

ULONG __cdecl
ldap_extended_operation_sW (
        LDAP *ExternalHandle,
        PWCHAR Oid,
        struct berval   *Data,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        PWCHAR          *ReturnedOid,
        struct berval   **ReturnedData
        )
{
    ULONG err;
    PLDAP_CONN connection = NULL;
    ULONG  MessageNumber = (ULONG) -1;
    LDAPMessage   *Res = NULL;
    ULONG ServerError = LDAP_SUCCESS;


    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {

        err = LDAP_PARAM_ERROR;
        goto error;
    }

    err = LdapExtendedOp(   connection,
                            Oid,
                            Data,
                            TRUE,    // Unicode controls
                            FALSE,   // Asynchronous
                            (PLDAPControlW *) ServerControls,
                            (PLDAPControlW *) ClientControls,
                            &MessageNumber
                            );

    if (err != LDAP_SUCCESS) {
        
        goto error;
    }

    ASSERT( MessageNumber != (ULONG) -1 );

    err = ldap_result_with_error(  connection,
                                   MessageNumber,
                                   LDAP_MSG_ALL,
                                   NULL,
                                   &Res,
                                   NULL
                                   );

    if (err != LDAP_SUCCESS) {
        
        goto error;
    }

    //
    // Pluck out the server returned error.
    //

    if (Res != NULL) {

        ServerError = ldap_result2error( connection->ExternalInfo,
                                         Res,
                                         FALSE
                                         );
    }


    //
    // Even if the server failed us, parse the extended response for the OID
    // and return data if any.
    //

    err = LdapParseExtendedResult( connection,
                                   Res,
                                   (PWCHAR*) ReturnedOid,
                                   ReturnedData,
                                   TRUE,       // Free the message
                                   LANG_ACP
                                   );

    //
    // Give precedence to the server return code.
    //

    if (ServerError != LDAP_SUCCESS) {

        err = ServerError;
    }


error:
    if (connection)
        DereferenceLdapConnection( connection );

    return err;

}


ULONG __cdecl
ldap_close_extended_op(
        LDAP    *ExternalHandle,
        ULONG   MessageNumber
        )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapAbandon( connection, MessageNumber, FALSE );

    DereferenceLdapConnection( connection );

    return err;
}

// delete.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\getset.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    getset.cxx  modify or get values from an LDAP connection block

Abstract:

   This module implements the LDAP ldap_get_opt and ldap_set_opt APIs.

Author:

    Andy Herron    (andyhe)        08-May-1996
    Anoop Anantha  (AnoopA)        24-Jun-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"


static PWCHAR SupportedExtensionList[] = {
                                L"VIRTUAL_LIST_VIEW",
                                NULL
                                };

#define NUM_SUPPORTED_EXTENSIONS  ((sizeof(SupportedExtensionList)/sizeof(PWCHAR))-1)



ULONG __cdecl ldap_get_optionW (
    LDAP *ExternalHandle,
    int option,
    void *outvalue )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    //
    // The connection itself might be in a closed state but we still need
    // to reference it. Hence, we call GetConnectionPointer2.
    //

    connection = GetConnectionPointer2(ExternalHandle);

    if (((connection == NULL) && (option != LDAP_OPT_API_INFO)) ||
         (outvalue == NULL)) {

        err = LDAP_PARAM_ERROR;
        goto error;
    }

    err = LdapGetConnectionOption( connection, option, outvalue, TRUE );

error:
    if (connection)
    {
        DereferenceLdapConnection( connection );
    }

    return err;
}

ULONG __cdecl ldap_get_option (
    LDAP *ExternalHandle,
    int option,
    void *outvalue )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    //
    // The connection itself might be in a closed state but we still need
    // to reference it. Hence, we call GetConnectionPointer2.
    //
    
    connection = GetConnectionPointer2(ExternalHandle);

    if (((connection == NULL) && (option != LDAP_OPT_API_INFO))||
         (outvalue == NULL)) {
        err = LDAP_PARAM_ERROR;
        goto error;
    }

    err = LdapGetConnectionOption( connection, option, outvalue, FALSE );

error:
    if (connection)
    {
        DereferenceLdapConnection( connection );
    }

    return err;
}


ULONG __cdecl ldap_set_optionW (
    LDAP *ExternalHandle,
    int option,
    const void *invalue )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL)
    {
        err = LDAP_PARAM_ERROR;
        goto error;
    }

    err = LdapSetConnectionOption( connection, option, invalue, TRUE );

error:
    if (connection)
    {
        DereferenceLdapConnection( connection );
    }

    return err;
}

ULONG __cdecl ldap_set_option (
    LDAP *ExternalHandle,
    int option,
    const void *invalue )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL)
    {
        err = LDAP_PARAM_ERROR;
        goto error;
    }

    err = LdapSetConnectionOption( connection, option, invalue, FALSE );

error:
    if (connection)
    {
        DereferenceLdapConnection( connection );
    }

    return err;
}

ULONG LdapGetConnectionOption (
    PLDAP_CONN connection,
    int option,
    void *outvalue,
    BOOLEAN Unicode
    )
{
    ULONG err = LDAP_SUCCESS;
    PLDAP_REFERRAL_CALLBACK refCallbacks;


    ASSERT(outvalue != NULL);

    switch (option) {

    case LDAP_OPT_DESC:     // socket descriptor

        *((SOCKET *) outvalue) = get_socket( connection );
        break;

    case LDAP_OPT_DEREF:

        *((ULONG *) outvalue) = connection->publicLdapStruct.ld_deref;
        break;

    case LDAP_OPT_SIZELIMIT:

        *((ULONG *) outvalue) = connection->publicLdapStruct.ld_sizelimit;
        break;

    case LDAP_OPT_TIMELIMIT:

        *((ULONG *) outvalue) = connection->publicLdapStruct.ld_timelimit;
        break;

    case LDAP_OPT_SEND_TIMEOUT:

        *((ULONG *) outvalue) = connection->SendDrainTimeSeconds;
        break;

    case LDAP_OPT_REFERRALS:

        if (connection->publicLdapStruct.ld_options & LDAP_OPT_CHASE_REFERRALS) {

            *((ULONG *) outvalue) = PtrToUlong(LDAP_OPT_ON);

        } else {

            *((ULONG *) outvalue) = ( connection->publicLdapStruct.ld_options &
         (LDAP_CHASE_SUBORDINATE_REFERRALS | LDAP_CHASE_EXTERNAL_REFERRALS));
        }
        break;

    case LDAP_OPT_SSL:

        *((ULONG *) outvalue) =
                PtrToUlong((connection->SecureStream) ? LDAP_OPT_ON : LDAP_OPT_OFF );
        break;

    case LDAP_OPT_VERSION:

        *((ULONG *) outvalue) = connection->publicLdapStruct.ld_version;
        break;

    case LDAP_OPT_REFERRAL_HOP_LIMIT:

        *((ULONG *) outvalue) = connection->publicLdapStruct.ld_refhoplimit;
        break;

    case LDAP_OPT_HOST_NAME:

        //
        // Existing code does NOT free the strings returned by this API. We
        // should (unfortunately) retain the same semantics.
        //

        if (Unicode) {

            if (connection->DnsSuppliedName != NULL) {

               *((PWCHAR *) outvalue) = connection->DnsSuppliedName;

            } else if (connection->ExplicitHostName != NULL) {

                *((PWCHAR *) outvalue) = connection->ExplicitHostName;

            } else {

                *((PWCHAR *) outvalue) = connection->HostNameW;
            }

        } else {

            PCHAR tempName = NULL;

            if (connection->OptHostNameA != NULL) {
                ldapFree(connection->OptHostNameA, LDAP_BUFFER_SIGNATURE);
                connection->OptHostNameA = NULL;
            }

            if (connection->DnsSuppliedName != NULL) {

               err = FromUnicodeWithAlloc( connection->DnsSuppliedName, &tempName, LDAP_BUFFER_SIGNATURE, LANG_ACP );

            } else if (connection->ExplicitHostName != NULL) {

               err = FromUnicodeWithAlloc( connection->ExplicitHostName, &tempName, LDAP_BUFFER_SIGNATURE, LANG_ACP );

            } else {

               err = FromUnicodeWithAlloc( connection->HostNameW, &tempName, LDAP_BUFFER_SIGNATURE, LANG_ACP );
            }

            *((PCHAR *) outvalue) = tempName;
            connection->OptHostNameA = tempName;
        }

        break;

    case LDAP_OPT_DNSDOMAIN_NAME:

        if (Unicode) {
            
            *((PWCHAR *) outvalue) = ldap_dup_stringW(connection->DomainName,
                                                      0,
                                                      LDAP_BUFFER_SIGNATURE
                                                      );

        } else {

            PCHAR tempName = NULL;

            err = FromUnicodeWithAlloc( connection->DomainName, &tempName, LDAP_BUFFER_SIGNATURE, LANG_ACP );

            *((PCHAR *) outvalue) = tempName;
        }

        break;

    case LDAP_OPT_ERROR_NUMBER:

        *((ULONG *) outvalue) = connection->publicLdapStruct.ld_errno;
        break;

    case LDAP_OPT_SSPI_FLAGS:

        *((ULONG *) outvalue) = connection->NegotiateFlags;
        break;

    case LDAP_OPT_PROMPT_CREDENTIALS:

        *((ULONG *) outvalue) = PtrToUlong( connection->PromptForCredentials ?
                                            LDAP_OPT_ON : LDAP_OPT_OFF );
        break;

    case LDAP_OPT_ERROR_STRING:

        if (Unicode) {

            *((PWCHAR *) outvalue) = (PWCHAR) ldap_err2stringW( connection->publicLdapStruct.ld_errno );

        } else {

            *((PCHAR *) outvalue) = (PCHAR) connection->publicLdapStruct.ld_error;
        }
        break;

    case LDAP_OPT_SERVER_ERROR:

       if (Unicode) {

          *((PWCHAR *) outvalue) = (PWCHAR) GetErrorMessage( connection, TRUE );

       } else {

          *((PCHAR *) outvalue) = (PCHAR) GetErrorMessage( connection, FALSE );

       }
       break;

    case LDAP_OPT_SERVER_EXT_ERROR: {

       PCHAR errorString;
       DWORD errRet = 0;
       DWORD i;

       err = LDAP_UNAVAILABLE;
       errorString = (PCHAR) GetErrorMessage( connection, FALSE );

       //
       // ok, we got something. Make sure it is at least 8 bytes long and the
       // first 8 bytes are hexadecimals.  If the first 8 bytes are not hexadecimal,
       // it is not formatted correctly. We cannot assume validity in this case.
       //

       if (errorString != NULL) {

           if ( strlen(errorString) >=  8 ) {

               for (i=0; i < 8; i++ ) {

                  errRet <<= 4;

                  if ( (errorString[i] >= '0') && (errorString[i] <= '9') ) {

                      errRet |= (errorString[i] - '0');
                  } else if ( (errorString[i] >= 'a') && (errorString[i] <= 'f') ) {

                      errRet |= (errorString[i] - 'a' + 10);
                  } else if ( (errorString[i] >= 'A') && (errorString[i] <= 'F') ) {

                      errRet |= (errorString[i] - 'A' + 10);
                  } else {
                      break;
                  }
               }

               if ( i == 8 ) {
                  err = LDAP_SUCCESS;
               } else {
                   errRet = 0;
               }
           }
           ldap_memfree(errorString);
       }

       *((ULONG *) outvalue) = errRet;
       break;
    }

    case LDAP_OPT_REFERRAL_CALLBACK:

        refCallbacks = (PLDAP_REFERRAL_CALLBACK) outvalue;

        if (refCallbacks->SizeOfCallbacks == sizeof(LDAP_REFERRAL_CALLBACK)) {

            refCallbacks->NotifyRoutine = connection->ReferralNotifyRoutine;
            refCallbacks->QueryForConnection = connection->ReferralQueryRoutine;
            refCallbacks->DereferenceRoutine = connection->DereferenceNotifyRoutine;

        } else {

            err = LDAP_PARAM_ERROR;
        }

        break;

    case LDAP_OPT_CLIENT_CERTIFICATE:

       *((QUERYCLIENTCERT **) outvalue) = connection->ClientCertRoutine;

       break;

    case LDAP_OPT_SERVER_CERTIFICATE:

       *((VERIFYSERVERCERT **) outvalue) = connection->ServerCertRoutine;

       break;


    case LDAP_OPT_GETDSNAME_FLAGS:

        *((ULONG *) outvalue) = connection->GetDCFlags;
        break;

    case LDAP_OPT_HOST_REACHABLE:

        err = PtrToUlong(LDAP_OPT_ON);

        if (connection->ServerDown == TRUE) {

            err = PtrToUlong(LDAP_OPT_OFF);

        } else {

            ULONGLONG tickCount = LdapGetTickCount();

            if (tickCount > connection->TimeOfLastReceive) {

                tickCount -= connection->TimeOfLastReceive;

                if (tickCount >= connection->KeepAliveSecondCount * 1000) {

                    //
                    //  if we would have to send a ping, then we return
                    //  ldap_opt_off, otherwise if the connection is up,
                    //  we return ok (LDAP_OPT_ON).
                    //

                    err = PtrToUlong(LDAP_OPT_OFF);
                }
            }
        }

        *((ULONG *) outvalue) = err;
        err = LDAP_SUCCESS;
        break;

    case LDAP_OPT_THREAD_FN_PTRS:
    case LDAP_OPT_REBIND_FN:
    case LDAP_OPT_REBIND_ARG:
    case LDAP_OPT_RESTART:
    case LDAP_OPT_IO_FN_PTRS:
    case LDAP_OPT_CACHE_FN_PTRS:
    case LDAP_OPT_CACHE_STRATEGY:
    case LDAP_OPT_CACHE_ENABLE:

        err = LDAP_LOCAL_ERROR;
        break;

    case LDAP_OPT_PING_KEEP_ALIVE:

        *((ULONG *) outvalue) = connection->KeepAliveSecondCount;
        break;

    case LDAP_OPT_PING_WAIT_TIME:

        *((ULONG *) outvalue) = connection->PingWaitTimeInMilliseconds;
        break;

    case LDAP_OPT_PING_LIMIT:

        *((ULONG *) outvalue) = connection->PingLimit;
        break;

    case LDAP_OPT_SSL_INFO:

       PSECURESTREAM pSecureStream;

       pSecureStream = (PSECURESTREAM) connection->SecureStream;

       if ((pSecureStream == NULL) ||
           ((connection->HostConnectState != HostConnectStateConnected))) {
           
           //
           // If SSL/TLS is not on, report it
           //
           
           err = LDAP_UNAVAILABLE;
           break;
       }

       err = pSecureStream->GetSSLAttributes( (PSecPkgContext_ConnectionInfo) outvalue );
       err = LdapConvertSecurityError( connection, err );
       break;

    case LDAP_OPT_REF_DEREF_CONN_PER_MSG:

        *((ULONG *) outvalue) =
                PtrToUlong((connection->ReferenceConnectionsPerMessage) ? LDAP_OPT_ON : LDAP_OPT_OFF );
        break;

    case LDAP_OPT_SIGN:

       // We want to return TRUE if the user requested signing, but has not yet bound, to preserve semantics
       // (otherwise, you could call ldap_set_option to turn on signing, then immediately call ldap_get_option and
       // it would indicate signing was off, a strange situation).  We also want to return TRUE if signing is
       // on even though the user didn't ask for it (as a result of group policy).  This does create one issue, though:
       // if the connection is currently signed, and you use ldap_set_option to turn off signing, ldap_get_option
       // will still indicate signing is on until you re-bind because it indicates the current (not future) status.
       // Since the ability to turn off signing is a new feature, though, it shouldn't be too big of an issue.
       *((ULONG *) outvalue) =
               PtrToUlong(((connection->UserSignDataChoice)||(connection->CurrentSignStatus)) ? LDAP_OPT_ON : LDAP_OPT_OFF );
       break;

    case LDAP_OPT_ENCRYPT:
       // see comments about signing above
       *((ULONG *) outvalue) =
               PtrToUlong(((connection->UserSealDataChoice)||(connection->CurrentSealStatus)) ? LDAP_OPT_ON : LDAP_OPT_OFF );
       break;

    case LDAP_OPT_SASL_METHOD:

       if (Unicode) {

           *((PWCHAR *) outvalue) = ldap_dup_stringW(connection->SaslMethod,
                                                     0,
                                                     LDAP_BUFFER_SIGNATURE
                                                     );

       } else {

           PCHAR temp = NULL;

           err = FromUnicodeWithAlloc(connection->SaslMethod,
                                      &temp,
                                      LDAP_BUFFER_SIGNATURE,
                                      LANG_ACP
                                      );

           *((PCHAR *) outvalue) = temp;

       }

       break;

    case LDAP_OPT_AREC_EXCLUSIVE:
        
        *((ULONG *) outvalue) =
                PtrToUlong((connection->AREC_Exclusive) ? LDAP_OPT_ON : LDAP_OPT_OFF );
        break;

    case LDAP_OPT_AUTO_RECONNECT:
        
        *((ULONG *) outvalue) =
                PtrToUlong((connection->UserAutoRecChoice) ? LDAP_OPT_ON : LDAP_OPT_OFF );
        break;

    case LDAP_OPT_FAST_CONCURRENT_BIND:
        
        *((ULONG *) outvalue) =
                PtrToUlong((connection->ConcurrentBind) ? LDAP_OPT_ON : LDAP_OPT_OFF );
        break;

    case LDAP_OPT_SECURITY_CONTEXT:
    
       if (!connection->BindPerformed) {

          err = LDAP_UNWILLING_TO_PERFORM;
          break;
       }
       ((PCtxtHandle) outvalue)->dwLower = connection->SecurityContext.dwLower;
       ((PCtxtHandle) outvalue)->dwUpper = connection->SecurityContext.dwUpper;
       break;

    case LDAP_OPT_API_INFO:
        
        LDAPAPIInfoW *pLdapApiInfo;
         
        pLdapApiInfo = (LDAPAPIInfoW *) outvalue;

        if ( pLdapApiInfo->ldapai_info_version != LDAP_API_INFO_VERSION ) {
            pLdapApiInfo->ldapai_info_version = LDAP_API_INFO_VERSION;
            err = LDAP_UNWILLING_TO_PERFORM;
            break;
        }

        pLdapApiInfo->ldapai_api_version = LDAP_API_VERSION;
        pLdapApiInfo->ldapai_protocol_version = LDAP_VERSION3;
        pLdapApiInfo->ldapai_vendor_version = LdapGetModuleBuildNum();
        
        if (Unicode) {
        
            pLdapApiInfo->ldapai_vendor_name = ldap_dup_stringW( LDAP_VENDOR_NAME_W,
                                                                 0,
                                                                 LDAP_VALUE_SIGNATURE ); 
        } else {

            pLdapApiInfo->ldapai_vendor_name = (PWCHAR) ldap_dup_string( LDAP_VENDOR_NAME,
                                                                         0,
                                                                         LDAP_VALUE_SIGNATURE ); 
        }

        PWCHAR *Array_To_Return;
        ULONG  numberofentries;
        ULONG  i;

        Array_To_Return = NULL;
        numberofentries = 0;

        for (i=0; i < NUM_SUPPORTED_EXTENSIONS; i++) {

            err = add_string_to_list( &Array_To_Return,
                                      &numberofentries,
                                      SupportedExtensionList[i],
                                      TRUE
                                      );

            if (err == 0) {
                Array_To_Return = NULL;
                err = LDAP_NO_MEMORY;
                break;
            }
        }

        pLdapApiInfo->ldapai_extensions = Array_To_Return;

        if (!Unicode) {

            //
            // Convert the list of unicode strings to ANSI... what a pain
            //
            
            PWCHAR *ExtNames = pLdapApiInfo->ldapai_extensions;
            PCHAR *ansiNames = (PCHAR *) ExtNames;
            PCHAR explodedName;
            
            if (ansiNames != NULL) {
        
                while (*ExtNames != NULL) {
                    
                    explodedName = NULL;
            
                    err = FromUnicodeWithAlloc( *ExtNames, &explodedName, LDAP_VALUE_SIGNATURE, LANG_ACP );
            
                    if (err != LDAP_SUCCESS) {
            
                        ldap_value_free( ansiNames );
                        err = LDAP_NO_MEMORY;
                        break;
                    }
            
                    ldapFree( *ExtNames, LDAP_VALUE_SIGNATURE );
                    *((PCHAR *) ExtNames) = explodedName;
                    ExtNames++;        // on to next entry in array
                }
            }

            pLdapApiInfo->ldapai_extensions = (PWCHAR*) ansiNames;
        }

        break;

    case LDAP_OPT_API_FEATURE_INFO:

        LDAPAPIFeatureInfoW *pLdapApiFeatureInfo;
         
        pLdapApiFeatureInfo = (LDAPAPIFeatureInfoW *) outvalue;

        if ( pLdapApiFeatureInfo->ldapaif_info_version != LDAP_FEATURE_INFO_VERSION ) {
            pLdapApiFeatureInfo->ldapaif_info_version = LDAP_FEATURE_INFO_VERSION;
            err = LDAP_UNWILLING_TO_PERFORM;
            break;
        }

        //
        // Match the name of the requested extension against our
        // SupportedExtensionList. For the time being, since we support just one
        // extension, we will fudge the value.
        //

        pLdapApiFeatureInfo->ldapaif_version = LDAP_API_FEATURE_VIRTUAL_LIST_VIEW;

        break;
    
    case LDAP_OPT_ROOTDSE_CACHE:
        *((ULONG *) outvalue) =
                PtrToUlong( DisableRootDSECache ? LDAP_OPT_OFF : LDAP_OPT_ON );
        break;

    case LDAP_OPT_TCP_KEEPALIVE:
        *((ULONG *) outvalue) =
                PtrToUlong( connection->UseTCPKeepAlives ? LDAP_OPT_ON : LDAP_OPT_OFF );
        break;

    default:

        err = LDAP_PARAM_ERROR;
    }

    return err;
}


ULONG LdapSetConnectionOption (
    PLDAP_CONN connection,
    int option,
    const void *invalue,
    BOOLEAN Unicode
    )
{
    ULONG err = LDAP_SUCCESS;
    ULONG value;
    PLDAP_REFERRAL_CALLBACK refCallbacks;

    ASSERT(connection != NULL);

    switch (option) {
    case LDAP_OPT_DEREF:

        value = RealValue(invalue);

        if ((value != LDAP_DEREF_NEVER) &&
            (value != LDAP_DEREF_SEARCHING) &&
            (value != LDAP_DEREF_FINDING) &&
            (value != LDAP_DEREF_ALWAYS)) {

            err = LDAP_PARAM_ERROR;

        } else {

            connection->publicLdapStruct.ld_deref = value;
        }
        break;

    case LDAP_OPT_SIZELIMIT:

        connection->publicLdapStruct.ld_sizelimit = *((ULONG *) invalue);
        break;

    case LDAP_OPT_TIMELIMIT:

        connection->publicLdapStruct.ld_timelimit = *((ULONG *) invalue);
        break;

    case LDAP_OPT_SEND_TIMEOUT:
        connection->SendDrainTimeSeconds = *((ULONG *) invalue);
        break;

    case LDAP_OPT_SSPI_FLAGS:

        connection->NegotiateFlags = *((ULONG *) invalue);

        if (connection->NegotiateFlags & (ISC_REQ_INTEGRITY | ISC_REQ_SEQUENCE_DETECT)) {
            connection->UserSignDataChoice = TRUE;
        }
        else {
            connection->UserSignDataChoice = FALSE;
        }

        if (connection->NegotiateFlags & ISC_REQ_CONFIDENTIALITY) {
            connection->UserSealDataChoice = TRUE;
        }
        else {
            connection->UserSealDataChoice = FALSE;
        }  

        if (connection->NegotiateFlags & ISC_REQ_MUTUAL_AUTH) {
            connection->UserMutualAuthChoice = TRUE;
        }
        else {
            connection->UserMutualAuthChoice = FALSE;
        }

        break;

    case LDAP_OPT_REFERRALS:

        value = RealValue(invalue);

        if (value == PtrToUlong(LDAP_OPT_ON)) {

            connection->publicLdapStruct.ld_options |= LDAP_OPT_CHASE_REFERRALS;
            connection->publicLdapStruct.ld_options |= LDAP_CHASE_SUBORDINATE_REFERRALS;
            connection->publicLdapStruct.ld_options |= LDAP_CHASE_EXTERNAL_REFERRALS;

        } else if (value == PtrToUlong(LDAP_OPT_OFF)) {

            connection->publicLdapStruct.ld_options &= ~LDAP_OPT_CHASE_REFERRALS;
            connection->publicLdapStruct.ld_options &= ~LDAP_CHASE_SUBORDINATE_REFERRALS;
            connection->publicLdapStruct.ld_options &= ~LDAP_CHASE_EXTERNAL_REFERRALS;

        } else if ((value & (LDAP_CHASE_SUBORDINATE_REFERRALS |
                             LDAP_CHASE_EXTERNAL_REFERRALS)) != value) {

            err = LDAP_PARAM_ERROR;

        } else {

            connection->publicLdapStruct.ld_options &= ~LDAP_OPT_CHASE_REFERRALS;
            connection->publicLdapStruct.ld_options &= ~LDAP_CHASE_SUBORDINATE_REFERRALS;
            connection->publicLdapStruct.ld_options &= ~LDAP_CHASE_EXTERNAL_REFERRALS;
            connection->publicLdapStruct.ld_options |= ( value & LDAP_CHASE_SUBORDINATE_REFERRALS );
            connection->publicLdapStruct.ld_options |= ( value & LDAP_CHASE_EXTERNAL_REFERRALS );
        }
        break;

    case LDAP_OPT_PROMPT_CREDENTIALS:

        value = RealValue(invalue);

        if (value == PtrToUlong(LDAP_OPT_ON)) {

            connection->PromptForCredentials = TRUE;

        } else if (value == PtrToUlong(LDAP_OPT_OFF)) {

            connection->PromptForCredentials = FALSE;

        } else {

            err = LDAP_PARAM_ERROR;
        }
        break;

    case LDAP_OPT_SSL:

        value = RealValue(invalue);

        if (value == PtrToUlong(LDAP_OPT_ON)) {

            if (connection->SslPort == FALSE) {

                if (connection->BindPerformed) {

                    err = LDAP_UNWILLING_TO_PERFORM;
                    break;
                }

                if ( connection->HostConnectState == HostConnectStateUnconnected ) {

                    err = SEC_E_OK;

                } else {

                    err = LdapSetupSslSession( connection );
                }

                if (err == SEC_E_OK) {

                    connection->SslPort = TRUE;

                } else {

                    err = LDAP_LOCAL_ERROR;
                    break;
                }

            } else {

                err = LDAP_SUCCESS;
            }

        } else if (value == PtrToUlong(LDAP_OPT_OFF)) {

            //
            //  we don't allow clients to disable ssl once the connection has
            //  been setup.
            //

            if ( connection->HostConnectState == HostConnectStateUnconnected ) {

                connection->SslPort = FALSE;

            } else if ((connection->SslPort == TRUE) ||
                       (connection->SslSetupInProgress == TRUE) ||
                       (connection->SecureStream != NULL)) {

                err = LDAP_UNWILLING_TO_PERFORM;
                break;
            }

            err = LDAP_SUCCESS;

        } else {

            err = LDAP_PARAM_ERROR;
        }
        break;

    case LDAP_OPT_VERSION:

        value = RealValue(invalue);

        if ((value != LDAP_VERSION2) &&
            (value != LDAP_VERSION3)) {

            err = LDAP_LOCAL_ERROR;

        } else {

            connection->publicLdapStruct.ld_version = value;
        }
        break;

    case LDAP_OPT_REFERRAL_HOP_LIMIT:

        value = *((ULONG *) invalue);

        connection->publicLdapStruct.ld_refhoplimit = value;
        break;

    case LDAP_OPT_ERROR_NUMBER:     // what the heck... let them change it.

        connection->publicLdapStruct.ld_errno = *((ULONG *) invalue);
        break;

    case LDAP_OPT_REFERRAL_CALLBACK:

        refCallbacks = (PLDAP_REFERRAL_CALLBACK) invalue;

        if (refCallbacks->SizeOfCallbacks == sizeof(LDAP_REFERRAL_CALLBACK)) {

            connection->ReferralNotifyRoutine = refCallbacks->NotifyRoutine;
            connection->ReferralQueryRoutine = refCallbacks->QueryForConnection;
            connection->DereferenceNotifyRoutine = refCallbacks->DereferenceRoutine;

        } else {

            err = LDAP_PARAM_ERROR;
        }
        break;

    case LDAP_OPT_CLIENT_CERTIFICATE:

       connection->ClientCertRoutine = (QUERYCLIENTCERT *)invalue;
       break;

    case LDAP_OPT_SERVER_CERTIFICATE:

       connection->ServerCertRoutine = (VERIFYSERVERCERT *)invalue;
       break;

    case LDAP_OPT_GETDSNAME_FLAGS:

        value = *((ULONG *) invalue);
        connection->GetDCFlags = value;
        break;

    case LDAP_OPT_HOST_NAME:

        if (connection->HostConnectState != HostConnectStateUnconnected) {

            err = LDAP_UNWILLING_TO_PERFORM;
            break;
        }

        PCHAR newHostName;

        newHostName = *((PCHAR *) invalue);

        if (newHostName == NULL) {
            break;
        }

        if (!Unicode) {

            err = ToUnicodeWithAlloc( newHostName, -1, &connection->ExplicitHostName, LDAP_HOST_NAME_SIGNATURE, LANG_ACP);

            break;

        } else {

            connection->ExplicitHostName = ldap_dup_stringW( (PWCHAR) newHostName,
                                                              0,
                                                              LDAP_HOST_NAME_SIGNATURE );

            if (connection->ExplicitHostName == NULL) {
                err = LDAP_NO_MEMORY;
            }
        }

        break;

    case LDAP_OPT_SIGN:

       value = RealValue(invalue);

       if (value == PtrToUlong(LDAP_OPT_ON)) {

          if (connection->SslPort) {

             err = LDAP_UNWILLING_TO_PERFORM;
             break;
          }

          connection->NegotiateFlags |= (ISC_REQ_INTEGRITY | ISC_REQ_SEQUENCE_DETECT);
          connection->UserSignDataChoice = TRUE;
       }
       else if (value == PtrToUlong(LDAP_OPT_OFF)) {

          connection->NegotiateFlags &= ~(ISC_REQ_INTEGRITY | ISC_REQ_SEQUENCE_DETECT);
          connection->UserSignDataChoice = FALSE;
       }
       else {
       
          err = LDAP_PARAM_ERROR;
       }
        
           
       break;

    case LDAP_OPT_ENCRYPT:

       value = RealValue(invalue);

       if (value == PtrToUlong(LDAP_OPT_ON)) {

           if (connection->SslPort) {

             err = LDAP_UNWILLING_TO_PERFORM;
             break;
           }

           connection->NegotiateFlags |= ISC_REQ_CONFIDENTIALITY;
           connection->UserSealDataChoice = TRUE;

       }
       else if (value == PtrToUlong(LDAP_OPT_OFF)) {

          connection->NegotiateFlags &= ~(ISC_REQ_CONFIDENTIALITY);
          connection->UserSealDataChoice = FALSE;
          
       }
       else {
       
          err = LDAP_PARAM_ERROR;
       }

       break;

    case LDAP_OPT_DNSDOMAIN_NAME:

        PWCHAR DomainName;

        if (connection->BindInProgress) {

            err = LDAP_UNWILLING_TO_PERFORM;
            break;
        }

        DomainName = *((PWCHAR *) invalue);

        if (connection->DomainName != NULL) {
            ldapFree( connection->DomainName, LDAP_HOST_NAME_SIGNATURE );
            connection->DomainName = NULL;
        }
        
        if (DomainName == NULL) {
            //
            // Nothing else to do
            //
            break;
        }

        //
        // Make a copy of the string
        //

        if (Unicode) {

            connection->DomainName = ldap_dup_stringW( DomainName, 0, LDAP_HOST_NAME_SIGNATURE );

            if (connection->DomainName == NULL) {
                err = LDAP_NO_MEMORY;
            }

        } else {

            err = ToUnicodeWithAlloc( (PCHAR) DomainName,
                                       -1,
                                       &connection->DomainName,
                                       LDAP_HOST_NAME_SIGNATURE,
                                       LANG_ACP );
        }

        break;
    
    
    case LDAP_OPT_DESC:     // socket descriptor
    case LDAP_OPT_ERROR_STRING:
    case LDAP_OPT_SECURITY_CONTEXT:

        err = LDAP_UNWILLING_TO_PERFORM;
        break;

    case LDAP_OPT_THREAD_FN_PTRS:
    case LDAP_OPT_REBIND_FN:
    case LDAP_OPT_REBIND_ARG:
    case LDAP_OPT_RESTART:
    case LDAP_OPT_IO_FN_PTRS:
    case LDAP_OPT_CACHE_FN_PTRS:
    case LDAP_OPT_CACHE_STRATEGY:
    case LDAP_OPT_CACHE_ENABLE:

        err = LDAP_LOCAL_ERROR;
        break;

    case LDAP_OPT_PING_KEEP_ALIVE:

        value = *((ULONG *) invalue);

        if ((value != 0) &&
            ((value < LDAP_PING_KEEP_ALIVE_MIN) ||
             (value > LDAP_PING_KEEP_ALIVE_MAX)))  {

            err = LDAP_PARAM_ERROR;

        } else {

            connection->KeepAliveSecondCount = value;
        }
        break;

    case LDAP_OPT_PING_WAIT_TIME:

        value = *((ULONG *) invalue);

        if ((value != 0) &&
            ((value < LDAP_PING_WAIT_TIME_MIN) ||
             (value > LDAP_PING_WAIT_TIME_MAX)))  {

            err = LDAP_PARAM_ERROR;

        } else {

            connection->PingWaitTimeInMilliseconds = value;
        }
        break;

    case LDAP_OPT_PING_LIMIT:

        value = *((ULONG *) invalue);

        if ((value != 0) &&
            ((value < LDAP_PING_LIMIT_MIN) ||
             (value > LDAP_PING_LIMIT_MAX)))  {

            err = LDAP_PARAM_ERROR;

        } else {

            connection->PingLimit = LOWORD(value);
        }
        break;

    case LDAP_OPT_REF_DEREF_CONN_PER_MSG:

        value = RealValue(invalue);

        if (value == PtrToUlong(LDAP_OPT_ON)) {

            connection->ReferenceConnectionsPerMessage = TRUE;

        } else if (value == PtrToUlong(LDAP_OPT_OFF)) {

            connection->ReferenceConnectionsPerMessage = FALSE;

        } else {

            err = LDAP_PARAM_ERROR;
        }
        break;

    case LDAP_OPT_SASL_METHOD:

        PWCHAR SaslMethod;

        if (connection->BindInProgress) {

            err = LDAP_UNWILLING_TO_PERFORM;
            break;
        }

        SaslMethod = *((PWCHAR *) invalue);

        if (SaslMethod == NULL) {
            err = LDAP_PARAM_ERROR;
            break;
        }

        //
        // Make a copy of the string
        //

        if (Unicode) {

            SaslMethod = ldap_dup_stringW(SaslMethod, 0, LDAP_SASL_SIGNATURE);

        } else {

            err = ToUnicodeWithAlloc( (PCHAR) SaslMethod, -1, &SaslMethod,LDAP_SASL_SIGNATURE, LANG_ACP );
        }

        if (pSaslGetProfilePackageW) {

            err = (*pSaslGetProfilePackageW)( SaslMethod,
                                             &connection->PreferredSecurityPackage
                                            );

            IF_DEBUG(BIND) {
                LdapPrint1("SaslGetProfilePackageA returned 0x%x\n", err);
            }

            err = LdapConvertSecurityError( connection, err );

            if (err == LDAP_SUCCESS) {

                ldapFree( connection->SaslMethod, LDAP_SASL_SIGNATURE );
                connection->SaslMethod = SaslMethod;
            } else {
                ldapFree( SaslMethod, LDAP_SASL_SIGNATURE );
            }

        } else {

            err = LDAP_LOCAL_ERROR;
        }

        break;

    case LDAP_OPT_AREC_EXCLUSIVE:
        
        value = RealValue(invalue);

        if (value == PtrToUlong(LDAP_OPT_ON)) {

            connection->AREC_Exclusive = TRUE;

        } else if (value == PtrToUlong(LDAP_OPT_OFF)) {

            connection->AREC_Exclusive = FALSE;

        } else {

            err = LDAP_PARAM_ERROR;
        }
        break;

	case LDAP_OPT_FAST_CONCURRENT_BIND:

        value = RealValue(invalue);

        if (value == PtrToUlong(LDAP_OPT_ON)) {

            ACQUIRE_LOCK( &connection->StateLock);

            if (connection->BindPerformed ||
                connection->BindInProgress) {

                // Must start with a unbound connection
                err = LDAP_UNWILLING_TO_PERFORM;
                RELEASE_LOCK( &connection->StateLock);
                break;
            }

            connection->ConcurrentBind = TRUE;

            RELEASE_LOCK( &connection->StateLock);

            // put server into fast concurrent bind mode
            err = ldap_extended_operation_sW(
                            connection->ExternalInfo,
                            LDAP_SERVER_FAST_BIND_OID_W,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL);

            if (err != LDAP_SUCCESS) {
                ACQUIRE_LOCK( &connection->StateLock);
                connection->ConcurrentBind = FALSE;
                RELEASE_LOCK( &connection->StateLock);
                break;
            }

            // turn off referral chasing
            err = LdapSetConnectionOption(connection, LDAP_OPT_REFERRALS, LDAP_OPT_OFF, Unicode);
            ASSERT(err == LDAP_SUCCESS);
        }
        else {
            err = LDAP_PARAM_ERROR;
        }
        break;
    
    case LDAP_OPT_AUTO_RECONNECT:

        value = RealValue(invalue);

        if (value == PtrToUlong(LDAP_OPT_ON)) {

            connection->AutoReconnect = TRUE;
            connection->UserAutoRecChoice = TRUE;

        } else if (value == PtrToUlong(LDAP_OPT_OFF)) {

            connection->AutoReconnect = FALSE;
            connection->UserAutoRecChoice = FALSE;

        } else {

            err = LDAP_PARAM_ERROR;
        }
        break;

    case LDAP_OPT_ROOTDSE_CACHE:
        
        value = RealValue(invalue);

        if (value == PtrToUlong(LDAP_OPT_ON)) {

            DisableRootDSECache = FALSE;

        } else if (value == PtrToUlong(LDAP_OPT_OFF)) {

            DisableRootDSECache = TRUE;

        } else {

            err = LDAP_PARAM_ERROR;
        }
        
        break;


    case LDAP_OPT_TCP_KEEPALIVE:
    
        value = RealValue(invalue);

        if (value == PtrToUlong(LDAP_OPT_ON)) {

            connection->UseTCPKeepAlives = TRUE;

        } else if (value == PtrToUlong(LDAP_OPT_OFF)) {

            connection->UseTCPKeepAlives = FALSE;

        } else {

            err = LDAP_PARAM_ERROR;
        }
        
        break;
        
    default:

        err = LDAP_PARAM_ERROR;
    }

    return err;
}

// getset.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\ldapp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ldapp.h   LDAP client 32 API header file... internal structures

Abstract:

   This module is the header file for the 32 bit LDAP client API code...
   it contains all interal data structures.

Author:

    Andy Herron    (andyhe)        08-May-1996
    Anoop Anantha  (AnoopA)        24-Jun-1998

Revision History:

--*/


#ifndef LDAP_CLIENT_INTERNAL_DEFINED
#define LDAP_CLIENT_INTERNAL_DEFINED

#define LDAP_DEFAULT_LOCALE LOCALE_USER_DEFAULT

#define PLDAPDN PWCHAR

typedef struct ldap_memory_descriptor {

    ULONG Tag;
    DWORD Length;

} LDAP_MEMORY_DESCRIPTOR, *PLDAP_MEMORY_DESCRIPTOR;


// the following signature is "Lsec"

#define LDAP_SECURITY_SIGNATURE 0x6365734c

#define GENERIC_SECURITY_SIZE 1024

//
// State of the connection object
// Closed objects are kept alive till their ref count drops to zero.
// Ref count of a non-active object should never be incremented - it
// should be treated as dead as far as new users are concerned.
//

#define ConnObjectActive          1
#define ConnObjectClosing         2
#define ConnObjectClosed          3

//
// State of the connection inside the connection object
// These are valid only if the connection object is active
//

#define HostConnectStateUnconnected     0x01
#define HostConnectStateConnecting      0x02
#define HostConnectStateReconnecting    0x04
#define HostConnectStateConnected       0x08
#define HostConnectStateError           0x10

#define DEFAULT_NEGOTIATE_FLAGS (ISC_REQ_MUTUAL_AUTH | ISC_RET_EXTENDED_ERROR)

//
//  The LDAP_CONNECTION block is one of the principal data structure for
//  this library.  It tracks the following :
//
//   - destination server info (name, address, credentials, etc)
//   - outstanding receives from this server
//   - completed receives from this server
//   - stats and other per connection info
//
//  It contains within it the non-opaque structure exposed through the API
//  that is compatible with the reference implementation not only at the
//  source level but also at the obj level.  ( That is, the fields such as
//  sb_naddr that are exposed in the reference implementation correspond in
//  offset to the friendlier names in this structure at the same offset.  In
//  the case of sb_naddr, it corresponds to UdpHandle. )
//
//  All important fields that we don't want theoritically trashed by the client
//  (since it's not clear what fields apps will use in the reference
//  implementation) are in front of the external structure in the larger
//  overall structure.  That is, we only pass back a pointer to TcpHandle and
//  below and everything above should never be touched by the client).
//
//
//  This MUST match the ldap structure in WINLDAP.H!  We just have it here
//  so that we can use friendly names and hide opaque fields.
//

#if !defined(_WIN64)
#pragma pack(push, 4)
#endif

typedef struct ldap_connection {

    LONG    ReferenceCount;         // for lifetime management

    LIST_ENTRY ConnectionListEntry;
    LIST_ENTRY PendingCryptoList;
    LIST_ENTRY CompletedReceiveList;

    PLDAPMessage PendingMessage;    // pointer to LDAP message structure
                                    // that we're currently receiving.  This
                                    // is used for receiving a message that
                                    // spans multiple packets.

    ULONG   MaxReceivePacket;
    ULONG   HandlesGivenToCaller;   // number of times we've given handle
                                    // to caller
    ULONG   HandlesGivenAsReferrals; // protected by ConnectionListLock.

    PLDAPDN DNOnBind;               // user name specified in bind
    LDAP_LOCK ScramblingLock;       // protects access to the credentials.
    PWCHAR  CurrentCredentials;     // user credentials specified on bind
    UNICODE_STRING ScrambledCredentials; // contains the password part of CurrentCredentials
    BOOLEAN Scrambled;              // are the credentials scrambled ?
    ULONG   BindMethod;             // method specified on bind
    HANDLE  ConnectEvent;           // handle to wait on for during connect

    LUID    CurrentLogonId;
    CredHandle hCredentials;        // credential handle from SSPI
    BOOLEAN UserSignDataChoice;     // user's choice of whether to sign data
    BOOLEAN UserSealDataChoice;     // user's choice of whether to seal data
    BOOLEAN CurrentSignStatus;      // whether signing or sealing are CURRENTLY
    BOOLEAN CurrentSealStatus;      //   being used on this connection
    BOOLEAN WhistlerServer;          // is server at least Whister?
    BOOLEAN SupportsGSSAPI;         // server advertises that it supports GSSAPI
    BOOLEAN SupportsGSS_SPNEGO;     // server advertises that it supports GSS-SPNEGO
    BOOLEAN SupportsDIGEST;          // server advertises that it supports DIGEST-MD5
    ULONG   HighestSupportedLdapVersion;  // server advertised LDAP version.
    TimeStamp  CredentialExpiry;    // local time credential expires.
    CtxtHandle SecurityContext;

    struct sockaddr_in SocketAddress;

    PWCHAR   ListOfHosts;            // pointer to list of hosts.
    BOOLEAN  ProcessedListOfHosts;   // whether ListOfHosts has been processed into NULL-sep list
    BOOLEAN  DefaultServer;          // whether user requested we find default server/domain (passed in NULL init/open)
    BOOLEAN  AREC_Exclusive;         // the given host string is not a domain name.
    BOOLEAN  ForceHostBasedSPN;      // force use of LdapMakeServiceNameFromHostName to generate SPN
    PWCHAR   ServiceNameForBind;     // service name for kerberos bind
    PWCHAR   ExplicitHostName;       // host name given to us by caller
    PWCHAR   DnsSuppliedName;        // host name supplied by DNS
    PWCHAR   DomainName;             // Domain name returned from DsGetDcName
    PWCHAR   HostNameW;              // Unicode version of LDAP_CONN.HostName
    PCHAR    OptHostNameA;           // Placeholder for the ANSI value returned from LDAP_OPT_HOSTNAME
                                     // which we need to free during ldap_unbind

    PLDAP    ExternalInfo;           // points to lower portion of this structure
    ULONG    GetDCFlags;             // flags ORed in on DsGetDCName
    ULONG    NegotiateFlags;         // Flags for Negotiate SSPI provider.
    BOOLEAN  UserMutualAuthChoice;   // user's choice of whether to enforce mutual auth
    DWORD    ResolvedGetDCFlags;     // flags _returned_ by DsGetDcName

    //
    //  fields required for keep alive logic
    //

    LONG        ResponsesExpected;      // number of responses that are pending
    ULONGLONG   TimeOfLastReceive;      // tick count that we last received a response.
    ULONG       KeepAliveSecondCount;
    ULONG       PingWaitTimeInMilliseconds;
    USHORT      PingLimit;
    USHORT      NumberOfPingsSent;      // number of unanswered pings we've sent before closing
    USHORT      GoodConsecutivePings;   // number of consecutive answered pings we've sent before closing
    BOOLEAN     UseTCPKeepAlives;       // whether to turn on TCP's keep-alive functionality

    USHORT  NumberOfHosts;
    USHORT  PortNumber;             // port number used on connect

    LDAP_LOCK StateLock;            // protect updates to states below
    UCHAR     ConnObjectState;      // state of connection object
    UCHAR     HostConnectState;     // have we connected to the server?
    BOOLEAN   ServerDown;           // State of server
    BOOLEAN   AutoReconnect;        // whether autoreconnect is desired
    BOOLEAN   UserAutoRecChoice;    // User's choice for Autoreconnect.
    BOOLEAN   Reconnecting;
    LDAP_LOCK ReconnectLock;        // to single thread autoreconnect requests
    LONG      WaiterCount;          // Number of threads waiting on this connection
    ULONGLONG LastReconnectAttempt; // Timestamp of last Autoreconnect attempt

    ULONG SendDrainTimeSeconds;     // how many seconds to spend draining receive data
                                    // in LdapSendRaw

    //
    // Bind data for this connection.
    //
    BOOLEAN BindInProgress;         // Are we currently exchanging bind packets?
    BOOLEAN SspiNeedsResponse;      // Does SSPI need the server response?
    BOOLEAN SspiNeedsMoreData;      // Is the SSPI token incomplete?
    BOOLEAN TokenNeedsCompletion;   // Does SSPI need to complete the token before we
                                    //     send it to the server?
    BOOLEAN BindPerformed;          // Is the bind complete?
    BOOLEAN SentPacket;             // have we sent a packet to this connection?
    BOOLEAN SslPort;                // Is this a connection to a well known SSL port 636/3269?
    BOOLEAN SslSetupInProgress;     // Are we currently setting up an SSL session?

    BOOLEAN ConcurrentBind;         // Are we running in fast concurrent bind mode?

    ULONG   PreTLSOptions;          // Referral chasing options prior to Starting TLS.

    BOOLEAN PromptForCredentials;   // do we prompt for credentials?

    PSecPkgInfoW PreferredSecurityPackage; // User wants to use this package if possible
    PWCHAR  SaslMethod;             // The preferred SASL method for this connection

    //
    //  when this flag is set to true, we reference connections for each
    //  message we get in for all the requests with this connection as primary.
    //

    BOOLEAN ReferenceConnectionsPerMessage;

    PLDAPMessage BindResponse;      // The response that holds the inbound token.

    //
    // The sicily server authentication requires a different bind method
    // number depending on which packet of the authentication sequence
    // we are currently in (YUCK), so we have to keep track.
    //

    ULONG   CurrentAuthLeg;

    //
    // Important SSL Notes:
    //
    // When we have to do an SSL send, we may have to break the message up
    // into multiple crypto blocks.  We MUST send these blocks in order and
    // back to back without any intervening sends.  The SocketLock protects
    // sends and socket closures on the connection in this manner; any thread
    // wishing to do a send on an SSL connection MUST acquire this lock.
    //

    PVOID   SecureStream;              // Crypto stream object (handles all SSPI details).
    CRITICAL_SECTION SocketLock;

    //
    //  Callback routines to allow caching of connections by ADSI etc.
    //

    QUERYFORCONNECTION *ReferralQueryRoutine;
    NOTIFYOFNEWCONNECTION *ReferralNotifyRoutine;
    DEREFERENCECONNECTION *DereferenceNotifyRoutine;

    //
    //  Callback routines to allow specifying client certificates and validating
    //  server certificates.
    //

    QUERYCLIENTCERT *ClientCertRoutine;
    VERIFYSERVERCERT *ServerCertRoutine;

    //
    //  this is considered the top of the struct LDAP structure that we pass
    //  back to the application.
    //

    LDAP publicLdapStruct;

} LDAP_CONN, * PLDAP_CONN;

#if !defined(_WIN64)
#pragma pack(pop)
#endif

#define TcpHandle    publicLdapStruct.ld_sb.sb_sd
#define UdpHandle    publicLdapStruct.ld_sb.sb_naddr

//  the following signature is "LCon"

#define LDAP_CONN_SIGNATURE 0x6e6f434c

//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise.  It is followed by two macros for setting and clearing
//  flags
//

#define BooleanFlagOn(Flags,SingleFlag) \
    ((BOOLEAN)((((Flags) & (SingleFlag)) !=0)))

#define SetFlag(Flags,SingleFlag) { \
    (Flags) |= (SingleFlag);        \
}

#define ClearFlag(Flags,SingleFlag) { \
    (Flags) &= ~(SingleFlag);         \
}


//
// Entry that we keep off the THREAD_ENTRY block per connection that is being
// used on this thread.
//

typedef struct error_entry {

   struct error_entry * pNext;
   
   PLDAP_CONN Connection;        // primary connection
   ULONG      ThreadId;          // Thread for which this error applies
   PWCHAR     ErrorMessage;      // Error message

} ERROR_ENTRY, *PERROR_ENTRY;

//
//  Per thread current attribute for ldap_first_attribute.  This structure is
//  stored as a linked list in the THREAD_ENTRY, one for each connection being
//  used on that thread.
//

typedef struct ldap_attr_name_per_thread {

    struct ldap_attr_name_per_thread *pNext;
    DWORD  Thread;
    PLDAP_CONN PrimaryConn;
    LDAP_MEMORY_DESCRIPTOR AttrTag;
    UCHAR  AttributeName[ MAX_ATTRIBUTE_NAME_LENGTH ];
    LDAP_MEMORY_DESCRIPTOR AttrTagW;
    WCHAR  AttributeNameW[ MAX_ATTRIBUTE_NAME_LENGTH ];

} LDAP_ATTR_NAME_THREAD_STORAGE, *PLDAP_ATTR_NAME_THREAD_STORAGE;

//  the following signature is "LAtr"

#define LDAP_ATTR_THREAD_SIGNATURE 0x7274414c


//
// THREAD_ENTRY: A global linked list of these is maintained
// with one per thread.  This is used to hold the linked lists
// of per-connection error and attribute entries for that thread.
//
typedef struct thread_entry {

    LIST_ENTRY ThreadEntry;

    DWORD dwThreadID;
    PERROR_ENTRY pErrorList;
    PLDAP_ATTR_NAME_THREAD_STORAGE pCurrentAttrList;

} THREAD_ENTRY, *PTHREAD_ENTRY;

//
//  Entry that we keep off the LDAP_REQUEST block per referral we've chased
//  for this request.
//

typedef struct referral_table_entry {

    PLDAP_CONN ReferralServer;      // referenced pointer
    PWCHAR     ReferralDN;          // DN for referral
    ULONG      ScopeOfSearch;       // Scope of search
    PWCHAR     SearchFilter;        // Search Filter
    PWCHAR     *AttributeList;      // List of attributes

    PVOID      BerMessageSent;      // Message sent in BER format
    ULONG      RequestsPending;
    USHORT     ReferralInstance;    // unique ID for this referral
    BOOLEAN    SingleLevelSearch;   // is this a single level search where
                                    // subordinate referrals would be base srch
    BOOLEAN    CallDerefCallback;   // do we call caching deref callback?
    ULONG      ResentAttempts;      // how many times has this referral been resent?

} REFERRAL_TABLE_ENTRY, *PREFERRAL_TABLE_ENTRY;

//  the following signature is "LRTa"

#define LDAP_REFTABLE_SIGNATURE 0x6154524c

//  the following signature is "LRDN"

#define LDAP_REFDN_SIGNATURE 0x4e44524c

//
//  The LDAP_REQUEST block is another of the principal data structure for
//  this library.  Most other structures are linked off of it.
//  It tracks the following :
//
//   - list of responses received for this request, including referred
//   - list of connections that this Request has used.
//   - resource lock to protect lists and other important fields
//
typedef struct ldap_request {

    LIST_ENTRY RequestListEntry;
    LONG    ReferenceCount;

    PLDAPMessage MessageLinkedList; // pointer to head... pulled from here
    PLDAP_CONN PrimaryConnection;   // referenced pointer

    //
    // SecondayConnection points to an external referred server (if one exists)
    // We redirect all of our paged searches to this searver
    //

    PLDAP_CONN SecondaryConnection;

    LDAP_LOCK   Lock;
    ULONGLONG   RequestTime;
    ULONG   TimeLimit;          // 0 implies no limit
    ULONG   SizeLimit;          // 0 implies no limit

    ULONG   ReturnCode;         // error returned by server
    LONG    MessageId;          // unique across all connections

    //
    //  Per Request per Connection, we maintain a count of how many requests we
    //  have outstanding.  This allows us to not hang when we call into
    //  DrainWinsock when we really don't have anything to wait on.
    //
    //  This is stored off of the request block, where it's traversed at abandon
    //  time.  It's cross referenced with the connection where it's searched
    //  when the connection goes down.
    //

    ULONG      RequestsPending;

    PVOID      BerMessageSent;      // Message sent in BER format
    PREFERRAL_TABLE_ENTRY ReferralConnections;  // pointer to table

    USHORT  ReferralTableSize;
    USHORT  ReferralHopLimit;
    USHORT  ReferralCount;      // incremented every time we chase a new one

    //
    //  Track the number of requests to different servers we have open such
    //  that we don't stop returning data prematurely.
    //

    USHORT  ResponsesOutstanding;   // sum of requests pending for all referrals

    BOOLEAN Abandoned;

    UCHAR ChaseReferrals;
    UCHAR Operation;

    //
    //  If the call is synchronous, then the pointers that we have below for
    //  the different parameters are not allocated, they simply point back to
    //  the original caller's parameters.
    //

    BOOLEAN Synchronous;

    //
    //  When this has been closed, this will be true.
    //

    BOOLEAN Closed;

    //
    //  when this flag is set to true, we reference connections for each
    //  message we get in so that the app can call ldap_conn_from_msg.
    //

    BOOLEAN ReferenceConnectionsPerMessage;

    //
    // When a notification control is detected, we set this to TRUE to
    // avoid deleting the BER request buffer upon returning notifications.
    //

    BOOLEAN NotificationSearch;

    //
    //  These store the original parameters for each operation. We have to
    //  store these since chasing a referral may mean we need to regenerate
    //  the ASN1 since the DN can change.
    //

    PWCHAR OriginalDN;

    PLDAPControlW *ServerControls;      // array of controls
    PLDAPControlW *ClientControls;      // array of controls

    struct ldap_request *PageRequest;   // Original Page request
    LDAP_BERVAL  *PagedSearchServerCookie;

    union {

        struct {
            LDAPModW **AttributeList;
            BOOLEAN Unicode;
        } add;

        struct {
            PWCHAR Attribute;
            PWCHAR Value;
            struct berval   Data;
        } compare;

        struct {
            LDAPModW **AttributeList;
            BOOLEAN Unicode;
        } modify;

        struct {
            PWCHAR   NewDistinguishedName;
            PWCHAR   NewParent;
            INT      DeleteOldRdn;
        } rename;

        struct {
            ULONG   ScopeOfSearch;
            PWCHAR  SearchFilter;
            PWCHAR  *AttributeList;
            ULONG   AttributesOnly;
            BOOLEAN Unicode;
        } search;

        struct {
            struct berval Data;
        } extended;
    };

    LONG    PendingPagedMessageId;

    BOOLEAN GotExternalReferral;    // we have to send requests to an alternate
                                    // server (PrimaryConnection->ExternalReferredServer)

    BOOLEAN AllocatedParms;

    BOOLEAN AllocatedControls;

    BOOLEAN PagedSearchBlock;       // is this a block controlling a paged
                                    // search?  if FALSE, then normal request

    BOOLEAN ReceivedData;           // have we received data on this paged
                                    // search request?  also used on non-paged.

    BOOLEAN CopyResultToCache;      // Before closing the request, copy result
                                    // contents to cache

    BOOLEAN ResultsAreCached;       // Don't go to the wire to get results. They
                                    // are already queued to your recv buffers

    ULONG ResentAttempts;           // Number of times this request has been
                                    // resent during autoreconnects

} LDAP_REQUEST, * PLDAP_REQUEST;

//  the following signature is "LReq"

#define LDAP_REQUEST_SIGNATURE 0x7165524c

//
//  The LDAP_RECVBUFFER structure is used to receive a server's response.
//  It contains the necessary fields to passdown to the transport through
//  winsock to receive data.
//
//  These are linked into the LDAP_CONN structure via the CompletedReceiveList
//  for messages that have already been received.
//
//  The CompletedReceiveList is ordered... newly received LDAP_RECVBUFFER
//  structures are put on the end.  This is so that if a server sends
//  responses ordered, we maintain the order when we pass the results up to
//  the calling program.
//

typedef struct ldap_recvbuffer {

    PLDAP_CONN Connection;

    LIST_ENTRY ReceiveListEntry;

    DWORD   NumberOfBytesReceived;
    DWORD   NumberOfBytesTaken; // number of bytes already copied off to msgs

    DWORD   BufferSize;

    UCHAR   DataBuffer[1];

} LDAP_RECVBUFFER, * PLDAP_RECVBUFFER;

//  the following signature is "LRec"

#define LDAP_RECV_SIGNATURE 0x6365524c

//
//  this structure is used to track the messages we have to check for waiters.
//  we store them off rather than calling directly so as not to muck with the
//  locking order.
//

typedef struct message_id_list_entry {

    struct message_id_list_entry *Next;
    ULONG MessageId;

} MESSAGE_ID_LIST_ENTRY, *PMESSAGE_ID_LIST_ENTRY;

#define LDAP_MSGID_SIGNATURE 0x64494d4c

//
//  The LDAP_MESSAGEWAIT structure is used by a thread that wants to wait for
//  a message from a server.
//  It allocates one by calling LdapGetMessageWaitStructure
//  This initializes an event the thread can wait on and puts the block on
//  a global list of waiting threads.
//
//  When a message comes in, the receive thread will satisfy a wait for a thread
//  on the waiters list.  This thread will then process the message and satisfy
//  any other waiters that should be.
//
//  These structures are freed by the calling thread using
//  LdapFreeMessageWaitStructure.
//
//  The structure has a few fields of interest :
//    - event for thread to wait on that is triggered when message comes in
//    - message number that waiting thread is interested in (0 if interested
//      in all messages from server)
//    - list entry for list of outstanding wait structures
//    - connection that client is interested in, null is ok.  Just means the
//      thread is waiting for any message
//

typedef struct ldap_messagewait {

    LIST_ENTRY WaitListEntry;
    PLDAP_CONN Connection;          // referenced pointer

    HANDLE Event;
    ULONG  MessageNumber;           // may be zero
    ULONG   AllOfMessage;       // for search results, trigger at last response?
    BOOLEAN Satisfied;
    BOOLEAN PendingSendOnly;    // is this wait only a pending send?

} LDAP_MESSAGEWAIT, * PLDAP_MESSAGEWAIT;


typedef struct _SOCKHOLDER {

   SOCKET sock;                    // socket used in the connection
   LPSOCKET_ADDRESS psocketaddr;   // corresponding  pointer to connecting address
   PWCHAR DnsSuppliedName;         // Name returned from DNS

} SOCKHOLDER, *PSOCKHOLDER;

typedef struct _SOCKHOLDER2 {

   LPSOCKET_ADDRESS psocketaddr;   // address to connect to
   PWCHAR DnsSuppliedName;         // Name returned from DNS

} SOCKHOLDER2, *PSOCKHOLDER2;


typedef struct _LDAPReferralDN
{
    PWCHAR   ReferralDN;     // DN present in the referral
    PWCHAR * AttributeList;  // Attributes requested
    ULONG    AttribCount;    // Number of attributes requested
    ULONG    ScopeOfSearch;  // Search scope
    PWCHAR   SearchFilter;   // search filter
    PWCHAR   Extension;      // Extension part of the URL
    PWCHAR   BindName;       // A bindname extension for the URL

} LDAPReferralDN, * PLDAPReferralDN;


typedef struct _EncryptHeader_v1
{
   ULONG EncryptMessageSize;

} EncryptHeader_v1, *PEncryptHeader_v1;

//
// On the wire, the following signature appears as "ENCRYPTD"
//

#define LDAP_ENCRYPT_SIGNATURE 0x4454505952434e45

//
// hd.exe which is found in the idw directory was used to create these tags.
//


//  the following signature is "LWai"

#define LDAP_WAIT_SIGNATURE 0x6961574c

//  the following signature is "LBer"

#define LDAP_LBER_SIGNATURE 0x7265424c

//  the following signature is "LMsg"

#define LDAP_MESG_SIGNATURE 0x67734d4c

//  the following signature is "LStr"

#define LDAP_STRING_SIGNATURE 0x7274534c

//  the following signature is "LVal"

#define LDAP_VALUE_SIGNATURE 0x6C61564c

//  the following signature is "LVll"

#define LDAP_VALUE_LIST_SIGNATURE 0x6C6C564c

//  the following signature is "LBuf"

#define LDAP_BUFFER_SIGNATURE 0x6675424c

//  the following signature is "LUDn"

#define LDAP_USER_DN_SIGNATURE 0x6e44554c

//  the following signature is "LGDn"

#define LDAP_GENERATED_DN_SIGNATURE 0x6e44474c

//  the following signature is "LCre"

#define LDAP_CREDENTIALS_SIGNATURE 0x6572434c

//  the following signature is "LBCl"

#define LDAP_LDAP_CLASS_SIGNATURE 0x6c43424c

//  the following signature is "LAns"

#define LDAP_ANSI_SIGNATURE 0x736e414c

//  the following signature is "LUni"

#define LDAP_UNICODE_SIGNATURE 0x696e554c

//  the following signature is "LSsl"

#define LDAP_SSL_CLASS_SIGNATURE 0x6c73534c

//  the following signature is "LAtM"

#define LDAP_ATTRIBUTE_MODIFY_SIGNATURE 0x4d74414c

//  the following signature is "LMVa"

#define LDAP_MOD_VALUE_SIGNATURE 0x61564d4c

//  the following signature is "LMVb"

#define LDAP_MOD_VALUE_BERVAL_SIGNATURE 0x62564d4c

//  the following signature is "LSel"

#define LDAP_SELECT_READ_SIGNATURE 0x6c65534c

//  the following signature is "LCnt"

#define LDAP_CONTROL_SIGNATURE 0x746e434c

//  the following signature is "LCrl"

#define LDAP_CONTROL_LIST_SIGNATURE 0x6c72434c

//  the following signature is "LBad"

#define LDAP_DONT_FREE_SIGNATURE 0x6461424c

//  the following signature is "LFre"

#define LDAP_FREED_SIGNATURE 0x6572464c

//  the following signature is "LExO"

#define LDAP_EXTENDED_OP_SIGNATURE 0x4f78454c

//  the following signature is "LCda"

#define LDAP_COMPARE_DATA_SIGNATURE 0x6164434c

//  the following signature is "LEsc"

#define LDAP_ESCAPE_FILTER_SIGNATURE 0x6373454c

//  the following signature is "LHst"

#define LDAP_HOST_NAME_SIGNATURE 0x7473484c

//  the following signature is "LBvl"

#define LDAP_BERVAL_SIGNATURE 0x6c76424c

//  the following signature is "LSrv"

#define LDAP_SERVICE_NAME_SIGNATURE 0x7672534c

//  the following signature is "LSdr"

#define LDAP_SOCKADDRL_SIGNATURE 0x7264534c

//  the following signature is "LErr"

#define LDAP_ERROR_SIGNATURE 0x7272454c

//  the following signature is "LUrl"

#define LDAP_URL_SIGNATURE 0x6c72554c

//  the following signature is "LSal"

#define LDAP_SASL_SIGNATURE 0x6c61534c

// the following signature is "LThd"

#define LDAP_PER_THREAD_SIGNATURE 0x6c546864

//
//  function declarations
//

PLDAP_CONN
GetConnectionPointer(
    LDAP *ExternalHandle
    );

PLDAP_CONN
GetConnectionPointer2(
    LDAP *ExternalHandle
    );

PLDAP_CONN
ReferenceLdapConnection(
    PLDAP_CONN Connection
    );

PLDAP_REQUEST
ReferenceLdapRequest(
    PLDAP_REQUEST request
    );

BOOL
LdapInitializeWinsock (
    VOID
    );

VOID
CloseLdapConnection (
    PLDAP_CONN Connection
    );

PLDAP_CONN
LdapAllocateConnection (
    PWCHAR HostName,
    ULONG PortNumber,
    ULONG Secure,
    BOOLEAN Udp
    );

VOID
DereferenceLdapConnection2 (
    PLDAP_CONN connection
    );

LPVOID
ldapMalloc (
    DWORD Bytes,
    ULONG Tag
    );

VOID
ldapFree (
    LPVOID Block,
    ULONG  Tag
    );

VOID
ldapSecureFree (
    LPVOID Block,
    ULONG  Tag
    );

BOOLEAN
ldapSwapTags (
    LPVOID Block,
    ULONG  OldTag,
    ULONG  NewTag
    );

VOID
ldap_MoveMemory (
    PCHAR dest,
    PCHAR source,
    ULONG length
    );

PLDAP_REQUEST LdapCreateRequest (
    PLDAP_CONN Connection,
    UCHAR Operation
    );

VOID
DereferenceLdapRequest2 (
    PLDAP_REQUEST Request
    );

PLDAP_RECVBUFFER
LdapGetReceiveStructure (
    DWORD cbBuffer
    );

VOID
LdapFreeReceiveStructure (
    IN PLDAP_RECVBUFFER ReceiveBuffer,
    IN BOOLEAN HaveLock
    );

PLDAP_MESSAGEWAIT
LdapGetMessageWaitStructure (
    IN PLDAP_CONN Connection,
    IN ULONG CompleteMessages,
    IN ULONG MessageNumber,
    IN BOOLEAN PendingSendOnly
    );

VOID
LdapFreeMessageWaitStructure (
    PLDAP_MESSAGEWAIT Message
    );

VOID
CloseLdapRequest (
    PLDAP_REQUEST Request
    );

PLDAP_REQUEST
FindLdapRequest(
    LONG MessageId
    );

PCHAR
ldap_dup_string (
    PCHAR String,
    ULONG Extra,
    ULONG Tag
    );

PWCHAR
ldap_dup_stringW (
    PWCHAR String,
    ULONG Extra,
    ULONG Tag
    );

ULONG
add_string_to_list (
    PWCHAR **ArrayToReturn,
    ULONG *ArraySize,
    PWCHAR StringToAdd,
    BOOLEAN CreateCopy
    );

VOID
SetConnectionError (
    PLDAP_CONN Connection,
    ULONG   LdapError,
    PCHAR   DNNameInError
    );

ULONG
HandleReferrals (
    PLDAP_CONN Connection,
    PLDAPMessage *FirstSearchEntry,
    PLDAP_REQUEST Request
    );

ULONG
LdapSendCommand (
    PLDAP_CONN Connection,
    PLDAP_REQUEST Request,
    USHORT ReferralNumber
    );

ULONG
LdapBind (
    PLDAP_CONN connection,
    PWCHAR BindDistName,
    ULONG Method,
    PWCHAR BindCred,
    BOOLEAN Synchronous
    );

BOOLEAN
LdapInitSecurity (
    VOID
    );

BOOLEAN
LdapInitSsl (
    VOID
    );

BOOLEAN
CheckForNullCredentials (
    PLDAP_CONN Connection
    );

VOID
CloseCredentials (
    PLDAP_CONN Connection
    );

VOID
SetNullCredentials (
    PLDAP_CONN Connection
    );

ULONG
LdapConvertSecurityError (
    PLDAP_CONN Connection,
    SECURITY_STATUS sErr
    );

ULONG
LdapSspiBind (
    PLDAP_CONN Connection,
    PSecPkgInfoW Package,
    ULONG UserMethod,
    ULONG SspiFlags,
    PWCHAR UserName,
    PWCHAR TargetName,
    PWCHAR Credentials
    );

ULONG
LdapGetSicilyPackageList(
    PLDAP_CONN Connection,
    PBYTE PackageList,
    ULONG Length,
    PULONG pResponseLen
    );

VOID
LdapClearSspiState(
    PLDAP_CONN Connection
);

ULONG
LdapSetSspiContinueState(
    PLDAP_CONN Connection,
    SECURITY_STATUS sErr
    );

ULONG
LdapExchangeOpaqueToken(
    PLDAP_CONN Connection,
    ULONG UserMethod,
    PWCHAR MethodOID,
    PWCHAR UserName,
    PVOID pOutboundToken,
    ULONG cbTokenLength,
    SecBufferDesc *pInboundToken,
    BERVAL **ServerCred,
    PLDAPControlW  *ServerControls,
    PLDAPControlW  *ClientControls,
    PULONG  MessageNumber,
    BOOLEAN SendOnly,
    BOOLEAN Unicode,
    BOOLEAN * pSentMessage
    );

ULONG
LdapTryAllMsnAuthentication(
    PLDAP_CONN Connection,
    PWCHAR BindCred
    );

ULONG
LdapSetupSslSession (
    PLDAP_CONN Connection
    );

DWORD
LdapSendRaw (
    IN PLDAP_CONN Connection,
    PCHAR Data,
    ULONG DataCount
    );

DWORD
GetDefaultLdapServer(
    PWCHAR DomainName,
    LPWSTR Addresses[],
    LPWSTR DnsHostNames[],
    LPWSTR MemberDomains[],
    LPDWORD Count,
    ULONG DsFlags,
    BOOLEAN *SameSite,
    USHORT PortNumber,
    ULONG *pResolvedDsFlags
    );

DWORD
InitLdapServerFromDomain(
    LPCWSTR DomainName,
    ULONG Flags,
    OUT HANDLE *Handle,
    LPWSTR *Site
    );

DWORD
NextLdapServerFromDomain(
    HANDLE Handle,
    LPSOCKET_ADDRESS *lpSockAddresses,
    PWCHAR *DnsHostName,
    PULONG SocketCount
    );

DWORD
CloseLdapServerFromDomain(
    HANDLE Handle,
    LPWSTR Site
    );

ULONG
ParseLdapToken (
    PWCHAR CurrentPosition,
    PWCHAR *StartOfToken,
    PWCHAR *EqualSign,
    PWCHAR *EndOfToken
);

ULONG
FromUnicodeWithAlloc (
    PWCHAR Source,
    PCHAR *Output,
    ULONG Tag,
    ULONG CodePage
    );

ULONG
ToUnicodeWithAlloc (
    PCHAR Source,
    LONG SourceLength,
    PWCHAR *Output,
    ULONG Tag,
    ULONG CodePage
    );

ULONG
strlenW(
    PWCHAR string
    );

BOOLEAN
ldapWStringsIdentical (
    PWCHAR string1,
    LONG length1,
    PWCHAR string2,
    LONG length2
    );

ULONG
DrainPendingCryptoStream (
    PLDAP_CONN Connection
    );

ULONG
LdapDupLDAPModStructure (
    LDAPModW *AttributeList[],
    BOOLEAN Unicode,
    LDAPModW **OutputList[]
);

VOID
LdapFreeLDAPModStructure (
    PLDAPModW *AttrList,
    BOOLEAN Unicode
    );

ULONG
AddToPendingList (
    PLDAP_REQUEST Request,
    PLDAP_CONN Connection
    );

VOID
DecrementPendingList (
    PLDAP_REQUEST Request,
    PLDAP_CONN Connection
    );

VOID
ClearPendingListForRequest (
    PLDAP_REQUEST Request
    );

VOID
ClearPendingListForConnection (
    PLDAP_CONN Connection
    );

ULONG
LdapCheckControls (
    PLDAP_REQUEST Request,
    PLDAPControlW *ServerControls,
    PLDAPControlW *ClientControls,
    BOOLEAN Unicode,
    ULONG   ExtraSlots
    );

VOID
FreeLdapControl(
    PLDAPControlW *Controls
    );

BOOLEAN
LdapCheckForMandatoryControl (
    PLDAPControlW *Controls
    );

ULONG
ldap_result_with_error (
    PLDAP_CONN      Connection,
    ULONG           msgid,
    ULONG           AllOfMessage,
    struct l_timeval  *TimeOut,
    LDAPMessage     **res,
    LDAPMessage     **LastResult
    );

ULONG
FreeCurrentCredentials (
    PLDAP_CONN Connection
    );

ULONG
LdapSaveSearchParameters (
    PLDAP_REQUEST Request,
    PWCHAR  DistinguishedName,
    PWCHAR  SearchFilter,
    PWCHAR  AttributeList[],
    BOOLEAN Unicode
    );

ULONG
LdapSearch (
        PLDAP_CONN connection,
        PWCHAR  DistinguishedName,
        ULONG   ScopeOfSearch,
        PWCHAR  SearchFilter,
        PWCHAR  AttributeList[],
        ULONG   AttributesOnly,
        BOOLEAN Unicode,
        BOOLEAN Synchronous,
        PLDAPControlW *ServerControls,
        PLDAPControlW *ClientControls,
        ULONG   TimeLimit,
        ULONG   SizeLimit,
        ULONG  *MessageNumber
    );

ULONG
LdapAbandon (
    PLDAP_CONN connection,
    ULONG msgid,
    BOOLEAN SendAbandon
    );

PLDAPMessage
ldap_first_record (
    PLDAP_CONN connection,
    LDAPMessage *Results,
    ULONG MessageType
    );

PLDAPMessage
ldap_next_record (
    PLDAP_CONN connection,
    LDAPMessage *Results,
    ULONG MessageType
    );

ULONG
ldap_count_records (
    PLDAP_CONN connection,
    LDAPMessage *Results,
    ULONG MessageType
    );

VOID
GetCurrentLuid (
    PLUID Luid
    );

ULONG
LdapMakeCredsWide(
    PCHAR pAnsiAuthIdent,
    PCHAR *ppWideAuthIdent,
    BOOLEAN FromWide
    );

ULONG
LdapMakeCredsThin(
    PCHAR pAnsiAuthIdent,
    PCHAR *ppWideAuthIdent,
    BOOLEAN FromWide
    );

ULONG
LdapMakeEXCredsWide(
    PCHAR pAnsiAuthIdentEX,
    PCHAR *ppWideAuthIdentEX,
    BOOLEAN FromWide
    );

ULONG
LdapMakeEXCredsThin(
    PCHAR pAnsiAuthIdentEX,
    PCHAR *ppWideAuthIdentEX,
    BOOLEAN FromWide
    );

BOOLEAN
LdapAuthError(
   ULONG err
   );

ULONG
LdapPingServer(
    PLDAP_CONN      Connection
    );

VOID
UnloadPingLibrary(
    VOID
    );

VOID
LdapWakeupSelect (
    VOID
    );

VOID
CheckForWaiters (
    ULONG MessageNumber,
    BOOLEAN AnyWaiter,
    PLDAP_CONN Connection
    );

ULONG
LdapEncodeSortControl (
        PLDAP_CONN connection,
        PLDAPSortKeyW  *SortKeys,
        PLDAPControlW  Control,
        BOOLEAN Criticality,
        ULONG codePage
        );

ULONG
LdapParseResult (
        PLDAP_CONN connection,
        LDAPMessage *ResultMessage,
        ULONG *ReturnCode OPTIONAL,          // returned by server
        PWCHAR *MatchedDNs OPTIONAL,         // free with ldap_value_freeW
        PWCHAR *ErrorMessage OPTIONAL,       // free with ldap_value_freeW
        PWCHAR **Referrals OPTIONAL,         // free with ldap_value_freeW
        PLDAPControlW **ServerControls OPTIONAL,
        BOOLEAN Freeit,
        ULONG codePage
        );

ULONG LdapParseExtendedResult (
        PLDAP_CONN      connection,
        LDAPMessage    *ResultMessage,
        PWCHAR         *ResultOID,
        struct berval **ResultData,
        BOOLEAN         Freeit,
        ULONG           codePage
        );

ULONG
LdapAutoReconnect (
    PLDAP_CONN Connection
    );

ULONG
SimulateErrorMessage (
    PLDAP_CONN Connection,
    PLDAP_REQUEST Request,
    ULONG Error
    );

ULONG
LdapConnect (
    PLDAP_CONN connection,
    struct l_timeval  *timeout,
    BOOLEAN DontWait
    );

ULONG
ProcessAlternateCreds (
      PLDAP_CONN Connection,
      PSecPkgInfoW Package,
      PWCHAR Credentials,
      PWCHAR *newcreds
      );

BOOLEAN
LdapIsAddressNumeric (
    PWCHAR HostName
    );

ULONG
LdapDetermineServerVersion (
    PLDAP_CONN Connection,
    struct l_timeval  *Timeout,
    BOOLEAN *pfIsServerWhistler     // OUT
    );

BOOLEAN LoadUser32Now(
    VOID
    );

ULONG
ConnectToSRVrecs(
    PLDAP_CONN Connection,
    PWCHAR HostName,
    BOOLEAN SuggestedHost,
    USHORT port,
    struct l_timeval  *timeout
    );

ULONG
ConnectToArecs(
    PLDAP_CONN  Connection,
    struct hostent  *hostEntry,
    BOOLEAN SuggestedHost,
    USHORT port,
    struct l_timeval  *timeout
    );

ULONG
LdapParallelConnect(
       PLDAP_CONN   Connection,
       PSOCKHOLDER2 *sockAddressArr,
       USHORT port,
       UINT totalCount,
       struct l_timeval  *timeout
       );

VOID
InsertErrorMessage(
     PLDAP_CONN Connection,
     PWCHAR     ErrorMessage
      );

PVOID
GetErrorMessage(
     PLDAP_CONN Connection,
     BOOLEAN Unicode
      );

BOOL
AddPerThreadEntry(
                DWORD ThreadID
                );

BOOL
RemovePerThreadEntry(
                DWORD ThreadID
                );

VOID
RoundUnicodeStringMaxLength(
    UNICODE_STRING *pString,
    USHORT dwMultiple
    );

VOID
EncodeUnicodeString(
    UNICODE_STRING *pString
    );

VOID
DecodeUnicodeString(
    UNICODE_STRING *pString
    );

HMODULE 
LoadSystem32LibraryA(
  PCHAR lpFileName
);

BOOLEAN
IsMessageIdValid(
     LONG MessageId
     );

PLDAPReferralDN
LdapParseReferralDN(
    PWCHAR newDN
    );

VOID
DebugReferralOutput(
    PLDAP_REQUEST Request,
    PWCHAR HostAddr,
    PWCHAR NewUrlDN
    );

VOID
DiscoverDebugRegKey(
    VOID
    );

DWORD
ReadRegIntegrityDefault(
    DWORD *pdwIntegrity
    );
    
#define DEFAULT_INTEGRITY_NONE      0
#define DEFAULT_INTEGRITY_PREFERRED 1
#define DEFAULT_INTEGRITY_REQUIRED  2

VOID
FreeEntireLdapCache(
   VOID
   );

VOID
InitializeLdapCache (
   VOID
   );

PWCHAR
LdapFirstAttribute (
    PLDAP_CONN      connection,
    LDAPMessage     *Message,
    BerElement      **OpaqueResults,
    BOOLEAN         Unicode
    );

PWCHAR
LdapNextAttribute (
    PLDAP_CONN      connection,
    LDAPMessage     *Message,
    BerElement      *OpaqueResults,
    BOOLEAN         Unicode
    );

ULONG
LdapGetValues (
    PLDAP_CONN      connection,
    LDAPMessage     *Message,
    PWCHAR          attr,
    BOOLEAN         BerVal,
    BOOLEAN         Unicode,
    PVOID           *Output
    );


ULONG LdapGetConnectionOption (
    PLDAP_CONN connection,
    int option,
    void *outvalue,
    BOOLEAN Unicode
    );

ULONG LdapSetConnectionOption (
    PLDAP_CONN connection,
    int option,
    const void *invalue,
    BOOLEAN Unicode
    );

ULONG LDAPAPI LdapGetPagedCount(
        PLDAP_CONN      connection,
        PLDAP_REQUEST   request,
        ULONG          *TotalCount,
        PLDAPMessage    Results
    );

ULONGLONG
LdapGetTickCount(
    VOID
    );

ULONG
LdapGetModuleBuildNum(
    VOID
    );


//
//  Here's the function declarations for dynamically loading winsock
//
//  We dynamically load winsock so that we can either load winsock 1.1 or 2.0,
//  and the functions we pull in depend on what version we're going to use.
//

typedef int (PASCAL FAR *FNWSAFDISSET)(SOCKET, fd_set FAR *);

extern LPFN_WSASTARTUP pWSAStartup;
extern LPFN_WSACLEANUP pWSACleanup;
extern LPFN_WSAGETLASTERROR pWSAGetLastError;
extern LPFN_RECV precv;
extern LPFN_SELECT pselect;
extern LPFN_WSARECV pWSARecv;
extern LPFN_SOCKET psocket;
extern LPFN_CONNECT pconnect;
extern LPFN_GETHOSTBYNAME pgethostbyname;
extern LPFN_GETHOSTBYADDR pgethostbyaddr;
extern LPFN_INET_ADDR pinet_addr;
extern LPFN_INET_NTOA pinet_ntoa;
extern LPFN_HTONS phtons;
extern LPFN_HTONL phtonl;
extern LPFN_NTOHL pntohl;
extern LPFN_CLOSESOCKET pclosesocket;
extern LPFN_SEND psend;
extern LPFN_IOCTLSOCKET pioctlsocket;
extern LPFN_SETSOCKOPT psetsockopt;
extern FNWSAFDISSET pwsafdisset;
extern LPFN_WSALOOKUPSERVICEBEGINW pWSALookupServiceBeginW;
extern LPFN_WSALOOKUPSERVICENEXTW pWSALookupServiceNextW;
extern LPFN_WSALOOKUPSERVICEEND pWSALookupServiceEnd;


//
// Function declarations for loading NTDS APIs
//

typedef DWORD (*FNDSMAKESPNW) (
                   LPWSTR ServiceClass,
                   LPWSTR ServiceName,
                   LPWSTR InstanceName,
                   USHORT InstancePort,
                   LPWSTR Referrer,
                   DWORD *pcSpnLength,
                   LPWSTR pszSpn
                   );

extern FNDSMAKESPNW pDsMakeSpnW;

//
// Function declarations for loading Rtl APIs
//

typedef VOID (*FNRTLINITUNICODESTRING) (
           PUNICODE_STRING DestinationString,
           PCWSTR SourceString
           );

extern FNRTLINITUNICODESTRING pRtlInitUnicodeString;

typedef VOID (*FRTLRUNENCODEUNICODESTRING) (
           PUCHAR          Seed,
           PUNICODE_STRING String
           );

extern FRTLRUNENCODEUNICODESTRING pRtlRunEncodeUnicodeString;

typedef VOID (*FRTLRUNDECODEUNICODESTRING) (
           UCHAR           Seed,
           PUNICODE_STRING String
           );

extern FRTLRUNDECODEUNICODESTRING pRtlRunDecodeUnicodeString;


typedef NTSTATUS (*FRTLENCRYPTMEMORY) (
           PVOID Memory,
           ULONG MemoryLength,
           ULONG OptionFlags
           );

extern FRTLENCRYPTMEMORY pRtlEncryptMemory;

typedef NTSTATUS (*FRTLDECRYPTMEMORY) (
           PVOID Memory,
           ULONG MemoryLength,
           ULONG OptionFlags
           );

extern FRTLDECRYPTMEMORY pRtlDecryptMemory;


//
// Function declarations for loading USER32 APIs
//

typedef int (*FNLOADSTRINGA) (
    IN HINSTANCE hInstance,
    IN UINT uID,
    OUT LPSTR lpBuffer,
    IN int nBufferMax
    );

extern FNLOADSTRINGA pfLoadStringA;

typedef int (*FNWSPRINTFW) (
   OUT LPWSTR,
   IN LPCWSTR,
   ...);

extern FNWSPRINTFW pfwsprintfW;

typedef int (*FNMESAGEBOXW) (
    IN HWND hWnd,
    IN LPCWSTR lpText,
    IN LPCWSTR lpCaption,
    IN UINT uType
    );

extern FNMESAGEBOXW pfMessageBoxW;

//
// Function declarations for loading SECUR32 APIs
//

typedef BOOL (WINAPI *FGETTOKENINFORMATION) (
    HANDLE TokenHandle,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    LPVOID TokenInformation,
    DWORD TokenInformationLength,
    PDWORD ReturnLength
    );

typedef BOOL (WINAPI *FOPENPROCESSTOKEN) (
    HANDLE ProcessHandle,
    DWORD DesiredAccess,
    PHANDLE TokenHandle
    );

typedef BOOL (WINAPI *FOPENTHREADTOKEN) (
    HANDLE ThreadHandle,
    DWORD DesiredAccess,
    BOOL OpenAsSelf,
    PHANDLE TokenHandle
    );

typedef SECURITY_STATUS (SEC_ENTRY *FSASLGETPROFILEPACKAGEW) (
    IN  LPWSTR ProfileName,
    OUT PSecPkgInfoW * PackageInfo
    );

extern FSASLGETPROFILEPACKAGEW pSaslGetProfilePackageW;

typedef SECURITY_STATUS (SEC_ENTRY *FSASLINITIALIZESECURITYCONTEXTW) (
    PCredHandle                 phCredential,
    PCtxtHandle                 phContext,
    LPWSTR                      pszTargetName,
    unsigned long               fContextReq,
    unsigned long               Reserved1,
    unsigned long               TargetDataRep,
    PSecBufferDesc              pInput,
    unsigned long               Reserved2,
    PCtxtHandle                 phNewContext,
    PSecBufferDesc              pOutput,
    unsigned long SEC_FAR *     pfContextAttr,
    PTimeStamp                  ptsExpiry
    );

extern FSASLINITIALIZESECURITYCONTEXTW pSaslInitializeSecurityContextW;

typedef SECURITY_STATUS (SEC_ENTRY *FQUERYCONTEXTATTRIBUTESW) (
   PCtxtHandle phContext,              // Context to query
   unsigned long ulAttribute,          // Attribute to query
   void SEC_FAR * pBuffer              // Buffer for attributes
   );

extern FQUERYCONTEXTATTRIBUTESW pQueryContextAttributesW;

typedef PSecurityFunctionTableW (*FSECINITSECURITYINTERFACEW)( VOID );
typedef PSecurityFunctionTableA (*FSECINITSECURITYINTERFACEA)( VOID );

extern FSECINITSECURITYINTERFACEW pSspiInitialize;
extern FSECINITSECURITYINTERFACEW pSslInitialize;

PSecurityFunctionTableW Win9xSspiInitialize();
PSecurityFunctionTableW Win9xSslInitialize();

//
// Macros that let us call Unicode version in NT and Ansi version in Win9x
//
#define LdapSspiInitialize()      (GlobalWin9x ? Win9xSspiInitialize() : (*pSspiInitialize)())
#define LdapSslInitialize()       (GlobalWin9x ? Win9xSslInitialize()  : (*pSslInitialize)())

#endif  // LDAP_CLIENT_INTERNAL_DEFINED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\ldapstr.h ===
#define WINLDAP_BASE_MSG                            1000

#define WINLDAP_RC_SUCCESS                          (WINLDAP_BASE_MSG+0x00)
#define WINLDAP_RC_OPERATIONS_ERROR                 (WINLDAP_BASE_MSG+0x01)
#define WINLDAP_RC_PROTOCOL_ERROR                   (WINLDAP_BASE_MSG+0x02)
#define WINLDAP_RC_TIMELIMIT_EXCEEDED               (WINLDAP_BASE_MSG+0x03)
#define WINLDAP_RC_SIZELIMIT_EXCEEDED               (WINLDAP_BASE_MSG+0x04)
#define WINLDAP_RC_COMPARE_FALSE                    (WINLDAP_BASE_MSG+0x05)
#define WINLDAP_RC_COMPARE_TRUE                     (WINLDAP_BASE_MSG+0x06)
#define WINLDAP_RC_AUTH_METHOD_NOT_SUPPORTED        (WINLDAP_BASE_MSG+0x07)
#define WINLDAP_RC_STRONG_AUTH_REQUIRED             (WINLDAP_BASE_MSG+0x08)
#define WINLDAP_RC_REFERRAL_V2                      (WINLDAP_BASE_MSG+0x09)
#define WINLDAP_RC_REFERRAL                         (WINLDAP_BASE_MSG+0x0a)
#define WINLDAP_RC_ADMIN_LIMIT_EXCEEDED             (WINLDAP_BASE_MSG+0x0b)
#define WINLDAP_RC_UNAVAILABLE_CRIT_EXTENSION       (WINLDAP_BASE_MSG+0x0c)
#define WINLDAP_RC_CONFIDENTIALITY_REQUIRED         (WINLDAP_BASE_MSG+0x0d)
#define WINLDAP_RC_NO_SUCH_ATTRIBUTE                (WINLDAP_BASE_MSG+0x10)
#define WINLDAP_RC_UNDEFINED_TYPE                   (WINLDAP_BASE_MSG+0x11)
#define WINLDAP_RC_INAPPROPRIATE_MATCHING           (WINLDAP_BASE_MSG+0x12)
#define WINLDAP_RC_CONSTRAINT_VIOLATION             (WINLDAP_BASE_MSG+0x13)
#define WINLDAP_RC_ATTRIBUTE_OR_VALUE_EXISTS        (WINLDAP_BASE_MSG+0x14)
#define WINLDAP_RC_INVALID_SYNTAX                   (WINLDAP_BASE_MSG+0x15)
#define WINLDAP_RC_NO_SUCH_OBJECT                   (WINLDAP_BASE_MSG+0x20)
#define WINLDAP_RC_ALIAS_PROBLEM                    (WINLDAP_BASE_MSG+0x21)
#define WINLDAP_RC_INVALID_DN_SYNTAX                (WINLDAP_BASE_MSG+0x22)
#define WINLDAP_RC_IS_LEAF                          (WINLDAP_BASE_MSG+0x23)
#define WINLDAP_RC_ALIAS_DEREF_PROBLEM              (WINLDAP_BASE_MSG+0x24)
#define WINLDAP_RC_INAPPROPRIATE_AUTH               (WINLDAP_BASE_MSG+0x30)
#define WINLDAP_RC_INVALID_CREDENTIALS              (WINLDAP_BASE_MSG+0x31)
#define WINLDAP_RC_INSUFFICIENT_RIGHTS              (WINLDAP_BASE_MSG+0x32)
#define WINLDAP_RC_BUSY                             (WINLDAP_BASE_MSG+0x33)
#define WINLDAP_RC_UNAVAILABLE                      (WINLDAP_BASE_MSG+0x34)
#define WINLDAP_RC_UNWILLING_TO_PERFORM             (WINLDAP_BASE_MSG+0x35)
#define WINLDAP_RC_LOOP_DETECT                      (WINLDAP_BASE_MSG+0x36)
#define WINLDAP_RC_SORT_CONTROL_MISSING             (WINLDAP_BASE_MSG+0x3C)
#define WINLDAP_RC_INDEX_RANGE_ERROR                (WINLDAP_BASE_MSG+0x3D)
#define WINLDAP_RC_NAMING_VIOLATION                 (WINLDAP_BASE_MSG+0x40)
#define WINLDAP_RC_OBJECT_CLASS_VIOLATION           (WINLDAP_BASE_MSG+0x41)
#define WINLDAP_RC_NOT_ALLOWED_ON_NONLEAF           (WINLDAP_BASE_MSG+0x42)
#define WINLDAP_RC_NOT_ALLOWED_ON_RDN               (WINLDAP_BASE_MSG+0x43)
#define WINLDAP_RC_ALREADY_EXISTS                   (WINLDAP_BASE_MSG+0x44)
#define WINLDAP_RC_NO_OBJECT_CLASS_MODS             (WINLDAP_BASE_MSG+0x45)
#define WINLDAP_RC_RESULTS_TOO_LARGE                (WINLDAP_BASE_MSG+0x46)
#define WINLDAP_RC_AFFECTS_MULTIPLE_DSAS            (WINLDAP_BASE_MSG+0x47)
#define WINLDAP_RC_LDAP_CONTROL_ERROR               (WINLDAP_BASE_MSG+0x4c)
#define WINLDAP_RC_OTHER                            (WINLDAP_BASE_MSG+0x50)
#define WINLDAP_RC_SERVER_DOWN                      (WINLDAP_BASE_MSG+0x51)
#define WINLDAP_RC_LOCAL_ERROR                      (WINLDAP_BASE_MSG+0x52)
#define WINLDAP_RC_ENCODING_ERROR                   (WINLDAP_BASE_MSG+0x53)
#define WINLDAP_RC_DECODING_ERROR                   (WINLDAP_BASE_MSG+0x54)
#define WINLDAP_RC_TIMEOUT                          (WINLDAP_BASE_MSG+0x55)
#define WINLDAP_RC_AUTH_UNKNOWN                     (WINLDAP_BASE_MSG+0x56)
#define WINLDAP_RC_FILTER_ERROR                     (WINLDAP_BASE_MSG+0x57)
#define WINLDAP_RC_USER_CANCELLED                   (WINLDAP_BASE_MSG+0x58)
#define WINLDAP_RC_PARAM_ERROR                      (WINLDAP_BASE_MSG+0x59)
#define WINLDAP_RC_NO_MEMORY                        (WINLDAP_BASE_MSG+0x5a)
#define WINLDAP_RC_CONNECT_ERROR                    (WINLDAP_BASE_MSG+0x5b)
#define WINLDAP_RC_NOT_SUPPORTED                    (WINLDAP_BASE_MSG+0x5c)
#define WINLDAP_RC_CONTROL_NOT_FOUND                (WINLDAP_BASE_MSG+0x5d)
#define WINLDAP_RC_NO_RESULTS_RETURNED              (WINLDAP_BASE_MSG+0x5e)
#define WINLDAP_RC_MORE_RESULTS_TO_RETURN           (WINLDAP_BASE_MSG+0x5f)
#define WINLDAP_RC_CLIENT_LOOP                      (WINLDAP_BASE_MSG+0x60)
#define WINLDAP_RC_REFERRAL_LIMIT_EXCEEDED          (WINLDAP_BASE_MSG+0x61)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\globals.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    globals.h  global data for LDAP client DLL

Abstract:

   This module contains data declarations necessary for LDAP client DLL.

Author:

    Andy Herron    (andyhe)        08-May-1996
    Anoop Anantha  (AnoopA)        24-Jun-1998

Revision History:

--*/

extern LIST_ENTRY GlobalListActiveConnections;
extern LIST_ENTRY GlobalListWaiters;
extern LIST_ENTRY GlobalListRequests;
extern CRITICAL_SECTION RequestListLock;
extern CRITICAL_SECTION ConnectionListLock;
extern CRITICAL_SECTION LoadLibLock;
extern CRITICAL_SECTION CacheLock;
extern CRITICAL_SECTION SelectLock1;
extern CRITICAL_SECTION SelectLock2;
extern HANDLE     LdapHeap;
extern LONG      GlobalConnectionCount;
extern LONG      GlobalRequestCount;
extern LONG      GlobalWaiterCount;
extern LONG      GlobalMessageNumber;
extern BOOLEAN   MessageNumberHasWrapped;
extern BOOLEAN   GlobalWinsock11;
extern BOOLEAN   GlobalWinNT;
extern BOOLEAN GlobalLdapShuttingDown;
extern DWORD  GlobalReceiveHandlerThread;
extern DWORD  GlobalDrainWinsockThread;
extern HANDLE GlobalLdapShutdownEvent;
extern HINSTANCE GlobalLdapDllInstance;
extern BOOLEAN   GlobalWin9x;
extern HINSTANCE SecurityLibraryHandle;
extern HINSTANCE SslLibraryHandle;
extern HINSTANCE NetApi32LibraryHandle;
extern HINSTANCE AdvApi32LibraryHandle;
extern HINSTANCE NTDSLibraryHandle;
extern HINSTANCE USER32LibraryHandle;
extern LONG GlobalCountOfOpenRequests;
extern ULONG GlobalWaitSecondsForSelect;
extern ULONG GlobalLdapPingLimit;
extern ULONG GlobalPingWaitTime;
extern ULONG GlobalRequestResendLimit;
extern UCHAR GlobalSeed;
extern BOOLEAN PopupRegKeyFound;
extern BOOLEAN DisableRootDSECache;
extern BOOLEAN GlobalUseScrambling;
extern LIST_ENTRY GlobalPerThreadList;
extern CRITICAL_SECTION PerThreadListLock;
extern DWORD GlobalIntegrityDefault;
extern DWORD GlobalRejectNewRequests;

//
// The GlobalPerThreadList is protected by the PerThreadListLock.
// You hold this lock when navigating down the list (to find
// the THREAD_ENTRY for your thread) and when navigating
// across the per-thread entry to find the entry for your connection.
// Once you get the ERROR_ENTRY or LDAP_ATTR_NAME_THREAD_STORAGE for
// your connection, you don't need to hold it.  Since the entries
// are per-thread, per-connection, there are only 2 ways something
// could come along and alter your entry out from under you:
//   (1) Something else running on the same thread.  This can't happen
//       because 2 things can't run on the same thread at the same time.
//
//   (2) The connection ref count being decreased to 0 by another thread
//       and the connection being destroyed (DereferenceLdapConnection2).
//       But as long as you're in code that holds a ref on the connection,
//       this can't happen.
//
// So you need to hold the lock while navigating the lists, to protect
// against the _lists_ changing due to thread attach/detach or a connection
// being destoryed, but you don't have to protect against your _entry_
// changing.
//

#define LDAP_BIND_TIME_LIMIT_DEFAULT  (30*1000)
#define LDAP_SSL_NEGOTIATE_TIME_DEFAULT 30
#define LDAP_TIME_LIMIT_DEFAULT 0
#define CLDAP_DEFAULT_RETRY_COUNT 4
#define CLDAP_DEFAULT_TIMEOUT_COUNT 3
#define LDAP_REF_DEFAULT_HOP_LIMIT 32
#define LDAP_SERVER_PORT 389
#define LDAP_SERVER_PORT_SSL 636

#define GETHOSTBYNAME_RETRIES 3
#define GETHOSTBYADDR_RETRIES 3

#define INITIAL_MAX_RECEIVE_BUFFER 4096  // increased to handle bigger UDP packets
#define INITIAL_HEAP (16*1024)

#define LDAP_MAX_WAIT_TIME INFINITE
#define LDAP_ERROR_STR_LENGTH 100
#define LDAP_MAX_ERROR_STRINGS (LDAP_REFERRAL_LIMIT_EXCEEDED+1)

#define MAX_ATTRIBUTE_NAME_LENGTH 800

//
//  The following Authentication methods are defined for Microsoft Normandy
//  Compatibility.  Send a bind request with auth method of BIND_SSPI_NEGOTIATE
//  and null for user name and credentials and we'll negotiate common SSPI
//  providers with the server.
//

#define BIND_SSPI_PACKAGEREQ            0x89    // context specific + primitive
#define BIND_SSPI_NEGOTIATE             0x8a    // context specific + primitive
#define BIND_SSPI_RESPONSE              0x8b    // context specific + primitive

extern WCHAR LdapErrorStringsW[LDAP_MAX_ERROR_STRINGS][LDAP_ERROR_STR_LENGTH];
extern CHAR LdapErrorStrings[LDAP_MAX_ERROR_STRINGS][LDAP_ERROR_STR_LENGTH];

//
//  Security support
//

extern ULONG   NumberSecurityPackagesInstalled;
extern ULONG   NumberSslPackagesInstalled;
extern PSecurityFunctionTableW SspiFunctionTableW;
extern PSecurityFunctionTableW SslFunctionTableW;
extern PSecurityFunctionTableA SspiFunctionTableA;
extern PSecurityFunctionTableA SslFunctionTableA;
extern PSecPkgInfoW SslPackagesInstalled;
extern PSecPkgInfoW SecurityPackagesInstalled;
extern PSecPkgInfoW SspiPackageNegotiate;
extern PSecPkgInfoW SspiPackageKerberos;
extern PSecPkgInfoW SspiPackageSslPct;
extern PSecPkgInfoW SspiPackageSicily;
extern PSecPkgInfoW SspiPackageNtlm;
extern PSecPkgInfoW SspiPackageDpa;
extern PSecPkgInfoW SspiPackageDigest;
extern ULONG SspiMaxTokenSize;

//
//  This socket is used to wake up our thread in select to come and reread
//  the list of handles to wait on.
//

extern SOCKET LdapGlobalWakeupSelectHandle;
extern BOOLEAN InsideSelect;


extern DWORD GlobalTlsLastErrorIndex;

#define LANG_UNICODE    0
#define LANG_ACP        1
#define LANG_UTF8       2

//
//  Keep alive logic defaults/min/max
//
//  The current default/min/max for these values are as follows :
//
//  PING_KEEP_ALIVE :  120/5/maxInt  seconds (may also be zero)
//  PING_WAIT_TIME  :  2000/10/60000 milliseconds (may also be zero)
//  PING_LIMIT      :  4/0/maxInt

#define LDAP_PING_KEEP_ALIVE_DEF  120
#define LDAP_PING_KEEP_ALIVE_MIN  5
#define LDAP_PING_KEEP_ALIVE_MAX  ((ULONG) -1)

#define LDAP_PING_WAIT_TIME_DEF 2000
#define LDAP_PING_WAIT_TIME_MIN 10
#define LDAP_PING_WAIT_TIME_MAX 60000

#define LDAP_PING_LIMIT_DEF 4
#define LDAP_PING_LIMIT_MIN 1
#define LDAP_PING_LIMIT_MAX ((ULONG) -1)

#define LDAP_REQUEST_RESEND_LIMIT_DEF 20

// globals.h eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\lmacros.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    lmacro.h   LDAP client 32 API macros

Abstract:

   This module contains macros for the 32 bit LDAP client API code.

Author:

    Andy Herron (andyhe)        08-May-1996

Revision History:

--*/


#ifndef LDAP_CLIENT_MACROS_DEFINED
#define LDAP_CLIENT_MACROS_DEFINED

#define LDAP_LOCK           CRITICAL_SECTION
#define INITIALIZE_LOCK(x)  InitializeCriticalSection(x);
#define DELETE_LOCK(x)      DeleteCriticalSection(x);
#define ACQUIRE_LOCK(x)     EnterCriticalSection(x);
#define RELEASE_LOCK(x)     LeaveCriticalSection(x);

//
// The following stringizing macro will expand the value of a
// #define passed as a parameter.  For example, if SOMEDEF is
// #define'd to be 123, then STRINGIZE(SOMEDEF) will produce
// "123", not "SOMEDEF"
//
#define STRINGIZE(y)          _STRINGIZE_helper(y)
#define _STRINGIZE_helper(z)  #z

#define DereferenceLdapConnection( _conn ) {                            \
        ACQUIRE_LOCK( &(_conn)->StateLock );                            \
        ASSERT((_conn)->ReferenceCount > 0);                            \
        (_conn)->ReferenceCount--;                                      \
        IF_DEBUG(REFCNT) {                                              \
            LdapPrint2("LDAP deref conn 0x%x, new count = 0x%x\n",      \
                    _conn,(_conn)->ReferenceCount );                    \
        }                                                               \
        if ((_conn)->ReferenceCount == 0) {                             \
            RELEASE_LOCK( &(_conn)->StateLock );                        \
            DereferenceLdapConnection2( _conn );                        \
        }                                                               \
        else {                                                          \
            RELEASE_LOCK( &(_conn)->StateLock );                        \
        }                                                               \
    }

#define is_cldap( _conn ) (( (_conn)->UdpHandle != INVALID_SOCKET ) ? TRUE : FALSE )

#define get_socket( _conn ) (( (_conn)->UdpHandle != INVALID_SOCKET ) ? \
                               (_conn)->UdpHandle : (_conn)->TcpHandle )


#define DereferenceLdapRequest( _req ) {                                \
        ACQUIRE_LOCK( &(_req)->Lock );                                  \
        ASSERT((_req)->ReferenceCount > 0);                             \
        (_req)->ReferenceCount--;                                       \
        IF_DEBUG(REFCNT) {                                              \
            LdapPrint2("LDAP deref req 0x%x, new count = 0x%x\n",       \
                    _req,(_req)->ReferenceCount );                      \
        }                                                               \
        if ((_req)->ReferenceCount == 0) {                              \
            RELEASE_LOCK( &(_req)->Lock );                              \
            DereferenceLdapRequest2( _req );                            \
        }                                                               \
        else {                                                          \
            RELEASE_LOCK( &(_req)->Lock );                              \
        }                                                               \
    }


//
// Warning! Do not hold any global locks before calling BeginSocketProtection
//

#define BeginSocketProtection( _conn ) {                                \
        ACQUIRE_LOCK( &SelectLock2 );                                   \
        LdapWakeupSelect();                                             \
        ACQUIRE_LOCK( &SelectLock1 );                                   \
        ACQUIRE_LOCK( &((_conn)->SocketLock) );                         \
}

#define EndSocketProtection( _conn ) {                                  \
        RELEASE_LOCK( &((_conn)->SocketLock) );                         \
        RELEASE_LOCK( &SelectLock1 );                                   \
        RELEASE_LOCK( &SelectLock2 );                                   \
}

//
// used in LdapParallelConnect to clean up useless sockets
//

#define LdapCleanupSockets( _numsockets ) {                             \
ULONG _i;                                                               \
for (_i = 0; _i < _numsockets; _i++) {                                  \
   if (sockarray[_i].sock == INVALID_SOCKET) {                          \
      continue;                                                         \
   }                                                                    \
   sockErr = (*pclosesocket)( sockarray[_i].sock );                     \
   ASSERT(sockErr == 0);                                                \
   sockarray[_i].sock = INVALID_SOCKET;                                 \
}                                                                       \
}

//
//  define ListEntry macros here since we're also compiling for Win9x.
//

//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.  We pick them up here because
//  the build breaks when we include ntrtl.h.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
// We will leave the upper 7 bits for the referral instance number. That
// leaves 2^25 == 33 million message numbers.
//

#define GET_NEXT_MESSAGE_NUMBER( _msg ) {                               \
    _msg = 0;                                                           \
    if ((GlobalMessageNumber + 1) & 0xFE000000) {                       \
        GlobalMessageNumber = 0;                                        \
        MessageNumberHasWrapped = TRUE;                                 \
    }                                                                   \
    if (GlobalWin9x) {                                                  \
        while ((_msg == 0) || (_msg == (ULONG) -1)) {                   \
            LONG _prev = GlobalMessageNumber;                           \
            _msg = ++GlobalMessageNumber;                               \
            if (_prev + 1 != _msg ) {                                   \
                _msg = 0;                                               \
            }                                                           \
        }                                                               \
    } else {                                                            \
        while ((_msg == 0) || (_msg == (ULONG) -1)) {                   \
            if ( MessageNumberHasWrapped ) {                            \
                do {                                                    \
                    _msg = InterlockedIncrement( &GlobalMessageNumber );\
                        if ((_msg)&(0xFE000000)) {                      \
                            GlobalMessageNumber = 0;                    \
                        }                                               \
                } while (!IsMessageIdValid ((_msg)));                   \
            } else {                                                    \
                _msg = InterlockedIncrement( &GlobalMessageNumber );    \
            }                                                           \
        }                                                               \
    }                                                                   \
}

#define GET_BASE_MESSAGE_NUMBER( _msgNo ) ((ULONG) ( (_msgNo) & 0x01FFFFFF ) )
#define GET_REFERRAL_NUMBER( _msgNo ) ((ULONG) ( (_msgNo) & 0xFE000000 ) >> 25)

#define MAKE_MESSAGE_NUMBER( _base, _referral ) ((ULONG)(_base+((_referral) << 25)))

extern CHAR LdapHexToCharTable[17];

#define MAPHEXTODIGIT(x) ( x >= '0' && x <= '9' ? (x-'0') :        \
                           x >= 'A' && x <= 'F' ? (x-'A'+10) :     \
                           x >= 'a' && x <= 'f' ? (x-'a'+10) : 0 )

#define ISHEX(x)         ( x >= '0' && x <= '9' ? (TRUE) :     \
                           x >= 'A' && x <= 'F' ? (TRUE) :     \
                           x >= 'a' && x <= 'f' ? (TRUE) : FALSE )

#define RealValue( x )   ( PtrToUlong(x) > 1024 ? *((ULONG *) x) : PtrToUlong(x) )


#define IsLdapInteger( x ) ( (x >= 0 ) && (x <= 2147483647) ? TRUE : FALSE )

#endif  // LDAP_CLIENT_MACROS_DEFINED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\ldapber.cxx ===
/*--------------------------------------------------------------------------
    ldapber.cxx

        This module contains the implementation for the LDAP Basic Encoding
        Rules (BER) class.  It is intended to be built for both client and
        server.

    Copyright (C) 1993 Microsoft Corporation
    All rights reserved.

    Authors:
        robertc     Rob Carney

    History:
        04-17-96    robertc     Created.
  --------------------------------------------------------------------------*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

#define MIN_LDAP_MSG_SIZE 6


VOID *CLdapBer::operator new (
    size_t cSize
    )
{
    return ldapMalloc( (DWORD) cSize, LDAP_LDAP_CLASS_SIGNATURE );
}

VOID CLdapBer::operator delete (
    VOID *pInstance
    )
{
    ldapFree( pInstance, LDAP_LDAP_CLASS_SIGNATURE );
    return;
}

//
// CLdapBer Implementation
//
CLdapBer::CLdapBer (
    ULONG  LdapVersion
    )
{
    m_cbData    = 0;
    m_cbDataMax = 0;
    m_pbData    = NULL;
    m_iCurrPos  = 0;
    m_cbSeq     = 0;
    m_iSeqStart = 0;
    m_bytesReceived = 0;
    m_dnOffset  = 0;
    m_isCopy = FALSE;
    m_OverridingTag = 0;

    if (LdapVersion == LDAP_VERSION2) {

        m_CodePage = CP_ACP;

    } else {

        m_CodePage = CP_UTF8;
    }

    m_iCurrSeqStack = 0;
}


CLdapBer::~CLdapBer()
{
    Reset();

    if (m_pbData && ( ! m_isCopy)) {
        ldapFree(m_pbData, LDAP_LBER_SIGNATURE );
    }
    m_pbData = NULL;
    m_cbDataMax = 0;
}

ULONG
CLdapBer::CopyExistingBERStructure ( CLdapBer *lber )
//
//  This copies the main BER structure but doesn't copy the data since
//  we can share the buffer.
//
{
    m_cbData    = lber->m_cbData;
    m_cbDataMax = lber->m_cbDataMax;
    m_pbData    = lber->m_pbData;
    m_iCurrPos  = 0;
    m_cbSeq     = 0;
    m_iSeqStart = 0;
    m_bytesReceived = lber->m_bytesReceived;
    m_dnOffset  = lber->m_dnOffset;
    m_isCopy = TRUE;

    m_iCurrSeqStack = 0;

    return NOERROR;
}



/*!-------------------------------------------------------------------------
    CLdapBer::Reset
        Resets the class and frees any associated memory.
  ------------------------------------------------------------------------*/
void CLdapBer::Reset(BOOLEAN FullReset /* =FALSE */)
{
    if (FullReset == TRUE) {

        m_dnOffset  = 0;
        m_cbData    = 0;
        m_bytesReceived = 0;
    }
    m_iCurrPos  = 0;
    m_cbSeq     = 0;
    m_iSeqStart = 0;

    m_iCurrSeqStack = 0;
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrLoadBer
        This routine loads the BER class from an input source data buffer
        that was received from the server.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrLoadBer(    const BYTE *pbSrc,
                                ULONG cbSrc,
                                ULONG *BytesTaken,
                                BOOLEAN HaveWholeMessage,
                                BOOLEAN IgnoreTag /*=FALSE*/
                                )
{
    ULONG hr;
    ULONG   bytesToTake = cbSrc;
    ULONG   messageLength;
    ULONG   bytesToAlloc;

    Reset(TRUE);

    //
    //  We may not need the entire buffer... check the first couple of
    //  bytes to get the total length of the message.
    //

    if (cbSrc < MIN_LDAP_MSG_SIZE && (HaveWholeMessage== FALSE)) {

        //
        //  this is just a partial message... copy the whole thing off but
        //  leave length indeterminate.
        //

        messageLength = 0;
        bytesToAlloc = MIN_LDAP_MSG_SIZE;

    } else {

        //
        //  we know that the message is formed as follows :
        //      BER_SEQUENCE    length 1  0x30
        //  followed by ASN.1 encoding of message length
        //

        if ((!IgnoreTag) && (*pbSrc != BER_SEQUENCE)) {

            return LDAP_DECODING_ERROR;
        }

        hr = Asn1GetPacketLength( (PUCHAR) pbSrc, cbSrc, &messageLength );
        if (hr != NOERROR) {
            return hr;
        }

        if (messageLength < bytesToTake) {

            bytesToTake = messageLength;
        }

        bytesToAlloc = 0;
    }

    m_cbData = m_cbSeq = messageLength;

    hr = HrEnsureBuffer( bytesToAlloc, TRUE); // length is picked up in m_cbData
    if (hr != 0) {
        return hr;
    }

    CopyMemory(m_pbData, pbSrc, bytesToTake);

    *BytesTaken = m_bytesReceived = bytesToTake;

    return NOERROR;
}

/*!-------------------------------------------------------------------------
    CLdapBer::HrLoadMoreBer
        This routine loads the BER class from an input source data buffer
        that was received from the server.  It loads subsequent packets
        into the buffer.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrLoadMoreBer(const BYTE *pbSrc, ULONG cbSrc, ULONG *BytesTaken)
{
    ULONG hr;
    ULONG   bytesToTake;

    if (m_cbData == 0) {

        ULONG   messageLength;

        //
        //  we don't know the total message length yet.  So let's copy enough
        //  of the data to be able to get the packet length.
        //

        if ( m_bytesReceived < MIN_LDAP_MSG_SIZE ) {

            bytesToTake = MIN_LDAP_MSG_SIZE - m_bytesReceived;

            if (cbSrc < bytesToTake) {

                //
                //  we're receiving the data a few bytes at
                //  a time... oh well, we live with it.  Just copy the data
                //  into the buffer and we'll pick up the length next time.
                //

                CopyMemory(m_pbData+m_bytesReceived, pbSrc, cbSrc);

                m_bytesReceived += cbSrc;
                *BytesTaken = cbSrc;
                return NOERROR;
            }

            //
            //  without updating any counts, we copy over enough data to
            //  determine the length of the packet.  We update the received
            //  data count below when we copy it over again.
            //

            CopyMemory(m_pbData+m_bytesReceived, pbSrc, bytesToTake);
        }

        //
        //  we know that the message is formed as follows :
        //      BER_SEQUENCE    length 1  0x30
        //  followed by ASN.1 encoding of message length
        //

        if (*m_pbData != BER_SEQUENCE) {

            return LDAP_DECODING_ERROR;
        }

        // At this point, we're guaranteed to have at least MIN_LDAP_MSG_SIZE bytes
        // in the buffer (we could have more, but it doesn't matter for Asn1GetPacketLength)
        hr = Asn1GetPacketLength( (PUCHAR) m_pbData, MIN_LDAP_MSG_SIZE, &messageLength );
        if (hr != NOERROR) {
            return hr;
        }

        m_cbData = m_cbSeq = messageLength;
    }

    bytesToTake = m_cbData - m_bytesReceived;

    //
    //  if we don't have enough for the remainder of the message, take all
    //  of what was passed in.
    //

    if (cbSrc < bytesToTake) {

        bytesToTake = cbSrc;
    }

    hr = HrEnsureBuffer( 0, TRUE);      // length is in m_cbData
    if (hr != 0) {
        return hr;
    }

    CopyMemory(m_pbData+m_bytesReceived, pbSrc, bytesToTake);

    m_bytesReceived += bytesToTake;
    *BytesTaken = bytesToTake;

    return NOERROR;
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrStartReadSequence
        Start a sequence for reading.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrStartReadSequence(ULONG ulTag/*=BER_SEQUENCE*/, BOOLEAN IgnoreTag/*=FALSE*/) 
{
    ULONG   hr;
    ULONG   iPos, cbLength;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrStartReadSequence ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    if ( !IgnoreTag ) {
        
        if ((ULONG)m_pbData[m_iCurrPos] != ulTag)
            {
                IF_DEBUG(BER) {
                    LdapPrint2( "HrStartReadSequence expected tag of 0x%x, received 0x%x.\n",
                                ulTag, (ULONG)m_pbData[m_iCurrPos] );
                }
                
                return E_INVALIDARG;
            }
        
    }
    
    m_iCurrPos++;           // Skip over the tag.

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrStartReadSequence 2 ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return E_INVALIDARG;
    }
    

    GetCbLength(&cbLength); // Get the # bytes in the length field.

    hr = HrPushSeqStack(m_iCurrPos, cbLength, m_iSeqStart, m_cbSeq);

    if (hr == NOERROR) {

        // Get the length of the sequence.
        hr = HrGetLength(&m_cbSeq);
        if (hr != 0) {

            HrPopSeqStack(&iPos, &cbLength, &m_iSeqStart, &m_cbSeq);

        } else {

            m_iSeqStart = m_iCurrPos;   // Set to the first position in the sequence.
        }
    }

    if (m_iCurrPos > m_cbData)
    {
//      ASSERT(m_iCurrPos <= m_cbData);
        hr = E_INVALIDARG;
    }

    return hr;
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrEndReadSequence
        Ends a read sequence and restores the current sequence counters.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrEndReadSequence()
{
    ULONG       cbSeq;
    ULONG       iPos, cbLength;
    ULONG     hr;

    hr = HrPopSeqStack(&m_iCurrPos, &cbLength, &m_iSeqStart, &m_cbSeq);

    // Now position the current position to the end of the sequence.
    // m_iCurrPos is now pointing to the length field of the sequence.
    iPos = m_iCurrPos;

    if (hr == NOERROR) {

        hr = HrGetLength(&cbSeq);
        if (hr == NOERROR) {

            // Set the current position to the end of the sequence.
            m_iCurrPos = iPos + cbSeq + cbLength;
            if (m_iCurrPos > m_cbData)
                hr = E_INVALIDARG;
            }
        }

    return hr;
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrStartWriteSequence
        Start a sequence for writing.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrStartWriteSequence(ULONG ulTag/*=BER_SEQUENCE*/)
{
    ULONG hr;
    ULONG   cbLength = 5;   // Defaults to 4 byte lengths

    if (m_OverridingTag) {

       ulTag = m_OverridingTag;
       m_OverridingTag = 0;
    }

    hr = HrEnsureBuffer(cbLength + 1);

    if (hr != 0) {
        return hr;
    }

    m_pbData[m_iCurrPos++] = (BYTE)ulTag;

    hr = HrPushSeqStack(m_iCurrPos, cbLength, m_iSeqStart, m_cbSeq);

    m_iCurrPos += cbLength; // Skip over length
    m_cbData = m_iCurrPos;  // update total length of data

    return hr;
}

/*!-------------------------------------------------------------------------
    CLdapBer::HrAddTag
        Add a tag... used for unbind
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrAddTag(ULONG ulTag)
{
    ULONG hr;

    hr = HrEnsureBuffer(2);

    if (hr != 0) {
        return hr;
    }

    m_pbData[m_iCurrPos++] = (BYTE)ulTag;
    m_pbData[m_iCurrPos++] = '\0';
    m_cbData = m_iCurrPos;

    return hr;
}

/*!-------------------------------------------------------------------------
    CLdapBer::HrEndWriteSequence
        Ends a write sequence, by putting the sequence length field in.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrEndWriteSequence()
{
    ULONG     hr;
    ULONG       cbSeq;
    ULONG       iPos, iPosSave, cbLength;

    if (m_OverridingTag) {
       
       //
       // We can't override the End sequence. This has to be an error
       //

       return E_INVALIDARG;
    }

    hr = HrPopSeqStack(&iPos, &cbLength, &m_iSeqStart, &m_cbSeq);

    if (hr == NOERROR) {

        // Get the length of the current sequence.
        cbSeq = m_iCurrPos - iPos - cbLength;

        // Save & set the current position.
        iPosSave = m_iCurrPos;
        m_iCurrPos = iPos;

        hr = HrSetLength(cbSeq, cbLength);
        m_iCurrPos = iPosSave;
    }

    return hr;
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrPushSeqStack
        Pushes the current value on the sequence stack.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrPushSeqStack(ULONG iPos, ULONG cbLength, ULONG iParentSeqStart, ULONG cbParentSeq)
{

    ASSERT(m_iCurrSeqStack < MAX_BER_STACK);
    if (m_iCurrSeqStack >= MAX_BER_STACK)
        return E_OUTOFMEMORY;

    m_rgiSeqStack[m_iCurrSeqStack].iPos     = iPos;
    m_rgiSeqStack[m_iCurrSeqStack].cbLength = cbLength;
    m_rgiSeqStack[m_iCurrSeqStack].iParentSeqStart = iParentSeqStart;
    m_rgiSeqStack[m_iCurrSeqStack].cbParentSeq     = cbParentSeq;
    m_iCurrSeqStack++;

    return NOERROR;
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrPopSeqStack
        Ends a read sequence.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrPopSeqStack(ULONG *piPos, ULONG *pcbLength, ULONG *piParentSeqStart, ULONG *pcbParentSeq)
{
    if (m_iCurrSeqStack == 0)
    {
        ASSERT(m_iCurrSeqStack != 0);
        return E_INVALIDARG;
    }

    --m_iCurrSeqStack;
    *piPos     = m_rgiSeqStack[m_iCurrSeqStack].iPos;
    *pcbLength = m_rgiSeqStack[m_iCurrSeqStack].cbLength;
    *piParentSeqStart = m_rgiSeqStack[m_iCurrSeqStack].iParentSeqStart;
    *pcbParentSeq     = m_rgiSeqStack[m_iCurrSeqStack].cbParentSeq;

    return NOERROR;
}



/*!-------------------------------------------------------------------------
    CLdapBer::HrSkipElement
        This routine skips over the current BER tag and value.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrSkipElement()
{
    //
    //  an element is made up of a tag, a length, and a value.  we'll
    //  skip the tag, find out what the length is, and then skip the value.
    //

    ULONG hr;
    ULONG   cb;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrSkipElement ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    m_iCurrPos++;       // skip tag

    // Don't need to check m_iCurrPos < m_cbData here after the increment, HrGetLength
    // will do it for us

    hr = HrGetLength(&cb);

    if ((hr == NOERROR) && (m_iCurrPos < m_cbData)) {

        m_iCurrPos += cb;
    }

    return hr;
}

/*!-------------------------------------------------------------------------
    CLdapBer::HrSkipTag
        Skips over the current tag.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrSkipTag()
{
    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrSkipTag ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    m_iCurrPos++;

    return NOERROR;
}



/*!-------------------------------------------------------------------------
    CLdapBer::HrPeekTag
        This routine gets the current tag, but doesn't increment the
        current position.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrPeekTag(ULONG *pulTag)
{
    ULONG   iPos;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrPeekTag ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    iPos = m_iCurrPos;

    *pulTag = (ULONG)m_pbData[iPos];

    return NOERROR;
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrGetValue
        This routine gets an integer value from the current BER entry.  The
        default tag is an integer, but can Tagged with a different value
        via ulTag.
        Returns: NOERROR, E_INVALIDARG, E_OUTOFMEMORY
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrGetValue(LONG *pi, ULONG ulTag/*=BER_INTEGER*/, BOOLEAN IgnoreTag/*=FALSE*/) 
{
    ULONG hr;
    ULONG   cb;
    ULONG   ul;
    ULONG currentOffset = m_iCurrPos;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetValue ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    ul = (ULONG)m_pbData[m_iCurrPos]; // TAG

    if (!IgnoreTag && (ul != ulTag)) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetValue expected tag of 0x%x, received 0x%x.\n",
                        ulTag, ul );
        }
        return E_INVALIDARG;
    }

    m_iCurrPos++;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetValue ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        m_iCurrPos = currentOffset;
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    hr = HrGetLength(&cb);

    if ((hr == NOERROR) && (m_iCurrPos < m_cbData))
    {
        // We don't have to check that there are sufficient (cb) bytes in the buffer
        // here to hold the int, HrGetLength would have done that before returning
        hr = GetInt(m_pbData + m_iCurrPos, cb, pi);
        m_iCurrPos += cb;
    }

    if (hr != NOERROR) {
        m_iCurrPos = currentOffset;
    }
    return hr;
}


ULONG CLdapBer::HrGetValueWithAlloc(PCHAR *szValue, BOOLEAN IgnoreTag/*=FALSE*/)
{
    ULONG hr;
    ULONG   cb;
    PCHAR   buffer;
    ULONG currentOffset = m_iCurrPos;

    *szValue = NULL;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetValueWithAlloc ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    if ( !IgnoreTag ) {
        
        if (m_pbData[m_iCurrPos] != BER_OCTETSTRING) {
            
            IF_DEBUG(BER) {
                LdapPrint1( "HrGetValueWithAlloc got tag of 0x%x.\n",
                            m_pbData[m_iCurrPos] );
            }
            return LDAP_DECODING_ERROR;
        }
        
    }

    m_iCurrPos++;          // skip tag

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetValueWithAlloc ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        m_iCurrPos = currentOffset;
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    hr = HrGetLength(&cb);  // HrGetLength will check for sufficient bytes in buffer
                            // to hold cb-length string before returning

    if ((hr == NOERROR) && (cb == 0) && (m_iCurrPos < m_cbData)) {
        // zero-length string
        *szValue = (PCHAR) ldapMalloc( 1, LDAP_VALUE_SIGNATURE );
        if (!(*szValue)) {
            return LDAP_NO_MEMORY;
        }

        (*szValue)[0] = '\0';
        return NOERROR;
    }

    if ((hr == NOERROR) && (m_iCurrPos < m_cbData)) {

        //
        //  convert from UTF-8 to ANSI if required...  unfortunately there's
        //  no real quick way.
        //

        if (m_CodePage == CP_UTF8) {

            PWCHAR uniString = NULL;
            buffer = NULL;

            hr = ToUnicodeWithAlloc( (PCHAR) (m_pbData + m_iCurrPos),
                                     cb,
                                     &uniString,
                                     LDAP_UNICODE_SIGNATURE,
                                     LANG_UTF8 );

            if (hr == NOERROR) {

                hr = FromUnicodeWithAlloc(  uniString,
                                            &buffer,
                                            LDAP_VALUE_SIGNATURE,
                                            LANG_ACP
                                            );
            }
            ldapFree( uniString, LDAP_UNICODE_SIGNATURE );

            if (buffer == NULL) {

                hr = LDAP_NO_MEMORY;

            } else {

                *szValue = buffer;
                m_iCurrPos += cb;
            }
        } else {

            buffer = (PCHAR) ldapMalloc( cb + 1, LDAP_VALUE_SIGNATURE );

            if (buffer == NULL) {

                hr = LDAP_NO_MEMORY;

            } else {

                // Get the string.
                CopyMemory(buffer, m_pbData + m_iCurrPos, cb);
                *(buffer+cb) = '\0';
                *szValue = buffer;
                m_iCurrPos += cb;
            }
        }
    }

    if (hr != NOERROR) {
        m_iCurrPos = currentOffset;
    }
    return hr;
}

ULONG CLdapBer::HrGetValueWithAlloc(PWCHAR *szValue, BOOLEAN IgnoreTag/*=FALSE*/)
{
    ULONG hr;
    ULONG   cb;
    PWCHAR   buffer;
    ULONG currentOffset = m_iCurrPos;
    int err, required;

    *szValue = NULL;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetValueWithAlloc ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    if ( !IgnoreTag ) {
        
        if (m_pbData[m_iCurrPos] != BER_OCTETSTRING) {
            
            IF_DEBUG(BER) {
                LdapPrint1( "HrGetValueWithAlloc got tag of 0x%x.\n",
                            m_pbData[m_iCurrPos] );
            }
            return LDAP_DECODING_ERROR;
        }

    }
        
    m_iCurrPos++;          // skip tag

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetValueWithAlloc ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        m_iCurrPos = currentOffset;
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    hr = HrGetLength(&cb);  // HrGetLength will check for sufficient bytes in buffer
                            // to hold cb-length string before returning

    if ((hr == NOERROR) && (cb == 0) && (m_iCurrPos < m_cbData)) {
        // zero-length string
        *szValue = (PWCHAR) ldapMalloc( 1*sizeof(WCHAR), LDAP_VALUE_SIGNATURE );
        if (!(*szValue)) {
            return LDAP_NO_MEMORY;
        }

        (*szValue)[0] = L'\0';
        return NOERROR;
    }

    if ((hr == NOERROR) && (m_iCurrPos < m_cbData)) {

        if (m_CodePage == CP_UTF8) {

            required = LdapUTF8ToUnicode( (const char *) (m_pbData + m_iCurrPos),
                                       cb,
                                       NULL,
                                       0 );

        } else {

            required = MultiByteToWideChar( m_CodePage,
                                            0,
                                            (const char *) (m_pbData + m_iCurrPos),
                                            cb,
                                            NULL,
                                            0 );
        }
        
        if ((required == 0) && (err = GetLastError())) {

            IF_DEBUG(BER) {
                LdapPrint1( "HrGetValueWithAlloc received error of 0x%x from MultiByteToWideChar.\n",
                                err );
            }

            switch (err) {
            case ERROR_INSUFFICIENT_BUFFER:
                hr = E_INVALIDARG;
                break;
            case ERROR_NO_UNICODE_TRANSLATION:
                hr = LDAP_DECODING_ERROR;
                break;
            default:
                hr = LDAP_LOCAL_ERROR;
            }

        } else {

            buffer = (PWCHAR) ldapMalloc( (required + 1) * sizeof(WCHAR), LDAP_VALUE_SIGNATURE );

            if (buffer == NULL) {

                hr = LDAP_NO_MEMORY;

            } else {

                if (m_CodePage == CP_UTF8) {

                    err = LdapUTF8ToUnicode( (const char *) (m_pbData + m_iCurrPos),
                                         cb,
                                         buffer,
                                         (required + 1)  );
                } else {

                    err = MultiByteToWideChar( m_CodePage,
                                               0,
                                               (const char *) (m_pbData + m_iCurrPos),
                                               cb,
                                               buffer,
                                               (required + 1) );
                }
                
                if ((err == 0) && (err = GetLastError())){

                    IF_DEBUG(BER) {
                        LdapPrint1( "HrGetValue received error of 0x%x from MultiByteToWideChar.\n",
                                        err );
                    }

                    switch (err) {
                    case ERROR_INSUFFICIENT_BUFFER:
                        hr = E_INVALIDARG;
                        break;
                    case ERROR_NO_UNICODE_TRANSLATION:
                        hr = LDAP_DECODING_ERROR;
                        break;
                    default:
                        hr = LDAP_LOCAL_ERROR;
                    }

                    // don't leak the buffer
                    ldapFree(buffer, LDAP_VALUE_SIGNATURE);
                    buffer = NULL;
                }
                else {

                    *(buffer+required) = L'\0';
                    *szValue = buffer;
                    m_iCurrPos += cb;
                }
            }
        }
    }

    if (hr != NOERROR) {
        m_iCurrPos = currentOffset;
    }
    return hr;
}


ULONG CLdapBer::HrGetValueWithAlloc(struct berval **pValue, BOOLEAN IgnoreTag/*=FALSE*/) 
{
    ULONG hr;
    ULONG   cb;
    PCHAR   buffer;
    struct berval *bval;
    ULONG currentOffset = m_iCurrPos;

    *pValue = NULL;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetValueWithAlloc ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    if ( !IgnoreTag ) {
        
        if (m_pbData[m_iCurrPos] != BER_OCTETSTRING) {

            IF_DEBUG(BER) {
                LdapPrint1( "HrGetValueWithAlloc got tag of 0x%x.\n",
                            m_pbData[m_iCurrPos] );
            }
            return LDAP_DECODING_ERROR;
        }

    }
        
    m_iCurrPos++;          // skip tag

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetValueWithAlloc ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        m_iCurrPos = currentOffset;
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    hr = HrGetLength(&cb);  // HrGetLength will check for sufficient bytes in buffer
                            // to hold cb-length binary data before returning

    if ((hr == NOERROR) && (m_iCurrPos < m_cbData)) {

        bval = (struct berval *) ldapMalloc( sizeof(struct berval) + cb + 1,
                                             LDAP_VALUE_SIGNATURE );

        if (bval == NULL) {

            hr = LDAP_NO_MEMORY;

        } else {

            buffer = ((PCHAR) bval) + sizeof(struct berval);
            bval->bv_len = cb;
            bval->bv_val = buffer;

            // Get the string.
            CopyMemory(buffer, m_pbData + m_iCurrPos, cb);
            *(buffer+cb) = '\0';
            *pValue = bval;
            m_iCurrPos += cb;
        }
    }

    if (hr != NOERROR) {
        m_iCurrPos = currentOffset;
    }
    return hr;
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrGetValue
        This routine gets a string value from the current BER entry.  If
        the current BER entry isn't an integer type, then E_INVALIDARG is
        returned.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrGetValue(CHAR *szValue, ULONG cbValue, ULONG ulTag/*=BER_OCTETSTRING*/, BOOLEAN IgnoreTag/*=FALSE*/) 
{
    ULONG hr;
    ULONG   cb, ul;
    ULONG currentOffset = m_iCurrPos;

    szValue[0] = '\0';

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetValue ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    ul = (ULONG)m_pbData[m_iCurrPos]; // TAG

    if (!IgnoreTag && (ul != ulTag)) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetValue expected tag of 0x%x, received 0x%x.\n",
                        ulTag, ul );
        }
        return E_INVALIDARG;
    }

    m_iCurrPos++;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetValue ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        m_iCurrPos = currentOffset;
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    hr = HrGetLength(&cb); // HrGetLength will check for sufficient bytes in buffer
                           // to hold cb-length string before returning

    if ((hr == NOERROR) && (m_iCurrPos < m_cbData)) {

        if (m_CodePage == CP_UTF8) {

            PWCHAR uniString = NULL;

            hr = ToUnicodeWithAlloc( (PCHAR)(m_pbData + m_iCurrPos),
                                     cb,
                                     &uniString,
                                     LDAP_UNICODE_SIGNATURE,
                                     LANG_UTF8 );

            if (hr == NOERROR) {

                ULONG chars = LdapUnicodeToUTF8( uniString,
                                                 -1,
                                                 szValue,
                                                 cbValue
                                                 );

                hr = ((chars > 0) ? NOERROR : LDAP_NO_MEMORY);
            }
            ldapFree( uniString, LDAP_UNICODE_SIGNATURE );

        } else {

            if (cb >= cbValue) {

                ASSERT(cb < cbValue);
                hr = E_INVALIDARG;

            } else {

                // Get the string.
                CopyMemory(szValue, m_pbData + m_iCurrPos, cb);
                szValue[cb] = '\0';
                m_iCurrPos += cb;
            }
        }
    }

    if (hr != NOERROR) {
        m_iCurrPos = currentOffset;
    }

    return hr;
}

/*!-------------------------------------------------------------------------
    CLdapBer::HrGetValue
        This routine gets a string value from the current BER entry.  If
        the current BER entry isn't an integer type, then E_INVALIDARG is
        returned.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrGetValue(WCHAR *szValue, ULONG cchValue, ULONG ulTag/*=BER_OCTETSTRING*/, BOOLEAN IgnoreTag/*=FALSE*/)
{
    ULONG hr;
    ULONG   cb, ul;
    ULONG currentOffset = m_iCurrPos;

    szValue[0] = '\0';

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetValue ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    ul = (ULONG)m_pbData[m_iCurrPos]; // TAG

    if (!IgnoreTag && (ul != ulTag)) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetValue expected tag of 0x%x, received 0x%x.\n",
                        ulTag, ul );
        }
        return E_INVALIDARG;
    }

    m_iCurrPos++;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetValue ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        m_iCurrPos = currentOffset;
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    hr = HrGetLength(&cb);  // HrGetLength will check for sufficient bytes in buffer
                            // to hold cb-length string before returning

    if ((hr == NOERROR) && (m_iCurrPos < m_cbData)) {


        ULONG required;

        if (m_CodePage == CP_UTF8) {

            required = LdapUTF8ToUnicode( (const char *) (m_pbData + m_iCurrPos),
                                      cb,
                                      NULL,
                                      0 );

        } else {

            required = MultiByteToWideChar( m_CodePage,
                                            0,
                                            (const char *) (m_pbData + m_iCurrPos),
                                            cb,
                                            NULL,
                                            0 );
        }

        if (required >= cchValue) {

            hr = E_INVALIDARG;

        } else {

            ULONG wChars = cchValue;
            int err;

            if (m_CodePage == CP_UTF8) {

                err = LdapUTF8ToUnicode( (const char *) (m_pbData + m_iCurrPos),
                                     cb,
                                     szValue,
                                     wChars );
            } else {

                err = MultiByteToWideChar( m_CodePage,
                                           0,
                                           (const char *) (m_pbData + m_iCurrPos),
                                           cb,
                                           szValue,
                                           wChars );
            }
            if (err == 0) {

                err = GetLastError();

                IF_DEBUG(BER) {
                    LdapPrint1( "HrGetValue received error of 0x%x from MultiByteToWideChar.\n",
                                    err );
                }

                switch (err) {
                case ERROR_INSUFFICIENT_BUFFER:
                    hr = E_INVALIDARG;
                    break;
                case ERROR_NO_UNICODE_TRANSLATION:
                    hr = LDAP_DECODING_ERROR;
                    break;
                default:
                    hr = LDAP_LOCAL_ERROR;
                }
            } else {

                szValue[err] = L'\0';
            }

            szValue[wChars-1] = L'\0';
            m_iCurrPos += cb;
        }
    }

    if (hr != NOERROR) {

        m_iCurrPos = currentOffset;
    }

    return hr;
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrGetBinaryValue
        This routine gets a binary value from the current BER entry.  If
        the current BER entry isn't the right type, then E_INVALIDARG is
        returned.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrGetBinaryValue(BYTE *pbBuf, ULONG cbBuf,
                                   ULONG ulTag/*=BER_OCTETSTRING*/, PULONG pcbLength)
{
    ULONG hr;
    ULONG   cb, ul;
    ULONG currentOffset = m_iCurrPos;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetBinaryValue ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    ul = (ULONG)m_pbData[m_iCurrPos]; // TAG

    if (ul != ulTag)
    {
        IF_DEBUG(BER) {
            LdapPrint2( "HrGetBinaryValue expected tag of 0x%x, received 0x%x.\n",
                        ulTag, ul );
        }
        return E_INVALIDARG;
    }

    m_iCurrPos++;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetBinaryValue ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        m_iCurrPos = currentOffset;
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    hr = HrGetLength(&cb);  // HrGetLength will check for sufficient bytes in buffer
                            // to hold cb-length value before returning

    if ((hr == NOERROR) && (m_iCurrPos < m_cbData)) {

        if (cb >= cbBuf)
        {
            ASSERT(cb < cbBuf);
            hr = E_INVALIDARG;
        }
        else
        {
            // Get the string.
            CopyMemory(pbBuf, m_pbData + m_iCurrPos, cb);
            m_iCurrPos += cb;
            if ( pcbLength ) {
                *pcbLength = cb;
            }
        }
    }

    if (hr != NOERROR) {
        m_iCurrPos = currentOffset;
    }

    return hr;
}

/*!-------------------------------------------------------------------------
    CLdapBer::HrGetBinaryValuePointer
        This routine gets a pointer to a binary value from the current BER entry.
        If the current BER entry isn't the right type, then E_INVALIDARG is
        returned.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrGetBinaryValuePointer(PBYTE *ppbBuf, PULONG pcbBuf, ULONG ulTag/*=BER_OCTETSTRING*/, BOOLEAN IgnoreTag/*=FALSE*/)
{
    ULONG hr;
    ULONG   cb, ul;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetBinaryValuePointer ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    ul = (ULONG)m_pbData[m_iCurrPos]; // TAG

    if (!IgnoreTag && (ul != ulTag)) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetBinaryValue expected tag of 0x%x, received 0x%x.\n",
                        ulTag, ul );
        }
        return E_INVALIDARG;
    }

    m_iCurrPos++;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetBinaryValuePointer ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    hr = HrGetLength(&cb);  // HrGetLength will check for sufficient bytes in buffer
                            // to hold cb-length value before returning

    if ((hr == NOERROR) && (m_iCurrPos < m_cbData))
    {
        // Set the pointer.
        *ppbBuf = m_pbData + m_iCurrPos;
        *pcbBuf = cb;
        m_iCurrPos += cb;
    }

    return hr;
}

/*!-------------------------------------------------------------------------
    CLdapBer::HrGetEnumValue
        This routine gets an enumerated value from the current BER entry.  If
        the current BER entry isn't an enumerated type, then E_INVALIDARG is
        returned.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrGetEnumValue(LONG *pi)
{
    ULONG   hr;
    ULONG   cb;
    ULONG   ul;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetEnumValue ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    ul = (ULONG)m_pbData[m_iCurrPos]; // TAG

    if (ul != BER_ENUMERATED) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetEnumValue expected tag of 0x%x, received 0x%x.\n",
                        BER_ENUMERATED, ul );
        }
        return E_INVALIDARG;
    }

    m_iCurrPos++;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetEnumValue ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    hr = HrGetLength(&cb);  // HrGetLength will check for sufficient bytes in buffer
                            // to hold cb-length value before returning

    if ((hr == NOERROR) && (m_iCurrPos < m_cbData))
    {
        hr = GetInt(m_pbData + m_iCurrPos, cb, pi);
        m_iCurrPos += cb;
    }

    return hr;
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrGetStringLength
        This routine gets the length of the current BER entry, which is
        assumed to be a string.  If the current BER entry's tag doesn't
        match ulTag, E_INVALIDARG is returned
  ------------------------------------------------------------------------*/
ULONG
CLdapBer::HrGetStringLength(int *pcbValue, ULONG ulTag)
{
    ULONG   ul;
    int     iCurrPosSave = m_iCurrPos;
    ULONG   hr;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetStringLength ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    ul = (ULONG)m_pbData[m_iCurrPos]; // TAG

    if (ul != ulTag) {
        IF_DEBUG(BER) {
            LdapPrint2( "HrGetStringLength expected tag of 0x%x, received 0x%x.\n",
                        ulTag, ul );
        }
        return E_INVALIDARG;
    }

    m_iCurrPos++;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetStringLength ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    hr = HrGetLength((ULONG *)pcbValue);
    m_iCurrPos = iCurrPosSave;
    return hr;
}

/*!-------------------------------------------------------------------------
    CLdapBer::HrAddValue
        This routine puts an integer value in the BER buffer.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrAddValue(LONG i, ULONG ulTag/*=BER_INTEGER*/)
{
    ULONG hr;
    ULONG   cbInt;
    DWORD   dwMask = 0xff000000;
    DWORD   dwHiBitMask = 0x80000000;


    if (m_OverridingTag) {

       ulTag = m_OverridingTag;
       m_OverridingTag = 0;
    }

    if (i == 0)
    {
        cbInt = 1;
    }
    else
    {
        cbInt = sizeof(LONG);
        while (dwMask && !(i & dwMask))
        {
            dwHiBitMask >>= 8;
            dwMask >>= 8;
            cbInt--;
        }
        if (!(i & 0x80000000)) {

            //
            //  the value to insert was a positive number, make sure we allow
            //  for it by sending an extra bytes since it's not negative.
            //

            if (i & dwHiBitMask) {
                cbInt++;
            }

        }
    }

    hr = HrEnsureBuffer(1 + 5 + cbInt); // 1 for tag, 5 for length
    if (hr != 0) {
        return hr;
    }

    m_pbData[m_iCurrPos++] = (BYTE)ulTag;

    hr = HrSetLength(cbInt);
    if (hr == NOERROR) {

        AddInt(m_pbData + m_iCurrPos, cbInt, i);

        m_iCurrPos += cbInt;

        m_cbData = m_iCurrPos;
    }

    return hr;
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrAddValue
        Puts a string into the BER buffer.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrAddValue(const CHAR *szValue, ULONG ulTag)
{
    ULONG   hr;
    ULONG   cbValue;
    CHAR   nullStr = '\0';
    PWCHAR uniString = NULL;
    ULONG wLength = 0;

    if (m_OverridingTag) {

       ulTag = m_OverridingTag;
       m_OverridingTag = 0;
    }

    if (szValue == NULL) {

        szValue = &nullStr;
    }

    cbValue = (ULONG) strlen(szValue);

    if ((m_CodePage == CP_UTF8) && (cbValue > 0)) {

        hr = ToUnicodeWithAlloc( (PCHAR) szValue,
                                 cbValue,
                                 &uniString,
                                 LDAP_UNICODE_SIGNATURE,
                                 LANG_ACP );

        if (hr != NOERROR) {

            return hr;
        }

        wLength = strlenW( uniString );

        cbValue = LdapUnicodeToUTF8( uniString,
                                     wLength,
                                     NULL,
                                     0 );

        if (cbValue == 0) {

            ldapFree( uniString, LDAP_UNICODE_SIGNATURE );
            return LDAP_NO_MEMORY;
        }
    }

    hr = HrEnsureBuffer(1 + 5 + cbValue); // 1 for tag, 5 for len

    if (hr != 0) {
        ldapFree( uniString, LDAP_UNICODE_SIGNATURE );
        return hr;
    }

    m_pbData[m_iCurrPos++] = (BYTE)ulTag;

    hr = HrSetLength(cbValue);

    if (hr == NOERROR) {

        //
        //  convert from ANSI to UTF-8 if required...  unfortunately there's
        //  no real quick way.
        //

        if ((m_CodePage == CP_UTF8) && (cbValue > 0)) {

            cbValue = LdapUnicodeToUTF8( uniString,
                                         wLength,
                                         (PCHAR) (m_pbData + m_iCurrPos),
                                         cbValue
                                         );

            hr = ((cbValue > 0) ? NOERROR : LDAP_NO_MEMORY);
            ldapFree( uniString, LDAP_UNICODE_SIGNATURE );

        } else {

            CopyMemory(m_pbData + m_iCurrPos, szValue, cbValue);
        }

        m_iCurrPos += cbValue;
        m_cbData = m_iCurrPos;
    }

    return hr;
}

/*!-------------------------------------------------------------------------
    CLdapBer::HrAddValue
        Puts a string into the BER buffer.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrAddValue(const WCHAR *szValue, ULONG ulTag)
{
    ULONG hr;
    ULONG   cbValue;
    WCHAR   nullStr = L'\0';

    if (m_OverridingTag) {

       ulTag = m_OverridingTag;
       m_OverridingTag = 0;
    }
    
    if (szValue == NULL) {

        szValue = &nullStr;
    }

    ULONG wStrLen = strlenW( (PWCHAR) szValue );

    if (m_CodePage == CP_UTF8) {

        cbValue  = LdapUnicodeToUTF8( szValue,
                                  wStrLen,
                                  NULL,
                                  0 );

    } else {

        cbValue  = WideCharToMultiByte( m_CodePage,
                                        0,
                                        szValue,
                                        wStrLen,
                                        NULL,
                                        0,
                                        NULL,
                                        NULL );
    }

    if ((cbValue == 0) && (wStrLen > 0)) {

        int err = GetLastError();

        IF_DEBUG(BER) {
            LdapPrint1( "HrAddValue received error of 0x%x from WideCharToMultiByte.\n",
                            err );
        }

        switch (err) {
        case ERROR_INSUFFICIENT_BUFFER:
            hr = E_INVALIDARG;
            break;
        default:
            hr = LDAP_LOCAL_ERROR;
        }

    } else {

        hr = HrEnsureBuffer(1 + 5 + cbValue); // 1 for tag, 5 for len
        if (hr != 0) {
            return hr;
        }

        m_pbData[m_iCurrPos++] = (BYTE)ulTag;

        hr = HrSetLength(cbValue);
        if (hr == NOERROR) {

            if (wStrLen > 0) {

                if (m_CodePage == CP_UTF8) {

                    cbValue  = LdapUnicodeToUTF8( szValue,
                                              wStrLen,
                                              (char *) (m_pbData + m_iCurrPos),
                                              cbValue );
                } else {

                    cbValue  = WideCharToMultiByte( m_CodePage,
                                                    0,
                                                    szValue,
                                                    wStrLen,
                                                    (char *) (m_pbData + m_iCurrPos),
                                                    cbValue,
                                                    NULL,
                                                    NULL );
                }
            }

            m_iCurrPos += cbValue;
            m_cbData = m_iCurrPos;
        }
    }
    return hr;
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrAddBinaryValue
        Puts a binary value into the BER buffer.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrAddBinaryValue(BYTE *pbValue, ULONG cbValue, ULONG ulTag)
{
    ULONG hr;

    if (m_OverridingTag) {

       ulTag = m_OverridingTag;
       m_OverridingTag = 0;
    }

    hr = HrEnsureBuffer(1 + 5 + cbValue); // 1 for tag, 5 for len

    if (hr != 0) {
        return hr;
    }

    m_pbData[m_iCurrPos++] = (BYTE)ulTag;

    hr = HrSetLength(cbValue);
    if (hr == NOERROR)
    {
        CopyMemory(m_pbData + m_iCurrPos, pbValue, cbValue);

        m_iCurrPos += cbValue;

        m_cbData = m_iCurrPos;
    }

    return hr;
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrAddBinaryValue
        Puts a binary value into the BER buffer.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrAddBinaryValue(WCHAR *pbValue, ULONG cChars, ULONG ulTag)
{
    ULONG hr;
    ULONG cbValue;
    WCHAR   nullStr = L'\0';

    if (m_OverridingTag) {

       ulTag = m_OverridingTag;
       m_OverridingTag = 0;
    }


    if (pbValue == NULL) {

        pbValue = &nullStr;
    }

    if (m_CodePage == CP_UTF8) {

        cbValue = LdapUnicodeToUTF8( pbValue,
                                 cChars,
                                 NULL,
                                 0 );
    } else {

        cbValue  = WideCharToMultiByte( m_CodePage,
                                        0,
                                        pbValue,
                                        cChars,
                                        NULL,
                                        0,
                                        NULL,
                                        NULL );
    }

    if ((cbValue == 0) && (cChars > 0)) {

        int err = GetLastError();

        IF_DEBUG(BER) {
            LdapPrint1( "HrAddValue received error of 0x%x from WideCharToMultiByte.\n",
                            err );
        }

        switch (err) {
        case ERROR_INSUFFICIENT_BUFFER:
            hr = E_INVALIDARG;
            break;
        default:
            hr = LDAP_LOCAL_ERROR;
        }

    } else {

        hr = HrEnsureBuffer(1 + 5 + cbValue); // 1 for tag, 5 for len
        if (hr != 0) {
            return hr;
        }

        m_pbData[m_iCurrPos++] = (BYTE)ulTag;

        hr = HrSetLength(cbValue);
        if (hr == NOERROR) {

            if (cChars > 0) {

                if (m_CodePage == CP_UTF8) {

                    cbValue = LdapUnicodeToUTF8( pbValue,
                                             cChars,
                                             (char *) (m_pbData + m_iCurrPos),
                                             cbValue );
                } else {

                    cbValue  = WideCharToMultiByte( m_CodePage,
                                                    0,
                                                    pbValue,
                                                    cChars,
                                                    (char *) (m_pbData + m_iCurrPos),
                                                    cbValue,
                                                    NULL,
                                                    NULL );
                }
            }

            m_iCurrPos += cbValue;
            m_cbData = m_iCurrPos;
        }
    }
    return hr;
}

/*!-------------------------------------------------------------------------
    CLdapBer::HrAddEscapedValue
        Puts a value into the BER buffer that may have escape chars in it.
        We convert the chars after we've converted to UTF-8 or ANSI.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrAddEscapedValue(WCHAR *pbValue, ULONG ulTag)
{
    ULONG hr;
    ULONG cbValue;
    WCHAR nullStr = L'\0';
    ULONG cChars;
    PCHAR allocatedBuffer = NULL;

    if (pbValue == NULL) {

        pbValue = &nullStr;
    }

    cChars = strlenW( pbValue );

    if (cChars == 0) {

        return HrAddValue( (const WCHAR *) pbValue, ulTag );
    }

    if (m_CodePage == CP_UTF8) {

        cbValue = LdapUnicodeToUTF8( pbValue,
                                     cChars,
                                     NULL,
                                     0 );
    } else {

        cbValue  = WideCharToMultiByte( m_CodePage,
                                        0,
                                        pbValue,
                                        cChars,
                                        NULL,
                                        0,
                                        NULL,
                                        NULL );
    }

    if (cbValue == 0) {

        int err = GetLastError();

        IF_DEBUG(BER) {
            LdapPrint1( "HrAddValue received error of 0x%x from WideCharToMultiByte.\n",
                            err );
        }

        switch (err) {
        case ERROR_INSUFFICIENT_BUFFER:
            hr = E_INVALIDARG;
            break;
        default:
            hr = LDAP_LOCAL_ERROR;
        }

        return hr;
    }

    allocatedBuffer = (PCHAR) ldapMalloc( cbValue + 1, LDAP_ESCAPE_FILTER_SIGNATURE );

    if (allocatedBuffer == NULL) {

        return LDAP_NO_MEMORY;
    }

    if (m_CodePage == CP_UTF8) {

        cbValue = LdapUnicodeToUTF8( pbValue,
                                     cChars,
                                     allocatedBuffer,
                                     cbValue );
    } else {

        cbValue  = WideCharToMultiByte( m_CodePage,
                                        0,
                                        pbValue,
                                        cChars,
                                        allocatedBuffer,
                                        cbValue,
                                        NULL,
                                        NULL );
    }

    *(allocatedBuffer+cbValue) = '\0';

    PCHAR source;
    PCHAR dest;
    CHAR ch;

    source = dest = allocatedBuffer;

    while (*source != '\0') {

        ch = *(source++);

        if (ch == '\\') {

            UCHAR upNibble, loNibble;

            ch = *(source++);

            if (ISHEX(ch) == TRUE) {

                //
                //  if we have a backslash followed by some hex chars, then
                //  and only then do we translate it to the bin equivalent
                //

                upNibble = ch;

                ch = *(source++);
                cbValue--;

                if (ch == '\0') {
                    break;
                }

                if (ISHEX(ch) == TRUE) {

                    loNibble = ch;
                    cbValue--;

                } else {

                    //
                    //  if they only specified "\n" rather than "\nn", assume
                    //  a leading 0.
                    //

                    source--;       // obviously back up one since not using it.
                    loNibble = upNibble;
                    upNibble = 0;
                }

                ch = (MAPHEXTODIGIT( upNibble ) * 16) +
                      MAPHEXTODIGIT( loNibble );

            } else {

                source--;       // back up one since not translating the '\'
                ch = '\\';
            }
        }
        *(dest++) = ch;
    }

    *dest = L'\0';

    hr = HrAddBinaryValue( (BYTE *) allocatedBuffer,
                                    cbValue,
                                    ulTag );

    ldapFree( allocatedBuffer, LDAP_ESCAPE_FILTER_SIGNATURE );

    return hr;
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrSetLength
        Sets the length of cb to the current position in the BER buffer.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrSetLength(ULONG cb, ULONG cbLength/*=0xffffffff*/)
{
    // Short or long version of length ?
    if (((cb <= 0x7f) && (cbLength == 0xffffffff)) || (cbLength == 1))
    {
        m_pbData[m_iCurrPos++] = (BYTE)cb;
    }
    else if (((cb <= 0x7fff) && (cbLength == 0xffffffff)) || (cbLength == 3))
    {
        // Two byte length
        m_pbData[m_iCurrPos++] = 0x82;
        m_pbData[m_iCurrPos++] = (BYTE)((cb>>8) & 0x00ff);
        m_pbData[m_iCurrPos++] = (BYTE)(cb & 0x00ff);
    }
    else if (((cb < 0x7fffffff) && (cbLength == 0xffffffff)) || (cbLength == 5))
    {
        // Don't bother with 3 byte length, go directly to 4 byte.
        m_pbData[m_iCurrPos++] = 0x84;
        m_pbData[m_iCurrPos++] = (BYTE)((cb>>24) & 0x00ff);
        m_pbData[m_iCurrPos++] = (BYTE)((cb>>16) & 0x00ff);
        m_pbData[m_iCurrPos++] = (BYTE)((cb>>8) & 0x00ff);
        m_pbData[m_iCurrPos++] = (BYTE)(cb & 0x00ff);
    }
    else
    {
        ASSERT(cb < 0x7fffffff);
        return E_INVALIDARG;
    }

    return NOERROR;
}


/*!-------------------------------------------------------------------------
    CLdapBer::GetCbLength
        Gets the # of bytes required for the length field in the current
        position in the BER buffer.
  ------------------------------------------------------------------------*/
void CLdapBer::GetCbLength(ULONG *pcbLength)
{
    // Short or long version of the length ?
    if (m_pbData[m_iCurrPos] & 0x80)
    {
        *pcbLength = 1;
        *pcbLength += m_pbData[m_iCurrPos] & 0x7f;
    }
    else
    {
        // Short version of the length.
        *pcbLength = 1;
    }
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrGetLength
        Gets the length from the current position in the BER buffer.  Only
        definite lengths are supported.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrGetLength(ULONG *pcb)
{
    ULONG   cbLength;
    ULONG   i, cb;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetLength ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    GetCbLength(&cbLength);

    // Short or long version of the length ?
    if (cbLength == 1)
    {
        cb = m_pbData[m_iCurrPos++] & 0x7f;
    }
    else if (cbLength <= 5)
    {
        // Account for the overhead byte.cbLength field.
        cbLength--;
        m_iCurrPos++;

        if ((m_iCurrPos + (cbLength-1)) >= m_cbData) {
            IF_DEBUG(BER) {
                LdapPrint2( "HrGetLength ran out of data, length 0x%x, offset 0x%x.\n",
                            m_cbData, m_iCurrPos );
            }
            return LDAP_DECODING_ERROR;
        }

        cb = m_pbData[m_iCurrPos++];
        for (i=1; i < cbLength; i++)
        {
            cb <<= 8;
            cb |= m_pbData[m_iCurrPos++] & 0xffffffff;
        }
    }
    else
    {
        // We don't support lengths 2^32.
        LdapPrint2("HrGetLength got a bad length, cbLength=0x%x, offset=0x%x.\n", cbLength, m_iCurrPos);
        return E_INVALIDARG;
    }

    if (( cb >= m_cbData ) ||
        ((cb + m_iCurrPos) > m_cbData )) {
        
        // Bogus length.
        IF_DEBUG(BER) {
            LdapPrint2( "HrGetLength discovered bogus length 0x%x, buffer length 0x%x\n",
                        cb, m_cbData );
        }

        return LDAP_DECODING_ERROR;
    }

    *pcb = cb;

    return NOERROR;
}



/*!-------------------------------------------------------------------------
    CLdapBer::GetInt
        Gets an integer from a BER buffer.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::GetInt(BYTE *pbData, ULONG cbValue, LONG *plValue)
{
    ULONG   ulVal=0;
    ULONG   cbDiff;
    BOOL    fSign = FALSE;

    // We assume the tag & length have already been taken off and we're
    // at the value part.

    if (cbValue > sizeof(LONG)) {

        *plValue = 0x7FFFFFFF;
        return LDAP_DECODING_ERROR;
    }

    cbDiff = sizeof(LONG) - cbValue;

    // See if we need to sign extend;

    if ((cbDiff > 0) && (*pbData & 0x80)) {

        fSign = TRUE;
    }

    while (cbValue > 0)
    {
        ulVal <<= 8;
        ulVal |= (ULONG)*pbData++;
        cbValue--;
    }

    // Sign extend if necessary.
    if (fSign) {

        *plValue = 0x80000000;
        *plValue >>= cbDiff * 8;
        *plValue |= ulVal;

    } else {

        *plValue = (LONG) ulVal;
    }

    return NOERROR;
}


/*!-------------------------------------------------------------------------
    CLdapBer::AddInt
        Adds an integer to the input pbData buffer.
  ------------------------------------------------------------------------*/
void CLdapBer::AddInt(BYTE *pbData, ULONG cbValue, LONG lValue)
{
    ULONG i;

    for (i=cbValue; i > 0; i--)
    {
        *pbData++ = (BYTE)(lValue >> ((i - 1) * 8)) & 0xff;
    }
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrEnsureBuffer
        Ensures that we've got room to put cbNeeded more bytes into the buffer.
  ------------------------------------------------------------------------*/
ULONG
CLdapBer::HrEnsureBuffer(ULONG cbNeeded, BOOL fExact)
{
    ULONG cbNew;
    BYTE *pbT;

    if (( cbNeeded + m_cbData <= m_cbDataMax) &&
        (m_cbDataMax > 0)) {

        return NOERROR;
    }

    if (fExact) {

        cbNew = cbNeeded + m_cbData;

    } else {

        if (cbNeeded > CB_DATA_GROW) {

            cbNew = m_cbDataMax + cbNeeded;

        } else {

            cbNew = m_cbDataMax + CB_DATA_GROW;
        }
    }
    pbT = (BYTE *)ldapMalloc(cbNew,LDAP_LBER_SIGNATURE);
    if (!pbT) {
        return LDAP_NO_MEMORY;
    }
    if (m_pbData) {

        CopyMemory(pbT, m_pbData, m_cbDataMax);
        ldapFree(m_pbData, LDAP_LBER_SIGNATURE );
    }

    m_pbData = pbT;
    m_cbDataMax = cbNew;
    return NOERROR;
}

ULONG
CLdapBer::HrSetDNLocation()
//
//  Record the position of the distinguished name
//
//  We have to parse out the message here
//
{
    ULONG tag;
    ULONG hr;
    ULONG cb = 0;

    m_dnOffset = m_iCurrPos;

    //
    //  ensure that it is a octet string for the DN.  if not, then we don't
    //  know how to interpret the rest
    //

    hr = HrPeekTag( &tag );

    if (hr != NOERROR) {
        return hr;
    }

    if (tag != BER_OCTETSTRING) {

        return E_INVALIDARG;
    }

    m_iCurrPos++;           // skip tag

    hr = HrGetLength(&cb);

    if (hr != NOERROR) {

        return hr;
    }

    //
    //  if it has a zero length DN and nothing after it, toss it.
    //

    if (cb == 0) {

        //
        //  check that it a sequence starts here for PartialAttributeList
        //

        hr = HrPeekTag( &tag );

        if (hr != NOERROR) {
            return hr;
        }

        if (tag != BER_SEQUENCE) {
            return E_INVALIDARG;
        }

        m_iCurrPos++;           // skip tag

        hr = HrGetLength(&cb);

        if (hr != NOERROR) {

            return hr;
        }
    }

    m_iCurrPos = m_dnOffset;
    return NOERROR;
}

//
//  CLdapBer::HrGetDN
//      This routine gets the DN string value from the current BER entry.
//
ULONG CLdapBer::HrGetDN(PWCHAR *szDN)
{
    ULONG hr;
    ULONG   savedCurrentPosition = m_iCurrPos;

    *szDN = NULL;

    if ((m_dnOffset == 0) ||
        (m_pbData == NULL) ||
        (m_dnOffset > m_cbDataMax)) {

        return E_INVALIDARG;
    }

    if (m_pbData[m_dnOffset] != BER_OCTETSTRING) {

        return LDAP_DECODING_ERROR;
    }

    m_iCurrPos = m_dnOffset;

    hr = HrGetValueWithAlloc( szDN );

    //
    //  we need to change the memory type for a DN.
    //

    ldapSwapTags( *szDN, LDAP_VALUE_SIGNATURE, LDAP_BUFFER_SIGNATURE );

    m_iCurrPos = savedCurrentPosition;

    return hr;
}



void
Asn1GetCbLength (
    PUCHAR Buffer,
    ULONG *pcbLength
    )
{
    // Short or long version of the length ?
    if (*Buffer & 0x80)
    {
        *pcbLength = 1;
        *pcbLength += (*Buffer) & 0x7f;
    }
    else
    {
        // Short version of the length.
        *pcbLength = 1;
    }
}


ULONG
Asn1GetPacketLength (
    PUCHAR Buffer,
    ULONG cbBuffer,
    ULONG *plValue
    )
{
    ULONG   cb;
    ULONG   ul;
    ULONG   totalLength = 0;
    ULONG   cbLength;
    ULONG   i;

    if (cbBuffer < 2) {
    
        // Buffer has to have at least a tag byte and a single-byte length
        IF_DEBUG(BER) {
            LdapPrint1( "Asn1GetPacketLength: buffer too small(0x%x)\n",
                        cbBuffer );
        }
        return E_INVALIDARG;
    }

    ul = (ULONG) (*Buffer); // TAG

    if ( ul != BER_SEQUENCE ) {

        IF_DEBUG(BER) {
            LdapPrint2( "Asn1GetPacketLength expected tag of 0x%x, received 0x%x.\n",
                        BER_SEQUENCE, ul );
        }
        return E_INVALIDARG;
    }

    Buffer++;       // skip tag
    totalLength = 1;

    Asn1GetCbLength(Buffer, &cbLength);

    // Short or long version of the length ?

    if (cbLength == 1) {

        cb = (*Buffer) & 0x7f;
        totalLength += 1;

    } else if (cbLength <= 5) {

        if (cbLength+1 > cbBuffer) {

            // Buffer too small to accomodate the claimed length
            // (+1 is for the tag)
            IF_DEBUG(BER) {
                LdapPrint1( "Asn1GetPacketLength: buffer too small, bad length (0x%x)\n",
                            cbBuffer );
            }
            
            return E_INVALIDARG;
        }

        // Account for the overhead byte.cbLength field.
        cbLength--;
        Buffer++;
        totalLength += 1;

        cb = *Buffer;
        Buffer++;
        totalLength += 1;
        for (i=1; i < cbLength; i++) {

            cb <<= 8;
            cb |= (*(Buffer++)) & 0xffffffff;
            totalLength += 1;
        }
    } else {

        // We don't support lengths 2^32.
        ASSERT(cbLength <= 5);
        return E_INVALIDARG;
    }

    *plValue = totalLength + cb;

    return NOERROR;
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrSkipTag2
        Skips over the current tag.
        
  On Success: Returns NO_ERROR; sets tag and length arguments
  On Failure: Returns LDAP_NO_SUCH_ATTRIBUTE; sets nothing
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrSkipTag2(ULONG *tag, ULONG *len)
{
   ULONG SavedOffset = m_iCurrPos;
   ULONG hr;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrSkipTag2 ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    *tag = (ULONG)m_pbData[m_iCurrPos]; // Got the TAG

    m_iCurrPos++;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrSkipTag2 ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        m_iCurrPos = SavedOffset;
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    hr = HrGetLength( len );

    if ((hr != NOERROR) || (m_cbData < m_iCurrPos)) {

       m_iCurrPos = SavedOffset;
       return hr;
    }


    return NOERROR;
}



ULONG CLdapBer::HrOverrideTag(ULONG ulTag)
{
   if (ulTag != 0) {

      //
      // Reject any invalid tags
      //

      m_OverridingTag = ulTag;
      return NOERROR;
   }

   return E_INVALIDARG;

}



/*!-------------------------------------------------------------------------
    CLdapBer::HrAddValue
        This routine puts a Boolean value in the BER buffer.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrAddValue(BOOLEAN i, ULONG ulTag/*=BER_BOOLEAN*/)
{
    ULONG hr;
    ULONG   cbInt;


    if (m_OverridingTag) {

       ulTag = m_OverridingTag;
       m_OverridingTag = 0;
    }

    cbInt = 0x1; // Sizeof boolean value

    hr = HrEnsureBuffer(1 + 1 + cbInt); // 1 for tag, 1 for length
    if (hr != 0) {
        return hr;
    }

    m_pbData[m_iCurrPos++] = (BYTE)ulTag;

    hr = HrSetLength(cbInt);

    if (hr == NOERROR) {

//      AddInt(m_pbData + m_iCurrPos, cbInt, i);

       *(m_pbData + m_iCurrPos) = ((i == TRUE) ? 0xFF:0x0);

        m_iCurrPos += cbInt;

        m_cbData = m_iCurrPos;
    }

    return hr;
}


// ldapber.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\initterm.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    initterm.c    global data for LDAP client DLL

Abstract:

   This module contains data definitions necessary for LDAP client DLL.

   Also contains code that initializes/frees global data.

Author:

    Andy Herron    (andyhe)        15-May-1996
    Anoop Anantha  (AnoopA)        24-Jun-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "dststlog.h"

#ifdef __cplusplus
extern "C" {
#endif

#define _DECL_DLLMAIN
#include <process.h>

BOOL WINAPI
LdapDllInit (
    HINSTANCE hinstDLL,
    DWORD     Reason,
    LPVOID    Reserved
    );

#ifdef __cplusplus
}
#endif

//
//  global data goes here...
//

HINSTANCE  GlobalLdapDllInstance = NULL;
LIST_ENTRY GlobalListActiveConnections;
LIST_ENTRY GlobalListWaiters;
LIST_ENTRY GlobalListRequests;
CRITICAL_SECTION ConnectionListLock;
CRITICAL_SECTION RequestListLock;
CRITICAL_SECTION LoadLibLock;
CRITICAL_SECTION CacheLock;
CRITICAL_SECTION SelectLock1;
CRITICAL_SECTION SelectLock2;
HANDLE     LdapHeap;
LONG      GlobalConnectionCount;
LONG      GlobalRequestCount;
LONG      GlobalWaiterCount;
LONG      GlobalMessageNumber;
LONG      GlobalCountOfOpenRequests;
WSADATA   GlobalLdapWSAData;
BOOLEAN   MessageNumberHasWrapped = FALSE;
BOOLEAN   GlobalCloseWinsock;
BOOLEAN   GlobalWinsock11;
BOOLEAN   GlobalWinNT = TRUE;
BOOLEAN   PopupRegKeyFound = FALSE;
HINSTANCE WinsockLibraryHandle = NULL;
HINSTANCE SecurityLibraryHandle;
HINSTANCE SslLibraryHandle;
HINSTANCE AdvApi32LibraryHandle = NULL;
HINSTANCE NTDSLibraryHandle = NULL;
HINSTANCE ScramblingLibraryHandle = NULL;
BOOLEAN GlobalLdapShuttingDown;
BOOLEAN DisableRootDSECache = FALSE;
UCHAR   GlobalSeed = 0;      // Let RtlRunEncodeUnicodeString choose the seed
BOOLEAN GlobalUseScrambling = FALSE; // should we scramble passwords?
LIST_ENTRY GlobalPerThreadList;
CRITICAL_SECTION PerThreadListLock;
DWORD GlobalIntegrityDefault = DEFAULT_INTEGRITY_PREFERRED; // what minimum level of signing is required?
DWORD GlobalRejectNewRequests = 0;


ULONG GlobalWaitSecondsForSelect = LDAP_PING_KEEP_ALIVE_DEF;
ULONG GlobalLdapPingLimit = LDAP_PING_LIMIT_DEF;
ULONG GlobalPingWaitTime = LDAP_PING_WAIT_TIME_DEF;
ULONG GlobalRequestResendLimit = LDAP_REQUEST_RESEND_LIMIT_DEF;

#if DBG
DBGPRINT  GlobalLdapDbgPrint = DbgPrint;
#else
DBGPRINT  GlobalLdapDbgPrint = NULL;
#endif

BOOLEAN   GlobalWin9x;
DWORD     GlobalReceiveHandlerThread;
DWORD     GlobalDrainWinsockThread;
HINSTANCE NetApi32LibraryHandle;
LONG     GlobalLoadUnloadRefCount = 0;

//
//  Security support
//

ULONG   NumberSecurityPackagesInstalled;
ULONG   NumberSslPackagesInstalled;
PSecurityFunctionTableW SspiFunctionTableW;
PSecurityFunctionTableW SslFunctionTableW;
PSecurityFunctionTableA SspiFunctionTableA;     // For use in Win9x
PSecurityFunctionTableA SslFunctionTableA;      //    - do -
PSecPkgInfoW SslPackagesInstalled;
PSecPkgInfoW SecurityPackagesInstalled;
PSecPkgInfoW SspiPackageNegotiate;
PSecPkgInfoW SspiPackageKerberos;
PSecPkgInfoW SspiPackageSslPct;
PSecPkgInfoW SspiPackageSicily;
PSecPkgInfoW SspiPackageNtlm;
PSecPkgInfoW SspiPackageDpa;
PSecPkgInfoW SspiPackageDigest;
ULONG SspiMaxTokenSize = 0;

//
//  This socket is used to wake up our thread in select to come and reread
//  the list of handles to wait on.
//

SOCKET LdapGlobalWakeupSelectHandle = INVALID_SOCKET;
BOOLEAN InsideSelect = FALSE;

//
//
//  pointers to functions we import from winsock (1.1 or 2.0)
//

LPFN_WSASTARTUP pWSAStartup = NULL;
LPFN_WSACLEANUP pWSACleanup = NULL;
LPFN_WSAGETLASTERROR pWSAGetLastError = NULL;
LPFN_RECV precv = NULL;
LPFN_SELECT pselect = NULL;
LPFN_WSARECV pWSARecv = NULL;
LPFN_SOCKET psocket = NULL;
LPFN_CONNECT pconnect = NULL;
LPFN_GETHOSTBYNAME pgethostbyname = NULL;
LPFN_GETHOSTBYADDR pgethostbyaddr = NULL;
LPFN_INET_ADDR pinet_addr = NULL;
LPFN_INET_NTOA pinet_ntoa = NULL;
LPFN_HTONS phtons = NULL;
LPFN_HTONL phtonl = NULL;
LPFN_NTOHL pntohl = NULL;
LPFN_CLOSESOCKET pclosesocket = NULL;
LPFN_SEND psend = NULL;
LPFN_IOCTLSOCKET pioctlsocket = NULL;
LPFN_SETSOCKOPT psetsockopt = NULL;
FNWSAFDISSET pwsafdisset = NULL;
LPFN_BIND pbind = NULL;
LPFN_GETSOCKNAME pgetsockname = NULL;
LPFN_WSALOOKUPSERVICEBEGINW pWSALookupServiceBeginW = NULL;
LPFN_WSALOOKUPSERVICENEXTW pWSALookupServiceNextW = NULL;
LPFN_WSALOOKUPSERVICEEND pWSALookupServiceEnd = NULL;

FNDSMAKESPNW pDsMakeSpnW = NULL;

FNRTLINITUNICODESTRING pRtlInitUnicodeString = NULL;
FRTLRUNENCODEUNICODESTRING pRtlRunEncodeUnicodeString = NULL;
FRTLRUNDECODEUNICODESTRING pRtlRunDecodeUnicodeString = NULL;
FRTLENCRYPTMEMORY pRtlEncryptMemory = NULL;
FRTLDECRYPTMEMORY pRtlDecryptMemory = NULL;


CHAR LdapErrorStrings[LDAP_MAX_ERROR_STRINGS][LDAP_ERROR_STR_LENGTH];
WCHAR LdapErrorStringsW[LDAP_MAX_ERROR_STRINGS][LDAP_ERROR_STR_LENGTH];
HANDLE GlobalLdapShutdownEvent = NULL;
DWORD GlobalTlsLastErrorIndex = (DWORD) -1;

CHAR LdapHexToCharTable[17] = "0123456789ABCDEF";

#if DBG
ULONG LdapDebug = DEBUG_ERRORS;
#else
ULONG LdapDebug = 0;
#endif


//
// Once GlobalHasInitialized is TRUE, initialization
// has reached the commit point and LdapClientTerminate
// needs to free any resources that were allocated
//
static BOOLEAN GlobalHasInitialized = FALSE;

//
//  local declarations follow...
//

BOOL
LdapClientInitialize (
    HINSTANCE hinstDLL
    );

BOOL
LdapClientTerminate (
    BOOL AllClean
    );

VOID
LdapCleanupPerThreadData(
    VOID
    );

BOOL
LdapUsePrivateHeap(
    VOID
    );


//
//  This routine handles initializing/releasing global data.  It is called
//  when we're attached/detached from a process.
//

BOOL WINAPI
LdapDllInit (
    HINSTANCE hinstDLL,
    DWORD     Reason,
    LPVOID    Reserved
    )
{
    //
    //  we don't call the _CRT_INIT etc routines because Athena group doesn't
    //  want us to load MSVCRT.DLL.
    //

    if (Reason == DLL_PROCESS_ATTACH) {

        //
        // Start up logging
        //
        
        GlobalLdapDllInstance = hinstDLL;
        return LdapClientInitialize( hinstDLL );

    } else if (Reason == DLL_PROCESS_DETACH) {

        // if Reserved is null, someone called FreeLibrary... we only cleanup
        // on FreeLibrary, not on process terminate.

        if (Reserved == NULL) {

            return LdapClientTerminate( TRUE );
        }

    } else if (Reason == DLL_THREAD_ATTACH) {
            return AddPerThreadEntry(GetCurrentThreadId());

    } else if (Reason == DLL_THREAD_DETACH) {

        if (GlobalTlsLastErrorIndex != (DWORD) -1) {

            TlsSetValue( GlobalTlsLastErrorIndex, NULL );
        }
        RemovePerThreadEntry(GetCurrentThreadId());
    }

    return TRUE;        // we always return sucess
}

BOOL
LdapClientInitialize (
    HINSTANCE hinstDLL
    )
{
    //
    //  If we've already initialized, return TRUE because someone's called
    //  ldap_startup either twice or we handled it at DLL load time.
    //

    UNREFERENCED_PARAMETER( hinstDLL );

    DWORD dwCritSectInitStage = 0;

    if (LdapHeap != NULL) {
        
        InterlockedIncrement( &GlobalLoadUnloadRefCount );
        return TRUE;
    }


    //
    //  handle initializing all data at attach time
    //

    InitializeListHead(&GlobalListActiveConnections);
    InitializeListHead(&GlobalListWaiters);
    InitializeListHead(&GlobalListRequests);
    InitializeListHead(&GlobalPerThreadList);


    __try {
        INITIALIZE_LOCK( &ConnectionListLock );
        dwCritSectInitStage = 1;
        
        INITIALIZE_LOCK( &RequestListLock );
        dwCritSectInitStage = 2;
        
        INITIALIZE_LOCK( &LoadLibLock );
        dwCritSectInitStage = 3;
        
        INITIALIZE_LOCK( &CacheLock );
        dwCritSectInitStage = 4;
        
        INITIALIZE_LOCK( &SelectLock1 );
        dwCritSectInitStage = 5;
        
        INITIALIZE_LOCK( &SelectLock2 );
        dwCritSectInitStage = 6;
        
        INITIALIZE_LOCK( &PerThreadListLock );
        dwCritSectInitStage = 7;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {

        //
        // Something went wrong with the crit section initialization
        //

        switch (dwCritSectInitStage) {
            // fall-through is deliberate

        case 7:
            DELETE_LOCK( &PerThreadListLock );
        case 6:
            DELETE_LOCK( &SelectLock2 );
        case 5:
            DELETE_LOCK( &SelectLock1 );
        case 4:
            DELETE_LOCK( &CacheLock );
        case 3:
            DELETE_LOCK( &LoadLibLock );
        case 2:
            DELETE_LOCK( &RequestListLock );
        case 1:
            DELETE_LOCK( &ConnectionListLock );
        case 0:
        default:
            break;
        }
        
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        IF_DEBUG(ERRORS) {
            LdapPrint0( "LDAP client failed to initialize critical sections.\n");
        }
        
        return FALSE;
    }


    //
    // We use a private heap in the server configuration for the Exchange
    // folks who claim that wldap32 increases process heap contention.
    //

    if (LdapUsePrivateHeap()) {
    
        LdapHeap = HeapCreate( 0, INITIAL_HEAP, 0 );
    }
    else {
        LdapHeap = NULL;
    }


    if (LdapHeap == NULL) {

        LdapHeap = GetProcessHeap();

        if (LdapHeap == NULL) {

            IF_DEBUG(ERRORS) {
                LdapPrint1( "LDAP client failed to create heap, err = 0x%x.\n", GetLastError());
            }

            //
            // Clean up the critical sections we earlier initialized
            //
            DELETE_LOCK( &ConnectionListLock );
            DELETE_LOCK( &RequestListLock );
            DELETE_LOCK( &LoadLibLock );
            DELETE_LOCK( &CacheLock );
            DELETE_LOCK( &SelectLock1 );
            DELETE_LOCK( &SelectLock2 );
            DELETE_LOCK( &PerThreadListLock );

            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
    }

    IF_DEBUG(INIT_TERM) {
        LdapPrint0( "LDAP Client API 32 initializing.\n" );
    }
    

    //
    // Add an entry to GlobalPerThreadList for this thread
    //
    if (!AddPerThreadEntry(GetCurrentThreadId())) {
        //
        // Cleanup and abort
        //
        if (LdapHeap != NULL &&
            LdapHeap != GetProcessHeap()) {

            HeapDestroy( LdapHeap );
            LdapHeap = NULL;
        }
        
        DELETE_LOCK( &ConnectionListLock );
        DELETE_LOCK( &RequestListLock );
        DELETE_LOCK( &LoadLibLock );
        DELETE_LOCK( &CacheLock );
        DELETE_LOCK( &SelectLock1 );
        DELETE_LOCK( &SelectLock2 );
        DELETE_LOCK( &PerThreadListLock );

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    GlobalHasInitialized = TRUE;

    NumberSecurityPackagesInstalled = 0;
    GlobalCountOfOpenRequests = 0;
    NumberSslPackagesInstalled = 0;
    SecurityPackagesInstalled = NULL;
    SslPackagesInstalled = NULL;
    SspiFunctionTableW = NULL;
    SslFunctionTableW = NULL;
    SspiFunctionTableA = NULL;
    SslFunctionTableA = NULL;

    SspiPackageKerberos = NULL;
    SspiPackageSslPct = NULL;
    SspiPackageSicily = NULL;
    SspiPackageNegotiate = NULL;
    SspiPackageNtlm = NULL;
    SspiPackageDpa = NULL;
    SspiPackageDigest = NULL;

    GlobalMessageNumber = 0;
    GlobalConnectionCount = 0;
    GlobalRequestCount = 0;
    GlobalWaiterCount = 0;
    GlobalCloseWinsock = FALSE;
    GlobalWinsock11 = TRUE;
    WinsockLibraryHandle = NULL;
    SecurityLibraryHandle = NULL;
    SslLibraryHandle = NULL;
    NetApi32LibraryHandle = NULL;
    AdvApi32LibraryHandle = NULL;
    GlobalLdapShuttingDown = FALSE;
    GlobalLdapShutdownEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    GlobalReceiveHandlerThread = NULL;
    GlobalDrainWinsockThread = NULL;

    InitializeLdapCache();

    if (ReadRegIntegrityDefault(&GlobalIntegrityDefault) != ERROR_SUCCESS) {
        // if we couldn't read a default integrity (signing) setting from
        // the registry, set our default to "preferred-but-not-required"
        GlobalIntegrityDefault = DEFAULT_INTEGRITY_PREFERRED;
    }

    GlobalTlsLastErrorIndex = TlsAlloc();

    InterlockedIncrement( &GlobalLoadUnloadRefCount );

    IF_DEBUG(INIT_TERM) {
        LdapPrint0( "LDAP Client API 32 initialization complete.\n" );
    }
    
    return TRUE;
}

BOOL
AddPerThreadEntry(
                DWORD ThreadID
                )
{
    //
    // Create a per-thread entry for ThreadID and link it onto the GlobalPerThreadList
    //
    PTHREAD_ENTRY threadEntry = (PTHREAD_ENTRY) ldapMalloc( sizeof( THREAD_ENTRY ), LDAP_PER_THREAD_SIGNATURE);

    if (threadEntry != NULL) {

        threadEntry->dwThreadID = ThreadID;
        threadEntry->pErrorList = NULL;
        threadEntry->pCurrentAttrList = NULL;

        ACQUIRE_LOCK( &PerThreadListLock );
        InsertHeadList ( &GlobalPerThreadList, &threadEntry->ThreadEntry);
        RELEASE_LOCK( &PerThreadListLock );
        
        return TRUE;
    }

    return FALSE;
}

BOOL
RemovePerThreadEntry(
                DWORD ThreadID
                )
{
    PLIST_ENTRY pThreadListEntry = NULL;
    PTHREAD_ENTRY pThreadEntry = NULL;

    PERROR_ENTRY pErrorEntry, pErrorEntryNext;
    PLDAP_ATTR_NAME_THREAD_STORAGE pAttrEntry,pAttrEntryNext;

    ACQUIRE_LOCK( &PerThreadListLock );

    //
    // Locate the per-thread entry for ThreadID
    //
    pThreadListEntry = GlobalPerThreadList.Flink;

    while (pThreadListEntry != &GlobalPerThreadList) {

        pThreadEntry = CONTAINING_RECORD( pThreadListEntry, THREAD_ENTRY, ThreadEntry );
        pThreadListEntry = pThreadListEntry->Flink;

        if (pThreadEntry->dwThreadID == ThreadID) {

            //
            // Found the per-thread entry for ThreadID
            // Remove and free it and it's child lists
            //
            RemoveEntryList(&pThreadEntry->ThreadEntry);

            // walk & free the error list
            pErrorEntry = pThreadEntry->pErrorList;

            while (pErrorEntry != NULL) {

                pErrorEntryNext = pErrorEntry->pNext;

                if (pErrorEntry->ErrorMessage != NULL) {

                   ldap_memfreeW( pErrorEntry->ErrorMessage );
                }

                ldapFree( pErrorEntry, LDAP_ERROR_SIGNATURE );
                
                pErrorEntry = pErrorEntryNext;
            }
            
            // walk & free the attribute list
            pAttrEntry = pThreadEntry->pCurrentAttrList;
            
            while (pAttrEntry != NULL) {

                pAttrEntryNext = pAttrEntry->pNext;

                ldapFree( pAttrEntry, LDAP_ATTR_THREAD_SIGNATURE );
                
                pAttrEntry = pAttrEntryNext;
            }

            // free the per-thread entry itself
            ldapFree(pThreadEntry, LDAP_PER_THREAD_SIGNATURE);
            RELEASE_LOCK ( &PerThreadListLock );
            return TRUE;
        }
    }

    RELEASE_LOCK( &PerThreadListLock );
    return FALSE;
}




//
// Determine whether to use a private heap or the process heap for all
// allocations.
//
// Using a private heap isolates us from other modules in the process
// (good for debugging) and reduces contention on the process heap
// (good for servers).  However, it also increases overhead (bad for
// clients/low memory machines).
//
// Algorithm for deciding whether to use a private heap or the process
// heap:
//
//   CHK bits always use a private heap
//
//   Win9x uses the process heap.
//   NT3.5 -- NT4 use a private heap (since they don't support VERSIONINFOEX)
//   Windows 2000+: if running Personal or Pro, use the process heap
//                  otherwise, use a private heap
//
//
BOOL
LdapUsePrivateHeap (
    VOID
    )
{
#if LDAPDBG

    // CHK bits --> private heap
    return TRUE;

#else

    DWORD sysVersion;
    DWORD winMajorVersion;

    sysVersion = GetVersion();
    winMajorVersion = (DWORD) (LOBYTE(LOWORD(sysVersion)));

    //
    // Check for pre-Windows 2000 operating systems
    //

    if (sysVersion >= 0x80000000) {
        // Win9x --> process heap
        IF_DEBUG(INIT_TERM) {
            LdapPrint0("Platform is windows 95/98\n");
        }
        return FALSE;
    }

    if (winMajorVersion < 5) {
        // a version of NT prior to Windows 2000 ---> private heap
        IF_DEBUG(INIT_TERM) {
            LdapPrint0("Platform is windows NT prior to Windows 2000\n");
        }        
        return TRUE;
    }

    //
    // Windows 2000 or higher: use GetVersionEx with VERSIONINFOEX
    // to determine the configuration
    //

    OSVERSIONINFOEX verInfo;
    verInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if (!GetVersionEx(reinterpret_cast<OSVERSIONINFO*>(&verInfo))) {
        // failed --- just use a private heap
        IF_DEBUG(INIT_TERM) {
            LdapPrint1("Could not get any version information from GetVersionEx 0x%x\n", GetLastError());
        }

        return TRUE;
    }

    if (verInfo.wSuiteMask & VER_SUITE_PERSONAL) {
        // Windows Personal --> process heap
        IF_DEBUG(INIT_TERM) {
            LdapPrint0("Platform is Windows Personal\n");
        }        
        return FALSE;
    }
    else if (verInfo.wProductType == VER_NT_WORKSTATION) {
        // Windows Professional --> process heap
        IF_DEBUG(INIT_TERM) {
            LdapPrint0("Platform is Windows Professional\n");
        }        
        return FALSE;        
    }
    else {
        // some sort of Server --> private heap
        IF_DEBUG(INIT_TERM) {
            LdapPrint0("Platform is Windows Server\n");
        }        
        return TRUE;       
    }
    
#endif
}


BOOL
LdapInitializeWinsock (
    VOID
    )
//
//  When we call into winsock at dll load time, the c-runtime libraries may
//  not have initialized the heap and winsock could trap.  To work around this
//  problem, we'll call winsock startup routine on the first connect request.
//
{
    WORD wVersion;
    DWORD sysVersion;
    DWORD winMajorVersion;
    int i, err;
    ULONG nonblockingMode = 1;
    SOCKADDR_IN sa = {0};
    int buffersize = sizeof(sa);
    CHAR DllName[] = "RADMIN32.DLL";
    ULONG offset = 0;
    ULONG retval = 0;


    if (GlobalCloseWinsock) {
        return(TRUE);
    }

    ACQUIRE_LOCK( &LoadLibLock );

    if (GlobalCloseWinsock) {
        RELEASE_LOCK( &LoadLibLock );
        return(TRUE);
    }

    DSINITLOG();
    
    //
    //  Load either winsock 2.0 or 1.1 DLL, depending on if we're on 3.51 or
    //  4.0.
    //

    GlobalWin9x = FALSE;
    sysVersion = GetVersion();
    winMajorVersion = (DWORD) (LOBYTE(LOWORD(sysVersion)));

    if ((winMajorVersion == 3) &&
        (sysVersion < 0x80000000)) {  // Windows NT 3.5x

        WinsockLibraryHandle = LoadSystem32LibraryA( "WSOCK32.DLL" );

        GlobalWinsock11 = TRUE;     // we're using Winsock 1.1 on NT 3.5/3.51

        LdapPrint0("Using wsock32 on NT 3.5x\n");

    } else {

        if (sysVersion >= 0x80000000) {

            GlobalWin9x = TRUE;
        }

        //
        // We prefer to use the Winsock2 library if available.
        //

        WinsockLibraryHandle = LoadSystem32LibraryA( "WS2_32.DLL" );

        if (WinsockLibraryHandle != NULL) {

            GlobalWinsock11 = FALSE;

        } else {

            //
            // we have no choice but to load Winsock1.1
            //

            WinsockLibraryHandle = LoadSystem32LibraryA( "WSOCK32.DLL" );
            LdapPrint0("Using wsock32 due to lack of winsock2.\n");

            if (WinsockLibraryHandle != NULL) {
                GlobalWinsock11 = TRUE;
            }
        }
    }

    if (WinsockLibraryHandle == NULL) {

        IF_DEBUG(ERRORS) {
            LdapPrint1( "LDAP client failed to load Winsock, err = 0x%x.\n", GetLastError());
        }

        goto error;
    }

    //
    //  Grab the addresses of all functions we'll call
    //

    pWSAStartup = (LPFN_WSASTARTUP) GetProcAddress( WinsockLibraryHandle, "WSAStartup" );
    pWSACleanup = (LPFN_WSACLEANUP) GetProcAddress( WinsockLibraryHandle, "WSACleanup" );
    pWSAGetLastError = (LPFN_WSAGETLASTERROR) GetProcAddress( WinsockLibraryHandle, "WSAGetLastError" );
    psocket = (LPFN_SOCKET) GetProcAddress( WinsockLibraryHandle, "socket");
    pconnect = (LPFN_CONNECT) GetProcAddress( WinsockLibraryHandle, "connect");
    pgethostbyname = (LPFN_GETHOSTBYNAME) GetProcAddress( WinsockLibraryHandle, "gethostbyname");
    pgethostbyaddr = (LPFN_GETHOSTBYADDR) GetProcAddress( WinsockLibraryHandle, "gethostbyaddr");
    pinet_addr = (LPFN_INET_ADDR) GetProcAddress( WinsockLibraryHandle, "inet_addr");
    pinet_ntoa = (LPFN_INET_NTOA) GetProcAddress( WinsockLibraryHandle, "inet_ntoa");
    phtons = (LPFN_HTONS) GetProcAddress( WinsockLibraryHandle, "htons");
    phtonl = (LPFN_HTONL) GetProcAddress( WinsockLibraryHandle, "htonl");
    pntohl = (LPFN_NTOHL) GetProcAddress( WinsockLibraryHandle, "ntohl");
    pclosesocket = (LPFN_CLOSESOCKET) GetProcAddress( WinsockLibraryHandle, "closesocket");
    precv = (LPFN_RECV) GetProcAddress( WinsockLibraryHandle, "recv");
    psend = (LPFN_SEND) GetProcAddress( WinsockLibraryHandle, "send");
    pselect = (LPFN_SELECT) GetProcAddress( WinsockLibraryHandle, "select" );
    pwsafdisset = (FNWSAFDISSET) GetProcAddress( WinsockLibraryHandle, "__WSAFDIsSet");
    pioctlsocket = (LPFN_IOCTLSOCKET) GetProcAddress( WinsockLibraryHandle, "ioctlsocket");
    psetsockopt = (LPFN_SETSOCKOPT) GetProcAddress( WinsockLibraryHandle, "setsockopt");
    pbind = (LPFN_BIND) GetProcAddress( WinsockLibraryHandle, "bind");
    pgetsockname = (LPFN_GETSOCKNAME) GetProcAddress( WinsockLibraryHandle, "getsockname");
    pWSALookupServiceBeginW = (LPFN_WSALOOKUPSERVICEBEGINW) GetProcAddress( WinsockLibraryHandle, "WSALookupServiceBeginW");
    pWSALookupServiceNextW = (LPFN_WSALOOKUPSERVICENEXTW) GetProcAddress( WinsockLibraryHandle, "WSALookupServiceNextW");
    pWSALookupServiceEnd = (LPFN_WSALOOKUPSERVICEEND) GetProcAddress( WinsockLibraryHandle, "WSALookupServiceEnd");

    if (pWSAStartup == NULL ||
        pWSACleanup == NULL ||
        pWSAGetLastError == NULL ||
        precv == NULL ||
        psocket == NULL ||
        pconnect == NULL ||
        pgethostbyname == NULL ||
        pgethostbyaddr == NULL ||
        pinet_addr == NULL ||
        phtons == NULL ||
        phtonl == NULL ||
        pntohl == NULL ||
        psend  == NULL ||
        pclosesocket == NULL ||
        pwsafdisset == NULL ||
        pselect == NULL ) {

        IF_DEBUG(ERRORS) {
            LdapPrint1( "LDAP client failed GetProcAddress, err = 0x%x.\n", GetLastError());
        }

        FreeLibrary( WinsockLibraryHandle );
        WinsockLibraryHandle = NULL;

        goto error;
    }

    //
    // Try to load up either radmin32.dll, advapi32.dll or ntdll.dll to get access to the
    // scrambling routines.
    //
    // First, check to see if we are on NT. If yes, load NTDLL.DLL and ADVAPI32.DLL.
    // We'll preferably use the encryption routines of advapi32.dll, if they're
    // available (Whistler and up), otherwise we'll use ntdll.dll's Unicode scrambling
    // routines.
    // If not on NT, load RADMIN32.DLL only from the system directory of the Win9x
    // machine.
    //

    OSVERSIONINFO OsVersionInfo;
    CHAR SystemPath[MAX_PATH + 15]; // we will append "RADMIN32.DLL" to the path returned

    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (!GetVersionEx( &OsVersionInfo )) {

        IF_DEBUG(INIT_TERM) {
            LdapPrint1("Could not get any version information from GetVersionEx 0x%x\n", GetLastError());
        }
        goto LoadDone;
    }

    if (OsVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {

        IF_DEBUG(INIT_TERM) {
            LdapPrint0("Platform is windows NT\n");
        }
        GlobalWinNT = TRUE;
    } else {

        IF_DEBUG(INIT_TERM) {
            LdapPrint0("Platform is windows 9x\n");
        }
        GlobalWinNT = FALSE;
    }

    if (GlobalWinNT) {

        ScramblingLibraryHandle = LoadSystem32LibraryA( "NTDLL.DLL" );

        if (!AdvApi32LibraryHandle) {
            AdvApi32LibraryHandle = LoadSystem32LibraryA( "ADVAPI32.DLL" );
        }

        if (ScramblingLibraryHandle || AdvApi32LibraryHandle) {

            goto GetFnPtrs;

        } else {

            goto LoadDone;
        }
    }

    //
    // We are on Win9x. We have to look for RADMIN32.DLL only in the
    // system directory
    //

    retval = GetSystemDirectoryA( (PCHAR) SystemPath, MAX_PATH);

    if ((retval != 0) && !(retval > MAX_PATH)) {

        //
        // succeeded in getting the system path.
        //

        for (i=0; i<MAX_PATH; i++ ) {

            if (SystemPath[i] == '\0') {

                SystemPath[i] = '\\';     // append a '\' to the end
                SystemPath[i+1] = '\0';
                i++;
                break;
            }
        }

        for (offset=0; offset < sizeof("RADMIN32.DLL"); offset++ ) {
            SystemPath[i+offset] = DllName[offset];
        }

        IF_DEBUG(INIT_TERM) {
            LdapPrint1("Looking to load %s\n", SystemPath);
        }

        ScramblingLibraryHandle = LoadLibraryA( SystemPath );

        if (ScramblingLibraryHandle == NULL) {

            IF_DEBUG(INIT_TERM) {
                LdapPrint1("LDAP: Failed to load %s\n", SystemPath);
            }

        } else {
            IF_DEBUG(INIT_TERM) {
                LdapPrint1("Succeeded in loading %s\n", SystemPath);
            }
        }
    }

GetFnPtrs:

    GlobalUseScrambling = FALSE;

    if ((AdvApi32LibraryHandle) && (ScramblingLibraryHandle) && (GlobalWinNT)) {
        //
        // Try to get the advapi32.dll RtlEncryptMemory/RtlDecryptMemory functions,
        // along with ntdll's RtlInitUnicodeString.  Note that RtlEncryptMemory
        // and RtlDecryptMemory are really named SystemFunction040/041, hence
        // the macros.
        //

        pRtlEncryptMemory = (FRTLENCRYPTMEMORY) GetProcAddress( AdvApi32LibraryHandle, STRINGIZE(RtlEncryptMemory) );
        pRtlDecryptMemory = (FRTLDECRYPTMEMORY) GetProcAddress( AdvApi32LibraryHandle, STRINGIZE(RtlDecryptMemory) );
        pRtlInitUnicodeString = (FNRTLINITUNICODESTRING) GetProcAddress( ScramblingLibraryHandle, "RtlInitUnicodeString" );

        if (pRtlEncryptMemory && pRtlDecryptMemory && pRtlInitUnicodeString) {
            //
            // We want to use scrambling
            //
        
            GlobalUseScrambling =  TRUE;

            IF_DEBUG(INIT_TERM) {
                LdapPrint0("Using Strong Scrambling APIs\n");
            }

            goto LoadDone;
        }
        else {
            //
            // Clean up so we can try falling back to the run-encode scrambling functions
            // (we keep the AdvApi32LibraryHandle around since we'll probably need it
            // later anyway)
            //
            pRtlEncryptMemory = NULL;
            pRtlDecryptMemory = NULL;
            pRtlInitUnicodeString = NULL;
        }
    }

    if (ScramblingLibraryHandle) {

        pRtlInitUnicodeString = (FNRTLINITUNICODESTRING) GetProcAddress( ScramblingLibraryHandle, "RtlInitUnicodeString" );
        pRtlRunEncodeUnicodeString = (FRTLRUNENCODEUNICODESTRING) GetProcAddress( ScramblingLibraryHandle, "RtlRunEncodeUnicodeString" );
        pRtlRunDecodeUnicodeString = (FRTLRUNDECODEUNICODESTRING) GetProcAddress( ScramblingLibraryHandle, "RtlRunDecodeUnicodeString" );
    }

    if (!ScramblingLibraryHandle ||
        !pRtlInitUnicodeString ||
        !pRtlRunEncodeUnicodeString ||
         !pRtlRunDecodeUnicodeString) {

        //
        // If we failed to get even one of these functions, we shouldn't try scrambling
        //

        IF_DEBUG(INIT_TERM) {
            LdapPrint0("LDAP: Failed to load scrambling APIs\n");
        }

        if (ScramblingLibraryHandle) {

            FreeLibrary( ScramblingLibraryHandle );
            ScramblingLibraryHandle = NULL;
        }

        ScramblingLibraryHandle = NULL;
        pRtlInitUnicodeString = NULL;
        pRtlRunEncodeUnicodeString = NULL;
        pRtlRunDecodeUnicodeString = NULL;

    } else {
        GlobalUseScrambling = TRUE;
    
        IF_DEBUG(INIT_TERM) {
            LdapPrint0("Using Scrambling APIs\n");
        }
    }

LoadDone:
    
    if ( GlobalWinsock11 ) {

        wVersion = MAKEWORD( 1, 1 );

    } else {

        wVersion = MAKEWORD( 2, 0 );
    }

    IF_DEBUG(INIT_TERM) {
        LdapPrint0( "LDAP Client initializing Winsock.\n" );
    }

    err = (*pWSAStartup)( wVersion, &GlobalLdapWSAData );

    if (err != 0) {

        IF_DEBUG(ERRORS) {
            LdapPrint1( "LDAP client failed to init Winsock, err = 0x%x.\n", (*pWSAGetLastError)());
        }
        goto error;
    }

    IF_DEBUG(INIT_TERM) {
        LdapPrint0( "LDAP Client initialized winsock.\n" );
    }

    //
    // We create the select wakeup socket.
    //

    LdapGlobalWakeupSelectHandle = (*psocket)(PF_INET, SOCK_DGRAM, 0);

    if (LdapGlobalWakeupSelectHandle == INVALID_SOCKET) {
       LdapPrint1("Failed to create socket in LdapClientInitialize: %d\n", (*pWSAGetLastError)());
       goto error;
    }

    //
    // Bind the socket to a local port
    //

    sa.sin_family = AF_INET;

    retval = (*pbind) ( LdapGlobalWakeupSelectHandle,
                       (SOCKADDR*) &sa,
                       sizeof(sa)
                       );

    if (retval != 0) {
       LdapPrint1("Failed to bind socket in LdapClientInitialize: %d\n", (*pWSAGetLastError)() );
       goto error;
    }

    //
    // Find out which port the system bound the socket to
    //

    retval = (*pgetsockname) ( LdapGlobalWakeupSelectHandle,
                              (SOCKADDR*) &sa,
                              &buffersize
                              );

    if (retval != 0) {
       LdapPrint1("Failed in getsockname in LdapClientInitialize: %d\n", (*pWSAGetLastError)() );
       goto error;
    }

    //
    // Connect the socket to itself
    //

    sa.sin_family = AF_INET;
    sa.sin_addr.s_addr = (*pinet_addr)("127.0.0.1");
    retval = (*pconnect)( LdapGlobalWakeupSelectHandle,
                         (SOCKADDR*) &sa,
                         sizeof( sa )
                         );

    if (retval != 0) {
       LdapPrint1("Failed to connect socket to itself in LdapClientInitialize: %d\n", (*pWSAGetLastError)() );
       goto error;
    }

    //
    // Mark it non-blocking so that sends and receives don't block
    //

    retval = (*pioctlsocket)( LdapGlobalWakeupSelectHandle,
                              FIONBIO,
                              &nonblockingMode
                              );

    if (retval != 0) {
       LdapPrint1("Failed to set socket to nonblocking in LdapClientInitialize: %d\n", (*pWSAGetLastError)() );
       goto error;
    }

    GlobalCloseWinsock = TRUE;

    RELEASE_LOCK( &LoadLibLock );
    return TRUE;

error:
    
    if ( WinsockLibraryHandle ) {

        FreeLibrary( WinsockLibraryHandle );
        WinsockLibraryHandle = NULL;
    }

    if ( ScramblingLibraryHandle ) {

        FreeLibrary( ScramblingLibraryHandle );
        ScramblingLibraryHandle = NULL;
    }
    
    RELEASE_LOCK( &LoadLibLock );
    return FALSE;

}


BOOL
LdapClientTerminate (
    BOOL AllClean
    )
//
//  The DLL is being unloaded from memory.  Cleanup all resources allocated.
//
{
    PLDAP_CONN connection;
    PLIST_ENTRY listEntry;
    PLDAP_REQUEST request;
    PLDAP_MESSAGEWAIT waitStructure;
    PTHREAD_ENTRY pEntry;


    IF_DEBUG(INIT_TERM) {
        LdapPrint0( "LDAP Client API 32 terminating.\n" );
    }

    //
    //  close (immediately) all active connections
    //

    if ( GlobalLdapShutdownEvent != NULL ) {

       ResetEvent( GlobalLdapShutdownEvent );
    }

    GlobalLdapShuttingDown = TRUE;

    if (GlobalHasInitialized == FALSE) {

        // We didn't (completely) initialize, so nothing to clean up.
        // Partial initialization prior to GlobalHasInitialized being set
        // to TRUE would have cleaned up after itself when it failed.

        IF_DEBUG(INIT_TERM) {
            LdapPrint0( "LDAP Client API 32 termination after incomplete initialization.\n" );
        }

        return TRUE;
    }

    //
    //  close all requests
    //

    if (AllClean) {

        ACQUIRE_LOCK( &RequestListLock );

        listEntry = GlobalListRequests.Flink;

        while (listEntry != &GlobalListRequests) {

            request = CONTAINING_RECORD( listEntry, LDAP_REQUEST, RequestListEntry );
            request = ReferenceLdapRequest(request);

            if (! request) {

                listEntry = listEntry->Flink;
                continue;
            }

            RELEASE_LOCK( &RequestListLock );

            CloseLdapRequest( request );

            DereferenceLdapRequest( request );

            ACQUIRE_LOCK( &RequestListLock );

            listEntry = GlobalListRequests.Flink;
        }

        RELEASE_LOCK( &RequestListLock );
    }

    //
    //  shutdown all connections
    //

    ACQUIRE_LOCK( &ConnectionListLock );

    listEntry = GlobalListActiveConnections.Flink;

    while (listEntry != &GlobalListActiveConnections) {

        connection = CONTAINING_RECORD( listEntry, LDAP_CONN, ConnectionListEntry );

        connection = ReferenceLdapConnection( connection );

        if (!connection) {

            listEntry = listEntry->Flink;
            continue;
        }

        RELEASE_LOCK( &ConnectionListLock );

        //
        //  CloseLdapConnection MUST set the state to closing or we loop here.
        //

        CloseLdapConnection( connection);

        DereferenceLdapConnection( connection );

        ACQUIRE_LOCK( &ConnectionListLock );

        listEntry = GlobalListActiveConnections.Flink;
    }

    //
    //  Let all waiters go.
    //

    listEntry = GlobalListWaiters.Flink;

    while (listEntry != &GlobalListWaiters) {

        waitStructure = CONTAINING_RECORD( listEntry,
                                           LDAP_MESSAGEWAIT,
                                           WaitListEntry );
        listEntry = listEntry->Flink;

        waitStructure->Satisfied = TRUE;
        SetEvent( waitStructure->Event );
    }

    RELEASE_LOCK( &ConnectionListLock );

    if (GlobalWaiterCount > 0 &&
        GlobalLdapShutdownEvent != NULL ) {

        IF_DEBUG(INIT_TERM) {
            LdapPrint1( "LdapClientTerminate waiting for 0x%x threads.\n",
                        GlobalWaiterCount );
        }

        WaitForSingleObjectEx( GlobalLdapShutdownEvent,
                               INFINITE,
                               TRUE );         // alertable
    }

    if ( GlobalLdapShutdownEvent != NULL ) {

        CloseHandle( GlobalLdapShutdownEvent );
        GlobalLdapShutdownEvent = NULL;
    }

    //
    // Destroy the per-thread list.
    // This requires destroying the per-thread entry for each
    // thread in the list.
    //
    ACQUIRE_LOCK( &PerThreadListLock );

    while (!IsListEmpty(&GlobalPerThreadList)) {

        // Get the first entry and free it (RemovePerThreadEntry will take
        // care of removing it from the list & deallocating the memory)
        pEntry = CONTAINING_RECORD(GlobalPerThreadList.Flink, THREAD_ENTRY, ThreadEntry);
        RemovePerThreadEntry(pEntry->dwThreadID);
    }
    
    RELEASE_LOCK( &PerThreadListLock );

    //
    // Clean up our cache pages.
    //

    ACQUIRE_LOCK( &CacheLock );
    FreeEntireLdapCache();
    RELEASE_LOCK( &CacheLock );

    DELETE_LOCK( &CacheLock );
    DELETE_LOCK( &ConnectionListLock );
    DELETE_LOCK( &RequestListLock );

    if (LdapHeap != NULL &&
        LdapHeap != GetProcessHeap()) {

        HeapDestroy( LdapHeap );
        LdapHeap = NULL;
    }

    if (GlobalCloseWinsock) {

        GlobalCloseWinsock = FALSE;
        (*pWSACleanup)();
    }

    if (SslPackagesInstalled != NULL) {

        SslFunctionTableW->FreeContextBuffer( SslPackagesInstalled );
        SslPackagesInstalled = NULL;
    }

    if (SslLibraryHandle != NULL) {

        FreeLibrary( SslLibraryHandle );
        SslLibraryHandle = NULL;
    }

    if (ScramblingLibraryHandle != NULL) {

        FreeLibrary( ScramblingLibraryHandle );
        ScramblingLibraryHandle = NULL;
    }

    if (SecurityPackagesInstalled != NULL) {

        SspiFunctionTableW->FreeContextBuffer( SecurityPackagesInstalled );
        SecurityPackagesInstalled = NULL;
    }

    if (SecurityLibraryHandle != NULL) {

        FreeLibrary( SecurityLibraryHandle );
        SecurityLibraryHandle = NULL;
    }

    if ( LdapGlobalWakeupSelectHandle != INVALID_SOCKET ) {

        int sockerr = (*pclosesocket)(LdapGlobalWakeupSelectHandle);
        ASSERT(sockerr == 0); 
        LdapGlobalWakeupSelectHandle = INVALID_SOCKET;
    }

    if (WinsockLibraryHandle != NULL) {

        FreeLibrary( WinsockLibraryHandle );
        WinsockLibraryHandle = NULL;
    }

    if (NetApi32LibraryHandle != NULL) {

        FreeLibrary( NetApi32LibraryHandle );
        NetApi32LibraryHandle = NULL;
    }

    if (AdvApi32LibraryHandle != NULL) {

        FreeLibrary( AdvApi32LibraryHandle );
        AdvApi32LibraryHandle = NULL;
    }

    UnloadPingLibrary();

    if (GlobalTlsLastErrorIndex != (DWORD) -1) {

        TlsFree( GlobalTlsLastErrorIndex );
        GlobalTlsLastErrorIndex = (DWORD) -1;
    }

    DELETE_LOCK( &LoadLibLock );
    DELETE_LOCK( &SelectLock1 );
    DELETE_LOCK( &SelectLock2 );
    DELETE_LOCK( &PerThreadListLock );
    
    IF_DEBUG(INIT_TERM) {
        LdapPrint0( "LDAP Client API 32 termination complete.\n" );
    }

    return TRUE;
}

ULONG __cdecl ldap_startup (
    PLDAP_VERSION_INFO version,
    HANDLE *hInstance
    )
{
    BOOL rc;

    DBG_UNREFERENCED_PARAMETER( hInstance );

    //
    //  we may make this more complicated in future versions.
    //

    if ((version->lv_size != sizeof(LDAP_VERSION)) ||
        (version->lv_major != LAPI_MAJOR_VER1) ||
        (version->lv_minor != LAPI_MINOR_VER1)) {

        return LDAP_OPERATIONS_ERROR;
    }

    //
    //  Set to highest level we support.
    //

    version->lv_major = LAPI_MAJOR_VER1;
    version->lv_minor = LAPI_MINOR_VER1;

    rc = LdapClientInitialize( GlobalLdapDllInstance );

    return( (rc == TRUE) ? LDAP_SUCCESS : LDAP_OPERATIONS_ERROR );
}


ULONG __cdecl ldap_cleanup (
    HANDLE hInstance
    )
//
//  Cleanup all resources owned by library.
//
{
    ULONG prevRefCount;
    BOOL rc;

    DBG_UNREFERENCED_PARAMETER( hInstance );
    
    prevRefCount = InterlockedDecrement( &GlobalLoadUnloadRefCount );

    if (prevRefCount > 0) {

        return LDAP_SUCCESS;
    }

    rc = LdapClientTerminate( TRUE );

    return( (rc == TRUE) ? LDAP_SUCCESS : LDAP_OPERATIONS_ERROR );
}

// initterm.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\modify.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    modify.cxx handle modify requests to an LDAP server

Abstract:

   This module implements the LDAP modify APIs.

Author:

    Andy Herron (andyhe)        02-Jul-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

ULONG
EncodeModifyList (
    CLdapBer *Lber,
    LDAPModW *ModificationList[],
    BOOLEAN Unicode
    );

ULONG
LdapModify (
    PLDAP_CONN connection,
    PWCHAR DistinguishedName,
    LDAPModW *ModificationList[],
    BOOLEAN Unicode,
    BOOLEAN Synchronous,
    PLDAPControlW *ServerControls,
    PLDAPControlW *ClientControls,
    ULONG  *MessageNumber
    )
//
//  This allows a client to modify an entry in the tree.  Note that if Unicode
//  is FALSE, then the AttributeList does not point to a list of Unicode
//  attributes, but rather a list of single byte attributes.
//
{
    ULONG err = LDAP_SUCCESS;
    ULONG messageNumber;
    PLDAP_REQUEST request = NULL;

    if (MessageNumber == NULL) {

        return LDAP_PARAM_ERROR;
    }

    *MessageNumber = (ULONG) -1;

    err = LdapConnect( connection, NULL, FALSE );

    if (err != 0) {
       return err;
    }

    SetConnectionError( connection, LDAP_SUCCESS, NULL );

    request = LdapCreateRequest( connection, LDAP_MODIFY_CMD );

    if (request == NULL) {

        IF_DEBUG(OUTMEMORY) {
            LdapPrint1( "ldap_modify connection 0x%x couldn't allocate request.\n", connection);
        }
        err = LDAP_NO_MEMORY;
        SetConnectionError( connection, err, NULL );
        return err;
    }

    messageNumber = request->MessageId;

    request->Synchronous = Synchronous;

    request->modify.Unicode = Unicode;

    err = LDAP_SUCCESS;

    if ((ServerControls != NULL) || (ClientControls != NULL)) {

        err = LdapCheckControls( request,
                                 ServerControls,
                                 ClientControls,
                                 Unicode,
                                 0 );

        if (err != LDAP_SUCCESS) {

            IF_DEBUG(CONTROLS) {
                LdapPrint2( "ldap_modify connection 0x%x trouble with SControl, err 0x%x.\n",
                            connection, err );
            }
        }
    }

    if (err == LDAP_SUCCESS) {

        if (Synchronous || (request->ChaseReferrals == 0)) {

            request->AllocatedParms = FALSE;
            request->OriginalDN = DistinguishedName;
            request->modify.AttributeList = ModificationList;

        } else {

            request->AllocatedParms = TRUE;

            if (DistinguishedName != NULL) {

                request->OriginalDN = ldap_dup_stringW( DistinguishedName, 0, LDAP_UNICODE_SIGNATURE );

                if (request->OriginalDN == NULL) {

                    err = LDAP_NO_MEMORY;
                }
            }
            if ( err == LDAP_SUCCESS ) {

                err = LdapDupLDAPModStructure(  ModificationList,
                                                Unicode,
                                                &request->modify.AttributeList );
            }
        }
    }

    if (err == LDAP_SUCCESS) {

        START_LOGGING;
        DSLOG((DSLOG_FLAG_TAG_CNPN,"[+]"));
        DSLOG((0,"[ID=%d][OP=ldap_modify][DN=%ws][ST=%I64d]\n",
               request->MessageId,DistinguishedName,request->RequestTime));
        LogAttributesAndControls(NULL, ModificationList, ServerControls, Unicode);
        DSLOG((DSLOG_FLAG_NOTIME,"[-]\n"));
        END_LOGGING;

        err = SendLdapModify( request,
                              connection,
                              request->OriginalDN,
                              (CLdapBer **)&request->BerMessageSent,
                              request->modify.AttributeList,
                              request->modify.Unicode,
                              0 );
    }

    if (err != LDAP_SUCCESS) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "ldap_modify connection 0x%x send with error of 0x%x.\n",
                        connection, err );
        }

        DSLOG((0,"[+][ID=%d][ET=%I64d][ER=%d][-]\n",request->MessageId,LdapGetTickCount(), err));
        messageNumber = (ULONG) -1;
        SetConnectionError( connection, err, NULL );

        CloseLdapRequest( request );
    }

    DereferenceLdapRequest( request );
    *MessageNumber = messageNumber;
    return err;
}


ULONG __cdecl
ldap_modifyW (
    LDAP *ExternalHandle,
    PWCHAR DistinguishedName,
    LDAPModW *AttributeList[]
    )
//
//  This is the client API to allow modifying objects in the directory.
//
{
    ULONG err;
    ULONG msgId;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {

        return LDAP_PARAM_ERROR;
    }

    err =  LdapModify( connection,
                       DistinguishedName,
                       AttributeList,
                       TRUE,
                       FALSE,
                       NULL,
                       NULL,
                       &msgId
                       );

    DereferenceLdapConnection( connection );

    return msgId;
}

ULONG __cdecl
ldap_modify (
    LDAP *ExternalHandle,
    PCHAR DistinguishedName,
    LDAPModA *AttributeList[]
    )
{
    ULONG err;
    ULONG msgId = (ULONG) -1;

    err = ldap_modify_extA( ExternalHandle,
                            DistinguishedName,
                            AttributeList,
                            NULL,
                            NULL,
                            &msgId
                            );
    return msgId;
}

ULONG __cdecl
ldap_modify_sW (
    LDAP *ExternalHandle,
    PWCHAR DistinguishedName,
    LDAPModW *AttributeList[]
    )
{
    return ldap_modify_ext_sW(  ExternalHandle,
                                DistinguishedName,
                                AttributeList,
                                NULL,
                                NULL
                                );
}

ULONG __cdecl
ldap_modify_s (
    LDAP *ExternalHandle,
    PCHAR DistinguishedName,
    LDAPModA *AttributeList[]
    )
//
//  This is the client API to allow modifying objects to the directory.
//
{
    return ldap_modify_ext_sA(  ExternalHandle,
                                DistinguishedName,
                                AttributeList,
                                NULL,
                                NULL
                                );
}

WINLDAPAPI ULONG LDAPAPI ldap_modify_extW(
        LDAP *ExternalHandle,
        PWCHAR DistinguishedName,
        LDAPModW *AttributeList[],
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        ULONG          *MessageNumber
        )
{
    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {

        return LDAP_PARAM_ERROR;
    }

    err = LdapModify(  connection,
                       DistinguishedName,
                       AttributeList,
                       TRUE,
                       FALSE,
                       ServerControls,
                       ClientControls,
                       MessageNumber
                       );

    DereferenceLdapConnection( connection );

    return err;
}

WINLDAPAPI ULONG LDAPAPI ldap_modify_extA(
        LDAP *ExternalHandle,
        PCHAR DistinguishedName,
        LDAPModA *AttributeList[],
        PLDAPControlA   *ServerControls,
        PLDAPControlA   *ClientControls,
        ULONG          *MessageNumber
        )
{
    ULONG err;
    PWCHAR wName = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if ((connection == NULL) || (MessageNumber == NULL)) {

        err = LDAP_PARAM_ERROR;
        goto error;
    }

    *MessageNumber = (ULONG) -1;

    err = ToUnicodeWithAlloc( DistinguishedName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, err, NULL );
        goto error;
    }

    err = LdapModify( connection,
                      wName,
                      (LDAPModW **)AttributeList,
                      FALSE,
                      FALSE,
                      (PLDAPControlW *) ServerControls,
                      (PLDAPControlW *) ClientControls,
                      MessageNumber
                      );

error:
    if (wName)
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    if (connection)
        DereferenceLdapConnection( connection );

    return err;
}

WINLDAPAPI ULONG LDAPAPI ldap_modify_ext_sW(
        LDAP *ExternalHandle,
        PWCHAR DistinguishedName,
        LDAPModW *AttributeList[],
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls
        )
{
    ULONG msgId;
    ULONG err;
    LDAPMessage *results = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapModify(   connection,
                        DistinguishedName,
                        AttributeList,
                        TRUE,
                        TRUE,
                        ServerControls,
                        ClientControls,
                        &msgId
                        );

    //
    //  if we error'd out before we sent the request, return the error here.
    //

    if (msgId != (ULONG) -1) {

        //
        //  we simply need to wait for the response to come in.
        //

        err = ldap_result_with_error( connection,
                                      msgId,
                                      LDAP_MSG_ALL,
                                      NULL,           // no timeout value specified
                                      &results,
                                      NULL
                                      );

        if (results == NULL) {

            LdapAbandon( connection, msgId, TRUE );

        } else {

            err = ldap_result2error( ExternalHandle,
                                     results,
                                     TRUE
                                     );
        }
    }

    DereferenceLdapConnection( connection );

    return err;
}

WINLDAPAPI ULONG LDAPAPI ldap_modify_ext_sA(
        LDAP *ExternalHandle,
        PCHAR DistinguishedName,
        LDAPModA *AttributeList[],
        PLDAPControlA   *ServerControls,
        PLDAPControlA   *ClientControls
        )
{
    ULONG err;
    PWCHAR wName = NULL;
    ULONG msgId;
    LDAPMessage *results = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = ToUnicodeWithAlloc( DistinguishedName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        goto error;
    }

    err = LdapModify(   connection,
                        wName,
                        (LDAPModW **)AttributeList,
                        FALSE,
                        TRUE,
                        (PLDAPControlW *) ServerControls,
                        (PLDAPControlW *) ClientControls,
                        &msgId
                        );

    //
    //  if we error'd out before we sent the request, return the error here.
    //

    if (msgId != (ULONG) -1) {

        //
        //  we simply need to wait for the response to come in.
        //

        err = ldap_result_with_error( connection,
                                      msgId,
                                      LDAP_MSG_ALL,
                                      NULL,           // no timeout value specified
                                      &results,
                                      NULL
                                      );

        if (results == NULL) {

            LdapAbandon( connection, msgId, TRUE );

        } else {

            err = ldap_result2error( ExternalHandle,
                                     results,
                                     TRUE
                                     );
        }
    }

error:
    if (wName)
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    DereferenceLdapConnection( connection );

    return err;
}


ULONG
SendLdapModify (
    PLDAP_REQUEST Request,
    PLDAP_CONN Connection,
    PWCHAR DistinguishedName,
    CLdapBer **Lber,
    LDAPModW *AttributeList[],
    BOOLEAN Unicode,
    LONG AltMsgId
    )
//
//  This allows a client to modify an entry in the tree.  Note that if Unicode
//  is FALSE, then the AttributeList does not point to a list of Unicode
//  attributes, but rather a list of single byte attributes.
//
{
    ULONG hr;

    if ( (Connection->publicLdapStruct.ld_version == LDAP_VERSION2) &&
         ( LdapCheckForMandatoryControl( Request->ServerControls ) == TRUE )) {

        IF_DEBUG(CONTROLS) {
            LdapPrint1( "SendLdapModify Connection 0x%x has mandatory controls.\n", Connection);
        }
        SetConnectionError( Connection, LDAP_UNAVAILABLE_CRIT_EXTENSION, NULL );
        return LDAP_UNAVAILABLE_CRIT_EXTENSION;
    }

    CLdapBer *lber = new CLdapBer( Connection->publicLdapStruct.ld_version );

    if (lber == NULL) {
        SetConnectionError( Connection, LDAP_NO_MEMORY, NULL );
        return LDAP_NO_MEMORY;
    }

    //
    //  The request looks like the following :
    //
    //  ModifyRequest ::=
    //    [APPLICATION 6] SEQUENCE {
    //         object         LDAPDN,
    //         modification   SEQUENCE OF SEQUENCE {
    //                             operation      ENUMERATED {
    //                                                 add       (0),
    //                                                 delete    (1),
    //                                                 replace   (2)
    //                                            },
    //                             modification   SEQUENCE {
    //                                               type    AttributeType,
    //                                               values  SET OF
    //                                                         AttributeValue
    //                                            }
    //                        }
    //    }
    //
    //              attrs          SEQUENCE OF SEQUENCE {
    //                                  type          AttributeType,
    //                                  values        SET OF AttributeValue
    //                             }
    //         }
    //

    hr = lber->HrStartWriteSequence();
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldap_modify startWrite conn 0x%x encoding error of 0x%x.\n",
                        Connection, hr );
        }
encodingError:
        if (lber != NULL) {

           delete lber;
        }
        return LDAP_ENCODING_ERROR;

    } else {            // we can't forget EndWriteSequence

       if (AltMsgId != 0) {

          hr = lber->HrAddValue((LONG) AltMsgId );

       } else {

          hr = lber->HrAddValue((LONG) Request->MessageId );
       }

       if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldap_modify MsgNo conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            goto encodingError;
        }

        hr = lber->HrStartWriteSequence(LDAP_MODIFY_CMD);
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldap_modify cmd conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            goto encodingError;

        } else {        // we can't forget EndWriteSequence

            hr = lber->HrAddValue((const WCHAR *) DistinguishedName );
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_modify DN conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                goto encodingError;
            }

            //
            //  add the modification list and we're done.
            //

            hr = lber->HrStartWriteSequence();
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_modify attrlist conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                goto encodingError;

            } else {        // we can't forget EndWriteSequence

                hr = EncodeModifyList( lber,
                                       AttributeList,
                                       Unicode );

                if (hr != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "ldap_modify attrlist conn 0x%x encoding error of 0x%x.\n",
                                    Connection, hr );
                    }
                    if (lber != NULL) {

                       delete lber;
                    }
                    return hr;
                }

                hr = lber->HrEndWriteSequence();
                ASSERT( hr == NOERROR );
            }

            hr = lber->HrEndWriteSequence();
            ASSERT( hr == NOERROR );
        }

        //
        //  put in the server controls here if required
        //

        if ( (Connection->publicLdapStruct.ld_version != LDAP_VERSION2) &&
             ( Request->ServerControls != NULL )) {

            hr = InsertServerControls( Request, Connection, lber );

            if (hr != LDAP_SUCCESS) {

                if (lber != NULL) {

                   delete lber;
                }
                return hr;
            }
        }

        hr = lber->HrEndWriteSequence();
        ASSERT( hr == NOERROR );
    }

    //
    //  send the modify request.
    //

    ACQUIRE_LOCK( &Connection->ReconnectLock );

    AddToPendingList( Request, Connection );

    hr = LdapSend( Connection, lber );

    if (hr != LDAP_SUCCESS) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "ldap_modify connection 0x%x send with error of 0x%x.\n",
                        Connection, hr );
        }
        DecrementPendingList( Request, Connection );

    } else {

        //
        //  Save off the lber value, free any lber message that is already
        //  present.
        //

        lber = (CLdapBer *) InterlockedExchangePointer((PVOID *) Lber,
                                                       (PVOID) lber );
    }

    RELEASE_LOCK( &Connection->ReconnectLock );

    if (lber != NULL) {

       delete lber;
    }

    return hr;
}


ULONG
EncodeModifyList (
    CLdapBer *Lber,
    LDAPModW *ModificationList[],
    BOOLEAN Unicode
    )
//
//  This routine is used by LdapModify to copy a list of LDAPMOD records
//  to an outgoing message.
//
//         modification   SEQUENCE OF SEQUENCE {
//                             operation      ENUMERATED {
//                                                 add       (0),
//                                                 delete    (1),
//                                                 replace   (2)
//                                            },
//                             modification   SEQUENCE {
//                                               type    AttributeType,
//                                               values  SET OF
//                                                         AttributeValue
//                                            }
//                        }
//    }
//
//              attrs          SEQUENCE OF SEQUENCE {
//                                  type          AttributeType,
//                                  values        SET OF AttributeValue
//                             }
//         }
{
    ULONG count = 0;
    ULONG hr;

    if (ModificationList == NULL) {

        return LDAP_SUCCESS;
    }

    while (ModificationList[count] != NULL) {

        PLDAPModW attr = ModificationList[count];
        ULONG operation = attr->mod_op & ~LDAP_MOD_BVALUES;

        hr = Lber->HrStartWriteSequence();
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint1( "EncodeModifyList attrlist 2 encoding error of 0x%x.\n", hr );
            }
            return LDAP_ENCODING_ERROR;

        } else {    // we can't forget EndWriteSequence

            //
            //  write out the modification operation
            //

            if ((operation != LDAP_MOD_ADD) &&
                (operation != LDAP_MOD_DELETE) &&
                (operation != LDAP_MOD_REPLACE)) {

                IF_DEBUG(PARSE) {
                    LdapPrint1( "EncodeModifyList invalid operation of 0x%x.\n", operation );
                }
                return LDAP_PARAM_ERROR;
            }

            hr = Lber->HrAddValue((LONG) operation, BER_ENUMERATED);
            if (hr != NOERROR) {
                IF_DEBUG(PARSE) {
                    LdapPrint1( "EncodeModifyList attrlist 3 encoding error of 0x%x.\n", hr );
                }
                return LDAP_ENCODING_ERROR;
            }

            hr = Lber->HrStartWriteSequence();
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint1( "EncodeModifyList attrlist 4 encoding error of 0x%x.\n", hr );
                }
                return LDAP_ENCODING_ERROR;

            } else {    // we can't forget EndWriteSequence

                //
                //  write out the attribute type to modify
                //
                //  We don't have to worry when adding the attribute
                //  types if we need to convert them to unicode to
                //  preserve any DBCS codes as they should be IA5
                //  attribute names only.
                //

                if (Unicode) {

                    hr = Lber->HrAddValue((const WCHAR *) attr->mod_type );

                } else {

                    hr = Lber->HrAddValue((const CHAR *) attr->mod_type );
                }
                if (hr != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint1( "EncodeModifyList attrlist 3 encoding error of 0x%x.\n", hr );
                    }
                    return LDAP_ENCODING_ERROR;
                }

                hr = Lber->HrStartWriteSequence(BER_SET);
                if (hr != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint1( "EncodeModifyList attrlist 4 encoding error of 0x%x.\n", hr );
                    }
                    return LDAP_ENCODING_ERROR;

                } else {    // we can't forget EndWriteSequence

                    //
                    //  the attribute value is either a string or a ptr to
                    //  a berval structure.  Handle appropriately.
                    //

                    if (attr->mod_op & LDAP_MOD_BVALUES) {

                        //
                        //  array of berval structures, put each one into request
                        //

                        if (attr->mod_vals.modv_bvals == NULL) {

                            if (operation != LDAP_MOD_DELETE) {

                                IF_DEBUG(PARSE) {
                                    LdapPrint0( "EncodeModifyList attrlist is empty\n" );
                                }
                                return LDAP_PARAM_ERROR;
                            }

                        } else {

                            //
                            //  the values exist, encode them.
                            //

                            ULONG valCount = 0;

                            while (attr->mod_vals.modv_bvals[valCount]) {

                                PLDAP_BERVAL berValue = attr->mod_vals.modv_bvals[valCount++];

                                hr = Lber->HrAddBinaryValue((BYTE *) berValue->bv_val,
                                                                    berValue->bv_len );
                                if (hr != NOERROR) {

                                    IF_DEBUG(PARSE) {
                                        LdapPrint1( "EncodeModifyList attrlist 5 encoding error of 0x%x.\n", hr );
                                    }
                                    return LDAP_ENCODING_ERROR;
                                }
                            }
                        }

                    } else {

                        //
                        //  array of strings, put each one into request
                        //

                        if (attr->mod_vals.modv_strvals == NULL) {

                            if ((operation != LDAP_MOD_DELETE) &&
                                (operation != LDAP_MOD_REPLACE)) {

                                IF_DEBUG(PARSE) {
                                    LdapPrint0( "EncodeModifyList attrlist is empty\n" );
                                }
                                return LDAP_PARAM_ERROR;
                            }

                        } else {

                            //
                            //  the values exist, encode them.
                            //

                            ULONG valCount = 0;

                            while (attr->mod_vals.modv_strvals[valCount]) {

                                if (Unicode) {

                                    PWCHAR strValue = attr->mod_vals.modv_strvals[valCount++];

                                    hr = Lber->HrAddValue((const WCHAR *) strValue );

                                } else {

                                    PWCHAR wValue = NULL;
                                    PCHAR strValue = ((PLDAPModA)attr)->mod_vals.modv_strvals[valCount++];

                                    //
                                    //  We need to convert from single byte
                                    //  to unicode.  Otherwise we may be
                                    //  putting DBCS codes into the UTF8
                                    //  stream, which would not be good.
                                    //

                                    hr = ToUnicodeWithAlloc( strValue,
                                                             -1,
                                                             &wValue,
                                                             LDAP_UNICODE_SIGNATURE,
                                                             LANG_ACP );

                                    if (hr == LDAP_SUCCESS) {

                                        hr = Lber->HrAddValue((const WCHAR *) wValue );
                                    }

                                    ldapFree( wValue, LDAP_UNICODE_SIGNATURE );
                                }
                                if (hr != NOERROR) {

                                    IF_DEBUG(PARSE) {
                                        LdapPrint1( "EncodeModifyList attrlist 6 encoding error of 0x%x.\n", hr );
                                    }
                                    return LDAP_ENCODING_ERROR;
                                }
                            }
                        }
                    }
                }
                hr = Lber->HrEndWriteSequence();     // BER_SET
                ASSERT( hr == NOERROR );
            }
            hr = Lber->HrEndWriteSequence();
            ASSERT( hr == NOERROR );
        }
        hr = Lber->HrEndWriteSequence();
        ASSERT( hr == NOERROR );

        count++;
    }           // while modificationList != NULL

    return LDAP_SUCCESS;
}

// modify.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\names.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    names.cxx handle LDAP names

Abstract:

   This module implements the APIs to break apart LDAP names

Author:

    Andy Herron   (andyhe)        02-Jul-1996
    Anoop Anantha (anoopa)        09-Aug-2000

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

WCHAR
ia5_toupper( WCHAR ch );

PWCHAR * __cdecl
ldap_explode_dnW (
    PWCHAR dn,
    ULONG notypes
    )
//
//  explode the name "cn=andyhe, o=microsoft, c=US"
//  into ->  cn=andyhe
//           o=microsoft
//           c=US
//
{
    PWCHAR currentPosition = dn;
    WCHAR savedChar;
    ULONG numberEntries = 0;
    PWCHAR nextSeparator;        // pointer to separator
    PWCHAR *arrayToReturn = NULL;
    PWCHAR  endOfValue;          // end of current value, no spaces or quotes

    if (currentPosition == NULL) {

        return NULL;
    }

    __try {

        while ((*currentPosition != L'=') && (*currentPosition != L'\0')) {
            currentPosition++;
        }
    
        if (*currentPosition != L'=') {
    
            //
            //  This does not contain = signs, therefore must be DNS name only.
            //  These contain either '@' or '.', so we separate them out based
            //  on these.
            //
    
            currentPosition = dn;
    
            //
            //  we don't use strtok here because the WAB guys don't want us to
            //  load MSVCRT dll.
            //
    
            while (*currentPosition != L'\0') {
    
                nextSeparator = currentPosition;
    
                while ((*nextSeparator != L'\0') &&
                       (*nextSeparator != L'@')  &&
                       (*nextSeparator != L'.') ) {
                    nextSeparator++;
                }
    
                savedChar = *nextSeparator;
                *nextSeparator = L'\0';
    
                add_string_to_list( &arrayToReturn,
                                    &numberEntries,
                                    currentPosition,
                                    TRUE );
    
                *nextSeparator = savedChar;
                currentPosition = nextSeparator;
    
                if (*currentPosition != L'\0') {
                    currentPosition++;
                }
            }
    
            return arrayToReturn;
        }
    
        //
        //  These contain either '@' or '.', so we separate them out based
        //  on these.
        //
    
        currentPosition = dn;
    
        //
        //  we don't use strtok here because the WAB guys don't want us to
        //  load MSVCRT dll.
        //
    
        while (*currentPosition != L'\0') {
    
           nextSeparator = currentPosition;
    
            //
            //  pick up the next full ava "cn = bob" or "cn = bob\" robert"
            //
    
            do {
    
                if (*nextSeparator == L'"') {
    
                    //
                    //  look for either non-escaped endquote or nul
                    //
    
                    do {
                        
                        if ((*nextSeparator ==  L'\\') &&
                            (*(nextSeparator+1) != L'\0')) {
    
                            nextSeparator++;
                        }
                        
                        nextSeparator++;
    
                      } while ((*nextSeparator != L'\0') && (*nextSeparator != L'"'));
    
                
                } else if ( *nextSeparator == L'\\' ) {
    
                    nextSeparator++;
    
                    if ((*nextSeparator) == L'\0') {
    
                        //
                        //  the string ends in a \, this is invalid.  end it here
                        //
    
                        currentPosition = nextSeparator;
                        continue;
    
                    } else {
    
                        nextSeparator++;      // skip the escaped character
                        continue;
                    }
                }
    
                nextSeparator++;
    
            } while (( *nextSeparator != L'\0') &&
                     ( *nextSeparator != L';') &&
                     ( *nextSeparator != L','));
    
            while (*currentPosition == L' ') {
                currentPosition++;
            }
    
            if (*currentPosition == L'\0') {
                break;
            }
    
            //
            //  end of current string is separator, back up one to point to
            //  end of value
            //
    
            endOfValue = nextSeparator - 1;
    
            while ((*endOfValue == L' ') &&      // strip trailing blanks
                   (endOfValue > currentPosition) ) {
    
               if ((*(endOfValue-1) == '\\')&&
                    ( ((endOfValue-1) == currentPosition) ||
                      (*(endOfValue-2) != '\\') )) {
                  //
                  // Don't strip off blank if it is escaped.
                  //
                  break;
               }
    
                endOfValue--;
            }
    
            //
            //  coming out of the above loop, currentPosition points to beginning
            //  of AVA, nextSeparator points to separator or null, and
            //  endOfValue points to last char in value (or '"').
            //
    
            if (notypes) {
    
                PWCHAR startingPosition = currentPosition;
    
                //
                //  skip past the attribute name and equals to the value
                //
    
                while ((*currentPosition != L'=') &&
                       (currentPosition < endOfValue)) {
    
                    currentPosition++;
                }
    
                //
                //  if we didn't find an equal, just copy the whole bloomin thing
                //
    
                if (*currentPosition != L'=') {
                    currentPosition = startingPosition;
                } else {
                    currentPosition++;
                }
    
                while (*currentPosition == L' ') {
                    currentPosition++;
                }
    
                if (*currentPosition == L'"') {
                    currentPosition++;
    
                    if (*endOfValue == L'"') {
                        endOfValue--;
                    }
                }
            }
    
            //
            //  make sure we didn't get some funky string like a=""
            //
    
            if (currentPosition <= endOfValue) {
    
                endOfValue++;
    
                savedChar = *endOfValue;
                *endOfValue = L'\0';
    
                add_string_to_list( &arrayToReturn,
                                    &numberEntries,
                                    currentPosition,
                                    TRUE );
    
                *endOfValue = savedChar;
            }
    
            currentPosition = nextSeparator;
    
            if (*currentPosition != L'\0') {
                currentPosition++;
            }
        }
    
        return arrayToReturn;
    
    }__except (EXCEPTION_EXECUTE_HANDLER) {

         //
         // Free any partial array allocations.
         //
         
         ldap_value_freeW( arrayToReturn );
         return NULL;
    }
}

PCHAR * __cdecl
ldap_explode_dn (
    PCHAR dn,
    ULONG notypes
    )
//
//  This calls the unicode form of explodeDn and then converts the output from
//  Unicode to ansi before we give back the result.
//
{
    PWCHAR wName = NULL;
    PWCHAR *Names = NULL;
    PCHAR *ansiNames;
    PCHAR explodedName;
    ULONG err;

    err = ToUnicodeWithAlloc( dn, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        return NULL;
    }

    Names = ldap_explode_dnW( wName, notypes );

    ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    ansiNames = (PCHAR *) Names;

    if (ansiNames != NULL) {

        while (*Names != NULL) {
            explodedName = NULL;

            err = FromUnicodeWithAlloc( *Names, &explodedName, LDAP_VALUE_SIGNATURE, LANG_ACP );

            if (err != LDAP_SUCCESS) {

                //
                //  so close... we just couldn't convert from Unicode.  No way
                //  to return a meaningful error here.
                //

                ldap_value_free( ansiNames );
                return NULL;
            }

            ldapFree( *Names, LDAP_VALUE_SIGNATURE );
            *((PCHAR *) Names) = explodedName;
            Names++;        // on to next entry in array
        }
    }
    return ansiNames;
}

PWCHAR __cdecl
ldap_dn2ufnW (
    PWCHAR dn
    )
//
//  From RFC 1781...
//
// To take a distinguished name, and generate a name of this format with
// attribute types omitted, the following steps are followed.
//
//  1.  If the first attribute is of type CommonName, the type may be
//      omitted.
//
//  2.  If the last attribute is of type Country, the type may be
//      omitted.
//
//  3.  If the last attribute is of type Country, the last
//      Organisation attribute may have the type omitted.
//
//  4.  All attributes of type OrganisationalUnit may have the type
//      omitted, unless they are after an Organisation attribute or
//      the first attribute is of type OrganisationalUnit.
//
{
    PWCHAR currentPosition = dn;
    PWCHAR bufferToReturn;
    BOOLEAN inQuotes = FALSE;
    PWCHAR marker;
    BOOLEAN foundOrganization = FALSE;
    BOOLEAN foundCountry = FALSE;
    PWCHAR outputPosition;

    LONG charsRemaining;

    if (currentPosition == NULL) {

        return NULL;
    }

    //
    //  since we may in fact expand the string past what is currently
    //  allocated, grab a bit more than we need.  This is a rare case, and
    //  we don't overrun much.
    //

    bufferToReturn = ldap_dup_stringW(  dn,
                                        16,
                                        LDAP_BUFFER_SIGNATURE );

    if (bufferToReturn == NULL) {

        return NULL;
    }

    charsRemaining = strlenW(dn) + 16;

    while ((*currentPosition != L'=') && (*currentPosition != L'\0')) {
        currentPosition++;
    }

    //
    //  if it isn't an AVA type of name, just return whole string
    //

    if (*currentPosition != L'=') {

        return bufferToReturn;
    }

    currentPosition = dn;
    outputPosition = bufferToReturn;

    while (*currentPosition == L' ') {
        currentPosition++;
    }

    marker = currentPosition;

    //
    //  if the first attribute type is 'cn', move past it
    //

    if ((*currentPosition == L'c') &&
        (*(currentPosition+1) == L'n')) {

        currentPosition += 2;

        while (*currentPosition == L' ') {
            currentPosition++;
        }

        if (*currentPosition != L'=') {
            currentPosition = marker;
        } else {
            currentPosition++;
        }
    }

    while (*currentPosition != L'\0') {

        switch (*currentPosition) {
        case L'"':
            inQuotes = (BOOLEAN) ( inQuotes ? FALSE : TRUE );
            break;

        case L';':
        case L',':
            if (! inQuotes) {

                if (charsRemaining >= 2) {
                    *outputPosition++ = L',';
                    *outputPosition++ = L' ';
                }
                currentPosition++;
                
                charsRemaining -= 2;
                if (charsRemaining < 0) {
                    // out of space
                    ldapFree(bufferToReturn, LDAP_BUFFER_SIGNATURE);
                    return NULL;
                }

                //
                //  find beginning of next attribute
                //

                while (*currentPosition == L' ') {
                    currentPosition++;
                }

                //
                //  check for 'c='
                //

                if (foundCountry == FALSE) {

                    if ((*currentPosition == L'c') &&
                        ((*(currentPosition+1) == L' ') ||
                         (*(currentPosition+1) == L'='))) {

                        foundCountry = TRUE;
                        currentPosition++;

                        while ((*currentPosition == L' ') ||
                               (*currentPosition == L'=')) {
                            currentPosition++;
                        }
                        continue;
                    }

                    if (foundOrganization == FALSE) {

                        //
                        //  look for o=
                        //

                        if ((*currentPosition == L'o') &&
                            ((*(currentPosition+1) == L' ') ||
                             (*(currentPosition+1) == L'='))) {

                            foundOrganization = TRUE;
                            currentPosition++;

                            while ((*currentPosition == L' ') ||
                                   (*currentPosition == L'=')) {
                                currentPosition++;
                            }
                            continue;
                        }

                        //
                        //  look for ou=
                        //

                        if ((*currentPosition == L'o') &&
                            (*(currentPosition+1) == L'u') &&
                            ((*(currentPosition+2) == L' ') ||
                             (*(currentPosition+2) == L'='))) {

                            currentPosition += 2;

                            while ((*currentPosition == L' ') ||
                                   (*currentPosition == L'=')) {
                                currentPosition++;
                            }
                            continue;
                        }

                    } else {        // have we found o=

                        //
                        //  look for st=
                        //

                        if ((*currentPosition == L's') &&
                            (*(currentPosition+1) == L't') &&
                            ((*(currentPosition+2) == L' ') ||
                             (*(currentPosition+2) == L'='))) {

                            currentPosition += 2;

                            while ((*currentPosition == L' ') ||
                                   (*currentPosition == L'=')) {
                                currentPosition++;
                            }
                            continue;
                        }

                        //
                        //  look for l=
                        //

                        if ((*currentPosition == L'l') &&
                            ((*(currentPosition+1) == L' ') ||
                             (*(currentPosition+1) == L'='))) {

                            currentPosition++;

                            while ((*currentPosition == L' ') ||
                                   (*currentPosition == L'=')) {
                                currentPosition++;
                            }
                            continue;
                        }
                    }
                }
            }
            break;

        case L' ':           // don't copy spaces unless within quotes
            if (! inQuotes) {
                currentPosition++;
                continue;
            }
            break;

        default:        // do nothing but fall through, we copy the char below
            break;
        }

        if (charsRemaining >= 1) {
            *outputPosition++ = *currentPosition;        
        }
        currentPosition++;

        charsRemaining--;
        if (charsRemaining < 0) {
            // out of space
            ldapFree(bufferToReturn, LDAP_BUFFER_SIGNATURE);
            return NULL;
        }
        
    }

    *outputPosition = L'\0';
    return bufferToReturn;
}

PCHAR __cdecl
ldap_dn2ufn (
    PCHAR dn
    )
{
    ULONG err;
    PWCHAR wName = NULL;
    PWCHAR wNewUfn = NULL;
    PCHAR pUfn = NULL;

    err = ToUnicodeWithAlloc( dn, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP);

    if (err != LDAP_SUCCESS) {

        return NULL;
    }

    wNewUfn = ldap_dn2ufnW( wName );

    ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    if (wNewUfn != NULL) {

        err = FromUnicodeWithAlloc( wNewUfn, &pUfn, LDAP_BUFFER_SIGNATURE, LANG_ACP );
        ldapFree( wNewUfn, LDAP_BUFFER_SIGNATURE );
    }

    return pUfn;
}

ULONG __cdecl
ldap_ufn2dnW (
    PWCHAR ufn,
    PWCHAR *pDn
    )
//
//  From RFC 1781...
//
// Take a user friendly name and generate a valid DN format.
// The following steps are followed :
//
//  1.  If the first attribute type is not specified, it is
//      CommonName.
//
//  2.  If the last attribute type is not specified, it is Country.
//
//  3.  If there is no organisation explicitly specified, the last
//      attribute with type not specified is of type Organisation.
//
//  4.  Any remaining attribute with type unspecified must be before
//      an Organisation or OrganisationalUnit attribute, and is of
//      type OrganisationalUnit.
//
//  5.  We uppercase all attribute types.
//
//  6.  All whitespace between attribute type, '=', and attribute values
//      are eliminated.
//
{
    PWCHAR currentPosition = ufn;
    PWCHAR equalPointer;
    ULONG numberOfElements = 1;
    ULONG err;
    PWCHAR marker;
    BOOLEAN foundOrganization = FALSE;
    BOOLEAN foundCountry = FALSE;
    PWCHAR outputPosition;
    ULONG tokenLength;
    ULONG numberElementsParsed = 0;
    PWCHAR secondToLastOU = NULL;
    PWCHAR lastOU = NULL;
    BOOLEAN interveningAttributeFound = FALSE;

    if (pDn == NULL) {
        return LDAP_PARAM_ERROR;
    }

    *pDn = NULL;

    if (ufn == NULL) {
        return LDAP_SUCCESS;
    }

    //
    //  count the number of distinct elements, we don't worry about
    //  quotes or escape characters.. just calculate a worst case.
    //

    while (*currentPosition != L'\0') {

        if (*(currentPosition++) == L',') {

            numberOfElements++;
        }
    }

    //
    //  We'll expand it by adding at most the following :
    //   initial "cn="
    //   last "c="
    //   numberOfElements * "ou="
    //
    //   This gives us an upper limit on the size.
    //

    *pDn = ldap_dup_stringW( ufn,
                             5 + (numberOfElements * 3),
                             LDAP_GENERATED_DN_SIGNATURE );

    if (*pDn == NULL) {

        return LDAP_NO_MEMORY;
    }

    outputPosition = *pDn;
    currentPosition = ufn;

    while (*currentPosition != L'\0') {

        //
        //  toss in a comma separator before the next token
        //

        if (numberElementsParsed > 0) {

            *(outputPosition++) = L',';
        }

        err = ParseLdapToken(   currentPosition,
                                &marker,
                                &equalPointer,
                                &currentPosition );

        if (err != LDAP_SUCCESS) {

            ldapFree( *pDn, LDAP_GENERATED_DN_SIGNATURE );
            *pDn = NULL;
            return err;
        }

        if (*marker == L'\0') {

            //
            //  hmmm... the DN ended on a comma.  we'll allow it.
            //

            break;
        }

        if ((marker == currentPosition) ||
            (marker == equalPointer)) {

            //
            //  hmmm.... they specified ", stuff" or "= stuff" to start with
            //  and this is invalid
            //
NamingViolation:

            //
            //  if they specified what we think is an invalid DN,  we
            //  may very well be wrong.  We try our best but we've seen
            //  some really funky DNs returned by servers... so let's
            //  just return the DN as it was passed in to us.
            //

            CopyMemory( *pDn, ufn, (strlenW( ufn ) + 1 ) * sizeof(WCHAR));
            return LDAP_SUCCESS;
        }

        if (equalPointer == NULL) {

            if (numberElementsParsed == 0) {

                *(outputPosition++) = L'C';
                *(outputPosition++) = L'N';
                *(outputPosition++) = L'=';

            } else if (foundCountry == FALSE) {

                interveningAttributeFound = FALSE;

                //
                //  remember where we copied this in because we may have to
                //  go back in later and change it to a O= or C=
                //

                secondToLastOU = lastOU;
                lastOU = outputPosition;

                if (foundOrganization == FALSE) {

                    *(outputPosition++) = L'O';
                    *(outputPosition++) = L'U';
                    *(outputPosition++) = L'=';
                }
            }

            equalPointer = marker;

        } else {

            BOOLEAN isCountry = FALSE;
            BOOLEAN isOrg = FALSE;

            //
            //  an attribute type has been specified.
            //  copy the attribute name as uppercased with no embedded spaces.
            //

            if (*marker == L'C' || *marker == L'c') {
                isCountry = TRUE;
            }

            if (*marker == L'O' || *marker == L'o') {
                isOrg = TRUE;
            }

            *(outputPosition++) = ia5_toupper( *marker );

            marker++;

            while (marker < equalPointer) {

                if (*marker != L' ') {

                    isCountry = FALSE;
                    isOrg = FALSE;

                    *(outputPosition++) = ia5_toupper( *marker );
                }
                marker++;
            }

            if (isCountry) {

                foundCountry = TRUE;

            } else {

                interveningAttributeFound = TRUE;

            }
            if (isOrg) {

                foundOrganization = TRUE;
            }

            *(outputPosition++) = L'=';
            equalPointer++;             // point to next char past '='
        }

        //
        //  getting to here, equalPointer should point to the first position
        //  past the equal sign to the value that we'll copy to the output buffer
        //

        while (*equalPointer == L' ') {

            equalPointer++;
        }

        if ((*equalPointer == L'\0') || (*equalPointer == L',')) {

            goto NamingViolation;
        }

        ASSERT( currentPosition > equalPointer );

        tokenLength = (ULONG)(((PCHAR) currentPosition) - ((PCHAR) equalPointer));

        numberElementsParsed++;

        CopyMemory( outputPosition, equalPointer, tokenLength );
        outputPosition += ( tokenLength / sizeof(WCHAR) );

        //
        //  skip forward to point to next AVA
        //

        if (*currentPosition != L'\0') {

            currentPosition++;
        }
    }

    *outputPosition = L'\0';

    //
    //  if we added a couple of "OU=" at the end, let's go back and change them
    //  to "O=" and "C="
    //

    if ((foundCountry == TRUE) &&
        (foundOrganization == TRUE)) {

        //
        //  Both a O= and a C= were specified by the client, nothing to do or
        //  undo here.
        //

    } else if ( foundCountry == TRUE ) {

        //
        //  Only a C= was found.  Need to go back to last OU= we put in and
        //  change it to O=.
        //

        if (lastOU != NULL) {

            //  change it from OU= to O= by moving everything up.

            ldap_MoveMemory( (PCHAR) (lastOU+1),
                             (PCHAR) (lastOU+2),
                             (strlenW(lastOU+2) + 1) * sizeof(WCHAR));
        }

    } else if ( foundOrganization == TRUE ) {

        //
        //  Only a O= was specified.  Need to go to last one and modify it to
        //  C=.  We only do this if the very last element didn't have a
        //  attribute identifier.
        //

        if ((lastOU != NULL) && (interveningAttributeFound == FALSE)) {

            //  toss in C= by moving everything down.

            ldap_MoveMemory( (PCHAR) (lastOU+2),
                             (PCHAR) lastOU,
                             (strlenW(lastOU) + 1) * sizeof(WCHAR));
            *lastOU = L'C';
            *(lastOU+1) = L'=';
        }

    } else {

        //
        //  Neither a C= or O= was specified.  If the last token didn't have
        //  an attribute identifier, change it to C= from OU=
        //

        if (lastOU != NULL) {

            if (interveningAttributeFound == FALSE) {

                //  change it from OU= to C= by moving everything up.

                ASSERT( *lastOU == L'O' );
                *lastOU = L'C';
                ldap_MoveMemory(    (PCHAR) (lastOU+1),
                                    (PCHAR) (lastOU+2),
                                    (strlenW(lastOU+2) + 1) * sizeof(WCHAR));

                if (secondToLastOU != NULL) {

                    //
                    //  They really didn't have any types... not only do
                    //  we convert the last OU= to C= (which we just did
                    //  above) but here we change the second to last OU=
                    //  to O=
                    //

                    ASSERT( *secondToLastOU == L'O' );
                    ldap_MoveMemory( (PCHAR) (secondToLastOU+1),
                                     (PCHAR) (secondToLastOU+2),
                                     (strlenW(secondToLastOU+2) + 1) * sizeof(WCHAR));
                }
            } else {

                // there was an intervening named attribute between the
                // last unnamed one and the end, so we assume that the last
                // unnamed one is O=, since none was specified.

                ASSERT( *lastOU == L'O' );
                ldap_MoveMemory(    (PCHAR) (lastOU+1),
                                    (PCHAR) (lastOU+2),
                                    (strlenW(lastOU+2) + 1)*sizeof(WCHAR));
            }
        }
    }

    return LDAP_SUCCESS;
}

ULONG __cdecl
ldap_ufn2dn (
    PCHAR ufn,
    PCHAR *pDn
    )
{
    ULONG err;
    PWCHAR wName = NULL;
    PWCHAR wNewDn = NULL;

    if (pDn == NULL) {
        return LDAP_PARAM_ERROR;
    }

    *pDn = NULL;

    err = ToUnicodeWithAlloc( ufn, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        return err;
    }

    err = ldap_ufn2dnW( wName, &wNewDn );

    ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    if (wNewDn != NULL) {

        err = FromUnicodeWithAlloc( wNewDn, pDn, LDAP_GENERATED_DN_SIGNATURE, LANG_ACP );
        ldapFree( wNewDn, LDAP_GENERATED_DN_SIGNATURE );
    }

    return err;
}

ULONG
ParseLdapToken (
    PWCHAR CurrentPosition,
    PWCHAR *StartOfToken,
    PWCHAR *EqualSign,
    PWCHAR *EndOfToken
    )
//
//  Find end of token such as ',' or L'\0'.  Also save off position of '='
//  and of start of attribute name.
//
{
    BOOLEAN inQuotes = FALSE;
    BOOLEAN foundEquals = FALSE;

    while (*CurrentPosition == L' ') {
        CurrentPosition++;
    }

    *StartOfToken = CurrentPosition;
    *EqualSign = NULL;

    while (*CurrentPosition != L'\0') {

        if (*CurrentPosition == L'\\') {

            //
            //  allow characters to be escaped, but include the escape
            //

            if (*(CurrentPosition+1) != L'\0') {

                CurrentPosition++;
            }
        } else if (*CurrentPosition == L'"') {

            inQuotes = (BOOLEAN) ( inQuotes ? FALSE : TRUE );

        } else if (inQuotes == FALSE) {

            if (*CurrentPosition == L'=') {

                if (foundEquals == FALSE) {

                    foundEquals = TRUE;
                    *EqualSign = CurrentPosition;
                }
            }

            if (*CurrentPosition == L',') {

                break;
            }
        }
        CurrentPosition++;
    }

    *EndOfToken = CurrentPosition;
    return LDAP_SUCCESS;
}

//
//  can't use toupper because that would pull in msvcrt.dll
//

WCHAR
ia5_toupper (
    WCHAR ch
    )
{
    if (ch >= L'a' && ch <= L'z') {

        ch -= L'a';
        ch += L'A';
    }
    return ch;
}

// results.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\paged.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    paged.cxx  paged results support routines for the LDAP api

Abstract:

   This module implements routines that handle paging through results

Author:

    Andy Herron (andyhe)        02-Apr-1997

Revision History:

    Anoop Anantha (anoopa)      25-Dec-1999
            
            Added support for Virtual List View (VLV)

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

// prevent warnings about the unknown "prefast" #pragma
#pragma warning(disable:4068)

ULONG LdapGetNextPage(
        PLDAP_CONN      connection,
        PLDAP_REQUEST   request,
        ULONG           PageSize,
        ULONG          *MessageNumber,
        BOOLEAN         Synchronous
        );

ULONG
LdapCreatePageControl (
        PLDAP_CONN      connection,
        ULONG           PageSize,
        struct berval  *Cookie,
        UCHAR           IsCritical,
        PLDAPControlW  *Control,
        ULONG           CodePage
        );

ULONG
LdapParsePageControl (
        PLDAP_CONN      connection,
        PLDAPControlW  *ServerControls,
        ULONG          *TotalCount,
        struct berval  **Cookie,
        ULONG           CodePage
        );

PLDAPSearch
LdapSearchInitPage (
        PLDAP_CONN      connection,
        PWCHAR          DistinguishedName,
        ULONG           ScopeOfSearch,
        PWCHAR          SearchFilter,
        PWCHAR          AttributeList[],
        ULONG           AttributesOnly,
        ULONG           CodePage,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        ULONG           PageTimeLimit,
        ULONG           TotalSizeLimit,
        PLDAPSortKeyW  *SortKeys
    )
//
//  We setup a request buffer to hold the info for this search since it will
//  span multiple requests.
//
{
    ULONG err;
    PLDAP_REQUEST request = NULL;
    UCHAR chaseReferrals;
    PLDAPControlW *controls;
    PLDAPControlW currentControl = NULL;
    ULONG extraSlots;
    BOOLEAN Unicode = (( CodePage == LANG_UNICODE ) ? TRUE : FALSE );

    err = LdapConnect( connection, NULL, FALSE );

    if (err != 0) {

       SetConnectionError( connection, err, NULL );

       return NULL;
    }

    SetConnectionError( connection, LDAP_SUCCESS, NULL );

    request = LdapCreateRequest( connection, LDAP_SEARCH_CMD );

    if (request == NULL) {

        IF_DEBUG(OUTMEMORY) {
            LdapPrint1( "ldap_search connection 0x%x couldn't allocate request.\n", connection);
        }
        err = LDAP_NO_MEMORY;
        goto exitSetupPagedResults;
    }

    request->Synchronous = FALSE;
    request->AllocatedParms = FALSE;
    request->search.Unicode = Unicode;
    request->search.ScopeOfSearch = ScopeOfSearch;
    request->search.AttributesOnly = AttributesOnly;
    request->TimeLimit = PageTimeLimit;
    request->SizeLimit = TotalSizeLimit;
    request->ReceivedData = FALSE;
    request->PendingPagedMessageId = 0;

    //
    //  we have to save off here whether or not we chase referrals because
    //  LdapCheckControls will not save off the controls if we don't chase
    //  referrals.
    //

    chaseReferrals = request->ChaseReferrals;
    request->ChaseReferrals = TRUE;

    if ((SortKeys != NULL) && (*SortKeys != NULL)) {

        extraSlots = 2;

    } else {

        extraSlots = 1;
    }

    err = LdapCheckControls( request,
                             ServerControls,
                             ClientControls,
                             Unicode,
                             extraSlots );  // extra for sorting, extra for paged

    if (err != LDAP_SUCCESS) {

        IF_DEBUG(CONTROLS) {
            LdapPrint2( "ldap_search connection 0x%x trouble with SControl, err 0x%x.\n",
                        connection, err );
        }
        goto exitSetupPagedResults;
    }

    request->ChaseReferrals = chaseReferrals;
    request->PagedSearchBlock = TRUE;

    err = LdapSaveSearchParameters( request,
                                    DistinguishedName,
                                    SearchFilter,
                                    AttributeList,
                                    Unicode
                                    );
    if (err != LDAP_SUCCESS) {

        IF_DEBUG(CONTROLS) {
            LdapPrint2( "ldap_search connection 0x%x trouble saving parms, err 0x%x.\n",
                        connection, err );
        }
        goto exitSetupPagedResults;
    }

    //
    //  add in sorting control to the list of server controls
    //

    if ((SortKeys != NULL) && (*SortKeys != NULL)) {

        controls = request->ServerControls;

        while (*controls != NULL) {

            currentControl = *controls;

            if (currentControl->ldctl_oid == NULL) {
                break;
            }
            currentControl = NULL;
            controls++;
        }

        if (currentControl == NULL) {

            err = LDAP_NO_MEMORY;
            IF_DEBUG(CONTROLS) {
                LdapPrint2( "ldap_search connection 0x%x trouble saving parms, err 0x%x.\n",
                            connection, err );
            }
            goto exitSetupPagedResults;
        }

        err = LdapEncodeSortControl( connection,
                                     SortKeys,
                                     currentControl,
                                     TRUE,               // criticality
                                     CodePage
                                     );
    }

exitSetupPagedResults:

    if (err != LDAP_SUCCESS) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "ldap_init_page connection 0x%x had error of 0x%x.\n",
                        connection, err );
        }

        if (request != NULL) {

            CloseLdapRequest( request );
            DereferenceLdapRequest( request );
        }
        request = NULL;
    }

    SetConnectionError( connection, err, NULL );

    //
    // In this case, the refcount of the search handle (which is actually
    // a request) is 2.
    //

    return (PLDAPSearch) request;
}

WINLDAPAPI PLDAPSearch LDAPAPI ldap_search_init_pageW(
        PLDAP           ExternalHandle,
        PWCHAR          DistinguishedName,
        ULONG           ScopeOfSearch,
        PWCHAR          SearchFilter,
        PWCHAR          AttributeList[],
        ULONG           AttributesOnly,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        ULONG           PageTimeLimit,
        ULONG           TotalSizeLimit,
        PLDAPSortKeyW  *SortKeys
    )
{
    PLDAP_CONN connection = NULL;
    PLDAPSearch search;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {

        return NULL;
    }

    search = LdapSearchInitPage(connection,
                                DistinguishedName,
                                ScopeOfSearch,
                                SearchFilter,
                                AttributeList,
                                AttributesOnly,
                                LANG_UNICODE,
                                ServerControls,
                                ClientControls,
                                PageTimeLimit,
                                TotalSizeLimit,
                                SortKeys
                                );

    DereferenceLdapConnection( connection );

    return search;
}

WINLDAPAPI PLDAPSearch LDAPAPI ldap_search_init_pageA(
        PLDAP           ExternalHandle,
        PCHAR           DistinguishedName,
        ULONG           ScopeOfSearch,
        PCHAR           SearchFilter,
        PCHAR           AttributeList[],
        ULONG           AttributesOnly,
        PLDAPControlA   *ServerControls,
        PLDAPControlA   *ClientControls,
        ULONG           PageTimeLimit,
        ULONG           TotalSizeLimit,
        PLDAPSortKeyA  *SortKeys
    )
{
    ULONG err;
    PWCHAR wName = NULL;
    PWCHAR wFilter = NULL;
    PLDAP_CONN connection = NULL;
    PLDAPSearch search = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return NULL;
    }

    err = ToUnicodeWithAlloc( DistinguishedName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, err, NULL );
        goto error;
    }

    err = ToUnicodeWithAlloc( SearchFilter, -1, &wFilter, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, err, NULL );
        goto error;
    }

    search = LdapSearchInitPage(connection,
                                wName,
                                ScopeOfSearch,
                                wFilter,
                                (PWCHAR *) AttributeList,
                                AttributesOnly,
                                LANG_ACP,
                                (PLDAPControlW *) ServerControls,
                                (PLDAPControlW *) ClientControls,
                                PageTimeLimit,
                                TotalSizeLimit,
                                (PLDAPSortKeyW *) SortKeys
                                );

error:
    if (wName)
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    if (wFilter)
        ldapFree( wFilter, LDAP_UNICODE_SIGNATURE );

    DereferenceLdapConnection( connection );

    return search;
}


ULONG LdapGetNextPage(
        PLDAP_CONN      connection,
        PLDAP_REQUEST   request,
        ULONG           PageSize,
        ULONG          *MessageNumber,
        BOOLEAN         Synchronous
    )
{
    ULONG err;
    PLDAPControlW *controls;
    PLDAPControlW replacedControl = NULL;
    PLDAPControlW allocatedControl = NULL;
    ULONG msgId = (ULONG) -1;

    PLDAP_CONN tempConn = connection;

    if (MessageNumber != NULL) {

        *MessageNumber = msgId;
    }

    err = LdapConnect( connection, NULL, FALSE );

    if (err != 0) {

       return err;
    }

    if (request->PagedSearchBlock != TRUE) {

        return LDAP_PARAM_ERROR;
    }

    //
    //  if we've received all of the data and have an empty cookie, nothing
    //  more to do.
    //

    if ((request->ReceivedData == TRUE) &&
        (request->PagedSearchServerCookie == NULL)) {

        return LDAP_NO_RESULTS_RETURNED;
    }

    if (request->PendingPagedMessageId != 0) {

        //
        //  if we've already sent the cookie, don't do it again.
        //

        return LDAP_LOCAL_ERROR;
    }

    controls = request->ServerControls;

    while (*controls != NULL) {

        replacedControl = *controls;

        if (replacedControl->ldctl_oid == NULL) {

            break;
        }

        replacedControl = NULL;
        controls++;
    }

    if (replacedControl == NULL) {

        err = LDAP_LOCAL_ERROR;
        IF_DEBUG(CONTROLS) {
            LdapPrint2( "ldap_get_next_page connection 0x%x trouble setting controls, err 0x%x.\n",
                        connection, err );
        }
        goto exitGetNextPage;
    }

    err = LdapCreatePageControl(    connection,
                                    PageSize,
                                    request->PagedSearchServerCookie,
                                    0x01,       // IsCritical
                                    &allocatedControl,
                                    request->search.Unicode ?
                                            LANG_UNICODE :
                                            LANG_ACP );

    *controls = allocatedControl;

    request->ReceivedData = TRUE;

    //
    // for now, if the app passed in clientControls, then we hope that they
    // disabled referrals
    //

    PLDAPControlW   *ClientControls;

    ClientControls = request->ClientControls;

    LDAPControlW referralControl;
    PLDAPControlW controlArray[2];
    ULONG referralControlValue;

    if (ClientControls == NULL) {

        //
        //  we're not setup to handle subordinate referrals on paged results
        //  so just handle external referrals if client so desires
        //

        referralControlValue = ( connection->publicLdapStruct.ld_options &
                                LDAP_CHASE_EXTERNAL_REFERRALS );

        controlArray[0] = &referralControl;
        controlArray[1] = NULL;

        referralControl.ldctl_iscritical = TRUE;
        referralControl.ldctl_value.bv_len = sizeof(referralControlValue);
        referralControl.ldctl_value.bv_val = (PCHAR) &referralControlValue;

        if (request->search.Unicode) {

            referralControl.ldctl_oid = LDAP_CONTROL_REFERRALS_W;

        } else {
#pragma prefast(suppress:276, "we always condition our access to ldctl_oid based on the Unicode flag setting (Prefast bug 545)")
            referralControl.ldctl_oid = (PWCHAR) LDAP_CONTROL_REFERRALS;
        }

        ClientControls = &controlArray[0];
    }

    //
    // Before we fire off the search, we have to make sure that we are
    // sending the search to the correct server. In the case of us following
    // external referrals, we have to walk a chain of connections until we
    // find the last server.
    //

    if (request->SecondaryConnection) {

        IF_DEBUG(CONTROLS) {
            LdapPrint0("Sending paged search to external referred server\n");
        }
        tempConn = request->SecondaryConnection;
    }

    err = LdapSearch(   tempConn,
                        request->OriginalDN,
                        request->search.ScopeOfSearch,
                        request->search.SearchFilter,
                        request->search.AttributeList,
                        request->search.AttributesOnly,
                        request->search.Unicode,
                        Synchronous,
                        request->ServerControls,
                        ClientControls,
                        request->TimeLimit,
                        request->SizeLimit,
                        &msgId
                        );

    if (err == LDAP_SUCCESS) {

        request->PendingPagedMessageId = msgId;

        //
        // Find the request associated with this msgid and hookup
        // the search block. This will be useful later during external
        // referral chasing.
        //

        PLDAP_REQUEST LatestRequest = FindLdapRequest( msgId );

        if (LatestRequest) {

            //
            // Reference the search block so that it doesn't go away.
            //

            request = ReferenceLdapRequest( request );
            ASSERT( request );
            LatestRequest->PageRequest = request;
            DereferenceLdapRequest( LatestRequest );
        }
    }

exitGetNextPage:

    if (replacedControl != NULL) {

        if (allocatedControl != NULL) {

            ldap_control_freeW( allocatedControl );
        }

        *controls = replacedControl;
    }

    if (MessageNumber != NULL) {

        *MessageNumber = msgId;
    }

    return err;
}


WINLDAPAPI ULONG LDAPAPI ldap_get_next_page(
        PLDAP           ExternalHandle,
        PLDAPSearch     SearchBlock,
        ULONG           PageSize,
        ULONG          *MessageNumber
    )
{
    ULONG err;
    PLDAP_CONN connection = NULL;
    PLDAP_REQUEST request = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    request = ReferenceLdapRequest( (PLDAP_REQUEST) SearchBlock );

    if (request == NULL) {
        DereferenceLdapConnection( connection );
        return LDAP_PARAM_ERROR;
    }
    
    err = LdapGetNextPage(  connection,
                            request,
                            PageSize,
                            MessageNumber,
                            FALSE );

    DereferenceLdapRequest( request );
    DereferenceLdapConnection( connection );

    return err;
}

WINLDAPAPI ULONG LDAPAPI ldap_get_next_page_s(
        PLDAP           ExternalHandle,
        PLDAPSearch     SearchHandle,
        struct l_timeval  *timeout,
        ULONG           PageSize,
        ULONG          *TotalCount,
        LDAPMessage     **Results
    )
{
    ULONG msgId;
    ULONG err = LDAP_SUCCESS;
    ULONG RetCode = LDAP_SUCCESS;
    PLDAP_CONN connection = NULL;
    PLDAP_REQUEST request = NULL;
    ULONG timeLimit;

    connection = GetConnectionPointer(ExternalHandle);

    if ((connection == NULL) || (Results == NULL) || (SearchHandle == NULL)) {

        err = LDAP_PARAM_ERROR;
        goto error;
    }

    *Results = NULL;

    if (TotalCount != NULL) {

        *TotalCount = 0;
    }

    if (timeout != NULL) {

        timeLimit = (ULONG) timeout->tv_sec + ( timeout->tv_usec / ( 1000 * 1000 ));

    } else {

        timeLimit = connection->publicLdapStruct.ld_timelimit;
    }

    request = ReferenceLdapRequest( (PLDAP_REQUEST) SearchHandle );

    if (request == NULL) {
        DereferenceLdapConnection( connection );
        return LDAP_PARAM_ERROR;
    }
    
    err = LdapGetNextPage(  connection,
                            request,
                            PageSize,
                            &msgId,
                            TRUE );

    
    //
    //  if we error'd out before we sent the request, return the error here.
    //

    if (msgId != (ULONG) -1) {

        PLDAPMessage lastMessage = NULL;

        //
        //  otherwise we simply need to wait for the response to come in.
        //

        err = ldap_result_with_error(  connection,
                                       msgId,
                                       LDAP_MSG_ALL,
                                       timeout,
                                       Results,
                                       &lastMessage
                                       );

        if (*Results == NULL) {

            LdapAbandon( connection, msgId, TRUE );

        } else {

            ASSERT( lastMessage != NULL );

            RetCode = LdapGetPagedCount(    connection,
                                            request,
                                            TotalCount,
                                            lastMessage );
        }
    }

error:

    if (request)
        DereferenceLdapRequest( request );

    if (connection)
        DereferenceLdapConnection( connection );

    if (RetCode != LDAP_SUCCESS) {

       return RetCode;

    }

    return err;

}


WINLDAPAPI
ULONG LDAPAPI ldap_get_paged_count(
        PLDAP           ExternalHandle,
        PLDAPSearch     SearchBlock,
        ULONG          *TotalCount,
        PLDAPMessage    Results
    )
{
    ULONG err;
    PLDAP_CONN connection = NULL;
    PLDAP_REQUEST request = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {

        return LDAP_PARAM_ERROR;
    }

    request = (PLDAP_REQUEST) SearchBlock;

    request = ReferenceLdapRequest( request );

    if (request == NULL) {
        
        return LDAP_PARAM_ERROR;
    }
    
    err = LdapGetPagedCount( connection,
                             request,
                             TotalCount,
                             Results );

    DereferenceLdapRequest( request );
    DereferenceLdapConnection( connection );

    return err;
}



ULONG LDAPAPI LdapGetPagedCount(
        PLDAP_CONN      connection,
        PLDAP_REQUEST   request,
        ULONG          *TotalCount,
        PLDAPMessage    Results
    )
{
    PLDAPControlW *serverControls = NULL;
    ULONG err = LDAP_SUCCESS;
    ULONG RetCode = LDAP_SUCCESS;

    if (Results == NULL) {

        return LDAP_PARAM_ERROR;
    }

    if (request->PagedSearchBlock != TRUE) {

        return LDAP_PARAM_ERROR;
    }

    if ( request->SecondaryConnection ) {

        IF_DEBUG(CONTROLS) {
            LdapPrint2("Getting data for conn 0x%x instead of 0x%x\n",request->SecondaryConnection, connection );
        }
        connection = request->SecondaryConnection;
    }

    if (TotalCount != NULL) {

        *TotalCount = 0;
    }

    err = LdapParseResult(  connection,
                            Results,
                            &RetCode,  // return code
                            NULL,     // matchedDNs
                            NULL,     // error message
                            NULL,     // referrals
                            &serverControls,
                            FALSE,    // don't free messages
                            request->search.Unicode ?
                                        LANG_UNICODE :
                                        LANG_ACP );

    //
    //  grab the server cookie from the response and store in the paged request
    //  buffer.
    //

    if (serverControls != NULL) {

        ULONG  totalCount;

        ber_bvfree( request->PagedSearchServerCookie );
        request->PagedSearchServerCookie = NULL;

        err = LdapParsePageControl( connection,
                                    serverControls,
                                    &totalCount,
                                    &request->PagedSearchServerCookie,
                                    request->search.Unicode ?
                                            LANG_UNICODE :
                                            LANG_ACP );

        if (request->PagedSearchServerCookie != NULL &&
            request->PagedSearchServerCookie->bv_len == 0) {

            ber_bvfree( request->PagedSearchServerCookie );
            request->PagedSearchServerCookie = NULL;
        }

        if (err == LDAP_SUCCESS) {

            if (TotalCount != NULL) {

                *TotalCount = totalCount;
            }

            request->PendingPagedMessageId = 0;
        }

        ldap_controls_freeW( serverControls );

    } else if (request->PagedSearchServerCookie != NULL) {

        //
        //  check to see if the server sent a searchResultDone.  If it did,
        //  then we simply free the cookie.
        //

        LDAPMessage *checkResult = Results;

        while ((checkResult != NULL) &&
               ((checkResult->lm_msgtype == LDAP_RES_REFERRAL) ||
                (checkResult->lm_msgtype == LDAP_RES_SEARCH_ENTRY))) {

            checkResult = checkResult->lm_chain;
        }

        if (checkResult != NULL) {

            request->PendingPagedMessageId = 0;

            ber_bvfree( request->PagedSearchServerCookie );
            request->PagedSearchServerCookie = NULL;
        }
    }

    if (RetCode != LDAP_SUCCESS) {

       //
       // If the server returned an error code, let the user know.
       //

       return RetCode;
    }

    return err;
}

WINLDAPAPI ULONG LDAPAPI ldap_search_abandon_page(
        PLDAP           ExternalHandle,
        PLDAPSearch     SearchBlock
    )
{
    ULONG err = LDAP_SUCCESS;
    PLDAP_CONN connection = NULL;
    PLDAP_CONN refConnection = NULL;
    PLDAP_REQUEST request = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if ((connection == NULL) || (SearchBlock == NULL)) {

        err = LDAP_PARAM_ERROR;
        goto error;
    }

    refConnection = connection;     // For dereferencing later

    request = (PLDAP_REQUEST) SearchBlock;

    request = ReferenceLdapRequest( request );

    if (request == NULL) {
        err = LDAP_PARAM_ERROR;
        goto error;
    }

    if (request->PagedSearchBlock != TRUE) {

        err = LDAP_PARAM_ERROR;
        goto error;
    }

    if (request->SecondaryConnection) {

        IF_DEBUG(CONTROLS) {
            LdapPrint2("Getting data for conn 0x%x instead of 0x%x\n",request->SecondaryConnection, connection );
        }
        connection = request->SecondaryConnection;
    }

    //
    //  if we have a cookie from the server, then send a search request closing
    //  it out.
    //

    if ((request->ReceivedData == TRUE) &&
        (request->PagedSearchServerCookie != NULL)) {

        PLDAPMessage results = NULL;

        err = ldap_get_next_page_s( connection->ExternalInfo,
                                    SearchBlock,
                                    NULL,       // timeout
                                    0,
                                    NULL,       // total count
                                    &results );

        ldap_msgfree( results );
    }

    if (request->PendingPagedMessageId != 0) {

        LdapAbandon( connection, request->PendingPagedMessageId, TRUE );
        request->PendingPagedMessageId = 0;
    }

    if (request->SecondaryConnection != NULL) {

        //
        // We have to decrement refcnt
        //

        ACQUIRE_LOCK( &request->SecondaryConnection->StateLock);
        request->SecondaryConnection->HandlesGivenAsReferrals--;
        RELEASE_LOCK( &request->SecondaryConnection->StateLock);

        IF_DEBUG(CONTROLS) {
            LdapPrint1("Penultimate refcnt for sec conn is %d\n", request->SecondaryConnection->ReferenceCount);
        }
    }

    CloseLdapRequest( request );

    DereferenceLdapRequest( request );

error:
    if (request)
        DereferenceLdapRequest( request );
    
    if (refConnection)
        DereferenceLdapConnection( refConnection );
    
    return err;
}


WINLDAPAPI
ULONG LDAPAPI
ldap_create_page_controlW (
        PLDAP           ExternalHandle,
        ULONG           PageSize,
        struct berval  *Cookie,
        UCHAR           IsCritical,
        PLDAPControlW  *Control
        )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {

        return LDAP_PARAM_ERROR;
    }

    err = LdapCreatePageControl(    connection,
                                    PageSize,
                                    Cookie,
                                    IsCritical,
                                    Control,
                                    LANG_UNICODE );

    DereferenceLdapConnection( connection );

    return err;
}

WINLDAPAPI
ULONG LDAPAPI
ldap_create_page_controlA (
        PLDAP           ExternalHandle,
        ULONG           PageSize,
        struct berval  *Cookie,
        UCHAR           IsCritical,
        PLDAPControlA  *Control
        )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        if (Control) {

            *Control = NULL;
        }

        return LDAP_PARAM_ERROR;
    }

    err = LdapCreatePageControl(    connection,
                                    PageSize,
                                    Cookie,
                                    IsCritical,
                                    (PLDAPControlW *) Control,
                                    LANG_ACP );

    DereferenceLdapConnection( connection );

    return err;
}

ULONG
LdapCreatePageControl (
        PLDAP_CONN      connection,
        ULONG           PageSize,
        struct berval  *Cookie,
        UCHAR           IsCritical,
        PLDAPControlW  *Control,
        ULONG           CodePage
        )
{

    ULONG err;
    BOOLEAN criticality = ( (IsCritical > 0) ? TRUE : FALSE );
    PLDAPControlW  control = NULL;
    CLdapBer *lber = NULL;

    if (Control == NULL) {

        return LDAP_PARAM_ERROR;
    }

    control = (PLDAPControlW) ldapMalloc( sizeof( LDAPControlW ), LDAP_CONTROL_SIGNATURE );

    if (control == NULL) {

        *Control = NULL;
        return LDAP_NO_MEMORY;
    }

    control->ldctl_iscritical = criticality;

    if (CodePage == LANG_UNICODE) {

        control->ldctl_oid = ldap_dup_stringW( LDAP_PAGED_RESULT_OID_STRING_W,
                                               0,
                                               LDAP_VALUE_SIGNATURE );
    } else {

        control->ldctl_oid = (PWCHAR) ldap_dup_string(  LDAP_PAGED_RESULT_OID_STRING,
                                                        0,
                                                        LDAP_VALUE_SIGNATURE );
    }

    if (control->ldctl_oid == NULL) {

        err = LDAP_NO_MEMORY;
        goto exitEncodePagedControl;
    }

    lber = new CLdapBer( connection->publicLdapStruct.ld_version );

    if (lber == NULL) {

        err = LDAP_NO_MEMORY;
        goto exitEncodePagedControl;
    }

    err = lber->HrStartWriteSequence();

    if (err != LDAP_SUCCESS) {

        goto exitEncodePagedControl;
    }

    err = lber->HrAddValue( (LONG) PageSize );

    if ((Cookie != NULL) &&
        (Cookie->bv_len > 0) &&
        (Cookie->bv_val != NULL)) {

        err = lber->HrAddBinaryValue((BYTE *) Cookie->bv_val,
                                              Cookie->bv_len
                                              );
    } else {

        err = lber->HrAddValue( (const CHAR *) NULL );
    }

    if (err != LDAP_SUCCESS) {

        goto exitEncodePagedControl;
    }

    err = lber->HrEndWriteSequence();
    ASSERT( err == NOERROR );

    control->ldctl_value.bv_len = lber->CbData();

    if (control->ldctl_value.bv_len == 0) {

        err = LDAP_LOCAL_ERROR;
        goto exitEncodePagedControl;
    }

    control->ldctl_value.bv_val = (PCHAR) ldapMalloc(
                                                control->ldctl_value.bv_len,
                                                LDAP_CONTROL_SIGNATURE );

    if (control->ldctl_value.bv_val == NULL) {

        err = LDAP_NO_MEMORY;
        goto exitEncodePagedControl;
    }

    CopyMemory( control->ldctl_value.bv_val,
                lber->PbData(),
                control->ldctl_value.bv_len );

    err = LDAP_SUCCESS;

exitEncodePagedControl:

    if (err != LDAP_SUCCESS) {

        ldap_control_freeW( control );
        control = NULL;
    }

    if (lber != NULL) {
        delete lber;
    }

    *Control = control;
    return err;
}

WINLDAPAPI
ULONG LDAPAPI
ldap_parse_page_controlW (
        PLDAP           ExternalHandle,
        PLDAPControlW  *ServerControls,
        ULONG          *TotalCount,
        struct berval  **Cookie
        )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {

        return LDAP_PARAM_ERROR;
    }

    err = LdapParsePageControl(     connection,
                                    ServerControls,
                                    TotalCount,
                                    Cookie,
                                    LANG_UNICODE );

    DereferenceLdapConnection( connection );

    return err;
}

WINLDAPAPI
ULONG LDAPAPI
ldap_parse_page_controlA (
        PLDAP           ExternalHandle,
        PLDAPControlA  *ServerControls,
        ULONG          *TotalCount,
        struct berval  **Cookie
        )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {

        return LDAP_PARAM_ERROR;
    }

    err = LdapParsePageControl(     connection,
                                    (PLDAPControlW *) ServerControls,
                                    TotalCount,
                                    Cookie,
                                    LANG_ACP );

    DereferenceLdapConnection( connection );

    return err;
}

ULONG
LdapParsePageControl (
        PLDAP_CONN      connection,
        PLDAPControlW  *ServerControls,
        ULONG          *TotalCount,
        struct berval  **Cookie,
        ULONG           CodePage
        )
{
    ULONG err = LDAP_CONTROL_NOT_FOUND;
    CLdapBer *lber = NULL;

    //
    //  First thing is to zero out the parms passed in.
    //

    if (TotalCount != NULL) {

        *TotalCount = 0;
    }

    if (Cookie != NULL) {

        *Cookie = NULL;
    }

    if (ServerControls != NULL) {

        PLDAPControlW *controls = ServerControls;
        PLDAPControlW currentControl;
        ULONG bytesTaken;
        LONG totalCount;

        while (*controls != NULL) {

            currentControl = *controls;

            //
            //  check to see if the current control is the SIMPLE PAGING control
            //

            if ( ((CodePage == LANG_UNICODE) &&
                  ( ldapWStringsIdentical( currentControl->ldctl_oid,
                                           -1,
                                           LDAP_PAGED_RESULT_OID_STRING_W,
                                           -1 ) == TRUE )) ||
                 ((CodePage == LANG_ACP) &&
                  ( CompareStringA( LDAP_DEFAULT_LOCALE,
                                    NORM_IGNORECASE,
                                    (PCHAR) currentControl->ldctl_oid,
                                    -1,
                                    LDAP_PAGED_RESULT_OID_STRING,
                          